<!DOCTYPE html><html lang="en" ><head ><title >Retrieve image information without loading entire image</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='Read width/height/depth information directly from image file (no LoadImage required), language=bmx, category=Graphics'><meta name='author' content='BlitzSupport'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=1>Graphics</a>/Retrieve image information without loading entire image</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="2477.bmx">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >Retrieve image information without loading entire image by BlitzSupport</td><td align="right">2009 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> This code retrieves width, height, number of colours and some other basic (arbitrarily decided!) information directly from image files, ie. you don't have to load the full images into Blitz first.<br><br><b>To use:</b><br><br>Call GetImageInfo with your image filename, <i>test the result in case it's Null</i> (important!), and access the <i>width</i>, <i>height</i>, <i>colors</i> and <i>info</i> fields from the ImageInfo result, eg.<br><br><pre class=code>
image:ImageInfo = GetImageInfo ("test.jpg")

If image &lt;&gt; Null
	Print image.width
	Print image.height
	Print image.colors
	Print image.info
Else
	Print "Couldn't get image information!"
EndIf
</pre><br><br>The currently supported formats are the most popular ones for Blitz usage, ie. BMP, JPEG, TGA and PNG (plus Gif). These all seem to work very well now, having been tested on around 11,500 files. In fact, the code seems to return 100% correct results as far as I can tell; if you find any results that state information couldn't be found for one of the supported images, check whether or not it really is the type of image specified by the file extension -- the chances are it isn't!<br><br>NB. You can copy/paste/call the individual formats' functions directly, if you prefer, rather than GetImageInfo (), eg. GetJPEGInfo (). Just be sure to include the ImageInfo type at the top of the code.<br><br><i>To do:<br><br>More consistent colour information. Currently returns mixed results between formats, eg. an indexed palette-based image might have only 256 colours, each of which can be (eg.) a 24-bit value, so I'm returning 24-bits. I think I'll return a max colours-per-pixel and number of palette entries where applicable.<br></i><br><br>If you add any other image formats (<i>following the same conventions as the code below</i>), please drop me an email and I'll update this code. (Please only email me if your code can be declared public domain.) </td></tr><tr ><td class="cell"><pre class="code">Type ImageInfo
	Field width:Int
	Field height:Int
	Field colors:Int
	Field info:String
End Type

Function GetBMPInfo:ImageInfo (f:String)

	Local image:ImageInfo = New ImageInfo

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	Local bmp:TStream = LittleEndianStream (ReadFile (f))

	If bmp
		
		Try
		
			If ReadByte (bmp) = $42 And ReadByte (bmp) = $4D
	
				For Local loop:Int = 1 To 12
					ReadByte bmp
				Next
				
				Local width:Int
				Local height:Int
				
				If ReadInt (bmp) = 40
					width = ReadInt (bmp)
					height = ReadInt (bmp)
				EndIf
	
				' Not needed...
				
				ReadByte bmp
				ReadByte bmp
				
				Local depth:Int = ReadShort (bmp)
				
				Local compression:Int = ReadInt (bmp)
				
				Local version:String
				
				Select compression
					Case 0
						version = "No compression"
					Case 1
						version = "RLE-8 compression"
					Case 2
						version = "RLE-4 compression"
					Default
						version = "Unknown compression"
				End Select

				image.width	= width
				image.height	= height
				image.colors	= 2 ^ depth
				image.info	= version
			
			Else
				image = Null
			EndIf
		
			Catch ReadFail:Object
			DebugLog "Read error in " + f
			image = Null

		End Try
		
		CloseFile bmp

	Else
		image = Null
	EndIf
		
	Return image

End Function

Function GetGIFInfo:ImageInfo (f:String)

	Local image:ImageInfo = New ImageInfo
	
	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	' Read the file...
	
	Local gif:TStream = LittleEndianStream (ReadFile (f))

	If gif
	
		Try
		
			' First 3 bytes must be "GIF"...
			
			Local g:String
			
			Local loop:Int ' For byte-seek loops...
			
			For loop = 0 To 2
				g = g + Chr (ReadByte (gif))
			Next
	
			If g = "GIF"
	
				Print "Got GIF???"
				
				' Next 3 bytes contain version (87a or 89a)...
				
				Local version:String = "GIF version "
				
				For loop = 3 To 5
					version = version + Chr (ReadByte (gif))
				Next
		
				' Dimensions...
				
				Local width:Int = ReadShort (gif)
				Local height:Int = ReadShort (gif)
		
				' Depth is encoded in first 3 bits of this byte!
				
				Local packed:Int = ReadByte (gif)
				Local depth:Int = (packed &amp; 1) + (packed &amp; 1 Shl 1) + (packed &amp; 1 Shl 2) + 1
				Local colors:Int = 2 ^ depth
		
				image.width	= width
				image.height	= height
				image.colors	= colors
				image.info	= version:String

			Else
				image = Null
			EndIf

			Catch ReadFail:Object
			DebugLog "Read error in " + f
			image = Null
			
		End Try
		
		CloseFile gif
	
	Else
		image = Null
	EndIf
	
	Return image

End Function

Function GetJPEGInfo:ImageInfo (f:String)

	Global remote:Int = False ' Used for online images
	
	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
		remote = True
	EndIf

	Local image:ImageInfo = New ImageInfo

	Local jpeg:TStream = BigEndianStream (ReadFile (f))

	If jpeg

		Try

			' Start of image (SOI) marker ($FFD8) -- MUST BE PRESENT!
			
			If ReadByte (jpeg) = $FF And ReadByte (jpeg) = $D8
		
				' ... followed by JFIF 'APP0' marker ($FFE0). In theory must be present, but reality says otherwise...
		
				ReadByte jpeg	' Should be $FF but not always true...
				ReadByte jpeg	' Should be $E0 but not always true...
		
				' Start of first block...
				
				Local block_length:Int = ReadShort (jpeg) - 2 ' Less these two bytes!
		
				' Check for JFIF identification string (generally treated as optional)...
		
				Local jfif:Int = 0
				
				' Have to check each byte separately as BlitzMax's 'early-out' feature may mean the
				' wrong number of bytes are read if one doesn't match, eg. If ReadByte (x) And ReadByte (y)...
				
				If ReadByte (jpeg)	= 74 Then jfif = jfif + 1	' ASCII code for "J"
				If ReadByte (jpeg)	= 70 Then jfif = jfif + 1	' ASCII code for "F"
				If ReadByte (jpeg)	= 73 Then jfif = jfif + 1	' ASCII code for "I"
				If ReadByte (jpeg)	= 70 Then jfif = jfif + 1	' ASCII code for "F"
				If ReadByte (jpeg)	= 0 Then jfif = jfif + 1		' 0
				
				If jfif = 5 Then jfif = True Else jfif = False
				
				' Read next two bytes. If the file has a JFIF marker, this is the version string. If
				' not, it's probably random bollocks...
				
				Local major:String = String (ReadByte (jpeg))			' Major revision number
				Local minor:String = RSet (String (ReadByte (jpeg)), 2)	' Minor revision (padded with leading space)
				
				Local version:String
				
				If jfif
		
					' JFIF-compliant! Yay!
					
					minor = Replace (minor, " ", "0")				' Replace space with 0!
					
					' The above changes version from (eg.) "1.2" to "1.02",
					' as in common rendering of "JFIF, version 1.02"...
					
					version = "JFIF version " + major + "." + minor
				
				Else
				
					' Missing either APP0 marker or "JFIF" string. Boo!
					
					version = "Not a 100% JFIF-compliant JPEG file"
					
				EndIf
		
				image.info = version
				
				Local loop:Int ' For byte seek loops...
					
				' Skip block length, minus the previous 7 reads since start of block...
				
				If remote
					
					' Online image, read byte-by-byte...
					
					For loop = 1 To block_length - 7
						ReadByte jpeg
					Next
				Else
					' Local image, just stream...
					SeekStream jpeg, StreamPos (jpeg) + (block_length - 7)
				EndIf
	
				Local back_byte:Int = 0 ' See below...
							
				While Not Eof (jpeg)
		
					' We should be at the start of a block; if not, bail out...
					
	'				DebugLog "---------------------------------------------------------------------------------------"
	'				DebugLog "New block at " + StreamPos (jpeg)
	'				DebugLog "---------------------------------------------------------------------------------------"
	
					Local checkff:Byte ' Byte to be tested for $FF (start of block)...
					
					' See further down -- needed as we can't seek backwards with online images...
					
					If back_byte
						' Byte from last time around...
						checkff = back_byte
					Else
						checkff = ReadByte (jpeg)
					EndIf
					
					If checkff = $FF
					
						back_byte = 0 ' Reset for next loop...
	
						' Read the byte AFTER a $FF marker...
						
						Local afterff:Byte = ReadByte (jpeg)
						
				' 		Some debug information, perhaps of interest...
				'		DebugLog "$FF" + Right (Hex (afterff), 2)
				'		$D8 = Start of Image (SOI) marker
				'		$D9 = End of Image (EOI) marker
				'		$ED = Photoshop data marker
				'		$E1 = Start of Exif data
						
						' Grab next two bytes (length of block) before proceeding...

						block_length = ReadShort (jpeg) - 2 ' The 2 subtracted bytes store the length itself...
						
						If afterff =&gt; $C0 And afterff &lt;= $C3
				
							' Bits per pixel...
							
							Local bpp:Int = ReadByte (jpeg)
				
							' Height and width...
							
							Local height:Int = ReadShort (jpeg)' (ReadByte (jpeg) Shl 8) + ReadByte (jpeg)
							Local width:Int = ReadShort (jpeg)'(ReadByte (jpeg) Shl 8) + ReadByte (jpeg)
							
							' Components per pixel (1 for grayscale, 3 for RGB)...
							
							Local components:Int = ReadByte (jpeg)
							
							' Depth/total colours...
							
							Local depth:Int = bpp * components
							Local colors:Int = 2 ^ depth
				
							' Fill in ImageInfo data...
				
							image.width	= width
							image.height	= height
							image.colors	= colors

							' Done!
				
							Exit
	
						Else
						
							' Go to next block...
	
							If remote
							
								' Online image, read byte-by-byte...
								
								For loop = 1 To block_length
									ReadByte jpeg
								Next
								
							Else
								' Local image, just seek...
								SeekStream jpeg, StreamPos (jpeg) + block_length
							EndIf
													
							' Found huge string of zeroes after jumping block_length in PS 7 JPEG! Skip...
							
							Local next_byte:Byte = 0
							
							Repeat
								next_byte = ReadByte (jpeg)
							Until next_byte
							
							' OK, found non-zero byte, so go back one byte and return to start of loop...
							
							back_byte = next_byte ' Store last-read byte (can't seek back with online images)...
	
							' back_byte will be checked at start of While/Wend loop...
							
						EndIf
						
					Else
					
						' Not at a block marker. Oops! Bail...
						
						image = Null
						Exit
						
					EndIf
					
				Wend
		
			Else
				image = Null
			EndIf

			Catch ReadFail:Object
			DebugLog "Read error in " + f
			image = Null

		End Try
		
		CloseFile jpeg
		
	Else
		image = Null
	EndIf
	
	Return image

End Function

Function GetPNGInfo:ImageInfo (f:String)

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf

	Local image:ImageInfo = New ImageInfo

	Local png:TStream = BigEndianStream (ReadFile (f))

	If png

		Try
		
			' PNG header...
			
			If ReadByte (png) = $89 And Chr (ReadByte (png)) = "P" And Chr (ReadByte (png)) = "N" And Chr (ReadByte (png)) = "G"
			
				' PNG header continued...
				
				If ReadByte (png) = 13 And ReadByte (png) = 10 And ReadByte (png) = 26 And ReadByte (png) = 10
	
					For Local loop:Int = 1 To 4
						ReadByte png
					Next
					
					' IHDR chunk (always first)...
					
					If Chr (ReadByte (png)) = "I" And Chr (ReadByte (png)) = "H" And Chr (ReadByte (png)) = "D" And Chr (ReadByte (png)) = "R"
				
						Local width:Int	= ReadInt (png)
						Local height:Int	= ReadInt (png)
						Local depth:Int	= ReadByte (png)
	
						Local colortype:Int	= ReadByte (png)
						
						Local info:String
						
						Select colortype
						
							Case 0
								info = "Pixels represented by grayscale values"
	
							Case 2
								info = "Pixels represented by RGB values"
							
							Case 3
								info = "Pixels represented by palette indices"
							
							Case 4
								info = "Pixels represented by grayscale values plus alpha"
							
							Case 6
								info = "Pixels represented by RGB values plus alpha"
							
							Default
								info = "Unknown pixel format"
								
						End Select
	
						image.width	= width
						image.height	= height
						image.colors	= 2 ^ depth
						image.info	= info
					
					Else
						image = Null
					EndIf
					
				Else
					image = Null
				EndIf
			
			Else
				image = Null
			EndIf
			
			Catch ReadFail:Object
			DebugLog "Read error in " + f
			image = Null
			
		End Try
		
		CloseFile png
		
	Else
		image = Null
	EndIf
		
	Return image

End Function

Function GetTGAInfo:ImageInfo (f$)

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf

	Local image:ImageInfo = New ImageInfo
	
	Local tga:TStream = LittleEndianStream (ReadFile (f$))

	If tga
		
		Try
		
			Local idlength:Byte = ReadByte (tga)
	
			Local colormap:Byte = ReadByte (tga)
			
			Local imagetype:Byte = ReadByte (tga)
			
			Local info:String
			
			Select imagetype
			
				' First three bits:
				
				Case 0
					info = "No image data present"
				Case 1
					info = "Uncompressed color-mapped image"
				Case 2
					info = "Uncompressed RGB image"
				Case 3
					info = "Uncompressed grayscale image"
	
				' Fourth bit:
				
				Case 9
					info = "RLE-compressed color-mapped image"
				Case 10
					info = "RLE-compressed RGB image"
				Case 11
					info = "RLE-compressed grayscale image"
	
				' From http://www.gamers.org/dEngine/quake3/TGA.txt ...
				
				Case 32
					info = "Color-mapped image (Huffman/Delta/RLE-compressed)"
	
				Case 33
					info = "Color-mapped image (Huffman/Delta/RLE-compressed, 4-pass quadtree)"
	
				Default
					info = "Unknown image type"
					
			End Select
			
			Local colormapstart:Short	= ReadShort (tga)
			Local colormaplength:Short	= ReadShort (tga)
			Local colormapbpp:Byte		= ReadByte (tga)
	
			Local xorigin:Short = ReadShort (tga)
			Local yorigin:Short = ReadShort (tga)
			
			Local width:Short	= ReadShort (tga)
			Local height:Short	= ReadShort (tga)
			
			Local depth:Byte	= ReadByte (tga)
	
			If colormap
	
				depth = colormapbpp
	
	'				DebugLog "Color map start: " + colormapstart
	'				DebugLog "Color map length: " + colormaplength
	'				DebugLog "Color map bits per pixel: " + colormapbpp
	
	'				Select colormap
	'					Case 0
	'						DebugLog "Image has no indexed palette"
	'					Case 1
	'						DebugLog "Image has indexed palette (" + colormaplength + " entries)"
	'					Case colormap =&gt;2 And colormap &lt;= 127
	'						DebugLog "Truevision-specific color map"
	'					Case colormap =&gt; 128 And colormap &lt;= 255
	'						DebugLog "Third-party color map"
	'				End Select
	
			EndIf
			
			Local desc:Byte = ReadByte (tga)
			
			Local pixelattr:Byte = desc &amp; (Int (2 ^ 3) | Int (2 ^ 2) | Int (2 ^ 1) | Int (2 ^ 0))
	
			Select pixelattr
			
				Case 0
	
					info = info + ", no alpha mask"
	
				Case 1
	
					info = info + ", with background mask"
	
				Case 8
	
					info = info + ", with alpha mask"
					
			End Select
	
			' 32-bit depth may or may not include an alpha mask, but RGB values are max 24-bit...
			
			If depth = 32 Then depth = 24
			
			Local colors:Int = Int (2 ^ depth)
			
			' NOTE: colors value is the maximum number of colours available to each
			' pixel. This applies even in images with a limited number of palette
			' entries, eg. a palette of 8 indexed colours may still contain 24-bit values!
			
			image.width = width
			image.height = height
			image.colors = colors
			image.info = info
			
			Catch ReadFail:Object
			DebugLog "Read error in " + f
			image = Null

		End Try
	
		CloseFile tga
	
	Else
		image = Null
	EndIf
	
	Return image

End Function

' -----------------------------------------------------------------------------
' File format tests...
' -----------------------------------------------------------------------------

Function GotBMP:Int (f:String)

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	Local result:Int = False
	
	Local bmp:TStream = LittleEndianStream (ReadFile (f))

	If bmp
		
		Try
		
			If ReadByte (bmp) = $42 And ReadByte (bmp) = $4D
	
				For Local loop:Int = 1 To 12
					ReadByte bmp
				Next
				
				If ReadInt (bmp) = 40
					result = True
				EndIf
		
			EndIf
			
			Catch ReadFail:Object
			DebugLog "Read error in " + f
		
		End Try
		
		CloseFile bmp
		
	EndIf

	Return result
	
End Function

Function GotGIF:Int (f:String)

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	Local result:Int = False
	
	Local gif:TStream = LittleEndianStream (ReadFile (f))

	If gif
	
		Try
		
			' First 3 bytes must be "GIF"...
			
			Local g:String ' /beavis: Uh... huh huh!
			
			Local loop:Int ' For byte-seek loops...
			
			For loop = 0 To 2
				g = g + Chr (ReadByte (gif))
			Next
	
			If g = "GIF"
	
				' Next 3 bytes contain version (87a or 89a)...
				
				Local version:String
				
				For loop = 3 To 5
					version = version + Chr (ReadByte (gif))
				Next
				
				If version = "87a" Or version$ = "89a"
					result = True
				EndIf

			EndIf
			
			Catch ReadFail:Object
			DebugLog "Read error in " + f
		
		End Try
		
		CloseFile gif
	
	EndIf

	Return result
			
End Function

Function GotJPEG:Int (f:String)

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	Local result:Int = False
	
	Local jpeg:TStream = BigEndianStream (ReadFile (f))

	If jpeg

		Try
		
			If ReadByte (jpeg) = $FF And ReadByte (jpeg) = $D8

				ReadByte jpeg
				ReadByte jpeg
				
				Local block_length:Int = ReadShort (jpeg) - 2
				
				ReadByte jpeg
				ReadByte jpeg
				ReadByte jpeg
				ReadByte jpeg
				ReadByte jpeg

				ReadByte jpeg
				ReadByte jpeg

				Local loop:Int
					
				For loop = 1 To block_length - 7
					ReadByte jpeg
				Next

				If ReadByte (jpeg) = $FF
					result = True
				EndIf
				
			EndIf
			
			Catch ReadFail:Object
			DebugLog "Read error in " + f
		
		End Try
		
		CloseFile jpeg
		
	EndIf

	Return result
	
End Function

Function GotPNG:Int (f:String)

	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	Local result:Int = False
	
	Local png:TStream = BigEndianStream (ReadFile (f))

	If png

		Try

			If ReadByte (png) = $89 And Chr (ReadByte (png)) = "P" And Chr (ReadByte (png)) = "N" And Chr (ReadByte (png)) = "G"
			
				' PNG header continued...
				
				If ReadByte (png) = 13 And ReadByte (png) = 10 And ReadByte (png) = 26 And ReadByte (png) = 10
	
					For Local loop:Int = 1 To 4
						ReadByte png
					Next
					
					' IHDR chunk (always first)...
					
					If Chr (ReadByte (png)) = "I" And Chr (ReadByte (png)) = "H" And Chr (ReadByte (png)) = "D" And Chr (ReadByte (png)) = "R"
						
						result = True
						
					EndIf
					
				EndIf
				
			EndIf
				
			Catch ReadFail:Object
			DebugLog "Read error in " + f
		
		End Try
		
		CloseFile png
		
	EndIf

	Return result
	
End Function

Function GotTGA:Int (f:String, ext:Int = True)

	' Best to take extension into account here, since there are no 100% identifying TGA markers...
	
	If ext
		If Lower (ExtractExt (f)) &lt;&gt; "tga"
			Return False
		EndIf
	EndIf
	
	If Lower (Left (f, 7)) = "http://"
		f = "http::" + Right (f, Len (f) - 7)
	EndIf
	
	Local result:Int = False
	
	Local tga:TStream = LittleEndianStream (ReadFile (f))

	If tga

		Try

			ReadByte tga
			ReadByte tga
			ReadByte tga

			ReadShort tga
			ReadShort tga
			Local mapbits:Byte = ReadByte (tga)
	
			ReadShort tga
			ReadShort tga
			
			' Width and height &gt; 0...
			
			If ReadShort (tga) &gt; 0 And ReadShort (tga) &gt; 0
			
				' Depth &gt; 0 or bits per palette entry &gt; 0...

				Local depth:Byte = ReadByte (tga)

				If depth

					result = True
					
					Select depth
						Case 8
						Case 16
						Case 24
						Case 32
						Default
							result = False
					End Select
					
				Else
					If mapbits
	
						result = True
						
						Select depth
							Case 15
							Case 16
							Case 24
							Case 32
							Default
								result = False
						End Select
					EndIf
				EndIf
				
			EndIf

			Catch ReadFail:Object
			DebugLog "Read error in " + f
		
		End Try
		
		CloseFile tga
		
	EndIf

	Return result
	
End Function

Function GetImageInfo:ImageInfo (f:String)

	Local i:ImageInfo = New ImageInfo
	
	Local ext:String = Lower (ExtractExt (f))

	Select ext:String
	
		Case "jpg", "jpeg", "jpe", "jfif"
			i = GetJPEGInfo (f)
			
		Case "gif"
			i = GetGIFInfo (f)

		Case "bmp"
			i = GetBMPInfo (f)

		Case "png"
			i = GetPNGInfo (f)

		Case "tga"
			i = GetTGAInfo (f)
			
		Default
			i = Null

	End Select

	If i = Null
		If GotJPEG (f) Then i = GetJPEGInfo (f); If i Then i.info = "This is really a JPEG file!"; Return i
		If GotBMP (f) Then i = GetBMPInfo (f); If i Then i.info = "This is really a BMP file!"; Return i
		If GotPNG (f) Then i = GetPNGInfo (f); If i Then i.info = "This is really a PNG file!"; Return i
		If GotGIF (f) Then i = GetGIFInfo (f); If i Then i.info = "This is really a GIF file!"; Return i
		If GotTGA (f) Then i = GetTGAInfo (f); If i Then i.info = "This is really a TGA file!"; Return i
	EndIf
	
	Return i
	
End Function</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Quick test -- add some image filenames:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' ************ Copy main code archive entry here! ************

' -----------------------------------------------------------------------------
' D E M O . . .
' -----------------------------------------------------------------------------

' Provide some files of jpg, gif, bmp, tga and png types...

Local f1:String = "test.jpg"
Local f2:String = "test.gif"
Local f3:String = "test.bmp"
Local f4:String = "test.png"
Local f5:String = "test.tga"

' IMPORTANT! ALWAYS check return value from GetImageInfo is non-Null before
' attempting to access information...

' File names defined at top of code!

Print ""

Local info:ImageInfo

' -----------------------------------------------------------------------------
' JPEG test...
' -----------------------------------------------------------------------------

info = GetImageInfo (f1$)

If info
	Print "Info for ~q" + f1$ + "~q:"
	Print ""
	Print "~t" + info.width + " x " + info.height + ", " + info.colors + " colours (" + info.info + ")"
	Print ""
Else
	Print "No information returned for ~q" + f1$ + "~q!"
EndIf

' -----------------------------------------------------------------------------
' GIF test...
' -----------------------------------------------------------------------------

info = GetImageInfo (f2$)

If info
	Print "Info for ~q" + f2$ + "~q:"
	Print ""
	Print "~t" + info.width + " x " + info.height + ", " + info.colors + " colours (" + info.info + ")"
	Print ""
Else
	Print "No information returned for ~q" + f2$ + "~q!"
EndIf

' -----------------------------------------------------------------------------
' BMP test...
' -----------------------------------------------------------------------------

info = GetImageInfo (f3$)

If info
	Print "Info for ~q" + f3$ + "~q:"
	Print ""
	Print "~t" + info.width + " x " + info.height + ", " + info.colors + " colours (" + info.info + ")"
	Print ""
Else
	Print "No information returned for ~q" + f3$ + "~q!"
EndIf

' -----------------------------------------------------------------------------
' PNG test...
' -----------------------------------------------------------------------------

info = GetImageInfo (f4$)

If info
	Print "Info for ~q" + f4$ + "~q:"
	Print ""
	Print "~t" + info.width + " x " + info.height + ", " + info.colors + " colours (" + info.info + ")"
	Print ""
Else
	Print "No information returned for ~q" + f4$ + "~q!"
EndIf

' -----------------------------------------------------------------------------
' TGA test...
' -----------------------------------------------------------------------------

info = GetImageInfo (f5$)

If info
	Print "Info for ~q" + f5$ + "~q:"
	Print ""
	Print "~t" + info.width + " x " + info.height + ", " + info.colors + " colours (" + info.info + ")"
	Print ""
Else
	Print "No information returned for ~q" + f5$ + "~q!"
EndIf
</textarea><br><br>If you have a folder full of images (including any sub-folders), this will go through all of them and print the details.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' ************ Copy main code archive entry here! ************

Local f:String = "G:\Docs\My Pictures\" ' Your image folder!

' -----------------------------------------------------------------------------
' D E M O . . .
' -----------------------------------------------------------------------------

Print ""
ParseFolder f ' Defined above!
End

Function PrintImageInfo (f:String)
	
	Local info:ImageInfo = GetImageInfo (f:String)
	
	If info
		Print "Info for ~q" + f:String + "~q:"
		Print ""
		Print "~t" + info.width + " x " + info.height + ", " + info.colors + " colours (" + info.info + ")"
		Print ""
	Else
		Print "No information returned for ~q" + f:String + "~q!"
	EndIf

	Print ""
	
End Function

Function ParseFolder (dir:String)

	If Right (dir:String, 1) &lt;&gt; "\" And Right (dir:String, 1) &lt;&gt; "/"
		dir:String = dir:String + "/"
	EndIf
	
	Local folder:Int = ReadDir (dir:String)

	If folder
	
		Repeat

			Local entry:String = NextFile (folder)

			If entry = "" Then Exit
			
			If entry &lt;&gt; "." And entry &lt;&gt; ".."

				Local file:String
				Local full:String
				
				If FileType (dir + entry) = FILETYPE_FILE
	
					file = entry
		
					full = dir
		
					If Right (full, 1) &lt;&gt; "\" And Right (full, 1) &lt;&gt; "/"
						full = full + "\"
					EndIf
		
					full = full + file
		
					PrintImageInfo (full)
		
				Else
		
					If FileType (dir + entry) = FILETYPE_DIR
	
						file = entry
		
						If file &lt;&gt; "." And file &lt;&gt; ".."
		
							Local ffolder:String = dir
		
							If Right (ffolder, 1) &lt;&gt; "\" And Right (ffolder, 1) &lt;&gt; "/"
								ffolder = ffolder + "\"
							EndIf
	
							ffolder = ffolder + file
								
							ParseFolder (ffolder)
		
						EndIf
		
					EndIf
		
				EndIf
	
			EndIf

		Forever
	
	EndIf

End Function
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Some JPEG files contain EXIF data - data which shows information from the digital camera/phone the picture was taken on; such as date/time taken, shutter speed, ISO, aperture, white balance and so on.<br><br>You checked for any correlation between that and the jpeg images that don't work right? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> No, it doesn't appear to be related to EXIF information. I believe some files don't contain the expected $FF, or possibly $C0, values, though I need to look into it further...<br><br>($FF marks the start of a block of information, and a following $C0 marks the block containing width/height information... at a very quick glance, it seems either that $C0 isn't found after a $FF in the files that fail, or the expected $FF block marker isn't found where it's expected at some point.)<br><br>I believe EXIF would just be another $FF block (or several), but <b><a href="http://www.takenet.or.jp/~ryuuji/minisoft/exifread/english/download.html" target="_blank">this program</a></b> seems to prove EXIF isn't the problem. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I read somewhere that when you open a jpeg, part of the file is run as an exe so perhaps they built some kind of protection into it... maybe check the disc space it takes up, then ctrl-prtSc it and save as the same resolution jpeg. and see if it still doesnt return info? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>part of the file is run as an exe<br> <br></div><br>I don't think that's true!<br><br>I've almost got it sussed, though -- only 8 of my 10,000+ JPEGs are failing now (as opposed to around 1,400 yesterday!). I just had to check for some more $FFC<i>x</i> markers and relax the requirement for certain 'correct' details which are often skipped in reality. The only other 'fails' were images with incorrect extensions (eg. a BMP file named as "blah.jpg"), so that's pretty good.<br><br>I have an idea what might be wrong with the remaining 8 files, but will be updating this code soon anyway... <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> [EDIT: Sorted!]<br><br>Gah! Photoshop 7 JPEGs are the only ones failing, and it seems that they're widely incompatible unless saved using the 'Save for Web' function, since Adobe wisely decided to do their own thing that nobody else does. I might have a go at working around this, but I don't think it's that important -- see links below if interested:<br><br><a href="http://photo.net/bboard/q-and-a-fetch-msg?msg_id=003j8d" target="_blank">http://photo.net/bboard/q-and-a-fetch-msg?msg_id=003j8d</a><br><br><a href="http://www.codeproject.com/KB/graphics/iptc.aspx?fid=2301&amp;df=90&amp;mpp=25&amp;noise=3&amp;sort=Position&amp;view=Quick&amp;fr=26&amp;select=716178" target="_blank">http://www.codeproject.com/KB/graphics/iptc.aspx?fid=2301&amp;df=90&amp;mpp=25&amp;noise=3&amp;sort=Position&amp;view=Quick&amp;fr=26&amp;select=716178</a><br><br><a href="http://www.tow.com/photo/articles/1d_jpeg_iptc/" target="_blank">http://www.tow.com/photo/articles/1d_jpeg_iptc/</a><br><br>http://209.85.229.132/search?q=cache:Lf0CVkgJLMwJ:www.adobeforums.com/webx%3F14@@... <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I've updated the code (and my first post) with the fixed JPEG reader. It seems to correctly retrieve the details of any supported image file I throw at it now! The only exceptions have been images named with the wrong extension, just because the test code passes images to each decoder based on extension (so it actually flags mis-named files!).<br><br>Just got to test on PPC Mac, attempt to work around stupid PS 7 JPEGs and add some checking for corrupt files (so I don't call ReadByte past the end of broken files, not that this has come up so far). <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I read somewhere that when you open a jpeg, part of the file is run as an exe so perhaps they built some kind of protection into it. <br></div><br><br>That's not true, although there have been some viruses that did spread through plain images: This was due to an archaic windows 3.x printer image format that contained some macro system which was found to be vulnerable to buffer overflows. This was exploited by renaming the bad files in question to .JPG, which IE would then blindly hand over to the Windows rendering system to display... Except it wasn't really a JPEG but a different file format containing the virus code which then got executed.<br><br>The problem was 'fixed' by Microsoft by removing support for the other image format altogether.<br><br>Normal JPEGs have no executable code or 'smarts' inside of them, it's just a common lossy compression algorithm. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> For anyone that may be interested, this now appears to provide 100% correct results for all supported image formats -- BMP, PNG, JPEG and Gif so far. Please see updated code (including example in first post), and my updated comments before the code. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TaskMaster</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I haven't looked at your code, but does your code also determine the pic type by looking at the info, or does it use the file extension?<br><br>Can you just feed it a file (such as picture.dat) and it tell you whether it is jpg, gif, bmp, or png as well as give you the info? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> This is great!<br><br>Any thought of extending it to support exif reading?<br><br>(Not the only place I put this request):<br><br><a href="/Community/posts.php?topic=84682" target="_blank">/Community/posts.php?topic=84682</a><br><br><a href="http://code.google.com/p/maxmods/issues/detail?id=9" target="_blank">http://code.google.com/p/maxmods/issues/detail?id=9</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Thanks James. I had my own hacked jpg size reader before. I just adapted Marks jpg loader but hacked it so it only read the first few bytes - seemed to work ok, but this is much better. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Sounds good but dont forget the tga format :) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I've added TGA support, and (@ TaskMaster) I do plan to add proper image type checking rather than just relying on extension.<br><br>Dunno about Exif... I got really bogged down by that in the JPEG code, but might have another go!<br><br>(I've put the demos into the first post so the main code can just be copied and pasted into your own projects. You'll have to paste it into the demos to try them!) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Wa-hey... coming in the next day or so:<br><br><pre class=code>
Info for "http://www.hi-toro.com/images/test.tga":

	512 x 384, 16777216 colours (Uncompressed color-mapped image, no alpha mask)


Info for "http://www.hi-toro.com/images/test.png":

	300 x 300, 256 colours (Pixels represented by RGB values)
</pre><br><br>URLs (<i>http://</i> only) can now be passed as easily as filenames. Online images do (eg. JPEG) block jumps byte-by-byte, while local images can just use SeekStream to keep the same speed.<br><br>I need to do some more error-checking (particularly for EOF) before adding any more features (eg. found a couple of instances of not returning Null on failure to retrieve information). <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I've updated this entry with online support (just pass a normal http:// based URL), and I've added Try/Catch around byte read sections, so that broken files are aborted safely. (Tested on some deliberately truncated files, online and locally.)<br><br><pre class=code>
image:ImageInfo = GetImageInfo ("http://www.hi-toro.com/images/test.png")

If image &lt;&gt; Null
	Print "Width: " + image.width
	Print "Height: " + image.height
	Print "Colours: " + image.colors
	Print "Info: " + image.info
Else
	Print "Couldn't get image information!"
EndIf
</pre><br><br>Next will be proper file-type checking, rather than choosing which function to call based on the file extension. Also need to add consistency between formats' colour reporting, which is a bit mixed at present.<br><br>EDIT: Fixed variable name discrepancy when running without SuperStrict. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Fixed endianness so it now works correctly on PPC Macs -- it was failing on some file types.<br><br>There is a minor problem still on the PPC Mac, but I think it's a <a href="/Community/posts.php?topic=84743" target="_blank">Blitz bug/discrepancy</a>. It doesn't crash, though -- it just returns false information for images that are broken/truncated. For normal files it's fine. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Proper file-type checking now added...<br><br>It now checks using the file extension first, as before (since most files <i>are</i> named correctly), but if the result of GetImageInfo () is Null (the expected result where a file's extension is incorrect), it byte-checks the actual file type. (It puts a warning with the correct file type into the .info field, but the width/height/etc results should be correct regardless, assuming you have a valid, non-Null ImageInfo result.) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> The "minor problem" on PPC Mac is non-existent if your BlitzMax installation is up to date -- version 1.33 upwards will be fine. Corrupt files are correctly caught and skipped. <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
