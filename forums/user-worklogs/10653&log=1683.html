<!DOCTYPE >
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><title>The Official Blitz Website</title><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"></head><body> 
 
<table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tbody><tr><td>&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="../../news.html" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="../../index.html" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="../../codearcs.html" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="../../user-worklogs.html" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="../../gallery.html" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="../../sdkspecs.html" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="../../search.html" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></tbody></table></td><td class="menubarright"></td></tr></tbody></table><div class="main"><h1>Worklog for Warner</h1><h1>Worklog Warner</h1><a href="../../user-worklogs.html">Return to Worklogs</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>CSG again</td><td align="right"><font class="tiny">(Posted 2011-02-16)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> Last week I was working on new CSG routines. I was looking for a cleaner and more reliable version.<br>I've
 allways thought that BSP's were the more advanced method, in 
comparision to Laidlaw. But I learnt Laidlaw creates less unneeded 
polygons, so I gave it a second chance.<br>I wrote an OOP version of the Laidlaw algorithm in BlitzMax.<br>I
 feel more confident about this version: it has no strange patches, 
everything tested seems to work, and I understand the routines it uses.<br>However, I've learnt not to trust these CSG routines I write too easily, so I'm a bit cautious before claiming success.<br>Here is a screenshot:<br><img src="10653&amp;log=1683_files/csg_003.html"> <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Terrains</td><td align="right"><font class="tiny">(Posted 2009-07-18)</font></td></tr></tbody></table></td></tr><tr><td class="posttext">
 Now for the dropper, I'm working on terrains. I've posted two of the 
things I did so far. I translated a Russian ROAM algo. On the MacBook 
I'm working on this holiday, it runs at about 400 fps, but on my own 
laptop PC it runs at only 60 fps. Without terrain, minib3d runs at 170 
fps.<br>Anyway, still working through. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Editor progress</td><td align="right"><font class="tiny">(Posted 2009-07-15)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <img src="10653&amp;log=1683_files/afbeelding1a.html"><br>I'm
 working on a Mac for the last few days, and the program is coming down 
nicely. I did underestimate what a huge task nearly everything is. When 
an object is updated, it needs to be replaced in the TreeView, the icon 
has to be updated, and the mesh. When an object is removed from the 
object panel, I need to check if a copy was made from it, and if that 
copy still exists in the main editor. If the copy is still there, the 
user cannot delete the prototype from the object panel.<br>Anyway, I 
included Lathe and Extrude. You can realtime alter objects made with 
these functions. When done, you can convert them to a common mesh.<br>Lathe allready generates uv coords, Extrude still does not.<br>When
 a normal mesh is edited, you can drag around it's vertices. It is a 
nice feature, but it makes the program too slow, so I need to upgrade 
that.<br>After that, todo: tween button for animations, most likely several bugfixes, and then on to the world editor. (sort of dropper) <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>St Elsewhere</td><td align="right"><font class="tiny">(Posted 2009-07-15)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <a href="http://www.youtube.com/watch?v=y1Hr0MrxMak" target="_blank">http://www.youtube.com/watch?v=y1Hr0MrxMak</a> <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Project update 1</td><td align="right"><font class="tiny">(Posted 2009-06-14)</font></td></tr></tbody></table></td></tr><tr><td class="posttext">
 Again, a lot of progress. I stripped bones from .b3d files so I can 
attach new objects to them. I created a global turnentity for minib3d, 
and I created a basic loft tool.<br>Also, I downloaded wxmax, which seems to work nicely, and I made a testing program where wxmax and minib3d are combined.<br>Everything is still in a basic stage, but I'm hoping to make progress soon.<br><br>Combining
 everything will be a big challenge. I'm not sure how to create a single
 editor that has all the functions I wrote and still maintain a certain 
level of simplicity. Still working on that. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Improved routines</td><td align="right"><font class="tiny">(Posted 2009-05-30)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> The second 'workaround' works much better than trying to merge trees.<br>Also, before adding new objects, I'm adding their bounding box, to avoid the final mesh from getting too fragmented.<br><img src="10653&amp;log=1683_files/csg_006.html"><br>The editor is updated as well, you can now also add spheres to the scene.<br><a href="http://abcbasic.comyr.com/csg.zip" target="_blank">http://abcbasic.comyr.com/csg.zip</a><br><br>Note
 that the editor is not a well-written program. I simply patched it 
together quite fast to be able to test the CSG routines. <br>The height differences in the floor are a result of the editor, not the CSG routines. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Another workaround</td><td align="right"><font class="tiny">(Posted 2009-05-29)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <img src="10653&amp;log=1683_files/csg_005.html"><br>Right, instead of trying to merge the BSP's, which I can only partially get to work, <br>I'm now using the same workaround as I did before.<br>Except the method is now a bit more optimized.<br><br>I create a list of all BSP trees.<br>If a polygon ends up in an 'outside' leaf, it is pushed through the next tree, else it is not.<br>That way, as soon as a polygon is inside a solid, the determination process is terminated.<br><br>I figured that would take the same amount of calculations, <br>and that way, the nodes are not fragmented too much.<br>It seems to work sofar. Every test I did that failed with the previous method, is passed correctly.<br>Still, I've learnt not to get too optimistic too soon.<br>I guess back to some more testing for now.. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Idea</td><td align="right"><font class="tiny">(Posted 2009-05-29)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> Right, I did solve the problem partially.<br>And I now see that it can be done. It is just the merging function that is incorrect.<br><br>The workaround is attaching Tree2 to each 'front' leaf of Tree1.<br>That is quite overdone, and it slows down the BSP routines heavily when meshes increase their complexity.<br>I would only need to attach subtrees of Tree2 to certain frontleaves of Tree1.<br>However, I need to work out a routine that can determine which subleaf should be attached at what frontleaves.<br><br>Still, it's progress. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>:(</td><td align="right"><font class="tiny">(Posted 2009-05-29)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> @#$%&amp;! The merging routine doesn't seem to work properly.<br>Adding cubes, pyramids and cylinders seem to work, but when I started using spheres the trouble began.<br>Actually,
 the method was incorrect, it only shows when shapes are getting more 
complex. Spheres just brought up the problem sooner.<br>Well, back to the drawing board. This CSG is costing me years of my life. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Editor</td><td align="right"><font class="tiny">(Posted 2009-05-28)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <img src="10653&amp;log=1683_files/csgb.html"><br>I've made an editor to try out the csg routines.<br>Here is the download:<br><a href="http://abcbasic.comyr.com/csg.zip" target="_blank">http://abcbasic.comyr.com/csg.zip</a><br>It contains a small bug, but I didn't want to upload another version.<br>The picking plane that goes upwards doesn't point itself towards the camera.<br>Basically, you'll have to stay 'in front' of the world to be able to draw. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>Wrapper functions</td><td align="right"><font class="tiny">(Posted 2009-05-28)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <img src="10653&amp;log=1683_files/csgh.html"><br>Again good news! It works splendidly.<br>I've added the wrapper functions, and the code is now pretty neat:<br><pre class="code">	b1.TCSGBrush = CSG_LoadBrush("tex.bmp")	
	b2.TCSGBrush = CSG_LoadBrush("tex2.bmp")	

	m1.TCSGObject = CSG_CreateCylinder(0, 0, 0, 20, 20, 20, 24)

	cbe = CreateCube()
	ScaleMesh cbe, 20, 20, 20
	PositionMesh cbe, 20, 20, -20
	m2.TCSGObject = CSG_MeshToObject(cbe)
	FreeEntity cbe
	
	cbe = CreateCube()
	ScaleMesh cbe, 5, 22, 5
	PositionMesh cbe, -8, 0, 8
	m3.TCSGObject = CSG_MeshToObject(cbe)
	FreeEntity cbe
	
	CSG_PaintObject(m1, b1)
	CSG_PaintObject(m2, b2)
	CSG_PaintObject(m3, b2)

	CSG_Add(m1, m2)
	CSG_Substract(m1, m3)
	
	mesh = CSG_Render(m1)
</pre><br>I've included materials, and an _Add and _Substract function.<br>Every test I've done seems to work.<br>I will knock up a small editor to try it out further.<br><br>I
 should include optimisation, so that if a polygon is split, but none of
 the halfs are deleted, it should be reverted to it's unsplitted state.<br>But I don't really feel like doing that. Maybe later on. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>BSP tree merging</td><td align="right"><font class="tiny">(Posted 2009-05-28)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <img src="10653&amp;log=1683_files/csg_002.html"><br>Wh00t,
 again a new victory! Merging BSP trees. That was quite difficult for 
me, because their structure is beyond my abstract capabilities.<br><br>My first step was a workaround. <br>I could allready merge two objects using their BSP trees.<br>Object1's
 polies are pushed through the BSP tree of Object 2 and vice versa. Each
 object is rendered, and both are collapsed to a single mesh.<br><br>However, I could not merge the two BSP trees. <br>So whenever I wanted to add a 3rd shape, things went wrong.<br><br>The workaround was as follows:<br>I made a list with all objects that were added. <br>Then, when a new object is added, I push it though each object on this list, <br>and then I push each object on the list though this mesh.<br>Finally, each mesh is rendered and collapsed into the endresult. (AddMesh)<br><br>That worked, but offcourse it wasn't the 'right' way. I can imagine that merging the trees is faster.<br>Finally, after trying, thinking, drawing and a bunch of trial and error, it seems to work.<br>At least, so far.<br><br>So now I have the following code:<br><pre class="code">	PushDownCSGMesh(m1, root2, True) ;mesh1-&gt;BSP mesh2
	PushDownCSGMesh(m2, root1)       ;mesh2-&gt;BSP mesh1
		
	For p.TPoly = Each TPoly
		If p\parent = m1 Then
			If p\side = -1 Then DeletePoly p
		ElseIf p\parent = m2 Then
			If p\side =  1 Then DeletePoly p
		End If
	Next
		
	CSG_FlipMesh m2
	CSG_FlipNodes root2
	
	AddPolies m2, m1
</pre><br>It substracts object2 from object1 and adds the object2 BSP tree to object1's tree.<br>It's still WIP offcourse.<br>I'll now write a function that automates the above. <br><br>  </td></tr></tbody></table><br><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td class="posthead"><table width="100%" cellspacing="0" cellpadding="0"><tbody><tr><td>BSP CSG routine</td><td align="right"><font class="tiny">(Posted 2009-05-23)</font></td></tr></tbody></table></td></tr><tr><td class="posttext"> <img src="10653&amp;log=1683_files/csg.html"><br><br>Today, I finally got the BSP's down.<br>Luckily I found a page describing an algorithm in Google's cache. The page itself has dissapeared.<br><br>The Laidlaw approach didn't work for me. The code for that I posted in the archives.<br>Allready I could use planes to split objects. The step to change from triangles to polygons really paid off.<br>But now, I can generate a mesh defined by planes.<br>Each plane is defined by a normal and a 'd' value that indicates the<br>distance from the origin.<br><br>First, I create a big quad for each plane, then I chop off the outside pieces with a BSP tree.<br><br>Each polygon is pushed down a BSP tree. That is a binary tree using planes.<br>A function checks on which side the poly is. <br>If it is in front, the poly is pushed down the front leaf.<br>If it is in the back, the poly is pushed down the back leaf.<br>If the poly is on both sides, it is split into two parts, and each half is pushed down the according tree.<br>If the poly ends up on a front side, it remains, and if it ends up on a back side, it is deleted.<br><br>To determine on which side a polygon is, I use PointOnPlane.<br>If a poly is coplanar with the plane, I look at their normal and d values.<br>If it is the same as the plane's, the poly is pushed down <br>the front leaf, otherwise, it is pushed down the back leaf.<br><br>Polygons are defined by a number of points. Automatically, each point is connected with the previous point, <br>and the end is closed. That way, if I remove points from this triangle, it remains closed.<br>Since all polygons in this program are convex, it is not difficult to triangulate them: each side is <br>connected with the first point.<br>The method leaves small artifacts, but they are really small. <br>And a proper meshweld allready solves a big part of that problem.<br>Beside that, it is robust, and it works consistently.<br><br>I did need to cut off epsilon values, when using ray_plane (elias_t), PointOnPlane (leadwerks) and Compare.<br><br>Also, I can take another shape, and chop off the pieces that are outside the first shape, using it's BSP tree.<br>Later on, I shall build in the possibility to add the second shape's planes to the BSP tree.<br><br>Then, hopefully, I can perform boolean operations using BSP's. <br>A lot of hard work went into this, and I'm glad it all works out finally.<br><br><img src="10653&amp;log=1683_files/csg_004.html"> <br><br>  </td></tr></tbody></table><br></div><table width="100%"><tbody><tr><td></td></tr></tbody></table></body></html>