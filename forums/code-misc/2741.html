<!DOCTYPE html><html lang="en" ><head ><title >blitz3D like syntax to c++</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='converts Blitz3D like syntax to c++ code, language=bb, category=Miscellaneous'><meta name='author' content='MusicianKool'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=9>Miscellaneous</a>/blitz3D like syntax to c++</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="2741.bb">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >blitz3D like syntax to c++ by MusicianKool</td><td align="right">2010 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> Well this will make coding in c++ easier.  Still not sure on how to make c++ dll's for expanding blitz3d, as that is the primary goal here.  But for now it will translate the basic syntax of Blitz3D to c++.  and will provide a good reference to what your code would look like in c++.  It's about 90% complete, but it might not go any farther then that, as I'm stumped on some of blitz3d's type handling.  I'm using Dev-C++ for testing the c++ code, I have not tested on other C++ compilers.  So features:<br><br>[PLEASE READ THE BELOW]<br>regular c++ case sensitive for all commands(not really but just to be on the safe side make everything lowercase! ) <br>and variables(this is a must - 'a' is not the same as 'A' in c++ variable naming as well as 'ab' &lt;&gt; 'Ab' &lt;&gt; 'aB' &lt;&gt; 'AB')<br>c++ basic math is good '+=' '-=' '*=' '/=' '++' '--'<br>To use more complex math functions use '#include &lt;math.h&gt;'  at the begining of the '.ob' file.<br>The syntax is about the same as blitz3d for most if not all c++ math functions, the only thing that is different is you need to have a return convention for them ie:<br><pre class=code>
;blitz3D cos example
a# = Cos(n)

;translator example
local a#
a = float cos(n)
</pre><br>you can inline c++ code with:<br><pre class=code>
[cpp]
// put c++ code here
[cpp]
;this will also work
[c++]
// put c++ code here
[c++]
</pre><br><br><br>Limitations:<br>No mulitiple lines of code on a single line outside a c++ code block not only is it bad coding its not translated corectly:<br><pre class=code>
x = 1:y = 2:z = 3:for i = 1 to 10:print x:next
</pre><br>should be<br><pre class=code>
x = 1
y = 2
z = 3
for i = 1 to 10
	print x
next
</pre><br><br>the local statement in blitz3D allows assigning values to variables.  that is not true with this translator. <br><pre class=code>
local x=1,y=2,words$="what is a word?",flo#=1.2323201
</pre><br>should be<br><pre class=code>
local x%,y,words$,flo#
x = 1
y=2
words= "what is a word?"
flo =1.2323201
</pre><br><br><br>The translator only works within class/end class and function/ end function  scope. so globals need to be declared in c++ syntax and outside of any function and class.<br><pre class=code>
int i;
string k;
float x;
</pre><br><br>'type / end type' works the same as 'class / end class'<br>any field accesor like blitz3D's 'f\variable' is changed to 'f.variable' .<br><br>Things I haven't figured out.<br>Insert, after, before, first, last, for f.foo = each foo<br>converting strings to integers/floats and vis versa.<br><br>If I remember more limitations or uses I will list them: <br>Please tell me of any bugs or features that should be added!<br><br><br><br>test2.ob<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Comment test for cpp
#include &lt;iostream&gt; 		;Must use this include for using print and other commands
#include &lt;string&gt;			;Must be used to do strings
#include &lt;new&gt;				;Must be used for dynamic arrays
#include &lt;list&gt;				;Must be used for dynamic lists of classes
using namespace std
#define true = 1
#define false = 0


Class foo 					;Test Comment on Class
	field a% 				;Test Comment on Field
	field b$
	Method addhundo() 	;Test Comment on Method
		a += 100			;Test Comment on Method code
	end method				;Test Comment on Method Exit
	Method addsome(amount%)
		local i%,j
		for i = 1 to amount
			while j &lt; 10
				if a = 1000 then
					return
				endif
				a += i
				j++
				print j
				if j &gt; 5 then
					exit
				endif
			wend
		next
	end method
End Class 					;Test Comment on Class exit

function dosomething(f.foo)
	f.a = 0
	f.b = "xxxx"
end function

Function make_an_instance.foo()
	foo g
	return g
end function

Function Main() 			;Test Comment on function
	; 'foo f' creates a new class foo where f is the handle but as soon 
	; as f isn't used anymore the class instance is deleted!
	; Use 'f tolist foo'  to put it into the class list
	; or use 'foo_list.push_back(f)' as that is what 'f tolist foo' converts too.
	; Also you can change the fields of f and use 'f tolist foo' and it will create
	; a new instance of foo with the changed fields.
	; And 'f.foo = new foo' translates to 'foo f;foo_list.push_back(f)' so works
	; the same as blitz3D.
	foo f
	print f.a
	f tolist foo
	f.addhundo()
	print f.a
	f tolist foo
	f.b = "Hello"
	print f.b+"  World!"
	f tolist foo
	f.addsome(100)
	print f.a
	f tolist foo
	
	print "Printing made instences"
	
	; Still trying to figure out how:
	; for i.foo = each foo
	;	 print i.a + "    " + i.b
	; next
	; would translate to the below c++ code.
	[cpp]
	list&lt;foo&gt;::iterator i;
	for(i=foo_list.begin();i != foo_list.end(); ++i){
		cout &lt;&lt; (*i).a &lt;&lt; "   " &lt;&lt; (*i).b &lt;&lt; endl;
	}
	[cpp]
	
	waitkey
	g.foo = new foo			;This creates a new class foo where g is the handle and stores it in a list.
	dim myarray.foo[100]
	for i = 0 to 99
		myarray[i].a = i
	next
	for i = 0 to 99
		print myarray[i].a
	next
	
	dosomething(f)
	print f.a + f.b
	foo m = make_an_instance.foo()
	print m.a + m.b
	print "delete myarray"
	Delete myarray
	Waitkey
end function				;Test Comment on function exit
</textarea><br><br>Translates to 'test2.cpp':<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
// Comment test for cpp
#include &lt;iostream&gt; 		  // Must use this include for using print and other commands;
#include &lt;string&gt;			  // Must be used to do strings;
#include &lt;new&gt;				  // Must be used for dynamic arrays;
#include &lt;list&gt;				  // Must be used for dynamic lists of classes;
using namespace std;
#define true = 1;
#define false = 0;

class foo { //Test Comment on Class
public:
	int a;	//Test Comment on Field
	string b;	
	foo ();
	~foo ();
	void addhundo ();
	void addsome (int amount);
};//Test Comment on Class exit
list&lt;foo&gt; foo_list;
foo::foo() { //Constructor
	a = 0;
	b = "";
} 
foo::~foo() { //Destructor
} 
void foo::addhundo() { //Test Comment on Method
	a += 100			;//Test Comment on Method code
} //Test Comment on Method Exit
void foo::addsome(int amount) { 
	int i = 0;int j = 0;
	for ( i = 1 ; i &lt;= amount ; i++ ){
		while (j &lt; 10){
			if (a == 1000 ){
				return;
			}
			a += i;
			j++;
			cout &lt;&lt; j &lt;&lt; endl;
			if (j &gt; 5 ){
				break;
			}
		}
	}
} 
void dosomething(foo &amp;f){
	f.a = 0;
	f.b = "xxxx";
}
foo make_an_instance_foo(){
	foo g;
	return g;
}
int main(){//Test Comment on function
	;// 'foo f' creates a new class foo where f is the handle but as soon
	;// as f isn't used anymore the class instance is deleted!
	;// Use 'f tolist foo'  to put it into the class list
	;// or use 'foo_list.push_back(f)' as that is what 'f tolist foo' converts too.
	;// Also you can change the fields of f and use 'f tolist foo' and it will create
	;// a new instance of foo with the changed fields.
	;// And 'f.foo = new foo' translates to 'foo f;foo_list.push_back(f)' so works
	;// the same as blitz3D.
	foo f;
	cout &lt;&lt; f.a &lt;&lt; endl;
	foo_list.push_back(f);
	f.addhundo();
	cout &lt;&lt; f.a &lt;&lt; endl;
	foo_list.push_back(f);
	f.b = "Hello";
	cout &lt;&lt; f.b &lt;&lt; "  World!" &lt;&lt; endl;
	foo_list.push_back(f);
	f.addsome(100);
	cout &lt;&lt; f.a &lt;&lt; endl;
	foo_list.push_back(f);
	;
	cout &lt;&lt; "Printing made instences" &lt;&lt; endl;
	;
	;// Still trying to figure out how:
	;// for i.foo = each foo
	;//	 print i.a + "    " + i.b
	;// next
	;// would translate to the below c++ code.
	
	list&lt;foo&gt;::iterator i;
	for(i=foo_list.begin();i != foo_list.end(); ++i){
		cout &lt;&lt; (*i).a &lt;&lt; "   " &lt;&lt; (*i).b &lt;&lt; endl;
	}
	
	;
	system("PAUSE");
	foo g;foo_list.push_back(g);//This creates a new class foo where g is the handle and stores it in a list.
	foo * myarray = new (nothrow) foo[100];if (myarray == 0){cout &lt;&lt; "Error: memory could Not be allocated";return 0;};
	for ( int i = 0 ; i &lt;= 99 ; i++ ){
		myarray[i].a = i;
	}
	for ( int i = 0 ; i &lt;= 99 ; i++ ){
		cout &lt;&lt; myarray[i].a &lt;&lt; endl;
	}
	;
	dosomething(f);
	cout &lt;&lt; f.a  &lt;&lt;  f.b &lt;&lt; endl;
	foo m = make_an_instance_foo();
	cout &lt;&lt; m.a  &lt;&lt;  m.b &lt;&lt; endl;
	cout &lt;&lt; "delete myarray" &lt;&lt; endl;
	delete[] myarray;
	system("PAUSE");
}//Test Comment on function exit

</textarea><br><br>The source (put this in the same folder that test2.ob is in):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
FileName$ = "Test2"
Global file = ReadFile(filename+".OB")
Global file2= WriteFile(filename+".cpp")
Global LineIn$,InClass,InMethod,LineCount
Global ObservedKeySymbol$,ObservedKeyWord$,ObservedNumber$
Global InCpp

Convert_OOPS_cpp()
Write_cpp_Code()

CloseFile(file2)	;close the output file so that it can be debuged through blitz
CloseFile(file)		;close the Objective Blitz3D file

End

Type Class
	Field Name$
	Field Name_Lower$
	Field ClassTabs
	Field TypesPointer$
	Field LastPointer$
	Field ParentClass.Class
	Field ContainMethods
	Field Private
	Field Comment$
	Field ExitClassComment$
	Field iterator$
End Type

Type Fields
	Field Name$
	Field Name_Lower$
	Field VariableType
	Field Tabs
	Field ParentClass.Class
	Field ParentClassName$
	Field Private
	Field Comment$
End Type

Type Method
	Field parentPTR.Class
	Field Name$
	Field Name_Lower$
	Field ReturnType%
	Field Parameters$
	Field Tabs
	Field Private
	Field Comment$
	Field ExitComment$
	Field Constructor
	Field Destructor
End Type
Type MethodCode
	Field Parent.Method
	Field Code$
	Field Tabs
	Field Comment$
	Field Term
End Type
Type MethodVariable
	Field Name$
	Field VariableType
	Field Parent.Method
	Field Declared
	Field ClassName$
	Field IsArray
End Type

Type Functions
	Field Name$
	Field Name_Lower$
	Field ReturnType%
	Field Parameters$
	Field Comment$
	Field ExitComment$
	Field ClassName$
End Type
Type FunctionCode
	Field Parent.Functions
	Field Code$
	Field Tabs
	Field Comment$
	Field Term
End Type
Type FunctionVariable
	Field Name$
	Field VariableType
	Field Parent.Functions
	Field Declared
	Field ClassName$
	Field IsArray
End Type

Function Convert_OOPS_cpp()
	
Local LineCount,TabCount,T.Class,Name$,OldBS,M.Method,LineRead,C.Class,ParentName$,MC.MethodCode
Local InFunctionFlag,F.Functions

	While Not Eof(file)
		
		LineIn$ = ReadLine(file):LineCount = LineCount + 1
		TabCount = RemoveTabs()
		ti = 0
		Select True
			Case Lower(Left$(LineIn$,5)) = "class" Or Lower(Left$(LineIn$,5)) = "type "
				T.Class = ProcessClass.Class(LineIn$,TabCount)
				M.method = New Method
				M\Name = T\Name
				M\Constructor = True
				M\parentPTR = T
				M\Tabs = T\ClassTabs + 1
				M\Comment = "//Constructor"
				M.Method = New Method
				M\Name = "~"+T\Name
				M\parentPTR = T
				M\Destructor = True
				M\Comment = "//Destructor"
				M\Tabs = T\ClassTabs + 1
				InClass = True
	
			Case Lower(Left$(LineIn$,9)) = "end class" Or Lower(Left$(LineIn$,8)) = "end type"
				InClass = False
				For i = 9 To Len(LineIn)
					If Mid$(LineIn,i,1) = ";" Then T\ExitClassComment = "//"+Right$(LineIn,Len(LineIn)-i)
				Next
			
			Case Lower(Left$(LineIn$,5)) = "field"
				ProcessField(LineIn$, T , TabCount)
	
			Case InClass = True And LineRead = False And Lower(Left$(LineIn,6))&lt;&gt; "method" And InMethod = False
				ProcessField(LineIn$, T , TabCount)
			
			Case Lower(Left$(LineIn$,8)) = "private:" : T\Private = True
			
			Case Lower(Left$(LineIn$,7)) = "public:" : T\Private = False
		
			Case Lower(Left$(LineIn$,10)) = "end method" 
				MethodFlag = False:InMethod = False
				For i = 10 To Len(LineIn)
					If Mid$(LineIn,i,1) = ";" Then M\ExitComment = "//"+Right$(LineIn,Len(LineIn)-i)
				Next
			
			Case MethodFlag
				LineIn = RemoveRightSideTabs_Spaces$(LineIn)
				If Lower(LineIn) = "return" Then M\ReturnType = 0
				MC.MethodCode = New MethodCode
				MC\Parent = M
				MC\Tabs = TabCount
				MC\Code = LineIn
	
			Case Lower(Left$(LineIn$,6)) = "method"
				T\ContainMethods = True
				M.Method = New Method
				tm$ =  Right$(LineIn$,Len(LineIn$)-7)
				startx = 0: endx = 0:TypeHandle = 0:Coms = 0
				For j = 1 To Len( tm )
					If Mid$(tm,j,1) = "." Then TypeHandle = j
					If Mid$(tm,j,1) = "(" Then StartX = j
					If Mid$(tm,j,1) = ")" Then EndX = j
					If Mid$(tm,j,1) = ";" Then ComS = j
				Next
				Select True
					Case Mid$(tm,startx-1,1) = "%"
						M\ReturnType = 1
					Case Mid$(tm,startx-1,1) = "#"
						M\ReturnType = 2
					Case Mid$(tm,startx-1,1) = "$"
						M\ReturnType = 3
					Case TypeHandle &lt;&gt; 0 And typehandle &lt; startx
						M\ReturnType = 4
				End Select
				If coms &lt;&gt; 0 Then M\Comment = "//"+Right$(tm,Len(tm)-coms)
				If M\ReturnType&lt;&gt;0 Then 
					M\Name$ = Left$(tm,startx-2)
				Else
					M\Name$ = Left$(tm,startx-1)
				EndIf
				M\Name_Lower = Lower(M\Name)
				If endx - startx &gt; 1 Then M\Parameters$ = Mid$(tm,startx+1,(endx-2)-startx+1)
				M\Parameters = ProcessMethodParameters$(M)
				M\Tabs = TabCount
				M\parentPTR = T
				If T\Private = True Then M\Private = True
				MethodFlag = True
				InMethod = True
			
			Case Lower(Left$(LineIn$,12)) = "end function"
				InFunctionFlag = False
				For i = 10 To Len(LineIn)
					If Mid$(LineIn,i,1) = ";" Then F\ExitComment = "//"+Right$(LineIn,Len(LineIn)-i)
				Next
	
			Case InFunctionFlag ;Then
				LineIn = RemoveRightSideTabs_Spaces$(LineIn)
				If Lower(LineIn) = "waitkey" Then LineIn = "system("+Chr(34)+"PAUSE"+Chr(34)+")"
				FC.FunctionCode = New FunctionCode
				fC\Parent = F
				fC\Tabs = TabCount
				fc\code = LineIn
	
			Case Lower(Left$(LineIn,9)) = "function "
				F.Functions = New Functions
				tm$ = Right$(LineIn,Len(LineIn)-9)
				startx = 0: endx = 0:TypeHandle = 0:Coms = 0
				For j = 1 To Len( tm )
					If Mid$(tm,j,1) = "." Then TypeHandle = j
					If Mid$(tm,j,1) = "(" Then StartX = j
					If Mid$(tm,j,1) = ")" Then EndX = j
					If Mid$(tm,j,1) = ";" Then ComS = j
				Next
				Select True
					Case Mid$(tm,startx-1,1) = "%"
						F\ReturnType = 1
					Case Mid$(tm,startx-1,1) = "#"
						F\ReturnType = 2
					Case Mid$(tm,startx-1,1) = "$"
						F\ReturnType = 3
					Case typehandle &lt;&gt; 0 And typehandle &lt; startx
						F\ReturnType = 4
						F\classname = Mid$(tm,typehandle+1,(startx-typehandle)-1)
				End Select
				If coms &lt;&gt; 0 Then F\Comment = "//"+Right$(tm,Len(tm)-coms)
				Select True
					Case F\ReturnType &gt; 0 And F\ReturnType&lt;4
						F\Name = Left$(tm,startx-2)
					Case F\ReturnType = 4
						F\Name = Left$(tm,typehandle-1)
					Default
						F\Name = Left$(tm,startx-1)
				End Select
				F\Name_Lower = Lower(F\Name)
				If Lower(F\Name) = "main" Then F\Name = F\Name_Lower:F\ReturnType = 1
				If endx - startx &gt; 1 Then F\Parameters = Mid$(tm,startx+1,(endx-2)-startx+1):ProcessFunctionParameters$(F)
				InFunctionFlag = True
			Default
				If Left$(LineIn$,1) &lt;&gt; ";" Then
					If LineIn$ &lt;&gt; "" Then tol$ = Objective_Line$(LineIn$)+";":WriteLine(file2,ReplaceTabs$(tol$,TabCount));:WriteLine(file2,"")
				Else
					WriteLine(file2,ReplaceTabs$("//"+Right$(LineIn,Len(LineIn)-1),TabCount))
				EndIf
		End Select
	Wend
End Function

Function Write_cpp_Code()

	Local T.Class,TT.Class

	For T.Class = Each Class
		
		WriteLine(file2,"")
		
		TT = T\ParentClass
		If TT &lt;&gt; Null Then	
			WriteLine(file2,ReplaceTabs$("class" + " " + T\Name +":public "+ T\ParentClass\Name+" { " + T\Comment,T\ClassTabs))
			WriteLine(file2,"public:")
		Else
			WriteLine(file2,ReplaceTabs$("class" + " " + T\Name+ " { " + T\Comment,T\ClassTabs))
			WriteLine(file2,"public:")
		EndIf
		ProcessTypes(T)	
		PredeclareMethods(T)
		
		WriteLine(file2,ReplaceTabs$("};"+T\ExitClassComment,T\ClassTabs))
		WriteLine(file2,ReplaceTabs$("list&lt;"+T\Name+"&gt; "+T\Name+"_list;",T\ClassTabs))
		If T\ContainMethods = True Then WriteMethods(T)
	Next
	WriteFunctions()
End Function

Function WriteMethods(T.Class)

	Local M.Method,Method,BS,Code$,mct,LIN$,Name$,MC.MethodCode,F.Fields
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T Then
			
			Select True
				Case M\ReturnType = 0
					Name = "void"
				Case M\ReturnType = 1
					Name = "int"
				Case M\ReturnType = 2
					Name = "float"
				Case M\ReturnType = 3
					Name = "string"
				Case M\ReturnType = 4
					Name = T\Name
			End Select
			
			If M\Constructor = False And M\Destructor = False Then
				LIN$ = Name+" "+T\Name$+"::"+ M\Name$+"("+M\Parameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\Tabs-1))
				For MC.MethodCode = Each MethodCode
					If MC\Parent = M Then
						MC\Code = RemoveRightSideTabs_Spaces$(MC\Code)
						ProcessMethodCode(MC)
						Code= MC\Code
						If MC\Term = True Then
							WriteLine(file2,ReplaceTabs$(Code+MC\Comment,MC\Tabs-1))
						Else
							WriteLine(file2,ReplaceTabs$(Code+";"+MC\Comment,MC\Tabs-1))
						EndIf
					EndIf
				Next
			ElseIf M\Constructor
				LIN$ = T\Name$+"::"+ M\Name$+"("+M\Parameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\Tabs-1))
				For F.Fields = Each Fields
					If F\ParentClass = M\parentPTR Then
						Select True
							Case F\VariableType = 0
								WriteLine(file2,ReplaceTabs(F\Name + " = 0;",M\Tabs))
							Case F\VariableType = 1
								WriteLine(file2,ReplaceTabs(F\Name + " = "+Chr(34)+Chr(34)+";",M\Tabs))
							Case F\VariableType = 2
								WriteLine(file2,ReplaceTabs(F\Name + " = 0.0;",M\Tabs))
						End Select
					EndIf
				Next
			ElseIf M\Destructor 
				LIN$ = T\Name$+"::"+ M\Name$+"("+M\Parameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\Tabs-1))
			EndIf
			WriteLine(file2,ReplaceTabs$("}"+" "+M\ExitComment,M\Tabs-1))
		EndIf
	Next
End Function

Function WriteFunctions()
	
	Local F.Functions,Name$,FC.FunctionCode
	For F.Functions = Each Functions
		Select True
			Case F\ReturnType = 0
				Name = "void"
			Case F\ReturnType = 1
				Name = "int"
			Case F\ReturnType = 2
				Name = "string"
			Case F\ReturnType = 3
				Name = "float"
			Case F\ReturnType = 4
				Name = F\ClassName
		End Select
		If F\ClassName &lt;&gt; "" Then
			WriteLine(file2,Name+" " + F\Name+"_"+Name + "(" +F\Parameters+"){"+F\Comment)
		Else
			WriteLine(file2,Name+" " + F\Name + "(" +F\Parameters+"){"+F\Comment)
		EndIf
		For FC.functioncode = Each functioncode
			If FC\Parent = F Then
				FC\Code = RemoveRightSideTabs_Spaces$(FC\Code)
				ProcessFunctionCode(FC)
				If FC\Term = True Then
					WriteLine(file2,ReplaceTabs(FC\Code+FC\Comment,FC\Tabs))
				Else
					WriteLine(file2,ReplaceTabs(FC\Code+";"+FC\Comment,FC\Tabs))
				EndIf
			EndIf
		Next
		WriteLine(file2,"}"+F\ExitComment)
	Next
End Function

Function ProcessClass.Class(LineIn$,TabCount)

	Local T.Class,C.Class,TLIN,ParentName$,TI,SI,I
	
	ParentName$ = ""
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then 
			TI = I
		EndIf
	Next

	T.Class = New Class
	
	If SI &lt;&gt; 0 Then T\Comment = "//"+Right$(LineIn$,Len(LineIn$) - (SI)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	TLIN = Len(LineIn$)-Len("Class")
	If TLIN &lt;= 0 Then RuntimeError "Error @ Line: "+ LineCount+" Class has no name!"

	If TI &lt;&gt; 0 Then ParentName$ = RemoveSpaces$(Mid$(LineIn$,(TI+1),(SI - TI)-2))
	
	If ParentName$ &lt;&gt; "" Then
		For C.Class = Each Class
			If C\Name$=ParentName$ Or C\Name_Lower$=ParentName$ Then 
				T\ParentClass = C:T\Name = Mid$(LineIn$,7,TI - 7)
			EndIf
		Next
	Else
		T\Name = Right$(LineIn$, TLIN - 1)
	EndIf
	
	T\Name_Lower = Lower(T\name)
	T\ClassTabs = TabCount
	T\ContainMethods = False
	
	Return T
	
End Function

Function ProcessField(LineIn$,T.Class,TabCount)
	
	Local FieldName$,F.Fields,I,SI,TI,TP
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then TI = I
		If Mid$(LineIn$,I,1) = "." Then TP = I
	Next
	
	F.Fields = New Fields
	If Lower(LineIn) = "public:" Then F\Name = "public:":F\VariableType = 999:F\ParentClass = T:F\Tabs=TabCount:Return
	If Lower(LineIn) = "private:" Then F\Name = "private:":F\VariableType = 999:F\ParentClass = T:F\Tabs=TabCount:Return
	If Lower(LineIn) = "protected:" Then F\Name = "protected:":F\VariableType = 999:F\ParentClass = T:F\Tabs=TabCount:Return
	If Lower(Left$(LineIn$,5))= "list&lt;" Or Lower(Left$(LineIn$,5))= "list " Then F\Name = LineIn+";":F\VariableType = 999:F\ParentClass=T:F\Tabs=TabCount:Return
	If SI &lt;&gt; 0 Then F\Comment = "//"+Right$(LineIn$,Len(LineIn$)-(SI)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	Select True
		Case Right$(LineIn$,1)="%"
			F\VariableType=0
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="$"
			F\VariableType=1
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="#"
			F\VariableType=2
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case TP &lt;&gt; 0
			F\VariableType=3
			F\ParentClassName = Right$(LineIn,Len(LineIn)-tp)
			LineIn = Left$(LineIn,tp-1)
		Default
			F\VariableType=0
	End Select
	
	FieldName$ = Right$(LineIn$,Len(LineIn$)-6)
	F\Name = FieldName
	F\Name_Lower = Lower(FieldName)
	F\ParentClass = T
	F\Tabs = TabCount
	F\Private = T\Private
	If Lower(Left$(LineIn$,5))= "list&lt;" Or Lower(Left$(LineIn$,5))= "list " Then F\VariableType = 999
End Function

Function Objective_Line$(code$,term = True)
	Local F.Functions
	
	If Left$(Code$,7) = "Global " And InClass = False And InMethod = False And InFunction = False Then 
		Code = Right$(Code,Len(Code)-7)
	ElseIf Left$(Code$,7) = "Global " And InClass = True Or InMethod = True Or InFunction = True
		RuntimeError "Global in Class or Method not allowed @ "+ LineCount
	EndIf
	For i = 1 To Len(Code)
		If  Mid$(Code,i,1) = " " Or  Mid$(Code,i,1) = "=" Then LSP = i
		If Mid$(Code,i,1) = ";" Then 
			tCode$ = " // " +Right$(Code,Len(Code)-i)
			Code = Left$(Code,i-1)
		EndIf
		If Mid$(Code,i,1) = "." Then
			If lsp &lt;&gt; 0 Then
				fcode$=Mid$(Code,LSP+1,(i-lsp)-1)
			Else
				fCode$ = Left$(Code,i-1)
			EndIf
			For f.functions = Each functions
				If Lower(fCode) = F\Name_Lower Then Code = Left$(Code,i-1) + "_" + Right$(Code,Len(Code)-i)
			Next
		EndIf
		If Mid$(code,i,1) = "\" Then
			code$ = Left$(code,i-1)+"."+Right$(code,Len(code)-i)
		EndIf
	Next
	If Lower(Left$(Code,6)) = "print " Or Lower(Left$(Code,6)) = "print(" Then 
		Code = "cout &lt;&lt; " + Right$(Code,Len(Code)-6)
		For i = 1 To Len(Code)-1
			If Mid$(Code,i,1) = "+" Then Code = Left$(Code,i-1)+" &lt;&lt; "+ Right$(Code,Len(Code)-i):i = i+3
		Next
		Code = Code + " &lt;&lt; endl"
	EndIf
	If Lower(Left$(Code,9)) = "#include " Or Lower(Left$(Code,9)) = "#include&lt;" Then
		Return Code + " " + tcode
	EndIf
	If Lower(Left$(code,4)) = "dim " Then
		dx = 0:de = 0:dt = 0:di = False:ds = False:df = False
		For I = 5 To Len(Code)
			If Mid$(code,i,1) = "[" Then DX = i
			If Mid$(code,i,1) = "]" Then DE = i
			If Mid$(Code,i,1) = "%" Then DI = True
			If Mid$(Code,i,1) = "$" Then DS = True
			If Mid$(code,i,1) = "#" Then DF = True
			If Mid$(code,i,1) = "." Then DT = i
		Next
		If di = True Or ds = True Or df = True Or DT &lt;&gt; 0 Then
			Select True
				Case di
					Dtype$ = "int"
					name$ =  Mid$(code,5,(DX-1)-5)
				Case ds
					Dtype$ = "string"
					name$ =  Mid$(code,5,(DX-1)-5)
				Case df
					Dtype$ = "float"
					name$ =  Mid$(code,5,(DX-1)-5)
				Case dt &gt; 0
					Dtype$ = Mid$(code,dt+1,dx-dt-1)
					name$ = Mid$(code,5,dt-5)
			End Select
		Else
			Dtype$ = "int"
			name$ = Mid$(code,5,(DX)-5)
		EndIf
		Amount$ = Mid$(Code,dx+1,(de-dx)-1)
		code$ = Dtype$+" * "+name$ + " = new (nothrow) "+dtype$+"["+amount+"];"+"if ("+name+" == 0){cout &lt;&lt; "+Chr(34)+"Error: memory could Not be allocated"+Chr(34)+";return 0;}":Return code+tcode
	EndIf
	If Lower(Left$(Code,7)) =  "delete " Then
		name$ = Mid$(Code,8,(Len(Code)-7))
		Code = "delete[] "+name$
	EndIf
	tl = Instr(Lower(code)," tolist ")
	If tl &gt; 0 Then
		code = Right$(code,Len(code)-(tl+7))+"_list.push_back("+Left$(code,tl-1)+")"
	EndIf
	tl = 0:tl=Instr(Lower(code)," = new ")Or Instr(Lower(code),"= new ") Or Instr(Lower(code)," =new ")Or Instr(Lower(code),"=new ")
	If tl &gt; 0 Then
		For i = 1 To Len(code)
			If Mid$(code,i,1) = "." Then Exit
		Next
		code = Mid$(code,i+1,(tl-1)-(i+1))+" "+ Left$(code,i-1)+";"+Mid$(code,i+1,(tl-1)-(i+1))+"_list.push_back("+ Left$(code,i-1)+")"
	EndIf
	Return Code + tcode
End Function

Function ProcessTypes(T.Class)
	
	Local F.Fields,FT$,Name$
	
	For F.Fields = Each Fields
		FT = ""
		If F\ParentClass = T Then
			Select True
				Case F\VariableType = 0
					Name = "int"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Case F\VariableType = 1
					Name = "string"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Case F\VariableType = 2
					Name = "float"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Default
					WriteLine(file2,ReplaceTabs$(F\Name+Chr(9)+F\Comment,F\Tabs))
			End Select
		EndIf
	Next
	
End Function

Function ProcessTypesParent(T.Class)
	
	Local F.Fields,FT$
	
	For F.Fields = Each Fields
		FT = ""
		
		If F\ParentClass = T And F\Private = False Then
		Select True
				Case F\VariableType = 0
					FT = "%":Name = "int"
				Case F\VariableType = 1
					FT = "$":Name = "string"
				Case F\VariableType = 2
					FT = "#":Name = "float"
			End Select
			WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
		EndIf
	Next
	
End Function

Function PredeclareMethods(T.Class)
	
	Local M.Method,Name$
	For M.Method = Each Method
		If M\parentPTR = T Then 
			Select True
				Case M\ReturnType = 0
					Name = "void"
				Case M\ReturnType = 1
					Name = "int"
				Case M\ReturnType = 2
					Name = "float"
				Case M\ReturnType = 3
					Name = "string"
				Case M\ReturnType = 4
					Name = T\Name
			End Select
			If M\Constructor Then
				WriteLine(file2,ReplaceTabs$(M\Name + " (" +M\Parameters+");",M\Tabs))
			ElseIf M\Destructor Then
				WriteLine(file2,ReplaceTabs$(M\Name + " (" +M\Parameters+");",M\Tabs))
			Else
				WriteLine(file2,ReplaceTabs$(Name + " " + M\Name + " (" +M\Parameters+")"+";",M\Tabs))
			EndIf
		EndIf
	Next
End Function

Function ProcessFunctionParameters$(M.Functions)
	If M\Parameters = "" Then Return
	Local I, StartX=1,MV.FunctionVariable,In$,VN$,CN,TN$,CNSX,T.Class,TI,MVN$
	In = M\Parameters
	For I = 1 To Len(In$)
		If TestKeySymbol(Mid$(In,I,1)) Or (I = Len(in)) Then
			If I = Len(In) Then
				VN = Mid$(M\Parameters,StartX,(I+1) - StartX)
			Else
				VN = Mid$(M\Parameters,StartX,I - StartX)
			EndIf
			If (ObservedKeySymbol &lt;&gt; "." Or CN = True) And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then 
				MV.FunctionVariable = New FunctionVariable
				MV\Parent = M
				Select True
					Case ObservedKeySymbol = "%"
						MV\VariableType = 1
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case ObservedKeySymbol = "#"
						MV\VariableType = 2
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case ObservedKeySymbol = "$"
						MV\VariableType = 3
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case CN = True
						TN$ = Mid$(In,CNSX,(i+1)- CNSX):CN = False
						For t.class = Each class
							If TN = T\Name Then MV\VariableType = 4:MV\ClassName = T\Name:MV\Name = MVN
						Next
					Default
						MV\VariableType = 1	
						MV\Name = VN
				End Select
				MV\Declared = True
			Else If ObservedKeySymbol = "." And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then
				CN = True:CNSX = I+1:MVN = Mid$(In,StartX,I - StartX)
			EndIf
			TI = I:StartX = I+1
		EndIf
	Next
	m\parameters = ReWriteFunctionParameters$(M)
End Function

Function ReWriteFunctionParameters$(M.Functions)
	Local MV.FunctionVariable,tParameters$,Name$
	For MV.FunctionVariable = Each functionVariable
		If MV\Parent = M Then
			Select True
				Case MV\VariableType = 1
					Name = "int "
				Case MV\VariableType = 2
					Name = "float "
				Case MV\VariableType = 3
					Name = "string&amp; "
				Case MV\VariableType = 4
					Name = MV\ClassName + " &amp;"
			End Select
			tParameters = tParameters + Name + MV\Name + ","
		EndIf
	Next
	Return Left$(tParameters,Len(tParameters)-1)
End Function

Function ProcessFunctionCode(MC.FunctionCode)

	Local F.Fields,VariableName$,StartX,MV.FunctionVariable,Name$
	StartX = 1
	If Lower(MC\Code) = "[cpp]" Or Lower(MC\Code) = "[c++]" And incpp = False Then incpp = True:MC\Code = "":MC\Term = True:Return
	If Lower(MC\Code) = "[cpp]" Or Lower(MC\Code) = "[c++]" And incpp = True Then incpp = False:MC\Code = "":MC\Term = True:Return
	If InCpp = True Then MC\Term = True :Return
	For i = 1 To Len(MC\Code)
		If Mid$(MC\Code,i,1) =";" Then 
			MC\Comment = "//"+Right$(MC\Code,Len(MC\Code)-i)
			MC\Code = Left$(MC\code,i-1):Exit
		EndIf
	Next
	
	If Lower(Left$(MC\Code,6)) = "local " Then
		MC\Code = Right$(MC\Code,Len(MC\Code)-6):LC = 1
		For i = 1 To Len(MC\code)
			If Mid$(MC\Code ,i,1) = "," Or i = Len(MC\code) And  Mid$(MC\Code ,i,1)&lt;&gt;";" Then
				Select True
					Case Mid$(MC\Code ,i-1,1) = "%" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "%")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						EndIf
						CreateFunctionVariable(Name,1,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "#" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "#")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "float "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 9
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"float " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"float "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 9
						EndIf
						CreateFunctionVariable(Name,2,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "$" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "$")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "string "+Left$(MC\Code,lc)+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"string " + Name +" = "+Chr(34)+Chr(34)+";"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"string "+Name+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						EndIf
						CreateFunctionVariable(Name,3,MC\Parent)
					Default
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc))
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 6
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-1)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 8
						EndIf
						CreateFunctionVariable(Name,1,MC\Parent)
				End Select
				lc = i
			EndIf
		Next
		MC\Term = True
	EndIf
	If Lower(Left$(MC\Code,4)) = "for " Then

		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		For I = 5 To Len(MC\Code)
			lmc$ = Mid$(MC\Code,i,1)
			If Mid$(MC\Code,i,1) = " "Or  Mid$(MC\Code,i,1) = "="Then VariableName = Mid$(MC\Code,5,i-5):StartX = I:Exit
		Next
		viu = False
		For MV.Functionvariable = Each Functionvariable
			If MV\Parent = MC\Parent And MV\Name = VariableName Or MV\Name = Left$(VariableName,Len(VariableName)-1) Then
				If MV\Declared = True Then
					ExitTrue = False
					For I = StartX+1 To Len(MC\Code)
						LMC$ = Mid$(MC\Code,i,1)
						If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
							Tcode$ = "for ( "+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
							ExitTrue = True:TI = i
						EndIf
						If ExitTrue Then Exit
					Next
					ExitTrue = False
					For i = ti To Len(MC\code)
						If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
						If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
					Next
					
					Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
					For i = n2 To Len(MC\Code)
						If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
					Next
					MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
					MV\Declared = True
					viu = True
				EndIf
			EndIf
		Next
		If viu = False Then
			MV.FunctionVariable = New FunctionVariable
			MV\Parent = MC\Parent
			Select True
				Case Right$(VariableName,1) = "%"
					MV\VariableType = 1:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Case Right$(VariableName,1) = "#"
					MV\VariableType = 2:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Default
					MV\VariableType = 1:MV\Name = VariableName 
			End Select
			If MV\Declared &lt;&gt; True Then
				Select True
					Case MV\VariableType = 1
						Name = "int "
					Case MV\VariableType = 2
						Name = "float "
				End Select
				ExitTrue = False
				For I = StartX+1 To Len(MC\Code)
					LMC$ = Mid$(MC\Code,i,1)
					If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
						Tcode$ = "for ( "+Name+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
						ExitTrue = True:TI = i
					EndIf
					If ExitTrue Then Exit
				Next
				ExitTrue = False
				For i = ti To Len(MC\code)
					If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
					If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
				Next
				
				Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
				For i = n2 To Len(MC\Code)
					If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
				Next
				MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
			EndIf
		EndIf
		MC\Term = True
	EndIf
	If Lower(MC\Code) = "next" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,3)) = "if " Or Lower(Left$(MC\Code,3)) = "if(" Then
		
		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		MC\Code = Left$(MC\Code,3) + "(" + Right$(MC\Code,Len(MC\Code)-3)
		For i = 3 To Len(MC\Code)
			If Mid$(MC\Code,i,1) = "=" And (Mid$(MC\Code,i-1,2) &lt;&gt; "&lt;=" Or Mid$(MC\Code,i-1,2) &lt;&gt; "&gt;="Or Mid$(MC\Code,i-1,2) &lt;&gt; "!=" )Then 
				MC\Code = Left$(MC\Code,i)+"="+Right$(MC\Code,Len(MC\Code)-i):i = i + 1
			Else If Mid$(MC\Code,i,2) = "&lt;&gt;" Then
				MC\Code = Left$(MC\code,i-1)+"!="+Right$(MC\Code,Len(MC\code)-(i+1))
			EndIf
			If i = Len(MC\Code) Then
				If Mid$(MC\Code,i-3,4) = "then" Then MC\Code = Left$(MC\Code,i-4)+"){":MC\Term = True
			EndIf
		Next
	EndIf
	If Lower(MC\Code) = "else" Then MC\Code = "} else {":MC\Term = True
	If Lower(Left$(MC\Code,8)) = "else if " Then MC\Code = "} else if (" + Right$(MC\Code,Len(MC\code)-8)+"){":MC\Term = True
	If Lower(MC\Code) = "endif" Or Lower(MC\Code) = "end if" Then MC\Code = "}":MC\Term = True
	If Lower(MC\Code) = "wend" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,6)) = "while " Then MC\Code = "while (" + Right$(MC\code,Len(MC\Code)-6) +"){":MC\Term=True
	If Lower(MC\code) = "exit" Then MC\Code = "break"
	If Lower(Left$(MC\Code,6)) = "print " Or Lower(Left$(MC\Code,6)) = "print(" Then 
		MC\Code = "cout &lt;&lt; " + Right$(MC\Code,Len(MC\Code)-6)
		For i = 1 To Len(MC\Code)-1
			If Mid$(MC\Code,i,1) = "+" Then MC\Code = Left$(MC\Code,i-1)+" &lt;&lt; "+ Right$(MC\Code,Len(MC\Code)-i):i = i+3
		Next
		MC\Code = MC\Code + " &lt;&lt; endl"
	EndIf
	If MC\Term = False Then MC\Code = Objective_Line$(MC\Code)
End Function

Function ProcessMethodParameters$(M.Method)
	If M\Parameters = "" Then Return
	Local I, StartX=1,MV.MethodVariable,In$,VN$,CN,TN$,CNSX,T.Class,TI,MVN$
	In = M\Parameters
	For I = 1 To Len(In$)

		If TestKeySymbol(Mid$(In,I,1)) Or (I = Len(in)) Then
			If I = Len(In) Then
				VN = Mid$(M\Parameters,StartX,(I) - StartX)
			Else
				VN = Mid$(M\Parameters,StartX,I - StartX)
			EndIf
			If (ObservedKeySymbol &lt;&gt; "." Or CN = True) And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then 
				MV.MethodVariable = New MethodVariable
				MV\Parent = M
				Select True
					Case ObservedKeySymbol = "%"
						MV\VariableType = 1
						MV\Name = VN
					Case ObservedKeySymbol = "#"
						MV\VariableType = 2
						MV\Name =VN
					Case ObservedKeySymbol = "$"
						MV\VariableType = 3
						MV\Name =VN
					Case CN = True
						TN$ = Mid$(In,CNSX,(i+1)- CNSX):CN = False
						For t.class = Each class
							If TN = T\Name Then MV\VariableType = 4:MV\ClassName = T\Name:MV\Name = MVN
						Next
					Default
						MV\VariableType = 1	
						MV\Name = VN
				End Select
				MV\Declared = True
			Else If ObservedKeySymbol = "." And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then
				CN = True:CNSX = I+1:MVN = Mid$(In,StartX,I - StartX)
			EndIf
			TI = I:StartX = I+1
		EndIf
	Next
	Return ReWriteMethodParameters$(M)
End Function

Function ReWriteMethodParameters$(M.Method)
	Local MV.MethodVariable,tParameters$,Name$
	For MV.MethodVariable = Each MethodVariable
		If MV\Parent = M Then
			Select True
				Case MV\VariableType = 1
					Name = "int "
				Case MV\VariableType = 2
					Name = "float "
				Case MV\VariableType = 3
					Name = "string&amp; "
				Case MV\VariableType = 4
					Name = MV\ClassName + " &amp;"
			End Select
			tParameters = tParameters + Name + MV\Name + ","
		EndIf
	Next
	Return Left$(tParameters,Len(tParameters)-1)
End Function

Function ProcessMethodVariables(M.Method)
	Local MC.MethodCode,StartX = 1,MV.MethodVariable,MVUsed,VN$,F.Fields
	For MC.MethodCode = Each MethodCode
		If MC\Parent = M Then
			For i = 1 To Len(MC\Code)
				If TestKeySymbol(Mid$(MC\Code,i,1)) Then
					VN = Mid$(MC\Code,StartX,i - StartX)
					If TestKeyword(VN)= False And VN &lt;&gt; "" Then
						MVUsed = False
						For F.Fields = Each Fields
							If F\ParentClass = M\parentPTR Then
								If VN = F\Name Then MVUsed = True
							EndIf
						Next
						For MV.MethodVariable = Each MethodVariable
							If MV\Name =VN And MV\Parent = M Then MVUsed = True
						Next
						If MVUsed = False Then
							MV.MethodVariable = New MethodVariable
							MV\Parent = M
							Select True
								Case Right$(VN,1) = "%"
									MV\VariableType = 1
									MV\Name = Left$(VN,Len(VN)-1)
								Case Right$(VN,1) = "#"
									MV\VariableType = 2
									MV\Name = Left$(VN,Len(VN)-1)
								Case Right$(VN,1) = "$"
									MV\VariableType = 3
									MV\Name = Left$(VN,Len(VN)-1)
								Default
									MV\VariableType = 1	
									MV\Name = VN
							End Select
						EndIf
					EndIf
					StartX = i + 1
				EndIf
			Next
		EndIf
	Next
End Function

Function ProcessMethodCode(MC.MethodCode)
	Local F.Fields,VariableName$,StartX,MV.MethodVariable,Name$
	StartX = 1
	If MC\Code = "[cpp]" Or MC\Code = "[c++]" And incpp = False Then incpp = True:MC\Code = "":Return
	If MC\Code = "[cpp]" Or MC\Code = "[c++]" And incpp = True Then incpp = False:MC\Code = "":Return
	If InCpp = True Then MC\Term = True :Return
	For i = 1 To Len(MC\code)
		If Mid$(MC\Code,i,1) =";" Then 
			MC\Comment = "//"+Right$(MC\Code,Len(MC\Code)-i)
			MC\Code = Left$(MC\code,i-1):Exit
		EndIf
	Next
	
	If Lower(Left$(MC\Code,6)) = "local " Then
		MC\Code = Right$(MC\Code,Len(MC\Code)-6):LC = 1
		For i = 1 To Len(MC\code)
			If Mid$(MC\Code ,i,1) = "," Or i = Len(MC\code) And  Mid$(MC\Code ,i,1)&lt;&gt;";" Then
				Select True
					Case Mid$(MC\Code ,i-1,1) = "%" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "%")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						EndIf
						CreateMethodVariable(Name,1,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "#" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "#")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "float "+Name+" = 0.0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"float " + Name +" = 0.0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"float "+Name+" = 0.0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						EndIf
						CreateMethodVariable(Name,2,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "$" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "$")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "string "+Left$(MC\Code,lc)+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"string " + Name +" = "+Chr(34)+Chr(34)+";"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"string "+Name+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						EndIf
						CreateMethodVariable(Name,3,MC\Parent)
					Default
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc))
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 6
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-1)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 8
						EndIf
						CreateMethodVariable(Name,1,MC\Parent)
				End Select
				lc = i
			EndIf
		Next
		MC\Term = True
	EndIf
	If Lower(Left$(MC\Code,4)) = "for " Then
		
		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		For I = 5 To Len(MC\Code)
			lmc$ = Mid$(MC\Code,i,1)
			If Mid$(MC\Code,i,1) = " "Or  Mid$(MC\Code,i,1) = "="Then VariableName = Mid$(MC\Code,5,i-5):StartX = I:Exit
		Next
		viu = False
		For MV.methodvariable = Each methodvariable
			If MV\Parent = MC\Parent And MV\Name = VariableName Or MV\Name = Left$(VariableName,Len(VariableName)-1) Then
				If MV\Declared = True Then
					ExitTrue = False
					For I = StartX+1 To Len(MC\Code)
						LMC$ = Mid$(MC\Code,i,1)
						If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
							Tcode$ = "for ( "+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
							ExitTrue = True:TI = i
						EndIf
						If ExitTrue Then Exit
					Next
					ExitTrue = False
					For i = ti To Len(MC\code)
						If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
						If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
					Next
					
					Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
					For i = n2 To Len(MC\Code)
						If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
					Next
					MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
					MV\Declared = True
					viu = True
				EndIf
			EndIf
		Next
		If viu = False Then
			MV.methodVariable = New MethodVariable
			MV\Parent = MC\Parent
			Select True
				Case Right$(VariableName,1) = "%"
					MV\VariableType = 1:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Case Right$(VariableName,1) = "#"
					MV\VariableType = 2:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Default
					MV\VariableType = 1:MV\Name = VariableName 
			End Select
			If MV\Declared &lt;&gt; True Then
				Select True
					Case MV\VariableType = 1
						Name = "int "
					Case MV\VariableType = 2
						Name = "float "
				End Select
				ExitTrue = False
				For I = StartX+1 To Len(MC\Code)
					LMC$ = Mid$(MC\Code,i,1)
					If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
						Tcode$ = "for ( "+Name+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
						ExitTrue = True:TI = i
					EndIf
					If ExitTrue Then Exit
				Next
				ExitTrue = False
				For i = ti To Len(MC\code)
					If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
					If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
				Next
				
				Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
				For i = n2 To Len(MC\Code)
					If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
				Next
				MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
			EndIf
		EndIf
		MC\Term = True
	EndIf
	If Lower(MC\Code) = "next" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,3)) = "if " Or Lower(Left$(MC\Code,3)) = "if(" Then
		
		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		MC\Code = Left$(MC\Code,3) + "(" + Right$(MC\Code,Len(MC\Code)-3)
		For i = 3 To Len(MC\Code)
			If Mid$(MC\Code,i,1) = "=" And (Mid$(MC\Code,i-1,2) &lt;&gt; "&lt;=" Or Mid$(MC\Code,i-1,2) &lt;&gt; "&gt;="Or Mid$(MC\Code,i-1,2) &lt;&gt; "!=" )Then 
				MC\Code = Left$(MC\Code,i)+"="+Right$(MC\Code,Len(MC\Code)-i):i = i + 1
			Else If Mid$(MC\Code,i,2) = "&lt;&gt;" Then
				MC\Code = Left$(MC\code,i-1)+"!="+Right$(MC\Code,Len(MC\code)-(i+1))
			EndIf
			If i = Len(MC\Code) Then
				If Mid$(MC\Code,i-3,4) = "then" Then MC\Code = Left$(MC\Code,i-4)+"){":MC\Term = True
			EndIf
		Next
	EndIf
	If Lower(MC\Code) = "else" Then MC\Code = "} else {":MC\Term = True
	If Lower(Left$(MC\Code,8)) = "else if " Then MC\Code = "} else if (" + Right$(MC\Code,Len(MC\code)-8)+"){":MC\Term = True
	If Lower(MC\Code) = "endif" Or Lower(MC\Code) = "end if" Then MC\Code = "}":MC\Term = True
	If Lower(MC\Code) = "wend" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,6)) = "while " Then MC\Code = "while (" + Right$(MC\code,Len(MC\Code)-6) +"){":MC\Term=True
	If Lower(MC\code) = "exit" Then MC\Code = "break"
	If Lower(Left$(MC\Code,6)) = "print " Or Lower(Left$(MC\Code,6)) = "print(" Then 
		MC\Code = "cout &lt;&lt; " + Right$(MC\Code,Len(MC\Code)-6)
		For i = 1 To Len(MC\Code)-1
			If Mid$(MC\Code,i,1) = "+" Then MC\Code = Left$(MC\Code,i-1)+" &lt;&lt; "+ Right$(MC\Code,Len(MC\Code)-i):i = i+3
		Next
		MC\Code = MC\Code + " &lt;&lt; endl"
	EndIf
End Function

Function CreateMethodVariable(Name$,vt%,Parent.method)
	Local MV.MethodVariable
	MV.MethodVariable = New MethodVariable
	MV\Name = Name
	MV\VariableType = vt
	MV\Parent = Parent
	MV\Declared = True
End Function

Function CreateFunctionVariable(Name$,vt%,Parent.Functions)
	Local MV.FunctionVariable
	MV.FunctionVariable = New FunctionVariable
	MV\Name = Name
	MV\VariableType = vt
	MV\Parent = Parent
	MV\Declared = True
End Function

; Remove Tabs from the OO code if any, keep track of how many there are
Function RemoveTabs()

	Local tc = 0
	
	While Left$(LineIn$,1) = Chr(9)
		tc = tc + 1
		LineIn$ = Right$(LineIn$,Len(LineIn$)-1)
	Wend
	
	Return tc
	
End Function

; Replace Tabs from the OO code so that the readablity is still present.
Function ReplaceTabs$(In$,Tabs)
	
	Local i
	
	For i = 1 To Tabs
		In$ = Chr(9) + In$
	Next
	
	Return In$
	
End Function

; Remove Spaces from the left side of a sting.
Function RemoveSpaces$(in$)
	
	While Left$(in$,1) = " "
		in$ = Right$(in$,Len(in$)-1)
	Wend
	
	Return in$
	
End Function

; Remove Spaces and tabs on the right side(does not keep track of them)
Function RemoveRightSideTabs_Spaces$(In$)
	
	While Right$(In$,1) = " " Or Right$(In$,1) = Chr(9)
		In$ = Left$(In$,Len(In$)-1)
	Wend
	
	Return In$
	
End Function

.KeyWords ;
Data 12	;amount
Data "for","next"
Data "if","end if","endif","else","elseif","else if"
Data "while","wend" ;13
Data "to","then"

Function TestKeyword(code$)
	Restore KeyWords
	Read amt
	For i = 1 To amt
		Read KW$
		kw = Lower(kw)
		If kw = Lower(code) Or kw+" " = Lower(Left$(code,Len(kw)+1)) Or kw+"(" = Lower(Left$(code,Len(kw)+1))Then ObservedKeyWord = kw :Return True
	Next
	Return False
End Function

.KeySymbols
Data 25;amount
Data ";",":","(",")","&lt;"
Data "&gt;","!","~","`","."
Data ",","{","}","[","]"
Data "=","+","-","*","/"
Data "^"," ","#","$","%"

Function TestKeySymbol(in$)
	Restore keysymbols
	Read amt
	If in = Chr(34) Then Return True
	For i = 1 To amt
		Read kw$
		If kw = in Then ObservedKeySymbol = kw:Return True
	Next
	Return False
End Function

.Numbers
Data 10;amount
Data "0","1","2","3","4","5","6","7","8","9"
Function TestNumber(in$)
	Restore numbers
	Read amt
	For i = 1 To amt
		Read kw$
		If Asc(kw) = Asc(in) Then ObservedNumber = kw:Return True
	Next
	Return False
End Function
</textarea> </td></tr><tr ><td class="cell"><pre class="code">...</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> A lot of my coding practicve follows the requirements here, Hopefully I've kept to my own rules enough to give this a try :)<br><br>I'm sure it could be really handy in some cases, though pure C++ could perhaps be a lot better than translated B3D stuff, at least this couyld get most of the groundwork done in any conversions!<br><br>Thanks for sharing MusicianKooL! <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
