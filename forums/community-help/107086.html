<!DOCTYPE html><html lang="en" ><head ><title >need some help with maths (vectors)</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >need some help with maths (vectors)</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >need some help with maths (vectors)</a><br><br>
<a name="1323779"></a>

<a name="1323780"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello, <br><br>Let's assume that i know the position of a point in 3d space (or in 2d space), and i know 2 3d vectors (or 2d vectors) which starts/ends at this point.<br><br>I want to calculate another vector which would be "perpendicular" to the combination of the 2 vectors.<br><br>the formula can be for 2d points and 2d vectors since there is no depth variation (on the z axis)<br><br>An illustration to better understand what i mean :<br><img src="http://rd-stuff.fr/illustration-problem-201610312159.jpg"><br><br>magenta : 3d point (or 2d point)<br>red : 3d vectorA (or 2d vectorA)<br>green : 3d vectorB (or 2d vectorB)<br>blue : 3d vectorC (or 2d vectorC) (&lt;- what i want to find, considering the point and the vectorA and the vectorB)<br><br>any magic formula ?<br><br>Thanks, <br><br></td></tr></table><br>
<a name="1323784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's the definition of the Cross Product.<br>-&gt; a third vector z perpendicular to the plane xy<br><br>you can get the sens of your vector if you observe a simple rule :<br>X goes to Y<br>Y goes to Z<br>Z goes to X<br>X = Y.cross (Z)<br>Y = Z.cross (X)<br>Z = X.cross (Y)<br><br>so:<br>if you want the x axis -&gt; y.z<br>xx# = yy# * zz# - yz# * zy#<br>xy# = yz# * zx# - yx# * zz#<br>xz# = yx# * zy# - yy# * zx#<br><br>if you want the y axis -&gt; z.x<br>yx# = zy# * xz# - zz# * xy#<br>yy# = zz# * xx# - zx# * xz#<br>yz# = zx# * xy# - zy# * xx#<br><br>and if you want the z axis -&gt; x.y<br>zx# = xy# * yz# - xz# * yy#<br>zy# = xz# * yx# - xx# * yz#<br>zz# = xx# * yy# - xy# * yx#<br><br>here you probably search the Y axis (the plane, ZX)<br>if you want for 2d space, just "0" the third axis and the equations becomes very clear ;) <br><br></td></tr></table><br>
<a name="1323817"></a>

<a name="1323818"></a>

<a name="1323819"></a>

<a name="1323820"></a>

<a name="1323821"></a>

<a name="1323832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Bobysait&gt;&gt;what do you mean by "if i want the x axis ? or y axis ? or z axis ?"<br>On the illustration, the point, the vectorA, the vectorB, are 3d points/vectors, but they always have the same z coordinate, so they can be considered 2d points/vectors (with different x,y coordinates).<br><br>i want to find the blue vector which must have x,y properties not only x or not only y...<br><br>can you please clarify what you mean ?<br><br>Thanks, <br><br></td></tr></table><br>
<a name="1323833"></a>

<a name="1323834"></a>

<a name="1323835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> RemiD,<br>You need to calculate the normal of the polygon by calculating the <a href="https://www.opengl.org/wiki/Calculating_a_Surface_Normal" target="_blank">cross product</a> of the 2 vectors that you already have.<br><br>There are many coordinate systems used in 3d. You have the local polygon space, texture space, model space, world space plus many many more.<br><br>For you to achieve your goal here you need to understand that the polygon has its own local x,y and z axis in relation to the polygon face. No matter what direction the polygon is facing within the 3d world this local polygon space doesn't change.<br><br><br>I'll repeat a lot of what you already know ( as your'e almost there ) for the sake of others that maybe don't know the terms and what/how they relate...<br><br>To keep things simple use triangles.<br>You'll have 3 vertices, which we'll call A B and C. It doesn't matter which vertex you name as what, the point is to identify the 3 different vertices.<br><br>Choose any 2 of the vertices, lets choose A and B.<br>Using some simple math take the x,y,z coord of vertex A from the x,y,z coord of vertice B. If vertex A is at 2,2,0 and vertex B is at 6,4,0 then do 6-2 = 4, 4-2 = 2, 0-0 = 0. This new 4,2,0 is called a vector, which is the vector from vertex A to vertex B.<br><br>Now do the same for A to C.<br><br>Now you have 2 vectors, A to B and A to C, these can be thought of ( but inaccurately termed ) as the X,Y vectors. To find the Z vector, ie the direction the polygon is facing ( the polygon normal that's perpendicular to the other 2 vectors ) you need to use the standard Cross Product algo.<br><br>Heres some blitz style pseudo code to help out<br><pre class=code>
' Calculate the cross product of 2 3d vertices

' Three vertices
Local Ax, Ay, Az
Local Bx, By, Bz
Local Cx, Cy, Cz

Local ABx,ABy,ABz    ' This will be a vector from A to B ( B - A )
Local ACx,ACy,ACz    ' This will be a vector from A to C ( C - A )

Local Nx,Ny,Nz       ' This will be the Z ( axis in relation the polygon face ) in other words the 'normal'

ABx = Bx - Ax
ABy = By - Ay
ABz = Bz - Az

ACx = Cx - Ax
ACy = Cy - Ay
ACz = Cz - Az

Nx = ABy * ACz - ABz * ACy
Ny = ABz * ACx - ABx * ACz
Nz = ABx * ACy - ABy * ACx
</pre> <br><br></td></tr></table><br>
<a name="1323836"></a>

<a name="1323837"></a>

<a name="1323838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> @col&gt;&gt;i don't understand why you call the resulting vector (perpendicular to the 2 others vectors) the "normal" of the polygon, because in 3d the normal is a vector perpendicular to a triangle, but after some thought there is also a normal for each vertex which can be calculated by taking into account the normals of the triangles which use this vertex, so it is similar, but this time in 2d.<br><br>Ok i will try the formula, thanks for the explanations ! <br><br></td></tr></table><br>
<a name="1323841"></a>

<a name="1323909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> the resulting vector seems incorrect (or maybe there is an error in my code ?)<br>see :<br>;removed useless code <br><br></td></tr></table><br>
<a name="1323842"></a>

<a name="1323843"></a>

<a name="1323845"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> why you call the resulting vector (perpendicular to the 2 others vectors) the "normal" of the polygon <br></div><br><br>Yes, I can understand the confusion, sorry about that.<br>In this situation the poly normal and vertex normal are exactly the same thing, as this will calculate the vector that's perpendicular to the other 2 vectors. Using that algo, and providing that you don't change the winding order of the vertices in the calculations, then you will get the same result for each vertex if you move the vertices around in the calculation, as long as you don't change their winding order. This is why I referred to it as a polygon normal. All 3 vertices will have the same Z vector. Again, sorry for the confusion.<br><br><div class="quote"> there is also a normal for each vertex which can be calculated by taking into account the normals of the triangles which use this vertex <br></div><br>If you wanted smooth shading across the faces then yes.<br>In the case of a box which would have hard edges then you calculate the vertex normals using the cross product as above. <br><br></td></tr></table><br>
<a name="1323847"></a>

<a name="1323849"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> My Blitz3D is very rusty nowadays and I struggled with your example so I just downloaded the ole champion and threw together this working example to hopefully help visualize things...<br><br><pre class=code>
Graphics3D 800,600,32,2

Local cam = CreateCamera()
PositionEntity cam, 0, 0, -50

Local light = CreateLight()
PositionEntity light, 0, 0, -30

Local pivot = CreatePivot()

Local Ax# = 0.0 : Ay# = 0.0 : Az# = 0.0
Local Bx# = 0.0 : By# = 10.0 : Bz# = 0.0
Local Cx# = 10.0 : Cy# = 0.0 : Cz# = 0.0

Local p0 = CreateSphere(20)
Local p1 = CreateSphere(20)
Local p2 = CreateSphere(20)

PositionEntity p0, Ax, Ay, Az
PositionEntity p1, Bx, By, Bz
PositionEntity p2, Cx, Cy, Cy

EntityParent p0, pivot
EntityParent p1, pivot
EntityParent p2, pivot

; the xaxis bar
Local xaxis = CreateCylinder(16)
ScaleMesh xaxis, 0.2, 5, 0.2
PositionMesh xaxis, 0, 5, 0
EntityColor xaxis, 255, 0, 0

; the yaxis bar
Local yaxis = CreateCylinder(16)
ScaleMesh yaxis, 0.2, 5, 0.2
PositionMesh yaxis, 0, 5, 0
EntityColor yaxis, 0, 255, 0

; the zaxis bar
Local zaxis = CreateCylinder(16)
ScaleMesh zaxis, 0.2, 5, 0.2
PositionMesh zaxis, 0, 5, 0
EntityColor zaxis, 0, 0, 255


Local ang# = 0.0
While Not KeyDown(1)
	Cls
	
	; xaxis bar
	Local CAx# = EntityX( p2, 1 ) - EntityX( p0, 1 )
	Local CAy# = EntityY( p2, 1 ) - EntityY( p0, 1 )
	Local CAz# = EntityZ( p2, 1 ) - EntityZ( p0, 1 )
	AlignToVector xaxis, CAx, CAy, CAz, 2
	
	; yaxis bar
	Local BAx# = EntityX( p1, 1 ) - EntityX( p0, 1 )
	Local BAy# = EntityY( p1, 1 ) - EntityY( p0, 1 )
	Local BAz# = EntityZ( p1, 1 ) - EntityZ( p0, 1 )
	AlignToVector yaxis, BAx, BAy, BAz, 2

	; zaxis bar
	Local Nx# = BAy * CAz - BAz * CAy
	Local Ny# = BAz * CAx - BAx * CAz
	Local Nz# = BAx * CAy - BAy * CAx
	AlignToVector zaxis, Nx, Ny, Nz, 2
	
	
	ang = ang + 1
	RotateEntity pivot, ang * 0.5, ang * 0.75, ang * 0.15
	
	RenderWorld
	Flip
Wend
End
</pre> <br><br></td></tr></table><br>
<a name="1323851"></a>

<a name="1323852"></a>

<a name="1323853"></a>

<a name="1323854"></a>

<a name="1323890"></a>

<a name="1323891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @col&gt;&gt;it seems that your example produces the same result (normal vector) than my example, and if so, that's not the vector that i want to calculate ! and by looking at my illustration i think that you misunderstood (or i badly expressed) what i want.<br><br>i want to calculate a vector which starts at the point where 2 vectors starts/ends and which is at the middle of the angle between the 2 vectors and start at the point and ends away from the the point. (it can be 2d points/vectors or 3d points/vectors, whatever)<br><br>here is the new illustration : <br><img src="http://rd-stuff.fr/illustration-problem-201611011800.jpg"><br><br>i already have a formula to calculate the angle between 2 3d vectors, but i need a way to calculate the properties of the vector which would be in the middle and pointing away from the point (starts at the point and ends away from the point)<br><br>but even if i find a way to calculate the properties of this vector, i see another problem : how to determine if the vector points on one side of the 2 others vectors or on the other side... (inside the triangle ABC or outside the triangle ABC)<br><br><br>well, maybe there is an easiest way to get vertices normals pointing in the direction that i want by using a premade mesh ? i will try... (maybe with the above shape but with front faces and back faces on a closed welded surface ?) <br><br></td></tr></table><br>
<a name="1323855"></a>

<a name="1323856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, you're not looking for a "perpendicular" vector, or you have so hardness to read 3D (there is actually a majority of people that can't deal with perspective view ... maybe you're one of them).<br><br>In the demo, the blue vector is perpendicular to the plane of the red and green.<br><br>Now, I think you should tell us what you want to do instead of a way to do it.<br>-&gt; on your screenshot above, is it the problem you encounter while trying to do a perpendicular vector ? or is it what you're looking for ?<br>(if it's what you're looking for, then it's absolutely not a perpendicular vector but a Vector bisector (in french -&gt; bissectrice), which is obtained by just adding the two vectors and divide by 2.0)<br><br><br>[EDIT]<br><br>Ok, you posted another one while I was typing this one.<br>Definitely, you're not looking for a perpendicular vector, but the bisector.<br><br>V' = (V1+V2)/2<br>Then if it's the opposite of the angle, then multiply by "-1"<br><br><br>Ax = -(Bx + Cx)/2<br>Ay = -(By + Cy)/2<br>Az = -(Bz + Cz)/2 &lt;- this one is "0" in 2D <br><br></td></tr></table><br>
<a name="1323857"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>maybe with the above shape but with front faces and back faces on a closed welded surface ?)<br> <br></div><br>no ! <br><br></td></tr></table><br>
<a name="1323858"></a>

<a name="1323859"></a>

<a name="1323862"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Definitely, you're not looking for a perpendicular vector, but the bisector.<br> <br></div><br>oh sorry, i tried to explain but the terms i used where what i thought it was not necessarily what they mean in maths...<br><br><br>@Bobysait&gt;&gt;thanks, i will try this formula. <br><br></td></tr></table><br>
<a name="1323860"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you're doing it with triangles, then there is no need to check for the sens if you always use the TriangleVertex order to get your vectors.<br><br><pre class=code>
For t = 0 To CountTriangles(surf)-1
 v0 = TriangleVertex(surf, t, 0)
 v1 = TriangleVertex(surf, t, 1)
 v2 = TriangleVertex(surf, t, 2)
 ; v1 is probably the point to "project"
 ax# = VertexX(surf, v0)
 ay# = VertexY(surf, v0)
 az# = VertexZ(surf, v0)
 bx# = VertexX(surf, v1)
 by# = VertexY(surf, v1)
 bz# = VertexZ(surf, v1)
 cx# = VertexX(surf, v2)
 cy# = VertexY(surf, v2)
 cz# = VertexZ(surf, v2)
 ; AB = A to B
 abx# = bx-ax
 aby# = by-ay
 abz# = bz-az
 ; CB = C to B
 cbx# = bx-cx
 cby# = by-cy
 cbz# = bz-cz
 ; the "projected" vector
 vx# = (abx+bcx) * 0.5
 vy# = (aby+bcy) * 0.5
 vz# = (abz+bcz) * 0.5
 ; if you want the projected "point" and not only the "vector", add the position of v1
 px# = bx+vx
 py# = by+vy
 pz# = bz+vz
Next
</pre> <br><br></td></tr></table><br>
<a name="1323875"></a>

<a name="1323876"></a>

<a name="1323877"></a>

<a name="1323878"></a>

<a name="1323879"></a>

<a name="1323880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay...I'm late to the party but let me try and visualise what you are describing (I looked at the diagram above to get an idea)...<br><br>You have a vector AB and a vector CB and you want to find a vector of any length that is in the direction midway between the two vectors.<br><br>So basically what you should do is this:<br><br>normalize vectors AB and CB to get two unit vectors (pure direction, magnitude 1).<br><br>Add the two unit vectors together and call it D<br><br>normalize vector D....it is now also a unit vector pointing in the direction midway between vectors AB and CB but with length 1.<br><br>scalar multiply unit vector D to the length you wish it to be.<br><br>Note - this will work for all vectors as long as the two vectors are not 180 degrees apart (ie opposite directions) as that will return a zero result for direction as the vectors cancel each other out.<br><br>Edit: Additional:<br>I recognise that you may or may not know the terms for vector mathematics (I studied it at university in the mid 90s) so I will describe in simple terms some of the words I used in case you have different understandings:<br><br>'normalize a vector' - divide it by its length<br>'unit vector' - a vector of length 1 unit - this may be considered to be a vector which is purely directional as it has a magnitude of 1.<br><br>'scalar multiply' - multiply all coefficients (x,y,z) of the vector by a single number - this has the effect of changing the magnitude of the vector but not changing the direction.<br><br>Edit 2 - bobysait is right about what you want - you want to bisect the angle between two vectors not find the perpendicular vector. perpendicular suggests that the angle is 90 degrees between the vectors and may be found by either using the cross product between two vectors and/or finding a pair of vectors for which the dot product is zero.<br><br>'cross product' = a cross b = c, typically equals this:<br>cx = ay*bz - by*az<br>cy = - ax*bz + bx*az<br>cz = ax*by - bx * ay<br>Gives a vector which is perpendicular (ninety degrees) to the original two vectors of length |a||b| sin (theta)<br>Cross product is zero when the vectors have zero angle between them.<br><br><br>'dot product' = a dot b = scalar value<br>ax * bx + ay * by + az * cz<br>Gives a value which is equal to |a| |b| cos(theta)<br>Dot product is zero when the vectors have 90 degrees between them.<br>Note the dot product is very useful for determining if an object is ahead or behind of another object since cos(theta) is goes close to 1 when an object is ahead of it, close to -1 when an object is behind it, and close to zero when an object is at right angles to it.<br><br>where |a| = magnitude of a, |b| = magnitude of b, theta is the angle between them. <br><br></td></tr></table><br>
<a name="1323895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Flanker</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> If I understood well, it's very simple :<br><br><img src="https://i.imgbox.com/hfwviqW2.png"><br><br>1 - Input vectors<br>2 - Normalize the vectors so they have the same lenght<br>3 - You have an isoceles triangle, so the point in the middle of the third side gives you two equals angles.<br>4 - Invert the blue vector to get you normal, and eventually you'll have to normalize it. <br><br></td></tr></table><br>
<a name="1323896"></a>

<a name="1323897"></a>

<a name="1323901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Flanker&gt;&gt;<br>i think that i have found another simpler approach using the custom calculated vertices normals of a premade mesh.<br><br>however you method is smart ! thank you, i will try it !<br>(you can skip step 4 by directly calculating the normalised vector DA) <br><br></td></tr></table><br>
<a name="1323899"></a>

<a name="1323900"></a>

<a name="1327194"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> my other approach with a procedure to custom calculate the vertices normals of a premade mesh depending on the normals of the triangles which use each vertex, partly produces correct normals and partly produces incorrect normals, and i have no idea what is the error or if there is any, because all seems correct...<br><img src="http://rd-stuff.fr/pumpkin-shape-debug-glowrects-vertices-normals-201611021513.jpg"><br><br>ok, now i am going to try the method explained by Flanker... this should work... <br><br></td></tr></table><br>
<a name="1323902"></a>

<a name="1323903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Flanker</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> The bisector formula posted by bobysait should also work and is even simpler. <br><br></td></tr></table><br>
<a name="1323905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Part of this is easy and part is difficult/impossible. I say impossible because the problem is still not clearly defined.<br><br>So let's try to nail this down. A closed polygon in 2d has an inside and an outside. The same is true in 3d if all points are restricted to some plane. But the general 3d case has no such easy distinction.<br><br>So let's concentrate on 2d. We have a point and two vectors, considered to be a point and two edges of some polygon. Looking only at the point and two edges we consider them to be a vertex and two edges of a triangle. The problem of an "angle bisector" was solved earlier in this thread. Orienting the vector to point to the outside of the triangle was also easily done.<br><br>But we still don't know if this points to the interior or exterior of the larger polygon. Farther up this page, in post #9, there is a polygon that looks like the grin on a Halloween pumpkin. If you try the triangle method on that you sometimes get a bisecting vector pointing into the polygon and other times pointing out.<br><br>But the edges should be oriented consistently. Imagine the polygon is drawn on the floor. And let's say the edge vectors are all oriented so that as you walk along the polygon the interior is on your left. That tells you how to orient the angle bisector. You want it to point to the outside, i.e. to your right.<br><br>There is a simple "dot product" test to tell if a point is to the left or right of a vector ( edge of 2d polygon ), which solves the problem. <br><br></td></tr></table><br>
<a name="1323906"></a>

<a name="1323907"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> in any case, there will be too many vectors calculated... those who are oriented outwards the shape (what i want) and also those who are oriented inwards the shape (what i don't want)<br><br><br>i have another idea to achieve what i want, it is a ugly manual workaround but it should work well... <br><br></td></tr></table><br>
<a name="1323908"></a>

<a name="1323910"></a>

<a name="1323911"></a>

<a name="1323912"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Flanker's method in code : (seems to work well)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D(640,480,32,2)

SeedRnd(MilliSecs())

;Input
Global MX%
Global MY%
Global MXDiff%
Global MYDiff%

Global Camera = CreateCamera()
CameraViewport(Camera,0,0,GraphicsWidth(),GraphicsHeight())
CameraRange(Camera,0.1,100)
CameraClsColor(Camera,000,000,000)

;InteractionMode
Global InteractionMode%
Const C2D% = 1
Const C3D% = 2
InitializeInteractionMode()

;Ghost
Global GhostRoot
Global GhostRootYaw#
Global GhostEyes
Global GhostEyesPitch#
BuildGhost()
InitializeGhost()
 
A_x# = Rnd(-3,3) : A_y# = Rnd(-3,3) : A_z# = 0
B_x# = Rnd(-3,3) : B_y# = Rnd(-3,3) : B_z# = 0
C_x# = Rnd(-3,3) : C_y# = Rnd(-3,3) : C_z# = 0
ABV_x# = B_x - A_x : ABV_y# = B_y - A_y : ABV_z# = B_z - A_z
ABLength# = Sqr( ( ABV_x * ABV_x ) + ( ABV_y * ABV_y ) + ( ABV_z * ABV_z ) )
ABN_x# = ABV_x/ABLength : ABN_y# = ABV_y/ABLength : ABN_z# = ABV_z/ABLength
ACV_x# = C_x - A_x : ACV_y# = C_y - A_y : ACV_z# = C_z - A_z
ACLength# = Sqr( ( ACV_x * ACV_x ) + ( ACV_y * ACV_y ) + ( ACV_z * ACV_z ) )
ACN_x# = ACV_x/ACLength : ACN_y# = ACV_y/ACLength : ACN_z# = ACV_z/ACLength
D_x# = A_x + ABN_x : D_y# = A_y + ABN_y : D_z# = A_z + ABN_z
E_x# = A_x + ACN_x : E_y# = A_y + ACN_y : E_z# = A_z + ACN_z
DEV_x# = E_x - D_x : DEV_y# = E_y - D_y : DEV_z# = E_z - D_z
F_x# = D_x + DEV_x/2 : F_y# = D_y + DEV_y/2 : F_z# = D_z + DEV_z/2 
FAV_x# = A_x - F_x : FAV_y# = A_y - F_y : FAV_z# = A_z - F_z
FALength# = Sqr( ( FAV_x * FAV_x ) + ( FAV_y * FAV_y ) + ( FAV_z * FAV_z ) )
MiddleN_x# = FAV_x/FALength : MiddleN_y# = FAV_y/FALength : MiddleN_z# = FAV_z/FALength

Global APoint = CreateCube() 
ScaleMesh(APoint,0.02/2,0.02/2,0.02/2)
EntityColor(APoint,000,000,255) ;lightblue
EntityFX(APoint,1)
PositionEntity(APoint,A_x,A_y,A_z,True)

Global BPoint = CreateCube() 
ScaleMesh(BPoint,0.02/2,0.02/2,0.02/2)
EntityColor(BPoint,255,000,000) ;lightred
EntityFX(BPoint,1)
PositionEntity(BPoint,B_x,B_y,B_z,True)

Global CPoint = CreateCube() 
ScaleMesh(CPoint,0.02/2,0.02/2,0.02/2)
EntityColor(CPoint,000,255,000) ;lightgreen
EntityFX(CPoint,1)
PositionEntity(CPoint,C_x,C_y,C_z,True)

Global DPoint = CreateCube() 
ScaleMesh(DPoint,0.02/2,0.02/2,0.02/2)
EntityColor(DPoint,128,000,000) ;mediumred
EntityFX(DPoint,1)
PositionEntity(DPoint,D_x,D_y,D_z,True)

Global EPoint = CreateCube() 
ScaleMesh(EPoint,0.02/2,0.02/2,0.02/2)
EntityColor(EPoint,000,128,000) ;mediumgreen
EntityFX(EPoint,1)
PositionEntity(EPoint,E_x,E_y,E_z,True)

Global FPoint = CreateCube() 
ScaleMesh(FPoint,0.02/2,0.02/2,0.02/2)
EntityColor(FPoint,255,255,000) ;lightyellow
EntityFX(FPoint,1)
PositionEntity(FPoint,F_x,F_y,F_z,True)

Global ABVector = CreateCylinder(8)
ScaleMesh(ABVector,0.01/2,1.0/2,0.01/2)
PositionMesh(ABVector,0,1.0/2,0)
RotateMesh(ABVector,90,0,0)
EntityColor(ABVector,255,000,000) ;lightred
EntityFX(ABVector,1)
PositionEntity(ABVector,A_x,A_y,A_z,True)
ScaleEntity(ABVector,1,1,ABLength)
AlignToVector(ABVector,ABV_x,ABV_y,ABV_z,3,1.0)

Global ACVector = CreateCylinder(8)
ScaleMesh(ACVector,0.01/2,1.0/2,0.01/2)
PositionMesh(ACVector,0,1.0/2,0)
RotateMesh(ACVector,90,0,0)
EntityColor(ACVector,000,255,000) ;lightgreen
EntityFX(ACVector,1)
PositionEntity(ACVector,A_x,A_y,A_z,True)
ScaleEntity(ACVector,1,1,ACLength)
AlignToVector(ACVector,ACV_x,ACV_y,ACV_z,3,1.0)

Global MiddleVector = CreateCylinder(8)
ScaleMesh(MiddleVector,0.01/2,1.0/2,0.01/2)
PositionMesh(MiddleVector,0,1.0/2,0)
RotateMesh(MiddleVector,90,0,0)
EntityColor(MiddleVector,255,255,000) ;lightyellow
EntityFX(MiddleVector,1)
PositionEntity(MiddleVector,A_x,A_y,A_z,True)
ScaleEntity(MiddleVector,1,1,1.0)
AlignToVector(MiddleVector,MiddleN_x,MiddleN_y,MiddleN_z,3,1.0)

;DLight
Global DLight = CreateLight(1)
LightColor(DLight,192,192,192)
PositionEntity(DLight,50,1000,-1000,True)
RotateEntity(DLight,45,0,0,True)

AmbientLight(019,019,019)

PositionEntity(GhostRoot,0,1.65,-5,True)

Global MainLoopTimer = CreateTimer(30)

Main()

End()

Function Main()

 Repeat

  MainLoopMsStart% = MilliSecs()

  GetInput()

  UpdateInteractionMode()
  If( InteractionMode = C2D )
   ;
  Else If( InteractionMode = C3D )
   UpdateGhost() 	   
  EndIf

  If( KeyHit(57)=1 )
   A_x# = Rnd(-3,3) : A_y# = Rnd(-3,3) : A_z# = 0
   B_x# = Rnd(-3,3) : B_y# = Rnd(-3,3) : B_z# = 0
   C_x# = Rnd(-3,3) : C_y# = Rnd(-3,3) : C_z# = 0
   ABV_x# = B_x - A_x : ABV_y# = B_y - A_y : ABV_z# = B_z - A_z
   ABLength# = Sqr( ( ABV_x * ABV_x ) + ( ABV_y * ABV_y ) + ( ABV_z * ABV_z ) )
   ABN_x# = ABV_x/ABLength : ABN_y# = ABV_y/ABLength : ABN_z# = ABV_z/ABLength
   ACV_x# = C_x - A_x : ACV_y# = C_y - A_y : ACV_z# = C_z - A_z
   ACLength# = Sqr( ( ACV_x * ACV_x ) + ( ACV_y * ACV_y ) + ( ACV_z * ACV_z ) )
   ACN_x# = ACV_x/ACLength : ACN_y# = ACV_y/ACLength : ACN_z# = ACV_z/ACLength
   D_x# = A_x + ABN_x : D_y# = A_y + ABN_y : D_z# = A_z + ABN_z
   E_x# = A_x + ACN_x : E_y# = A_y + ACN_y : E_z# = A_z + ACN_z
   DEV_x# = E_x - D_x : DEV_y# = E_y - D_y : DEV_z# = E_z - D_z
   F_x# = D_x + DEV_x/2 : F_y# = D_y + DEV_y/2 : F_z# = D_z + DEV_z/2 
   FAV_x# = A_x - F_x : FAV_y# = A_y - F_y : FAV_z# = A_z - F_z
   FALength# = Sqr( ( FAV_x * FAV_x ) + ( FAV_y * FAV_y ) + ( FAV_z * FAV_z ) )
   MiddleN_x# = FAV_x/FALength : MiddleN_y# = FAV_y/FALength : MiddleN_z# = FAV_z/FALength
   PositionEntity(APoint,A_x,A_y,A_z,True)
   PositionEntity(BPoint,B_x,B_y,B_z,True)
   PositionEntity(CPoint,C_x,C_y,C_z,True)
   PositionEntity(DPoint,D_x,D_y,D_z,True)
   PositionEntity(EPoint,E_x,E_y,E_z,True)
   PositionEntity(FPoint,F_x,F_y,F_z,True)
   PositionEntity(ABVector,A_x,A_y,A_z,True)
   ScaleEntity(ABVector,1,1,ABLength)
   AlignToVector(ABVector,ABV_x,ABV_y,ABV_z,3,1.0)
   PositionEntity(ACVector,A_x,A_y,A_z,True)
   ScaleEntity(ACVector,1,1,ACLength)
   AlignToVector(ACVector,ACV_x,ACV_y,ACV_z,3,1.0)
   PositionEntity(MiddleVector,A_x,A_y,A_z,True)
   ScaleEntity(MiddleVector,1,1,1.0)
   AlignToVector(MiddleVector,MiddleN_x,MiddleN_y,MiddleN_z,3,1.0)
  EndIf

  PositionRotateEntityLikeOtherEntity(Camera,GhostEyes)

  WireFrame(False)
  If( KeyDown(2)=1 )
   WireFrame(True)
  EndIf

  SetBuffer(BackBuffer())
  RenderWorld()

  Color(255,255,255)
  CText("Tris = "+TrisRendered(),0,0) 
  CText("FPS = "+FPS,0,15)
  
  ;Flip(1)
  WaitTimer(MainLoopTimer)
  VWait():Flip(False)

  MainLoopMsTime = MilliSecs() - MainLoopMsStart
  If( MainLoopMsTime &lt; 1 )
   MainLoopMsTime = 1
  EndIf

  FPS% = 1000.0/MainLoopMsTime

 Until( KeyDown(1)=1 )

End Function

Function CText(TextStr$,PX%,PY%)
 Text(PX,PY,TextStr,False,False)
End Function

Function PositionEntityLikeOtherEntity(Entity,OEntity)
 PositionEntity(Entity,EntityX(OEntity,True),EntityY(OEntity,True),EntityZ(OEntity,True),True)
End Function

Function RotateEntityLikeOtherEntity(Entity,OEntity)
 RotateEntity(Entity,EntityPitch(OEntity,True),EntityYaw(OEntity,True),EntityRoll(OEntity,True),True)
End Function

Function PositionRotateEntityLikeOtherEntity(Entity,OEntity)
 PositionEntity(Entity,EntityX(OEntity,True),EntityY(OEntity,True),EntityZ(OEntity,True),True)
 RotateEntity(Entity,EntityPitch(OEntity,True),EntityYaw(OEntity,True),EntityRoll(OEntity,True),True)
End Function

Function InitializeInteractionMode()
 InteractionMode = C3D
 HidePointer()
End Function

Function UpdateInteractionMode() 

 If( KeyHit(15)=1 )
  If( InteractionMode = C2D )
   InteractionMode = C3D
   HidePointer()
  Else If( InteractionMode = C3D )
   InteractionMode = C2D
   ShowPointer()
  EndIf
 EndIf

End Function

Function BuildGhost()
 
 GhostRoot = CreatePivot()

 GhostEyes = CreatePivot()
 PositionRotateEntityLikeOtherEntity(GhostEyes,GhostRoot)
 EntityParent(GhostEyes,GhostRoot,True)

End Function

Function InitializeGhost()
 PositionEntity(GhostRoot,0,0,-3,True)
End Function

Function UpdateGhost()

 MoveMouse(GraphicsWidth()/2,GraphicsHeight()/2)
 GhostRootYaw = GhostRootYaw - Float(MXDiff)/10
 RotateEntity(GhostRoot,0,GhostRootYaw,0,False)
 GhostEyesPitch = GhostEyesPitch + Float(MYDiff)/10
 If( GhostEyesPitch &lt; -89 )
  GhostEyesPitch = -89
 Else If( GhostEyesPitch &gt; 89 )
  GhostEyesPitch = 89
 EndIf
 RotateEntity(GhostEyes,GhostEyesPitch,0,0,False)

 If( KeyDown(42) = 0 And KeyDown(29) = 0 )
  Speed# = 0.1
 Else If( KeyDown(42) = 1 And KeyDown(29) = 0 )
  Speed# = 1
 Else If( KeyDown(42) = 0 And KeyDown(29) = 1 )
  Speed# = 0.01
 EndIf

 If( KeyDown(17)=1 Or MouseDown(1)=1 )
  MoveEntity(GhostRoot,0,0,Speed)
 Else If( KeyDown(31)=1 Or MouseDown(2)=1 )
  MoveEntity(GhostRoot,0,0,-Speed)
 EndIf
 If( KeyDown(30)=1 )
  MoveEntity(GhostRoot,-Speed,0,0)
 Else If( KeyDown(32)=1 )
  MoveEntity(GhostRoot,Speed,0,0)
 EndIf
 If( KeyDown(16)=1 )
  MoveEntity(GhostRoot,0,-Speed,0)
 Else If( KeyDown(18)=1 )
  MoveEntity(GhostRoot,0,Speed,0)
 EndIf
 
End Function

Function GetInput()

 MX = MouseX()
 MY = MouseY()

 MXDiff = MouseXSpeed()
 MYDiff = MouseYSpeed()

End Function
</textarea><br>(press space to randomly position A,B,C and calculate the stuff) <br><br></td></tr></table><br>
<a name="1323913"></a>

<a name="1323914"></a>

<a name="1323923"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Matty's method in code : (seems to work well)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D(640,480,32,2)

SeedRnd(MilliSecs())

;Input
Global MX%
Global MY%
Global MXDiff%
Global MYDiff%

Global Camera = CreateCamera()
CameraViewport(Camera,0,0,GraphicsWidth(),GraphicsHeight())
CameraRange(Camera,0.1,100)
CameraClsColor(Camera,000,000,000)

;InteractionMode
Global InteractionMode%
Const C2D% = 1
Const C3D% = 2
InitializeInteractionMode()

;Ghost
Global GhostRoot
Global GhostRootYaw#
Global GhostEyes
Global GhostEyesPitch#
BuildGhost()
InitializeGhost()

A_x# = Rnd(-3,3) : A_y# = Rnd(-3,3) : A_z# = 0
B_x# = Rnd(-3,3) : B_y# = Rnd(-3,3) : B_z# = 0
C_x# = Rnd(-3,3) : C_y# = Rnd(-3,3) : C_z# = 0
ABV_x# = B_x - A_x : ABV_y# = B_y - A_y : ABV_z# = B_z - A_z
ABLength# = Sqr( ( ABV_x * ABV_x ) + ( ABV_y * ABV_y ) + ( ABV_z * ABV_z ) )
ABN_x# = ABV_x/ABLength : ABN_y# = ABV_y/ABLength : ABN_z# = ABV_z/ABLength
ACV_x# = C_x - A_x : ACV_y# = C_y - A_y : ACV_z# = C_z - A_z
ACLength# = Sqr( ( ACV_x * ACV_x ) + ( ACV_y * ACV_y ) + ( ACV_z * ACV_z ) )
ACN_x# = ACV_x/ACLength : ACN_y# = ACV_y/ACLength : ACN_z# = ACV_z/ACLength
MiddleV_x# = ABN_x + ACN_x : MiddleV_y# = ABN_y + ACN_y : MiddleV_z# = ABN_z + ACN_z  
MiddleLength# = Sqr( ( MiddleV_x * MiddleV_x ) + ( MiddleV_y * MiddleV_y ) + ( MiddleV_z * MiddleV_z ) )
MiddleN_x# = MiddleV_x/MiddleLength*-1 : MiddleN_y# = MiddleV_y/MiddleLength*-1 : MiddleN_z# = MiddleV_z/MiddleLength*-1

Global APoint = CreateCube() 
ScaleMesh(APoint,0.02/2,0.02/2,0.02/2)
EntityColor(APoint,000,000,255) ;lightblue
EntityFX(APoint,1)
PositionEntity(APoint,A_x,A_y,A_z,True)

Global BPoint = CreateCube() 
ScaleMesh(BPoint,0.02/2,0.02/2,0.02/2)
EntityColor(BPoint,255,000,000) ;lightred
EntityFX(BPoint,1)
PositionEntity(BPoint,B_x,B_y,B_z,True)

Global CPoint = CreateCube() 
ScaleMesh(CPoint,0.02/2,0.02/2,0.02/2)
EntityColor(CPoint,000,255,000) ;lightgreen
EntityFX(CPoint,1)
PositionEntity(CPoint,C_x,C_y,C_z,True)

Global ABVector = CreateCylinder(8)
ScaleMesh(ABVector,0.01/2,1.0/2,0.01/2)
PositionMesh(ABVector,0,1.0/2,0)
RotateMesh(ABVector,90,0,0)
EntityColor(ABVector,255,000,000) ;lightred
EntityFX(ABVector,1)
PositionEntity(ABVector,A_x,A_y,A_z,True)
ScaleEntity(ABVector,1,1,ABLength)
AlignToVector(ABVector,ABV_x,ABV_y,ABV_z,3,1.0)

Global ACVector = CreateCylinder(8)
ScaleMesh(ACVector,0.01/2,1.0/2,0.01/2)
PositionMesh(ACVector,0,1.0/2,0)
RotateMesh(ACVector,90,0,0)
EntityColor(ACVector,000,255,000) ;lightgreen
EntityFX(ACVector,1)
PositionEntity(ACVector,A_x,A_y,A_z,True)
ScaleEntity(ACVector,1,1,ACLength)
AlignToVector(ACVector,ACV_x,ACV_y,ACV_z,3,1.0)

Global MiddleVector = CreateCylinder(8)
ScaleMesh(MiddleVector,0.01/2,1.0/2,0.01/2)
PositionMesh(MiddleVector,0,1.0/2,0)
RotateMesh(MiddleVector,90,0,0)
EntityColor(MiddleVector,255,255,000) ;lightyellow
EntityFX(MiddleVector,1)
PositionEntity(MiddleVector,A_x,A_y,A_z,True)
ScaleEntity(MiddleVector,1,1,1.0)
AlignToVector(MiddleVector,MiddleN_x,MiddleN_y,MiddleN_z,3,1.0)

;DLight
Global DLight = CreateLight(1)
LightColor(DLight,192,192,192)
PositionEntity(DLight,50,1000,-1000,True)
RotateEntity(DLight,45,0,0,True)

AmbientLight(019,019,019)

PositionEntity(GhostRoot,0,1.65,-5,True)

Global MainLoopTimer = CreateTimer(30)

Main()

End()

Function Main()

 Repeat

  MainLoopMsStart% = MilliSecs()

  GetInput()

  UpdateInteractionMode()
  If( InteractionMode = C2D )
   ;
  Else If( InteractionMode = C3D )
   UpdateGhost() 	   
  EndIf

  If( KeyHit(57)=1 )
   A_x# = Rnd(-3,3) : A_y# = Rnd(-3,3) : A_z# = 0
   B_x# = Rnd(-3,3) : B_y# = Rnd(-3,3) : B_z# = 0
   C_x# = Rnd(-3,3) : C_y# = Rnd(-3,3) : C_z# = 0
   ABV_x# = B_x - A_x : ABV_y# = B_y - A_y : ABV_z# = B_z - A_z
   ABLength# = Sqr( ( ABV_x * ABV_x ) + ( ABV_y * ABV_y ) + ( ABV_z * ABV_z ) )
   ABN_x# = ABV_x/ABLength : ABN_y# = ABV_y/ABLength : ABN_z# = ABV_z/ABLength
   ACV_x# = C_x - A_x : ACV_y# = C_y - A_y : ACV_z# = C_z - A_z
   ACLength# = Sqr( ( ACV_x * ACV_x ) + ( ACV_y * ACV_y ) + ( ACV_z * ACV_z ) )
   ACN_x# = ACV_x/ACLength : ACN_y# = ACV_y/ACLength : ACN_z# = ACV_z/ACLength
   MiddleV_x# = ABN_x + ACN_x : MiddleV_y# = ABN_y + ACN_y : MiddleV_z# = ABN_z + ACN_z  
   MiddleLength# = Sqr( ( MiddleV_x * MiddleV_x ) + ( MiddleV_y * MiddleV_y ) + ( MiddleV_z * MiddleV_z ) )
   MiddleN_x# = MiddleV_x/MiddleLength*-1 : MiddleN_y# = MiddleV_y/MiddleLength*-1 : MiddleN_z# = MiddleV_z/MiddleLength*-1
   PositionEntity(APoint,A_x,A_y,A_z,True)
   PositionEntity(BPoint,B_x,B_y,B_z,True)
   PositionEntity(CPoint,C_x,C_y,C_z,True)
   PositionEntity(ABVector,A_x,A_y,A_z,True)
   ScaleEntity(ABVector,1,1,ABLength)
   AlignToVector(ABVector,ABV_x,ABV_y,ABV_z,3,1.0)
   PositionEntity(ACVector,A_x,A_y,A_z,True)
   ScaleEntity(ACVector,1,1,ACLength)
   AlignToVector(ACVector,ACV_x,ACV_y,ACV_z,3,1.0)
   PositionEntity(MiddleVector,A_x,A_y,A_z,True)
   ScaleEntity(MiddleVector,1,1,1.0)
   AlignToVector(MiddleVector,MiddleN_x,MiddleN_y,MiddleN_z,3,1.0)
  EndIf

  PositionRotateEntityLikeOtherEntity(Camera,GhostEyes)

  WireFrame(False)
  If( KeyDown(2)=1 )
   WireFrame(True)
  EndIf

  SetBuffer(BackBuffer())
  RenderWorld()

  Color(255,255,255)
  CText("Tris = "+TrisRendered(),0,0) 
  CText("FPS = "+FPS,0,15)
  
  ;Flip(1)
  WaitTimer(MainLoopTimer)
  VWait():Flip(False)

  MainLoopMsTime = MilliSecs() - MainLoopMsStart
  If( MainLoopMsTime &lt; 1 )
   MainLoopMsTime = 1
  EndIf

  FPS% = 1000.0/MainLoopMsTime

 Until( KeyDown(1)=1 )

End Function

Function CText(TextStr$,PX%,PY%)
 Text(PX,PY,TextStr,False,False)
End Function

Function PositionEntityLikeOtherEntity(Entity,OEntity)
 PositionEntity(Entity,EntityX(OEntity,True),EntityY(OEntity,True),EntityZ(OEntity,True),True)
End Function

Function RotateEntityLikeOtherEntity(Entity,OEntity)
 RotateEntity(Entity,EntityPitch(OEntity,True),EntityYaw(OEntity,True),EntityRoll(OEntity,True),True)
End Function

Function PositionRotateEntityLikeOtherEntity(Entity,OEntity)
 PositionEntity(Entity,EntityX(OEntity,True),EntityY(OEntity,True),EntityZ(OEntity,True),True)
 RotateEntity(Entity,EntityPitch(OEntity,True),EntityYaw(OEntity,True),EntityRoll(OEntity,True),True)
End Function

Function Distance2D#(PAX#,PAZ#,PBX#,PBZ#)

 VX# = PBX - PAX
 VZ# = PBZ - PAZ
 Distance2D# = Sqr((VX*VX)+(VZ*VZ))
 Return Distance2D

End Function

Function Distance3D#(PAX#,PAY#,PAZ#,PBX#,PBY#,PBZ#)

 VX# = PBX - PAX
 VY# = PBY - PAY
 VZ# = PBZ - PAZ
 Distance3D# = Sqr((VX*VX)+(VY*VY)+(VZ*VZ))
 Return Distance3D

End Function

Function InitializeInteractionMode()
 InteractionMode = C3D
 HidePointer()
End Function

Function UpdateInteractionMode() 

 If( KeyHit(15)=1 )
  If( InteractionMode = C2D )
   InteractionMode = C3D
   HidePointer()
  Else If( InteractionMode = C3D )
   InteractionMode = C2D
   ShowPointer()
  EndIf
 EndIf

End Function

Function BuildGhost()
 
 GhostRoot = CreatePivot()

 GhostEyes = CreatePivot()
 PositionRotateEntityLikeOtherEntity(GhostEyes,GhostRoot)
 EntityParent(GhostEyes,GhostRoot,True)

End Function

Function InitializeGhost()
 PositionEntity(GhostRoot,0,0,-3,True)
End Function

Function UpdateGhost()

 MoveMouse(GraphicsWidth()/2,GraphicsHeight()/2)
 GhostRootYaw = GhostRootYaw - Float(MXDiff)/10
 RotateEntity(GhostRoot,0,GhostRootYaw,0,False)
 GhostEyesPitch = GhostEyesPitch + Float(MYDiff)/10
 If( GhostEyesPitch &lt; -89 )
  GhostEyesPitch = -89
 Else If( GhostEyesPitch &gt; 89 )
  GhostEyesPitch = 89
 EndIf
 RotateEntity(GhostEyes,GhostEyesPitch,0,0,False)

 If( KeyDown(42) = 0 And KeyDown(29) = 0 )
  Speed# = 0.1
 Else If( KeyDown(42) = 1 And KeyDown(29) = 0 )
  Speed# = 1
 Else If( KeyDown(42) = 0 And KeyDown(29) = 1 )
  Speed# = 0.01
 EndIf

 If( KeyDown(17)=1 Or MouseDown(1)=1 )
  MoveEntity(GhostRoot,0,0,Speed)
 Else If( KeyDown(31)=1 Or MouseDown(2)=1 )
  MoveEntity(GhostRoot,0,0,-Speed)
 EndIf
 If( KeyDown(30)=1 )
  MoveEntity(GhostRoot,-Speed,0,0)
 Else If( KeyDown(32)=1 )
  MoveEntity(GhostRoot,Speed,0,0)
 EndIf
 If( KeyDown(16)=1 )
  MoveEntity(GhostRoot,0,-Speed,0)
 Else If( KeyDown(18)=1 )
  MoveEntity(GhostRoot,0,Speed,0)
 EndIf
 
End Function

Function GetInput()

 MX = MouseX()
 MY = MouseY()

 MXDiff = MouseXSpeed()
 MYDiff = MouseYSpeed()

End Function
</textarea><br>(press space to randomly position A,B,C and calculate the stuff) <br><br></td></tr></table><br>
<a name="1323915"></a>

<a name="1323933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Youve calculated middlelength wrongly in that implementation of mine.<br><br>Edit - fixed. <br><br></td></tr></table><br>
<a name="1323921"></a>

<a name="1323922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Youve calculated middlelength wrongly in that implementation of mine. <br> <br></div><br>oh ok i see the error thanks <br><br></td></tr></table><br>
<a name="1323953"></a>

<a name="1323954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>Floyd</b> wrote:<br>But we still don't know if this points to the interior or exterior of the larger polygon. Farther up this page, in post #9, there is a polygon that looks like the grin on a Halloween pumpkin. If you try the triangle method on that you sometimes get a bisecting vector pointing into the polygon and other times pointing out.<br><br>But the edges should be oriented consistently. Imagine the polygon is drawn on the floor. And let's say the edge vectors are all oriented so that as you walk along the polygon the interior is on your left. That tells you how to orient the angle bisector. You want it to point to the outside, i.e. to your right.<br><br>There is a simple "dot product" test to tell if a point is to the left or right of a vector ( edge of 2d polygon ), which solves the problem. <br></div><br>That's an interesting problem, to know what direction of the bisector is facing into the "outside" of the mesh.<br>Besides converting the mesh outer edges (the edges that are not shared between two triangles) into a closed line-segment polygon and doing an <a href="https://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm" target="_blank">even-odd point inclusion test</a>, I think you can also solve it with angles and some definitions of triangle meshes. This only works in 2D, though (or 3D restricted to a plane like you said):<br><br>- A vertex can have two connections (edges), like in the eyes of that face or the corners of the grin. In this case, the two edges\vectors from that vertex have to be joined themselves, always (they form a triangle in the mesh). In this case you know that the outside direction is the one opposite to that edge that joins the two edges of the vertex.<br><br>- Most of the time a vertex will have more than two connections. In this case you can take the two vectors and create two angle "regions".<br><br><img src="http://i.imgur.com/XhgvsUE.png"><br><br>The vertex that spawns the two edges\vectors has at least one more edge (but it could be more) that is connecting it to the rest of the mesh.<br>The region that represents 'outside' is the region that does not include absolutely any other mesh edges (shown in dashed red below) for that vertex. So the direction of the bisector that passes through the region that is not the one where all the mesh edges are, is the one that goes outside (the orange one).<br><br><img src="http://i.imgur.com/j4BpYce.png"><br><br>You would use ATan2 a lot for this, but even though it uses trigonometry (can get imprecise) it should give the results needed. I do think the pre-determined edge ordering scheme you mentioned should be faster. <br><br></td></tr></table><br>
<a name="1323974"></a>

<a name="1323975"></a>

<a name="1323977"></a>

<a name="1323985"></a>

<a name="1323990"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> here is the flat shape in question, to better see the vertices and triangles : <br><img src="http://rd-stuff.fr/pumpkin-shape-glow-areas-201611030914.jpg"><br><br>the good thing is that the shape is welded (there is only one vertex at each position and thus no vertices share the same position)<br><br>the problem is that each vertex is used by one or several triangles and the wanted pointing outwards vector can only be calculated by considering only the edges of the outline (not the edges at the inside of the shape).<br><br>so, a possible approach, would be for each vertex, to first identify which edges are on the outline of the shape (even if they do not form an existing triangle) and use these to calculate the pointing outwards vector. <br><br></td></tr></table><br>
<a name="1323994"></a>

<a name="1323995"></a>

<a name="1323996"></a>

<a name="1323997"></a>

<a name="1323998"></a>

<a name="1324001"></a>

<a name="1324008"></a>

<a name="1324033"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> for the moment i have this :<br><pre class=code>
;removed because of errors
</pre> <br><br></td></tr></table><br>
<a name="1324006"></a>

<a name="1324029"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> it seems that the procedure that i described in my previous post works, but it seems that there is a bug somewhere in my code :<br><br>i will try to debug it later... <br><br></td></tr></table><br>
<a name="1324030"></a>

<a name="1324031"></a>

<a name="1324032"></a>

<a name="1324034"></a>

<a name="1324129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> done :<br><img src="http://rd-stuff.fr/pumpkin-shape-glow-mask-201611031853.jpg"><br><br>here is the final procedure :<br><pre class=code>
;for each triangle
 ;get the points and edges properties
 ;for each edge which composes this triangle (0-&gt;1, 1-&gt;0, 1-&gt;2, 2-&gt;1, 2-&gt;0, 0-&gt;2)
 ;add a new edge (with its properties) to the edges list
 ;0-&gt;1
 ;1-&gt;0
 ;1-&gt;2
 ;2-&gt;1
 ;2-&gt;0 
 ;0-&gt;2

;for each edge
 ;check if there are others edges with these properties
 ;if yes (it means that it is used by another triangle, therefore inside the shape)
  ;
 ;if no (it means that it is not used by another triangle, therefore on the outline of the shape)
  ;add a new outlineedge (with its properties) to the outlineedge list

;for each vertex
 ;for each outlineedge which uses this vertex as the start point (there should be 2)
  ;keep the properties of this outlineedge
 ;using the properties of the 2 outlineedges which use this vertex as the start point
 ;determine the points A,B,C of the triangle
 ;calculate the vector AB
 ;calculate the length AB
 ;calculate the normalised vector AB
 ;calculate the vector AC
 ;calculate the length AC
 ;calculate the normalised vector AC
 ;calculate the middle vector
 ;calculate the middle length
 ;calculate the middle normalised vector
 ;project a point along the middle normalised vector (0.01 with a slight random offset on the xaxis and on the y axis to not have the point positionned on the edge of a triangle with straight edges))
 ;check if point is inside one of the triangles of the shape
 ;if no (it means the middle normalised vector points outward the shape)
  ;keep the middle normalised vector
 ;if yes (it means the middle normalised vector points inward the shape)
  ;invert the middle normalised vector
 ;debug the middle outward normalised vector with a marker
</pre><br><br>thanks Flanker and Matty ! <br><br></td></tr></table><br>
<a name="1324111"></a>

<a name="1324112"></a>

<a name="1324113"></a>

<a name="1324114"></a>

<a name="1324115"></a>

<a name="1324116"></a>

<a name="1324117"></a>

<a name="1324262"></a>

<a name="1324265"></a>

<a name="1324266"></a>

<a name="1324267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know the thread is done by now but I like the brain puzzle. Here's some more on the method that Floyd mentioned in post #19.<br><br>---------------------------<br>You have a vertex on the outline of the mesh. That vertex has two outline edges, from which you can form vectors a and b. You can find the bisector of these two vectors by normalising their sum like it's already been discussed:<br><img src="http://i.imgur.com/KxQBG1V.png"><br><br>Important to make sure the vectors are formed from one end of the edge to the vertex, and then from the vertex to the other end (like the arrows indicate). This means the bisector needs to be calculated the old way (both vectors going away from the vertex), and for the rest below, use the vectors going to and from the vertex as illustrated.<br><br>---------------------------<br>We need to find which directions of the bisector represent the "outside" and the "inside".<br>To do this we need a few things. You need to find vectors that are normal (perpendicular) to vectors a and b. You can find these by using cross products -- you do a cross product (a x b) to get a vector c which is perpendicular to both a and b, and then do cross products (c x a) and (c x b) (important to use this same order of c x edge for both) to get a new vector perpendicular to a and another perpendicular to b. These will be shown as the purple lines on the last image. They still don't tell what is outside or inside.<br><br>---------------------------<br>Next we need a vector that we know points inside the mesh so we can project it onto the perpendicular vectors of a or b and find out which direction goes inside the mesh.<br>A good vector to use is the one that goes from the vertex to centre of the triangle that is formed by edge a or edge b. These are outline edges, by definition each outline edge is a part of only a single triangle of the mesh. You can choose the triangle that edge a is a part of, for example, and calculate the centre of that -- it's the average of its vertices, or (v1+v2+v3)/3. This vector is shown as the red arrow below.<br><img src="http://i.imgur.com/C8lhalH.png"><br><br>---------------------------<br>With the vector perpendicular to edge 'a' (the purple line of the green vector) and another vector that we know goes inside the mesh (red vector), we can project the red vector onto the purple line and find out what direction of that purple line means "inside" the mesh -- we check this with the sign of the dot product (red . purple), if it's positive or negative. It's important to project the red arrow to the perpendicular vector of the same edge that is a part of the triangle that the red arrow was made from (the red arrow was made from the triangle formed by edge a, so we project it onto the purple line of edge a).<br>The bisector points in two directions, inside and outside the mesh. To know which direction is outside the mesh, you can make two vectors going in opposite directions along the bisector (shown with blue points, so the vectors are from the vertex to each blue point), and project these vectors onto the purple line of edge a. Based on the sign of this dot product you can know which direction along the bisector goes outside: it will be the sign opposite to what you got from the dot product with the red vector, which we know goes inside the mesh.<br><img src="http://i.imgur.com/a5IiLvN.png"> <br><br></td></tr></table><br>
<a name="1324134"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have tested my previous procedure with another arbitrary shape (another pumpkin carved areas), and it seems to work well :<br><img src="http://rd-stuff.fr/pumpkin-shape-other-glow-mask-201611032039.jpg"><br>:)<br><br>@Kryzon&gt;&gt;thanks for the explanations/illustrations, i will take a look <br><br></td></tr></table><br>
<a name="1324139"></a>

<a name="1324140"></a>

<a name="1324141"></a>

<a name="1324166"></a>

<a name="1324167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> using these "middle outwards" normalised vectors around the outline of the shape, it is possible to create 2 kinds of glow effects :<br>-&gt;a glow with rectangles (2triangles each) coming out from the outline of the shape and projected forward and slightly outwards (so that it has a -45 angle and is visible from the front and from the side) (using a combination of the vertices normals of the flat shape and the "middle outwards" normalised vectors of each vertex)<br>-&gt;a glow with a duplicated flat shape, with different flat layers around the shape, with each layer slightly bigger than the other and with its vertices uniformly positioned around the previous layer, with a decreasing alpha... (using the "middle outwards" normalised vectors of each vertex) <br><br></td></tr></table><br>
<a name="1324263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Unless I forgot something. <br></div><br>I did forget something, or rather didn't catch it at the time. I rewrote some of that post to correct it. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
