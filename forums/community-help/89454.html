<!DOCTYPE html><html lang="en" ><head ><title >Which physics engine models driving well?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Which physics engine models driving well?</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Which physics engine models driving well?</a><br><br>
<a name="1015895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TaskMaster</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see a lot of physics engines being advertised and/or used around here.  Is any one of them good for doing a 2D driving game?  I want it to seem fairly realistic, with spin outs, drifting, etc.<br><br>If there is something good available already, that would be great.  I would rather use something like that, rather than start coding my own.<br><br>Decent driving physics really are quite complicated, with measuring force on each tire, shifting weight, etc.  If i have to do my own, I will probably go this route, but if there is a fairly decent engine that will seem real, then I would like to try it first. <br><br></td></tr></table><br>
<a name="1015918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any of the full physics engines (Tokamak, ODE, PhysX) can be used in 2D just as well as 3D, just ignore the vertical aspect when moving from the physics objects to your 2D sprites.<br><br>The only good vehicle simulation I've managed to get working is with Tokamak, despite ODE having excellently bouncy carwheel joints. <br><br>I spent a few years making and working with an ODE lib when Blitz3D was first released but never managed to get the vehicle to behave itself when sliding or when moving fast. Same with PhysX, they all seem to suffer from the same snap-spinning behavior and get very twitchy at higher speeds.<br><br>For some reason Tokamak's friction / contact method enables the wheels to slide in a much nicer and more progressive way, so my Tokamak cars in Stunt Race can perform full opposite-lock powerslides of almost any duration, they can power-understeer and oversteer and also lift-off oversteer if you come off the power during hard cornering.<br><br>I've not yet seen any ODE or PhysX vehicle demo that can do this.<br><br>If you want slower-moving vehicles that don't slide around and with bouncy suspension, use ODE (or PhysX). If you want fast vehicles that can drift etc.. use Tokamak.<br><br>I also have my own custom 2D vehicle physics engine but it's taken about 10 years to develop so it's not available to anyone else, sorry :)<br>Short video of it here: <a href="http://webspace.mypostoffice.co.uk/~james.kett/B3D_drift.flv" target="_blank">http://webspace.mypostoffice.co.uk/~james.kett/B3D_drift.flv</a> <br><br></td></tr></table><br>
<a name="1015978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TaskMaster</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> That video looks pretty dang good.<br><br>I'll look at Tokamak.  Thanks for the info.<br><br>I figured I might have to model my own.  Which is OK, I think it will be kinda fun to develop, but I also know it will take some time. <br><br></td></tr></table><br>
<a name="1016013"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, it took me ages. That video clip isn't using Tokamak just a very upgraded version of Marco Monster's 2d physics code :<br><br><a href="http://regedit.gamedev.pl/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html" target="_blank">http://regedit.gamedev.pl/Mirror/Car%20Physics%20for%20Games/Car%20Physics%20for%20Games.html</a><br><br><a href="http://hamboeck.blogspot.com/2008/03/marco-monsters-car-physics-demo-in-xna.html" target="_blank">http://hamboeck.blogspot.com/2008/03/marco-monsters-car-physics-demo-in-xna.html</a> <br><br></td></tr></table><br>
<a name="1016087"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Check out this old Tokamak rally demo that's recently been found again:<br><br><a href="http://www.hi-toro.com/blitz/misc/tokamakrally.zip" target="_blank">http://www.hi-toro.com/blitz/misc/tokamakrally.zip</a><br><br>it works pretty well and would form a nice basis for any driving game. <br><br></td></tr></table><br>
<a name="1016154"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TaskMaster</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have seen both of those links you posted.  The first one is still open in a tab, I have been studying it, along with the Physics for Game Programmers book. <br><br></td></tr></table><br>
<a name="1017049"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I played around with Monstrous Softwares 2D car simulation. I added the ability to reverse which is something the original never add. The sim works quite well but I think sometimes the car can slide infinitely sideways if you turn, brake, then self-correct the wheels:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework BRL.GLMax2D
Rem
  Car Physics Demo
  version 0.8 3-06-2001
  Copyright (c) 2001 Monstrous Software
  Platforms: Allegro/DJGPP, Allegro/Linux, Allegro/MSVC
  Demonstrates rough approximation of car physics
  Added: Ability to drive in reverse - JimB
EndRem

Const TRAIL_SIZE:Int =	200			'/* number of dots in car trail */

Const DELTA_T:Float =	0.01			'/* time between integration steps in physics modelling */
Const INPUT_DELTA_T:Float = 0.1		'/* Delay between keyboard polls */
Const SCREEN_W:Int = 640
Const SCREEN_H:Int = 480
Const TODEG:Float = 180.0 / Pi
Const TORAD:Float = Pi/180.0

'''
Graphics SCREEN_W,SCREEN_H
SetClsColor 255, 255, 255
'''

Type Vec2
	Field x:Float,y:Float
End Type

Type  TCarType
	Field	wheelbase:Float		' wheelbase in m
	Field	b:Float				' in m, distance from CG to front axle
	Field	c:Float				' in m, idem to rear axle
	Field	h:Float				' in m, height of CM from ground
	Field	mass:Float			' in kg
	Field	inertia:Float			' in kg.m
	Field	length:Float,width:Float
	Field	wheellength:Float,wheelwidth:Float
	'
	Method Init()
		b = 1.0					' m							
		c = 1.0					' m
		wheelbase = b+c
		h = 1.0					' m
		mass = 1750				' kg			
		inertia = 1204			' kg.m			
		width = 1.5				' m
		length = 3.0				' m, must be &gt; wheelbase
		wheellength = 0.7
		wheelwidth = 0.3
	End Method
End Type

Type TCar
	Field	cartype:TCarType		' pointer to static car data
	Field	position_wc:Vec2		' position of car centre in world coordinates
	Field	velocity_wc:Vec2		' velocity vector of car in world coordinates
	Field	angle:Float				' angle of car body orientation (in rads)
	Field	angularvelocity:Float
	Field	steerangle:Float			' angle of steering (Input)
	Field	throttle:Float			' amount of throttle (Input)
	Field	brake:Float 				' amount of braking (Input)
	Field	gear:Int			' gear position 1=FORWARD -1=REVERSE
	'
	Method New()
		position_wc = New Vec2
		velocity_wc = New Vec2
	End Method
	'
	Method Init(thiscartype:TCarType)
		cartype = thiscartype
		gear=1
		' weight per axle = half car mass times 1G (=9.8m/s^2) 
		weight = cartype.mass * 9.8 * 0.5
		'
		position_wc.x=0 ; position_wc.y=0
		velocity_wc.x=0 ; velocity_wc.y=0
		angle=0 ; angularvelocity=0
		steerangle=0 ; throttle=0 ; brake=0
	End Method
	'
	Method ControlViaKeys()
		' acceleration / throttle
		If KeyDown(KEY_UP)
			If throttle&lt;100 Then throttle:+1
			brake=0
		ElseIf KeyDown(KEY_DOWN)
			If brake&lt;98.8 Then brake:+1.03
			throttle=0
		Else
			If throttle&gt;0 Then throttle:-0.8
			If brake&lt;99.88 Then brake:+0.18
		EndIf
		' Steering
		If KeyDown(KEY_LEFT)
			If steerangle&gt;-Pi/4.0 Then steerangle:-Pi/184.0
		Else If KeyDown(KEY_RIGHT)
			If steerangle&lt;Pi/4.0 Then steerangle:+Pi/184.0
		Else
			steerangle:/1.04
		EndIf
		' gears
		If Abs(velocity.x)&lt;=0.	1
			If KeyDown(KEY_A) Then gear=1 ' forward
			If KeyDown(KEY_Z) Then gear=-1 ' reverse
		EndIf
		' Let front, rear Or both axles slip
		rear_slip=0 ; front_slip=0
		If KeyDown(KEY_R) rear_slip=1
		If KeyDown(KEY_F) front_slip=1
		If KeyHit(KEY_T) velocity_wc.x:+10 ' quick boost
		If KeyDown(KEY_SPACE)
			front_slip=1 ; rear_slip=1
		EndIf
	End Method
	'
	Method UpdatePhysics()
		sn = Sin(angle*TODEG)
		cs = Cos(angle*TODEG)
	
		' SAE convention: x is to the front of the car, y is to the right, z is down
	
		' transform velocity in world reference frame to velocity in car reference frame
		velocity.x =  cs * velocity_wc.y + sn * velocity_wc.x
		velocity.y = -sn * velocity_wc.y + cs * velocity_wc.x
	
		' Lateral force on wheels
		'	
		' Resulting velocity of the wheels as result of the yaw rate of the car body
		' v = yawrate * r where r is distance of wheel To CG (approx. half wheel base)
		' yawrate (ang.velocity) must be in rad/s
		'
		yawspeed = cartype.wheelbase * 0.5 * angularvelocity
		
		'bangz: velocity.x = fVLong_, velocity.y = fVLat_
		' Calculate the side slip angle of the car (a.k.a. beta)
		If Abs(velocity.x)&lt;=0.05
			sideslip = 0 ; slipanglefront=0 ; slipanglerear=0
			yawspeed=0 ; angularvelocity=0
		Else
			rot_angle = ATan2( yawspeed, velocity.x)*TORAD
			sideslip = ATan2( velocity.y, velocity.x)*TORAD
			' Calculate slip angles For front And rear wheels (a.k.a. Alpha)
			slipanglefront = sideslip + rot_angle - steerangle
			slipanglerear  = sideslip - rot_angle
		EndIf
				
		' lateral force on front wheels = (Ca * slip angle) capped To friction circle * Load
		flatf.x = 0
		flatf.y = CA_F * slipanglefront
		flatf.y = Min(MAX_GRIP, flatf.y)
		flatf.y = Max(-MAX_GRIP, flatf.y)
		flatf.y :* weight
		If(front_slip) flatf.y :* 0.5
	
		' lateral force on rear wheels
		flatr.x = 0
		flatr.y = CA_R * slipanglerear
		flatr.y = Min(MAX_GRIP, flatr.y)
		flatr.y = Max(-MAX_GRIP, flatr.y)
		flatr.y :* weight
		If(rear_slip) flatr.y :* 0.5
	
		' longtitudinal force on rear wheels - very simple traction model
		ftraction.x = 60.0*((throttle*3.5) - brake*Sgn(velocity.x))
		ftraction.y = 0
		If rear_slip Then ftraction.x :* 0.5
		
		' Forces and torque on body
		' ==========================================	
		' drag and rolling resist
		resist.x = -( RESISTANCE*velocity.x + DRAG*velocity.x*Abs(velocity.x) )
		resist.y = -( RESISTANCE*velocity.y + DRAG*velocity.y*Abs(velocity.y) )
		' sum forces
		force.x = ftraction.x + Sin(steerangle*TODEG) * flatf.x + flatr.x + resist.x
		force.y = ftraction.y + Cos(steerangle*TODEG) * flatf.y + flatr.y + resist.y	
		' torque on body from lateral forces
		torque = cartype.b * flatf.y - cartype.c * flatr.y
		' ==========================================
		' Acceleration
		' ==========================================
		' Newton F = m.a, therefore a = F/m
		acceleration.x = force.x/cartype.mass
		acceleration.y = force.y/cartype.mass
		angular_acceleration = torque / cartype.inertia
		' ==========================================
		' Velocity and position
		' ==========================================
		' transform acceleration from car reference frame to world reference frame
		acceleration_wc.x =  cs * acceleration.y + sn * acceleration.x
		acceleration_wc.y = -sn * acceleration.y + cs * acceleration.x
		' velocity is integrated acceleration
		velocity_wc.x:+ DELTA_T * acceleration_wc.x
		velocity_wc.y:+ DELTA_T * acceleration_wc.y
		
		' fix continous side slipping bug
		Local veltotal:Float=(Abs(velocity_wc.x)+Abs(velocity_wc.y))
		If Int(throttle)=0 And veltotal&gt;0.0
			velocity_wc.x:/1.025
			velocity_wc.y:/1.025
		EndIf
		
		' zero out the velocities when car has almost stopped
		If Abs(throttle)=0
			If Abs(velocity_wc.x)&lt;0.08 Then velocity_wc.x=0
			If Abs(velocity_wc.y)&lt;0.08 Then velocity_wc.y=0
		EndIf
		
		' position is integrated velocity
		If gear&gt;0
			position_wc.x :+ DELTA_T * velocity_wc.x
			position_wc.y :+ DELTA_T * velocity_wc.y
		ElseIf gear=-1
			position_wc.x :- DELTA_T * velocity_wc.x
			position_wc.y :- DELTA_T * velocity_wc.y
		EndIf
		' ==========================================
		' Angular velocity and heading
		' ==========================================
		' integrate angular acceleration to get angular velocity
		angularvelocity :+ DELTA_T * angular_acceleration
		' integrate angular velocity to get angular orientation
		If gear&gt;0
			angle:+ DELTA_T * angularvelocity
		ElseIf gear=-1
			angle:- DELTA_T * angularvelocity
		EndIf
	End Method
	'
	Method Render()
		Local corners:Vec2[4] , wheels:Vec2[4]
		Local w:Vec2[4]
		Local sn:Float, cs:Float
		Local i:Int , y:Int
		'
		sn = Sin(angle*TODEG) ; cs = Cos(angle*TODEG)
		'
		screen_pos.x =  position_wc.x * scale + SCREEN_W/2
		screen_pos.y = -position_wc.y * scale + SCREEN_H/2
		'
		While(screen_pos.y &lt; 0)
			screen_pos.y :+SCREEN_H
		Wend
		While(screen_pos.y&gt;SCREEN_H)
			screen_pos.y:-SCREEN_H
		Wend
		While(screen_pos.x &lt; 0)
			screen_pos.x :+SCREEN_W
		Wend
		While(screen_pos.x &gt; SCREEN_W)
			screen_pos.x :-SCREEN_W
		Wend
		TTrail.Draw Self
		'
		' Draw car body
		'
		SetColor 160,0,0
		' wheels: 0=fr Left, 1=fr Right, 2 =rear Right, 3=rear Left
		corners[0] = New Vec2
		corners[0].x = -cartype.width/2
		corners[0].y = -cartype.length/2
		corners[1] = New Vec2
		corners[1].x = cartype.width/2
		corners[1].y = -cartype.length/2
		corners[2] = New Vec2
		corners[2].x = cartype.width/2
		corners[2].y = cartype.length/2
		corners[3] = New Vec2
		corners[3].x = -cartype.width/2
		corners[3].y = cartype.length/2
	
		For i = 0 To 3
			w[i] = New  Vec2
			w[i].x = cs*corners[i].x - sn*corners[i].y
			w[i].y = sn*corners[i].x + cs*corners[i].y
			corners[i].x = w[i].x ; corners[i].y = w[i].y
		Next
		
		For i = 0 To 3
			corners[i].x :* scale ; corners[i].y :* scale
			corners[i].x :+ screen_pos.x ; 	corners[i].y :+ screen_pos.y
		Next
	
		DrawLine corners[0].x, corners[0].y, corners[1].x, corners[1].y
		DrawLine corners[1].x, corners[1].y, corners[2].x, corners[2].y
		DrawLine corners[2].x, corners[2].y, corners[3].x, corners[3].y
		DrawLine corners[3].x, corners[3].y, corners[0].x, corners[0].y
		'
		' Draw wheels
		'
		SetColor 0,0,160
		' wheels: 0=fr Left, 1=fr Right, 2 =rear Right, 3=rear Left
		wheels[0] = New Vec2
		wheels[0].x = -cartype.width/2
		wheels[0].y = -cartype.b
		wheels[1] = New Vec2
		wheels[1].x = cartype.width/2
		wheels[1].y = -cartype.b
		wheels[2] = New Vec2
		wheels[2].x = cartype.width/2
		wheels[2].y = cartype.c
		wheels[3] = New Vec2
		wheels[3].x = -cartype.width/2
		wheels[3].y = cartype.c
		'
		For i = 0 To 3
			w[i].x = cs*wheels[i].x - sn*wheels[i].y
			w[i].y = sn*wheels[i].x + cs*wheels[i].y
			wheels[i].x = w[i].x
			wheels[i].y = w[i].y
		Next
		'
		For i = 0 To 3
			wheels[i].x :* scale
			wheels[i].y :* scale
			wheels[i].x :+ screen_pos.x
			wheels[i].y :+ screen_pos.y
		Next
		'
		draw_wheel( 0, wheels[0].x, wheels[0].y, front_slip)
		draw_wheel( 1, wheels[1].x, wheels[1].y, front_slip)
		draw_wheel( 2, wheels[2].x, wheels[2].y, rear_slip)
		draw_wheel( 3, wheels[3].x, wheels[3].y, rear_slip)
	Rem
		' "wheel spokes" To show Ackermann centre of turn
		'
		DrawLine   wheels[0].x, wheels[0].y,
			wheels[0].x -Cos(angle+steerangle)*100,
			wheels[0].y -Sin(angle+steerangle)*100,col);
		DrawLine   wheels[3].x, wheels[3].y,
			wheels[3].x -Cos(angle)*100,
			wheels[3].y -Sin(angle)*100,col);
	EndRem
	End Method
	'
	Method draw_wheel(nr:Int,x:Int,y:Int,crossed:Int)
		Local r:Float
		SetColor 0,160,0
		If nr&lt;2 Then r=steerangle Else r=0
		draw_rect angle+r,cartype.wheelwidth*scale, cartype.wheellength*scale,x,y,crossed
	End Method
End Type

Type  TTrailPoint
	Field x:Float,y:Float,angle:Float
End Type

Type TTrail
	Global num_trail:Int
	Global tp:TTrailPoint[TRAIL_SIZE]
	'
	Function Add(x:Float,y:Float)
		If num_trail&lt;TRAIL_SIZE-1
			If tp[num_trail] = Null Then tp[num_trail]=New TtrailPoint
			tp[num_trail].x=x
			tp[num_trail].y=y
			num_trail:+1
		Else
			For Local i:Int =  0 Until TRAIL_SIZE-2 
				tp[i].x=tp[i+1].x
				tp[i].y=tp[i+1].y
			Next
			tp[num_trail-1].x=x
			tp[num_trail-1].y=y
		EndIf
	End Function
	'
	Function Draw(thiscar:TCar)
		Local x:Int,y:Int
		SetColor 230,230,230
		For Local i:Int=0 Until num_trail
			x=(tp[i].x-thiscar.position_wc.x)*scale+screen_pos.x
			y=-(tp[i].y-thiscar.position_wc.y)*scale+screen_pos.y
			DrawCircle x, y, 2
		Next
	End Function
End Type


Global screen_pos:Vec2 = New Vec2
Global scale:Float
Global str:String

Rem
	Lots of globals, so their value may be printed on screen
	Normally, most of these variables should be private to the physics function
End Rem
Global velocity:Vec2 = New Vec2
Global acceleration_wc:Vec2 = New Vec2
Global rot_angle:Double
Global sideslip:Double
Global slipanglefront:Double
Global slipanglerear:Double
Global force:Vec2 = New Vec2
Global rear_slip:Int
Global front_slip:Int
Global resist:Vec2 = New Vec2
Global acceleration:Vec2 = New Vec2
Global torque:Double
Global angular_acceleration:Double
Global sn:Double, cs:Double
Global yawspeed:Double
Global weight:Double
Global ftraction:Vec2 = New Vec2
Global flatf:Vec2 = New Vec2, flatr:Vec2 = New Vec2

'#################################################

' These constants are arbitrary values, not realistic ones
Const DRAG:Float = 5.0		 	' factor For air resist (drag)
Const RESISTANCE:Float = 30.0	' factor For rolling resist
Const CA_R:Float=-5.20			' cornering stiffness
Const CA_F:Float=-5.0			' cornering stiffness
Const MAX_GRIP:Float =4.0		' maximum (normalised) friction force, =diameter of friction circle

' Run the game
Main()
' --------------

Function Main( )
	Local quit:Int
	Local car:TCar=New TCar
	Local cartype:TCarType=New TCarType
	cartype.Init ; car.Init cartype
	
	Local lastticks:Int=0
	Local lastiticks:Int = 0
	scale = 28						' pixels per m

	While Not KeyHit(KEY_ESCAPE)
		Cls()
		If KeyHit(KEY_F9) ' F9 To reset
			car.Init cartype
			TTrail.num_trail=0
		EndIf
		If KeyHit(KEY_F4) Then DebugStop
		' Zoom in / out
		If KeyDown(KEY_Q) scale :+ 0.5
		If KeyDown(KEY_W) scale :- 0.5
		car.ControlViaKeys
		car.UpdatePhysics
		car.Render
		TTRail.Add car.position_wc.x,car.position_wc.y
		Draw_Dials car
		Draw_TextMessages car
		Flip
	Wend
End Function

' #######################################################

Function draw_rect(angle:Float, w:Int,l:Int,x:Int,y:Int,crossed:Int)
	Local c:Vec2[4],c2:Vec2[4]
	Local sn:Float,cs:Float
	Local i:Int
    sn=Sin(angle*TODEG) ; cs=Cos(angle*TODEG)
    c[0]=New Vec2
    c[0].x =-w/2 ; c[0].y=l/2
    c[1] = New Vec2
    c[1].x = w/2 ; c[1].y=l/2
    c[2] = New Vec2
    c[2].x = w/2 ; c[2].y=-l/2
    c[3] = New Vec2
    c[3].x = -w/2 ; c[3].y=-l/2
	'
	For i = 0 To 3
		c2[i]=New Vec2
		c2[i].x=cs*c[i].x-sn*c[i].y
		c2[i].y=sn*c[i].x+cs*c[i].y
		c[i].x=c2[i].x ; c[i].y=c2[i].y
	Next
	'
	For i = 0 To 3
		c[i].x:+x ; c[i].y:+y
	Next
	DrawLine  c[0].x,c[0].y, c[1].x, c[1].y
	DrawLine  c[1].x,c[1].y, c[2].x, c[2].y
	DrawLine  c[2].x,c[2].y, c[3].x, c[3].y
	DrawLine  c[3].x,c[3].y, c[0].x, c[0].y
	'
	If crossed
		DrawLine  c[0].x,c[0].y,c[2].x,c[2].y
		DrawLine  c[1].x,c[1].y,c[3].x,c[3].y
	EndIf
End Function

Function Draw_Dials(thiscar:TCar)
	SetColor 0, 100,100
	' Velocity vector dial
	'
	Const VDIAL_X:Int = 550
	Const VDIAL_Y:Int = 120
	DrawCircle VDIAL_X, VDIAL_Y, 50
	DrawLine VDIAL_X, VDIAL_Y, VDIAL_X+velocity.x, VDIAL_Y-velocity.y
	'
	Const VWDIAL_X:Int = 550
	Const VWDIAL_Y:Int = 260
	DrawCircle VWDIAL_X, VWDIAL_Y, 50
	SetColor 0, 0, 100
	DrawLine VWDIAL_X, VWDIAL_Y, VWDIAL_X+thiscar.velocity_wc.x, VWDIAL_Y-thiscar.velocity_wc.y
	'
	Const BRAKE_X:Int = 420
	Const BRAKE_Y:Int = 120
	SetColor 70, 0, 0
	DrawRect  BRAKE_X, BRAKE_Y-100, 20, 100
	SetColor 120, 0,0
	DrawRect  BRAKE_X+2, BRAKE_Y-thiscar.brake, 16, thiscar.brake
	'
	Const THROTTLE_X:Int = 440
	Const THROTTLE_Y:Int = 120
	SetColor 0, 70, 0
	DrawRect  THROTTLE_X, THROTTLE_Y-100, 20, 100
	SetColor 0, 120,0
	DrawRect  THROTTLE_X+2, THROTTLE_Y-thiscar.throttle, 16, thiscar.throttle
	'
	Const GEAR_X:Int = 400
	Const GEAR_Y:Int = 40
	SetColor 70, 70, 70
	DrawLine GEAR_X,GEAR_Y,GEAR_X,GEAR_Y+40
	SetColor 0, 0, 0
	DrawRect GEAR_X-10,GEAR_Y+20-7-thiscar.gear*18,20,14
	'	
	DrawArcDial "Steer Angle",420,160,thiscar.steerangle
	DrawArcDial "Side Slip",420,220,sideslip
	DrawArcDial "Rot Angle",420,280,rot_angle
	DrawArcDial "SlipAng F",450,360,slipanglefront
	DrawArcDial "SlipAng R",450,420,slipanglerear
End Function

Function Draw_TextMessages(thiscar:TCar)
	' text messages
	Const TEXT_X:Int =10
	SetColor 100, 100, 100
	Local y%=10
	str = "scale "+scale+" pixels/m   &lt;Q,W&gt;"
	DrawText str, TEXT_X,y
	y:+10
	str = "velocity x "+velocity.x
	DrawText str, TEXT_X,y
	y:+10
	str = "sideslip "+sideslip
	DrawText str, TEXT_X,y
	y:+10
	str = "vel_wc x "+thiscar.velocity_wc.x
	DrawText str, TEXT_X,y
	y:+10
	str = "vel_wc y "+thiscar.velocity_wc.y
	DrawText str, TEXT_X,y
	y:+10	
	str = "angle "+thiscar.angle*TODEG
	DrawText str, TEXT_X, y+10
	y:+10
	str = "ESC=quit Q/W=zoom   UP=Throttle DOWN=Brakes   A/Z=Gears   SPACE=Handbrake"
	DrawText str, 0, SCREEN_H-20
End Function

Function DrawArcDial(label$,xp%,yp%,param:Float)
	Local ncol%
	SetColor 0, 0, 0
	DrawArc xp,yp,220,328,35
	SetColor 0, 100, 0
	DrawLine xp,yp,xp+Int(Sin(param*TODEG)*30.0), yp-Int(Cos(param*TODEG)*30.0)
	DrawText label,xp-TextWidth(label)/2,yp+4
End Function

Function DrawCircle(xC%,yC%,radius%,filled:Int = False)	
	If filled = True
		DrawOval xC - radius, yC - radius, radius * 2, radius * 2
	Else 
		If (xC-radius) &gt; SCREEN_W  Return  
		If (yC-radius) &gt; SCREEN_H  Return
		If (xC+radius) &lt; 0 Then Return
		If (yC+radius) &lt; 0 Then Return
		Local x:Int = 0
		Local d:Int = (2*Radius)						
		Local y:Int=Radius
		While x&lt;y
			If d &lt; 0 Then
				d = d + (4 * x) + 6
			Else
				d = d + 4 * (x - y) + 10
				y = y - 1
			End If
			Plot(xC + X, yC + Y)
			Plot(xC + X, yC - Y)
			Plot(xC - X, yC + Y)
			Plot(xC - X, yC - Y)
			Plot(xC + Y, yC + X)
			Plot(xC + Y, yC - X)
			Plot(xC - Y, yC + X)
			Plot(xC - Y, yC - X)
			x=x+1
		Wend
	EndIf
End Function

Function DrawArc(x:Float,y:Float,startAngle:Float,endAngle:Float,radius:Float)
	If startAngle = endAngle Then Return
	If startAngle &gt; endAngle
		Local ta:Float = endAngle
		endAngle = startAngle ; startAngle = ta
	EndIf
	Local angle:Float = endAngle - StartAngle
	Local Stp:Float = angle/(angle * Pi / 180.0 * radius)
	Local AccumAngle:Float = StartAngle
	Local dx:Float = Cos(accumAngle) * radius
	Local dy:Float = Sin(accumAngle) * radius
	'DrawLine x, y, x + dx, y + dy
	While accumAngle &lt; (StartAngle+Angle)					
			dx:Float = Cos((accumAngle))*radius
			dy:Float = Sin((accumAngle))*radius
			Plot x+dx,y+dy ; 	AccumAngle:+stp
	Wend
	'DrawLine x, y, x + dx, y + dy
End Function</textarea> <br><br></td></tr></table><br>
<a name="1017159"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TaskMaster</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks.<br><br>When I get a chance, I will take a look at this.<br><br>I appreciate any hints/help I an get. <br><br></td></tr></table><br>
<a name="1019358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Damien Sturdy</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> See, I've always disagreed with Vorderman about ODE, despite me using his wrapper on the very game I'm about to link,<br><br><a href="http://damiensturdy.servegame.org/" target="_blank">http://damiensturdy.servegame.org/</a> ,check out the B3D racer, link to download here:<br><a href="http://damiensturdy.servegame.org/downloads/RACER_20_01_10.rar" target="_blank">http://damiensturdy.servegame.org/downloads/RACER_20_01_10.rar</a><br><br>It took a lot of work and even a fair bit of manual calculation, but if you play as the Mazdo car in this you'll see it's actually quite possible with ODE and I find ODE really easy to set up. The above actually uses both Vorderman's ODE wrapper AND JV-ODE. for some reason porting to JV-ODE never worked, so I wrapped JV-ODE code into Vorderman's functions, and whump, away it went first time lol.<br><br><br>That said, I've also had great fun with Tokamak, although I've never quite got a good suspension out of it. <br><br></td></tr></table><br>
<a name="1019378"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got a 404 on that link, Cygnus. Same going from the site itself. <br><br></td></tr></table><br>
<a name="1019442"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good to see that my ODE wrapper still rocks!!!<br><br>I prefer Tokamak though :) <br><br></td></tr></table><br>
<a name="1019539"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Damien Sturdy</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Darnit! I changed my server layout. Fixed!!! :-)<br><br>Also, since when are we allowed to have commas in links? X-D this forum software thought my proceeding comma was part of the URL.<br><br>Vorderman - YOU are the reason I never gave up coding all those years ago, and last November I found the racer and said "Hmmph, such a shame, the wrapper is small and efficient, yet it suffers some old ODE bugs." - so I removed your DLL calls and replaced them with calls to JVODE functions. I'd already heavily modified your code so this was the easiest way forward.<br><br>Anyway, have a play. You're right that you can't do infinite powerslides, but the Mazdo is pretty close lol. It all depends on what you need really, Tokamak didn't give me an impressive view that's all, but Toka is WAY faster. <br><br></td></tr></table><br>
<a name="1019569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> YOU are the reason I never gave up coding all those years ago <br></div><br><br>You say that like it's a curse!! <br><br></td></tr></table><br>
<a name="1019576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Damien Sturdy</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hahaha, Not a curse, I've had a darn great time! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
