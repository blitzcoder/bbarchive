<!DOCTYPE html><html lang="en" ><head ><title >Dabz DX9 2D Engine</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Dabz DX9 2D Engine</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Dabz DX9 2D Engine</a><br><br>
<a name="971607"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GaryV</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does anybody have a DLL (release compile) of this?<br><br>I only have access to VC++ at work and I can't compile personal stuff.  I would prefer not to have to download the freebie version of VC++ just to compile this DLL.<br><br>Any help would be appreciated... <br><br></td></tr></table><br>
<a name="972157"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sauer</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no DLL for it, I tried but couldn't figure out how to compile the DLL in CodeBlocks.<br><br>I don't believe there is a userlib for it either... just C++ code. <br><br></td></tr></table><br>
<a name="972176"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GaryV</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you for the info. <br><br></td></tr></table><br>
<a name="972394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> If I have the time next week, I'll package it up to a DLL (And release the source too), it really shouldnt take that long! :)<br><br>Though, I will only package the graphical/OGG audio and other fruity bits, because you obviously wont need input and file access since your using Blitz... Okay Dokey! :D<br><br>Dabz <br><br></td></tr></table><br>
<a name="972525"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sauer</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm finding it hard to not use all caps and multiple exclamation points when I say:<br><br>Thank you!<br><br>:) <br><br></td></tr></table><br>
<a name="972528"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GaryV</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I appreciate that, but you don't have to go to any trouble on my account. <br><br></td></tr></table><br>
<a name="972622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wrapped most of it via P/invoke to C# if anyone's interested <br><br></td></tr></table><br>
<a name="972669"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, I've wrapped up most of the code:-<br><br><pre class=code>
//DX9_Plus DLL
//Written by Michael Denathorn 2009

#include &lt;d3d9.h&gt;
#include &lt;d3dx9.h&gt;
#include &lt;map&gt;
#include &lt;stdio.h&gt;
#include &lt;vector &gt;
#include &lt;string.h&gt;
#include &lt;Shlobj.h&gt;
#include &lt;aclapi.h&gt;

using namespace std;

#define BBDECL extern "C" _declspec(dllexport)
#define BBCALL _stdcall
#define PI 3.14159f

//Window platform definitions
#define PLATFORM_WIN32s		0
#define PLATFORM_WINNT		1
#define PLATFORM_WIN2000	2
#define PLATFORM_WINXP		3
#define PLATFORM_WINVISTA	4
#define PLATFORM_WIN95		5
#define PLATFORM_WIN98		6
#define PLATFORM_WINME		7

HWND screenWindow;
BOOL isWindowed;
LPSTR lastNetErrorString;
BOOL AppStatus;

typedef DWORD HEXCOLOR;
typedef LPDIRECT3DDEVICE9 D3D_DEVICE;
typedef LPDIRECT3DSURFACE9 BUFFER;

LPDIRECT3D9             pD3D = NULL;
LPDIRECT3DDEVICE9       pD3DDevice;

LPDIRECT3DSURFACE9		pBackBuffer;
LPDIRECT3DSURFACE9		pCurrentSurface;
LPD3DXSPRITE            sprite;
D3DCAPS9 d3dCaps;
D3DPRESENT_PARAMETERS d3dPresent;

HEXCOLOR clsColor = D3DCOLOR_ARGB(255,0,0,0);;

//Internal functions prototypes
VOID Message(LPCSTR string);

struct Texture {
	LPDIRECT3DTEXTURE9  texture;
	LPDIRECT3DSURFACE9 pTextureSurface;
	int textureWidth;
	int textureHeight;
	int cellWidth;
	int cellHeight;
	int originX,originY;
	int rotationX, rotationY;
	int extra;
};

map&lt;int, Texture&gt; TextureMap;
int textureCount = 0;

struct Font {
	ID3DXFont *g_font;
	int height;
	int width;
	LPCSTR fontName;
	BOOL italic;
	D3DCOLOR color;
};

map&lt;int, Font&gt; FontMap;
int fontCount = 0;

struct TLVERTEX
{
    float x;
    float y;
    float z;
    float rhw;
    D3DCOLOR colour;
    float u;
    float v;
};
//Custom vertex format
const DWORD D3DFVF_TLVERTEX = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1; 

D3DXIMAGE_INFO InfoFromFile;

bool drawImage = false;
float alpha = 1.0;
float rotation = 0.0;
D3DXVECTOR2 scale;
HANDLE dhandle;
WIN32_FIND_DATA fdata;
LPSTR currentDirFile;

//Create a new graphics window
BBDECL BOOL BBCALL DX9_Graphics(int resWidth, int resHeight, int resFormat, HWND hWnd, BOOL bWindowedMode, BOOL synced)
{
    HRESULT hr;
	D3DFORMAT format;
    //Make Direct3D object
    pD3D = Direct3DCreate9(D3D_SDK_VERSION);
	
    //Make sure NULL pointer was not returned
    if (!pD3D)
        return FALSE;

    //Get device capabilities
    ZeroMemory (&amp;d3dCaps, sizeof(d3dCaps));
    if (FAILED(pD3D-&gt;GetDeviceCaps (D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &amp;d3dCaps)))
        return FALSE;

    //Setup present parameters
    ZeroMemory(&amp;d3dPresent,sizeof(d3dPresent));
    d3dPresent.EnableAutoDepthStencil = TRUE;
	d3dPresent.AutoDepthStencilFormat = D3DFMT_D16;
	d3dPresent.SwapEffect             = D3DSWAPEFFECT_DISCARD;
    d3dPresent.hDeviceWindow = hWnd;
    d3dPresent.BackBufferCount = 1;

	if(synced==TRUE)
	{
		d3dPresent.PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
	}
	else
	{
		d3dPresent.PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
	}
	
    //Check if windowed
    if (bWindowedMode)
    {
		SetWindowPos(hWnd,NULL,10,10,resWidth+(GetSystemMetrics(SM_CXBORDER)*2),resHeight+(GetSystemMetrics(SM_CXSIZE)+GetSystemMetrics(SM_CXBORDER)),SWP_SHOWWINDOW);
        D3DDISPLAYMODE d3ddm;
        RECT rWindow;

        //Get display mode
        pD3D-&gt;GetAdapterDisplayMode (D3DADAPTER_DEFAULT, &amp;d3ddm);

        //Get window bounds
        GetClientRect (hWnd, &amp;rWindow);

        //Setup screen dimensions
        resWidth = rWindow.right - rWindow.left;
        resHeight = rWindow.bottom - rWindow.top;

        //Setup backbuffer
        d3dPresent.Windowed = true;
        d3dPresent.BackBufferFormat = d3ddm.Format;
        d3dPresent.BackBufferWidth = rWindow.right - rWindow.left;
        d3dPresent.BackBufferHeight = rWindow.bottom - rWindow.top;
    }
    else
    {   
		if (resFormat == 16)
		{
			hr=pD3D-&gt;CheckDeviceType(D3DADAPTER_DEFAULT,//Adapter
                           D3DDEVTYPE_HAL,    //DeviceType
                           D3DFMT_X1R5G5B5,     //DisplayFormat
                           D3DFMT_X1R5G5B5,     //BackBufferFormat
                           false);            //Windowed

			if(SUCCEEDED(hr))
			{
				format = D3DFMT_X1R5G5B5;
			}
			else
			{
				format = D3DFMT_R5G6B5;
			}
		}
		else
		{
			format = D3DFMT_X8R8G8B8;
			
		}
        
		d3dPresent.Windowed = false;
        d3dPresent.BackBufferWidth = resWidth;
        d3dPresent.BackBufferHeight = resHeight;
        d3dPresent.BackBufferFormat = format;
    }

    //Check if hardware vertex processing is available
    if (d3dCaps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT)
    {    
        //Create device with hardware vertex processing
        hr = pD3D-&gt;CreateDevice(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL, hWnd,
            D3DCREATE_HARDWARE_VERTEXPROCESSING, &amp;d3dPresent, &amp;pD3DDevice);        
    }
    else
    {
        //Create device with software vertex processing
        hr = pD3D-&gt;CreateDevice(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL, hWnd,
            D3DCREATE_SOFTWARE_VERTEXPROCESSING, &amp;d3dPresent, &amp;pD3DDevice);
    }

    //Make sure device was created
    if (FAILED(hr))
        return FALSE;

	pD3DDevice-&gt;SetRenderState( D3DRS_LIGHTING, FALSE );

	

	D3DXCreateSprite(pD3DDevice, &amp;sprite );
	pD3DDevice-&gt;GetRenderTarget(0,&amp;pBackBuffer);
	pD3DDevice-&gt;SetRenderTarget(0,pBackBuffer);
	pCurrentSurface = pBackBuffer;
	screenWindow = hWnd; 
	scale.x = 1.0;
	scale.y = 1.0;
    isWindowed = bWindowedMode;
	AppStatus = TRUE;
    return TRUE;
}

BBDECL VOID BBCALL DX9_Cls()
{
	if (pD3DDevice != NULL) {
	pD3DDevice-&gt;Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,clsColor, 1.0f, 0 );
	pD3DDevice-&gt;BeginScene();
	} 
}

BBDECL VOID BBCALL DX9_Flip()
{
	if (drawImage == true)
	{
		drawImage = false;
		sprite-&gt;End();
	}
	if (pD3DDevice != NULL) {
		pD3DDevice-&gt;EndScene();
		pD3DDevice-&gt;Present(NULL,NULL,NULL,NULL);
	}
}

BBDECL VOID BBCALL DX9_SetClsColor(int r,int g, int b, int a)
{
	clsColor = D3DCOLOR_ARGB(a,r,g,b);
}

BBDECL VOID BBCALL DX9_ShowPointer() 
{
	ShowCursor(true);
	pD3DDevice-&gt;ShowCursor(true);
}

BBDECL VOID BBCALL DX9_HidePointer() 
{
	ShowCursor(false);
	pD3DDevice-&gt;ShowCursor(false);
}

//Load a normal image, no masking or animation
BBDECL int BBCALL DX9_LoadImage(LPCSTR filePath) 
{
	Texture passedTexture;
	textureCount = textureCount + 1;

	HRESULT hr;

	hr = D3DXGetImageInfoFromFileA(filePath, &amp;InfoFromFile);
	
	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot extract info from file.","DX9 Error",MB_OK);
		return(FALSE);
	}
	
	hr = D3DXCreateTextureFromFileExA(pD3DDevice,
                                 filePath,
                                 InfoFromFile.Width, 
                                 InfoFromFile.Height, 
                                 1,   
                                 D3DPOOL_DEFAULT,
                                 D3DFMT_UNKNOWN,
                                 D3DPOOL_DEFAULT,
                                 D3DX_DEFAULT,
                                 D3DX_DEFAULT,
                                 0,
                                 NULL,
                                 NULL,
                                 &amp;passedTexture.texture);

	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot create texture.","DX9 Error",MB_OK);
		return(FALSE);
	}
	
	passedTexture.pTextureSurface = NULL;
	passedTexture.textureWidth = InfoFromFile.Width;
	passedTexture.textureHeight = InfoFromFile.Height;
	passedTexture.cellWidth = InfoFromFile.Width;
	passedTexture.cellHeight = InfoFromFile.Height;
	passedTexture.extra = 1;
	passedTexture.originX = 0;
	passedTexture.originY = 0;
	passedTexture.rotationX = 0;
	passedTexture.rotationY = 0;

	TextureMap.insert(pair&lt;int,Texture&gt;(textureCount,passedTexture));
	return textureCount;
}

BBDECL VOID BBCALL DX9_DrawImage(int image, int x, int y)
{
	Texture passedTexture = TextureMap[image];

	if (drawImage == false)
	{
		sprite-&gt;Begin( D3DXSPRITE_ALPHABLEND );
		drawImage = true; 
	}

	int px = (x-passedTexture.originX);
	int py = (y-passedTexture.originY);
	
	D3DXVECTOR2 vPosition = D3DXVECTOR2((float)px, (float)py);
	D3DXVECTOR2 rotationPoint = D3DXVECTOR2((float)passedTexture.rotationX, (float)passedTexture.rotationY);
	D3DXMATRIX worldMatrix;
	
	D3DXMatrixTransformation2D(&amp;worldMatrix,NULL,0.0,&amp;scale,&amp;rotationPoint, rotation,&amp;vPosition);

	sprite-&gt;SetTransform(&amp;worldMatrix);
    sprite-&gt;Draw( passedTexture.texture, NULL, NULL, NULL, D3DCOLOR_COLORVALUE(1.0f,1.0f,1.0f,alpha));
}
BBDECL VOID BBCALL DX9_DrawImageRect(int image, int x, int y, int top, int left, int width, int height)
{
	Texture passedTexture = TextureMap[image];

	if (drawImage == false)
	{
		sprite-&gt;Begin( D3DXSPRITE_ALPHABLEND );
		drawImage = true; 
	}

	int px = (x-passedTexture.originX);
	int py = (y-passedTexture.originY);

	RECT srcRect;
	srcRect.top    = top;
	srcRect.left   = left;
	srcRect.bottom = srcRect.top  + height;
    srcRect.right  = srcRect.left + width;

	D3DXVECTOR2 vPosition = D3DXVECTOR2((float)px, (float)py);
	D3DXVECTOR2 rotationPoint = D3DXVECTOR2((float)passedTexture.rotationX, (float)passedTexture.rotationY);
	D3DXMATRIX worldMatrix;
	
	D3DXMatrixTransformation2D(&amp;worldMatrix,NULL,0.0,&amp;scale,&amp;rotationPoint, rotation,&amp;vPosition);
	
	sprite-&gt;SetTransform(&amp;worldMatrix);
    sprite-&gt;Draw(passedTexture.texture, &amp;srcRect, NULL, NULL, D3DCOLOR_COLORVALUE(1.0f,1.0f,1.0f,alpha));
}

BBDECL VOID BBCALL DX9_DrawAnimImageRect(int image, int x, int y, int top, int left, int width, int height,int frame)
{
	Texture passedTexture = TextureMap[image];

	if (drawImage == false)
	{
		sprite-&gt;Begin( D3DXSPRITE_ALPHABLEND );
		drawImage = true; 
	}

	int px = (x-passedTexture.originX);
	int py = (y-passedTexture.originY);

	RECT srcRect;
	srcRect.top    = ((( frame / (passedTexture.textureWidth/passedTexture.cellWidth)) * passedTexture.cellHeight))+top;
	srcRect.left   = ((( frame % (passedTexture.textureWidth/passedTexture.cellWidth) ) * passedTexture.cellWidth))+left;
	srcRect.bottom = (srcRect.top  + passedTexture.cellHeight)+height;
    srcRect.right  = (srcRect.left + passedTexture.cellWidth)+width;

	D3DXVECTOR2 vPosition = D3DXVECTOR2((float)px, (float)py);
	D3DXVECTOR2 rotationPoint = D3DXVECTOR2((float)passedTexture.rotationX, (float)passedTexture.rotationY);
	D3DXMATRIX worldMatrix;
	
	D3DXMatrixTransformation2D(&amp;worldMatrix,NULL,0.0,&amp;scale,&amp;rotationPoint, rotation,&amp;vPosition);
	
	sprite-&gt;SetTransform(&amp;worldMatrix);
    sprite-&gt;Draw(passedTexture.texture, &amp;srcRect, NULL, NULL, D3DCOLOR_COLORVALUE(1.0f,1.0f,1.0f,alpha));
}

BBDECL VOID BBCALL DX9_DrawAnimImage(int image, int x, int y, int frame)
{
	Texture passedTexture = TextureMap[image];

	if (drawImage == false)
	{
		sprite-&gt;Begin( D3DXSPRITE_ALPHABLEND );
		drawImage = true; 
	}

	int px = (x-passedTexture.originX);
	int py = (y-passedTexture.originY);

	RECT srcRect;
	srcRect.top    = (( frame / (passedTexture.textureWidth/passedTexture.cellWidth)) * passedTexture.cellHeight);
	srcRect.left   = (( frame % (passedTexture.textureWidth/passedTexture.cellWidth) ) * passedTexture.cellWidth);
	srcRect.bottom = srcRect.top  + passedTexture.cellHeight;
    srcRect.right  = srcRect.left + passedTexture.cellWidth;

	D3DXVECTOR2 vPosition = D3DXVECTOR2((float)px, (float)py);
	D3DXVECTOR2 rotationPoint = D3DXVECTOR2((float)passedTexture.rotationX, (float)passedTexture.rotationY);
	D3DXMATRIX worldMatrix;
	
	D3DXMatrixTransformation2D(&amp;worldMatrix,NULL,0.0,&amp;scale,&amp;rotationPoint, rotation,&amp;vPosition);
	
	sprite-&gt;SetTransform(&amp;worldMatrix);
    sprite-&gt;Draw(passedTexture.texture, &amp;srcRect, NULL, NULL, D3DCOLOR_COLORVALUE(1.0f,1.0f,1.0f,alpha));
}

BBDECL int BBCALL DX9_LoadMaskedImage(LPCSTR filePath,int r, int g, int b) 
{
	Texture passedTexture;
	

	HRESULT hr;

	hr = D3DXGetImageInfoFromFileA(filePath, &amp;InfoFromFile);
	
	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot extract info from file.","DX9 Error",MB_OK);
		return(FALSE);
	}
	
	hr = D3DXCreateTextureFromFileExA(pD3DDevice,
                                 filePath,
                                 InfoFromFile.Width, 
                                 InfoFromFile.Height, 
                                 1,   
                                 D3DPOOL_DEFAULT,
                                 D3DFMT_UNKNOWN,
                                 D3DPOOL_DEFAULT,
                                 D3DX_DEFAULT,
                                 D3DX_DEFAULT,
                                 D3DCOLOR_XRGB(r,g,b),
                                 NULL,
                                 NULL,
                                 &amp;passedTexture.texture);

	
	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot create texture.","DX9 Error",MB_OK);
		return(FALSE);
	}
	
	passedTexture.pTextureSurface = NULL;
	passedTexture.textureWidth  = InfoFromFile.Width;
	passedTexture.textureHeight = InfoFromFile.Height;
	passedTexture.cellWidth = InfoFromFile.Width;
	passedTexture.cellHeight = InfoFromFile.Height;
	passedTexture.extra = 1;
	passedTexture.originX = 0;
	passedTexture.originY = 0;
	passedTexture.rotationX = 0;
	passedTexture.rotationY = 0;

	textureCount = textureCount + 1;
	TextureMap.insert(pair&lt;int,Texture&gt;(textureCount,passedTexture));
	return textureCount;
}

BBDECL int BBCALL DX9_LoadAnimImage(LPCSTR filePath, int cellWidth, int cellHeight, int cellAmount)
{
	Texture passedTexture;
	textureCount = textureCount + 1;

	HRESULT hr;

	hr = D3DXGetImageInfoFromFileA(filePath, &amp;InfoFromFile);

	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot extract info from file.","DX9 Error",MB_OK);
		return(FALSE);
	}
	
	hr = D3DXCreateTextureFromFileExA(pD3DDevice,
                                 filePath,
                                 InfoFromFile.Width,
                                 InfoFromFile.Height, 
                                 1,   
                                 D3DPOOL_DEFAULT,
                                 D3DFMT_UNKNOWN,
                                 D3DPOOL_DEFAULT,
                                 D3DX_DEFAULT,
                                 D3DX_DEFAULT,
                                 0,
                                 NULL,
                                 NULL,
                                 &amp;passedTexture.texture );

	
	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot create texture.","DX9 Error",MB_OK);
		return(FALSE);
	}

	passedTexture.pTextureSurface = NULL;
	passedTexture.textureWidth  = InfoFromFile.Width;
	passedTexture.textureHeight = InfoFromFile.Height;
	passedTexture.cellWidth = cellWidth;
	passedTexture.cellHeight = cellHeight;
	passedTexture.extra = cellAmount;
	passedTexture.originX = 0;
	passedTexture.originY = 0;
	passedTexture.rotationX = 0;
	passedTexture.rotationY = 0;

	TextureMap.insert(pair&lt;int,Texture&gt;(textureCount,passedTexture));
	return textureCount;
}

BBDECL int BBCALL DX9_LoadMaskedAnimImage(LPCSTR filePath, short cellWidth, short cellHeight, short cellAmount, int r, int g, int b)
{
	Texture passedTexture;
	textureCount = textureCount + 1;

	HRESULT hr;

	hr = D3DXGetImageInfoFromFileA(filePath, &amp;InfoFromFile);

	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot extract info from file.","DX9 Error",MB_OK);
		return(FALSE);
	}
	
	hr = D3DXCreateTextureFromFileExA(pD3DDevice,
                                 filePath,
                                 InfoFromFile.Width, 
                                 InfoFromFile.Height, 
                                 1,   
                                 D3DPOOL_DEFAULT,
                                 D3DFMT_UNKNOWN,
                                 D3DPOOL_DEFAULT,
                                 D3DX_DEFAULT,
                                 D3DX_DEFAULT,
                                 D3DCOLOR_XRGB(r,g,b),
                                 NULL,
                                 NULL,
                                 &amp;passedTexture.texture);

	
	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot create texture.","DX9 Error",MB_OK);
		return(FALSE);
	}

	passedTexture.pTextureSurface = NULL;
	passedTexture.textureWidth  = InfoFromFile.Width;
	passedTexture.textureHeight = InfoFromFile.Height;
	passedTexture.cellWidth = cellWidth;
	passedTexture.cellHeight = cellHeight;
	passedTexture.extra = cellAmount;
	passedTexture.originX = 0;
	passedTexture.originY = 0;
	passedTexture.rotationX = 0;
	passedTexture.rotationY = 0;

	TextureMap.insert(pair&lt;int,Texture&gt;(textureCount,passedTexture));
	return textureCount;
}

BBDECL int BBCALL DX9_CreateTargetImage(int imageWidth, int imageHeight)
{
	Texture passedTexture;
	D3DXCreateTexture(pD3DDevice,imageWidth,imageHeight,1,D3DUSAGE_RENDERTARGET,D3DFMT_A8R8G8B8,D3DPOOL_DEFAULT,&amp;passedTexture.texture);
	passedTexture.texture-&gt;GetSurfaceLevel(0,&amp;passedTexture.pTextureSurface);
	
	passedTexture.textureWidth = imageWidth;
	passedTexture.textureHeight = imageHeight;
	passedTexture.cellWidth = imageWidth;
	passedTexture.cellHeight = imageHeight;
	passedTexture.extra = 1;
	passedTexture.originX = 0;
	passedTexture.originY = 0;
	passedTexture.rotationX = 0;
	passedTexture.rotationY = 0;

	textureCount = textureCount + 1;
	TextureMap.insert(pair&lt;int,Texture&gt;(textureCount,passedTexture));
	return textureCount;
}

BBDECL int BBCALL DX9_CopyImage(int image)
{
	Texture passedTexture = TextureMap[image];
	Texture newTexture;

	newTexture.cellHeight = passedTexture.cellHeight;
	newTexture.cellWidth = passedTexture.cellWidth;
	newTexture.extra = passedTexture.extra;
	newTexture.textureHeight = passedTexture.textureHeight;
	newTexture.textureWidth = passedTexture.textureWidth;
	newTexture.rotationX = 0;
	newTexture.rotationY = 0;
	newTexture.originX = 0;
	newTexture.originY = 0;
	
	D3DXCreateTexture(pD3DDevice,passedTexture.textureWidth,passedTexture.textureHeight,1,D3DUSAGE_RENDERTARGET,D3DFMT_R5G6B5,D3DPOOL_DEFAULT,&amp;newTexture.texture);
	

	for(DWORD level = 0; level &lt; newTexture.texture-&gt;GetLevelCount(); level++)
	{
		LPDIRECT3DSURFACE9 source = NULL;
		passedTexture.texture-&gt;GetSurfaceLevel(level, &amp;source);
		LPDIRECT3DSURFACE9 dest = NULL;
		newTexture.texture-&gt;GetSurfaceLevel(level, &amp;newTexture.pTextureSurface);
		if(FAILED(pD3DDevice-&gt;StretchRect(source, NULL, newTexture.pTextureSurface, NULL,D3DTEXF_NONE)))
		{
			return(0);
		}
	}
	

	textureCount = textureCount + 1;
	TextureMap.insert(pair&lt;int,Texture&gt;(textureCount,passedTexture));
	return textureCount;
}

//Only pass a render target created by DX9_CreateTargetImage
BBDECL VOID BBCALL DX9_SetRenderTarget(int image)
{
	Texture passedTexture = TextureMap[image];

	pD3DDevice-&gt;SetRenderTarget(0,passedTexture.pTextureSurface);
	pCurrentSurface = passedTexture.pTextureSurface;
}

//Return the drawing to the backbuffer
VOID DX9_SetDefaultRenderTarget() 
{
	pD3DDevice-&gt;SetRenderTarget(0,pBackBuffer);
	pCurrentSurface = pBackBuffer;
}

BBDECL VOID BBCALL DX9_SetRotation(float radians )
{
	rotation = radians;
}

BBDECL float BBCALL DX9_DegreeToRadian(int degrees) 
{
	return(degrees * (PI / 180));
}

BBDECL VOID BBCALL DX9_SetScale(float scaleX,float scaleY)
{
	scale.x = scaleX;
	scale.y = scaleY;
}

BBDECL VOID BBCALL DX9_MidRotation(int image)
{
	Texture passedTexture = TextureMap[image];

	passedTexture.rotationX = passedTexture.cellWidth/2;
	passedTexture.rotationY = passedTexture.cellHeight/2;
	TextureMap.erase(image);
	TextureMap.insert(pair&lt;int,Texture&gt;(image,passedTexture));

}

BBDECL VOID BBCALL DX9_RotationHandle(int image, int x,int y)
{
	Texture passedTexture = TextureMap[image];

	passedTexture.rotationX = x;
	passedTexture.rotationY = y;
	TextureMap.erase(image);
	TextureMap.insert(pair&lt;int,Texture&gt;(image,passedTexture));
}

BBDECL VOID BBCALL DX9_SetAlpha(float alphaLevel)
{
	alpha = alphaLevel;
}

BBDECL VOID BBCALL DX9_MidHandle(int image)
{
	Texture passedTexture = TextureMap[image];

	passedTexture.originX = passedTexture.cellWidth/2;
	passedTexture.originY = passedTexture.cellHeight/2;
	TextureMap.erase(image);
	TextureMap.insert(pair&lt;int,Texture&gt;(image,passedTexture));

}

BBDECL VOID BBCALL DX9_HandleImage(int image, int x, int y)
{
	Texture passedTexture = TextureMap[image];
	passedTexture.originX = x;
	passedTexture.originY = y;
	TextureMap.erase(image);
	TextureMap.insert(pair&lt;int,Texture&gt;(image,passedTexture));
}

//Note, the text functions below are normally slow, so, if
//you can, use bitmap fonts and these for debug stuff.
BBDECL int BBCALL DX9_LoadFont(LPCSTR font, int width, int height,BOOL italic)
{
	Font newFont;
	newFont.fontName = font;
	newFont.width = width;
	newFont.height = height;
	newFont.italic = italic;
	newFont.color = D3DCOLOR_ARGB(255,255,255,255);
	HRESULT hr;
	hr=D3DXCreateFontA(pD3DDevice,     //D3D Device
                     height,               //Font height
                     width,                //Font width
                     FW_NORMAL,        //Font Weight
                     1,                //MipLevels
                     italic,            //Italic
                     DEFAULT_CHARSET,  //CharSet
                     OUT_DEFAULT_PRECIS, //OutputPrecision
                     ANTIALIASED_QUALITY, //Quality
                     DEFAULT_PITCH|FF_DONTCARE,//PitchAndFamily
                     font,          //pFacename,
                     &amp;newFont.g_font);         //ppFont

	if (FAILED(hr))
	{
		MessageBoxA(screenWindow,"Cannot create font.","DX9 Error",MB_OK);
		return(FALSE);
	}

	fontCount = fontCount + 1;
	FontMap.insert(pair&lt;int,Font&gt;(fontCount,newFont));
	return fontCount;
}

BBDECL int BBCALL DX9_FontWidth(int font)
{
	Font passedFont = FontMap[font];
	return passedFont.width;
}

BBDECL int BBCALL DX9_FontHeight(int font)
{
	Font passedFont = FontMap[font];
	return passedFont.height;
}

BBDECL VOID BBCALL DX9_DrawText(LPCSTR text,int x, int y, BOOL centre, int font)
{
	if (drawImage == true)
	{
		drawImage = false;
		sprite-&gt;End();
	}

	Font passedFont = FontMap[font];
	TEXTMETRICA metrics;

	passedFont.g_font-&gt;GetTextMetricsA(&amp;metrics);
	if (centre == TRUE)
	{
		x = x - (DX9_FontWidth(font)*(strlen(text)))/2;
		y = y - (DX9_FontHeight(font)/2);
	}
	RECT font_rect={x,y,metrics.tmMaxCharWidth*(strlen(text)),metrics.tmHeight};

	passedFont.g_font-&gt;DrawTextA(NULL,        //pSprite
                                text,  //pString
                                -1,          //Count
                                &amp;font_rect,  //pRect
                                DT_LEFT|DT_NOCLIP,//Format,
                                passedFont.color); //Color

}

BBDECL VOID BBCALL DX9_DrawTextInt(int integer,int x, int y, BOOL centre, int font)
{
	if (drawImage == true)
	{
		drawImage = false;
		sprite-&gt;End();
	}

	char buf[MAX_PATH];
	sprintf(buf, "%d\0",integer);

	LPCSTR text = buf;
	Font passedFont = FontMap[font];
	TEXTMETRICA metrics;

	passedFont.g_font-&gt;GetTextMetricsA(&amp;metrics);
	if (centre == TRUE)
	{
		x = x - (DX9_FontWidth(font)*(strlen(text)))/2;
		y = y - (DX9_FontHeight(font)/2);
	}
	RECT font_rect={x,y,metrics.tmMaxCharWidth*(strlen(text)),metrics.tmHeight};

	passedFont.g_font-&gt;DrawTextA(NULL,        //pSprite
                                text,  //pString
                                -1,          //Count
                                &amp;font_rect,  //pRect
                                DT_LEFT|DT_NOCLIP,//Format,
                                passedFont.color); //Color
}

BBDECL VOID BBCALL DX9_DrawTextFloat(float float_,int x, int y, BOOL centre, int font)
{
	if (drawImage == true)
	{
		drawImage = false;
		sprite-&gt;End();
	}

	char buf[MAX_PATH];
	sprintf(buf, "%f\0",float_);

	LPCSTR text = buf;
	Font passedFont = FontMap[font];
	TEXTMETRICA metrics;

	passedFont.g_font-&gt;GetTextMetricsA(&amp;metrics);
	if (centre == TRUE)
	{
		x = x - (DX9_FontWidth(font)*(strlen(text)))/2;
		y = y - (DX9_FontHeight(font)/2);
	}
	RECT font_rect={x,y,metrics.tmMaxCharWidth*(strlen(text)),metrics.tmHeight};

	passedFont.g_font-&gt;DrawTextA(NULL,        //pSprite
                                text,  //pString
                                -1,          //Count
                                &amp;font_rect,  //pRect
                                DT_LEFT|DT_NOCLIP,//Format,
                                passedFont.color); //Color
}

BBDECL int BBCALL DX9_GetOSVersion()
{
		int winPlatform; 
    OSVERSIONINFOA VersionInfo;

    ZeroMemory(&amp;VersionInfo, sizeof(OSVERSIONINFOA));
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    GetVersionExA(&amp;VersionInfo);

	switch(VersionInfo.dwPlatformId)
	{
		case VER_PLATFORM_WIN32s:
			winPlatform = PLATFORM_WIN32s;
			break;
		case VER_PLATFORM_WIN32_NT:
			winPlatform = PLATFORM_WINNT;//Windows NT
			switch(VersionInfo.dwMajorVersion)
			{
				case 4:
					winPlatform = PLATFORM_WINNT;//Windows NT
					break;
				case 5:
					switch(VersionInfo.dwMinorVersion)
					{
						case 0:
							winPlatform = PLATFORM_WIN2000;//Windows 2000
							break;
						case 1:
							winPlatform = PLATFORM_WINXP;//Windows XP
							break;
					}
				case 6:
					winPlatform = PLATFORM_WINVISTA;//Vista
					break;
			}
			break;
		case VER_PLATFORM_WIN32_WINDOWS:
			switch(VersionInfo.dwMinorVersion)
			{
				case 0:
					winPlatform = PLATFORM_WIN95;//Win95
					break;
				case 90:
					winPlatform = PLATFORM_WINME;//WinME
					break;
				case 10:
					winPlatform = PLATFORM_WIN98;//Win98
					break;
			}
	}
	return(winPlatform);
}

BBDECL int BBCALL DX9_ImageWidth(int image) 
{
	Texture passedTexture = TextureMap[image];
	return passedTexture.cellWidth;
}

BBDECL int BBCALL DX9_ImageHeight(int image) 
{
	Texture passedTexture = TextureMap[image];
	return passedTexture.cellHeight;
}

BBDECL int BBCALL DX9_ImageCellAmount(int image) 
{
	Texture passedTexture = TextureMap[image];
	return passedTexture.extra;
}

//Thanks to Grey Alien for this one!
BBDECL BOOL BBCALL GiveDirectoryUserFullAccess(LPCTSTR dirPath)
{	
	HANDLE hDir = CreateFile(dirPath,READ_CONTROL|WRITE_DAC,0,NULL,OPEN_EXISTING,FILE_FLAG_BACKUP_SEMANTICS,NULL);
	if(hDir == INVALID_HANDLE_VALUE) return FALSE;
	
	ACL* pOldDACL=NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	GetSecurityInfo(hDir,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,&amp;pOldDACL,NULL,&amp;pSD);
	
	EXPLICIT_ACCESS ea={0};
	ea.grfAccessMode = GRANT_ACCESS;
	ea.grfAccessPermissions = GENERIC_ALL;
	ea.grfInheritance = CONTAINER_INHERIT_ACE|OBJECT_INHERIT_ACE;
	ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
	ea.Trustee.ptstrName = TEXT("Users");
	
	ACL* pNewDACL = NULL;
	SetEntriesInAcl(1,&amp;ea,pOldDACL,&amp;pNewDACL);
	
	SetSecurityInfo(hDir,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,pNewDACL,NULL);
	
	LocalFree(pSD);
	LocalFree(pNewDACL);
	CloseHandle(hDir);
	return TRUE;
}

//Release Image and font (Also used in DX9_End(void))
BBDECL int BBCALL DX9_ReleaseFont(int font)
{
	Font passedFont = FontMap[font];
	if (passedFont.g_font != NULL)
	{
		passedFont.g_font-&gt;Release();
		passedFont.g_font = NULL;
		FontMap.erase(font);
	}
	return(FontMap.size());
}

BBDECL int BBCALL DX9_ReleaseImage(int image)
{
	Texture passedTexture = TextureMap[image];
	if (passedTexture.texture != NULL)
	{
		passedTexture.texture-&gt;Release();
		passedTexture.texture = NULL;
		if (passedTexture.pTextureSurface != NULL)
		{
			passedTexture.pTextureSurface-&gt;Release();
			passedTexture.pTextureSurface = NULL;
		}
		TextureMap.erase(image);
	}
	return(TextureMap.size());
}
//Release all resources
BBDECL VOID BBCALL DX9_End()
{

	//Clear out textures
	for(int loop = 0;loop &lt; textureCount; loop = loop + 1)
	{
		DX9_ReleaseImage(loop);
	}

	TextureMap.clear();
	
	//Clear out fonts
	for(int loop = 0;loop &lt; fontCount; loop = loop + 1)
	{
		DX9_ReleaseFont(loop);
	}

	FontMap.clear();

	//Show the cursor if we are ending the app
	ShowCursor(true);
	pD3DDevice-&gt;ShowCursor(true);
	
	//Release all DirectX related guff
	pD3D-&gt;Release(); 
	pD3DDevice-&gt;Release();
	pBackBuffer-&gt;Release();
	pCurrentSurface-&gt;Release();
	sprite-&gt;Release();
}
</pre><br><br>Decls file:-<br><br><pre class=code>
.lib "DX9DLL.dll"

DX9_Graphics%(resWidth%,resHeight%,resFormat%,hWnd%,bWindowedMode%,synced%):"_DX9_Graphics@24"
DX9_Cls():"_DX9_Cls@0"
DX9_Flip():"_DX9_Flip@0"
DX9_SetClsColor(r%,g%,b%,a%):"_DX9_SetClsColor@16"
DX9_ShowPointer():"_DX9_ShowPointer@0"
DX9_HidePointer():"_DX9_HidePointer@0"
DX9_LoadImage%(imageFilepath$):"_DX9_LoadImage@4"
DX9_DrawImage(hImage%,x%,y%):"_DX9_DrawImage@12"
DX9_DrawAnimImage(hImage%,x%,y%,frame%):"_DX9_DrawAnimImage@16"
DX9_DrawImageRect(hImage%,x%,y%,top%,left%,width%,height%):"_DX9_DrawImageRect@28"
DX9_DrawAnimImageRect(hImage%,x%,y%,top%,left%,width%,height%,frame%):"_DX9_DrawAnimImageRect@32"
DX9_LoadMaskedImage%(imageFilePath$,r%,g%,b%):"_DX9_LoadMaskedImage@16"
DX9_LoadAnimImage%(imageFilePath$,cellWidth%,cellHeight%,cellAmount%):"_DX9_LoadAnimImage@16"
DX9_LoadMaskedAnimImage%(imageFilePath$,cellWidth%,cellHeight%,cellAmount%,r%,g%,b%):"_DX9_LoadMaskedAnimImage@28"
DX9_ReleaseImage%(image%):"_DX9_ReleaseImage@4"
DX9_CreateTargetImage%(width%,height%):"_DX9_CreateTargetImage@8"
DX9_SetRenderTarget(hTargetImage%):"_DX9_SetRenderTarget@4"
DX9_SetDefaultRenderTarget():"_DX9_SetDefaultRenderTarget@0"
DX9_CopyImage%(hImage%):"_DX9_CopyImage@4"
DX9_DegreeToRadian(degree%):"_DX9_DegreeToRadian@4"
DX9_SetScale(scalex#,scaleY#):"_DX9_SetScale@8"
DX9_SetRotation(radians%):"_DX9_SetRotation@4"
DX9_MidRotation(hImage%):"_DX9_MidRotation@4"
DX9_RotationHandle(hImage%,x%,y%):"_DX9_RotationHandle@12"
DX9_SetAlpha(alpha#):"_DX9_SetAlpha@4"
DX9_MidHandle(hImage%):"_DX9_MidHandle@4"
DX9_HandleImage(hImage%):"_DX9_HandleImage@4"
DX9_LoadFont%(font$,width%,height%,italic%):"_DX9_LoadFont@16"
DX9_FontWidth%(hFont%):"_DX9_FontWidth@4"
DX9_FontHeight%(hFont%):"_DX9_FontHeight@4"
DX9_ReleaseFont(hFont%):"_DX9_ReleaseFont@4"
DX9_DrawText(text$,x%,y%,centre%,hFont%):"_DX9_DrawText@20"
DX9_DrawTextInt(int%,x%,y%,centre%,hFont%):"_DX9_DrawTextInt@20"
DX9_DrawTextFloat(float#,x%,y%,centre%,hFont%):"_DX9_DrawTextFloat@20"
DX9_MouseX%():"_DX9_MouseX@0"
DX9_MouseY%():"_DX9_MouseY@0"
DX9_GetOSVersion%():"_DX9_GetOSVersion@0"
DX9_ImageWidth%(hImage):"_DX9_ImageWidth@4"
DX9_ImageHeight%(hImage):"_DX9_ImageHeight@4"
DX9_ImageCellAmount%(hImage):"_DX9_ImageCellAmount@4"
GiveDirectoryUserFullAccess%(dirPath$):"_GiveDirectoryUserFullAccess@4"
DX9_End():"_DX9_End@0"
</pre><br><br>Download: <a href="http://www.blitzmonkeys.com/adminfiles/dabz/DX9DLL.zip" target="_blank">http://www.blitzmonkeys.com/adminfiles/dabz/DX9DLL.zip</a><br><br>Havent had time to do the sound stuff, but you may be able to muster that yourself if you really need it.<br><br>Dabz <br><br></td></tr></table><br>
<a name="972785"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sauer</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey thanks a million, I really appreciate it. <br><br></td></tr></table><br>
<a name="972818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> No worries! ;)<br><br>There may be the odd typo in the DECLS file, most of it is untested (But theoretically it should work) at the time, but check return types or function parameters against the C++ source (If anything goes screwy), other than that, the DLL should build straight off the bat in Visual C++ 2008 Express!   <br><br>Just remember to read the ickle readme.txt file, nothing major, just a little info thats all! :)<br><br>Dabz <br><br></td></tr></table><br>
<a name="972838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GaryV</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you, Dabz. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
