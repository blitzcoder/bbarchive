<!DOCTYPE html><html lang="en" ><head ><title >Perfs 3 vertices per triangle vs shared vertices</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Perfs 3 vertices per triangle vs shared vertices</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Perfs 3 vertices per triangle vs shared vertices</a><br><br>
<a name="1174868"></a>

<a name="1174869"></a>

<a name="1174870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello,<br><br>I am wondering if it is better (for the render and for the perfs) to use a mesh with several triangles with shared vertices or to use a mesh with several triangles with 3 vertices per triangle.<br><br>Why would i need 3 vertices per triangle you may ask ?<br>Because it is easier to do UVMapping (to set the UV coords) without having to unweld individual triangle or groups of triangles.<br><br>Moreover i think it should be possible to recalculate all vertices normals in order to have a progressive lighting even if each triangle has its own 3 vertices.<br><br>Your thoughts about this ? It seems 3D World Studio does that, each triangle has its own 3 vertices (or 4vertices when it is a quad).<br><br>I ask this because i may decide code a building modeler and UVMapping is a complicated matter.<br><br>Thanks,<br><br><font class="tiny">Last edited 2013</font> <br><br></td></tr></table><br>
<a name="1174875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not an expert but fewer verts = smaller data set which makes any searching or scanning pass on an object potentially significantly faster... as relates render time I don't think it would matter much since it renders tris and the tris reference their verts so shouldn't make a difference there. Just more memory and if you're searching for a vert for any reason (projection or collision testing perhaps) could take way long since your vert count could be ~3x as big. 3x more verts is 3x more memory for verts but that's still trivial memory use compared with say a single texture so wouldn't be too concerned about that. <br><br></td></tr></table><br>
<a name="1174877"></a>

<a name="1174878"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>as relates render time I don't think it would matter much since it renders tris and the tris reference their verts so shouldn't make a difference there. Just more memory<br> <br></div><br>Thanks for the explanation ima747, this is good if it does not increase the render time.<br><br>About the collision calculation i don't care because i will use low tris colliders.<br><br>And about the memory i don't think this will be a problem to have a few more vertices stored.<br><br>Ok!<br><br><font class="tiny">Last edited 2013</font> <br><br></td></tr></table><br>
<a name="1174895"></a>

<a name="1174896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have done some tests and it seems that more vertices = more render time !<br>I am surprised about this.<br>I don't know exactly how 3d rendering works but i thought that each vertex of each triangle was retrieved and thus the number of vertices would not matter. But apparently it is not so.<br><br>For the same shape,<br>Render3d takes around 22ms with 100 meshes with shared vertices between some triangles<br>and Render3d takes around 33ms with 100 meshes with 3 vertices per triangle<br><br>If you are interested you can download the example here : <br><a href="http://rd-stuff.fr/Triangles_with_shared_vertices_vs_triangles_with_3_vertices_2013.01.27_18h48m.zip" target="_blank">http://rd-stuff.fr/Triangles_with_shared_vertices_vs_triangles_with_3_vertices_2013.01.27_18h48m.zip</a><br><br>Not good for me, but i can't change it, so i guess i have to find another way to achieve what i want. <br><br></td></tr></table><br>
<a name="1174902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> More vertices will slowdown T&amp;L (transform and lighting).<br><a href="http://en.wikipedia.org/wiki/Transform,_clipping,_and_lighting" target="_blank">http://en.wikipedia.org/wiki/Transform,_clipping,_and_lighting</a> <br><br></td></tr></table><br>
<a name="1175023"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SystemError51</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I don't know exactly how 3d rendering works but i thought that each vertex of each triangle was retrieved and thus the number of vertices would not matter. <br></div><br><br>You need to store the data for the vertices somewhere. You usually do this in the GPU's memory for super-fast access.<br><br>In the past, most people have been using something known as a <i>Display List</i> - with it, you were able to store a sequence or vertices, including their normal data and whathaveyou, and then later call the list with just one operation. Extremely effective for static geometry.<br><br>However, today I would recommend using something known as <i>Vertex Buffer Objects</i>. They essentially allow for the same thing, except that you can manipulate vertices even when they are already stored in the GPU's memory. They are arguably one of the fastest method to render geometry.<br><br>Here's a bit more info on those:<br><br><a href="http://en.wikipedia.org/wiki/Vertex_Buffer_Object" target="_blank">http://en.wikipedia.org/wiki/Vertex_Buffer_Object</a><br><a href="http://www.songho.ca/opengl/gl_vbo.html" target="_blank">http://www.songho.ca/opengl/gl_vbo.html</a><br><a href="http://nehe.gamedev.net/tutorial/vertex_buffer_objects/22002/" target="_blank">http://nehe.gamedev.net/tutorial/vertex_buffer_objects/22002/</a><br><br>Hope that helps. <br><br></td></tr></table><br>
<a name="1175053"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Beaker and SystemError51&gt;&gt;<br>Thanks for the links, i will take a look. <br><br></td></tr></table><br>
<a name="1175161"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd take a guess that the hardware can reuse shared verts. As in, for two triangles with two shared vertices it has to transform all three verts for the first triangle, but can then reuse the two shared verts when processing the second triangle. <br><br>Ideal conditions would give you ~1 vertex T&amp;L calculation per triangle, instead of with separate verts that you suggested, which would require 3 T&amp;L calculations per triangle. <br><br></td></tr></table><br>
<a name="1175198"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> agree with zzz, re-using the calculations performed on the verts is the time saving in the render pass. I think there's proabably some pretty significant ways one could optimize the renderer for non-recycled verts, but there could be some pretty major implications in other areas (like beaker said, T&amp;L). It's going to depend on how your renderer works in addition to the hardware in the eld. Fundamentally more is always more, and that *usually* means more work to process the more data. The exception to that rule is when you're using more data/memory as form of pre-processing in a way (simple example is precalculating rotation maps etc. where you're doing the work once then storing it so you can just access an array rather than run the calculations again and again). My previous assumption was based on a) no operations being performed in time critical points on vertexes b) vertexes being referenced from a render pass on a tri, so the verts themselves are never directly sorted or accessed accept as a reference. This is not likely to be how the hardware accelerator is going to handle things with anything particularly modern. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
