<!DOCTYPE html><html lang="en" ><head ><title >Ref counting and Mark and sweep</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Ref counting and Mark and sweep</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Ref counting and Mark and sweep</a><br><br>
<a name="1185909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Has anyone any experience mixing the two? ref counting could theorically (not sure if it is a good idea) allow for faster collection when there are no cyclic references at a very slow cost and mark and sweep could be used with less overhead (as most died object would have been already collected by the ref counting) so pauses would be smaller...<br>But, as everything related to performance... you can't be sure unless you actually test it so, before I spend a month or the like, has anyone tested this before and, is there any conclusion that could be helpful? <br><br></td></tr></table><br>
<a name="1185912"></a>

<a name="1185915"></a>

<a name="1185916"></a>

<a name="1185917"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wrote an obscenely long post on this topic yesterday which may be of some interest to you: <a href="http://www.blitzbasic.com/Community/post.php?topic=100424&amp;post=1185874" target="_blank">http://www.blitzbasic.com/Community/post.php?topic=100424&amp;post=1185874</a><br><br><br>Short version: there is no "best" solution to memory management - it depends <i>very</i> much on the language, and the programs you expect to be written in that language.<br><br>-- Which language? (If this is for your own, which languages is it most like?)<br>-- is it a toy, research project, or production quality?<br>-- Do you care about real-time interactivity or only overall speed?<br>-- How many objects do you expect it to allocate?<br>-- How often? What is their lifespan likely to be?<br>-- How large are they? How much do they vary?<br><br>BlitzMax for instance counts as a language with a "small" number of "large" objects with "long" lifespans (objects with many fields allocated into a collection and used throughout the playtime of a level). Lisp is a language with a "large" number of "varying" objects with "either long or short" lifespans (you might have some big vectors, but there are a lot of tiny cons cells to manage). Haskell is a language with a "very large" number of "small" objects with "extremely short" lifespans (huge numbers of temporary tuples created between function calls - think GB/sec).<br><br><br>The more you tend towards large numbers of small objects changing owners frequently, the less efficient refcounting becomes. The reference counting for a language at Haskell's extreme will be significantly slower than tracing, and if your objects are generally small, the count field itself may become a significant waste of memory (if you're a Lisp mostly playing with two-word cons cells, adding a third word for the count can increase memory usage by <i>over 100%</i>... see further). A language manipulating small objects will also benefit greatly from a tracing GC's ability to move objects around in memory to make it more cache-friendly. A language that uses a lot of similar tiny objects like cons cells may save on memory by compressing them into smaller spaces or sharing objects (e.g. hash-consing and cdr-coding are techniques that allow Lisps to share the same space for multiple objects; cdr-coding can remove all of the memory overhead of list nodes, for instance); using refcounting would prevent this sort of optimisation.<br><br>The more you tend towards small numbers of large objects, the more efficient refcounting becomes as there are fewer updates and it uses less memory. Towards the BlitzMax end of the scale refcounting may start to outperform tracing.<br><br>The <i>general</i> guideline most people assume nowadays is that you should assume tracing is faster than refcounting until you've proven otherwise. Note that a production-quality tracing GC will <i>not</i> search the entire dataset but will divide the data into generations, so it only normally needs to trace a few objects at a time (something like 90% of objects never live past their first assignment, so you mostly only need to repeatedly scan the last ~1MB of allocations). A production-quality reference counter will use static analysis (a la ARC) to remove as many of the refcount updates as possible at compile-time; the goal with reference counting is, bizarrely, <i>not to count</i> references wherever possible. Note also that performance can mean two unrelated things: <i>total</i> execution time (almost always better to use tracing), which disregards pauses and only measures time from start to finish; and <i>real-time</i> execution, which uses algorithms that are slower overall to ensure no noticeable pauses creep in.<br><br><br>In either case, a naive one-pass mark-and-sweep that doesn't move objects, and a naive reference counter that updates counts on every access, will both be slow compared to production runtimes. They are also <i>by far</i> the best options for a toy or research (assuming it's not GC research) compiler, because they're simple and readable and you don't normally care about eking every last bit of performance out.<br><br>For a production-grade project... start by using a third-party GC and tweak as necessary. The <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/" target="_blank">Boehm GC</a> is general-purpose and can slot into any language and is fast enough for real-world use. Although it pauses, it is likely to be much faster than a naive implementation of any algorithm because... well, it's a massive corporate effort.<br><br>Other third party options include ARC, for refcounting (compile to something you can run through Clang), or the GC behind <a href="http://www.rscheme.org/rs/index.html" target="_blank">RScheme</a> (which is real-time, <i>no pauses</i>), and designed to be retargetable.<br><br><br>On the matter of combining approaches, conventional wisdom is that combining refcounting and tracing isn't especially effective as you will end up with the worst of both worlds (the trace will have to run either way to catch the cycles, especially if it's conservative rather than precise; and you still have the overhead of the refcounts while you aren't tracing). The advanced research compilers <a href="http://www.itu.dk/research/mlkit/index.php/Main_Page" target="_blank">MLKit</a> and <a href="http://en.wikipedia.org/wiki/Stalin_%28Scheme_implementation%29" target="_blank">Stalin</a> both ignore refcounting and instead use <a href="http://en.wikipedia.org/wiki/Region-based_memory_management" target="_blank">regions</a> (a kind of pool allocation), which can be dramatically faster <i>as long as</i> the programs written don't exhibit "unusual" object lifespans (e.g. a lot of objects being created deep down the call chain and passed all the way up to the top level, bypassing region boundaries).<br><br><br>Finally... if your language has "interesting" semantics, you don't need to be constrained by convention! e.g. if you use a linear type system, you can completely get rid of any runtime memory management at all (except moving, if you want it)! The downside being that the language requires you to program in a very different way, and be more aware of dataflow and ownership. <br><br></td></tr></table><br>
<a name="1185918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Yasha!<br>It's for one personal researh project that is not aimed to production-quality, but more or a learning project.<br>My idea was/is to try to get a working generational mark&amp;sweep GC. I think the C++ implementation of Bohm GC does take into account threading and all the abomination you can do with pointers in C++. I don't think I need something this complex for a start but, I don't know, it's the first time I'm working in the creation of a GC! <br><br></td></tr></table><br>
<a name="1185922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> If it's your very first time, a really simple GC to copy might be PicoLisp's: http://picolisp.com/5000/!wiki?home<br><br>One-pass, no moving, fits in ~20 lines of C (trivially possible to make it nonrecursive too, maybe make that your first upgrade). It's a good demonstration too of how sometimes "fast enough" is all you want, because its simplicity means it actually is pretty fast. Simplest GC implementation I know of.<br><br>It is not generational. I couldn't recommend a "simple" generational GC to look at sadly. <br><br></td></tr></table><br>
<a name="1185925"></a>

<a name="1185926"></a>

<a name="1185927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Yasha: How safe would be to make the final collection of dead object, on a Mark&amp;Sweep on a separated thread? If they're dead, sohuldn't it be safe by definition? (I'm just sitting in my table, with some paper, a pen, and trying to organize ideas, but as you seem to have worked this road before, maybe you have something useful to say (I mean, something more)<br><br>EDIT: The only think that comes to my mind would be that any complete mem copy to prevent fragmentation should (maybe?) be performed once the dead code mem is free? <br><br></td></tr></table><br>
<a name="1185983"></a>

<a name="1185984"></a>

<a name="1185986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's some information that might help introduce this topic <a href="http://stackoverflow.com/questions/2583644/difference-between-background-and-concurrent-garbage-collection" target="_blank">here</a> and <a href="http://msdn.microsoft.com/en-us/library/ee787088.aspx#concurrent_garbage_collection" target="_blank">here</a>.<br><br>I'll warn you now though: as with every other time threading rears its head, adding it to GC is going to be <i>hard</i>. I would investigate things like incremental or generational GC first if possible.<br><br><br>Anyway the direct answer to your question is (annoyingly, as always), "it depends". Basically it depends on what is involved in freeing objects. Simple plain old data is normally not "freed" as such, especially in a copying GC, because it will have been allocated form a larger pool block and will just be forgotten about, to be overwritten either by a new object, or when the data in the pool is compacted.<br><br>-- if the object isn't plain old data, but is something external that needs to be finalised, wherever that other stuff is, it will need to be locked for the freeing thread<br>-- only one thread can compact one pool at a time<br>-- if a thread needs to access data from elsewhere in the program while freeing an object, it will need to have locked access to whatever is allocated there<br><br>So to grossly oversimplify, what it comes down to is that you end up having multiple smaller pools that objects are equally likely to be allocated from; some of these can be collected by threads in the background while others are doing useful work. Any one pool though has to be treated as a whole unit; that pool's work thread will be paused while it's being collected. If a collector thread needs access to information in a work thread's pool to finalise an object, the work will get paused; and if a work thread needs access to data in a pool currently being compacted, the work will have to wait. So it's only a pause-<i>reduction</i> system, not a complete pause-elimination system; eventually a collector thread is likely to have to lock a work thread for one reason or another (in practice a large enough number of pools may well be enough to eliminate all noticeable pauses, so it's still worth investigating). If you read the link, Microsoft also are happy to pause threads for young-generation collections because they feel it's fast enough not to be a problem in practice.<br><br>For elimination of pauses altogether you're likely to have better results from an incremental GC. The two could also be combined; perhaps more practical to rely on single-threaded means to reduce or eliminate pauses, and simply split the heap into separate areas for the purpose of actually enabling multithreading at all, rather than using multithreading as your principal GC accelerator.<br><br><br>(As for my own experience... extremely limited. I have never investigated implementing a complicated GC; in my own work, I'm mainly interested in static analysis to try to reduce the need for it at all, and just use a naive one to clean up the extras.) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
