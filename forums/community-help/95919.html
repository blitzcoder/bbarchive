<!DOCTYPE html><html lang="en" ><head ><title >Strings in C : Question!</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Strings in C : Question!</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Strings in C : Question!</a><br><br>
<a name="1107712"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a particularly random question but wow, handling strings in C is really complicated. I've figured out how to handle strings now but I can't seem to figure out how to delete the contents of a string without getting a compiler warning. <br><br>Anyone know how to do this cleanly? <br>For example, I have a 3 character string and so far I am deleting it like this:-<br><br><pre class=code>
grabbed_string = { '\0','\0','\0' } ;
</pre><br><br>I always get the error <pre class=code>"extended initializer lists only available with -std=c++0x or -std=gnu++0x"</pre><br><br>I don't understand the warning but everything works ok and the string is being deleted as it is intended to be. But still, I'd like to know what is wrong.<br><br>Any tips? :) <br><br></td></tr></table><br>
<a name="1107717"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AltanilConard</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cant you use grabbed_string = ""; ? <br><br></td></tr></table><br>
<a name="1107719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> You would think that would work wouldn't you? But you can't do that in C, it will throw an error. Something along the lines of "You can't assign a const to a non const variable" type of error.<br><br>C is fiddly, for example you can't even do stringa = stringb; <br><br></td></tr></table><br>
<a name="1107720"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AltanilConard</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, you'd use a char* ofc, something like:<br><pre class=code>
char* str = "hello";
printf("%s \n", str);
str = "bye";
printf("%s \n", str);
</pre><br>should work. What are you trying to do? <br><br></td></tr></table><br>
<a name="1107722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I was using a char and not a char* despite the fact I was passing a char* into a function.<br>What I am simply trying to do loop through each character of a string and pick out a single character Mid$ style. It works but kept coming up with that warning. But clearly I was just declaring the string incorrectly. <br><br></td></tr></table><br>
<a name="1107724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Are we talking about plain C here, or C++? C doesn't actually have strings; it has 'arrays of characters'.<br><br>Conard: My C is very rusty but I think that code will just create a memory leak. <br><br></td></tr></table><br>
<a name="1107727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AltanilConard</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pointers get me so confused. <br>big10p is right, in my example "hello" is still in memory; you must somehow free it and allocate new.<br>I'm going to open that old C book and read the pointer chapter once again. <br><br></td></tr></table><br>
<a name="1107729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Actually, I'm not sure there is a way to free string memory. G'ah, can't remember. <br><br></td></tr></table><br>
<a name="1107730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Canardian</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just use C++ string. They are faster than any self-written C string functions with all the dynamic memory allocation and releasing. <br><br></td></tr></table><br>
<a name="1107737"></a>

<a name="1107739"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't really understand the question, but the basic thing you need to remember is that there are no strings in C; you have to allocate and deallocate blocks of memory manually. I have no idea what you're <i>trying</i> to do in the first post, but you're definitely not deleting a string, just putting another one into the variable.<br><br>Meanwhile, the string <i>syntax</i> is just a nice shortcut that creates a statically allocated block of characters somewhere in the executable's memory (so you shouldn't free or modify those or you will invoke our friend Undefined Behaviour!).<br><br>Judging by your first listed error message, if you're using C++ rather than C (they aren't the same language!), Lumooja's right: you're better off using C++ strings instead, which provide a lot of the Basic-style syntax you're used to and largely look after themselves.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1107800"></a>

<a name="1107801"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Conard's code won't leak memory. String literals which are embedded into the code are stored once in a global memory region (as Yasha described). When you make the pointer equal "hello", it sets the pointer to that (constant) memory block. Then you make the pointer equal "bye", it sets the pointer to the bye memory block. When you go through the function again, it just sets back to "hello" again. There is only ever one set of "hello" and "bye" in memory. They are basically stored in global arrays, and you only reference them. The code snippet allocates NO dynamic memory.<br><br>The original code doesn't work because you can only use { } syntax to initialize something for the first time, not give it another value later. It's also important to understand the difference between char and char *.<br><br>If you can, std::string in C++ is a lot easier to use (although still not as nice as Blitz strings). C-style strings are faster if you are doing something heavy duty, but I wouldn't worry about it in general.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1107890"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know it's easy to just include the C++ string header file but doing so takes up valuable memory which is why I was doing it in C. I just wanted to know how to nullify a string in C so that the string is empty. \0 certainly does the trick except for the warning. <br><br></td></tr></table><br>
<a name="1107894"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I just wanted to know how to nullify a string in C so that the string is empty. <br></div><br><br>The point is that it depends very much on what you mean by "nullify", because (as is pointed out above), C doesn't have a string type and therefore you could be talking about a couple of different operations that a Basic style string system would handle behind the scenes.<br><br>Setting all characters to 0 will cause standard string functions to think that you're passing "", but the object in memory <i>will be the same size</i> - because it's still the same object (incidentally, you should only need to set the first character to 0 as such functions iterate along the string to find the end point - setting anything past that is unnecessary, so you could do grabbed_string[0] = 0).<br><br>Anyway, this means that you're still using memory for the characters you aren't using, and can't put more than that number of characters into that buffer. Also, unless you store the length of the buffer somewhere, you won't have any safe way to re-lengthen the string (within the bounds of the buffer).<br><br>The simple solution with C strings is to simply allocate a new string each time you want something new, and free the old one. Behind the scenes reference counting as used by BlitzMax (and most other languages that have a string type) is kinda useful for this. Actually modifying strings in place is really not recommended for most tasks (certainly nothing resembling the way you would use strings in Blitz).<br><br>To sum it up: C <i>does not support strings</i> in any meaningful way, and if you want to use C-style strings you need to stop thinking about them as a value type the way one does for Blitz, because they aren't. <br><br></td></tr></table><br>
<a name="1107896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's really advice yasha, I thought though that my securing a bit of memory and just nullifying it each time that it would be the most useful approach. Setting all the characters to zero isn't a null string since it actually contains something. If you know how to deallocate and allocate new stings then that would be really handy information to know. <br><br></td></tr></table><br>
<a name="1107902"></a>

<a name="1107906"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If you know how to deallocate and allocate new stings then that would be really handy information to know. <br></div><br><br>Uh... malloc, generally (or whatever allocator function you're using):<br><br><pre class=code>char * my_str = malloc(sizeof(char) * (desired_length + 1));</pre><br><br>...remembering of course that the contents of this block are undefined until you put something in them. You need to then manually set the characters, and manually set the null character.<br><br>To be honest, if you're not already familiar and totally comfortable with using malloc and free, and happy using C pointers, you'll have some difficulty with this. Strings grow out of basic C-language principles.<br><br>Say you wanted to do this (Blitz), where s1 and s2 are strings:<pre class=code>s1 = s1 + s2</pre><br>...in C, you'd do something more like:<br><pre class=code>char * temp = malloc(sizeof(char) * (strlen(s1) + strlen(s2) + 1));
strncpy(temp, s1, strlen(s1));
strncpy(temp + strlen(s1), s2, strlen(s2) + 1);
free(s1);
s1 = temp;</pre><br>... phew (hopefully I got that right). Now you could wrap this up and make it tidier, but you have to understand that you're still doing something like that.<br><br>Note also that C++ strings won't suffer from memory leaks if you get it wrong: your program may get a bit bigger, but it will be a lot more reliable and readable.<br><br><div class="quote"> I thought though that my securing a bit of memory and just nullifying it each time that it would be the most useful approach. <br></div><br><br>If your string is some kind of code or identifier, and is always the same length, you could arguably do something like this. It really depends so much on what you want to do.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1107943"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> As Yasha states, there are many different ways of handling strings in C/C++, each with their pros and cons. For example, malloc'd strings are considerably slower than stack-based strings. Is saving a few bytes worth it?<br><br>If you explain exactly what you are trying to do, we could make some better recommendations.<br><br>Warnings in C shouldn't be ignored unless you know what they entail. What is the warning?<br><br>Note that you CANNOT modify string literals. The following code is very bad.<br><br><pre class=code>char * mystr = "Hello there";
mystr[0] = '\0';</pre><br>This is because it alters the actual static memory where the string literal is stored. The next time you come across that line, "Hello there" has actually been permanently erased!<br><br>If you want to modify the string, you will need to create your own storage and copy the string.<br><br>My old-style C is a bit rusty, so this may have syntax errors..<br><br>Either you can go down the stack or dynamic route. Stack is much faster, but your string must have a fixed upper size and the string doesn't survive beyond that level of scope. Dynamic is slower, but you can pick your size at run-time and return the string (or more correctly, a pointer to the string) from the function.<br><br>Stack<br><pre class=code>void f()
{
	char mystring[32]; /* max 31 char + 1 terminating char, don't forget to accomodate it */
	strcpy(mystring, "Hello world");
	mystring[5] = '\0';
	/* go nuts */

	/* DON'T DO THIS. you couldn't anyway because of the function being void.. */
	return mystring; /* does not exist after function */
}</pre><br><br>As a shortcut, you can initialize an array from a string literal and let it determine the size for you automatically.<br><br><pre class=code>char mystring[] = "Hello there"; /* takes just enough space */</pre><br><br>The advantage of the first method is you could give yourself more room if you want to expand the string.<br><br>This uses stack storage, which is fixed, eg 4mb stack. Saving a few bytes here and there won't affect any memory usage and probably won't risk stack overflow unless your strings are hundreds of characters in size simultaneously.<br><br>Here is dynamically<br><pre class=code>void f()
{
	static char * datasource = "Hello world"; /* don't modify this pointer */
	/* allocate enough storage for the source string, 32 extra characters and don't forget the terminator */
	char * mystring = (char *) malloc(sizeof(char) * (strlen(datasource) + 32 + 1));
	/* copy the source string */
	strcpy(mystring, datasource);

	/* this can append to a string, give it a pointer to the current position of the first terminating character. overflow its size at your peril */

	sprintf(mystring + strlen(datasource), "%s", "I am adding");

	printf("%s", mystring"); /* "Hello worldI am adding" */

	/* remember or it will leak */
	free(mystring);

	/* you could also return this string from the function and it will still exist. but you must free it at some point, free it only once and not use any pointers to the memory block after it has been freed */

}</pre> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
