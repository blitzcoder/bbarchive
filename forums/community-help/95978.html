<!DOCTYPE html><html lang="en" ><head ><title >Paid Job: Seeking recursion expert</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Paid Job: Seeking recursion expert</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Paid Job: Seeking recursion expert</a><br><br>
<a name="1108730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AarbronBeast</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys.<br><br>I am looking for someone to write me an algorithm that solves the problem below.  I will be able to pay a nominal amount (of money) for a program that completely and efficiently solves the problem correctly.  Could use this today or tomorrow.  Any takers?<br><br>I am looking for an algorithm that solve the following problem (please read carefully as this isn't your typical straightforward combination logic):<br><br>Given a set of unique items, write an algorithm that walks through all of the possible combinations of GROUPS of items, avoiding duplicate groups and duplicate items.<br><br>For example: A set of 5 items can be grouped as follows:<br>1 group of 5 items<br>1 group of 1 item + 1 group of 4 items<br>1 group of 2 items + 1 group of 3 items<br>2 groups of 1 item + 1 group of 3 items<br>2 groups of 2 items + 1 group of 1 item<br>3 groups of 1 item + 1 group of 2 items<br>5 groups of 1 item<br><br>(I think I listed them all.  It gets a lot more complicated the more items you have.)<br><br>Knowing the complete set of possible groupings, the final output should look like this (given items A, B, C, D and E):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
-1 GROUP
[ABCDE] 

-2 GROUPS
[A] [BCDE]
[B] [ACDE]
[C] [ABDE]
[D] [ABCE]
[E] [ABCD]
[AB] [CDE]
[AC] [BDE]
[AD] [BCE]
and so on…

-3 GROUPS
[A] [B] [CDE] 
[A] [C] [BDE]
[A] [D] [BCE]
and so on…

-4 GROUPS
[A] [B] [C] [DE] 
[A] [B] [D] [CE]
[A] [B] [E] [CD]
and so on…

-5 GROUPS
[A] [B] [C] [D] [E]

&lt;end&gt;
</textarea><br><br>Requirements:<br>1) The number of group sections will always equal the total number of items.<br>2) Must use EACH of the items in the set ONCE for each row of data.  (i.e. No duplicate items.)<br>3) A row of data should not exist on another row in the same section with a different group order (for example, [A] [BCDE] and [BCDE] [A] are the same and need to be avoided.)<br>4) Likewise, items within a data row's grouping should not be duplicated on a different row within a section out of sequence. (meaning [A] [BCDE] and [A] [DCBE] are the same, and need to be avoided.)<br>5) Recursion is probably the best way to solve this, but please avoid using any sort of outside libraries or uncommon functions.  The logic should be written by using only the core language elements (arrays, variables, conditionals, loops, subroutines, etc…)<br>6) Can be programmed in BlitzMax, or any other "easily readable language" so that it can be translated to other languages without too much hassle.  The program must be able to output the results to prove it works.<br><br>I spent more than enough time on it already, and I couldn't figure out a good way to do it.  If you are interested in getting paid for your work, please check with me first for authorization.<br><br>Anyone want the job? <br><br></td></tr></table><br>
<a name="1108732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have done stuff similar to this before, I could take a go, <br>If I find I cant do it you dont have to pay me of course <br><br></td></tr></table><br>
<a name="1108748"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AarbronBeast</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, slenkar.  How long do you think it'll take you to figure something out? <br><br></td></tr></table><br>
<a name="1108776"></a>

<a name="1108779"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mathematically this problem is "generate all partitions of a set of size n". You can find plenty of algorithms online.<br><br>The number of partitions is called the <a href="http://www.dnull.com/bells/bell1000.html" target="_blank">Bell Numbers</a> and grows exponentially. By n=16 it is over a billion.<br><br>So I hope you don't need this for anything but very small n.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1108797"></a>

<a name="1108798"></a>

<a name="1108803"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AarbronBeast</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Floyd.  I didn't know what this math subject was called, so I was unable to find anything.  I'll have a look.  Billions sounds like a lot, and it's certainly possible that I'll have lots more than 16 items.  I might have to think of a different way to approach the problem.<br><br>slenkar, maybe you can hold off.  I might be able to make sense of the algorithms online or change my mind altogether.<br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1108800"></a>

<a name="1108802"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's some c code, which I got from <a href="http://compprog.wordpress.com/2007/10/15/generating-the-partitions-of-a-set/" target="_blank">http://compprog.wordpress.com/2007/10/15/generating-the-partitions-of-a-set/</a><br>I changed it slightly to get better looking output in BlitzMax.<br><br>If you have BlitzMax, and MingW set up to work with it, then you can run this directly from the IDE.<br><br>1. Create a new file.<br>2. Save it as partitions.c, so the IDE knows it is c code.<br>3. Paste in the code given below.<br>4. Build and Run.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;stdio.h&gt;

/*
	printp
		- print out the partitioning scheme s of n elements 
		as: {1, 2, 4} {3}
*/
void printp(int *s, int n) {
	/* Get the total number of partitions. In the exemple above, 2.*/
	int part_num = 1;
	int i;
	for (i = 0; i &lt; n; ++i)
		if (s[i] &gt; part_num)
			part_num = s[i];

	/* Print the p partitions. */
	int p;
	for (p = part_num; p &gt;= 1; --p) {
		printf("{");
		/* If s[i] == p, then i + 1 is part of the pth partition. */
		for (i = 0; i &lt; n; ++i)
			if (s[i] == p)
				printf("%d ", i + 1);
		printf("} ");
	}
	printf("\n");
}

/*
	next
		- given the partitioning scheme represented by s and m, generate
		the next

	Returns: 1, if a valid partitioning was found
		0, otherwise
*/
int next(int *s, int *m, int n) {
	/* Update s: 1 1 1 1 -&gt; 2 1 1 1 -&gt; 1 2 1 1 -&gt; 2 2 1 1 -&gt; 3 2 1 1 -&gt;
	1 1 2 1 ... */
	/*int j;
	printf(" -&gt; (");
	for (j = 0; j &lt; n; ++j)
		printf("%d, ", s[j]);
	printf(")\n");*/
	int i = 0;
	++s[i];
	while ((i &lt; n - 1) &amp;&amp; (s[i] &gt; m[i] + 1)) {
		s[i] = 1;
		++i;
		++s[i];
	}

	/* If i is has reached n-1 th element, then the last unique partitiong
	has been found*/
	if (i == n - 1)
		return 0;

	/* Because all the first i elements are now 1, s[i] (i + 1 th element)
	is the largest. So we update max by copying it to all the first i
	positions in m.*/
	int max = s[i];
	for (i = i - 1; i &gt;= 0; --i)
		m[i] = max;

/*	for (i = 0; i &lt; n; ++i)
		printf("%d ", m[i]);
	getchar();*/
	return 1;
}

int main(int argc, char *argv[]) {
	int s[16]; /* s[i] is the number of the set in which the ith element
			should go */
	int m[16]; /* m[i] is the largest of the first i elements in s*/

	int n = 3;
	int i;
	/* The first way to partition a set is to put all the elements in the same
	   subset. */
	for (i = 0; i &lt; n; ++i) {
		s[i] = 1;
		m[i] = 1;
	}

	/* Print the first partitioning. */
	printp(s, n);

	/* Print the other partitioning schemes. */
	while (next(s, m, n))
		printp(s, n);

	return 0;
}</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1108813"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AarbronBeast</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Floyd.  I don't have MinGW installed, but I found a post with instructions on how to do that.  I'll be checking it out tonight.  You're a gem. <br><br></td></tr></table><br>
<a name="1108824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Please be aware that there is bug in the above code.  After line 61 you need to add:<br><br>if (m[i] &gt; max) max = m[i];<br><br>(This part of the code.....)<br><br>/* Because all the first i elements are now 1, s[i] (i + 1 th element)<br>	is the largest. So we update max by copying it to all the first i<br>	positions in m.*/<br>	int max = s[i];<br>	if (m[i] &gt; max) max = m[i]; /*----------&lt; Add this line */<br>	for (i = i - 1; i &gt;= 0; --i)<br>		m[i] = max;<br><br>What your looking for is indeed the bell numbers. So starting at n=5 the code starts missing good sets. If uncorrected n=5 results in 51 instead of 52 sets. n=6 results in 188 instead of 203, so for and so on.<br><br><a href="http://compprog.wordpress.com/2007/10/15/generating-the-partitions-of-a-set/" target="_blank">http://compprog.wordpress.com/2007/10/15/generating-the-partitions-of-a-set/</a> <br><br></td></tr></table><br>
<a name="1108837"></a>

<a name="1108841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for this. It figures it would go wrong at n=5. I tried n=3 and n=4 and it looked fine.<br>I could have looked a little more thoroughly, or at least scrolled down the page where I got the code!<br><br>Here's an updated version, with line numbers added to the output. It gets 52 partitions for n=5.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;stdio.h&gt;

/*
	printp
		- print out the partitioning scheme s of n elements 
		as: {1, 2, 4} {3}
*/
void printp(int *s, int n) {
	/* Get the total number of partitions. In the exemple above, 2.*/
	int part_num = 1;
	int i;
	for (i = 0; i &lt; n; ++i)
		if (s[i] &gt; part_num)
			part_num = s[i];

	/* Print the p partitions. */
	static int count;
	printf( "%10d: ", ++count );
	int p;
	for (p = part_num; p &gt;= 1; --p) {
		printf("{");
		/* If s[i] == p, then i + 1 is part of the pth partition. */
		for (i = 0; i &lt; n; ++i)
			if (s[i] == p)
				printf("%d ", i + 1);
		printf("} ");
	}
	printf("\n");
}

/*
	next
		- given the partitioning scheme represented by s and m, generate
		the next

	Returns: 1, if a valid partitioning was found
		0, otherwise
*/
int next(int *s, int *m, int n) {
	/* Update s: 1 1 1 1 -&gt; 2 1 1 1 -&gt; 1 2 1 1 -&gt; 2 2 1 1 -&gt; 3 2 1 1 -&gt;
	1 1 2 1 ... */
	/*int j;
	printf(" -&gt; (");
	for (j = 0; j &lt; n; ++j)
		printf("%d, ", s[j]);
	printf(")\n");*/
	int i = 0;
	++s[i];
	while ((i &lt; n - 1) &amp;&amp; (s[i] &gt; m[i] + 1)) {
		s[i] = 1;
		++i;
		++s[i];
	}

	/* If i is has reached n-1 th element, then the last unique partitiong
	has been found*/
	if (i == n - 1)
		return 0;

	/* Because all the first i elements are now 1, s[i] (i + 1 th element)
	is the largest. So we update max by copying it to all the first i
	positions in m.*/
	int max = s[i];
   if (m[i] &gt; max) max = m[i];     /* missing in original code!  */
	for (i = i - 1; i &gt;= 0; --i)
		m[i] = max;

/*	for (i = 0; i &lt; n; ++i)
		printf("%d ", m[i]);
	getchar();*/
	return 1;
}

int main(int argc, char *argv[]) {
	int s[16]; /* s[i] is the number of the set in which the ith element
			should go */
	int m[16]; /* m[i] is the largest of the first i elements in s*/

	int n = 5;
	int i;
	/* The first way to partition a set is to put all the elements in the same
	   subset. */
	for (i = 0; i &lt; n; ++i) {
		s[i] = 1;
		m[i] = 1;
	}

	/* Print the first partitioning. */
	printp(s, n);

	/* Print the other partitioning schemes. */
	while (next(s, m, n))
		printp(s, n);

	return 0;
}</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1108925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AarbronBeast</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I just installed MinGW and tried out the code.  Yup.  That seems to be exactly what I was looking for.  Many thanks. <br><br></td></tr></table><br>
<a name="1109207"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> same code in blitz3d<br><pre class=code>
Function printp(s[16],n)
	Local txt$="", pn=1
	For i=0 To n-1
		If s[i]&gt;pn Then pn=s[i]
	Next
	For p = pn To 1 Step -1
		txt=txt+"{"
		For i=0 To n-1
			If s[i]=p Then txt=txt+Str(i+1)
		Next
		txt=txt+"} "
	Next
	Print txt
End Function

Function Next_(s[16], m[16], n)
	s[0]=s[0]+1
	While i&lt;n-1 And s[i]&gt;m[i]+1
		s[i]=1
		i=i+1
		s[i]=s[i]+1
	Wend
	If (i=n-1) Then Return 0
	max=s[i]
	If m[i]&gt;max Then max=m[i]
	For j=i-1 To 0 Step -1
		m[j]=max
	Next
	Return 1
End Function

Local s[16], m[16], n=4

For i=0 To n-1
	s[i]=1
	m[i]=1
Next

printp(s,n)
While (Next_(s, m,n))
	printp(s,n)
Wend

WaitKey
End

</pre> <br><br></td></tr></table><br>
<a name="1201810"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bluemoon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know this is 2 years ago but someone may find this useful. It produces all the combination between 1 and 1023, i.e upto 10 items.<br><br><pre class=code>
Type Combination
		Field strRep$
		Field number%
		Field size%
	End Type
	
	Dim combination.Combination(1023)
	
	For x = 1 To 1023
		combination(x) = New Combination
		combination(x)\strRep$=comBuilder$(x)                 ;string representation of the combination.
		combination(x)\number%=x                              ;is the number that builds the combination
		combination(x)\size=Len((combination(x)\strRep$)+1)/2 ;number of objects in the combination
	Next 
	
	For x = 1 To 15
		DebugLog "No "+Str$(x)+"...."+combination(x)\strRep$+ " size = "+Str$(combination(x)\size%)
	Next	
	
	WaitKey()
	End
	
	;builds a string rep of a combination
	;comma delimeter.	
	Function comBuilder$(n)
		
		nRep=n
		
		Repeat
		If nRep Mod 2 = 1 Then 
			count=count+1
			s$=s$+Str$(count)
			s$=s$+","	
			Else
			count=count+1
		End If
		
		nRep=nRep/2
		Until nRep = 0
		
		Return Left$(s$,Len(s$)-1) ;return string without the last comma.
		 
	End Function
</pre><br><br>Generating combinations is that simple!. <br><br></td></tr></table><br>
<a name="1201857"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey thanks for gravedigging a 2 year old thread offering paid work. <br><br></td></tr></table><br>
<a name="1201888"></a>

<a name="1201981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>" ... the partitions of a set S are all the ways in which you can choose disjoint, non-empty subsets of S that unioned result in S. "</b> <br></div> <br><br></td></tr></table><br>
<a name="1201893"></a>

<a name="1202072"></a>

<a name="1202130"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> bluemoon's program generates subsets, not partitions.<br><br>For elements 1 to n there are 2^n subsets, including the empty set. That would be 1024 subsets of {1,2,3...10}.<br><br>The way that program works is that there is a natural correspondence between subsets of 1..n and n-bit numbers. The element k is in the subset if bit k is 1 in the corresponding number.<br><br>Here's a demonstration with 1..5, showing the subset number, the five relevant bits and the corresponding subset.<br><br><pre class=code>Graphics 600, 450, 0, 2

N = 5

For k = 0 To 2^N - 1
	Write RSet( k, 5 ) + ": " + Right( Bin(k), 5 ) + "    " 
	bit = 1
	For b = 1 To N
		If bit And k Then Write " " + b
		bit = bit Shl 1
	Next
	Print
Next

WaitKey</pre> <br><br></td></tr></table><br>
<a name="1201980"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> . . . . <img src="http://i411.photobucket.com/albums/pp194/aeDream/Yahoo%20emoticons/CupOfCoffee.gif"><br><br><img src="http://imageshack.us/a/img35/9647/hyny.png"> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
