<!DOCTYPE html><html lang="en" ><head ><title >Fave languages - and why?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Fave languages - and why?</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >Fave languages - and why?</a><br><br>
<a name="1185707"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Over the years I've used quite a few languages.  My faves were Fast BASIC, Hisoft BASIC and STOS on the Atari ST, Pascal, C and to a degree C++, and of course BlitzMax.<br><br>What were your favorite languages and why?  And what didn't you like? <br><br></td></tr></table><br>
<a name="1185724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fave: AmosPro<br>Crap:  Amos3D <br><br></td></tr></table><br>
<a name="1185725"></a>

<a name="1185726"></a>

<a name="1185727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hotshot2005</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> STOS? Ughhh That really horrible because when you want to look code up then it all gone.....WTF <br><br>My Fav Language AmosPro on Amiga, Blitz 3D/Purebasic on PC because all of them are easy to used<br><br>Python? Lot easier than C++ and less stressful<br><br>C++? They are alright but you have do memory alloctions which suck! :(<br><br>Java? I hate them and why does I have type actionlisten this and that....Zzzz  Zzzz  so Dull :(<br><br>C#? They are much fun to do<br><br>Assembler? I think my point of view on Assembler is waste of time and it take lots of patient to understand them! <br><br></td></tr></table><br>
<a name="1185728"></a>

<a name="1185729"></a>

<a name="1185730"></a>

<a name="1185731"></a>

<a name="1185733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I particularly like two attributes of languages:<br><br>-- focus<br>-- extensibility<br><br>'Focus' meaning that the language defines a small core where every feature has a unique role: no duplication, no features that can't be defined in terms of other features, and a core feature set that reflects the kind of problems the language was developed to solve. I want to <i>feel</i> my mind exploring and inhabiting as much as possible of the language-space, know that I am completely and competently wielding a well-defined sharp-edged tool, and have a total understanding of everything that's going on in what I've written. I'd rather use a different tool when I come to a different problem than feel I'm not properly directing myself at the current one because I can't aim the language at it precisely enough.<br><br>'Extensibility' meaning that this small core probably isn't going to be enough to express everything you want, so a great language makes it easy to compose its existing features together and create new ones. Seamlessly slotting in the parts I need to work with whatever is already there. Remodelling the language into something more precise and more closely reflecting the task I want it to solve, because no off-the-shelf general purpose language is optimised for expressing a particular solution.<br><br><br>So, two languages I really like that meet both of these criteria:<br><br>-- C<br>-- Scheme<br><br>Both of these are brilliantly minimal languages. A moderately-experienced user can easily hold the entirety of either language in their head in one go while writing. Both are tightly focused, too: C on playing with memory, Scheme on algorithmic purity. And both have fantastically powerful extension mechanisms that enable complete reconfiguration of the language into something else entirely: C's preprocessor is, for instance, <a href="/posts.php?topic=100141" target="_blank">powerful enough to turn a C compiler into a BASIC compiler</a>, or add things like exceptions, lambdas, <a href="http://rosettacode.org/wiki/Order" target="_blank">arbitrary metaprogramming</a> or <a href="https://github.com/CObjectSystem/COS" target="_blank">full OOP</a>; Scheme's macro system is even more powerful, perfectly capable of turning Scheme from a Lisp into a statically-typed infix language if you so desire.<br><br>So on the one hand you have the wonderful sensation of power that comes with a tightly focused tool, while on the other hand you aren't limited by that focus - if I decide my C program needs 'noGC' annotations or that my Scheme program needs a pluggable object system, in they go without complaint. The particular combination of light+infinite also makes them excellent testbeds for new ideas or prototype features without needing to rebuild an entire compiler as you would with some other languages. For instance I am interested in developing a language with a practical <a href="http://en.wikipedia.org/wiki/Linear_type_system#Linear_type_systems" target="_blank">linear type system</a>; you can actually do that using C as a platform.<br><br><br>Languages that I particularly dislike for particular reasons:<br><br>-- Common Lisp<br>-- C++<br>-- Python<br><br>Common Lisp and C++ both fail at focus. Common Lisp thinks it can throw in everything as a library and still be coherent, leading to a vast standard library nobody can be bothered to read and duplication of effort (although I'll admit that the real reason I dislike it is because it's a Lisp-2, which is just nasty). C++... I have whined about at length, but I think the point stands that <i>nobody</i> ever uses all of the language in one go (not least because you can't: templates vs. macros, pointers vs. references... the language is literally fighting itself). Python I dislike because of the community's insistence on doing things the One Right Way, which flies counter to the entire notion of reconfiguring a tool to suit a task that I personally value so much, and which I think is a seriously ineffective way to work or think about problems.<br><br><br>Honourable mentions:<br><br>-- Standard ML is a stunningly beautiful language, thanks to its clean formal definition and absolutely solid theoretical foundations. Its weakness is that it is a little bit limiting at times in favour of making the mathematics behind it perfect, at the price of some usability. It also doesn't have any facility for metaprogramming. An ML close to SML but with metaprogramming, existentials, and finer memory control, might well be my perfect language. (Adding these things and making them usable is no simple task, however.)<br><br>-- <a href="http://en.wikipedia.org/wiki/Bc_%28programming_language%29" target="_blank">bc and dc</a>. Hilariously good fun. Go play with 'em!<br><br>-- <a href="http://picolisp.com/5000/" target="_blank">PicoLisp</a>. This is minimalism taken quite possibly to an extreme. It's a bit of a throwback with its dynamic scope and fexprs, but delightfully mindbending to work with. Note that the combination of dynamic scope and fexprs means that PicoLisp has the interesting attribute of being <i>completely impossible</i> to compile (despite being really easy to interpret).<br><br><br>If you're interested in languages for their own sake, <i>the</i> place to discuss them online is <a href="http://lambda-the-ultimate.org/" target="_blank">Lambda The Ultimate</a>. Expect to learn... a lot.<br><br><br>Blitz3D and BlitzMax are obviously also among my favourites. The languages themselves... are a bit old-fashioned once you've looked around the larger scene. But this site is a wonderful resource filled with wonderful people and that's almost as important than the actual features offered by the languages. <br><br></td></tr></table><br>
<a name="1185732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> My favourite languages are:<br>1) C++, it will always be the best language for loads of tasks that I used to use before the latest crop of ease to use languages come along.<br><br>2) BlitzMax, its easier than C++ but not as powerful in some areas without help ;)<br><br>3) Blitz3d, another great language but sadly limited by its platform specifics.<br><br>4) Blitz Basic 2.1 (Amiga) another great language that really mad coding fun on the ol' A500/A1200 :)<br><br>5) Amstrad basic - very simple easy to use for the most part.<br><br>6) ZX Spectrum basic - relatively easy to use :)<br><br>7) ASM - yes it has to be here somewhere, ASM is the most powerful language known to man. Unfortunately its also the hardest to learn and the least portable. <br><br></td></tr></table><br>
<a name="1185749"></a>

<a name="1185750"></a>

<a name="1185791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> My favorite languages :<br>Blitz3D, PureBasic, some assembly language. <br><br></td></tr></table><br>
<a name="1185753"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Captain Wicker (crazy hillbilly)</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> favorite languages list, starting with absolute favorite.<br><br>1. NuclearBasic<br>2. BlitzMax<br>3. Dark Basic Pro<br>4. Blitz3D<br>5. C++ with Irrlicht, DarkGDK, or NuclearFusion<br>6. BlitzPlus (just for the GUI)<br>7. FreeBASIC with OpenB3D (minib3d clone) or Irrlicht Wrapper<br>8. Python + PyGame<br>9. and my least favorite (what I am currently hooked on) is MinPSPW + Irrlicht wrapper (homebrew sdk)<br><br>You can call this my top 9, because I don't know of anything else that I actually like to use. LOL <br><br></td></tr></table><br>
<a name="1185756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Amos Pro is still my favorite, with blitzMax coming in second. <br><br></td></tr></table><br>
<a name="1185760"></a>

<a name="1185761"></a>

<a name="1185762"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yasha, fantastic information as always - thanks. Taken aback by how similar your thoughts are too mine - especially with regard focus.  "wielding a well-defined sharp-edged tool".  I think the IDE in conjunction with the language are vital for that kind of experience.<br><br>Amos Pro I never used, but yes I can see why it was thought of fondly.  I've never used action! either, but again a couple of nice features.<br><br>Nuclear BASIC has a good engine, but the language itself is too old school for me. <br><br></td></tr></table><br>
<a name="1185799"></a>

<a name="1185800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've used a few languages and enjoy most of them.  I quite enjoy Pronto 4GL coding - which I do at work.  Not too much of a fan of php, but I like javascript. Not saying php is a bad language - just that I don't particularly like some aspects of it.<br><br>I like monkey, it seems like a nice language to work in...<br><br>I don't like SAP ABAP programming - what a nightmare hodge podge of garbled messily structured goop (technical term ;-) to work with....never want to touch it again. <br><br></td></tr></table><br>
<a name="1185834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I absolutely despised Objective C when I first picked it up but it has slowly become my go-to language. A few reasons why I like it.<br>- Highly readable. Functions are basically sentences so unless someone has completely shoe horned Pascal/C syntax into their ObjC method names (seen it done... its NOT pretty) things just do what they say. Far easier to go back to a project since it is (to some extent) self documenting as a result.<br>- Memory handling. If you use ARC you can essentially pretend there's a garbage collector, only it's crazy faster. And if you really want finite control over memory you can do that to. Best of both worlds IMO. I know what's going on, I can take control if I want to, but I can also just let it do it's thing and not worry about GC overhead etc.<br>- C friendly. Just shove some C in anywhere you like and you're fine. Great for when you're pulling code blocks from other projects, or opensource stuff etc. No need to refactor or create interfaces, just copy/paste. You can also interface with C++ the same way with relative ease (generally just change the file name).<br><br>It's FAR from a perfect language, documentation can be excellent or horrifying depending on how you go about it and what you're looking for. Lots of people hate the syntax. Has an apple association which is enough for lots of people to just flip out (If you hate something because it's apple you're just as bad as the people that love something because it's apple, you're just the other side of the fence... and I don't put myself above that, just making a note :). Just for me the control is natural. Nothing loose and ugly (my opinion of Java) but not quite as restrictive as C/C++ with as much redundant header file work (there's still plenty, but it's simpler in my mind anyway).<br><br><br>I'm warming to javascript. The further from web pages I take it the more I enjoy it.<br>Despise Java. It just feels unnatural. All the IDE's i've tried drive me bat-shit crazy for one reason or another (mostly because they're usually written in Java so they're slow and unstable...). Can't really put my finger on it exactly besides the IDE issues, but we just don't get on well at all.<br>PHP is nice for what it is. You just tell a web page to do something and it does, no real fuss, always nice to not have to fight with the language etc.<br>I used to love Perl but I haven't touched it in years and it seemed a little backwards the last time I looked at it...<br>Just rambling now... tah <br><br></td></tr></table><br>
<a name="1185838"></a>

<a name="1185840"></a>

<a name="1185841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Objective-C is a nice language, but it does have a couple of big problems:<br><br>1) It's Apple. Not a problem because of Apple, but a problem because it's <i>not ISO</i>. Apple add and remove features from their own compiler all the time, with no reference implementation or standard version to actually make the language portable in any way (there are a couple of other compilers, but GCC is missing a lot of interesting features and Portable Object Compiler is totally incompatible with Clang; neither are standardised). Apple have kinda weaponised the language in the same way Microsoft did with C++ so that you have to decide between the portable base, and their superior but locked-down version of it.<br><br>2) The rate at which Apple are adding features is a little worrying. The language is getting quite big these days. Edging closer every day to C++ levels of overkill.<br><br>3) The language isn't being designed consistently, but seems quite ad-hoc. Features are added at multiple levels of the toolchain and all seem to exist in their own design space (e.g. ARC actually has nothing to do with Objective-C: it's a Clang static analysis applied after the language-level features have all been parsed out). Features are also often quite muddy in their design (e.g. blocks were rejected from inclusion into ISO C because they take away too much of the programmer's control over memory allocation; the runtime gets to decide how to implement them and it may not do so consistently). Objective-C <i>used</i> to be really great, because it was a clean preprocessing layer pasted on top of pure C; nowadays, there's quite a lot of Objective stuff left in at runtime and again it's heading down the C++ route of code not meaning what it looks like it means.<br><br>4) Politics. Being Apple's baby means it has to be different. ARC is actually a good example of this: while it's tightly optimised and probably the best solution <i>for Cocoa on iOS written in Objective-C</i>, it is by no means superior to garbage collection in all cases (it's actually just a slightly more badass version of what BlitzMax uses); in fact for many language/platform combinations it would be substantially inferior to true GC... but at this point Apple's reality distortion field will activate and try to overrule decades of CS research on memory management. It's a nuisance because it gets in the way of establishing an objective assessment of the toolkit (ARC <i>is</i> great, we just need honesty).<br><br><br>It's still a really nice language, but it's currently in a bit of a fragile position. <br><br></td></tr></table><br>
<a name="1185843"></a>

<a name="1185844"></a>

<a name="1185845"></a>

<a name="1185846"></a>

<a name="1185847"></a>

<a name="1185848"></a>

<a name="1185850"></a>

<a name="1185851"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just out of curiosity, here are other <i>objectives</i>.:<br><br><b>Objective-C</b>:<br><a href="http://www.roseindia.net/iphone/objectivec/objective-c-windows.shtml" target="_blank">http://www.roseindia.net/iphone/objectivec/objective-c-windows.shtml</a><br><a href="http://www.gnustep.org/resources/sources.html" target="_blank">http://www.gnustep.org/resources/sources.html</a><br><br><b>Objeck</b>: <a href="https://sourceforge.net/projects/objeck-lang/" target="_blank">https://sourceforge.net/projects/objeck-lang/</a><br><br><b>Objective-J</b>   : <a href="http://www.cappuccino-project.org/#features" target="_blank">http://www.cappuccino-project.org/#features</a><br><b>Objective-Rex</b> : <a href="http://www.oorexx.org/" target="_blank">http://www.oorexx.org/</a><br><br><b>Objective Pascals</b>:<br>Oxygene <a href="http://www.remobjects.com/oxygene/" target="_blank">http://www.remobjects.com/oxygene/</a>   {not free}<br>Free Pascal : <a href="http://www.freepascal.org/" target="_blank">http://www.freepascal.org/</a>      {is free}<br><br>Massive list of Object-Oriented Languages: <a href="http://tinyurl.com/2494yz" target="_blank">http://tinyurl.com/2494yz</a><br>--------------------------------------------------------------------------<br>Other interesting languages worth mentioning:<br><br>SheerPower 4GL : <a href="http://www.sp4gl.com/" target="_blank">http://www.sp4gl.com/</a><br>Alice          : <a href="http://www.ps.uni-saarland.de/alice/" target="_blank">http://www.ps.uni-saarland.de/alice/</a> <br><br></td></tr></table><br>
<a name="1185863"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Re: Yasha<br><br>Indeed, Apple is doing it's own thing but (IMO anyway) the language wouldn't really exist in any real world usable state without them. If MS can have C# and people like it (as some do) then Apple taking the reigns on Objective C can't be all bad (nor all good). While it is getting pretty bloated and inconsistent in some places, those are largely OS specific things (New UI base types etc.) the base of the language itself (the part that could in theory be portable) is basically just C but with Objects, rather than C with objects added on as another layer (i.e. C++). So in a modern world where objective programming is pretty much required for any reasonable consistency in a project C falls short, and C++ brings tons of baggage on just the object level (let alone all the stuff that sits on top of that). As relates ARC I disagree. It isn't garbage collection. It is just a huge chunk of analysis and preprocessing that does all the manual handling (the old retain releases) for you. Now a person is always better than a machine (and yay! you can turn if off for anything you want) but again in the real world a human is more likely to mess up than a machine (notice how iOS apps in general have gotten a lot more stable since ARC was introduced? The OS isn't any better, ARC just keeps devs from screwing their own memory as frequently, myself included). And again, you can turn it off an take over by hand any time you want. I've never trusted garbage collection (a pox on you Java!). And not having the system monitoring a pool on any level I believe leads to faster execution (no overhead and pauses for the memory to get sorted out which happens all the time when you're thrashing it), and more reliable available memory (if something's not in use it will get released right away. If it's in the floater space where a garbage collector would sweep it up it will get cleaned up with an auto release from the pool on the next cycle, which will be, at worst, the same time the GC would have gotten to it.) This is all opinion, but based on real world experience rather than synthetic benchmarking so I'm happy with it anyway.<br><br>Blocks are indeed a double edged sword however. They bring some definite drawbacks, but ARC actually helps keep those in check (again IMO). The benefits are pretty great as well however (MUCH shallower learning curve for multithreading safely for example). Still torn over them myself, in that I like what they can do, but in an old man waving a cane type way I wish people did things like they did in the old days grumble grumble... I see them mostly as a way to bring one of the few things I kinda like about Java (the ability to wrap a block of code up in a little package and hand it around so you don't have to personally keep track of it, it's just associated with whatever needs it) to a language I prefer in a way that I find a bit easier to use.<br><br>All opinion on my part, maybe based on nothing but my own imagination, but there we are.<br><br>On the subject of Apple closing it off, I think that they actually are trying really hard to get Objective C and their tools etc. out there and as open as possible. I base this on my experience with some of the dev team at last years WWDC. However I think the real bottle neck is there just isn't enough time. Apple really doesn't have as many developers as people imagine (and their money stockpile would lead you to believe). Could go into much more detail but it's all speculative and not related to the thread so I'll store it for another day. <br><br></td></tr></table><br>
<a name="1185867"></a>

<a name="1185871"></a>

<a name="1185872"></a>

<a name="1185874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> not having the system monitoring a pool on any level I believe leads to faster execution <br></div><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">The main thing about garbage collection, and memory management in general, is
that there's no one-size-fits-all solution (this is getting orthogonal to your
point but I believe is on-topic for the thread). Depending upon what you're
doing, and by extension what the language is commonly doing and what style of
work is normal for it, different strategies will exhibit wildly different
performance characteristics.

e.g. For an imperative language (C or BASIC based), using a smallish number of
large objects like BlitzMax or Objective-C, reference counting can be very
efficient. Objects persist in blocks of code for a reasonably long time, so many
refcount updates can be eluded by static analysis, and objects are only created
and destroyed quite rarely, usually in groups at predefined, or at least
predictable, times. Since objects are large the extra few bytes for the refcount
is also a negligible percentage of total memory use. Recounts also don't happen
very often which is important for battery life.

For a functional language you're more likely to use very large numbers of small
objects, rapidly passing through multiple calling contexts that make lifetime
analysis more difficult. Hundreds of megabytes of temporaries tend to be created
each second (not an exaggeration: a typical Haskell program can hit the GB/s
mark quite easily) and objects are tiny: a Lisp cons cell is only two data
words, so adding a refcount slot would increase the program's memory usage by a
sizeable percentage (as well as prevent space optimisations that Lisps often use
to cram a cons cell into less than two words). For functional programming
languages, all current measurements indicate that tracing GC dramatically
outperforms reference counting both obviously in memory, and also in speed as
there are too many count updates at runtime. Programs made up of many small
objects like cons cells also desperately need to be able to move survivor
objects closer together to take advantage of cache locality or they will suffer
terribly for it.

On the other hand, FP benchmarks tend to ignore pauses altogether because FP is
less commonly used to write interactive programs: as long as the total runtime
over the course of the entire computation is shorter than an alternative, a
strategy gets considered "best". It also doesn't matter how CPU-intensive the
actual collection is when thinking in this way, because a heavily-numeric
program will almost always be running on mains power.

It is possible to write non-pausing tracing GC systems (in fact, it is
&lt;i&gt;only&lt;/i&gt; possible to formally guarantee there will be no pauses when using a
runtime that manages deallocations: unmanaged recounting can lead to cascades as
well), but at the cost of slowing down the average performance of the program as
a whole as more stuff is running. Strategies such as generational GC can have
better performance on average, but only if the program conforms to predicted
runtime behaviour and doesn't behave pathologically.

To date nobody has come up with a static analysis that can elide &lt;i&gt;all&lt;/i&gt;
runtime management. MLkit and Stalin both use heavy static analysis (very heavy
- Stalin will spend days optimising a program) to place most objects into
regions, which can be deallocated as blocks; both of these need a backup GC to
run in the background to catch and move objects with unusual lifespans (and
again, can suffer if the program is pathological; the wrong program run through
MLkit's region inferencer can actually slow down by up to 25 times compared to
just using the tracing GC).

There are fully compile-time memory management techniques, but all of them rely
on restricting some part of the way the user is allowed to interact with
objects. The most interesting in my opinion is the 'linear type system', which
introduces objects that may only have one live reference at any time, so no
refcount updates are necessary (the compiler can easily track variable usage to
see that no linear variable is ever used a second time) and all deallocation
points are known in advance; this is great for performance (and coincidentally
also great for multithreading as you can prove that you don't need to lock
linear objects), and you can add a moving system if necessary - but it comes at
the massive cost of completely changing everything a conventional programmer
thought they knew about the entire notion of objects and sharing, which is why
you don't see much widespread adoption of it. Most people want to share objects.
(Developing a language with &lt;i&gt;practical and simple&lt;/i&gt; support for linear
typing is one of my ongoing research projects.)


ARC is truly great, far superior to anything else on iOS... But it can't be
everything to all users (note: it could probably do a lot more if it didn't have
to be compatible with C and its unrestricted pointer fun...).</textarea><br><br>(<b>EDIT:</b> Crunched because only like two people are interested in this. I wouldn't read a post that long either!) <br><br></td></tr></table><br>
<a name="1185868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Yasha: Just a small observation - I for one can't be bothered to read lengthy, rambling posts.  They're the death of many a thread. <br><br></td></tr></table><br>
<a name="1185887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MCP</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Amiga<br><br>Hisoft Devpac 3<br>Lattice SAS C<br>BlitzBasic 2.1<br><br><br>PC<br><br>C++<br>Purebasic <br><br></td></tr></table><br>
<a name="1185919"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> My favourite languages:<br><br>- Monkey<br>- C#<br>- Java<br>- D<br>- BlitzMax<br><br>Not for technical reasons but for the fun I've got from using them. <br><br></td></tr></table><br>
<a name="1185961"></a>

<a name="1185962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> The following languages/packages are also interesting for study :<br><br>CygWin <img src="http://i411.photobucket.com/albums/pp194/aeDream/spacers/H14/56x14_DBECE1_zps0d3eedab.png">  : <a href="http://www.cygwin.com/" target="_blank">http://www.cygwin.com/</a><br>"<b>R</b>" Programming  : <a href="http://www.r-project.org/" target="_blank">http://www.r-project.org/</a><br>The iGraph Library: <a href="http://igraph.sourceforge.net/" target="_blank">http://igraph.sourceforge.net/</a><br><br><b>R</b> has the potential for adding lots and lots of add-ons.<br><br><b>Python</b> is fun, but creepy &amp; cryptic.  I'm still in the process of <br>trying to understand it. <img src="http://i411.photobucket.com/albums/pp194/aeDream/lol_zpsd019eb76.gif"><br><br>Example: <b>iGraph</b> works for both Python and R,... <br><br></td></tr></table><br>
<a name="1186281"></a>

<a name="1186282"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> My favourite languages are:<br><br>1) Blitz 3D, anything you want to do in 3D is possible in this language - some of the physics libs make it almost bewildering the things you can achieve.<br><br>2) Blitz Basic 2.1 - Ooodles of coding fun within this on my Amiga 1200, Plotting graphs on my 1200 x 512 pixels on my 1084S monitor, kewl.<br><br>3) ZX Spectrum Basic - where I developed my love/addiction/habit of hobby coding.<br><br>4) Blitz Max - wrote my first ever indie product to be sanctioned by a body responsible for delivering educational software to schools, the prototype for which was made in Blitz3D<br><br>5) C - Managed to write space invaders in a terminal window once.<br><br>6) VB6 &amp; some express versions of it - a bit clunky in places but managed to make some reasonable front ends with this.<br><br>7) Monkey - I can see the potential of this but I need an extra 5 hours in the day to get on with it. <br><br>8) Javascript - it is wonderous what can be coded within a web browser these days with the likes of paper.js and others.... <br><br></td></tr></table><br>
<a name="1186345"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ringo</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> C nothing else nothing more.<br><br>Blitz3d for prototyping. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
