<!DOCTYPE html><html lang="en" ><head ><title >What is a garbage collector?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >What is a garbage collector?</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=125" >General Help</a>/<a href="#bottom" >What is a garbage collector?</a><br><br>
<a name="1241716"></a>

<a name="1241717"></a>

<a name="1241718"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am determined to learn c # and it really has been be an adventure, I do not think I lost time with my unfinished projects in Blitz3D :) but as I read c # has a garbage collector, which is absent in c ++.<br><br>What is a garbage collector?, And programming in C ++ be more difficult than in C #? <br><br></td></tr></table><br>
<a name="1241759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> A garbage collector is really useful.<br><br>You know how in blitz3d when you create an entity and have to manually keep track of its handle and free it when you are done? - That is different in a system with a garbage collector.<br><br>With a garbage collector things usually are taken care of in memory when the scope of the function being processed is exited.<br><br>This means that you don't have to manually go through and "free" entities and the like when you are done with them since they will automatically just magically disappear from memory after your last reference to them in code disappears.<br><br>Now, some people may initially think they prefer the manual approach like blitz3d but in reality it allows for much cleaner code to do it with garbage collection. <br><br></td></tr></table><br>
<a name="1241776"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dynaman</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> It does allow for cleaner code BUT if is is badly implemented it also causes stutters at the worst moments.  There are ways around that however and most modern implementations do not cause the stuttering problem. <br><br></td></tr></table><br>
<a name="1241782"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was gonna say a person who empties ya bins lol<br><br>Its just a part of the language that checks for unreferenced data in your program and then gets rid of it, for example a loaded texture that isn't linked to a code texture reference would be a prime candidate.<br><br>It runs every so often and cleans up the useless data. <br><br></td></tr></table><br>
<a name="1241788"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> One thing that's interesting about a garbage collector is that, contrary to what you might assume, with all the extra code and stuff going on in the background, a well-implemented one (like the ones used by Java and C#) actually results in <i>faster</i> code overall than manual deallocation. There are some complex reasons for this, but it basically comes down to the allocator being able to make more effective use of the memory it's given, when it has more information about the objects. (Another fun counterintuitive fact: some GCs, like GHC's generational collector, actually get faster the more garbage your program produces!)<br><br>Unfortunately the faster the collector, the more likely it is to "stutter". At the moment, the main tradeoff in memory handling is that you can have a completely pause-free and smooth program, or you can have a program that pauses occasionally, but runs faster overall. (Although a well-designed program on modern hardware will often only have pauses of 1 or 2 ms, which is good enough for gaming these days.)<br><br><br>On a technical note, there are also two meanings of "garbage collector" in current use. The posts above are the definition used by most programmers - any system that automatically cleans up memory for you without needing to write it into the code. But in "the literature", garbage collection normally specifically refers to <i>tracing</i> collectors, and doesn't cover other automatic memory management strategies (of which there are several). BlitzMax uses a refcounting collector, so many outsiders would actually say it has no GC. (Apple's ARC uses a very similar collector and they are really adamant that it should <i>not</i> be called a GC, mainly for marketing reasons.) Other collectors include region-based and type-based collectors. They all have different general performance and coding implications (types = fastest but hardest to code for; refcounting = slowest but easiest to code for).<br><br>The main disadvantage of garbage collectors is that they use a lot of memory, which is why Apple likes to discourage the idea of them on mobile devices which have little memory. (I think the best tracing GCs at the moment only outperform manual management when they can use at least ~170% of the memory for the same program; many will use more like 500% if they can get away with it.) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
