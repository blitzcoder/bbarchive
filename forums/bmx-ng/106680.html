<!DOCTYPE html><html lang="en" ><head ><title >NG: How to import .a libs? aka. Newton Begging</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >NG: How to import .a libs? aka. Newton Begging</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=126" >BlitzMax NG</a>/<a href="#bottom" >NG: How to import .a libs? aka. Newton Begging</a><br><br>
<a name="1314322"></a>

<a name="1314323"></a>

<a name="1314330"></a>

<a name="1314701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is it possible to import/use .a libraries in bmx-ng?<br><br>I've tried putting my .a lib in a /lib folder (I notice it doesn't exist by default) -- no joy there -- so am instead trying to load it from the local source directory, but using <b>Import "libode_single.a"</b> gives a bunch of "undefined references" (using 32-bit build with 32-bit .a), while <b>Import "-lode_single.a"</b> just says "cannot find -lode_single.a".<br><br>Here's a test archive: <a href="http://www.hi-toro.com/temp/odetest.zip" target="_blank">http://www.hi-toro.com/temp/odetest.zip</a><br><br>I'm basically trying to get <a href="http://ode.org/" target="_blank">ODE</a> working at the most basic level -- the DLL version works fine with the two test functions, but it would be nice to be able to use the more cross-platform-ish .a method. <br><br></td></tr></table><br>
<a name="1314332"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If I remember correctly, I have a previous post somewhere on how to do static linking, try doing a search here on this category. <br><br></td></tr></table><br>
<a name="1314365"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've had a good go at searching, but although there's the odd reference, I can't find anything that actually goes into static linking in any way (that's the term I needed!).<br><br>http://www.blitzbasic.com/Community/_search.php?bbs=BlitzMax+Modules&amp;forum=&amp;terms=static&amp;method=simple&amp;case=no&amp;results=topic&amp;user=RustyKristi&amp;submit=Search<br><br>Off to play about again and see if I can get anywhere with this... <br><br></td></tr></table><br>
<a name="1314366"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just re-uploaded odetest.zip, as it had the .a from the DLL build, doh! (Guess that's a set of import definitions?)<br><br>Still giving exactly the same results, though, with the correct static lib, ie. undefined references. Even used the 'nm' tool to list the functions (_dWorldCreate and dWorldDestroy both exist, tried defining as such in the Blitz code to no avail). <br><br></td></tr></table><br>
<a name="1314393"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've pushed an update to bmk, which should allow for direct imports of .a files now.<br><br>The other way to do it is to put it in a module, and setup an LD_OPTS path, and a -l import. <br><br></td></tr></table><br>
<a name="1314413"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool, will have a go later -- thanks, Brucey. Started writing a wrapper for ODE (was just going to use the DLL interface), so once I've got the C API basically converted to BMX I'll deal with the interface stuff.<br><br>Mind you, a proper Brucey wrapper wouldn't go amiss! Was surprised to find there isn't really an open, cross-platform 3D physics library out there. <br><br></td></tr></table><br>
<a name="1314414"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> You know how to bait Brucey: give him a "known library" and "not wrapped for BlitzMax yet"... and you have really good chances to see it wrapped some time later... :-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1314419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ha ha, worth a try! <br><br></td></tr></table><br>
<a name="1314424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  and you have really good chances to see it wrapped some time later <br></div><br>Nah. I have an unreleased Newton Dynamics module here. They both seem to do the same kind of thing, so there's little point me investing time in another one. <br><br></td></tr></table><br>
<a name="1314427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> The most important keyword here is "unreleased" :-p<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1314428"></a>

<a name="1314429"></a>

<a name="1314430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fair enough... so, obvious question: any plans to release your Newton mod?!<br><br>I'm still plugging away with ODE anyway -- pretty simple C API, so hoping I can piece enough together to get it working... ish. Looking good so far!<br><br>Good thing about ODE (other than being plain C interface-wise) is that there is previous Blitz history, with Blitz3D and the JV-ODE wrapper examples, which gives me (largely-unfounded) hope that I might be able to make it do something. <br><br></td></tr></table><br>
<a name="1314448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I've pushed an update to bmk, which should allow for direct imports of .a files now. <br></div><br><br>nice! this should make importing much easier. :-) <br><br></td></tr></table><br>
<a name="1314505"></a>

<a name="1314506"></a>

<a name="1314507"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woo-hoo, got my ODE converter to output all of the C API and build a test using the DLL interface. Whether or not it'll actually work in practice (or if my C++ -&gt; bmx type conversions are any good) remains to be seen. Finding out if there's much involved in translating ODE's world orientation to B3D's orientation is another matter entirely...<br><br>Will have a go at making it work with static linking shortly. <br><br></td></tr></table><br>
<a name="1314554"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Egads, there's a big difference between being able to call the plain C functions and actually doing anything that involves bmx/C++ interfacing, particularly dealing with structs... this stuff is clearly beyond my ken! :/ <br><br></td></tr></table><br>
<a name="1314555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's nice James. Are you trying to use ODE with OpenB3D?<br><br>Just curious and on a side note, do you have any examples or demo with ragdolls and ODE?<br><br>thanks <br><br></td></tr></table><br>
<a name="1314579"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> No, I was hoping to, but see last comment -- failed dismally at the, er, hard part. We clearly need a man like Brucey to bring us a proper port!<br><br>(Is your Newton port publish-able, Brucey, or just a private thing?) <br><br></td></tr></table><br>
<a name="1314612"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Er, note to self... updating bmx-ng going great, except for, er, "vulkan.mod" crash on running openB3D example! Where the heck did <i>that</i> come from?! :/ <br><br></td></tr></table><br>
<a name="1314614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey James,<br><br>I have all of the latest modules and your speccy example runs fine on a linux machine which uses the openB3D ( gl ) module too. What OS and error do you get with the vulkan module? <br><br></td></tr></table><br>
<a name="1314615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  Is your Newton port publish-able <br></div><br>um... it's incomplete, but the stuff that's done appears to work - although you'd need to integrate it into... whatever.<br><br>Since I'm rubbish with 3D, I wouldn't know how to tie the two things together.<br><br><br><div class="quote"> "vulkan.mod" crash on running openB3D example <br></div><br>Do you have some more details on the crash?<br><br><div class="quote">  Where the heck did that come from?! <br></div><br>It's a new NG feature... something to do with Star Trek, if I'm not wrong? <br><br></td></tr></table><br>
<a name="1314617"></a>

<a name="1314618"></a>

<a name="1314620"></a>

<a name="1314622"></a>

<a name="1314623"></a>

<a name="1314625"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ha ha... I assumed it came from recent openb3d updates, but maybe not... ?<br><br><div class="quote"> <br>Do you have some more details on the crash?<br> <br></div><br><br>Not really -- it builds with my ongoing bmx-ng, but today I finally got bcc, bmk and the pub/brl/sdl/maxgui and openb3d mods to build, and the end result of an openb3d test was that it gave an EXCEPTION_ACCESS_VIOLATION error, nothing more. (Deleted my build/s and .bmx folder.)<br><br>I get your point about not knowing how to integrate into "whatever", as I imagine the matrices and position (z vs y, etc) could be different, but if you could find it in your noble heart to publish some sort of release, I'd like to at least cluelessly have a pop at getting it to match up with the *B3Ds, at least!<br><br>I suppose I need to dig into my crash, though... :/<br><br>For what it's worth, here's my <a href="http://www.hi-toro.com/temp/deadspeccyshader.zip" target="_blank">deadspeccyshader</a>, though you'd probably have to have a matching ng setup to get the exact same problem. In theory, it's all the latest stuff, other than a fix to openb3d.mod\b3dsound.mod\b3dsound.bmx in line 320: <b>HearingPoint = New HearingPoint</b> -&gt; <b>HearingPoint = New ListeningPoint</b> <br><br></td></tr></table><br>
<a name="1314627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> BTW My latest attempts to build all-new bcc/bmk/pub/brl went remarkably smoothly today, no build errors at all, other than the aforementioned third-party b3dsound error -- all built perfectly, which was f'ing amazing! <br><br></td></tr></table><br>
<a name="1314632"></a>

<a name="1314634"></a>

<a name="1314635"></a>

<a name="1314636"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> No crash here my ole mate. On Linux x64.<br><br><br>I'm not sure if this is any good for you but here's a raw port of the newton ( 3 I believe? ) functions that I found except the callbacks are commented out, I can't even remember why :/<br><br>Part 1 as the forum takes a dump when its posted as one code. If it no good for you then just throw it away, or Brucey may have even more of it - like the structs/types for eg.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
?win32
Import Pub.Win32

Global newton_dll:Byte Ptr
Global Newton_DllName$
?win32x86
Newton_DllName = "newton32.dll"
?win32x64
Newton_DllName = "newton64.dll"
?

?win32
newton_dll = LoadLibraryA(Newton_DllName)

Global NewtonAcyclicArticulationAddJoint(articulation:Byte Ptr,joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonAcyclicArticulationAddJoint")
Global NewtonAcyclicArticulationAttachBone:Byte Ptr(articulation:Byte Ptr,parentBone:Byte Ptr,childBone:Byte Ptr)=GetProcAddress(newton_dll,"NewtonAcyclicArticulationAttachBone")
Global NewtonAcyclicArticulationCreate:Byte Ptr(rootBone:Byte Ptr)=GetProcAddress(newton_dll,"NewtonAcyclicArticulationCreate")
Global NewtonAcyclicArticulationDelete(articulation:Byte Ptr)=GetProcAddress(newton_dll,"NewtonAcyclicArticulationDelete")
Global NewtonAcyclicArticulationDetachBone(articulation:Byte Ptr,bone:Byte Ptr)=GetProcAddress(newton_dll,"NewtonAcyclicArticulationDetachBone")
Global NewtonAlloc:Byte Ptr(sizeInBytes:Int)=GetProcAddress(newton_dll,"NewtonAlloc")
Global NewtonAtomicAdd:Int(_ptr:Int Ptr,value:Int)=GetProcAddress(newton_dll,"NewtonAtomicAdd")
Global NewtonAtomicSwap:Int(_ptr:Int Ptr,value:Int)=GetProcAddress(newton_dll,"NewtonAtomicSwap")
Global NewtonBallGetJointAngle(ball:Byte Ptr,angle:Float Ptr)=GetProcAddress(newton_dll,"NewtonBallGetJointAngle")
Global NewtonBallGetJointForce(ball:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonBallGetJointForce")
Global NewtonBallGetJointOmega(ball:Byte Ptr,omega:Float Ptr)=GetProcAddress(newton_dll,"NewtonBallGetJointOmega")
Global NewtonBallSetConeLimits(ball:Byte Ptr,pin:Float Ptr,maxConeAngle:Float,maxTwistAngle:Float)=GetProcAddress(newton_dll,"NewtonBallSetConeLimits")
Global NewtonBallSetUserCallback(ball:Byte Ptr,callback(ball:Byte Ptr,timestep:Float))=GetProcAddress(newton_dll,"NewtonBallSetUserCallback")
Global NewtonBodyAddForce(body:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyAddForce")
Global NewtonBodyAddImpulse(body:Byte Ptr,pointDeltaVeloc:Float Ptr,pointPosit:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyAddImpulse")
Global NewtonBodyAddTorque(body:Byte Ptr,torque:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyAddTorque")
Global NewtonBodyApplyImpulseArray(body:Byte Ptr,impuleCount:Int,strideInByte:Int,impulseArray:Float Ptr,pointArray:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyApplyImpulseArray")
Global NewtonBodyApplyImpulsePair(body:Byte Ptr,linearImpulse:Float Ptr,angularImpulse:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyApplyImpulsePair")
Global NewtonBodyCalculateInverseDynamicsForce(body:Byte Ptr,timestep:Float,desiredVeloc:Float Ptr,forceOut:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyCalculateInverseDynamicsForce")
Global NewtonBodyGetAABB(body:Byte Ptr,p0:Float Ptr,p1:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetAABB")
Global NewtonBodyGetAngularDamping(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetAngularDamping")
Global NewtonBodyGetAutoSleep:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetAutoSleep")
Global NewtonBodyGetCentreOfMass(body:Byte Ptr,com:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetCentreOfMass")
Global NewtonBodyGetCollidable:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetCollidable")
Global NewtonBodyGetCollision:Byte Ptr(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetCollision")
Global NewtonBodyGetContinuousCollisionMode:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetContinuousCollisionMode")
'Global NewtonBodyGetDestructorCallback(body:Byte Ptr)(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetDestructorCallback")
Global NewtonBodyGetFirstContactJoint:Byte Ptr(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetFirstContactJoint")
Global NewtonBodyGetFirstJoint:Byte Ptr(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetFirstJoint")
Global NewtonBodyGetForce(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetForce")
Global NewtonBodyGetForceAcc(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetForceAcc")
'Global NewtonBodyGetForceAndTorqueCallback(body:Byte Ptr,timestep:Float,threadIndex:Int)(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetForceAndTorqueCallback")
Global NewtonBodyGetFreezeState:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetFreezeState")
Global NewtonBodyGetID:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetID")
Global NewtonBodyGetInertiaMatrix(body:Byte Ptr,inertiaMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetInertiaMatrix")
Global NewtonBodyGetInvInertiaMatrix(body:Byte Ptr,invInertiaMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetInvInertiaMatrix")
Global NewtonBodyGetInvMass(body:Byte Ptr,invMass:Float Ptr,invIxx:Float Ptr,invIyy:Float Ptr,invIzz:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetInvMass")
Global NewtonBodyGetJointRecursiveCollision:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetJointRecursiveCollision")
Global NewtonBodyGetLinearDamping:Float(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetLinearDamping")
Global NewtonBodyGetMassMatrix(body:Byte Ptr,mass:Float Ptr,Ixx:Float Ptr,Iyy:Float Ptr,Izz:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetMassMatrix")
Global NewtonBodyGetMaterialGroupID:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetMaterialGroupID")
Global NewtonBodyGetMatrix(body:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetMatrix")
Global NewtonBodyGetNextContactJoint:Byte Ptr(body:Byte Ptr,contactJoint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetNextContactJoint")
Global NewtonBodyGetNextJoint:Byte Ptr(body:Byte Ptr,joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetNextJoint")
Global NewtonBodyGetOmega(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetOmega")
Global NewtonBodyGetPointVelocity(body:Byte Ptr,point:Float Ptr,velocOut:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetPointVelocity")
Global NewtonBodyGetPosition(body:Byte Ptr,pos:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetPosition")
Global NewtonBodyGetRotation(body:Byte Ptr,rotation:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetRotation")
Global NewtonBodyGetSimulationState:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetSimulationState")
Global NewtonBodyGetSleepState:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetSleepState")
Global NewtonBodyGetTorque(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetTorque")
Global NewtonBodyGetTorqueAcc(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetTorqueAcc")
'Global NewtonBodyGetTransformCallback(body:Byte Ptr,matrix:Float Ptr,threadIndex:Int)(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetTransformCallback")
Global NewtonBodyGetType:Int(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetType")
Global NewtonBodyGetUserData:Object(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetUserData")
Global NewtonBodyGetVelocity(body:Byte Ptr,vector:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetVelocity")
Global NewtonBodyGetWorld:Byte Ptr(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodyGetWorld")
Global NewtonBodyIntegrateVelocity(body:Byte Ptr,timestep:Float)=GetProcAddress(newton_dll,"NewtonBodyIntegrateVelocity")
Global NewtonBodySetAngularDamping(body:Byte Ptr,angularDamp:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetAngularDamping")
Global NewtonBodySetAutoSleep(body:Byte Ptr,state:Int)=GetProcAddress(newton_dll,"NewtonBodySetAutoSleep")
Global NewtonBodySetCentreOfMass(body:Byte Ptr,com:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetCentreOfMass")
Global NewtonBodySetCollidable(body:Byte Ptr,collidableState:Int)=GetProcAddress(newton_dll,"NewtonBodySetCollidable")
Global NewtonBodySetCollision(body:Byte Ptr,collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodySetCollision")
Global NewtonBodySetCollisionScale(body:Byte Ptr,scaleX:Float,scaleY:Float,scaleZ:Float)=GetProcAddress(newton_dll,"NewtonBodySetCollisionScale")
Global NewtonBodySetContinuousCollisionMode(body:Byte Ptr,state:UInt)=GetProcAddress(newton_dll,"NewtonBodySetContinuousCollisionMode")
Global NewtonBodySetDestructorCallback(body:Byte Ptr,callback(body:Byte Ptr))=GetProcAddress(newton_dll,"NewtonBodySetDestructorCallback")
Global NewtonBodySetForce(body:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetForce")
Global NewtonBodySetForceAndTorqueCallback(body:Byte Ptr,callback(body:Byte Ptr,timestep:Float,threadIndex:Int))=GetProcAddress(newton_dll,"NewtonBodySetForceAndTorqueCallback")
Global NewtonBodySetFreezeState(body:Byte Ptr,state:Int)=GetProcAddress(newton_dll,"NewtonBodySetFreezeState")
Global NewtonBodySetJointRecursiveCollision(body:Byte Ptr,state:UInt)=GetProcAddress(newton_dll,"NewtonBodySetJointRecursiveCollision")
Global NewtonBodySetLinearDamping(body:Byte Ptr,linearDamp:Float)=GetProcAddress(newton_dll,"NewtonBodySetLinearDamping")
Global NewtonBodySetMassMatrix(body:Byte Ptr,mass:Float,Ixx:Float,Iyy:Float,Izz:Float)=GetProcAddress(newton_dll,"NewtonBodySetMassMatrix")
Global NewtonBodySetMassProperties(body:Byte Ptr,mass:Float,collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonBodySetMassProperties")
Global NewtonBodySetMaterialGroupID(body:Byte Ptr,id:Int)=GetProcAddress(newton_dll,"NewtonBodySetMaterialGroupID")
Global NewtonBodySetMatrix(body:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetMatrix")
Global NewtonBodySetMatrixRecursive(body:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetMatrixRecursive")
Global NewtonBodySetOmega(body:Byte Ptr,omega:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetOmega")
Global NewtonBodySetSimulationState(bodyPtr:Byte Ptr,state:Int)=GetProcAddress(newton_dll,"NewtonBodySetSimulationState")
Global NewtonBodySetSleepState(body:Byte Ptr,state:Int)=GetProcAddress(newton_dll,"NewtonBodySetSleepState")
Global NewtonBodySetTorque(body:Byte Ptr,torque:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetTorque")
Global NewtonBodySetTransformCallback(body:Byte Ptr,callback(body:Byte Ptr,matrix:Float Ptr,threadIndex:Int))=GetProcAddress(newton_dll,"NewtonBodySetTransformCallback")
Global NewtonBodySetUserData(body:Byte Ptr,userData:Object)=GetProcAddress(newton_dll,"NewtonBodySetUserData")
Global NewtonBodySetVelocity(body:Byte Ptr,velocity:Float Ptr)=GetProcAddress(newton_dll,"NewtonBodySetVelocity")
Global NewtonCalculateSpringDamperAcceleration:Float(dt:Float,ks:Float,x:Float,kd:Float,s:Float)=GetProcAddress(newton_dll,"NewtonCalculateSpringDamperAcceleration")
Global NewtonCollisionCalculateAABB(collision:Byte Ptr,matrix:Float Ptr,p0:Float Ptr,p1:Float Ptr)=GetProcAddress(newton_dll,"NewtonCollisionCalculateAABB")
Global NewtonCollisionClosestPoint:Int(newtonWorld:Byte Ptr,collisionA:Byte Ptr,matrixA:Float Ptr,collisionB:Byte Ptr,matrixB:Float Ptr,contactA:Float Ptr,contactB:Float Ptr,normalAB:Float Ptr,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonCollisionClosestPoint")
Global NewtonCollisionCollide:Int(newtonWorld:Byte Ptr,maxSize:Int,collisionA:Byte Ptr,matrixA:Float Ptr,collisionB:Byte Ptr,matrixB:Float Ptr,contacts:Float Ptr,normals:Float Ptr,penetration:Float Ptr,attributeA:Long Ptr,attributeB:Long Ptr,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonCollisionCollide")
Global NewtonCollisionCollideContinue:Int(newtonWorld:Byte Ptr,maxSize:Int,timestep:Float,collisionA:Byte Ptr,matrixA:Float Ptr,velocA:Float Ptr,omegaA:Float Ptr,collisionB:Byte Ptr,matrixB:Float Ptr,velocB:Float Ptr,omegaB:Float Ptr,timeOfImpact:Float Ptr,contacts:Float Ptr,normals:Float Ptr,penetration:Float Ptr,attributeA:Long Ptr,attributeB:Long Ptr,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonCollisionCollideContinue")
Global NewtonCollisionCreateInstance:Byte Ptr(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionCreateInstance")
Global NewtonCollisionDataPointer:Byte Ptr(convexCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionDataPointer")
Global NewtonCollisionForEachPolygonDo(collision:Byte Ptr,matrix:Float Ptr,callback(userData:Byte Ptr,vertexCount:Int,faceArray:Float Ptr,faceId:Int),userData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionForEachPolygonDo")
Global NewtonCollisionGetInfo(collision:Byte Ptr,collisionInfo:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetInfo")
Global NewtonCollisionGetMatrix(collision:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetMatrix")
Global NewtonCollisionGetMode:Int(convexCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetMode")
Global NewtonCollisionGetParentInstance:Byte Ptr(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetParentInstance")
Global NewtonCollisionGetScale(collision:Byte Ptr,scaleX:Float Ptr,scaleY:Float Ptr,scaleZ:Float Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetScale")
Global NewtonCollisionGetSkinThickness:Float(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetSkinThickness")
Global NewtonCollisionGetSubCollisionHandle:Byte Ptr(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetSubCollisionHandle")
Global NewtonCollisionGetType:Int(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetType")
Global NewtonCollisionGetUserData:Object(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetUserData")
Global NewtonCollisionGetUserData1:Object(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetUserData1")
Global NewtonCollisionGetUserID:UInt(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionGetUserID")
Global NewtonCollisionIntersectionTest:Int(newtonWorld:Byte Ptr,collisionA:Byte Ptr,matrixA:Float Ptr,collisionB:Byte Ptr,matrixB:Float Ptr,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonCollisionIntersectionTest")
Global NewtonCollisionPointDistance:Int(newtonWorld:Byte Ptr,point:Float Ptr,collision:Byte Ptr,matrix:Float Ptr,contact:Float Ptr,normal:Float Ptr,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonCollisionPointDistance")
Global NewtonCollisionRayCast:Float(collision:Byte Ptr,p0:Float Ptr,p1:Float Ptr,normal:Float Ptr,attribute:Long Ptr)=GetProcAddress(newton_dll,"NewtonCollisionRayCast")
Global NewtonCollisionSerialize(newtonWorld:Byte Ptr,collision:Byte Ptr,serializeFunction(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCollisionSerialize")
Global NewtonCollisionSetMatrix(collision:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCollisionSetMatrix")
Global NewtonCollisionSetMode(convexCollision:Byte Ptr,mode:Int)=GetProcAddress(newton_dll,"NewtonCollisionSetMode")
Global NewtonCollisionSetScale(collision:Byte Ptr,scaleX:Float,scaleY:Float,scaleZ:Float)=GetProcAddress(newton_dll,"NewtonCollisionSetScale")
Global NewtonCollisionSetUserData(collision:Byte Ptr,userData:Object)=GetProcAddress(newton_dll,"NewtonCollisionSetUserData")
Global NewtonCollisionSetUserData1(collision:Byte Ptr,userData:Object)=GetProcAddress(newton_dll,"NewtonCollisionSetUserData1")
Global NewtonCollisionSetUserID(collision:Byte Ptr,id:UInt)=GetProcAddress(newton_dll,"NewtonCollisionSetUserID")
Global NewtonCollisionSupportVertex(collision:Byte Ptr,dir:Float Ptr,vertex:Float Ptr)=GetProcAddress(newton_dll,"NewtonCollisionSupportVertex")
Global NewtonCompoundCollisionAddSubCollision:Byte Ptr(compoundCollision:Byte Ptr,convexCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionAddSubCollision")
Global NewtonCompoundCollisionBeginAddRemove(compoundCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionBeginAddRemove")
Global NewtonCompoundCollisionEndAddRemove(compoundCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionEndAddRemove")
Global NewtonCompoundCollisionGetCollisionFromNode:Byte Ptr(compoundCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionGetCollisionFromNode")
Global NewtonCompoundCollisionGetFirstNode:Byte Ptr(compoundCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionGetFirstNode")
Global NewtonCompoundCollisionGetNextNode:Byte Ptr(compoundCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionGetNextNode")
Global NewtonCompoundCollisionGetNodeByIndex:Byte Ptr(compoundCollision:Byte Ptr,index:Int)=GetProcAddress(newton_dll,"NewtonCompoundCollisionGetNodeByIndex")
Global NewtonCompoundCollisionGetNodeIndex:Int(compoundCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionGetNodeIndex")
Global NewtonCompoundCollisionRemoveSubCollision(compoundCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionRemoveSubCollision")
Global NewtonCompoundCollisionRemoveSubCollisionByIndex(compoundCollision:Byte Ptr,nodeIndex:Int)=GetProcAddress(newton_dll,"NewtonCompoundCollisionRemoveSubCollisionByIndex")
Global NewtonCompoundCollisionSetSubCollisionMatrix(compoundCollision:Byte Ptr,collisionNode:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCompoundCollisionSetSubCollisionMatrix")
Global NewtonConstraintCreateBall:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Float Ptr,childBody:Byte Ptr,parentBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateBall")
Global NewtonConstraintCreateCorkscrew:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Float Ptr,pinDir:Float Ptr,childBody:Byte Ptr,parentBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateCorkscrew")
Global NewtonConstraintCreateHinge:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Float Ptr,pinDir:Float Ptr,childBody:Byte Ptr,parentBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateHinge")
Global NewtonConstraintCreateSlider:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Float Ptr,pinDir:Float Ptr,childBody:Byte Ptr,parentBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateSlider")
Global NewtonConstraintCreateUniversal:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Float Ptr,pinDir0:Float Ptr,pinDir1:Float Ptr,childBody:Byte Ptr,parentBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateUniversal")
Global NewtonConstraintCreateUpVector:Byte Ptr(newtonWorld:Byte Ptr,pinDir:Float Ptr,body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateUpVector")
Global NewtonConstraintCreateUserJoint:Byte Ptr(newtonWorld:Byte Ptr,maxDOF:Int,callback(userJoint:Byte Ptr,timestep:Float,threadIndex:Int),getInfo(userJoint:Byte Ptr,info:Byte Ptr),childBody:Byte Ptr,parentBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConstraintCreateUserJoint")
Global NewtonContactGetCollision0:Byte Ptr(contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactGetCollision0")
Global NewtonContactGetCollision1:Byte Ptr(contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactGetCollision1")
Global NewtonContactGetCollisionID0:Byte Ptr(contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactGetCollisionID0")
Global NewtonContactGetCollisionID1:Byte Ptr(contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactGetCollisionID1")
Global NewtonContactGetMaterial:Byte Ptr(contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactGetMaterial")
Global NewtonContactJointGetClosestDistance:Float(contactJoint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactJointGetClosestDistance")
Global NewtonContactJointGetContactCount:Int(contactJoint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactJointGetContactCount")
Global NewtonContactJointGetFirstContact:Byte Ptr(contactJoint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactJointGetFirstContact")
Global NewtonContactJointGetNextContact:Byte Ptr(contactJoint:Byte Ptr,contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactJointGetNextContact")
Global NewtonContactJointRemoveContact(contactJoint:Byte Ptr,contact:Byte Ptr)=GetProcAddress(newton_dll,"NewtonContactJointRemoveContact")
Global NewtonConvexCollisionCalculateBuoyancyAcceleration(convexCollision:Byte Ptr,matrix:Float Ptr,shapeOrigin:Float Ptr,gravityVector:Float Ptr,fluidPlane:Float Ptr,fluidDensity:Float,fluidViscosity:Float,accel:Float Ptr,alpha:Float Ptr)=GetProcAddress(newton_dll,"NewtonConvexCollisionCalculateBuoyancyAcceleration")
Global NewtonConvexCollisionCalculateInertialMatrix(convexCollision:Byte Ptr,inertia:Float Ptr,origin:Float Ptr)=GetProcAddress(newton_dll,"NewtonConvexCollisionCalculateInertialMatrix")
Global NewtonConvexCollisionCalculateVolume:Float(convexCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonConvexCollisionCalculateVolume")
Global NewtonConvexHullGetFaceIndices:Int(convexHullCollision:Byte Ptr,face:Int,faceIndices:Int Ptr)=GetProcAddress(newton_dll,"NewtonConvexHullGetFaceIndices")
Global NewtonConvexHullGetVertexData:Int(convexHullCollision:Byte Ptr,vertexData:Float Ptr Ptr,strideInBytes:Int Ptr)=GetProcAddress(newton_dll,"NewtonConvexHullGetVertexData")
Global NewtonCorkscrewCalculateStopAccel:Float(corkscrew:Byte Ptr,desc:Byte Ptr,position:Float)=GetProcAddress(newton_dll,"NewtonCorkscrewCalculateStopAccel")
Global NewtonCorkscrewCalculateStopAlpha:Float(corkscrew:Byte Ptr,desc:Byte Ptr,angle:Float)=GetProcAddress(newton_dll,"NewtonCorkscrewCalculateStopAlpha")
Global NewtonCorkscrewGetJointAngle:Float(corkscrew:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCorkscrewGetJointAngle")
Global NewtonCorkscrewGetJointForce(corkscrew:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonCorkscrewGetJointForce")
Global NewtonCorkscrewGetJointOmega:Float(corkscrew:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCorkscrewGetJointOmega")
Global NewtonCorkscrewGetJointPosit:Float(corkscrew:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCorkscrewGetJointPosit")
Global NewtonCorkscrewGetJointVeloc:Float(corkscrew:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCorkscrewGetJointVeloc")
Global NewtonCorkscrewSetUserCallback(corkscrew:Byte Ptr,callback:UInt(corkscrew:Byte Ptr,desc:Byte Ptr))=GetProcAddress(newton_dll,"NewtonCorkscrewSetUserCallback")
Global NewtonCreate:Byte Ptr()=GetProcAddress(newton_dll,"NewtonCreate")
Global NewtonCreateBox:Byte Ptr(newtonWorld:Byte Ptr,dx:Float,dy:Float,dz:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateBox")
Global NewtonCreateCapsule:Byte Ptr(newtonWorld:Byte Ptr,radius:Float,height:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateCapsule")
Global NewtonCreateChamferCylinder:Byte Ptr(newtonWorld:Byte Ptr,radius:Float,height:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateChamferCylinder")
Global NewtonCreateClothPatch:Byte Ptr(newtonWorld:Byte Ptr,mesh:Byte Ptr,shapeID:Int,structuralMaterial:Byte Ptr,bendMaterial:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCreateClothPatch")
Global NewtonCreateCollisionFromSerialization:Byte Ptr(newtonWorld:Byte Ptr,deserializeFunction(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCreateCollisionFromSerialization")
Global NewtonCreateCompoundCollision:Byte Ptr(newtonWorld:Byte Ptr,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateCompoundCollision")
Global NewtonCreateCompoundCollisionFromMesh:Byte Ptr(newtonWorld:Byte Ptr,mesh:Byte Ptr,hullTolerance:Float,shapeID:Int,subShapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateCompoundCollisionFromMesh")
Global NewtonCreateCone:Byte Ptr(newtonWorld:Byte Ptr,radius:Float,height:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateCone")
Global NewtonCreateConvexHull:Byte Ptr(newtonWorld:Byte Ptr,count:Int,vertexCloud:Float Ptr,strideInBytes:Int,tolerance:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateConvexHull")
Global NewtonCreateConvexHullFromMesh:Byte Ptr(newtonWorld:Byte Ptr,mesh:Byte Ptr,tolerance:Float,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateConvexHullFromMesh")
Global NewtonCreateCylinder:Byte Ptr(newtonWorld:Byte Ptr,radius:Float,height:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateCylinder")
Global NewtonCreateDeformableBody:Byte Ptr(newtonWorld:Byte Ptr,deformableMesh:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateDeformableBody")
Global NewtonCreateDeformableMesh:Byte Ptr(newtonWorld:Byte Ptr,mesh:Byte Ptr,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateDeformableMesh")
Global NewtonCreateDynamicBody:Byte Ptr(newtonWorld:Byte Ptr,collision:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateDynamicBody")
Global NewtonCreateFracturedCompoundCollision:Byte Ptr(newtonWorld:Byte Ptr,solidMesh:Byte Ptr,shapeID:Int,fracturePhysicsMaterialID:Int,pointcloudCount:Int,vertexCloud:Float Ptr,strideInBytes:Int,materialID:Int,textureMatrix:Float Ptr,regenerateMainMeshCallback(body:Byte Ptr,mainMesh:Byte Ptr,fracturedCompountCollision:Byte Ptr),emitFracturedCompound(fracturedBody:Byte Ptr),emitFracfuredChunk(chunkBody:Byte Ptr,fracturexChunkMesh:Byte Ptr,fracturedCompountCollision:Byte Ptr))=GetProcAddress(newton_dll,"NewtonCreateFracturedCompoundCollision")
Global NewtonCreateHeightFieldCollision:Byte Ptr(newtonWorld:Byte Ptr,width:Int,height:Int,gridsDiagonals:Int,elevationdatType:Int,elevationMap:Byte Ptr,attributeMap:Byte Ptr,verticalScale:Float,horizontalScale:Float,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateHeightFieldCollision")
Global NewtonCreateKinematicBody:Byte Ptr(newtonWorld:Byte Ptr,collision:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateKinematicBody")
Global NewtonCreateNull:Byte Ptr(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonCreateNull")
Global NewtonCreateSceneCollision:Byte Ptr(newtonWorld:Byte Ptr,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateSceneCollision")
Global NewtonCreateSphere:Byte Ptr(newtonWorld:Byte Ptr,radius:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateSphere")
Global NewtonCreateTaperedCapsule:Byte Ptr(newtonWorld:Byte Ptr,radio0:Float,radio1:Float,height:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateTaperedCapsule")
Global NewtonCreateTaperedCylinder:Byte Ptr(newtonWorld:Byte Ptr,radio0:Float,radio1:Float,height:Float,shapeID:Int,offsetMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonCreateTaperedCylinder")
Global NewtonCreateTreeCollision:Byte Ptr(newtonWorld:Byte Ptr,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateTreeCollision")
Global NewtonCreateTreeCollisionFromMesh:Byte Ptr(newtonWorld:Byte Ptr,mesh:Byte Ptr,shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateTreeCollisionFromMesh")
Global NewtonCreateUserMeshCollision:Byte Ptr(newtonWorld:Byte Ptr,minBox:Float Ptr,maxBox:Float Ptr,userData:Byte Ptr,collideCallback(collideDescData:Byte Ptr,continueCollisionHandle:Byte Ptr),rayHitCallback:Float(lineDescData:Byte Ptr),destroyCallback(userData:Byte Ptr),getInfoCallback(userData:Byte Ptr,infoRecord:Byte Ptr),getLocalAABBCallback:Int(userData:Byte Ptr,boxP0:Float Ptr,boxP1:Float Ptr),facesInAABBCallback:Int(userData:Byte Ptr,p0:Float Ptr,p1:Float Ptr,vertexArray:Float Ptr Ptr,vertexCount:Int Ptr,vertexStrideInBytes:Int Ptr,indexList:Int Ptr,maxIndexCount:Int,userDataList:Int Ptr),serializeCallback(userData:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr),shapeID:Int)=GetProcAddress(newton_dll,"NewtonCreateUserMeshCollision")
Global NewtonDeformableMeshBeginConfiguration(deformableMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshBeginConfiguration")
Global NewtonDeformableMeshConstraintParticle(deformableMesh:Byte Ptr,particleIndex:Int,posit:Float Ptr,body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshConstraintParticle")
Global NewtonDeformableMeshCreateClusters(deformableMesh:Byte Ptr,clusterCount:Int,overlapingWidth:Float)=GetProcAddress(newton_dll,"NewtonDeformableMeshCreateClusters")
Global NewtonDeformableMeshEndConfiguration(deformableMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshEndConfiguration")
Global NewtonDeformableMeshGetFirstSegment:Byte Ptr(deformableMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshGetFirstSegment")
Global NewtonDeformableMeshGetNextSegment:Byte Ptr(deformableMesh:Byte Ptr,segment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshGetNextSegment")
Global NewtonDeformableMeshGetParticleCount:Int(deformableMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshGetParticleCount")
Global NewtonDeformableMeshGetParticlePosition(deformableMesh:Byte Ptr,particleIndex:Int,posit:Float Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshGetParticlePosition")
Global NewtonDeformableMeshGetVertexCount:Int(deformableMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshGetVertexCount")
Global NewtonDeformableMeshGetVertexStreams(deformableMesh:Byte Ptr,vertexStrideInByte:Int,vertex:Float Ptr,normalStrideInByte:Int,normal:Float Ptr,uvStrideInByte0:Int,uv0:Float Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshGetVertexStreams")
Global NewtonDeformableMeshSegmentGetIndexCount:Int(deformableMesh:Byte Ptr,segment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshSegmentGetIndexCount")
Global NewtonDeformableMeshSegmentGetIndexList:Int Ptr(deformableMesh:Byte Ptr,segment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshSegmentGetIndexList")
Global NewtonDeformableMeshSegmentGetMaterialID:Int(deformableMesh:Byte Ptr,segment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshSegmentGetMaterialID")
Global NewtonDeformableMeshSetDebugCallback(deformableMesh:Byte Ptr,callback(userData:Byte Ptr,vertexCount:Int,faceArray:Float Ptr,faceId:Int))=GetProcAddress(newton_dll,"NewtonDeformableMeshSetDebugCallback")
Global NewtonDeformableMeshSetSkinThickness(deformableMesh:Byte Ptr,skinThickness:Float)=GetProcAddress(newton_dll,"NewtonDeformableMeshSetSkinThickness")
Global NewtonDeformableMeshUnconstraintParticle(deformableMesh:Byte Ptr,particleIndex:Int)=GetProcAddress(newton_dll,"NewtonDeformableMeshUnconstraintParticle")
Global NewtonDeformableMeshUpdateRenderNormals(deformableMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeformableMeshUpdateRenderNormals")
Global NewtonDeserializeFromFile(newtonWorld:Byte Ptr,filename:Byte Ptr,bodyCallback(body:Byte Ptr,userData:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr),bodyUserData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDeserializeFromFile")
Global NewtonDestroy(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDestroy")
Global NewtonDestroyAllBodies(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDestroyAllBodies")
Global NewtonDestroyBody(body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDestroyBody")
Global NewtonDestroyCollision(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDestroyCollision")
Global NewtonDestroyJoint(newtonWorld:Byte Ptr,joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDestroyJoint")
Global NewtonDispachThreadJob(newtonWorld:Byte Ptr,task(world:Byte Ptr,userData:Byte Ptr,threadIndex:Int),usedData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonDispachThreadJob")
Global NewtonEnumrateDevices:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonEnumrateDevices")
Global NewtonFracturedCompoundCollisionGetVertexCount:Int(fracturedCompound:Byte Ptr,meshOwner:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundCollisionGetVertexCount")
Global NewtonFracturedCompoundCollisionGetVertexNormals:Float Ptr(fracturedCompound:Byte Ptr,meshOwner:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundCollisionGetVertexNormals")
Global NewtonFracturedCompoundCollisionGetVertexPositions:Float Ptr(fracturedCompound:Byte Ptr,meshOwner:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundCollisionGetVertexPositions")
Global NewtonFracturedCompoundCollisionGetVertexUVs:Float Ptr(fracturedCompound:Byte Ptr,meshOwner:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundCollisionGetVertexUVs")
Global NewtonFracturedCompoundGetFirstSubMesh:Byte Ptr(fracturedCompound:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundGetFirstSubMesh")
Global NewtonFracturedCompoundGetMainMesh:Byte Ptr(fracturedCompound:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundGetMainMesh")
Global NewtonFracturedCompoundGetNextSubMesh:Byte Ptr(fracturedCompound:Byte Ptr,subMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundGetNextSubMesh")
Global NewtonFracturedCompoundIsNodeFreeToDetach:Int(fracturedCompound:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundIsNodeFreeToDetach")
Global NewtonFracturedCompoundMeshPartGetFirstSegment:Byte Ptr(fractureCompoundMeshPart:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundMeshPartGetFirstSegment")
Global NewtonFracturedCompoundMeshPartGetIndexCount:Int(fractureCompoundMeshSegment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundMeshPartGetIndexCount")
Global NewtonFracturedCompoundMeshPartGetIndexStream:Int(fracturedCompound:Byte Ptr,meshOwner:Byte Ptr,segment:Byte Ptr,index:Int Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundMeshPartGetIndexStream")
Global NewtonFracturedCompoundMeshPartGetMaterial:Int(fractureCompoundMeshSegment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundMeshPartGetMaterial")
Global NewtonFracturedCompoundMeshPartGetNextSegment:Byte Ptr(fractureCompoundMeshSegment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundMeshPartGetNextSegment")
Global NewtonFracturedCompoundNeighborNodeList:Int(fracturedCompound:Byte Ptr,collisionNode:Byte Ptr,list:Byte Ptr Ptr,maxCount:Int)=GetProcAddress(newton_dll,"NewtonFracturedCompoundNeighborNodeList")
Global NewtonFracturedCompoundPlaneClip:Byte Ptr(fracturedCompound:Byte Ptr,plane:Float Ptr)=GetProcAddress(newton_dll,"NewtonFracturedCompoundPlaneClip")
Global NewtonFracturedCompoundSetCallbacks(fracturedCompound:Byte Ptr,regenerateMainMeshCallback(body:Byte Ptr,mainMesh:Byte Ptr,fracturedCompountCollision:Byte Ptr),emitFracturedCompound(fracturedBody:Byte Ptr),emitFracfuredChunk(chunkBody:Byte Ptr,fracturexChunkMesh:Byte Ptr,fracturedCompountCollision:Byte Ptr))=GetProcAddress(newton_dll,"NewtonFracturedCompoundSetCallbacks")
Global NewtonFree(_ptr:Byte Ptr)=GetProcAddress(newton_dll,"NewtonFree")
</textarea> <br><br></td></tr></table><br>
<a name="1314633"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Part2, just copy-paste to the end of part1<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global NewtonGetBroadphaseAlgorithm:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonGetBroadphaseAlgorithm")
Global NewtonGetContactMergeTolerance:Float(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonGetContactMergeTolerance")
Global NewtonGetCurrentDevice:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonGetCurrentDevice")
Global NewtonGetDeviceString(newtonWorld:Byte Ptr,deviceIndex:Int,vendorString:Byte Ptr,maxSize:Int)=GetProcAddress(newton_dll,"NewtonGetDeviceString")
Global NewtonGetEulerAngle(matrix:Float Ptr,eulersAngles0:Float Ptr,eulersAngles1:Float Ptr)=GetProcAddress(newton_dll,"NewtonGetEulerAngle")
'Global NewtonGetJointSerializationCallbacks(newtonWorld:Byte Ptr,serializeJoint(joint:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr) Var,deserializeJoint(body0:Byte Ptr,body1:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr) Var)=GetProcAddress(newton_dll,"NewtonGetJointSerializationCallbacks")
Global NewtonGetMaxThreadsCount:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonGetMaxThreadsCount")
Global NewtonGetMemoryUsed:Int()=GetProcAddress(newton_dll,"NewtonGetMemoryUsed")
Global NewtonGetMultiThreadSolverOnSingleIsland:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonGetMultiThreadSolverOnSingleIsland")
Global NewtonGetThreadsCount:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonGetThreadsCount")
Global NewtonHeightFieldSetUserRayCastCallback(heightfieldCollision:Byte Ptr,rayHitCallback:Float(body:Byte Ptr,heightFieldCollision:Byte Ptr,intersection:Float,row:Int,col:Int,normal:Float Ptr,faceId:Int,usedData:Byte Ptr))=GetProcAddress(newton_dll,"NewtonHeightFieldSetUserRayCastCallback")
Global NewtonHingeCalculateStopAlpha:Float(hinge:Byte Ptr,desc:Byte Ptr,angle:Float)=GetProcAddress(newton_dll,"NewtonHingeCalculateStopAlpha")
Global NewtonHingeGetJointAngle:Float(hinge:Byte Ptr)=GetProcAddress(newton_dll,"NewtonHingeGetJointAngle")
Global NewtonHingeGetJointForce(hinge:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonHingeGetJointForce")
Global NewtonHingeGetJointOmega:Float(hinge:Byte Ptr)=GetProcAddress(newton_dll,"NewtonHingeGetJointOmega")
Global NewtonHingeSetUserCallback(hinge:Byte Ptr,callback:UInt(hinge:Byte Ptr,desc:Byte Ptr))=GetProcAddress(newton_dll,"NewtonHingeSetUserCallback")
Global NewtonInvalidateCache(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonInvalidateCache")
Global NewtonIslandGetBody:Byte Ptr(island:Byte Ptr,bodyIndex:Int)=GetProcAddress(newton_dll,"NewtonIslandGetBody")
Global NewtonIslandGetBodyAABB(island:Byte Ptr,bodyIndex:Int,p0:Float Ptr,p1:Float Ptr)=GetProcAddress(newton_dll,"NewtonIslandGetBodyAABB")
Global NewtonJointGetBody0:Byte Ptr(joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointGetBody0")
Global NewtonJointGetBody1:Byte Ptr(joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointGetBody1")
Global NewtonJointGetCollisionState:Int(joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointGetCollisionState")
Global NewtonJointGetInfo(joint:Byte Ptr,info:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointGetInfo")
Global NewtonJointGetStiffness:Float(joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointGetStiffness")
Global NewtonJointGetUserData:Object(joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointGetUserData")
Global NewtonJointIsActive:Int(joint:Byte Ptr)=GetProcAddress(newton_dll,"NewtonJointIsActive")
Global NewtonJointSetCollisionState(joint:Byte Ptr,state:Int)=GetProcAddress(newton_dll,"NewtonJointSetCollisionState")
Global NewtonJointSetDestructor(joint:Byte Ptr,destructor(me:Byte Ptr))=GetProcAddress(newton_dll,"NewtonJointSetDestructor")
Global NewtonJointSetStiffness(joint:Byte Ptr,state:Float)=GetProcAddress(newton_dll,"NewtonJointSetStiffness")
Global NewtonJointSetUserData(joint:Byte Ptr,userData:Object)=GetProcAddress(newton_dll,"NewtonJointSetUserData")
Global NewtonMaterialContactRotateTangentDirections(material:Byte Ptr,directionVector:Float Ptr)=GetProcAddress(newton_dll,"NewtonMaterialContactRotateTangentDirections")
Global NewtonMaterialCreateGroupID:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialCreateGroupID")
Global NewtonMaterialDestroyAllGroupID(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialDestroyAllGroupID")
Global NewtonMaterialGetBodyCollidingShape:Byte Ptr(material:Byte Ptr,body:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetBodyCollidingShape")
Global NewtonMaterialGetContactFaceAttribute:UInt(material:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetContactFaceAttribute")
Global NewtonMaterialGetContactForce(material:Byte Ptr,body:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetContactForce")
Global NewtonMaterialGetContactMaxNormalImpact:Float(material:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetContactMaxNormalImpact")
Global NewtonMaterialGetContactMaxTangentImpact:Float(material:Byte Ptr,index:Int)=GetProcAddress(newton_dll,"NewtonMaterialGetContactMaxTangentImpact")
Global NewtonMaterialGetContactNormalSpeed:Float(material:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetContactNormalSpeed")
Global NewtonMaterialGetContactPositionAndNormal(material:Byte Ptr,body:Byte Ptr,posit:Float Ptr,normal:Float Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetContactPositionAndNormal")
Global NewtonMaterialGetContactTangentDirections(material:Byte Ptr,body:Byte Ptr,dir0:Float Ptr,dir1:Float Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetContactTangentDirections")
Global NewtonMaterialGetContactTangentSpeed:Float(material:Byte Ptr,index:Int)=GetProcAddress(newton_dll,"NewtonMaterialGetContactTangentSpeed")
Global NewtonMaterialGetDefaultGroupID:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetDefaultGroupID")
Global NewtonMaterialGetMaterialPairUserData:Object(material:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMaterialGetMaterialPairUserData")
Global NewtonMaterialGetUserData:Object(newtonWorld:Byte Ptr,id0:Int,id1:Int)=GetProcAddress(newton_dll,"NewtonMaterialGetUserData")
Global NewtonMaterialSetCollisionCallback(newtonWorld:Byte Ptr,id0:Int,id1:Int,userData:Byte Ptr,aabbOverlap:Int(material:Byte Ptr,body0:Byte Ptr,body1:Byte Ptr,threadIndex:Int),process(contact:Byte Ptr,timestep:Float,threadIndex:Int))=GetProcAddress(newton_dll,"NewtonMaterialSetCollisionCallback")
Global NewtonMaterialSetCompoundCollisionCallback(newtonWorld:Byte Ptr,id0:Int,id1:Int,compoundAabbOverlap:Int(material:Byte Ptr,body0:Byte Ptr,collsionNode0:Byte Ptr,body1:Byte Ptr,collsionNode1:Byte Ptr,threadIndex:Int))=GetProcAddress(newton_dll,"NewtonMaterialSetCompoundCollisionCallback")
Global NewtonMaterialSetContactElasticity(material:Byte Ptr,restitution:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetContactElasticity")
Global NewtonMaterialSetContactFrictionCoef(material:Byte Ptr,staticFrictionCoef:Float,kineticFrictionCoef:Float,index:Int)=GetProcAddress(newton_dll,"NewtonMaterialSetContactFrictionCoef")
Global NewtonMaterialSetContactFrictionState(material:Byte Ptr,state:Int,index:Int)=GetProcAddress(newton_dll,"NewtonMaterialSetContactFrictionState")
Global NewtonMaterialSetContactNormalAcceleration(material:Byte Ptr,accel:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetContactNormalAcceleration")
Global NewtonMaterialSetContactNormalDirection(material:Byte Ptr,directionVector:Float Ptr)=GetProcAddress(newton_dll,"NewtonMaterialSetContactNormalDirection")
Global NewtonMaterialSetContactSoftness(material:Byte Ptr,softness:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetContactSoftness")
Global NewtonMaterialSetContactTangentAcceleration(material:Byte Ptr,accel:Float,index:Int)=GetProcAddress(newton_dll,"NewtonMaterialSetContactTangentAcceleration")
Global NewtonMaterialSetDefaultCollidable(newtonWorld:Byte Ptr,id0:Int,id1:Int,state:Int)=GetProcAddress(newton_dll,"NewtonMaterialSetDefaultCollidable")
Global NewtonMaterialSetDefaultElasticity(newtonWorld:Byte Ptr,id0:Int,id1:Int,elasticCoef:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetDefaultElasticity")
Global NewtonMaterialSetDefaultFriction(newtonWorld:Byte Ptr,id0:Int,id1:Int,staticFriction:Float,kineticFriction:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetDefaultFriction")
Global NewtonMaterialSetDefaultSoftness(newtonWorld:Byte Ptr,id0:Int,id1:Int,value:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetDefaultSoftness")
Global NewtonMaterialSetSurfaceThickness(newtonWorld:Byte Ptr,id0:Int,id1:Int,thickness:Float)=GetProcAddress(newton_dll,"NewtonMaterialSetSurfaceThickness")
Global NewtonMeshAddFace(mesh:Byte Ptr,vertexCount:Int,vertex:Float Ptr,strideInBytes:Int,materialIndex:Int)=GetProcAddress(newton_dll,"NewtonMeshAddFace")
Global NewtonMeshApplyAngleBasedMapping(mesh:Byte Ptr,material:Int,reportPrograssCallback:Int(normalizedProgressPercent:Float,userData:Byte Ptr),reportPrgressUserData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshApplyAngleBasedMapping")
Global NewtonMeshApplyBoxMapping(mesh:Byte Ptr,frontMaterial:Int,sideMaterial:Int,topMaterial:Int)=GetProcAddress(newton_dll,"NewtonMeshApplyBoxMapping")
Global NewtonMeshApplyCylindricalMapping(mesh:Byte Ptr,cylinderMaterial:Int,capMaterial:Int)=GetProcAddress(newton_dll,"NewtonMeshApplyCylindricalMapping")
Global NewtonMeshApplySphericalMapping(mesh:Byte Ptr,material:Int)=GetProcAddress(newton_dll,"NewtonMeshApplySphericalMapping")
Global NewtonMeshApplyTransform(mesh:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshApplyTransform")
Global NewtonMeshApproximateConvexDecomposition:Byte Ptr(mesh:Byte Ptr,maxConcavity:Float,backFaceDistanceFactor:Float,maxCount:Int,maxVertexPerHull:Int,reportProgressCallback:Int(normalizedProgressPercent:Float,userData:Byte Ptr),reportProgressUserData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshApproximateConvexDecomposition")
Global NewtonMeshBeginFace(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshBeginFace")
Global NewtonMeshBeginHandle:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshBeginHandle")
Global NewtonMeshBuildFromVertexListIndexList(mesh:Byte Ptr,faceCount:Int,faceIndexCount:Int Ptr,faceMaterialIndex:Int Ptr,vertex:Float Ptr,vertexStrideInBytes:Int,vertexIndex:Int Ptr,normal:Float Ptr,normalStrideInBytes:Int,normalIndex:Int Ptr,uv0:Float Ptr,uv0StrideInBytes:Int,uv0Index:Int Ptr,uv1:Float Ptr,uv1StrideInBytes:Int,uv1Index:Int Ptr)=GetProcAddress(newton_dll,"NewtonMeshBuildFromVertexListIndexList")
Global NewtonMeshCalculateFaceNormal(mesh:Byte Ptr,face:Byte Ptr,normal:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCalculateFaceNormal")
Global NewtonMeshCalculateOOBB(mesh:Byte Ptr,matrix:Float Ptr,x:Float Ptr,y:Float Ptr,z:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshCalculateOOBB")
Global NewtonMeshCalculateVertexNormals(mesh:Byte Ptr,angleInRadians:Float)=GetProcAddress(newton_dll,"NewtonMeshCalculateVertexNormals")
Global NewtonMeshClip(mesh:Byte Ptr,clipper:Byte Ptr,clipperMatrix:Float Ptr,topMesh:Byte Ptr Ptr,bottomMesh:Byte Ptr Ptr)=GetProcAddress(newton_dll,"NewtonMeshClip")
Global NewtonMeshConvexMeshIntersection:Byte Ptr(mesh:Byte Ptr,convexMesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshConvexMeshIntersection")
Global NewtonMeshCreate:Byte Ptr(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreate")
Global NewtonMeshCreateConvexHull:Byte Ptr(newtonWorld:Byte Ptr,pointCount:Int,vertexCloud:Float Ptr,strideInBytes:Int,tolerance:Float)=GetProcAddress(newton_dll,"NewtonMeshCreateConvexHull")
Global NewtonMeshCreateDelaunayTetrahedralization:Byte Ptr(newtonWorld:Byte Ptr,pointCount:Int,vertexCloud:Float Ptr,strideInBytes:Int,materialID:Int,textureMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateDelaunayTetrahedralization")
Global NewtonMeshCreateFirstLayer:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateFirstLayer")
Global NewtonMeshCreateFirstSingleSegment:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateFirstSingleSegment")
Global NewtonMeshCreateFromCollision:Byte Ptr(collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateFromCollision")
Global NewtonMeshCreateFromMesh:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateFromMesh")
Global NewtonMeshCreateFromSerialization:Byte Ptr(newtonWorld:Byte Ptr,deserializeFunction(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateFromSerialization")
Global NewtonMeshCreateNextLayer:Byte Ptr(mesh:Byte Ptr,segment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateNextLayer")
Global NewtonMeshCreateNextSingleSegment:Byte Ptr(mesh:Byte Ptr,segment:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateNextSingleSegment")
Global NewtonMeshCreateVoronoiConvexDecomposition:Byte Ptr(newtonWorld:Byte Ptr,pointCount:Int,vertexCloud:Float Ptr,strideInBytes:Int,materialID:Int,textureMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshCreateVoronoiConvexDecomposition")
Global NewtonMeshDestroy(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshDestroy")
Global NewtonMeshDifference:Byte Ptr(mesh:Byte Ptr,clipper:Byte Ptr,clipperMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshDifference")
Global NewtonMeshEndFace(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshEndFace")
Global NewtonMeshEndHandle(mesh:Byte Ptr,handle:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshEndHandle")
Global NewtonMeshFirstMaterial:Int(mesh:Byte Ptr,handle:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshFirstMaterial")
Global NewtonMeshFixTJoints(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshFixTJoints")
Global NewtonMeshGetEdgeIndices(mesh:Byte Ptr,edge:Byte Ptr,v0:Int Ptr,v1:Int Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetEdgeIndices")
Global NewtonMeshGetFaceIndexCount:Int(mesh:Byte Ptr,face:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFaceIndexCount")
Global NewtonMeshGetFaceIndices(mesh:Byte Ptr,face:Byte Ptr,indices:Int Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFaceIndices")
Global NewtonMeshGetFaceMaterial:Int(mesh:Byte Ptr,face:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFaceMaterial")
Global NewtonMeshGetFacePointIndices(mesh:Byte Ptr,face:Byte Ptr,indices:Int Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFacePointIndices")
Global NewtonMeshGetFaces(mesh:Byte Ptr,faceIndexCount:Int Ptr,faceMaterial:Int Ptr,faceIndices:Byte Ptr Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFaces")
Global NewtonMeshGetFirstEdge:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFirstEdge")
Global NewtonMeshGetFirstFace:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFirstFace")
Global NewtonMeshGetFirstPoint:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFirstPoint")
Global NewtonMeshGetFirstVertex:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetFirstVertex")
Global NewtonMeshGetIndirectVertexStreams(mesh:Byte Ptr,vertexStrideInByte:Int,vertex:Float Ptr,vertexIndices:Int Ptr,vertexCount:Int Ptr,normalStrideInByte:Int,normal:Float Ptr,normalIndices:Int Ptr,normalCount:Int Ptr,uvStrideInByte0:Int,uv0:Float Ptr,uvIndices0:Int Ptr,uvCount0:Int Ptr,uvStrideInByte1:Int,uv1:Float Ptr,uvIndices1:Int Ptr,uvCount1:Int Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetIndirectVertexStreams")
Global NewtonMeshGetNextEdge:Byte Ptr(mesh:Byte Ptr,edge:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetNextEdge")
Global NewtonMeshGetNextFace:Byte Ptr(mesh:Byte Ptr,face:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetNextFace")
Global NewtonMeshGetNextPoint:Byte Ptr(mesh:Byte Ptr,point:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetNextPoint")
Global NewtonMeshGetNextVertex:Byte Ptr(mesh:Byte Ptr,vertex:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetNextVertex")
Global NewtonMeshGetNormalArray:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetNormalArray")
Global NewtonMeshGetPointArray:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetPointArray")
Global NewtonMeshGetPointCount:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetPointCount")
Global NewtonMeshGetPointIndex:Int(mesh:Byte Ptr,point:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetPointIndex")
Global NewtonMeshGetPointStrideInByte:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetPointStrideInByte")
Global NewtonMeshGetTotalFaceCount:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetTotalFaceCount")
Global NewtonMeshGetTotalIndexCount:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetTotalIndexCount")
Global NewtonMeshGetUV0Array:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetUV0Array")
Global NewtonMeshGetUV1Array:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetUV1Array")
Global NewtonMeshGetVertexArray:Byte Ptr(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetVertexArray")
Global NewtonMeshGetVertexCount:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetVertexCount")
Global NewtonMeshGetVertexIndex:Int(mesh:Byte Ptr,vertex:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetVertexIndex")
Global NewtonMeshGetVertexIndexFromPoint:Int(mesh:Byte Ptr,point:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetVertexIndexFromPoint")
Global NewtonMeshGetVertexStreams(mesh:Byte Ptr,vertexStrideInByte:Int,vertex:Float Ptr,normalStrideInByte:Int,normal:Float Ptr,uvStrideInByte0:Int,uv0:Float Ptr,uvStrideInByte1:Int,uv1:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetVertexStreams")
Global NewtonMeshGetVertexStrideInByte:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshGetVertexStrideInByte")
Global NewtonMeshIntersection:Byte Ptr(mesh:Byte Ptr,clipper:Byte Ptr,clipperMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshIntersection")
Global NewtonMeshIsFaceOpen:Int(mesh:Byte Ptr,face:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshIsFaceOpen")
Global NewtonMeshIsOpenMesh:Int(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshIsOpenMesh")
Global NewtonMeshLoadOFF:Byte Ptr(newtonWorld:Byte Ptr,filename:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshLoadOFF")
Global NewtonMeshMaterialGetIndexCount:Int(mesh:Byte Ptr,handle:Byte Ptr,materialId:Int)=GetProcAddress(newton_dll,"NewtonMeshMaterialGetIndexCount")
Global NewtonMeshMaterialGetIndexStream(mesh:Byte Ptr,handle:Byte Ptr,materialId:Int,index:Int Ptr)=GetProcAddress(newton_dll,"NewtonMeshMaterialGetIndexStream")
Global NewtonMeshMaterialGetIndexStreamShort(mesh:Byte Ptr,handle:Byte Ptr,materialId:Int,index:Short Ptr)=GetProcAddress(newton_dll,"NewtonMeshMaterialGetIndexStreamShort")
Global NewtonMeshMaterialGetMaterial:Int(mesh:Byte Ptr,handle:Byte Ptr,materialId:Int)=GetProcAddress(newton_dll,"NewtonMeshMaterialGetMaterial")
Global NewtonMeshNextMaterial:Int(mesh:Byte Ptr,handle:Byte Ptr,materialId:Int)=GetProcAddress(newton_dll,"NewtonMeshNextMaterial")
Global NewtonMeshPolygonize(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshPolygonize")
Global NewtonMeshSaveOFF(mesh:Byte Ptr,filename:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshSaveOFF")
Global NewtonMeshSerialize(mesh:Byte Ptr,serializeFunction(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshSerialize")
Global NewtonMeshSetFaceMaterial(mesh:Byte Ptr,face:Byte Ptr,matId:Int)=GetProcAddress(newton_dll,"NewtonMeshSetFaceMaterial")
Global NewtonMeshSimplify:Byte Ptr(mesh:Byte Ptr,maxVertexCount:Int,reportPrograssCallback:Int(normalizedProgressPercent:Float,userData:Byte Ptr),reportPrgressUserData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshSimplify")
Global NewtonMeshTriangulate(mesh:Byte Ptr)=GetProcAddress(newton_dll,"NewtonMeshTriangulate")
Global NewtonMeshUnion:Byte Ptr(mesh:Byte Ptr,clipper:Byte Ptr,clipperMatrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonMeshUnion")
Global NewtonRemoveUnusedVertices(mesh:Byte Ptr,vertexRemapTable:Int Ptr)=GetProcAddress(newton_dll,"NewtonRemoveUnusedVertices")
Global NewtonSceneCollisionAddSubCollision:Byte Ptr(sceneCollision:Byte Ptr,collision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionAddSubCollision")
Global NewtonSceneCollisionBeginAddRemove(sceneCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionBeginAddRemove")
Global NewtonSceneCollisionEndAddRemove(sceneCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionEndAddRemove")
Global NewtonSceneCollisionGetCollisionFromNode:Byte Ptr(sceneCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionGetCollisionFromNode")
Global NewtonSceneCollisionGetFirstNode:Byte Ptr(sceneCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionGetFirstNode")
Global NewtonSceneCollisionGetNextNode:Byte Ptr(sceneCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionGetNextNode")
Global NewtonSceneCollisionGetNodeByIndex:Byte Ptr(sceneCollision:Byte Ptr,index:Int)=GetProcAddress(newton_dll,"NewtonSceneCollisionGetNodeByIndex")
Global NewtonSceneCollisionGetNodeIndex:Int(sceneCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionGetNodeIndex")
Global NewtonSceneCollisionRemoveSubCollision(compoundCollision:Byte Ptr,collisionNode:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionRemoveSubCollision")
Global NewtonSceneCollisionRemoveSubCollisionByIndex(sceneCollision:Byte Ptr,nodeIndex:Int)=GetProcAddress(newton_dll,"NewtonSceneCollisionRemoveSubCollisionByIndex")
Global NewtonSceneCollisionSetSubCollisionMatrix(sceneCollision:Byte Ptr,collisionNode:Byte Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonSceneCollisionSetSubCollisionMatrix")
Global NewtonSelectBroadphaseAlgorithm(newtonWorld:Byte Ptr,algorithmType:Int)=GetProcAddress(newton_dll,"NewtonSelectBroadphaseAlgorithm")
Global NewtonSerializeToFile(newtonWorld:Byte Ptr,filename:Byte Ptr,bodyCallback(body:Byte Ptr,userData:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr),bodyUserData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSerializeToFile")
Global NewtonSetContactMergeTolerance(newtonWorld:Byte Ptr,tolerance:Float)=GetProcAddress(newton_dll,"NewtonSetContactMergeTolerance")
Global NewtonSetCurrentDevice(newtonWorld:Byte Ptr,deviceIndex:Int)=GetProcAddress(newton_dll,"NewtonSetCurrentDevice")
Global NewtonSetEulerAngle(eulersAngles:Float Ptr,matrix:Float Ptr)=GetProcAddress(newton_dll,"NewtonSetEulerAngle")
Global NewtonSetFrictionModel(newtonWorld:Byte Ptr,model:Int)=GetProcAddress(newton_dll,"NewtonSetFrictionModel")
Global NewtonSetIslandUpdateEvent(newtonWorld:Byte Ptr,islandUpdate:Int(newtonWorld:Byte Ptr,islandHandle:Byte Ptr,bodyCount:Int))=GetProcAddress(newton_dll,"NewtonSetIslandUpdateEvent")
Global NewtonSetJointSerializationCallbacks(newtonWorld:Byte Ptr,serializeJoint(joint:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr),deserializeJoint(body0:Byte Ptr,body1:Byte Ptr,_function(serializeHandle:Byte Ptr,buffer:Byte Ptr,size:Int),serializeHandle:Byte Ptr))=GetProcAddress(newton_dll,"NewtonSetJointSerializationCallbacks")
Global NewtonSetMemorySystem(malloc:Byte Ptr(sizeInBytes:Int),free(_ptr:Byte Ptr,sizeInBytes:Int))=GetProcAddress(newton_dll,"NewtonSetMemorySystem")
Global NewtonSetMinimumFrameRate(newtonWorld:Byte Ptr,frameRate:Float)=GetProcAddress(newton_dll,"NewtonSetMinimumFrameRate")
Global NewtonSetMultiThreadSolverOnSingleIsland(newtonWorld:Byte Ptr,mode:Int)=GetProcAddress(newton_dll,"NewtonSetMultiThreadSolverOnSingleIsland")
Global NewtonSetSolverModel(newtonWorld:Byte Ptr,model:Int)=GetProcAddress(newton_dll,"NewtonSetSolverModel")
Global NewtonSetThreadsCount(newtonWorld:Byte Ptr,threads:Int)=GetProcAddress(newton_dll,"NewtonSetThreadsCount")
Global NewtonSliderCalculateStopAccel:Float(slider:Byte Ptr,desc:Byte Ptr,position:Float)=GetProcAddress(newton_dll,"NewtonSliderCalculateStopAccel")
Global NewtonSliderGetJointForce(slider:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonSliderGetJointForce")
Global NewtonSliderGetJointPosit:Float(slider:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSliderGetJointPosit")
Global NewtonSliderGetJointVeloc:Float(slider:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSliderGetJointVeloc")
Global NewtonSliderSetUserCallback(slider:Byte Ptr,callback:UInt(slider:Byte Ptr,desc:Byte Ptr))=GetProcAddress(newton_dll,"NewtonSliderSetUserCallback")
Global NewtonStaticCollisionSetDebugCallback(staticCollision:Byte Ptr,userCallback(bodyWithTreeCollision:Byte Ptr,body:Byte Ptr,faceID:Int,vertexCount:Int,vertex:Float Ptr,vertexStrideInBytes:Int))=GetProcAddress(newton_dll,"NewtonStaticCollisionSetDebugCallback")
Global NewtonSyncThreadJobs(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonSyncThreadJobs")
Global NewtonTreeCollisionAddFace(treeCollision:Byte Ptr,vertexCount:Int,vertexPtr:Float Ptr,strideInBytes:Int,faceAttribute:Int)=GetProcAddress(newton_dll,"NewtonTreeCollisionAddFace")
Global NewtonTreeCollisionBeginBuild(treeCollision:Byte Ptr)=GetProcAddress(newton_dll,"NewtonTreeCollisionBeginBuild")
Global NewtonTreeCollisionEndBuild(treeCollision:Byte Ptr,optimize:Int)=GetProcAddress(newton_dll,"NewtonTreeCollisionEndBuild")
Global NewtonTreeCollisionForEachFace(treeCollision:Byte Ptr,forEachFaceCallback:Int(context:Byte Ptr,polygon:Float Ptr,strideInBytes:Int,indexArray:Int Ptr,indexCount:Int),context:Byte Ptr)=GetProcAddress(newton_dll,"NewtonTreeCollisionForEachFace")
Global NewtonTreeCollisionGetFaceAttribute:Int(treeCollision:Byte Ptr,faceIndexArray:Int Ptr,indexCount:Int)=GetProcAddress(newton_dll,"NewtonTreeCollisionGetFaceAttribute")
Global NewtonTreeCollisionGetVertexListTriangleListInAABB:Int(treeCollision:Byte Ptr,p0:Float Ptr,p1:Float Ptr,vertexArray:Float Ptr Ptr,vertexCount:Int Ptr,vertexStrideInBytes:Int Ptr,indexList:Int Ptr,maxIndexCount:Int,faceAttribute:Int Ptr)=GetProcAddress(newton_dll,"NewtonTreeCollisionGetVertexListTriangleListInAABB")
Global NewtonTreeCollisionSetFaceAttribute(treeCollision:Byte Ptr,faceIndexArray:Int Ptr,indexCount:Int,attribute:Int)=GetProcAddress(newton_dll,"NewtonTreeCollisionSetFaceAttribute")
Global NewtonTreeCollisionSetUserRayCastCallback(treeCollision:Byte Ptr,rayHitCallback:Float(body:Byte Ptr,treeCollision:Byte Ptr,intersection:Float,normal:Float Ptr,faceId:Int,usedData:Byte Ptr))=GetProcAddress(newton_dll,"NewtonTreeCollisionSetUserRayCastCallback")
Global NewtonUniversalCalculateStopAlpha0:Float(universal:Byte Ptr,desc:Byte Ptr,angle:Float)=GetProcAddress(newton_dll,"NewtonUniversalCalculateStopAlpha0")
Global NewtonUniversalCalculateStopAlpha1:Float(universal:Byte Ptr,desc:Byte Ptr,angle:Float)=GetProcAddress(newton_dll,"NewtonUniversalCalculateStopAlpha1")
Global NewtonUniversalGetJointAngle0:Float(universal:Byte Ptr)=GetProcAddress(newton_dll,"NewtonUniversalGetJointAngle0")
Global NewtonUniversalGetJointAngle1:Float(universal:Byte Ptr)=GetProcAddress(newton_dll,"NewtonUniversalGetJointAngle1")
Global NewtonUniversalGetJointForce(universal:Byte Ptr,force:Float Ptr)=GetProcAddress(newton_dll,"NewtonUniversalGetJointForce")
Global NewtonUniversalGetJointOmega0:Float(universal:Byte Ptr)=GetProcAddress(newton_dll,"NewtonUniversalGetJointOmega0")
Global NewtonUniversalGetJointOmega1:Float(universal:Byte Ptr)=GetProcAddress(newton_dll,"NewtonUniversalGetJointOmega1")
Global NewtonUniversalSetUserCallback(universal:Byte Ptr,callback:UInt(universal:Byte Ptr,desc:Byte Ptr))=GetProcAddress(newton_dll,"NewtonUniversalSetUserCallback")
Global NewtonUpVectorGetPin(upVector:Byte Ptr,pin:Float Ptr)=GetProcAddress(newton_dll,"NewtonUpVectorGetPin")
Global NewtonUpVectorSetPin(upVector:Byte Ptr,pin:Float Ptr)=GetProcAddress(newton_dll,"NewtonUpVectorSetPin")
Global NewtonUpdate(newtonWorld:Byte Ptr,timestep:Float)=GetProcAddress(newton_dll,"NewtonUpdate")
Global NewtonUpdateAsync(newtonWorld:Byte Ptr,timestep:Float)=GetProcAddress(newton_dll,"NewtonUpdateAsync")
Global NewtonUserJointAddAngularRow(joint:Byte Ptr,relativeAngle:Float,dir:Float Ptr)=GetProcAddress(newton_dll,"NewtonUserJointAddAngularRow")
Global NewtonUserJointAddGeneralRow(joint:Byte Ptr,jacobian0:Float Ptr,jacobian1:Float Ptr)=GetProcAddress(newton_dll,"NewtonUserJointAddGeneralRow")
Global NewtonUserJointAddLinearRow(joint:Byte Ptr,pivot0:Float Ptr,pivot1:Float Ptr,dir:Float Ptr)=GetProcAddress(newton_dll,"NewtonUserJointAddLinearRow")
Global NewtonUserJointGetRowForce:Float(joint:Byte Ptr,row:Int)=GetProcAddress(newton_dll,"NewtonUserJointGetRowForce")
Global NewtonUserJointSetFeedbackCollectorCallback(joint:Byte Ptr,getFeedback(userJoint:Byte Ptr,timestep:Float,threadIndex:Int))=GetProcAddress(newton_dll,"NewtonUserJointSetFeedbackCollectorCallback")
Global NewtonUserJointSetRowAcceleration(joint:Byte Ptr,acceleration:Float)=GetProcAddress(newton_dll,"NewtonUserJointSetRowAcceleration")
Global NewtonUserJointSetRowMaximumFriction(joint:Byte Ptr,friction:Float)=GetProcAddress(newton_dll,"NewtonUserJointSetRowMaximumFriction")
Global NewtonUserJointSetRowMinimumFriction(joint:Byte Ptr,friction:Float)=GetProcAddress(newton_dll,"NewtonUserJointSetRowMinimumFriction")
Global NewtonUserJointSetRowSpringDamperAcceleration(joint:Byte Ptr,springK:Float,springD:Float)=GetProcAddress(newton_dll,"NewtonUserJointSetRowSpringDamperAcceleration")
Global NewtonUserJointSetRowStiffness(joint:Byte Ptr,stiffness:Float)=GetProcAddress(newton_dll,"NewtonUserJointSetRowStiffness")
Global NewtonUserJointSetSolver(joint:Byte Ptr,solver:Int,maxContactJoints:Int)=GetProcAddress(newton_dll,"NewtonUserJointSetSolver")
Global NewtonUserMeshCollisionContinuousOverlapTest:Int(collideDescData:Byte Ptr,continueCollisionHandle:Byte Ptr,minAabb:Float Ptr,maxAabb:Float Ptr)=GetProcAddress(newton_dll,"NewtonUserMeshCollisionContinuousOverlapTest")
Global NewtonWaitForUpdateToFinish(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWaitForUpdateToFinish")
Global NewtonWorldAddPostListener:Byte Ptr(newtonWorld:Byte Ptr,nameId:Byte Ptr,listenerUserData:Byte Ptr,update(world:Byte Ptr,listenerUserData:Byte Ptr,timestep:Float),destroy(world:Byte Ptr,listenerUserData:Byte Ptr))=GetProcAddress(newton_dll,"NewtonWorldAddPostListener")
Global NewtonWorldAddPreListener:Byte Ptr(newtonWorld:Byte Ptr,nameId:Byte Ptr,listenerUserData:Byte Ptr,update(world:Byte Ptr,listenerUserData:Byte Ptr,timestep:Float),destroy(world:Byte Ptr,listenerUserData:Byte Ptr))=GetProcAddress(newton_dll,"NewtonWorldAddPreListener")
Global NewtonWorldCollide:Int(newtonWorld:Byte Ptr,matrix:Float Ptr,shape:Byte Ptr,userData:Byte Ptr,prefilter:UInt(body:Byte Ptr,collision:Byte Ptr,userData:Byte Ptr),info:Byte Ptr,maxContactsCount:Int,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonWorldCollide")
Global NewtonWorldConvexCast:Int(newtonWorld:Byte Ptr,matrix:Float Ptr,target:Float Ptr,shape:Byte Ptr,hitParam:Float Ptr,userData:Byte Ptr,prefilter:UInt(body:Byte Ptr,collision:Byte Ptr,userData:Byte Ptr),info:Byte Ptr,maxContactsCount:Int,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonWorldConvexCast")
Global NewtonWorldConvexRayCast(newtonWorld:Byte Ptr,shape:Byte Ptr,matrix:Float Ptr,p1:Float Ptr,filter:Float(body:Byte Ptr,shapeHit:Byte Ptr,hitContact:Float Ptr,hitNormal:Float Ptr,collisionID:Long,userData:Byte Ptr,intersectParam:Float),userData:Byte Ptr,prefilter:UInt(body:Byte Ptr,collision:Byte Ptr,userData:Byte Ptr),threadIndex:Int)=GetProcAddress(newton_dll,"NewtonWorldConvexRayCast")
Global NewtonWorldCriticalSectionLock(newtonWorld:Byte Ptr,threadIndex:Int)=GetProcAddress(newton_dll,"NewtonWorldCriticalSectionLock")
Global NewtonWorldCriticalSectionUnlock(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldCriticalSectionUnlock")
Global NewtonWorldFloatSize:Int()=GetProcAddress(newton_dll,"NewtonWorldFloatSize")
Global NewtonWorldForEachBodyInAABBDo(newtonWorld:Byte Ptr,p0:Float Ptr,p1:Float Ptr,callback:Int(body:Byte Ptr,userData:Byte Ptr),userData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldForEachBodyInAABBDo")
Global NewtonWorldForEachJointDo(newtonWorld:Byte Ptr,callback(joint:Byte Ptr,userData:Byte Ptr),userData:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldForEachJointDo")
Global NewtonWorldGetBodyCount:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetBodyCount")
Global NewtonWorldGetConstraintCount:Int(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetConstraintCount")
'Global NewtonWorldGetDestructorCallback(world:Byte Ptr)(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetDestructorCallback")
Global NewtonWorldGetFirstBody:Byte Ptr(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetFirstBody")
Global NewtonWorldGetFirstMaterial:Byte Ptr(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetFirstMaterial")
Global NewtonWorldGetListenerUserData:Object(newtonWorld:Byte Ptr,listener:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetListenerUserData")
Global NewtonWorldGetNextBody:Byte Ptr(newtonWorld:Byte Ptr,curBody:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetNextBody")
Global NewtonWorldGetNextMaterial:Byte Ptr(newtonWorld:Byte Ptr,material:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetNextMaterial")
Global NewtonWorldGetPostListener:Byte Ptr(newtonWorld:Byte Ptr,nameId:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetPostListener")
Global NewtonWorldGetPreListener:Byte Ptr(newtonWorld:Byte Ptr,nameId:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetPreListener")
Global NewtonWorldGetUserData:Object(newtonWorld:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldGetUserData")
Global NewtonWorldGetVersion:Int()=GetProcAddress(newton_dll,"NewtonWorldGetVersion")
'Global NewtonWorldListenerGetBodyDestroyCallback(world:Byte Ptr,listenerUserData:Byte Ptr,body:Byte Ptr)(newtonWorld:Byte Ptr,listener:Byte Ptr)=GetProcAddress(newton_dll,"NewtonWorldListenerGetBodyDestroyCallback")
Global NewtonWorldListenerSetBodyDestroyCallback(newtonWorld:Byte Ptr,listener:Byte Ptr,bodyDestroyCallback(world:Byte Ptr,listenerUserData:Byte Ptr,body:Byte Ptr))=GetProcAddress(newton_dll,"NewtonWorldListenerSetBodyDestroyCallback")
Global NewtonWorldRayCast(newtonWorld:Byte Ptr,p0:Float Ptr,p1:Float Ptr,filter:Float(body:Byte Ptr,shapeHit:Byte Ptr,hitContact:Float Ptr,hitNormal:Float Ptr,collisionID:Long,userData:Byte Ptr,intersectParam:Float),userData:Byte Ptr,prefilter:UInt(body:Byte Ptr,collision:Byte Ptr,userData:Byte Ptr),threadIndex:Int)=GetProcAddress(newton_dll,"NewtonWorldRayCast")
Global NewtonWorldSetCollisionConstructorDestructorCallback(newtonWorld:Byte Ptr,constructor(newtonWorld:Byte Ptr,collision:Byte Ptr,sourceCollision:Byte Ptr),destructor(newtonWorld:Byte Ptr,collision:Byte Ptr))=GetProcAddress(newton_dll,"NewtonWorldSetCollisionConstructorDestructorCallback")
Global NewtonWorldSetDestructorCallback(newtonWorld:Byte Ptr,destructor(world:Byte Ptr))=GetProcAddress(newton_dll,"NewtonWorldSetDestructorCallback")
Global NewtonWorldSetUserData(newtonWorld:Byte Ptr,userData:Object)=GetProcAddress(newton_dll,"NewtonWorldSetUserData")
Global NewtonYield()=GetProcAddress(newton_dll,"NewtonYield")
?
</textarea> <br><br></td></tr></table><br>
<a name="1314648"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry, col, meant to comment on your comment re. Speccy/Linux last night! Glad/impressed to hear it worked!<br><br>Nice work on the Newton commands, but I think it effectively puts us where my ODE efforts got us, ie. no doubt able to call the commands, but not actually able to do much with the library due to lack of interfacing with the C/C++ structs. I could be wrong, though, will have a look!<br><br>(Of course, source-level, Brucey-style would be better, anyway, so we're not limited to Windows/DLL usage of the library.) <br><br></td></tr></table><br>
<a name="1314651"></a>

<a name="1314652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> ....like the structs/types for eg <br></div><br>Yeah, I tend to hide all the raw calls and pointers behind BlitzMax, because we aren't all so hardcore as col ;-)<br><br><div class="quote"> if you could find it in your noble heart to publish some sort of release <br></div><br><br>I'll see if I can get something done this week.<br>It's building from source, rather than using a dll, so I'll need to check it compiles across platforms... <br><br></td></tr></table><br>
<a name="1314660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome, thanks Brucey! Going to have a play and see if I can make col's version do anything, but cross-platform sourceyness would be ideal. I'm sure someone will be able to figure out making it work with Blitz3D-style position/rotation if I fail (OK, "when" I fail). <br><br></td></tr></table><br>
<a name="1314664"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking through the api source and a couple of tutorials it's slowly coming back to me :P<br>Newton works via callbacks to set your 3D entity position and when you want to apply forces and stuff.<br><br>A general overview of events...<br><br>1. Use NewtonCreate to get a 'world' instance into which all of your physics bodies will go.<br>2. Each 3D entity will need a newton collider to represent its collision shape. For a 3D sphere you would NewtonCreateSphere, for a 3D box you would NewtonCreateBox. There are a few different ones that should cover all needed collider shapes.<br>3. For each collider you need a dynamic body. This is where you may be tripped up as the NewtonCreateBody wants a 4x4 matrix to represent the 3D object initial rotation and position. If OpenB3D can't give you that then I suppose you could create one yourself.<br>4. You then NewtonBodySetMassMatrix for each newton body.<br>5. Then setup some callbacks. For each Newton body ( which also means each 3D entity ) use NewtonBodySetForceAndTorqueCallback with a function that will get called when Newton is ready to apply forces and torque. You would need to store the forces in blitzmax side variables so that when the callback gets called from Newton you can then give the variable datas to Newton in this callback function. Also setup a NewtonSetTransformCallback for when Newton wants to tell you of the new rotation/position of the newton body.<br><br>The NewtonSetTransformCallback will give you a 4x4 matrix that you would use to position and rotate your 3D entity. So if OpenB3D doesn't give you the option of setting your 3D entity rotation and position via a combined 4x4 transformation matrix then I guess you need to extract the rx,ry,rz and tx,ty,tz parts from the matrix and set the 3D entity manually using OpenB3D EntityRotation and EntityPosition ( or equivalent ) commands.<br><br>Of course you'd probably want to wrap up the Newton body stuff and use NewtonBodySetUserData to set say a 'TNewtonBody instance' to be associated with the actual 'newton body instance', then in the callbacks you can NewtonBodyGetUserData with the 'newton body instance' to get the 'TNewtonBody instance'.<br><br>Each frame you do a NewtonUpdate. It's advisable to use a FIXED timestep here as opposed to a fluctuating one to keep everything in check. Newton will call the 'apply forces' callback for each 'newton body instance'. After all calculations are done in Newton it will then call the 'set transform' callbacks so that you can set the new rotation and position.<br><br>As far as the transformation matrix stuff goes if OpenB3D doesn't let you set the rotation and position in 1 hit via a 4x4 matrix then it may be beneficial to dive into the source and write a couple of functions to allow you to do it - you know... just to make things easy(er) ;-)<br><br>Hope it helps. <br><br></td></tr></table><br>
<a name="1314690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good write up! Sounds awfully complicated compared to ODE, but I just had a look inside OpenB3D, and the TEntity type does indeed contain a user-accessible matrix:<br><br><pre class=code>
Type TEntity
	
	Global entity_list:TList=CreateList() ' Entity list
	Field child_list:TList=CreateList() ' Entity list
	Field parent:TEntity ' returned by GetParent - NULL
	
	' transform
	Field mat:TMatrix ' returned by EntityX/Y/Z (global) - LoadIdentity
	Field rotmat:TMatrix ' openb3d: used in EntityPitch/Yaw/Roll (global) - LoadIdentity

	...

</pre><br><br>... and TMatrix contains a pointer to a 4 x 4 matrix and plenty of conversion methods (which may or may not address your last point re. applying a matrix directly):<br><br><pre class=code>
Type TMatrix

	Field grid:Float Ptr ' array [4,4] - LoadIdentity

	...
</pre><br><br>... not that I really know much about matrix operations, but at least it should be possible to make them talk to each other without too much customisation. <br><br></td></tr></table><br>
<a name="1314700"></a>

<a name="1314702"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Literally didn't know this existed until now!<br><br><a href="/posts.php?topic=99274" target="_blank">Blitz3D Newton wrapper and source</a><br><br>I assume it's for 1.x, but should still give plenty of insight in to how to make them talk to each other.<br><br>Weirdly, all of the links still work!<br><br>Reasonably hopeful that Brucey's wrapper + *B3D will work with a bit of hacking and swearing. <br><br></td></tr></table><br>
<a name="1314703"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I had a look at that before I started work on wrapping it myself.<br><br><a href="https://github.com/bmx-ng/newton.mod" target="_blank">https://github.com/bmx-ng/newton.mod</a><br><br>There are currently two examples, which cover the newton starter tutorials. <br><br></td></tr></table><br>
<a name="1314709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, thanks, Brucey. I've literally spent 2-3 hours playing about with the various Blitz3D physics wrappers -- newton and bullet, plus other bits and pieces -- all a lot of fun, so will go have a play with this right now. Really appreciate it! <br><br></td></tr></table><br>
<a name="1314715"></a>

<a name="1314716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm still padding out the API. Let me know what stuff you need next (that I've yet to implement) and I'll do that next.<br>Although the API is not too large, it's all wrapped up in BlitzMax types, which is intended to make using it easier. So it takes a bit more work than just generating a list of function pointers :-p<br><br>If you didn't need legacy BlitzMax support, I'd probably change the TNMatrix to a Struct and leave it out of the GC... <br><br></td></tr></table><br>
<a name="1314718"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't need legacy support, personally -- my BlitzMax experience is now totally NG.<br><br><div class="quote"> <br>Although the API is not too large, it's all wrapped up in BlitzMax types, which is intended to make using it easier. So it takes a bit more work than just generating a list of function pointers :-p<br> <br></div><br>Definitely noticing that after my attempt, but nice to know!<br><br>First thing I need to try is to get something visual to work. The two examples certainly work fine here, and I reckon I've a fair bit to work with now to point me in the right direction... which doesn't necessarily mean success! <br><br></td></tr></table><br>
<a name="1314719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's probably easy enough to plug into OpenB3D if you know what you are doing.. unfortunately, I don't...<br><br>If someone ever builds a small example, I can include that in the distro... or we could end up with, say, a newton-openb3d module, which takes on the nitty gritty work itself... and you just use it with your 3D stuff. <br><br></td></tr></table><br>
<a name="1314721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> I may have drunk too much alcohol (I'm on holi-holi-day!), but will have a pop tonight/tomorrow. Can't be *that* hard to align a B3D entity to a Newton body, especially with all those 3rd-party examples out there! (He said.) <br><br></td></tr></table><br>
<a name="1314729"></a>

<a name="1314747"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Much of a hangover? :D<br><br>Cool stuff :-)<br><br>In theory then you should be able to set the OpenB3D matrix from the one returned by newton and that's it. If it doesn't work first time then you may be that you need to transpose it - it could be column-major or row-major, that just depends on the Newton implementation vs the OpenB3D implementation of matrices. <br><br></td></tr></table><br>
<a name="1314761"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I'm kind of hoping it will be that simple (should find out in a bit) and not too bad, hangover-wise, ahem... :P <br><br></td></tr></table><br>
<a name="1314765"></a>

<a name="1314781"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> @James<br>A big fry-up normally fixes me up if I feel a little rough :p<br><br>@Brucey...<br>Newton uses multiple threads which don't play well with the GC. Adding in<br><pre class=code>ModuleInfo "CC_OPTS: -DDG_USE_THREAD_EMULATION"</pre><br>to newton.mod/dynamics.bmx should fix that problem.<br><br>@all<br>Here's a simple thrown together example for you to show one way to do it.<br>With some textures, colour, a timer, make a variety of 'game boards' some rocking music... *ahem* yeah... then it could well pass up for the basis for a game ;-)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Import openb3d.b3dglgraphics
Import newton.dynamics

Graphics3D 800,600,0,2

Local world:TNWorld = TNWorld.Create()

Local cam:TCamera = CreateCamera()
MoveEntity cam, 0, 10, -20

Local box:TGameBox = New TGameBox( world )
CreateShadow( box._entity )

Local ball:TGameBall = New TGameBall( world )
CreateShadow( ball._Entity )

Local light:TLight = CreateLight()
MoveEntity light,0,50,-5
PointEntity light,box._entity

' some kind of ground - maybe add a collider and game over when the ball hits it.
Local ground:TMesh = CreateCube()
ScaleMesh ground, 25, 1, 25
PositionEntity ground, 0, -8, 0

' point camera to the centre of the box
PointEntity cam, box._Entity

 ' just in case
world.InvalidateCache()

While Not KeyDown( KEY_ESCAPE )
	Cls
	
	If KeyDown( KEY_UP ) box.pushbackdown()
	If KeyDown( KEY_DOWN ) box.pushfrontdown()
	If KeyDown( KEY_LEFT) box.pushleftdown()
	If KeyDown( KEY_RIGHT ) box.pushrightdown()
	
	' mimic b3d updateworld
	world.Update(1.0/60.0)
	RenderWorld
	Flip
Wend


Type TGameBall Extends TNBody
	Field _Entity:TMesh
	
	Method New()
		RuntimeError "calling incorrect constructor!"
	EndMethod

	Method New( world:TNWorld )
		' create our 3d object
		_Entity = CreateSphere()
		MoveEntity _Entity, 0, 4, 0
		
		' newton collider
		Local sphere:TNCollision = world.CreateSphere( 1, 0, Null )

		' copy entity matrix to newton matrix
		Local matrix:TNMatrix = New TNMatrix
		MemCopy( Varptr matrix.frontX, _Entity.mat.grid, 64 )
		
		world.CreateDynamicBody( sphere, matrix, Self )
		SetMassProperties( 1.0, sphere )
		
		' no need for the collider any more
		sphere.Destroy()
	EndMethod
	
	' newton callbacks
	Method OnForceAndTorque(timestamp:Float, threadIndex:Int)
		' apply gravity
		Local mass:Float
	 	Local Ixx:Float
		Local Iyy:Float
		Local Izz:Float
	
		GetMassMatrix(mass, Ixx, Iyy, Izz)
		SetForce(0.0, -9.8 * mass, 0.0, 0.0)
	EndMethod

	Method OnTransform(matrix:Float Ptr, threadIndex:Int)
		' copy the matrix to the entity
		MemCopy(  _Entity.mat.grid, matrix, 64 )
	EndMethod
EndType

Type TGameBox Extends TNBody
	Field _Entity:TMesh
	Field _ForceX:Float
	Field _Forcez:Float
	
	Method New()
		RuntimeError "calling incorrect constructor!"
	EndMethod
	
	Method New( world:TNWorld)
		_Entity = CreateCube()

		' scale the mesh, not the entity!
		ScaleMesh _Entity, 10, 1, 10
		
		' start at an angle
		RotateEntity _Entity, Rand( -10, 10 ), 0, Rand( -10, 10 )

		' newton collider
		Local box:TNCollision = world.CreateBox( 20, 2, 20, 0, Null, Null )

		' copy entity matrix to newton matrix
		Local matrix:TNMatrix = New TNMatrix
		MemCopy( Varptr matrix.frontX, _Entity.mat.grid, 64 )
		
		world.CreateDynamicBody( box, matrix, Self )
		SetMassProperties( 1000, box )

		' no need for the collider any more
		box.Destroy()
	EndMethod

	Method PushBackDown()
		_ForceX :- 1
		_ForceX = Max( -10, _ForceX )
	EndMethod
	
	Method PushFrontDown()
		_ForceX :+ 1
		_ForceX = Min( 10, _ForceX )
	EndMethod
	
	Method PushLeftDown()
		_ForceZ :+ 1
		_ForceZ = Min( 10, _ForceZ )
	EndMethod
	
	Method PushRightDown()
		_ForceZ :- 1
		_ForceZ = Max( -10, _ForceZ )
	EndMethod

	' newton callbacks
	Method OnForceAndTorque(timestamp:Float, threadIndex:Int)
		Local mass:Float
	 	Local Ixx:Float, Iyy:Float, Izz:Float
		
		GetMassMatrix(mass, Ixx, Iyy, Izz)
		SetTorque( _ForceX * mass, 0.0, _ForceZ * mass , 1.0)
	EndMethod

	Method OnTransform(matrix:Float Ptr, threadIndex:Int)
		MemCopy(  _Entity.mat.grid, matrix, 64 )
	EndMethod
EndType
</textarea> <br><br></td></tr></table><br>
<a name="1314767"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Newton uses multiple threads which don't play well with the GC. <br></div><br>NG's GC?<br>I thought Boehm was pretty solid with threading? <br><br></td></tr></table><br>
<a name="1314769"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Dave,<br><br>question about your openb3d, are you using Munch's or Brucey's version? <br><br></td></tr></table><br>
<a name="1314770"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> NG's GC? <br></div><br>For sure, yes.<br>I get gc issues with 3rd party libraries that spawn their own threads which then callback into BMax code from those 'untracked' threads, it's the same for threaded and non-threaded builds. I think the GC error mentions that its being called from an unknown thread or something similar. I'v never really worried about it.<br><br>In the past I can still create a new Blitz thread in which I then use the single threaded 3rd party lib, so any app can still be multi-threaded. Other than that I've had to keep the 3rd party accessing code totally separate from 'Max code - NG or Legacy.<br><br>@RustiKristi<br>The same one that BlitzSupport posted for his <a href="/posts.php?topic=106601" target="_blank">speccy shader demo</a>. It has a copyright with Bruceys name in it so I'd assume it's Bruceys version ;-) <br><br></td></tr></table><br>
<a name="1314771"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right. I'm just confused with the openb3d. So far this is what I understand<br><br>OpenB3D (angros47) Main Project (ported on Blitzmax/PB,etc) see below<br>OpenB3D Wrapper (Munch) discontinued, latest. works great on vanilla<br>OpenB3D Wrapper Bah (Munch/Brucey) Less files, compatible with NG <br><br>In short, is munch the vanilla version and Brucey's on NG? <br><br></td></tr></table><br>
<a name="1314772"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> are you using Munch's or Brucey's version?  <br></div><br>I really need to update mine to get it more in-line with the work that's been done on the other one. <br><br></td></tr></table><br>
<a name="1314773"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Right. I'm just confused with the openb3d. <br></div><br>Yep, that's one of the joys of open source ;-) <br><br></td></tr></table><br>
<a name="1314774"></a>

<a name="1314775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I really need to update mine to get it more in-line with the work that's been done on the other one. <br> <br></div><br><br>Mind you though, the latest commit is an unfinished attempt for GLES, so find the working commit a few steps back.<br><br><div class="quote"> Yep, that's one of the joys of open source ;-)  <br></div><br><br>haha yes this happens a lot. :D <br><br></td></tr></table><br>
<a name="1314784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Weird, I didn't know Brucey had an OpenB3D version! Mine's the one from <a href="https://github.com/markcwm/openb3d.mod" target="_blank">here</a>, specifically the commit highlighted by RK a while ago: <a href="http://www.blitzbasic.com/Community/post.php?topic=106512&amp;post=1311173" target="_blank">http://www.blitzbasic.com/Community/post.php?topic=106512&amp;post=1311173</a><br><br>Great job there, col, looks like I was actually on the right track with MemCopying the matrix earlier (had to go out), so I'm impressed with myself too! Will dissect with interest, many thanks to all... <br><br></td></tr></table><br>
<a name="1314791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> -DDG_USE_THREAD_EMULATION <br></div><br>I'm thinking for NG, I can change Newton (dgThread.h/cpp) to register its thread with the GC. In theory that would solve the issue of "unknown threads"... <br><br></td></tr></table><br>
<a name="1314828"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> That sounds like a winning solution there Brucey, awesome!<br>One of the other joys of open source eh.<br><br><div class="quote"> so I'm impressed with myself too! <br></div><br>As was quoted in Kellys Heroes...<br>'have a little faith baby, have a little faith' ;-) <br><br></td></tr></table><br>
<a name="1314987"></a>

<a name="1314988"></a>

<a name="1314989"></a>

<a name="1314990"></a>

<a name="1314991"></a>

<a name="1314997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woo-hoo, this is awesome!<br><br>Heavily based on your example, col, though I've been fiddling about to make things more "me-friendly". This is a bit of a jumble for now, just experimenting...<br><br>Numbers of 500-1000 cubes are good for my system, gets a bit bogged down at 2000, but this might well be dependent on update rate as well. [* See EDITs below!]<br><br><b><br>Code below, runnable Win32 executables (32- and 64-bit) here:<br><br><a href="http://www.hi-toro.com/blitz/newtontest.zip" target="_blank">http://www.hi-toro.com/blitz/newtontest.zip</a><br></b><br><br>Thanks again, guys, great new toy! A lot to figure out, but this was encouraging...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Framework openb3d.b3dglgraphics
Import newton.dynamics

Const NUM_CUBES:Int = 100 ' Play with this! Starting number of cubes...

Graphics3D 1024, 768, 0, 60

Local update:Int = 30 ' 60 feels too slow, though is more accurate... 'GraphicsHertz () * 1.0 '0.5

SeedRnd MilliSecs ()

Local world:TNWorld = CreateNewtonWorld ()

Local cam:TCamera = CreateCamera ()

	CameraClsColor cam, 32, 64, 128
	MoveEntity cam, 0.0, 0.0, -10.0

AmbientLight 255.0, 255.0, 255.0

'Local ambient_overhead:TLight = CreateLight ()

Local crap_sun:TLight = CreateLight ()

	LightRange crap_sun, 2000.0
	MoveEntity crap_sun, -1000.0, 1000.0, -500.0

Local ground:TNewtonGround = New TNewtonGround (world, 100.0, 1.0, 100.0)

	EntityColor ground.mesh, 0, 64, 0

Local cubes:Int = NUM_CUBES

AddCubes world, cubes

'PointEntity ambient_overhead, ground.mesh
PointEntity crap_sun, ground.mesh

'ResetNewtonWorld world ' Don't think needed unless trying to repeat exact same outcome (?)

Repeat

	If KeyDown (KEY_LEFT) Then TurnEntity cam, 0.0, 1.0, 0.0, True
	If KeyDown (KEY_RIGHT) Then TurnEntity cam, 0.0, -1.0, 0.0, True
	
	If KeyDown (KEY_UP) Then TurnEntity cam, 1.0, 0.0, 0.0
	If KeyDown (KEY_DOWN) Then TurnEntity cam, -1.0, 0.0, 0.0

	If KeyDown (KEY_A) Then MoveEntity cam, 0.0, 0.0, 0.1
	If KeyDown (KEY_Z) Then MoveEntity cam, 0.0, 0.0, -0.1
	
	If KeyHit (KEY_SPACE)
		AddCubes world, 100
		cubes = cubes + 100
'		ResetNewtonWorld world
	EndIf
	
	UpdateNewtonWorld world, update
	
'	PointEntity cam, cube.mesh
	
	RenderWorld
	
	BeginMax2D
	
		ShadowText "Cursors + A/Z to move; SPACE to add 100 cubes...", 20.0, 20.0
		ShadowText "Cubes: " + cubes, 20.0, 40.0
		
	EndMax2D
	
	Flip
	
Until KeyHit (KEY_ESCAPE) Or AppTerminate ()

End

Function ShadowText:Int (msg:String, x:Float, y:Float)

	Local red:Int, green:Int, blue:Int
	
	GetColor red, green, blue
	
	SetColor 0, 0, 0
	DrawText msg, x + 1, y + 1

	SetColor 255, 255, 255
	DrawText msg, x, y

	SetColor red, green, blue

End Function

Function ResetNewtonWorld (world:TNWorld)
	world.InvalidateCache
End Function

Function UpdateNewtonWorld (world:TNWorld, update_rate:Float)
	world.Update 1.0/update_rate
End Function

Type NewtonBody Extends TNBody

	Field mesh:TMesh
	Field mass:Float
	
	Method OnTransform(matrix:Float Ptr, threadIndex:Int)
		AlignEntity mesh, matrix
	End Method

	Method OnForceAndTorque(timestamp:Float, threadIndex:Int)

		Local _mass:Float
	 	Local Ixx:Float, Iyy:Float, Izz:Float
		
		GetMassMatrix _mass, Ixx, Iyy, Izz
		
		' Gravity only...
		
		SetForce 0.0 * _mass, -0.987 * _mass, 0.0 * _mass, 1.0

	EndMethod

End Type

Function AddCubes (world:TNWorld, cubes:Int)

	For Local loop:Int = 1 To cubes
	
		If loop Mod 1000 = 0 Then Print loop ' Progress every 1000 for testing 10k+
		
		Local cubemesh:TMesh = CreateCube ()
		
			Local size:Float = Float (Rnd (0.1, 1.0))
			ScaleMesh cubemesh, size, size, size
		
			MoveEntity cubemesh, Float (Rnd (-25.0, 25.0)), Float (Rnd (50.0)), Float (Rnd (5, 25.0))
			TurnEntity cubemesh, Float (Rnd (-360.0, 360.0)), Float (Rnd (-360.0, 360.0)), Float (Rnd (-360.0, 360.0))
		
		Local cube:TNewtonCube = New TNewtonCube (world, cubemesh, size)
		
			EntityColor cube.mesh, Float (Rnd (255.0)), Float (Rnd (255.0)), Float (Rnd (255.0))
			CreateShadow cube.mesh
	
	Next

End Function

Type TNewtonGround Extends NewtonBody

	Method New ()
		RuntimeError ("No TNWorld passed to TNewtonCube.New!")
	End Method
	
	Method New (world:TNWorld, width:Float = 1.0, height:Float = 1.0, depth:Float = 1.0)
	
		mass = 0.0
		
		mesh = CreateCube ()

			ScaleMesh mesh, width * 0.5, height * 0.5, depth * 0.5
	
		MoveEntity mesh, 0.0, -10.0, 0.0
		
		Local collider:TNCollision
		Local matrix:TNMatrix
		
			collider	= world.CreateBox (width, height, depth, 0, Null, Null)
			matrix		= New TNMatrix
		
			AlignNewtonMatrix matrix, mesh
		
			world.CreateDynamicBody collider, matrix, Self
			SetMassProperties mass, collider
		
			collider.Destroy
		
	End Method

End Type

Type TNewtonCube Extends NewtonBody

	Method New ()
		RuntimeError ("No TNWorld passed to TNewtonCube.New!")
	End Method

	Method New (world:TNWorld, _mesh:TMesh, _mass:Float = 1.0)
	
		mesh = _mesh
		mass = _mass

		Local collider:TNCollision
		Local matrix:TNMatrix
		
			collider	= world.CreateBox (MeshWidth (mesh), MeshHeight (mesh), MeshDepth (mesh), 0, Null, Null)
			matrix		= New TNMatrix
		
			AlignNewtonMatrix matrix, mesh
		
			world.CreateDynamicBody collider, matrix, Self
			SetMassProperties mass, collider
		
			collider.Destroy
	
	End Method
	
	Method New (world:TNWorld, mass:Float = 1.0, width:Float = 1.0, height:Float = 1.0, depth:Float = 1.0)
	
		mesh = CreateCube ()

			ScaleMesh mesh, width * 0.5, height * 0.5, depth * 0.5
	
		Local collider:TNCollision
		Local matrix:TNMatrix
		
			collider	= world.CreateBox (MeshWidth (mesh), MeshHeight (mesh), MeshDepth (mesh), 0, Null, Null)
			matrix		= New TNMatrix
		
			AlignNewtonMatrix matrix, mesh
		
			world.CreateDynamicBody collider, matrix, Self
			SetMassProperties mass, collider
		
			collider.Destroy
		
	End Method

End Type

' Set autofail to False to manually handle Null return...

Function CreateNewtonWorld:TNWorld (autofail:Int = True)
	
	Local world:TNWorld = TNWorld.Create ()
	
	If autofail And world = Null
		RuntimeError "CreateNewtonWorld: Failed to create Newton world!"
		End
	EndIf
	
	Return world
	
End Function

' Fill in Newton TNMatrix from OpenB3D's TEntity.mat[:TMatrix].grid...

Function AlignNewtonMatrix:Int (matrix:TNMatrix, mesh:TMesh)
	MemCopy Byte Ptr (matrix), mesh.mat.grid, 64
End Function

' Fill in OpenB3D's TEntity.mat[:TMatrix].grid from Newton TNMatrix...

Function AlignEntity:Int (mesh:TMesh, matrix:Float Ptr)
	MemCopy mesh.mat.grid, matrix, 64
End Function

</textarea><br><br>If you set NUM_CUBES into the tens of thousands, it can take minutes to set up (exponentially slower as more cubes are added, guess as it cross-checks each body). I've had 20,000 going successfully -- not quickly -- and had a crash at 50,000, though I suspect that might have been OpenB3D, not sure, as it 'built' all 50,000 cubes before crashing.<br><br>EDIT: Just realised having thousands of shadows on the go probably doesn't help the frame-rate! Comment-out <b>CreateShadow cube.mesh</b> in the AddCubes function to test without.<br><br>EDIT 2: Yeah, CreateShadow was definitely slowing down the creation process, and I currently have 50,000 cubes on the go with shadows disabled! Runs in seconds-per-frame at first, then picks up to 'a few frames per second'... and uses 1.7 GB of RAM! <br><br></td></tr></table><br>
<a name="1314993"></a>

<a name="1314998"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Further to EDITs 1 and 2: Tested with 100,000 cubes, 5.4 GB of RAM! Technically, it runs. Impressive test of both Newton and OpenB3D, if you ask me. <br><br></td></tr></table><br>
<a name="1314995"></a>

<a name="1314996"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dynamically add/remove cubes... seems to work, and learned to invalidate world after removing objects! (See comment inside <i>If KeyHit (KEY_MINUS)</i> check.)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Framework openb3d.b3dglgraphics
Import newton.dynamics

Graphics3D 1024, 768, 0, 60

Local update:Int = 30 ' 60 feels too slow, though is more accurate... 'GraphicsHertz () * 1.0 '0.5

SeedRnd MilliSecs ()

Local world:TNWorld = CreateNewtonWorld ()

Local cam:TCamera = CreateCamera ()

	CameraClsColor cam, 32, 64, 128
	MoveEntity cam, 0.0, 0.0, -25.0

AmbientLight 255.0, 255.0, 255.0

'Local ambient_overhead:TLight = CreateLight ()

Local crap_sun:TLight = CreateLight ()

	LightRange crap_sun, 2000.0
	MoveEntity crap_sun, -1000.0, 1000.0, -500.0

Local ground:TNewtonGround = New TNewtonGround (world, 100.0, 1.0, 100.0)

	EntityColor ground.mesh, 0, 64, 0

Local cubes:TList = CreateList ()

For Local loop:Int = 1 To 100
	ListAddLast cubes, AddCube (world)
Next

'PointEntity ambient_overhead, ground.mesh
PointEntity crap_sun, ground.mesh

ResetNewtonWorld world

Repeat

	If KeyDown (KEY_LEFT) Then TurnEntity cam, 0.0, 1.0, 0.0, True
	If KeyDown (KEY_RIGHT) Then TurnEntity cam, 0.0, -1.0, 0.0, True
	
	If KeyDown (KEY_UP) Then TurnEntity cam, 1.0, 0.0, 0.0
	If KeyDown (KEY_DOWN) Then TurnEntity cam, -1.0, 0.0, 0.0

	If KeyDown (KEY_A) Then MoveEntity cam, 0.0, 0.0, 0.1 + KeyDown (KEY_LSHIFT) * 0.5
	If KeyDown (KEY_Z) Then MoveEntity cam, 0.0, 0.0, -(0.1 + KeyDown (KEY_LSHIFT) * 0.5)
	
	If KeyHit (KEY_EQUALS) Or KeyHit (KEY_NUMADD)
		For Local loop:Int = 1 To 100
			ListAddLast cubes, AddCube (world)
		Next
		ResetNewtonWorld world
	EndIf

	If KeyHit (KEY_MINUS) Or KeyHit (KEY_NUMSUBTRACT)

		If CountList (cubes)

			Local count:Int = 0

			For Local cube:TNewtonCube = EachIn cubes
			
				If count &lt; 100
					
					cube.Remove
					
					ListRemove cubes, cube
					
					count = count + 1
					
				Else
					
					' IMPORTANT: Without this, cubes sitting at rest
					' on top of others won't fall if the cube/s below
					' are removed!
					
					ResetNewtonWorld world
					
					Exit
					
				EndIf
				
			Next

		EndIf

	EndIf
	
	UpdateNewtonWorld world, update
	
'	PointEntity cam, cube.mesh
	
	RenderWorld
	
	BeginMax2D
	
		ShadowText "Cursors to rotate", 20.0, 20.0
		ShadowText "A/Z to move; SHIFT to move faster", 20.0, 40.0
		ShadowText "+/- to add/remove 100 cubes", 20.0, 60.0
		ShadowText "Cubes: " + CountList (cubes), 20.0, 100.0
		
	EndMax2D
	
	Flip
	
Until KeyHit (KEY_ESCAPE) Or AppTerminate ()

End

Function AddCube:TNewtonCube (world:TNWorld)

	Local cubemesh:TMesh = CreateCube ()
	
		Local size:Float = Float (Rnd (0.1, 1.0))
		ScaleMesh cubemesh, size, size, size
	
		MoveEntity cubemesh, Float (Rnd (-25.0, 25.0)), Float (Rnd (50.0)), Float (Rnd (-25, 25.0))
		TurnEntity cubemesh, Float (Rnd (-360.0, 360.0)), Float (Rnd (-360.0, 360.0)), Float (Rnd (-360.0, 360.0))
	
	Local cube:TNewtonCube = New TNewtonCube (world, cubemesh, size)
	
		EntityColor cube.mesh, Float (Rnd (255.0)), Float (Rnd (255.0)), Float (Rnd (255.0))
		cube.shadow = CreateShadow (cube.mesh)

	Return cube
	
End Function

Function ShadowText:Int (msg:String, x:Float, y:Float)

	Local red:Int, green:Int, blue:Int
	
	GetColor red, green, blue
	
	SetColor 0, 0, 0
	DrawText msg, x + 1, y + 1

	SetColor 255, 255, 255
	DrawText msg, x, y

	SetColor red, green, blue

End Function

Function ResetNewtonWorld (world:TNWorld)
	world.InvalidateCache
End Function

Function UpdateNewtonWorld (world:TNWorld, update_rate:Float)
	world.Update 1.0/update_rate
End Function

Type NewtonBody Extends TNBody

	Field mesh:TMesh
	Field mass:Float
	Field shadow:TShadowObject
	
	Method OnTransform(matrix:Float Ptr, threadIndex:Int)
		AlignEntity mesh, matrix
	End Method

	Method OnForceAndTorque(timestamp:Float, threadIndex:Int)

		Local _mass:Float
	 	Local Ixx:Float, Iyy:Float, Izz:Float
		
		GetMassMatrix _mass, Ixx, Iyy, Izz
		
		' Gravity only...
		
		SetForce 0.0 * _mass, -0.987 * _mass, 0.0 * _mass, 1.0

	EndMethod

	Method Remove ()
		
		If shadow	Then FreeShadow shadow
		If mesh		Then FreeEntity mesh
		
		Self.Destroy
		
	End Method
	
End Type

Type TNewtonGround Extends NewtonBody

	Method New ()
		RuntimeError ("No TNWorld passed to TNewtonCube.New!")
	End Method
	
	Method New (world:TNWorld, width:Float = 1.0, height:Float = 1.0, depth:Float = 1.0)
	
		mass = 0.0
		
		mesh = CreateCube ()

			ScaleMesh mesh, width * 0.5, height * 0.5, depth * 0.5
	
		MoveEntity mesh, 0.0, -10.0, 0.0
		
		Local collider:TNCollision
		Local matrix:TNMatrix
		
			collider	= world.CreateBox (width, height, depth, 0, Null, Null)
			matrix		= New TNMatrix
		
			AlignNewtonMatrix matrix, mesh
		
			world.CreateDynamicBody collider, matrix, Self
			SetMassProperties mass, collider
		
			collider.Destroy
		
	End Method

End Type

Type TNewtonCube Extends NewtonBody

	Method New ()
		RuntimeError ("No TNWorld passed to TNewtonCube.New!")
	End Method

	Method New (world:TNWorld, _mesh:TMesh, _mass:Float = 1.0)
	
		mesh = _mesh
		mass = _mass

		Local collider:TNCollision
		Local matrix:TNMatrix
		
			collider	= world.CreateBox (MeshWidth (mesh), MeshHeight (mesh), MeshDepth (mesh), 0, Null, Null)
			matrix		= New TNMatrix
		
			AlignNewtonMatrix matrix, mesh
		
			world.CreateDynamicBody collider, matrix, Self
			SetMassProperties mass, collider
		
			collider.Destroy
	
	End Method
	
	Method New (world:TNWorld, mass:Float = 1.0, width:Float = 1.0, height:Float = 1.0, depth:Float = 1.0)
	
		mesh = CreateCube ()

			ScaleMesh mesh, width * 0.5, height * 0.5, depth * 0.5
	
		Local collider:TNCollision
		Local matrix:TNMatrix
		
			collider	= world.CreateBox (MeshWidth (mesh), MeshHeight (mesh), MeshDepth (mesh), 0, Null, Null)
			matrix		= New TNMatrix
		
			AlignNewtonMatrix matrix, mesh
		
			world.CreateDynamicBody collider, matrix, Self
			SetMassProperties mass, collider
		
			collider.Destroy
		
	End Method

End Type

' Set autofail to False to manually handle Null return...

Function CreateNewtonWorld:TNWorld (autofail:Int = True)
	
	Local world:TNWorld = TNWorld.Create ()
	
	If autofail And world = Null
		RuntimeError "CreateNewtonWorld: Failed to create Newton world!"
		End
	EndIf
	
	Return world
	
End Function

' Fill in Newton TNMatrix from OpenB3D's TEntity.mat[:TMatrix].grid...

Function AlignNewtonMatrix:Int (matrix:TNMatrix, mesh:TMesh)
	MemCopy Byte Ptr (matrix), mesh.mat.grid, 64
End Function

' Fill in OpenB3D's TEntity.mat[:TMatrix].grid from Newton TNMatrix...

Function AlignEntity:Int (mesh:TMesh, matrix:Float Ptr)
	MemCopy mesh.mat.grid, matrix, 64
End Function
</textarea><br><br><a href="http://www.hi-toro.com/blitz/addremove.zip" target="_blank">Win32 32- and 64-bit executables.</a> <br><br></td></tr></table><br>
<a name="1315026"></a>

<a name="1315027"></a>

<a name="1315028"></a>

<a name="1315029"></a>

<a name="1315030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's my current state of play:<br><br><a href="http://www.hi-toro.com/blitz/newtonb3d.zip" target="_blank">http://www.hi-toro.com/blitz/newtonb3d.zip</a><br><br>Ignore '*.mod' folders, not currently a module (aborted for now as PITA) -- just drill down into the /examples folder, run example.bmx source or 32/64-bit executables!<br><br>Usage: Hit the [<b>+</b>] and [<b>-</b>] keys a few times to get started, then read the on-screen text! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
