<!DOCTYPE html><html lang="en" ><head ><title >Mesh LoadTerrain</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='Creates a mesh from a heightmap image you choose. Doesn't use blitz terrains., language=bb, category=3D Graphics - Mesh'><meta name='author' content='Ross C'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=12>3D Graphics - Mesh</a>/Mesh LoadTerrain</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="1609.bb">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mesh LoadTerrain by Ross C</td><td align="right">2006 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> This function is exactly like the LoadTerrain command in blitz, except it uses a blitz mesh instead of a blitz terrain. There's no LOD, but it should be alot faster in many circumstances. Same syntax as the Blitz function. Also centres the mesh, unlike the original function.<br><br>EDIT&lt;&lt;&lt; I have redone this routine, as it had many errors and inaccurate workings:<br><br>- It will now properly apply the heightmap without a strange seem appearing.<br>- I have added the functionality to adjust the Y scale.<br>- You can load three textures, and state flags, and they will be applied.<br>- The UV mapping has been fixed now.<br>- The function returns the mesh back, which i don't think it did before?<br><br><pre class=code>
Global terrain = load_terrain("heightmap.bmp",0.5); load the terrain half scale (since Red pixel colours highest value is 255, the highest value will now be 128.)
</pre><br><br>To load a texture and apply it to the terrain.<br><br><pre class=code>
Global terrain = load_terrain("heightmap.bmp",0.5,"terrain_texture.bmp",1+16+32); load the terrain, and apply a texture, with the clamping flags and colour flag. Note, you must clamp the texture if it encompasses the whole mesh, or it's edges will bleed to the other side.
</pre> </td></tr><tr ><td class="cell"><pre class="code">; Y position is calculated by: scale * pixel colour on loaded image.

; PLEASE NOTE: You must clamp the texture your applying if it is spread across the whole mesh.
;              If you don't, it will bleed across to the opposite side. Clamp with flags 16 + 32
Function load_terrain(heightmap$,y_scale#=1,texture1$="",t_flag1 = 1,texture2$="",t_flag2 = 1,texture3$="",t_flag3 = 1)


	temp = LoadImage(heightmap$)
	If temp = 0 Then Return 0
	
	x = ImageWidth(temp)
	DebugLog(" image width = "+x)
	y = ImageHeight(temp)

	mesh = CreateMesh()
	surf = CreateSurface(mesh)

	For ly = 0 To y-1 ; your doing -1 because the image pixels start at 1 and the vertex
					  ; indices start at 0
		For lx = 0 To x-1
			AddVertex surf,lx , 0, -ly, Float(lx)/(x-1), Float(ly)/(y-1)
		Next
	Next
	RenderWorld
	
	AddTriangle surf, 0, 65,64
	AddTriangle surf, 0, 1 ,65
	For ly = 0 To y-2
		For lx = 0 To x-2 ; leave the vertex counting an extra unit short, as the code below reaches
						  ; reaches one unit ahead to create the triangles

			; below is to simply explain the creation process and order of the triangles.
			; Triangles must be created in clockwise order, facing the camera, to be seen.
			current_y = ly*y
			next_y = (ly+1)*y
			current_x = lx
			next_x = lx+1
			;create the quad
			AddTriangle surf, current_y+current_x, next_y+next_x    , next_y + current_x
			AddTriangle surf, current_y+current_x, current_y+next_x , next_y + next_x
		Next
	Next


	PositionMesh mesh, -x/2.0,0,y/2.0 ; centre the mesh on the world axis.

	SetBuffer ImageBuffer(temp)
	For ly = 0 To y-1
		For lx = 0 To x-1
			GetColor lx,ly
			index = (ly*y) + lx
			VertexCoords surf, index , VertexX(surf,index), ColorRed()*y_scale, VertexZ(surf,index)
		Next
	Next
	SetBuffer BackBuffer()
	
	UpdateNormals mesh
	
	If texture1 &lt;&gt; "" Then
		t1 = LoadTexture(texture1,t_flag1)
		If t1 = 0 Then RuntimeError(" Error in load_terrain() function: Texture1 not found from filename given")
		EntityTexture mesh,t1,0,0
	End If
	If texture2 &lt;&gt; "" Then
		t2 = LoadTexture(texture2,t_flag2)
		If t2 = 0 Then RuntimeError(" Error in load_terrain() function: Texture2 not found from filename given")
		EntityTexture mesh,t2,0,1
	End If
	If texture3 &lt;&gt; "" Then
		t3 = LoadTexture(texture3,t_flag3)
		If t3 = 0 Then RuntimeError(" Error in load_terrain() function: Texture3 not found from filename given")
		EntityTexture mesh,t3,0,2
	End If
		
	
	Return mesh
	
End Function</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hambone</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Very nice.  Very clear.  When I have a little time I may extend this further to something like this:<br><br>Global terrain = load_terrain("heightmap.bmp, texture.bmp,lightmap.bmp") <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ShadowTurtle</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> You mean:<br><br>Global terrain = load_terrain("heightmap.bmp", "texture.bmp", "lightmap.bmp")<br><br>Function load_terrain(file$, texfile$ = "", lightfile$ = "")<br>  ...<br>End Function <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hambone</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Yeah,<br><br>Exactly like that.  Your English is fine.  Far better than the gibberish that I type most of the time :)<br><br>Thanks,<br><br>Allan <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Well, the texture co-ords are set, so, it should be a doodle to set up :o) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Got it working but the texture coords are out of whack. =( <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> It also loads the height map inverted...<br><br>EDIT: Change this line and it will load the height map correctly.<br><br><pre class=code>
GetColor lx,y-ly
</pre><br><br>Also add this to the end of the function:<br><pre class=code>
Return mesh
</pre> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Altered it to:<br><pre class=code>
LoadTerrain3( "hmap.bmp","tmap.bmp","lmap.bmp")
</pre><br><br>Now the heightmap is loaded correctly and also the texture coordinates are set.  The function automatically scales the texture to fit the terrain.  Next on my list for this function is to have it break the terrain up into manageable segments that can be used with PVS and also define the detail level of the terrains so you can cap each segment at say, 500.<br><br><pre class=code>
Function LoadTerrain3(hmap$,tmap$=0,lmap$=0)

	; load the heightmap
	temp = LoadImage(hmap$)
	If temp = 0 Then RuntimeError "Heightmap image "+hmap$+" does not exist." : Return 0
	
	; store heightmap dimensions
	x = ImageWidth(temp)
	y = ImageHeight(temp)

	; load texture and lightmaps
	tmap = LoadTexture(tmap$)
	lmap = LoadTexture(lmap$)
	
	; auto scale the textures to the right size
	If tmap ScaleTexture tmap,x,y
	If lmap	ScaleTexture lmap,x,y

	; start building the terrain
	mesh = CreateMesh()
	surf = CreateSurface(mesh)

	; create some verts for the terrain
	For ly = 0 To y
		For lx = 0 To x
			AddVertex surf,lx,0,ly,1.0/lx,1.0/ly
		Next
	Next
	RenderWorld
	
	; connect the verts with faces
	For ly = 0 To y-1
		For lx = 0 To x-1
			AddTriangle surf,lx+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)
			AddTriangle surf,(lx+1)+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)+(x+1)
		Next
	Next
	
	; position the terrain to center 0,0,0
	PositionMesh mesh, -x/2.0,0,-y/2.0

	; alter vertice height to match the heightmap red channel
	SetBuffer ImageBuffer(temp)
	For lx = 0 To x
		For ly = 0 To y
			GetColor lx,y-ly
			index = lx + ((x+1)*ly)
			VertexCoords surf, index , VertexX(surf,index), ColorRed()/20.0,VertexZ(surf,index)
			; set the terrain texture coordinates
			VertexTexCoords surf,index,lx,-ly 
		Next
	Next
	SetBuffer BackBuffer()
	
	; update the terrain normals so lighting will look correct
	UpdateNormals mesh
	
	; apply texture map to index 0
	If tmap EntityTexture mesh,tmap,0,0
		
	; apply lightmap to index 1 with flag 2
	If lmap EntityTexture mesh,lmap,0,1 : TextureBlend lmap,2
	
	Return Mesh
End Function
</pre> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Hmm...new bug.<br><br>The far right and bottom vertices aren't effected by the hmap.  They stay at 0,0,0 even if the right wall is painted pure white... <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ckob</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> not sure why but when I try this it crashes on renderworld. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> Your heightmap is probably too big .. creating too many poly's or verts per surface.  I think the limit is 64k verts and 32k polys - higher on some cards.<br><br>Stevie <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ckob</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> 256 X 256  ? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ShadowTurtle</td><td align="right"><font class=tiny>2006</font></td></tr></table></td></tr><tr ><td class="posttext"> from Chroma:<br>&gt;&gt; The far right and bottom vertices aren't effected by<br>&gt;&gt; the hmap. They stay at 0,0,0 even if the right wall<br>&gt;&gt; is painted pure white...<br><br>from ckob:<br>&gt;&gt; not sure why but when I try this it crashes on<br>&gt;&gt; renderworld. <br><br>In an other situation i am haved the same problem. Any vertice from triangle does not exists. Blitz debugger does it nothin register and so it make bugs.<br><br>You must integrate border-checking. As sample this would be set on a vertice in mesh:<br><pre class=code>; from: AddTriangle surf,lx+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)

vertice = lx+((x+1)*ly)
</pre><br><br>So you must test:<br><pre class=code>
If lx+((x+1)*ly) &gt; CountVertices(surf) then ... End If
</pre><br><br>... ... or similarly.<br><br>On many refers of vertices this would be a long work for(to? sry, my english is bad) testing. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >thelizardking</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> 128x128, actually... <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >thelizardking</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> 128x128, actually...but the function works AWSOME! thnxs ta big10p 4 finding it 4 me...lol thats how lazy i am<br><br>p.s. just add ResizeImage temp,128,128 after If temp = 0 Then RuntimeError "Heightmap image "+hmap$+" does not exist." : Return 0 <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> The functions works very good. I wrote a complete tech demo which tiles a given heightmap/colormap into smaller pieces and displays it nearly seamless (there is still a bug with the UV coordinates I couldn't locate).<br><br>Screenshot<br><img src="http://www.christianhart.de/bb/monkeyisland.jpg"><br><br><a href="http://www.christianhart.de/bb/monkeyisland1.zip" target="_blank">Download with Source and Images</a><br><br>Source:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">; Meshterrain Demo, Version 1.001 by Krischan (webmaster@...)
;
; Make sure there are three images in the current folder:
;
; - a Heightmap (standard: 256x256 PNG)
; - a Colormap (standard: 2048x2048 JPG)
; - a detail Texture (standard: 512x512 PNG)
;
; This script will cut the images and display the heightmap/colormap as a tiled Mesh Terrain
;
; Textures and Heightmap generated with Large 3D Terrain SE 2.5 (http://www.bundysoft.com/L3DT)
; Based on a script from Ross C and this thread:
;
; <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1609" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1609</a>

; Settings
Global speed#	=	0.1			; Walk speed
Global scale#	=	100.00		; map scale
Global tiles	=	16			; how many tiles in X -AND- Y direction? must be power of 2
Global mapsize	=	256			; overview map size
Global range#	=	100			; initial view range (100 = 100% map size)
Global showmap	=	1			; show map
Global fog		=	1			; use fog or not
Global gravity	=	1			; use gravity or not
Global wired	=	0			; show wireframe or not
Global raster	=	0			; show tile raster or not
Global border#	=	0.99		; 1.00 = 100% = walk along the borderline
Global vscale#	=	8.0			; vertical terrain scale divider (increase if using smaller hmaps)
Global ipos		=	50			; initial player y position

AppTitle "Monkey Island Meshterrain Demo 1.001"
Graphics3D 1024,768,32,1

ms=MilliSecs() : SeedRnd(ms)

Dim hm(tiles,tiles),cm(tiles,tiles),tile(tiles,tiles)
Global cam,player,cam_pitch#,cam_yaw#,mvx#,mvy#,mvz#,targetpitch#,targetyaw#,sp#

hmap=LoadImage("heightmap.png")
cmap=LoadImage("colormap.jpg")
detail=LoadTexture("detail.png")

hmw=ImageWidth(hmap) : hmh=ImageHeight(hmap) : hmws=hmw/tiles : hmhs=hmh/tiles
cmw=ImageWidth(cmap) : cmh=ImageHeight(cmap) : cmws=cmw/tiles : cmhs=cmh/tiles

Global sw=hmw*range#

; create textures and heightmap tiles
x=1
Repeat
	y=1 
	Repeat
		cm(x,y)=CreateTexture(cmw/tiles,cmh/tiles,1+16+32)
		hm(x,y)=CreateImage((hmw/tiles)+1,(hmh/tiles)+1)
		y=y+1
	Until y&gt;tiles
	x=x+1
Until x&gt;tiles

; cut heightmap
x=hmws
Repeat
	y=hmhs
	Repeat
		CopyRect(x-hmws,y-hmhs,hmws+1,hmhs+1,0,0,ImageBuffer(hmap),ImageBuffer(hm(x/hmws,y/hmhs)))
	y=y+hmhs
	Until y&gt;hmh
	x=x+hmws
Until x&gt;hmw

; cut colormap
x=cmws
Repeat
	y=cmhs
	Repeat
		CopyRect(x-cmws,y-cmhs,cmws,cmhs,0,0,ImageBuffer(cmap),TextureBuffer(cm(x/cmws,y/cmhs)))
		If raster Then
			SetBuffer TextureBuffer(cm(x/cmws,y/cmhs))
			Color 255,0,0
			Rect(0,0,cmws,cmhs,0)
		EndIf
		y=y+cmhs
	Until y&gt;cmh
	x=x+cmws
Until x&gt;cmw

; resize and free unused images
ResizeImage cmap,mapsize,mapsize
FreeImage(hmap)
mf#=mapsize*1.0/hmw

; create mesh terrain tiles
x=0
Repeat
	y=0
	Repeat
		tx=1+Abs(x)/hmws : ty=1+Abs(y)/hmhs
		tile(tx,ty)=LoadMeshTerrain(hm(tx,ty),cm(tx,ty),detail,tx,ty)
		PositionEntity tile(tx,ty),(x*scale#)-((hmw/2)*scale#),0,(y*scale#)+((hmh/2)*scale#)
		EntityType tile(tx,ty),2
		ScaleEntity tile(tx,ty),scale#,scale#,scale#
		y=y-hmhs
	Until y&lt;(-hmh+hmhs)
	x=x+hmws
Until x&gt;(hmw-hmws)

player=CreatePivot()
PositionEntity player,0,ipos*scale#,0
EntityType player,1
EntityRadius player,1.0*scale#

cam=CreateCamera(player)
PositionEntity cam,0,0,0
CameraZoom cam,2
CameraFogColor cam,100,150,200
CameraClsColor cam,100,150,200
cam_yaw=230
targetyaw=230

AmbientLight 255,255,255

s=Speed(ms)

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

Collisions 1,2,2,3

; Main loop
While Not KeyHit(1)

	FPS_C=FPS_C+1 
	If ms&lt;MilliSecs() 
		ms=MilliSecs()+1000 
		FPS=FPS_C 
		FPS_C=0 
	EndIf

	old=pos : pos=MouseZSpeed()
	
	; Keys
	If KeyHit(59) Then wired=1-wired		; F1 = Wireframe on/off
	If KeyHit(60) Then gravity=1-gravity	; F2 = Gravity on/off
	If KeyHit(61) Then fog=1-fog			; F3 = Fog on/off
	If KeyHit(28) Then showmap=1-showmap	; Return = Map on/off
	If KeyDown(201) Then sw=sw+hmw/16		; Page up = slow range increase
	If KeyDown(209) Then sw=sw-hmw/16		; Page down = slow range decrease
	
	If old=1 Then sw=sw+hmw					; Mouse Wheel up = fast range increase
	If old=-1 Then sw=sw-hmw				; Mouse Wheel down = fast range decrease
	
	If sw&lt;hmw Then sw=hmw

	PlayerControls()
	
	plx#=EntityX(player) : ply#=EntityY(player) : plz#=EntityZ(player)
	If gravity Then ply#=ply#-(sp#*50)
	If plx#&lt;((-hmw*border#)/2)*scale# Then plx=((-hmw*border#)/2)*scale#
	If plx#&gt;((hmw*border#)/2)*scale# Then plx#=((hmw*border#)/2)*scale#
	If plz#&lt;((-hmh*border#)/2)*scale# Then plz#=((-hmh*border#)/2)*scale#
	If plz#&gt;((hmw*border#)/2)*scale# Then plz#=((hmw*border#)/2)*scale#
	PositionEntity player,plx#,ply#,plz#
	
	CameraFogMode cam,fog
	CameraRange cam,0.1,sw
	CameraFogRange cam,0,sw

	WireFrame wired
	UpdateWorld
	RenderWorld
	
	Color 255,255,255
	Text 0,0,"Tris: "+TrisRendered()+"  FPS: "+FPS+"  Range: "+sw+"  Wireframe: "+wired+"  Gravity: "+gravity+"  Fog: "+fog+"  Build time: "+(s/1000.0)+" sec."
	
	If showmap Then
		Color 0,0,0 : Rect 0,25,mapsize,mapsize,1 : DrawImage cmap,0,25
		Color 255,255,255 : Text 0,12,"X:"+Int(plx#)+" Y:"+Int(ply#)+" Z:"+Int(plz#)+" Pitch: "+cam_pitch+" Yaw: "+cam_yaw
		Color 255,0,0 : Oval((mapsize/2)+(plx#/scale#*mf#)-2,25+(mapsize/2)+(plz#*-1/scale#*mf#)-2,4,4,1)
	EndIf
	
	Flip 0

Wend

End

Function Speed(ms) : s=(MilliSecs()-ms) : Return s : End Function

Function PlayerControls()

	mxspd# = MouseXSpeed()*0.25
	myspd# = MouseYSpeed()*0.25

	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

	targetpitch = targetpitch + myspd
	targetpitch = ClampValue(targetpitch, -85,85)
	targetyaw = targetyaw - mxspd	

	cam_pitch = cam_pitch + (targetpitch - cam_pitch)/16.0
	cam_yaw = cam_yaw + (targetyaw - cam_yaw)/16.0
	
	RotateEntity player,0,cam_yaw,0
	RotateEntity cam,cam_pitch,0,0
	
	sp#=speed#
	If KeyDown(42) Or KeyDown(54) Then sp#=(speed#*5)	; Shift = Turbo

	If KeyDown(200) Then mvz=mvz+sp#			; Arrow up = forward
	If KeyDown(208) Then mvz=mvz-sp#			; Arrow down = backward
	If KeyDown(205) Then mvx=mvx+sp#			; Arrow right = right
	If KeyDown(203) Then mvx=mvx-sp#			; Arrow left = left
	
	If MouseDown(1) Then mvy=mvy+sp#			; LMB = raise
	If MouseDown(2) Then mvy=mvy-sp#			; RMB = lower
		
	If KeyDown(17) Then mvz=mvz+sp#				; W = forward
	If KeyDown(31) Then mvz=mvz-sp#				; S = backward
	If KeyDown(30) Then mvx=mvx-sp#				; A = left
	If KeyDown(32) Then mvx=mvx+sp#				; D = right

	If KeyDown(16) Then mvy=mvy+sp#				; Q = raise
	If KeyDown(18) Then mvy=mvy-sp#				; E = lower
	
	
	TranslateEntity player,0,mvy,0
	MoveEntity player,mvx,0,mvz

	mvx=mvx/1.01
	mvy=mvy/1.01
	mvz=mvz/1.01
	
End Function

Function ClampValue(Original#, low#, high#)

	If Original&lt;low  Then Return low
	If Original&gt;high Then Return high
	Return Original

End Function


Function LoadMeshTerrain(heightmap,colormap=False,detail=False,tx=0,ty=0)

	lessx=1 : If tx=ti Then lessx=2
	lessy=1 : If ty=ti Then lessy=2

	x = ImageWidth(heightmap)-lessx : y = ImageHeight(heightmap)-lessy

	mesh = CreateMesh() : surf = CreateSurface(mesh)

	For ly = 0 To y
		For lx = 0 To x
			AddVertex surf,lx,0,ly,1.0/lx,1.0/ly
		Next
	Next

	For ly = 0 To y-1
		For lx = 0 To x-1
			AddTriangle surf,lx+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)
			AddTriangle surf,(lx+1)+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)+(x+1)
		Next
	Next
	
	PositionMesh mesh,0,0,-y

	SetBuffer ImageBuffer(heightmap) : LockBuffer ImageBuffer(heightmap)

	For lx = 0 To x
		For ly = 0 To y
			h=(ReadPixelFast(lx,y-ly) And $ff0000)/$10000
			index = lx + ((x+1)*ly)
			VertexCoords surf,index,VertexX(surf,index),h/vscale#,VertexZ(surf,index)
			VertexTexCoords surf,index,lx,(y-ly)
		Next
	Next

	UnlockBuffer ImageBuffer(heightmap) : SetBuffer BackBuffer()
	
	UpdateNormals mesh
	
	If colormap EntityTexture mesh,colormap,0,0 : ScaleTexture colormap,x,y
	If detail EntityTexture mesh,detail,0,2 : ScaleTexture detail,2,2 : TextureBlend detail,5
			
	Return Mesh
	
End Function</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nexus6</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Moved comments to programming. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>2008</font></td></tr></table></td></tr><tr ><td class="posttext"> Need to have another look at this... Thanks for tidying it up though :o) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> UPDATED! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Hey Ross, this is very interesting.  I did some stuff a while back (ermm 10 years or so ago) that used Vista and DEM files to create landscapes.  <br><br>It is great to see the type of code necessary to produce such fantastic results, thanks for sharing. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Did anyone fix the UV Coordinate glitch yet? I cant seem to find it. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> ? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I know u guys proally dont have time to fix it, but here's what i mean by uv coordinate glitch. its some bad geometry.<br><br><img src="http://i406.photobucket.com/albums/pp148/DarkShadowWing/badgeom.png"> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Ok, guys. I have tried &amp; tried to fix ur code, but i still end up where i started. here's my code so far. download the zip provided above to try the code.<br><br>i added stuff as well. ull need a cloud texture. i will provide it to u. and a sea texture. which i cant provide to you. i say this because my sea texture isnt perfect.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">; Meshterrain Demo, Version 1.001 by Krischan (webmaster@...)
;
; Make sure there are three images in the current folder:
;
; - a Heightmap (standard: 256x256 PNG)
; - a Colormap (standard: 2048x2048 JPG)
; - a detail Texture (standard: 512x512 PNG)
;
; This script will cut the images and display the heightmap/colormap as a tiled Mesh Terrain
;
; Textures and Heightmap generated with Large 3D Terrain SE 2.5 (http://www.bundysoft.com/L3DT)
; Based on a script from Ross C and this thread:
;
; <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1609" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1609</a>

; Settings
Global speed#	=	1			; Walk speed
Global scale#	=	1000.00		; map scale
Global tiles	=	16			; how many tiles in X -AND- Y direction? must be power of 2
Global mapsize	=	256			; overview map size
Global range#	=	100			; initial view range (100 = 100% map size)
Global showmap	=	1			; show map
Global fog		=	1			; use fog or not
Global gravity	=	2			; use gravity or not
Global wired	=	0			; show wireframe or not
Global raster	=	0			; show tile raster or not
Global border#	=	1		; 1.00 = 100% = walk along the borderline
Global vscale#	=	3.0			; vertical terrain scale divider (increase if using smaller hmaps)
Global ipos		=	30			; initial player y position

AppTitle "Monkey Island Meshterrain Demo 1.001"
HidePointer

Graphics3D 1024,768,32,2
AmbientLight 255, 255, 255

Global lake = CreatePlane()
ScaleEntity lake, 1000, 1, 1000

z1$ = LoadTexture("wave.PNG")
EntityAlpha lake, .01

EntityTexture lake, z1$
PositionEntity lake, 0, 2000, 0

Global lakez = CreatePlane()
ScaleEntity lakez, 1000, 1, 1000

EntityAlpha lakez,.2

EntityTexture lakez, z1$

ScaleTexture z1$, 1000, 1000

sky=CreatePlane()
ScaleEntity sky, 10, 1, 10
cloud=LoadTexture("RealClouds02.pcx",2)
ScaleTexture cloud,10000,10000
PositionEntity sky,0,2900,0
TurnEntity sky,0,0,180
EntityTexture sky,cloud

sky2=CreatePlane()
ScaleEntity sky2, 50, 1, 50
cloud2=LoadTexture("RealClouds02.pcx",2)
ScaleTexture cloud2,10000,10000
PositionEntity sky2,0,5000,0
TurnEntity sky2,0,0,180
EntityTexture sky2,cloud2

ms=MilliSecs() : SeedRnd(ms)

Dim hm(tiles,tiles),cm(tiles,tiles),tile(tiles,tiles)
Global cam,player,cam_pitch#,cam_yaw#,mvx#,mvy#,mvz#,targetpitch#,targetyaw#,sp#

hmap=LoadImage("heightmap.png")
cmap=LoadImage("colormap.jpg")
detail=LoadTexture("detail.png")

hmw=ImageWidth(hmap) : hmh=ImageHeight(hmap) : hmws=hmw/tiles : hmhs=hmh/tiles
cmw=ImageWidth(cmap) : cmh=ImageHeight(cmap) : cmws=cmw/tiles : cmhs=cmh/tiles

Global sw=hmw*range#

; create textures and heightmap tiles
x=1
Repeat
	y=1 
	Repeat
		cm(x,y)=CreateTexture(cmw/tiles,cmh/tiles,1+16+32)
		hm(x,y)=CreateImage((hmw/tiles)+1,(hmh/tiles)+1)
		y=y+1
	Until y&gt;tiles
	x=x+1
Until x&gt;tiles

; cut heightmap
x=hmws
Repeat
	y=hmhs
	Repeat
		CopyRect(x-hmws,y-hmhs,hmws+1,hmhs+1,0,0,ImageBuffer(hmap),ImageBuffer(hm(x/hmws,y/hmhs)))
	y=y+hmhs
	Until y&gt;hmh
	x=x+hmws
Until x&gt;hmw

; cut colormap
x=cmws
Repeat
	y=cmhs
	Repeat
		CopyRect(x-cmws,y-cmhs,cmws,cmhs,0,0,ImageBuffer(cmap),TextureBuffer(cm(x/cmws,y/cmhs)))
		If raster Then
			SetBuffer TextureBuffer(cm(x/cmws,y/cmhs))
			Color 255,0,0
			Rect(0,0,cmws,cmhs,0)
		EndIf
		y=y+cmhs
	Until y&gt;cmh
	x=x+cmws
Until x&gt;cmw

; resize and free unused images
ResizeImage cmap,mapsize,mapsize
FreeImage(hmap)
mf#=mapsize*1.0/hmw

; create mesh terrain tiles
x=0
Repeat
	y=0
	Repeat
		tx=1+Abs(x)/hmws : ty=1+Abs(y)/hmhs
		tile(tx,ty)=LoadMeshTerrain(hm(tx,ty),cm(tx,ty),detail,tx,ty)
		; find Xfighter in your Samples directory and use the textures in there

		PositionEntity tile(tx,ty),(x*scale#)-((hmw/2)*scale#),0,(y*scale#)+((hmh/2)*scale#)
		EntityType tile(tx,ty),2
		ScaleEntity tile(tx,ty),scale#,scale#,scale#
		y=y-hmhs
	Until y&lt;(-hmh+hmhs)
	x=x+hmws
Until x&gt;(hmw-hmws)

player=CreateCube()
PositionEntity player,0,ipos*scale#,4
EntityType player,1
EntityRadius player,1.0*scale#

ScaleEntity player, 100, 100, 100

cam=CreateCamera(player)
;PositionEntity cam,0,0,0
CameraZoom cam,.2
CameraFogColor cam,100,150,200
CameraClsColor cam,100,150,200
cam_yaw=230
targetyaw=230

AmbientLight 255,255,255

s=Speed(ms)

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

Collisions 1,2,2,3

; Main loop
While Not KeyHit(1)

z# = z# + .0001
PositionTexture z1$, z#, z#

cl#=cl-.0003; this is the speed of the lower cloud level
PositionTexture cloud,cl,cl
cl2#=cl2-.00002; this is the speed of the upper cloud level
PositionTexture cloud2,cl2,cl2

If zoom# &lt;= 1 Then zoom# = 1

If zoom# &gt; 1.45 Then zoom# = 1.45

If MouseZ() Then zoom# = MouseZ()+zoom#*.0000001 : Else zoom# = 1

CameraZoom cam, zoom#

	FPS_C=FPS_C+1 
	If ms&lt;MilliSecs() 
		ms=MilliSecs()+1000 
		FPS=FPS_C 
		FPS_C=0 
	EndIf

	old=pos : pos=MouseZSpeed()
	
	; Keys
	If KeyHit(59) Then wired=1-wired		; F1 = Wireframe on/off
	If KeyHit(60) Then gravity=1-gravity	; F2 = Gravity on/off
	If KeyHit(61) Then fog=1-fog			; F3 = Fog on/off
	If KeyHit(28) Then showmap=1-showmap	; Return = Map on/off
	If KeyDown(201) Then sw=sw+hmw/16		; Page up = slow range increase
	If KeyDown(209) Then sw=sw-hmw/16		; Page down = slow range decrease
	
	If old=1 Then sw=sw+hmw					; Mouse Wheel up = fast range increase
	If old=-1 Then sw=sw-hmw				; Mouse Wheel down = fast range decrease
	
	If sw&lt;hmw Then sw=hmw

	PlayerControls()
	
	plx#=EntityX(player) : ply#=EntityY(player) : plz#=EntityZ(player)
	If gravity Then ply#=ply#-(sp#*50)
	If plx#&lt;((-hmw*border#)/2)*scale# Then plx=((-hmw*border#)/2)*scale#
	If plx#&gt;((hmw*border#)/2)*scale# Then plx#=((hmw*border#)/2)*scale#
	If plz#&lt;((-hmh*border#)/2)*scale# Then plz#=((-hmh*border#)/2)*scale#
	If plz#&gt;((hmw*border#)/2)*scale# Then plz#=((hmw*border#)/2)*scale#

	PositionEntity player,plx#,ply#,plz#
	
	CameraFogMode cam,fog
	CameraRange cam,0.1,sw
	CameraFogRange cam,0,sw

	WireFrame wired
	UpdateWorld
	RenderWorld
	
	Color 255,255,255
	Text 0,0,"Tris: "+TrisRendered()+"  FPS: "+FPS+"  Range: "+sw+"  Wireframe: "+wired+"  Gravity: "+gravity+"  Fog: "+fog+"  Build time: "+(s/1000.0)+" sec."+"zoom: "+zoom#+" gravity:"+mvy
	
	If showmap Then
		Color 0,0,0 : Rect 0,25,mapsize,mapsize,1 : DrawImage cmap,0,25
		Color 255,255,255 : Text 0,12,"X:"+Int(plx#)+" Y:"+Int(ply#)+" Z:"+Int(plz#)+" Pitch: "+cam_pitch+" Yaw: "+cam_yaw
		Color 255,0,0 : Oval((mapsize/2)+(plx#/scale#*mf#)-2,25+(mapsize/2)+(plz#*-1/scale#*mf#)-2,4,4,1)
	EndIf
	
	Flip 0

Wend

End

Function Updatecamera(cam1,follow,mindist#,maxdist#)  ;This function updates the camera

PointEntity cam1,follow  ;You may need to edit this out depending on your program

x# = EntityX(cam1)
y# = EntityY(cam1)
z# = EntityZ(cam1)

x1# = EntityX(follow)
y1# = EntityY(follow) ;the plus 10 is optional so your camera stays somewhat above your character... change if needed or remove completely
z1# = EntityZ(follow)

dx# = x#-x1#
dy# = y#-y1#
dz# = z#-z1#

dist# = Sqr((dx#*dx#) + (dy#*dy#) + (dz#*dz#))	;distance formula 3d (the reason I 'reinvented the wheel' here is because I needed the x y and z differences for later anyway so it is more efficient to use the variables twice than to have the computer do it for you)

If dist# &gt; maxdist# Then
	fct# = maxdist#/dist#
	dx# = dx#*fct#
	dy# = dy#*fct#
	dz# = dz#*fct#
ElseIf dist# &lt; mindist# Then
	fct# = mindist#/dist#
	dx# = dx#*fct#
	dy# = dy#*fct#
	dz# = dz#*fct#
EndIf

PositionEntity cam1, x1#+dx#,y1#+dy#,z1#+dz#		;This positions the camera where it needs to go.

End Function
Function Speed(ms) : s=(MilliSecs()-ms) : Return s : End Function

Function PlayerControls()

	mxspd# = MouseXSpeed()*0.25
	myspd# = MouseYSpeed()*0.25

	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

	targetpitch = targetpitch + myspd
	targetpitch = ClampValue(targetpitch, -85,85)
	targetyaw = targetyaw - mxspd	

	cam_pitch = cam_pitch + (targetpitch - cam_pitch)/16.0
	cam_yaw = cam_yaw + (targetyaw - cam_yaw)/16.0
	
	RotateEntity player,0,cam_yaw,0
	RotateEntity cam,cam_pitch,0,0
	
	sp#=speed#
	If KeyDown(42) Or KeyDown(54) Then sp#=(speed#*5)	; Shift = Turbo
	If mvy# &lt;= .01 Then mvy# = .01

	If KeyDown(200) Then mvz=mvz+sp#			; Arrow up = forward
	If KeyDown(208) Then mvz=mvz-sp#			; Arrow down = backward
	If KeyDown(205) Then mvx=mvx+sp#			; Arrow right = right
	If KeyDown(203) Then mvx=mvx-sp#			; Arrow left = left
	
	If MouseDown(1) Then mvy=mvy+sp#			; LMB = raise
	If MouseDown(2) Then mvy=mvy-sp#			; RMB = lower
		
	If KeyDown(17) Then mvz=mvz+sp#				; W = forward
	If KeyDown(31) Then mvz=mvz-sp#				; S = backward
	If KeyDown(30) Then mvx=mvx-sp#				; A = left
	If KeyDown(32) Then mvx=mvx+sp#				; D = right

	If KeyDown(16) Then mvy=mvy+sp#				; Q = raise
	If KeyDown(18) Then mvy=mvy-sp#				; E = lower
	
	
	TranslateEntity player,0,mvy,0
	MoveEntity player,mvx,0,mvz

	mvx=mvx/1.01
	mvy=mvy/1.01
	mvz=mvz/1.01
	
End Function

Function ClampValue(Original#, low#, high#)

	If Original&lt;low  Then Return low
	If Original&gt;high Then Return high
	Return Original

End Function


Function LoadMeshTerrain(heightmap,colormap=False,detail=False,tx=0,ty=0)

	lessx=1 : If tx=ti Then lessx=2
	lessy=1 : If ty=ti Then lessy=2

	x = ImageWidth(heightmap)-lessx : y = ImageHeight(heightmap)-lessy

	mesh = CreateMesh() : surf = CreateSurface(mesh)

	For ly = 0 To y
		For lx = 0 To x
			AddVertex surf,lx,0,ly,1.0/lx,1.0/ly
		Next
	Next

	For ly = 0 To y-1
		For lx = 0 To x-1
			AddTriangle surf,lx+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)			
			AddTriangle surf,(lx+1)+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)+(x+1)
		Next
	Next
	
	PositionMesh mesh,0,0,-y

	SetBuffer ImageBuffer(heightmap) : LockBuffer ImageBuffer(heightmap)

	For lx = 0 To x
		For ly = 0 To y
			h=(ReadPixelFast(lx,y-ly) And $ff0000)/$10000
			index = lx + ((x+1)*ly)
			VertexCoords surf,index,VertexX(surf,index),h/vscale#,VertexZ(surf,index)
			VertexTexCoords surf,index,lx,(y-ly)
		Next
	Next

	UnlockBuffer ImageBuffer(heightmap) : SetBuffer BackBuffer()
	
	UpdateNormals mesh
	
	If colormap EntityTexture mesh,colormap,0,0 : ScaleTexture colormap,x,y
	If detail EntityTexture mesh,detail,0,2 : ScaleTexture detail,2,2 : TextureBlend detail,5
			
	Return Mesh
	
End Function</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Cloud texture: <a href="http://www.mediafire.com/download.php?zgmjlieydgl" target="_blank">http://www.mediafire.com/download.php?zgmjlieydgl</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >cyberyoyo</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Great demo Drkshadowwing,I'll take a lot at the UV problem but there is a possibility that it might not be fixable since it appears on the limit between two different meshes.<br><br>As for RossC code, it always gives me a MAV on renderworld()...<br><br>It's nice to see that B3d can be so great after all these years :) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >cyberyoyo</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> (double post plz delete) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >cyberyoyo</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> [EDITED]<br>Code removed and moved to the appropriate thread there:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=83668" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=83668</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Remember this isn't a help forum. The code works perfectly fine. If you have trouble with code using my code, please don't post it here :o) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Additional here is my own solution, a little bit more code than a single function, its a complete demo (but still based on Ross C's original code). I managed to fix the UV coordinates and use the Terragen File Format as a heightmap base which gives more precision. You can even use Vertex Shadows now because I fixed the chunk normals, too. The Terragen size is irrelevant, the demo will calculate how many tiles are needed and fixes the seams automatically. The colormap texture is stretched across the whole terrain so it should be huge, otherwise you can activate the "vertexcolors" flag but this is not as nice as a colormap.<br><br>Screenshot:<br><img src="http://www.christianhart.de/bb/terratiles/terratiles.jpg"><br><br>Use Mouse for movement (LMB/RMB = up/down) and these keys:<br><br>Arrows = Move (5 times fast while holding right SHIFT)<br>C = show/hide chunk seams (otherwise you won't notice any seam)<br>F = fog on/off<br>Q/E = increase/decrease light angle<br>1...9 = light angle preset between 0° and 180° in 22.5° steps<br>SPACE = wireframe on/off<br><br>The code is well commented but if you have any questions feel free to ask me.<br><br>Complete Demo with media (830KB): <a href="http://www.christianhart.de/bb/terratiles/terratiles.zip" target="_blank">http://www.christianhart.de/bb/terratiles/terratiles.zip</a><br>(otherwise you need a custom terragen file, ex. 257x257 size and a matching colormap ex. 1024x1024 pixels)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 800,600,32,2
SetBuffer BackBuffer()


; Variables to change
Global Speed#=0.02			; Player move Speed
Global scale%=100			; Scene scale
Global angle#=160			; Initial light angle (0...90...180...270...360 = dawn,noon,evening,midnight,dawn)
Global tilesize%=32			; Vertices per tile (x*x)
Global VertexColors%=False	; use Vertexcolors or not
Global Colored=True			; show tile seams (switch with Key "C")
Global Fog%=True			; use fog or not (switch with Key "F")
Global divider#=2.0			; vertical divider for height


; Globals
Global min#=65536.0
Global max#=0.0
Global oldangle#=-1
Global minm#,maxm#
Global size,xpts,ypts,xscale#,yscale#,zscale#,crad#,crvm,hscale,hbase
Global cam%,speedmulti%,wf%,init%
Global lightpivot%,sun%,light%,ambientcol%,clscol%,water%
Global FPS_C%,FMS%,FPS%
Global heightfield%,tiles%,tsize%
Global Tween#


; Arrays
Dim meshes(0,0),surfaces(0,0),tris(0,0),vertex(0,0)


; Loading Textures
Global colormap=LoadTexture("colormap.jpg",16+32)
Global texsize=TextureWidth(colormap)
ScaleTexture colormap,texsize,texsize


; Load Terragen Terrain
Print "Loading Terrain..." : LoadTerragen("island.ter")


; Init Scene
Print "Init Scene..." : InitScene()


; Create Meshterrain Tiles
Print "Create Meshterrain Tiles..." : CreateTiles()


; Fixing Chunk normals
Print "Fixing Chunk Normals..." : FixChunkNormals()


; Collisions
Collisions 1,2,2,3
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2


While Not KeyHit(1)
	
	Local ms%,ft%
	
	; Frame Tweeing
	ms=MilliSecs() : Tween#=(ms-ft)/5.0 : ft=ms
	
	; check for User Input
	CheckInput()
	
	Updatescene()
	
	; Render
	UpdateWorld Tween
	RenderWorld
	
	; Infotext
	Text 0, 0,"Tris..........: "+TrisRendered()
	Text 0,15,"FPS...........: "+ShowFPS()
	Text 0,30,"Angle.........: "+Int(angle)+"°"
	Text 0,45,"Tiles/Tilesize: "+(tiles*tiles)+"/"+tsize
	
	Flip 0
	
Wend

End


; -------------------------------------------------------------------------------------------------
; simple FPS measurement
; -------------------------------------------------------------------------------------------------
Function ShowFPS()
	
    FPS_C=FPS_C+1 : If FMS&lt;MilliSecs() Then FMS=MilliSecs()+1000 : FPS=FPS_C : FPS_C=0
	Return FPS
	
End Function


; -------------------------------------------------------------------------------------------------
; Check User Input (Keyboard / Mouse) and Camera Movement
; -------------------------------------------------------------------------------------------------
Function CheckInput()
	
	Local up%=0
	
	; Key Q/W: change light angle
	If KeyDown(16) Then angle=angle-0.1*Tween
	If KeyDown(17) Then angle=angle+0.1*Tween
	
	; Key 1-9: predefined angle 0-180° in 22.5° steps
	If KeyHit(2) Then angle=0.0
	If KeyHit(3) Then angle=22.5
	If KeyHit(4) Then angle=45
	If KeyHit(5) Then angle=67.5
	If KeyHit(6) Then angle=90
	If KeyHit(7) Then angle=112.5
	If KeyHit(8) Then angle=135
	If KeyHit(9) Then angle=157.5
	If KeyHit(10) Then angle=180.0
	
	; SHIFT = increase player speed 5 times
	If KeyDown(54) Then speedmulti=5 Else speedmulti=1
	
	; Space = Wireframe on/off
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; F = Fogswitch
	If KeyHit(33) Then Fog=1-Fog : CameraFogMode cam,Fog
	
	; C = Colorswitch
	If KeyHit(46) Then Colored=1-Colored : FixChunkNormals()
	
	; LMB/RMB: up/down
	If MouseDown(1) Then up=1
	If MouseDown(2) Then up=-1
	
	; Simple Camera movement
	TurnEntity cam,MouseYSpeed(),-MouseXSpeed(),0
	RotateEntity cam,EntityPitch(cam),EntityYaw(cam),0
	MoveEntity cam,(KeyDown(205)-KeyDown(203))*Speed*Tween*speedmulti/2.0,up*Speed*Tween*speedmulti,(KeyDown(200)-KeyDown(208))*Speed*Tween*speedmulti/2
	
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	
End Function


; -------------------------------------------------------------------------------------------------
; Init additional elements like cam, light, water
; -------------------------------------------------------------------------------------------------
Function InitScene()
	
	; Create Camera
	cam=CreateCamera()
	PositionEntity cam,scale/3,scale/6,scale/3
	CameraRange cam,0.01,scale*2
	CameraFogMode cam,Fog
	CameraFogRange cam,scale/2,scale
	EntityType cam,1
	EntityRadius cam,0.1
	CameraClsColor cam,187,213,239
	CameraFogColor cam,187,213,239
	
	; Light
	lightpivot=CreatePivot()
	sun=CreateSphere(8,lightpivot)
	ScaleEntity sun,2,2,2
	EntityColor sun,255,255,128
	EntityFX sun,1+8
	PositionEntity sun,-scale/2,0,0
	light=CreateLight(1,sun)
	PositionEntity light,0,0,0
	LightColor light,255,255,255
	AmbientLight 32,32,32
	
	; Water
	water=CreateCube()
	EntityFX water,1+8
	EntityAlpha water,0.5
	EntityColor water,32,64,128
	ScaleEntity water,scale/2,0.01,scale/2
	
End Function


; -------------------------------------------------------------------------------------------------
; Updates light FX by angle
; -------------------------------------------------------------------------------------------------
Function Updatescene()
	
	; Limit angle to 0...360 degrees
	angle=angle Mod 360.0 : If angle&lt;0 Then angle=360.0+angle
	
	; only continue if angle has been changed
	If angle&lt;&gt;oldangle Then
		
		; rotate light angle and point light sources to pivot
		RotateEntity lightpivot,0,-90,-angle
		PointEntity light,lightpivot
		
		; Update Ambientlight, Cameraclscolor according to angle
		If angle&gt;=0 And angle&lt;=180 Then
			
			If angle&lt;=90 Then
				ambientcol=Normalize(angle,0,90,32,128)
				clscol=Normalize(angle,0,90,16,512)
			EndIf
			
			If angle&gt;=90 Then
				ambientcol=Normalize(angle,90,180,128,32)
				clscol=Normalize(angle,90,180,512,16)
			EndIf
			
			; limit daylight
			If clscol&gt;224 Then clscol=224
			
			; set AmbientLight And CameraClsColor
			AmbientLight ambientcol,ambientcol,ambientcol
			CameraClsColor cam,clscol*0.70,clscol*0.75,clscol*1.0
			CameraFogColor cam,clscol*0.75,clscol*0.80,clscol*1.0
			
		EndIf
		
	EndIf
	
	If Not init Then PointEntity cam,lightpivot : init=True
	
	oldangle=angle
	
End Function


; -------------------------------------------------------------------------------------------------
; Creates and textures the tiles, optional with vertexcolors by the colormap texture
; -------------------------------------------------------------------------------------------------
Function CreateTiles()
	
	Local x%,y%
	
	LockBuffer TextureBuffer(colormap)
	
	For y=0 To tiles-1
		
		For x=0 To tiles-1
			
			; new Tile
			meshes(x,y)=CreateMeshTile(scale/tsize,tsize+1,x,y)
			EntityFX meshes(x,y),2
			
			; get Surface and Tris per Tile
			surfaces(x,y)=GetSurface(meshes(x,y),1)
			tris(x,y)=CountVertices(surfaces(x,y))
			
			; apply texture
			EntityTexture meshes(x,y),colormap,0,1
			
			; collision
			EntityType meshes(x,y),2
			
		Next
		
	Next
	
	UnlockBuffer TextureBuffer(colormap)
	
End Function


; -------------------------------------------------------------------------------------------------
; Fixes the Chunk normals that no visible seams appear
; -------------------------------------------------------------------------------------------------
Function FixChunkNormals()
	
	Local x%,y%,z%
	Local nx#,ny#,nz#
	Local r%,g%,b%
	
	For y=0 To tiles-1
		
		For x=0 To tiles-1
			
			For z=0 To tsize
				
				; align vertical normals
				nx=VertexNX(surfaces(x,y),tsize+(z*(tsize+1)))
				ny=VertexNY(surfaces(x,y),tsize+(z*(tsize+1)))
				nz=VertexNZ(surfaces(x,y),tsize+(z*(tsize+1)))
				If x&lt;tiles-1 Then VertexNormal surfaces(x+1,y),0+(z*(tsize+1)),nx,ny,nz
				
				; align horizontal normals
				nx=VertexNX(surfaces(x,y),tris(x,y)-(tsize+1)+z)
				ny=VertexNY(surfaces(x,y),tris(x,y)-(tsize+1)+z)
				nz=VertexNZ(surfaces(x,y),tris(x,y)-(tsize+1)+z)
				If y&lt;tiles-1 Then VertexNormal surfaces(x,y+1),z,nx,ny,nz
				
				r=128
				g=128
				b=128
				
				; If set: seams=red
				If Colored Then
					r=255
					g=0
					b=0
				EndIf
				
				VertexColor surfaces(x,y),tsize+(z*(tsize+1)),r,g,b
				If x&lt;tiles-1 Then VertexColor surfaces(x+1,y),(z*(tsize+1)),r,g,b
				VertexColor surfaces(x,y),tris(x,y)-(tsize+1)+z,r,g,b
				If y&lt;tiles-1 Then VertexColor surfaces(x,y+1),z,r,g,b
					
			Next
			
		Next
	Next
	
End Function


; -------------------------------------------------------------------------------------------------
; Creates a single Mesh Terrain Tile with unfixed chunk borders
; -------------------------------------------------------------------------------------------------
Function CreateMeshTile(size%,vertexes,startx%=0,starty%=0)
	
	Local a%,r%,g%,b%,rgb%,v%
	Local mesh%,surface%
	Local xpoint%,ypoint%
	Local zpoint%
	Local tri%,lx%,ly%,h#,index%
	Local texfactor1#=texsize/(xpts-1)
	Local texfactor2#=texsize/(xpts*1.0)
	Local vx#,vz#
	Local sx%=startx*tsize
	Local sy%=starty*tsize
	
	; create mesh and surface
	mesh = CreateMesh()
	surface = CreateSurface(mesh)
	
	Local buffer%=TextureBuffer(colormap)
	
	LockBuffer buffer
	
    ; set vertices
	For xpoint=0 To vertexes-1
		
		For zpoint=0 To vertexes-1
			
			h#=Normalize(PeekShort(heightfield,(((startx*tsize)+zpoint)+((starty*tsize)+xpoint)*xpts)*2)-32767,min,max,minm,maxm)/divider
			
			vx=-(scale/2.0)+(((starty)*tsize)+xpoint)*(scale*1.0/xpts)
			vz=-(scale/2.0)+(((startx)*tsize)+zpoint)*(scale*1.0/xpts)
			
			v=AddVertex (surface,vx,h,vz,((startx*tsize)+zpoint)*texfactor1,((starty*tsize)+xpoint)*texfactor1)
			
			If VertexColors Then
				
				; read texel
				rgb=ReadPixelFast(((startx*tsize)+zpoint)*texfactor2,((starty*tsize)+xpoint)*texfactor2,buffer)
				r=(rgb And $ff0000)/$10000
				g=(rgb And $ff00)/$100
				b=(rgb And $ff)
				
				; set vertexcolor by colormap
				VertexColor surface,v,r,g,b,1
				
			Else
				
				VertexColor surface,v,128,128,128,1.0
				
			EndIf	
			
			
		Next
		
	Next
	
	UnlockBuffer buffer
	
	; create triangles
	For tri = 0 To (vertexes^2)-vertexes-1
		If tri Mod vertexes&lt;&gt;vertexes-1
			AddTriangle (surface,tri,tri+1,tri+vertexes)
			AddTriangle (surface,tri+1,tri+vertexes+1,tri+vertexes)
		EndIf
	Next
	
	UpdateNormals mesh
	
	Return mesh
	
End Function


; -----------------------------------------------------------------------------
; Read Terragen-File and store heightdata to bank
; -----------------------------------------------------------------------------
Function LoadTerragen(filename$)
	
	Local bank%,i%,xpt%,ypt%,h%,h1#,bytes%=16,pos%,off%=0
	Local infoflag$,sizeflag$,xptsflag$,yptsflag$,scalflag$,cradflag$,crvmflag$,altwflag$,endflag$
	
	; open stream
	Local file=ReadFile(filename$)
	
	; Terragen-Header available?
	For i=1 To 16 : infoflag=infoflag+Chr(ReadByte(file)) : Next
	If infoflag&lt;&gt;"TERRAGENTERRAIN " Then RuntimeError "No valid Terragen Header found!"
	
	; SIZE-Flag available?
	For i=1 To 4 : sizeflag=sizeflag+Chr(ReadByte(file)) : Next
	If sizeflag&lt;&gt;"SIZE" Then RuntimeError "No SIZE Flag found!" Else size=ReadInt(file) : bytes=bytes+4+4
	
	; XPTS-Flag available?
	For i=1 To 4 : xptsflag=xptsflag+Chr(ReadByte(file)) : Next
	If xptsflag&lt;&gt;"XPTS" Then RuntimeError "No XPTS Flag found!" Else xpts=ReadInt(file) : bytes=bytes+4+4
	
	; YPTS-Flag available?
	For i=1 To 4 : yptsflag=yptsflag+Chr(ReadByte(file)) : Next
	If yptsflag&lt;&gt;"YPTS" Then RuntimeError "No YPTS Flag found!" Else ypts=ReadInt(file) : bytes=bytes+4+4
	
	; SCAL-Flag available?
	For i=1 To 4 : scalflag=scalflag+Chr(ReadByte(file)) : Next
	If scalflag&lt;&gt;"SCAL" Then RuntimeError "No SCAL Flag found!" Else xscale#=ReadFloat(file) : yscale#=ReadFloat(file) : zscale#=ReadFloat(file) : bytes=bytes+4+4+4+4
	
	; CRAD-Flag available? (optional)
	For i=1 To 4 : cradflag=cradflag+Chr(ReadByte(file)) : Next
	If cradflag&lt;&gt;"CRAD" Then SeekFile file,FilePos(file)-4 : Goto nextcrvm Else crad=ReadFloat(file) : bytes=bytes+4+4
	
	; CRVM-Flag available? (optional)
	.nextcrvm
	For i=1 To 4 : crvmflag=crvmflag+Chr(ReadByte(file)) : Next
	If crvmflag&lt;&gt;"CRVM" Then SeekFile file,FilePos(file)-4 : Goto nextaltw Else crvm=ReadFloat(file) : bytes=bytes+4+4
	
	; ALTW-Flag available?
	.nextaltw
	For i=1 To 4 : altwflag=altwflag+Chr(ReadByte(file)) : Next
	If altwflag&lt;&gt;"ALTW" Then RuntimeError "No ALTW Flag found!" Else hscale=ReadShort(file) : hbase=ReadShort(file) : bytes=bytes+4+2+2
	
	; Banksize = x*y*2
	heightfield=CreateBank(xpts*ypts*2)
	
	; read height data
	For ypt=ypts To 1 Step -1
		
		For xpt=1 To xpts Step 1
			
			; get 16bit height info and convert to signed integer
			h=ReadShort(file)-32767
			
			; calc minimum/maximum height
			If h&lt;=min Then min=h
			If h&gt;=max Then max=h
			
			; put height data to bank
			PokeShort heightfield,((xpt-1)+(ypt-1)*xpts)*2,h
			
		Next
	
	Next
	
	; close stream
	CloseFile(file)
	
	; calc number of tiles and tilesize
	tiles%=(xpts-1)/tilesize
	tsize%=(xpts-1)/tiles
	
	; get minimum/maximum height
	minm#=(hbase+((min*hscale)/65536.0))*scale/xpts*(xpts/1025.0)
	maxm#=(hbase+((max*hscale)/65536.0))*scale/xpts*(xpts/1025.0)
	
	Dim meshes(tiles,tiles),surfaces(tiles,tiles),tris(tiles,tiles),vertex(tilesize,tilesize)
	
End Function


; -----------------------------------------------------------------------------
; Normalize a value
; -----------------------------------------------------------------------------
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


; -------------------------------------------------------------------------------------------------
; Create a simple quad, with alpha and fx
; -------------------------------------------------------------------------------------------------
Function CreateQuad(r%=255,g%=255,b%=255,alpha#=1.0,fx%=0)
	
	Local mesh%,surface%,v1%,v2%,v3%,v4%
	
	mesh=CreateMesh()
	surface=CreateSurface(mesh)
	
	v1=AddVertex (surface,-1,1,0,1,0)
	v2=AddVertex (surface,1,1,0,0,0)
	v3=AddVertex (surface,-1,-1,0,1,1)
	v4=AddVertex (surface,1,-1,0,0,1)
	
	VertexColor surface,v1,r,g,b,alpha
	VertexColor surface,v3,r,g,b,alpha
	VertexColor surface,v2,r,g,b,alpha
	VertexColor surface,v4,r,g,b,alpha
	
	AddTriangle(surface,0,1,2)
	AddTriangle(surface,3,2,1)
	
	EntityFX mesh,fx
	
	FlipMesh mesh
	
	Return mesh
	
End Function</textarea><br><br>As some of you might have noticed, it is the same island like in this screenshot, yes it could look that nice (i use a quadtree function there but I couldn't manage the Vertex Shadows with it):<br><br><a href="http://www.blitzbasic.com/gallery/view_pic.php?id=1910" target="_blank">http://www.blitzbasic.com/gallery/view_pic.php?id=1910</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I have a slight fix.<br><br>Well. I cant get it to work..<br><br>But I added it..<br><br>Its a few lines that allow for when the sun = 10 degrees (aka 6 am), it adds a day on to the day variable.<br><br>I know, not useful, but maybe you guys can fix it:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 800,600,32,2
SetBuffer BackBuffer()


; Variables to change
Global Day#                  ;Day&lt;=365.24
Global Speed#=0.02			; Player move Speed
Global scale%=100			; Scene scale
Global angle#=160			; Initial light angle (0...90...180...270...360 = dawn,noon,evening,midnight,dawn)
Global tilesize%=32			; Vertices per tile (x*x)
Global VertexColors%=False	; use Vertexcolors or not
Global Colored=True			; show tile seams (switch with Key "C")
Global Fog%=True			; use fog or not (switch with Key "F")
Global divider#=2.0			; vertical divider for height


; Globals
Global min#=65536.0
Global max#=0.0
Global oldangle#=-1
Global minm#,maxm#
Global size,xpts,ypts,xscale#,yscale#,zscale#,crad#,crvm,hscale,hbase
Global cam%,speedmulti%,wf%,init%
Global lightpivot%,sun%,light%,ambientcol%,clscol%,water%
Global FPS_C%,FMS%,FPS%
Global heightfield%,tiles%,tsize%
Global Tween#


; Arrays
Dim meshes(0,0),surfaces(0,0),tris(0,0),vertex(0,0)


; Loading Textures
Global colormap=LoadTexture("colormap.jpg",16+32)
Global texsize=TextureWidth(colormap)
ScaleTexture colormap,texsize,texsize


; Load Terragen Terrain
Print "Loading Terrain..." : LoadTerragen("island.ter")


; Init Scene
Print "Init Scene..." : InitScene()


; Create Meshterrain Tiles
Print "Create Meshterrain Tiles..." : CreateTiles()


; Fixing Chunk normals
Print "Fixing Chunk Normals..." : FixChunkNormals()


; Collisions
Collisions 1,2,2,3
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2


While Not KeyHit(1)
	
	Local ms%,ft%
	
	; Frame Tweeing
	ms=MilliSecs() : Tween#=(ms-ft)/5.0 : ft=ms
	
	; check for User Input
	CheckInput()
	
	Updatescene()
	
	; Render
	UpdateWorld Tween
	RenderWorld
	
	; Infotext
	Text 0, 0,"Tris..........: "+TrisRendered()
	Text 0,15,"FPS...........: "+ShowFPS()
	Text 0,30,"Angle.........: "+Int(angle)+"°"
	Text 0,45,"Tiles/Tilesize: "+(tiles*tiles)+"/"+tsize
	Text 0,60,"Day...........: "+Day#
	
	Flip 0
	
Wend

End


; -------------------------------------------------------------------------------------------------
; simple FPS measurement
; -------------------------------------------------------------------------------------------------
Function ShowFPS()
	
    FPS_C=FPS_C+1 : If FMS&lt;MilliSecs() Then FMS=MilliSecs()+1000 : FPS=FPS_C : FPS_C=0
	Return FPS
	
End Function


; -------------------------------------------------------------------------------------------------
; Check User Input (Keyboard / Mouse) and Camera Movement
; -------------------------------------------------------------------------------------------------
Function CheckInput()
	
	Local up%=0
	
	; Key Q/W: change light angle
	If KeyDown(16) Then angle=angle-0.1*Tween
	If KeyDown(17) Then angle=angle+0.1*Tween
	
	; Key 1-9: predefined angle 0-180° in 22.5° steps
	If KeyHit(2) Then angle=0.0
	If KeyHit(3) Then angle=22.5
	If KeyHit(4) Then angle=45
	If KeyHit(5) Then angle=67.5
	If KeyHit(6) Then angle=90
	If KeyHit(7) Then angle=112.5
	If KeyHit(8) Then angle=135
	If KeyHit(9) Then angle=157.5
	If KeyHit(10) Then angle=180.0
	
	; SHIFT = increase player speed 5 times
	If KeyDown(54) Then speedmulti=5 Else speedmulti=1
	
	; Space = Wireframe on/off
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; F = Fogswitch
	If KeyHit(33) Then Fog=1-Fog : CameraFogMode cam,Fog
	
	; C = Colorswitch
	If KeyHit(46) Then Colored=1-Colored : FixChunkNormals()
	
	; LMB/RMB: up/down
	If MouseDown(1) Then up=1
	If MouseDown(2) Then up=-1
	
	; Simple Camera movement
	TurnEntity cam,MouseYSpeed(),-MouseXSpeed(),0
	RotateEntity cam,EntityPitch(cam),EntityYaw(cam),0
	MoveEntity cam,(KeyDown(205)-KeyDown(203))*Speed*Tween*speedmulti/2.0,up*Speed*Tween*speedmulti,(KeyDown(200)-KeyDown(208))*Speed*Tween*speedmulti/2
	
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	
End Function


; -------------------------------------------------------------------------------------------------
; Init additional elements like cam, light, water
; -------------------------------------------------------------------------------------------------
Function InitScene()
	
	; Create Camera
	cam=CreateCamera()
	PositionEntity cam,scale/3,scale/6,scale/3
	CameraRange cam,0.01,scale*2
	CameraFogMode cam,Fog
	CameraFogRange cam,scale/2,scale
	EntityType cam,1
	EntityRadius cam,0.1
	CameraClsColor cam,187,213,239
	CameraFogColor cam,187,213,239
	
	; Light
	lightpivot=CreatePivot()
	sun=CreateSphere(8,lightpivot)
	ScaleEntity sun,2,2,2
	EntityColor sun,255,255,128
	EntityFX sun,1+8
	PositionEntity sun,-scale/2,0,0
	light=CreateLight(1,sun)
	PositionEntity light,0,0,0
	LightColor light,255,255,255
	AmbientLight 32,32,32
	
	; Water
	water=CreateCube()
	EntityFX water,1+8
	EntityAlpha water,0.5
	EntityColor water,32,64,128
	ScaleEntity water,scale/2,0.01,scale/2
	
End Function


; -------------------------------------------------------------------------------------------------
; Updates light FX by angle
; -------------------------------------------------------------------------------------------------
Function Updatescene()
	
	; Limit angle to 0...360 degrees
	angle=angle Mod 360.0 : If angle&lt;0 Then angle=360.0+angle
	
	If Day# = 0.0 Then Day# = 1.0
	
	;Limit day to 1...365.24 days
	Day#=Day# Mod 365.24 : If Day#&lt;0.0 Then Day#=365.24+Day#
	
	; only continue if angle has been changed
	If angle&lt;&gt;oldangle Then
		
		; rotate light angle and point light sources to pivot
		RotateEntity lightpivot,0,-90,-angle
		PointEntity light,lightpivot
		
		If angle# = 10.0 Then Day#=Day#+1
		
		; Update Ambientlight, Cameraclscolor according to angle
		If angle&gt;=0 And angle&lt;=180 Then
			
			If angle&lt;=90 Then
				ambientcol=Normalize(angle,0,90,32,128)
				clscol=Normalize(angle,0,90,16,512)
			EndIf
			
			If angle&gt;=90 Then
				ambientcol=Normalize(angle,90,180,128,32)
				clscol=Normalize(angle,90,180,512,16)
			EndIf
			
			; limit daylight
			If clscol&gt;224 Then clscol=224
			
			; set AmbientLight And CameraClsColor
			AmbientLight ambientcol,ambientcol,ambientcol
			CameraClsColor cam,clscol*0.70,clscol*0.75,clscol*1.0
			CameraFogColor cam,clscol*0.75,clscol*0.80,clscol*1.0
			
		EndIf
		
	EndIf
	
	If Not init Then PointEntity cam,lightpivot : init=True
	
	oldangle=angle
	
End Function


; -------------------------------------------------------------------------------------------------
; Creates and textures the tiles, optional with vertexcolors by the colormap texture
; -------------------------------------------------------------------------------------------------
Function CreateTiles()
	
	Local x%,y%
	
	LockBuffer TextureBuffer(colormap)
	
	For y=0 To tiles-1
		
		For x=0 To tiles-1
			
			; new Tile
			meshes(x,y)=CreateMeshTile(scale/tsize,tsize+1,x,y)
			EntityFX meshes(x,y),2
			
			; get Surface and Tris per Tile
			surfaces(x,y)=GetSurface(meshes(x,y),1)
			tris(x,y)=CountVertices(surfaces(x,y))
			
			; apply texture
			EntityTexture meshes(x,y),colormap,0,1
			
			; collision
			EntityType meshes(x,y),2
			
		Next
		
	Next
	
	UnlockBuffer TextureBuffer(colormap)
	
End Function


; -------------------------------------------------------------------------------------------------
; Fixes the Chunk normals that no visible seams appear
; -------------------------------------------------------------------------------------------------
Function FixChunkNormals()
	
	Local x%,y%,z%
	Local nx#,ny#,nz#
	Local r%,g%,b%
	
	For y=0 To tiles-1
		
		For x=0 To tiles-1
			
			For z=0 To tsize
				
				; align vertical normals
				nx=VertexNX(surfaces(x,y),tsize+(z*(tsize+1)))
				ny=VertexNY(surfaces(x,y),tsize+(z*(tsize+1)))
				nz=VertexNZ(surfaces(x,y),tsize+(z*(tsize+1)))
				If x&lt;tiles-1 Then VertexNormal surfaces(x+1,y),0+(z*(tsize+1)),nx,ny,nz
				
				; align horizontal normals
				nx=VertexNX(surfaces(x,y),tris(x,y)-(tsize+1)+z)
				ny=VertexNY(surfaces(x,y),tris(x,y)-(tsize+1)+z)
				nz=VertexNZ(surfaces(x,y),tris(x,y)-(tsize+1)+z)
				If y&lt;tiles-1 Then VertexNormal surfaces(x,y+1),z,nx,ny,nz
				
				r=128
				g=128
				b=128
				
				; If set: seams=red
				If Colored Then
					r=255
					g=0
					b=0
				EndIf
				
				VertexColor surfaces(x,y),tsize+(z*(tsize+1)),r,g,b
				If x&lt;tiles-1 Then VertexColor surfaces(x+1,y),(z*(tsize+1)),r,g,b
				VertexColor surfaces(x,y),tris(x,y)-(tsize+1)+z,r,g,b
				If y&lt;tiles-1 Then VertexColor surfaces(x,y+1),z,r,g,b
					
			Next
			
		Next
	Next
	
End Function


; -------------------------------------------------------------------------------------------------
; Creates a single Mesh Terrain Tile with unfixed chunk borders
; -------------------------------------------------------------------------------------------------
Function CreateMeshTile(size%,vertexes,startx%=0,starty%=0)
	
	Local a%,r%,g%,b%,rgb%,v%
	Local mesh%,surface%
	Local xpoint%,ypoint%
	Local zpoint%
	Local tri%,lx%,ly%,h#,index%
	Local texfactor1#=texsize/(xpts-1)
	Local texfactor2#=texsize/(xpts*1.0)
	Local vx#,vz#
	Local sx%=startx*tsize
	Local sy%=starty*tsize
	
	; create mesh and surface
	mesh = CreateMesh()
	surface = CreateSurface(mesh)
	
	Local buffer%=TextureBuffer(colormap)
	
	LockBuffer buffer
	
    ; set vertices
	For xpoint=0 To vertexes-1
		
		For zpoint=0 To vertexes-1
			
			h#=Normalize(PeekShort(heightfield,(((startx*tsize)+zpoint)+((starty*tsize)+xpoint)*xpts)*2)-32767,min,max,minm,maxm)/divider
			
			vx=-(scale/2.0)+(((starty)*tsize)+xpoint)*(scale*1.0/xpts)
			vz=-(scale/2.0)+(((startx)*tsize)+zpoint)*(scale*1.0/xpts)
			
			v=AddVertex (surface,vx,h,vz,((startx*tsize)+zpoint)*texfactor1,((starty*tsize)+xpoint)*texfactor1)
			
			If VertexColors Then
				
				; read texel
				rgb=ReadPixelFast(((startx*tsize)+zpoint)*texfactor2,((starty*tsize)+xpoint)*texfactor2,buffer)
				r=(rgb And $ff0000)/$10000
				g=(rgb And $ff00)/$100
				b=(rgb And $ff)
				
				; set vertexcolor by colormap
				VertexColor surface,v,r,g,b,1
				
			Else
				
				VertexColor surface,v,128,128,128,1.0
				
			EndIf	
			
			
		Next
		
	Next
	
	UnlockBuffer buffer
	
	; create triangles
	For tri = 0 To (vertexes^2)-vertexes-1
		If tri Mod vertexes&lt;&gt;vertexes-1
			AddTriangle (surface,tri,tri+1,tri+vertexes)
			AddTriangle (surface,tri+1,tri+vertexes+1,tri+vertexes)
		EndIf
	Next
	
	UpdateNormals mesh
	
	Return mesh
	
End Function


; -----------------------------------------------------------------------------
; Read Terragen-File and store heightdata to bank
; -----------------------------------------------------------------------------
Function LoadTerragen(filename$)
	
	Local bank%,i%,xpt%,ypt%,h%,h1#,bytes%=16,pos%,off%=0
	Local infoflag$,sizeflag$,xptsflag$,yptsflag$,scalflag$,cradflag$,crvmflag$,altwflag$,endflag$
	
	; open stream
	Local file=ReadFile(filename$)
	
	; Terragen-Header available?
	For i=1 To 16 : infoflag=infoflag+Chr(ReadByte(file)) : Next
	If infoflag&lt;&gt;"TERRAGENTERRAIN " Then RuntimeError "No valid Terragen Header found!"
	
	; SIZE-Flag available?
	For i=1 To 4 : sizeflag=sizeflag+Chr(ReadByte(file)) : Next
	If sizeflag&lt;&gt;"SIZE" Then RuntimeError "No SIZE Flag found!" Else size=ReadInt(file) : bytes=bytes+4+4
	
	; XPTS-Flag available?
	For i=1 To 4 : xptsflag=xptsflag+Chr(ReadByte(file)) : Next
	If xptsflag&lt;&gt;"XPTS" Then RuntimeError "No XPTS Flag found!" Else xpts=ReadInt(file) : bytes=bytes+4+4
	
	; YPTS-Flag available?
	For i=1 To 4 : yptsflag=yptsflag+Chr(ReadByte(file)) : Next
	If yptsflag&lt;&gt;"YPTS" Then RuntimeError "No YPTS Flag found!" Else ypts=ReadInt(file) : bytes=bytes+4+4
	
	; SCAL-Flag available?
	For i=1 To 4 : scalflag=scalflag+Chr(ReadByte(file)) : Next
	If scalflag&lt;&gt;"SCAL" Then RuntimeError "No SCAL Flag found!" Else xscale#=ReadFloat(file) : yscale#=ReadFloat(file) : zscale#=ReadFloat(file) : bytes=bytes+4+4+4+4
	
	; CRAD-Flag available? (optional)
	For i=1 To 4 : cradflag=cradflag+Chr(ReadByte(file)) : Next
	If cradflag&lt;&gt;"CRAD" Then SeekFile file,FilePos(file)-4 : Goto nextcrvm Else crad=ReadFloat(file) : bytes=bytes+4+4
	
	; CRVM-Flag available? (optional)
	.nextcrvm
	For i=1 To 4 : crvmflag=crvmflag+Chr(ReadByte(file)) : Next
	If crvmflag&lt;&gt;"CRVM" Then SeekFile file,FilePos(file)-4 : Goto nextaltw Else crvm=ReadFloat(file) : bytes=bytes+4+4
	
	; ALTW-Flag available?
	.nextaltw
	For i=1 To 4 : altwflag=altwflag+Chr(ReadByte(file)) : Next
	If altwflag&lt;&gt;"ALTW" Then RuntimeError "No ALTW Flag found!" Else hscale=ReadShort(file) : hbase=ReadShort(file) : bytes=bytes+4+2+2
	
	; Banksize = x*y*2
	heightfield=CreateBank(xpts*ypts*2)
	
	; read height data
	For ypt=ypts To 1 Step -1
		
		For xpt=1 To xpts Step 1
			
			; get 16bit height info and convert to signed integer
			h=ReadShort(file)-32767
			
			; calc minimum/maximum height
			If h&lt;=min Then min=h
			If h&gt;=max Then max=h
			
			; put height data to bank
			PokeShort heightfield,((xpt-1)+(ypt-1)*xpts)*2,h
			
		Next
	
	Next
	
	; close stream
	CloseFile(file)
	
	; calc number of tiles and tilesize
	tiles%=(xpts-1)/tilesize
	tsize%=(xpts-1)/tiles
	
	; get minimum/maximum height
	minm#=(hbase+((min*hscale)/65536.0))*scale/xpts*(xpts/1025.0)
	maxm#=(hbase+((max*hscale)/65536.0))*scale/xpts*(xpts/1025.0)
	
	Dim meshes(tiles,tiles),surfaces(tiles,tiles),tris(tiles,tiles),vertex(tilesize,tilesize)
	
End Function


; -----------------------------------------------------------------------------
; Normalize a value
; -----------------------------------------------------------------------------
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


; -------------------------------------------------------------------------------------------------
; Create a simple quad, with alpha and fx
; -------------------------------------------------------------------------------------------------
Function CreateQuad(r%=255,g%=255,b%=255,alpha#=1.0,fx%=0)
	
	Local mesh%,surface%,v1%,v2%,v3%,v4%
	
	mesh=CreateMesh()
	surface=CreateSurface(mesh)
	
	v1=AddVertex (surface,-1,1,0,1,0)
	v2=AddVertex (surface,1,1,0,0,0)
	v3=AddVertex (surface,-1,-1,0,1,1)
	v4=AddVertex (surface,1,-1,0,0,1)
	
	VertexColor surface,v1,r,g,b,alpha
	VertexColor surface,v3,r,g,b,alpha
	VertexColor surface,v2,r,g,b,alpha
	VertexColor surface,v4,r,g,b,alpha
	
	AddTriangle(surface,0,1,2)
	AddTriangle(surface,3,2,1)
	
	EntityFX mesh,fx
	
	FlipMesh mesh
	
	Return mesh
	
End Function
;~IDEal Editor Parameters:
;~C#Blitz3D</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Excuse me. NOT a help forum. Stick this somewhere else. Talk about confusing an issue.<br><br>That's real impressive code, but it's not the right place to post this... I reupdated the code, fixing the UV glitch (which someone isn't seeming to understand...) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> And I just added my code because it is based and related to Ross' code. The next one will get its own code archive entry. And yes - Darkshadowwing - if you need assistance this is the wrong subforum, post it into "Blitz 3D Programming". This forum here is some kind of showcase where you can improve the code or comment it. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Thank you :o) (I really like your extended code btw!) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Just wait for the next version. You will LOVE it :-) Here ist a small candy snapshot preview:<br><br><img src="http://www.christianhart.de/bb/monkeyisland_new1.jpg"> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> *Drools* <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
