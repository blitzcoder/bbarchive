<!DOCTYPE html><html lang="en" ><head ><title >Vent_lib. A B3D-like vector GFX system</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='Duplicates the B3D commandset for vector entities, language=bb, category=3D Graphics - Mesh'><meta name='author' content='big10p'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=12>3D Graphics - Mesh</a>/Vent_lib. A B3D-like vector GFX system</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="3092.bb">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vent_lib. A B3D-like vector GFX system by big10p</td><td align="right">2013 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> This lib duplicates the B3D commandset for vector GFX entities. I wrote this years ago, so can't remember if I completed it, or not. However, most of the functionality is there, at least.<br><br>This lib is a bit of a monster, so has had to be split into 2 parts. Part 1 is below, followed by part 2 in the following post. Copy/paste part 1 into the IDE, then copy/paste part 2, directly after it. Now, save the file as 'vent_lib.bb'. </td></tr><tr ><td class="cell"><pre class="code">;
; (vent_lib.bb)
;
; VentLib - 2D Vector Entity System Library.
;
;
;


	;
	; Constants.
	;

	Const VL_VERT_BUFF_SIZE% = 100
	Const VL_LINE_BUFF_SIZE% = 100
	
	Const VL_PICK_MODE_NONE%		= 0
	Const VL_PICK_MODE_CIRCLE%	= 1
	Const VL_PICK_MODE_POLY%		= 2
	Const VL_PICK_MODE_BOX%			= 3

	Const VL_CLASS_PIVOT%	= 0
	Const VL_CLASS_MESH%	= 1	

	;
	; Globals.
	;
	
	; Linked list of all pickable entities.
	Global vl_first_pickable.vl_elinkT = Null
	
	; Tform command results.
	Global vl_tformed_x#
	Global vl_tformed_y#

	; Screen scale metrics.
	Global vl_screen_units_x#		= 10.0
	Global vl_screen_units_y#
	Global vl_unit_size_pixels#
	
	; Default vertex render size.
	Global vl_vertex_size% = 0
	
	; Default vector line flicker intensity.
	Global vl_vector_flicker# = 0;.25
	
	; vl__lines_intersect_xy(), vl__line_intersects_circle() results.
	Global vl_intersect_x#
	Global vl_intersect_y#	
	
	; Latest pick status variables.
	Global vl_picked_entity.vl_entityT	= Null
	Global vl_picked_line%							= -1
	Global vl_picked_x#									= 0.0
	Global vl_picked_y#									= 0.0
	Global vl_picked_nx#								= 0.0
	Global vl_picked_ny#								= 0.0
	
	; Latest picked point and pick line deltas from pick origin - needed for vl_picked_time().
	Global vl_picked_dx#								= 0.0
	Global vl_picked_dy#								= 0.0
	Global vl_pick_line_dx#							= 0.0
	Global vl_pick_line_dy#							= 0.0

	
	;
	; Types.
	;
	
	; Main entity type.
		
	Type vl_entityT
		Field visuals.vl_visualsT					; Visual data required by mesh class entities.

		Field x#													; Local X coord of entity origin.
		Field y#													; Local Y coord of entity origin.
		Field scale_x#										; Local X scale of entity.
		Field scale_y#										; Local Y scale of entity.
		Field rot#												; Local rotation angle of entity.

		Field parent.vl_entityT						; Entity's parent entity.
		Field first_child.vl_elinkT				; Linked list of child entities.

		Field class%											; Entity class type.
		Field hidden%											; Visibility status (can be overidden if parent is hidden).
		Field name$												; Entity name.
		Field pick_mode%									; Entity pick mode.
		Field obscurer%										; Entity obscurer status used by vl_entity_visible().
		Field radius#											; Entity pick radius.
		Field box_x#											; Entity pick box X position.
		Field box_y#											; Entity pick box Y position.
		Field box_width#									; Entity pick box width.
		Field box_height#									; Entity pick box height.
	End Type

	; Mesh entity visual data type.
	
	Type vl_visualsT
		Field mesh.vl_meshT								; Entity mesh data.

		Field order%											; Draw order.
		Field r%, g%, b%									; Entity color.
		Field brightness#									; Entity brightness.
		
		Field draw_me%										; Flags to renderer whether entity is to be drawn, or not.
		Field vert_x#[VL_VERT_BUFF_SIZE]	; Transformed vertices buffer - X coords.
		Field vert_y#[VL_VERT_BUFF_SIZE]	; Transformed vertices buffer - Y coords
	End Type

	; Mesh type.
		
	Type vl_meshT
		Field first_user.vl_elinkT					; Linked list of entities using this mesh.
		
		Field last_vert_i%									; Index of last defined vertex.
		Field vert_x#[VL_VERT_BUFF_SIZE]		; Mesh vertices buffer - X coords.
		Field vert_y#[VL_VERT_BUFF_SIZE]		; Mesh vertices buffer - Y coords.
		
		Field last_line_i%									; Index of last defined line.
		Field line_v0_i%[VL_LINE_BUFF_SIZE]	; Mesh vector line buffer - start coords.
		Field line_v1_i%[VL_LINE_BUFF_SIZE]	; Mesh vector line buffer - end coords.
		Field line_hard%[VL_LINE_BUFF_SIZE] ; Flags indicating if line is hard(1) or soft(0).
	End Type


	; Entity linked list type.
	
	Type vl_elinkT
		Field entity.vl_entityT			; Entity being referenced.
		Field next_elink.vl_elinkT	; Next entity link in list.
	End Type








;
;
;
Function vl_graphics(width%, height%, depth% = 0, mode% = 0)

	Graphics width, height, depth, mode

	vl_scale_graphics(vl_screen_units_x)
	
End Function


;
;
;
Function vl_scale_graphics(scale#)

	vl_screen_units_x		= scale
	vl_screen_units_y		= vl_screen_units_x * (Float(GraphicsHeight()) / GraphicsWidth())
	vl_unit_size_pixels	= (GraphicsWidth() - 1.0) / vl_screen_units_x

End Function


;
;
;
Function vl_graphics_width#()

	Return vl_screen_units_x

End Function


;
;
;
Function vl_graphics_height#()

	Return vl_screen_units_y

End Function


;
; Renders all visible entities to the currently set drawing buffer.
;
Function vl_render_world(clear% = True)

	;
	; Reset all entity render flags.
	;
	
	For visuals.vl_visualsT = Each vl_visualsT

		visuals\draw_me = False

	Next
	

	;
	; Transform all visible entities into actual screen coords.
	;
	
	For this.vl_entityT = Each vl_entityT

		If (this\parent = Null) And (Not this\hidden)

			If this\class = VL_CLASS_MESH
				; This entity has no parent so it's local coord system IS the global coord system.
				vl__tform_entity(this, this\x, this\y, this\rot, this\scale_x, this\scale_y)
			EndIf
						
			; Recursively tranform all this entity's children.
			If this\first_child &lt;&gt; Null
				vl__tform_children(this, this\x, this\y, this\rot, this\scale_x, this\scale_y)
			EndIf

		EndIf

	Next

	
	;
	; Draw all visible entities.
	;
	
	red		= ColorRed() 
	green	= ColorGreen()
	blue	= ColorBlue()

	If clear Then Cls
	
	LockBuffer GraphicsBuffer()

	If vl_vertex_size ; Draw vector lines AND verts...

		For visuals.vl_visualsT = Each vl_visualsT
	
			If visuals\draw_me
		
				mesh.vl_meshT = visuals\mesh
				
				brightness# = visuals\brightness
				flicker# = 1.0 - Rnd(0.0, vl_vector_flicker)
				r = (visuals\r * brightness) * flicker
				g = (visuals\g * brightness) * flicker
				b = (visuals\b * brightness) * flicker
		
				Color r, g, b
				
				;
				; Draw all lines defined in this mesh.
				;
				
				For i = 0 To mesh\last_line_i
		
					; Get line start and end vertex indices.
					v0_i = mesh\line_v0_i[i]
					v1_i = mesh\line_v1_i[i]
					
					; Draw vector line.
					Line visuals\vert_x[v0_i], visuals\vert_y[v0_i], visuals\vert_x[v1_i], visuals\vert_y[v1_i]
		
				Next
		
				;				
				; Draw verts at double brightness.
				;
				
				If r &gt;= 128 Then r = 255 Else r = (r Shl 1)
				If g &gt;= 128 Then g = 255 Else g = (g Shl 1)
				If b &gt;= 128 Then b = 255 Else b = (b Shl 1)

				Color r, g, b
	
				If vl_vertex_size = 1 ; Draw simple 1x1 verts...
				
					For i = 0 To mesh\last_vert_i
			
						vx# = visuals\vert_x[i]
						vy# = visuals\vert_y[i]
						
						Line vx, vy, vx, vy
			
					Next

				Else ; Draw 3x3 verts...

					For i = 0 To mesh\last_vert_i
			
						vx# = visuals\vert_x[i]
						vy# = visuals\vert_y[i]
						
						Line vx-1, vy, vx+1, vy
						Line vx, vy-1, vx, vy+1
			
					Next

				EndIf
										
			EndIf

		Next

	Else ; Draw vector lines only...
	
		For visuals.vl_visualsT = Each vl_visualsT
	
			If visuals\draw_me
			
				mesh.vl_meshT = visuals\mesh
				
				brightness# = visuals\brightness
				flicker# = 1.0 - Rnd(0.0, vl_vector_flicker)
				r = (visuals\r * brightness) * flicker
				g = (visuals\g * brightness) * flicker
				b = (visuals\b * brightness) * flicker

				Color r, g, b
		
				;
				; Draw all lines defined in this mesh.
				;
				
				For i = 0 To mesh\last_line_i
		
					; Get line start and end vertex indices.
					v0_i = mesh\line_v0_i[i]
					v1_i = mesh\line_v1_i[i]
					
					; Draw vector line.
					Line visuals\vert_x[v0_i], visuals\vert_y[v0_i], visuals\vert_x[v1_i], visuals\vert_y[v1_i]
		
				Next
		
				;x# = vl_screen(vl__entity_x(this, True))
				;y# = vl_screen(vl__entity_y(this, True))
				;Line x, y, x, y

			EndIf

		Next

	EndIf
	
	UnlockBuffer GraphicsBuffer()
	
	; Reinstate original color.
	Color red, green, blue
	 
End Function


;
; Sets the flicker intensity to use when drawing vector lines.
;
; Params:
; value - Level of flicker to use. 0 = extreme flicker, 1 = no flicker.
;
Function vl_vector_flicker(value#)

	If value &lt; 0.0

		value = 0.0

	ElseIf value &gt; 1.0

		value = 1.0

	EndIf
	
	vl_vector_flicker = value

End Function


;
; Sets the size vertices should be drawn at.
;
; params:
; size - Size level all vertices are to be drawn at.
;        0 = Vertices are not drawn.
;        1 = Vertices are drawn using a single pixel.
;        2 = Vertices are drawn using a 3x3 pixel cross.
;
Function vl_vertex_size(size%)

	If size =&lt; 0

		vl_vertex_size = 0

	ElseIf size &gt;= 2

		vl_vertex_size = 2

	Else

		vl_vertex_size = 1

	EndIf

End Function


;
; Creates a blank mesh entity. Geometry can then be added to this mesh
; by using the vl_add_vertex and vl_add_line commands.
;
; Params:
; parent_ID - Handle of entity to be made the new mesh entity's parent.
;             The new mesh entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created mesh entity.
;
Function vl_create_mesh(parent_ID% = 0)

	entity.vl_entityT		= New vl_entityT
	visuals.vl_visualsT	= New vl_visualsT
	mesh.vl_meshT				= New vl_meshT

	entity_ID = Handle(entity)

	; Initialize new entity.
	
	entity\visuals			= visuals

	If parent_ID Then vl__add_child(Object.vl_entityT(parent_ID), entity)

	entity\first_child	= Null

	entity\x						= 0.0
	entity\y						= 0.0
	entity\scale_x			= 1.0
	entity\scale_y			= 1.0
	entity\rot					= 0.0

	entity\class 				= VL_CLASS_MESH
	entity\hidden				= False
	entity\name					= ""
	entity\pick_mode		= VL_PICK_MODE_NONE
	entity\obscurer			= False
	entity\radius				= 1.0
	entity\box_x				= -1.0
	entity\box_y				= -1.0
	entity\box_width		= 2.0
	entity\box_height		= 2.0

	; Initialize new entity visual data.	

	visuals\mesh				= mesh
	
	vl__entity_order(entity, 0)

	visuals\r						= 255
	visuals\g						= 255
	visuals\b						= 255
	visuals\brightness	= 0.5
	
	; Initialize new mesh.
		
	vl__add_user(mesh, entity)
	
	mesh\last_vert_i	= -1
	mesh\last_line_i	= -1

	Return entity_ID

End Function


;
; Creates a polygon mesh entity.
;
; Params:
; sides     - Number of sides the polygon should have.
; parent_ID - Handle of entity to be made the new mesh entity's parent.
;             The new mesh entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created polygon mesh entity.
;
Function vl_create_polygon(sides% = 3, parent_ID% = 0)

	mesh = vl_create_mesh(Parent_ID)
	
	total_verts	= sides
	vert_ang#		= 0.0
	delta_ang#	= 360.0 / sides

	; Add verts for all corners of polygon.
	For n = 0 To total_verts - 1

		vl_add_vertex(mesh, Cos(vert_ang), Sin(vert_ang))

		vert_ang = vert_ang + delta_ang
	Next	

	; Add vector lines.
	For n = 0 To total_verts - 2

		vl_add_line(mesh, n, n + 1)

	Next

	vl_add_line(mesh, total_verts - 1, 0)
	
	Return mesh
	
End Function


;
; Creates a box/square mesh entity.
;
; Params:
; parent_ID - Handle of entity to be made the new mesh entity's parent.
;             The new mesh entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created box mesh entity.
;
Function vl_create_box(parent_ID% = 0)

	mesh = vl_create_mesh(Parent_ID)
	
	vl_add_vertex(mesh,  1, -1)
	vl_add_vertex(mesh,  1,  1)
	vl_add_vertex(mesh, -1,  1)
	vl_add_vertex(mesh, -1, -1)

	vl_add_line(mesh, 0, 1)
	vl_add_line(mesh, 1, 2)
	vl_add_line(mesh, 2, 3)
	vl_add_line(mesh, 3, 0)
	
	Return mesh
	
End Function


;
; Creates a star-shaped mesh entity.
;
; Params:
; points    - Number of points the star should have.
; indent    - Sets the 'depth' of the indent between the points of the star.
; parent_ID - Handle of entity to be made the new mesh entity's parent.
;             The new mesh entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created star mesh entity.
;
Function vl_create_star(points% = 5, indent# = 0.5, parent_ID% = 0)

	mesh = vl_create_mesh(Parent_ID)
	
	total_verts	= points * 2
	vert_ang#		= 0.0
	delta_ang#	= 360.0 / total_verts

	; Add verts for all star points &amp; indents.
	For n = 0 To total_verts - 1

		If (n And 1) Then size# = indent Else size# = 1.0

		vl_add_vertex(mesh, Cos(vert_ang) * size, Sin(vert_ang) * size)

		vert_ang = vert_ang + delta_ang

	Next

	; Add vector lines.
	For n = 0 To total_verts - 2

		vl_add_line(mesh, n, n + 1)

	Next

	vl_add_line(mesh, total_verts - 1, 0)

	Return mesh
	
End Function


;
; Creates a pivot entity.
;
; Params:
; parent_ID - Handle of entity to be made the new pivot entity's parent.
;             The new pivot will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created pivot entity.
;
Function vl_create_pivot(parent_ID% = 0)

	entity.vl_entityT		= New vl_entityT

	entity_ID = Handle(entity)

	; Initialize new entity.
	
	entity\visuals			= Null 

	If parent_ID Then vl__add_child(Object.vl_entityT(parent_ID), entity)

	entity\first_child	= Null

	entity\x						= 0.0
	entity\y						= 0.0
	entity\scale_x			= 1.0
	entity\scale_y			= 1.0
	entity\rot					= 0.0

	entity\class 				= VL_CLASS_PIVOT
	entity\hidden				= False
	entity\name					= ""
	entity\pick_mode		= VL_PICK_MODE_NONE
	entity\obscurer			= False
	entity\radius				= 1.0
	entity\box_x				= -1.0
	entity\box_y				= -1.0
	entity\box_width		= 2.0
	entity\box_height		= 2.0

	Return entity_ID

End Function


;
; Creates a point entity. Point entities disply as a single pixel when rendered.
;
; Params:
; parent_ID - Handle of entity to be made the new point entity's parent.
;             The new point entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created point entity.
;
Function vl_create_point(parent_ID% = 0)

	mesh = vl_create_mesh(Parent_ID)
	
	vl_add_vertex(mesh, 0, 0)

	vl_add_line(mesh, 0, 0)
	
	Return mesh

End Function


;
; Deletes an entity and frees all it's resources. All the entity's children are also freed.
;
; Params:
; entity_ID  - Handle of entity to be freed.
;
Function vl_free_entity(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	; Recursively free any child entities.
	If entity\first_child &lt;&gt; Null Then vl__free_children(entity)

	If entity\class = VL_CLASS_MESH	

		mesh.vl_meshT = entity\visuals\mesh
		vl__delete_user(mesh, entity)
		
		; Delete this mesh if no other entities are using it.
		If mesh\first_user = Null Then Delete mesh
	
		Delete entity\visuals

	EndIf

	If entity\pick_mode Then vl__delete_pickable(entity)

	If entity\parent &lt;&gt; Null Then vl__delete_child(entity)
	
	Delete entity
			
End Function


;
; Rotates all the vertices of a mesh by the specified rotation angle.
;
; Params:
; entity_ID  - Handle of entity referencing the mesh to be rotated.
; rot        - Angle to rotate the mesh by.
;
Function vl_rotate_mesh(entity_ID%, rot#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	mesh.vl_meshT = entity\visuals\mesh

	cos_rot# = Cos(rot)
	sin_rot# = Sin(rot)

	For i = 0 To mesh\last_vert_i

		vert_x# = mesh\vert_x[i]
		vert_y# = mesh\vert_y[i]

		mesh\vert_x[i] = (vert_x * cos_rot) - (vert_y * sin_rot)
		mesh\vert_y[i] = (vert_y * cos_rot) + (vert_x * sin_rot)
		
	Next

End Function


;
; Moves/Offsets all vertices of a mesh by the specified x,y amounts.
;
; Params:
; entity_ID  - Handle of entity referencing the mesh to be positioned.
; x          - X amount to move all vertices by.
; y          - Y amount to move all vertices by.
;
Function vl_position_mesh(entity_ID%, x#, y#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh

	For i = 0 To mesh\last_vert_i

		mesh\vert_x[i] = mesh\vert_x[i] + x
		mesh\vert_y[i] = mesh\vert_y[i] + y
		
	Next

End Function


;
; Adds a copy of one mesh to another mesh.
;
; Params:
; source_entity_ID - Handle of entity referencing the mesh to be copied.
; dest_entity_ID   - Handle of entity referencing the mesh to be added to.
; hardness         - Indicates what hardness the copied mesh lines should be given
;                    when added to the destination mesh:
;                    0 = Set all lines to be soft (unpickable).
;                    1 = Set all lines to be hard (pickable).
;                    2 = (default) Keep lines same as defined in source mesh.
;
Function vl_add_mesh(source_entity_ID%, dest_entity_ID%, hardness% = 2)

	If hardness &lt; 0 Then hardness = 0
	
	source_entity.vl_entityT = Object.vl_entityT(source_entity_ID)
	source_mesh.vl_meshT = source_entity\visuals\mesh

	dest_entity.vl_entityT = Object.vl_entityT(dest_entity_ID)
	dest_mesh.vl_meshT = dest_entity\visuals\mesh

	; Copy all vertices from source mesh to destination mesh.
	
	vert_i_offset = dest_mesh\last_vert_i + 1
	dest_mesh\last_vert_i = dest_mesh\last_vert_i + source_mesh\last_vert_i + 1
	
	For i = 0 To source_mesh\last_vert_i

		dest_mesh\vert_x[vert_i_offset + i] = source_mesh\vert_x[i]
		dest_mesh\vert_y[vert_i_offset + i] = source_mesh\vert_y[i]
		
	Next

	; Copy all vector lines from source mesh to destination mesh.
	
	line_i_offset = dest_mesh\last_line_i + 1
	dest_mesh\last_line_i = dest_mesh\last_line_i + source_mesh\last_line_i + 1
	
	If hardness &lt; 2 ; Set lines to specified hardness...

		For i = 0 To source_mesh\last_line_i
	
			dest_mesh\line_v0_i[line_i_offset + i] = source_mesh\line_v0_i[i] + vert_i_offset
			dest_mesh\line_v1_i[line_i_offset + i] = source_mesh\line_v1_i[i] + vert_i_offset
			dest_mesh\line_hard[line_i_offset + i] = hardness
	
		Next

	Else ; Keep source mesh's line hardness...
	
		For i = 0 To source_mesh\last_line_i
	
			dest_mesh\line_v0_i[line_i_offset + i] = source_mesh\line_v0_i[i] + vert_i_offset
			dest_mesh\line_v1_i[line_i_offset + i] = source_mesh\line_v1_i[i] + vert_i_offset
			dest_mesh\line_hard[line_i_offset + i] = source_mesh\line_hard[i]
	
		Next

	EndIf
			
End Function


;
; Creates a copy of an existing mesh.
;
; Params:
; entity_ID - Handle of entity whose mesh is to be copied.
; parent_ID - Handle of entity to be made the new mesh entity's parent.
;             The new mesh entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created mesh entity.
;
Function vl_copy_mesh(entity_ID%, parent_ID% = 0)

	new_mesh_ID = vl_create_mesh(parent_ID)
	
	vl_add_mesh(entity_ID, new_mesh_ID)
	
	Return new_mesh_ID
	
End Function


;
; Scales all vertices of a mesh by the specified x,y factors.
;
; Params:
; entity_ID  - Handle of entity referencing the mesh to be scaled.
; x          - X factor to scale all vertices by.
; y          - Y factor to scale all vertices by.
;
Function vl_scale_mesh(entity_ID%, scale_x#, scale_y#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh

	For i = 0 To mesh\last_vert_i

		mesh\vert_x[i] = mesh\vert_x[i] * scale_x
		mesh\vert_y[i] = mesh\vert_y[i] * scale_y
		
	Next

End Function


;
; Flips all vector lines of a mesh so they face the opposite way.
;
; Params:
; entity_ID  - Handle of entity referencing the mesh to be flipped.
;
Function vl_flip_mesh(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh

	For i = 0 To mesh\last_line_i

		temp_v0_i = mesh\line_v0_i[i]
		
		mesh\line_v0_i[i] = mesh\line_v1_i[i]
		mesh\line_v1_i[i] = temp_v0_i
		
	Next

End Function


;
; Scales and translates all vertices of a mesh so that the mesh occupies the specified box.
;
; Params:
; entity_ID  - Handle of entity referencing the mesh to be made to fit the box.
; x          - X coord of the corner of the fit box.
; y          - Y coord of the corner of the fit box.
; width      - Width of the fit box.
; height     - Height of the fit box.
; uniform    - False (default) to fit the mesh exactly inside the fit box.
;              True to scale verts uniformly so as to retain the mesh's aspect ratio.
;
Function vl_fit_mesh(entity_ID%, x#, y#, width#, height#, uniform% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh

	If mesh\last_vert_i = -1 Then Return


	;
	; Find mesh width/height and x,y offset needed to centre the mesh inside the defined box (this is
	; required for meshes whose origin isn't at the dead-centre of the bounding box of it's verts).
	;
		
	biggest_x#	= mesh\vert_x[0]
	smallest_x#	= biggest_x
	biggest_y#	= mesh\vert_y[0]
	smallest_y#	= biggest_y

	For i = 1 To mesh\last_vert_i

		vert_x# = mesh\vert_x[i]

		If vert_x &gt; biggest_x
			biggest_x = vert_x
		ElseIf vert_x &lt; smallest_x
			smallest_x = vert_x
		EndIf

		vert_y# = mesh\vert_y[i]

		If vert_y &gt; biggest_y
			biggest_y = vert_y
		ElseIf vert_y &lt; smallest_y
			smallest_y = vert_y
		EndIf
		
	Next

	mesh_width# = biggest_x - smallest_x
	offset_x# = (biggest_x - mesh_width) + (mesh_width / 2.0)

	mesh_height# = biggest_y - smallest_y
	offset_y# = (biggest_y - mesh_height) + (mesh_height / 2.0)


	;
	; Change all mesh verts to fit inside the defined box.
	;

	; Find centre of defined box.
	origin_x# = x + (width / 2.0)
	origin_y# = y + (height / 2.0)

	If uniform ; Keep mesh aspect ratio...

		If mesh_width &gt; mesh_height
			height = (width * (mesh_height / mesh_width)) * Sgn(height)
		Else
			width = (height * (mesh_width / mesh_height)) * Sgn(width)
		EndIf

	EndIf

	scale_x# = width / mesh_width
	scale_y# = height / mesh_height
		
	For i = 0 To mesh\last_vert_i

		mesh\vert_x[i] = origin_x + ((mesh\vert_x[i] - offset_x) * scale_x)
		mesh\vert_y[i] = origin_y + ((mesh\vert_y[i] - offset_y) * scale_y)
		
	Next

End Function


;
; Removes all vertices and/or vector lines from a mesh.
;
; Params:
; entity_ID   - Handle of entity referencing the mesh to be cleared.
; clear_verts - True (default) to remove al vertices. False not to.
; clear_lines - True (default) to remove al vector lines. False not to.
;
Function vl_clear_mesh(entity_ID%, clear_verts% = True, clear_lines% = True)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh

	If clear_verts Then mesh\last_vert_i = -1

	If clear_lines Then mesh\last_line_i = -1

End Function


;
; Determines whether the specified meshes are intersecting.
;
; Params:
; entity_a_ID - Handle of first mesh to test for intersection.
; entity_b_ID - Handle of second mesh to test for intersection.
;
; Returns:
; True if the two meshes are currently intersecting, False otherwise.
;
Function vl_meshes_intersect(entity_a_ID%, entity_b_ID%)

	; Transform mesh A to world space.
	entity_a.vl_entityT = Object.vl_entityT(entity_a_ID)
	visuals_a.vl_visualsT = entity_a\visuals
	mesh_a.vl_meshT = visuals_a\mesh
	vl__tform_entity_world(entity_a, vl__entity_x(entity_a, True), vl__entity_y(entity_a, True), vl__entity_rotation(entity_a, True), vl__entity_scale_x(entity_a, True), vl__entity_scale_y(entity_a, True))

	; Transform mesh B to world space.
	entity_b.vl_entityT = Object.vl_entityT(entity_b_ID)
	visuals_b.vl_visualsT = entity_b\visuals
	mesh_b.vl_meshT = visuals_b\mesh
	vl__tform_entity_world(entity_b, vl__entity_x(entity_b, True), vl__entity_y(entity_b, True), vl__entity_rotation(entity_b, True), vl__entity_scale_x(entity_b, True), vl__entity_scale_y(entity_b, True))

	If (mesh_a\last_line_i + mesh_b\last_line_i) &gt; 10
		check_meshes = vl__vert_boxes_intersect(entity_a, entity_b)
	Else
		check_meshes = True
	EndIf
	
	If check_meshes ; See if any lines in mesh A intersect with any lines in mesh B...
	
		For a_i = 0 To mesh_a\last_line_i
	
			; Get this mesh A line start and delta.
			v0_i = mesh_a\line_v0_i[a_i]
			v1_i = mesh_a\line_v1_i[a_i]
	
			x1# = visuals_a\vert_x[v0_i]
			y1# = visuals_a\vert_y[v0_i]
	
			dx1# = visuals_a\vert_x[v1_i] - x1
			dy1# = visuals_a\vert_y[v1_i] - y1
	
			For b_i = 0 To mesh_b\last_line_i
	
				; Get this mesh B line start and delta.
				v0_i = mesh_b\line_v0_i[b_i]
				v1_i = mesh_b\line_v1_i[b_i]
		
				x2# = visuals_b\vert_x[v0_i]
				y2# = visuals_b\vert_y[v0_i]
		
				dx2# = visuals_b\vert_x[v1_i] - x2
				dy2# = visuals_b\vert_y[v1_i] - y2
	
				If vl__lines_intersect(x1, y1, dx1, dy1,  x2, y2, dx2, dy2) Then Return True
	
			Next
			
		Next
	
	EndIf
		
	Return False
	
End Function


;
; Returns the width of a mesh.
;
; Params:
; entity_ID - Handle of entity whose width is to be returned.
;
; Returns:
; The given entity's mesh width.
;
Function vl_mesh_width#(entity_ID%)

	Return vl__mesh_width(Object.vl_entityT(entity_ID))

End Function


;
; Returns the height of a mesh.
;
; Params:
; entity_ID - Handle of entity whose height is to be returned.
;
; Returns:
; The given entity's mesh height.
;
Function vl_mesh_height#(entity_ID%)

	Return vl__mesh_height(Object.vl_entityT(entity_ID))

End Function


;
; Returns the parent of an entity.
;
; Params:
; entity_ID - Handle of entity whose parent is to be returned.
;
; Returns:
; The handle of the given entity's parent.
;
Function vl_get_parent(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	Return Handle(entity\parent)

End Function


;
; Returns the child of an entity.
;
; Params:
; entity_ID - Handle of entity whose child is to be returned.
; child_num - Number of child to get. Range is 1 to vl_count_children().
;
; Returns:
; The handle of the given entity's child.
;
Function vl_get_child(entity_ID%, child_num)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	child_link.vl_elinkT = entity\first_child
	child.vl_entityT = Null
	count = 1
	
	While child_link &lt;&gt; Null
	
		If count = child_num Then Return Handle(child_link\entity)
		
		count = count + 1
		child_link = child_link\next_elink

	Wend

End Function


;
; Returns the first child of an entity with the given name. All the entity's 
; children and sub-children are searched, via recursion.
;
; Params:
; entity_ID - Handle of entity whose named child is to be returned.
; name      - The name of the child to find (case sensitive).
;
; Returns:
; The handle of the given entity's first child with the specified name.
;
Function vl_find_child(entity_ID%, name$)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	If entity\first_child &lt;&gt; Null Then Return Handle(vl__find_child(entity, name$))

End Function


;
; Returns the number of children an entity has.
;
; Params:
; entity_ID - Handle of entity whose children are to be counted.
;
; Returns:
; The total number of immediate children an entity has.
;
Function vl_count_children(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	child_link.vl_elinkT = entity\first_child

	total = 0
	
	While child_link &lt;&gt; Null

		total = total + 1			
		child_link = child_link\next_elink

	Wend

	Return total

End Function


;
; Sets the color of an entity.
;
; Params:
; entity_ID - Handle of entity whose color is to be set.
; r         - Red component of color.
; g         - Green component of color.
; b         - Blue component of color.
;
Function vl_entity_color(entity_ID%, r%, g%, b%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	entity\visuals\r = r
	entity\visuals\g = g
	entity\visuals\b = b

End Function


;
; Sets an entity's brightness.
;
; Params:
; entity_ID - Handle of entity whose brightness is to be set.
; value     - Level of brightness to give the entity. 0 = invisible, 1 = fullbright.
;
Function vl_entity_brightness(entity_ID%, value#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	If value &lt; 0.0

		value = 0.0

	ElseIf value &gt; 1.0

		value = 1.0

	EndIf
	
	entity\visuals\brightness = value

End Function


;
; Returns the name of an entity.
;
; Params:
; entity_ID - Handle of entity whose name is to be returned.
;
; Returns:
; The given entity's name.
;
Function vl_entity_name$(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	Return entity\name$

End Function


;
; Returns the class of an entity.
;
; Params:
; entity_ID - Handle of entity whose class is to be returned.
;
; Returns:
; A string describing the class of the given entity.
;
Function vl_entity_class$(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	If entity\class
	
		Return "Mesh"
		
	Else
	
		Return "Pivot"
		
	EndIf

End Function


;
; Sets the name of an entity.
;
; Params:
; entity_ID - Handle of entity whose name is to be set.
; name      - Name to give the entity.
;
Function vl_name_entity(entity_ID%, name$)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	entity\name$ = name$

End Function


;
; Sets the drawing order of an entity.
;
; Params:
; entity_ID - Handle of entity whose draw order is to be set.
; order     - Order the entity will be drawn in.
;
Function vl_entity_order(entity_ID%, order%)

	vl__entity_order(Object.vl_entityT(entity_ID), order)
	
End Function


;
; Sets an entity's pick mode.
;
; Params:
; entity_ID - Handle of entity whose pick mode is to be set.
; mode      - Mode of geometry to be used when picking the entity:
;             0 = None (unpickable)
;             1 = Circle (vl_entity_radius is used)
;             2 = Polygon (uses the polygon defined by the mesh's vector lines)
;             3 = Box (vl_entity_box is used)
; obscurer  - True (default) to determine the entity 'obscures' other entities
;             during a vl_entity_visible() call. 
;
Function vl_entity_pick_mode(entity_ID%, mode%, obscurer% = True)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	If mode &lt; 0
	
		mode = 0
		
	ElseIf mode &gt; 3
	
		mode = 3
		
	EndIf
	
	vl__entity_pick_mode(entity, mode, obscurer)
	
End Function


;
; Returns the nearest pickable entity ahead of the specified entity.
;
; Params:
; entity_ID - Handle of entity to pick ahead of.
; range#    - Distance to pick ahead of entity by.
;
Function vl_entity_pick(entity_ID%, range#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	; Temporarily assert entity is hidden to ensure it isn't included in the pick.
	hidden = entity\hidden
	entity\hidden = True
	
	rot# = vl__entity_rotation(entity, True)
	vl_line_pick(vl__entity_x(entity, True), vl__entity_y(entity, True), (Cos(rot) * range), (Sin(rot) * range))

	entity\hidden = hidden

	Return Handle(vl_picked_entity)

End Function


;
; Sets the dimensions on an entity's pick box.
;
; Params:
; entity_ID - Handle of entity whose pick box is to be set.
; x         - X position of entity's pick box.
; y         - Y position of entity's pick box.
; width     - Width of entity's pick box.
; height    - Height of entity's pick box.
;
Function vl_entity_box(entity_ID%, x#, y#, width#, height#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	;
	; Ensure box 'winds' clockwise from top-left corner to ensure the normal of a picked
	; box edge can be calculated correctly (i.e. normals need to point outward).
	;
	
	If width &lt; 0.0

		x = x + width
		width = -width

	EndIf

	If height &lt; 0.0

		y = y + height
		height = -height

	EndIf
	
	entity\box_x			= x
	entity\box_y			= y
	entity\box_width	= width
	entity\box_height	= height

End Function


;
; Sets the radius on an entity's pick circle.
;
; Params:
; entity_ID - Handle of entity whose pick circle is to be set.
; radius    - Radius of entity's pick circle.
;
Function vl_entity_radius(entity_ID%, radius#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	entity\radius = radius

End Function


;
; Parents (attaches) one entity to another.
;
; Params:
; entity_ID - Handle of entity to be made a child of parent.
; parent_ID - Handle of entity to be made the parent of entity. 0 sets the entity to have no parent.
; glob      - True (default) for the entity to retain it's global position/rotation/scale.
;             False for the entity to retain it's local position/rotation/scale.
;
Function vl_entity_parent(entity_ID%, parent_ID%, glob% = True)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	If parent_ID ; Parent entity...

		parent.vl_entityT = Object.vl_entityT(parent_ID)

		If (entity = parent) Or (entity\parent = parent) Then Return

		If glob ; Retain entity's global position/rotation/scale...

			pg_scale_x# = vl__entity_scale_x(parent, True)
			pg_scale_y# = vl__entity_scale_y(parent, True)

			; Find global coords of entity, relative to parent.
			dx# = vl__entity_x(entity, True) - vl__entity_x(parent, True)
			dy# = vl__entity_y(entity, True) - vl__entity_y(parent, True)
			
			; Rotate coords into parent's coord system.
			inv_pg_rot# = -vl__entity_rotation(parent, True)

			cos_rot# = Cos(inv_pg_rot)
			sin_rot# = Sin(inv_pg_rot)
			
			x# = (dx * cos_rot) - (dy * sin_rot)
			y# = (dy * cos_rot) + (dx * sin_rot)

			; Scale global coords into parent's global scale.
			entity\x = x / pg_scale_x
			entity\y = y / pg_scale_y

			; Convert global entity rotation to equivalent in parent's coord system.
			entity\rot = vl__clamp_rot(vl__entity_rotation(entity, True) + inv_pg_rot)
			
			; Convert global entity scale to equivalent in parent's scale.
			entity\scale_x = vl__entity_scale_x(entity, True) / pg_scale_x
			entity\scale_y = vl__entity_scale_y(entity, True) / pg_scale_y

		EndIf

		If entity\parent &lt;&gt; Null Then vl__delete_child(entity)

		vl__add_child(parent, entity)
			
	Else ; Un-parent entity...

		If entity\parent &lt;&gt; Null ; Entity does have a parent...
		
			If glob ; Retain entity's global position/rotation/scale...
	
				global_x#				= vl__entity_x(entity, True)
				global_y#				= vl__entity_y(entity, True)
				global_rot#			= vl__entity_rotation(entity, True)
				global_scale_x#	= vl__entity_scale_x(entity, True)
				global_scale_y#	= vl__entity_scale_y(entity, True)
				
				entity\x				= global_x
				entity\y				= global_y
				entity\rot			= global_rot
				entity\scale_x	= global_scale_x
				entity\scale_y	= global_scale_y
			
			EndIf
	
			vl__delete_child(entity)
		
		EndIf
		
	EndIf
		
End Function


;
; Returns an entity's X position coordinate.
;
; Params:
; entity_ID - Handle of entity whose X coord is to be returned.
; glob      - True returns the entity's global X coord.
;             False (default) returns the entity's local X coord.
;
; Returns:
; The given entity's current X coord. 
;
Function vl_entity_x#(entity_ID%, glob% = False)

	Return vl__entity_x(Object.vl_entityT(entity_ID), glob)

End Function


;
; Returns an entity's Y position coordinate.
;
; Params:
; entity_ID - Handle of entity whose Y coord is to be returned.
; glob      - True returns the entity's global Y coord.
;             False (default) returns the entity's local Y coord.
;
; Returns:
; The given entity's current Y coord. 
;
Function vl_entity_y#(entity_ID%, glob% = False)

	Return vl__entity_y(Object.vl_entityT(entity_ID), glob)

End Function


;
; Returns an entity's width.
;
; Params:
; entity_ID - Handle of entity whose width is to be returned.
; glob      - True returns the entity's global width.
;             False (default) returns the entity's local width.
;
; Returns:
; The given entity's current width. 
;
Function vl_entity_width#(entity_ID%, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	If glob
	
		vl__tform_entity_world(entity, vl__entity_x(entity, True), vl__entity_y(entity, True), vl__entity_rotation(entity, True), vl__entity_scale_x(entity, True), vl__entity_scale_y(entity, True))
	
		visuals.vl_visualsT = entity\visuals
		mesh.vl_meshT = visuals\mesh
	
		If mesh\last_vert_i = -1 Then Return 0.0
		
		biggest#	= visuals\vert_x[0]
		smallest#	= biggest
	
		For i = 1 To mesh\last_vert_i
	
			vert_x# = visuals\vert_x[i]
	
			If vert_x &gt; biggest
			
				biggest = vert_x
			
			ElseIf vert_x &lt; smallest
			
				smallest = vert_x
				
			EndIf
			
		Next
	
		Return (biggest - smallest)

	Else
	
		Return Abs(vl__mesh_width(entity) * vl__entity_scale_x(entity, True))
	
	EndIf
	
End Function


;
; Returns an entity's height.
;
; Params:
; entity_ID - Handle of entity whose height is to be returned.
; glob      - True returns the entity's global height.
;             False (default) returns the entity's local height.
;
; Returns:
; The given entity's current height. 
;
Function vl_entity_height#(entity_ID%, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	If glob
	
		vl__tform_entity_world(entity, vl__entity_x(entity, True), vl__entity_y(entity, True), vl__entity_rotation(entity, True), vl__entity_scale_x(entity, True), vl__entity_scale_y(entity, True))
	
		visuals.vl_visualsT = entity\visuals
		mesh.vl_meshT = visuals\mesh
	
		If mesh\last_vert_i = -1 Then Return 0.0
		
		biggest#	= visuals\vert_y[0]
		smallest#	= biggest
	
		For i = 1 To mesh\last_vert_i
	
			vert_y# = visuals\vert_y[i]
	
			If vert_y &gt; biggest
			
				biggest = vert_y
			
			ElseIf vert_y &lt; smallest
			
				smallest = vert_y
				
			EndIf
			
		Next
	
		Return (biggest - smallest)

	Else
	
		Return Abs(vl__mesh_height(entity) * vl__entity_scale_y(entity, True))
	
	EndIf
	
End Function


;
; Returns an entity's angle of rotation.
;
; Params:
; entity_ID - Handle of entity whose rotation is to be returned.
; glob      - True returns the entity's global rotation.
;             False (default) returns the entity's local rotation.
;
; Returns:
; The given entity's current angle of rotation. 
;
Function vl_entity_rotation#(entity_ID%, glob% = False)

	Return vl__entity_rotation(Object.vl_entityT(entity_ID), glob)

End Function


;
; Returns an entity's X axis scale.
;
; Params:
; entity - Entity whose X scale is to be returned.
; glob   - True returns the entity's global X scale.
;          False (default) returns the entity's local X scale.
;
; Returns:
; The given entity's current X axis scale. 
;
Function vl_entity_scale_x#(entity_ID%, glob% = False)

	Return vl__entity_scale_x(Object.vl_entityT(entity_ID), glob)

End Function


;
; Returns an entity's Y axis scale.
;
; Params:
; entity - Entity whose Y scale is to be returned.
; glob   - True returns the entity's global Y scale.
;          False (default) returns the entity's local Y scale.
;
; Returns:
; The given entity's current Y axis scale. 
;
Function vl_entity_scale_y#(entity_ID%, glob% = False)

	Return vl__entity_scale_y(Object.vl_entityT(entity_ID), glob)

End Function


;
; Returns the distance between two entities.
;
; Params:
; entity_a_ID - Handle of first entity.
; entity_b_ID - Handle of second entity.
;
; Returns:
; The absolute distance between the two given entities.
;
Function vl_entity_distance#(entity_a_ID%, entity_b_ID%)

	entity_a.vl_entityT = Object.vl_entityT(entity_a_ID)
	entity_b.vl_entityT = Object.vl_entityT(entity_b_ID)

	dx# = vl__entity_x(entity_a, True) - vl__entity_x(entity_b, True)
	dy# = vl__entity_y(entity_a, True) - vl__entity_y(entity_b, True)

	Return Sqr(dx * dx + dy * dy)

End Function


;
; Determines whether two entities can 'see' each other i.e. there are no pickable, obscurer
; entities between the line-of-sight of the two entities.
;
; Params:
; entity_a_ID - Handle of first entity.
; entity_b_ID - Handle of second entity.
;
; Returns:
; True if both entities can see each other, false otherwise.
;
Function vl_entity_visible(entity_a_ID%, entity_b_ID%)

	entity_a.vl_entityT = Object.vl_entityT(entity_a_ID)
	entity_b.vl_entityT = Object.vl_entityT(entity_b_ID)

	sx# = vl__entity_x(entity_a, True)
	sy# = vl__entity_y(entity_a, True)
	dx# = vl__entity_x(entity_b, True) - sx
	dy# = vl__entity_y(entity_b, True) - sy

	;
	; See if there's any pickable, visible, obscurer entities between the two entities.
	;
	
	pickable.vl_elinkT = vl_first_pickable
	
	While pickable &lt;&gt; Null
	
		this.vl_entityT = pickable\entity
		
		If (this &lt;&gt; entity_a) And (this &lt;&gt; entity_b) And vl__entity_visible(this) And this\obscurer

			;
			; See if this entity is picked, using it's defined pick method.
			;
			
			Select this\pick_mode
			
			Case VL_PICK_MODE_CIRCLE
			
				cx# = vl__entity_x(this, True)
				cy# = vl__entity_y(this, True)
				
				If vl__line_intersects_circle(sx, sy, dx, dy,  cx, cy, this\radius) Then Return False

			Case VL_PICK_MODE_BOX

				rot# = vl__entity_rotation(this, True)
				cos_rot# = Cos(rot)
				sin_rot# = Sin(rot)
		
				trans_x# = (this\box_x * cos_rot) - (this\box_y * sin_rot)
				trans_y# = (this\box_y * cos_rot) + (this\box_x * sin_rot)

				edge_x# = vl__entity_x(this, True) + trans_x
				edge_y# = vl__entity_y(this, True) + trans_y
		
				width_dx#		= cos_rot * this\box_width
				width_dy#		= sin_rot * this\box_height
				height_dx#	= Cos(rot + 90) * this\box_width
				height_dy#	= Sin(rot + 90) * this\box_height
		
				For n = 1 To 4
				
					; Set correct delta for current edge being tested.
					Select n
					Case 1 ; Top.
						edge_dx# = width_dx
						edge_dy# = width_dy
					Case 2 ; Right.
						edge_dx# = height_dx
						edge_dy# = height_dy
					Case 3 ; Bottom.
						edge_dx# = -width_dx
						edge_dy# = -width_dy
					Case 4 ; Left.
						edge_dx# = -height_dx
						edge_dy# = -height_dy
					End Select
		
					If vl__lines_intersect(sx, sy, dx, dy,  edge_x, edge_y, edge_dx, edge_dy)
		
						Return False
								
					EndIf
					
					edge_x = edge_x + edge_dx
					edge_y = edge_y + edge_dy
				
				Next

			Case VL_PICK_MODE_POLY
			
				; Transform this entity's verts to world coords so we can check if it's vector
				; lines intersect with the pick line.
				vl__tform_entity_world(this, vl__entity_x(this, True), vl__entity_y(this, True), vl__entity_rotation(this, True), vl__entity_scale_x(this, True), vl__entity_scale_y(this, True))

				visuals.vl_visualsT = this\visuals
				mesh.vl_meshT = visuals\mesh
				
				If mesh\last_line_i &gt; 6
					check_for_pick = vl__line_intersects_vert_box(this, sx, sy, dx, dy)
				Else
					check_for_pick = True
				EndIf
				
				If check_for_pick
				
					For i = 0 To mesh\last_line_i
			
						; Get this mesh line start and delta.
						v0_i = mesh\line_v0_i[i]
						v1_i = mesh\line_v1_i[i]
				
						mx# = visuals\vert_x[v0_i]
						my# = visuals\vert_y[v0_i]
				
						mdx# = visuals\vert_x[v1_i] - mx
						mdy# = visuals\vert_y[v1_i] - my
		
						If vl__lines_intersect(sx, sy, dx, dy,  mx, my, mdx, mdy)
					
							Return False
															
						EndIf
		
					Next
			
				EndIf
			
			End Select
			
		EndIf
	
		pickable = pickable\next_elink
		
	Wend

	Return True
	
End Function


;
; Determines whether an entity is within the bounds of the screen.
;
; Params:
; entityID - Handle of entity to check.
;
; Returns:
; True if the given entity is visible, false otherwise.
;
Function vl_entity_in_view(entityID%)

	entity.vl_entityT = Object.vl_entityT(entityID)

	If entity\class = VL_CLASS_MESH
	
	Else
	
		x# = vl__entity_x(entity, True)
		y# = vl__entity_y(entity, True)

		If (x &lt; 0) Or (x &gt; vl_screen_units_x) Then Return False
		If (y &lt; 0) Or (y &gt; vl_screen_units_y) Then Return False
	
		Return True

	EndIf
	
End Function


;
; Converts a world coordinate to the corresponding screen coordinate.
;
; Params:
; world - The world coord to be converted to screen coord.
;
; Returns:
; The screen coordinate that corresponds to the given world coordinate.
;
Function vl_screen#(world#)

	Return (world * vl_unit_size_pixels)

End Function


;
; Converts a screen coordinate to the corresponding world coordinate.
;
; Params:
; screen - The screen coord to be converted to world coord.
;
; Returns:
; The world coordinate that corresponds to the given screen coordinate.
;
Function vl_world#(screen#)

	Return (screen / vl_unit_size_pixels)

End Function


;
; Adds a new vertex to the mesh used by the given entity.
;
; Params:
; entity_ID - Handle of entity whose mesh is to receive the new vertex.
; x         - X coord of new vertex.
; y         - Y coord of new vertex.
;
; Returns:
; The index number of the newly created vertex.
;
Function vl_add_vertex(entity_ID%, x#, y#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh
	
	i = mesh\last_vert_i + 1
	mesh\last_vert_i = i
	
	mesh\vert_x[i] = x
	mesh\vert_y[i] = y

	Return i

End Function


;
; Adds a new vector line to the mesh used by the given entity.
;
; Params:
; entity_ID - Handle of entity whose mesh is to receive the new vector line.
; v0        - Index of vertex representing the start point of the vector line.
; v1        - Index of vertex representing the end point of the vector line.
; hard      - Flag indicating if line is hard or not.
;             False = Soft line (not pickable).
;             True (default) = Hard line (pickable).
;
; Returns:
; The index number of the newly created vector line.
;
Function vl_add_line(entity_ID%, v0%, v1%, hard% = True)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh

	i = mesh\last_line_i + 1
	mesh\last_line_i = i
	
	mesh\line_v0_i[i] = v0
	mesh\line_v1_i[i] = v1
	mesh\line_hard[i] = (hard &lt;&gt; 0)
		
	Return i

End Function


;
; Sets the hard state of an existing mesh vector line.
;
; Params:
; entity_ID - Handle of entity whose mesh holds the affected line.
; line_i    - Index of vector line to set the hard state of.
; hard      - Hard state to set the line to:
;             0 - Line is soft (unpickable).
;             1 - Line is hard (pickable).
;
Function vl_line_hard(entity_ID%, line_i%, hard%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	entity\visuals\mesh\line_hard[line_i] = (hard &lt;&gt; 0)
		
End Function


;
; Returns the requested vertex index of the specified mesh vector line.
;
; Params:
; entity_ID - Handle of entity whose mesh holds the vector line vertex requested.
; line_i    - Index of vector line to get the vertex index of.
; vert_i    - Index of line vertex to be returned.
;             0 = Vector line's start vertex.
;             1 = Vector line's end vertex.
;
; Returns:
; The requested vertex index of the specified mesh vector line.
;
Function vl_line_vertex(entity_ID%, line_i%, vert_i%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	If vert_i

		Return entity\visuals\mesh\line_v1_i[line_i]

	Else

		Return entity\visuals\mesh\line_v0_i[line_i]

	EndIf
	
End Function


;
; Sets the coordinates of an existing mesh vertex.
;
; Params:
; entity_ID - Handle of entity whose mesh holds the affected vertex.
; vert_i    - Index of vertex to be set.
; x         - X coord to set vertex to.
; y         - Y coord to set vertex to.
;
Function vl_vertex_coords(entity_ID%, vert_i%, x#, y#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	mesh.vl_meshT = entity\visuals\mesh
	
	mesh\vert_x[vert_i] = x
	mesh\vert_y[vert_i] = y

End Function


;
; Returns the X coordinate of a vertex.
;
; Params:
; entity_ID - Handle of entity whose mesh holds the specified vertex.
; vert_i    - Index of vertex to return the X coord of.
;
; Returns:
; The X coordinate of the specified vertex.
;
Function vl_vertex_x#(entity_ID%, vert_i%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	Return entity\visuals\mesh\vert_x[vert_i]

End Function


;
; Returns the Y coordinate of a vertex.
;
; Params:
; entity_ID - Handle of entity whose mesh holds the specified vertex.
; vert_i    - Index of vertex to return the Y coord of.
;
; Returns:
; The Y coordinate of the specified vertex.
;
Function vl_vertex_y#(entity_ID%, vert_i%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	Return entity\visuals\mesh\vert_y[vert_i]

End Function


;
; Returns the number of vertices in a mesh.
;
; Params:
; entity_ID - Handle of entity whose mesh vertices are to be counted.
;
; Returns:
; The total number of vertices defined in the specified entity's mesh.
;
Function vl_count_vertices(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	Return (entity\visuals\mesh\last_vert_i + 1)
	
End Function


;
; Returns the number of vector lines in a mesh.
;
; Params:
; entity_ID - Handle of entity whose mesh lines are to be counted.
;
; Returns:
; The total number of vector lines defined in the specified entity's mesh.
;
Function vl_count_lines(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	Return (entity\visuals\mesh\last_line_i + 1)
	
End Function


;
; Creates a copy of an existing entity. All children are also copied.
;
; Params:
; entity_ID - Handle of entity to be copied.
; parent_ID - Handle of entity to be made the new entity's parent.
;             The new entity will then adopt the parent's position/rotation/scale.
;
; Returns:
; The handle of the newly created entity copy.
;
Function vl_copy_entity(entity_ID%, parent_ID% = 0)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	;
	; Create and initialize new entity copy.
	;

	new_entity.vl_entityT = New vl_entityT
	new_entity_ID = Handle(new_entity)
	
	new_entity\visuals			= Null
	new_entity\scale_x			= 1.0
	new_entity\scale_y			= 1.0
	new_entity\rot					= 0.0
	new_entity\x						= 0.0
	new_entity\y						= 0.0
	new_entity\parent				= Null
	new_entity\first_child	= Null

	new_entity\class				= entity\class
	new_entity\hidden				= False
	new_entity\name					= entity\name
	new_entity\radius				= entity\radius
	new_entity\box_x				= entity\box_x
	new_entity\box_y				= entity\box_y
	new_entity\box_width		= entity\box_width
	new_entity\box_height		= entity\box_height

	vl__entity_pick_mode(new_entity, entity\pick_mode, entity\obscurer)

	If entity\class = VL_CLASS_MESH

		visuals.vl_visualsT			= entity\visuals
		new_visuals.vl_visualsT	= New vl_visualsT
		new_entity\visuals			= new_visuals

		vl__add_user(visuals\mesh, new_entity)
		vl__entity_order(new_entity, visuals\order)

		new_visuals\mesh				= visuals\mesh
		new_visuals\r						= visuals\r
		new_visuals\g						= visuals\g
		new_visuals\b						= visuals\b
		new_visuals\brightness	= visuals\brightness

	EndIf
	
	; Recursively copy any child entities.
	If entity\first_child &lt;&gt; Null Then vl__copy_children(entity, new_entity)

	; Keep this AFTER the recursion call, else an infinite loop will be entered
	; if the entity to be parented to is also the entity being copied!
	If parent_ID Then vl_entity_parent(new_entity_ID, parent_ID, False)

	Return new_entity_ID

End Function


;
; Hides an entity so that it's no longer drawn. All children are also hidden.
;
; Params:
; entity_ID - Handle of entity to be hidden.
;
Function vl_hide_entity(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	entity\hidden = True

End Function


;
; Shows an entity.
;
; Params:
; entity_ID - Handle of entity to be shown.
;
Function vl_show_entity(entity_ID%)

	entity.vl_entityT = Object.vl_entityT(entity_ID)

	entity\hidden = False

End Function


;
; Positions an entity at an absolute position.
;
; Params:
; entity_ID - Handle of entity to be positioned.
; x         - X coord entity will be positioned at.
; y         - Y coord entity will be positioned at.
; glob      - True if the position is global.
;             False (default) if the position is local.
;
Function vl_position_entity(entity_ID%, x#, y#, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	parent.vl_entityT = entity\parent
	
	If glob And (parent &lt;&gt; Null)

		; Find global coords of x,y point, relative to parent.
		dx# = x - vl__entity_x(parent, True)
		dy# = y - vl__entity_y(parent, True)

		; Rotate coords into parent's coord system.
		inv_pg_rot# = -vl__entity_rotation(parent, True)

		cos_rot# = Cos(inv_pg_rot)
		sin_rot# = Sin(inv_pg_rot)
		
		x = (dx * cos_rot) - (dy * sin_rot)
		y = (dy * cos_rot) + (dx * sin_rot)

		; Scale coords to parent's global scale.
		entity\x = x / vl__entity_scale_x(parent, True)
		entity\y = y / vl__entity_scale_y(parent, True)

	Else
	
		entity\x = x
		entity\y = y
	
	EndIf

End Function</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>2013</font></td></tr></table></td></tr><tr ><td class="posttext"> Part 2:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">


;
; Turns/rotates an entity relative to it's current orientation.
;
; Params:
; entity_ID - Handle of entity to be turned.
; rot       - Angle to turn the entity by (+ve = clockwise, -ve = anticlockwise).
;
Function vl_turn_entity(entity_ID%, rot#)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	entity\rot = vl__clamp_rot(entity\rot + rot)

End Function


;
; Rotates an entity so that it's at an absolute orientation.
;
; Params:
; entity_ID - Handle of entity to be rotated.
; rot       - Angle to set the entity's rotation to.
; glob      - True if the rotation is global.
;             False (default) if the rotation is local (i.e. relative to entity's parent).
;
Function vl_rotate_entity(entity_ID%, rot#, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	parent.vl_entityT = entity\parent
	
	If glob And (parent &lt;&gt; Null)

		delta# = rot - vl__entity_rotation(parent, True)

		entity\rot = vl__clamp_rot(delta)

	Else
	
		entity\rot = vl__clamp_rot(rot)
		
	EndIf
	
End Function


;
; Sets an entity's scale.
;
; Params:
; entity_ID - Handle of entity to be scaled.
; scale_x   - X scale to set entity to (negative values flip the entity around it's Y axis). 
; scale_y   - Y scale to set entity to (negative values flip the entity around it's X axis).
; glob      - True if the scale is global.
;             False (default) if the scale is local (i.e. relative to entity's parent).
;
Function vl_scale_entity(entity_ID%, scale_x#, scale_y#, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	If glob
	
		; Find evquivalent local scale of global scale_x, scale_y.
		sx# = (scale_x / vl__entity_scale_x(entity, True)) * entity\scale_x
		sy# = (scale_y / vl__entity_scale_y(entity, True)) * entity\scale_y
		
		entity\scale_x = sx 
		entity\scale_y = sy

	Else
	
		entity\scale_x = scale_x
		entity\scale_y = scale_y
	
	EndIf

End Function


;
; Translates an entity relative to its current position and not its orientation.
;
; Params:
; entity_ID - Handle of entity to be translated.
; scale_x   - X amount to translate the entity by. 
; scale_y   - Y amount to translate the entity by.
; glob      - True to translate according to the world coord system.
;             False (default) to translate locally (i.e. relative to entity's parent).
;
Function vl_translate_entity(entity_ID%, x#, y#, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	parent.vl_entityT = entity\parent
	
	If glob And (parent &lt;&gt; Null) ; Tform translation vector from world to parent's coord system...
					
		; Rotate vector into parent entity's coord system.
		inv_rot# = -vl__entity_rotation(parent, True)

		cos_rot# = Cos(inv_rot)
		sin_rot# = Sin(inv_rot)
		
		delta_x# = (x * cos_rot) - (y * sin_rot)
		delta_y# = (y * cos_rot) + (x * sin_rot)

		; Scale vector to parent entity's global scale, before translating.
		entity\x = entity\x + (delta_x / vl__entity_scale_x(parent, True))
		entity\y = entity\y + (delta_y / vl__entity_scale_y(parent, True))

	Else
	
		entity\x = entity\x + x
		entity\y = entity\y + y
		
	EndIf
		
End Function


;
; Moves an entity relative to its current position and orientation.
;
; Params:
; entity_ID - Handle of entity to be moved.
; x         - Amount to move the entity along it's X axis by. 
; y         - Amount to move the entity along it's Y axis by.
; glob      - True to move using the global unit scale.
;             False (default) to move using the local unit scale (i.e. parent's coord system).
;
Function vl_move_entity(entity_ID%, x#, y#, glob% = False)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	parent.vl_entityT = entity\parent

	If (parent &lt;&gt; Null)

		scale_x# = vl__entity_scale_x(parent, True)
		scale_y# = vl__entity_scale_y(parent, True)
		
		If glob ; Move entity using global unit scale...

			inv_rot# = vl__entity_rotation(entity, False)
	
			cos_rot# = Cos(inv_rot)
			sin_rot# = Sin(inv_rot)
			
			delta_x# = (x * cos_rot) - (y * sin_rot)
			delta_y# = (y * cos_rot) + (x * sin_rot)
	
			entity\x = entity\x + (delta_x / scale_x)
			entity\y = entity\y + (delta_y / scale_y)

		Else ; Move entity using parent's unit scale...
		
			axis_rot# = vl__entity_rotation(entity, False)
	
			If Abs(x) &gt; 0 ; Move along X axis...
	
				ang# = ATan2(Sin(axis_rot) * scale_x, Cos(axis_rot) * scale_y)
				
				entity\x = entity\x + (Cos(ang) * x) 
				entity\y = entity\y + (Sin(ang) * x)
	
			EndIf
	
			If Abs(y) &gt; 0 ; Move along Y axis...
			
				axis_rot = axis_rot + 90.0
				ang# = ATan2(Sin(axis_rot) * scale_x, Cos(axis_rot) * scale_y)
		
				entity\x = entity\x + (Cos(ang) * y) 
				entity\y = entity\y + (Sin(ang) * y)
	
			EndIf

		EndIf
				
	Else

		global_rot# = vl__entity_rotation(entity, True)
	
		cos_rot# = Cos(global_rot)
		sin_rot# = Sin(global_rot)
		
		global_x# = (x * cos_rot) - (y * sin_rot)
		global_y# = (y * cos_rot) + (x * sin_rot)

		entity\x = entity\x + global_x
		entity\y = entity\y + global_y
	
	EndIf
		
End Function


;
; Rotates one entity so that it points at another.
;
; Params:
; entity_a_ID - Handle of entity to be pointed.
; entity_b_ID - Handle of entity to be pointed at.
;
Function vl_point_entity(entity_a_ID%, entity_b_ID%)

	entity_a.vl_entityT = Object.vl_entityT(entity_a_ID)
	entity_b.vl_entityT = Object.vl_entityT(entity_b_ID)

	dx# = vl__entity_x(entity_b, True) - vl__entity_x(entity_a, True)
	dy# = vl__entity_y(entity_b, True) - vl__entity_y(entity_a, True)
	
	entity_a\rot = vl__clamp_rot(entity_a\rot + (ATan2(dy, dx) - vl__entity_rotation(entity_a, True)))

End Function


;
; Returns the angle that one entity needs to be rotated to in order to point at another entity.
;
; Params:
; entity_a_ID - Handle of entity to be pointed.
; entity_b_ID - Handle of entity to be pointed at.
;
Function vl_delta_rotation#(entity_a_ID%, entity_b_ID%)

	entity_a.vl_entityT = Object.vl_entityT(entity_a_ID)
	entity_b.vl_entityT = Object.vl_entityT(entity_b_ID)

	dx# = vl__entity_x(entity_b, True) - vl__entity_x(entity_a, True)
	dy# = vl__entity_y(entity_b, True) - vl__entity_y(entity_a, True)
	
	Return vl__clamp_rot(ATan2(dy, dx) - vl__entity_rotation(entity_a, True))

End Function


;
; Returns the rotation angle of a vector, specified in the range 0 to 360 degrees.
;
; Params:
; x,y - The vector's X and Y lengths.
;
; Returns:
; The specified vector's angle.
;
Function vl_vector_rotation#(x#, y#)

	Return vl__clamp_rot(ATan2(y, x))

End Function


;
; Tansforms a point from one coord system into another.
; The coords of the tranformed point can then be read from the global
; variables vl_tformed_x and vl_tformed_y.
;
; Params:
; x                - X coord of point to be transformed.
; y                - Y coord of point to be transformed.
; source_entity_ID - Handle of source entity, or 0 for world coord system.
; dest_entity_ID   - Handle of destination entity, or 0 for world coord system.
;
Function vl_tform_point(x#, y#, source_entity_ID%, dest_entity_ID%)

	If source_entity_ID ; Convert point from source entity space, to global space...
	
		source_entity.vl_entityT = Object.vl_entityT(source_entity_ID)
		
		; Scale point to global scale.
		x = x * vl__entity_scale_x(source_entity, True)
		y = y * vl__entity_scale_y(source_entity, True)
		
		; Rotate point to match source entity's global rotation.
		global_rot# = vl__entity_rotation(source_entity, True)

		cos_rot# = Cos(global_rot)
		sin_rot# = Sin(global_rot)
		
		trans_x# = (x * cos_rot) - (y * sin_rot)
		trans_y# = (y * cos_rot) + (x * sin_rot)

		global_x# = vl__entity_x(source_entity, True) + trans_x
		global_y# = vl__entity_y(source_entity, True) + trans_y

	Else ; Source is global space...

		global_x# = x
		global_y# = y

	EndIf


	If dest_entity_ID ; Convert point from global space, to destination entity space...

		dest_entity.vl_entityT = Object.vl_entityT(dest_entity_ID)
				
		; Find global coords of point, relative to destination entity.
		dx# = global_x - vl__entity_x(dest_entity, True)
		dy# = global_y - vl__entity_y(dest_entity, True)

		; Rotate coords into destination entity's coord system.
		inv_rot# = -vl__entity_rotation(dest_entity, True)

		cos_rot# = Cos(inv_rot)
		sin_rot# = Sin(inv_rot)
		
		x = (dx * cos_rot) - (dy * sin_rot)
		y = (dy * cos_rot) + (dx * sin_rot)

		; Scale coords to destination entity's global scale.
		vl_tformed_x = x / vl__entity_scale_x(dest_entity, True)
		vl_tformed_y = y / vl__entity_scale_y(dest_entity, True)

	Else ; Destination is global space...

		vl_tformed_x = global_x
		vl_tformed_y = global_y

	EndIf

End Function


;
; Tansforms a vector from one coord system into another.
; The components of the tranformed vector can then be read from the global
; variables vl_tformed_x and vl_tformed_y.
;
; Params:
; x                - X coord of vector to be transformed.
; y                - Y coord of vector to be transformed.
; source_entity_ID - Handle of source entity, or 0 for world coord system.
; dest_entity_ID   - Handle of destination entity, or 0 for world coord system.
;
Function vl_tform_vector(x#, y#, source_entity_ID%, dest_entity_ID%)

	If source_entity_ID ; Convert vector from source entity space, to global space...
	
		source_entity.vl_entityT = Object.vl_entityT(source_entity_ID)
		
		; Scale vector to global scale.
		x = x * vl__entity_scale_x(source_entity, True)
		y = y * vl__entity_scale_y(source_entity, True)
		
		; Rotate vector to match source entity's global rotation.
		global_rot# = vl__entity_rotation(source_entity, True)

		cos_rot# = Cos(global_rot)
		sin_rot# = Sin(global_rot)
		
		global_x# = (x * cos_rot) - (y * sin_rot)
		global_y# = (y * cos_rot) + (x * sin_rot)

	Else ; Source is global space...

		global_x# = x
		global_y# = y

	EndIf


	If dest_entity_ID ; Convert vector from global space, to destination entity space...

		dest_entity.vl_entityT = Object.vl_entityT(dest_entity_ID)
				
		; Rotate vector into destination entity's coord system.
		inv_rot# = -vl__entity_rotation(dest_entity, True)

		cos_rot# = Cos(inv_rot)
		sin_rot# = Sin(inv_rot)
		
		x = (global_x * cos_rot) - (global_y * sin_rot)
		y = (global_y * cos_rot) + (global_x * sin_rot)

		; Scale vector to destination entity's global scale.
		vl_tformed_x = x / vl__entity_scale_x(dest_entity, True)
		vl_tformed_y = y / vl__entity_scale_y(dest_entity, True)
		
	Else ; Destination is global space...

		vl_tformed_x = global_x
		vl_tformed_y = global_y

	EndIf

End Function


;
; Tansforms a normal vector from one coord system into another and normalizes the result.
; The components of the tranformed vector can then be read from the global
; variables vl_tformed_x and vl_tformed_y.
;
; Params:
; x                - X coord of vector to be transformed.
; y                - Y coord of vector to be transformed.
; source_entity_ID - Handle of source entity, or 0 for world coord system.
; dest_entity_ID   - Handle of destination entity, or 0 for world coord system.
;
Function vl_tform_normal(x#, y#, source_entity_ID%, dest_entity_ID%)

	If source_entity_ID ; Convert vector from source entity space, to global space...
	
		source_entity.vl_entityT = Object.vl_entityT(source_entity_ID)
		
		; Scale vector to global scale.
		x = x * vl__entity_scale_y(source_entity, True)
		y = y * vl__entity_scale_x(source_entity, True)
		
		; Rotate vector to match source entity's global rotation.
		global_rot# = vl__entity_rotation(source_entity, True)

		cos_rot# = Cos(global_rot)
		sin_rot# = Sin(global_rot)
		
		global_x# = (x * cos_rot) - (y * sin_rot)
		global_y# = (y * cos_rot) + (x * sin_rot)

	Else ; Source is global space...

		global_x# = x
		global_y# = y

	EndIf


	If dest_entity_ID ; Convert vector from global space, to destination entity space...

		dest_entity.vl_entityT = Object.vl_entityT(dest_entity_ID)
				
		; Rotate vector into destination entity's coord system.
		inv_rot# = -vl__entity_rotation(dest_entity, True)

		cos_rot# = Cos(inv_rot)
		sin_rot# = Sin(inv_rot)
		
		x = (global_x * cos_rot) - (global_y * sin_rot)
		y = (global_y * cos_rot) + (global_x * sin_rot)

		; Scale vector to destination entity's global scale.
		vl_tformed_x = x / vl__entity_scale_y(dest_entity, True)
		vl_tformed_y = y / vl__entity_scale_x(dest_entity, True)
		
	Else ; Destination is global space...

		vl_tformed_x = global_x
		vl_tformed_y = global_y

	EndIf
	
	; Normalize the result.
	mag# = Sqr(vl_tformed_x * vl_tformed_x + vl_tformed_y * vl_tformed_y)
	vl_tformed_x = vl_tformed_x / mag
	vl_tformed_y = vl_tformed_y / mag

End Function


;
; Wrapper function (for completeness) to get the X coord of the most recently perfomed
; tform command i.e. vl_tform_point(), vl_tform_vector(), vl_tform_normal().
;
; Returns:
; The resultant X coord of the most recently performed tform command.
;
Function vl_tformed_x#()

	Return vl_tformed_x

End Function


;
; Wrapper function (for completeness) to get the Y coord of the most recently perfomed
; tform command i.e. vl_tform_point(), vl_tform_vector(), vl_tform_normal().
;
; Returns:
; The resultant Y coord of the most recently performed tform command.
;
Function vl_tformed_y#()

	Return vl_tformed_y

End Function


;
; Aligns an entity's axis to a vector.
;
; Params:
; entity_ID - Handle of entity to be aligned.
; x         - X coord of alignment vector.
; y         - Y coord of alignment vector.
; axis      - Axis of entity that will be aligned to the vector.
;             1 for X axis.
;             2 for Y axis.
; rate      - Rate at which the entity is aligned to the vector.      
;             Range is 0 to 1 where 1 immediately 'snaps' the entity alignment to the vector.
;
Function vl_align_to_vector(entity_ID%, x#, y#, axis%, rate# = 1.0)

	entity.vl_entityT = Object.vl_entityT(entity_ID)
	
	; Find angle of global vector.
	ang# = ATan2(y, x)

	; We're simply going to align the entity's X axis to the vector,
	; so adjust angle if Y axis is required.
	If axis = 2 Then ang = ang + 90.0

	; Find shortest difference between the global entity and vector angles.
	delta# = vl__clamp_rot(ang - vl__entity_rotation(entity, True))
	If delta &gt; 180.0 Then delta = delta - 360.0

	; Adjust entity rotation angle by required rate.
	entity\rot = vl__clamp_rot(entity\rot + (delta * rate))

End Function


;
; Finds the pickable entity nearest to the defined line's origin.
;
; Params:
; sx,sy - Start coords of pick line.
; dx,dy - Delta coords of pick line.
;
Function vl_line_pick(sx#, sy#, dx#, dy#)

	; We're going to search for the picked point nearest to the pick origin, so we initially set this
	; to beyond the pick vector range to ensure the first pick found becomes the nearest.
	nearest_dist_sq# = (dx * dx) + (dy * dy) + 100

	; Reset pick result status variables.
	vl_picked_entity.vl_entityT	= Null
	vl_picked_line							= -1
	vl_picked_x									= 0.0
	vl_picked_y									= 0.0
	vl_picked_nx								= 0.0
	vl_picked_ny								= 0.0

	vl_picked_dx								= 0.0
	vl_picked_dy								= 0.0
	vl_pick_line_dx							= dx
	vl_pick_line_dy							= dy

	;
	; Search all pickable, visible entities for the one picked nearest to the pick origin.
	;
	
	pickable.vl_elinkT = vl_first_pickable
	
	While pickable &lt;&gt; Null

		this.vl_entityT = pickable\entity
	
		If vl__entity_visible(this)

			;
			; See if this entity is picked, using it's defined pick method.
			;
			
			Select this\pick_mode
			
			Case VL_PICK_MODE_CIRCLE
			
				cx# = vl__entity_x(this, True)
				cy# = vl__entity_y(this, True)
				
				If vl__line_intersects_circle(sx, sy, dx, dy,  cx, cy, this\radius)

					; Calc the squared distance of intersection point from pick origin.
					x# = sx - vl_intersect_x
					y# = sy - vl_intersect_y
					dist_sq# = (x * x) + (y * y)

					If (dist_sq &lt; nearest_dist_sq) ; This pick is the closest to the pick origin so far...
		
						vl_picked_entity	= this
						vl_picked_line		= -1
						vl_picked_x				= vl_intersect_x
						vl_picked_y				= vl_intersect_y
						vl_picked_nx 			= vl_intersect_x - cx
						vl_picked_ny 			= vl_intersect_y - cy
						
						nearest_dist_sq = dist_sq
		
					EndIf
				
				EndIf
				
			Case VL_PICK_MODE_BOX

				rot# = vl__entity_rotation(this, True)
				cos_rot# = Cos(rot)
				sin_rot# = Sin(rot)
		
				trans_x# = (this\box_x * cos_rot) - (this\box_y * sin_rot)
				trans_y# = (this\box_y * cos_rot) + (this\box_x * sin_rot)

				edge_x# = vl__entity_x(this, True) + trans_x
				edge_y# = vl__entity_y(this, True) + trans_y
		
				width_dx#		= cos_rot * this\box_width
				width_dy#		= sin_rot * this\box_height
				height_dx#	= Cos(rot + 90) * this\box_width
				height_dy#	= Sin(rot + 90) * this\box_height
		
				For n = 1 To 4
				
					; Set correct delta for current edge being tested.
					Select n
					Case 1 ; Top.
						edge_dx# = width_dx
						edge_dy# = width_dy
					Case 2 ; Right.
						edge_dx# = height_dx
						edge_dy# = height_dy
					Case 3 ; Bottom.
						edge_dx# = -width_dx
						edge_dy# = -width_dy
					Case 4 ; Left.
						edge_dx# = -height_dx
						edge_dy# = -height_dy
					End Select
		
					If vl__lines_intersect_xy(sx, sy, dx, dy,  edge_x, edge_y, edge_dx, edge_dy)
		
						; Calc the squared distance of intersection point from pick origin.
						x# = sx - vl_intersect_x
						y# = sy - vl_intersect_y
						dist_sq# = (x * x) + (y * y)
		
						; Calc normal of intersected vector line.
						nx# = (edge_y + edge_dy) - edge_y 
						ny# = edge_x - (edge_x + edge_dx)
						
						; Calc dot product of normal and pick vector.
						dot# = dx * nx + dy * ny
			
						If (dist_sq &lt; nearest_dist_sq) And (dot &lt; 0) ; This pick is the closest to the pick origin so far...
			
							vl_picked_entity	= this
							vl_picked_line		= -1
							vl_picked_x				= vl_intersect_x
							vl_picked_y				= vl_intersect_y
							vl_picked_nx 			= nx 
							vl_picked_ny 			= ny
							
							nearest_dist_sq = dist_sq
			
						EndIf
		
					EndIf
					
					edge_x = edge_x + edge_dx
					edge_y = edge_y + edge_dy
				
				Next

			Case VL_PICK_MODE_POLY
			
				; Transform this entity's verts to world coords so we can check if it's vector
				; lines intersect with the pick line.
				vl__tform_entity_world(this, vl__entity_x(this, True), vl__entity_y(this, True), vl__entity_rotation(this, True), vl__entity_scale_x(this, True), vl__entity_scale_y(this, True))

				visuals.vl_visualsT = this\visuals
				mesh.vl_meshT = visuals\mesh
				
				If mesh\last_line_i &gt; 6
					check_for_pick = vl__line_intersects_vert_box(this, sx, sy, dx, dy)
				Else
					check_for_pick = True
				EndIf
				
				If check_for_pick
				
					For i = 0 To mesh\last_line_i
			
						If mesh\line_hard[i]
						
							; Get this mesh line start and delta.
							v0_i = mesh\line_v0_i[i]
							v1_i = mesh\line_v1_i[i]
					
							mx# = visuals\vert_x[v0_i]
							my# = visuals\vert_y[v0_i]
					
							mdx# = visuals\vert_x[v1_i] - mx
							mdy# = visuals\vert_y[v1_i] - my
			
							If vl__lines_intersect_xy(sx, sy, dx, dy,  mx, my, mdx, mdy)
						
								; Calc the squared distance of intersection point from pick origin.
								x# = sx - vl_intersect_x
								y# = sy - vl_intersect_y
								dist_sq# = (x * x) + (y * y)
		
								; Calc normal of intersected vector line.
								nx# = (my + mdy) - my 
								ny# = mx - (mx + mdx)
								
								; Calc dot product of normal and pick vector.
								dot# = dx * nx + dy * ny
					
								If (dist_sq &lt; nearest_dist_sq) And (dot &lt; 0) ; This pick is the closest to the pick origin so far...
					
									vl_picked_entity	= this
									vl_picked_line		= i
									vl_picked_x				= vl_intersect_x
									vl_picked_y				= vl_intersect_y
									vl_picked_nx 			= nx 
									vl_picked_ny 			= ny
									
									nearest_dist_sq = dist_sq
					
								EndIf
									
							EndIf
		
						EndIf
						
					Next
			
				EndIf
			
			End Select
			
		EndIf
	
		pickable = pickable\next_elink
		
	Wend
	
	If vl_picked_entity &lt;&gt; Null
	
		; Normalize the picked line normal.
		l# = Sqr(vl_picked_nx * vl_picked_nx + vl_picked_ny * vl_picked_ny)
		vl_picked_nx = vl_picked_nx / l
		vl_picked_ny = vl_picked_ny / l
		
		; Store the picked point delta for use by vl_picked_time().
		vl_picked_dx = vl_picked_x - sx
		vl_picked_dy = vl_picked_y - sy
		
	EndIf
	
End Function


;
; Picks the entity at the specified screen coordinates.
; Note: If more than one entity is picked, the one with the lowest entity order is returned.
;
; Params:
; x,y - Screen coordinates to perform pick at.
;
; Returns:
; The handle of the picked entity, or 0 if no entity was picked.
;
Function vl_screen_pick(x#, y#)

	; Convert screen coords to world coords.
	x = vl_world(x)
	y = vl_world(y)
	
	; Reset pick result status variables.
	vl_picked_entity.vl_entityT	= Null
	vl_picked_line							= -1
	vl_picked_x									= 0.0
	vl_picked_y									= 0.0
	vl_picked_nx								= 0.0
	vl_picked_ny								= 0.0

	vl_picked_dx								= 0.0
	vl_picked_dy								= 0.0
	vl_pick_line_dx							= 0.0
	vl_pick_line_dy							= 0.0

	;
	; Search all pickable, visible entities for the one picked nearest to the pick origin.
	;
	
	pickable.vl_elinkT = vl_first_pickable
	
	While pickable &lt;&gt; Null
	
		this.vl_entityT = pickable\entity
		
		If vl__entity_visible(this)

			;
			; See if this entity is picked, using it's defined pick method.
			;
			
			Select this\pick_mode
			
			Case VL_PICK_MODE_CIRCLE
			
				dx# = vl__entity_x(this, True) - x
				dy# = vl__entity_y(this, True) - y
				
				If (dx * dx + dy * dy) &lt;= (this\radius * this\radius)

					If vl_picked_entity &lt;&gt; Null
					
						If vl_picked_entity\class = VL_CLASS_MESH
						
							If this\class = VL_CLASS_MESH
							
								If (this\visuals\order &lt; vl_picked_entity\visuals\order)
					
									vl_picked_entity	= this
					
								EndIf
						
							EndIf
							
						Else
						
							vl_picked_entity	= this

						EndIf

					Else

						vl_picked_entity	= this
						vl_picked_x				= x
						vl_picked_y				= y
					
					EndIf
				
				EndIf
				
			Case VL_PICK_MODE_BOX

				rot# = vl__entity_rotation(this, True)
				cos_rot# = Cos(rot)
				sin_rot# = Sin(rot)
		
				trans_x# = (this\box_x * cos_rot) - (this\box_y * sin_rot)
				trans_y# = (this\box_y * cos_rot) + (this\box_x * sin_rot)

				edge_x# = vl__entity_x(this, True) + trans_x
				edge_y# = vl__entity_y(this, True) + trans_y
		
				width_dx#		= cos_rot * this\box_width
				width_dy#		= sin_rot * this\box_height
				height_dx#	= Cos(rot + 90) * this\box_width
				height_dy#	= Sin(rot + 90) * this\box_height

				point_in_box = True
						
				For n = 1 To 4
				
					; Set correct delta for current edge being tested.
					Select n
					Case 1 ; Top.
						edge_dx# = width_dx
						edge_dy# = width_dy
					Case 2 ; Right.
						edge_dx# = height_dx
						edge_dy# = height_dy
					Case 3 ; Bottom.
						edge_dx# = -width_dx
						edge_dy# = -width_dy
					Case 4 ; Left.
						edge_dx# = -height_dx
						edge_dy# = -height_dy
					End Select

					point_dx# = x - edge_x
					point_dy# = y - edge_y
					
					; Calc dot product of edge vector and edge_start_to_point vector.
					dot# = edge_dx * point_dx + edge_dy * point_dy

					If dot &lt; 0

						point_in_box = False
						Exit

					EndIf
					
					edge_x = edge_x + edge_dx
					edge_y = edge_y + edge_dy
				
				Next

				If point_in_box
	
					If vl_picked_entity &lt;&gt; Null
					
						If vl_picked_entity\class = VL_CLASS_MESH
						
							If this\class = VL_CLASS_MESH
							
								If (this\visuals\order &lt; vl_picked_entity\visuals\order)
					
									vl_picked_entity	= this
					
								EndIf
						
							EndIf
							
						Else
						
							vl_picked_entity	= this

						EndIf

					Else

						vl_picked_entity	= this
						vl_picked_x				= x
						vl_picked_y				= y
					
					EndIf
	
				EndIf
			
			Case VL_PICK_MODE_POLY

				; Transform this entity's verts to world coords so we can check if it's mesh
				; contains the pick point.
				vl__tform_entity_world(this, vl__entity_x(this, True), vl__entity_y(this, True), vl__entity_rotation(this, True), vl__entity_scale_x(this, True), vl__entity_scale_y(this, True))

				If this\visuals\mesh\last_line_i &gt; 10
					check_for_pick = vl__point_in_vert_box(this, x, y)
				Else
					check_for_pick = True
				EndIf
				
				If check_for_pick
				
					If vl__point_in_polygon(this, x, y)
				
						If vl_picked_entity &lt;&gt; Null
						
							If vl_picked_entity\class = VL_CLASS_MESH
							
								If (this\visuals\order &lt; vl_picked_entity\visuals\order)
					
									vl_picked_entity	= this
					
								EndIf
								
							Else
							
								vl_picked_entity	= this
	
							EndIf
	
						Else
	
							vl_picked_entity	= this
							vl_picked_x				= x
							vl_picked_y				= y
						
						EndIf
													
					EndIf
		
				EndIf
			
			End Select
			
		EndIf

		pickable = pickable\next_elink
		
	Wend

	Return Handle(vl_picked_entity)

End Function


;
; Returns the entity picked by the most recently perfomed
; pick command i.e. vl_line_pick().
;
; Returns:
; The entity ID of the most recently performed pick command.
;
Function vl_picked_entity()

	Return Handle(vl_picked_entity)

End Function


;
; Wrapper function (for completeness) to get the X coord of the most recently perfomed
; pick command i.e. vl_line_pick().
;
; Returns:
; The resultant X coord of the most recently performed pick command.
;
Function vl_picked_x#()

	Return vl_picked_x

End Function


;
; Wrapper function (for completeness) to get the Y coord of the most recently perfomed
; pick command i.e. vl_line_pick().
;
; Returns:
; The resultant Y coord of the most recently performed pick command.
;
Function vl_picked_y#()

	Return vl_picked_y

End Function


;
; Wrapper function (for completeness) to get the normal X coord of the most recently perfomed
; pick command i.e. vl_line_pick().
;
; Returns:
; The resultant normal X coord of the most recently performed pick command.
;
Function vl_picked_nx#()

	Return vl_picked_nx

End Function


;
; Wrapper function (for completeness) to get the normal Y coord of the most recently perfomed
; pick command i.e. vl_line_pick().
;
; Returns:
; The resultant normal Y coord of the most recently performed pick command.
;
Function vl_picked_ny#()

	Return vl_picked_ny

End Function


;
; Wrapper function (for completeness) to get the index number of the vector line that was picked
; by the most recently executed pick command i.e. vl_line_pick().
;
; Returns:
; The resultant vector line index of the most recently performed pick command.
;
Function vl_picked_line()

	Return vl_picked_line

End Function


;
; Returns the 'time' the last pick occured along the pick line. E.g.:
; 0.0 = pick occured at start of pick line.
; 0.5 = pick occured halfway along pick line.
; 1.0 = pick occured at end of pick line.
;
; Returns:
; The 'time' the most recent pick occured along the last pick line.
;
Function vl_picked_time#()

	delta_sq# = vl_pick_line_dx * vl_pick_line_dx + vl_pick_line_dy * vl_pick_line_dy
	
	If delta_sq &gt; 0

		Return (Sqr(vl_picked_dx * vl_picked_dx + vl_picked_dy * vl_picked_dy) / Sqr(delta_sq))

	Else
	
		Return 0.0

	EndIf
	
End Function




;
; *** Internal library functions ***
;




;
; Clamps an arbitrary angle of rotation to the equivalent in the range 0-360 degrees.
;
; Params:
; rot - The rotation angle to be clamped.
;
; Returns:
; The given rotation angle, converted to the range 0-360 degrees.
;
Function vl__clamp_rot#(rot#)

	rot = rot Mod 360.0
	
	If rot &lt; 0 Then Return (rot + 360.0)
	
	Return rot

End Function


;
; Adds an entity to another entity's list of children.
;
; Params:
; parent - The entity to be made the parent.
; child  - The entity to be made the child of parent.
;
Function vl__add_child(parent.vl_entityT, child.vl_entityT)

	; Add child to entity's list of children.
	this.vl_elinkT	= New vl_elinkT
	this\entity			= child
	this\next_elink	= parent\first_child

	parent\first_child = this

	child\parent = parent
	
End Function


;
; Removes an entity from it's parent's list of children.
;
; Params:
; child  - The entity to be removed as a child of it's parent.
;
Function vl__delete_child(child.vl_entityT)

	this.vl_elinkT = child\parent\first_child
	prev.vl_elinkT = Null
	
	; Search for child in parent's list of children.
	While this &lt;&gt; Null

		If this\entity = child ; Child found...

			; Remove child link from list.
			If this = child\parent\first_child
			
				child\parent\first_child = this\next_elink

			Else

				prev\next_elink = this\next_elink

			EndIf
			
			Delete this
			child\parent = Null
			Return

		EndIf
		
		prev = this
		this = this\next_elink

	Wend
	
End Function


;
; Adds an entity to a mesh's list of users.
;
; Params:
; mesh - The mesh to add the user entity to.
; user - The entity to be made a user of mesh.
;
Function vl__add_user(mesh.vl_meshT, user.vl_entityT)

	; Add user to mesh's list of users.
	this.vl_elinkT = New vl_elinkT
	this\entity = user
	this\next_elink = mesh\first_user

	mesh\first_user = this

End Function


;
; Removes an entity from a mesh's list of users.
;
; Params:
; mesh - The mesh holding the user.
; user - The entity to be removed as a user.
;
Function vl__delete_user(mesh.vl_meshT, user.vl_entityT)

	this.vl_elinkT = mesh\first_user
	prev.vl_elinkT = Null
	
	; Search mesh's list for the given user.
	While this &lt;&gt; Null

		If this\entity = user ; User found...

			; Remove user link from list.
			If this = mesh\first_user

				mesh\first_user = this\next_elink

			Else

				prev\next_elink = this\next_elink

			EndIf
			
			Delete this
			Return

		EndIf
		
		prev = this
		this = this\next_elink

	Wend
	
End Function


;
; Adds an entity to the list of all pickable entities.
;
; Params:
; entity - The entity to be added to the list of pickable entities.
;
Function vl__add_pickable(entity.vl_entityT)

	; Add entity to list of pickable entities.
	this.vl_elinkT	= New vl_elinkT
	this\entity			= entity
	this\next_elink	= vl_first_pickable

	vl_first_pickable = this

End Function


;
; Removes an entity from the list of all pickable entities.
;
; Params:
; entity - The entity to be removed from the list of pickable entities.
;
Function vl__delete_pickable(entity.vl_entityT)

	this.vl_elinkT = vl_first_pickable
	prev.vl_elinkT = Null
	
	; Search pickable list for the given entity.
	While this &lt;&gt; Null

		If this\entity = entity ; Entity found...

			; Remove pickable entity link from list.
			If this = vl_first_pickable

				vl_first_pickable = this\next_elink

			Else

				prev\next_elink = this\next_elink

			EndIf
			
			Delete this
			Return

		EndIf
		
		prev = this
		this = this\next_elink

	Wend
	
End Function


;
; Transform the vertices of a given entity's children (and sub-children, via recursion),
; from their local coordinate systems, into absolute pixel coords, ready for rendering.
;
; Params:
; parent     - The entity whose immediate children are to be transformed.
; pg_x       - The parent's global X coord.
; pg_y       - The parent's global Y coord.
; pg_rot     - The parent's global rotation.
; pg_scale_x - The parent's global X scale.
; pg_scale_y - The parent's global Y scale.
;
Function vl__tform_children(parent.vl_entityT, pg_x#, pg_y#, pg_rot#, pg_scale_x#, pg_scale_y#)

	child_link.vl_elinkT = parent\first_child

	cos_rot# = Cos(pg_rot)
	sin_rot# = Sin(pg_rot)

	; Transform all parent's immediate children.
	While child_link &lt;&gt; Null

		entity.vl_entityT = child_link\entity

		If Not entity\hidden
		
			; Transform this child entity's local position/rotation/scale into the global coord system.
			local_x# = entity\x * pg_scale_x
			local_y# = entity\y * pg_scale_y
	
			trans_x# = (local_x * cos_rot) - (local_y * sin_rot)
			trans_y# = (local_y * cos_rot) + (local_x * sin_rot)
	
			global_x#				= pg_x + trans_x
			global_y#				= pg_y + trans_y
			global_rot#			= pg_rot + entity\rot
			global_scale_x#	= pg_scale_x * entity\scale_x
			global_scale_y#	= pg_scale_y * entity\scale_y
			
			If entity\class = VL_CLASS_MESH
				; Transform this child entity's verts into absolute pixel coords.
				vl__tform_entity(entity, global_x, global_y, global_rot, global_scale_x, global_scale_y)
			EndIf
			
			If entity\first_child &lt;&gt; Null
				; Recursion: transform all this child entity's immediate children.
				vl__tform_children(entity, global_x, global_y, global_rot, global_scale_x, global_scale_y)
			EndIf

		EndIf
			
		child_link = child_link\next_elink

	Wend

End Function


;
; Transforms an entity's mesh vertices into absolute pixel coords, ready for rendering.
; The transformed vertices are stored in the given entity's vertex buffer.
;
; Params:
; entity         - The entity whose mesh vertices are to be transformed.
; global_x       - The entity's global X coord.
; global_y       - The entity's global Y coord.
; global_rot     - The entity's global rotation.
; global_scale_x - The entity's global X scale.
; global_scale_y - The entity's global Y scale.
;
Function vl__tform_entity(entity.vl_entityT, global_x#, global_y#, global_rot#, global_scale_x#, global_scale_y#)

	visuals.vl_visualsT	= entity\visuals
	mesh.vl_meshT				= visuals\mesh

	cos_rot# = Cos(global_rot)
	sin_rot# = Sin(global_rot)

	origin_x# = (global_x * vl_unit_size_pixels)
	origin_y# = (global_y * vl_unit_size_pixels)
	;origin_x# = Floor((global_x * vl_unit_size_pixels) + .5)
	;origin_y# = Floor((global_y * vl_unit_size_pixels) + .5)

	For i = 0 To mesh\last_vert_i

		; Transform mesh vertex into entity's global scale/rotation.
		vert_x# = (mesh\vert_x[i] * global_scale_x) * vl_unit_size_pixels
		vert_y# = (mesh\vert_y[i] * global_scale_y) * vl_unit_size_pixels

		trans_x# = (vert_x * cos_rot) - (vert_y * sin_rot)
		trans_y# = (vert_y * cos_rot) + (vert_x * sin_rot)
		
		; Store transformed vertex in entity's vertex buffer.
		visuals\vert_x[i] = Floor((origin_x + trans_x) + .5)
		visuals\vert_y[i] = Floor((origin_y + trans_y) + .5)

	Next

	; Flag to renderer that this entity is to be drawn (i.e. it's not hidden).
	visuals\draw_me = True

End Function


;
; Transforms an entity's mesh vertices into absolute world coords.
; The transformed vertices are stored in the given entity's vertex buffer.
;
; Params:
; entity         - The entity whose mesh vertices are to be transformed.
; global_x       - The entity's global X coord.
; global_y       - The entity's global Y coord.
; global_rot     - The entity's global rotation.
; global_scale_x - The entity's global X scale.
; global_scale_y - The entity's global Y scale.
;
Function vl__tform_entity_world(entity.vl_entityT, global_x#, global_y#, global_rot#, global_scale_x#, global_scale_y#)

	visuals.vl_visualsT	= entity\visuals
	mesh.vl_meshT				= visuals\mesh

	cos_rot# = Cos(global_rot)
	sin_rot# = Sin(global_rot)

	For i = 0 To mesh\last_vert_i

		; Transform mesh vertex into entity's global scale/rotation.
		vert_x# = (mesh\vert_x[i] * global_scale_x)
		vert_y# = (mesh\vert_y[i] * global_scale_y)

		trans_x# = (vert_x * cos_rot) - (vert_y * sin_rot)
		trans_y# = (vert_y * cos_rot) + (vert_x * sin_rot)
		
		; Store transformed vertex in entity's vertex buffer.
		visuals\vert_x[i] = global_x + trans_x
		visuals\vert_y[i] = global_y + trans_y

	Next

End Function


;
; Frees a given entity's immediate children (and sub-children, via recursion).
;
; Params:
; parent - The entity whose immediate children are to be freed.
;
Function vl__free_children(parent.vl_entityT)

	child_link.vl_elinkT = parent\first_child

	; Free all parent's immediate children.
	While child_link &lt;&gt; Null

		entity.vl_entityT = child_link\entity

		If entity\class = VL_CLASS_MESH	
	
			mesh.vl_meshT = entity\visuals\mesh
			vl__delete_user(mesh, entity)
			
			; Delete this mesh if no other entities are using it.
			If mesh\first_user = Null Then Delete mesh
		
			Delete entity\visuals
	
		EndIf

		If entity\pick_mode Then vl__delete_pickable(entity)
	
		If entity\first_child &lt;&gt; Null
			; Recursion: free all this child entity's immediate children.
			vl__free_children(entity)
		EndIf

		Delete entity

		prev_link.vl_elinkT = child_link	
		child_link = child_link\next_elink
		Delete prev_link
		
	Wend

End Function


;
; Copies a given entity's children (and sub-children, via recursion).
;
; Params:
; entity - The entity whose immediate children are to be copied.
; parent - The entity to be made the parent of the new copy.
;
Function vl__copy_children(entity.vl_entityT, parent.vl_entityT)

	child_link.vl_elinkT = entity\first_child

	; Copy all entity's immediate children.
	While child_link &lt;&gt; Null

		source_entity.vl_entityT = child_link\entity
		
		;
		; Create and initialize new entity copy.
		;

		new_entity.vl_entityT = New vl_entityT
		new_entity_ID = Handle(new_entity)

		new_entity\visuals			= Null
		new_entity\scale_x			= source_entity\scale_x
		new_entity\scale_y			= source_entity\scale_y
		new_entity\rot					= source_entity\rot
		new_entity\x						= source_entity\x
		new_entity\y						= source_entity\y
		new_entity\parent				= Null
		new_entity\first_child	= Null
	
		new_entity\class				= source_entity\class
		new_entity\hidden				= False
		new_entity\name					= source_entity\name
		new_entity\radius				= source_entity\radius
		new_entity\box_x				= source_entity\box_x
		new_entity\box_y				= source_entity\box_y
		new_entity\box_width		= source_entity\box_width
		new_entity\box_height		= source_entity\box_height
	
		vl__entity_pick_mode(new_entity, source_entity\pick_mode, source_entity\obscurer)
	
		If source_entity\class = VL_CLASS_MESH
	
			visuals.vl_visualsT			= source_entity\visuals
			new_visuals.vl_visualsT	= New vl_visualsT
			new_entity\visuals			= new_visuals
	
			vl__add_user(visuals\mesh, new_entity)
			vl__entity_order(new_entity, visuals\order)
	
			new_visuals\mesh				= visuals\mesh
			new_visuals\r						= visuals\r
			new_visuals\g						= visuals\g
			new_visuals\b						= visuals\b
			new_visuals\brightness	= visuals\brightness
	
		EndIf

		vl__add_child(parent, new_entity)

		; Recursively copy any child entities.
		If source_entity\first_child &lt;&gt; Null Then vl__copy_children(source_entity, new_entity)

		child_link = child_link\next_elink

	Wend

End Function


;
; Returns the first child of an entity with the given name. All the entity's 
; children and sub-children are searched, via recursion.
;
; Params:
; parent    - The entity whose immediate children are to be searched.
; name      - The name of the child to find (case sensitive).
;
; Returns:
; The given entity's first child with the specified name.
;
Function vl__find_child.vl_entityT(parent.vl_entityT, name$)

	child_link.vl_elinkT = parent\first_child

	While child_link &lt;&gt; Null

		entity.vl_entityT = child_link\entity

		If entity\name$ = name$ Then Return entity

		If entity\first_child &lt;&gt; Null

			child.vl_entityT = vl__find_child(entity, name$)
			If child &lt;&gt; Null Then Return child

		EndIf
		
		child_link = child_link\next_elink

	Wend

	Return Null
	
End Function


;
; Sets the drawing order of an entity.
;
; Params:
; entity - Entity whose draw order is to be set.
; order  - Order the entity will be drawn in.
;
Function vl__entity_order(entity.vl_entityT, order%)

	visuals.vl_visualsT	= entity\visuals
	visuals\order				= order

	For this.vl_visualsT = Each vl_visualsT

		If this\order &lt; order
		
			Insert visuals Before this
			Return

		EndIf

	Next

	Insert visuals After Last vl_visualsT
		
End Function


;
; Returns an entity's X position coordinate.
;
; Params:
; entity - Entity whose X coord is to be returned.
; glob   - True returns the entity's global X coord.
;          False (default) returns the entity's local X coord.
;
; Returns:
; The given entity's current X coord. 
;
Function vl__entity_x#(entity.vl_entityT, glob% = False)

	If (glob = False) Or (entity\parent = Null)
	
		Return entity\x

	Else
	
		global_x# = 0.0
		total_rot# = vl__entity_rotation(entity\parent, True)

		Repeat

			dx# = entity\x * vl__entity_scale_x(entity\parent, True)
			dy# = entity\y * vl__entity_scale_y(entity\parent, True)
			
			trans_x# = (dx * Cos(total_rot)) - (dy * Sin(total_rot))
	
			global_x = global_x + trans_x

			entity = entity\parent
			
			If entity\parent = Null Then Return global_x + entity\x
			
			total_rot = total_rot - entity\rot
			
		Forever

	EndIf

End Function


;
; Returns an entity's Y position coordinate.
;
; Params:
; entity - Entity whose Y coord is to be returned.
; glob   - True returns the entity's global Y coord.
;          False (default) returns the entity's local Y coord.
;
; Returns:
; The given entity's current Y coord. 
;
Function vl__entity_y#(entity.vl_entityT, glob% = False)

	If (glob = False) Or (entity\parent = Null)
	
		Return entity\y

	Else
	
		global_y# = 0.0
		total_rot# = vl__entity_rotation(entity\parent, True)

		Repeat

			dx# = entity\x * vl__entity_scale_x(entity\parent, True)
			dy# = entity\y * vl__entity_scale_y(entity\parent, True)

			trans_y# = (dy * Cos(total_rot)) + (dx * Sin(total_rot))
	
			global_y = global_y + trans_y

			entity = entity\parent
			
			If entity\parent = Null Then Return global_y + entity\y
			
			total_rot = total_rot - entity\rot
			
		Forever
		
	EndIf

End Function


;
; Returns an entity's angle of rotation.
;
; Params:
; entity - Entity whose rotation is to be returned.
; glob   - True returns the entity's global rotation.
;          False (default) returns the entity's local rotation.
;
; Returns:
; The given entity's current angle of rotation. 
;
Function vl__entity_rotation#(entity.vl_entityT, glob% = False)

	If glob
	
		total_rot# = 0.0
		
		Repeat
		
			total_rot = total_rot + entity\rot
			entity = entity\parent
		
		Until entity = Null

		Return vl__clamp_rot(total_rot)
	
	Else

		Return entity\rot
	
	EndIf
	
End Function


;
; Returns an entity's X axis scale.
;
; Params:
; entity - Entity whose X scale is to be returned.
; glob   - True returns the entity's global X scale.
;          False (default) returns the entity's local X scale.
;
; Returns:
; The given entity's current X axis scale. 
;
Function vl__entity_scale_x#(entity.vl_entityT, glob% = False)

	If glob
	
		scale_x# = 1.0
		
		Repeat
		
			scale_x = scale_x * entity\scale_x
			entity = entity\parent
		
		Until entity = Null

		Return scale_x
	
	Else
	
		Return entity\scale_x

	EndIf
	
End Function


;
; Returns an entity's Y axis scale.
;
; Params:
; entity - Entity whose Y scale is to be returned.
; glob   - True returns the entity's global Y scale.
;          False (default) returns the entity's local Y scale.
;
; Returns:
; The given entity's current Y axis scale. 
;
Function vl__entity_scale_y#(entity.vl_entityT, glob% = False)

	If glob
	
		scale_y# = 1.0
		
		Repeat
		
			scale_y = scale_y * entity\scale_y
			entity = entity\parent
		
		Until entity = Null

		Return scale_y
	
	Else
	
		Return entity\scale_y

	EndIf
	
End Function


;
; Determines whether an entity is visible or not.
;
; Params:
; entity - Entity whose visibility is to be returned.
;
; Returns:
; True if the entity is visible, False otherwise.
;
Function vl__entity_visible(entity.vl_entityT)

	parent.vl_entityT = entity\parent
	
	While parent &lt;&gt; Null

		If entity\hidden Then Return False
	
		entity = parent
		parent = entity\parent
		
	Wend
	
	Return (Not entity\hidden)

End Function


;
; Sets an entity's pick mode.
;
; Params:
; entity    - Entity whose pick mode is to be set.
; mode      - Mode of geometry to be used when picking the entity:
;             0 = None (unpickable)
;             1 = Circle (vl_entity_radius is used)
;             2 = Polygon (uses the polygon defined by the mesh's vector lines)
;             3 = Box (vl_entity_box is used)
; obscurer  - True to determine the entity 'obscures' other entities
;             during a vl_entity_visible() call. 
;
Function vl__entity_pick_mode(entity.vl_entityT, mode%, obscurer%)

	If mode
	
		If (Not entity\pick_mode) Then vl__add_pickable(entity)
		
	Else
	
		If entity\pick_mode Then vl__delete_pickable(entity)
		
	EndIf
	
	entity\pick_mode	= mode
	entity\obscurer		= (obscurer &lt;&gt; 0)

End Function


;
; Returns the width of a mesh.
;
; Params:
; entity - Entity whose mesh width is to be returned.
;
; Returns:
; The given entity's mesh width.
;
Function vl__mesh_width#(entity.vl_entityT)

	mesh.vl_meshT = entity\visuals\mesh

	If mesh\last_vert_i = -1 Then Return 0.0
	
	biggest#	= mesh\vert_x[0]
	smallest#	= biggest

	For i = 1 To mesh\last_vert_i

		vert_x# = mesh\vert_x[i]

		If vert_x &gt; biggest
		
			biggest = vert_x
		
		ElseIf vert_x &lt; smallest
		
			smallest = vert_x
			
		EndIf
		
	Next

	Return (biggest - smallest)

End Function


;
; Returns the height of a mesh.
;
; Params:
; entity - Entity whose mesh height is to be returned.
;
; Returns:
; The given entity's mesh height.
;
Function vl__mesh_height#(entity.vl_entityT)

	mesh.vl_meshT = entity\visuals\mesh

	If mesh\last_vert_i = -1 Then Return 0.0
	
	biggest#	= mesh\vert_y[0]
	smallest#	= biggest

	For i = 1 To mesh\last_vert_i

		vert_y# = mesh\vert_y[i]

		If vert_y &gt; biggest
		
			biggest = vert_y
		
		ElseIf vert_y &lt; smallest
		
			smallest = vert_y
			
		EndIf
		
	Next

	Return (biggest - smallest)

End Function


;
; Determines whethera line intersects the bounding box defined by the transformed
; vertices of an entity.
; Note: vl__tform_entity_world() must have been called on the given entity, prior to calling this function!
;
; Params:
; entity - Entity whose world bounding box is to be checked for intersection with the pick line.
; x,y    - Start coords of pick line.
; dx,dy  - Delta coords of pick line.
;
; Returns:
; True if the pick line intersects the entity's world bounding box, False otherwise.
;
Function vl__line_intersects_vert_box(entity.vl_entityT, x#, y#, dx#, dy#)

	visuals.vl_visualsT	= entity\visuals
	
	last_vert_i = visuals\mesh\last_vert_i

	If last_vert_i = -1 Then Return False
	
	;
	; Find transformed entity's world bounding box metrics.
	;
	
	biggest_x#	= visuals\vert_x[0]
	smallest_x#	= biggest_x

	biggest_y#	= visuals\vert_y[0]
	smallest_y#	= biggest_y

	For i = 1 To last_vert_i

		vert_x# = visuals\vert_x[i]
		vert_y# = visuals\vert_y[i]

		If vert_x &gt; biggest_x
		
			biggest_x = vert_x
					
		ElseIf vert_x &lt; smallest_x
		
			smallest_x = vert_x
			
		EndIf

		If vert_y &gt; biggest_y
		
			biggest_y = vert_y
		
		ElseIf vert_y &lt; smallest_y
		
			smallest_y = vert_y
			
		EndIf
		
	Next

	bw# = biggest_x - smallest_x
	bh# = biggest_y - smallest_y
	
	; Check if the pick line intersects any bounding box edge.
	If vl__lines_intersect(smallest_x, smallest_y, bw,   0,  x, y, dx, dy) Return True
	If vl__lines_intersect(biggest_x,  smallest_y, 0,   bh,  x, y, dx, dy) Return True
	If vl__lines_intersect(biggest_x,  biggest_y,  -bw,  0,  x, y, dx, dy) Return True
	If vl__lines_intersect(smallest_x, biggest_y,  0,  -bh,  x, y, dx, dy) Return True

	; Check if the pick line is entirely contained within the bounding box.
	If ((x + dx) &lt; smallest_x) Or ((x + dx) &gt; biggest_x) Then Return False
	If ((y + dy) &lt; smallest_y) Or ((y + dy) &gt; biggest_y) Then Return False

	Return True

End Function


;
; Determines whether the bounding boxes defined by the transformed
; vertices of two entities intersect, or not.
; Note: vl__tform_entity_world() must have been called on the given entities, prior to calling this function!
;
; Params:
; entity_a - First entity whose vertex bounding box is to be checked.
; entity_b - Second entity whose vertex bounding box is to be checked.
;
; Returns:
; True if the two entities vertex bounding boxes intersect, False otherwise.
;
Function vl__vert_boxes_intersect(entity_a.vl_entityT, entity_b.vl_entityT)

	a_last_vert_i = entity_a\visuals\mesh\last_vert_i
	b_last_vert_i = entity_b\visuals\mesh\last_vert_i

	If (a_last_vert_i = -1) Or (b_last_vert_i = -1) Then Return False
	
	;
	; Find entity A's vertex bounding box metrics.
	;
	
	visuals.vl_visualsT = entity_a\visuals
	
	a_biggest_x#	= visuals\vert_x[0]
	a_smallest_x#	= a_biggest_x

	a_biggest_y#	= visuals\vert_y[0]
	a_smallest_y#	= a_biggest_y

	For i = 1 To a_last_vert_i

		vert_x# = visuals\vert_x[i]
		vert_y# = visuals\vert_y[i]

		If vert_x &gt; a_biggest_x
			a_biggest_x = vert_x
		ElseIf vert_x &lt; a_smallest_x
			a_smallest_x = vert_x
		EndIf

		If vert_y &gt; a_biggest_y
			a_biggest_y = vert_y
		ElseIf vert_y &lt; a_smallest_y
			a_smallest_y = vert_y
		EndIf
		
	Next

	;
	; Find entity B's vertex bounding box metrics.
	;

	visuals.vl_visualsT = entity_b\visuals
	
	b_biggest_x#	= visuals\vert_x[0]
	b_smallest_x#	= b_biggest_x

	b_biggest_y#	= visuals\vert_y[0]
	b_smallest_y#	= b_biggest_y

	For i = 1 To b_last_vert_i

		vert_x# = visuals\vert_x[i]
		vert_y# = visuals\vert_y[i]

		If vert_x &gt; b_biggest_x
			b_biggest_x = vert_x
		ElseIf vert_x &lt; b_smallest_x
			b_smallest_x = vert_x
		EndIf

		If vert_y &gt; b_biggest_y
			b_biggest_y = vert_y
		ElseIf vert_y &lt; b_smallest_y
			b_smallest_y = vert_y
		EndIf
		
	Next

	If (a_smallest_x &lt;= b_biggest_x) And (a_biggest_x &gt;= b_smallest_x) And (a_smallest_y &lt;= b_biggest_y) And (a_biggest_y &gt;= b_smallest_y)
		Return True
	Else
		Return False
	EndIf

End Function


;
; Determines whether a point is inside the bounding box defined by the transformed
; vertices of an entity.
; Note: vl__tform_entity_world must have been called on the given entity, prior to calling this function!
;
; Params:
; entity - Entity whose world bounding box is to be checked for containment of point.
; x,y    - World point to check.
;
; Returns:
; True if the point is inside the entity's world bounding box, False otherwise.
;
Function vl__point_in_vert_box(entity.vl_entityT, x#, y#)

	visuals.vl_visualsT = entity\visuals

	last_vert_i = visuals\mesh\last_vert_i

	If last_vert_i = -1 Then Return False
	
	;
	; Find transformed entity's world bounding box metrics.
	;
	
	biggest_x#	= visuals\vert_x[0]
	smallest_x#	= biggest_x

	biggest_y#	= visuals\vert_y[0]
	smallest_y#	= biggest_y

	For i = 1 To last_vert_i

		vert_x# = visuals\vert_x[i]
		vert_y# = visuals\vert_y[i]

		If vert_x &gt; biggest_x
			biggest_x = vert_x
		ElseIf vert_x &lt; smallest_x
			smallest_x = vert_x
		EndIf

		If vert_y &gt; biggest_y
			biggest_y = vert_y
		ElseIf vert_y &lt; smallest_y
			smallest_y = vert_y
		EndIf
		
	Next

	; Check if the point is contained within the bounding box.
	If (x &lt; smallest_x) Or (x &gt; biggest_x) Then Return False
	If (y &lt; smallest_y) Or (y &gt; biggest_y) Then Return False

	Return True

End Function


;
; Determines whether a line intersects a circle. If there is an intersection, the
; point of intersection is returned in the global variables vl_intersect_x and vl_intersect_y.
; Note: A line that starts inside the circle is never considered to intersect the circle!
;
; Params:
; x1,y1  - Start coord of line.
; dx,dy  - Line delta coords.
; cx,cy  - Centre point of circle.
; radius - Radius of circle.
;
; Returns:
; True if the line intersects the circle, false otherwise.
;
Function vl__line_intersects_circle(x1#, y1#, dx#, dy#,  cx#, cy#, radius#)

	A# = dx * dx + dy * dy
	B# = (dx * (x1 - cx) + dy * (y1 - cy)) * 2.0
	C# = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - (radius * radius)

  det# = (B * B) - ((A * 4.0) * C)

	If (A &lt;= 0.000001) Or (det &lt; 0)

		Return False

	Else

		t# = (-B - Sqr(det)) / (A * 2.0)

		If (t &gt;= 0) And (t &lt;= 1)

			vl_intersect_x = x1 + (t * dx)
			vl_intersect_y = y1 + (t * dy)

			Return True

		EndIf

		Return False

	End If

End Function


;
; Determines whether two lines intersect without calculating the actual point of intersection.
;
; Params:
; x1,y1   - Start coords of first line.
; dx1,dy1 - Delta coords of first line.
; x2,y2   - Start coords of second line.
; dx2,dy2 - Delta coords of second line.
;
; Returns:
; True if the lines intersect, false otherwise.
;
Function vl__lines_intersect(x1#, y1#, dx1#, dy1#,  x2#, y2#, dx2#, dy2#)
	
	u_b# = dy2 * dx1 - dx2 * dy1

	If (u_b &lt;&gt; 0) 

		ua_t# = (dx2 * (y1 - y2)) - (dy2 * (x1 - x2))
		ub_t# = (dx1 * (y1 - y2)) - (dy1 * (x1 - x2))
		
		ua# = ua_t / u_b
		ub# = ub_t / u_b

		If (ua &gt;= 0 And ua =&lt; 1 And ub &gt;= 0 And ub =&lt; 1) Then Return True

	EndIf

	Return False
	
End Function


;
; Determines whether two lines intersect, or not. If the lines do intersect, the
; point of intersection is returned in the global variables vl_intersect_x and vl_intersect_y.
;
; Params:
; x1,y1   - Start coords of first line.
; dx1,dy1 - Delta coords of first line.
; x2,y2   - Start coords of second line.
; dx2,dy2 - Delta coords of second line.
;
; Returns:
; True if the lines intersect, false otherwise.
;
Function vl__lines_intersect_xy(x1#, y1#, dx1#, dy1#,  x2#, y2#, dx2#, dy2#)
	
	u_b# = dy2 * dx1 - dx2 * dy1

	If (u_b &lt;&gt; 0) 

		ua_t# = (dx2 * (y1 - y2)) - (dy2 * (x1 - x2))
		ub_t# = (dx1 * (y1 - y2)) - (dy1 * (x1 - x2))
		
		ua# = ua_t / u_b
		ub# = ub_t / u_b
	
		If (ua &gt;= 0 And ua &lt;= 1 And ub &gt;= 0 And ub &lt;= 1) 

			vl_intersect_x = x1 + (ua * dx1)
			vl_intersect_y = y1 + (ua * dy1)

			Return True

		EndIf 

	EndIf

	Return False
	
End Function


;
; Determines whether a point lies inside the polygon defined by the hard lines of the
; specified, transformed entity's mesh.
; Note: vl__tform_entity_world() must have been called on the given entity, prior to
;       calling this function!
;       Also, the hard lines of the mesh must define a convex polygon else erroneous
;       results could occur.
;
; Params:
; entity - Entity whose transformed mesh polygon is to be checked.
; x,y    - World point to check.
;
; Returns:
; True if the point is inside the mesh polygon, false otherwise.
;
Function vl__point_in_polygon(entity.vl_entityT, x#, y#)

	visuals.vl_visualsT	= entity\visuals
	mesh.vl_meshT				= visuals\mesh
	
	in = False
	
	For i = 0 To mesh\last_line_i
	
		If mesh\line_hard[i]
		
			; Get this mesh line start and end verts.
			v0_i = mesh\line_v0_i[i]
			v1_i = mesh\line_v1_i[i]
	
			x1# = visuals\vert_x[v0_i]
			y1# = visuals\vert_y[v0_i]
	
			x2# = visuals\vert_x[v1_i]
			y2# = visuals\vert_y[v1_i]
	
			If ((((y1 &lt;= y) And (y &lt; y2)) Or ((y2 &lt;= y) And (y &lt; y1))) And (x &lt; (((x2 - x1) * (y - y1)) / (y2 - y1)) + x1))
				in = Not in
			EndIf

		EndIf
		
	Next

	Return in
	
End Function
</textarea><br><br>And here's a bare-bones Asteroid thingy, to demonstrate. Controls: Cursor keys and SPACE to fire.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Include "vent_lib3.bb"

vl_graphics 1024,768,0,1
vl_vertex_size 1

Const Upkey = 200
Const DownKey = 208
Const LeftKey = 205
Const Rightkey = 203

;Global Camera = CreateCamera()
;PositionEntity Camera,0,0,-150
	Global frame_count%
	Global fps%
	Global slowest_fps%
	Global fps_timeout%
	Global frame_time%
	Global slowest_frame%
	Global frame_start%
	fps_timer = CreateTimer(60) ; Set to desired FPS.
	slowmo% = False


Type Player
	Field Model
	Field SpeedX#
	Field SpeedY#
	Field TurnSpeed#
	Field TurnDrag#
	Field TurnAcceleration#
	Field MoveDrag#
	Field MoveAcceleration#
	Field MoveDeceleration#
End Type

Type bulletT
	Field entity
End Type

Global ME.player = PLAYERcreate()

SetBuffer BackBuffer()

;main program
While Not KeyDown(1)
	frame_start = MilliSecs()
	If KeyHit(14) Then slowmo = Not slowmo

	If KeyHit(57)
		bullet.bulletT = New bulletT
		bullet\entity = vl_create_point(ME\model)
		vl_move_entity(bullet\entity, 1, 0)
		vl_entity_parent(bullet\entity, 0)
	EndIf
	
	update_bullets()
	PLAYERmove( ME )
	Cls
	vl_render_world()

	frame_time = MilliSecs() - frame_start	
	show_info()

	;WaitTimer(fps_timer)
	VWait
	Flip 0

	If slowmo Then Delay 200
Wend
End

;===============================================
;===============================================
;===============================================

Function update_bullets()

	For this.bulletT = Each bulletT
		vl_move_entity(this\entity, .05, 0, True)
	Next

End Function


Function PLAYERcreate.Player()

	p.player = New Player
	p\SpeedX# = 0
	p\SpeedY# = 0
	p\TurnSpeed# = 0
	p\TurnAcceleration# = 0.03
	p\TurnDrag# = .99
	p\MoveAcceleration# = 0.001
	p\MoveDeceleration# = 0.001
	p\MoveDrag = .99
		
	;MaxSpeed = .03 / ( 1.0 -.99 ) = 3
	;MaxTurnSpeed = .05 / ( 1.0 - .99 ) = 5
		
	p\Model = vl_create_polygon()
	vl_scale_entity p\Model, .4,.2
	vl_position_entity p\model, 5,5
	
	Return p
	
End Function

;===============================================
;===============================================
;===============================================

Function PLAYERmove( p.Player )

	;turning
	Turn# = KeyDown (LeftKey) - KeyDown(RightKey)
	p\TurnSpeed# = turn*2;p\TurnSpeed# * p\TurnDrag + Turn * p\TurnAcceleration 
	vl_turn_entity p\Model, p\TurnSpeed

	;moving
	Direction# = KeyDown(UpKey) - KeyDown(DownKey)
	
	
	
	vl_tform_normal 1,0,  p\Model, 0
	Thrust# = ( Direction = 1 ) * p\MoveAcceleration - ( Direction = -1 ) * p\MoveDeceleration 
	p\SpeedX = p\SpeedX * p\MoveDrag + Thrust * vl_tformed_x() 
	p\SpeedY = p\SpeedY * p\MoveDrag + Thrust * vl_tformed_y()
	vl_translate_entity p\Model, p\SpeedX , p\SpeedY

End Function


;
; Display debug info.
;
Function show_info()
	
	If fps_timeout
		frame_count = frame_count + 1

		If MilliSecs() &gt; fps_timeout Then
			fps_timeout = MilliSecs() + 1000 
			fps = frame_count 
			frame_count = 0 
		
			If fps &lt; slowest_fps Or slowest_fps = 0 Then slowest_fps = fps
		EndIf 
		
		If frame_time &gt; slowest_frame Then slowest_frame = frame_time
		
		Color 255,255,0
		Text 10,25," Millisecs: " + frame_time
		Text 10,40,"   Slowest: " + slowest_frame
		Color 0,255,255
		Text 10,55,"       FPS: " + fps
		Text 10,70,"     Worst: " + slowest_fps
		Color 255,255,255
	Else
		; First call initialization.
		fps_timeout = MilliSecs() + 1000 
	EndIf
	
End Function
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2013</font></td></tr></table></td></tr><tr ><td class="posttext"> Just went to try this, but it's unfortunately cut off at the end of the include -- might have to split it up a bit, not sure if there's a limit but it is nearly 64k in size so sounds likely. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>2013</font></td></tr></table></td></tr><tr ><td class="posttext"> Ah, yes. It seems to have been cut off. :( I'll see what I can do... <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
