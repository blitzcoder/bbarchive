<!DOCTYPE html><html lang="en" ><head ><title >BRL.Reflection: Pointer support</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >BRL.Reflection: Pointer support</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >BRL.Reflection: Pointer support</a><br><br>
<a name="959795"></a>

<a name="1179293"></a>

<a name="1179295"></a>

<a name="1179297"></a>

<a name="1179298"></a>

<a name="1179299"></a>

<a name="1179400"></a>

<a name="1179401"></a>

<a name="1179725"></a>

<a name="1180763"></a>

<a name="1182258"></a>

<a name="1182260"></a>

<a name="1261645"></a>

<a name="1261646"></a>

<a name="1261650"></a>

<a name="1261651"></a>

<a name="1261655"></a>

<a name="1261657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> snip <br><br></td></tr></table><br>
<a name="1261658"></a>

<a name="1291132"></a>

<a name="1291133"></a>

<a name="1291134"></a>

<a name="1291135"></a>

<a name="1291142"></a>

<a name="1291150"></a>

<a name="1291151"></a>

<a name="1291152"></a>

<a name="1291203"></a>

<a name="1291209"></a>

<a name="1291790"></a>

<a name="1291812"></a>

<a name="1291819"></a>

<a name="1291895"></a>

<a name="1293944"></a>

<a name="1294089"></a>

<a name="1294155"></a>

<a name="1299596"></a>

<a name="1299612"></a>

<a name="1299616"></a>

<a name="1299666"></a>

<a name="1299688"></a>

<a name="1299704"></a>

<a name="1299707"></a>

<a name="1299739"></a>

<a name="1301519"></a>

<a name="1301520"></a>

<a name="1301521"></a>

<a name="1312416"></a>

<a name="1312417"></a>

<a name="1317708"></a>

<a name="1317710"></a>

<a name="1317865"></a>

<a name="1317866"></a>

<a name="1317997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>UPDATED: September 3 2016 - version 1.28</b><br><br><b>!!!</b> Contains a potentially breaking change to how function return types are handled.  <b>!!!</b><br><b>!!!</b> Specificly <b>TMethod</b> and <b>TFunction</b> requires calling <i>TypeId().ReturnType()</i> instead of just <i>TypeId()</i> <b>!!!</b><br><b>!!!</b> Or one can call <i>TMethod.ReturnType()</i> and <i>TFunction.ReturnType()</i> directly <b>!!!</b><br><br><b>!!</b> Only mainline module that uses this is BRL.MaxLUA, so line 77 in maxlua.bmx would need to me modified to use this modified reflection <b>!!</b><br>If this change is unacceptable, see post <a href="/post.php?topic=84918&amp;post=1301518" target="_blank">#82</a> for a copy of reflection.bmx with original semantics. (untested)<br><br><b>!!</b> Win32 and Linux targets use assembly for more arguments (30), MacOS still uses old way (8).<br><br>see history in source below for more info.<br><br>Download precompiled: <a href="https://drive.google.com/open?id=0BzVLNZSckvfheERVLXpXc2NUOWc" target="_blank">brl.reflection.mod_grb_v1.28.7z</a><br>Or use the sources below...<br><br>mod/brl.mod/reflection.mod/reflection.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Rem
bbdoc: BASIC/Reflection
End Rem
Module BRL.Reflection

ModuleInfo "Version: 1.28"
ModuleInfo "Author: Mark Sibly"
ModuleInfo "License: zlib/libpng"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.28 [grable]"
ModuleInfo "History: Reverted back to old _Call() before assembly (max 8 arguments) for MacOSX"
ModuleInfo "History: 1.27 [Derron]"
ModuleInfo "History: Fixed MacOSX assembly not compiling"
ModuleInfo "History: 1.26 [Derron]"
ModuleInfo "History: Fixed TFunction.FunctionPtr() accessing supertype of Null"
ModuleInfo "History: 1.25 [grable]"
ModuleInfo "History: Fixed linux version of bbCallMethod"
ModuleInfo "History: Added macos version of bbCallMethod"
ModuleInfo "History: 1.24 [grable]"
ModuleInfo "History: Added linux version of bbCallMethod"
ModuleInfo "History: 1.23 [grable]"
ModuleInfo "History: Added _bbCallMethod() asm function for calling with proper number of arguments"
ModuleInfo "History: Increased maximum argument count to 30"
ModuleInfo "History: 1.22 [grable]"
ModuleInfo "History: Fixed _Call not working with Long/Double return types"
ModuleInfo "History: 1.21 [grable]"
ModuleInfo "History: Fixed _Push not setting bbEmptyArray for Null arrays."
ModuleInfo "History: 1.20 [derron]"
ModuleInfo "History: Fixed typo, and added Null argument to TMethod.Invoke()"
ModuleInfo "History: 1.19 [grable]"
ModuleInfo "History: Fixed TTypeId.PointerType() recursing over root PointerTypeId"
ModuleInfo "History: 1.18 [grable]"
ModuleInfo "History: Added check for NullTypeId in TypeTagForId, also improved error message"
ModuleInfo "History: 1.17 [grable]"
ModuleInfo "History: Fixed missing ElementType for ArrayTypeId"
ModuleInfo "History: 1.16 [gwron]"
ModuleInfo "History: minor adjustments to code (cleanup)."
ModuleInfo "History: 1.15 [brucey]"
ModuleInfo "History: fixed _Assign not setting bbEmptyArray for Null arrays."
ModuleInfo "History: 1.14 [grable]"
ModuleInfo "History: fixed missing call to ReturnType() in TMethod.Invoke()"
ModuleInfo "History: 1.13 [grable]"
ModuleInfo "History: fixed TypeTagForId() regarding pointers"
ModuleInfo "History: fixed _Push and _Assign regarding pointers"
ModuleInfo "History: 1.12 [grable]"
ModuleInfo "History: added TTypeId.ArraySlice() for slicing untyped arrays"
ModuleInfo "History: 1.11 [grable]"
ModuleInfo "History: refixed TMethod overrides, and added same for TFunction"
ModuleInfo "History: 1.10 [grable]"
ModuleInfo "History: fixed bug in FindConstant()"
ModuleInfo "History: added TField.FieldPtr() for direct pointer to instance fields"
ModuleInfo "History: 1.09 [grable]"
ModuleInfo "History: fixed parsing of function pointers with spaces via ForName"
ModuleInfo "History: 1.08 [grable]"
ModuleInfo "History: Added type constants (TConstant and relevant methods to TTypeId)"
ModuleInfo "History: 1.07 [grable]"
ModuleInfo "History: Minor fixes"
ModuleInfo "History: 1.06 [grable]"
ModuleInfo "History: Added function pointer support (FunctionTypeId...)"
ModuleInfo "History: Also did some reworking of TFunction/TMethod and pushed parsing of function metadata over to TypeIdForTag()"
ModuleInfo "History: 1.05 [Otus]"
ModuleInfo "History: Fixed TMethod overrides, Nested arrays (TTypeId.ForName)"
ModuleInfo "History: 1.04 [grable]"
ModuleInfo "History: Added pointer support (PointerTypeId...)"
ModuleInfo "History: 1.03 [blitz-forum]"
ModuleInfo "History: Added support for type functions (TFunction...)"

ModuleInfo "History: 1.02 Release"
ModuleInfo "History: Added Brucey's size fix to GetArrayElement()/SetArrayElement()"
ModuleInfo "History: 1.01 Release"
ModuleInfo "History: Fixed NewArray using temp type name"

Import BRL.LinkedList
Import BRL.Map

Import "reflection.cpp"

?Win32
Import "callmethod.win32.x86.s"
?Linux
Import "callmethod.linux.x86.s"
?MacOS
' disabled until i can figure out what special voodoo macs require
'Import "callmethod.macos.x86.s"
?

Private

?MacOS
Const MAX_CALL_ARGS:Int = 8
?Not MacOS
Const MAX_CALL_ARGS:Int = 30
?

Extern

Function bbObjectNew:Object( class )
Function bbObjectRegisteredTypes:Int Ptr( count Var )

Function bbArrayNew1D:Object( typeTag:Byte Ptr,length )
Function bbArraySlice:Object( typeTag:Byte Ptr,inarr:Object,start:Int,stop:Int )

Function bbRefArrayClass()
Function bbRefStringClass()
Function bbRefObjectClass()

Function bbRefArrayLength( array:Object, dim:Int = 0 )
Function bbRefArrayTypeTag$( array:Object )
Function bbRefArrayDimensions:Int( array:Object )
Function bbRefArrayCreate:Object( typeTag:Byte Ptr,dims:Int[] )
Function bbRefArrayNull:Object()

Function bbRefFieldPtr:Byte Ptr( obj:Object,index )
Function bbRefMethodPtr:Byte Ptr( obj:Object,index )
Function bbRefArrayElementPtr:Byte Ptr( sz,array:Object,index )

Function bbRefGetObject:Object( p:Byte Ptr )
Function bbRefPushObject( p:Byte Ptr,obj:Object )
Function bbRefInitObject( p:Byte Ptr,obj:Object )
Function bbRefAssignObject( p:Byte Ptr,obj:Object )

Function bbRefGetObjectClass( obj:Object )
Function bbRefGetSuperClass( class )

?Not MacOS
Function bbCallMethod:Int( p:Byte Ptr, args:Byte Ptr, sz:Int)
Function bbCallMethod_Float:Float( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
Function bbCallMethod_Object:Object( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
Function bbCallMethod_Double:Double( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
?
End Extern

Type TClass

	Method Compare( with:Object )
		Return _class-TClass( with )._class
	End Method
	
	Method SetClass:TClass( class )
		_class=class
		Return Self
	End Method
	
	Field _class
End Type

Function _Get:Object( p:Byte Ptr,typeId:TTypeId )
	Select typeId
	Case ByteTypeId
		Return String.FromInt( (Byte Ptr p)[0] )
	Case ShortTypeId
		Return String.FromInt( (Short Ptr p)[0] )
	Case IntTypeId
		Return String.FromInt( (Int Ptr p)[0] )
	Case LongTypeId
		Return String.FromLong( (Long Ptr p)[0] )
	Case FloatTypeId
		Return String.FromFloat( (Float Ptr p)[0] )
	Case DoubleTypeId
		Return String.FromDouble( (Double Ptr p)[0] )
	Default
		If typeid.ExtendsType(PointerTypeId) Or typeid.ExtendsType(FunctionTypeId) Then
			Return String.FromInt( (Int Ptr p)[0] )
		EndIf
		Return bbRefGetObject( p )
	End Select
End Function

Function _Push:Byte Ptr( sp:Byte Ptr,typeId:TTypeId,value:Object )
	Select typeId
	Case ByteTypeId,ShortTypeId,IntTypeId
		(Int Ptr sp)[0]=value.ToString().ToInt()
		Return sp+4
	Case LongTypeId
		(Long Ptr sp)[0]=value.ToString().ToLong()
		Return sp+8
	Case FloatTypeId
		(Float Ptr sp)[0]=value.ToString().ToFloat()
		Return sp+4
	Case DoubleTypeId
		(Double Ptr sp)[0]=value.ToString().ToDouble()
		Return sp+8
	Case StringTypeId
		If Not value value=""
		bbRefPushObject sp,value
		Return sp+4
	Default
		If typeid.ExtendsType(PointerTypeId) Then
			If value Then
				(Int Ptr sp)[0]=value.ToString().ToInt()
			Else
				(Int Ptr sp)[0]=0
			EndIf
			Return sp+4
		ElseIf typeid.ExtendsType(FunctionTypeId) Then
			If value Then
				(Int Ptr sp)[0]=value.ToString().ToInt()
			Else
				(Int Ptr sp)[0]=Int Byte Ptr NullFunctionError
			EndIf
			Return sp+4
		ElseIf typeId.ExtendsType(ArrayTypeId)
			If Not value Then value = bbRefArrayNull()
		EndIf
		If value
			Local c=typeId._class
			Local t=bbRefGetObjectClass( value )
			While t And t&lt;&gt;c
				t=bbRefGetSuperClass( t )
			Wend
			If Not t Throw "_Push() ERROR"
		EndIf
		bbRefPushObject sp,value
		Return sp+4
	End Select
End Function

Function _Assign( p:Byte Ptr,typeId:TTypeId,value:Object )
	Select typeId
	Case ByteTypeId
		(Byte Ptr p)[0]=value.ToString().ToInt()
	Case ShortTypeId
		(Short Ptr p)[0]=value.ToString().ToInt()
	Case IntTypeId
		(Int Ptr p)[0]=value.ToString().ToInt()
	Case LongTypeId
		(Long Ptr p)[0]=value.ToString().ToLong()
	Case FloatTypeId
		(Float Ptr p)[0]=value.ToString().ToFloat()
	Case DoubleTypeId
		(Double Ptr p)[0]=value.ToString().ToDouble()
	Case StringTypeId
		If Not value value=""
		bbRefAssignObject p,value
	Default
		If typeid.ExtendsType(PointerTypeId) Then
			If value Then
				(Int Ptr p)[0]=value.ToString().ToInt()
			Else
				(Int Ptr p)[0]=0
			EndIf
			Return
		ElseIf typeid.ExtendsType(FunctionTypeId) Then
			If value Then
				(Int Ptr p)[0]=value.ToString().ToInt()
			Else
				(Int Ptr p)[0]=Int Byte Ptr NullFunctionError
			EndIf
			Return
		ElseIf typeId.ExtendsType(ArrayTypeId)
			If Not value Then value = bbRefArrayNull()
		EndIf
		If value
			Local c=typeId._class
			Local t=bbRefGetObjectClass( value )
			While t And t&lt;&gt;c
				t=bbRefGetSuperClass( t )
			Wend
			If Not t Throw "_Assign() ERROR"
		EndIf
		bbRefAssignObject p,value
	End Select
End Function

'
' bmx fallback path for calling methods. for macos
'
?MacOS
Function _Call:Object( callableP:Byte Ptr, retTypeId:TTypeId, obj:Object=Null, args:Object[], argtypes:TTypeId[])
	Assert args.Length = argtypes.Length

	Local q:Int[MAX_CALL_ARGS + 2], sp:Byte Ptr = q
	
	If obj 'method call of an instance
		bbRefPushObject sp,obj
		sp:+4
	EndIf
	
	Local lret:Long
	If retTypeId = LongTypeId Then
		Byte Ptr Ptr(sp)[0] = Byte Ptr Varptr lret
		sp :+ 4
	EndIf

	For Local i:Int = 0 Until args.Length
		If Int Ptr(sp) &gt;= Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #1"
		sp = _Push( sp, argtypes[i], args[i])
	Next
	If Int Ptr(sp) &gt; Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #2"
	
	Select retTypeId
		Case ByteTypeId, ShortTypeId, IntTypeId
			Local f(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
			Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
		Case LongTypeId
			Local r:Long
			If obj Then
				Local f( p0, r:Long Var, p1,p2,p3,p4,p5,p6,p7) = callableP
				f( q[0], r, q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
			Else
				Local f( r:Long Var, p0, p1,p2,p3,p4,p5,p6,p7) = callableP
				f( r, q[0], q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
			EndIf
			Return String.FromLong(r)
		Case FloatTypeId
			Local f:Float(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
			Return String.FromFloat( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
		Case DoubleTypeId
			Local f:Double(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
			Return String.FromDouble( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
		Default
			If retTypeId.ExtendsType(PointerTypeId) Or retTypeId.ExtendsType(FunctionTypeId) Then
				Local f:Int(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
				Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Else
				Local f:Object(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
				Return f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
			EndIf
	End Select
End Function
?

'
' asembly path for calling methods. for linux and win32
'
?Not MacOS
Function _Call:Object( callableP:Byte Ptr, retTypeId:TTypeId, obj:Object=Null, args:Object[], argtypes:TTypeId[])
	Assert args.Length = argtypes.Length

	Local q:Int[MAX_CALL_ARGS + 2], sp:Byte Ptr = q
	
	If obj 'method call of an instance
		bbRefPushObject sp,obj
		sp:+4
	EndIf
	
	Local lret:Long
	If retTypeId = LongTypeId Then
		Byte Ptr Ptr(sp)[0] = Byte Ptr Varptr lret
		sp :+ 4
	EndIf

	For Local i:Int = 0 Until args.Length
		If Int Ptr(sp) &gt;= Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #1"
		sp = _Push( sp, argtypes[i], args[i])
	Next
	If Int Ptr(sp) &gt; Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #2"
	
	Local size:Int = sp - Byte Ptr q
	Select retTypeId
		Case ByteTypeId, ShortTypeId, IntTypeId
			Return String.FromInt( bbCallMethod( callableP, q, size) )
		Case LongTypeId
			bbCallMethod( callableP, q, size)
			Return String.FromInt( lret )
		Case FloatTypeId
			Return String.FromFloat( bbCallMethod_Float( callableP, q, size) )
		Case DoubleTypeId
			Return String.FromDouble( bbCallMethod_Double( callableP, q, size) )
		Default
			If retTypeId.ExtendsType(PointerTypeId) Or retTypeId.ExtendsType(FunctionTypeId) Then
				Return String.FromInt( bbCallMethod( callableP, q, size) )
			Else
				Return bbCallMethod_Object( callableP, q, size)
			EndIf
	End Select
End Function
?

Function TypeTagForId$( id:TTypeId )
	If id.ExtendsType( ArrayTypeId )
		Return "[]"+TypeTagForId( id.ElementType() )
	EndIf
	If id.ExtendsType( ObjectTypeId )
		Return ":"+id.Name()
	EndIf
	If id.ExtendsType( PointerTypeId )
		Local t:TTypeId = id.ElementType()
		If t Then Return "*"+TypeTagForId(t)
		Return "*"
	EndIf
	If id.ExtendsType( FunctionTypeId )
		Local s:String
		For Local t:TTypeId = EachIn id._argTypes
			If s Then s :+ ","
			s :+ TypeTagForId(t)
		Next
		s = "(" + s + ")"
		If id._retType Then s :+ TypeTagForId(id._retType)
		Return s
	EndIf
	Select id
		Case ByteTypeId Return "b"
		Case ShortTypeId Return "s"
		Case IntTypeId Return "i"
		Case LongTypeId Return "l"
		Case FloatTypeId Return "f"
		Case DoubleTypeId Return "d"
		Case StringTypeId Return "$"
		Case NullTypeId Return "Null"
	End Select
	Throw "~q" + id.Name() + "~q was unexpected at this time"
End Function

Function TypeIdForTag:TTypeId( ty$ )
	If ty.StartsWith( "[" )
		Local dims:Int = ty.split(",").length
		ty=ty[ty.Find("]")+1..]
		Local id:TTypeId = TypeIdForTag( ty )
		If id Then
			id._arrayType = Null
			id=id.ArrayType(dims)
		End If
		Return id
	EndIf
	If ty.StartsWith( ":" )
		ty=ty[1..]
		Local i=ty.FindLast( "." )
		If i&lt;&gt;-1 ty=ty[i+1..]
		Return TTypeId.ForName( ty )
	EndIf
	If ty.StartsWith( "(" ) Then
		Local t:String[]
		Local idx:Int = ty.FindLast(")")
		If idx &gt; 0 Then
			t = [ ty[1..idx], ty[idx+1..] ]
		Else
			t = [ ty[1..], "" ]
		EndIf
		Local retType:TTypeId=TypeIdForTag( t[1] ), argTypes:TTypeId[]
		If t[0].length&gt;0 Then
			Local i,b,q$=t[0], args:TList=New TList
			#first_loop
			While i&lt;q.length
				Select q[i]
				Case Asc( "," )
					args.AddLast q[b..i]
					i:+1
					b=i
				Case Asc( "[" )
					i:+1
					While i&lt;q.length And q[i]=Asc(",")
						i:+1
					Wend
				Case Asc( "(" )
					Local level:Int = 1
					i:+1
					While i&lt;q.Length
						If q[i] = Asc(",") Then
							If level = 0 Then Continue first_loop
						ElseIf q[i] = Asc(")") Then
							level :- 1
						ElseIf q[i] = Asc("(") Then 
							level :+ 1
						EndIf
						i:+1
					Wend
				Default
					i:+1
				End Select
			Wend
			If b &lt; q.Length Then args.AddLast q[b..]
			
			argTypes=New TTypeId[args.Count()]

			i=0
			For Local s:String = EachIn args
				argTypes[i]=TypeIdForTag( s )
				If Not argTypes[i] Then argTypes[i] = ObjectTypeId
				i:+1
			Next
		EndIf
		If Not retType Then retType = ObjectTypeId
		retType._functionType = Null
		Return retType.FunctionType(argTypes)
	EndIf
	If ty.StartsWith( "*" ) Then
		ty = ty[1..]
		Local id:TTypeId = TypeIdForTag( ty )
		If id Then
			id._pointerType = Null
			id = id.PointerType()
		EndIf
		Return id
	EndIf
	Select ty
		Case "b" Return ByteTypeId
		Case "s" Return ShortTypeId
		Case "i" Return IntTypeId
		Case "l" Return LongTypeId
		Case "f" Return FloatTypeId
		Case "d" Return DoubleTypeId
		Case "$" Return StringTypeId
	End Select
End Function

Function ExtractMetaData$( meta$,key$ )
	If Not key Return meta
	Local i=0
	While i&lt;meta.length
		Local e=meta.Find( "=",i )
		If e=-1 Throw "Malformed meta data"
		Local k$=meta[i..e],v$
		i=e+1
		If i&lt;meta.length And meta[i]=Asc("~q")
			i:+1
			Local e=meta.Find( "~q",i )
			If e=-1 Throw "Malformed meta data"
			v=meta[i..e]
			i=e+1
		Else
			Local e=meta.Find( " ",i )
			If e=-1 e=meta.length
			v=meta[i..e]
			i=e
		EndIf
		If k=key Return v
		If i&lt;meta.length And meta[i]=Asc(" ") i:+1
	Wend
End Function
	
Public

Rem
bbdoc: Primitive byte type
End Rem
Global ByteTypeId:TTypeId=New TTypeId.Init( "Byte",1 )

Rem
bbdoc: Primitive short type
End Rem
Global ShortTypeId:TTypeId=New TTypeId.Init( "Short",2 )

Rem
bbdoc: Primitive int type
End Rem
Global IntTypeId:TTypeId=New TTypeId.Init( "Int",4 )

Rem
bbdoc: Primitive long type
End Rem
Global LongTypeId:TTypeId=New TTypeId.Init( "Long",8 )

Rem
bbdoc: Primitive float type
End Rem
Global FloatTypeId:TTypeId=New TTypeId.Init( "Float",4 )

Rem
bbdoc: Primitive double type
End Rem
Global DoubleTypeId:TTypeId=New TTypeId.Init( "Double",8 )

Rem
bbdoc: Primitive object type
End Rem
Global ObjectTypeId:TTypeId=New TTypeId.Init( "Object",4,bbRefObjectClass() )

Rem
bbdoc: Primitive string type
End Rem
Global StringTypeId:TTypeId=New TTypeId.Init( "String",4,bbRefStringClass(),ObjectTypeId )

Rem
bbdoc: Primitive array type
End Rem
Global ArrayTypeId:TTypeId=New TTypeId.Init( "Null[]",4,bbRefArrayClass(),ObjectTypeId )

Rem
bbdoc: Primitive pointer type
End Rem
Global PointerTypeId:TTypeId=New TTypeId.Init( "Ptr",4 )

Rem
bbdoc: Primitive function type
End Rem
Global FunctionTypeId:TTypeId=New TTypeId.Init( "Null()",4 )

Rem
bbdoc: Primitive null type
End Rem
Global NullTypeId:TTypeId=New TTypeId.Init( "Null",4 )

' finish setup of array type
ArrayTypeId._ElementType = NullTypeId

Rem
bbdoc: Type member - field or method.
End Rem
Type TMember

	Rem
	bbdoc: Get member name
	End Rem
	Method Name$()
		Return _name
	End Method

	Rem
	bbdoc: Get member type
	End Rem	
	Method TypeId:TTypeId()
		Return _typeId
	End Method
	
	Rem
	bbdoc: Get member meta data
	End Rem
	Method MetaData$( key$="" )
		Return ExtractMetaData( _meta,key )
	End Method
	
	Field _name$,_typeId:TTypeId,_meta$
	
End Type

Rem
bbdoc: Type constant
EndRem
Type TConstant Extends TMember
	Method Init:TConstant( name:String, typeId:TTypeId, meta:String, rtti:Int)
		_name = name
		_typeId = typeId
		_meta = meta
		_rtti = Int Ptr(rtti) + 2 ' now points at string: [dd size][db data...]
		Return Self
	EndMethod

	Rem
	bbdoc: Get constant value
	EndRem
	Method GetString:String()
		Return String.FromShorts( Short Ptr(_rtti+1), _rtti[0])
	EndMethod

	Rem
	bbdoc: Get constant value as @Int
	EndRem
	Method GetInt:Int()
		Return GetString().ToInt()
	EndMethod

	Rem
	bbdoc: Get constant value as @Float
	EndRem	
	Method GetFloat:Int()
		Return GetString().ToFloat()
	EndMethod

	Rem
	bbdoc: Get constant value as @Long
	EndRem	
	Method GetLong:Int()
		Return GetString().ToLong()
	EndMethod

	Rem
	bbdoc: Get constant value as @Double
	EndRem	
	Method GetDouble:Int()
		Return GetString().ToDouble()
	EndMethod

	Rem
	bbdoc: Get constant value as @{Byte Ptr}
	EndRem
	Method GetPointer:Byte Ptr()
		Return Byte Ptr GetString().ToInt()
	EndMethod
		
	Field _rtti:Int Ptr
EndType

Rem
bbdoc: Type field
End Rem
Type TField Extends TMember

	Method Init:TField( name$,typeId:TTypeId,meta$,index )
		_name=name
		_typeId=typeId
		_meta=meta
		_index=index
		Return Self
	End Method

	Rem
	bbdoc: Get field value
	End Rem
	Method Get:Object( obj:Object )
		Return _Get( bbRefFieldPtr( obj,_index ),_typeId )
	End Method
	
	Rem
	bbdoc: Get int field value
	End Rem
	Method GetInt:Int( obj:Object )
		Return GetString( obj ).ToInt()
	End Method
	
	Rem
	bbdoc: Get long field value
	End Rem
	Method GetLong:Long( obj:Object )
		Return GetString( obj ).ToLong()
	End Method
	
	Rem
	bbdoc: Get float field value
	End Rem
	Method GetFloat:Float( obj:Object )
		Return GetString( obj ).ToFloat()
	End Method
	
	Rem
	bbdoc: Get double field value
	End Rem
	Method GetDouble:Double( obj:Object )
		Return GetString( obj ).ToDouble()
	End Method
	
	Rem
	bbdoc: Get string field value
	End Rem
	Method GetString$( obj:Object )
		Return String( Get( obj ) )
	End Method
		
	Rem
	bbdoc: Get pointer field value
	End Rem
	Method GetPointer:Byte Ptr( obj:Object)
		Return Byte Ptr GetString(obj).ToInt()
	EndMethod		
	
	Rem
	bbdoc: Set field value
	End Rem
	Method Set( obj:Object,value:Object )
		_Assign bbRefFieldPtr( obj,_index ),_typeId,value
	End Method
	
	Rem
	bbdoc: Set int field value
	End Rem
	Method SetInt( obj:Object,value:Int )
		SetString obj,String.FromInt( value )
	End Method
	
	Rem
	bbdoc: Set long field value
	End Rem
	Method SetLong( obj:Object,value:Long )
		SetString obj,String.FromLong( value )
	End Method
	
	Rem
	bbdoc: Set float field value
	End Rem
	Method SetFloat( obj:Object,value:Float )
		SetString obj,String.FromFloat( value )
	End Method
	
	Rem
	bbdoc: Set double field value
	End Rem
	Method SetDouble( obj:Object,value:Double )
		SetString obj,String.FromDouble( value )
	End Method
	
	Rem
	bbdoc: Set string field value
	End Rem
	Method SetString( obj:Object,value$ )
		Set obj,value
	End Method
		
	Rem
	bbdoc: Set pointer field value
	End Rem
	Method SetPointer( obj:Object, value:Byte Ptr)
		SetString(obj, String.FromInt(Int value))
	EndMethod

	Rem
	bbdoc: Get the pointer to the field of an instance
	about: this returns a @{direct pointer to the instance field}
	End Rem
	Method FieldPtr:Byte Ptr( obj:Object)
		Return bbRefFieldPtr( obj, _index)
	EndMethod
	
	Rem
	bbdoc: Invoke function pointer field
	End Rem
	Method Invoke:Object( obj:Object, args:Object[] = Null)
		Return _Call( GetPointer(obj), _typeId.ReturnType(), Null, args, _typeId.ArgTypes())
	EndMethod	
	
	Field _index
	
End Type

Rem
bbdoc: Type method
End Rem
Type TMethod Extends TMember

	Method Init:TMethod( name$,typeId:TTypeId,meta$,selfTypeId:TTypeId,index )
		_name=name
		_typeId=typeId
		_meta=meta
		_selfTypeId=selfTypeId
		_index=index
		If _index &gt;= 65536 Then
			_fptr = Byte Ptr(_index)
		Else
			_fptr = Null
		EndIf
		Return Self
	End Method
	
	Rem
	bbdoc: Get method arg types
	End Rem
	Method ArgTypes:TTypeId[]()
		Return _typeId._argTypes
	End Method
		
	Rem
	bbdoc: Get method return type
	End Rem
	Method ReturnType:TTypeId()
		Return _typeId._retType
	End Method

	Rem
	bbdoc: Get method function pointer
	endrem
	Method FunctionPtr:Byte Ptr( obj:Object)
		If _fptr Then Return _fptr
		If _index &lt; 65536 Then
			_fptr = bbRefMethodPtr( obj ,_index)
		EndIf
		Return _fptr
	End Method

	Rem
	bbdoc: Invoke method
	End Rem
	Method Invoke:Object( obj:Object,args:Object[] = Null )
		Return _Call( FunctionPtr(obj), ReturnType(), obj, args, ArgTypes() )
	End Method
	
	Field _selfTypeId:TTypeId,_index
	Field _fptr:Byte Ptr
End Type

Rem
bbdoc: Type function
endrem
Type TFunction Extends TMember
	Method Init:TFunction(name:String, typeId:TTypeId, meta:String, selfTypeId:TTypeId, index:Int)
		_name=name
		_typeId=typeId
		_meta=meta
		_selfTypeId=selfTypeId		
		_index=index
		If _index &gt;= 65536 Then
			_fptr = Byte Ptr(_index)
		Else
			_fptr = Null
		EndIf
		Return Self
	End Method

	Rem
	bbdoc: Get function arg types
	End Rem
	Method ArgTypes:TTypeId[]()
		Return _typeId._argTypes
	End Method
	
	Rem
	bbdoc: Get function return type
	End Rem
	Method ReturnType:TTypeId()
		Return _typeId._retType
	End Method
		
	Rem
	bbdoc: Get function pointer.
	endrem
	Method FunctionPtr:Byte Ptr( obj:Object)
		If _fptr Then Return _fptr
		If _index &lt; 65536 Then
			If Not obj Then
				_fptr = Byte Ptr Int Ptr(_selfTypeId._class + _index)[0]
			Else
				_fptr = bbRefMethodPtr( obj ,_index)
			EndIf
		EndIf
		Return _fptr
	End Method
	
	Rem
	bbdoc: Invoke type function
	endrem	
	Method Invoke:Object( obj:Object, args:Object[] = Null)
		Return _Call( FunctionPtr(obj), ReturnType(), Null, args, ArgTypes())
	End Method
	
	Field _selfTypeId:TTypeId, _fptr:Byte Ptr, _index:Int
EndType
	
Rem
bbdoc: Type id
End Rem
Type TTypeId

	Rem
	bbdoc: Get name of type
	End Rem
	Method Name$()
		Return _name
	End Method
	
	Rem
	bbdoc: Get type meta data
	End Rem	
	Method MetaData$( key$="" )
		Return ExtractMetaData( _meta,key )
	End Method

	Rem
	bbdoc: Get super type
	End Rem	
	Method SuperType:TTypeId()
		Return _super
	End Method
	
	Rem
	bbdoc: Get array type
	End Rem
	Method ArrayType:TTypeId(dims:Int = 1)
		If Not _arrayType
			Local dim:String
			If dims &gt; 1 Then
				For Local i:Int = 1 Until dims
					dim :+ ","
				Next
			End If
			_arrayType=New TTypeId.Init( _name+"[" + dim + "]",4,bbRefArrayClass() )
			_arrayType._elementType=Self
			If _super
				_arrayType._super=_super.ArrayType()
			Else
				_arrayType._super=ArrayTypeId
			EndIf
		EndIf
		Return _arrayType
	End Method
		
	Rem
	bbdoc: Get element type
	End Rem
	Method ElementType:TTypeId()
		Return _elementType
	End Method
		
	Rem
	bbdoc: Get pointer type
	End Rem
	Method PointerType:TTypeId()
		If Not _pointerType Then
			_pointerType = New TTypeId.Init( _name + " Ptr", 4)
			_pointerType._elementType = Self
			If _super Then
				_pointerType._super = _super.PointerType()
				_pointerType._TypeTag = TypeTagForId(_pointerType).ToCString()
			Else
				_pointerType._super = PointerTypeId
				_pointerType._TypeTag = "*".ToCString()
			EndIf
		EndIf
		Return _pointerType
	End Method
		
	Rem
	bbdoc: Get function pointer type
	End Rem
	Method FunctionType:TTypeId( args:TTypeId[]=Null)
		If Not _functionType Then
			Local s:String
			For Local t:TTypeId = EachIn args
				If s Then s :+ ","
				s :+ t.Name()
			Next
			_functionType = New TTypeId.Init( _name + "(" + s + ")", 4)
			_functionType._retType = Self
			_functionType._argTypes = args
			If _super Then
				_functionType._super = _super.FunctionType()
			Else
				_functionType._super = FunctionTypeId
			EndIf
		EndIf
		Return _functionType
	End Method
		
	Rem
	bbdoc: Get function return type
	End Rem
	Method ReturnType:TTypeId()
		If Not _retType Then Throw "TypeID is not a function type"
		Return _retType
	End Method
		
	Rem
	bbdoc: Get function argument types
	End Rem
	Method ArgTypes:TTypeId[]()
		If Not _retType Then Throw "TypeID is not a function type"
		Return _argTypes
	End Method		
	
	Rem
	bbdoc: Determine if type extends a type
	End Rem
	Method ExtendsType( typeId:TTypeId )
		If Self=typeId Return True
		If _super Return _super.ExtendsType( typeId )
	End Method
	
	Rem
	bbdoc: Get list of derived types
	End Rem
	Method DerivedTypes:TList()
		If Not _derived _derived=New TList
		Return _derived
	End Method

	Rem
	bbdoc: Create a new object
	End Rem	
	Method NewObject:Object()
		If Not _class Throw "Unable to create new object"
		Return bbObjectNew( _class )
	End Method
	
	Rem
	bbdoc: Get list of constants
	about: Only returns constants declared in this type, not in super types.
	End Rem
	Method Constants:TList()
		Return _consts
	End Method	
	
	Rem
	bbdoc: Get list of fields
	about: Only returns fields declared in this type, not in super types.
	End Rem
	Method Fields:TList()
		Return _fields
	End Method
	
	Rem
	bbdoc: Get list of methods
	about: Only returns methods declared in this type, not in super types.
	End Rem
	Method Methods:TList()
		Return _methods
	End Method
	
	Rem
	bbdoc: Get ist of functions
	about: Only returns functions declared in this type, not in super types.
	endrem
	Method Functions:TList()
		Return _functions
	End Method	
	
	Rem
	bbdoc: Find a field by name
	about: Searchs type hierarchy for field called @name.
	End Rem
	Method FindField:TField( name$ )
		name=name.ToLower()
		For Local t:TField=EachIn _fields
			If t.Name().ToLower()=name Return t
		Next
		If _super Return _super.FindField( name )
	End Method
	
	Rem
	bbdoc: Find a constant by name
	about: Searchs type hierarchy for constant called @name.
	End Rem
	Method FindConstant:TConstant( name$ )
		name=name.ToLower()
		For Local t:TConstant=EachIn _consts
			If t.Name().ToLower()=name Return t
		Next
		If _super Return _super.FindConstant( name )
	End Method	
	
	Rem
	bbdoc: Find a method by name
	about: Searchs type hierarchy for method called @name.
	End Rem
	Method FindMethod:TMethod( name$ )
		name=name.ToLower()
		For Local t:TMethod=EachIn _methods
			If t.Name().ToLower()=name Return t
		Next
		If _super Return _super.FindMethod( name )
	End Method
		
	Rem
	bbdoc: Find a function by name
	about: Searches type heirarchy for function called @name
	endrem
	Method FindFunction:TFunction(name:String)
		name = name.ToLower()
		For Local t:TFunction = EachIn _functions
			If t.Name().ToLower() = name Return t
		Next
		If _super Return _super.FindFunction(name)
	End Method
	
	Rem
	bbdoc: Enumerate all constants
	about: Returns a list of all constants in type hierarchy
	End Rem	
	Method EnumConstants:TList( list:TList=Null )
		If Not list list=New TList
		If _super _super.EnumConstants list
		For Local t:TConstant=EachIn _consts
			list.AddLast t
		Next
		Return list
	End Method
	
	Rem
	bbdoc: Enumerate all fields
	about: Returns a list of all fields in type hierarchy
	End Rem	
	Method EnumFields:TList( list:TList=Null )
		If Not list list=New TList
		If _super _super.EnumFields list
		For Local t:TField=EachIn _fields
			list.AddLast t
		Next
		Return list
	End Method
	
	Rem
	bbdoc: Enumerate all methods
	about: Returns a list of all methods in type hierarchy
	End Rem
	Method EnumMethods:TList( list:TList=Null )
		Function cmp_by_index:Int( a:TMethod, b:TMethod)
			Return a._index - b._index
		EndFunction
		
		If Not list list=New TList
		If _super And _super &lt;&gt; Self Then _super.EnumMethods list
		For Local t:TMethod=EachIn _methods
			list.AddLast t
		Next
		'FIX: remove overridden methods
'		list.Sort()
'		Local prev:TMethod
'		For Local t:TMethod = EachIn list
'			If prev Then
'				If (t._index - prev._index) = 0 Then list.Remove(prev)
'			EndIf
'			prev = t
'		Next
		list.Sort( True, Byte Ptr cmp_by_index)
		Local prev:TMethod
		For Local t:TMethod = EachIn list
			If prev Then
				If (t._index - prev._index) = 0 Then list.Remove(prev)
			EndIf
			prev = t
		Next
		
		Return list
	End Method	

	Rem
	bbdoc: Enumerate all functions
	about: Returns a list of all functions in type hierarchy
	End Rem
	Method EnumFunctions:TList( list:TList=Null )
		Function cmp_by_name:Int( a:TFunction, b:TFunction)
			Return a.Name().Compare(b.Name())
		EndFunction

		If Not list list=New TList
		If _super And _super &lt;&gt; Self Then _super.EnumFunctions list
		For Local t:TFunction=EachIn _functions
			list.AddLast t
		Next
		
		'FIX: remove overridden functions
		list.Sort( True, Byte Ptr cmp_by_name)
		Local prev:TFunction
		For Local t:TFunction = EachIn list
			If prev Then				
				If (t.Name().Compare(prev.Name())) = 0 Then list.Remove(prev)
			EndIf
			prev = t
		Next

		Return list
	End Method

	Rem
	bbdoc: Create a new array
	End Rem
	Method NewArray:Object( length, dims:Int[] = Null )
		If Not _elementType Throw "TypeID is not an array type"
		Local tag:Byte Ptr=_elementType._typeTag
		If Not tag
			tag=TypeTagForId( _elementType ).ToCString()
			_elementType._typeTag=tag
		EndIf
		If Not dims Then
			Return bbArrayNew1D( tag,length )
		Else
			Return bbRefArrayCreate( tag, dims )
		End If
	End Method
		
	Rem
	bbdoc: Create a new array slice from another array
	End Rem
	Method ArraySlice:Object( a:Object, start:Int = 0, stop:Int = -1 )
		If Not _elementType Throw "TypeID is not an array type"
		Local tag:Byte Ptr=_elementType._typeTag
		If Not tag
			tag=TypeTagForId( _elementType ).ToCString()
			_elementType._typeTag=tag
		EndIf
		If stop &lt; 0 Then
			stop = bbRefArrayLength( a, 0)
		EndIf
		Return bbArraySlice( tag, a, start, stop)
	End Method
	
	Rem
	bbdoc: Get array length
	End Rem
	Method ArrayLength( array:Object, dim:Int = 0 )
		If Not _elementType Throw "TypeID is not an array type"
		Return bbRefArrayLength( array, dim )
	End Method
	
	Rem
	bbdoc: Get the number of dimensions
	End Rem
	Method ArrayDimensions:Int( array:Object )
		If Not _elementType Throw "TypeID is not an array type"
		Return bbRefArrayDimensions( array )
	End Method
	
	Rem
	bbdoc: Get an array element
	End Rem
	Method GetArrayElement:Object( array:Object,index )
		If Not _elementType Throw "TypeID is not an array type"
		Local p:Byte Ptr=bbRefArrayElementPtr( _elementType._size,array,index )
		Return _Get( p,_elementType )
	End Method
	
	Rem
	bbdoc: Set an array element
	End Rem
	Method SetArrayElement( array:Object,index,value:Object )
		If Not _elementType Throw "TypeID is not an array type"
		Local p:Byte Ptr=bbRefArrayElementPtr( _elementType._size,array,index )
		_Assign p,_elementType,value
	End Method
	
	Rem
	bbdoc: Get Type by name
	End Rem
	Function ForName:TTypeId( name$ )
		_Update
		' arrays
		If name.EndsWith( "[]" )
			name=name[..name.length-2].Trim()
			Local elementType:TTypeId = ForName( name )
			If Not elementType Then Return Null
			Return elementType.ArrayType()
		' pointers
		ElseIf name.EndsWith( "Ptr" )
			name=name[..name.length-4].Trim()
			If Not name Then Return Null
			Local baseType:TTypeId = ForName( name )
			If baseType Then
				' check for valid pointer base types
				Select baseType
					Case ByteTypeId, ShortTypeId, IntTypeId, LongTypeId, FloatTypeId, DoubleTypeId
						Return baseType.PointerType()
					Default
						If baseType.ExtendsType(PointerTypeId) Then Return baseType.PointerType()
				EndSelect
			EndIf
			Return Null
		' function pointers
		ElseIf name.EndsWith( ")" )
			' check if its in the table already
			Local t:TTypeId = TTypeId( _nameMap.ValueForKey( name.ToLower() ) )
			If t Then Return t
			Local i:Int = name.Find("(")
			Local ret:TTypeId = ForName( name[..i].Trim())
			Local typs:TTypeId[]
			If Not ret Then ret = NullTypeId
			If ret Then
				Local params:String = name[i+1..name.Length-1].Trim()
				If params Then
					Local args:String[] = params.Split(",")
					If args.Length &gt;= 1 And args[0] Then
						typs = New TTypeId[args.Length]
						For Local i:Int = 0 Until args.Length
							typs[i] = ForName(args[i].Trim())
							If Not typs[i] Then typs[i] = ObjectTypeId
						Next
					EndIf
				EndIf
				ret._functionType = Null
				Return ret.FunctionType(typs)
			EndIf
		Else
			' regular type name lookup
			Return TTypeId( _nameMap.ValueForKey( name.ToLower() ) )
		EndIf
	End Function	
Rem
	Function ForName:TTypeId( name$ )
		_Update
		If name.EndsWith( "]" )
			' TODO
			name=name[..name.length-2]
			Return TTypeId( _nameMap.ValueForKey( name.ToLower() ) ).ArrayType()
		Else
			Return TTypeId( _nameMap.ValueForKey( name.ToLower() ) )
		EndIf
	End Function
EndRem

	Rem
	bbdoc: Get Type by object
	End Rem	
	Function ForObject:TTypeId( obj:Object )
		_Update
		Local class=bbRefGetObjectClass( obj )
		If class=ArrayTypeId._class
			If Not bbRefArrayLength( obj ) Return ArrayTypeId
			Return TypeIdForTag( bbRefArrayTypeTag( obj ) ).ArrayType()
		Else
			Return TTypeId( _classMap.ValueForKey( New TClass.SetClass( class ) ) )
		EndIf
	End Function
	
	Rem
	bbdoc: Get list of all types
	End Rem
	Function EnumTypes:TList()
		_Update
		Local list:TList=New TList
		For Local t:TTypeId=EachIn _nameMap.Values()
			list.AddLast t
		Next
		Return list
	End Function

	'***** PRIVATE *****
	
	Method Init:TTypeId( name$,size,class=0,supor:TTypeId=Null )
		_name=name
		_size=size
		_class=class
		_super=supor
		_consts=New TList
		_fields=New TList
		_methods=New TList
		_functions=New TList
		_nameMap.Insert _name.ToLower(),Self
		If class _classMap.Insert New TClass.SetClass( class ),Self
		Return Self
	End Method
	
	Method SetClass:TTypeId( class )
		Local debug=(Int Ptr class)[2]
		Local name$=String.FromCString( Byte Ptr( (Int Ptr debug)[1] ) ),meta$
		Local i=name.Find( "{" )
		If i&lt;&gt;-1
			meta=name[i+1..name.length-1]
			name=name[..i]
		EndIf
		_name=name
		_meta=meta
		_class=class
		_nameMap.Insert _name.ToLower(),Self
		_classMap.Insert New TClass.SetClass( class ),Self
		Return Self
	End Method
	
	Function _Update()
		Local count,p:Int Ptr=bbObjectRegisteredTypes( count )
		If count=_count Return
		Local list:TList=New TList
		For Local i=_count Until count
			Local ty:TTypeId=New TTypeId.SetClass( p[i] )
			list.AddLast ty
		Next
		_count=count
		For Local t:TTypeId=EachIn list
			t._Resolve
		Next
	End Function
	
	Method _Resolve()
		If _fields Or Not _class Return
		
		_consts=New TList
		_fields=New TList
		_methods=New TList
		_functions=New TList
		_super=TTypeId( _classMap.ValueForKey( New TClass.SetClass( (Int Ptr _class)[0] ) ) )
		If Not _super _super=ObjectTypeId
		If Not _super._derived _super._derived=New TList
		_super._derived.AddLast Self
		
		Local debug=(Int Ptr _class)[2]
		Local p:Int Ptr=(Int Ptr debug)+2
		
		While p[0]
			Local id$=String.FromCString( Byte Ptr p[1] )
			Local ty$=String.FromCString( Byte Ptr p[2] )
			
			Local meta$
			Local i=ty.Find( "{" )
			If i&lt;&gt;-1
				meta=ty[i+1..ty.length-1]
				ty=ty[..i]
			EndIf

			Select p[0]
				Case 1	'const
					Local tt:TTypeId = TypeIdFortag(ty)
					If tt Then
						_consts.AddLast New TConstant.Init( id, tt, meta, p[3])
					EndIf
					
				Case 3	'field
					Local tt:TTypeId = TypeIdForTag(ty)
					If tt Then
						_fields.AddLast New TField.Init( id, tt, meta, p[3])
					EndIf
					
				Case 6	'method
					Local tt:TTypeId = TypeIdForTag(ty)
					If tt Then			
						_methods.AddLast New TMethod.Init( id, tt, meta, Self, p[3])
					EndIf
					
				Case 7	' function
					Local tt:TTypeId = TypeIdForTag(ty)
					If tt Then
						_functions.AddLast New TFunction.Init(id, tt, meta, Self, p[3])
					EndIf
			EndSelect
			p:+4
		Wend
	End Method
	
	Field _name$
	Field _meta$
	Field _class
	Field _size=4
	Field _consts:TList
	Field _fields:TList
	Field _methods:TList
	Field _functions:TList
	Field _super:TTypeId
	Field _derived:TList
	Field _arrayType:TTypeId
	Field _elementType:TTypeId
	Field _typeTag:Byte Ptr
	Field _pointerType:TTypeId
	Field _functionType:TTypeId, _argTypes:TTypeId[], _retType:TTypeId
	
	Global _count,_nameMap:TMap=New TMap,_classMap:TMap=New TMap
	
End Type

</textarea><br><br>mod/brl.mod/reflection.mod/reflection.cpp<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

#include &lt;brl.mod/blitz.mod/blitz.h&gt;
#include &lt;cstdarg&gt;

extern "C"{

void *bbRefFieldPtr( BBObject *obj,int index ){
	return (char*)obj+index;
}

void *bbRefMethodPtr( BBObject *obj,int index ){
	return *( (void**) ((char*)obj-&gt;clas+index) );
}

void *bbRefArrayElementPtr( int sz,BBArray *array,int index ){
	return (char*)BBARRAYDATA( array,array-&gt;dims )+sz*index;
}

BBArray* bbRefArrayNull() {
	return &amp;bbEmptyArray;
}

int bbRefArrayClass(){
	return (int)&amp;bbArrayClass;
}

int bbRefStringClass(){
	return (int)&amp;bbStringClass;
}

int bbRefObjectClass(){
	return (int)&amp;bbObjectClass;
}

int bbRefArrayLength( BBArray *array, int dim ){
	return array-&gt;scales[((dim &lt;= array-&gt;dims)? dim : 0)];
}

int bbRefArrayDimensions( BBArray *array ){
	return array-&gt;dims;
}

//Note: arrDims must be 1D int array...
BBArray *bbRefArrayCreate( const char *type,BBArray *arrDims ){
//	assert( arrDims-&gt;dims==1 );
//	assert( arrDims-&gt;type[0]=='i' );
	
	int dims=arrDims-&gt;scales[0];
	int *lens=(int*)BBARRAYDATA( arrDims,1 );
	
	return bbArrayNewEx( type,dims,lens );
}

BBString *bbRefArrayTypeTag( BBArray *array ){
	return bbStringFromCString( array-&gt;type );
}

BBObject *bbRefGetObject( BBObject **p ){
	return *p;
}

void bbRefPushObject( BBObject **p,BBObject *t ){
	*p=t;
}

void bbRefInitObject( BBObject **p,BBObject *t ){
	BBRETAIN( t );
	*p=t;
}

void bbRefAssignObject( BBObject **p,BBObject *t ){
	BBRETAIN( t );
	BBRELEASE( *p );
	*p=t;
}

BBClass *bbRefGetObjectClass( BBObject *p ){
	return p-&gt;clas;
}

BBClass *bbRefGetSuperClass( BBClass *clas ){
	return clas-&gt;super;
}

}
</textarea><br><br>mod/brl.mod/reflection.mod/callmethod.win32.x86.s<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
format MS COFF

public _bbCallMethod
extrn _memcpy

section	"code" code

_bbCallMethod:
	push ebp
	mov ebp, esp
	sub esp, dword [ebp+16]
	push dword [ebp+16]
	push dword [ebp+12]
	push esp
	call _memcpy
	add esp, 4
	call dword [ebp+8]
	mov esp, ebp
	pop ebp
	ret
</textarea><br><br>mod/brl.mod/reflection.mod/callmethod.linux.x86.s<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
format ELF

public bbCallMethod
extrn memcpy

section	"code"

bbCallMethod:
	push ebp
	mov ebp, esp
	sub esp, dword [ebp+16]
	push dword [ebp+16]
	push dword [ebp+12]
	push esp
	call memcpy
	add esp, 4
	call dword [ebp+8]
	mov esp, ebp
	pop ebp
	ret
</textarea><br><br>mod/brl.mod/reflection.mod/callmethod.macos.x86.s<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

.globl _bbCallMethod


.text

_bbCallMethod:
	pushl   %ebp
	movl    %esp,%ebp
	subl    0x10(%ebp),%esp
	pushl  0x10(%ebp)
	pushl  0xc(%ebp)
	pushl   %esp
	calll   _memcpy
	addl    $0x4,%esp
	calll   *0x8(%ebp)
	movl    %ebp,%esp
	popl    %ebp
	ret
</textarea> <br><br></td></tr></table><br>
<a name="959860"></a>

<a name="1179291"></a>

<a name="1179292"></a>

<a name="1179294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> snip <br><br></td></tr></table><br>
<a name="961582"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Would it be possible to create something like EnumFunctions() for functions which don't belong to a type?<br><br>I can create a TFunction manually for a function I already know about, proving that functions work the same wherever they are:<br><pre class=code>
Function a(s$)
	Print s
End Function

f:tfunction=New tfunction.init("a",IntTypeId.functiontype([StringTypeId]),"",IntTypeId,a)
f.invoke(["hi"])
</pre><br><br>but I don't know enough about how the debugger works internally to be able to find arbitrary functions.<br><br>How I imagine it working is something like: f:TFunction = TFunction.ForFunction(a) <br><br></td></tr></table><br>
<a name="961739"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is possible. But only in Debug mode, as no meta-data is stored for functions in Release mode :/<br><br>The meta-data is related to the Debug Scope, so its in its own table.<br>Decoding it shouldnt pose a problem though, its getting access to it.<br><br>Any ideas? <br><br></td></tr></table><br>
<a name="1030497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >spacerat</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> This code doesn't seem to work any more. When I call TTypeID.ForName("class name") for any class, I usually get an EXCEPTION_ACCESS_VIOLATION, and the debugger points to line 1139:<br><pre class=code>	_functions.AddLast New TFunction.Init(id, tt, meta, Self, Byte Ptr(Int Ptr(Self._class + p[3])[0]) )</pre><br><br>Before finding this thread I'd been using the code I stuck together at the end of this <a href="http://www.blitzmax.com/Community/posts.php?topic=84420#956203" target="_blank">http://www.blitzmax.com/Community/posts.php?topic=84420#956203</a> thread, which crashes in the same way on the equivalent line. I suppose some internal change to blitz broke it; can anyone spread any light on what changed or how to fix it? <br><br></td></tr></table><br>
<a name="1031884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> The original BRL.Reflection hasnt changed though, so im guessing the meta-data hasnt changed either.<br>I just tried some tests with 1.39 and i cant get it to crash on any of my tests.<br><br>Can you give me an example?<br><br>Btw, you say it "usually" crashes. Does this mean it works some of the time?<br>If so it might not be the reflection code, but some other memory related error. <br><br></td></tr></table><br>
<a name="1039129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >n-Halbleiter</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another thing I just found out: You forgot to add <br><pre class=code>	_functions=New TList</pre><br>to the Method "Init" of TTypeID. Adding this prevents your program to crash sometimes, if you tried to look up an unexistent function, because ObjectTypeID does not have a list "_functions".<br><br>So the (slightly) modified Method "Init" could look like this:<br><pre class=code>	Method Init:TTypeId( name$,size,class=0,supor:TTypeId=Null )
		_name=name
		_size=size
		_class=class
		_super=supor
		_fields=New TList
		_methods=New TList
		_functions=New TList
		_nameMap.Insert _name.ToLower(),Self
		If class _classMap.Insert New TClass.SetClass( class ),Self
		Return Self
	End Method</pre><br><br>Just wanted to mention. :)<br><br>EDIT: Corrected typing mistake... <br><br></td></tr></table><br>
<a name="1089920"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >n-Halbleiter</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just one thing I just noticed:<br><br>The modification seems not to work with BMax version 1.42. If I have a Function inside a type and when I try to do _anything_ with reflection it crashes in the line spacerat already mentioned. Can anyone confirm this?<br><br>Thanks in advance <br><br></td></tr></table><br>
<a name="1179296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> bump<br><br>top post has been updated with new BRL.Reflection. <br><br></td></tr></table><br>
<a name="1180764"></a>

<a name="1180765"></a>

<a name="1180766"></a>

<a name="1180767"></a>

<a name="1180768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> bug fix update. new version 1.10, see top post.<br><br>fixed a stupid bug in <b>FindConstant</b> and made <b>ForName</b> able to parse function types with spaces between elements.<br>allso added a new convenience method <b>TField.FieldPtr()</b> for a direct pointer to the field of and instance.<br><br>On a side note, I really wonder why globals within a type arent emitted like the rest of the elements.. even constants are emitted, just not exposed via the default reflection implementation.<br><br>It would be handy to have type globals as well i think :) <br><br></td></tr></table><br>
<a name="1182259"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> version 1.11:<br>refixed method overrides, allso did the same for functions (sorting by name and removing duplicates)<br>cant believe i missed this one for so long :p <br><br></td></tr></table><br>
<a name="1193774"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FabriceW</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wrote a little dependency injection module for blitzmax using reflection. It is working great with your modifications. <br><br>You can find it on GitHub: <a href="https://github.com/FWeinb/injection.mod" target="_blank">here</a> <br><br></td></tr></table><br>
<a name="1261501"></a>

<a name="1261529"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hallo. Here's a list of issues I found whilst applying these changes for bmx-ng :<br><br>* TypeTagForId() doesn't work properly for pointers.<br>* _Push and _Assign can crash for Pointer/Function types if value is null. <br><br></td></tr></table><br>
<a name="1261647"></a>

<a name="1261648"></a>

<a name="1261656"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks brucey, they fail in vanilla bmx too.. Some wrong assumptions on my part ;)<br><br>Pointer types now use _elementType to properly store its base.<br>And _Push/_Assign check for Null and sets 0 for pointers and NullFunctionError for function pointers.<br><br>EDIT: Left some bad code in last update, fixed now. <br><br></td></tr></table><br>
<a name="1290821"></a>

<a name="1290822"></a>

<a name="1290823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any ideas why the "updated revisions" (&gt;1.05 or so) do no longer work with LUA objects)?<br><br>I expose objects to lua, so eg. a lua script could call "list.Count()". With the current revision, this is no longer possible (it is not exposed).<br><br>When accessing an object my lua engine does something in the likes of:<br><pre class=code>
Local obj:Object = lua_unboxobject(getLuaState(), 1)
Local typeId:TTypeId = TTypeId.ForObject(obj)
Local ident:String = lua_tostring(getLuaState(), 2)
print "ident: "+ident +"  typeId: "+typeId.name()
</pre><br><br>so for aboves example this outputs "ident: Count  typeId: TList" - when running on an ancient version of the code (1.05 or so - at least it contains some of the changes you did, but I did not have pointer / functionpointers...).<br>Ok so when I updated the code, it now outputs "ident: Count  typeId: String".<br>Of course invokation of "Count()" is then no longer possible (as it sees it as a property then).<br><br>I assume it has to do with the changes done in the helper functions (ForTag etc.) and that it is coming from an external source (lua_unboxobject).<br><br>lua_unboxobject() could be found in "maxlua.mod/lua_object.c".<br><br><br>I also tried to replace some changed functions with other ones, but up to now without success.<br><br><br><b>Edit:</b><br><br>Samplecode:<br><pre class=code>
Strict

Type TMyObject
	Field myList:TList = CreateList()

	Method GetList:TList()
		Local list:TList = CreateList()
		list.AddLast("1")
		Return list
	End Method
End Type


Global myObject:TMyObject = New TMyObject
LuaRegisterObject(myobject,"myobject")


Global source:string = "function Run()~n print(~qmylist:~q .. myobject.myList.Count() .. ~q  GetList:~q .. myobject.GetList().Count())~nend~n"
Global luaClass:TLuaClass = TLuaClass.Create(source)
Local luaInstance:TLuaObject = TLuaObject.Create(luaClass, Null)

luaInstance.Invoke("Run",Null)
</pre><br><br>This returns "mylist:0  GetList:1" when using old reflection code (which could be found <a href="https://github.com/GWRon/Dig/blob/master/external/reflectionExtended/reflection.bmx" target="_blank">HERE</a>).<br>When using the extended reflection in it's current incarnation, it exits with an lua error: "[string "function Run()..."]:2: attempt to call field 'Count' (a nil value)".<br>To check it on your own you will have to adjust either brl.mod/reflection.mod - or adjust brl.mod/maxlua.mod to use your custom reflectionXYZ.mod.<br><br><br>Does someone have "inbetween" releases of the code, so I could check at which point of development it stopped working (for me) ?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1290947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> It also fails when calling some "extended objects" Super.Init()-calls (which call their Super.Init() and so on) ... I got errors in "TagForType()" with some null-properties. <br><br>Am not able to produce a small code snippet for now - but it seems to be something aside of the LUA connection.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291136"></a>

<a name="1291137"></a>

<a name="1291138"></a>

<a name="1291139"></a>

<a name="1291140"></a>

<a name="1291141"></a>

<a name="1291143"></a>

<a name="1291144"></a>

<a name="1291145"></a>

<a name="1291146"></a>

<a name="1291149"></a>

<a name="1291207"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, sorry about that. I made the TypeId of functions, methods and function pointers be the same (before, its TypeId was only its return type).<br>Essentially allowing for Function TypeIds, this in turn now requires to call <i>ReturnType()</i> to get at the return type.<br><br>There was a bug in my BRL.Reflection version too which didnt account for this when calling methods, added a fixed version above now.<br><br>For MaxLUA and any other code that uses a <b>TMethod</b> or <b>TFunction</b> and calling <i>TypeId()</i> on it to deduce its return type now has to use <i>TypeId().ReturnType()</i> or <i>TMethod.ReturnType()</i> instead...<br>I know its a breaking change :(<br><br>On line 77 in bmxlua.bmx change:<pre class=code>
Select meth.TypeId()
</pre>to<pre class=code>
Select meth.TypeId().ReturnType()
</pre>or<pre class=code>
Select meth.ReturnType()
</pre>And it should work again.<br><br><br>EDIT: If this change really bothers some people or messes up a lot of code, let me know. I could change TMethod.TypeId() and TFunction.TypeId() to return ONLY the return type directly and add an aditional .FunctionType() and/or .MethodType() to get at the full type (even though this would brake from the convention of .TypeId() returning the full type of any member) <br><br></td></tr></table><br>
<a name="1291153"></a>

<a name="1291154"></a>

<a name="1291155"></a>

<a name="1291166"></a>

<a name="1291168"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your new code - and some small adjustments, let my lua-connection does its duty again. Thanks.<br><br><br>Regarding "ReturnType()" and inconsistency: I understand your thoughts on this. I think the reason for a "TypeID" returning the call-result's type is, something similar to "consistency".<br><br>You do not need to know what special instance a "TMember"-extending object is, you just need to call memberOrExtendedMember.TypeID() to get the desired result.<br><br>The "member.TypeId().ReturnType()" is indeed a worthy replacement - if you know the existence of ReturnType() :-).<br><br><br><br>@functionType/methodType<br>I do not know what is more important: "backwards compatibility" (keeping other modules unchanged) or consistency?<br><br>I just searched mods/brl.mod for "TypeID(" and only maxlua.bmx seems to use it for now.<br><br>What about "TypeID()" returning the member typeID (TFunction, TConstant...) and "ValueTypeID()" returning the typeID for whatever is returned (for functions this is the result type, for constants the TypeID(). <br><br>Keeping it backwards compatible would lead to "MemberTypeID()" returning TConstant, TField, TFunction, .. and "TypeID()" returning the return value "type".<br>Hmpf, somehow I cannot come up with something really helpful now, maybe others will come to help regarding that issue.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Edit: maybe you want to incorporate Brucey's fix regarding Null-Arrays:<br><br><a href="https://github.com/maxmods/brl.mod/commit/fbbdbc8d222d115a11d0f2eb7ebe5556c29347f4" target="_blank">https://github.com/maxmods/brl.mod/commit/fbbdbc8d222d115a11d0f2eb7ebe5556c29347f4</a><br><br><br>Else I would wait some days and modify the maxmods-reflection.mod to reflect your current changes (and then adjust maxlua.mod if needed).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291204"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for letting me know about that one Derron :)<br>Updated top post, and i changed it a little so one doesnt need mingw to recompile. <br><br></td></tr></table><br>
<a name="1291247"></a>

<a name="1291248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doesn't your adjustment (regarding Brucey's bbRefArrayNull) remove the possibility to check if the returned value is a NullArray?<br><br>In Brucey's code the "bbRefArrayNull" is always the same (the pointer to a special object is returned ?) in yours there is a fresh object created everytime.<br><br>Or did I miss something - what is the difference between your approach and Brucey's ? I just want to avoid that we miss something Brucey added by intention...<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291614"></a>

<a name="1291616"></a>

<a name="1291620"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Needed to add this to reflection.cpp<br><br><pre class=code>
BBArray * bbRefArrayNull() {
	return &amp;bbEmptyArray;
}
</pre><br><br>and to reflection.bmx:<br><br>in externs:<br><pre class=code>Function bbRefArrayNull:Object()</pre><br><br>and replace<br><pre class=code>
		If value
			Local c=typeId._class
			Local t=bbRefGetObjectClass( value )
			While t And t&lt;&gt;c
				t=bbRefGetSuperClass( t )
			Wend
			If Not t Throw "ERROR"
		EndIf
		bbRefAssignObject p,value
</pre><br><br>with<br><pre class=code>
		If value
			Local c=typeId._class
			Local t=bbRefGetObjectClass( value )
			While t And t&lt;&gt;c
				t=bbRefGetSuperClass( t )
			Wend
			If Not t Throw "ERROR"
		Else
			If typeId.Name().Endswith("]") Then
				value = bbRefArrayNull()
			EndIf
		EndIf
		bbRefAssignObject p,value
</pre><br>(as done by Brucey).<br><br><br>Without that change I get segfaults in a sample code of my framework.<br><pre class=code>
Function TypeTagForId$( id:TTypeId )
	If id.ExtendsType( ArrayTypeId )
		Return "[]"+TypeTagForId( id.ElementType() )
	EndIf
[...]
</pre><br>Debugger says, "id" is null. The problem is a nulled array which I use. So instead of "field obj:myobjects[5]" I have "field obj:myobjects[]" ("uninitialized").<br><br><br>So this means your "extends(ArrayTypeId)" does not trigger in that case (dunno why) and the result is a null-access (segfault).<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291628"></a>

<a name="1291631"></a>

<a name="1291632"></a>

<a name="1291640"></a>

<a name="1291641"></a>

<a name="1291642"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Some further questions:<br><br>---<br>in _CallMethod you convert pointers from Byte Ptr, in _CallFunction from Int<br><br><pre class=code>
		If retTypeId.ExtendsType(PointerTypeId) Or retTypeId.ExtendsType(FunctionTypeId) Then
			Local f:Byte Ptr(p0,p1,p2,p3,p4,p5,p6,p7)=p
			Return String.FromInt( Int f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )		


'=== VS ===
			If retTypeId.ExtendsType(PointerTypeId) Or retTypeId.ExtendsType(FunctionTypeId) Then
				Local f:Int(p0, p1, p2, p3, p4, p5, p6, p7) = funcp
				Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
</pre><br><br>Is this _intention_ or is this something you forgot to unify?<br><br><br>---<br>In "Function TypeTagForId$( id:TTypeId )" you take care of "PointerTypeId" and "FunctionTypeId" twice (once "simple" and another time by checking if it extends from it).<br><br><br>---<br>Within TMethod you have "Method FunctionPtr..." - which is not utilized. The "else"-case of this method differs to the "else" part of the Invoke() method. Is this by intention? <br><br>- by further checks, it seems as if you just do unneeded code there (as in "Init()" the _fptr is already set to BytePtr(index). Think we could shape some  code off here.<br><br>So <br><pre class=code>
	Method Invoke:Object( obj:Object,args:Object[] )
		If _index&lt;65536
			Return _CallMethod( bbRefMethodPtr( obj,_index ),_typeId.ReturnType(),obj,args,_typeId._argTypes )
		EndIf
		Return _CallMethod( Byte Ptr(_index),_typeId,obj,args,_typeId._argTypes )
	End Method
</pre><br><br>becomes<br><pre class=code>
	Method Invoke:Object( obj:Object,args:Object[] )
		Return _CallMethod( FunctionPtr(obj), _typeId.ReturnType(), obj, args, _typeId._argTypes )
	End Method
</pre><br><br>If aboves int/byte ptr difference was unintented, you could unify "_callMethod" and "_callFunction" and shorten it even more (only difference then is the pushing of the instance in a method call).<br><br><br>Edit:<br>This is the current version of your code including my adjustments:<br><a href="https://raw.githubusercontent.com/GWRon/brl.mod-vanilla/ae348595e4e8778e7a8d8a53639e72c48c5e6a39/reflection.mod/reflection.bmx" target="_blank">https://raw.githubusercontent.com/GWRon/brl.mod-vanilla/ae348595e4e8778e7a8d8a53639e72c48c5e6a39/reflection.mod/reflection.bmx</a><br><br>Changes (yours + mine) could be followed there:<br><a href="https://github.com/GWRon/brl.mod-vanilla/commits/feat_extendedReflection2/reflection.mod/reflection.bmx" target="_blank">https://github.com/GWRon/brl.mod-vanilla/commits/feat_extendedReflection2/reflection.mod/reflection.bmx</a><br><br>With mine being:<br><a href="https://github.com/GWRon/brl.mod-vanilla/commit/ae348595e4e8778e7a8d8a53639e72c48c5e6a39" target="_blank">https://github.com/GWRon/brl.mod-vanilla/commit/ae348595e4e8778e7a8d8a53639e72c48c5e6a39</a><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291716"></a>

<a name="1291717"></a>

<a name="1291719"></a>

<a name="1291720"></a>

<a name="1291721"></a>

<a name="1291722"></a>

<a name="1291723"></a>

<a name="1291724"></a>

<a name="1291725"></a>

<a name="1291726"></a>

<a name="1291727"></a>

<a name="1291728"></a>

<a name="1291729"></a>

<a name="1291730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry for being so slow to answer, i forget to check my email often enough and dont frequenctly check the module sub forum.<br><br><div class="quote"> In Brucey's code the "bbRefArrayNull" is always the same (the pointer to a special object is returned ?) in yours there is a fresh object created everytime. <br></div>It should be the same really, and with my extremely limited tests it was.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Type Test
	Field a:Object[]
EndType

Local o:Test = New Test
Local t:TTypeId = TTypeId.ForObject(o)

Print o.a.length
Print o.a.ToString()
Print

o.a = ["bleh"]
Print o.a.length
Print o.a.ToString()
Print

t.FindField("a").Set( o, Null)
Print o.a.length
Print o.a.ToString()
Print

o.a = ["blah"]
Print o.a.length
Print o.a.ToString()
Print

t.FindField("a").Set( o, Null)
Print o.a.length
Print o.a.ToString()
</textarea><br><div class="quote"> Without that change I get segfaults in a sample code of my framework. <br></div>Hmm.. there might be a reason Brucey chose to test the name of the type after all. Its just that it should not be needed if everything is as it should...<br><br><pre class=code>
SuperStrict

Local nullobject:Object
Local nullarray:Object[]
Local nullstring:String

Local t1:TTypeId = TTypeId.ForObject(nullobject)
Local t2:TTypeId = TTypeId.ForObject(nullarray)
Local t3:TTypeId = TTypeId.ForObject(nullstring)

If t1 Then Print "t1: " + t1.Name()
If t2 Then Print "t2: " + t2.Name()
If t3 Then Print "t3: " + t3.Name()
</pre>Notice that t1 in the above example is Null, which is in line with the original.<br>Is there a need for a Null type akin to the Null[] perhaps? Or is the Null[] type not needed either?<br>Its been a while since i coded this so the reasoning behind it escapes me :/<br><br><br>About _CallMethod and _CallFunction differences: Forgetfullness :p<br><br>About TypeTagForId: More forgetfullness, specificly that ExtendsType() checks for equality directly.<br><br>About TMethod.FunctionPtr() not being used: Perhaps premature optimization by limiting the amount of method calls. I intended it to be a user level method really.<br><br><br>Could you test your framework with bbArrayNull() and using ExtendsType(ArrayTypeId) instead of the name check? The purist in me doesnt like it one bit ;)<br>And double check that it really does get different Null arrays, as it shouldnt do that.<br><br>Id really like to keep it able to compile without mingw for those who still dont use it, though maybe at this point there is no need?<br>	<br>But all in all i accept your changes :)<br>If you agree i can include them in the copy here.. But id like to double check the null array stuff first. <br><br></td></tr></table><br>
<a name="1291781"></a>

<a name="1291782"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, I somehow cannot replicate the segfault now ... neither without your nullArray nor Brucey's variant.<br><br>regarding MinGW: brl.reflection does contain the .cpp-file already, so MinGW is used regardless of the adjustment Brucey's fix uses.<br><br><br>So it seems, as we could mix both additions to something new:<br><pre class=code>
		ElseIf typeId.ExtendsType(ArrayTypeId) Then
			If Not value Then
				value = bbRefArrayNull()
			EndIf
		EndIf
</pre><br><br>bbRefArrayNull() is the better decision (imho) as it uses the "internal" representation - maybe "object[]" does that too, but am not sure about this.<br><br>I understand your scepticism to things like Find("]") :-). If array recognition works flawless, there would be no need for this.<br><br><br>Regarding your sample:<br>_assign is only used when using reflection to  manipulate values - so in my case this is most probably a Clone-Method for cloning instances (which might contain uninitialized arrays).<br>As there were other issues (already tackled but: dimensions were not correct for some (copied) arrays - happens on Mac and windows) things might have come together without us knowing the real issues.<br><br><br><br>---<br>I just searched my emails for the correspondence with Brucey about this subject and found an issue for this, but he only adjusted it for "bmx-ng/brl.mod":<br><i>Brucey:</i><br><div class="quote"> In some cases, bbArrayCastFromObject will return a &amp;bbNullObject.<br>It should probably always return an array of some kind - at least a &amp;bbEmptyArray. <br></div><br><a href="https://github.com/bmx-ng/brl.mod/issues/7" target="_blank">https://github.com/bmx-ng/brl.mod/issues/7</a><br><br><br><br>@different null arrays<br>Seems I did not express myself well then. What I am was talking about is, that "nullArray" is a freshly created local variable - each time. the bbRefArrayNull() is returning the same variable each time (but an function call of course - or is the "ref" different each time?).<br>I assume "local nullarray:object[]" is returning the very same thing (uninitialized).<br><br><br><br>BTW:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework Brl.StandardIO
Import Brl.Reflection 'the modded one!

Type TMyType
	Field A:Int[2]
	Field B:Int[0]
	Field C:Int[]

	Method New()
		C = new Int[1]
	End Method 	
End Type
global my:TMyType = new TMyType

Local myA:TTypeId = TTypeId.ForObject(my.A)
Local myB:TTypeId = TTypeId.ForObject(my.B)
Local myC:TTypeId = TTypeId.ForObject(my.C)

If myA then print "myA: " + myA.Name() + " length: "+myA.ArrayLength(my.A)
If myB then print "myB: " + myB.Name() + " length: "+myB.ArrayLength(my.B)
If myC then print "myC: " + myC.Name() + " length: "+myC.ArrayLength(my.C)
</textarea><br><br>I assumed "myB" would have a length of 0 - but it throws out that myB is not an arrayType...<br><br><br><br>Conclusion:<br>Your code (nullarray) should work as expected now (until I get it to crash again :-)). Nonetheless I would prefer doing it similar to other object types and return the "bb***" type (as Brucey did) - of course then, with your "Extends-variant".<br><br><br>The most up to date variant is now:<br><a href="https://github.com/GWRon/brl.mod-vanilla/commits/feat_extendedReflection2/reflection.mod/reflection.bmx" target="_blank">https://github.com/GWRon/brl.mod-vanilla/commits/feat_extendedReflection2/reflection.mod/reflection.bmx</a><br><br>@agree<br>No problem, most of codes are zlib/libpng - or in this case they are just the same as the original code, so feel free to adopt/copy/print out ... :-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> bbRefArrayNull() is the better decision (imho) as it uses the "internal" representation - maybe "object[]" does that too, but am not sure about this. <br></div>Any array declaration without a size will be set to bbEmptyArray no matter what.<br>Otherwise you could not do <b>.Length</b> on it without it returning bogus values or crashing.<br><br><div class="quote"> brl.reflection does contain the .cpp-file already, so MinGW is used regardless of the adjustment Brucey's fix uses. <br></div>Not if it has already been compiled. So long as the CPP file itself hasent changed it will just import the object file unmodified.<br><br>But since both you and Brucey seem to like it better il cave ;)<br><br><br>The reason it fails for the second array in your test is because it expects TTypeId._ElementType to be filled, the Null[] type didnt do this.. So a bug :)<br><br>Stick this after the definition of NullTypeId to fix it:<br><pre class=code>
' finish setup of ArrayTypeId
ArrayTypeId._ElementType = NullTypeId
</pre><br><br>Updated top post with new version. <br><br></td></tr></table><br>
<a name="1291808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> So for my sample this now responds with:<br>myB: Null[] length: 0<br><br>While "myB" is of type int[] - so a null-sized integer-array.<br><br>"So a bug :)" :-)<br><br><br>@precompiled cpp<br>You are right with that - nonetheless people will already have MinGW installed if they compiled BlitzMax from github.com (as it is an open source project now :-).<br>*teeth grinding* you are right - but at least I tried to exculpate.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> While "myB" is of type int[] - so a null-sized integer-array. <br></div>Even though the type of the field is Int[] there is no way for TTypeId.ForObject() to know that. All it sees is bbEmptyArray, hence the Null[].<br><br><div class="quote"> *teeth grinding* you are right - but at least I tried to exculpate. <br></div>Sorry for being a pedant :p <br><br></td></tr></table><br>
<a name="1291827"></a>

<a name="1291828"></a>

<a name="1291829"></a>

<a name="1291831"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, but for "Fields" we could find out the type by asking the "parent".<br><br><br><pre class=code>
SuperStrict
Framework Brl.StandardIO
Import Brl.Reflection 'the modded one!

Type TMyType
	Field B:Int[0]
End Type
global my:TMyType = new TMyType

print "Definition: TMyType.B type="+TTypeID.ForObject(my).FindField("B").TypeID().name()
print "Content:            B type="+TTypeID.ForObject(my.B).name()
</pre><br><pre class=code>
Definition: TMyType.B type=Int[]
Content:            B type=Null[]
</pre><br><br><br>But returning "Null[]" for all possibilities is surely more consistent.<br>Else we could return the definition-TTypeId for empty arrays when possible. But for this, "ForObject(my.B)" should know about the object "my", which it doesn't (could be referenced by multiple objects).<br>Hmm, seems there is no 100% working way, except adding this data right on compilation (with BCC, kind of "meta data"). Things should be kept up to date then as BlitzMax allows assigning 0-sized arrays ("bla = New Int[0]").<br><br><br>Ideas how this could get solved? <br><br>Also ideas on how to access globals are very welcome.<br><br><br>BTW:<br><pre class=code>' finnish setup of array type</pre><br>Might be better than a Danish setup :-)<br><br> <br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291894"></a>

<a name="1291896"></a>

<a name="1291897"></a>

<a name="1291898"></a>

<a name="1291899"></a>

<a name="1291900"></a>

<a name="1291901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> But for this, "ForObject(my.B)" should know about the object "my", which it doesn't (could be referenced by multiple objects). <br></div>You just cant. Not because of some limitation of reflection, but because its an expression returning a value, and that value is Null.<br><br>An evil example to further the point.<pre class=code>
Type TTest
   Field X:Float[]
EndType
Local x:TTest = New TTest
Local a:Int[] = [ 1 ]
Byte Ptr Ptr(Varptr x.X)[0] = Byte Ptr Ptr(Varptr a)[0]
Print TTypeId.ForObject(x.X).Name()
</pre><br><div class="quote"> except adding this data right on compilation (with BCC, kind of "meta data") <br></div>Its not impossible, but it would blow up the meta-data, as every level of every object expression would have to be added. And its not something one really needs anyway.<br><br><div class="quote"> BlitzMax allows assigning 0-sized arrays ("bla = New Int[0]"). <br></div>True, but it still returns bbEmptyArray for them, so no type is assigned.<br>You could make bbEmptyIntArray and friends but that would break a whole lot of code expecting only 3 null types (object, array, string) and would probably make things slower when checking for Null.<br><br><div class="quote"> Also ideas on how to access globals are very welcome. <br></div>Not unless mark decides to add them to the meta-data.<br>Though i guess now that BlitzMax is opensource it wouldnt be to difficult, i just prefer to use vanilla myself.<br><br><div class="quote"> Might be better than a Danish setup :-) <br></div>Damn, i could swear i fixed that! Thats how it goes when one juggles 4 editor instances of the same file lol <br><br></td></tr></table><br>
<a name="1291902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> You could make bbEmptyIntArray and friends but that would break a whole lot of code expecting only 3 null types (object, array, string) and would probably make things slower when checking for Null. <br></div><br><br>couldnt bbEmptyIntArray inherit bbEmptyArray so "old code" is still able to checkwhether something is an empty array at all?<br><br>Problem stays, that empty "MyObject[]"-arrays would need their "MyObjectEmptyArray" too - which is not existing. So we only would add exceptions for the inbuilt-simple-"types" (int, float, ...).<br><br><br>@other stuff<br>Thanks for the elaboration. Disregarding this we advanced with the code and got rid of some bugs. Benefits for all (and for free ;-)).<br><br>Appended the last revision to my repository.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291920"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> couldnt bbEmptyIntArray inherit bbEmptyArray so "old code" is still able to checkwhether something is an empty array at all? <br></div>It may work like that with reflection, but blitz itself does simple pointer compares so it would have to check a loooong list of stuff. <br>And it would require compiler help to do it, not something i would advocate at all!<br><br>In fact there are too many null types already, it would be best to coalesce the 3 into a single one. Less confusion for the runtime and compiler.<br><br><br>Always nice to get rid of bugs :D <br><br></td></tr></table><br>
<a name="1293599"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> When using The DX10/11 modules (https://github.com/SRSSoftware/srs.mod) the resulting binary crashes at the "Throw" in "Function TypeTagForId$( id:TTypeId )".<br><br>But it then crashes in one of my types, which I cannot explain. As soon as I remove the connection to that modules, everything works nicely again.<br><br>Ideas?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293708"></a>

<a name="1293709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could you change that Throw into:<pre class=code>
Throw "~q" + id.Name() + "~q was unexpected at this time"
</pre>To narrow it down a bit?<br><br>Im just guessing here, but it might happen upon an extern type and getting confused... <br><br></td></tr></table><br>
<a name="1293858"></a>

<a name="1293861"></a>

<a name="1293863"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thrown (as expected):<br>"Null" was unexpected at this time.<br><br><br><img src="http://abload.de/img/debug_1jiomy.png"><br><br><img src="http://abload.de/img/debug_2u0r71.png"><br><br><img src="http://abload.de/img/debug_37artj.png"><br><br><br>The odd thing is, I did not even use that TBatchImage, I just imported the module. And as you see on the pictures, the source of the throw is in "base.util.helper" - no function given, which means it troubled within two globals I define there:<br><br><pre class=code>
	Global ListTypeID:TTypeId= TTypeId.ForObject(new TList)
	Global MapTypeID:TTypeId= TTypeId.ForObject(new TMap)
</pre><br>(I use them to check in a clone method whether an object extends from a Tlist or a tmap - as they are often used containers)<br><br>Disabling the "ForObject" call there, delays the error for some milliseconds to trigger at something else trying to use some reflection. So I assume it was coincidence to crash on these globals ... they are just the first things to use reflection (right upon start).<br><br><br>As I am not able to "shrink it down" to something useable.<br><br>Download my complete game (code + assets), copy the SRS.mod to your modules, import it from the "TVTower.bmx" file (the project main file) and it should "break".<br><br><a href="https://github.com/GWRon/TVTower" target="_blank">https://github.com/GWRon/TVTower</a><br><a href="https://github.com/SRSSoftware/srs.mod" target="_blank">https://github.com/SRSSoftware/srs.mod</a><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293864"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thrown (as expected):<br>"Null" was unexpected at this time.<br><br><br><img src="http://abload.de/img/debug_1jiomy.png"><br><br><img src="http://abload.de/img/debug_2u0r71.png"><br><br><img src="http://abload.de/img/debug_37artj.png"><br><br><br>The odd thing is, I did not even use that TBatchImage, I just imported the module. And as you see on the pictures, the source of the throw is in "base.util.helper" - no function given, which means it troubled within two globals I define there:<br><br><pre class=code>
	Global ListTypeID:TTypeId= TTypeId.ForObject(new TList)
	Global MapTypeID:TTypeId= TTypeId.ForObject(new TMap)
</pre><br>(I use them to check in a clone method whether an object extends from a Tlist or a tmap - as they are often used containers)<br><br>Disabling the "ForObject" call there, delays the error for some milliseconds to trigger at something else trying to use some reflection. So I assume it was coincidence to crash on these globals ... they are just the first things to use reflection (right upon start).<br><br><br>As I am not able to "shrink it down" to something useable for now:<br>Download my complete game (code + assets), copy the SRS.mod to your modules, import it from the "TVTower.bmx" file (the project main file) and it should "break".<br><br><a href="https://github.com/GWRon/TVTower" target="_blank">https://github.com/GWRon/TVTower</a><br><a href="https://github.com/SRSSoftware/srs.mod" target="_blank">https://github.com/SRSSoftware/srs.mod</a><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293871"></a>

<a name="1293872"></a>

<a name="1293873"></a>

<a name="1293874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> I downloaded the source and tried to run, but all i get is this weird error:<br><pre class=code>
Building TVTower
error loading "C:/TVTower/source/main.bmx"
Process complete
</pre>Never run into something like this before :(<br><br>I suspect my BMK is broken for some reason, but everything else seems to work so im stumped... <br><br></td></tr></table><br>
<a name="1293878"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah ok... think you use the vanilla BMK ? It has no support for some additional things done on compilation (creation of a "source/version.txt" containing the compilation date)<br><br>So it might then stumble over the missing incbin or so?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293881"></a>

<a name="1293883"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah i use vanilla bmx.<br><br>And its not the version.txt it bugs on, it just doesnt like reading from UTF-16-LE files. At all.<br>Meaning it fails to read even the first byte.<br><br>This is surely weird.<br><br>EDIT: It manages to read the BOM atleast, and figures out the correct format. But fails to read the next byte. <br><br></td></tr></table><br>
<a name="1293887"></a>

<a name="1293890"></a>

<a name="1293893"></a>

<a name="1293895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> They should be UTF8 with BOM ... as BlitzMax else even is not able to print "" (Umlauts) - which are present in the ANSI chars (246 is "").<br><br><pre class=code>
$ file -i main.bmx
main.bmx: text/plain; charset=utf-8
</pre><br>(i also run <b>for f in `ls *.bmx`; do echo "$f" ' -- ' `file -bi "$f"` ; done</b> and only got us-ascii and utf-8 files)<br>Saving the file as UTF16-LE resulted in the correct recognition as utf-16le.<br><br><br>Only alternative to UTF8 with BOM was to extract every string to text files and then importing them... which I only did for localized files. But one my developer buddies uses German comments - resulting in the usage of umlauts...<br><br><br><br>I compile the very same code within my Windows XP VM using the default BlitzMax 1.50 (plus its MaxIDE) and MinGW 4.6.1. I updated BMK to use Brucey's (as this allows for some pre/post-compilation scripts). <br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293894"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, i see now the original is UTF8 with BOM, must have been maxide that saved it as UTF16LE for some reason.<br>But it still fails to read it :(  And opening the file in Scite i can see it has highlighted umlauts in Red, signaling that they may be incorrect.. or something.<br><br>Il try to remove all occurances of that and see what happens. <br><br></td></tr></table><br>
<a name="1293899"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes... editing these files in MaxIDE is not recommended ... same for blIDE (that dev used blIDE [full version]) as this also destroyed these characters as it tried to save it in some odd encoding mix.<br><br><br>Even if it destroys the character, the error you got is more than misleading: the source file is there, it just might run into problems compiling them... very odd.<br><br>PS: Brucey did compile the game more than once and never mentioned such an error, so it might be something with your BlitzMax-installation (1.50 - as some older versions stalled when processing some comments in my code).<br>  <br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293901"></a>

<a name="1293903"></a>

<a name="1293908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> <strike>For even more weirdness, compiling BMK without "Framework BRL.Blitz" and it works as expected!</strike><br>Scratch that, i forgot i replaced LoadText() with LoadString() to test that ;)<br><br>The odd thing too, is that i can use LoadText() to load that same file without trouble. Its just my BMK that is borked for whatever reason :( <br><br></td></tr></table><br>
<a name="1293906"></a>

<a name="1293907"></a>

<a name="1293909"></a>

<a name="1293910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am using "Framework BRL.StandardIO" :-)<br><br>... but I cannot explain why removing the framework-command resolves such an issue... <br><br>Edit: registered your "scratch this"<br><br>If LoadText was the thing failing, then the incbin might be problematic - albeit it fails differently here, when the to-incbin-file is not existing.<br><br>Edit2:<br>Do you use the vanilla bmk or a custom built one ?<br>Maybe you are able to try Bruceys BMK (do not forget to copy core.bmk + make.bmk to the bin-dir). It will really speed up compilation. Newer incarnations of his BMK look for BlitzMax/MinGW32 to find a custom MinGW and else fall back to the default one.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293915"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> I use vanilla BMK, just modified to work with GCC 5.1.0. So nothing special, just some added flags to various parts.<br>Nothing that should mess with TTextStream.<br><br>I have tried Bruceys BMK before, but never gotten it to work sadly.<br><br>By removing the BOM it does compile though, which is weird to say the least. <br><br></td></tr></table><br>
<a name="1293916"></a>

<a name="1293922"></a>

<a name="1293924"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok ... then - if the game is running now on your side (hopefully it does :-)) the next step would be to download the DX10-module and place it in your mods-folder. The import it within the code (main.bmx or so - I used source/Dig/base.util.graphicsmanager.win32.bmx - as it would be used there) and after compilation it should error when executing (because of the reflection).<br><br>Your reflection code is there:<br>source/Dig/external/reflectionExtended/reflection.bmx<br><br><br>Edit: if you miss maxmod2.mod then you could find a "lite" version of it in source/Dig/external/maxmod2_lite.mod.zip<br><br>If you do not want to have to use another module (and then fall back to "FreeAudio"), open up<br>source/Dig/base.sfx.soundmanager.bmx<br>and use the "nortaudio" variant for your platform (I use this for a user who runs Knoppix/Linux and has issues with PulseAudio...).<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293921"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> It will take some time, i have to compile until it fails on a file. Remove the BOM on that file. And then recompile until it hits another file with the same error.<br>Surprisingly its not all of the files, just a few of them. <br><br></td></tr></table><br>
<a name="1293923"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry to read about that tedious job :-)<br><br>Meanwhile you could check my post before yours ...as I edited it (maxmod2.mod).<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293945"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got it to compile, but it now fails in the linker:<br><pre class=code>
C:/TVTower/source/.bmx/zip.c.release.win32.x86.o:zip.c:(.text+0x197b): undefined reference to `_time32'
C:/TVTower/source/Dig/external/libxml/src/.bmx/nanohttp.c.release.win32.x86.o:nanohttp.c:(.text+0x7d2): undefined reference to `WspiapiGetAddrInfo@16'
C:/TVTower/source/Dig/external/libxml/src/.bmx/nanohttp.c.release.win32.x86.o:nanohttp.c:(.text+0x847): undefined reference to `WspiapiFreeAddrInfo@4'
C:/TVTower/source/Dig/external/libxml/src/.bmx/nanohttp.c.release.win32.x86.o:nanohttp.c:(.text+0x864): undefined reference to `WspiapiFreeAddrInfo@4'
C:/TVTower/source/Dig/external/libxml/src/.bmx/nanohttp.c.release.win32.x86.o:nanohttp.c:(.text+0x8bf): undefined reference to `WspiapiFreeAddrInfo@4'
</pre><br>Nothing i do manages to fix it either.<br>I guess our build systems are just too different :(<br><br>Sorry, but im giving up now. Unless you manage to narrow the reflection bug down to a smaller sample.<br><br>Ive updated top post with a possible fix. (added NullTypeId check) <br><br></td></tr></table><br>
<a name="1293956"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry to hear (but i understand ...)<br><br>Dunno why you get this error, people on the internet suggest to import "-lws2_32" ... but this is not needed here. Assume this has to do with our minGW versions.<br><br><br>Will try your "possible fix" tomorrow when sober and awake :-)<br><br>Maybe I can come up with a smaller example then.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293959"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
SuperStrict

Import SRS.D3D11Max2D
Import "../TVTower.WorkingCopy/TVTower.git/source/Dig/external/reflectionExtended/reflection.bmx"

Global ListTypeID:TTypeId=TTypeId.ForObject(New TList)

Print "done"
</pre><br><br>This errors out here... of course you need to adjust the path to the reflection file.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmm.. It works here :/<br><br>Even when loading only that version of reflection.<br><pre class=code>
Framework BRL.StandardIO
SuperStrict

Import SRS.D3D11Max2D
Import "c:/TVTower/source/Dig/external/reflectionExtended/reflection.bmx"

Global ListTypeID:TTypeId=TTypeId.ForObject(New TList)

Print "done"
</pre> <br><br></td></tr></table><br>
<a name="1294067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's very odd then...<br><br>Hmm.. potential source of the error?<br>I mean ... I understand that it should not "error" as I do not use the imported source, so reflection does not know about it... some "framework" thingy ?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1294082"></a>

<a name="1294083"></a>

<a name="1294092"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> <strike>I just thought of something that might cause problems even if no types or reflection is used directly, types with the same name in different modules.<br><br>And i got this to error out:<br><pre class=code>
SuperStrict

Import SRS.D3D11Max2D

Local o:Object = New TList
Global ListTypeID:TTypeId=TTypeId.ForObject(o)
Print ListTypeID.Name()
Print ListTypeID.FindMethod("ToString").Invoke(o, Null).ToString()

Print "done"

Type TList
	Method ToString:String()
		Return "new TList"
	EndMethod
EndType
</pre>Comment out the D3D11 module and it works like it should again.<br><br>Im going to bed now but il look into it more tomorrow. At least i have something to work with now :)<br></strike> <br><br></td></tr></table><br>
<a name="1294090"></a>

<a name="1294091"></a>

<a name="1294093"></a>

<a name="1294094"></a>

<a name="1294095"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> I couldnt sleep, so did some tests and figured out what was causing the error.<br>Var parameters ;) Seems they get converted to pointers in the metadata.<br>Well it was the cause, but the bug in reflection code was in TTypeId.PointerType() which caused it to recurse over its root PointerTypeId when it shouldnt.<br><br>Top post updated with fix.<br><br>I hope this works for you Derron, and thanks for being patient :)<br><br>EDIT: Heres the test i ended up using:<br><pre class=code>
SuperStrict

Type TSample
	Method Update(pos:Float[] Var)
	EndMethod
EndType

Local o:Object = New TSample
Global t:TTypeId=TTypeId.ForObject(o)
Print t.Name()
Local m:TMethod = t.FindMethod("Update")
For Local a:TTypeId = EachIn m.ArgTypes()
	Print a.Name()
Next

Print "done"
</pre> <br><br></td></tr></table><br>
<a name="1294108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> 'finnish<br>-&gt; finish :-)<br><br>Type TMethod<br>Method Invoke:Object( obj:Object,args:Object[] )<br>-&gt; Method Invoke:Object( obj:Object,args:Object[] = Null )<br><br>TFunction and TField already use "= Null", so adding it is nice for consistency.<br><br>=== SNIP ===<br>Now to the important: it works (does not crash).<br><br><br>Do you have an explanation why it did not crash without that module? Why is it using some reflection stuff of that module even if I do not use it?<br><br><br>Thanks for "not being able to sleep" (and solving another issue) :-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1294156"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Do you have an explanation why it did not crash without that module? Why is it using some reflection stuff of that module even if I do not use it? <br></div>Because when reflection is first used, it goes through ALL registered types and adds them internally to a TMap.<br>At which point it happened upon a Type with a Method with Var parameters.<br><br>I guess Var parameters arent used much on Methods elsewhere, but SRS.D3D11Max2D has one in TBatchImage with 4 of them ;)<br><br>Fixed the typo (again! lol) and added Null as suggested.<br><br><div class="quote"> Thanks for "not being able to sleep" (and solving another issue) :-) <br></div>Hehe, no problem :) <br><br></td></tr></table><br>
<a name="1299597"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Version 1.21 - fixed _Push not setting bbEmptyArray for Null arrays. <br><br></td></tr></table><br>
<a name="1299604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> Updated my Pull Request (Brucey's Maxmod: github.com/maxmods/brl.mod) to incorporate 1.21.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> Version 1.22 - fixed _Call not working with Long/Double return values.<br><br>Weird that i (or anyone else) havent noticed this before, so to be sure. Run this before trying 1.22 to verify that it really is bugged:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Type TType
	Method meth_long:Long( a:Int)
		Print "meth_long:a " + a
		Return 2
	EndMethod
	
	Method meth_double:Double( a:Int)
		Print "meth_double:a " + a
		Return 2.5
	EndMethod
	
	Function func_long:Long( a:Int)
		Print "func_long:a " + a
		Return 2
	EndFunction
	
	Function func_double:Double( a:Int)
		Print "func_double:a " + a
		Return 2.5
	EndFunction
EndType

Local o:TType = New TType
Local t:TTypeId = TTypeId.ForObject(o)
Print "~nMETHODS:"
Print t.FindMethod("meth_long").Invoke( o, ["1"]).ToString()
Print t.FindMethod("meth_double").Invoke(o, ["1"]).ToString()
Print "~nFUNCTIONS:"
Print t.FindFunction("func_long").Invoke( o, ["1"]).ToString()
Print t.FindFunction("func_double").Invoke(o, ["1"]).ToString()
</textarea> <br><br></td></tr></table><br>
<a name="1299617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Version 1.23:<br>   Added _bbCallMethod() asm function for calling with proper number of arguments.<br>   Increased maximum argument count to 30.<br><br>I was inspired by <a href="/posts.php?topic=105977" target="_blank">this post</a> to finally add proper calling :) <br><br></td></tr></table><br>
<a name="1299654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Test "long/double":<br>segfaulting with current implementation (v1.21)<br><br><br>Updated reflection code (all 2 files + 1 new file).<br><pre class=code>
./bmk makeapp -t console -a -r -x "/testcodes/reflectionExtendedTest.bmx"
[  6%] Compiling:reflection.cpp
[ 74%] Archiving:reflection.release.linux.x86.a
[ 99%] Processing:reflectionExtendedTest.bmx
ar: creating /BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a
[ 99%] Compiling:reflectionExtendedTest.bmx.console.release.linux.x86.s
flat assembler  version 1.68  (32768 kilobytes memory)
3 passes, 5544 bytes.
[100%] Linking:reflectionExtendedTest
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xb7f): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xbaa): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xbcc): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xbf7): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xc21): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o):(code+0xc4e): more undefined references to `bbCallMethod' follow
collect2: error: ld returned 1 exit status
Build Error: Failed to link /testcodes/reflectionExtendedTest
</pre><br><br>Did I miss something?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm thats a bit weird. TClass is virtually empty, no references to bbCallMethod there. Only used in _Call 6 times.<br><br>The log doesnt show <b>callmethod.s</b> either, maybe it isnt picked up by bmk and then not compiled in?<br><br>To double check that, see if reflection.bmx.release.linux.x86.s has _bbCallMethod as an <b>extrn</b> at the top somewhere.<br><br>Other than that, maybe try a recompile of the mod alone. <br><br></td></tr></table><br>
<a name="1299686"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> reflection.bmx.release.linux.x86.s:<br><pre class=code>
	format	ELF
	extrn	__bb_blitz_blitz
	extrn	__bb_linkedlist_linkedlist
	extrn	__bb_map_map
	extrn	bbArrayNew1D
	extrn	bbArraySlice
	extrn	bbCallMethod
	extrn	bbEmptyArray
...
</pre><br><br>compiled the module via:<br>./bmk makemods -a brl.reflection<br><br>it compiled flawlessly<br><br><br>removed all .bmx stuff and i/a files.<br>re-compiled your sample (which should rebuild everything if needed):<br><pre class=code>
./bmk makeapp -t console -a -r -x "/testcodes/reflectionExtendedTest.bmx"
[  6%] Compiling:callmethod.s
flat assembler  version 1.68  (32768 kilobytes memory)
1 passes, 170 bytes.
[  6%] Compiling:reflection.cpp
[ 69%] Processing:reflection.bmx
[ 72%] Compiling:reflection.bmx.release.linux.x86.s
flat assembler  version 1.68  (32768 kilobytes memory)
5 passes, 38112 bytes.
[ 74%] Archiving:reflection.release.linux.x86.a
[ 99%] Processing:reflectionExtendedTest.bmx
ar: creating /BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a
[ 99%] Compiling:reflectionExtendedTest.bmx.console.release.linux.x86.s
flat assembler  version 1.68  (32768 kilobytes memory)
3 passes, 5544 bytes.
[100%] Linking:reflectionExtendedTest
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xb7f): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xbaa): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xbcc): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xbf7): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o): In function `_brl_reflection_TClass_SetClass':
(code+0xc21): undefined reference to `bbCallMethod'
/BlitzMax/mod/brl.mod/reflection.mod/reflection.release.linux.x86.a(reflection.bmx.release.linux.x86.o):(code+0xc4e): more undefined references to `bbCallMethod' follow
collect2: error: ld returned 1 exit status
Build Error: Failed to link /testcodes/reflectionExtendedTest
</pre><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299689"></a>

<a name="1299690"></a>

<a name="1299706"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> Aha, i forgot about ELF ;)  The .s file is using "MS COFF".<br>Im surprised fasm and bmk doesnt complain about it though, they really should!<br><br>Anyway, try version 1.24 with own files for linux and win32. <br><br></td></tr></table><br>
<a name="1299691"></a>

<a name="1299692"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> What's up with MacOS - special handling needed too?<br><br><br>Linux still fails:<br><pre class=code>
./bmk makeapp -t console -r -x "/testcodes/reflectionExtendedTest.bmx"
[  6%] Compiling:callmethod.linux.x86.s
flat assembler  version 1.68  (32768 kilobytes memory)
/BlitzMax/mod/brl.mod/reflection.mod/callmethod.linux.x86.s [6]:
section	"code" code
error: invalid argument.
Build Error: Failed to assemble /BlitzMax/mod/brl.mod/reflection.mod/callmethod.linux.x86.s
</pre><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299705"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> Damn fasm is fickle ;) Yeah, il add one for macos as well. Even though i have to use AT&amp;T syntax :(<br><br>Updated top post with version 1.25, hopefully this is it :p <br><br></td></tr></table><br>
<a name="1299727"></a>

<a name="1299728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> Back to the error in #65<br><br>(removed module's .i/.a files, .bmx directory, and precompilates of the test sample before compiling it again)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299738"></a>

<a name="1299740"></a>

<a name="1299741"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm seems linux doesnt like underscores or something, or it adds them itself.<br>Anyway, remove the underscores from all the labels (including _memcpy) and it should compile.<br><br>Had to install linux in a vm to test ;)  MacOS is still untested.<br><br>Updated top post. <br><br></td></tr></table><br>
<a name="1299778"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> Works now.<br>Seems you were right with the underscore.<br><br><br>@Mac<br>There are options to install a Mac OS X in a VM too..<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301318"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> The versions starting with 1.14/1.15 lead to a bugged BMK (Brucey's BMK).<br><br>This BMK calls some Lua files (.bmk) - but these now fail with "arg0" being invalid data - so passing things to lua is bit of broken.<br><br>Do not know what exactly, as my game's lua-scripts work as intented (think so at least).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> I assume its the one from here <a href="https://github.com/bmx-ng/bmk" target="_blank">https://github.com/bmx-ng/bmk</a> ..<br><br>I am unable to reproduce it though, arg0 contains valid data for assemble, compileBMX and compileC (arg0 in those contains the entire commandline).<br><br>In what instances does this happen, and what platforms? <br><br></td></tr></table><br>
<a name="1301328"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using Brl.mod from<br><a href="https://github.com/maxmods/brl.mod" target="_blank">https://github.com/maxmods/brl.mod</a><br>and Pub.mod from<br><a href="https://github.com/maxmods/pub.mod" target="_blank">https://github.com/maxmods/pub.mod</a><br><br>Copied your Brl.reflection-code from the first post (reflection.bmx, reflection.cpp, callmethod.linux.x68.s). Recompiled modules via "bmk makemods brl" (recompiled a bunch of modules, as brl.blitz is recompiled too (base for many things).<br><br><br>Then I recompiled BMK with vanilla BCC and the modified Brl.reflection.<br>Put BMK into another BlitzMax-Directory (BlitzMaxNG-overload) and when trying to execute a compilation (eg. modules) I get this:<br><br><pre class=code>
$ ./bmk makemods
ERROR
[string "function bmk_source_type(...)..."]:5: attempt to concatenate local 'arg0' (a userdata value)
</pre><br><br>This errors is based on a .bmk-file executed before compilation - saying "arg0" is invalid data.<br><br><br>OS: Linux 64Bit.<br><br><br>As "callmethod***" is introduced after it started getting "borked", I assume it must be something different.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301337"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is only 4 places where it spits out "ERROR", in _Push(), _Assign() and two in _Call().<br>Im guessing its one of them in _Call(), both of them are thrown when the number of arguments is exceeded.<br>Though with a maximum of 30 arguments that is a bit weird...<br><br>The reason for the invalid data in arg0 is probably because it throws that exception and skips some init code related to the lua call.<br><br>Could you number the throws in reflection.bmx to narrow it down perhaps?<br><br>Il try to narrow it down in any case, but it might take me a while to reproduce. <br><br></td></tr></table><br>
<a name="1301339"></a>

<a name="1301340"></a>

<a name="1301341"></a>

<a name="1301342"></a>

<a name="1301343"></a>

<a name="1301344"></a>

<a name="1301345"></a>

<a name="1301346"></a>

<a name="1301348"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried that already (Error1 - Error4) but it keeps saying "ERROR" (no number).<br><br>I rebuilt all modules afterwards (and manually deleted the modules precompilates), rebuild BMK completely ... <br><br>- removed brl.mod completely, unzipped a new one, pasted reflection code into it, adjusted "Error" to "errorNumber" and recompiled BMK ... message is "ERROR".<br><br>Maybe "Error" is the LUA message, not the message from reflection.<br><br>I think this is the case and the error is, that "arg0" is kind of "nil" (Lua-"Null") which disallows access to it.<br><br><br>My game's Lua-code might run without trouble as I do not use MaxLua but a custom implementation with some extensions/differences.<br><br><br>Edit: maxlua.bmx:<br><pre class=code>
Function LuaDumpErr()
	WriteStdout "ERROR~n"
	WriteStdout lua_tostring( LuaState(),-1 )
End Function
</pre><br><br>This is where the ERROR comes from.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301347"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, my bad :p<br><br>I did the same as in your recipe, and got an access violation when calling RunCommand (in bmk)<br>And then remembered that i had to modify brl.maxlua for the changed ReturnType() thing, and after that everything went as normal.<br><br>This is on Windows though, il try the same dance in Linux too. <br><br></td></tr></table><br>
<a name="1301349"></a>

<a name="1301350"></a>

<a name="1301351"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> So would you mind sharing what you have changed in maxlua? :-)<br><br><br>I assume this:<br><pre class=code>
Function Invoke( L:Byte Ptr )
	Local t:Object=meth.Invoke( obj,args )
	Select meth.TypeId()
	' becomes
	Select meth.ReturnType()
...
</pre><br><br>This explains why my lua-engine still works - I use this code line:<br>Local typeId:TTypeId = funcOrMeth.TypeID().ReturnType()<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301353"></a>

<a name="1301357"></a>

<a name="1301358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its in the top post.. Line 77 of maxlua.bmx, same change as yours.<br><br>EDIT: Just tried it on linux, still not able to reproduce :( <br><br></td></tr></table><br>
<a name="1301361"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> As soon as I adjusted that maxlua line, compilation with the newly compiled BMK was possible again (no LUA-error anylonger).<br><br>Thanks for your help.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301364"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, good to know, no problem dude :) <br><br></td></tr></table><br>
<a name="1301516"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not a bug, but a question:<br><br>Do you see any chance to make that "ReturnType()" portion compatible to the original mod?<br><br>When trying out things with Bruceys NG (and the NG-modules) I used the brl.reflection of NG as it contained Method/Function/Field/Const already (and your code contained some things not compatible with NG/overload).<br><br>It compiled fine but the issue was, that my lua-engine relied on<br><br>Local typeId:TTypeId = funcOrMeth.TypeID().ReturnType()<br><br>which resulted in different types in your code file and Bruceys brl.reflection.<br><br><br>So the question is based on the idea of keeping things "compatible" as much as possible. It would also get rid of the needed modification of brl.maxlua.<br><br><br>Thoughts?<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1301518"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, since you have control over your own lua glue you could use the <b>?bmx-ng</b> directive and revert to original behavior inside that.<br><br>There is a reason for the change though, because of Function Types.<br>Notice that TypeId() is implemented in TMember, and it returns the full typeid.<br>So a TField can contain a FunctionType, and that type can have a return type which is also a FunctionType etc.<br><br>I see it as a limitation of the original BRL.Reflection being incomplete in a way, not only missing types but also overloading the TypeId() method to mean different things. It really should have had a ReturnType() instead :p<br><br>I dont want to override it for TMethod and TFunction to be honest, as that way you cant treat a TMember and its TypeId() uniformly.<br><br>But since this modification is more or less complete (barring any new bugs) overriding them yourself isnt that much of a chore..<br><br>All you would need is adding these two methods to TMethod and TFunction.<pre class=code>
	Method TypeId:TTypeId()
		Return ReturnType()
	End Method

	Method FunctionTypeId:TTypeId()
		Return _typeId
	End Method
</pre>Note that i have not tested this ;)<br><br><b>reflection.bmx</b> with original semantics.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Rem
bbdoc: BASIC/Reflection
End Rem
Module BRL.Reflection

ModuleInfo "Version: 1.25"
ModuleInfo "Author: Mark Sibly"
ModuleInfo "License: zlib/libpng"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.25 [grable]"
ModuleInfo "History: Fixed linux version of bbCallMethod"
ModuleInfo "History: Added macos version of bbCallMethod"
ModuleInfo "History: 1.24 [grable]"
ModuleInfo "History: Added linux version of bbCallMethod"
ModuleInfo "History: 1.23 [grable]"
ModuleInfo "History: Added _bbCallMethod() asm function for calling with proper number of arguments"
ModuleInfo "History: Increased maximum argument count to 30"
ModuleInfo "History: 1.22 [grable]"
ModuleInfo "History: Fixed _Call not working with Long/Double return types"
ModuleInfo "History: 1.21 [grable]"
ModuleInfo "History: Fixed _Push not setting bbEmptyArray for Null arrays."
ModuleInfo "History: 1.20 [derron]"
ModuleInfo "History: Fixed typo, and added Null argument to TMethod.Invoke()"
ModuleInfo "History: 1.19 [grable]"
ModuleInfo "History: Fixed TTypeId.PointerType() recursing over root PointerTypeId"
ModuleInfo "History: 1.18 [grable]"
ModuleInfo "History: Added check for NullTypeId in TypeTagForId, also improved error message"
ModuleInfo "History: 1.17 [grable]"
ModuleInfo "History: Fixed missing ElementType for ArrayTypeId"
ModuleInfo "History: 1.16 [gwron]"
ModuleInfo "History: minor adjustments to code (cleanup)."
ModuleInfo "History: 1.15 [brucey]"
ModuleInfo "History: fixed _Assign not setting bbEmptyArray for Null arrays."
ModuleInfo "History: 1.14 [grable]"
ModuleInfo "History: fixed missing call to ReturnType() in TMethod.Invoke()"
ModuleInfo "History: 1.13 [grable]"
ModuleInfo "History: fixed TypeTagForId() regarding pointers"
ModuleInfo "History: fixed _Push and _Assign regarding pointers"
ModuleInfo "History: 1.12 [grable]"
ModuleInfo "History: added TTypeId.ArraySlice() for slicing untyped arrays"
ModuleInfo "History: 1.11 [grable]"
ModuleInfo "History: refixed TMethod overrides, and added same for TFunction"
ModuleInfo "History: 1.10 [grable]"
ModuleInfo "History: fixed bug in FindConstant()"
ModuleInfo "History: added TField.FieldPtr() for direct pointer to instance fields"
ModuleInfo "History: 1.09 [grable]"
ModuleInfo "History: fixed parsing of function pointers with spaces via ForName"
ModuleInfo "History: 1.08 [grable]"
ModuleInfo "History: Added type constants (TConstant and relevant methods to TTypeId)"
ModuleInfo "History: 1.07 [grable]"
ModuleInfo "History: Minor fixes"
ModuleInfo "History: 1.06 [grable]"
ModuleInfo "History: Added function pointer support (FunctionTypeId...)"
ModuleInfo "History: Also did some reworking of TFunction/TMethod and pushed parsing of function metadata over to TypeIdForTag()"
ModuleInfo "History: 1.05 [Otus]"
ModuleInfo "History: Fixed TMethod overrides, Nested arrays (TTypeId.ForName)"
ModuleInfo "History: 1.04 [grable]"
ModuleInfo "History: Added pointer support (PointerTypeId...)"
ModuleInfo "History: 1.03 [blitz-forum]"
ModuleInfo "History: Added support for type functions (TFunction...)"

ModuleInfo "History: 1.02 Release"
ModuleInfo "History: Added Brucey's size fix to GetArrayElement()/SetArrayElement()"
ModuleInfo "History: 1.01 Release"
ModuleInfo "History: Fixed NewArray using temp type name"

Import BRL.LinkedList
Import BRL.Map

Import "reflection.cpp"

?Not x86
	Throw "callmethod assembly is x86 only!"
?
?Win32
Import "callmethod.win32.x86.s"
?Linux
Import "callmethod.linux.x86.s"
?MacOS
Import "callmethod.macos.x86.s"
?

Private

Const MAX_CALL_ARGS:Int = 30 ' original=8

Extern

Function bbObjectNew:Object( class )
Function bbObjectRegisteredTypes:Int Ptr( count Var )

Function bbArrayNew1D:Object( typeTag:Byte Ptr,length )
Function bbArraySlice:Object( typeTag:Byte Ptr,inarr:Object,start:Int,stop:Int )

Function bbRefArrayClass()
Function bbRefStringClass()
Function bbRefObjectClass()

Function bbRefArrayLength( array:Object, dim:Int = 0 )
Function bbRefArrayTypeTag$( array:Object )
Function bbRefArrayDimensions:Int( array:Object )
Function bbRefArrayCreate:Object( typeTag:Byte Ptr,dims:Int[] )
Function bbRefArrayNull:Object()

Function bbRefFieldPtr:Byte Ptr( obj:Object,index )
Function bbRefMethodPtr:Byte Ptr( obj:Object,index )
Function bbRefArrayElementPtr:Byte Ptr( sz,array:Object,index )

Function bbRefGetObject:Object( p:Byte Ptr )
Function bbRefPushObject( p:Byte Ptr,obj:Object )
Function bbRefInitObject( p:Byte Ptr,obj:Object )
Function bbRefAssignObject( p:Byte Ptr,obj:Object )

Function bbRefGetObjectClass( obj:Object )
Function bbRefGetSuperClass( class )

Function bbCallMethod:Int( p:Byte Ptr, args:Byte Ptr, sz:Int)
Function bbCallMethod_Float:Float( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
Function bbCallMethod_Object:Object( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
Function bbCallMethod_Double:Double( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"

End Extern

Type TClass

	Method Compare( with:Object )
		Return _class-TClass( with )._class
	End Method
	
	Method SetClass:TClass( class )
		_class=class
		Return Self
	End Method
	
	Field _class
End Type

Function _Get:Object( p:Byte Ptr,typeId:TTypeId )
	Select typeId
	Case ByteTypeId
		Return String.FromInt( (Byte Ptr p)[0] )
	Case ShortTypeId
		Return String.FromInt( (Short Ptr p)[0] )
	Case IntTypeId
		Return String.FromInt( (Int Ptr p)[0] )
	Case LongTypeId
		Return String.FromLong( (Long Ptr p)[0] )
	Case FloatTypeId
		Return String.FromFloat( (Float Ptr p)[0] )
	Case DoubleTypeId
		Return String.FromDouble( (Double Ptr p)[0] )
	Default
		If typeid.ExtendsType(PointerTypeId) Or typeid.ExtendsType(FunctionTypeId) Then
			Return String.FromInt( (Int Ptr p)[0] )
		EndIf
		Return bbRefGetObject( p )
	End Select
End Function

Function _Push:Byte Ptr( sp:Byte Ptr,typeId:TTypeId,value:Object )
	Select typeId
	Case ByteTypeId,ShortTypeId,IntTypeId
		(Int Ptr sp)[0]=value.ToString().ToInt()
		Return sp+4
	Case LongTypeId
		(Long Ptr sp)[0]=value.ToString().ToLong()
		Return sp+8
	Case FloatTypeId
		(Float Ptr sp)[0]=value.ToString().ToFloat()
		Return sp+4
	Case DoubleTypeId
		(Double Ptr sp)[0]=value.ToString().ToDouble()
		Return sp+8
	Case StringTypeId
		If Not value value=""
		bbRefPushObject sp,value
		Return sp+4
	Default
		If typeid.ExtendsType(PointerTypeId) Then
			If value Then
				(Int Ptr sp)[0]=value.ToString().ToInt()
			Else
				(Int Ptr sp)[0]=0
			EndIf
			Return sp+4
		ElseIf typeid.ExtendsType(FunctionTypeId) Then
			If value Then
				(Int Ptr sp)[0]=value.ToString().ToInt()
			Else
				(Int Ptr sp)[0]=Int Byte Ptr NullFunctionError
			EndIf
			Return sp+4
		ElseIf typeId.ExtendsType(ArrayTypeId)
			If Not value Then value = bbRefArrayNull()
		EndIf
		If value
			Local c=typeId._class
			Local t=bbRefGetObjectClass( value )
			While t And t&lt;&gt;c
				t=bbRefGetSuperClass( t )
			Wend
			If Not t Throw "_Push() ERROR"
		EndIf
		bbRefPushObject sp,value
		Return sp+4
	End Select
End Function

Function _Assign( p:Byte Ptr,typeId:TTypeId,value:Object )
	Select typeId
	Case ByteTypeId
		(Byte Ptr p)[0]=value.ToString().ToInt()
	Case ShortTypeId
		(Short Ptr p)[0]=value.ToString().ToInt()
	Case IntTypeId
		(Int Ptr p)[0]=value.ToString().ToInt()
	Case LongTypeId
		(Long Ptr p)[0]=value.ToString().ToLong()
	Case FloatTypeId
		(Float Ptr p)[0]=value.ToString().ToFloat()
	Case DoubleTypeId
		(Double Ptr p)[0]=value.ToString().ToDouble()
	Case StringTypeId
		If Not value value=""
		bbRefAssignObject p,value
	Default
		If typeid.ExtendsType(PointerTypeId) Then
			If value Then
				(Int Ptr p)[0]=value.ToString().ToInt()
			Else
				(Int Ptr p)[0]=0
			EndIf
			Return
		ElseIf typeid.ExtendsType(FunctionTypeId) Then
			If value Then
				(Int Ptr p)[0]=value.ToString().ToInt()
			Else
				(Int Ptr p)[0]=Int Byte Ptr NullFunctionError
			EndIf
			Return
		ElseIf typeId.ExtendsType(ArrayTypeId)
			If Not value Then value = bbRefArrayNull()
		EndIf
		If value
			Local c=typeId._class
			Local t=bbRefGetObjectClass( value )
			While t And t&lt;&gt;c
				t=bbRefGetSuperClass( t )
			Wend
			If Not t Throw "_Assign() ERROR"
		EndIf
		bbRefAssignObject p,value
	End Select
End Function

Function _Call:Object( callableP:Byte Ptr, retTypeId:TTypeId, obj:Object=Null, args:Object[], argtypes:TTypeId[])
	Assert args.Length = argtypes.Length

	Local q:Int[MAX_CALL_ARGS + 2], sp:Byte Ptr = q
	
	If obj 'method call of an instance
		bbRefPushObject sp,obj
		sp:+4
	EndIf
	
	Local lret:Long
	If retTypeId = LongTypeId Then
		Byte Ptr Ptr(sp)[0] = Byte Ptr Varptr lret
		sp :+ 4
	EndIf

	For Local i:Int = 0 Until args.Length
		If Int Ptr(sp) &gt;= Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args"
		sp = _Push( sp, argtypes[i], args[i])
	Next
	If Int Ptr(sp) &gt; Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #2"
	Select retTypeId
		Case ByteTypeId, ShortTypeId, IntTypeId
'			Local f(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'			Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Return String.FromInt( bbCallMethod( callableP, q, sp - Byte Ptr q) )
		Case LongTypeId
'			Local r:Long
'			If obj Then
'				Local f( p0, r:Long Var, p1,p2,p3,p4,p5,p6,p7) = callableP
'				f( q[0], r, q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
'			Else
'				Local f( r:Long Var, p0, p1,p2,p3,p4,p5,p6,p7) = callableP
'				f( r, q[0], q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
'			EndIf
'			Return String.FromLong(r)
			bbCallMethod( callableP, q, sp - Byte Ptr q)
			Return String.FromInt( lret )
		Case FloatTypeId
'			Local f:Float(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'			Return String.FromFloat( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Return String.FromFloat( bbCallMethod_Float( callableP, q, sp - Byte Ptr q) )
		Case DoubleTypeId
'			Local f:Double(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'			Return String.FromDouble( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Return String.FromDouble( bbCallMethod_Double( callableP, q, sp - Byte Ptr q) )
		Default
			If retTypeId.ExtendsType(PointerTypeId) Or retTypeId.ExtendsType(FunctionTypeId) Then
'				Local f:Int(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'				Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
				Return String.FromInt( bbCallMethod( callableP, q, sp - Byte Ptr q) )
			Else
'				Local f:Object(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'				Return f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
				Return bbCallMethod_Object( callableP, q, sp - Byte Ptr q)
			EndIf
	End Select
End Function

Function TypeTagForId$( id:TTypeId )
	If id.ExtendsType( ArrayTypeId )
		Return "[]"+TypeTagForId( id.ElementType() )
	EndIf
	If id.ExtendsType( ObjectTypeId )
		Return ":"+id.Name()
	EndIf
	If id.ExtendsType( PointerTypeId )
		Local t:TTypeId = id.ElementType()
		If t Then Return "*"+TypeTagForId(t)
		Return "*"
	EndIf
	If id.ExtendsType( FunctionTypeId )
		Local s:String
		For Local t:TTypeId = EachIn id._argTypes
			If s Then s :+ ","
			s :+ TypeTagForId(t)
		Next
		s = "(" + s + ")"
		If id._retType Then s :+ TypeTagForId(id._retType)
		Return s
	EndIf
	Select id
		Case ByteTypeId Return "b"
		Case ShortTypeId Return "s"
		Case IntTypeId Return "i"
		Case LongTypeId Return "l"
		Case FloatTypeId Return "f"
		Case DoubleTypeId Return "d"
		Case StringTypeId Return "$"
		Case NullTypeId Return "Null"
	End Select
	Throw "~q" + id.Name() + "~q was unexpected at this time"
End Function

Function TypeIdForTag:TTypeId( ty$ )
	If ty.StartsWith( "[" )
		Local dims:Int = ty.split(",").length
		ty=ty[ty.Find("]")+1..]
		Local id:TTypeId = TypeIdForTag( ty )
		If id Then
			id._arrayType = Null
			id=id.ArrayType(dims)
		End If
		Return id
	EndIf
	If ty.StartsWith( ":" )
		ty=ty[1..]
		Local i=ty.FindLast( "." )
		If i&lt;&gt;-1 ty=ty[i+1..]
		Return TTypeId.ForName( ty )
	EndIf
	If ty.StartsWith( "(" ) Then
		Local t:String[]
		Local idx:Int = ty.FindLast(")")
		If idx &gt; 0 Then
			t = [ ty[1..idx], ty[idx+1..] ]
		Else
			t = [ ty[1..], "" ]
		EndIf
		Local retType:TTypeId=TypeIdForTag( t[1] ), argTypes:TTypeId[]
		If t[0].length&gt;0 Then
			Local i,b,q$=t[0], args:TList=New TList
			#first_loop
			While i&lt;q.length
				Select q[i]
				Case Asc( "," )
					args.AddLast q[b..i]
					i:+1
					b=i
				Case Asc( "[" )
					i:+1
					While i&lt;q.length And q[i]=Asc(",")
						i:+1
					Wend
				Case Asc( "(" )
					Local level:Int = 1
					i:+1
					While i&lt;q.Length
						If q[i] = Asc(",") Then
							If level = 0 Then Continue first_loop
						ElseIf q[i] = Asc(")") Then
							level :- 1
						ElseIf q[i] = Asc("(") Then 
							level :+ 1
						EndIf
						i:+1
					Wend
				Default
					i:+1
				End Select
			Wend
			If b &lt; q.Length Then args.AddLast q[b..]
			
			argTypes=New TTypeId[args.Count()]

			i=0
			For Local s:String = EachIn args
				argTypes[i]=TypeIdForTag( s )
				If Not argTypes[i] Then argTypes[i] = ObjectTypeId
				i:+1
			Next
		EndIf
		If Not retType Then retType = ObjectTypeId
		retType._functionType = Null
		Return retType.FunctionType(argTypes)
	EndIf
	If ty.StartsWith( "*" ) Then
		ty = ty[1..]
		Local id:TTypeId = TypeIdForTag( ty )
		If id Then
			id._pointerType = Null
			id = id.PointerType()
		EndIf
		Return id
	EndIf
	Select ty
		Case "b" Return ByteTypeId
		Case "s" Return ShortTypeId
		Case "i" Return IntTypeId
		Case "l" Return LongTypeId
		Case "f" Return FloatTypeId
		Case "d" Return DoubleTypeId
		Case "$" Return StringTypeId
	End Select
End Function

Function ExtractMetaData$( meta$,key$ )
	If Not key Return meta
	Local i=0
	While i&lt;meta.length
		Local e=meta.Find( "=",i )
		If e=-1 Throw "Malformed meta data"
		Local k$=meta[i..e],v$
		i=e+1
		If i&lt;meta.length And meta[i]=Asc("~q")
			i:+1
			Local e=meta.Find( "~q",i )
			If e=-1 Throw "Malformed meta data"
			v=meta[i..e]
			i=e+1
		Else
			Local e=meta.Find( " ",i )
			If e=-1 e=meta.length
			v=meta[i..e]
			i=e
		EndIf
		If k=key Return v
		If i&lt;meta.length And meta[i]=Asc(" ") i:+1
	Wend
End Function
	
Public

Rem
bbdoc: Primitive byte type
End Rem
Global ByteTypeId:TTypeId=New TTypeId.Init( "Byte",1 )

Rem
bbdoc: Primitive short type
End Rem
Global ShortTypeId:TTypeId=New TTypeId.Init( "Short",2 )

Rem
bbdoc: Primitive int type
End Rem
Global IntTypeId:TTypeId=New TTypeId.Init( "Int",4 )

Rem
bbdoc: Primitive long type
End Rem
Global LongTypeId:TTypeId=New TTypeId.Init( "Long",8 )

Rem
bbdoc: Primitive float type
End Rem
Global FloatTypeId:TTypeId=New TTypeId.Init( "Float",4 )

Rem
bbdoc: Primitive double type
End Rem
Global DoubleTypeId:TTypeId=New TTypeId.Init( "Double",8 )

Rem
bbdoc: Primitive object type
End Rem
Global ObjectTypeId:TTypeId=New TTypeId.Init( "Object",4,bbRefObjectClass() )

Rem
bbdoc: Primitive string type
End Rem
Global StringTypeId:TTypeId=New TTypeId.Init( "String",4,bbRefStringClass(),ObjectTypeId )

Rem
bbdoc: Primitive array type
End Rem
Global ArrayTypeId:TTypeId=New TTypeId.Init( "Null[]",4,bbRefArrayClass(),ObjectTypeId )

Rem
bbdoc: Primitive pointer type
End Rem
Global PointerTypeId:TTypeId=New TTypeId.Init( "Ptr",4 )

Rem
bbdoc: Primitive function type
End Rem
Global FunctionTypeId:TTypeId=New TTypeId.Init( "Null()",4 )

Rem
bbdoc: Primitive null type
End Rem
Global NullTypeId:TTypeId=New TTypeId.Init( "Null",4 )

' finish setup of array type
ArrayTypeId._ElementType = NullTypeId

Rem
bbdoc: Type member - field or method.
End Rem
Type TMember

	Rem
	bbdoc: Get member name
	End Rem
	Method Name$()
		Return _name
	End Method

	Rem
	bbdoc: Get member type
	End Rem	
	Method TypeId:TTypeId()
		Return _typeId
	End Method
	
	Rem
	bbdoc: Get member meta data
	End Rem
	Method MetaData$( key$="" )
		Return ExtractMetaData( _meta,key )
	End Method
	
	Field _name$,_typeId:TTypeId,_meta$
	
End Type

Rem
bbdoc: Type constant
EndRem
Type TConstant Extends TMember
	Method Init:TConstant( name:String, typeId:TTypeId, meta:String, rtti:Int)
		_name = name
		_typeId = typeId
		_meta = meta
		_rtti = Int Ptr(rtti) + 2 ' now points at string: [dd size][db data...]
		Return Self
	EndMethod

	Rem
	bbdoc: Get constant value
	EndRem
	Method GetString:String()
		Return String.FromShorts( Short Ptr(_rtti+1), _rtti[0])
	EndMethod

	Rem
	bbdoc: Get constant value as @Int
	EndRem
	Method GetInt:Int()
		Return GetString().ToInt()
	EndMethod

	Rem
	bbdoc: Get constant value as @Float
	EndRem	
	Method GetFloat:Int()
		Return GetString().ToFloat()
	EndMethod

	Rem
	bbdoc: Get constant value as @Long
	EndRem	
	Method GetLong:Int()
		Return GetString().ToLong()
	EndMethod

	Rem
	bbdoc: Get constant value as @Double
	EndRem	
	Method GetDouble:Int()
		Return GetString().ToDouble()
	EndMethod

	Rem
	bbdoc: Get constant value as @{Byte Ptr}
	EndRem
	Method GetPointer:Byte Ptr()
		Return Byte Ptr GetString().ToInt()
	EndMethod
		
	Field _rtti:Int Ptr
EndType

Rem
bbdoc: Type field
End Rem
Type TField Extends TMember

	Method Init:TField( name$,typeId:TTypeId,meta$,index )
		_name=name
		_typeId=typeId
		_meta=meta
		_index=index
		Return Self
	End Method

	Rem
	bbdoc: Get field value
	End Rem
	Method Get:Object( obj:Object )
		Return _Get( bbRefFieldPtr( obj,_index ),_typeId )
	End Method
	
	Rem
	bbdoc: Get int field value
	End Rem
	Method GetInt:Int( obj:Object )
		Return GetString( obj ).ToInt()
	End Method
	
	Rem
	bbdoc: Get long field value
	End Rem
	Method GetLong:Long( obj:Object )
		Return GetString( obj ).ToLong()
	End Method
	
	Rem
	bbdoc: Get float field value
	End Rem
	Method GetFloat:Float( obj:Object )
		Return GetString( obj ).ToFloat()
	End Method
	
	Rem
	bbdoc: Get double field value
	End Rem
	Method GetDouble:Double( obj:Object )
		Return GetString( obj ).ToDouble()
	End Method
	
	Rem
	bbdoc: Get string field value
	End Rem
	Method GetString$( obj:Object )
		Return String( Get( obj ) )
	End Method
		
	Rem
	bbdoc: Get pointer field value
	End Rem
	Method GetPointer:Byte Ptr( obj:Object)
		Return Byte Ptr GetString(obj).ToInt()
	EndMethod		
	
	Rem
	bbdoc: Set field value
	End Rem
	Method Set( obj:Object,value:Object )
		_Assign bbRefFieldPtr( obj,_index ),_typeId,value
	End Method
	
	Rem
	bbdoc: Set int field value
	End Rem
	Method SetInt( obj:Object,value:Int )
		SetString obj,String.FromInt( value )
	End Method
	
	Rem
	bbdoc: Set long field value
	End Rem
	Method SetLong( obj:Object,value:Long )
		SetString obj,String.FromLong( value )
	End Method
	
	Rem
	bbdoc: Set float field value
	End Rem
	Method SetFloat( obj:Object,value:Float )
		SetString obj,String.FromFloat( value )
	End Method
	
	Rem
	bbdoc: Set double field value
	End Rem
	Method SetDouble( obj:Object,value:Double )
		SetString obj,String.FromDouble( value )
	End Method
	
	Rem
	bbdoc: Set string field value
	End Rem
	Method SetString( obj:Object,value$ )
		Set obj,value
	End Method
		
	Rem
	bbdoc: Set pointer field value
	End Rem
	Method SetPointer( obj:Object, value:Byte Ptr)
		SetString(obj, String.FromInt(Int value))
	EndMethod

	Rem
	bbdoc: Get the pointer to the field of an instance
	about: this returns a @{direct pointer to the instance field}
	End Rem
	Method FieldPtr:Byte Ptr( obj:Object)
		Return bbRefFieldPtr( obj, _index)
	EndMethod
	
	Rem
	bbdoc: Invoke function pointer field
	End Rem
	Method Invoke:Object( obj:Object, args:Object[] = Null)
		Return _Call( GetPointer(obj), _typeId.ReturnType(), Null, args, _typeId.ArgTypes())
	EndMethod	
	
	Field _index
	
End Type

Rem
bbdoc: Type method
End Rem
Type TMethod Extends TMember

	Method Init:TMethod( name$,typeId:TTypeId,meta$,selfTypeId:TTypeId,index )
		_name=name
		_typeId=typeId
		_meta=meta
		_selfTypeId=selfTypeId
		_index=index
		If _index &gt;= 65536 Then
			_fptr = Byte Ptr(_index)
		Else
			_fptr = Null
		EndIf
		Return Self
	End Method
	
	Rem
	bbdoc: Get method arg types
	End Rem
	Method ArgTypes:TTypeId[]()
		Return _typeId._argTypes
	End Method
		
	Rem
	bbdoc: Get method return type
	End Rem
	Method ReturnType:TTypeId()
		Return _typeId._retType
	End Method
	
	Rem
	bbdoc: Get method return type
	End Rem	
	Method TypeId:TTypeId()
		Return ReturnType()
	End Method

	Rem
	bbdoc: Get method type
	End Rem	
	Method FunctionTypeId:TTypeId()
		Return _typeId
	End Method

	Rem
	bbdoc: Get method function pointer
	endrem
	Method FunctionPtr:Byte Ptr( obj:Object)
		If _fptr Then Return _fptr
		If _index &lt; 65536 Then
			_fptr = bbRefMethodPtr( obj ,_index)
		EndIf
		Return _fptr
	End Method

	Rem
	bbdoc: Invoke method
	End Rem
	Method Invoke:Object( obj:Object,args:Object[] = Null )
		Return _Call( FunctionPtr(obj), ReturnType(), obj, args, ArgTypes() )
	End Method
	
	Field _selfTypeId:TTypeId,_index
	Field _fptr:Byte Ptr
End Type

Rem
bbdoc: Type function
endrem
Type TFunction Extends TMember
	Method Init:TFunction(name:String, typeId:TTypeId, meta:String, selfTypeId:TTypeId, index:Int)
		_name=name
		_typeId=typeId
		_meta=meta
		_selfTypeId=selfTypeId		
		_index=index
		If _index &gt;= 65536 Then
			_fptr = Byte Ptr(_index)
		Else
			_fptr = Null
		EndIf
		Return Self
	End Method

	Rem
	bbdoc: Get function arg types
	End Rem
	Method ArgTypes:TTypeId[]()
		Return _typeId._argTypes
	End Method
	
	Rem
	bbdoc: Get function return type
	End Rem
	Method ReturnType:TTypeId()
		Return _typeId._retType
	End Method

	Rem
	bbdoc: Get method return type
	End Rem	
	Method TypeId:TTypeId()
		Return ReturnType()
	End Method

	Rem
	bbdoc: Get method type
	End Rem	
	Method FunctionTypeId:TTypeId()
		Return _typeId
	End Method

	Rem
	bbdoc: Get function pointer.
	endrem
	Method FunctionPtr:Byte Ptr( obj:Object)
		If _fptr Then Return _fptr
		If _index &lt; 65536 Then
			_fptr = bbRefMethodPtr( obj ,_index)
		EndIf
		Return _fptr
	End Method
	
	Rem
	bbdoc: Invoke type function
	endrem	
	Method Invoke:Object( obj:Object, args:Object[] = Null)
		Return _Call( FunctionPtr(obj), ReturnType(), Null, args, ArgTypes())
	End Method
	
	Field _selfTypeId:TTypeId, _fptr:Byte Ptr, _index:Int
EndType
	
Rem
bbdoc: Type id
End Rem
Type TTypeId

	Rem
	bbdoc: Get name of type
	End Rem
	Method Name$()
		Return _name
	End Method
	
	Rem
	bbdoc: Get type meta data
	End Rem	
	Method MetaData$( key$="" )
		Return ExtractMetaData( _meta,key )
	End Method

	Rem
	bbdoc: Get super type
	End Rem	
	Method SuperType:TTypeId()
		Return _super
	End Method
	
	Rem
	bbdoc: Get array type
	End Rem
	Method ArrayType:TTypeId(dims:Int = 1)
		If Not _arrayType
			Local dim:String
			If dims &gt; 1 Then
				For Local i:Int = 1 Until dims
					dim :+ ","
				Next
			End If
			_arrayType=New TTypeId.Init( _name+"[" + dim + "]",4,bbRefArrayClass() )
			_arrayType._elementType=Self
			If _super
				_arrayType._super=_super.ArrayType()
			Else
				_arrayType._super=ArrayTypeId
			EndIf
		EndIf
		Return _arrayType
	End Method
		
	Rem
	bbdoc: Get element type
	End Rem
	Method ElementType:TTypeId()
		Return _elementType
	End Method
		
	Rem
	bbdoc: Get pointer type
	End Rem
	Method PointerType:TTypeId()
		If Not _pointerType Then
			_pointerType = New TTypeId.Init( _name + " Ptr", 4)
			_pointerType._elementType = Self
			If _super Then
				_pointerType._super = _super.PointerType()
				_pointerType._TypeTag = TypeTagForId(_pointerType).ToCString()
			Else
				_pointerType._super = PointerTypeId
				_pointerType._TypeTag = "*".ToCString()
			EndIf
		EndIf
		Return _pointerType
	End Method
		
	Rem
	bbdoc: Get function pointer type
	End Rem
	Method FunctionType:TTypeId( args:TTypeId[]=Null)
		If Not _functionType Then
			Local s:String
			For Local t:TTypeId = EachIn args
				If s Then s :+ ","
				s :+ t.Name()
			Next
			_functionType = New TTypeId.Init( _name + "(" + s + ")", 4)
			_functionType._retType = Self
			_functionType._argTypes = args
			If _super Then
				_functionType._super = _super.FunctionType()
			Else
				_functionType._super = FunctionTypeId
			EndIf
		EndIf
		Return _functionType
	End Method
		
	Rem
	bbdoc: Get function return type
	End Rem
	Method ReturnType:TTypeId()
		If Not _retType Then Throw "TypeID is not a function type"
		Return _retType
	End Method
		
	Rem
	bbdoc: Get function argument types
	End Rem
	Method ArgTypes:TTypeId[]()
		If Not _retType Then Throw "TypeID is not a function type"
		Return _argTypes
	End Method		
	
	Rem
	bbdoc: Determine if type extends a type
	End Rem
	Method ExtendsType( typeId:TTypeId )
		If Self=typeId Return True
		If _super Return _super.ExtendsType( typeId )
	End Method
	
	Rem
	bbdoc: Get list of derived types
	End Rem
	Method DerivedTypes:TList()
		If Not _derived _derived=New TList
		Return _derived
	End Method

	Rem
	bbdoc: Create a new object
	End Rem	
	Method NewObject:Object()
		If Not _class Throw "Unable to create new object"
		Return bbObjectNew( _class )
	End Method
	
	Rem
	bbdoc: Get list of constants
	about: Only returns constants declared in this type, not in super types.
	End Rem
	Method Constants:TList()
		Return _consts
	End Method	
	
	Rem
	bbdoc: Get list of fields
	about: Only returns fields declared in this type, not in super types.
	End Rem
	Method Fields:TList()
		Return _fields
	End Method
	
	Rem
	bbdoc: Get list of methods
	about: Only returns methods declared in this type, not in super types.
	End Rem
	Method Methods:TList()
		Return _methods
	End Method
	
	Rem
	bbdoc: Get ist of functions
	about: Only returns functions declared in this type, not in super types.
	endrem
	Method Functions:TList()
		Return _functions
	End Method	
	
	Rem
	bbdoc: Find a field by name
	about: Searchs type hierarchy for field called @name.
	End Rem
	Method FindField:TField( name$ )
		name=name.ToLower()
		For Local t:TField=EachIn _fields
			If t.Name().ToLower()=name Return t
		Next
		If _super Return _super.FindField( name )
	End Method
	
	Rem
	bbdoc: Find a constant by name
	about: Searchs type hierarchy for constant called @name.
	End Rem
	Method FindConstant:TConstant( name$ )
		name=name.ToLower()
		For Local t:TConstant=EachIn _consts
			If t.Name().ToLower()=name Return t
		Next
		If _super Return _super.FindConstant( name )
	End Method	
	
	Rem
	bbdoc: Find a method by name
	about: Searchs type hierarchy for method called @name.
	End Rem
	Method FindMethod:TMethod( name$ )
		name=name.ToLower()
		For Local t:TMethod=EachIn _methods
			If t.Name().ToLower()=name Return t
		Next
		If _super Return _super.FindMethod( name )
	End Method
		
	Rem
	bbdoc: Find a function by name
	about: Searches type heirarchy for function called @name
	endrem
	Method FindFunction:TFunction(name:String)
		name = name.ToLower()
		For Local t:TFunction = EachIn _functions
			If t.Name().ToLower() = name Return t
		Next
		If _super Return _super.FindFunction(name)
	End Method
	
	Rem
	bbdoc: Enumerate all constants
	about: Returns a list of all constants in type hierarchy
	End Rem	
	Method EnumConstants:TList( list:TList=Null )
		If Not list list=New TList
		If _super _super.EnumConstants list
		For Local t:TConstant=EachIn _consts
			list.AddLast t
		Next
		Return list
	End Method
	
	Rem
	bbdoc: Enumerate all fields
	about: Returns a list of all fields in type hierarchy
	End Rem	
	Method EnumFields:TList( list:TList=Null )
		If Not list list=New TList
		If _super _super.EnumFields list
		For Local t:TField=EachIn _fields
			list.AddLast t
		Next
		Return list
	End Method
	
	Rem
	bbdoc: Enumerate all methods
	about: Returns a list of all methods in type hierarchy
	End Rem
	Method EnumMethods:TList( list:TList=Null )
		Function cmp_by_index:Int( a:TMethod, b:TMethod)
			Return a._index - b._index
		EndFunction
		
		If Not list list=New TList
		If _super And _super &lt;&gt; Self Then _super.EnumMethods list
		For Local t:TMethod=EachIn _methods
			list.AddLast t
		Next
		'FIX: remove overridden methods
'		list.Sort()
'		Local prev:TMethod
'		For Local t:TMethod = EachIn list
'			If prev Then
'				If (t._index - prev._index) = 0 Then list.Remove(prev)
'			EndIf
'			prev = t
'		Next
		list.Sort( True, Byte Ptr cmp_by_index)
		Local prev:TMethod
		For Local t:TMethod = EachIn list
			If prev Then
				If (t._index - prev._index) = 0 Then list.Remove(prev)
			EndIf
			prev = t
		Next
		
		Return list
	End Method	

	Rem
	bbdoc: Enumerate all functions
	about: Returns a list of all functions in type hierarchy
	End Rem
	Method EnumFunctions:TList( list:TList=Null )
		Function cmp_by_name:Int( a:TFunction, b:TFunction)
			Return a.Name().Compare(b.Name())
		EndFunction

		If Not list list=New TList
		If _super And _super &lt;&gt; Self Then _super.EnumFunctions list
		For Local t:TFunction=EachIn _functions
			list.AddLast t
		Next
		
		'FIX: remove overridden functions
		list.Sort( True, Byte Ptr cmp_by_name)
		Local prev:TFunction
		For Local t:TFunction = EachIn list
			If prev Then				
				If (t.Name().Compare(prev.Name())) = 0 Then list.Remove(prev)
			EndIf
			prev = t
		Next

		Return list
	End Method

	Rem
	bbdoc: Create a new array
	End Rem
	Method NewArray:Object( length, dims:Int[] = Null )
		If Not _elementType Throw "TypeID is not an array type"
		Local tag:Byte Ptr=_elementType._typeTag
		If Not tag
			tag=TypeTagForId( _elementType ).ToCString()
			_elementType._typeTag=tag
		EndIf
		If Not dims Then
			Return bbArrayNew1D( tag,length )
		Else
			Return bbRefArrayCreate( tag, dims )
		End If
	End Method
		
	Rem
	bbdoc: Create a new array slice from another array
	End Rem
	Method ArraySlice:Object( a:Object, start:Int = 0, stop:Int = -1 )
		If Not _elementType Throw "TypeID is not an array type"
		Local tag:Byte Ptr=_elementType._typeTag
		If Not tag
			tag=TypeTagForId( _elementType ).ToCString()
			_elementType._typeTag=tag
		EndIf
		If stop &lt; 0 Then
			stop = bbRefArrayLength( a, 0)
		EndIf
		Return bbArraySlice( tag, a, start, stop)
	End Method
	
	Rem
	bbdoc: Get array length
	End Rem
	Method ArrayLength( array:Object, dim:Int = 0 )
		If Not _elementType Throw "TypeID is not an array type"
		Return bbRefArrayLength( array, dim )
	End Method
	
	Rem
	bbdoc: Get the number of dimensions
	End Rem
	Method ArrayDimensions:Int( array:Object )
		If Not _elementType Throw "TypeID is not an array type"
		Return bbRefArrayDimensions( array )
	End Method
	
	Rem
	bbdoc: Get an array element
	End Rem
	Method GetArrayElement:Object( array:Object,index )
		If Not _elementType Throw "TypeID is not an array type"
		Local p:Byte Ptr=bbRefArrayElementPtr( _elementType._size,array,index )
		Return _Get( p,_elementType )
	End Method
	
	Rem
	bbdoc: Set an array element
	End Rem
	Method SetArrayElement( array:Object,index,value:Object )
		If Not _elementType Throw "TypeID is not an array type"
		Local p:Byte Ptr=bbRefArrayElementPtr( _elementType._size,array,index )
		_Assign p,_elementType,value
	End Method
	
	Rem
	bbdoc: Get Type by name
	End Rem
	Function ForName:TTypeId( name$ )
		_Update
		' arrays
		If name.EndsWith( "[]" )
			name=name[..name.length-2].Trim()
			Local elementType:TTypeId = ForName( name )
			If Not elementType Then Return Null
			Return elementType.ArrayType()
		' pointers
		ElseIf name.EndsWith( "Ptr" )
			name=name[..name.length-4].Trim()
			If Not name Then Return Null
			Local baseType:TTypeId = ForName( name )
			If baseType Then
				' check for valid pointer base types
				Select baseType
					Case ByteTypeId, ShortTypeId, IntTypeId, LongTypeId, FloatTypeId, DoubleTypeId
						Return baseType.PointerType()
					Default
						If baseType.ExtendsType(PointerTypeId) Then Return baseType.PointerType()
				EndSelect
			EndIf
			Return Null
		' function pointers
		ElseIf name.EndsWith( ")" )
			' check if its in the table already
			Local t:TTypeId = TTypeId( _nameMap.ValueForKey( name.ToLower() ) )
			If t Then Return t
			Local i:Int = name.Find("(")
			Local ret:TTypeId = ForName( name[..i].Trim())
			Local typs:TTypeId[]
			If Not ret Then ret = NullTypeId
			If ret Then
				Local params:String = name[i+1..name.Length-1].Trim()
				If params Then
					Local args:String[] = params.Split(",")
					If args.Length &gt;= 1 And args[0] Then
						typs = New TTypeId[args.Length]
						For Local i:Int = 0 Until args.Length
							typs[i] = ForName(args[i].Trim())
							If Not typs[i] Then typs[i] = ObjectTypeId
						Next
					EndIf
				EndIf
				ret._functionType = Null
				Return ret.FunctionType(typs)
			EndIf
		Else
			' regular type name lookup
			Return TTypeId( _nameMap.ValueForKey( name.ToLower() ) )
		EndIf
	End Function	
Rem
	Function ForName:TTypeId( name$ )
		_Update
		If name.EndsWith( "]" )
			' TODO
			name=name[..name.length-2]
			Return TTypeId( _nameMap.ValueForKey( name.ToLower() ) ).ArrayType()
		Else
			Return TTypeId( _nameMap.ValueForKey( name.ToLower() ) )
		EndIf
	End Function
EndRem

	Rem
	bbdoc: Get Type by object
	End Rem	
	Function ForObject:TTypeId( obj:Object )
		_Update
		Local class=bbRefGetObjectClass( obj )
		If class=ArrayTypeId._class
			If Not bbRefArrayLength( obj ) Return ArrayTypeId
			Return TypeIdForTag( bbRefArrayTypeTag( obj ) ).ArrayType()
		Else
			Return TTypeId( _classMap.ValueForKey( New TClass.SetClass( class ) ) )
		EndIf
	End Function
	
	Rem
	bbdoc: Get list of all types
	End Rem
	Function EnumTypes:TList()
		_Update
		Local list:TList=New TList
		For Local t:TTypeId=EachIn _nameMap.Values()
			list.AddLast t
		Next
		Return list
	End Function

	'***** PRIVATE *****
	
	Method Init:TTypeId( name$,size,class=0,supor:TTypeId=Null )
		_name=name
		_size=size
		_class=class
		_super=supor
		_consts=New TList
		_fields=New TList
		_methods=New TList
		_functions=New TList
		_nameMap.Insert _name.ToLower(),Self
		If class _classMap.Insert New TClass.SetClass( class ),Self
		Return Self
	End Method
	
	Method SetClass:TTypeId( class )
		Local debug=(Int Ptr class)[2]
		Local name$=String.FromCString( Byte Ptr( (Int Ptr debug)[1] ) ),meta$
		Local i=name.Find( "{" )
		If i&lt;&gt;-1
			meta=name[i+1..name.length-1]
			name=name[..i]
		EndIf
		_name=name
		_meta=meta
		_class=class
		_nameMap.Insert _name.ToLower(),Self
		_classMap.Insert New TClass.SetClass( class ),Self
		Return Self
	End Method
	
	Function _Update()
		Local count,p:Int Ptr=bbObjectRegisteredTypes( count )
		If count=_count Return
		Local list:TList=New TList
		For Local i=_count Until count
			Local ty:TTypeId=New TTypeId.SetClass( p[i] )
			list.AddLast ty
		Next
		_count=count
		For Local t:TTypeId=EachIn list
			t._Resolve
		Next
	End Function
	
	Method _Resolve()
		If _fields Or Not _class Return
		
		_consts=New TList
		_fields=New TList
		_methods=New TList
		_functions=New TList
		_super=TTypeId( _classMap.ValueForKey( New TClass.SetClass( (Int Ptr _class)[0] ) ) )
		If Not _super _super=ObjectTypeId
		If Not _super._derived _super._derived=New TList
		_super._derived.AddLast Self
		
		Local debug=(Int Ptr _class)[2]
		Local p:Int Ptr=(Int Ptr debug)+2
		
		While p[0]
			Local id$=String.FromCString( Byte Ptr p[1] )
			Local ty$=String.FromCString( Byte Ptr p[2] )
			
			Local meta$
			Local i=ty.Find( "{" )
			If i&lt;&gt;-1
				meta=ty[i+1..ty.length-1]
				ty=ty[..i]
			EndIf

			Select p[0]
				Case 1	'const
					Local tt:TTypeId = TypeIdFortag(ty)
					If tt Then
						_consts.AddLast New TConstant.Init( id, tt, meta, p[3])
					EndIf
					
				Case 3	'field
					Local tt:TTypeId = TypeIdForTag(ty)
					If tt Then
						_fields.AddLast New TField.Init( id, tt, meta, p[3])
					EndIf
					
				Case 6	'method
					Local tt:TTypeId = TypeIdForTag(ty)
					If tt Then			
						_methods.AddLast New TMethod.Init( id, tt, meta, Self, p[3])
					EndIf
					
				Case 7	' function
					Local tt:TTypeId = TypeIdForTag(ty)
					If tt Then
						_functions.AddLast New TFunction.Init(id, tt, meta, Self, p[3])
					EndIf
			EndSelect
			p:+4
		Wend
	End Method
	
	Field _name$
	Field _meta$
	Field _class
	Field _size=4
	Field _consts:TList
	Field _fields:TList
	Field _methods:TList
	Field _functions:TList
	Field _super:TTypeId
	Field _derived:TList
	Field _arrayType:TTypeId
	Field _elementType:TTypeId
	Field _typeTag:Byte Ptr
	Field _pointerType:TTypeId
	Field _functionType:TTypeId, _argTypes:TTypeId[], _retType:TTypeId
	
	Global _count,_nameMap:TMap=New TMap,_classMap:TMap=New TMap
	
End Type
</textarea> <br><br></td></tr></table><br>
<a name="1302417"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> Missed your reply - so excuse the delay.<br><br>I understand your reasons on why you did it that way.<br>Of course I am using "?bmxng"-conditionals, but the problem is, that once, bmxng adjusts its behaviour to "yours", then the application needs manual adjustment (if you miss removing that conditional adjustments, it breaks logic/bugs out).<br><br>Hmpf.<br><br>Thanks again for your time.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311970"></a>

<a name="1311971"></a>

<a name="1311975"></a>

<a name="1311980"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just recognized, that invoking functions does not work as expected:<br><br><pre class=code>
SuperStrict

Framework Brl.StandardIO

Import Brl.Reflection 'extended variant


Type Test
	Function Func:Int()
	End Function
End Type


Local tID:TTypeId = TTypeId.ForName("Test")

Local func:TFunction = tID.FindFunction("Func")

'segfaults in "invoke"
func.Invoke(Null)

Print "invoked"
</pre><br><br><br>When adding a "debugstop" and then going into all called functions it segfaults when calling the external function "bbRefMethodPtr" (because "obj" is null)<br><br><pre class=code>
	Method FunctionPtr:Byte Ptr( obj:Object)
		If _fptr Then Return _fptr
		If _index &lt; 65536 Then
~~~~&gt;		_fptr = bbRefMethodPtr( obj ,_index)
		EndIf
		Return _fptr
	End Method
</pre><br><br>So the problem is that I pass "null" to invoke (as the obj-param) ... but am I really supposed to pass an instance of the type there? Functions are meant to be callable also via "TMyClass.FunctionName()".<br><br>Replacing that "func.Invoke(null)" with an existing type-instance as param, gets rid of the segfault...<br><br><pre class=code>
'works
Local t:Test = New Test
func.Invoke(t)
</pre><br><br><br>Invoking a method works.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1312418"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, its fixed in v0.26 by using the Self TypeId class directly on Null arguments. <br><br></td></tr></table><br>
<a name="1312774"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the update.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317705"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your code does not compile with my Mac OS X...<br><br>the *.x86.s contains invalid characters - also things like ".global" do not exist (you need to use ".globl") - and ".extern" seems to be not needed.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317709"></a>

<a name="1317711"></a>

<a name="1317712"></a>

<a name="1317713"></a>

<a name="1317714"></a>

<a name="1317715"></a>

<a name="1317716"></a>

<a name="1317717"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the heads up, without a mac its hard to test these things.<br><br>The invalid characters might be CRLF? Since i develop on windows, my editors use that as EOL, and its not UTF-8 either, which both linux and macosx might expect.<br><br>But that AT&amp;T syntax really sucks :(  Some docs say ".global" other say ".globl", other say they are aliased. But apparently its up the the platform??<br><strike>And I cant get it to assemble no matter what i do either...<br>Usually one uses size suffixes, but it complains when i do. And when i dont it also complains, so i am at a loss here.</strike><br>Stupid me forgets i have 64bit mingw now ;)<br><br>Does it work just with changing to .globl for you?<br><br>In any case, i updated it with your change at least. But im leaving .extern in to make it similar to the others, and just because its the right thing to do ;)<br><br>EDIT: Oh and btw, what version of AS are you using?  Since 2.10 they added .intel_syntax directive so i can probably use that instead.<br>EDIT2: I re-uploaded the archive with linux and macosx files in UTF-8 and with only LF chars. <br><br></td></tr></table><br>
<a name="1317719"></a>

<a name="1317720"></a>

<a name="1317722"></a>

<a name="1317723"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> I use a Mac in a VM ... so it is outdated (but used to work).<br><br><br>as -v<br>Apple Inc version cctools-750-70, GNU assembler version 1.38<br><br><br><br>Stored with LineEnding "CR" ("LF" is Linux, "CR/LF" is Windows) and it compiled with<br><br><pre class=code>
.globl _bbCallMethod
_memcpy

.text
	
_bbCallMethod:
	push %ebp
	mov %esp, %ebp
	sub 16(%ebp), %esp
	push 16(%ebp)
	push 12(%ebp)
	push %esp
	call _memcpy
	add 4, %esp
	call *8(%ebp)
	mov %ebp, %esp
	pop %ebp
	ret
</pre><br><br>Then on linking:<br><pre class=code>
Undefined symbols:
  "_bbCallMethod", referenced from:
      _814 in reflection.bmx.release.macos.x86.o
      _816 in reflection.bmx.release.macos.x86.o
      _808 in reflection.bmx.release.macos.x86.o
      _809 in reflection.bmx.release.macos.x86.o
      _810 in reflection.bmx.release.macos.x86.o
      _811 in reflection.bmx.release.macos.x86.o
ld: symbol(s) not found
</pre><br><br><br>PS: Excuse my request without a solution - was prepared to release a new version of my open source game ... and then it did not compile for Mac ... fiddling with little hotfixes for 3 hrs now ...arrrgh ;-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Apple Inc version cctools-750-70, GNU assembler version 1.38 <br></div><br>Ah yes, the things ive heard about seriously outdated gnu tools on mac isnt an exaggeration i suppose.<br><br>Im surprised it compiled with only CR, so far as i know OSX follows its BSD roots and uses LF like linux does.<br><br><div class="quote"> Excuse my request without a solution - was prepared to release a new version of my open source game ... and then it did not compile for Mac ... fiddling with little hotfixes for 3 hrs now ...arrrgh ;-) <br></div><br>No problem dude. Its <i>my</i> baby so i have to keep it well fed :p<br>But it seems your the only one using it though hehe <br><br></td></tr></table><br>
<a name="1317752"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any ideas about the linking issue?<br><br>Is there a real need for the ASM files at all? I mean: could that get achieved with c/bmx only?<br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1317758"></a>

<a name="1317759"></a>

<a name="1317760"></a>

<a name="1317761"></a>

<a name="1317762"></a>

<a name="1317763"></a>

<a name="1317764"></a>

<a name="1317765"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Any ideas about the linking issue? <br></div><br>Oh, sorry. I missed that.<br><br>Its probably the number of underscores before the symbol. Windows tends to always have one, the others not so much.<br><br>You can look at the generated S files on mac and see what bmx spits out, or try  removing/adding underscores.<br><br>Allso, after trying it on here it crashes. Which is probably because i didnt use size suffixes so it inferred the wrong size.<br>I disassembled the win32 code, and saw that it really did use them, so i did too and it now works here (on Windows, but still)<br>So try using this snippet until it compiles.<br><pre class=code>
.globl bbCallMethod
.extern _memcpy

.text

bbCallMethod:
	push   %ebp
	mov    %esp,%ebp
	sub    0x10(%ebp),%esp
	pushl  0x10(%ebp)
	pushl  0xc(%ebp)
	push   %esp
	call   _memcpy
	add    $0x4,%esp
	call   *0x8(%ebp)
	mov    %ebp,%esp
	pop    %ebp
	ret
</pre>Note the removed underscore, this wont compile on windows.<br><br>When you figure out the underscore thing il update the top post :)<br><br>EDIT:<br><div class="quote"> Is there a real need for the ASM files at all? I mean: could that get achieved with c/bmx only? <br></div><br>Well, sure. The original did just that, but it was limited by number of arguments and it was probably a bit slower. Though i havent benched it.<br>ASM is needed in this case to support unlimited arguments. <br><br></td></tr></table><br>
<a name="1317786"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried your code... and it compiled ... but the linker error kept the same.<br><br>So while I removed the underscore from "bbCallMethod" (two times) and _REBUILT_  my application (so no cache usage) the error kept saying<br><br><pre class=code>
Undefined symbols:
  "_bbCallMethod", referenced from:
      _814 in reflection.bmx.release.macos.x86.o
      _816 in reflection.bmx.release.macos.x86.o
      _808 in reflection.bmx.release.macos.x86.o
      _809 in reflection.bmx.release.macos.x86.o
      _810 in reflection.bmx.release.macos.x86.o
      _811 in reflection.bmx.release.macos.x86.o
ld: symbol(s) not found
</pre><br>(same line numbers than before)<br><br><br>reflection.bmx.release.linux.x86.s only contains "bbCallMethod", no underscore.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317811"></a>

<a name="1317812"></a>

<a name="1317813"></a>

<a name="1317814"></a>

<a name="1317815"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm.. <br><br>After looking over how BRL.Blitz does it, it uses underscore for macos so i was wrong on that one.<br>What i did notice though was that Blitz.bmx always uses the extern name with no underscores, so maybe that will work.<br><br>Change line 125 of reflection.bmx to:<pre class=code>
Function bbCallMethod:Int( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
</pre>EDIT: And add the underscore back in to the one i posted above.. <br><br></td></tr></table><br>
<a name="1317845"></a>

<a name="1317846"></a>

<a name="1317849"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> That did not do it.<br><br>So I build up a small example for the reflection stuff (my game just takes too long to compile in the Mac VM).<br><br><br>- switching back to LF-LineEnding (Unix-Style) (required, CR does not work)<br>- removed the "_memcpy" (invalid character '_' in mnemonic)<br>- added back underscores<br><br>-&gt; compiled and executed<br><br><br>I think ".extern _memcpy" is not needed, as "_memcpy" is automatically "externed".<br><br><br><br><pre class=code>
.globl _bbCallMethod

.text

_bbCallMethod:
	push %ebp
	mov %esp, %ebp
	sub 16(%ebp), %esp
	push 16(%ebp)
	push 12(%ebp)
	push %esp
	call _memcpy
	add 4, %esp
	call *8(%ebp)
	mov %ebp, %esp
	pop %ebp
	ret
</pre><br><br><br>reflection.bmx kept as before:<br><pre class=code>
Function bbCallMethod:Int( p:Byte Ptr, args:Byte Ptr, sz:Int)
Function bbCallMethod_Float:Float( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
Function bbCallMethod_Object:Object( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
Function bbCallMethod_Double:Double( p:Byte Ptr, args:Byte Ptr, sz:Int) = "bbCallMethod"
</pre><br><br><br>Edit: My Game now crashes when going into a specific situation. Will check in the evening if it has to do with the new reflection stuff (debug build surely takes some time ...time I do not have now).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317863"></a>

<a name="1317867"></a>

<a name="1317868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> Weird...  At least it compiles now :)<br><br>But you need to use the one with size suffixes, or it will read/write bytes instead of longs.<br><br><pre class=code>
.globl _bbCallMethod

.text

_bbCallMethod:
	pushl   %ebp
	movl    %esp,%ebp
	subl    0x10(%ebp),%esp
	pushl  0x10(%ebp)
	pushl  0xc(%ebp)
	pushl   %esp
	calll   _memcpy
	addl    $0x4,%esp
	calll   *0x8(%ebp)
	movl    %ebp,%esp
	popl    %ebp
	ret
</pre><br><br>Updated top post with the new code as well.<br><br>EDIT:<br><div class="quote"> I think ".extern _memcpy" is not needed, as "_memcpy" is automatically "externed". <br></div><br>Its a GCC builtin, which is probably why you dont have to define it. Still its the right thing to do ;)  declaring intent and all. <br><br></td></tr></table><br>
<a name="1317917"></a>

<a name="1317918"></a>

<a name="1317921"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#98">[#98]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ extern not needed<br>It is not "allowed" in that ancient build chain. So I did not "optionally" remove it, but was forced to do so.<br><br><br>Recompiled with your adjustments (in "debug mode"):<br><br>"TVTower.debug wurde unerwartet beendet." - think it is telling something in the likes of "unconditionally exited the application". So even the debugger did not "hop in".<br><br><br>Running it via "GDB" saays <br><br>Program received signal EXC_BADACCESS, Could not access memory.<br>Reason: KERN_PROTECTION_FAILURE at address: ...<br><br>the backtrace then contains<br>"in std::list&lt;IMaxModChannel*, std::allocator&lt;IMaxModChannel*&gt; &gt;:: ..."<br><br>So it somehow crashes when doing something with MaxMod2 (audio streaming module). But I doubt it has to do something - did not change that code portions the last days.<br><br><br>Ok, so I replaced the reflection stuff with a variant "before ASM" ... compiled and run the game without that crash.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317965"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#99">[#99]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well thats a bummer. The code is identical for all 3 platforms, but there may be some stack layout or other im not aware of on MacOSX (or Linux for that matter).<br><br>Hmm weird that it should propagate into there, but if there is some stack misalignment that would do it. <br>Il have to look into this...<br><br>At least you only have to replace _Call() with an earlier version.<br><br>Are you compiling this on Linux as well btw? <br><br></td></tr></table><br>
<a name="1317967"></a>

<a name="1317968"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#100">[#100]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can try the code below. Which aligns the arguments and the stack on 16 a byte boundary (with some waste of course) for MacOSX only.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function _Call:Object( callableP:Byte Ptr, retTypeId:TTypeId, obj:Object=Null, args:Object[], argtypes:TTypeId[])
	Assert args.Length = argtypes.Length

	Local q:Int[MAX_CALL_ARGS + 2], sp:Byte Ptr = q
	
	If obj 'method call of an instance
		bbRefPushObject sp,obj
		sp:+4
	EndIf
	
	Local lret:Long
	If retTypeId = LongTypeId Then
		Byte Ptr Ptr(sp)[0] = Byte Ptr Varptr lret
		sp :+ 4
	EndIf

	For Local i:Int = 0 Until args.Length
		If Int Ptr(sp) &gt;= Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #1"
		sp = _Push( sp, argtypes[i], args[i])
	Next
	If Int Ptr(sp) &gt; Int Ptr(q)+MAX_CALL_ARGS Then Throw "_Call() ERROR: Exceeded max args #2"
	
	Local size:Int = sp - Byte Ptr q
?MacOS
	' macs require 16 byte aligned stack
	size = size + 15 &amp; ~15
	If size &gt; SizeOf(q) Then Throw "_Call() ERROR: Exceeded max args #3"
?
	Select retTypeId
		Case ByteTypeId, ShortTypeId, IntTypeId
'			Local f(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'			Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Return String.FromInt( bbCallMethod( callableP, q, size) )
		Case LongTypeId
'			Local r:Long
'			If obj Then
'				Local f( p0, r:Long Var, p1,p2,p3,p4,p5,p6,p7) = callableP
'				f( q[0], r, q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
'			Else
'				Local f( r:Long Var, p0, p1,p2,p3,p4,p5,p6,p7) = callableP
'				f( r, q[0], q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
'			EndIf
'			Return String.FromLong(r)
			bbCallMethod( callableP, q, size)
			Return String.FromInt( lret )
		Case FloatTypeId
'			Local f:Float(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'			Return String.FromFloat( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Return String.FromFloat( bbCallMethod_Float( callableP, q, size) )
		Case DoubleTypeId
'			Local f:Double(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'			Return String.FromDouble( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
			Return String.FromDouble( bbCallMethod_Double( callableP, q, size) )
		Default
			If retTypeId.ExtendsType(PointerTypeId) Or retTypeId.ExtendsType(FunctionTypeId) Then
'				Local f:Int(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'				Return String.FromInt( f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] ) )
				Return String.FromInt( bbCallMethod( callableP, q, size) )
			Else
'				Local f:Object(p0, p1, p2, p3, p4, p5, p6, p7) = callableP
'				Return f( q[0],q[1],q[2],q[3],q[4],q[5],q[6],q[7] )
				Return bbCallMethod_Object( callableP, q, size)
			EndIf
	End Select
End Function
</textarea><br><pre class=code>
.globl _bbCallMethod

.text

_bbCallMethod:
	pushl %ebp
	movl %esp, %ebp
	andl $0xFFFFFFF0, %esp
	subl 0x10(%ebp), %esp
	pushl 0x10(%ebp)
	pushl 0xc(%ebp)
	pushl %esp
	calll _memcpy
	addl $0x4, %esp
	calll *0x8(%ebp)
	movl %ebp, %esp
	popl %ebp
	ret
</pre> <br><br></td></tr></table><br>
<a name="1317985"></a>

<a name="1317986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#101">[#101]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compiled with your adjustments. Compilation successful, game starts ... crashes on a specific action (going to next screen)<br><br>It must be some "specific thing". I also tried to removed "play sound"-parts but it still crashes.<br><br><br>@ Linux<br>Yes, my main development takes place on a Linux Mint 64 bit installation. <br>Windows is compiled via MicroXP-VM and Mac via a Mac OS X VM.<br>(Windows then could be tested on winXP, 7, 8 and 10 - for now I only had trouble with win10 and some graphics thingies)<br><br><br><br>Edit: I also tried the "demoapp"-sample of my framework Dig<br>(http://github.com/GWRon/Dig.git) and when replacing the "external/reflectionExtended"-portion with yours - aka "updating your reflection stuff") it crashes too - as soon as I close the modal dialogue (some gui stuff).<br>So it seems to be not connected to sound stuff.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1317995"></a>

<a name="1317996"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#102">[#102]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, if that didnt do it i dont know what will. I havent found any other "rules" for asm on macs either.<br>At least its only macs that are fussy, the rest are ok.<br><br>So for now, im going to revert back to the old way without assembly for macs. <br><br></td></tr></table><br>
<a name="1317999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#103">[#103]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excuse me for not being able to solve that puzzle with you.<br><br>ASM and memory/internal stuff is way over my head.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1318010"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#104">[#104]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hehe no problem dude :)<br><br>I will look into it some more though, whenever i get osx running in virtualbox.<br>Tried the 2 latest versions last year, but they both failed. Maybe itl work now, who knows :p <br><br></td></tr></table><br>
<a name="1318136"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#105">[#105]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wasnt aligning the stack properly, it needs to be aligned before each call apparently.<br>If you still want a go at this, replace the code in <a href="https://drive.google.com/open?id=0BzVLNZSckvfhWDRmNmk1SkR3RFU" target="_blank">v1.27</a> with the one below.<br><pre class=code>
.globl _bbCallMethod

.text

_bbCallMethod:
	push   %ebp
	mov    %esp,%ebp
	mov    %esp,%eax
	sub    0x10(%ebp),%eax
	and    $0xfffffff0,%eax
	mov    %eax,%esp
	push   $0x0
	pushl  0x10(%ebp)
	pushl  0xc(%ebp)
	push   %eax
	call   _memcpy
	add    $0x10,%esp
	call   *0x8(%ebp)
	mov    %ebp,%esp
	pop    %ebp
	ret
</pre> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
