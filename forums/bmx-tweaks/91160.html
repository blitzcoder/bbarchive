<!DOCTYPE html><html lang="en" ><head ><title >BlitzMax overview docs</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >BlitzMax overview docs</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >BlitzMax overview docs</a><br><br>
<a name="1037420"></a>

<a name="1221946"></a>

<a name="1222184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is an update to BlitzMax overview.bbdoc (from v 1.41). <br><br>I basically fixed some broken links and reformatted the example code. I also found that makedocs adds &lt;p&gt; inside &lt;pre&gt; tags on html files so that's why I've added &amp;nbsp; on every empty line inside &lt;pre&gt;... Edit: I've now added my own ending to the "Intro to OOP" tutorial rather than leave it saying "Stay tuned for part 2".<br><br>The files are zipped and posted below along with the patch.<br>blitzmax-overview-doc.zip (expired)<br><br>Last edit: 17 Aug 2010<br><br>BlitzMax overview.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- BlitzMax overview-old.bbdoc	2010-07-13 03:54:58.000000000 +0100
+++ BlitzMax overview.bbdoc	2010-08-17 11:04:51.079779687 +0100
@@ -5,14 +5,14 @@
 &lt;/head&gt;
 &lt;body&gt;
 
-&lt;h1&gt;BlitzMax tutorials and articles&lt;/h1&gt;
-
+&lt;h1&gt;BlitzMax overview&lt;/h1&gt;
+A collection of tutorials and articles from intermediate to advanced.
 &lt;ul&gt;
-&lt;li&gt;&lt;a href=#memory&gt;BlitzMax Memory management&lt;/a&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#memory&gt;BlitzMax memory management&lt;/a&gt;&lt;br&gt;
 &lt;br&gt;
 &lt;li&gt;&lt;a href=#oointro&gt;Introduction to OO programming&lt;/a&gt;&lt;br&gt;
 &lt;br&gt;
-&lt;li&gt;&lt;a href=#nehetuts&gt;The first 5 'Nehe' OpenGL tutorials&lt;/a&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#nehetuts&gt;The NeHe OpenGL tutorials&lt;/a&gt;&lt;br&gt;
 &lt;br&gt;
 &lt;li&gt;&lt;a href=#streams&gt;Writing custom stream handlers (advanced)&lt;/a&gt;&lt;br&gt;
 &lt;/ul&gt;
@@ -20,7 +20,7 @@
 &lt;hr&gt;
 
 &lt;div id=memory&gt;
-&lt;h1&gt;BlitzMax Memory management - or, "where did Delete go?!?"&lt;/h1&gt;
+&lt;h1&gt;BlitzMax memory management - or, "where did Delete go?!?"&lt;/h1&gt;
 
 As many users from a Blitz3D or BlitzPlus background have noticed, BlitzMax does not include a 'Delete' command.&lt;br&gt;
 &lt;br&gt;
@@ -50,23 +50,20 @@
 &lt;br&gt;
 One final complicating issue: BlitzMax includes a feature that allows you to assign objects to integers. This feature exists mainly to simplify things for beginners so, instead of...
 &lt;pre class=code&gt;
-Local image:TImage=LoadImage( "somepic.png" ) 'normal object to object assignment...
-&lt;/pre&gt;
+Local image:TImage=LoadImage( "somepic.png" ) 'normal object to object assignment...&lt;/pre&gt;
 ...you can just go...
 &lt;pre class=code&gt;
-Local image=LoadImage( "somepic.png" ) 'assigning an object to an int! What gives?
-&lt;/pre&gt;
+Local image=LoadImage( "somepic.png" ) 'assigning an object to an int! What gives?&lt;/pre&gt;
 However, if you are using this feature in your programs, you *must* later 'free' the object yourself using Release...
 &lt;pre class=code&gt;
-Release image
-&lt;/pre&gt;
+Release image&lt;/pre&gt;
 You can therefore think of Release as being similar to Blitz3D's FreeImage (or FreeSound, FreeThis, FreeThat etc).&lt;br&gt;
 &lt;br&gt;
 All-in-all, it's probably best to avoid object-to-int assignments altogther if you are concerned about memory leaks.&lt;br&gt;
 &lt;br&gt;
 And that's it! Well, not quite, but the above should be enough information for you to be able to write leak-free programs with. I'll go into some of the nitty gritty details below...&lt;br&gt;
 &lt;br&gt;
-&lt;h2&gt;The nitty gritty part 1 : dead objects &lt;/h2&gt;
+&lt;h2&gt;The nitty gritty part : dead objects&lt;/h2&gt;
 
 Ok, lets have a look at the question of 'what exactly is a dead object'? Well, a dead object is an object that is no longer referred to by any live objects. In other words, dead objects are objects your program can no longer 'see' - they are therefore completely useless to your program and can be safely deallocated.&lt;br&gt;
 &lt;br&gt;
@@ -75,24 +72,23 @@
 'example 1
 Local p:MyType=New MyType 'allocate object 1
 p=Null 'object 1 is now dead
-
+&amp;nbsp;
 'example 2
 Local p:MyType=New MyType 'allocate object 1
 Local q:MyType=New MyType 'allocate object 2
 p=q 'object 1 is now dead, object 2 is still alive
-
+&amp;nbsp;
 'example 3
 Local p:MyType[1] 'allocate object 1 (an array object)
-p[0]=New MyType 'allocate object 2
+p[0]=New MyType   'allocate object 2
 p=Null 'object 1 and object 2 both now dead
-
+&amp;nbsp;
 'example 4
 Local p:MyType=New MyType 'allocate object 1
-p.my_type=New MyType 'allocate object 2
-p.my_type=New MyType 'allocate object 3 - object 2 now dead
+p.my_type=New MyType      'allocate object 2
+p.my_type=New MyType      'allocate object 3 - object 2 now dead
 Local q:MyType=p.my_type
-p=Null 'object 1 and object 2 dead, object 3 still alive thanks to the q assignment above
-&lt;/pre&gt;
+p=Null 'object 1 and object 2 dead, object 3 still alive thanks to the q assignment above&lt;/pre&gt;
 After seeing this sort of thing, there is a tendancy for people to stick '=Null' code all over the place in an attempt to 'force' objects to become dead - but this is generally not necessary.&lt;br&gt;
 &lt;br&gt;
 Sooner or later, all variables will either be overwritten by new values, or (in the case of Locals and Fields) simply go out of scope. Both of these actions are enough to ensure that dead objects will be correctly detected and deallocated.&lt;br&gt;
@@ -105,7 +101,7 @@
 &lt;hr&gt;
 
 &lt;div id=oointro&gt;
-&lt;h1&gt;Crash course in OO programming for Blitz coders&lt;/h1&gt;
+&lt;h1&gt;Introduction to OO programming&lt;/h1&gt;
 
 Welcome to a crash course in OO programming for Blitz coders!&lt;br&gt;
 &lt;br&gt;
@@ -114,68 +110,63 @@
 *Disclaimer* - OO coding means different things to different people. This article is strongly swayed by my own experience with OO coding and what I like and find useful about it. The actual 'meaning' of OO is almost as fun to argue about as whether the universe is infinite or not.&lt;br&gt;
 &lt;br&gt;
 First up, OO coding has spawned a bunch of initially confusing but actually quite sensible buzzwords, including such gems as:&lt;br&gt;
+&lt;ul&gt;
+&lt;li&gt;Inheritance&lt;br&gt;
+&lt;li&gt;Polymorphism&lt;br&gt;
+&lt;li&gt;Virtual&lt;br&gt;
+&lt;li&gt;Abstract&lt;br&gt;
+&lt;li&gt;Concrete&lt;br&gt;
+&lt;li&gt;Type&lt;br&gt;
+&lt;li&gt;Class&lt;br&gt;
+&lt;li&gt;Object&lt;br&gt;
+&lt;li&gt;Instance&lt;br&gt;
+&lt;li&gt;Base Class&lt;br&gt;
+&lt;li&gt;Derived Class&lt;br&gt;
+&lt;li&gt;Super Class&lt;br&gt;
+&lt;li&gt;Sub Class&lt;br&gt;
+&lt;/ul&gt;
+Scary stuff! Well, not really. Never forget that behind the scenes it's all just a bunch of bits and bytes and Ifs and Adds and Gotos.&lt;br&gt;
 &lt;br&gt;
-Inheritance&lt;br&gt;
-Polymorphism&lt;br&gt;
-Virtual&lt;br&gt;
-Abstract&lt;br&gt;
-Concrete&lt;br&gt;
-Type&lt;br&gt;
-Class&lt;br&gt;
-Object&lt;br&gt;
-Instance&lt;br&gt;
-Base Class&lt;br&gt;
-Derived Class&lt;br&gt;
-Super Class&lt;br&gt;
-Sub Class&lt;br&gt;
-&lt;br&gt;
-Scary stuff!&lt;br&gt;
-&lt;br&gt;
-Well, not really. Never forget that behind the scenes its all just a bunch of bits and bytes and Ifs and Adds and Gotos.&lt;br&gt;
-&lt;br&gt;
-As always, its easier than the guys who get paid megabucks to do it would have us think.&lt;br&gt;
+As always, it's easier than the guys who get paid megabucks to do it would have us think.&lt;br&gt;
 &lt;br&gt;
-&lt;h2&gt;Part 1 : Inheritance&lt;/h2&gt;
+&lt;h2&gt;Inheritance&lt;/h2&gt;
 
 Inheritance is a way of 'composing' objects from other objects.&lt;br&gt;
 &lt;br&gt;
 This is already possible in procedural Blitz. Consider the following code...
 &lt;pre class=code&gt;
 Type Part1
-Field x,y,z
+	Field x,y,z
 End Type
-
+&amp;nbsp;
 Type Part2
-Field p1.Part1
-Field p,q,r
+	Field p1.Part1
+	Field p,q,r
 End Type
-
+&amp;nbsp;
 Function UpdatePart1( t:Part1 )
-'Do something clever with a Part1.
-End Function
-&lt;/pre&gt;
+	'Do something clever with a Part1.
+End Function&lt;/pre&gt;
 This is one way of composing objects. Part2 'contains' a Part1, via the p1 field.&lt;br&gt;
 &lt;br&gt;
 If you've got a Part2 object and want to call UpdatePart1(), you can grab the p1 field and use it in the function call, for example:
 &lt;pre class=code&gt;
 Local t:Part2=New Part2
 t.p1=New Part1 'need to create it!
-UpdatePart1 t.p1
-&lt;/pre&gt;
+UpdatePart1 t.p1&lt;/pre&gt;
 OO inheritance provides a different (not always better!) way to do this:
 &lt;pre class=code&gt;
 Type Base
-Field x,y,z
+	Field x,y,z
 End Type
-
+&amp;nbsp;
 Type Derived Extends Base
-Field p,q,r
+	Field p,q,r
 End Type
-
+&amp;nbsp;
 Function UpdateBase( t:Base )
-'Do something clever with a Base object.
-End Function
-&lt;/pre&gt;
+	'Do something clever with a Base object.
+End Function&lt;/pre&gt;
 Ok, we've already hit our first OO buzzwords - Base and Derived. These are not special keywords, they are just names I chose for these types. Bear with me and hopefully you'll get some idea of why I chose them.&lt;br&gt;
 &lt;br&gt;
 First up, The Base type is just the same as the procedural Part1 type - no problem there.&lt;br&gt;
@@ -187,20 +178,17 @@
 This means that the Derived type above actually has the additional fields x,y,z - these have been 'inherited' from the Base type. It is then perfectly legal for you to code up something like:
 &lt;pre class=code&gt;
 Local t:Derived=New Derived
-
-t.x=100 'x inherited from Base - thanks Base, you rock!
-&lt;/pre&gt;
+&amp;nbsp;
+t.x=100 'x inherited from Base - thanks Base, you rock!&lt;/pre&gt;
 Another way to think of it is the Derived type 'is a' Base type, but with some extra stuff. In fact, in OO terminology 'IsA' is often used to indicate inheritance or inheritance-like properties.&lt;br&gt;
 &lt;br&gt;
-Now it gets a bit interesting. Since our Derived type 'is a' Base type, its perfectly legal to use it where ever a Base type is expected - for example, the UpdateBase() function:
+Now it gets a bit interesting. Since our Derived type 'is a' Base type, it's perfectly legal to use it where ever a Base type is expected - for example, the UpdateBase() function:
 &lt;pre class=code&gt;
 Local MyDerived:Derived=New Derived 'fine...
-UpdateBase MyDerived 'What?!?
-&lt;/pre&gt;
-Initially, this looks *wrong* - 'Type mismatch error' looms! But in OO code its fine. Since Derived extends Base, its OK to use a Derived where ever a Base is expected - even in assignments:
+UpdateBase MyDerived 'What?!?&lt;/pre&gt;
+Initially, this looks *wrong* - 'Type mismatch error' looms! But in OO code it's fine. Since Derived extends Base, it's OK to use a Derived where ever a Base is expected - even in assignments:
 &lt;pre class=code&gt;
-Local MyBase:Base=New Derived 'Okay, because Derived extends (or 'Is a') Base.
-&lt;/pre&gt;
+Local MyBase:Base=New Derived 'Okay, because Derived extends (or 'Is a') Base.&lt;/pre&gt;
 In addition, there could be many types extending Base, and each of these could be used interchangeably with Base.&lt;br&gt;
 &lt;br&gt;
 Hopefully the terms 'Base' and 'Derived' now mean something. The Derived type is derived from, or 'comes from', the Base type.&lt;br&gt;
@@ -208,63 +196,81 @@
 Remember that Base and Derived are just names I chose for this example. In real world coding, you'd use useful names, for example:
 &lt;pre class=code&gt;
 Type Actor
-Field x,y,z
+	Field x,y,z
 End Type
-
+&amp;nbsp;
 Type Player Extends Actor
-Field lives,score
-End Type
-&lt;/pre&gt;
+	Field lives,score
+End Type&lt;/pre&gt;
 But still, you can think of Actor as the base type, and Player as the derived type - a Player is derived from an Actor.&lt;br&gt;
 &lt;br&gt;
-Its also perfectly legal (and very useful!) to extend extended types, for example:
+It's also perfectly legal (and very useful!) to extend extended types, for example:
 &lt;pre class=code&gt;
 Type Actor
-Field x,y,z
+	Field x,y,z
 End Type
-
+&amp;nbsp;
 Type Player Extends Actor
-Field lives,score
+	Field lives,score
 End Type
-
+&amp;nbsp;
 Type Enemy Extends Actor
-Field mood
+	Field mood
 End Type
-
+&amp;nbsp;
 Type Troll Extends Enemy
-Field grudge_quotient
+	Field grudge_quotient
 End Type
-
+&amp;nbsp;
 Type Ghoul Extends Enemy
-Field lust_for_life
-End Type
-&lt;/pre&gt;
+	Field lust_for_life
+End Type&lt;/pre&gt;
 So, if you've got a function like UpdateActor( t:Actor ), you can pass it any of the above types as they are all ultimately derived from Actor.&lt;br&gt;
 &lt;br&gt;
 Similarly, a RethinkMood( t:Enemy ) function could be used with any of the bad guys (Enemy, Troll or Ghoul) - but not with players, as Player is not derived from Enemy.&lt;br&gt;
 &lt;br&gt;
 This is what is known as a 'class hierarchy' - a 'tree' of types.&lt;br&gt;
 &lt;br&gt;
-Stay tuned for part 2...!
+&lt;h2&gt;Summary&lt;/h2&gt;
+
+To finish off, here's a summary of some more OO buzzwords.&lt;br&gt;
+&lt;br&gt;
+A %class is the same thing as a type i.e. a template that is used to create %objects, also known as %instances.&lt;br&gt;
+&lt;br&gt;
+A derived class is also known as a child class or %sub class, since they occur below another class in the hierarchy.&lt;br&gt;
+&lt;br&gt;
+A base class is also known as a parent class or %super class, since they are above all other classes in the hierarchy.&lt;br&gt;
+&lt;br&gt;
+If a class is declared as %abstract then it cannot be instantiated, it must first be extended in a derived class. Only the base class should be abstracted.&lt;br&gt;
+&lt;br&gt;
+If a method in a base class is declared as abstract, then before a derived class can become %concrete i.e. can be instantiated, it must implement the abstract method.&lt;br&gt;
+&lt;br&gt;
+Abstract and %virtual methods are similar in that both can be overridden by a derived method of the same name, they differ in that abstract methods are not implemented in the base class.&lt;br&gt;
+&lt;br&gt;
+In BlitzMax, methods (and functions) are virtual by default, so to create a %non-virtual method i.e. one that cannot be overridden, we can declare it as %final.&lt;br&gt;
+&lt;br&gt;
+For more on OO techniques, see the &lt;a href="../../Language/User defined types/index.html"&gt;User defined types&lt;/a&gt; section.&lt;br&gt;
 &lt;/div&gt;
 &lt;br&gt;
 &lt;hr&gt;
 
 &lt;div id=nehetuts&gt;
 
-&lt;h1&gt;The Nehe OpenGL tutorials&lt;/h1&gt;
+&lt;h1&gt;The NeHe OpenGL tutorials&lt;/h1&gt;
 The NeHe tutorials are a popular collection of OpenGL programming tutorials.&lt;br&gt;
 &lt;br&gt;
 Here are the first 5 NeHe tutorials converted to BlitzMax:
 &lt;ul&gt;
-&lt;li&gt;&lt;a href="../nehe_01.bmx"&gt;Nehe_01&lt;/a&gt;
-&lt;li&gt;&lt;a href="../nehe_02.bmx"&gt;Nehe_02&lt;/a&gt;
-&lt;li&gt;&lt;a href="../nehe_03.bmx"&gt;Nehe_03&lt;/a&gt;
-&lt;li&gt;&lt;a href="../nehe_04.bmx"&gt;Nehe_04&lt;/a&gt;
-&lt;li&gt;&lt;a href="../nehe_05.bmx"&gt;Nehe_05&lt;/a&gt;
+&lt;li&gt;&lt;a href="../nehe_01.bmx"&gt;nehe_01.bmx&lt;/a&gt;
+&lt;li&gt;&lt;a href="../nehe_02.bmx"&gt;nehe_02.bmx&lt;/a&gt;
+&lt;li&gt;&lt;a href="../nehe_03.bmx"&gt;nehe_03.bmx&lt;/a&gt;
+&lt;li&gt;&lt;a href="../nehe_04.bmx"&gt;nehe_04.bmx&lt;/a&gt;
+&lt;li&gt;&lt;a href="../nehe_05.bmx"&gt;nehe_05.bmx&lt;/a&gt;
 &lt;/ul&gt;
-For more information on these tutorials and to learn lots about OpenGL, check out the Nehe website at 
-&lt;a href=http://nege.gamedev.net target=_blank&gt;http://nehe.gamedev.net&lt;/a&gt;.
+For more information on these tutorials and to learn lots about OpenGL, check out the NeHe website at 
+&lt;a href=http://nehe.gamedev.net target=_blank&gt;http://nehe.gamedev.net&lt;/a&gt;.
+
+You can also get the community based NeHe tutorial ports from &lt;a href=http://www.blitzmax.com/Community/posts.php?topic=41689 target=_blank&gt;http://www.blitzmax.com/Community/posts.php?topic=41689&lt;/a&gt;.
 
 &lt;/div&gt;
 &lt;br&gt;
@@ -272,13 +278,13 @@
 
 &lt;div id=streams&gt;
 
-&lt;h1&gt;Writing custom stream handlers&lt;/h1&gt;
+&lt;h1&gt;Writing custom stream handlers (advanced)&lt;/h1&gt;
 
 BlitzMax's OO design allows you to add your own kinds of streams to the system.&lt;br&gt;
 &lt;br&gt;
 In this tutorial we will concentrate on creating a custom stream that simply converts any text written to or read from the stream to uppercase. Not very useful, but a good starting point for your own experiments!&lt;br&gt;
 &lt;br&gt;
-The source code for this tutorial can be found &lt;a href=upperstream.bmx&gt;here&lt;/a&gt;.&lt;br&gt;
+The source code for this tutorial is here: &lt;a href=../upperstream.bmx&gt;upperstream.bmx&lt;/a&gt;.&lt;br&gt;
 &lt;br&gt;
 To create a custom stream, you will need to create a new user type that extends the TStream type. Your type will also need to implement at least the following methods:
 &lt;pre class=code&gt;
@@ -286,46 +292,45 @@
 	Method Eof()
 		'code to return end-of-file status here...
 	End Method
-
+&amp;nbsp;
 	Method Pos()
 		'code to return current stream position here...
 	End Method
-
+&amp;nbsp;
 	Method Size()
 		'code to return size of stream here...
 	End Method
-
+&amp;nbsp;
 	Method Seek( pos )
 		'code to seek to a position in a stream here...
 	End Method
-
+&amp;nbsp;
 	Method Flush()
 		'code to flush stream output here...
 	End Method
-
+&amp;nbsp;
 	Method Close()
 		'code to close stream here...
 	End Method
-
+&amp;nbsp;
 	Method Read( buf:Byte Ptr,count )
 		'code to read from stream here...
 	End Method
-
+&amp;nbsp;
 	Method Write( buf:Byte Ptr,count )
 		'code to write to a stream here...
 	End Method
-End Type
-&lt;/pre&gt;
+End Type&lt;/pre&gt;
 Whew, that's a fair bit of work! Fortunately, BlitzMax can simplify things a bit for us in this case.&lt;br&gt;
 &lt;br&gt;
-Many types of stream really just modify the behaviour of an existing stream. For example, the BlitzMax &lt;a href=../../mod/brl.mod/endianstream.mod/doc/commands.html&gt;endian stream&lt;/a&gt; works by modifying the behaviour of an existing stream - in a sense, it 'wraps' an existing stream. Our goal of creating an 'uppercase' stream also applies here.&lt;br&gt;
+Many types of stream really just modify the behaviour of an existing stream. For example, the BlitzMax &lt;a href="../../Modules/Streams/Endian streams/index.html"&gt;endian stream&lt;/a&gt; works by modifying the behaviour of an existing stream - in a sense, it 'wraps' an existing stream. Our goal of creating an 'uppercase' stream also applies here.&lt;br&gt;
 &lt;br&gt;
 BlitzMax provides the TStreamWrapper type for exactly this situtation. TStreamWrapper extends TStream, but also maintains an internal 'underlying' stream. Whenever you call a method of TStreamWrapper, it will simply 'forward' the method call to the underlying stream.&lt;br&gt;
 &lt;br&gt;
 This is ideal for situations where you only want to modify the behaviour of a few of the stream methods. In our case, we want to modify the Read and Write methods to convert text to uppercase - and here's how it's done:
 &lt;pre class=code&gt;
 Type TUpperStream Extends TStreamWrapper
-
+&amp;nbsp;
 	Method Read( buf:Byte Ptr,count )
 		'Read data from the underlying stream
 		count=Super.Read( buf,count )
@@ -338,7 +343,7 @@
 		'Done!
 		Return count
 	End Method
-
+&amp;nbsp;
 	Method Write( buf:Byte Ptr,count )
 		'Copy the data to a new buffer, converting to uppercase as we go
 		Local tmp:Byte[count]
@@ -352,71 +357,67 @@
 		'Write the data to the underlying stream
 		Return Super.Write( tmp,count )
 	End Method
-
+&amp;nbsp;
 	Function Create:TUpperStream( stream:TStream )
 		Local t:TUpperStream=New TUpperStream
-		'SetStream is a TStreamWrapper method that sets the underlying stream.
+		'SetStream is a TStreamWrapper method that sets the underlying stream
 		t.SetStream stream
 		Return t
 	End Function
-
-End Type
-&lt;/pre&gt;
-One important note: The Read method modifies the data 'in place'. However, the Write method makes a copy of the data. This is because, although we know it's safe to modify the read buffer - in fact, it will already be modified by the time we get to it - we can't be sure it's safe to modify the write buffer. The caller of 'Write' may well be expecting the contents of the buffer to remain unchanged.&lt;br&gt;
+&amp;nbsp;
+End Type&lt;/pre&gt;
+One important note: the Read method modifies the data 'in place'. However, the Write method makes a copy of the data. This is because, although we know it's safe to modify the read buffer - in fact, it will already be modified by the time we get to it - we can't be sure it's safe to modify the write buffer. The caller of 'Write' may well be expecting the contents of the buffer to remain unchanged.&lt;br&gt;
 &lt;br&gt;
 Now let's see it in action:
-&lt;pre&gt;
-'Create a tmp file and write some text to it.
+&lt;pre class=code&gt;
+'Create a tmp file and write some text to it
 Local tmp:TStream=WriteStream( "tmp" )
 tmp.WriteLine "A little example..."
 tmp.WriteLine "of our cool TUpperStream!"
 tmp.Close
-
+&amp;nbsp;
 'Open tmp file again, and wrap it with a TUpperStream
 tmp:TStream=ReadStream( "tmp" ) 
 Local upperizer:TUpperStream=TUpperStream.Create( tmp )
-
+&amp;nbsp;
 'Dump file contents
 While Not upperizer.Eof()
 	Print upperizer.ReadLine()
 Wend
-
+&amp;nbsp;
 'Close files
 upperizer.Close
-tmp.Close
-&lt;/pre&gt;
+tmp.Close&lt;/pre&gt;
 This demo creates a text file and reads it back through a TUpperStream, which converts the file contents to uppercase while it's being read. If you inspect the tmp file, it's still actually in mixed case - but it's just as easy to write through the TUpperCase stream and end up with an uppercase file.&lt;br&gt;
 &lt;br&gt;
 Finally, the icing on the cake: adding our TUpperStream to the system so that it can be used transparently:
 &lt;pre class=code&gt;
 Type TUpperStreamFactory Extends TStreamFactory
-
+&amp;nbsp;
 	Method CreateStream:TUpperStream( url:Object,proto$,path$,readable,writeable )
 		If proto$&lt;&gt;"uppercase" Return
 		Local stream:TStream=OpenStream( path,readable,writeable )
 		If stream Return TUpperStream.Create( stream )
 	End Method
-	
+&amp;nbsp;
 End Type
-
-New TUpperStreamFactory
-&lt;/pre&gt;
+&amp;nbsp;
+New TUpperStreamFactory&lt;/pre&gt;
 And a demo...
-&lt;pre&gt;
+&lt;pre class=code&gt;
 'Open a TUpperStream tmp file using WriteStream
 Local tmp2:TStream=WriteStream( "uppercase::tmp" )
 tmp2.WriteLine "Another little example..."
 tmp2.WriteLine "of our even cooler TUpperStream!"
 tmp2.Close
-
+&amp;nbsp;
 'Read back and dump tmp file
 tmp2:TStream=ReadStream( "tmp" )
 While Not tmp2.Eof()
 	Print tmp2.ReadLine()
 Wend
-tmp2.Close
-&lt;/pre&gt;
+tmp2.Close&lt;/pre&gt;
 &lt;/div&gt;
 
 &lt;/body&gt;
-&lt;/html&gt;
\ No newline at end of file
+&lt;/html&gt;
</textarea><br><br>BlitzMax overview.bbdoc<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;link rel="styleSheet" href="style.css" type="text/css"&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;BlitzMax overview&lt;/h1&gt;
A collection of tutorials and articles from intermediate to advanced.
&lt;ul&gt;
&lt;li&gt;&lt;a href=#memory&gt;BlitzMax memory management&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;li&gt;&lt;a href=#oointro&gt;Introduction to OO programming&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;li&gt;&lt;a href=#nehetuts&gt;The NeHe OpenGL tutorials&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
&lt;li&gt;&lt;a href=#streams&gt;Writing custom stream handlers (advanced)&lt;/a&gt;&lt;br&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;div id=memory&gt;
&lt;h1&gt;BlitzMax memory management - or, "where did Delete go?!?"&lt;/h1&gt;

As many users from a Blitz3D or BlitzPlus background have noticed, BlitzMax does not include a 'Delete' command.&lt;br&gt;
&lt;br&gt;
This appears to have caused a great deal of bemusement and head scratching in the Blitz community, which this tutorial will attempt to clear up.&lt;br&gt;
&lt;br&gt;
Note that any references to Blitz3D in the rest of this document also apply to BlitzPlus.&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;The BASICs&lt;/h2&gt;

First up, let's have a look at what Blitz3D's Delete command actually does. It really serves 2 purposes:
&lt;ol&gt;
&lt;li&gt;The object is removed from its 'type list'.
&lt;li&gt;The memory used by the object is returned to the system - this is called 'deallocating' the object.
&lt;/ol&gt;
Step 1 is necessary due to Blitz3D's type list system, which automatically adds all New-ed objects to an internal global type list.&lt;br&gt;
&lt;br&gt;
Step 2 is necessary to prevent memory leaks. A memory leak is when your program has allocated a chunk of memory, used it for something, and then forgotten to deallocate it when it is no longer useful. Since computers have a finite amount of memory, this will eventually cause problems if it happens often enough!&lt;br&gt;
&lt;br&gt;
The first thing about these 2 steps to note is that the global type list system is no longer present in BlitzMax, so step 1 is now completely up to the user - if you have added an object to a linked list (or lists), it is up to you to remove it.&lt;br&gt;
&lt;br&gt;
If all you are wanting to achieve is a system similar to Blitz3D's type list system, then this is as simple as using ListAddLast immediately after you have created an object using New, and using ListRemove immediately before deleting it using Delete - oops, there is no Delete! Ok, using ListRemove *instead* of Delete!&lt;br&gt;
&lt;br&gt;
This still leaves the question of deallocating the object's memory, and this is done in BlitzMax using a 'garbage collector'. A garbage collector
automatically scans for 'dead objects' every now and then and releases the memory they occupied.&lt;br&gt;
&lt;br&gt;
Note that the issue of deallocating objects is completely separate from the issue of type lists. Yes, if you forget to remove an object from a list it will remain 'live', but this is the same as forgetting to delete an object in Blitz3D!&lt;br&gt;
&lt;br&gt;
One final complicating issue: BlitzMax includes a feature that allows you to assign objects to integers. This feature exists mainly to simplify things for beginners so, instead of...
&lt;pre class=code&gt;
Local image:TImage=LoadImage( "somepic.png" ) 'normal object to object assignment...&lt;/pre&gt;
...you can just go...
&lt;pre class=code&gt;
Local image=LoadImage( "somepic.png" ) 'assigning an object to an int! What gives?&lt;/pre&gt;
However, if you are using this feature in your programs, you *must* later 'free' the object yourself using Release...
&lt;pre class=code&gt;
Release image&lt;/pre&gt;
You can therefore think of Release as being similar to Blitz3D's FreeImage (or FreeSound, FreeThis, FreeThat etc).&lt;br&gt;
&lt;br&gt;
All-in-all, it's probably best to avoid object-to-int assignments altogther if you are concerned about memory leaks.&lt;br&gt;
&lt;br&gt;
And that's it! Well, not quite, but the above should be enough information for you to be able to write leak-free programs with. I'll go into some of the nitty gritty details below...&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;The nitty gritty part : dead objects&lt;/h2&gt;

Ok, lets have a look at the question of 'what exactly is a dead object'? Well, a dead object is an object that is no longer referred to by any live objects. In other words, dead objects are objects your program can no longer 'see' - they are therefore completely useless to your program and can be safely deallocated.&lt;br&gt;
&lt;br&gt;
Here are a few examples of when objects become 'dead':&lt;br&gt;
&lt;pre class=code&gt;
'example 1
Local p:MyType=New MyType 'allocate object 1
p=Null 'object 1 is now dead
&amp;nbsp;
'example 2
Local p:MyType=New MyType 'allocate object 1
Local q:MyType=New MyType 'allocate object 2
p=q 'object 1 is now dead, object 2 is still alive
&amp;nbsp;
'example 3
Local p:MyType[1] 'allocate object 1 (an array object)
p[0]=New MyType   'allocate object 2
p=Null 'object 1 and object 2 both now dead
&amp;nbsp;
'example 4
Local p:MyType=New MyType 'allocate object 1
p.my_type=New MyType      'allocate object 2
p.my_type=New MyType      'allocate object 3 - object 2 now dead
Local q:MyType=p.my_type
p=Null 'object 1 and object 2 dead, object 3 still alive thanks to the q assignment above&lt;/pre&gt;
After seeing this sort of thing, there is a tendancy for people to stick '=Null' code all over the place in an attempt to 'force' objects to become dead - but this is generally not necessary.&lt;br&gt;
&lt;br&gt;
Sooner or later, all variables will either be overwritten by new values, or (in the case of Locals and Fields) simply go out of scope. Both of these actions are enough to ensure that dead objects will be correctly detected and deallocated.&lt;br&gt;
&lt;br&gt;
Probably the only good reason to use '=Null' is in the case of global variables, when you know that a global variable will not be modified for a long time, but it also happens to be keeping a large chunk of memory alive that is no longer useful to your program. In this case, an '=Null' is probably the right choice.&lt;br&gt;
&lt;br&gt;
BlitzMax also provides the GCMemAlloced() function to determine the amount of memory currently used by your program.&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr&gt;

&lt;div id=oointro&gt;
&lt;h1&gt;Introduction to OO programming&lt;/h1&gt;

Welcome to a crash course in OO programming for Blitz coders!&lt;br&gt;
&lt;br&gt;
OO stands for 'Object Oriented'. OO is a programming paradigm or 'way of thinking' that has taken on almost mythical proportions over the years yet, somewhat unusually for the world of computing, is actually quite useful!&lt;br&gt;
&lt;br&gt;
*Disclaimer* - OO coding means different things to different people. This article is strongly swayed by my own experience with OO coding and what I like and find useful about it. The actual 'meaning' of OO is almost as fun to argue about as whether the universe is infinite or not.&lt;br&gt;
&lt;br&gt;
First up, OO coding has spawned a bunch of initially confusing but actually quite sensible buzzwords, including such gems as:&lt;br&gt;
&lt;ul&gt;
&lt;li&gt;Inheritance&lt;br&gt;
&lt;li&gt;Polymorphism&lt;br&gt;
&lt;li&gt;Virtual&lt;br&gt;
&lt;li&gt;Abstract&lt;br&gt;
&lt;li&gt;Concrete&lt;br&gt;
&lt;li&gt;Type&lt;br&gt;
&lt;li&gt;Class&lt;br&gt;
&lt;li&gt;Object&lt;br&gt;
&lt;li&gt;Instance&lt;br&gt;
&lt;li&gt;Base Class&lt;br&gt;
&lt;li&gt;Derived Class&lt;br&gt;
&lt;li&gt;Super Class&lt;br&gt;
&lt;li&gt;Sub Class&lt;br&gt;
&lt;/ul&gt;
Scary stuff! Well, not really. Never forget that behind the scenes it's all just a bunch of bits and bytes and Ifs and Adds and Gotos.&lt;br&gt;
&lt;br&gt;
As always, it's easier than the guys who get paid megabucks to do it would have us think.&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;Inheritance&lt;/h2&gt;

Inheritance is a way of 'composing' objects from other objects.&lt;br&gt;
&lt;br&gt;
This is already possible in procedural Blitz. Consider the following code...
&lt;pre class=code&gt;
Type Part1
	Field x,y,z
End Type
&amp;nbsp;
Type Part2
	Field p1.Part1
	Field p,q,r
End Type
&amp;nbsp;
Function UpdatePart1( t:Part1 )
	'Do something clever with a Part1.
End Function&lt;/pre&gt;
This is one way of composing objects. Part2 'contains' a Part1, via the p1 field.&lt;br&gt;
&lt;br&gt;
If you've got a Part2 object and want to call UpdatePart1(), you can grab the p1 field and use it in the function call, for example:
&lt;pre class=code&gt;
Local t:Part2=New Part2
t.p1=New Part1 'need to create it!
UpdatePart1 t.p1&lt;/pre&gt;
OO inheritance provides a different (not always better!) way to do this:
&lt;pre class=code&gt;
Type Base
	Field x,y,z
End Type
&amp;nbsp;
Type Derived Extends Base
	Field p,q,r
End Type
&amp;nbsp;
Function UpdateBase( t:Base )
	'Do something clever with a Base object.
End Function&lt;/pre&gt;
Ok, we've already hit our first OO buzzwords - Base and Derived. These are not special keywords, they are just names I chose for these types. Bear with me and hopefully you'll get some idea of why I chose them.&lt;br&gt;
&lt;br&gt;
First up, The Base type is just the same as the procedural Part1 type - no problem there.&lt;br&gt;
&lt;br&gt;
The Derived type, however, introduces us to the Extends keyword, which is used to indicate inheritance.&lt;br&gt;
&lt;br&gt;
Extends always appears after 'Type whatever', and means that the type you are describing extends a different, existing type. So the type you are describing is composed not only of the fields and stuff you declare, but also the fields and stuff of the type you are extending!&lt;br&gt;
&lt;br&gt;
This means that the Derived type above actually has the additional fields x,y,z - these have been 'inherited' from the Base type. It is then perfectly legal for you to code up something like:
&lt;pre class=code&gt;
Local t:Derived=New Derived
&amp;nbsp;
t.x=100 'x inherited from Base - thanks Base, you rock!&lt;/pre&gt;
Another way to think of it is the Derived type 'is a' Base type, but with some extra stuff. In fact, in OO terminology 'IsA' is often used to indicate inheritance or inheritance-like properties.&lt;br&gt;
&lt;br&gt;
Now it gets a bit interesting. Since our Derived type 'is a' Base type, it's perfectly legal to use it where ever a Base type is expected - for example, the UpdateBase() function:
&lt;pre class=code&gt;
Local MyDerived:Derived=New Derived 'fine...
UpdateBase MyDerived 'What?!?&lt;/pre&gt;
Initially, this looks *wrong* - 'Type mismatch error' looms! But in OO code it's fine. Since Derived extends Base, it's OK to use a Derived where ever a Base is expected - even in assignments:
&lt;pre class=code&gt;
Local MyBase:Base=New Derived 'Okay, because Derived extends (or 'Is a') Base.&lt;/pre&gt;
In addition, there could be many types extending Base, and each of these could be used interchangeably with Base.&lt;br&gt;
&lt;br&gt;
Hopefully the terms 'Base' and 'Derived' now mean something. The Derived type is derived from, or 'comes from', the Base type.&lt;br&gt;
&lt;br&gt;
Remember that Base and Derived are just names I chose for this example. In real world coding, you'd use useful names, for example:
&lt;pre class=code&gt;
Type Actor
	Field x,y,z
End Type
&amp;nbsp;
Type Player Extends Actor
	Field lives,score
End Type&lt;/pre&gt;
But still, you can think of Actor as the base type, and Player as the derived type - a Player is derived from an Actor.&lt;br&gt;
&lt;br&gt;
It's also perfectly legal (and very useful!) to extend extended types, for example:
&lt;pre class=code&gt;
Type Actor
	Field x,y,z
End Type
&amp;nbsp;
Type Player Extends Actor
	Field lives,score
End Type
&amp;nbsp;
Type Enemy Extends Actor
	Field mood
End Type
&amp;nbsp;
Type Troll Extends Enemy
	Field grudge_quotient
End Type
&amp;nbsp;
Type Ghoul Extends Enemy
	Field lust_for_life
End Type&lt;/pre&gt;
So, if you've got a function like UpdateActor( t:Actor ), you can pass it any of the above types as they are all ultimately derived from Actor.&lt;br&gt;
&lt;br&gt;
Similarly, a RethinkMood( t:Enemy ) function could be used with any of the bad guys (Enemy, Troll or Ghoul) - but not with players, as Player is not derived from Enemy.&lt;br&gt;
&lt;br&gt;
This is what is known as a 'class hierarchy' - a 'tree' of types.&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;Summary&lt;/h2&gt;

To finish off, here's a summary of some more OO buzzwords.&lt;br&gt;
&lt;br&gt;
A %class is the same thing as a type i.e. a template that is used to create %objects, also known as %instances.&lt;br&gt;
&lt;br&gt;
A derived class is also known as a child class or %sub class, since they occur below another class in the hierarchy.&lt;br&gt;
&lt;br&gt;
A base class is also known as a parent class or %super class, since they are above all other classes in the hierarchy.&lt;br&gt;
&lt;br&gt;
If a class is declared as %abstract then it cannot be instantiated, it must first be extended in a derived class. Only the base class should be abstracted.&lt;br&gt;
&lt;br&gt;
If a method in a base class is declared as abstract, then before a derived class can become %concrete i.e. can be instantiated, it must implement the abstract method.&lt;br&gt;
&lt;br&gt;
Abstract and %virtual methods are similar in that both can be overridden by a derived method of the same name, they differ in that abstract methods are not implemented in the base class.&lt;br&gt;
&lt;br&gt;
In BlitzMax, methods (and functions) are virtual by default, so to create a %non-virtual method i.e. one that cannot be overridden, we can declare it as %final.&lt;br&gt;
&lt;br&gt;
For more on OO techniques, see the &lt;a href="../../Language/User defined types/index.html"&gt;User defined types&lt;/a&gt; section.&lt;br&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;hr&gt;

&lt;div id=nehetuts&gt;

&lt;h1&gt;The NeHe OpenGL tutorials&lt;/h1&gt;
The NeHe tutorials are a popular collection of OpenGL programming tutorials.&lt;br&gt;
&lt;br&gt;
Here are the first 5 NeHe tutorials converted to BlitzMax:
&lt;ul&gt;
&lt;li&gt;&lt;a href="../nehe_01.bmx"&gt;nehe_01.bmx&lt;/a&gt;
&lt;li&gt;&lt;a href="../nehe_02.bmx"&gt;nehe_02.bmx&lt;/a&gt;
&lt;li&gt;&lt;a href="../nehe_03.bmx"&gt;nehe_03.bmx&lt;/a&gt;
&lt;li&gt;&lt;a href="../nehe_04.bmx"&gt;nehe_04.bmx&lt;/a&gt;
&lt;li&gt;&lt;a href="../nehe_05.bmx"&gt;nehe_05.bmx&lt;/a&gt;
&lt;/ul&gt;
For more information on these tutorials and to learn lots about OpenGL, check out the NeHe website at 
&lt;a href=http://nehe.gamedev.net target=_blank&gt;http://nehe.gamedev.net&lt;/a&gt;.

You can also get the community based NeHe tutorial ports from &lt;a href=http://www.blitzmax.com/Community/posts.php?topic=41689 target=_blank&gt;http://www.blitzmax.com/Community/posts.php?topic=41689&lt;/a&gt;.

&lt;/div&gt;
&lt;br&gt;
&lt;hr&gt;

&lt;div id=streams&gt;

&lt;h1&gt;Writing custom stream handlers (advanced)&lt;/h1&gt;

BlitzMax's OO design allows you to add your own kinds of streams to the system.&lt;br&gt;
&lt;br&gt;
In this tutorial we will concentrate on creating a custom stream that simply converts any text written to or read from the stream to uppercase. Not very useful, but a good starting point for your own experiments!&lt;br&gt;
&lt;br&gt;
The source code for this tutorial is here: &lt;a href=../upperstream.bmx&gt;upperstream.bmx&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;
To create a custom stream, you will need to create a new user type that extends the TStream type. Your type will also need to implement at least the following methods:
&lt;pre class=code&gt;
Type TMyStream extends TStream
	Method Eof()
		'code to return end-of-file status here...
	End Method
&amp;nbsp;
	Method Pos()
		'code to return current stream position here...
	End Method
&amp;nbsp;
	Method Size()
		'code to return size of stream here...
	End Method
&amp;nbsp;
	Method Seek( pos )
		'code to seek to a position in a stream here...
	End Method
&amp;nbsp;
	Method Flush()
		'code to flush stream output here...
	End Method
&amp;nbsp;
	Method Close()
		'code to close stream here...
	End Method
&amp;nbsp;
	Method Read( buf:Byte Ptr,count )
		'code to read from stream here...
	End Method
&amp;nbsp;
	Method Write( buf:Byte Ptr,count )
		'code to write to a stream here...
	End Method
End Type&lt;/pre&gt;
Whew, that's a fair bit of work! Fortunately, BlitzMax can simplify things a bit for us in this case.&lt;br&gt;
&lt;br&gt;
Many types of stream really just modify the behaviour of an existing stream. For example, the BlitzMax &lt;a href="../../Modules/Streams/Endian streams/index.html"&gt;endian stream&lt;/a&gt; works by modifying the behaviour of an existing stream - in a sense, it 'wraps' an existing stream. Our goal of creating an 'uppercase' stream also applies here.&lt;br&gt;
&lt;br&gt;
BlitzMax provides the TStreamWrapper type for exactly this situtation. TStreamWrapper extends TStream, but also maintains an internal 'underlying' stream. Whenever you call a method of TStreamWrapper, it will simply 'forward' the method call to the underlying stream.&lt;br&gt;
&lt;br&gt;
This is ideal for situations where you only want to modify the behaviour of a few of the stream methods. In our case, we want to modify the Read and Write methods to convert text to uppercase - and here's how it's done:
&lt;pre class=code&gt;
Type TUpperStream Extends TStreamWrapper
&amp;nbsp;
	Method Read( buf:Byte Ptr,count )
		'Read data from the underlying stream
		count=Super.Read( buf,count )
		'Convert the data to uppercase
		For Local i=0 Until count
			If buf[i]&gt;=Asc("a") And Buf[i]&lt;=Asc("z")
				buf[i]=buf[i]-Asc("a")+Asc("A")
			EndIf
		Next
		'Done!
		Return count
	End Method
&amp;nbsp;
	Method Write( buf:Byte Ptr,count )
		'Copy the data to a new buffer, converting to uppercase as we go
		Local tmp:Byte[count]
		For Local i=0 Until count
			If buf[i]&gt;=Asc("a") And buf[i]&lt;=Asc("z")
				tmp[i]=buf[i]-Asc("a")+Asc("A")
			Else
				tmp[i]=buf[i]
			EndIf
		Next
		'Write the data to the underlying stream
		Return Super.Write( tmp,count )
	End Method
&amp;nbsp;
	Function Create:TUpperStream( stream:TStream )
		Local t:TUpperStream=New TUpperStream
		'SetStream is a TStreamWrapper method that sets the underlying stream
		t.SetStream stream
		Return t
	End Function
&amp;nbsp;
End Type&lt;/pre&gt;
One important note: the Read method modifies the data 'in place'. However, the Write method makes a copy of the data. This is because, although we know it's safe to modify the read buffer - in fact, it will already be modified by the time we get to it - we can't be sure it's safe to modify the write buffer. The caller of 'Write' may well be expecting the contents of the buffer to remain unchanged.&lt;br&gt;
&lt;br&gt;
Now let's see it in action:
&lt;pre class=code&gt;
'Create a tmp file and write some text to it
Local tmp:TStream=WriteStream( "tmp" )
tmp.WriteLine "A little example..."
tmp.WriteLine "of our cool TUpperStream!"
tmp.Close
&amp;nbsp;
'Open tmp file again, and wrap it with a TUpperStream
tmp:TStream=ReadStream( "tmp" ) 
Local upperizer:TUpperStream=TUpperStream.Create( tmp )
&amp;nbsp;
'Dump file contents
While Not upperizer.Eof()
	Print upperizer.ReadLine()
Wend
&amp;nbsp;
'Close files
upperizer.Close
tmp.Close&lt;/pre&gt;
This demo creates a text file and reads it back through a TUpperStream, which converts the file contents to uppercase while it's being read. If you inspect the tmp file, it's still actually in mixed case - but it's just as easy to write through the TUpperCase stream and end up with an uppercase file.&lt;br&gt;
&lt;br&gt;
Finally, the icing on the cake: adding our TUpperStream to the system so that it can be used transparently:
&lt;pre class=code&gt;
Type TUpperStreamFactory Extends TStreamFactory
&amp;nbsp;
	Method CreateStream:TUpperStream( url:Object,proto$,path$,readable,writeable )
		If proto$&lt;&gt;"uppercase" Return
		Local stream:TStream=OpenStream( path,readable,writeable )
		If stream Return TUpperStream.Create( stream )
	End Method
&amp;nbsp;
End Type
&amp;nbsp;
New TUpperStreamFactory&lt;/pre&gt;
And a demo...
&lt;pre class=code&gt;
'Open a TUpperStream tmp file using WriteStream
Local tmp2:TStream=WriteStream( "uppercase::tmp" )
tmp2.WriteLine "Another little example..."
tmp2.WriteLine "of our even cooler TUpperStream!"
tmp2.Close
&amp;nbsp;
'Read back and dump tmp file
tmp2:TStream=ReadStream( "tmp" )
While Not tmp2.Eof()
	Print tmp2.ReadLine()
Wend
tmp2.Close&lt;/pre&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</textarea><br><br>upperstream.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Type TUpperStream Extends TStreamWrapper

	Method Read( buf:Byte Ptr,count )
		'Read data from the underlying stream
		count=Super.Read( buf,count )
		'Convert the data to uppercase
		For Local i=0 Until count
			If buf[i]&gt;=Asc("a") And Buf[i]&lt;=Asc("z")
				buf[i]=buf[i]-Asc("a")+Asc("A")
			EndIf
		Next
		'Done!
		Return count
	End Method

	Method Write( buf:Byte Ptr,count )
		'Copy the data to a new buffer, converting to uppercase as we go
		Local tmp:Byte[count]
		For Local i=0 Until count
			If buf[i]&gt;=Asc("a") And buf[i]&lt;=Asc("z")
				tmp[i]=buf[i]-Asc("a")+Asc("A")
			Else
				tmp[i]=buf[i]
			EndIf
		Next
		'Write the data to the underlying stream
		Return Super.Write( tmp,count )
	End Method

	Function Create:TUpperStream( stream:TStream )
		Local t:TUpperStream=New TUpperStream
		'SetStream is a TStreamWrapper method that sets the underlying stream
		t.SetStream stream
		Return t
	End Function

End Type

Type TUpperStreamFactory Extends TStreamFactory

	Method CreateStream:TUpperStream( url:Object,proto$,path$,readable,writeable )
		If proto$&lt;&gt;"uppercase" Return
		Local stream:TStream=OpenStream( path,readable,writeable )
		If stream Return TUpperStream.Create( stream )
	End Method
	
End Type

New TUpperStreamFactory

'Example of manually creating a TUpperStream:

'Create a tmp file and write some text to it
Local tmp:TStream=WriteStream( "tmp" )
tmp.WriteLine "A little example..."
tmp.WriteLine "of our cool TUpperStream!"
tmp.Close

'Open tmp file again, and wrap it with a TUpperStream
tmp:TStream=ReadStream( "tmp" ) 
Local upperizer:TUpperStream=TUpperStream.Create( tmp )

'Dump file contents
While Not upperizer.Eof()
	Print upperizer.ReadLine()
Wend

'Close files
upperizer.Close
tmp.Close

'Example of automatically creating a TUpperStream:

'Open a TUpperStream tmp file using WriteStream
Local tmp2:TStream=WriteStream( "uppercase::tmp" )
tmp2.WriteLine "Another little example..."
tmp2.WriteLine "of our even cooler TUpperStream!"
tmp2.Close

'Read back and dump tmp file
tmp2:TStream=ReadStream( "tmp" )
While Not tmp2.Eof()
	Print tmp2.ReadLine()
Wend
tmp2.Close
</textarea> <br><br></td></tr></table><br>
<a name="1037569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> It would be great to add new sections to the OO tut for Abstract classes and Polymorphism... I would do it but I don't really know enough about these topics so I'd just be blindly copying stuff from other sites. <br><br>Anyone want to write a tut for even one of these topics?! We lesser folks could really use a good Bmx explanation.<br><br>Edit: might as well post some links.<br><a href="http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming" target="_blank">http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming</a><br><a href="http://en.wikipedia.org/wiki/Virtual_class" target="_blank">http://en.wikipedia.org/wiki/Virtual_class</a><br><a href="http://en.wikipedia.org/wiki/Virtual_function" target="_blank">http://en.wikipedia.org/wiki/Virtual_function</a><br><a href="http://en.wikipedia.org/wiki/Class_(computer_science)#Categories_of_classes" target="_blank">http://en.wikipedia.org/wiki/Class_(computer_science)#Categories_of_classes</a><br><a href="http://en.wikipedia.org/wiki/Abstract_type" target="_blank">http://en.wikipedia.org/wiki/Abstract_type</a> <br><br></td></tr></table><br>
<a name="1037599"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> there are two in the tutorial section on polymorphism:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=78860" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=78860</a><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=59233" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=59233</a> <br><br></td></tr></table><br>
<a name="1037604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Jesse. I've seen the first one and it's a mess but yeah, John J's tut covers Polymorphism nicely so I'll use that but he doesn't go into using Abstract properly. <br><br>Any links for that? ;) <br><br></td></tr></table><br>
<a name="1037611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know any links for it. I'll try to explain it:<br>abstract serves two purpose, one is to prevents a type from being used with out the extended type, weather "Abstract" is used in the declaration of a Function, Method or a type. For example you can declare a type as abstract like this:<br><pre class=code>
Type base Abstract
  field x:float

  Function Foo()
  .
  .
  End Function
  
  Method mymethod()
     x = 3
  End Method
end type
</pre>this will prevent an instance of base type to be created.<br>But, it can be create like this:<br><pre class=code>
'                  note there is no Function or Method declared in this type.
Type childtype Extends base 
End Type

local mytype:childType = new childtype
</pre><br>and is perfectly valid.<br><br>The other purpose is when "abstract is used on a Function and/or Method. If a type has a function or a method that contain abstract, the type signals the compiler that the extended type "must" have the definition of the function or the method and must have the same parameters and that the base type can never be instantiated by itself. If there is no definition of the abstract function or method in the extended type, the compiler will produce an error.<br><pre class=code>

Type base
   Field x:int

   Method Update(x:int) abstract ' template for extended types
End Type

Type mytype Extends base
    Method Update(x:int) ' required because the base has a method of same name as abstract.
      self.x = x
    End Method
End Type
</pre><br><br>there can not be an abstract method or function in the extended type. <br><br>I hope this is clear as I don't write good tutorials. I wrote this in hope you can understand it and write your own version of it. <br><br></td></tr></table><br>
<a name="1037614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's pretty good. Thanks very much. I should be able to cobble something decent together now. <br><br></td></tr></table><br>
<a name="1037914"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I forgot the "User defined types" section covers these topics already so I've just added a link to it at the end of "Intro to OOP" instead of adding new parts myself. <br><br></td></tr></table><br>
<a name="1038330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just changed my mind again and added a 'proper' ending to "Intro to OOP" as even along with "User defined types" there are still things missing. <br><br>Hopefully I haven't made a mistake.<br><br>Edit: ok, I fixed a mistake on the last line. I didn't know about final. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
