<!DOCTYPE html><html lang="en" ><head ><title >MaxGUI overview docs</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >MaxGUI overview docs</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >MaxGUI overview docs</a><br><br>
<a name="1037612"></a>

<a name="1221943"></a>

<a name="1222182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is an update to MaxGUI overview.bbdoc (from v 1.41). <br><br>I basically just added links, reformatted the code a little and created and linked to the example files. Also, as with <a href="/posts.php?topic=91160" target="_blank">BlitzMax overview docs</a> I added &amp;nbsp; to empty lines in &lt;pre&gt; tags.<br><br>The files are zipped here and posted below along with the patch.<br>maxgui-overview-doc.zip (expired)<br><br>Last edit: 18 Aug 2010<br><br>MaxGUI overview.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- MaxGUI overview-old.bbdoc	2010-07-13 03:54:58.000000000 +0100
+++ MaxGUI overview.bbdoc	2010-08-18 02:59:38.537322019 +0100
@@ -4,56 +4,50 @@
 &lt;link rel="styleSheet" href="../bmxstyle.css" type="text/css"&gt;
 &lt;/head&gt;
 &lt;body&gt;
-&lt;h1&gt;MaxGUI Overview&lt;/h1&gt;
-
-&lt;ul&gt;
-&lt;li&gt;Introduction
-&lt;li&gt;Getting Started
-&lt;li&gt;Gadget Layout
-&lt;li&gt;Crossplatform Issues
-&lt;li&gt;Using an EventHook
-&lt;li&gt;Using a Canvas
-&lt;li&gt;Event Hook based Rendering 
-&lt;li&gt;Porting from BlitzPlus
-&lt;li&gt;The New Modules
-&lt;li&gt;Under the Hood
-&lt;li&gt;Extending MaxGui
-&lt;/ul&gt;
-
-&lt;hr&gt;
-
-&lt;h3&gt;Introduction&lt;/h3&gt;
+&lt;h1&gt;MaxGUI overview&lt;/h1&gt;
 
 The MaxGui module provides commands to build user interfaces
 for applications programmed in BlitzMax.
 &lt;p&gt;
-The command set originates from the original BlitzPlus "Gadget"
+The command set originates from the original BlitzPlus 'Gadget'
 based names providing a healthy amount of backward
 compatability for users wishing to port code developed in 
 BlitzPlus.
 
-
-&lt;h3&gt;Getting Started&lt;/h3&gt;
+&lt;ul&gt;
+&lt;li&gt;&lt;a href=#started&gt;Getting Started&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#layout&gt;Gadget Layout&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#crossplatform&gt;Cross Platform Issues&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#hooks&gt;Using Event Hooks&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#canvas&gt;Using a Canvas&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#rendering&gt;Event Hook based Rendering&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#blitzplus&gt;Porting from BlitzPlus&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#modules&gt;The New Modules&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#hood&gt;Under the Hood&lt;/a&gt;&lt;br&gt;&lt;br&gt;
+&lt;li&gt;&lt;a href=#extending&gt;Extending MaxGui&lt;/a&gt;
+&lt;/ul&gt;
+&lt;hr&gt;
+&lt;div id=started&gt;
+&lt;h2&gt;Getting Started&lt;/h2&gt;
 
 
 The following program opens a small window on the desktop
 that ends when the window is closed.
+The source for this example is &lt;a href="../gettingstarted.bmx"&gt;here&lt;/a&gt;.
 &lt;p&gt;
 The code beginning at "While True" is the main event loop
-of the program, it repeats forever waiting for an Event
+of the program, it repeats forever waiting for an event
 to happen, printing the event's details to the output window
 and ending if the event has the ID of EVENT_WINDOWCLOSE.
 &lt;pre class=code&gt;
-' createwindow.bmx
-
-Strict 
-
+' gettingstarted.bmx
+&amp;nbsp;
+Strict
+&amp;nbsp;
 Import MaxGUI.Drivers
-
-Local window:TGadget
-
-window=CreateWindow("My Window",40,40,320,240)
-
+&amp;nbsp;
+Local window:TGadget=CreateWindow("My Window",40,40,320,240)
+&amp;nbsp;
 While True
 	WaitEvent 
 	Print CurrentEvent.ToString()
@@ -61,67 +55,80 @@
 		Case EVENT_WINDOWCLOSE
 			End
 	End Select
-Wend
-&lt;/pre&gt;
+Wend&lt;/pre&gt;
 Try moving and sizing the window while the program is running
 and you will see the details of the events that occur printed
 in the debug window of BlitzMax.
 &lt;p&gt;
 Try also modifying the "window=" line in the program with:
 &lt;pre class=code&gt;
-window=CreateWindow("My Window",40,40,320,240,Null,WINDOW_TITLEBAR)
-&lt;/pre&gt;
-which will create a Window with only a title bar and no status or
-menu bars. See the documentation for CreateWindow for more details
+Local window:TGadget=CreateWindow("My Window",40,40,320,240,Null,WINDOW_TITLEBAR)&lt;/pre&gt;
+This will create a window with only a title bar and no status or
+menu bars. See #CreateWindow for more details
 of the Window styles supported by MaxGui.
 &lt;p&gt;
 The MaxGui documentation contains working examples for each of 
-commands that create gadgets including CreateButton, CreateCanvas,
-CreateComboBox, CreateHTMLView, CreateLabel, CreateListBox,
-CreateMenu, CreatePanel, CreateProgBar, CreateSlider, CreateTabber,
-CreateTextField, CreateToolBar and CreateTreeView.
-&lt;p&gt;
-
-&lt;h3&gt;Gadget Layout&lt;/h3&gt;
-&lt;p&gt;
-A Gadget in MaxGui is given pixel coordinates when it is created
-that positions it in it's parent's client area. The client area of
-a Window gadget is inside the window's borders not including the
+the commands that create gadgets including:
+&lt;ul&gt;
+&lt;li&gt;#CreateButton
+&lt;li&gt;#CreateCanvas
+&lt;li&gt;#CreateComboBox
+&lt;li&gt;#CreateHTMLView
+&lt;li&gt;#CreateLabel
+&lt;li&gt;#CreateListBox
+&lt;li&gt;#CreateMenu
+&lt;li&gt;#CreatePanel
+&lt;li&gt;#CreateProgBar
+&lt;li&gt;#CreateSlider
+&lt;li&gt;#CreateTabber
+&lt;li&gt;#CreateTextField
+&lt;li&gt;#CreateToolBar
+&lt;li&gt;#CreateTreeView
+&lt;/ul&gt;
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=layout&gt;
+&lt;h2&gt;Gadget Layout&lt;/h2&gt;
+&lt;p&gt;
+A gadget in MaxGui is given pixel coordinates when it is created
+which positions it in its parent's client area. The client area of
+a window gadget is inside the window's borders, not including the
 space used by any Status or Menu bars.
 &lt;p&gt;
-If a Window is resized MaxGui uses any children's layout settings
-to reposition them within the new size of it's client area.
+If a window is resized MaxGui uses any children's layout settings
+to reposition them within the new size of its client area.
 &lt;p&gt;
-The SetGadgetLayout is used to control how the Gadget is repositioned
-when it's parent is resized.
+#SetGadgetLayout is used to control how the gadget is repositioned
+when its parent is resized.
 &lt;p&gt;
-By considering each edge of the Gadget independently, the MaxGui
+By considering each edge of the gadget independently, the MaxGui
 layout engine repositions each gadget according to each edge's
-rule where the rule is 
-&lt;p&gt;
-EDGE_CENTERED - The edge remains a fixed distance from the center of the parent&lt;br&gt;
-EDGE_ALIGNED - The edge is a locked distance away from it's parent's corresponding edge&lt;br&gt;
-EDGE_RELATIVE - The edge remains a proportional distance from the parent's 2 edges&lt;br&gt;
-&lt;p&gt;
+rule where the rules are: 
+&lt;ul&gt;
+&lt;li&gt;EDGE_CENTERED - The edge remains a fixed distance from the center of the parent&lt;br&gt;
+&lt;li&gt;EDGE_ALIGNED - The edge is a locked distance away from its parent's corresponding edge&lt;br&gt;
+&lt;li&gt;EDGE_RELATIVE - The edge remains a proportional distance from the parent's 2 edges&lt;br&gt;
+&lt;/ul&gt;
 The following code demonstrates a common case of creating a panel
 in a window the size of the window's client area and locking the
 distance of each edge to the correspong edge of the parent window
 (EDGE_ALIGNED rule). The result is that the panel is automatically sized by 
 MaxGui when the window is resized filling the entire client area.
+&lt;p&gt;
+The source for this example is &lt;a href="../gadgetlayout.bmx"&gt;here&lt;/a&gt;.
 &lt;pre class=code&gt;
+' gadgetlayout.bmx
+&amp;nbsp;
 Strict 
-
+&amp;nbsp;
 Import MaxGUI.Drivers
-
-Local window:TGadget
-Local panel:TGadget
-
-window=CreateWindow("My Window",40,40,320,240)
-
-panel=CreatePanel(0,0,ClientWidth(window),ClientHeight(window),window)
+&amp;nbsp;
+Local window:TGadget=CreateWindow("My Window",40,40,320,240)
+&amp;nbsp;
+Local panel:TGadget=CreatePanel(0,0,ClientWidth(window),ClientHeight(window),window)
 SetGadgetColor panel,200,100,100
 SetGadgetLayout panel,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED
-
+&amp;nbsp;
 While True
 	WaitEvent 
 	Print CurrentEvent.ToString()
@@ -129,32 +136,31 @@
 		Case EVENT_WINDOWCLOSE
 			End
 	End Select
-Wend
-&lt;/pre&gt;
-By removing the line of code with the SetGadetLayout command you can view the default 
-EDGE_CENTERED rule in effect on all edges with the panel retaining it's size 
-due to all it's edges being kept a fixed distance from the center 
+Wend&lt;/pre&gt;
+By removing the line of code with the "SetGadgetLayout" command you can view the default 
+EDGE_CENTERED rule in effect on all edges. This will make the panel retain its size 
+due to all its edges being kept a fixed distance from the center 
 of the window.
 &lt;p&gt;
-To view rule EDGE_RELATIVE in effect modify the SetGadgetLayout command to read
-"SetGadgetLayout panel,EDGE_RELATIVE,EDGE_RELATIVE,EDGE_RELATIVE,EDGE_RELATIVE".
-&lt;p&gt;
+To view rule EDGE_RELATIVE in effect modify the "SetGadgetLayout" command to read:
+&lt;pre class=code&gt;
+SetGadgetLayout panel,EDGE_RELATIVE,EDGE_RELATIVE,EDGE_RELATIVE,EDGE_RELATIVE&lt;/pre&gt;
 But wait, there is no discernable change in the resizing behavior between
 rule EDGE_ALIGNED and rule EDGE_RELATIVE???
 &lt;p&gt;
-Unless the panel is created inset from the window client such as 
+This will happen unless the panel is created inset from the window client such as 
 the result of the following modification:
 &lt;pre class=code&gt;
-panel=CreatePanel(10,10,ClientWidth(window)-20,ClientHeight(window)-20,window)
-&lt;/pre&gt;
-you will note the edges are infact being kept a proportional distance
+Local panel:TGadget=CreatePanel(10,10,ClientWidth(window)-20,ClientHeight(window)-20,window)&lt;/pre&gt;
+Now you will notice the edges are in fact being kept a proportional distance
 from the parent's 2 edges when the window is resized.
 &lt;p&gt;
-The fact is that EDGE_ALIGNED and EDGE_RELATIVE have the same effect on Gadget 
+The fact is that EDGE_ALIGNED and EDGE_RELATIVE have the same effect on gadget 
 edges when the edges are created on the borders of their parent's client area.
-&lt;p&gt;
-
-&lt;h3&gt;Crossplatform Issues&lt;/h3&gt;
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=crossplatform&gt;
+&lt;h2&gt;Cross Platform Issues&lt;/h2&gt;
 &lt;p&gt;
 In general the MaxGUI module should perform identically on Windows,
 Apple and Linux machines. However some care and attention is required
@@ -165,16 +171,16 @@
 enable you to publish programs that look and function well on a wide 
 variety of systems.
 &lt;p&gt;
-Recomended gadget dimensions.
+Use the recommended gadget dimensions:
 &lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt;Buttons and ComboBoxes should be 24 pixels high.
 &lt;p&gt;
 Shorter buttons are possible in Windows but they will become cropped
-on Apple systems so it is recomended that when using the default font
-buttons should be created with a height of 24 pixels.
+on Apple systems so it is recommended that the default font
+buttons are created with a height of 24 pixels.
 &lt;p&gt;
-&lt;li&gt;TextFields should be 20 pixels high and accompanying labels lowered 4 pixels.
+&lt;li&gt;TextFields should be 20 pixels high and accompanying labels lowered by 4 pixels.
 &lt;p&gt;
 Again, using the default font settings, the above rule should produce
 good results on all platforms. Often labels will be placed to the left
@@ -187,81 +193,85 @@
 row 30 pixels below the y position of the previous gadget's positions.
 &lt;/ul&gt;
 &lt;p&gt;
-Use the WINDOW_CLIENTCOORDS flag when dependent on client size.
-&lt;p&gt;
-If you are using a fixed size window specify it's size based on the
+Use the WINDOW_CLIENTCOORDS flag when dependent on client size:
+&lt;ul&gt;
+&lt;li&gt;If you are using a fixed size window specify its size based on the
 required client area using the WINDOW_CLIENTCOORDS style.
 &lt;p&gt;
 Specifying a window's size in the default frame coordinates will 
 result in a client area that may be different on different machines
 due to a number of factors including both the version of the computer's
-operating system and certain user preference outside your control.
-&lt;p&gt;
-&lt;p&gt;
-&lt;h3&gt;Using an EventHook&lt;/h3&gt;
+operating system and certain user preferences outside your control.
+&lt;/ul&gt;
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=hooks&gt;
+&lt;h2&gt;Using Event Hooks&lt;/h2&gt;
 &lt;p&gt;
 As an alternative to developing applications that have a single
-main loop that waits then processes events from an eventqueue
-the AddHook command allows a callback function to be used
+main loop that waits then processes events from an eventqueue,
+the #AddHook command allows a callback function to be used
 to process events as they happen.
 &lt;p&gt;
-This is important for two type of events.
-&lt;p&gt;
-EVENT_GADGETACTION events produced by Slider gadgets with the 
-original SLIDER_SCROLLBAR style and EVENT_WINDOWRESIZE events
-that occur when the user is resizing a Window both require
+This is important for two type of events:
+&lt;ul&gt;
+&lt;li&gt;EVENT_GADGETACTION events produced by slider gadgets with the 
+original SLIDER_SCROLLBAR style and also EVENT_WINDOWRESIZE events
+that occur when the user is resizing a window. Both of these require
 a hooked type of event processing for best results.
-In both these situations most OS's go into a "modal"
-loop that means a WaitEvent command will only return once
-the user releases the mouse button but with Event hooks 
+In these situations most OS's will go into a 'modal'
+loop which means a #WaitEvent command will only return once
+the user releases the mouse button but with event hooks 
 the code can be called directly from within the OS's own 
 modal loop.
 &lt;p&gt;
-The other type of event is EVENT_GADGETPAINT which is generated 
-whenever the operating system needs to redraw a Canvas gadget.
+&lt;li&gt;The other type of event is EVENT_GADGETPAINT which is generated 
+whenever the operating system needs to redraw a canvas gadget.
 When hooked, drawing code can be executed at the time of the 
 event rather than later when the OS returns control to the
 main program, at which time it may have already drawn other
-content above the Canvas.
-&lt;p&gt;
-
-&lt;h3&gt;Using a Canvas&lt;/h3&gt;
+content above the canvas.
+&lt;/ul&gt;
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=canvas&gt;
+&lt;h2&gt;Using a Canvas&lt;/h2&gt;
 &lt;p&gt;
 The following code is a simple example of using Max2D to 
-render dynamically into a Canvas Gadget...
+render dynamically into a canvas gadget. 
+The source for this example is &lt;a href="../createcanvas.bmx"&gt;here&lt;/a&gt;.
 &lt;pre class=code&gt;
 ' createcanvas.bmx
-
+&amp;nbsp;
 Strict 
-
+&amp;nbsp;
 Import MaxGUI.Drivers
-
+&amp;nbsp;
 Global GAME_WIDTH=320
 Global GAME_HEIGHT=240
-
-' create a centered window with client size GAME_WIDTH,GAME_HEIGHT
-
+&amp;nbsp;
+' create a centered window with client size GAME_WIDTH, GAME_HEIGHT
+&amp;nbsp;
 Local wx=(GadgetWidth(Desktop())-GAME_WIDTH)/2
 Local wy=(GadgetHeight(Desktop())-GAME_HEIGHT)/2
-
+&amp;nbsp;
 Local window:TGadget=CreateWindow("My Canvas",wx,wy,GAME_WIDTH,GAME_HEIGHT,Null,WINDOW_TITLEBAR|WINDOW_CLIENTCOORDS)
-
+&amp;nbsp;
 ' create a canvas for our game
-
+&amp;nbsp;
 Local canvas:TGadget=CreateCanvas(0,0,320,240,window)
-
+&amp;nbsp;
 ' create an update timer
-
+&amp;nbsp;
 CreateTimer 60
-
+&amp;nbsp;
 While WaitEvent()
 	Select EventID()
 		Case EVENT_TIMERTICK
 			RedrawGadget canvas
-
+&amp;nbsp;
 		Case EVENT_GADGETPAINT
-			Local g=CanvasGraphics(canvas)
-			SetGraphics g
+			SetGraphics CanvasGraphics(canvas)
 			SetOrigin 160,120
 			SetLineWidth 5
 			Cls
@@ -269,65 +279,65 @@
 			DrawLine 0,0,120*Cos(t),120*Sin(t)
 			DrawLine 0,0,80*Cos(t/60),80*Sin(t/60)
 			Flip
-
+&amp;nbsp;
 		Case EVENT_WINDOWCLOSE
 			FreeGadget canvas
 			End
-
+&amp;nbsp;
 		Case EVENT_APPTERMINATE
 			End
 	End Select
-Wend
-&lt;/pre&gt;
-The above code creates a timer that causes an event to occur
-at 60hz (ticks per second). 
+Wend&lt;/pre&gt;
+This example creates a timer that causes an event to occur
+at 60 Hz (ticks per second). 
 &lt;p&gt;
 Each time an EVENT_TIMERTICK is received by the program's main 
-event loop it calls RedrawGadget which tells the system to redraw
+event loop it calls #RedrawGadget which tells the system to redraw
 our canvas gadget.
 &lt;p&gt;
-The code following the Case EVENT_GADGETPAINT above is where
+The code following the "Case EVENT_GADGETPAINT" line is where
 the actual drawing takes place.
 &lt;p&gt;
-- of interest -
+You may be interested to find that if you remove the lines 
+"RedrawGadget canvas" and "Case EVENT_GADGETPAINT" from the program 
+that it still appears to function normally. "Why is this so?" you might ask.
+&lt;p&gt;
+This is because MaxGUI in fact allows you to draw to a canvas
+whenever you want. Drawing in response to an EVENT_GADGETPAINT
+however, is better behavior as no drawing code will be executed if
+the canvas is obscured or the application has a low refresh rate. 
+In this case, an obscured canvas will still be asked to redraw itself 
+when revealed by window movement from above.
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=rendering&gt;
+&lt;h2&gt;Event Hook based Rendering&lt;/h2&gt;
 &lt;p&gt;
-If you remove two lines of the above code that contain the
-"RedrawGadget canvas" and "Case EVENT_GADGETPAINT" the program
-still appears to function normally.
-&lt;p&gt;
-This is because MaxGUI infact allows you to draw to a canvas
-when ever you want. Drawing in response to an EVENT_GADGETPAINT
-however is better behavior as no drawing code is executed if
-the canvas is obscured or the application has a low refresh rate 
-in which case it will be still asked to redraw itself on the
-event an obscured canvas is revealed by window movement from
-above.
+As previously mentioned, the best way to manage redrawing a canvas
+gadget is with an event hook.
 &lt;p&gt;
-
-&lt;h3&gt;Event Hook based Rendering&lt;/h3&gt;
-&lt;p&gt;
-As mentioned above the best way to manage redrawing a Canvas
-gadget is with an EventHook.
-&lt;p&gt;
-The following example uses an EventHook to handle events
-at the time of occurance rather than from the WaitEvent()
+The following example uses an event hook to handle events
+at the time of occurence rather than from the #WaitEvent
 queue. You will notice at the bottom of the program that 
-infact the main loop does nothing but WaitEvent and all 
-the event handling is done inside the TApplet Type.
+in fact the main loop does nothing but WaitEvent and all 
+the event handling is done inside the TApplet type.
 &lt;p&gt;
+The source for this example is &lt;a href="../eventhookrendering.bmx"&gt;here&lt;/a&gt;.
 &lt;pre class=code&gt;
-' rendering a canvas using an EventHook based Applet Type
-
+' eventhookrendering.bmx
+&amp;nbsp;
+' rendering a canvas using an event hook based applet type
+&amp;nbsp;
 Strict
-
+&amp;nbsp;
 Import MaxGUI.Drivers
-
+&amp;nbsp;
 Type TApplet
-	
+&amp;nbsp;
 	Field	window:TGadget
 	Field	canvas:TGadget
 	Field	timer:TTimer
-	
+&amp;nbsp;
 	Method Render()
 		Local x,y,width,height,t,i
 		width=GraphicsWidth()
@@ -343,7 +353,7 @@
 			DrawLine 0,0,x,y
 		Next
 	End Method
-	
+&amp;nbsp;
 	Method OnEvent(event:TEvent)
 		Select event.id
 		Case EVENT_WINDOWCLOSE
@@ -356,7 +366,7 @@
 			Flip
 		End Select
 	End Method
-
+&amp;nbsp;
 	Function eventhook:Object(id,data:Object,context:Object)
 		Local	event:TEvent
 		Local	app:TApplet
@@ -364,7 +374,7 @@
 		app=TApplet(context)
 		app.OnEvent event	
 	End Function
-	
+&amp;nbsp;
 	Method Create:TApplet(name$)
 		Local	a:TApplet
 		Local	w,h
@@ -377,38 +387,39 @@
 		AddHook EmitEventHook,eventhook,Self
 		Return Self		
 	End Method
-	
+&amp;nbsp;
 End Type
-
+&amp;nbsp;
 AutoMidHandle True
-
+&amp;nbsp;
 Local	applet:TApplet
-
+&amp;nbsp;
 applet=New TApplet.Create("Render Applet")
-
+&amp;nbsp;
 While True
 	WaitEvent
-Wend
-&lt;/pre&gt;
+Wend&lt;/pre&gt;
 &lt;p&gt;
 Unfortunately I have obfiscated (made obscure) the 
 function of the event hook by wrapping it in an 
-Applet object and I have started using big words in
-my sentences.
+Applet object (and I have started using big words in
+my sentences).
 &lt;p&gt;
-To be as concise as possible, the TApplet Type declares
-a Class that features an OnEvent Method that with some 
-magic in it's constructor (the Create() Method) provides
+To be as concise as possible, the TApplet type declares
+a class that features an OnEvent method that, with some 
+magic in its constructor (the Create method), provides
 an object oriented way for our program to collect events.
 &lt;p&gt;
 Our TApplet implements the rendering sequence
-as featured in the previous example but because
-it does so based on a Hook responds in a more
+as featured in the previous example, but because
+it does so based on a hook, it responds in a more
 well behaved manner when the OS wishes to redraw the
 desktop when it is made visible by some user action
-or told to refresh with the RedrawGadget command.
-
-&lt;h3&gt;Porting from BlitzPlus&lt;/h3&gt;
+or told to refresh with the #RedrawGadget command.
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=blitzplus&gt;
+&lt;h2&gt;Porting from BlitzPlus&lt;/h2&gt;
 &lt;p&gt;
 The following are a few issues that you may encounter when
 porting code from BlitzPlus.
@@ -416,36 +427,30 @@
 
 &lt;h4&gt;Event Codes&lt;/h4&gt;
 &lt;p&gt;
-The codes returned by the WaitEvent and EventID commands
-are not the same as BlitzPlus. See the Event Objects docs
+The codes returned by the #WaitEvent and #EventID commands
+are not the same as BlitzPlus. See the 
+&lt;a href="../../Modules/Events/Events/index.html"&gt;Event Objects&lt;/a&gt; docs
 for a list of the constants used in MaxGUI. Numerical
 values have not been documented in order to encourage
 users to use the correct EVENT_NAMES.
 &lt;p&gt;
-New events in MaxGUI include
-&lt;p&gt;
-EVENT_HOTKEYHIT - see SetHotKeyEvent 
-&lt;p&gt;
-EVENT_WINDOWACCEPT - a file has been dragged onto the window
-&lt;p&gt;
-EVENT_GADGETPAINT - a canvas gadget needs redrawing
-&lt;p&gt;
-EVENT_GADGETSELECT - the selected state of a TextArea has changed
-&lt;p&gt;
-EVENT_GADGETMENU - the user has clicked the right button on this gadget
-&lt;p&gt;
-EVENT_GADGETOPEN - a node in a TreeViewNode has been expanded
-&lt;p&gt;
-EVENT_GADGETCLOSE - a node in a TreeViewNode has been collapsed
-&lt;p&gt;
-EVENT_GADGETDONE - an HTMLView has finished loading a page
-&lt;p&gt;
+New events in MaxGUI include:
+&lt;ul&gt;
+&lt;li&gt;EVENT_HOTKEYHIT - see #SetHotKeyEvent 
+&lt;li&gt;EVENT_WINDOWACCEPT - a file has been dragged onto the window
+&lt;li&gt;EVENT_GADGETPAINT - a canvas gadget needs redrawing
+&lt;li&gt;EVENT_GADGETSELECT - the selected state of a TextArea has changed
+&lt;li&gt;EVENT_GADGETMENU - the user has clicked the right button on this gadget
+&lt;li&gt;EVENT_GADGETOPEN - a node in a TreeViewNode has been expanded
+&lt;li&gt;EVENT_GADGETCLOSE - a node in a TreeViewNode has been collapsed
+&lt;li&gt;EVENT_GADGETDONE - an HTMLView has finished loading a page
+&lt;/ul&gt;
 
 &lt;h4&gt;TextArea filters&lt;/h4&gt;
 &lt;p&gt;
 TextAreas no longer generate Key Up, Key Down or Key Stroke events.
 &lt;p&gt;
-Instead the new SetGadgetFilter command can be used to install
+Instead, the new #SetGadgetFilter command can be used to install
 a callback routine that is called each time the user presses
 a key with the callback able to accept or reject each key
 by returning either True or False respectively.
@@ -453,55 +458,58 @@
 
 &lt;h4&gt;Popup Menus&lt;/h4&gt;
 
-There is a new PopupWindowMenu command that can be used
+There is a new #PopupWindowMenu command that can be used
 for implementing context menus commonly activated by the
 right mouse button (reported as an EVENT_GADGETMENU for most
 gadgets).
-
-
-&lt;h3&gt;The New Modules&lt;/h3&gt;
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=modules&gt;
+&lt;h2&gt;The New Modules&lt;/h2&gt;
 &lt;p&gt;
 The three platform specific modules that ship with MaxGui are 
 Win32MaxGui.mod, CocoaMaxGui.mod and FLTKMaxGui.mod which provide 
 native implementations of MaxGui for Windows, Apple MacOS and 
 Linux platforms respectively.
 &lt;p&gt;
-The new Event.mod and EventQueue.mod modules are extensions
+The new &lt;a href="../../Modules/Events/Events/index.html"&gt;Event&lt;/a&gt; and 
+&lt;a href="../../Modules/Events/Event queue/index.html"&gt;EventQueue&lt;/a&gt; modules are extensions 
 to the BlitzMax system. BlitzMax events provide the necessary 
 mechanics of communicating with a MaxGui based application as well
 as providing all BlitzMax applications with events such as
 EVENT_APPSUSPEND, EVENT_APPRESUME and EVENT_APPTERMINATE.
 &lt;p&gt;
-The commands WaitEvent, PeekEvent and PollEvent are the primary
-commands for receiving Events in BlitzMax programs and PostEvent
-can be used for generating Events.
-&lt;p&gt;
-
-&lt;h3&gt;Under the Hood&lt;/h3&gt;
+The commands #WaitEvent, #PeekEvent and #PollEvent are the primary
+commands for receiving events in BlitzMax programs and #PostEvent
+can be used for generating events.
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=hood&gt;
+&lt;h2&gt;Under the Hood&lt;/h2&gt;
 &lt;p&gt;
-The Type TGadget is used in MaxGui to represent all 18 Gadget
+The type TGadget is used in MaxGui to represent all 18 Gadget
 types including:
-&lt;p&gt;
-GADGET_DESKTOP
-GADGET_WINDOW
-GADGET_BUTTON
-GADGET_PANEL
-GADGET_TEXTFIELD
-GADGET_TEXTAREA
-GADGET_COMBOBOX
-GADGET_LISTBOX
-GADGET_TOOLBAR
-GADGET_TABBER
-GADGET_TREEVIEW
-GADGET_HTMLVIEW
-GADGET_LABEL
-GADGET_SLIDER
-GADGET_PROGBAR
-GADGET_MENUITEM
-GADGET_NODE
-GADGET_CANVAS
-&lt;p&gt;
-The TMaxGUIDriver Type defined in maxgui.driver represents the 
+&lt;ul&gt;
+&lt;li&gt;GADGET_DESKTOP
+&lt;li&gt;GADGET_WINDOW
+&lt;li&gt;GADGET_BUTTON
+&lt;li&gt;GADGET_PANEL
+&lt;li&gt;GADGET_TEXTFIELD
+&lt;li&gt;GADGET_TEXTAREA
+&lt;li&gt;GADGET_COMBOBOX
+&lt;li&gt;GADGET_LISTBOX
+&lt;li&gt;GADGET_TOOLBAR
+&lt;li&gt;GADGET_TABBER
+&lt;li&gt;GADGET_TREEVIEW
+&lt;li&gt;GADGET_HTMLVIEW
+&lt;li&gt;GADGET_LABEL
+&lt;li&gt;GADGET_SLIDER
+&lt;li&gt;GADGET_PROGBAR
+&lt;li&gt;GADGET_MENUITEM
+&lt;li&gt;GADGET_NODE
+&lt;li&gt;GADGET_CANVAS
+&lt;/ul&gt;
+The TMaxGUIDriver type defined in #MaxGui.Drivers represents the 
 gadget factory which is created at startup to produce platform 
 specific versions of TGadget on demand.
 &lt;p&gt;
@@ -513,15 +521,14 @@
 an abstract interface to the platform specific implementations
 meaning that like TGadget itself, they are not intended to be 
 extended by the user.
-&lt;p&gt;
-&lt;p&gt;
-
-
-&lt;h3&gt;Crossplatform vs Flexibility&lt;/h3&gt;
+&lt;/div&gt;
+&lt;br&gt;
+&lt;div id=extending&gt;
+&lt;h2&gt;Extending MaxGui&lt;/h2&gt;
 &lt;p&gt;
 It is expected that most users wanting to create custom
 gadgets that work well across all platforms will find 
-the Panel and Canvas gadgets provide adequate Event reporting
+the panel and canvas gadgets provide adequate event reporting
 and rendering functionality from which to produce their
 own uber-gadgets.
 &lt;p&gt;
@@ -537,10 +544,10 @@
 &lt;p&gt;
 This of course does not mean the the current specification 
 of MaxGUI is set in stone, rather, that those wanting to 
-interface at a lower level with the Operating System of
+interface at a lower level with the operating system of
 their choice do so in the privacy of their own modules
 rather than becoming muddied in the source of the lowlevel
 platform specific BRL modules.
-
+&lt;/div&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</textarea><br><br>MaxGUI overview.bbdoc<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;link rel="styleSheet" href="../bmxstyle.css" type="text/css"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;MaxGUI overview&lt;/h1&gt;

The MaxGui module provides commands to build user interfaces
for applications programmed in BlitzMax.
&lt;p&gt;
The command set originates from the original BlitzPlus 'Gadget'
based names providing a healthy amount of backward
compatability for users wishing to port code developed in 
BlitzPlus.

&lt;ul&gt;
&lt;li&gt;&lt;a href=#started&gt;Getting Started&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#layout&gt;Gadget Layout&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#crossplatform&gt;Cross Platform Issues&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#hooks&gt;Using Event Hooks&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#canvas&gt;Using a Canvas&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#rendering&gt;Event Hook based Rendering&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#blitzplus&gt;Porting from BlitzPlus&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#modules&gt;The New Modules&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#hood&gt;Under the Hood&lt;/a&gt;&lt;br&gt;&lt;br&gt;
&lt;li&gt;&lt;a href=#extending&gt;Extending MaxGui&lt;/a&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div id=started&gt;
&lt;h2&gt;Getting Started&lt;/h2&gt;


The following program opens a small window on the desktop
that ends when the window is closed.
The source for this example is &lt;a href="../gettingstarted.bmx"&gt;here&lt;/a&gt;.
&lt;p&gt;
The code beginning at "While True" is the main event loop
of the program, it repeats forever waiting for an event
to happen, printing the event's details to the output window
and ending if the event has the ID of EVENT_WINDOWCLOSE.
&lt;pre class=code&gt;
' gettingstarted.bmx
&amp;nbsp;
Strict
&amp;nbsp;
Import MaxGUI.Drivers
&amp;nbsp;
Local window:TGadget=CreateWindow("My Window",40,40,320,240)
&amp;nbsp;
While True
	WaitEvent 
	Print CurrentEvent.ToString()
	Select EventID()
		Case EVENT_WINDOWCLOSE
			End
	End Select
Wend&lt;/pre&gt;
Try moving and sizing the window while the program is running
and you will see the details of the events that occur printed
in the debug window of BlitzMax.
&lt;p&gt;
Try also modifying the "window=" line in the program with:
&lt;pre class=code&gt;
Local window:TGadget=CreateWindow("My Window",40,40,320,240,Null,WINDOW_TITLEBAR)&lt;/pre&gt;
This will create a window with only a title bar and no status or
menu bars. See #CreateWindow for more details
of the Window styles supported by MaxGui.
&lt;p&gt;
The MaxGui documentation contains working examples for each of 
the commands that create gadgets including:
&lt;ul&gt;
&lt;li&gt;#CreateButton
&lt;li&gt;#CreateCanvas
&lt;li&gt;#CreateComboBox
&lt;li&gt;#CreateHTMLView
&lt;li&gt;#CreateLabel
&lt;li&gt;#CreateListBox
&lt;li&gt;#CreateMenu
&lt;li&gt;#CreatePanel
&lt;li&gt;#CreateProgBar
&lt;li&gt;#CreateSlider
&lt;li&gt;#CreateTabber
&lt;li&gt;#CreateTextField
&lt;li&gt;#CreateToolBar
&lt;li&gt;#CreateTreeView
&lt;/ul&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;div id=layout&gt;
&lt;h2&gt;Gadget Layout&lt;/h2&gt;
&lt;p&gt;
A gadget in MaxGui is given pixel coordinates when it is created
which positions it in its parent's client area. The client area of
a window gadget is inside the window's borders, not including the
space used by any Status or Menu bars.
&lt;p&gt;
If a window is resized MaxGui uses any children's layout settings
to reposition them within the new size of its client area.
&lt;p&gt;
#SetGadgetLayout is used to control how the gadget is repositioned
when its parent is resized.
&lt;p&gt;
By considering each edge of the gadget independently, the MaxGui
layout engine repositions each gadget according to each edge's
rule where the rules are: 
&lt;ul&gt;
&lt;li&gt;EDGE_CENTERED - The edge remains a fixed distance from the center of the parent&lt;br&gt;
&lt;li&gt;EDGE_ALIGNED - The edge is a locked distance away from its parent's corresponding edge&lt;br&gt;
&lt;li&gt;EDGE_RELATIVE - The edge remains a proportional distance from the parent's 2 edges&lt;br&gt;
&lt;/ul&gt;
The following code demonstrates a common case of creating a panel
in a window the size of the window's client area and locking the
distance of each edge to the correspong edge of the parent window
(EDGE_ALIGNED rule). The result is that the panel is automatically sized by 
MaxGui when the window is resized filling the entire client area.
&lt;p&gt;
The source for this example is &lt;a href="../gadgetlayout.bmx"&gt;here&lt;/a&gt;.
&lt;pre class=code&gt;
' gadgetlayout.bmx
&amp;nbsp;
Strict 
&amp;nbsp;
Import MaxGUI.Drivers
&amp;nbsp;
Local window:TGadget=CreateWindow("My Window",40,40,320,240)
&amp;nbsp;
Local panel:TGadget=CreatePanel(0,0,ClientWidth(window),ClientHeight(window),window)
SetGadgetColor panel,200,100,100
SetGadgetLayout panel,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED
&amp;nbsp;
While True
	WaitEvent 
	Print CurrentEvent.ToString()
	Select EventID()
		Case EVENT_WINDOWCLOSE
			End
	End Select
Wend&lt;/pre&gt;
By removing the line of code with the "SetGadgetLayout" command you can view the default 
EDGE_CENTERED rule in effect on all edges. This will make the panel retain its size 
due to all its edges being kept a fixed distance from the center 
of the window.
&lt;p&gt;
To view rule EDGE_RELATIVE in effect modify the "SetGadgetLayout" command to read:
&lt;pre class=code&gt;
SetGadgetLayout panel,EDGE_RELATIVE,EDGE_RELATIVE,EDGE_RELATIVE,EDGE_RELATIVE&lt;/pre&gt;
But wait, there is no discernable change in the resizing behavior between
rule EDGE_ALIGNED and rule EDGE_RELATIVE???
&lt;p&gt;
This will happen unless the panel is created inset from the window client such as 
the result of the following modification:
&lt;pre class=code&gt;
Local panel:TGadget=CreatePanel(10,10,ClientWidth(window)-20,ClientHeight(window)-20,window)&lt;/pre&gt;
Now you will notice the edges are in fact being kept a proportional distance
from the parent's 2 edges when the window is resized.
&lt;p&gt;
The fact is that EDGE_ALIGNED and EDGE_RELATIVE have the same effect on gadget 
edges when the edges are created on the borders of their parent's client area.
&lt;/div&gt;
&lt;br&gt;
&lt;div id=crossplatform&gt;
&lt;h2&gt;Cross Platform Issues&lt;/h2&gt;
&lt;p&gt;
In general the MaxGUI module should perform identically on Windows,
Apple and Linux machines. However some care and attention is required
when testing in regards to how your application will look on each 
platform.
&lt;p&gt;
The following are a few issues that if considered should hopefully
enable you to publish programs that look and function well on a wide 
variety of systems.
&lt;p&gt;
Use the recommended gadget dimensions:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt;Buttons and ComboBoxes should be 24 pixels high.
&lt;p&gt;
Shorter buttons are possible in Windows but they will become cropped
on Apple systems so it is recommended that the default font
buttons are created with a height of 24 pixels.
&lt;p&gt;
&lt;li&gt;TextFields should be 20 pixels high and accompanying labels lowered by 4 pixels.
&lt;p&gt;
Again, using the default font settings, the above rule should produce
good results on all platforms. Often labels will be placed to the left
or right of TextFields, in which case they should be set 4 pixels lower
down the screen in order to correctly align with TextFields.
&lt;p&gt;
&lt;li&gt;Separate fields in a form by 30 pixels.
&lt;p&gt;
When creating a form with multiple TextField gadgets start each
row 30 pixels below the y position of the previous gadget's positions.
&lt;/ul&gt;
&lt;p&gt;
Use the WINDOW_CLIENTCOORDS flag when dependent on client size:
&lt;ul&gt;
&lt;li&gt;If you are using a fixed size window specify its size based on the
required client area using the WINDOW_CLIENTCOORDS style.
&lt;p&gt;
Specifying a window's size in the default frame coordinates will 
result in a client area that may be different on different machines
due to a number of factors including both the version of the computer's
operating system and certain user preferences outside your control.
&lt;/ul&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;div id=hooks&gt;
&lt;h2&gt;Using Event Hooks&lt;/h2&gt;
&lt;p&gt;
As an alternative to developing applications that have a single
main loop that waits then processes events from an eventqueue,
the #AddHook command allows a callback function to be used
to process events as they happen.
&lt;p&gt;
This is important for two type of events:
&lt;ul&gt;
&lt;li&gt;EVENT_GADGETACTION events produced by slider gadgets with the 
original SLIDER_SCROLLBAR style and also EVENT_WINDOWRESIZE events
that occur when the user is resizing a window. Both of these require
a hooked type of event processing for best results.
In these situations most OS's will go into a 'modal'
loop which means a #WaitEvent command will only return once
the user releases the mouse button but with event hooks 
the code can be called directly from within the OS's own 
modal loop.
&lt;p&gt;
&lt;li&gt;The other type of event is EVENT_GADGETPAINT which is generated 
whenever the operating system needs to redraw a canvas gadget.
When hooked, drawing code can be executed at the time of the 
event rather than later when the OS returns control to the
main program, at which time it may have already drawn other
content above the canvas.
&lt;/ul&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;div id=canvas&gt;
&lt;h2&gt;Using a Canvas&lt;/h2&gt;
&lt;p&gt;
The following code is a simple example of using Max2D to 
render dynamically into a canvas gadget. 
The source for this example is &lt;a href="../createcanvas.bmx"&gt;here&lt;/a&gt;.
&lt;pre class=code&gt;
' createcanvas.bmx
&amp;nbsp;
Strict 
&amp;nbsp;
Import MaxGUI.Drivers
&amp;nbsp;
Global GAME_WIDTH=320
Global GAME_HEIGHT=240
&amp;nbsp;
' create a centered window with client size GAME_WIDTH, GAME_HEIGHT
&amp;nbsp;
Local wx=(GadgetWidth(Desktop())-GAME_WIDTH)/2
Local wy=(GadgetHeight(Desktop())-GAME_HEIGHT)/2
&amp;nbsp;
Local window:TGadget=CreateWindow("My Canvas",wx,wy,GAME_WIDTH,GAME_HEIGHT,Null,WINDOW_TITLEBAR|WINDOW_CLIENTCOORDS)
&amp;nbsp;
' create a canvas for our game
&amp;nbsp;
Local canvas:TGadget=CreateCanvas(0,0,320,240,window)
&amp;nbsp;
' create an update timer
&amp;nbsp;
CreateTimer 60
&amp;nbsp;
While WaitEvent()
	Select EventID()
		Case EVENT_TIMERTICK
			RedrawGadget canvas
&amp;nbsp;
		Case EVENT_GADGETPAINT
			SetGraphics CanvasGraphics(canvas)
			SetOrigin 160,120
			SetLineWidth 5
			Cls
			Local t=MilliSecs()
			DrawLine 0,0,120*Cos(t),120*Sin(t)
			DrawLine 0,0,80*Cos(t/60),80*Sin(t/60)
			Flip
&amp;nbsp;
		Case EVENT_WINDOWCLOSE
			FreeGadget canvas
			End
&amp;nbsp;
		Case EVENT_APPTERMINATE
			End
	End Select
Wend&lt;/pre&gt;
This example creates a timer that causes an event to occur
at 60 Hz (ticks per second). 
&lt;p&gt;
Each time an EVENT_TIMERTICK is received by the program's main 
event loop it calls #RedrawGadget which tells the system to redraw
our canvas gadget.
&lt;p&gt;
The code following the "Case EVENT_GADGETPAINT" line is where
the actual drawing takes place.
&lt;p&gt;
You may be interested to find that if you remove the lines 
"RedrawGadget canvas" and "Case EVENT_GADGETPAINT" from the program 
that it still appears to function normally. "Why is this so?" you might ask.
&lt;p&gt;
This is because MaxGUI in fact allows you to draw to a canvas
whenever you want. Drawing in response to an EVENT_GADGETPAINT
however, is better behavior as no drawing code will be executed if
the canvas is obscured or the application has a low refresh rate. 
In this case, an obscured canvas will still be asked to redraw itself 
when revealed by window movement from above.
&lt;/div&gt;
&lt;br&gt;
&lt;div id=rendering&gt;
&lt;h2&gt;Event Hook based Rendering&lt;/h2&gt;
&lt;p&gt;
As previously mentioned, the best way to manage redrawing a canvas
gadget is with an event hook.
&lt;p&gt;
The following example uses an event hook to handle events
at the time of occurence rather than from the #WaitEvent
queue. You will notice at the bottom of the program that 
in fact the main loop does nothing but WaitEvent and all 
the event handling is done inside the TApplet type.
&lt;p&gt;
The source for this example is &lt;a href="../eventhookrendering.bmx"&gt;here&lt;/a&gt;.
&lt;pre class=code&gt;
' eventhookrendering.bmx
&amp;nbsp;
' rendering a canvas using an event hook based applet type
&amp;nbsp;
Strict
&amp;nbsp;
Import MaxGUI.Drivers
&amp;nbsp;
Type TApplet
&amp;nbsp;
	Field	window:TGadget
	Field	canvas:TGadget
	Field	timer:TTimer
&amp;nbsp;
	Method Render()
		Local x,y,width,height,t,i
		width=GraphicsWidth()
		height=GraphicsHeight()
		t=MilliSecs()
		SetBlend ALPHABLEND
		SetViewport 0,0,width,height
		SetClsColor 0,0,0
		SetOrigin width/2,height/2
		Cls
		For x=-width/2 To width/2 Step 2
			y=Sin(t*0.3+x)*height/2
			DrawLine 0,0,x,y
		Next
	End Method
&amp;nbsp;
	Method OnEvent(event:TEvent)
		Select event.id
		Case EVENT_WINDOWCLOSE
			End
		Case EVENT_TIMERTICK
			RedrawGadget canvas
		Case EVENT_GADGETPAINT
			SetGraphics CanvasGraphics(canvas)
			Render
			Flip
		End Select
	End Method
&amp;nbsp;
	Function eventhook:Object(id,data:Object,context:Object)
		Local	event:TEvent
		Local	app:TApplet
		event=TEvent(data)
		app=TApplet(context)
		app.OnEvent event	
	End Function
&amp;nbsp;
	Method Create:TApplet(name$)
		Local	a:TApplet
		Local	w,h
		window=CreateWindow(name,20,20,512,512)
		w=ClientWidth(window)
		h=ClientHeight(window)
		canvas=CreateCanvas(0,0,w,h,window)
		canvas.SetLayout 1,1,1,1
		timer=CreateTimer(100)
		AddHook EmitEventHook,eventhook,Self
		Return Self		
	End Method
&amp;nbsp;
End Type
&amp;nbsp;
AutoMidHandle True
&amp;nbsp;
Local	applet:TApplet
&amp;nbsp;
applet=New TApplet.Create("Render Applet")
&amp;nbsp;
While True
	WaitEvent
Wend&lt;/pre&gt;
&lt;p&gt;
Unfortunately I have obfiscated (made obscure) the 
function of the event hook by wrapping it in an 
Applet object (and I have started using big words in
my sentences).
&lt;p&gt;
To be as concise as possible, the TApplet type declares
a class that features an OnEvent method that, with some 
magic in its constructor (the Create method), provides
an object oriented way for our program to collect events.
&lt;p&gt;
Our TApplet implements the rendering sequence
as featured in the previous example, but because
it does so based on a hook, it responds in a more
well behaved manner when the OS wishes to redraw the
desktop when it is made visible by some user action
or told to refresh with the #RedrawGadget command.
&lt;/div&gt;
&lt;br&gt;
&lt;div id=blitzplus&gt;
&lt;h2&gt;Porting from BlitzPlus&lt;/h2&gt;
&lt;p&gt;
The following are a few issues that you may encounter when
porting code from BlitzPlus.
&lt;p&gt;

&lt;h4&gt;Event Codes&lt;/h4&gt;
&lt;p&gt;
The codes returned by the #WaitEvent and #EventID commands
are not the same as BlitzPlus. See the 
&lt;a href="../../Modules/Events/Events/index.html"&gt;Event Objects&lt;/a&gt; docs
for a list of the constants used in MaxGUI. Numerical
values have not been documented in order to encourage
users to use the correct EVENT_NAMES.
&lt;p&gt;
New events in MaxGUI include:
&lt;ul&gt;
&lt;li&gt;EVENT_HOTKEYHIT - see #SetHotKeyEvent 
&lt;li&gt;EVENT_WINDOWACCEPT - a file has been dragged onto the window
&lt;li&gt;EVENT_GADGETPAINT - a canvas gadget needs redrawing
&lt;li&gt;EVENT_GADGETSELECT - the selected state of a TextArea has changed
&lt;li&gt;EVENT_GADGETMENU - the user has clicked the right button on this gadget
&lt;li&gt;EVENT_GADGETOPEN - a node in a TreeViewNode has been expanded
&lt;li&gt;EVENT_GADGETCLOSE - a node in a TreeViewNode has been collapsed
&lt;li&gt;EVENT_GADGETDONE - an HTMLView has finished loading a page
&lt;/ul&gt;

&lt;h4&gt;TextArea filters&lt;/h4&gt;
&lt;p&gt;
TextAreas no longer generate Key Up, Key Down or Key Stroke events.
&lt;p&gt;
Instead, the new #SetGadgetFilter command can be used to install
a callback routine that is called each time the user presses
a key with the callback able to accept or reject each key
by returning either True or False respectively.
&lt;p&gt;

&lt;h4&gt;Popup Menus&lt;/h4&gt;

There is a new #PopupWindowMenu command that can be used
for implementing context menus commonly activated by the
right mouse button (reported as an EVENT_GADGETMENU for most
gadgets).
&lt;/div&gt;
&lt;br&gt;
&lt;div id=modules&gt;
&lt;h2&gt;The New Modules&lt;/h2&gt;
&lt;p&gt;
The three platform specific modules that ship with MaxGui are 
Win32MaxGui.mod, CocoaMaxGui.mod and FLTKMaxGui.mod which provide 
native implementations of MaxGui for Windows, Apple MacOS and 
Linux platforms respectively.
&lt;p&gt;
The new &lt;a href="../../Modules/Events/Events/index.html"&gt;Event&lt;/a&gt; and 
&lt;a href="../../Modules/Events/Event queue/index.html"&gt;EventQueue&lt;/a&gt; modules are extensions 
to the BlitzMax system. BlitzMax events provide the necessary 
mechanics of communicating with a MaxGui based application as well
as providing all BlitzMax applications with events such as
EVENT_APPSUSPEND, EVENT_APPRESUME and EVENT_APPTERMINATE.
&lt;p&gt;
The commands #WaitEvent, #PeekEvent and #PollEvent are the primary
commands for receiving events in BlitzMax programs and #PostEvent
can be used for generating events.
&lt;/div&gt;
&lt;br&gt;
&lt;div id=hood&gt;
&lt;h2&gt;Under the Hood&lt;/h2&gt;
&lt;p&gt;
The type TGadget is used in MaxGui to represent all 18 Gadget
types including:
&lt;ul&gt;
&lt;li&gt;GADGET_DESKTOP
&lt;li&gt;GADGET_WINDOW
&lt;li&gt;GADGET_BUTTON
&lt;li&gt;GADGET_PANEL
&lt;li&gt;GADGET_TEXTFIELD
&lt;li&gt;GADGET_TEXTAREA
&lt;li&gt;GADGET_COMBOBOX
&lt;li&gt;GADGET_LISTBOX
&lt;li&gt;GADGET_TOOLBAR
&lt;li&gt;GADGET_TABBER
&lt;li&gt;GADGET_TREEVIEW
&lt;li&gt;GADGET_HTMLVIEW
&lt;li&gt;GADGET_LABEL
&lt;li&gt;GADGET_SLIDER
&lt;li&gt;GADGET_PROGBAR
&lt;li&gt;GADGET_MENUITEM
&lt;li&gt;GADGET_NODE
&lt;li&gt;GADGET_CANVAS
&lt;/ul&gt;
The TMaxGUIDriver type defined in #MaxGui.Drivers represents the 
gadget factory which is created at startup to produce platform 
specific versions of TGadget on demand.
&lt;p&gt;
The type TGadget is actually an abstract class with TWin32Gadget,
TCocoaGadget and TFLTKGadget being the actual types produced
depending on the current TMaxGUIDriver.
&lt;p&gt;
The types TIconStrip, TGUIFont and TGadgetItem also provide
an abstract interface to the platform specific implementations
meaning that like TGadget itself, they are not intended to be 
extended by the user.
&lt;/div&gt;
&lt;br&gt;
&lt;div id=extending&gt;
&lt;h2&gt;Extending MaxGui&lt;/h2&gt;
&lt;p&gt;
It is expected that most users wanting to create custom
gadgets that work well across all platforms will find 
the panel and canvas gadgets provide adequate event reporting
and rendering functionality from which to produce their
own uber-gadgets.
&lt;p&gt;
The cross platform nature of MaxGUI means there are
implications for those wishing to extend functionality by
taking advantage of platform specific features that have
no logical equivalent on other platforms.
&lt;p&gt;
Those wishing to do so are encouraged to implement such 
features in separate modules rather than making modifications
to the BRL modules which are intended only to support the
core cross platform MaxGUI functionality.
&lt;p&gt;
This of course does not mean the the current specification 
of MaxGUI is set in stone, rather, that those wanting to 
interface at a lower level with the operating system of
their choice do so in the privacy of their own modules
rather than becoming muddied in the source of the lowlevel
platform specific BRL modules.
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</textarea><br><br>createcanvas.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' createcanvas.bmx

Strict 

Import MaxGUI.Drivers

Global GAME_WIDTH=320
Global GAME_HEIGHT=240

' create a centered window with client size GAME_WIDTH, GAME_HEIGHT

Local wx=(GadgetWidth(Desktop())-GAME_WIDTH)/2
Local wy=(GadgetHeight(Desktop())-GAME_HEIGHT)/2

Local window:TGadget=CreateWindow("My Canvas",wx,wy,GAME_WIDTH,GAME_HEIGHT,Null,WINDOW_TITLEBAR|WINDOW_CLIENTCOORDS)

' create a canvas for our game

Local canvas:TGadget=CreateCanvas(0,0,320,240,window)

' create an update timer

CreateTimer 60

While WaitEvent()
	Select EventID()
		Case EVENT_TIMERTICK
			RedrawGadget canvas

		Case EVENT_GADGETPAINT
			SetGraphics CanvasGraphics(canvas)
			SetOrigin 160,120
			SetLineWidth 5
			Cls
			Local t=MilliSecs()
			DrawLine 0,0,120*Cos(t),120*Sin(t)
			DrawLine 0,0,80*Cos(t/60),80*Sin(t/60)
			Flip

		Case EVENT_WINDOWCLOSE
			FreeGadget canvas
			End

		Case EVENT_APPTERMINATE
			End
	End Select
Wend
</textarea><br><br>eventhookrendering.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' eventhookrendering.bmx

' rendering a canvas using an event hook based applet type

Strict

Import MaxGUI.Drivers

Type TApplet
	
	Field	window:TGadget
	Field	canvas:TGadget
	Field	timer:TTimer
	
	Method Render()
		Local x,y,width,height,t,i
		width=GraphicsWidth()
		height=GraphicsHeight()
		t=MilliSecs()
		SetBlend ALPHABLEND
		SetViewport 0,0,width,height
		SetClsColor 0,0,0
		SetOrigin width/2,height/2
		Cls
		For x=-width/2 To width/2 Step 2
			y=Sin(t*0.3+x)*height/2
			DrawLine 0,0,x,y
		Next
	End Method
	
	Method OnEvent(event:TEvent)
		Select event.id
		Case EVENT_WINDOWCLOSE
			End
		Case EVENT_TIMERTICK
			RedrawGadget canvas
		Case EVENT_GADGETPAINT
			SetGraphics CanvasGraphics(canvas)
			Render
			Flip
		End Select
	End Method

	Function eventhook:Object(id,data:Object,context:Object)
		Local	event:TEvent
		Local	app:TApplet
		event=TEvent(data)
		app=TApplet(context)
		app.OnEvent event	
	End Function
	
	Method Create:TApplet(name$)
		Local	a:TApplet
		Local	w,h
		window=CreateWindow(name,20,20,512,512)
		w=ClientWidth(window)
		h=ClientHeight(window)
		canvas=CreateCanvas(0,0,w,h,window)
		canvas.SetLayout 1,1,1,1
		timer=CreateTimer(100)
		AddHook EmitEventHook,eventhook,Self
		Return Self
	End Method
	
End Type

AutoMidHandle True

Local	applet:TApplet

applet=New TApplet.Create("Render Applet")

While True
	WaitEvent
Wend
</textarea><br><br>gadgetlayout.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' gadgetlayout.bmx

Strict 

Import MaxGUI.Drivers

Local window:TGadget=CreateWindow("My Window",40,40,320,240)

Local panel:TGadget=CreatePanel(0,0,ClientWidth(window),ClientHeight(window),window)
SetGadgetColor panel,200,100,100
SetGadgetLayout panel,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED

While True
	WaitEvent 
	Print CurrentEvent.ToString()
	Select EventID()
		Case EVENT_WINDOWCLOSE
			End
	End Select
Wend
</textarea><br><br>gettingstarted.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' gettingstarted.bmx

Strict

Import MaxGUI.Drivers

Local window:TGadget=CreateWindow("My Window",40,40,320,240)

While True
	WaitEvent
	Print CurrentEvent.ToString()
	Select EventID()
		Case EVENT_WINDOWCLOSE
			End
	End Select
Wend
</textarea> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
