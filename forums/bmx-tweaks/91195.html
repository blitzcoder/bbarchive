<!DOCTYPE html><html lang="en" ><head ><title >makedocs tweak</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >makedocs tweak</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >makedocs tweak</a><br><br>
<a name="1037785"></a>

<a name="1221944"></a>

<a name="1222180"></a>

<a name="1222181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am redistributing binaries of makedocs and docmods so it's easy for the community to test them out. <br><br>I have only win32 and linux zips and I will get ppcmac later but I don't have an imac, so that's out unless someone wants to help.<br><br>Extract both files to your 'bin' folder.<br>makedocs-win32.zip (expired)<br>makedocs-linux.zip (expired)<br><br>All changes should be cross platform. If you know any bugs I've missed (or created) please point them out!<br><br>New docmods features, most changes are designed to reflect makedocs:<br>- added escape character parsing for '~#', '~@', '~%', '~|' and '~~'<br>- removed full stops added to end of paragraphs, single line docs are better without one<br>- added '#' links, for example '#brl.basic', '#Print', '#{User guide}', '#bah.regex', etc<br>- added '{{' and '}}' for &lt;pre&gt; tags and removed '&amp;' for &lt;pre&gt; as it's not supported in makedocs<br>- added '[', ']' and '*' for &lt;ul&gt; and &lt;li&gt; bullets, if '|' found then it's a table with '*' for &lt;tr&gt; and '|' for &lt;td&gt;<br>- added '+' for &lt;h1&gt; header tags, in intro.bbdoc the first '+' is &lt;h1&gt;thereafter it is &lt;h2&gt;<br>- removed module description printing as header in introduction<br>- added navbar for types instead of just type headers<br>- fixed example links not working if filename in lowercase<br>- changed type summary tables width from 90% to 95%, all type tables are now 95%<br>- more robust parsing of bbdoc rem tags, about: doesn't have to be last<br>- added 'param:' bbdoc rem tag, limited to one line but multiple entries are supported<br>- some other minor fixes<br><br>Not many makedocs features yet (but more soon):<br>- html links to all third party modules in the modules section, no need to use the sidebar<br>- 'Rem bbdoc:' on same line for 2 line descriptions<br>- fixed loading example files for type subfolders<br><br>Last edits: 27 Aug 2010. <br><br>I found this bug when I was updating the <a href="/posts.php?topic=91098" target="_blank">brl.linkedlist docs</a>.<br><br>In fredborgstyle.bmx a LoadText would crash if it didn't find an example file in a type subfolder.<br><br>Source file (from v 1.41) and the patch.<br><br>fredborgstyle.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- fredborgstyle-old.bmx	2010-07-13 03:54:59.000000000 +0100
+++ fredborgstyle.bmx	2010-07-21 04:33:14.471489783 +0100
@@ -111,7 +111,7 @@
 				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Information&lt;/td&gt;&lt;td class=docright&gt;"+t.about+"&lt;/td&gt;&lt;/tr&gt;"
 			EndIf
 			
-			If t.example 
+			If t.example And FileType( absDocDir+"/"+t.example )
 				Local p$=t.example
 				Local link$="&lt;a href=~q"+p+"~q&gt;Example&lt;/a&gt;"
 				Local code$=LoadText( absDocDir+"/"+p ).Trim()
</textarea><br><br>fredborgstyle.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import "docstyle.bmx"

Type TFredborgStyle Extends TDocStyle

	Method EmitHeader()

		'emit HTML header	
		Emit "&lt;html&gt;&lt;head&gt;&lt;title&gt;"+doc.id+"&lt;/title&gt;"
		Emit "&lt;link rel=stylesheet Type=text/css href=~q"+relRootDir+"/styles/fredborg.css~q&gt;"
		Emit "&lt;/head&gt;&lt;body&gt;"
		
		'emit title bar
		Emit "&lt;table width=100% cellspacing=0&gt;&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
		Emit "&lt;td class=small width=1%&gt;&lt;b&gt;"+doc.id+":&lt;/b&gt;&lt;/td&gt;"

		'emit links to summaries		
		For Local t$=EachIn allKinds
			If t="/" Or Not ChildList( t ) Continue

			Emit "&lt;td class=small width=1%&gt;&lt;a href=#_"+t+" class=small&gt;"+t+"s&lt;/a&gt;&lt;/td&gt;"

		Next

		'emit link to module source
		If doc.kind="Module"
			Local t$=ModuleSource( doc.id.ToLower() ),i=t.Find( "/mod/" )
			If i&lt;&gt;-1
				t=relRootDir+"/../.."+t[i..]
				Emit "&lt;td class=small width=1%&gt;&lt;a href='"+t+"' class=small&gt;Source&lt;/a&gt;&lt;/td&gt;"
			EndIf
		EndIf
		
		'end title bar
		Emit "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;&lt;br&gt;"
		
		'emit about
		If doc.about Emit doc.about+"&lt;br&gt;&lt;br&gt;"

	End Method
	
	Method EmitFooter()

		'emit HTML footer
		Emit "&lt;/body&gt;&lt;/html&gt;"

	End Method
	
	Method EmitLinks( kind$ )

		Local list:TList=ChildList( kind )
		If Not list Return
		
		'emit anchor: _Const, _Function etc...
		
		If kind="/"
		
			Emit "&lt;table class=doc cellspacing=3&gt;"
			
			For Local t:TDocNode=EachIn list
			
				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt; #{"+t.id+"}&lt;/td&gt;&lt;/tr&gt;"
	
			Next
	
			Emit "&lt;/table&gt;"
		
		Else
		
			Emit "&lt;a name=_"+kind+"&gt;&lt;/a&gt;"
			Emit "&lt;h2&gt;"+kind+"s&lt;/h2&gt;"
		
			Emit "&lt;table class=doc width=100% cellspacing=3&gt;"
			
			For Local t:TDocNode=EachIn list
			
				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt; #{"+t.id+"}&lt;/td&gt;&lt;td class=docright&gt;"+t.bbdoc+"&lt;/td&gt;&lt;/tr&gt;"
	
			Next
	
			Emit "&lt;/table&gt;"
		EndIf
	
	End Method
	
	Method EmitDecls( kind$ )

		Local list:TList=ChildList( kind )
		If Not list Return
		
		Emit "&lt;h2&gt;"+kind+" reference&lt;/h2&gt;"
		
		For Local t:TDocNode=EachIn list
		
			Emit "&lt;a name=~q"+t.id+"~q&gt;&lt;/a&gt;"
		
			Emit "&lt;p&gt;&lt;table class=doc width=100% cellspacing=3&gt;"
			Emit "&lt;tr&gt;&lt;td class=doctop colspan=2&gt;"+t.proto+"&lt;/td&gt;&lt;/tr&gt;"

			If t.returns
				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Returns&lt;/td&gt;&lt;td class=docright&gt;"+t.returns+"&lt;/td&gt;&lt;/tr&gt;"
			EndIf

			If t.bbdoc
				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Description&lt;/td&gt;&lt;td class=docright&gt;"+t.bbdoc+"&lt;/td&gt;&lt;/tr&gt;"
			EndIf

			If t.about
				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Information&lt;/td&gt;&lt;td class=docright&gt;"+t.about+"&lt;/td&gt;&lt;/tr&gt;"
			EndIf
			
			If t.example And FileType( absDocDir+"/"+t.example )
				Local p$=t.example
				Local link$="&lt;a href=~q"+p+"~q&gt;Example&lt;/a&gt;"
				Local code$=LoadText( absDocDir+"/"+p ).Trim()
				code="~n{{~n"+code+"~n}}~n"
				Emit "&lt;tr&gt;&lt;td class=docleft width=1%&gt;"+link+"&lt;/td&gt;&lt;td class=docright&gt;"+code+"&lt;/td&gt;&lt;/tr&gt;"
			EndIf
	
			Emit "&lt;/table&gt;"
		
		Next
		
	End Method

End Type
</textarea> <br><br></td></tr></table><br>
<a name="1037906"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This fixes links that redirect to the type identifier with the same name as a standard identifier.<br>For examples try clicking PeekByte in brl.bank or ReadByte in brl.stream.<br><br>In docstyle.bmx the link gets overridden by a type identifier link of the same name. <br>The fix isolates the right sort of link in the 'Else If' block and then if a '#' is found it strips off the type subfolder name.<br><br>Source file (from v 1.41) and the patch.<br><br>docstyle.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- docstyle-old.bmx	2010-07-13 03:54:59.000000000 +0100
+++ docstyle.bmx	2010-08-25 06:09:07.894402987 +0100
@@ -77,6 +77,8 @@
 			url=url[ docURL.length.. ]
 		Else If url.StartsWith( doc.path+"/" )
 			url="~q"+url[ doc.path.length+1.. ]+"~q"
+			Local tpos=url.Find( "#",2 )
+			If tpos&gt;1 url="~q"+url[tpos..]
 		Else
 			url="~q"+relRootDir+url+"~q"
 		EndIf
</textarea><br><br>docstyle.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import BRL.MaxUtil

Import "bbdoc.bmx"

Import "docnode.bmx"

Global BmxDocDir$=BlitzMaxPath()+"/docs/html"

Global NodeKinds$[]=[ "/","Module","Type" ]

Global LeafKinds$[]=[ "Const","Field","Global","Method","Function","Keyword" ]

Global AllKinds$[]=NodeKinds+LeafKinds

Type TDocStyle Extends TBBLinkResolver

	Field html$
	Field doc:TDocNode
	Field children:TMap
	Field docURL$
	Field absDocDir$		'where output doc goes
	Field relRootDir$		'relative path to root doc dir
	
	Global commands:TMap=New TMap

	Method NodeIsleaf( node:TDocNode )
		For Local t$=EachIn LeafKinds
			If t=node.kind Return True
		Next
	End Method
	
	Method FindNode:TDocNode( node:TDocNode,id$ )

		If node.id.ToLower()=id Return node

		If node.path.Tolower().EndsWith( "/"+id ) Return node

		For Local t:TDocNode=EachIn node.children
			Local p:TDocNode=FindNode( t,id )
			If p Return p
		Next
	End Method
	
	Method NodeURL$( node:TDocNode )
		If node.kind="Topic"
			Return node.path+".html"
		Else If NodeIsLeaf( node )
			Return ExtractDir( node.path )+"/index.html#"+node.id
		Else If node.path&lt;&gt;"/"
			Return node.path+"/index.html"
		Else
			Return "/index.html"
		EndIf
	End Method
	
	Method ResolveLink$( link$ )
		Local id$=link.ToLower()

		Local node:TDocNode=FindNode( doc,id )
		
		If Not node 
			node=FindNode( TDocNode.ForPath( "/" ),id )
		EndIf
		
		If Not node 
			Print "Error: Unable to resolve link '"+link+"'"
			Return link
		EndIf

		Local url$=nodeURL( node )
		
		'optimize links...
		If url.StartsWith( docURL+"#" )
			url=url[ docURL.length.. ]
		Else If url.StartsWith( doc.path+"/" )
			url="~q"+url[ doc.path.length+1.. ]+"~q"
			Local tpos=url.Find( "#",2 )
			If tpos&gt;1 url="~q"+url[tpos..]
		Else
			url="~q"+relRootDir+url+"~q"
		EndIf
		Return "&lt;a href="+url+"&gt;"+link+"&lt;/a&gt;"
	End Method
	
	Method EmitDoc( node:TDocNode )
		
		Print "Building: "+node.id
		
		html=""
		doc=node
		children=New TMap
		docURL=NodeURL( doc )
		absDocDir=BmxDocDir+ExtractDir( docURL )
		relRootDir=""

		Local p$=ExtractDir( docURL )
		While p&lt;&gt;"/"
			If relRootDir relRootDir:+"/"
			relRootDir:+".."
			p=ExtractDir( p )
		Wend
		If Not relRootDir relRootDir="."

		CreateDir absDocDir,True
		
		If doc.docDir CopyDir doc.docDir,absDocDir

		If docURL.EndsWith( "/index.html" )
			Local intro$=absDocDir+"/index.bbdoc"
			If FileType( intro )&lt;&gt;FILETYPE_FILE intro$=absDocDir+"/intro.bbdoc"
			If FileType( intro )=FILETYPE_FILE
				Local t$=LoadText( intro )
				If t.find( "commands.html" )&lt;&gt;-1
					Print "Error: Document contains 'commands.html'"
				EndIf
				doc.about=t+doc.about
			EndIf
		EndIf

		For Local t:TDocNode=EachIn doc.children

			Local list:TList=TList( children.ValueForKey( t.kind ) )
			If Not list
				list=New TList
				children.Insert t.kind,list
			EndIf

			list.AddLast t
			
			'update commands.txt
			Select t.kind
			Case "Keyword"
				commands.Insert t.id+" : "+t.bbdoc,NodeURL( t )
			Case "Const","Global","Function","Type"	',"Module"
				Local i=t.proto.Find( " " )
				If i&lt;&gt;-1 commands.Insert t.proto[i+1..].Trim()+" : "+t.bbdoc,NodeURL( t )
			End Select
		Next
		
		EmitHeader
		
		For Local t$=EachIn NodeKinds
			EmitLinks t
		Next
		
		For Local t$=EachIn LeafKinds
			EmitLinks t
		Next
		
		For Local t$=EachIn LeafKinds
			EmitDecls t
		Next
		
		EmitFooter
		
		html=BBToHtml( html,Self )
		
		SaveText html,BmxDocDir+docURL

		For Local t$=EachIn NodeKinds
			EmitNodes t
		Next
	
	End Method
	
	Method EmitNodes( kind$ )
		Local list:TList=TList( children.ValueForKey( kind ) )
		If Not list Return
		For Local t:TDocNode=EachIn list
			EmitDoc t
		Next
	End Method
	
	Method Emit( t$ )
		html:+t+"~n"
	End Method
	
	Method ChildList:TList( kind$ )
		Return TList( children.ValueForKey( kind ) )
	End Method
	
	Method EmitHeader() Abstract
	
	Method EmitFooter() Abstract
	
	Method EmitLinks( kind$ ) Abstract
	
	Method EmitDecls( kind$ ) Abstract
	
End Type
</textarea> <br><br></td></tr></table><br>
<a name="1038463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a few fixes and new features for makedocs.<br><br>Changes so far are:<br>- html links to all third party modules in the modules section, no need to use the sidebar<br>- 'Rem bbdoc:' on same line for 2 line descriptions<br>- fixed loading example files for type subfolders<br><br>Source file (from v 1.41) and the patch.<br><br>makedocs.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- makedocs-old.bmx	2010-07-13 03:54:59.000000000 +0100
+++ makedocs.bmx	2010-08-27 09:14:39.358077645 +0100
@@ -19,6 +19,9 @@
 
 system_ "~q"+BlitzMaxPath()+"/bin/docmods~q"
 
+Local tps$,tpdir$=BlitzMaxPath()+"/docs/html/Modules/Third party"
+If FileType( tpdir+"/index.html" ) tps=LoadText( tpdir+"/index.html" )
+
 Local style:TDocStyle=New TFredborgStyle
 
 DeleteDir BmxDocDir,True
@@ -46,6 +49,15 @@
 
 Cleanup BmxDocDir
 
+If FileType( tpdir )=0 CreateDir( tpdir )
+If tps.length SaveText tps,tpdir+"/index.html"
+
+Local tpfile$=tpdir[..tpdir.FindLast( "/" )]+"/index.html"
+If FileType( tpfile ) tps=LoadText( tpfile )
+Local tpi=tps.Find( "&lt;/table&gt;",tps.FindLast( "&lt;/a&gt;" ) )
+tps=tps[..tpi]+"&lt;tr&gt;&lt;td class=docleft width=1%&gt; &lt;a href='Third party/index.html'&gt;Third party&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;"+tps[tpi..]
+If FileType( tpdir+"/index.html" ) SaveText tps,tpfile
+
 '*****
 
 Function Cleanup( dir$ )
@@ -117,7 +129,7 @@
 	Local docDir$=ExtractDir( filePath )+"/doc"
 	If FileType( docDir )&lt;&gt;FILETYPE_DIR docDir=""
 
-	Local inrem,typePath$,section$
+	Local inrem,typePath$,section$,subDir$,intype
 	
 	Local bbdoc$,returns$,about$,keyword$,params:TList
 	
@@ -138,6 +150,15 @@
 			i:+1
 		EndIf
 		
+		If tline[..3]="rem" And tline.length&gt;10
+			Local tpos=tline.Find( "bbdoc:" )
+			If tpos&lt;&gt;-1
+				id="bbdoc:"
+				inrem=True
+				i=tpos+6
+			EndIf
+		EndIf
+		
 		If inrem
 		
 			If id="endrem"
@@ -195,6 +216,7 @@
 			If typePath
 				docPath=typePath
 				typePath=""
+				intype=0
 			EndIf
 			
 		Else If id="import" Or id="include"
@@ -237,6 +259,8 @@
 					typePath=docPath
 					docPath:+"/"+id
 					path=docPath
+					intype=1
+					subDir=""
 				Case "Module"
 					If docPath Throw "Doc path already set"
 					If bbdoc.FindLast( "/" )=-1
@@ -271,7 +295,13 @@
 				
 				If kind="Module" node.docDir=docDir
 				
-				Local tmpExampleFilePath$ = CasedFileName(docDir+"/"+id+".bmx")
+				If kind="Method" Or kind="Function"
+					subDir=path[..path.FindLast("/",1)]
+					subDir=subDir[subDir.FindLast("/",1)..]
+				EndIf
+				If intype=0 subDir=""
+				
+				Local tmpExampleFilePath$ = CasedFileName(docDir+subDir+"/"+id+".bmx")
 				If docDir And FileType( tmpExampleFilePath )=FILETYPE_FILE
 					node.example=StripDir(tmpExampleFilePath)
 				EndIf
</textarea><br><br>makedocs.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem

Build new style docs.

Only builds official docs and brl, maxgui and pub modules.

Calls 'docmods' first, which builds 3rd party modules.

End Rem

Strict

Framework BRL.Basic

Import "docnode.bmx"

Import "fredborgstyle.bmx"

system_ "~q"+BlitzMaxPath()+"/bin/docmods~q"

Local tps$,tpdir$=BlitzMaxPath()+"/docs/html/Modules/Third party"
If FileType( tpdir+"/index.html" ) tps=LoadText( tpdir+"/index.html" )

Local style:TDocStyle=New TFredborgStyle

DeleteDir BmxDocDir,True

CopyDir BlitzMaxPath()+"/docs/src",BmxDocDir

Local root:TDocNode=TDocNode.Create( "BlitzMax Help","/","/" )
root.about=LoadText( BmxDocDir+"/index.html" )

DocMods

DocBBDocs "/"

style.EmitDoc TDocNode.ForPath( "/" )

Local t$
For Local kv:TKeyValue=EachIn TDocStyle.commands
	t:+String( kv.Key() )+"|/docs/html"+String( kv.Value() )+"~n"
Next

Local p$=BlitzMaxPath()+"/doc/bmxmods/commands.txt"
If FileType( p )=FILETYPE_FILE t:+LoadText( p )

SaveText t,BmxDocDir+"/Modules/commands.txt"

Cleanup BmxDocDir

If FileType( tpdir )=0 CreateDir( tpdir )
If tps.length SaveText tps,tpdir+"/index.html"

Local tpfile$=tpdir[..tpdir.FindLast( "/" )]+"/index.html"
If FileType( tpfile ) tps=LoadText( tpfile )
Local tpi=tps.Find( "&lt;/table&gt;",tps.FindLast( "&lt;/a&gt;" ) )
tps=tps[..tpi]+"&lt;tr&gt;&lt;td class=docleft width=1%&gt; &lt;a href='Third party/index.html'&gt;Third party&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;"+tps[tpi..]
If FileType( tpdir+"/index.html" ) SaveText tps,tpfile

'*****

Function Cleanup( dir$ )
	For Local e$=EachIn LoadDir( dir )
		Local p$=dir+"/"+e
		Select FileType( p )
		Case FILETYPE_DIR
			Cleanup p
		Case FILETYPE_FILE
			If ExtractExt( e )="bbdoc"
				DeleteFile p
			Else If e.ToLower()="commands.html"
				DeleteFile p
			EndIf
		End Select
	Next
End Function

Function DocMods()

	For Local modid$=EachIn EnumModules()

		If Not modid.StartsWith( "brl." ) And Not modid.StartsWith( "pub." ) And Not modid.StartsWith("maxgui.") Continue

		Local p$=ModuleSource( modid )
		Try
			docBmxFile p,""
		Catch ex$
			Print "Error:"+ex
		End Try
	Next

End Function

Function DocBBDocs( docPath$ )

	Local p$=BmxDocDir+docPath
	
	For Local e$=EachIn LoadDir( p )

		Local q$=p+"/"+e

		Select FileType( q )
		Case FILETYPE_FILE
			Select ExtractExt( e )
			Case "bbdoc"
				Local id$=StripExt( e )
				If id="index" Or id="intro" Continue
				
				Local path$=(docPath+"/"+id).Replace( "//","/" )
				Local node:TDocNode=TDocNode.Create( id,path,"/" )
				
				node.about=LoadText( q )
			End Select
		Case FILETYPE_DIR
			DocBBDocs docPath+"/"+e
		End Select
	Next
	
End Function

Function docBmxFile( filePath$,docPath$ )

	If FileType( filePath )&lt;&gt;FILETYPE_FILE
		Print "Error: Unable to open '"+filePath+"'"
		Return
	EndIf

	Local docDir$=ExtractDir( filePath )+"/doc"
	If FileType( docDir )&lt;&gt;FILETYPE_DIR docDir=""

	Local inrem,typePath$,section$,subDir$,intype
	
	Local bbdoc$,returns$,about$,keyword$,params:TList
	
	Local text$=LoadText( filepath )
	
	For Local line$=EachIn text.Split( "~n" )

		line=line.Trim()
		Local tline$=line.ToLower()
		
		Local i
		Local id$=ParseIdent( tline,i )
		
		If id="end" id:+ParseIdent( tline,i )
		
		If i&lt;tline.length And tline[i]=Asc(":")
			id:+":"
			i:+1
		EndIf
		
		If tline[..3]="rem" And tline.length&gt;10
			Local tpos=tline.Find( "bbdoc:" )
			If tpos&lt;&gt;-1
				id="bbdoc:"
				inrem=True
				i=tpos+6
			EndIf
		EndIf
		
		If inrem
		
			If id="endrem"
			
				inrem=False
				
			Else If id="bbdoc:"
			
				bbdoc=line[i..].Trim()
				keyword=""
				returns=""
				about=""
				params=Null
				section="bbdoc"

			Else If bbdoc 
			
				Select id
				Case "keyword:"
					keyword=line[i..].Trim()
					section="keyword"
				Case "returns:"
					returns=line[i..].Trim()+"~n"
					section="returns"
				Case "about:"
					about=line[i..].Trim()+"~n"
					section="about"
				Case "param:"
					If Not params params=New TList
					params.AddLast line[6..].Trim()
					section="param"
				Default
					Select section
					Case "about"
						about:+line+"~n"
					Case "returns"
						returns:+" "+line
					Case "param"
						params.AddLast String( params.RemoveLast() )+" "+line
					Default
						'remaining sections 1 line only...
						If line Print "Error: Illegal bbdoc section in '"+filePath+"'"
					End Select
				End Select
			
			EndIf
		
		Else If id="rem"
		
			bbdoc=""
			inrem=True
			
		Else If id="endtype"

			If typePath
				docPath=typePath
				typePath=""
				intype=0
			EndIf
			
		Else If id="import" Or id="include"
		
			Local p$=ExtractDir( filePath )+"/"+ParseString( line,i )
			
			If ExtractExt( p ).ToLower()="bmx"
				docBmxFile p,docPath
			EndIf
		
		Else If bbdoc
		
			Local kind$,proto$
			
			If keyword
				id=keyword
				kind="Keyword"
				If id.StartsWith( "~q" ) And id.EndsWith( "~q" )
					id=id[1..id.length-1]
				EndIf
				proto=id
			Else If id
				For Local t$=EachIn AllKinds
					If id&lt;&gt;t.ToLower() Continue
					kind=t
					proto=line
					id=ParseIdent( line,i )
					Exit
				Next
			EndIf
			
			If kind

				Local path$

				Select kind
				Case "Type"
					If Not docPath Throw "No doc path"
					If typePath Throw "Type path already set"
					typePath=docPath
					docPath:+"/"+id
					path=docPath
					intype=1
					subDir=""
				Case "Module"
					If docPath Throw "Doc path already set"
					If bbdoc.FindLast( "/" )=-1
						bbdoc="Other/"+bbdoc
					EndIf
					docPath="/Modules/"+bbdoc
					path=docPath
					Local i=bbdoc.FindLast( "/" )
					bbdoc=bbdoc[i+1..]
				Default
					If Not docPath Throw "No doc path"
					path=docPath+"/"+id
				End Select
				
				Local i=proto.Find( ")=" )
				If i&lt;&gt;-1 
					proto=proto[..i+1]
					If id.StartsWith( "Sort" ) proto:+" )"	'lazy!!!!!
				EndIf
				i=proto.Find( "=New" )
				If i&lt;&gt;-1
					proto=proto[..i]
				EndIf
				
				Local node:TDocNode=TDocNode.Create( id,path,kind )
				
				node.proto=proto
				node.bbdoc=bbdoc
				node.returns=returns
				node.about=about
				node.params=params
				
				If kind="Module" node.docDir=docDir
				
				If kind="Method" Or kind="Function"
					subDir=path[..path.FindLast("/",1)]
					subDir=subDir[subDir.FindLast("/",1)..]
				EndIf
				If intype=0 subDir=""
				
				Local tmpExampleFilePath$ = CasedFileName(docDir+subDir+"/"+id+".bmx")
				If docDir And FileType( tmpExampleFilePath )=FILETYPE_FILE
					node.example=StripDir(tmpExampleFilePath)
				EndIf
				
			EndIf
			
			bbdoc=""

		EndIf
	Next
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1038616"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is lots of bug fixes and new features for docmods via docparser.bmx.<br><br>Changes include:<br>- added escape character parsing for '~#', '~@', '~%', '~|' and '~~'<br>- removed full stops added to end of paragraphs, single line docs are better without one<br>- added '#' links, for example '#brl.basic', '#Print', '#{User guide}', '#bah.regex', etc<br>- added '{{' and '}}' for &lt;pre&gt; tags and removed '&amp;' for &lt;pre&gt; as it's not supported in makedocs<br>- added '[', ']' and '*' for &lt;ul&gt; and &lt;li&gt; bullets, if '|' found then it's a table with '*' for &lt;tr&gt; and '|' for &lt;td&gt;<br>- added '+' for &lt;h1&gt; header tags, in intro.bbdoc the first '+' is &lt;h1&gt;thereafter it is &lt;h2&gt;<br>- removed module description printing as header in introduction<br>- added navbar for types instead of just type headers<br>- fixed example links not working if filename in lowercase<br>- changed type summary tables width from 90% to 95%, all type tables are now 95%<br>- more robust parsing of bbdoc rem tags, about: doesn't have to be last<br>- added 'param:' bbdoc rem tag, limited to one line but multiple entries are supported<br>- some other minor fixes<br><br>Source file (from v 1.41) and the patch.<br><br>docparser.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- docparser-old.bmx	2010-07-13 03:54:59.000000000 +0100
+++ docparser.bmx	2010-08-27 12:42:25.287548683 +0100
@@ -11,11 +11,23 @@
 		i=t.Find( bbTag,i )
 		If i=-1 Exit
 		
-		If i And t[i-1]&gt;32
+		If i And t[i-1]&gt;4096
 			i:+1
 			Continue
 		EndIf
 
+		If t[i-1..i+1]="~~@" Or t[i-1..i+1]="~~%"
+			i:+2
+			Continue
+		EndIf
+		
+		If t[i..i+2]="~~~~" i:+1
+		
+		If t[i]=Asc("%") And Not (IsAlphaNumeric(t[i+1]) Or t[i+1]=Asc("_"))
+			i:+2
+			Continue
+		EndIf
+		
 		Local e		
 		If i&lt;t.length-1 And t[i+1]=Asc("{")
 			Local e=t.Find( "}",i+2 )
@@ -24,6 +36,7 @@
 				Continue
 			EndIf
 			Local q$="&lt;"+htmlTag+"&gt;"+t[i+2..e]+"&lt;/"+htmlTag+"&gt;"
+			If htmlTag="" q=t[i+1..e]
 			t=t[..i]+q+t[e+1..]
 			i:+q.length
 			
@@ -40,6 +53,7 @@
 				e:+1
 			Wend
 			Local q$="&lt;"+htmlTag+"&gt;"+t[i+1..e]+"&lt;/"+htmlTag+"&gt;"
+			If htmlTag="" q=t[i+1..e]
 			t=t[..i]+q+t[e..]
 			i:+q.length
 		EndIf
@@ -52,7 +66,7 @@
 	
 	If i=-1 Return False
 	
-	If i&gt;0 And text[i-1]&gt;32 Return False
+	If i&gt;0 And text[i-1]&gt;4096 Return False
 	
 	e=i+1
 	While e&lt;text.length
@@ -69,14 +83,37 @@
 
 Function FormatText( t$ Var )
 
-	If t.length And IsAlphaNumeric( t[t.length-1] ) t:+"."
-
-	Local i,e
-
+	Local i,e,q,y,z
+	
 	'do links
 	i=0
 	While FindIdent( "#",t,i,e )
 	
+		If t[i-1..i+1]="~~#"
+			i:+2
+			Continue
+		EndIf
+		
+		If t.Find( "&lt;a",i-12 )&lt;&gt;-1 '&lt;a href=#
+			q=t.Find( "&lt;/a",i )
+			If q&lt;&gt;-1 i=q
+			i:+4
+			Continue
+		EndIf
+		
+		If t[i..i+2]="#{"
+			e=t.Find( "}",i+2 )
+			t=t[..i+1]+t[i+2..e]+t[e+1..]		
+			e:-1
+		EndIf
+		
+		If t[e..e+1]="#"
+			q=t.Find( " ",e+1 )
+			If q=-1 e=t.Find( "~t",e+1 )
+			If q=-1 e=t.Find( "~n",e+1 )
+			If q&lt;&gt;-1 e=q
+		EndIf
+		
 		While e&lt;t.length-1 And t[e]=Asc(".") And IsAlpha( t[e+1] )
 			e:+2
 			While e&lt;t.length And IsAlpha(t[e])
@@ -84,27 +121,100 @@
 			Wend
 		Wend
 		
-		Local id$=t[i+1..e],q=id.Find("."),ln$
-
+		Local ln$,s$,s2$,s3$
+		Local id$=t[i+1..e].ToLower()
+		q=id.Find( "." )
+		
+		'brl doc names
 		If q=-1
-			ln="&lt;a href=#"+id+"&gt;"+id+"&lt;/a&gt;"
+			ln="../../../../docs/html/"
+			z=id.Find( "/" )
+			If z&lt;&gt;-1 id=id[z+1..]
+			For s=EachIn LoadDir( ln )
+				If FileType( ln+s )=2
+					If z=-1 And id=s.ToLower() Exit
+					For s2=EachIn LoadDir( ln+s )
+						If FileType( ln+s+"/"+s2 )=2
+							If z=-1 And id=s2.ToLower() Exit
+							For s3=EachIn LoadDir( ln+s+"/"+s2 )
+								If FileType( ln+s+"/"+s2+"/"+s3 )=2
+									If id=s3.ToLower() Exit
+								EndIf
+							Next
+						EndIf
+						If id=s3.ToLower() Exit Else s3=Null
+					Next
+				EndIf
+				If id=s3.ToLower() Exit
+				If id=s2.ToLower() Exit Else s2=Null
+			Next
+			If s2=Null And s3=Null And id&lt;&gt;s.ToLower() s=Null
+			If s
+				If s2 s:+"/"+s2
+				If s3 s:+"/"+s3
+				id=t[i+1..e]
+				ln="&lt;a href='../../../../docs/html/"+s+"/index.html'&gt;"+id+"&lt;/a&gt;"
+				
+			'command names
+			Else
+				id=t[i+1..e]
+				ln="../../../../docs/html/Modules/commands.txt"
+				Local stream:TStream=ReadStream( ln )
+				If stream
+					s=stream.ReadString( StreamSize( stream ) )
+					y=0 ; z=0
+					While z&lt;s.length-1
+						z=s.Find( "~n",z+1 )
+						s2=s[y..z]
+						y=z+1
+						If s2.StartsWith( id ) Exit
+					Wend
+					stream.Close()
+					z=s2.Find( "|/" )
+					s=s2[z+1..].Trim()
+				EndIf
+				ln="&lt;a href='../../../.."+s+"'&gt;"+id+"&lt;/a&gt;"
+			EndIf
+			
+		'brl mod names
 		Else
-			ln="&lt;a href=../../../"
-			Repeat
-				ln:+id[..q]+".mod/"
-				id=id[q+1..]
-				q=id.Find(".")
-			Until q=-1
-			ln:+"doc/commands.html#"+id+"&gt;"+id+"&lt;/a&gt;"
+			If id.StartsWith( "brl." ) Or id.StartsWith( "pub." ) Or id.StartsWith( "maxgui." )
+				ln="../../../"+id[..q]+".mod/"+id[q+1..]+".mod/"+id[q+1..]+".bmx"
+				Local stream:TStream=ReadStream( ln )
+				If stream
+					s=stream.ReadString( StreamSize( stream ) )
+					y=0 ; z=0
+					While z&lt;s.length-1
+						z=s.Find( "~n",z+1 )
+						s2=s[y..z]
+						y=s2.Find( "bbdoc:" )
+						If y&lt;&gt;-1 Exit
+						y=z+1
+					Wend
+					stream.Close()
+					s=s2[y+6..].Trim()
+				EndIf
+				id=t[i+1..e]
+				ln="&lt;a href='../../../../docs/html/Modules/"+s+"/index.html'&gt;"+id+"&lt;/a&gt;"
+				
+			'third party mod names
+			Else
+				ln="../../../"+id[..q]+".mod/"+id[q+1..]+".mod//doc/commands.html"
+				If FileType( ln )=1
+					id=t[i+1..e]
+					ln="&lt;a href='../../../"+id[..q]+".mod/"+id[q+1..]+".mod/doc/commands.html'&gt;"+id+"&lt;/a&gt;"
+				Else
+					ln=id
+				EndIf
+			EndIf
 		EndIf
-			
+		
 		t=t[..i]+ln+t[e..]
 		i:+ln.length
 	Wend
 	
 	FormatTags t,"@","b"
 	FormatTags t,"%","i"
-	FormatTags t,"&amp;","pre"
 	
 	'do tables
 	i=0
@@ -112,23 +222,59 @@
 		i=t.Find( "~n[",i )
 		If i=-1 Exit
 		
-		Local i2=t.Find( "~n]",i+3 )
-		If i2=-1 Exit
+		Local e=t.Find( "~n]",i+3 )
+		If e=-1 Exit
+				
+		Local q$=t[i+2..e]
+		Local u=q.Find( " | " )
+		If u=-1
+			q=q.Replace( "* ","~n&lt;li&gt;" )
+			q="~n&lt;ul&gt;"+q+"&lt;/ul&gt;"
+		Else
+			q=q.Replace( "* ","&lt;/td&gt;&lt;/tr&gt;~n&lt;tr&gt;&lt;td&gt;" )
+			q=q.Replace( " | ","&lt;/td&gt;&lt;td&gt;" )
+			q="~n&lt;table&gt;&lt;tr&gt;&lt;td&gt;"+q+"&lt;/table&gt;"
+		EndIf
+		t=t[..i]+q+t[e+2..]
+		i:+q.length
+	Forever
+	
+	'strip tildes
+	FormatTags t,"~~",""
+	
+	'do pre
+	i=0
+	Repeat
+		i=t.Find( "~n{{",i )
+		If i=-1 Exit
+		
+		Local e=t.Find( "~n}}",i+3 )
+		If e=-1 Exit
 		
-		Local q$=t[i+2..i2]
-
-		q=q.Replace( "* ","&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;" )
-		q=q.Replace( " | ","&lt;/td&gt;&lt;td&gt;" )
+		Local q$="~n&lt;pre&gt;"+t[i+3..e].Trim()+"&lt;/pre&gt;"
+		t=t[..i]+q+t[e+3..]
+		i:+q.length
+	Forever
+	
+	'do headers
+	Local h$="h1"
+	i=0
+	Repeat
+		i=t.Find( "+",i )
+		If i=-1 Exit
+		If t[i-1..i]&lt;&gt;"~n" And i&gt;0 i:+1 ; Continue
 		
-		q="~n&lt;table&gt;&lt;tr&gt;&lt;td&gt;"+q+"&lt;/table&gt;~n"
+		Local e=t.Find( "~n",i+2 )
+		If e=-1 e=t.length
 		
-		t=t[..i]+q+t[i2+2..]
+		Local q$="~n&lt;"+h+"&gt;"+t[i+1..e]+"&lt;/"+h+"&gt;"
+		t=t[..i]+q+t[e..]
 		i:+q.length
-
+		h="h2"
 	Forever
 	
 	'paras
-	t=t.Replace( "~n~n","~n&lt;p&gt;~n" )
+	t=t.Replace( "~n~n","~n&lt;p&gt;" )
 	
 End Function
 
@@ -178,24 +324,24 @@
 		If kind=T_MODULE Return -1
 		If t.kind=T_MODULE Return 1
 		
+		If kind=T_TYPE Return -1
+		If t.kind=T_TYPE Return 1
+		
 		If kind=T_CONST Return -1
 		If t.kind=T_CONST Return 1
-
-		If kind=T_GLOBAL Return -1
-		If t.kind=T_GLOBAL Return 1
 		
 		If kind=T_FIELD Return -1
 		If t.kind=T_FIELD Return 1
-
+		
+		If kind=T_GLOBAL Return -1
+		If t.kind=T_GLOBAL Return 1
+		
 		If kind=T_METHOD Return -1
 		If t.kind=T_METHOD Return 1
 
 		If kind=T_FUNCTION Return -1
 		If t.kind=T_FUNCTION Return 1
 		
-		If kind=T_TYPE Return -1
-		If t.kind=T_TYPE Return 1
-		
 		If kind=T_EOL Return -1
 		If t.kind=T_EOL Return 1
 		
@@ -218,9 +364,9 @@
 
 	End Method
 	
-	Method EmitHtml$(summary:Int = False)
+	Method EmitHtml$( summary:Int=False,protoname:String=Null )
 		Local example$
-
+		
 		Local stream:TStream=ReadStream( ident+".bmx" )
 		If stream
 			While Not stream.Eof()
@@ -244,47 +390,41 @@
 				Local n_keywords:Int
 				For Local t:TDocs=EachIn kids
 					Select t.kind
-					Case T_CONST n_consts:+1
-					Case T_GLOBAL n_globals:+1
-					Case T_FUNCTION n_functions:+1
 					Case T_TYPE
 						' Type is doc'd or there are doc'd kids
 						If t.bbdoc Or t.kids.count() &gt; 0 Then
 							n_types:+1
 						End If
+					Case T_CONST n_consts:+1
+					Case T_GLOBAL n_globals:+1
+					Case T_FUNCTION n_functions:+1
 					Case T_EOL n_keywords:+1
 					End Select
 				Next
 				
+				'Module navbar
 				TPrint "&lt;table width=100% cellspacing=0&gt;&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
 				TPrint "&lt;td class=small width=1%&gt;&lt;b&gt;"+ident+":&lt;/b&gt;&lt;/td&gt;"
-				If n_consts TPrint "&lt;td class=small width=1%&gt;&lt;a href=#consts class=small&gt;Constants&lt;/a&gt;&lt;/td&gt;"
+				If n_types TPrint "&lt;td class=small width=1%&gt;&lt;a href=#types class=small&gt;Types&lt;/a&gt;&lt;/td&gt;"
+				If n_consts TPrint "&lt;td class=small width=1%&gt;&lt;a href=#consts class=small&gt;Consts&lt;/a&gt;&lt;/td&gt;"
 				If n_globals TPrint "&lt;td class=small width=1%&gt;&lt;a href=#globals class=small&gt;Globals&lt;/a&gt;&lt;/td&gt;"
 				If n_functions TPrint "&lt;td class=small width=1%&gt;&lt;a href=#functions class=small&gt;Functions&lt;/a&gt;&lt;/td&gt;"
-				If n_types TPrint "&lt;td class=small width=1%&gt;&lt;a href=#types class=small&gt;Types&lt;/a&gt;&lt;/td&gt;"
 				If n_keywords TPrint "&lt;td class=small width=1%&gt;&lt;a href=#keywords class=small&gt;Keywords&lt;/a&gt;&lt;/td&gt;"
-				
 				If Not infos.IsEmpty()
 					TPrint "&lt;td class=small width=1%&gt;&lt;a href=#modinfo class=small&gt;Modinfo&lt;/a&gt;&lt;/td&gt;"
 				EndIf
-				
 				Local t$=ModuleSource( ident.ToLower() )
 				Local i=t.Find( "/mod/" )
 				If i&lt;&gt;-1
 					t="../../../.."+t[i..]
 					TPrint "&lt;td class=small width=1%&gt;&lt;a href='"+t+"' class=small&gt;Source&lt;/a&gt;&lt;/td&gt;"
 				EndIf
-				TPrint "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"
+				TPrint "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;"
 				
 				Local stream:TStream=ReadStream( "intro.bbdoc" )
-				
-				If stream
-					TPrint "&lt;h1&gt;"+textCache.shortdesc+"&lt;/h1&gt;"
-					If textCache.longdesc TPrint textCache.longdesc.Trim()
-				Else
+				If Not stream
 					stream=ReadStream( "intro.html" )
 					If Not stream
-						TPrint "&lt;h1&gt;"+textCache.shortdesc+"&lt;/h1&gt;"
 						If textCache.longdesc TPrint textCache.longdesc.Trim()
 					EndIf
 				EndIf
@@ -310,107 +450,142 @@
 				If Not kids.IsEmpty()
 					Local s:String = Null
 					Local tkind=0
-					Local count:Int = 0
 					For Local doc:TDocs=EachIn kids
 						' kind is Type and is not doc'd and there are no doc'd kids
-						If doc.kind = T_TYPE And (Not doc.bbdoc And doc.kids.count() = 0) Then
+						If doc.kind = T_TYPE And (Not doc.bbdoc And doc.kids.Count() = 0) Then
 							Continue
 						End If
-					
-						s = "&lt;table class=doc width=100%&gt;"
-						
+						s="&lt;p&gt;&lt;table width=100%&gt;&lt;tr&gt;&lt;td class=blank colspan=2 align=left&gt;"
 						If kind&lt;&gt;T_TYPE And doc.kind&lt;&gt;tkind
-							count = 0
-							If tkind &lt;&gt; 0 Then
-								If tkind = T_CONST Or tkind = T_GLOBAL Or tkind = T_EOL Then
-									TPrint "&lt;/td&gt;&lt;/tr&gt;"
-								End If
-								TPrint "&lt;/table&gt;"
-							End If
+						If tkind&lt;&gt;0 TPrint "&lt;/table&gt;"
 							Select doc.kind
-								Case T_CONST TPrint "&lt;h2&gt;&lt;a name=consts&gt;&lt;/a&gt;Constants Summary&lt;/h2&gt;" + s + "&lt;tr&gt;&lt;td colspan=2&gt;"
-								Case T_GLOBAL TPrint "&lt;h2&gt;&lt;a name=globals&gt;&lt;/a&gt;Globals Summary&lt;/h2&gt;" + s + "&lt;tr&gt;&lt;td colspan=2&gt;"
-								Case T_FUNCTION TPrint "&lt;h2&gt;&lt;a name=functions&gt;&lt;/a&gt;Functions Summary&lt;/h2&gt;" + s
-								Case T_TYPE TPrint "&lt;h2&gt;&lt;a name=types&gt;&lt;/a&gt;Types Summary&lt;/h2&gt;" + s
-								Case T_EOL TPrint "&lt;h2&gt;&lt;a name=keywords&gt;&lt;/a&gt;Keywords Summary&lt;/h2&gt;" + s + "&lt;tr&gt;&lt;td colspan=2&gt;"
-								Default
-									Continue
+							Case T_TYPE TPrint s+"&lt;a name=types&gt;&lt;/a&gt;&lt;h2&gt;Types&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_CONST TPrint s+"&lt;a name=consts&gt;&lt;/a&gt;&lt;h2&gt;Consts&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_GLOBAL TPrint s+"&lt;a name=globals&gt;&lt;/a&gt;&lt;h2&gt;Globals&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_FUNCTION TPrint s+"&lt;a name=functions&gt;&lt;/a&gt;&lt;h2&gt;Functions&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_EOL TPrint s+"&lt;a name=keywords&gt;&lt;/a&gt;&lt;h2&gt;Keywords&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Default
+								Continue
+							End Select
+							tkind=doc.kind
+						EndIf
+						doc.EmitHtml( True,proto )
+					Next
+					If s TPrint "&lt;/table&gt;&lt;p&gt;"
+				EndIf
+			
+			'Type navbar
+			Case T_TYPE
+				TPrint "&lt;br&gt;&lt;table width=95% cellspacing=0 align=center id="+ident+"&gt;"
+				TPrint "&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
+				TPrint "&lt;td class=small width=1%&gt;&lt;b&gt;"+ident+":&lt;/b&gt;&lt;/td&gt;"
+				If Not kids.IsEmpty()
+					Local tkind=0
+					For Local doc:TDocs=EachIn kids
+						If doc.kind&lt;&gt;tkind
+							Select doc.kind
+							Case T_CONST
+								TPrint "&lt;td class=small width=1%&gt;"
+								TPrint "&lt;a href=#"+ident+"_consts class=small&gt;Consts&lt;/a&gt;&lt;/td&gt;"
+							Case T_FIELD
+								TPrint "&lt;td class=small width=1%&gt;"
+								TPrint "&lt;a href=#"+ident+"_fields class=small&gt;Fields&lt;/a&gt;&lt;/td&gt;"
+							Case T_GLOBAL
+								TPrint "&lt;td class=small width=1%&gt;"
+								TPrint "&lt;a href=#"+ident+"_globals class=small&gt;Globals&lt;/a&gt;&lt;/td&gt;"
+							Case T_METHOD
+								TPrint "&lt;td class=small width=1%&gt;"
+								TPrint "&lt;a href=#"+ident+"_methods class=small&gt;Methods&lt;/a&gt;&lt;/td&gt;"
+							Case T_FUNCTION
+								TPrint "&lt;td class=small width=1%&gt;"
+								TPrint "&lt;a href=#"+ident+"_functions class=small&gt;Functions&lt;/a&gt;&lt;/td&gt;"
+							Case T_EOL
+								TPrint "&lt;td class=small width=1%&gt;"
+								TPrint "&lt;a href=#"+ident+"_keywords class=small&gt;Keywords&lt;/a&gt;&lt;/td&gt;"
+							Default
+								Continue
 							End Select
 							tkind=doc.kind
 						EndIf
-						count:+ 1
-						If count &gt; 1 Then
-							If tkind = T_CONST Or tkind = T_GLOBAL Or tkind = T_EOL Then
-								TPrint ", "
-							End If
-						End If 
-						doc.EmitHtml(True)
 					Next
-					If s Then
-						TPrint "&lt;/table&gt;"
-					End If
 				EndIf
-						
+				TPrint "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;"
+				
+			'Reference tables
 			Default
-				TPrint "&lt;table class=doc width=100% cellspacing=3 id="+ident+"&gt;"
-				TPrint "&lt;tr&gt;&lt;td class=doctop colspan=2&gt;"+proto+"&lt;/td&gt;&lt;/tr&gt;"
+				If protoname.ToLower()[..4]="type"
+					Local s$=protoname[4..].Trim()
+					Local i=s.Find( " " )
+					If i=-1 i=s.length
+					TPrint "&lt;table width=95% cellspacing=3 align=center id="+s[..i]+"_"+ident+"&gt;"
+				Else
+					TPrint "&lt;table width=100% cellspacing=3 align=center id="+ident+"&gt;"
+				EndIf
+				If kind&lt;&gt;T_EOL
+					TPrint "&lt;tr&gt;&lt;td class=doctop colspan=2 align=left&gt;"+proto+"&lt;/td&gt;&lt;/tr&gt;"
+				Else
+					TPrint "&lt;tr&gt;&lt;td class=doctop colspan=2 align=left&gt;"+ident+"&lt;/td&gt;&lt;/tr&gt;"
+				EndIf
+				If textCache.parameters.Count()
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Parameters&lt;/td&gt;&lt;td class=docright&gt;"
+					For Local s$=EachIn textCache.parameters
+						TPrint s+"&lt;br&gt;"
+					Next
+					TPrint "&lt;/td&gt;&lt;/tr&gt;"
+				EndIf
 				If textCache.returns
-					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Returns&lt;/td&gt;&lt;td class=docright&gt;"+textCache.returns+"&lt;/td&gt;&lt;/tr&gt;"
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Returns&lt;/td&gt;"
+					TPrint "&lt;td class=docright&gt;"+textCache.returns+"&lt;/td&gt;&lt;/tr&gt;"
 				EndIf
 				If textCache.shortdesc
-					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Description&lt;/td&gt;&lt;td class=docright&gt;"+textCache.shortdesc+"&lt;/td&gt;&lt;/tr&gt;"
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Description&lt;/td&gt;"
+					TPrint "&lt;td class=docright&gt;"+textCache.shortdesc+"&lt;/td&gt;&lt;/tr&gt;"
 				EndIf
 				If textCache.longdesc
-					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Information&lt;/td&gt;&lt;td class=docright&gt;"+textCache.longdesc+"&lt;/td&gt;&lt;/tr&gt;"
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Information&lt;/td&gt;"
+					TPrint "&lt;td class=docright&gt;"+textCache.longdesc+"&lt;/td&gt;&lt;/tr&gt;"
 				EndIf
 				If example
-					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;&lt;a href="+ident+".bmx class=small&gt;Example&lt;/a&gt;&lt;/td&gt;&lt;td class=docright&gt;&lt;pre&gt;"+example+"&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;"
+					If FileType( CurrentDir()+"/"+ident+".bmx" )=0 ident=ident.ToLower()
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;&lt;a href="+ident+".bmx class=small&gt;Example&lt;/a&gt;"
+					TPrint "&lt;/td&gt;&lt;td class=docright&gt;&lt;pre&gt;"+example+"&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;"
 				EndIf
-				TPrint "&lt;/table&gt;"
+				TPrint "&lt;/table&gt;&lt;p&gt;"
 			End Select
 
 			If kind = T_TYPE Then
-				' Show summaries
+			' Show type summaries
 				If Not kids.IsEmpty()
 					Local s:String = Null
 					Local tkind=0
-					Local count:Int = 0
 					For Local doc:TDocs=EachIn kids
-						s = "&lt;table class=doc width=90% align=center&gt;" + ..
-							"&lt;tr &gt;&lt;th class=doctop colspan=2 align=left&gt;"
+						s="&lt;p&gt;&lt;table width=95% align=center&gt;&lt;tr&gt;&lt;td class=blank colspan=2 align=left&gt;"
 						If doc.kind&lt;&gt;tkind
-							count = 0
-							If tkind &lt;&gt; 0 Then
-								If tkind = T_CONST Or tkind = T_GLOBAL Or tkind = T_EOL Or tkind = T_FIELD Then
-									TPrint "&lt;/td&gt;&lt;/tr&gt;"
-								End If
-								TPrint "&lt;/table&gt;"
-							End If
+							If tkind&lt;&gt;0 TPrint "&lt;/table&gt;"
 							Select doc.kind
-								Case T_CONST TPrint s + "&lt;a name=" + ident + "_consts&gt;&lt;/a&gt;Constants Summary&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=2&gt;"
-								Case T_FIELD TPrint s + "&lt;a name=" + ident + "_fields&gt;&lt;/a&gt;Fields Summary&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=2&gt;"
-								Case T_GLOBAL TPrint s + "&lt;a name=" + ident + "_globals&gt;&lt;/a&gt;Globals Summary&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=2&gt;"
-								Case T_FUNCTION TPrint s + "&lt;a name=" + ident + "_functions&gt;&lt;/a&gt;Functions Summary&lt;/th&gt;&lt;/tr&gt;"
-								Case T_METHOD TPrint s + "&lt;a name=" + ident + "_methods&gt;&lt;/a&gt;Methods Summary&lt;/th&gt;&lt;/tr&gt;"
-								Default
-									Continue
+							Case T_CONST
+								TPrint s+"&lt;a name="+ident+"_consts&gt;&lt;/a&gt;&lt;h2&gt;Consts&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_FIELD
+								TPrint s+"&lt;a name="+ident+"_fields&gt;&lt;/a&gt;&lt;h2&gt;Fields&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_GLOBAL
+								TPrint s+"&lt;a name="+ident+"_globals&gt;&lt;/a&gt;&lt;h2&gt;Globals&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_METHOD
+								TPrint s+"&lt;a name="+ident+"_methods&gt;&lt;/a&gt;&lt;h2&gt;Methods&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_FUNCTION
+								TPrint s+"&lt;a name="+ident+"_functions&gt;&lt;/a&gt;&lt;h2&gt;Functions&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Case T_EOL
+								TPrint s+"&lt;a name="+ident+"_keywords&gt;&lt;/a&gt;&lt;h2&gt;Keywords&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
+							Default
+								Continue
 							End Select
 							tkind=doc.kind
 						EndIf
-						count:+ 1
-						If count &gt; 1 Then
-							If tkind = T_CONST Or tkind = T_GLOBAL Or tkind = T_FIELD Then
-								TPrint ", "
-							End If
-						End If 
-						doc.EmitHtml(True)
+						doc.EmitHtml( True,proto )
 					Next
-					If s Then
-						TPrint "&lt;/table&gt;"
-					End If
+					If s TPrint "&lt;/table&gt;&lt;p&gt;"
 				EndIf
 			End If
-
+			
 			If Not kids.IsEmpty()
 				Local tkind=0
 				For Local doc:TDocs=EachIn kids
@@ -418,42 +593,53 @@
 					If doc.kind = T_TYPE And (Not doc.bbdoc And doc.kids.count() = 0) Then
 						Continue
 					End If
-
-					If kind&lt;&gt;T_TYPE And doc.kind&lt;&gt;tkind
-						TPrint "&lt;h2"
-						Select doc.kind
-						Case T_CONST TPrint " id=constsdet&gt;Constants"
-						Case T_GLOBAL TPrint " id=globalsdet&gt;Globals"
-						Case T_FUNCTION TPrint " id=functionsdet&gt;Functions"
-						Case T_TYPE TPrint " id=typesdet&gt;Types"
-						Case T_FIELD TPrint "&gt;Fields"
-						Case T_METHOD TPrint "&gt;Methods"
-						Case T_EOL TPrint "&gt;Keywords"
-						End Select
-						TPrint "&lt;/h2&gt;"
+					
+					'Reference headers
+					If doc.kind&lt;&gt;tkind
+						If proto.ToLower()[..4]="type"
+							TPrint "&lt;table width=95% align=center&gt;"
+						Else
+							TPrint "&lt;table width=100% align=center&gt;"
+						EndIf
+						TPrint "&lt;tr&gt;&lt;td class=blank colspan=2 align=left&gt;&lt;a name=_blank&gt;&lt;/a&gt;"
+							Select doc.kind
+							Case T_TYPE TPrint "&lt;h2&gt;Type reference&lt;/h2&gt;"
+							Case T_CONST TPrint "&lt;h2&gt;Const reference&lt;/h2&gt;"
+							Case T_FIELD TPrint "&lt;h2&gt;Field reference&lt;/h2&gt;"
+							Case T_GLOBAL TPrint "&lt;h2&gt;Global reference&lt;/h2&gt;"
+							Case T_METHOD TPrint "&lt;h2&gt;Method reference&lt;/h2&gt;"
+							Case T_FUNCTION TPrint "&lt;h2&gt;Function reference&lt;/h2&gt;"
+							Case T_EOL TPrint "&lt;h2&gt;Keyword reference&lt;/h2&gt;"
+							End Select
+						TPrint "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"
 						tkind=doc.kind
 					EndIf
-					doc.EmitHtml
-					If kind&lt;&gt;T_TYPE TPrint "&lt;br&gt;"
+					doc.EmitHtml( False,proto )
 				Next
-			EndIf			
+			EndIf
+			
+		'Summary tables
 		Else
 			Select kind
-				Case T_CONST, T_GLOBAL, T_FIELD, T_EOL
-					TPrint "&lt;a href=#" + ident + "&gt;" + ident + "&lt;/a&gt;"
-				Case T_FUNCTION, T_METHOD, T_TYPE
-					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;&lt;a href=#" + ident + "&gt;" + ident + "&lt;/a&gt;&lt;/td&gt;&lt;td class=docright&gt;"
-					If textCache.shortdesc
-						TPrint textCache.shortdesc
-					Else
-						TPrint "&amp;nbsp;"
-					EndIf
-					TPrint "&lt;/td&gt;&lt;/tr&gt;"
+			Case T_TYPE,T_CONST,T_FIELD,T_GLOBAL,T_METHOD,T_FUNCTION,T_EOL
+				If protoname.ToLower()[..4]="type"
+					Local s$=protoname[4..].Trim()
+					Local i=s.Find( " " )
+					If i=-1 i=s.length
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;"
+					TPrint "&lt;a href=#"+s[..i]+"_"+ident+"&gt;"+ident+"&lt;/a&gt;"
+				Else
+					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;"
+					TPrint "&lt;a href=#"+ident+"&gt;"+ident+"&lt;/a&gt;"
+				EndIf
+				If textCache.shortdesc
+					TPrint "&lt;/td&gt;&lt;td class=docright&gt;"+textCache.shortdesc+"&lt;/td&gt;&lt;/tr&gt;"
+				Else
+					TPrint "&lt;/td&gt;&lt;td class=docright&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;"
+				EndIf
 			End Select
 		End If
 		
-
-		
 		Select kind
 		Case T_MODULE
 			If Not infos.IsEmpty()
@@ -652,29 +838,39 @@
 			FormatText this.shortdesc
 		EndIf
 		
-	     If d.Find( "returns:" )=0
-			Local i=d.Find("~n")
-			If i=-1 i=d.length
-			this.returns=d[8..i].Trim()
-			d=d[i+1..].Trim()
-			FormatText this.returns
-		Else If d.Find( "keyword:" )=0
-			Local i=d.Find("~n")
-			If i=-1 i=d.length
-			this.keyword=d[8..i].Trim()
-			d=d[i+1..].Trim()
+		i=d.Find( "keyword:" )
+		If i&lt;&gt;-1
+			Local e=d.Find( "~n",i )
+			If e=-1 e=d.length
+			this.keyword=d[i+8..e].Trim()
 			FormatText this.keyword
 		EndIf
-		While d.Find("parameter:") = 0
-			Local i=d.Find("~n")
-			If i=-1 i=d.length
-			Local param:String=d[10..i].Trim()
-			d=d[i+1..].Trim()
+		
+		i=d.Find( "returns:" )
+		If i&lt;&gt;-1
+			Local e=d.Find( "~n",i )
+			If e=-1 e=d.length
+			this.returns=d[i+8..e].Trim()
+			FormatText this.returns
+		EndIf
+		
+		i=d.Find( "param:" )
+		While i&lt;&gt;-1
+			Local e=d.Find( "~n",i )
+			If e=-1 e=d.length
+			Local param:String=d[i+6..e].Trim()
 			FormatText param
-			this.parameters.addLast(param)
+			this.parameters.AddLast( param )
+			i=d.Find( "param:",i+1 )
 		Wend
-		If d.Find( "about:" )=0
-			this.longdesc=d[6..].Trim()
+		
+		i=d.Find( "about:" )
+		If i&lt;&gt;-1
+			Local e=d.Find( "param:",i+6 )
+			If e=-1 e=d.Find( "returns:",i+6 )
+			If e=-1 e=d.Find( "keyword:",i+6 )
+			If e=-1 e=d.length
+			this.longdesc=d[i+6..e].Trim()
 			FormatText this.longdesc
 		EndIf	
 		
</textarea><br><br>docparser.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict

Import BRL.StandardIO
Import BRL.MaxUtil

Import "bmxtoker.bmx"

Function FormatTags( t$ Var,bbTag$,htmlTag$ )
	Local i
	Repeat
		i=t.Find( bbTag,i )
		If i=-1 Exit
		
		If i And t[i-1]&gt;4096
			i:+1
			Continue
		EndIf

		If t[i-1..i+1]="~~@" Or t[i-1..i+1]="~~%"
			i:+2
			Continue
		EndIf
		
		If t[i..i+2]="~~~~" i:+1
		
		If t[i]=Asc("%") And Not (IsAlphaNumeric(t[i+1]) Or t[i+1]=Asc("_"))
			i:+2
			Continue
		EndIf
		
		Local e		
		If i&lt;t.length-1 And t[i+1]=Asc("{")
			Local e=t.Find( "}",i+2 )
			If e=-1 
				i:+2
				Continue
			EndIf
			Local q$="&lt;"+htmlTag+"&gt;"+t[i+2..e]+"&lt;/"+htmlTag+"&gt;"
			If htmlTag="" q=t[i+1..e]
			t=t[..i]+q+t[e+1..]
			i:+q.length
			
		Else
			e=i+1
			While e&lt;t.length
				Local c=t[e]
				If c=Asc(".") And e+1&lt;t.length And IsAlpha( t[e+1] )
					e:+2
					Continue
				EndIf
				If c = Asc(";") Return
				If c&lt;&gt;Asc("_") And Not IsAlphaNumeric(c) Exit
				e:+1
			Wend
			Local q$="&lt;"+htmlTag+"&gt;"+t[i+1..e]+"&lt;/"+htmlTag+"&gt;"
			If htmlTag="" q=t[i+1..e]
			t=t[..i]+q+t[e..]
			i:+q.length
		EndIf
	Forever
End Function

Function FindIdent( pre$,text$,i Var,e Var )

	i=text.Find( pre,i )
	
	If i=-1 Return False
	
	If i&gt;0 And text[i-1]&gt;4096 Return False
	
	e=i+1
	While e&lt;text.length
		Local c=text[e]
		If c=Asc(".") And e+1&lt;text.length And IsAlpha( text[e+1] )
			e:+2
			Continue
		EndIf
		If c&lt;&gt;Asc("_") And Not IsAlphaNumeric(c) Exit
		e:+1
	Wend
	Return True
End Function

Function FormatText( t$ Var )

	Local i,e,q,y,z
	
	'do links
	i=0
	While FindIdent( "#",t,i,e )
	
		If t[i-1..i+1]="~~#"
			i:+2
			Continue
		EndIf
		
		If t.Find( "&lt;a",i-12 )&lt;&gt;-1 '&lt;a href=#
			q=t.Find( "&lt;/a",i )
			If q&lt;&gt;-1 i=q
			i:+4
			Continue
		EndIf
		
		If t[i..i+2]="#{"
			e=t.Find( "}",i+2 )
			t=t[..i+1]+t[i+2..e]+t[e+1..]		
			e:-1
		EndIf
		
		If t[e..e+1]="#"
			q=t.Find( " ",e+1 )
			If q=-1 e=t.Find( "~t",e+1 )
			If q=-1 e=t.Find( "~n",e+1 )
			If q&lt;&gt;-1 e=q
		EndIf
		
		While e&lt;t.length-1 And t[e]=Asc(".") And IsAlpha( t[e+1] )
			e:+2
			While e&lt;t.length And IsAlpha(t[e])
				e:+1
			Wend
		Wend
		
		Local ln$,s$,s2$,s3$
		Local id$=t[i+1..e].ToLower()
		q=id.Find( "." )
		
		'brl doc names
		If q=-1
			ln="../../../../docs/html/"
			z=id.Find( "/" )
			If z&lt;&gt;-1 id=id[z+1..]
			For s=EachIn LoadDir( ln )
				If FileType( ln+s )=2
					If z=-1 And id=s.ToLower() Exit
					For s2=EachIn LoadDir( ln+s )
						If FileType( ln+s+"/"+s2 )=2
							If z=-1 And id=s2.ToLower() Exit
							For s3=EachIn LoadDir( ln+s+"/"+s2 )
								If FileType( ln+s+"/"+s2+"/"+s3 )=2
									If id=s3.ToLower() Exit
								EndIf
							Next
						EndIf
						If id=s3.ToLower() Exit Else s3=Null
					Next
				EndIf
				If id=s3.ToLower() Exit
				If id=s2.ToLower() Exit Else s2=Null
			Next
			If s2=Null And s3=Null And id&lt;&gt;s.ToLower() s=Null
			If s
				If s2 s:+"/"+s2
				If s3 s:+"/"+s3
				id=t[i+1..e]
				ln="&lt;a href='../../../../docs/html/"+s+"/index.html'&gt;"+id+"&lt;/a&gt;"
				
			'command names
			Else
				id=t[i+1..e]
				ln="../../../../docs/html/Modules/commands.txt"
				Local stream:TStream=ReadStream( ln )
				If stream
					s=stream.ReadString( StreamSize( stream ) )
					y=0 ; z=0
					While z&lt;s.length-1
						z=s.Find( "~n",z+1 )
						s2=s[y..z]
						y=z+1
						If s2.StartsWith( id ) Exit
					Wend
					stream.Close()
					z=s2.Find( "|/" )
					s=s2[z+1..].Trim()
				EndIf
				ln="&lt;a href='../../../.."+s+"'&gt;"+id+"&lt;/a&gt;"
			EndIf
			
		'brl mod names
		Else
			If id.StartsWith( "brl." ) Or id.StartsWith( "pub." ) Or id.StartsWith( "maxgui." )
				ln="../../../"+id[..q]+".mod/"+id[q+1..]+".mod/"+id[q+1..]+".bmx"
				Local stream:TStream=ReadStream( ln )
				If stream
					s=stream.ReadString( StreamSize( stream ) )
					y=0 ; z=0
					While z&lt;s.length-1
						z=s.Find( "~n",z+1 )
						s2=s[y..z]
						y=s2.Find( "bbdoc:" )
						If y&lt;&gt;-1 Exit
						y=z+1
					Wend
					stream.Close()
					s=s2[y+6..].Trim()
				EndIf
				id=t[i+1..e]
				ln="&lt;a href='../../../../docs/html/Modules/"+s+"/index.html'&gt;"+id+"&lt;/a&gt;"
				
			'third party mod names
			Else
				ln="../../../"+id[..q]+".mod/"+id[q+1..]+".mod//doc/commands.html"
				If FileType( ln )=1
					id=t[i+1..e]
					ln="&lt;a href='../../../"+id[..q]+".mod/"+id[q+1..]+".mod/doc/commands.html'&gt;"+id+"&lt;/a&gt;"
				Else
					ln=id
				EndIf
			EndIf
		EndIf
		
		t=t[..i]+ln+t[e..]
		i:+ln.length
	Wend
	
	FormatTags t,"@","b"
	FormatTags t,"%","i"
	
	'do tables
	i=0
	Repeat
		i=t.Find( "~n[",i )
		If i=-1 Exit
		
		Local e=t.Find( "~n]",i+3 )
		If e=-1 Exit
				
		Local q$=t[i+2..e]
		Local u=q.Find( " | " )
		If u=-1
			q=q.Replace( "* ","~n&lt;li&gt;" )
			q="~n&lt;ul&gt;"+q+"&lt;/ul&gt;"
		Else
			q=q.Replace( "* ","&lt;/td&gt;&lt;/tr&gt;~n&lt;tr&gt;&lt;td&gt;" )
			q=q.Replace( " | ","&lt;/td&gt;&lt;td&gt;" )
			q="~n&lt;table&gt;&lt;tr&gt;&lt;td&gt;"+q+"&lt;/table&gt;"
		EndIf
		t=t[..i]+q+t[e+2..]
		i:+q.length
	Forever
	
	'strip tildes
	FormatTags t,"~~",""
	
	'do pre
	i=0
	Repeat
		i=t.Find( "~n{{",i )
		If i=-1 Exit
		
		Local e=t.Find( "~n}}",i+3 )
		If e=-1 Exit
		
		Local q$="~n&lt;pre&gt;"+t[i+3..e].Trim()+"&lt;/pre&gt;"
		t=t[..i]+q+t[e+3..]
		i:+q.length
	Forever
	
	'do headers
	Local h$="h1"
	i=0
	Repeat
		i=t.Find( "+",i )
		If i=-1 Exit
		If t[i-1..i]&lt;&gt;"~n" And i&gt;0 i:+1 ; Continue
		
		Local e=t.Find( "~n",i+2 )
		If e=-1 e=t.length
		
		Local q$="~n&lt;"+h+"&gt;"+t[i+1..e]+"&lt;/"+h+"&gt;"
		t=t[..i]+q+t[e..]
		i:+q.length
		h="h2"
	Forever
	
	'paras
	t=t.Replace( "~n~n","~n&lt;p&gt;" )
	
End Function

Type TDocs

	Field kind		'T_CONST, T_GLOBAL etc
	Field ident$	'identifier
	Field proto$	'Global/Function etc text
	Field bbdoc$	'rem/endrem bbdoc: text
	Field infos:TList=New TList	'ModuleInfo's
	Field imports:TList = New TList ' Added by BaH - 25/05/2006
	Field parent:TDocs ' Added by BaH - 25/05/2006
	Field textCache:TTextCache
	
	Field kids:TList=New TList
	
	Method Sort()
		kids.Sort
		For Local t:TDocs=EachIn kids
			t.Sort
		Next
	End Method
	
	' Added by BaH - 25/05/2006
	' Checks for extra references to the same imports...
	Method containsImport:Int(_file:String)
		If imports.contains(_file) Then
			Return True
		End If
		If parent &lt;&gt; Null Then
			Return parent.containsImport(_file)
		End If
		
		Return False
	End Method
	
	Method Compare( with:Object )
		Local t:TDocs=TDocs(with)

		If kind=t.kind
			If kind=T_MODULE 
				Return bbdoc.ToLower().Compare( t.bbdoc.ToLower() )
			EndIf
			Return ident.ToLower().Compare( t.ident.ToLower() )
		EndIf

		If kind=T_MODULE Return -1
		If t.kind=T_MODULE Return 1
		
		If kind=T_TYPE Return -1
		If t.kind=T_TYPE Return 1
		
		If kind=T_CONST Return -1
		If t.kind=T_CONST Return 1
		
		If kind=T_FIELD Return -1
		If t.kind=T_FIELD Return 1
		
		If kind=T_GLOBAL Return -1
		If t.kind=T_GLOBAL Return 1
		
		If kind=T_METHOD Return -1
		If t.kind=T_METHOD Return 1

		If kind=T_FUNCTION Return -1
		If t.kind=T_FUNCTION Return 1
		
		If kind=T_EOL Return -1
		If t.kind=T_EOL Return 1
		
		Throw "OOps!"
		
	End Method
	
	Method CacheTexts()
		If textCache = Null Then
			textCache = TTextCache.Create(bbdoc, kind)
		
			If Not kids.IsEmpty()
				Local tkind=0
				For Local doc:TDocs=EachIn kids
					doc.CacheTexts()
				Next
			EndIf

		End If

	End Method
	
	Method EmitHtml$( summary:Int=False,protoname:String=Null )
		Local example$
		
		Local stream:TStream=ReadStream( ident+".bmx" )
		If stream
			While Not stream.Eof()
				example:+stream.ReadLine()+"~n"
			Wend
			stream.Close
			example=example.Trim()
		EndIf
		
		If Not summary Then
			Select kind
			Case 0
			Case T_MODULE
				TPrint "&lt;html&gt;&lt;head&gt;&lt;title&gt;"+textCache.shortdesc+" reference&lt;/title&gt;"
				TPrint "&lt;link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'&gt;"
				TPrint "&lt;/head&gt;&lt;body&gt;"
				Local n_consts
				Local n_globals
				Local n_functions
				Local n_types
				Local n_keywords:Int
				For Local t:TDocs=EachIn kids
					Select t.kind
					Case T_TYPE
						' Type is doc'd or there are doc'd kids
						If t.bbdoc Or t.kids.count() &gt; 0 Then
							n_types:+1
						End If
					Case T_CONST n_consts:+1
					Case T_GLOBAL n_globals:+1
					Case T_FUNCTION n_functions:+1
					Case T_EOL n_keywords:+1
					End Select
				Next
				
				'Module navbar
				TPrint "&lt;table width=100% cellspacing=0&gt;&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
				TPrint "&lt;td class=small width=1%&gt;&lt;b&gt;"+ident+":&lt;/b&gt;&lt;/td&gt;"
				If n_types TPrint "&lt;td class=small width=1%&gt;&lt;a href=#types class=small&gt;Types&lt;/a&gt;&lt;/td&gt;"
				If n_consts TPrint "&lt;td class=small width=1%&gt;&lt;a href=#consts class=small&gt;Consts&lt;/a&gt;&lt;/td&gt;"
				If n_globals TPrint "&lt;td class=small width=1%&gt;&lt;a href=#globals class=small&gt;Globals&lt;/a&gt;&lt;/td&gt;"
				If n_functions TPrint "&lt;td class=small width=1%&gt;&lt;a href=#functions class=small&gt;Functions&lt;/a&gt;&lt;/td&gt;"
				If n_keywords TPrint "&lt;td class=small width=1%&gt;&lt;a href=#keywords class=small&gt;Keywords&lt;/a&gt;&lt;/td&gt;"
				If Not infos.IsEmpty()
					TPrint "&lt;td class=small width=1%&gt;&lt;a href=#modinfo class=small&gt;Modinfo&lt;/a&gt;&lt;/td&gt;"
				EndIf
				Local t$=ModuleSource( ident.ToLower() )
				Local i=t.Find( "/mod/" )
				If i&lt;&gt;-1
					t="../../../.."+t[i..]
					TPrint "&lt;td class=small width=1%&gt;&lt;a href='"+t+"' class=small&gt;Source&lt;/a&gt;&lt;/td&gt;"
				EndIf
				TPrint "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;"
				
				Local stream:TStream=ReadStream( "intro.bbdoc" )
				If Not stream
					stream=ReadStream( "intro.html" )
					If Not stream
						If textCache.longdesc TPrint textCache.longdesc.Trim()
					EndIf
				EndIf
				
				If stream
					Local intro$
					While Not stream.Eof()
						intro:+stream.ReadLine()+"~n"
					Wend
					Local i=intro.Find("&lt;body&gt;")
					If i&lt;&gt;-1
						intro=intro[i+6..]
						i=intro.find("&lt;/body&gt;")
						If i&lt;&gt;-1 intro=intro[..i]
					EndIf
					stream.close
					intro=intro.Trim()
					FormatText intro
					TPrint intro
				EndIf
	
				' Show summaries
				If Not kids.IsEmpty()
					Local s:String = Null
					Local tkind=0
					For Local doc:TDocs=EachIn kids
						' kind is Type and is not doc'd and there are no doc'd kids
						If doc.kind = T_TYPE And (Not doc.bbdoc And doc.kids.Count() = 0) Then
							Continue
						End If
						s="&lt;p&gt;&lt;table width=100%&gt;&lt;tr&gt;&lt;td class=blank colspan=2 align=left&gt;"
						If kind&lt;&gt;T_TYPE And doc.kind&lt;&gt;tkind
						If tkind&lt;&gt;0 TPrint "&lt;/table&gt;"
							Select doc.kind
							Case T_TYPE TPrint s+"&lt;a name=types&gt;&lt;/a&gt;&lt;h2&gt;Types&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_CONST TPrint s+"&lt;a name=consts&gt;&lt;/a&gt;&lt;h2&gt;Consts&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_GLOBAL TPrint s+"&lt;a name=globals&gt;&lt;/a&gt;&lt;h2&gt;Globals&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_FUNCTION TPrint s+"&lt;a name=functions&gt;&lt;/a&gt;&lt;h2&gt;Functions&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_EOL TPrint s+"&lt;a name=keywords&gt;&lt;/a&gt;&lt;h2&gt;Keywords&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Default
								Continue
							End Select
							tkind=doc.kind
						EndIf
						doc.EmitHtml( True,proto )
					Next
					If s TPrint "&lt;/table&gt;&lt;p&gt;"
				EndIf
			
			'Type navbar
			Case T_TYPE
				TPrint "&lt;br&gt;&lt;table width=95% cellspacing=0 align=center id="+ident+"&gt;"
				TPrint "&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
				TPrint "&lt;td class=small width=1%&gt;&lt;b&gt;"+ident+":&lt;/b&gt;&lt;/td&gt;"
				If Not kids.IsEmpty()
					Local tkind=0
					For Local doc:TDocs=EachIn kids
						If doc.kind&lt;&gt;tkind
							Select doc.kind
							Case T_CONST
								TPrint "&lt;td class=small width=1%&gt;"
								TPrint "&lt;a href=#"+ident+"_consts class=small&gt;Consts&lt;/a&gt;&lt;/td&gt;"
							Case T_FIELD
								TPrint "&lt;td class=small width=1%&gt;"
								TPrint "&lt;a href=#"+ident+"_fields class=small&gt;Fields&lt;/a&gt;&lt;/td&gt;"
							Case T_GLOBAL
								TPrint "&lt;td class=small width=1%&gt;"
								TPrint "&lt;a href=#"+ident+"_globals class=small&gt;Globals&lt;/a&gt;&lt;/td&gt;"
							Case T_METHOD
								TPrint "&lt;td class=small width=1%&gt;"
								TPrint "&lt;a href=#"+ident+"_methods class=small&gt;Methods&lt;/a&gt;&lt;/td&gt;"
							Case T_FUNCTION
								TPrint "&lt;td class=small width=1%&gt;"
								TPrint "&lt;a href=#"+ident+"_functions class=small&gt;Functions&lt;/a&gt;&lt;/td&gt;"
							Case T_EOL
								TPrint "&lt;td class=small width=1%&gt;"
								TPrint "&lt;a href=#"+ident+"_keywords class=small&gt;Keywords&lt;/a&gt;&lt;/td&gt;"
							Default
								Continue
							End Select
							tkind=doc.kind
						EndIf
					Next
				EndIf
				TPrint "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;"
				
			'Reference tables
			Default
				If protoname.ToLower()[..4]="type"
					Local s$=protoname[4..].Trim()
					Local i=s.Find( " " )
					If i=-1 i=s.length
					TPrint "&lt;table width=95% cellspacing=3 align=center id="+s[..i]+"_"+ident+"&gt;"
				Else
					TPrint "&lt;table width=100% cellspacing=3 align=center id="+ident+"&gt;"
				EndIf
				If kind&lt;&gt;T_EOL
					TPrint "&lt;tr&gt;&lt;td class=doctop colspan=2 align=left&gt;"+proto+"&lt;/td&gt;&lt;/tr&gt;"
				Else
					TPrint "&lt;tr&gt;&lt;td class=doctop colspan=2 align=left&gt;"+ident+"&lt;/td&gt;&lt;/tr&gt;"
				EndIf
				If textCache.parameters.Count()
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Parameters&lt;/td&gt;&lt;td class=docright&gt;"
					For Local s$=EachIn textCache.parameters
						TPrint s+"&lt;br&gt;"
					Next
					TPrint "&lt;/td&gt;&lt;/tr&gt;"
				EndIf
				If textCache.returns
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Returns&lt;/td&gt;"
					TPrint "&lt;td class=docright&gt;"+textCache.returns+"&lt;/td&gt;&lt;/tr&gt;"
				EndIf
				If textCache.shortdesc
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Description&lt;/td&gt;"
					TPrint "&lt;td class=docright&gt;"+textCache.shortdesc+"&lt;/td&gt;&lt;/tr&gt;"
				EndIf
				If textCache.longdesc
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;Information&lt;/td&gt;"
					TPrint "&lt;td class=docright&gt;"+textCache.longdesc+"&lt;/td&gt;&lt;/tr&gt;"
				EndIf
				If example
					If FileType( CurrentDir()+"/"+ident+".bmx" )=0 ident=ident.ToLower()
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;&lt;a href="+ident+".bmx class=small&gt;Example&lt;/a&gt;"
					TPrint "&lt;/td&gt;&lt;td class=docright&gt;&lt;pre&gt;"+example+"&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;"
				EndIf
				TPrint "&lt;/table&gt;&lt;p&gt;"
			End Select

			If kind = T_TYPE Then
			' Show type summaries
				If Not kids.IsEmpty()
					Local s:String = Null
					Local tkind=0
					For Local doc:TDocs=EachIn kids
						s="&lt;p&gt;&lt;table width=95% align=center&gt;&lt;tr&gt;&lt;td class=blank colspan=2 align=left&gt;"
						If doc.kind&lt;&gt;tkind
							If tkind&lt;&gt;0 TPrint "&lt;/table&gt;"
							Select doc.kind
							Case T_CONST
								TPrint s+"&lt;a name="+ident+"_consts&gt;&lt;/a&gt;&lt;h2&gt;Consts&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_FIELD
								TPrint s+"&lt;a name="+ident+"_fields&gt;&lt;/a&gt;&lt;h2&gt;Fields&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_GLOBAL
								TPrint s+"&lt;a name="+ident+"_globals&gt;&lt;/a&gt;&lt;h2&gt;Globals&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_METHOD
								TPrint s+"&lt;a name="+ident+"_methods&gt;&lt;/a&gt;&lt;h2&gt;Methods&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_FUNCTION
								TPrint s+"&lt;a name="+ident+"_functions&gt;&lt;/a&gt;&lt;h2&gt;Functions&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Case T_EOL
								TPrint s+"&lt;a name="+ident+"_keywords&gt;&lt;/a&gt;&lt;h2&gt;Keywords&lt;/h2&gt;&lt;/td&gt;&lt;/tr&gt;"
							Default
								Continue
							End Select
							tkind=doc.kind
						EndIf
						doc.EmitHtml( True,proto )
					Next
					If s TPrint "&lt;/table&gt;&lt;p&gt;"
				EndIf
			End If
			
			If Not kids.IsEmpty()
				Local tkind=0
				For Local doc:TDocs=EachIn kids
					' kind is Type and is not doc'd and there are no doc'd kids
					If doc.kind = T_TYPE And (Not doc.bbdoc And doc.kids.count() = 0) Then
						Continue
					End If
					
					'Reference headers
					If doc.kind&lt;&gt;tkind
						If proto.ToLower()[..4]="type"
							TPrint "&lt;table width=95% align=center&gt;"
						Else
							TPrint "&lt;table width=100% align=center&gt;"
						EndIf
						TPrint "&lt;tr&gt;&lt;td class=blank colspan=2 align=left&gt;&lt;a name=_blank&gt;&lt;/a&gt;"
							Select doc.kind
							Case T_TYPE TPrint "&lt;h2&gt;Type reference&lt;/h2&gt;"
							Case T_CONST TPrint "&lt;h2&gt;Const reference&lt;/h2&gt;"
							Case T_FIELD TPrint "&lt;h2&gt;Field reference&lt;/h2&gt;"
							Case T_GLOBAL TPrint "&lt;h2&gt;Global reference&lt;/h2&gt;"
							Case T_METHOD TPrint "&lt;h2&gt;Method reference&lt;/h2&gt;"
							Case T_FUNCTION TPrint "&lt;h2&gt;Function reference&lt;/h2&gt;"
							Case T_EOL TPrint "&lt;h2&gt;Keyword reference&lt;/h2&gt;"
							End Select
						TPrint "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"
						tkind=doc.kind
					EndIf
					doc.EmitHtml( False,proto )
				Next
			EndIf
			
		'Summary tables
		Else
			Select kind
			Case T_TYPE,T_CONST,T_FIELD,T_GLOBAL,T_METHOD,T_FUNCTION,T_EOL
				If protoname.ToLower()[..4]="type"
					Local s$=protoname[4..].Trim()
					Local i=s.Find( " " )
					If i=-1 i=s.length
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;"
					TPrint "&lt;a href=#"+s[..i]+"_"+ident+"&gt;"+ident+"&lt;/a&gt;"
				Else
					TPrint "&lt;tr&gt;&lt;td class=docleft width=1%&gt;"
					TPrint "&lt;a href=#"+ident+"&gt;"+ident+"&lt;/a&gt;"
				EndIf
				If textCache.shortdesc
					TPrint "&lt;/td&gt;&lt;td class=docright&gt;"+textCache.shortdesc+"&lt;/td&gt;&lt;/tr&gt;"
				Else
					TPrint "&lt;/td&gt;&lt;td class=docright&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;"
				EndIf
			End Select
		End If
		
		Select kind
		Case T_MODULE
			If Not infos.IsEmpty()
				TPrint "&lt;h2 id=modinfo&gt;Module Information&lt;/h2&gt;"
				TPrint "&lt;table width=100%&gt;"
				For Local t$=EachIn infos
					t=t[1..t.length-1]
					If Not t Continue
					Local i=t.Find(":")
					If i=-1 Continue
					Local key$=t[..i].Trim()
					Local val$=t[i+1..].Trim()
					TPrint "&lt;tr&gt;&lt;th width=1%&gt;"+key+"&lt;/th&gt;&lt;td&gt;"+val+"&lt;/td&gt;&lt;/tr&gt;"
				Next
			EndIf
			TPrint "&lt;/body&gt;&lt;/html&gt;"
		End Select
		
	End Method

End Type

Type TDocParser

	Field toker:TBMXToker
	
	Method Close()
		If Not toker Return
		toker.Close
		toker=Null
	End Method

	' Added by BaH - 25/05/2006
	Method processImport(parent:TDocs, txt:String)
	
		If txt.find(".bmx") &gt; 0 Then
	
			Local importFile:String = ExtractDir(toker._filename) + "/" + txt[1..txt.length-1]
			Local _file:String = StripDir(importFile).toLower()
			
			If Not parent.containsImport(_file) Then
				If FileType(importFile) = 1 Then ' exists !
					parent.imports.AddLast(_file)
					Local _toker:TBMXToker=TBMXToker.Create(importFile)
					Local _parser:TDocParser=TDocParser.WithToker(_toker)
					_parser.Parse parent
					_parser.Close
				End If
			End If
		End If
	
	End Method

	Method Parse( parent:TDocs )
	
		If Not toker Throw "closed"
	
		While toker.Curr()&lt;&gt;T_EOF

			If toker.Curr()=T_ENDTYPE 
				If parent.kind=T_TYPE Return
				toker.Bump
				Continue
			EndIf

			' Added by BaH - 25/05/2006, modified 01/06/2006
			If toker.Curr()=T_IMPORT Or toker.Curr()=T_INCLUDE Then
				If parent.kind=T_MODULE
					If toker.Bump()=T_STRINGLIT
						processImport(parent, Toker.Text())
					End If
				End If
			End If
			
			If toker.Curr()=T_MODULEINFO
				If parent.kind=T_MODULE 
					If toker.Bump()=T_STRINGLIT
						parent.infos.AddLast toker.Text()
					EndIf
				EndIf
				toker.Bump
				Continue
			EndIf
		
			Local skip:Int = False
			Local kind:Int
			Local bbdoc$
			
			If toker.Curr()&lt;&gt;T_REM 
				kind = toker.Bump()
				
				' Fix to stop fields / methods etc appearing at top of docs if type not doc'd.
				If kind = T_TYPE Then
					skip = True
				Else
					Continue
				End If
			EndIf
			
			If Not skip Then
				If toker.Text()[..6]&lt;&gt;"bbdoc:"
					toker.Bump
					Continue
				EndIf
				bbdoc = toker.Text()

			
				kind=toker.Bump()
				If kind&lt;&gt;T_CONST And kind&lt;&gt;T_GLOBAL And kind&lt;&gt;T_FUNCTION And kind&lt;&gt;T_METHOD..
				And kind&lt;&gt;T_MODULE And kind&lt;&gt;T_TYPE And kind&lt;&gt;T_FIELD And kind&lt;&gt;T_EOL
					toker.Bump
					Continue
				EndIf
			End If
			
			Local ident$,proto$
			If kind=T_EOL
				Local i=bbdoc.Find( "keyword:" )
				If i=-1 Continue
				ident=bbdoc[i+8..].Replace( "~q","" )
				proto="Keyword "+ident.Trim()
			Else
				proto=toker.Line()
				If toker.Bump()&lt;&gt;T_IDENT Continue
				ident=toker.Text()
				If toker.Bump()=Asc(".") And toker.Bump()=T_IDENT
					ident:+"."+toker.Text()
				EndIf
				toker.Bump
				Select kind
				Case T_CONST,T_GLOBAL
					Local i=proto.Find( "=" )
					If i&lt;&gt;-1 proto=proto[..i]
				Case T_FUNCTION,T_METHOD
					Local i=proto.Find( "=" )
					While i&lt;&gt;-1 And proto.Find( ")",i+1 )&lt;&gt;-1
						i=proto.Find( "=",i+1 )
					Wend
					If i&lt;&gt;-1 proto=proto[..i]
					
					
					i=proto.toLower().Find( "nodebug" )
					While i&lt;&gt;-1 And proto.Find( ")",i+1 )&lt;&gt;-1
						i=proto.toLower().Find( "nodebug",i+1 )
					Wend
					If i&lt;&gt;-1 proto=proto[..i]
					
				End Select
			EndIf
			
			'got a valid Doc!
			Local docs:TDocs=New TDocs
			docs.kind=kind
			docs.ident=ident.Trim()
			docs.proto=proto.Trim()
			docs.bbdoc=bbdoc.Trim()
			docs.parent = parent ' Added by BaH - 25/05/2006

			parent.kids.AddLast docs
			
			If kind=T_MODULE Or kind=T_TYPE
				Parse docs
			EndIf
			
		Wend
	
	End Method
	
	Function WithToker:TDocParser( toker:TBmxToker )
	
		Local t:TDocParser=New TDocParser
		t.toker=toker
		Return t

	End Function
	
End Type

Type TTextCache
	Field returns:String
	Field keyword:String
	Field shortdesc:String
	Field longdesc:String
	Field parameters:TList = New TList

	Function Create:TTextCache(bbdoc:String, kind:Int)
		Local this:TTextCache = New TTextCache
		
		Local d:String = bbdoc
		
		Local i=d.Find("~n")
		If i=-1 i=d.length
		this.shortdesc=d[6..i].Trim()
		d=d[i+1..].Trim()
		If kind&lt;&gt;T_MODULE 
			FormatText this.shortdesc
		EndIf
		
		i=d.Find( "keyword:" )
		If i&lt;&gt;-1
			Local e=d.Find( "~n",i )
			If e=-1 e=d.length
			this.keyword=d[i+8..e].Trim()
			FormatText this.keyword
		EndIf
		
		i=d.Find( "returns:" )
		If i&lt;&gt;-1
			Local e=d.Find( "~n",i )
			If e=-1 e=d.length
			this.returns=d[i+8..e].Trim()
			FormatText this.returns
		EndIf
		
		i=d.Find( "param:" )
		While i&lt;&gt;-1
			Local e=d.Find( "~n",i )
			If e=-1 e=d.length
			Local param:String=d[i+6..e].Trim()
			FormatText param
			this.parameters.AddLast( param )
			i=d.Find( "param:",i+1 )
		Wend
		
		i=d.Find( "about:" )
		If i&lt;&gt;-1
			Local e=d.Find( "param:",i+6 )
			If e=-1 e=d.Find( "returns:",i+6 )
			If e=-1 e=d.Find( "keyword:",i+6 )
			If e=-1 e=d.length
			this.longdesc=d[i+6..e].Trim()
			FormatText this.longdesc
		EndIf	
		
		Return this
	End Function
End Type</textarea> <br><br></td></tr></table><br>
<a name="1038782"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a tweak I posted a few months ago for makedocs and docmods but I've just updated it and moved it here so my changes are all in one place.<br><br>As a result of <a href="/posts.php?topic=88650#1007042" target="_blank">this thread</a> I added support for Rem and bbdoc: entries on the same line ie. so you can do this:<br><pre class=code>Rem bbdoc: my two line description
EndRem</pre><br>As far as I know it works fine and doesn't break anything. It's not an essential feature by any means but it's nice to have as an option for consts and globals.<br><br>I have applied the makedocs.bmx patch that used to be here (see above post #3 @lines -138 +152) as it was too complicated to have multiple patches for the same file.<br><br>So the docmods source (from v 1.41) and patch.<br><br>bmxtoker.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- bmxtoker-old.bmx	2010-07-13 03:54:59.000000000 +0100
+++ bmxtoker.bmx	2010-08-25 01:21:53.814770067 +0100
@@ -186,6 +186,14 @@
 				If v _toke=v.value
 				If _toke=T_REM
 					_text=""
+					If _line.Trim().length&gt;10
+						Local tpos=_line.Find( "bbdoc:" )
+						If tpos&lt;&gt;-1
+							_line=_line[tpos..]
+							_text=_line
+						EndIf
+					EndIf
+					
 					Repeat
 						If _stream.Eof()
 							_pos=0
</textarea><br><br>bmxtoker.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict

Import BRL.Map
Import BRL.Stream

Private

Function ReadTextStream:TStream( url:Object )

	Local format,size,c,d,e
	Local stream:TStream=ReadStream( url )
	If Not stream Return

	If Not stream.Eof()
		c=stream.ReadByte()
		size:+1
		If Not stream.Eof()
			d=stream.ReadByte()
			size:+1
			If c=$fe And d=$ff
				format=TTextStream.UTF16BE
			Else If c=$ff And d=$fe
				format=TTextStream.UTF16LE
			Else If c=$ef And d=$bb
				If Not stream.Eof()
					e=stream.ReadByte()
					size:+1
					If e=$bf format=TTextStream.UTF8
				EndIf
			EndIf
		EndIf
	EndIf

	If format Return TTextStream.Create( stream,format )
	
	stream.Close
	
	Return ReadStream( url )

End Function

Public

Function TPrint( t$ )
	Local p
	For Local i=0 Until t.length
		If t[i]&lt;256 Continue
		'unicode char!
		StandardIOStream.WriteString t[p..i]
		StandardIOStream.WriteString "&amp;#"+t[i]+";"
		p=i+1
	Next
	Print t[p..]
End Function

'----- Simple BMX Parser -----

Const T_EOF=		-1
Const T_EOL=		10

Const T_IDENT=		$10001
Const T_INTLIT=		$10002
Const T_FLOATLIT=	$10003
Const T_STRINGLIT=	$10004
Const T_STRINGERR=	$10005

Const T_REM=		$20001
Const T_ENDREM=		$20002
Const T_FUNCTION=	$20003
Const T_ENDFUNCTION=$20004
Const T_TYPE=		$20005
Const T_ENDTYPE=	$20006
Const T_CONST=		$20007
Const T_METHOD=		$20008
Const T_ENDMETHOD=	$20009
Const T_GLOBAL=		$2000a
Const T_INCLUDE=		$2000b ' Added by BaH - 01/06/2006
Const T_IMPORT=		$2000d
Const T_FIELD=		$2000e
Const T_EXTENDS=	$2000f
Const T_ABSTRACT=	$20010
Const T_FINAL=		$20011
Const T_MODULE=		$2000c
Const T_MODULEINFO=	$20012

Const T_DOTDOT=		$30001
Const T_ARRAYDECL=	$30002

Const T_KEYWORD=	$40000

Type TIntValue
	Field value:Int
End Type

Function IntValue:TIntValue( value )
	Local t:TIntValue=New TIntValue
	t.value=value
	Return t
End Function

Function IsSpace( char )
	Return char&lt;=Asc(" ") And char&lt;&gt;Asc("~n")
End Function

Function IsAlpha( char )
	Return ( char&gt;=Asc("a") And char&lt;=Asc("z") ) Or ( char&gt;=Asc("A") And char&lt;=Asc("Z") )
End Function

Function IsNumeric( char )
	Return char&gt;=Asc("0") And char&lt;=Asc("9")
End Function

Function IsAlphaNumeric( char )
	Return IsAlpha( char ) Or IsNumeric( char )
End Function

Type TBmxToker

	Field _filename:String ' Added by BaH - 25/05/2006

	Field _spc
	Field _pos,_line$
	Field _toke,_text$
	Field _stream:TStream
	
	Global _keywords:TMap
	
	Method Delete()
		Close
	End Method

	Method Bump()
	
		If _toke=T_EOF Return _toke
	
		If _pos&gt;=_line.length
			_pos=0
			If _stream.Eof()
				_toke=T_EOF
				_text=""
				Return
			EndIf
			_line=_stream.ReadLine().Trim()+"~n"
		EndIf
		
		Local from=_pos
		While _pos&lt;_line.length And IsSpace( _line[_pos] )
			_pos:+1
		Wend
		
		If _spc And _pos&lt;&gt;from
			_text=_line[from.._pos]
			_toke=Asc(" ")
			Return _toke
		EndIf
		
		from=_pos
		Local char=_line[_pos]
		_pos:+1
		
		If char=Asc("'")
			_pos=_line.length
			_toke=T_EOL
		Else If char=Asc("~n")
			_toke=T_EOL
		Else If isAlpha(char) Or char=Asc("_")
			While IsAlphaNumeric(_line[_pos]) Or _line[_pos]=Asc("_")
				_pos:+1
			Wend
			_toke=T_IDENT
			Local id$=_line[from.._pos].ToLower()
			If id="end" And _line[_pos]=Asc(" ") And IsAlpha(_line[_pos+1])
				Local t_pos=_pos+2
				While IsAlphaNumeric(_line[t_pos]) Or _line[t_pos]=Asc("_")
					t_pos:+1
				Wend
				Local id$="end"+_line[_pos+1..t_pos].ToLower()
				Local v:TIntValue=TIntValue( _keywords.ValueForKey( id ) )
				If v
					_pos=t_pos
					_toke=v.value
				EndIf
			EndIf
			If _toke=T_IDENT
				Local v:TIntValue=TIntValue( _keywords.ValueForKey( id ) )
				If v _toke=v.value
				If _toke=T_REM
					_text=""
					If _line.Trim().length&gt;10
						Local tpos=_line.Find( "bbdoc:" )
						If tpos&lt;&gt;-1
							_line=_line[tpos..]
							_text=_line
						EndIf
					EndIf
					
					Repeat
						If _stream.Eof()
							_pos=0
							_line=""
							Return _toke
						EndIf
						_line=_stream.ReadLine().Trim()+"~n"
						If _line[..6].ToLower()="endrem" Or _line[..7].ToLower()="end rem" Exit
						_text:+_line
					Forever
					_pos=_line.length
					Return _toke
				Else
					' Complete lines if they continue onto other lines - BaH 03/09/2006
					If _toke = T_FUNCTION Or _toke = T_METHOD Or _toke = T_CONST Or _toke = T_GLOBAL Or _toke = T_FIELD Then
						If _line.find("..") &gt;= 0 Then
							_line = getFullLine()
						End If
					End If
				EndIf
			EndIf
		Else If IsNumeric(char)
			While IsNumeric(_line[_pos])
				_pos:+1
			Wend
			_toke=T_INTLIT
			If _line[_pos]=Asc(".")
				_pos:+1
				While IsNumeric(_line[_pos])
					_pos:+1
				Wend
				_toke=T_FLOATLIT
			EndIf
		Else If char=Asc("~q")
			While _line[_pos]&lt;&gt;Asc("~q") And _line[_pos]&lt;&gt;Asc("~n")
				_pos:+1
			Wend
			If _line[_pos]=Asc("~q")
				_pos:+1
				_toke=T_STRINGLIT
			Else
				_toke=T_STRINGERR
			EndIf
		Else
			_toke=char
		EndIf
		
		_text=_line[from.._pos]
		
		Return _toke
		
	End Method
	
	' Completes a line that takes up more than one actual line - BaH 03/09/2006
	Method getFullLine:String()
		Local first:Int = True
		Local fullline:String
		Local line:String = _line
		Local pos:Int = 0
		Local from:Int
		
		#loop
		Repeat
		
			If Not first Then
				If _stream.Eof()
					pos=0
					line=""
					Return line
				EndIf
				line = _stream.ReadLine().Trim()+"~n"
			End If
			
			first = False

			If line.tolower().Trim() = "rem" Then
				Repeat
					If _stream.Eof()
						pos=0
						line=""
						Return fullline
					EndIf
					line = _stream.ReadLine().Trim()+"~n"
					If line[..6].ToLower()="endrem" Or line[..7].ToLower()="end rem" Then
						Continue loop
					End If
				Forever
			End If

			pos = 0
			from = pos
			While pos &lt; line.length And IsSpace( line[pos] )
				pos:+1
			Wend
			
			from = pos

			Local char:Int = line[pos]
			pos:+1
			While char &lt;&gt; Asc("~n")

				If char = Asc(".") And line[pos] = Asc(".") Then
					fullline:+ line[from..pos-1]
					Exit
				End If
				
				If char = Asc("'") Then
					Exit
				End If
				
				char=line[pos]
				pos:+1 
			Wend
			
			If char = Asc("~n") Then
				fullline :+ line[from..pos-1]
				Exit
			End If

		Forever

		Return fullline
	End Method
	
	Method Curr()
		Return _toke
	End Method
	
	Method Text$()
		Return _text
	End Method
	
	Method Line$()
		Return _line
	End Method
	
	Method Parse$( toke )
		If Curr()&lt;&gt;toke Throw "Unexpected token"
		Local t$=Text()
		Bump
		Return t
	End Method
	
	Method CParse$( toke )
		If Curr()&lt;&gt;toke Return
		Local t$=Text()
		Bump
		Return t
	End Method
	
	Method ParseUntil$( toke )
		Local t$
		While Curr()&lt;&gt;toke
			If Curr()=T_EOF Throw "Unexpected EOF"
			t:+Text()
			Bump
		Wend
		Bump
		Return t
	End Method
	
	Method Spaces( enable )
		If enable
			_spc:+1
		Else
			_spc:-1
		EndIf
	End Method
	
	Method Close()
		If _stream _stream.Close
		_stream=Null
	End Method
	
	Function CreateKeywords()
		If _keywords Return
		Function kw( id$,toke )
			_keywords.insert id,IntValue(toke)
		End Function
		_keywords=New TMap
		kw "rem",T_REM
		kw "endrem",T_ENDREM
		kw "function",T_FUNCTION
		kw "endfunction",T_ENDFUNCTION
		kw "method",T_METHOD
		kw "endmethod",T_ENDMETHOD
		kw "const",T_CONST
		kw "global",T_GLOBAL
		kw "include",T_INCLUDE ' Added by BaH - 01/06/2006
		kw "import",T_IMPORT
		kw "field",T_FIELD
		kw "type",T_TYPE
		kw "endtype",T_ENDTYPE
		kw "extends",T_EXTENDS
		kw "abstract",T_ABSTRACT
		kw "final",T_FINAL
		kw "module",T_MODULE
		kw "moduleinfo",T_MODULEINFO
	End Function	
	
	Function Create:TBmxToker( url:Object )
		CreateKeywords
		Local stream:TStream=ReadTextStream( url )
		If Not stream Throw "Unable to read stream: "+url.ToString()
		Local t:TBmxToker=New TBmxToker
		t._filename = url.ToString() ' Added by BaH - 25/05/2006
		t._stream=stream
		t.Bump
		Return t
	End Function

End Type
</textarea> <br><br></td></tr></table><br>
<a name="1038827"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >degac</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Big work, thanks!<br><br>Why dont' you make a .zip file with the latest version of bmxtoker.bmx, makedocs.bmx etc? <br><br></td></tr></table><br>
<a name="1038886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Grazie degac!<br><br>I would but I thought that everything in BlitzMax/src is under the BSSC license, although it doesn't say so I'm not sure. <br><br></td></tr></table><br>
<a name="1043225"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> This adds a function in docmods to create html links to all third party modules in the modules section.<br><br>Source file (from v 1.41) and patch.<br><br>docmods.diff<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">--- docmods-old.bmx	2010-08-02 01:23:56.000000000 +0100
+++ docmods.bmx	2010-08-27 10:33:46.572333788 +0100
@@ -68,6 +68,7 @@
 
 Function DocMods( docs:TDocs )
 
+	Local modlist$
 	For Local t:TDocs=EachIn docs.kids
 	
 		If t.kind&lt;&gt;T_MODULE Continue
@@ -83,7 +84,12 @@
 		StandardIOStream.Close
 		StandardIOStream=stdio
 	
+		Local i=t.bbdoc.Find( "bbdoc:" )
+		modlist:+t.ident+" "+t.bbdoc[i+6..].Trim()+"~n"
 	Next
+	
+	WriteModList( BlitzMaxPath()+"/docs/html/Modules/Third party",modlist )
+	
 End Function
 
 Function SyncDocs( docs:TDocs )
@@ -155,3 +161,41 @@
 
 End Function
 
+Function WriteModList( path:String,modlist:String )
+
+	If FileType( path )=0 CreateDir( path )
+	Local t$=path[path.FindLast( "/" )+1..]
+	
+	Local stdio:TStream=StandardIOStream
+	StandardIOStream=WriteFile( path+"/index.html" )
+	
+	If stdio
+		Print "&lt;html&gt;&lt;head&gt;&lt;title&gt;"+t+"&lt;/title&gt;"
+		Print "&lt;link rel=stylesheet Type=text/css href='../../styles/fredborg.css'&gt;"
+		Print "&lt;/head&gt;&lt;body&gt;"
+		Print "&lt;table width=100% cellspacing=0&gt;&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
+		Print "&lt;td class=small width=1%&gt;&lt;b&gt;"+t+":&lt;/b&gt;&lt;/td&gt;"
+		Print "&lt;td class=small width=1%&gt;&lt;a href=#_Module class=small&gt;Modules&lt;/a&gt;&lt;/td&gt;"
+		Print "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;&lt;br&gt;"
+		Print "&lt;a name=_Module&gt;&lt;/a&gt;&lt;h2&gt;Modules&lt;/h2&gt;"
+		Print "&lt;table class=doc width=100% cellspacing=3&gt;"
+		Local i,e,q,z
+		While e&lt;modlist.length-1
+			e=modlist.Find( "~n",e+1 )
+			t=modlist[i..e]
+			q=t.Find( " " )
+			z=t.Find( "." )
+			Local ln$=BlitzMaxPath()+"/mod/"+t[..z].ToLower()+".mod/"+t[z+1..q].ToLower()+".mod/doc/commands.html"
+			If FileType( ln )=1
+				Local s$="&lt;tr&gt;&lt;td class=docleft width=1%&gt; &lt;a href='"+ln+"'&gt;"
+				Print s+t[..q]+"&lt;/a&gt;&lt;/td&gt;&lt;td class=docright&gt;"+t[q+1..]+"&lt;/td&gt;&lt;/tr&gt;"
+			EndIf
+			i=e+1
+		Wend
+		Print "&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;"
+	EndIf
+	
+	StandardIOStream.Close()
+	StandardIOStream=stdio
+	
+End Function
</textarea><br><br>docmods.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem

Note: docmods is now only used to build 3rd party modules.

BRL, MAXGUI and PUB mods are built by new makedocs.

End Rem

Strict

Framework brl.basic

Import "docparser.bmx"

CreateDir BlitzMaxPath()+"/doc/bmxmods",True

Local docs:TDocs=ParseMods()

docs.Sort

If AppArgs.length=2 And AppArgs[1].ToLower()="sync"
	SyncDocs docs
Else
	DocMods docs
	SyncDocs docs
EndIf

Function ParseMods:TDocs()

	Local docs:TDocs=New TDocs
	
	Local mods:TList=EnumModules()
	
	For Local modid$=EachIn mods

		If modid.StartsWith( "brl." ) Or modid.StartsWith( "pub." ) Or modid.StartsWith( "maxgui." ) Continue
			
		Local ident$=ModuleIdent( modid )
		Local modDir$=ModulePath( modid )
		Local bmxFile$=ModuleSource( modid )
		Local docDir$=modDir+"/doc"
		
		If FileType( modDir+"/"+ident+".bmx" )=FILETYPE_FILE
			If FileType( docDir )&lt;&gt;FILETYPE_DIR
				CreateDir docDir
				If FileType( docDir )&lt;&gt;FILETYPE_DIR
					Print "Failed to created directory:"+docDir
					Continue
				EndIf
			EndIf

			Local toker:TBMXToker=TBMXToker.Create( bmxFile )

			Local parser:TDocParser=TDocParser.WithToker( toker )
			
			parser.Parse docs
	
			parser.Close

		EndIf
		
	Next

	Return docs
	
End Function

Function DocMods( docs:TDocs )

	Local modlist$
	For Local t:TDocs=EachIn docs.kids
	
		If t.kind&lt;&gt;T_MODULE Continue
		
		ChangeDir ModulePath( t.ident.tolower() )+"/doc"	'linux fix for "BRL." case problem

		Local stdio:TStream=StandardIOStream
		StandardIOStream=WriteFile( "commands.html" )

		t.CacheTexts ' pre cache of text for output (allows us to use it for summaries etc) - BaH 03/09/2006
		t.EmitHtml

		StandardIOStream.Close
		StandardIOStream=stdio
	
		Local i=t.bbdoc.Find( "bbdoc:" )
		modlist:+t.ident+" "+t.bbdoc[i+6..].Trim()+"~n"
	Next
	
	WriteModList( BlitzMaxPath()+"/docs/html/Modules/Third party",modlist )
	
End Function

Function SyncDocs( docs:TDocs )

	Local comms:TList=New TList
	Local index:TList=New TList
	
	Local stdio:TStream=StandardIOStream
	StandardIOStream=WriteFile( BlitzMaxPath()+"/doc/bmxmods/navbar.html" )
	
	TPrint "&lt;html&gt;&lt;head&gt;"
	TPrint "&lt;link rel=stylesheet type=text/css href='../bmxstyle.css'&gt;"
	TPrint "&lt;script&gt;function toggle(a){if(a.display!='block')a.display='block';else a.display='none';}&lt;/script&gt;"
	TPrint "&lt;/head&gt;&lt;body class=navbar&gt;"
	
	TPrint "&lt;b&gt;Module reference&lt;/b&gt;&lt;br&gt;"
	
	For Local t:TDocs=EachIn docs.kids

		If t.kind&lt;&gt;T_MODULE Continue
		
		Local modid$=t.ident.ToLower()
		Local modln$=modid.Replace(".","_")
		Local moddesc$=t.bbdoc[6..].Trim()
		Local i=moddesc.Find("~n")
		If i&lt;&gt;-1 moddesc=moddesc[..i]
		
		Local url$="../../mod/"+modid.Replace(".",".mod/")+".mod/doc/commands.html"
		
		TPrint "&lt;a onClick=toggle("+modln+".style) class=navbig href="+url+" target=main&gt;"+moddesc+"&lt;/a&gt;&lt;br&gt;"
		TPrint "&lt;div id="+modln+" class=entries&gt;"
		For Local p:TDocs=EachIn t.kids
			' kind is Type and is not doc'd and there are no doc'd kids
			If p.kind = T_TYPE And (Not p.bbdoc And p.kids.count() = 0) Then
				Continue
			End If
			Local turl$=url+"#"+p.ident
			TPrint "&amp;nbsp;&lt;a class=navsmall href="+turl+" target=main&gt;"+p.ident+"&lt;/a&gt;&lt;br&gt;"
			index.AddLast p.ident+":"+turl
			Local i=p.proto.Find( " " )
			If i&lt;&gt;-1 comms.AddLast p.proto[i+1..].Trim()+"|"+turl[5..]
		Next
		TPrint "&lt;/div&gt;"

	Next
	
	TPrint "&lt;br&gt;"
	TPrint "&lt;b&gt;Alphabetic index&lt;/b&gt;&lt;br&gt;"

	Local arr:Object[]=index.ToArray()
	
	arr.Sort
	For Local link$=EachIn arr
		Local i=link.Find( ":" )
		If i=-1 Throw "chunks"
		Local ident$=link[..i],url$=link[i+1..]
		TPrint "&lt;a class=navsmall href="+url+" target=main&gt;"+ident+"&lt;/a&gt;&lt;br&gt;"
	Next
	
	TPrint "&lt;/body&gt;&lt;/html&gt;"
	
	StandardIOStream.Close
	StandardIOStream=WriteStream( BlitzMaxPath()+"/doc/bmxmods/commands.txt" )
	For Local t$=EachIn comms
		Print t
	Next
	StandardIOStream.Close
	StandardIOStream=stdio

End Function

Function WriteModList( path:String,modlist:String )

	If FileType( path )=0 CreateDir( path )
	Local t$=path[path.FindLast( "/" )+1..]
	
	Local stdio:TStream=StandardIOStream
	StandardIOStream=WriteFile( path+"/index.html" )
	
	If stdio
		Print "&lt;html&gt;&lt;head&gt;&lt;title&gt;"+t+"&lt;/title&gt;"
		Print "&lt;link rel=stylesheet Type=text/css href='../../styles/fredborg.css'&gt;"
		Print "&lt;/head&gt;&lt;body&gt;"
		Print "&lt;table width=100% cellspacing=0&gt;&lt;tr align=center&gt;&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;"
		Print "&lt;td class=small width=1%&gt;&lt;b&gt;"+t+":&lt;/b&gt;&lt;/td&gt;"
		Print "&lt;td class=small width=1%&gt;&lt;a href=#_Module class=small&gt;Modules&lt;/a&gt;&lt;/td&gt;"
		Print "&lt;td class=small&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;&lt;br&gt;"
		Print "&lt;a name=_Module&gt;&lt;/a&gt;&lt;h2&gt;Modules&lt;/h2&gt;"
		Print "&lt;table class=doc width=100% cellspacing=3&gt;"
		Local i,e,q,z
		While e&lt;modlist.length-1
			e=modlist.Find( "~n",e+1 )
			t=modlist[i..e]
			q=t.Find( " " )
			z=t.Find( "." )
			Local ln$=BlitzMaxPath()+"/mod/"+t[..z].ToLower()+".mod/"+t[z+1..q].ToLower()+".mod/doc/commands.html"
			If FileType( ln )=1
				Local s$="&lt;tr&gt;&lt;td class=docleft width=1%&gt; &lt;a href='"+ln+"'&gt;"
				Print s+t[..q]+"&lt;/a&gt;&lt;/td&gt;&lt;td class=docright&gt;"+t[q+1..]+"&lt;/td&gt;&lt;/tr&gt;"
			EndIf
			i=e+1
		Wend
		Print "&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;"
	EndIf
	
	StandardIOStream.Close()
	StandardIOStream=stdio
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1269896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Always nice to resurrect 5 year old zombie posts :-p<br><br>Just a couple of questions, Mister Mcvi...<br><br>* Is this patch-work compatible with the latest 1.50 code?<br>* I'm sure you had something for lifting code examples from the forum manual, but I appear to have misplaced the link. Does it install them into the documentation ?<br><br>Thanks!<br><br>:o) <br><br></td></tr></table><br>
<a name="1272695"></a>

<a name="1272707"></a>

<a name="1272708"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> No and yes. <br><br>The doc examples code is <a href="/codearcs.php?code=3124" target="_blank">HERE</a>.<br><br>I'll have a look and see if this needs an update. <br><br></td></tr></table><br>
<a name="1272709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thought it would be no but I ran a diff on src/makedocs 1.41 v 1.50 and they're identical. So, yes then. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
