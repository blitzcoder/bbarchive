<!DOCTYPE html><html lang="en" ><head ><title >Antialias in OpenGL</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Antialias in OpenGL</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >Antialias in OpenGL</a><br><br>
<a name="717253"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I modified BRL.graphics and BRL.glgraphics to handle antialiasing in OpenGL.  Thanks to "John J." for handling most of the C programming.<br><br>First, open BRL.graphics ("graphics.bmx") and add these flags to the beginning.  These are flags you can pass to SetGraphicsDriver().  If you don't want to modify BRL.graphics, you can just declare these in your main program:<br><pre class=code>Const GRAPHICS_MULTISAMPLE2X=	$40
Const GRAPHICS_MULTISAMPLE4X=	$80
Const GRAPHICS_MULTISAMPLE8X=	$100
Const GRAPHICS_MULTISAMPLE16X=	$200</pre><br><br>Now replace the file "BRL.mod\glgraphics.mod\glgraphics.win32.c" with this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;windows.h&gt;
#include &lt;gl/gl.h&gt;

#include &lt;brl.mod/system.mod/system.h&gt;

enum{
	_BACKBUFFER=	0x2,
	_ALPHABUFFER=	0x4,
	_DEPTHBUFFER=	0x8,
	_STENCILBUFFER=	0x10,
	_ACCUMBUFFER=	0x20,
	_MULTISAMPLE2X=	0x40,
	_MULTISAMPLE4X=	0x80,
	_MULTISAMPLE8X=	0x100,
	_MULTISAMPLE16X=0x200,
};

enum{
	MODE_SHARED,
	MODE_WIDGET,
	MODE_WINDOW,
	MODE_DISPLAY
};


#define WGL_NUMBER_PIXEL_FORMATS_ARB        0x2000
#define WGL_DRAW_TO_WINDOW_ARB              0x2001
#define WGL_DRAW_TO_BITMAP_ARB              0x2002
#define WGL_ACCELERATION_ARB                0x2003
#define WGL_NEED_PALETTE_ARB                0x2004
#define WGL_NEED_SYSTEM_PALETTE_ARB         0x2005
#define WGL_SWAP_LAYER_BUFFERS_ARB          0x2006
#define WGL_SWAP_METHOD_ARB                 0x2007
#define WGL_NUMBER_OVERLAYS_ARB             0x2008
#define WGL_NUMBER_UNDERLAYS_ARB            0x2009
#define WGL_TRANSPARENT_ARB                 0x200A
#define WGL_TRANSPARENT_RED_VALUE_ARB       0x2037
#define WGL_TRANSPARENT_GREEN_VALUE_ARB     0x2038
#define WGL_TRANSPARENT_BLUE_VALUE_ARB      0x2039
#define WGL_TRANSPARENT_ALPHA_VALUE_ARB     0x203A
#define WGL_TRANSPARENT_INDEX_VALUE_ARB     0x203B
#define WGL_SHARE_DEPTH_ARB                 0x200C
#define WGL_SHARE_STENCIL_ARB               0x200D
#define WGL_SHARE_ACCUM_ARB                 0x200E
#define WGL_SUPPORT_GDI_ARB                 0x200F
#define WGL_SUPPORT_OPENGL_ARB              0x2010
#define WGL_DOUBLE_BUFFER_ARB               0x2011
#define WGL_STEREO_ARB                      0x2012
#define WGL_PIXEL_TYPE_ARB                  0x2013
#define WGL_COLOR_BITS_ARB                  0x2014
#define WGL_RED_BITS_ARB                    0x2015
#define WGL_RED_SHIFT_ARB                   0x2016
#define WGL_GREEN_BITS_ARB                  0x2017
#define WGL_GREEN_SHIFT_ARB                 0x2018
#define WGL_BLUE_BITS_ARB                   0x2019
#define WGL_BLUE_SHIFT_ARB                  0x201A
#define WGL_ALPHA_BITS_ARB                  0x201B
#define WGL_ALPHA_SHIFT_ARB                 0x201C
#define WGL_ACCUM_BITS_ARB                  0x201D
#define WGL_ACCUM_RED_BITS_ARB              0x201E
#define WGL_ACCUM_GREEN_BITS_ARB            0x201F
#define WGL_ACCUM_BLUE_BITS_ARB             0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB            0x2021
#define WGL_DEPTH_BITS_ARB                  0x2022
#define WGL_STENCIL_BITS_ARB                0x2023
#define WGL_AUX_BUFFERS_ARB                 0x2024
#define WGL_NO_ACCELERATION_ARB             0x2025
#define WGL_GENERIC_ACCELERATION_ARB        0x2026
#define WGL_FULL_ACCELERATION_ARB           0x2027
#define WGL_SWAP_EXCHANGE_ARB               0x2028
#define WGL_SWAP_COPY_ARB                   0x2029
#define WGL_SWAP_UNDEFINED_ARB              0x202A
#define WGL_TYPE_RGBA_ARB                   0x202B
#define WGL_TYPE_COLORINDEX_ARB             0x202C
#define WGL_SAMPLE_BUFFERS_ARB              0x2041
#define WGL_SAMPLES_ARB                     0x2042


static const char *CLASS_NAME="BlitzMax GLGraphics";

typedef struct BBGLContext BBGLContext;

struct BBGLContext{
	BBGLContext *succ;
	int mode,width,height,depth,hertz,flags;
	
	HDC hdc;
	HWND hwnd;
	HGLRC hglrc;
};

static BBGLContext *_contexts;
static BBGLContext *_sharedContext;
static BBGLContext *_currentContext;

typedef BOOL (APIENTRY * WGLSWAPINTERVALEXT) (int);

void bbGLGraphicsClose( BBGLContext *context );
void bbGLGraphicsGetSettings( BBGLContext *context,int *width,int *height,int *depth,int *hertz,int *flags );
void bbGLGraphicsSetGraphics( BBGLContext *context );

static const char *_appTitle(){
	return bbStringToCString( bbAppTitle );
}

static void _initPfd( PIXELFORMATDESCRIPTOR *pfd,int flags ){

	memset( pfd,0,sizeof(*pfd) );

	pfd-&gt;nSize=sizeof(pfd);
	pfd-&gt;nVersion=1;
	pfd-&gt;cColorBits=1;
	pfd-&gt;iPixelType=PFD_TYPE_RGBA;
	pfd-&gt;iLayerType=PFD_MAIN_PLANE;
	pfd-&gt;dwFlags=PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL;

	pfd-&gt;dwFlags|=(flags &amp; _BACKBUFFER) ? PFD_DOUBLEBUFFER : 0;
	pfd-&gt;cAlphaBits=(flags &amp; _ALPHABUFFER) ? 1 : 0;
	pfd-&gt;cDepthBits=(flags &amp; _DEPTHBUFFER) ? 1 : 0;
	pfd-&gt;cStencilBits=(flags &amp; _STENCILBUFFER) ? 1 : 0;
	pfd-&gt;cAccumBits=(flags &amp; _ACCUMBUFFER) ? 1 : 0;
}

static int _setSwapInterval( int n ){
	WGLSWAPINTERVALEXT 	wglSwapIntervalEXT=(WGLSWAPINTERVALEXT)wglGetProcAddress("wglSwapIntervalEXT");
	if( wglSwapIntervalEXT ) wglSwapIntervalEXT( n );
}

static BOOL _wglChoosePixelFormatARB( int hDC, const int *intAttribs, const FLOAT *floatAttribs, unsigned int maxFormats, int *lPixelFormat, unsigned int *numFormats)
{
	//Define function pointer datatype
	typedef BOOL (APIENTRY * WGLCHOOSEPIXELFORMATARB) (int hDC, const int *intAttribs, const FLOAT *floatAttribs, unsigned int maxFormats, int *lPixelFormat, unsigned int *numFormats);

	//Get the "wglChoosePixelFormatARB" function
	WGLCHOOSEPIXELFORMATARB wglChoosePixelFormatARB = (WGLCHOOSEPIXELFORMATARB)wglGetProcAddress("wglChoosePixelFormatARB");
	if(wglChoosePixelFormatARB)
		return wglChoosePixelFormatARB(hDC, intAttribs, floatAttribs, maxFormats, lPixelFormat, numFormats);
	else
		return 0;
}

static int MyChoosePixelFormat( int hDC, const int flags )
{
	//Extract multisample mode from flags 
	int multisample = 0;
	if (_MULTISAMPLE2X &amp; flags) multisample = 2;
	else if (_MULTISAMPLE4X &amp; flags) multisample = 4;
	else if (_MULTISAMPLE8X &amp; flags) multisample = 8;
	else if (_MULTISAMPLE16X &amp; flags) multisample = 16;

	//Empty float attributes array
	float floatAttribs[] = {0.0,0.0};
	
	//Some variables
	int lPixelFormat = 0;
	int numFormats=1;
	int result=0;

	//Include the multisample in the flags
	if (multisample &gt; 0){
		int intAttribs[] = {WGL_DRAW_TO_WINDOW_ARB,GL_TRUE,WGL_SUPPORT_OPENGL_ARB,GL_TRUE,WGL_ACCELERATION_ARB,WGL_FULL_ACCELERATION_ARB,WGL_COLOR_BITS_ARB,24,WGL_ALPHA_BITS_ARB,8,WGL_DEPTH_BITS_ARB,16,WGL_DOUBLE_BUFFER_ARB,GL_TRUE,WGL_SAMPLE_BUFFERS_ARB,GL_TRUE,WGL_SAMPLES_ARB,multisample,0,0};
		result=_wglChoosePixelFormatARB(hDC, &amp;intAttribs, &amp;floatAttribs, 1, &amp;lPixelFormat, &amp;numFormats);
	} else {
		int intAttribs[] = {WGL_DRAW_TO_WINDOW_ARB,GL_TRUE,WGL_SUPPORT_OPENGL_ARB,GL_TRUE,WGL_ACCELERATION_ARB,WGL_FULL_ACCELERATION_ARB,WGL_COLOR_BITS_ARB,24,WGL_ALPHA_BITS_ARB,8,WGL_DEPTH_BITS_ARB,16,WGL_DOUBLE_BUFFER_ARB,GL_TRUE,WGL_SAMPLE_BUFFERS_ARB,GL_FALSE,0,0};
		result=_wglChoosePixelFormatARB(hDC, &amp;intAttribs, &amp;floatAttribs, 1, &amp;lPixelFormat, &amp;numFormats);
	}

	//If result=True return lPixelFormat
	if (result &gt; 0){
		return lPixelFormat;
	} else {
		MessageBox(0,"wglChoosePixelFormatARB() failed.","Error",MB_OK);
		return 0;
	}
}

static _stdcall long _wndProc( HWND hwnd,UINT msg,WPARAM wp,LPARAM lp ){

	static HWND _fullScreen;
	
	BBGLContext *c;
	
	for( c=_contexts;c &amp;&amp; c-&gt;hwnd!=hwnd;c=c-&gt;succ ){}
	if( !c ) return DefWindowProc( hwnd,msg,wp,lp );

	bbSystemEmitOSEvent( hwnd,msg,wp,lp,&amp;bbNullObject );
	
	switch( msg ){
	case WM_SYSCOMMAND:
		if (wp==SC_SCREENSAVE) return 1;
		if (wp==SC_MONITORPOWER) return 1;
		break;
	case WM_SYSKEYDOWN:
		if( wp!=VK_F4 ) return 0;
		break;
	case WM_SETFOCUS:
		if( c &amp;&amp; c-&gt;mode==MODE_DISPLAY &amp;&amp; hwnd!=_fullScreen ){
			DEVMODE dm;
			int swapInt=0;
			memset( &amp;dm,0,sizeof(dm) );
			dm.dmSize=sizeof(dm);
			dm.dmPelsWidth=c-&gt;width;
			dm.dmPelsHeight=c-&gt;height;
			dm.dmBitsPerPel=c-&gt;depth;
			dm.dmFields=DM_PELSWIDTH|DM_PELSHEIGHT|DM_BITSPERPEL;
			if( c-&gt;hertz ){
				dm.dmDisplayFrequency=c-&gt;hertz;
				dm.dmFields|=DM_DISPLAYFREQUENCY;
				swapInt=1;
			}
			if( ChangeDisplaySettings( &amp;dm,CDS_FULLSCREEN )==DISP_CHANGE_SUCCESSFUL ){
				_fullScreen=hwnd;
			}else if( dm.dmFields &amp; DM_DISPLAYFREQUENCY ){
				dm.dmDisplayFrequency=0;
				dm.dmFields&amp;=~DM_DISPLAYFREQUENCY;
				if( ChangeDisplaySettings( &amp;dm,CDS_FULLSCREEN )==DISP_CHANGE_SUCCESSFUL ){
					_fullScreen=hwnd;
					swapInt=0;
				}
			}

			if( !_fullScreen ) bbExThrowCString( "GLGraphicsDriver failed to set display mode" );
			
			_setSwapInterval( swapInt );
		}
		return 0;
	case WM_DESTROY:
	case WM_KILLFOCUS:
		if( hwnd==_fullScreen ){
			ChangeDisplaySettings( 0,CDS_FULLSCREEN );
			ShowWindow( hwnd,SW_MINIMIZE );
			_setSwapInterval( 0 );
			_fullScreen=0;
		}
		return 0;
	case WM_PAINT:
		ValidateRect( hwnd,0 );
		return 0;
	case WM_LBUTTONDOWN:case WM_RBUTTONDOWN:case WM_MBUTTONDOWN:
		if( !_fullScreen ) SetCapture( hwnd );
		return 0;
	case WM_LBUTTONUP:case WM_RBUTTONUP:case WM_MBUTTONUP:
		if( !_fullScreen ) ReleaseCapture();
		return 0;
	}
	return DefWindowProc( hwnd,msg,wp,lp );
}

static void _initWndClass(){
	static int _done;
	if( _done ) return;
    WNDCLASS wc={0};
	wc.style=CS_HREDRAW|CS_VREDRAW|CS_OWNDC;
	wc.lpfnWndProc=(WNDPROC)_wndProc;
	wc.hInstance=GetModuleHandle(0);
	wc.lpszClassName=CLASS_NAME;
	wc.hCursor=(HCURSOR)LoadCursor( 0,IDC_ARROW );
	wc.hbrBackground=0;//(HBRUSH)GetStockObject(BLACK_BRUSH);
	if( !RegisterClass( &amp;wc ) ) exit(-1);
	_done=1;
}

static void _initSharedContext(){
	BBGLContext *context;
	HDC hdc;
	HWND hwnd;
	HGLRC hglrc;
	long pf;
	PIXELFORMATDESCRIPTOR pfd;
	
	if( _sharedContext ) return;
	
	_initWndClass();
	
	hwnd=CreateWindowEx( 
		0,CLASS_NAME,0,
		WS_POPUP,0,0,1,1,0,0,GetModuleHandle(0),0 );
		
	_initPfd( &amp;pfd,0 );
	
	hdc=GetDC( hwnd );

	pf=MyChoosePixelFormat( hdc, 0 );
	//pf=ChoosePixelFormat( hdc, &amp;pfd );

	if( !pf ){
		exit(0);
		DestroyWindow( hwnd );
		return;
	}
	SetPixelFormat( hdc,pf,&amp;pfd );
	hglrc=wglCreateContext( hdc );
	if( !hglrc ) exit(0);
	
	_sharedContext=(BBGLContext*)malloc( sizeof(BBGLContext) );
	memset( _sharedContext,0,sizeof(BBGLContext) );

	_sharedContext-&gt;mode=MODE_SHARED;	
	_sharedContext-&gt;width=1;
	_sharedContext-&gt;height=1;
	
	_sharedContext-&gt;hdc=hdc;
	_sharedContext-&gt;hwnd=hwnd;
	_sharedContext-&gt;hglrc=hglrc;
}

static void _validateSize( BBGLContext *context ){
	if( context-&gt;mode==MODE_WIDGET ){
		RECT rect;
		GetClientRect( context-&gt;hwnd,&amp;rect );
		context-&gt;width=rect.right-rect.left;
		context-&gt;height=rect.bottom-rect.top;
	}
}

int bbGLGraphicsGraphicsModes( int *modes,int count ){
	int i=0,n=0;
	while( n&lt;count ){
		DEVMODE	mode;
		mode.dmSize=sizeof(DEVMODE);
		mode.dmDriverExtra=0;

		if( !EnumDisplaySettings(0,i++,&amp;mode) ) break;

		if( mode.dmBitsPerPel&lt;16 ) continue;

		*modes++=mode.dmPelsWidth;
		*modes++=mode.dmPelsHeight;
		*modes++=mode.dmBitsPerPel;
		*modes++=mode.dmDisplayFrequency;
		++n;
	}
	return n;
}

BBGLContext *bbGLGraphicsAttachGraphics( HWND hwnd,int flags ){
	BBGLContext *context;
	
	HDC hdc;
	HGLRC hglrc;
	
	long pf;
	PIXELFORMATDESCRIPTOR pfd;
	RECT rect;
	
	_initSharedContext();
	
	hdc=GetDC( hwnd );
	if( !hdc ) return 0;
	
	_initPfd( &amp;pfd,flags );

	pf=MyChoosePixelFormat( hdc, flags );
	//pf=ChoosePixelFormat( hdc, &amp;pfd );

	if( !pf ) return 0;
	SetPixelFormat( hdc,pf,&amp;pfd );
	hglrc=wglCreateContext( hdc );
	wglShareLists( _sharedContext-&gt;hglrc,hglrc );
	
	GetClientRect( hwnd,&amp;rect );
	
	context=(BBGLContext*)malloc( sizeof(BBGLContext) );
	memset( context,0,sizeof(*context) );
	
	context-&gt;mode=MODE_WIDGET;
	context-&gt;width=rect.right;
	context-&gt;height=rect.bottom;
	context-&gt;flags=flags;
	
	context-&gt;hdc=hdc;
	context-&gt;hwnd=hwnd;
	context-&gt;hglrc=hglrc;
	
	context-&gt;succ=_contexts;
	_contexts=context;
	
	return context;
}

BBGLContext *bbGLGraphicsCreateGraphics( int width,int height,int depth,int hertz,int flags ){
	BBGLContext *context;
	
	int mode;
	HDC hdc;
	HWND hwnd;
	HGLRC hglrc;
	
	long pf;
	PIXELFORMATDESCRIPTOR pfd;
	int hwnd_style;
	RECT rect={0,0,width,height};
	
	_initSharedContext();
	
	if( depth ){
		mode=MODE_DISPLAY;
		hwnd_style=WS_POPUP;
	}else{
		mode=MODE_WINDOW;
		hwnd_style=WS_CAPTION|WS_SYSMENU;
		rect.left+=32;
		rect.top+=32;
		rect.right+=32;
		rect.bottom+=32;
	}
		
	AdjustWindowRectEx( &amp;rect,hwnd_style,0,0 );

	hwnd=CreateWindowEx( 
		0,CLASS_NAME,_appTitle(),
		hwnd_style,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top,0,0,GetModuleHandle(0),0 );
		
	if( !hwnd ) return 0;
	
	_initPfd( &amp;pfd,flags );

	hdc=GetDC( hwnd );
	
	pf=MyChoosePixelFormat( hdc,flags );
	//pf=ChoosePixelFormat( hdc, &amp;pfd );
	
	if( !pf ){
		DestroyWindow( hwnd );
		return 0;
	}
	SetPixelFormat( hdc,pf,&amp;pfd );
	hglrc=wglCreateContext( hdc );
	wglShareLists( _sharedContext-&gt;hglrc,hglrc );
	
	context=(BBGLContext*)malloc( sizeof(BBGLContext) );
	memset( context,0,sizeof(context) );
	
	context-&gt;mode=mode;
	context-&gt;width=width;
	context-&gt;height=height;
	context-&gt;depth=depth;
	context-&gt;hertz=hertz;
	context-&gt;flags=flags;
	
	context-&gt;hdc=hdc;
	context-&gt;hwnd=hwnd;
	context-&gt;hglrc=hglrc;
	
	context-&gt;succ=_contexts;
	_contexts=context;
	
	ShowWindow( hwnd,SW_SHOW );
	
	return context;
}

void bbGLGraphicsGetSettings( BBGLContext *context,int *width,int *height,int *depth,int *hertz,int *flags ){
	_validateSize( context );
	*width=context-&gt;width;
	*height=context-&gt;height;
	*depth=context-&gt;depth;
	*hertz=context-&gt;hertz;
	*flags=context-&gt;flags;
}

void bbGLGraphicsClose( BBGLContext *context ){
	BBGLContext **p,*t;
	
	for( p=&amp;_contexts;(t=*p) &amp;&amp; (t!=context);p=&amp;t-&gt;succ ){}
	if( !t ) return;
	
	if( t==_currentContext ){
		bbGLGraphicsSetGraphics( 0 );
	}
	
	wglDeleteContext( context-&gt;hglrc );

	if( t-&gt;mode==MODE_DISPLAY || t-&gt;mode==MODE_WINDOW ){
		DestroyWindow( t-&gt;hwnd );
	}
	
	*p=t-&gt;succ;
}

void bbGLGraphicsSetGraphics( BBGLContext *context ){

	if( context==_currentContext ) return;
	
	_currentContext=context;
	
	if( context ){
		wglMakeCurrent( context-&gt;hdc,context-&gt;hglrc );
	}else{
		wglMakeCurrent( 0,0 );
	}
}

void bbGLGraphicsFlip( int sync ){

	static int _sync=-1;

	if( !_currentContext ) return;
	
	sync=sync ? 1 : 0;
	if( sync!=_sync ){
		_sync=sync;
		_setSwapInterval( _sync );
	}

	SwapBuffers( _currentContext-&gt;hdc );
}

void bbGLGraphicsSwapSharedContext(){

	if( wglGetCurrentContext()!=_sharedContext-&gt;hglrc ){
		wglMakeCurrent( _sharedContext-&gt;hdc,_sharedContext-&gt;hglrc );
	}else if( _currentContext ){
		wglMakeCurrent( _currentContext-&gt;hdc,_currentContext-&gt;hglrc );
	}else{
		wglMakeCurrent( 0,0 );
	}
}</textarea><br><br>Recompile BRL.graphics and BRL.glgraphics modules.<br><br>To set Antialias in OpenGL, use this:<br><pre class=code>SetGraphicsDriver GLGraphicsDriver(),GRAPHICS_BACKBUFFER+GRAPHICS_MULTISAMPLE2X</pre><br>You will need to recreate any graphics windows or canvases for the change to take effect.  For a seamless transition, try creating the new canvas before deleting the old one.  The user will never suspect anything happened.<br><br>To turn antialiasing off, just call this command and rebuild the graphics window or canvas:<br><pre class=code>SetGraphicsDriver GLGraphicsDriver(),GRAPHICS_BACKBUFFER</pre> <br><br></td></tr></table><br>
<a name="717329"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Filax</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice tweak :) ! <br><br></td></tr></table><br>
<a name="726213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gavin Beard</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> is it only possible to change aa level by rebuild gfx window or canvas?<br><br>Excellent tweak thx <br><br></td></tr></table><br>
<a name="726214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, you have to rebuild the graphics to change between multisample levels.  However, I believe you can use glEnable GL_MULTISAMPLE to turn antialias on and off.<br><br>This is an annoying but unavoidable caveat of OpenGL.  Trust me, I researched it a lot! <br><br></td></tr></table><br>
<a name="728716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> do i have to apply aa using glEnable (GL_LINE_SMOOTH), or is all automatic with the aa on the setgraphicsdriver command? <br><br></td></tr></table><br>
<a name="729048"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> You might have to use glEnable GL_MULTISAMPLE_EXT.  You don't need to use LINE_SMOOTH or anything like that; that's a completely different (and crap) method. <br><br></td></tr></table><br>
<a name="730516"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Filax</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> The same thing is possible with DirectX ?<br>because vista seem incompatible with<br>opengl and vista is coming soon ... ? <br><br></td></tr></table><br>
<a name="745249"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vista is compatible with OpenGL, and it will not be emulated as it was planned by Microsoft. It will support native OpenGL in full screen mode and in windowed mode. <br><br></td></tr></table><br>
<a name="745563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kfprimm</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I got Vista last friday. I runs OpenGL just fine. <br><br></td></tr></table><br>
<a name="749159"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Barbapapa</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was wondering why this module tweak isn't implemented in the original module. I would need AA but haven't done any module tweaks, because they are lost every time I sync. <br><br></td></tr></table><br>
<a name="749160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Because there is no such thing for the DX7 side, it would need a DX9 replacement ... (at least I assume so) <br><br></td></tr></table><br>
<a name="749166"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Barbapapa</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes but this AA is about OpenGL only, so it's multiplatform, it's not for DirectX, so two different pair of shows, or am I missing something? <br><br></td></tr></table><br>
<a name="749218"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes you miss the most obvious point. It must be crossplattform and full Max2D compatible and thus DX would need to have it as well, as Max2D = OpenGL AND DX, not OpenGL only.<br>As GLGraphics is Max2D Core module for OpenGL this directly influences Max2D just in case this question would be the next :) <br>(but as mentioned, this is only an assumption why it didn't get included into the official modules) <br><br></td></tr></table><br>
<a name="756954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gavin Beard</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi <br><br>Just tried building this update into max 1.24 and it compiles fine.  however when ever i run a$ program i get an error : wglChoosePixelFormatARB() failed.  what causes this?<br><br>thx <br><br></td></tr></table><br>
<a name="764280"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know, post your program's code. <br><br></td></tr></table><br>
<a name="779792"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SofaKng</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm getting the same "wglChoosePixelFormatARB()" error...<br><br>The modules re-compile just fine, but when I try to run a simple program like this:<br><br>SetGraphicsDriver GLGraphicsDriver(),GRAPHICS_BACKBUFFER+GRAPHICS_MULTISAMPLE2X<br>Graphics 640, 480<br>Cls<br>Flip<br>WaitKey<br><br>...it displays that error.  :( <br><br></td></tr></table><br>
<a name="800764"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I updated the code to work with the latest version of brl.glgraphics.<br><br>Multisample mode is set by choosing a pixel format with a special function, wglChoosePixelFormat().  But the pointer to that function can not be retrieved until an OpenGL window is created.  Therefore multisample mode can not be set on the first graphics context created.  Fortunately, BRL's Graphics command set provides a way to create a dummy window.  I have added a GRAPHICS_HIDDEN flag so you can create a hidden graphics window, and the end user never has a clue it's there.<br><br>This will use a hidden context to initialize OpenGL, and then create a multisampled graphics context.  You can then use glEnable/Disable GL_MULTISAMPLE to toggle antialias mode, but it should be activated by default.<br><pre class=code>SetGraphicsDriver GLGraphicsDriver()
SetGraphics CreateGraphics(400,300,0,60,GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER|GRAPHICS_HIDDEN)
SetGraphics CreateGraphics(1024,768,0,60,GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER|GRAPHICS_MULTISAMPLE4X)</pre><br><br>Don't forget to declare the multisample constants somewhere (preferably in brl.graphics):<br><pre class=code>	GRAPHICS_MULTISAMPLE2X=	$40
	GRAPHICS_MULTISAMPLE4X=	$80
	GRAPHICS_MULTISAMPLE8X=	$100
	GRAPHICS_MULTISAMPLE16X=$200
	GRAPHICS_HIDDEN=	$400
</pre><br><br>glgraphics.win32.c:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;windows.h&gt;
#include &lt;gl/gl.h&gt;

#include &lt;brl.mod/system.mod/system.h&gt;

enum{
	_BACKBUFFER=	0x2,
	_ALPHABUFFER=	0x4,
	_DEPTHBUFFER=	0x8,
	_STENCILBUFFER=	0x10,
	_ACCUMBUFFER=	0x20,

 _MULTISAMPLE2X=	0x40,
_MULTISAMPLE4X=	0x80,
 _MULTISAMPLE8X=	0x100,
 _MULTISAMPLE16X=0x200,
 _HIDDEN=0x400,
};

enum{
	MODE_SHARED,
	MODE_WIDGET,
	MODE_WINDOW,
	MODE_DISPLAY
};


//--------------------------------------------------------------
// EDITED SECTION
//--------------------------------------------------------------



#define WGL_NUMBER_PIXEL_FORMATS_ARB        0x2000
#define WGL_DRAW_TO_WINDOW_ARB              0x2001
#define WGL_DRAW_TO_BITMAP_ARB              0x2002
#define WGL_ACCELERATION_ARB                0x2003
#define WGL_NEED_PALETTE_ARB                0x2004
#define WGL_NEED_SYSTEM_PALETTE_ARB         0x2005
#define WGL_SWAP_LAYER_BUFFERS_ARB          0x2006
#define WGL_SWAP_METHOD_ARB                 0x2007
#define WGL_NUMBER_OVERLAYS_ARB             0x2008
#define WGL_NUMBER_UNDERLAYS_ARB            0x2009
#define WGL_TRANSPARENT_ARB                 0x200A
#define WGL_TRANSPARENT_RED_VALUE_ARB       0x2037
#define WGL_TRANSPARENT_GREEN_VALUE_ARB     0x2038
#define WGL_TRANSPARENT_BLUE_VALUE_ARB      0x2039
#define WGL_TRANSPARENT_ALPHA_VALUE_ARB     0x203A
#define WGL_TRANSPARENT_INDEX_VALUE_ARB     0x203B
#define WGL_SHARE_DEPTH_ARB                 0x200C
#define WGL_SHARE_STENCIL_ARB               0x200D
#define WGL_SHARE_ACCUM_ARB                 0x200E
#define WGL_SUPPORT_GDI_ARB                 0x200F
#define WGL_SUPPORT_OPENGL_ARB              0x2010
#define WGL_DOUBLE_BUFFER_ARB               0x2011
#define WGL_STEREO_ARB                      0x2012
#define WGL_PIXEL_TYPE_ARB                  0x2013
#define WGL_COLOR_BITS_ARB                  0x2014
#define WGL_RED_BITS_ARB                    0x2015
#define WGL_RED_SHIFT_ARB                   0x2016
#define WGL_GREEN_BITS_ARB                  0x2017
#define WGL_GREEN_SHIFT_ARB                 0x2018
#define WGL_BLUE_BITS_ARB                   0x2019
#define WGL_BLUE_SHIFT_ARB                  0x201A
#define WGL_ALPHA_BITS_ARB                  0x201B
#define WGL_ALPHA_SHIFT_ARB                 0x201C
#define WGL_ACCUM_BITS_ARB                  0x201D
#define WGL_ACCUM_RED_BITS_ARB              0x201E
#define WGL_ACCUM_GREEN_BITS_ARB            0x201F
#define WGL_ACCUM_BLUE_BITS_ARB             0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB            0x2021
#define WGL_DEPTH_BITS_ARB                  0x2022
#define WGL_STENCIL_BITS_ARB                0x2023
#define WGL_AUX_BUFFERS_ARB                 0x2024
#define WGL_NO_ACCELERATION_ARB             0x2025
#define WGL_GENERIC_ACCELERATION_ARB        0x2026
#define WGL_FULL_ACCELERATION_ARB           0x2027
#define WGL_SWAP_EXCHANGE_ARB               0x2028
#define WGL_SWAP_COPY_ARB                   0x2029
#define WGL_SWAP_UNDEFINED_ARB              0x202A
#define WGL_TYPE_RGBA_ARB                   0x202B
#define WGL_TYPE_COLORINDEX_ARB             0x202C
#define WGL_SAMPLE_BUFFERS_ARB              0x2041
#define WGL_SAMPLES_ARB                     0x2042

static BOOL _wglChoosePixelFormatARB( int hDC, const int *intAttribs, const FLOAT *floatAttribs, unsigned int maxFormats, int *lPixelFormat, unsigned int *numFormats)
{
	//Define function pointer datatype
	typedef BOOL (APIENTRY * WGLCHOOSEPIXELFORMATARB) (int hDC, const int *intAttribs, const FLOAT *floatAttribs, unsigned int maxFormats, int *lPixelFormat, unsigned int *numFormats);

	//Get the "wglChoosePixelFormatARB" function
	WGLCHOOSEPIXELFORMATARB wglChoosePixelFormatARB = (WGLCHOOSEPIXELFORMATARB)wglGetProcAddress("wglChoosePixelFormatARB");
	if(wglChoosePixelFormatARB)
		return wglChoosePixelFormatARB(hDC, intAttribs, floatAttribs, maxFormats, lPixelFormat, numFormats);
	else
		MessageBox(0,"wglChoosePixelFormatARB() function not found!","Error",0);
		return 0;
}

static int MyChoosePixelFormat( int hDC, const int flags )
{
	//Extract multisample mode from flags 
	int multisample = 0;
	if (_MULTISAMPLE2X &amp; flags) multisample = 2;
	else if (_MULTISAMPLE4X &amp; flags) multisample = 4;
	else if (_MULTISAMPLE8X &amp; flags) multisample = 8;
	else if (_MULTISAMPLE16X &amp; flags) multisample = 16;

	//Empty float attributes array
	float floatAttribs[] = {0.0,0.0};
	
	//Some variables
	int lPixelFormat = 0;
	int numFormats=1;
	int result=0;

	//Include the multisample in the flags
	if (multisample &gt; 0){
		int intAttribs[] = {WGL_DRAW_TO_WINDOW_ARB,GL_TRUE,WGL_SUPPORT_OPENGL_ARB,GL_TRUE,WGL_ACCELERATION_ARB,WGL_FULL_ACCELERATION_ARB,WGL_COLOR_BITS_ARB,24,WGL_ALPHA_BITS_ARB,8,WGL_DEPTH_BITS_ARB,16,WGL_DOUBLE_BUFFER_ARB,GL_TRUE,WGL_SAMPLE_BUFFERS_ARB,GL_TRUE,WGL_SAMPLES_ARB,multisample,0,0};
		result=_wglChoosePixelFormatARB(hDC, &amp;intAttribs, &amp;floatAttribs, 1, &amp;lPixelFormat, &amp;numFormats);
	} else {
		int intAttribs[] = {WGL_DRAW_TO_WINDOW_ARB,GL_TRUE,WGL_SUPPORT_OPENGL_ARB,GL_TRUE,WGL_ACCELERATION_ARB,WGL_FULL_ACCELERATION_ARB,WGL_COLOR_BITS_ARB,24,WGL_ALPHA_BITS_ARB,8,WGL_DEPTH_BITS_ARB,16,WGL_DOUBLE_BUFFER_ARB,GL_TRUE,WGL_SAMPLE_BUFFERS_ARB,GL_FALSE,0,0};
		result=_wglChoosePixelFormatARB(hDC, &amp;intAttribs, &amp;floatAttribs, 1, &amp;lPixelFormat, &amp;numFormats);
	}

	//If result=True return lPixelFormat
	if (result &gt; 0){
		return lPixelFormat;
	} else {
		MessageBox(0,"wglChoosePixelFormatARB() failed.","Error",MB_OK);
		return 0;
	}
}



//--------------------------------------------------------------
//
//--------------------------------------------------------------


static const char *CLASS_NAME="BlitzMax GLGraphics";

typedef struct BBGLContext BBGLContext;

struct BBGLContext{
	BBGLContext *succ;
	int mode,width,height,depth,hertz,flags;
	
	HDC hdc;
	HWND hwnd;
	HGLRC hglrc;
};

static BBGLContext *_contexts;
static BBGLContext *_sharedContext;
static BBGLContext *_currentContext;

typedef BOOL (APIENTRY * WGLSWAPINTERVALEXT) (int);

void bbGLGraphicsClose( BBGLContext *context );
void bbGLGraphicsGetSettings( BBGLContext *context,int *width,int *height,int *depth,int *hertz,int *flags );
void bbGLGraphicsSetGraphics( BBGLContext *context );

static const char *_appTitle(){
	return bbStringToCString( bbAppTitle );
}

static void _initPfd( PIXELFORMATDESCRIPTOR *pfd,int flags ){

	memset( pfd,0,sizeof(*pfd) );

	pfd-&gt;nSize=sizeof(pfd);
	pfd-&gt;nVersion=1;
	pfd-&gt;cColorBits=1;
	pfd-&gt;iPixelType=PFD_TYPE_RGBA;
	pfd-&gt;iLayerType=PFD_MAIN_PLANE;
	pfd-&gt;dwFlags=PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL;

	pfd-&gt;dwFlags|=(flags &amp; _BACKBUFFER) ? PFD_DOUBLEBUFFER : 0;
	pfd-&gt;cAlphaBits=(flags &amp; _ALPHABUFFER) ? 1 : 0;
	pfd-&gt;cDepthBits=(flags &amp; _DEPTHBUFFER) ? 1 : 0;
	pfd-&gt;cStencilBits=(flags &amp; _STENCILBUFFER) ? 1 : 0;
	pfd-&gt;cAccumBits=(flags &amp; _ACCUMBUFFER) ? 1 : 0;

}

static int _setSwapInterval( int n ){
	WGLSWAPINTERVALEXT 	wglSwapIntervalEXT=(WGLSWAPINTERVALEXT)wglGetProcAddress("wglSwapIntervalEXT");
	if( wglSwapIntervalEXT ) wglSwapIntervalEXT( n );
}

static _stdcall long _wndProc( HWND hwnd,UINT msg,WPARAM wp,LPARAM lp ){

	static HWND _fullScreen;
	
	BBGLContext *c;
	
	for( c=_contexts;c &amp;&amp; c-&gt;hwnd!=hwnd;c=c-&gt;succ ){}
	if( !c ) return DefWindowProc( hwnd,msg,wp,lp );

	bbSystemEmitOSEvent( hwnd,msg,wp,lp,&amp;bbNullObject );
	
	switch( msg ){
	case WM_CLOSE:
		return 0;
	case WM_SYSCOMMAND:
		if (wp==SC_SCREENSAVE) return 1;
		if (wp==SC_MONITORPOWER) return 1;
		break;
	case WM_SYSKEYDOWN:
		if( wp!=VK_F4 ) return 0;
		break;
	case WM_SETFOCUS:
		if( c &amp;&amp; c-&gt;mode==MODE_DISPLAY &amp;&amp; hwnd!=_fullScreen ){
			DEVMODE dm;
			int swapInt=0;
			memset( &amp;dm,0,sizeof(dm) );
			dm.dmSize=sizeof(dm);
			dm.dmPelsWidth=c-&gt;width;
			dm.dmPelsHeight=c-&gt;height;
			dm.dmBitsPerPel=c-&gt;depth;
			dm.dmFields=DM_PELSWIDTH|DM_PELSHEIGHT|DM_BITSPERPEL;
			if( c-&gt;hertz ){
				dm.dmDisplayFrequency=c-&gt;hertz;
				dm.dmFields|=DM_DISPLAYFREQUENCY;
				swapInt=1;
			}
			if( ChangeDisplaySettings( &amp;dm,CDS_FULLSCREEN )==DISP_CHANGE_SUCCESSFUL ){
				_fullScreen=hwnd;
			}else if( dm.dmFields &amp; DM_DISPLAYFREQUENCY ){
				dm.dmDisplayFrequency=0;
				dm.dmFields&amp;=~DM_DISPLAYFREQUENCY;
				if( ChangeDisplaySettings( &amp;dm,CDS_FULLSCREEN )==DISP_CHANGE_SUCCESSFUL ){
					_fullScreen=hwnd;
					swapInt=0;
				}
			}

			if( !_fullScreen ) bbExThrowCString( "GLGraphicsDriver failed to set display mode" );
			
			_setSwapInterval( swapInt );
		}
		return 0;
	case WM_DESTROY:
	case WM_KILLFOCUS:
		if( hwnd==_fullScreen ){
			ChangeDisplaySettings( 0,CDS_FULLSCREEN );
			ShowWindow( hwnd,SW_MINIMIZE );
			_setSwapInterval( 0 );
			_fullScreen=0;
		}
		return 0;
	case WM_PAINT:
		ValidateRect( hwnd,0 );
		return 0;
	case WM_LBUTTONDOWN:case WM_RBUTTONDOWN:case WM_MBUTTONDOWN:
		if( !_fullScreen ) SetCapture( hwnd );
		return 0;
	case WM_LBUTTONUP:case WM_RBUTTONUP:case WM_MBUTTONUP:
		if( !_fullScreen ) ReleaseCapture();
		return 0;
	}
	return DefWindowProc( hwnd,msg,wp,lp );
}

static void _initWndClass(){
	static int _done;
	if( _done ) return;
    WNDCLASS wc={0};
	wc.style=CS_HREDRAW|CS_VREDRAW|CS_OWNDC;
	wc.lpfnWndProc=(WNDPROC)_wndProc;
	wc.hInstance=GetModuleHandle(0);
	wc.lpszClassName=CLASS_NAME;
	wc.hCursor=(HCURSOR)LoadCursor( 0,IDC_ARROW );
	wc.hbrBackground=0;//(HBRUSH)GetStockObject(BLACK_BRUSH);
	if( !RegisterClass( &amp;wc ) ) exit(-1);
	_done=1;
}

static void _initSharedContext(){
	BBGLContext *context;
	HDC hdc;
	HWND hwnd;
	HGLRC hglrc;
	long pf;
	PIXELFORMATDESCRIPTOR pfd;
	
	if( _sharedContext ) return;
	
	_initWndClass();
	
	hwnd=CreateWindowEx( 
		0,CLASS_NAME,0,
		WS_POPUP,0,0,1,1,0,0,GetModuleHandle(0),0 );
		
	_initPfd( &amp;pfd,0 );
	
	hdc=GetDC( hwnd );
	
	pf=ChoosePixelFormat( hdc,&amp;pfd );
	
	if( !pf ){
		exit(0);
		DestroyWindow( hwnd );
		return;
	}

	SetPixelFormat( hdc,pf,&amp;pfd );
	hglrc=wglCreateContext( hdc );
	if( !hglrc ) exit(0);
	
	_sharedContext=(BBGLContext*)malloc( sizeof(BBGLContext) );
	memset( _sharedContext,0,sizeof(BBGLContext) );

	_sharedContext-&gt;mode=MODE_SHARED;	
	_sharedContext-&gt;width=1;
	_sharedContext-&gt;height=1;
	
	_sharedContext-&gt;hdc=hdc;
	_sharedContext-&gt;hwnd=hwnd;
	_sharedContext-&gt;hglrc=hglrc;
}

static void _validateSize( BBGLContext *context ){
	if( context-&gt;mode==MODE_WIDGET ){
		RECT rect;
		GetClientRect( context-&gt;hwnd,&amp;rect );
		context-&gt;width=rect.right-rect.left;
		context-&gt;height=rect.bottom-rect.top;
	}
}

int bbGLGraphicsGraphicsModes( int *modes,int count ){
	int i=0,n=0;
	while( n&lt;count ){
		DEVMODE	mode;
		mode.dmSize=sizeof(DEVMODE);
		mode.dmDriverExtra=0;

		if( !EnumDisplaySettings(0,i++,&amp;mode) ) break;

		if( mode.dmBitsPerPel&lt;16 ) continue;

		*modes++=mode.dmPelsWidth;
		*modes++=mode.dmPelsHeight;
		*modes++=mode.dmBitsPerPel;
		*modes++=mode.dmDisplayFrequency;
		++n;
	}
	return n;
}

BBGLContext *bbGLGraphicsAttachGraphics( HWND hwnd,int flags ){
	BBGLContext *context;
	
	HDC hdc;
	HGLRC hglrc;
	
	long pf;
	PIXELFORMATDESCRIPTOR pfd;
	RECT rect;
	
	_initSharedContext();
	
	hdc=GetDC( hwnd );
	if( !hdc ) return 0;
	
	_initPfd( &amp;pfd,flags );
	

	int multisample = 0;
	if (_MULTISAMPLE2X &amp; flags) multisample = 2;
	else if (_MULTISAMPLE4X &amp; flags) multisample = 4;
	else if (_MULTISAMPLE8X &amp; flags) multisample = 8;
	else if (_MULTISAMPLE16X &amp; flags) multisample = 16;
	if (multisample&gt;0) {
		pf=MyChoosePixelFormat( hdc,flags );
	}
	else
	{
		pf=ChoosePixelFormat( hdc,&amp;pfd );
	}

	if( !pf ) return 0;
	SetPixelFormat( hdc,pf,&amp;pfd );
	hglrc=wglCreateContext( hdc );
	wglShareLists( _sharedContext-&gt;hglrc,hglrc );
	
	GetClientRect( hwnd,&amp;rect );
	
	context=(BBGLContext*)malloc( sizeof(BBGLContext) );
	memset( context,0,sizeof(*context) );
	
	context-&gt;mode=MODE_WIDGET;
	context-&gt;width=rect.right;
	context-&gt;height=rect.bottom;
	context-&gt;flags=flags;
	
	context-&gt;hdc=hdc;
	context-&gt;hwnd=hwnd;
	context-&gt;hglrc=hglrc;
	
	context-&gt;succ=_contexts;
	_contexts=context;
	
	return context;
}

BBGLContext *bbGLGraphicsCreateGraphics( int width,int height,int depth,int hertz,int flags ){
	BBGLContext *context;
	
	int mode;
	HDC hdc;
	HWND hwnd;
	HGLRC hglrc;
	
	long pf;
	PIXELFORMATDESCRIPTOR pfd;
	int hwnd_style;
	RECT rect={0,0,width,height};
	
	_initSharedContext();
	
	if( depth ){
		mode=MODE_DISPLAY;
		hwnd_style=WS_POPUP;
	}else{
		mode=MODE_WINDOW;
		hwnd_style=WS_CAPTION|WS_SYSMENU;
		rect.left+=32;
		rect.top+=32;
		rect.right+=32;
		rect.bottom+=32;
	}
		
	AdjustWindowRectEx( &amp;rect,hwnd_style,0,0 );

	hwnd=CreateWindowEx( 
		0,CLASS_NAME,_appTitle(),
		hwnd_style,rect.left,rect.top,rect.right-rect.left,rect.bottom-rect.top,0,0,GetModuleHandle(0),0 );
		
	if( !hwnd ) return 0;
	
	GetClientRect( hwnd,&amp;rect );
	width=rect.right-rect.left;
	height=rect.bottom-rect.top;
	
	_initPfd( &amp;pfd,flags );

	hdc=GetDC( hwnd );


	int multisample = 0;
	if (_MULTISAMPLE2X &amp; flags) multisample = 2;
	else if (_MULTISAMPLE4X &amp; flags) multisample = 4;
	else if (_MULTISAMPLE8X &amp; flags) multisample = 8;
	else if (_MULTISAMPLE16X &amp; flags) multisample = 16;
	if (multisample&gt;0) {
		pf=MyChoosePixelFormat( hdc,flags );
	}
	else
	{
		pf=ChoosePixelFormat( hdc,&amp;pfd );
	}

	if( !pf ){
		DestroyWindow( hwnd );
		return 0;
	}
	SetPixelFormat( hdc,pf,&amp;pfd );
	hglrc=wglCreateContext( hdc );
	wglShareLists( _sharedContext-&gt;hglrc,hglrc );
	
	context=(BBGLContext*)malloc( sizeof(BBGLContext) );
	memset( context,0,sizeof(context) );
	
	context-&gt;mode=mode;
	context-&gt;width=width;
	context-&gt;height=height;
	context-&gt;depth=depth;
	context-&gt;hertz=hertz;
	context-&gt;flags=flags;
	
	context-&gt;hdc=hdc;
	context-&gt;hwnd=hwnd;
	context-&gt;hglrc=hglrc;
	
	context-&gt;succ=_contexts;
	_contexts=context;
	
	//if ((_HIDDEN &amp; flags)==0) 

	if (_HIDDEN &amp; flags) {
		//MessageBox(0,"HIDDEN","",0);
	}
	else
	{
		//MessageBox(0,"SHOWN","",0);
		ShowWindow( hwnd,SW_SHOW );
	}

	return context;
}

void bbGLGraphicsGetSettings( BBGLContext *context,int *width,int *height,int *depth,int *hertz,int *flags ){
	_validateSize( context );
	*width=context-&gt;width;
	*height=context-&gt;height;
	*depth=context-&gt;depth;
	*hertz=context-&gt;hertz;
	*flags=context-&gt;flags;
}

void bbGLGraphicsClose( BBGLContext *context ){
	BBGLContext **p,*t;
	
	for( p=&amp;_contexts;(t=*p) &amp;&amp; (t!=context);p=&amp;t-&gt;succ ){}
	if( !t ) return;
	
	if( t==_currentContext ){
		bbGLGraphicsSetGraphics( 0 );
	}
	
	wglDeleteContext( context-&gt;hglrc );

	if( t-&gt;mode==MODE_DISPLAY || t-&gt;mode==MODE_WINDOW ){
		DestroyWindow( t-&gt;hwnd );
	}
	
	*p=t-&gt;succ;
}

void bbGLGraphicsSetGraphics( BBGLContext *context ){

	if( context==_currentContext ) return;
	
	_currentContext=context;
	
	if( context ){
		wglMakeCurrent( context-&gt;hdc,context-&gt;hglrc );
	}else{
		wglMakeCurrent( 0,0 );
	}
}

void bbGLGraphicsFlip( int sync ){

	static int _sync=-1;

	if( !_currentContext ) return;
	
	sync=sync ? 1 : 0;
	if( sync!=_sync ){
		_sync=sync;
		_setSwapInterval( _sync );
	}

	SwapBuffers( _currentContext-&gt;hdc );
}

void bbGLGraphicsSwapSharedContext(){

	if( wglGetCurrentContext()!=_sharedContext-&gt;hglrc ){
		wglMakeCurrent( _sharedContext-&gt;hdc,_sharedContext-&gt;hglrc );
	}else if( _currentContext ){
		wglMakeCurrent( _currentContext-&gt;hdc,_currentContext-&gt;hglrc );
	}else{
		wglMakeCurrent( 0,0 );
	}
}
</textarea> <br><br></td></tr></table><br>
<a name="1022476"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry to bump this thread.<br><br>Regarding the need to create a dummy window. Is there a way to 'kill' the hidden dummy window after you created your official graphics window with multisample?<br><br>Also, every time you want to change the sample amount (if the player was changing AA options in the game menu, for instance), do you need to create that dummy window again, or just the first time you start your application?<br>In other words, is the pointer to wglChoosePixelFormat() kept when you delete your official graphics window to create a different one with a different sample value? <br><br></td></tr></table><br>
<a name="1148926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >void</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ready to use modules here<br><a href="http://www.leadwerks.com/werkspace/topic/5143-blitzmax-arb-fsaa-ready-to-use-modules-real-antialias/" target="_blank">http://www.leadwerks.com/werkspace/topic/5143-blitzmax-arb-fsaa-ready-to-use-modules-real-antialias/</a> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
