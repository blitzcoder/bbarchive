<!DOCTYPE html><html lang="en" ><head ><title >MaxPhysics Community Project: In Progress (Tweaks)</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >MaxPhysics Community Project: In Progress (Tweaks)</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >MaxPhysics Community Project: In Progress (Tweaks)</a><br><br>
<a name="589463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is the "In progress" topic. Used to post code tweaks and additions aswell as comments and suggestion about that code. If you have ideas or links to sites that may help the project, post them <a href="/posts.php?topic=52760" target="_blank"> here </a> instead.<br><br>All accepted/good tweaks will be added to the library for everyone to use. <br><br>Don't hesitate to post your additions or findings here. Share you work and if you are unsure if it works or if it is any good, let all others take a look at it and decide. <br><br>All Suggestions go <a href="/posts.php?topic=52760" target="_blank"> here </a><br>Any Examples and Demos <a href="/posts.php?topic=52770" target="_blank"> here</a> <br>You can fine the complete source <a href="/posts.php?topic=52768" target="_blank"> here </a> <br><br></td></tr></table><br>
<a name="589509"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> By Altitudems: (Converted from Pollycode )<br><br>Vector.bmx<textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Const Two_Pi:Float = 2 * Pi
Const Rad_k:Float = 180.0 / Pi

Function Sign:Float (X:Float)
	If (X &lt; 0.0) Then  Return -1.0 Else Return 1.0
End Function

Function Swap (A:Float Var, B:Float Var)
	Local C:Float = A
	A = B
	B = C
End Function

Function RadiansToDegrees:Float(Rad:Float)
	Local K:Float = 180.0 / Pi
	Return Rad * K
End Function

Function DegreesToRadians:Float(Deg:Float)
	Local K:Float = Pi / 180.0
	Return Deg * K
End Function

Function NewVector:TVector2(_X:Float = 0, _Y:Float = 0)
	Local V:TVector2 = New TVector2
	V.X = _X
	V.Y = _Y
	Return V
End Function

Type TVector2
	Field X:Float
	Field Y:Float

	Function Create:TVector2(_X:Float, _Y:Float)
		Local V:TVector2 = New TVector2
		V.X = _X
		V.Y = _Y
		Return V
	End Function
	
	Method Clone:TVector2 ()
		Local V:TVector2 = New TVector2
		V.X = X
		V.Y = Y
		Return V
	End Method
	
	Method Set (_X:Float = 0, _Y:Float = 0)
		X = _X
		Y = _Y
	End Method
	
	Method Div:TVector2 (Scalar:Float)
		Local V:TVector2 = Self.Clone()
		V.X :/ Scalar
		V.Y :/ Scalar
		Return V
	End Method

	Method Mult:TVector2 (Scalar:Float)
		Local V:TVector2 = Clone()
		V.X :* Scalar
		V.Y :* Scalar
		Return V
	End Method
	
	Method Add:TVector2 (_X:Float, _Y:Float)
		Local V:TVector2 = Clone()
		V.X :+ _X
		V.Y :+ _Y
		Return V
	End Method

	Method Sub:TVector2 (_X:Float, _Y:Float)
		Local V:TVector2 = Clone()
		V.X :- _X
		V.Y :- _Y
		Return V
	End Method

	Method AddVector:TVector2 (_V:TVector2)
		Local V:TVector2 = Clone()
		V.X :+ _V.X
		V.Y :+ _V.Y
		Return V
	End Method
	
	Method SubVector:TVector2 (_V:TVector2)
		Local V:TVector2 = Clone()
		V.X :- _V.X
		V.Y :- _V.Y
		Return V
	End Method
	
	Method Cross:Float (_V:TVector2)
		Return (X * _V.Y) - (Y * _V.X)
	End Method

	Method Dot:Float (_V:TVector2)
		Return (X * _V.X) + (Y * _V.Y)
	End Method

	Method Reverse:TVector2 ()
		Local _V:TVector2 = Clone()
		_V.X = -_V.X
		_V.Y = -_V.Y
		Return _V
	End Method
	
	Method Length:Float ()
		Return Sqr(X * X + Y * Y)
	End Method
	
	Method Normalise:TVector2 ()
		Local _V:TVector2 = Clone()
		Local _L:Float = _V.Length()
		If (_L = 0.0) Return Null
		_V = _V.Mult(1.0 / _L)
		Return _V
	End Method
	
	Method Direction:TVector2 ()
		Local _V:TVector2 = Clone()
		_V.Normalise()
		Return _V
	End Method
	
	Method Angle:Float(_V:TVector2)
		Local Dot:Float = Dot(_V)
		Local Cross:Float = Cross(_V)
		
		'angle between segments
		Local Angle:Float = Float(ATan2(Cross, Dot))

		Return Angle
	End Method

	Method Rotate:TVector2 (_Angle:Float)
		Local _V:TVector2 = Clone()
		Local _X:Float = _V.X
		_V.X =  _V.X * Cos(_Angle) - _V.Y * Sin(_Angle)
		_V.Y = _X * Sin(_Angle) + _V.Y * Cos(_Angle)
		Return _V
	End Method
	
	Method RotateOnCenter:TVector2 (_Center:TVector2, _Angle:Float)
		Local Diff:TVector2 = Clone().SubVector(_Center)
		Diff.Rotate(_Angle)
		Local _V:TVector2 = Diff.AddVector(_Center)
		Return _V
	End Method

	Method Clamp (_Min:TVector2, _Max:TVector2)
		If (X &lt; _Min.X)
			X = _Min.X
		ElseIf (X &gt; _Max.X)
			X = _Max.X
		End If
		If (Y &lt; _Min.y)
			Y = _Min.Y
		ElseIf (Y &gt; _Max.Y)
			Y = _Max.Y
		End If
	End Method

	Method Randomise(_Min:TVector2, _Max:TVector2)
		X = RndFloat() * (_Max.X - _Min.X) + _Min.X
		Y = RndFloat() * (_Max.Y - _Min.Y) + _Min.Y
	End Method

	Method Render(_X:Float, _Y:Float)
		DrawLine _X,_Y,_X + X,_Y + Y
	End Method
End Type</textarea> <br><br></td></tr></table><br>
<a name="589512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Haramanai post the latest version of your line2d here. <br><br></td></tr></table><br>
<a name="589522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Line2d (As I see it)<br><br>About it : I created to use it for a game I wand to create. When I saw Wave's posts about Public Phisics I gived it to the public and converted it to fit the the Vector2d.<br><br>Progress : No progress. As the main idea I had for collision with lines breaked. I may see the circle to make it work with the circle. (If anything change I will post it in this post and in this topic)<br><br>Testing : I will do the testing again to be sure not to give something wrong (I have doned the testing when this was Line2d) I will change this area for for things to tested be well comers.<br><br>Wave. If you wand me to do anything with this just edit the above post and ask me to do so.<br><br>EDIT: THIS LINE 2D Was Abandon so I deleted the codebox to make the topic lighter <br><br></td></tr></table><br>
<a name="589669"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Main.bmx (Converted from Main.cpp)<br>You will notice I removed a lot of the Glut code<br>I think we can tackle the timer functions later<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Include "GameCode.bmx"

'--------------------------------------------------------------------------
' window size
'--------------------------------------------------------------------------
Const ScreenWidth:Int = 640
Const ScreenHeight:Int = 480

'Function Timer(Time:Int)
'	Idle()

'	glutTimerFunc(Time, Timer, Int(500.0 / 60.0))
'End Function

'--------------------------------------------------------------------------
' Graphics init
'--------------------------------------------------------------------------
Graphics Screenwidth,ScreenHeight
AppTitle "Tutorial 4 – Basic Arcade Collision response"

LineWidth 3
SetBlend ALPHABLEND

'-----------------------------------------------------
' resets the world with random data
'-----------------------------------------------------
GameInit()

While Not Keyhit(KEY_ESCAPE)

	'glutTimerFunc			(0, Timer, (int) 100.0f / 60.0f);
	'glutMotionFunc			(Motion);

	Cls
	
	'-----------------------------------------------------
	' Update the objects
	'-----------------------------------------------------
	GameUpdate(1.0 / 60.0)
	
	'--------------------------------------------------------------------------
	' render stuff
	'--------------------------------------------------------------------------	
	GameRender()

	Flip
Wend
</textarea><br><br>Vector.cpp still needs to be done.<br><br>I almost have polygon.cpp and .h done.<br><br>I'm about half way through converting GameCode.cpp and GameCode.h<br><br>Body.cpp and .h are next.<br><br>I'm sure I will do some things wrong so there will most likely be a long debuging period when everything is converted. Hopefully someone who knows c++ will help out.<br><br>Many of the variable names use abreviations and acronyms that make the code hard to understand, I think once the code is converted we should rename things. <br><br></td></tr></table><br>
<a name="589672"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was thinking we could use the blitzwiki for this project, then we could all edit the same code. Collaberation is hard in a forum. Plus it would be much easier to organize the project.<br><br>Here is a link:<br><a href="http://www.blitzwiki.org/index.php/Main_Page" target="_blank">http://www.blitzwiki.org/index.php/Main_Page</a><br><br>If we do it this way we could still post in the forums and give progress updates so that others start to get involved.<br><br>Wave: Since you started this project I'll let you decide to set up a page on the wiki or not.<br><br>We could possibly start something here:<br>http://www.blitzwiki.org/index.php/Category:User_Modules <br><br></td></tr></table><br>
<a name="589756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Many of the variable names use abreviations and acronyms that make the code hard to understand, I think once the code is converted we should rename things. <br></div>I totally agree.<br><br>I'll check into the Wiki right away, Thanks!<br><br>I have also considered opening a new category (with topics) in the TNet forums for this project. Then I can make you of you admins for those parts.<br><br>Also I can always put up a project page where the project in it's whole is explained (liek the first post). And then link to all other places.<br><br>EDIT<br>Replied in Main topic about Wiki <br><br></td></tr></table><br>
<a name="589779"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Diablo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok then, this is what i got when i translated Vector.cpp<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict

Include "Vector_h.bmx"

Function FindRoots:Byte(a#, b#, c#, t0# Var, t1# Var)

	Local d# = b# * b# - (4.0 * a# * c#)
	
	If d# &lt; 0.0 Then Return False
	
	d# = Float(Sqr(d#))
	
	Local one_over_two_a# = 1.0 / (2.0 * a#)
	
	t0# = (-b# - d#) * one_over_two_a#
	t1# = (-b# + d#) * one_over_two_a#
	
	If (t1 &lt; t0) Then
		Local t# = t0#
		t0# = t1#
		t1# = t#
	EndIf
	
	Return True

End Function

Function RaySphereIntersection(C:TVector2, r#, O:TVector2, D:TVector2, tmin#, tmax#, t# Var)

	Local t0#, t1#
	
	Local H:TVector2 = (O.SubVector(C))
	Local _a# = (D.Dot(D))
	Local _b# = (H.Dot(D)) * 2.0
	Local _c# = (H.Dot(H)) - (r# * r#)
	
	If Not FindRoots(_a#, _b#, _c#, t0, t1) Then Return False
	
	If t0 &gt; tmax Or t1 &lt; tmin Then Return False
	
	Local t# = t0#
	
	If t0# &lt; tmin# Then t# = t1#
	
	Return True
	
End Function</textarea><br><br>I didn't convert the render functions or the matrix function - i think the matrix function should be done in the Vector header??? <br><br></td></tr></table><br>
<a name="589823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great!<br><br>Do you know how: FindRoots() and RaySphereIntersection() works and what they do? Can you comment? I'll add them to our Vector2D type. Found <a href="http://www.blitzwiki.org/index.php/MaxPhysics_Vector2D" target="_blank">here </a><br><br><br><br>Can you explain more what the matrix functions do and how they work? <br><br></td></tr></table><br>
<a name="589835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Diablo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> sorry, i know c++ (a bit) but not that much about physics, i was converting from here 'Tutorial 7 - Rigid body dynamics\source' i'll have a google ;p<br><br>EDIT: ... I seem to recall i have 'Game programming all in one' i'll see if it has anything about physics in thier.<br><br>EDIT 2: Have a look at <a href="http://www.ping.be/~ping1339/matr.htm" target="_blank">THIS</a> for info on matrices and matrixs<br><br>EDIT 3: After some sreacher couldn't find that much about Find Roots apart from ways of doing but i found a little about Ray Sphere Intersection:<br><br><a href="http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter1.htm" target="_blank">One</a><br><a href="http://www.csee.umbc.edu/~olano/435f02/ray-sphere.html" target="_blank">Two</a><br><a href="http://www.ccs.neu.edu/home/fell/CSU540/programs/RayTracingFormulas.htm" target="_blank">Three</a><br><a href="http://www.gamedev.net/reference/articles/article1026.asp" target="_blank">About Ellipsoids</a> <br><br></td></tr></table><br>
<a name="589927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Diablo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Many of the variable names use abreviations and acronyms that make the code hard to understand, I think once the code is converted we should rename things. <br></div><br><br>I think a good naming system would be to use a form <a href="http://web.umr.edu/~cpp/common/hungarian.html" target="_blank">Hungarian Notation</a><br><br>i use it like this<br><br><div class="quote"> <br>b = Byte<br>i = Int<br>f = Float<br>k = Object/Type<br>m_ = Member of (see below for eg)<br>d = Double<br>UPPERCASE = Consts<br>lowercase = type names<br> <br></div><br><br>Example:<br><div class="quote"> <br>Type testtype<br>     field m_iX:int, m_iY:int<br>     field m_fAlpha:Float<br>End Type<br><br>Local kMyType:testtype = new testtype<br> <br></div> <br><br></td></tr></table><br>
<a name="589930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice project. Wave, this is the best introduction to matrices I've ever found. Even I understood most of it when I read it (though I've forgotten it all now)...<br><br><a href="http://chortle.ccsu.edu/VectorLessons/vectorIndex.html" target="_blank">http://chortle.ccsu.edu/VectorLessons/vectorIndex.html</a> <br><br></td></tr></table><br>
<a name="589964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I personally don't like Hungarian Notation. I like the BASIC style more. i.e. Name if after what it is and see the declearation if you are unsure. I'm even diverting from having our types start with T (Bmax standard). The reason is simple: It's not required because the type is called Vector2D and you can always use the name Vector:Vector2D in any method, function or example.<br><br>No offence though, but having everything named: vVector.dX would only lead to me thinking it means DeltaX - the difference in X. Which would not be wrong for a vector. Still I can't see the benifit as we are coding in Max and not C++ ;)<br><br>James, thanks for the link. I wish to add that I already know matrix math and vector math, it's just that I was unsure what the purpose of the method was =)<br><br>As a matter of fact I'm in the middle of the construction of a beginner tutorial on the subject of vectors and gamephysics. <br><br>The root function is for solving the roots of the equation system in RaySphereIntersection(C:TVector2, r#, O:TVector2, D:TVector2, tmin#, tmax#, t# Var) <br><br>It would be really useful if we could decrypt what C,O,D are and how to use tmin#, tmax# and t#.<br><br>t# is probably where on the line we collide, from 0 to 1.<br>C could be the circle's position vector <br><br></td></tr></table><br>
<a name="590189"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is some timer code. Additions to this is very welcome. I'm not sure if it should be a part of MaxPhysics, time is important. Anyhow if we are going to use it it needs some improvements. <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
 
 R E A L T I M E ~  T I M E R  

 This timer does not stop your game,
 the timer are used to alter game states and actions,
 depending on time and not gamespeed.


 TestTimer = SetTimer() ;Creates an instant timer

 If TimerOut(TestTimer) ; This will happen 
 
 End If 

EndRem


'Used For timed events
Type Timer'-----------------------------------------

	Field EndTime%	'The Time where the Timer ends
	Field Depleated = False
		
	'  C R E A T E  
	'----------------------------------------
	' USE: MyTimer:Timer = Timer.Create()
	' Returns a new timer	
	Function Create:Timer( Time# = 0 )
	
		Local NewTimer:Timer = New Timer
		NewTimer.EndTime = MilliSecs() + Int( Time*1000 )
		NewTimer.Depleated = False
			
		Return NewTimer
	
	EndFunction
	'----------------------------------------	
	
	
	'  O U T    (check if timer is out)
	'----------------------------------------
	' USE: If MyTimer.Out then...
	' Returns 1 if timer is out, 0 if it's not
	Method Out()
		If Depleated = True Return False
				
		If EndTime =&lt; MilliSecs()
			Depleated = True
			Return True
		Else
			Return False
		EndIf		
	End Method
	'----------------------------------------
	
	
	

	'  S T O P
	'----------------------------------------
	' USE: MyTimer.
	' Sets Timer to Offline
	Method Stop()
		Depleated = True
	End Method
	'----------------------------------------
	
	'  R E S T A R T 
	'----------------------------------------
	' USE: MyTimer.
	' Sets Timer to Offline
	Method Restart( Time# )
		Depleated = False
		EndTime = MilliSecs() + Int(Time*1000)
	End Method
	'----------------------------------------	
	
		
	
	'  R E P E A T
	'----------------------------------------
	'USE: If MyTimer.Repeat(TimeToRepeat) then...
	Method Repeats( TimeToRepeat# )
		If Depleated = True Return False
		
		If ( MilliSecs() - EndTime ) &gt; 0 'Is Millisecs() &gt; Than EndTime?
			EndTime = MilliSecs()+TimeToRepeat*1000
			Return True
		Else
			Return False
		EndIf
	End Method
	'----------------------------------------	
			
				
			
End Type'-------------------------------------------

Graphics 300,100,0

'~ ~ ~ ~ TIMER TEST ~ ~ ~ ~ ~
'Rem
Global MilliTimer:Timer 	= Timer.Create()	
Global SecTimer:Timer 		= Timer.Create(1)	
Global MinTimer:Timer 		= Timer.Create(60)	
Global HourTimer:Timer 	= Timer.Create(60*60)
Global PrintTimer:Timer 	= Timer.Create()

While Not KeyDown(Key_Escape)

	If MilliTimer.Repeats( 0.01 ) 	Milli:+1 ;If 	Milli =&gt; 100 Then Milli = 0

	If SecTimer.Repeats( 1 )		Sec:+1 ;If Sec =&gt; 60 Then Sec = 0
		
	If MinTimer.Repeats( 60 )		Minute:+1 ;If Minute =&gt; 60 Then Minute = 0

	If HourTimer.Repeats( 60*60 )   	Hour:+1	
	
	If PrintTimer.Repeats( 10 )	Print "TIME LOG: "+Hour+"h  "+Minute+"m  "+Sec+"s  "+Milli+" milli"
	
	DrawText "TIME: "+Hour+"."+Minute+"."+Sec+"."+Milli,10,30
	
	Flip;Cls
Wend
'EndRem
' ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
</textarea> <br><br></td></tr></table><br>
<a name="590212"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't like hungarian notation. I like the standard CPP style like so:<br><br>aBigVar:Float<br>someReallyLongRayCastVariable:Int<br><br>Where the first letter is lowercase and the rest capitalized.<br>There is no need to name a variable with "float" as strict will enforce declaration.<br><br>The real reason for having capitals or not is simply a matter of readibility, and having the first letter lowercase is a matter of faster typing, nothing more.<br><br>Functions should always have the first letter capitalized though. <br><br></td></tr></table><br>
<a name="590593"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok I don't know if this is right from Wave's point of view  but I added the Line2d to the wiki here : <a href="http://www.blitzwiki.org/index.php/MaxPhysics_Line2D" target="_blank">http://www.blitzwiki.org/index.php/MaxPhysics_Line2D</a><br>Currently there is a problem with the collideLine method and a demo that uses the reflection method. Pls check for bugs and read the discussion to see whats going on.<br>If anyone can help with the progress is wellcome. Plus If any one know better way to do thinks that are in the methods or functions pls post them to the discussion. <br><br></td></tr></table><br>
<a name="590797"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vector2D.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Rem
	File: "Vector2D.bmx"

	2D Vector Module
	The Vector Module which is a part of the Public MaxPhysics PROJECT
	
	VERSION HISTORY:
	
		ADDITIONS:
			Added a method: Plus( value!) - increases a vectors leangth with a scalar 
		
		FIXES:
			Fixed: Now using the real cartesian coordinate system
			Fixed: Replaced floats with doubles.
		
		TO DO:
			Each method should have a equivalent function
			only 3-4 are done.
EndRem




' /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /

'		T V E C T O R

'------------------------------------------------------------------------
Type Vector2D

	Field X!,Y!
	
		
	'===============
	' BASIC COMMANDS
	'===============
	
	'		 C R E A T E  V E C T O R
	'-----------------------------------------------
	Function Create:Vector2D( X!, Y! )
	
		Local Vector:Vector2D
		Vector = New Vector2D
		
		Vector.X!  = X!
		Vector.Y!  = Y!
		Return Vector 
		
	End Function
	
	'		C R E A T E   V E C T O R   F R O M
	'----------------------------------------------
	Function CreateFrom:Vector2D( Position1:Vector2D , Position2:Vector2D )
	
		Local Vector:Vector2D = Create(0,0)
		Vector.VectorFrom( Position1, Position2 )
		Return Vector
		
	EndFunction
	
	'		C R E A T E   /w  D I E C T I O N
	'----------------------------------------------	
	' I don't know any good name for this method
	Function CreateField:Vector2D( Length , Direction )

		Local Vector:Vector2D = Create(1,0)
		Vector.SetLength( Length )
		Vector.SetDirection( Direction )		
		Return Vector
				
	EndFunction
	
	'		 C O P Y   V E C T O R
	'----------------------------------------------
	Method Copy:Vector2D()'

		Return Create( X , Y )
		
	End Method

	'		 S E T  V E C T O R
	'----------------------------------------------
	Method Set( newX! , newY! )'
		X! = newX!
		Y! = newY!
	End Method

	'		 S E T  D I R E C T I O N
	'----------------------------------------------
	Method SetDirection( Angle! )'
		Local Length!  = Length()
		X = Cos( Angle! )*Length
		Y = -Sin( Angle! )*Length		    
	End Method
	Method SetDir( Angle! )
		SetDirection( Angle )
	EndMethod

	'		 S E T  L E N G T H
	'----------------------------------------------	
	Method SetLength( Length! )
		'If we want to set vector to zero 
		If Length = 0 Set(0,0);Return

		'If the new length is negative assume we want to
		If Length &lt; 0 Turn180() 'Reverse

		Local Angle! = Angle()'Of this Vector
		X =  Cos(Angle) * Length
		Y = -Sin(Angle) * Length			
					
	EndMethod
	Method SetMagnitude( Length! )
		SetLength( Length )
	EndMethod


	'		G E T   L E N G T H
	'----------------------------------------------
	Method Length!()
		Return Sqr( X*X + Y*Y )'
	EndMethod
	'Alternative Names - Use whatever you like
	Method Magnitude!()    Return Length() EndMethod
	Method GetLength!()    Return Length() EndMethod
	Method GetMagnitude!() Return Length() EndMethod
		
	'		G E T   L E N G T H   S Q U A R E D
	'----------------------------------------------	
	Method LengthSquared()
		Return ( X*X + Y*Y )'
	EndMethod	
		

	'		G E T  D I R E C T I O N
	'----------------------------------------------
	Method Direction!()
		Return ATan2(-y , x)
	End Method
	'Also Alternative Names - Use whatever you like	
	Method GetDirection!() Return Direction() EndMethod
	Method Dir!()          Return Direction() EndMethod	
	Method GetAngle!()     Return Direction() EndMethod
	Method Angle!()        Return Direction() EndMethod
	'And alternative to get 0&lt;= Angle &lt;360
	Method Dir360!()
		Local Angle! = Direction!()
		If Angle &lt; 0 Then Angle:+360
		Return Angle
	End Method

	
	'		R E V E R S E    V E C T O R 
	'----------------------------------------------
	Method Reverse() 'or Turn 180 Degrees
		X = -X
		Y = -Y
	End Method
	Method Turn180()
		Reverse()
	EndMethod
	
	'		V E C T O R   F R O M
	'----------------------------------------------
	Method VectorFrom( Position1:Vector2D , Position2:Vector2D)
		X = ( Position2.X - Position1.X ) 	
		Y = ( Position2.Y - Position1.Y )
		'Change the vector into a vector from Position1 to Position2		
	EndMethod

		



	'===============
	' MATH COMMANDS
	'===============

	'		A D D
	'----------------------------------------------	
	Method Add( Vector:Vector2D ) 
		X:+ Vector.X 
		Y:+ Vector.Y 
	EndMethod

	'		A D D  /w  D E L T A  T I M E
	'----------------------------------------------	
	Method AddDelta( Vector:Vector2D ) 
		Add( Vector )
		MultiplyDeltaTime()
	EndMethod	
		
		
	'		A D D  C O P Y
	'----------------------------------------------	
	' Add two Vectors and return the result as a 
	' third vector.
	Method AddCopy:Vector2D( Vector:Vector2D ) 
		Local NewVector:Vector2D
		NewVector = Self.Copy()
		NewVector.Add( Vector ) 
		Return NewVector 
	EndMethod
	
	'		A D D  N E W  /w  D E L T A  T I M E
	'----------------------------------------------	
	Method AddDeltaCopy:Vector2D( Vector:Vector2D ) 
		Local NewVector:Vector2D
		NewVector = AddCopy( Vector )
		NewVector.MultiplyDeltaTime()
		Return NewVector 
	EndMethod

	Method Increase( Value! )'Add a value to the vectors length
		Local Angle# = GetAngle()
		X:+ Cos( Angle ) * Value
		Y:- Sin( Angle ) * Value
	End Method
	Method Plus( Value! )
		Increase( Value )
	EndMethod
	
	'		R O T A T E 
	'----------------------------------------------	
	Method Rotate( Angle! )
		Local CurrentAngle! = Direction()
		Local Length! = Length()
		
		X =  Cos( CurrentAngle + Angle ) * Length
		Y = -Sin( CurrentAngle + Angle ) * Length
	EndMethod
	Method AddAngle( Angle! ) 
		Rotate( Angle )
	EndMethod
		

			
	'		S U B T R A C T
	'----------------------------------------------		
	Method Subtract( Vector:Vector2D )
		X:- Vector.X 
		Y:- Vector.Y
		
		'This would also work
		'Self.Add( Vector.Copy().Reverse() )
	EndMethod	
		
	'		 D O T  P R O D U C T 
	'----------------------------------------------
	Method DOT!( Vector:Vector2D )
		Return ( X * Vector.X + Y * Vector.Y)
	EndMethod
	'Alternative Name
	Method DotProduct!( Vector:Vector2D )
		Return Self.DOT( Vector )
	EndMethod	
	
	'		M U L T I P L Y   V E C T O R 
	'----------------------------------------------
	Method Multiply( Value! )
		X:*Value
		Y:*Value	
	EndMethod
	
	'		M U L T I P L Y   /w  Delta Time
	'----------------------------------------------	'
	Method MultiplyDeltaTime()
		Self.Multiply( Delta.Time() )
	EndMethod
		
	'		N O R M A L I Z E 
	'----------------------------------------------	
	Method Normalize()
		Local Length! = Length()
		If Length = 0 Return'Don't divide by zero
		Set( (X / Length), ( Y / Length)  ) 'Make length = 1
	End Method	
		
	'		 U N I T   V E C T O R 
	'----------------------------------------------
	Method Unit:Vector2D()
		Local Vector:Vector2D
		Vector = Self.Copy()
		Vector.Normalize()		
		Return Vector'Returns a New vector with length = 1
	End Method

	'Check if this vector collides with another Vector
	'You need to specify the start point of both vectors
	'Returns null if no collision found, returns a vector if they do
	'the vector represents the intersection point.
	Method Collide:Vector2D( Q:Vector2D, ZStart:Vector2D ,QStart:Vector2D )
		
		'Z = Self 'Makes the equations easier to follow
		'We have two vectors: Z and Q, and their start points

		Local LineDeltaZ!'		 
		Local LineDeltaQ!'
							
		If Q.X = 0
			If Y = 0
				LineDeltaZ = 0
			Else	
				LineDeltaZ = ( QStart.Y - ZStart.Y) / Y
			EndIf		
		Else
			Local A = (QStart.Y - ZStart.Y)
			Local B = (Q.Y / Q.X)
			Local C = (ZStart.X - QStart.X )
			Local D = (Y - Q.Y * X / Q.X )
			If D = 0 
				LineDeltaZ = 0
			Else
				LineDeltaZ = ( A + B*C ) / D
			EndIf
			'ORIGINAL EQUATION on one single line - breaks if divide by 0
			'L1d = ( _Line.StartPoint.y - StartPoint.y + (L2y/L2x)*( StartPoint.x - _Line.StartPoint.x )) / ( L1y - L2y*L1x/L2x )
		EndIf
		
		'Are we on the line?
		If LineDeltaZ &gt;= 0 And LineDeltaZ &lt;= 1
		
			If Q.X = 0
				LineDeltaQ = 0
			Else	
				LineDeltaQ = ( ZStart.X + X*LineDeltaZ - QStart.X ) / Q.X 
			EndIf
			
			If LineDeltaQ &gt;=0 And LineDeltaQ &lt;=1 
				Local Xi = ZStart.X + LineDeltaQ*X
				Local Yi = ZStart.Y + LineDeltaQ*Y
				Return Vector2D.Create( Xi,Yi )
			EndIf	
		EndIf
		
		Return Null	

	End Method

	
	
	
	
	'===============
	' DEBUG COMMANDS
	'===============
	
	'	 	D R A W   V E C T O R 
	'--------------------------------------------------
	Method DrawModify( From:Vector2D , Multiply! , Xtra )
		DrawLine From.X + Xtra, From.Y, From.X + Xtra + X* Multiply , From.Y + Y* Multiply 
	EndMethod
	Method DrawXY( FromX, FromY, Multiply! , Xtra )
		DrawModify( Point(FromX, FromY) , Multiply! , Xtra )
	End Method	
	
	'	 	D R A W   R E A L   V E C T O R 
	'--------------------------------------------------
	Method Draw( Origin:Vector2D =Null )
		If Origin = Null Origin = Create( 0, 0 )
		DrawModify( Origin , 1 , 0 )		
	EndMethod

	'		 D R A W   V E C T O R    D A T A
	'-----------------------------------------------
	Method DrawData( sLen, sDir, X, Y )
		Local Row = 0
		If sLen DrawText "Length : "+Length(),X,Y	+Row*15; Row:+1
		If sDir DrawText "Dir : "   +Dir360(),X,Y	+Row*15; Row:+1
	End Method


	
EndType	' /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /
'------------------------------------------------------------------------







' 			C R E A T E  V E C T O R
'-----------------------------------------------
'Purpose: Creates a New Vector 			
'Parameters: X = Vectors X value ' Same For Y	
'Returns: New Vector Type						
'-----------------------------------------------
Function CreateVector:Vector2D( X!=0, Y!=0 )
	Return Vector2D.Create( X, Y )
EndFunction




'		 C O P Y   V E C T O R
'----------------------------------------------
'Purpose: Copies a Vector into a New vector	
'Parameters: VECTOR
'Returns: a VECTOR, exact copy of first VECTOR
'-----------------------------------------------	
Function CopyVector()
EndFunction	
	
		
'		 V E C T O R   D I R E C T I O N
'----------------------------------------------------
'Purpose: Calculates the direction of a vector		
'Parameters: VECTOR
'Returns: Degrees
'Note on Angel: 0 is Left, 90 is down (BlitzStyle)
'Note LastDir: If Length = 0 this Function returns LastDir
'---------------------------------------------------------
Function VectorDirection!( Vector:Vector2D )
EndFunction

	'		 D O T  P R O D U C T 
'---------------------------------------------------
'Purpose: Calculated the Dot-Product of Two Vectors			
'Parameters: Two vectors you want to "Dot"
'Returns: The result   				
'---------------------------------------------------
Function Dot!(Vector:Vector2D,Vector2:Vector2D)

	Return Vector.DOT( Vector2 )	
	
End Function
'Alternative Naming (Both these works the same)
Function DotProduct!(Vector:Vector2D,Vector2:Vector2D)

	Return Vector.DOT( Vector2 )
	
End Function

'		N O R M A L I Z E 
'----------------------------------------------	
'Purpose: Sets Vector length To ONE but keeps 
' it's direction		
'Parameters: VECTOR to normalize
'-----------------------------------------------
Function Normalize()
EndFunction

'		 U N I T   V E C T O R 
'----------------------------------------------
'Note: This is same as Normalizing a vector
' except that this function does not alter the
' original vector. Instead it return a new vector
Function Unit()
EndFunction



' 			D R A W  V E C T O R
'__________________________________________________
'Purpose: Draws the vector from the specifed point
'Parameters: X,Y location		
'--------------------------------------------------
Function DrawVector( Vector:Vector2D, From:Vector2D , Multiply!=20 , Xtra=0 )
	Vector.DrawModify( From , Multiply! , Xtra )
EndFunction


	
'		 D R A W   V E C T O R    D A T A
'-----------------------------------------------
'Purpose: Prints the data of a vector		
'Parameters: sLen=ShowLength, SDir=ShowDirection
' X and Y = Where to start draw the data (text)
'-----------------------------------------------
Function DrawVectorData( Vector:Vector2D, sLen=True, sDir=False, X=10, Y=20 )
	Vector.DrawData( sLen, sDir, X, Y )
EndFunction
Function DrawVectorInfo( Vector:Vector2D, sLen=True, sDir=False, X=10, Y=20 )
	Vector.DrawData( sLen, sDir, X, Y )
EndFunction


Rem
	If you ever need a function to check something of a point you can
	use the vector to check against (position vector for example)
	Ex drawline( Point(50,100), ShipPosition:Vector )
EndRem
Function Point:Vector2D( X! , Y! )
	Local Vector:Vector2D= New Vector2D
	Vector.X = X
	Vector.Y = Y
	Return Vector
EndFunction	

Function DrawLineToPointFromOrigin( Start:Vector2D, Origin:Vector2D )
	DrawLine Start.X, Start.Y, Start.X + Origin.X , Start.Y + Origin.Y 		
EndFunction




' /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /

'		 D E L T A  T I M E

'------------------------------------------------------------------------
	Type Delta 
	'		
	'-----------------------------------------------------
	' This type is Fully global. Which means you'll always 
	' refere to it as Delta.Start() , Delta.Time(),
	' Delta.Update() 
	'
	' You shouldn't create instances of this type!
	' DeltaTime is same for all your objects!
	'
	Global DeltaTime!
	Global TimeDelay%
	
	'Run this once before your main loop
	'If you don't there will be a jump in deltatime
	Function Start()
		TimeDelay = MilliSecs()
	End Function
	
	'Everytime where you want to get the deltatime
	'call this: Delta.Time
	'You should multiply this to every place which 
	'adds to you position/speed/acceleration
	'
	' The basic rule is to add deltatime to all
	' things which gets added to every frame
	' Like Speed:+ 10*Delta.Time
	'
	' If you use the Vector Library simply use 
	' AddDelta() instead of Add()
	' And
	' AddDeltaNew() Instead of AddNew()
	
	Function Time!()
	
		Return DeltaTime!
	
	End Function
	
	'Put this once in your main loop
	'it calculates the current deltatime
	'depeding on your framerate or more exact
	'the time between each/the last frame.
	Function Update()
	'_____________________________________________________ 
	'Purpose: Calculates DeltaTime , put it in mainloop			
	'-----------------------------------------------------	
			DeltaTime = ( MilliSecs()- TimeDelay )*0.001
			TimeDelay  = MilliSecs()			
		
	EndFunction
		
End Type	' /  /  /  /  /  /  /  /  /  /  /  /  /  /  /  /
'----------------------------------------------------------------------------------------	

</textarea><br><br>Line2D.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import "Vector2D.bmx"

Rem

	Most things have been changed to fit witht he Vector2D library.
	I'm sure more things can be adapted to using Vectors instead of XY
	
	I'm sorry to say that none of this is tested yet, so there might be typing erros
	'Most of the conversion was about changing varibable names, but you will also see many 
	methods having acomplete workover, they should still work as before.

EndRem



Type Line2D Extends Vector2D

	Global List:TList
	Field StartX,StartY
	Field EndX,EndY
	Field Normal:Vector2D
	
	'Create a Line from XY coordinates
	Function CreateLineXY:Line2D( StartX, StartY, EndX, EndY )
		Return CreateLine( Point(StartX, StartY), Point(EndX, EndY) )
	EndFunction
		
	Function CreateLine:Line2D( From:Vector2D, To_:Vector2D  )
		Local Line:Line2D = New Line2D
		Line.StartX = From.X
		Line.StartY = From.Y
		Line.EndX = To_.X
		Line.EndY = To_.Y
		Line.UpdateLine()
		
		Line.Normal = Null'Not calculated, should it be?
		Return Line 	
	End Function
	
	Method SetLine( LineVector:Vector2D )
		X = LineVector.X
		Y = LineVector.Y
		GetNewEndPoint()
	EndMethod
	
	Method New()
		If Not List Then List = CreateList()
		List.AddLast( Self )
	EndMethod

	' D R A W   L I N E
	Method DrawLine2D()
	'	Draw( Point(StartX , StartY) )
	'	DrawLine StartX,StartY,StartX + X,StartY + Y
		DrawLine StartX,StartY,EndX,EndY		
		
	End Method
		
	Method ExtendLineEnd( Amount! )
		Increase( Amount )
		GetNewEndPoint()
	End Method
	
	Method ExtendLineStart( Amount! )
		Increase( Amount )
		GetNewStartPoint()
	End Method
	
	Method ExtendLineMid( Amount! )
		Increase( Amount/2 )
		GetNewStartPoint()		
		Increase( Amount/2 )
		GetNewEndPoint()
	EndMethod
			
	Method SetLineLength( Length! )
		'How much larger is our line?
		Local Difference! = ( Self.Length() - Length )
		ExtendLineEnd( Difference )
	EndMethod
		
	Method Reverse()
		Super.Reverse()
		Local TempX! = StartX
		Local TempY! = StartY
		StartX = EndX
		StartY = EndY
		EndX = TempX
		EndY = TempY
	End Method
	
	Method GetNewEndPoint()
		EndX = StartX + X
		EndY = StartY + Y		
	EndMethod
	
	Method GetNewStartPoint()
		StartX = EndX - X
		StartY = EndY - Y		
	EndMethod
	
	Method UpdateLine()
		X = ( EndX - StartX ) 
		Y = ( EndY - StartY )
	EndMethod
				
	Method RotateAroundStartPoint( Angle! )
		SetDirection(Angle)
		Local Length# = GetLength()
		EndX = StartX + ( Cos(Angle) * Length)
		EndY = StartY - ( Sin(Angle) * Length)
	EndMethod	
	
	Method RotateAroundEndPoint( Angle! )
		SetDirection(Angle)
		Local Length# = GetLength()	
		StartX = EndX + ( Cos(Angle) * Length)
		StartY = EndY - ( Sin(Angle) * Length)
	End Method
	
	Method CalculateNormal()
		If Not normal Return
	'Both these ways should work (WARPY)
	'But none of them do!?
	
	'	Local Angle# = ATan2( X, Y )
	'	Normal.X = Cos( Angle + 90 )
	'	Normal.Y = Sin( Angle + 90 )
	
	'OR
	
		Normal.X = 1
		Normal.Y = - X/Y		
		'Normal.Normalize()
	EndMethod
	
	Rem 'THIS METHOD SHOULD MOVE THE START POINT OF THE LINE
	'    WHILE THE LEANGTH AND DIRECTION SHOULD BE UNNAFFECTED
	Method MoveStartOfLineTo(  X!, Y!  )
	
	Endmethod
	Method MoveEndOfLineTo(  X!, Y!  )
	
	Endmethod	
	EndRem
	
	Method MoveStartToXY( X!, Y! )
		StartX = X
		StartY = Y
		UpdateLine()	
	EndMethod
	
	Method MoveEndToXY( X!, Y! )
		EndX = X
		EndY = Y
		UpdateLine()
	EndMethod
		
	Method Add( Vector:Vector2D )
		Super.Add( Vector )'Add Vectors
		'The StartPoint Remains the same
		GetNewEndPoint()
	End Method

	Method AddLine( Line:Line2D )
		Add( Vector2D.Create( Line.X, Line.Y) )
	End Method
	
	'This method is scary..
	'It returns True if the lines collide
	
	'Return Vector with position of impact (intesection point)
	Method CollideLine:Vector2D( Line:Line2D )', Xi Var , Yi Var)

		Local LineDeltaA!' - L1d		 
		Local LineDeltaB!' - L2d
		Local A,B,C,D 'Variables to hold the equation
					
		'Local L1x#,L1y#,L2x#,L2y#
	
	'	L1x = EndPoint.x-StartPoint.x
	'	L1y = EndPoint.y-StartPoint.y
	'	Self

	'	L2x = _Line.EndPoint.x-_Line.StartPoint.x
	'	L2y = _Line.EndPoint.y-_Line.StartPoint.y
	'	Line.X
		
		Rem Linebelow: May Or may Not be required
		If L2x = 0 Then L2x =0.00001  ''' Just as small it can be
		EndRem
		
		If Line.X = 0
			If Y = 0
				LineDeltaA = 0
			Else	
				LineDeltaA = (Line.StartY - StartY) / Y
			EndIf		
		Else
			A = (Line.StartY - StartY)
			B = (Line.Y / Line.X)
			C = (StartX - Line.StartX )
			D = ( Y - Line.Y * X / Line.X )
			If D = 0 
				LineDeltaA = 0
			Else
				LineDeltaA = ( A + B*C ) / D
			EndIf
			'ORIGINAL EQUATION on one single line - breaks if divide by 0
			'L1d = ( _Line.StartPoint.y - StartPoint.y + (L2y/L2x)*( StartPoint.x - _Line.StartPoint.x )) / ( L1y - L2y*L1x/L2x )
		EndIf
		
		'Are we on the line?
		If LineDeltaA &gt;= 0 And LineDeltaA &lt;= 1
		
			If Line.X = 0
				LineDeltaB = 0
			Else	
				LineDeltaB = ( StartX + X*LineDeltaA - Line.StartX ) / Line.X 
			EndIf
			
			If LineDeltaB &gt;=0 And LineDeltaB &lt;=1 
				Local Xi = StartX + LineDeltaA*X
				Local Yi = StartY + LineDeltaA*Y
				Return Point( Xi, Yi )'A Vector2D
			EndIf	
		EndIf
		
		Return Null	

	End Method

' Another version of the method below
'	Method ReflectedVector:Vector2D( Vector:Vector2D, Start:Vector2D )
'		Return ReflectedLine( VectorLine(Vector:Vector2D, Start:Vector2D) )
'	EndMethod
	
Rem	'THIS METHOD IS PARTIALLY CONVERTED
	Method ReflectedLine:Vector2D( Line:Line2D )
		'Local xi# , yi#
		Local X:Vector2D
		
		Intersection:Vector2D = GetCollideLinePoint( Line )		
		
		If X
			Local VLine:Line2D
			'VLine = Line2D.CreateVertical( Line , Intersection.X , Intersection.Y , 100)
			ReflectVector = Vector2D.Create( Line.X , Line.Y )
			ReflectVector.Rotate( 90 )'Make it Vertical
						
			Local Angle# =  ReflectVector.Angle() - Self.GetAngle() 
			Angle# = Angle*2 + GetAngle()
						
			'ReflectVector = Vector2D.Create() 'Line2d.CreateXY( Intersection.X , Intersection.Y , Intersection.X - 100 , Intersection.Y )
						 
			If tr = True Then Angle:-180
			VLine.SetAngle( Angle )
			
			If tr = True  Then VLine.SetLineLength( VectorFrom( Point( EndX, EndY ), Intersection ).Length() )'Sqr( (EndX - xi)*(EndX - xi) + (EndY - yi) * (EndY - yi) ))
			If tr = False Then VLine.SetLineLength( VectorFrom( Intersection, Point( EndX, EndY ) ).Length() )'Sqr( (StartX - xi)*(StartX - xi) + (StartY - yi) * (StartY - yi) ))
			Return VLine
			
		End If

		Return Null
	End Method
EndRem
		
Rem 'THIS is THE ORIGINAL OF THE ABOVE - CONVERION NOT COMPLETE!		
	Method ReflectedLine:Line2d(L2:Line2d , tr:Byte = 1)
	Local xi# , yi#
		If GetCollideLinePoint(xi , yi , L2)		
			Local L3:Line2d = Line2d.createVertical(L2 , xi , yi , 100)
			Local an# =  L3.getAngle() - getAngle() 
			L3 = Line2d.createXY(xi , yi , xi-100 , yi)
			an = getAngle() + an*2
			If tr = True Then an:-180
			L3.setAngle(an)
			If tr = True Then L3.setLength(Sqr( (EndPoint.x - xi)*(EndPoint.x - xi) + (EndPoint.y - yi) * (EndPoint.y - yi) ))
			If tr = False Then L3.setLength(Sqr( (StartPoint.x - xi)*(StartPoint.x - xi) + (StartPoint.y - yi) * (StartPoint.y - yi) ))
			Return L3
		End If
		Return Null
	End Method
EndRem
	
	Function CreateParallel:Line2D( Line:Line2d , From:Vector2D , _Length# )
			Local ParallelLine:Line2d 'Our new Line
			ParallelLine = VectorLine( Line, From )'Make a Line from our Line
			Return ParallelLine
	EndFunction		
			
	Function CreateVertical:Line2d( Line1:Line2d , From:Vector2D , _Length# )
			Local VerticalLine:Line2D
			VerticalLine = Line2D.CreateLine( From , Point(Line1.StartX , Line1.StartY) )
			VerticalLine.RotateAroundStartPoint( Line1.Angle() + 90 )
			Return VerticalLine
	End Function
		
EndType


'Simple as this - From Vector to Line
Function VectorLine:Line2D( Vector:Vector2D, Start:Vector2D )
	Local Line:Line2D = New Line2D
	Line.X = Vector.X
	Line.Y = Vector.Y
	Line.StartX = Start.X
	Line.StartY = Start.Y	
	Line.GetNewEndPoint()
	Return Line
EndFunction
</textarea><br><br>Line2D_Example.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import "Line2D.bmx"

Local L1:Line2d = Line2D.CreateLineXY(100 , 180 , 400 , 180)
Local L2:Line2d = Line2D.CreateLineXY(300 , 180 ,200 , 300)

SetGraphicsDriver GLMax2DDriver()
Graphics 1024 , 756 , 0
SetClsColor 40 , 40 , 40

'A point on the middle of the line
Global L1_LineMid:Vector2D =  Vector2D.Create(1,0)

While Not KeyDown(Key_Escape)

	Test(L1 , L2)
	SetColor 225,225,225
	DrawText "Your FPS is: "+FPS.Calc() , 400 , 10
	
	DrawText "DEBUG:    Line1  X: "+L1.X		+"  Y: "+L1.Y		+" ",20,50
	DrawText "          Start  X: "+L1.StartX+"  Y: "+L1.StartY	+" ",20,70	
	DrawText "          End    X: "+L1.EndX	+"  Y: "+L1.EndY	+" ",20,90
	
	DrawText "DEBUG:    Line2  X: "+L2.X		+"  Y: "+L2.Y		+" ",20,130
	DrawText "          Start  X: "+L2.StartX	+"  Y: "+L2.StartY	+" ",20,150	
	DrawText "          End    X: "+L2.EndX	+"  Y: "+L2.EndY	+" ",20,170
	
'	DrawLine L1.StartX,L1.StartY,L1.EndX,L1.EndY		
'	DrawLine L2.StartX,L1.StartY,L1.EndX,L1.EndY				
		
	Flip; Cls; FlushMem
Wend
End


Function Test(L1:Line2d , L2:Line2d )
	SetColor(255 , 40 , 40)
	L1.DrawLine2D()
	
	SetColor(40 , 255 , 40)
	L2.DrawLine2D()
	
	'This calculated the position (L1_LineMid) of the middle of line 1 (RED LINE)
 	L1_LineMid.Set( ( L1.StartX + L1.EndX ) / 2, ( L1.StartY + L1.EndY ) / 2 ) 


	'Show the normal of Line 1 ( RED LINE )
	L1.CalculateNormal()' DOES NOT WORK!
	SetColor 0,0,255
	
	'Draw the Normal as a BLUE vector
	'L1.Normal.DrawModify( L1_LineMid, 1 , 0)'Normal not created so it is NULL
	'L1_LineMid.DrawModify( Point(0,0) , 1 , 0)
		
	SetColor 255,255,0 
	
	If KeyDown(Key_1)
		L1.MoveStartToXY( MouseX(), MouseY()  )
	End If
	If KeyDown(Key_2)
		L1.MoveEndToXY(   MouseX(), MouseY()  )
	End If
	If KeyDown(Key_3)
		L2.MoveStartToXY( MouseX(), MouseY()  )
	End If
	If KeyDown(Key_4)
		L2.MoveEndToXY(   MouseX(), MouseY()  )
	End If
	
	'If L1.CollideLine( L2) DrawText "LINES IS COLLIDING",10,10
	
'	Local r:Line2d = L1.reflectedLine(L2 , True)
	If L1.CollideLine( L2 )
		DrawText "LINES IS COLLIDING",10,10
	End If
		
	
End Function






Type FPS

	Global Counter, Time, TFPS

	Function Calc%()
	'	FPS_Counter    &lt;&gt; Runs And displays the FPS
	'	--------------------------------------------
			Counter:+1
		
			If Time &lt; MilliSecs()
				TFPS = Counter
				Time = MilliSecs() + 1000'Update
				' &lt;- Frames/Sec
				Counter = 0
			EndIf
			
		Return TFPS
	'	;--------------------------------------------
	EndFunction
	
EndType
</textarea> <br><br></td></tr></table><br>
<a name="590805"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> My above post contains my latest additions to Line2D and Vector2D and the Example for Line2D. (Save them and try)<br><br>See how Line2D inherits Vector2D and uses many of the methos that already exists in Vector2D.<br><br>I don't have more time now and I didn't finnish the collision and reflection conversion (something is wrong). Take a look at it and see what you can do. (Compare with the old version if need be). <br><br>The reason I want to return a Vector instead of a line is that in most cases what you want is to alter the velocity vector of an object - not the objects velocity line. But you are most likley to want to collide against the line. So it's a Vector/Line Collision.<br><br>As always: Any additions, fixes, comments and suggestions are welcome!<br><br>@Haramani you added the Line2D to the right place. When you add a page you also need to link it from the main page. Go to the MAxPhysics Main page in the Wiki and cliock the [Edit] Tab. Add a link to MaxPhysics_Line2D. I have already fixed it for Line2D, but next time you might want to give it a try. When you click edit you will see how a link is supposed to look like, simple change the name to the page you want to add to the wiki. Also the main project plan is also open for EVERYONE to change and add to! Don't be feared by the fact that I started the project, it's public after all. <br><br></td></tr></table><br>
<a name="590808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> And if someone manage to fix the new Line2D, please update both Line2D and Vector2D with example in the Wiki.<br><br>I'll be away for some days now. Til then, good luck everyone and keep going! <br><br></td></tr></table><br>
<a name="591202"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Change to the <a href="http://www.blitzwiki.org/index.php/MaxPhysics_Line2D" target="_blank">http://www.blitzwiki.org/index.php/MaxPhysics_Line2D</a><br>Not yet as Wave's post above but in the getCollidePoint method Of the Line2d.<br>Pls check the Demo : Line2d_Reflection. For bugs. <br><br></td></tr></table><br>
<a name="591528"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> As was looking thru the Line2d sugested by Wave 4 posts above I came in a conclusion that if we really have to extend Vector2d the x , y fields by the Vector2d will be the start point of tha line and then the field of Line2d End:vector2d will be the rest.<br><br>In my point of view we don't need to extend Vector2d for the Line2d. We can create a method or function so we can take A vector2d from the line2d. We have just to subtract the first Vector2d of the Line from the Last one.<br>That's all from me. Sadly Wave will be away... so I cannot discuss this with him.(So I will continue as I have posted the Line2d in the blitzWiki) <br><br></td></tr></table><br>
<a name="592232"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm back! <br><br>The idea to expand Line2D with Vector2D is so that all methods for changing rotation, checking length, copying, scaling; any vector math that our line would need will automatically be inherited. No duplicate code; Easier omptimizations later.<br><br>I agree that to have a Line we only need a Vector and a StartPoint (or EndPoint) or A Startpoint and a endpoint and no Line. I think a startpoint and a vector for the Line itself feels like the most innutive. And the endpoint can still be there, for easy access (Though not 'really' required). <br><br>Another possible solution would be for line2D to not extend vector. And with all line math for intersections reflections and such already put inside Vector2D. In which Line2D merly use these method on itself. Though the line/and its start and end points need to be vectors.<br><br>Having line inherit vector makes this difference:<br><br>*If Inherits Vector<br>Line:Line2D = New Line2D<br>Line.X and Line.Y &lt;--- a Vector2D<br>Line.EndPoint.X  Line.EndPoint.Y &lt;--- a Vector2D<br>Line.StartPoint.X  Line.StartPoint.Y &lt;--- a Vector2D<br><br>*Line not inherited<br>Line:Line2D = New Line2D<br>Line.Main.X and Line.Main.Y &lt;--- a Vector2D<br>Line.EndPoint.X  Line.EndPoint.Y &lt;--- a Vector2D<br>Line.StartPoint.X  Line.StartPoint.Y &lt;--- a Vector2D<br><br>*Line as it is now<br>Line:Line2D = New Line2D<br>Line.X and Line.Y        &lt;--- a Vector2D<br>Line.EndX  Line.EndY<br>Line.StartX  Line.StartY<br><br><br>*Any other idea? <br><br></td></tr></table><br>
<a name="594381"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I update Vector2D with function for calculating the normal of a vector. In other words how to get a perpendicular vector, right and left side. <br><br>It was as easy as this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	'	 M A K E   L E F T   N O R M A L
	'----------------------------------------------	
	Method MakeLeftNormal()
		Return Set( Y, -X )
	EndMethod

		
	'	 M A K E   R I G H T   N O R M A L
	'----------------------------------------------	
	Method MakeRightNormal()
		Return Set( -Y, X )
	EndMethod

</textarea> <br><br></td></tr></table><br>
<a name="594536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woohoo! Circle Collision works! And I manage to do it myself first time ever it works on the first try. We need to mix this with line2D.<br><br>Check this out:<br><br>Circle2D.bmx - Includes a demo where you push around a circle!<br>Version: First<br>Dependencies: import latest Vector2D.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import "Vector2D.bmx"

Type Shape2D Abstract

	Method ShapesOverlap( Shape:Shape2D )
	EndMethod
	
	Method ShapesCollide:Vector2D( Shape:Shape2D )
		'A Shape Collides Against another Shape
	EndMethod
	
EndType


Type Circle2D Extends Shape2D

	Field Position:Vector2D = Point(0,0)
	Field Radius! = 1

	Function Create:Circle2D( X, Y, Radius! ) 
		Local Circle:Circle2D = New Circle2D
		Circle.Position.Set(X,Y)
		Circle.Radius = Radius
		Return Circle
	End Function
	
	'Circle vs another Shape
	'Returns the projected vector required to push us out of collision
	Method ShapesCollide:Vector2D( Shape:Shape2D )
		Select Shape
			Case Circle2D( Shape )
				Return CollideCircleReflect( Circle2D( Shape) )
			'Case Line2D( Shape )
			'	Return CollideLineReflect( Line2D( Shape ) )			
			'Case Polygon2D( Shape )
			'	Return CollidePolygonReflect( Polygon2D( Shape ) )						
		EndSelect
	EndMethod
	
	'Circle vs another Shape
	Method ShapesOverlap( Shape:Shape2D )
		Select Shape
			Case Circle2D( Shape )
				Return CollideCircle( Circle2D( Shape) )
			'Case Line2D( Shape )
			'	Return CollideLine( Line2D( Shape ) )			
			'Case Polygon2D( Shape )
			'	Return CollidePolygon( Polygon2D( Shape ) )						
		EndSelect
	EndMethod
	
	'Just check collision - Quick version
	Method CollideCircle( Circle:Circle2D)
		Local Distance! = Distance( Position, Circle.Position )	
		Local Amount! =  ( Radius + Circle.Radius ) - Distance
		If Amount &gt; 0 Then Return Amount Else Return False
	EndMethod
	
	Method GetAngleToCircle!( Circle:Circle2D )
		Local Reflect:Vector2D = Vector2D.CreateFrom( Position, Circle.Position )
		Return Reflect.Dir360() 'Or Angle() - depends on the form you want
	EndMethod
	
	'------------------------------------------------------------------------
	'Check for collisions, if collision detecte it return a reflection vector 
	'The reflection vector has the same length and direction required to push
	'the circle out-of collision with the other circle
	'------------------------------------------------------------------------
	Method CollideCircleReflect:Vector2D( Circle:Circle2D )
		Local Magnitude! = CollideCircle( Circle )
		Local ReflectAngle = GetAngleToCircle!( Circle )
		Return Vector2D.CreateField( Magnitude!, ReflectAngle )
	EndMethod
	
	Method Draw()
		DrawOval Position.X - Radius, Position.Y - Radius, Radius*2, Radius*2
	EndMethod
					
EndType

Function Distance!( Position1:Vector2D, Position2:Vector2D )	
	Local DX! = Position2.X - Position1.X
	Local DY! = Position2.Y - Position1.Y
	Return Sqr(DX*DX + DY*DY)
EndFunction

Local CircleA:Circle2D = Circle2D.Create(100 , 100 , 100)
Local CircleB:Circle2D = Circle2D.Create(320 , 240 , 50)
Local CircleB_Mobile = False 'Can we move B?

Graphics 640 , 480 , 0

While Not KeyDown(Key_Escape)
DrawText "Move around, Press SPACE to make the RED circle MOBILE.",10,10

	SetColor 0 , 200 , 0 'Green
	CircleA.Draw	
	SetColor 200 , 0 , 0' Red
	CircleB.Draw
	
	If KeyHit( Key_Space )
		If CircleB_Mobile = True Then CircleB_Mobile = False Else CircleB_Mobile = True
	EndIf
	
	SetColor 0 , 0 , 255' Blue
	Local OverlapDist = CircleA.CollideCircle( CircleB )
	Local OverlapAng  = CircleA.GetAngleToCircle( CircleB )
	If OverlapDist 
		DrawText "COLLIDING!   by : "+OverlapDist+", Angle: "+OverlapAng ,50,50
		
		Local Reflection:Vector2D = CircleA.CollideCircleReflect( CircleB )
		Reflection.Draw( CircleA.Position )
		
		If CircleB_Mobile = True
			CircleB.Position.Add( Reflection )
		EndIf
	
	EndIf
																									
	CircleA.Position.Set( MouseX(), MouseY() )
	Flip;Cls
Wend
</textarea> <br><br></td></tr></table><br>
<a name="594860"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good job. Keep it up guys. I'll be adding some things again soon. I've just been busy with work. We'll eventualy have it. <br><br></td></tr></table><br>
<a name="595095"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok I Changed the Line2d.<br><br>go here : <a href="http://www.blitzwiki.org/index.php/MaxPhysics_Line2D" target="_blank">http://www.blitzwiki.org/index.php/MaxPhysics_Line2D</a> for more details in the Comments on Updates, Additions and Fixes section and the source code. <br><br></td></tr></table><br>
<a name="595461"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like the new Line2d very much! <br><br>A pointer, I would like for the Line2D objects to be called Line:Line2D and not _Line2D:Line2D, as that kinda beats the purpose with having our Line called Line2D and not TLine or something. Same with Vector:Vector2D, I think that makes the code easier to follow. If it's okey for you then we can swiftly fix it with a simple replace. Same with Circle:Circle2D ;)<br><br>GetCollideLinePoint() - The place where you divide. I would like to divideup that calculation up on four lines:<br><pre class=code>
Local ua:Float = ( (x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3) ) / ( (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1) )
Local ub:Float = ( (x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3) ) / ( (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1) )
''''''''''''''''''
' Instead of the two line above:
local A = (x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3) )
local B = (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1) 
local C = (x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3)
If B = 0 return
Local ua:Float = ( A / B )
Local ub:Float = ( C / B )
</pre><br><br>I fear nill values you see ;)<br><pre class=code>
Local sx# = x2-x1
Local sy# = y2-y1

Local q# = ((px-x1) * (x2-x1) + (py - y1) * (y2-y1)) / (sx*sx + sy*sy)
''''''''''''''''
'' I suggest replacing above lines with these:
Local sx# = x2-x1
Local sy# = y2-y1
local Sq = (sx*sx + sy*sy)
if Sq = 0 return
Local q# = ((px-x1) * (x2-x1) + (py - y1) * (y2-y1)) / Sq
</pre><br><br><br>I'll look more into it ;)<br>I'll let you update the changes, or if you want me to I'll do it. <br><br></td></tr></table><br>
<a name="595471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm working on your line-circle collide. I wish I manage to make it work with reflection/bounce.<br><br>Soon it will be time to put this system together, I'll make a MaxPhysics Main File (which includes every thing) and also the collision planes idea. What it means is that we after that only need to import one file, the Main. <br><br></td></tr></table><br>
<a name="595481"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wave : I have no problem with all your sugestions above. <br>Make any changes you think it ' s for good.<br><br>I can't find so far a good way for the Circle Line Collision responce.<br><br>P.S. I have to tell you that I am not a Mathimatician and I don't have the knowledge of Vector Mathimatics and I just searching the Internet and expirimenting to find the solution I wand. <br><br></td></tr></table><br>
<a name="595492"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not the best, still need some tweaks. At least it is a working start. Requires some bugfixes in Vector2D so make user you get the latest version of it before you test this demo. Still no changes to Circle2D.<br><br><br>--Bounce/slide--<br>The solution is at hand:<br><br><pre class=code>
Strict

Include "Line2d.Bmx"
Include "Circle2d.bmx"
Include "Vector2D.bmx"

Global WallA:Line2D = Line2D.CreateLineXY(10 , 400 , 500 , 500)

Global BallA:Circle2D = Circle2D.Create(200 , 80 , 40)

Global BallB:Circle2D = Circle2D.Create(100 , 50 , 50)
Global BallB_Velocity:Vector2D= CreateVector()

Global Gravity:Vector2D = CreateVector(0, 0.03)'Constant Gravity Acceleration
Global SurfaceNormal:Vector2D = CreateVector(0,0)

Global Reflect:Vector2D = CreateVector(0,0)

Graphics 640 , 480 
While Not KeyDown(KEY_ESCAPE)
	Cls
	
	BallB_Velocity.Add( Gravity )'Apply Gravity
	BallB.Position.Add( BallB_Velocity )
	
	'''''The BallA Loop
	Local pre:Vector2d = BallA.position.copy()
	
	SetColor 0 , 255 , 0
	BallA.Draw()

	SetColor 255,0,0
	BallB.Draw()
	
	If WallA.OverLapCircle2d( BallB )
		SurfaceNormal.MakeRightNormalFrom( WallA )
	
		Reflect = GetReflect( SurfaceNormal, BallB_Velocity )
	
		BallB_Velocity.Add( Reflect )
		BallB_Velocity.Multiply( 0.7 )
	EndIf		

	SetColor 255,155,0'YELLOW
	BallB_Velocity.DrawModify( BallB.Position, 20 ,0 )	
		
	SetColor 255,255,255'REFLECT	
	Reflect.DrawModify( BallB.Position, 20 ,0 )
			
	'''''check for overlap
	Local Dist! = WallA.OverLapCircle2d(BallA)
	If Dist 
		SetColor 200 , 200 , 200
		DrawText "OVerLap , Distance : " + Dist , 10 , 10

	End If

	''To set the BallA Position for testing
	If MouseDown(1)
		BallA.Position.x = MouseX()
		BallA.Position.y = MouseY()
	End If
	

								
	'''The Stage Drawing
	SetColor 255 , 0 , 0
	WallA.LineDraw()
		'to move the wall
	If KeyDown(Key_1)
		WallA.setXY1(MouseX() , MouseY())
	End If
	If KeyDown(Key_2)
		WallA.setXY2(MouseX() , MouseY())
	End If
	
	Flip
Wend


	
	'Get Reflection Vector
	'---------------------
	'This is a part of physics objects when we implement it
	Function GetReflect:Vector2D( SurfaceNormal:Vector2D, Velocity:Vector2D )
		If Not SurfaceNormal Return
		If Not Velocity Return

	
	'	Local A! 	= SurfaceNormal.Dot( Velocity )
	'	Local B! 	= SurfaceNormal.Length() * Velocity.Length()
	'	Local ReflectAngle!  = ACos( A / B )
		
		Local SurfaceAngle!  = SurfaceNormal.Angle()
		Local VelocityAngle! = Velocity.Angle()		
		Local ReflectAngle! = VelocityAngle-SurfaceAngle
				
		Local Reflect:Vector2D = Vector2D.CreateField( Velocity.Length(), ReflectAngle )

		Return Reflect
	
	EndFunction	
	

						
		'Local Reflect:Vector2D = SurfaceNormal.Copy()
		'Reflect.Multiply( 2*SurfaceNormal.Dot( Velocity) )
		'Reflect.Subtract( Velocity )
		
	
	
	
	
	
	
	
	
	
	
	
	
</pre><br><br><div class="quote"> I am not a Mathimatician <br></div>Neither am I. Though I have studied physics, mechanics and vector math -linear algebra. <br><br></td></tr></table><br>
<a name="595498"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also I saw you added a "help us" headline in Line2D. That is a very good idea and makes it so much easier for people who want to help. That should be a standard in every WIKI page of this project!<br><br>EDIT:<br>Updated Line2D with minor name changes. Made the code a little neater according to me, so no code changes. <br><br></td></tr></table><br>
<a name="595565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yet another Circle Line Collision Demo but not Perfect.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem 
	I am going to use the document Generic_Collision_Detection_for_Games_Using_Ellipsoids
	you can find it in www.fluidstudios.com somewhere
	So I will use the headlines of the document to make it easy to understand what
	I am trying to do.
	I am doing this because I am not going to use Matrixes and Computer Graphics technics
	and I have a hope that someone may Look in to this and use those technics and make the whole
	think lighter(But more complex)
	Also it will be and a good tutorial for someone outside of collisions to start playing with them.
End Rem

Rem 
	Some Instruction
	Press F to set the Velocity realtivy mouse position and Circle position
	Press 1 or 2 to change the edges of the Red Line to the Mouse Position
	Press the mouse button to move the ball to the mouse position
End Rem
	

Strict
Include "Vector2d.bmx"
Include "Line2d.bmx"
Include "Circle2d.bmx"

Local Line:Line2d = Line2d.createLineXY(10 , 300 , 300 , 300)
Local Circle:Circle2d  = Circle2d.create(100 , 100 , 20)
Local CVel:Vector2d = createVector(10,10)
Local Grav:Vector2d = createVector( 0 , 0.98)

'''''''''''''''''''''''''''''''''''''
''''''''COLIDING A SPHERE WITH A PLANE
''''''''''''''''''''''''''''''''''''	
	''I will do it just with lines not planes , you will understand the difference
		''Because I wand it to work in both sides
''''''' C the Circle to move , Vel the velocity of the circle , L the Line to check for collision
Function CircleMove(C:Circle2d , Vel:Vector2d , L:Line2d)
	Local N:Vector2d = L.copy() ''''copy the Line
	N.MakeRightNormal()  	''' Make the Normal of the Line 
	'''' Becarefull the Line will work only in one side for example if the Line starts at
	'''''' x = 0 and and y = 100 and ends at x = 100 and y = 100
	''''''''' The Cricle must be above of the Line. For example Circle.position y = 50
	N.setLength(C.Radius) 'Set the normal's length to be equal to the radius of the circle
	SetColor 0 , 0 , 255 ''' To have Some visuals
	N.Draw(C.position) '''' of what is going on
	'''''' Now I will create a Vector named CCol that will present the point of the Circle Line collition point
	''''''' Like the ponit in the Figure 3 of the document The start of the Gray line Labaled 'B'
	Local CCol:Vector2d = Point(C.position.x + N.x , C.position.y + N.y)
	SetColor 200 , 200 , 200 	''' To visual the 
	drawpoint(CCol , 2)		''' ponint
	'''' Now Let's create a line that will present the Velocity of the Line or just can say
	''''''''' The gray line Labeled 'B' in the figure 3
	Local LineB:Line2d = Line2d.createLine(CCol , Vel) '''' This way of Line creation take Values
	'''' That present the StartPoint of the Line the first value and tha vector to be used the second one.
	''''Let's Draw this too
	SetColor 200 , 200 , 200 '' to Be gray...
	LineB.LineDraw()
	'''Now let's check for collision of the LineB and the Line and if it is a collison to get the point.
	Local xi! , yi! ''' those are the doubles that will take tha x y values of the collision point
	If L.getCollideLinePoint(xi , yi , LineB) '''' to check first of all if there is a collision
		Local CColLine:Vector2d = point(xi , yi) '''' the point of collision
		CColLine.subtract(N) ''''' to set the nessesary point to pressent the Circle Line Collision
		'''' Some visuals
		Local CircleCol:Circle2d = Circle2d.create(CColLine.x , CColLine.y , C.Radius)
		SetColor 50 , 150 , 50
		CircleCol.draw()
	End If
	Local EmbededLine:Line2d = Line2d.createLine(C.position , N) 
	If L.getCollideLinePoint(xi , yi , EmbededLine) '''' to check if it is embaded Plane
		Local CColLine:Vector2d = point(xi , yi) '''' the point of collision
		CColLine.subtract(N) ''''' to set the nessesary point to pressent the Circle Line Collision
		'''' Some visuals
		Local CircleCol:Circle2d = Circle2d.create(CColLine.x , CColLine.y , C.Radius)
		SetColor 50 , 150 , 50
		CircleCol.draw()
	End If

End Function



'''''''''''''''''''''''' The other stuf
Graphics 640 , 480
While Not KeyHit(KEY_ESCAPE)
	Cls
	SetColor 255 , 0 , 0
	Line.LineDraw()
	SetColor 0 , 255 , 0
	Circle.draw()
	CircleMove(Circle , CVel , Line)	
	
	If KeyHit(KEY_D)
		Local L:Line2d = Line2d.createFromVects(Circle.position , Line.Start)
		Print L.getAngle()
	End If
	
	If MouseDown(1)
		Circle.position.set( MouseX() , MouseY() )
	End If
	
	If KeyDown(KEY_1)
		Line.setXY1(MouseX() , MouseY())
	End If
	
	If KeyDown(KEY_2)
		Line.setXY2(MouseX() , MouseY())
	End If
	
	If KeyDown(KEY_F)
		CVel.set(MouseX() - Circle.position.x , MouseY() - Circle.position.y)
		SetColor 0 , 0 , 255
		CVel.draw(Circle.position)
	End If
	
	Flip
Wend
End
</textarea><br><br>It look good but it nevers fix the fault that the overlapDist it's smaller than Ball.radius<br>I believe this is the reason that the ball drill's throu the Line1 <br><br></td></tr></table><br>
<a name="595690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> The Last demo that I will post for Collision Circle2d before the perfection<br>I think it's a good place to expirimenting the Functions<br>Don't forget you need Vector2d.bmx and you can find it here : <a href="http://www.blitzwiki.org/index.php/MaxPhysics_Vector2D" target="_blank">http://www.blitzwiki.org/index.php/MaxPhysics_Vector2D</a><br>and the Circle2d.bmx which is here : <a href="http://www.blitzwiki.org/index.php/MaxPhysics_Circle2D" target="_blank">http://www.blitzwiki.org/index.php/MaxPhysics_Circle2D</a><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Include "Vector2d.bmx"
Include "Circle2d.bmx"


'''''''''' seting Lines
Local Vector:Vector2d[10]
Vector[0] = Vector2d.create(4.0000000000000000 , 1.0000000000000000)
Vector[1] = Vector2d.create(204.00000000000000 , 369.00000000000000)
Vector[2] = Vector2d.create(197.00000000000000 , 238.00000000000000)
Vector[3] = Vector2d.create(634.00000000000000 , 0.00000000000000000)
Vector[4] = Vector2d.create(122.00000000000000 , 448.00000000000000)
Vector[5] = Vector2d.create(499.00000000000000 , 448.00000000000000)
Vector[6] = Vector2d.create(499.00000000000000 , 448.00000000000000)
Vector[7] = Vector2d.create(499.00000000000000 , 225.00000000000000)
Vector[8] = Vector2d.create(122.00000000000000 , 448.00000000000000)
Vector[9] = Vector2d.create(122.00000000000000 , 221.00000000000000)


'''''''''''''''''' Ball stuff and gravity
Local Grav:Vector2d = Vector2d.create(0, 0.98)

Local Ball:Circle2d = Circle2d.create(400 , 20 , 10)

Local BallForce:Vector2d = Vector2d.create(0,0)

'''''''''''''''''''''''''''''''''''''''''Graphics and main Loop
Graphics 640 , 480 
While Not KeyHit(KEY_ESCAPE)
	Cls
	
	'''''''''' Drawing
	SetScale 1.0 , 1.0
	DrawText MouseX() + "   " + MouseY() , 10 , 10
	For Local i:Byte = 0 To Vector.Length - 1 Step 2
		SetColor 0 , 255 , 0
		DrawLine Vector[i].x  , Vector[i].y , Vector[i+1].x , Vector[i+1].y
		SetColor 200 , 150 , 100
		DrawText i , Vector[i].x , Vector[i].y
		DrawText i + 1 , Vector[i + 1].x , Vector[i + 1].y
	Next
	SetColor 0 , 0 , 255
	Ball.Draw()
	
	'''''' Forces
	BallForce.add(Grav)
	
	'''''' Update Positions and store data for the old ones
	Local PreBall:Vector2d = Ball.position.copy()
	Ball.position.add(BallForce)	

	
	

	''''Collision Handling
	Function MinDistPointLine!(px!,py!,x1!,y1!,x2!,y2!)  ''This function found in Blitz's forum Code Archive

		If x1 = x2 And y1 = y2 Then Return PointToPointDist(px,py,x1,y1)
	
		Local sx! = x2-x1
		Local sy! = y2-y1
	
		Local q! = ((px-x1) * (x2-x1) + (py - y1) * (y2-y1)) / (sx*sx + sy*sy)
	
		If q &lt; 0.0 Then q = 0.0
		If q &gt; 1.0 Then q = 1.0
	
		Return PointToPointDist(px,py,(1-q)*x1+q*x2,(1-q)*y1 + q*y2)
	End Function
	
	Function pointToPointDist!(x1! , y1! , x2! , y2!)
		Return Sqr( (x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1) )
	End Function
	
	For Local i:Byte = 0 To Vector.Length - 1 Step 2
		Local OverlapDist! = MinDistPointLine(Ball.position.x , Ball.position.y , Vector[i].x , Vector[i].y , Vector[i +1].x , Vector[i +1].y)
		If OverlapDist &lt;= Ball.Radius
			SetColor 255 , 0 , 0 'Just for fun
			SetScale 4.0 , 4.0
			DrawText "Gapp" , Ball.position.x , Ball.position.y ' Just for fun
			
			Local V1:Vector2d = Vector2d.create(Vector[i +1].x - Vector[i].x , Vector[i +1].y - Vector[i].y)
			Local V2:Vector2d = BallForce.copy()
			V1.MakeRightNormaL()
			Local an! = v1.getAngle() - V2.getAngle()
			an = V2.getAngle() + 2*an
			V2.setDir(an)
			V2.reverse()
			BallForce = V2.copy()
		End If
	Next
	
	

	''''''' Positionning Lines
		''''''''''''''''''Line[0]
	If KeyDown(Key_0)
		Vector[0].x = MouseX()
		Vector[0].y = MouseY()

	End If
	
	If KeyDown(Key_1)
		Vector[1].x = MouseX()
		Vector[1].y = MouseY()

	End If
	
		''''''''''''''''''Line[1]
	If KeyDown(Key_2)
		Vector[2].x = MouseX()
		Vector[2].y = MouseY()
	End If
	
	If KeyDown(Key_3)
		Vector[3].x = MouseX()
		Vector[3].y = MouseY()
	End If
	
		''''''''''''''''''Line[1]
	If KeyDown(Key_4)
		Vector[4].x = MouseX()
		Vector[4].y = MouseY()

	End If
	
	If KeyDown(Key_5)
		Vector[5].x = MouseX()
		Vector[5].y = MouseY()

	End If
		''''''''''''''''''Line[3]
	If KeyDown(Key_6)
		Vector[6].x = MouseX()
		Vector[6].y = MouseY()
	End If
	
	If KeyDown(Key_7)
		Vector[7].x = MouseX()
		Vector[7].y = MouseY()
	End If
	
		''''''''''''''''''Line[4]
	If KeyDown(Key_8)
		Vector[8].x = MouseX()
		Vector[8].y = MouseY()
	End If
	
	If KeyDown(Key_9)
		Vector[9].x = MouseX()
		Vector[9].y = MouseY()
	End If
	

	
	
	''''''''''''''''''''''' Psitionning Ball
	If MouseDown(1)
		Ball.Position.set( MouseX() , MouseY() )
		BallForce.set(0,0)
	End If
		
	Flip 1
Wend

	'''''''''''' To copy paste this to the setting Line section on the top and have the costom MAP
Print ""
Print "copy paste the below"
Print "''''''''''''''''''''''''''''''''''''''''''''"
Print 	 "Local Vector:Vector2d[10]"
For Local i:Byte = 0 To Vector.Length - 1
	Local printout$ = ""
	Printout:+ "Vector[" + i +"] = Vector2d.create(" + Vector[i].x + " , " + Vector[i].y + ")"
	Print printout
	'	Vector[0] = Vector2d.create(100 , 300)
	'	Vector[1] = Vector2d.create(300 , 300)
Next
end
</textarea><br><br>If you push a numeric key the edge with the label of it will go to the mouse coordinates<br>if you push the left mouse button the ball will go to that mouse coordinates<br>Last and the funniest : when you build your own map you can just copy paste the outpout from the output tab in the setting Lines section in the code to run the demo with your map. (I was trying to cheat and make a map that will look perfect to make an impression but anyway...)<br><br>P.S.1. It's like Iam kicking the Line2d But anyway...<br>P.S.2. It's buggy don't kill me<br>P.S.3. don't forget If you know a better way to handle this say it here or say it anonymus in the descution tab of Line2d in the BlitzWiki: http://www.blitzwiki.org/index.php/Talk:MaxPhysics_Line2D <br><br></td></tr></table><br>
<a name="596187"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is a good example, when we get this to work we know it will work!<br><br>RE: Your example above with the circle. The reason it jumps through the line is because you alter the speed only, not the possition. So every time it passes the line, you tell the ball to Change (reverse) direction. It does and starts to go up, then gravity pulls it down again. Until the velocity is so low that it doesn't matter if you reverse it anymore. <br><br>Also a note about force and velocity. They are not the same ;) <br><br></td></tr></table><br>
<a name="596318"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> For the problem of the circle collision I believe the solution of the problem lies somewhere in this document : <br><a href="http://www.fluidstudios.com/pub/FluidStudios/CollisionDetection/Fluid_Studios_Generic_Collision_Detection_for_Games_Using_Ellipsoids.pdf" target="_blank">http://www.fluidstudios.com/pub/FluidStudios/CollisionDetection/Fluid_Studios_Generic_Collision_Detection_for_Games_Using_Ellipsoids.pdf</a><br>I am still tying to find my way in this.<br>I recommend you to have a look in this document it looks like that is a standard one.<br><br>Also I found out that the Line2d that I had bothered you all this time it's not necessary for the Mod. The reason I am writing this up is that I created some functions to get rid of them.(It's like I am destroying me own creation but how cares)<br>here are some examples:<br>edit: Well I don't have the function in this CPU so maybe this function not correct but I have it in an other CPU at home I will change it if it is not the one.<br><pre class=code>
	Function LikeLine:Vector2d(Vector:Vector2d , VectorOrigin:Vector2d)
		Return Vector2d.create(Vector.x - VectorOrigin.x, Vector.y - VectorOrigin.y)
	End Function

</pre><br><br>The names of the functions of course are not standard they may have any name.<br>But the result is that there working like the lines where working.<br>I have somewhere and the clasic demo that I have made with the lines but only for collision.<br>Here it is:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Include "Vector2d.BMX"




Function GetCollideLinePoint(xi! Var , yi! Var , V1:Vector2d , V1Origin:Vector2d ,  V2:Vector2d , V2Origin:Vector2d)
		Local x1:Float = V1Origin.x
		Local y1:Float = V1Origin.y
		Local x2:Float = V1Origin.x + V1.x
		Local y2:Float = V1Origin.y + V1.y
		Local x3:Float = V2Origin.x
		Local y3:Float = V2Origin.y
		Local x4:Float = V2Origin.x + V2.x
		Local y4:Float = V2Origin.y + V2.y

		Local ua:Float = ( (x4 - x3)*(y1 - y3) - (y4 - y3)*(x1 - x3) ) / ( (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1) )
		Local ub:Float = ( (x2 - x1)*(y1 - y3) - (y2 - y1)*(x1 - x3) ) / ( (y4 - y3)*(x2 - x1) - (x4 - x3)*(y2 - y1) )

		If ua &gt;=0 And ua &lt;=1 
			If ub &gt;=0 And ub &lt;=1 
				xi = x1 + ua*(x2 - x1)
				yi = y1 + ua*(y2 - y1)
				Return True
			EndIf
		EndIf
		Return False			
	
End Function

Function DrawVectAt(Vector:Vector2d , x! , y!)
	DrawLine x , y , x + Vector.x , y + Vector.y
End Function

Local V1:Vector2d = Vector2d.create( 0 , 100)
Local V1Origin:Vector2d = Vector2d.create(50, 50)
Local V2:Vector2d = Vector2d.create(100 , 50)
Local V2Origin:Vector2d = Vector2d.create(50 , 50)

Local xi! , yi!

Graphics 640 , 480
While Not KeyDown(KEY_ESCAPE)
	Cls
	DrawVectAt(V1 , V1Origin.x , V1Origin.y)
	DrawVectAt(V2 , V2Origin.x , V2Origin.y)
	If GetCollideLinePoint(xi , yi , V1 , V1Origin , V2 , V2Origin)
		DrawText "OK" , 10 , 10
	End If
	
	'''''Handling
	If KeyDown(Key_1)
		V1.set(MouseX() - V1Origin.x , MouseY() - V1Origin.y)
	End If
	
	If KeyDown(Key_2)
		V1Origin.set(MouseX(), MouseY())
	End If

	Flip
Wend
End

</textarea><br>It's not organised like the others but it's a good example to catch what I am thinking right now.<br>I am not going to dive in the Matrixes (Because I am afraid Smith) because it's to much for me and I can't and don't want to understand them. So simple trigonometry for me and linear algebra(without Matrixes).<br>Thats all I just working almost all my free time on this so I had to tell what I am thinking to someone <br><br></td></tr></table><br>
<a name="596384"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okey, perhaps we should skip Line2D. The important thing is that the system is flexible and module.<br><br>I had this idea with circle/line collision, perhaps it is better to check the circle Velocity Vector against the line instead? In that way an object can never pass through another object. The velocity vector is increased with the radius of the object before collision test.<br><br>And to draw a vector please use:<br><br>VectorYouWantToDraw.Draw( StartVector )<br><br>To create a vector outside of the library itself use the functions:<br><br>NewVector:Vector2D = CreateVector( 55, 100)<br>Or<br>SomePoint:Vector2D = Point( 33, 10 )<br><br>EDIT<br><br>Good link, checking it now.<br><br>EDIT<br><br>Really good! Polygons here we come! <br><br></td></tr></table><br>
<a name="596701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> The first part of the document have done with great success. I also done it in a way to be like a tutorial<br>check it out<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem 
	I am going to use the document Generic_Collision_Detection_for_Games_Using_Ellipsoids
	you can find it in www.fluidstudios.com somewhere
	So I will use the headlines of the document to make it easy to understand what
	I am trying to do.
	I am doing this because I am not going to use Matrixes and Computer Graphics technics
	and I have a hope that someone may Look in to this and use those technics and make the whole
	think lighter(But more complex)
	Also it will be and a good tutorial for someone outside of collisions to start playing with them.
End Rem

Rem 
	Some Instruction
	Press F to set the Velocity realtivy mouse position and Circle position
	Press 1 or 2 to change the edges of the Red Line to the Mouse Position
	Press the mouse button to move the ball to the mouse position
End Rem
	

Strict
Include "Vector2d.bmx"
Include "Line2d.bmx"
Include "Circle2d.bmx"

Local Line:Line2d = Line2d.createLineXY(10 , 300 , 300 , 300)
Local Circle:Circle2d  = Circle2d.create(100 , 100 , 20)
Local CVel:Vector2d = createVector(10,10)
Local Grav:Vector2d = createVector( 0 , 0.98)

'''''''''''''''''''''''''''''''''''''
''''''''COLIDING A SPHERE WITH A PLANE
''''''''''''''''''''''''''''''''''''	
	''I will do it just with lines not planes , you will understand the difference
		''Because I wand it to work in both sides
''''''' C the Circle to move , Vel the velocity of the circle , L the Line to check for collision
Function CircleMove(C:Circle2d , Vel:Vector2d , L:Line2d)
	Local N:Vector2d = L.copy() ''''copy the Line
	N.MakeRightNormal()  	''' Make the Normal of the Line 
	'''' Becarefull the Line will work only in one side for example if the Line starts at
	'''''' x = 0 and and y = 100 and ends at x = 100 and y = 100
	''''''''' The Cricle must be above of the Line. For example Circle.position y = 50
	N.setLength(C.Radius) 'Set the normal's length to be equal to the radius of the circle
	SetColor 0 , 0 , 255 ''' To have Some visuals
	N.Draw(C.position) '''' of what is going on
	'''''' Now I will create a Vector named CCol that will present the point of the Circle Line collition point
	''''''' Like the ponit in the Figure 3 of the document The start of the Gray line Labaled 'B'
	Local CCol:Vector2d = Point(C.position.x + N.x , C.position.y + N.y)
	SetColor 200 , 200 , 200 	''' To visual the 
	drawpoint(CCol , 2)		''' ponint
	'''' Now Let's create a line that will present the Velocity of the Line or just can say
	''''''''' The gray line Labeled 'B' in the figure 3
	Local LineB:Line2d = Line2d.createLine(CCol , Vel) '''' This way of Line creation take Values
	'''' That present the StartPoint of the Line the first value and tha vector to be used the second one.
	''''Let's Draw this too
	SetColor 200 , 200 , 200 '' to Be gray...
	LineB.LineDraw()
	'''Now let's check for collision of the LineB and the Line and if it is a collison to get the point.
	Local xi! , yi! ''' those are the doubles that will take tha x y values of the collision point
	If L.getCollideLinePoint(xi , yi , LineB) '''' to check first of all if there is a collision
		Local CColLine:Vector2d = point(xi , yi) '''' the point of collision
		CColLine.subtract(N) ''''' to set the nessesary point to pressent the Circle Line Collision
		'''' Some visuals
		Local CircleCol:Circle2d = Circle2d.create(CColLine.x , CColLine.y , C.Radius)
		SetColor 50 , 150 , 50
		CircleCol.draw()
	End If
End Function



'''''''''''''''''''''''' The other stuf
Graphics 640 , 480
While Not KeyHit(KEY_ESCAPE)
	Cls
	SetColor 255 , 0 , 0
	Line.LineDraw()
	SetColor 0 , 255 , 0
	Circle.draw()
	CircleMove(Circle , CVel , Line)	
	
	If KeyHit(KEY_D)
		Local L:Line2d = Line2d.createFromVects(Circle.position , Line.Start)
		Print L.getAngle()
	End If
	
	If MouseDown(1)
		Circle.position.set( MouseX() , MouseY() )
	End If
	
	If KeyDown(KEY_1)
		Line.setXY1(MouseX() , MouseY())
	End If
	
	If KeyDown(KEY_2)
		Line.setXY2(MouseX() , MouseY())
	End If
	
	If KeyDown(KEY_F)
		CVel.set(MouseX() - Circle.position.x , MouseY() - Circle.position.y)
		SetColor 0 , 0 , 255
		CVel.draw(Circle.position)
	End If
	
	Flip
Wend
End
</textarea><br><br>P.S. As you can see I still use the Line2d. As you said it give great flexibility so I think it will stay for sometime more to make our life easier until the completion.<br>Also it may be good idia if will add a better vertion of this in the main tutorial section of the comunity to attract more people to help. <br><br></td></tr></table><br>
<a name="596838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great! Yet it doesn't seem to detect the edges correctly? <br><br>I'm almost complete with a vector physics tutorial for beginners! Let's post these at the same time. <br><br></td></tr></table><br>
<a name="596870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> The detection of the edges it's not a problem of the implementation. The document deals with edges later on. As far I understand we will have to find out ourselves a way to deal with edges of a single line, because the document doesn’t cover this think.<br>After all if I post this tutorial it will be a work in progress tutorial that it will be completed part by part in the post. Like the nehe tutorial.<br>Just tell me when you wand to post them. <br><br></td></tr></table><br>
<a name="596886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> After all if I post this tutorial it will be a work in progress <br></div><br>True, Go ahead and post it, I'll post mine in another topic when it's done and link here. I'll update my guide with some stuff from the library as we progress. <br><br></td></tr></table><br>
<a name="596913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have to organized a litle bit more but I don't have the time for today so I will post it sometime tomorow <br><br></td></tr></table><br>
<a name="597154"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> why not have a convex hull class instead of seperate box and circle? a convex hull with enough edges easily represents a circle.<br><br>Might make the core code a lot simpler with very little speed difference (most physics engines are based around response, not number of objects) <br><br></td></tr></table><br>
<a name="597172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Explain more.<br><br>Convex Hull? <br><br>Code Simpler?<br><br>Based around response not number of objects?<br><br>Any code example? <br><br></td></tr></table><br>
<a name="597176"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> He must mean a 6 or more sides pollygon to be like Circle. <br><br>Wave I am allready stuct in the document for elipsoid can I use the Circle2d in the wiki? So to post early examples and faild codes in the discution area to get help. and not overload this post?<br>It will be ok with you if I do not post the tutorial that we were talking yesterday?(sorry about that.) <br><br></td></tr></table><br>
<a name="597226"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> no problem. Please use the Circl2D. And if you change a lot you can always post it here. Id on't think we can overload these forums with this project, it's not that big. Anyhow, if you post in the Wiki add a post here to draw my attention :)<br><br>Note that there is a problem with ovals, and that is when they rotate. But it that is solved (did the guide adress that?), wow!<br><br>Right now I'm fixing the vector2D to respond to collidion against any surface. In this way our Shapes does not need to have collision mehtods themselves, they simple calculate their surfacenormal and pass it to the collision function.<br><br>Also I don't like the idea of adding Gravity (like the guide) inside the collision method, that sounds crazy to me. What about if we have more forces than gravity, such as gravitywells, explosions, fans.. Force should be applied, then it accelerated, acceleration makes us move - increase speed. The velocity is what we check and change in collision.<br><br>Still if you manage to convert the collisions from the guide, most problems are solved. <br><br></td></tr></table><br>
<a name="597284"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Projection work nice!<br>But reflection N Mirroring is Wierd!<br><pre class=code>
'Projection and Reflection
Import "Vector2D.bmx"

Graphics 500,500,0

Global Line:Vector2D 		= CreateVector( 300, 00 )
Global LineStart:Vector2D 	= CreateVector( 10, 200  )

Global Vec:Vector2D		 	= CreateVector( 0, 0 )
Global VecStart:Vector2D 	= CreateVector( 200, 20 )

Global Project:Vector2D	 	= CreateVector( 0, 0 )


While Not KeyDown( Key_Escape )
	
	SetColor 255,0,0'RED 
	DrawLine LineStart.X, LineStart.Y, LineStart.X + Line.X, LineStart.Y + Line.Y
	
	SetColor 0,255,0'BLUE
	Vec.Set( MouseX() - VecStart.X , MouseY() - VecStart.y  )
	Vec.Draw( VecStart )
	
	If KeyDown(Key_1)
		LineStart.Set( MouseX() ,MouseY() )
	End If
	
	If KeyDown(Key_2)
		Line.Set( MouseX() - LineStart.X, MouseY() - LineStart.Y   )
	End If
	
	SetColor 0,0,255'GREEN
	Project.ProjectionOf( Vec, Line )
	Project.Draw( VecStart )
	
	Local SurfaceNormal:Vector2D = Line.CreateLeftNormal()
	SurfaceNormal.Normalize()
	
	SetColor 0,255,255'TEAL
	Project.Mirror( SurfaceNormal ) 
	Project.Draw( VecStart )		
		
	SetColor 255,255,0'YELLOW
	Project.ProjectionOf( Vec, SurfaceNormal )
	Project.Draw( VecStart )				
	
	
Flip;Cls	
Wend
</pre> <br><br></td></tr></table><br>
<a name="597569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool demo those function are nesesery. The reflection that I made for lines it's realy crazy I can't even remember how I have done them. But as they are working we can keep them and just mark them to remember that we must make them clearer in the future.<br> About the elipsoid I don't think that it will be a problem with rotation. Plus gravity it's not added in the collision method. As you can see all the forces will be added to the position and then we have to check the data from the old position to the new and find were the collision will take place and make the responce.<br>About velocity. If you break it you will see that it's just force the force that it's nessesary to travel from one position to another in the given time.<br><br>Something about the Projection. To make the seperation axis method we need to drop the projection from 2 dimentions to 1 dimention. I was trying to make this to work for sometime now but sadly with no luck.<br><br>Last somethink about me. Here in Greece it's raining for 3 days now and I am working under the rain. My health it's too bad right now. I may be off for sometime, work it's hard and does not give me free time that I wand. <br><br></td></tr></table><br>
<a name="597621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> You are doing a great work! Take a break if you need to, don't feel to obligatied to the project.<br><br>Go here to checkout your line demo working with BOTH bounce and or slide! Soo cool!<br><a href="/posts.php?topic=53464" target="_blank"> IT WORKS! So far so good! </a><br><br>The golden function!<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
		Friction! from 0 to 1 ; 1 = Total Friction (get stuck), 0 = No Friction
		Elasticy! from 0 to 1 ; 1 = Perfect Bounce, 0 = No Bounce

		USE: 
		If CollideSurface( SurfaceNormal,....)
			ApplyResponse( Tank.Velocity, SurfaceNormal, 0, 0.5 )
		Endif
EndRem
Function ApplyResponse( Velocity:Vector2D Var, SurfaceNormal:Vector2D, Friction!, Elasticity! )
	SurfaceNormal.Normalize()

	Velocity.Mirror( SurfaceNormal ) 
	
	If Elasticity &lt; 0 Then Elasticity = 0'Slide
	If Elasticity &gt; 1 Then Elasticity = 1'Perfect Bounce
	
	Local Bounce:Vector2D = CreateVector(0,0)	
	Bounce.ProjectionOf( Velocity, SurfaceNormal )	
	Bounce.Multiply( Elasticity ) ' Apply Elasticy, to the perpendicular part of velocity
	
	If Friction &lt; 0 Then Friction = 0
	If Friction &gt; 1 Then Friction = 1
	Friction = 1 - Friction''  Case 1, now: 0, Case 0, now: 1
	
	Local Slide:Vector2D  = CreateVector()
	SurfaceNormal.MakeLeftNormal()'Convert the normal to the surface!
	Slide.ProjectionOf( Velocity, SurfaceNormal )' Project to surface
	Slide.Multiply( Friction ) ' Apply Friction, to the parallel part of velocity
	
	Velocity.Set(0,0)
	Velocity.Add( Slide )
	Velocity.Add( Bounce )

'FOR DEBUGGING ONLY		
'	SetColor 0,0,255'GREEN
'	Slide.Draw  ( Ball.Position )	
'	SetColor 255,255,0'YELLOW		
'	Bounce.Draw ( Ball.Position )	
	
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="598111"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> PhysicsObjects and CollisionPlanes. All in the mix now. Take a close look at this, and at Circle2D. Make Line2D extend Shape2D just like Circle2D does. <br><br>Still this example is not working correctly.. Time.. I'm NOT going to use MaxPhysics in my game, not at this time. I'm doing a simpler implementation into what I already have. So for my part I'm putting this project on-hold. Still I wanted to share what I have so far:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'File: TMaxPhysicsObject.bmx
Include "Vector2D.bmx"
Include "Circle2D.bmx" 'Shape2D lies in here too

'_________________________________________
'
'
'  Contains all data that is required
'  for collision response and movement
'
'_______________________________________-
Type TMaxPhysicsObject
	
	Field Static = False 'Will this object's position be affected by collisions?
	Field StaticRotation = True 'Will this object's rotation be affected by collisions?

	Field LastPosition:Vector2D[]
	Field Position		:Vector2D	= CreateVector()
	Field Velocity		:Vector2D	= CreateVector()
	Field Acceleration	:Vector2D	= CreateVector()
	Field Force			:Vector2D	= CreateVector()
	
	Field SurfaceFriction! '0 to 1 - Applied at Collisions only
	Field AirResistance!   'Applied always (depending on speed)
	
	Field Elasticity! '0 to 1 - determines Bouncyness
	'If higher than 1 the object will have greater speed after collision			
										
	Field Direction!
	Field RotationSpeed!
	Field RotationAcceleration!
	Field RotationFriction!
	
	Field Mass!
	
	Field Shapes:Shape2D[10] 'Increase if you want more
			
	Method AddCollisionShape( Shape:Shape2D )		
		For Local n = 0 Until Shapes.length
			If Shapes[n] = Null
				Shapes[n] = Shape
			EndIf
		Next
	
		'The Shape's center position
		Shape.Position = Position' The one and the same
		'This is set when you create the shape
		'Se respective Shape
		
	EndMethod
	
	
	'S E T  P H Y S I C S
	'_________________________________________________
	
	'From 0 to 1
	Method SetFriction( Friction! )
		SurfaceFriction = Friction
	EndMethod

	Method SetRotationFriction( Friction! )
		RotationFriction = Friction
	EndMethod

	'From 0 to 1
	Method SetElasticity( Amount! )
		Elasticity = Amount
	EndMethod
	'_________________________________________________
	
	

	'For Debugging of collide zones!
	Method DrawShape()
		For Local Circle:Circle2D = EachIn Shapes
			Circle.Draw()
		Next
	EndMethod

	Method Update()
		
	EndMethod

	' C O L L I S I O N
	Method Collide( AnotherPhysicsObject:TMaxPhysicsObject )
		If Self = AnotherPhysicsObject Return
		'Most times a Physics object only have one shape
		'But not always..
		For Local A:Shape2D  = EachIn Shapes
			For Local B:Shape2D = EachIn AnotherPhysicsObject.Shapes
				
				Local Project:Vector2D
				Project = A.ShapesCollide( B )' A Shape always has a collide method
				If Project 'Did we collide?
				'	DebugLog "Collision detected!"
					If Not Static 
						Position.Add( Project )'Project out of Collision!					
					EndIf
				EndIf
				
				Local SurfaceNormal:Vector2D = Project.CreateLeftNormal()
												
				'NOW add response!
				Local AvgElasticy! = (Elasticity + AnotherPhysicsObject.Elasticity)/2
				ApplyResponse( Velocity, SurfaceNormal, SurfaceFriction, AvgElasticy )
				
				
				'The only done so far is circle!
				' So in this example A and B are Circle (or it won't work)
				'Note: Circle2D extends Shape2D
				
				'TO DO ( in respective type )
				' Line2D	
				' Polygon2D
				
			Next
		Next
	EndMethod
EndType


Type TMaxCollisionPlane
	
	'Each plane contains a list of objects
	Field Plane:TList = CreateList()
	
	Method Add(	PhysicsObject:TMaxPhysicsObject )
		Plane.AddLast( PhysicsObject )
	EndMethod
	
	Method Remove( PhysicsObject:TMaxPhysicsObject )
		Plane.Remove( PhysicsObject )
	EndMethod
	
	Method Collide( Another:TMaxCollisionPlane )
		For A:TMaxPhysicsObject = EachIn Plane
			For B:TMaxPhysicsObject = EachIn Another.Plane
				A.Collide( B )
			Next
		Next
	EndMethod
EndType

Function CreateCollisionPlane:TMaxCollisionPlane()
	Return New TMaxCollisionPlane
EndFunction
Function Circle:Circle2D( Radius! )
	Return Circle2D.Create( X, Y, Radius )
EndFunction



Rem
		Friction! from 0 to 1 ; 1 = Total Friction (get stuck), 0 = No Friction
		Elasticy! from 0 to 1 ; 1 = Perfect Bounce, 0 = No Bounce

		USE: 
		If CollideSurface( SurfaceNormal,....)
			ApplyResponse( Tank.Velocity, SurfaceNormal, 0, 0.5 )
		Endif
EndRem
Function ApplyResponse( Velocity:Vector2D Var, SurfaceNormal:Vector2D, Friction!, Elasticity! )
	SurfaceNormal.Normalize()

	Velocity.Mirror( SurfaceNormal ) 
	
	If Elasticity &lt; 0 Then Elasticity = 0'Slide
	If Elasticity &gt; 1 Then Elasticity = 1'Perfect Bounce
	
	Local Bounce:Vector2D = CreateVector(0,0)	
	Bounce.ProjectionOf( Velocity, SurfaceNormal )	
	Bounce.Multiply( Elasticity ) ' Apply Elasticy, to the perpendicular part of velocity
	
	If Friction &lt; 0 Then Friction = 0
	If Friction &gt; 1 Then Friction = 1
	Friction = 1 - Friction''  Case 1, now: 0, Case 0, now: 1
	
	Local Slide:Vector2D  = CreateVector()
	SurfaceNormal.MakeLeftNormal()'Convert the normal to the surface!
	Slide.ProjectionOf( Velocity, SurfaceNormal )' Project to surface
	Slide.Multiply( Friction ) ' Apply Friction, to the parallel part of velocity
	
	Velocity.Set(0,0)
	Velocity.Add( Slide )
	Velocity.Add( Bounce )

'FOR DEBUGGING ONLY		
'	SetColor 0,0,255'GREEN
'	Slide.Draw  ( Ball.Position )	
'	SetColor 255,255,0'YELLOW		
'	Bounce.Draw ( Ball.Position )	
	
EndFunction

'------------------------------------------------------------------------------------
'____________________________________________________________________________________

'			::In another file::
'		Import "MaxPhysicsMain.bmx"

Type TTank Extends TMaxPhysicsObject

	Field Armor

	Method New()
		AddCollisionShape( Circle( 20 ) )'Center at Tank Position
		'Physics Settings here
		'* Friction
		'* Mass
		'* 
		Position.Set( Rand(50,450), Rand(50,450)  )
	EndMethod

EndType

Local TankA:TTank = New TTank
Local TankB:TTank = New TTank

Local TankPlane:TMaxCollisionPlane = CreateCollisionPlane()
TankPlane.Add( TankA )
TankPlane.Add( TankB )

Graphics 500,500,0

While Not KeyDown( Key_Escape )

	TankPlane.Collide( TankPlane ) 'Check against itself

	SetColor 255,0,0 'RED
	TankA.DrawShape

	SetColor 0,255,0 'BLUE
	TankB.DrawShape		
	
	TankA.Position.Set( MouseX(), MouseY() )
	
	Flip;Cls
Wend
</textarea><br><br>If someone wants to continue the work on the core or add new features, please do so. And if you have questions: Don't hesitate to ask!<br><br>Later,<br>Wave~ <br><br></td></tr></table><br>
<a name="600090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> This means that you are out from the project? <br><br></td></tr></table><br>
<a name="600137"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well anyway...<br>Just a transletion of the PolyColly code...<br>It's hust from the first tutorial<br>The Polygon.cpp<br><br>WE DON'T HAVE TO TRANSLATE ALL THE FILES OF THE POLYCOLLY.<br><br>Just the Polygon.cpp from all the tutorials and fit them to the Clasic 2d Coordinate system and Vector2d.<br><br>Edit : I deleted the codebox to post it to another post <br><br></td></tr></table><br>
<a name="600141"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not out, I'm just less active.<br><br>RE: the coordinate system, is there a reason for it? I had that in my library before, and I din't notice any big difference in function. <br><br>Do you know how to make a reflecting vector from a poly? That would be awesome. Then we can put them all together. Also I found and fixed a bug in the circle/line collision response, seems to work much better now. Still the circle vs circle collision is a bit wierd.<br><br>See in programming forum, my post for Physics Help. <br><br></td></tr></table><br>
<a name="600566"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> All comes from this: <a href="http://mathworld.wolfram.com/Reflection.html" target="_blank">http://mathworld.wolfram.com/Reflection.html</a><br>(My English are not good so I have a problem to explain this stuff).<br>It's not difficult to create a reflection vector from poly. You just have to now the collision point. From the collision point you get the side of the poly. Then with the method MakeLeftNormal you get the Normal of the side. Just remember that when you create polygons you have to create them clockwise <br>After that you have to find the minimum angle between your Vector and the normal of the side. This angle it's the master of the new reflected vector.<br>And here comes the crazy code: <br><pre class=code>
Side.MakeLeftNormal() 'Create the Normal from The side
Local an# =  Side.getAngle() - Vector.getAngle() 'The angle between the Normal and the Vector
Local ReflectedVector:Vector2d = point(1 , 1) ' Just a Vector with length and direction to be sure that the methods will work
an = Vector.getAngle() + an*2  ''' Two times the Angle between the normal and the Vector
ReflectedVector.setDir(an)
ReflectedVector.setLength(Vector.getLength())
ReflectedVector.reverse() '''' The last step 
</pre><br>The edges of a polygon it's a different story and I don't know how to handle them. <br><br></td></tr></table><br>
<a name="603396"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just realized that the polygons to work corect must have the first point seted to zero and to be created clockwise.<br><br><br>I also made a simple Polygon creator to make the testing easier.<br>Here it is : <br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict 

Include "Vector2d.bmx"


Local x# = 300 , y# = 200  ''''''The first point
Local A:Vector2d[1]
A[0] = point(0 , 0)

Local B:Vector2d[1]
B[0] = point(0 , 0)

Local r% = 5 ''''''' Just for drawing the point
Local P% = 1 '' To check witch poly to Draw

Graphics 640 , 480
While Not KeyDown(KEY_ESCAPE)
	Cls
	DrawText "You must create the poly ClockWise and be Convex" , 10 , 10
	DrawText "Press Space to Change From Poly1 to Poly2" , 10 , 20
	DrawText "Drawing Poly" + P , 10 , 30
	
	If KeyHit(Key_SPACE)
		If P = 1 
			P = 2
		Else
			P = 1
		End If
	End If
	
	If P = 1
		Local j:Int = A.Length - 1
		For Local i:Int = 0 To A.Length - 1
			SetColor 0 , 255 , 0
			DrawLine A[j].x + x , A[j].y + y , A[i].x + x , A[i].y + y
			SetColor 255 , 0 , 0
			DrawOval A[i].x + x - r , A[i].y +y - r , 2*r , 2*r
			j = i
		Next
		
		If MouseHit(1)
			A = A[..A.Length + 1]
			A[A.Length - 1] = point(MouseX() - x , MouseY() - y)
		End If
	Else
		Local j:Int = B.Length - 1
		For Local i:Int = 0 To B.Length - 1
			SetColor 0 , 255 , 0
			DrawLine B[j].x + x , B[j].y + y , B[i].x + x , B[i].y + y
			SetColor 255 , 0 , 0
			DrawOval B[i].x + x - r , B[i].y +y - r , 2*r , 2*r
			j = i
		Next
		
		If MouseHit(1)
			B = B[..B.Length + 1]
			B[B.Length - 1] = point(MouseX() - x , MouseY() - y)
		End If
	End If
		
	Flip
Wend
Print ""
Print ""
Print "'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''"
Print "''''''''''''''''''''''''''   COPY PASTE THIS TO GET THE POLYGONS"
Print "''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''"
Local str$ =  "Local Poly1:Vector2d[" + A.Length + "]"
Print str
For Local i:Int = 0 To A.length - 1
	str = "Poly1[" + i + "] = point(" + A[i].x + " , " + A[i].y + ")"
	Print str
Next

Print ""
str$ =  "Local Poly2:Vector2d[" + B.Length + "]"
Print str
For Local i:Int = 0 To B.length - 1
	str = "Poly2[" + i + "] = point(" + B[i].x + " , " + B[i].y + ")"
	Print str
Next

Print ""
Print "'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''"
Print ""
Print""
End

</textarea><br><br>Pls test and play around and tell me if you found any problem.<br><br>EDIT:I Deleted the codebox of Poly couse I had posted A new vertion of it 3 post down <br><br></td></tr></table><br>
<a name="603744"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been working with the collision response, Dynamic vs Static and Dynamic vs Dynamic objects seems to work now. The Shape we suse should now not matter. In other words the slide/bounce should work the same for circles and lines and polygons, but I need to put it all together.<br><br>Nice going with the polygons, I would need the collision method to return a vector. This vector should be the length N direction required to push the polygon out-of-collision. <br><br></td></tr></table><br>
<a name="603963"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow... PolyColly turns to be the worsest Document I ever readed. <br><br>There 3 options as I see it right now.<br><br>1. Just Translate and getted work the Polygon.cpp from the source code(we have to find out wich one is the best for us)<br><br>2.Just delete the code on the paper and try to impliment the saying. (code it from the begining)<br><br>3.Find a better document that dealing with polygons(If you know any tell me)<br><br>To tell you the truth I vote 3. But I can't find anything so far. <br><br></td></tr></table><br>
<a name="604090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well as I cannot find any other tutorials I am going to use PolyColly :(<br>I will go between the Polygon.cpp and the document to find out the right way for it.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Framework BRL.Blitz
Import BRL.Max2d
Import BRL.GLMax2d
Import BRL.D3d7Max2d
Import BRL.StandardIO

Include "Vector2d.bmx"

Type PolyColl

	

	Function Render(xOffSet:Vector2d , axVertices:Vector2d[])
	
	
		If axVertices = Null Then Return
		Local j:Int = axVertices.Length - 1
		For Local i:Int = 0 To axVertices.length - 1
			DrawLine axVertices[j].x + xOffSet.x , axVertices[j].y + xOffSet.y , axVertices[i].x + xOffSet.x , axVertices[i].y + xOffSet.y
			j = i
		Next
		
	End Function	

	Function Collide(A:Vector2d[],B:Vector2d[],xOffset:Vector2d Var)
		If A = Null Or B = Null Then Return False
	
		'// All the separation axes
		Local xAxis:Vector2d[64]    '// note : a maximum of 32 vertices per poly is supported
		Local iNumAxes:Int =0
	
		Local J = A.length - 1
		For Local i:Int = 0 To A.length - 1

		
			Local E0:Vector2d = A[j].copy()
			Local E1:Vector2d = A[i].copy()
			E1.subtract(E0)
			Local E:Vector2d  = E1.copy()

			xAxis[iNumAxes] = point(-E.y, E.x)
	
			If Not IntervalIntersect(A, B, xAxis[iNumAxes], xOffset)
				Return False
			End If
			
			j = i
			iNumAxes:+1
		Next
	
		j = B.length - 1
		For Local i:Int = 0 To B.length - 1
			Local E0:Vector2d = B[j].copy()
			Local E1:Vector2d = B[i].copy()
			E1.subtract(E0)
			Local E:Vector2d  = E1.copy()
			xAxis[iNumAxes] = point(-E.y, E.x)
	
			If Not IntervalIntersect(	A, B, xAxis[iNumAxes], xOffset)
				Return False
			End If
			j = i
			iNumAxes:+1
		Next
		Local D:Vector2d = xOffset.copy()
		xOffSet = FindMTD(xAxis , iNumAxes)
		If D.dot(xOffSet) &lt; 0.0
			xOffSet.reverse()
		End If
		
		
		Return True
	End Function


	Function GetInterval(axVertices:Vector2d[], iNumVertices:Int,xAxis:Vector2d,TMin:Float Var, TMax:Float Var)
		TMin = TMax = axVertices[0].Dot(xAxis)
	
		For Local i:Int = 1 To iNumVertices - 1
			Local d = axVertices[i].dot(xAxis)
			If d &lt; TMin
				TMin = d 
			Else 
				If d &gt; TMax
					TMax = d
				End If
			End If
		Next
	End Function
	
	Function IntervalIntersect(A:Vector2d[], B:Vector2d[], xAxis:Vector2d, xOffset:Vector2d)

		Local min0:Float , max0:Float
		Local min1:Float, max1:Float
		GetInterval(A, A.Length, xAxis, min0, max0);
		GetInterval(B, B.Length, xAxis, min1, max1);
	
		Local h:Float = xOffset.Dot(xAxis)
		min0 :+ h
		max0 :+ h
	
		Local d0:Float = min0 - max1 
		Local d1:Float = min1 - max0
		
		Local depth:Float
		If d0 &gt; d1
			depth = d0
		Else
			depth = d1
		End If
		
		Local Axis_Length_Squared:Float = xAxis.Dot(xAxis)  '''Convert for MTD
		xAxis.Multiply( depth / Axis_Length_Squared )
		
		If d0 &gt; 0.0 Or d1 &gt; 0.0
			Return False
		Else
			Return True
		End If
	End Function	
	
	Function FindMTD:Vector2d(PushVector:Vector2d[] , iNumAxis:Int)
		Local MTD:Vector2d = PushVector[0].copy()
		Local mind2:Float = PushVector[0].dot(PushVector[0])
		For Local i:Int = 1 To iNumAxis - 1
			Local d2:Float = PushVector[i].dot(PushVector[i])
			If d2 &lt; mind2
				mind2 = d2
				MTD = PushVector[i].copy()
			End If
		Next
		Return MTD
	End Function
	
End Type

'''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''' TEST
''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''  THE offsets of the polygons
Local offset1:Vector2d = point(200 , 200)
Local offSet2:Vector2d = point(300,300)


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''   COPY PASTE THIS TO GET THE POLYGONS
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Local Poly1:Vector2d[4]
Poly1[0] = point(0.00000000000000000 , 0.00000000000000000)
Poly1[1] = point(69.000000000000000 , 42.000000000000000)
Poly1[2] = point(9.0000000000000000 , 97.000000000000000)
Poly1[3] = point(-58.000000000000000 , 41.000000000000000)

Local Poly2:Vector2d[4]
Poly2[0] = point(0.00000000000000000 , 0.00000000000000000)
Poly2[1] = point(82.000000000000000 , 41.000000000000000)
Poly2[2] = point(16.000000000000000 , 105.00000000000000)
Poly2[3] = point(-54.000000000000000 , 46.000000000000000)

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''	GRAPHICS MAIN LOOP
Graphics 640 , 480


While Not KeyDown(KEY_ESCAPE)
	Cls
	If MouseDown(1)
		offset1 = point(MouseX() , MouseY() )
	End If
	
	If MouseDown(2)
		offSet2 = point(MouseX() , MouseY() )
	End If
	
	SetColor 255 , 0 , 0					
	PolyColl.render(offSet1 , Poly1)
	SetColor 0 , 0 , 255
	PolyColl.render(offSet2 , Poly2)
	Local XoffSet:Vector2d = offset1.copy()
	Xoffset.Subtract(offSet2)

	If PolyColl.Collide(Poly1 , Poly2 , XoffSet)
		SetColor 0 , 255 , 0
		DrawText "Collide" , 50 , 50
	End If
	XoffSet.draw(offSet1) ''' Xoffset turns to be the MTD
	'''''''Check the Pushed poly
	XoffSet.Add(offSet1)
	PolyColl.render(XoffSet , Poly1)
	
	SetColor 200 , 200 , 200
	DrawText "Press the Left Mouse Button to move the Red Poly" , 10 , 10
	DrawText "Press the Right Mouse Button to move the Blue Poly" , 10 , 20

	
	Flip
Wend

End
</textarea><br><br>The offset that Passes to the Collide method turns to be the MTD(minimum translation distance)<br>Be carefull couse this is still the tutorial 2 to deal with speed I have to done the tutorial 3. <br><br></td></tr></table><br>
<a name="604144"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess this already encompass what you have done with polygons, but take a look at it. It might help.<br><br>(It is not made by me, but I think it is free to use)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

'TO TEST RUN
Graphics 800,600,0',300'16,500

Global Poly1:TPolygon = TPolygon.Create()
'This creates a box with size 100x100
Poly1.Add(-50,-50)
Poly1.Add(50,-50)
Poly1.Add(50,50)
Poly1.Add(-50,50)
Poly1.Add(-50,-50)
Global Poly2:TPolygon = Poly1.Copy()
Global Rect:TPolygon  = Poly1.Copy()

Global X,Y 'This is for the test ball
Global GW = GraphicsWidth()/2 , GH = GraphicsHeight()/2 'Center everything so that we look from the coordinates 0,0 in the middle

Local Fps:FpsCounter = New FPSCounter
While Not KeyDown(Key_Escape)

	If Poly1 And Poly2
	
		If MouseHit(1) Poly1.Add( MouseX()-GW,MouseY()-GH )	'LeftMouse
		
		If MouseHit(2) Poly1.Add( Poly1.ix[0],Poly1.iy[0] )'Join back to start 'Right Mouse
		
		If KeyHit(Key_Space) Poly1 = TPolygon.Create() 'Start on a new Polygon
		
		Plot MouseX(),MouseY()	 'Mark Mouse

		Poly1.Draw( GW,GH )
		
		Poly2.Remove()
		Poly2 = Poly1.Copy() 'Make a copy of the polygon
		Poly2.Scale( 0.1 , 0.1 )'10% smaller
		Poly2.Draw( MouseX(), MouseY() )
		
		If PolygonOverlap(Poly1,GW,GH,Poly2,MouseX(), MouseY() ,False )
			DrawText "&lt; &lt;   C O L L I S I O N   D E T E C T E D   &gt; &gt;" , 0,0
		EndIf
		
		If PolygonOverlap(Poly1,GW,GH,Rect,X,Y,False )
			DrawText "&lt; &lt;   C O L L I S I O N   D E T E C T E D   &gt; &gt;" , 2,0
		EndIf	
			
		If PolygonOverlap(Poly2,MouseX(),MouseY(),Rect,X,Y,False )
			DrawText "&lt; &lt;   C O L L I S I O N   D E T E C T E D   &gt; &gt;" , 0,2
		EndIf		

	EndIf

		Rect.Draw(X,Y) ; X:+Rand(-2,2) ;Y:+Rand(-1,1)'Draw and shake the ball		
		
		DrawText( "X: "+MouseX()+"  Y: "+MouseY(),20,20 ) 
		FPS.CalculateFPS() ;FPS.DrawFPS(20,40)
		
		If KeyDown(Key_D) Poly1 = Null ;Poly2 = Null
		DrawText( " Polygon Count : "+Tpolygon.Count,20,60 )
			
Flip;Cls	
Wend


Type FPSCounter
	Field FPS%,Count%,Time%
	
	Method CalculateFPS()
			Count:+1			
			If Time+1000 &lt; MilliSecs() 'FPS last sec
				
				FPS=Count' &lt;- Frames/Sec
				Count=0
				Time=MilliSecs()			
			EndIf	
	End Method
	
	Method DrawFPS(X=0,Y=0)
		DrawText "Current FPS: "+FPS,X,Y
	End Method
	
	Method New() Time = MilliSecs() EndMethod
End Type
'---------------------------------------------------------------------------------------




Rem
Here starts the actuall module 

Module indiepath.poly

ModuleInfo "Name: 2d Polygon Lib"
ModuleInfo "License: Public Domain"
ModuleInfo "Author: Tim Fisher &amp; Gosse Corrupted , Edited by Wave~"

Import BRL.LinkedList
Import BRL.GLMax2D
End Rem


Global gSin#[360]
Global gCos#[360]

Local a%

For a = 0 To 359
	gSin#[a] = Sin(a)
	gCos#[a] = Cos(a)
Next

Type TPolygon
	
	Global List:TList
	Global Count
		
	Field iX#[64]	
	Field iY#[64]	
	Field fX#[64]	
	Field fY#[64]	
	Field iVertexCount		
	Field fScaleX#			
	Field fScaleY#			
	Field fAngle#			
	Field iMinX#				
	Field iMinY#				
	Field iMaxX#				
	Field iMaxY#
				
		'Used internally only
		Method New ()
            	If List = Null Then List = CreateList()
            	List.AddLast Self
			Count:+1
    		End Method		
		
		Method Remove()            	
			List.Remove Self
			Count:-1	
		EndMethod
		'Remove this Poly
		'MyPoly.Remove
		
		'Create a New Polygon Instance		
		'MyPoly:Polygon = Polygon.Create()
		Function Create:Tpolygon()
			Local Poly:TPolygon
			Poly = New TPolygon
			Poly.fScaleX=1;Poly.fScaleY=1
			Return Poly
		End Function		
		
		' The use:
		' MyPoly.AddVertex(x,y)
		Method AddVertex( X#,Y#, Update=True)
			iX#[iVertexCount] = x#
			iY#[iVertexCount] = y#		
			iVertexCount:+ 1
			If Update Then Self.Update()
		End Method
		'This is a even shorter version =)
		Method Add(X#,Y#,Update=True)
			AddVertex(X,Y,Update=True)		
		EndMethod
				
				
		'Scale alters the size
		'Ex to scale to double size
		'MyPoly.Scale(2,2)' 2 = 200%
		'Ex to scale to half size
		'MyPoly.Scale(0.5,0.5)' 0.5 = 50%
		Method Scale(sx#,sy#,Update=True)
			fScaleX#:* sx#
			fScaleY#:* sy#	
			If Update Then Self.Update()
		EndMethod

		
		'Resize the Poly by a stated amount
		'Set the polygon size		
		'MyPoly.ReSize(1,1)'set to original size
		Method Resize(sx#,sy#,update=True)
			fScaleX# = sx#
			fScaleY# = sy#	
			If update Then Self.Update()
		EndMethod
		
		
		'Turn the Poly By the stated amount
		'Ex MyPoly.Turn(15) 
		'Adds to the current direction
		Method Turn(rot#,update=True)
			fAngle# = wrap_angle(fAngle# + rot#)
			If update Then Self.Update()
		EndMethod
		
		
		'Rotate the Poly by the stated amount
		'Set the direction to this angle
		Method SetDir(Angle#,update=True)
			fAngle# = wrap_angle(angle#)
			If update Then Self.Update()
		EndMethod
		
		

		
		'Copy one poly to another
		'Returns a Polygon equal to the one you copied
		'Ex:
		'ACopyofMyPoly:Polygon = MyPoly.Copy()
		Method Copy:TPolygon()
			Local NewPoly:TPolygon
			NewPoly = New TPolygon
				
			For Local i = 0 To iVertexCount - 1
				NewPoly.iX#[i] = iX#[i]
				NewPoly.iY#[i] = iY#[i]
				NewPoly.fX#[i] = fX#[i]
				NewPoly.fY#[i] = fY#[i]
			Next
			
			NewPoly.iVertexCount = iVertexCount
			NewPoly.fScaleX#	= fScaleX#
			NewPoly.fScaleY#	= fScaleY#
			NewPoly.fAngle# 	= fAngle#
			NewPoly.iMinX# 	= iMinX#
			NewPoly.iMinY#	= iMinY#
			NewPoly.iMaxX# 	= iMaxX#
			NewPoly.iMaxY# 	= iMaxY#
			
			Return NewPoly
		EndMethod
		
		
		
		'Update the Poly
		Method Update()
			Local f1X#, f1Y#, f1#, f2#, angle#,i 
			
			iMinX = 9999999.00
			iMinY = 9999999.00
			iMaxX = -9999999.00
			iMaxY = -9999999.00
			
			For i = 0 To iVertexCount - 1
				f1X# = iX#[i] * fScaleX#
				f1y# = iY#[i] * fScaleY#
				
				angle# = fAngle#
				
				If angle# &lt;&gt; 0 Then
					f1# = gCos#[Angle#] * f1X# - gSin#[Angle#] * f1Y#
					f2# = gSin#[Angle#] * f1X# + gCos#[Angle#] * f1Y#
					f1X# = f1#
					f1y# = f2#
				EndIf
		
				fX#[i] = f1X#
				fY#[i] = f1Y#
					
				If f1X# &lt; iMinX# Then iMinX = f1X#
				If f1Y# &lt; iMinY# Then iMinY = f1Y#
				If f1X# &gt; iMaxX# Then iMaxX = f1X#
				If f1Y# &gt; iMaxY# Then iMaxY = f1Y#
			Next
		End Method			

		'Draw the Specified Poly to Screen
		'Uses the current drawing color
		'Dunno what happens with rotations and line-scales?
		Method Draw(x#,y#)
			Local lx#, ly#, i
			lx# = fX#[0] + x#
			ly# = fY#[0] + y#
			
			For i = 1 To iVertexCount -1
				DrawLine (lx#,ly#,fX#[i]+x,fY#[i]+y)
				lx# = fX#[i] + x#
				ly# = fY#[i] + y#
			Next
		EndMethod 
		
		'Make sure all angles are within 0 to 360 degrees
		Function Wrap_Angle#(angle#)
			While angle# &gt;= 360 ; angle#:- 360 ; Wend
			While angle# &lt;  0   ; angle#:+ 360 ; Wend
			Return angle#
		End Function
End Type
	
'Return TRUE if circles overlap
'This is faster than poly overlap and could be used 
'until we get into a "critical" range.
Function CircleOverlap(x1#,y1#,rad1#,x2#,y2#,rad2#)
	Local dx#, dy#, rsqr#
	dx# = x2# - x1#
	dy# = y2# - y1#
	rsqr# = (rad1# + rad2#) * (rad1# + rad2#)
	Return (dx#*dx#+dy#*dy# &lt; rsqr#)
End Function
		
'Checks 2 polygons and sees if they overlap			
Function PolygonOverlap(poly1:TPolygon,x1#,y1#,poly2:TPolygon,x2#,y2#,bounding = True)

	Local tx1#, ty1#, tx2#, ty2#, tx3#, ty3#, tx4#, ty4#
	Local dSqr#, d1#, d2#, dx#, dy#
	Local lx1#, ly1#, lx2#, ly2#
	Local i,j
	
		If bounding Then
			tx1 = X1 + poly1.iMinX
			ty1 = Y1 + poly1.iMinY
			tx2 = X1 + poly1.iMaxX
			ty2 = Y1 + poly1.iMaxY
			tx3 = X2 + poly2.iMinX
			ty3 = Y2 + poly2.iMinY
			tx4 = X2 + poly2.iMaxX
			ty4 = Y2 + poly2.iMaxX
	

			If Not (tx3 &gt; tx1 And ty3 &gt; ty1 And tx3 &lt; tx2 And ty3 &lt; ty2) Then
				If Not (tx4 &gt; tx1 And ty4 &gt; ty1 And tx4 &lt; tx2 And ty4 &lt; ty2) Then
					If Not (tx3 &gt; tx1 And ty4 &gt; ty1 And tx3 &lt; tx2 And ty4 &lt; ty2) Then
						If Not (tx4 &gt; tx1 And ty3 &gt; ty1 And tx4 &lt; tx2 And ty3 &lt; ty2) Then
							Return False
						End If
					End If
				End If
			End If
		End If
		

		lx1 = poly1.fX#[0] + X1
		ly1 = poly1.fY#[0] + Y1
		lx2 = poly2.fX#[0] + X2
		ly2 = poly2.fY#[0] + Y2

		For i = 1 To poly1.iVertexCount - 1
			For j = 1 To poly2.iVertexCount - 1

			tx1 = poly1.fX#[i] + X1
			ty1 = poly1.fY#[i] + Y1
			tx3 = poly2.fX#[j] + X2
			ty3 = poly2.fY#[j] + Y2
			tx2 = lX1
			ty2 = lY1
			tx4 = lX2
			ty4 = lY2

			dSqr = (ty4-ty3)*(tx2-tx1)-(tx4-tx3)*(ty2-ty1)
			d1 = (ty1-ty3)
			d2 = (tx1-tx3)
			dX = ((tx2-tx1)*d1-(ty2-ty1)*d2)
			dY = ((tx4-tx3)*d1-(ty4-ty3)*d2)
	
			If dSqr = 0 Then
	
				If dX = 0 And dY = 0 Then
					Return True
				End If
			Else
	
				d1 = dX / dSqr
				d2 = dY / dSqr
				If (d1 &gt;= 0 And d1 &lt;= 1) And (d2 &gt;= 0 And d2 &lt;= 1) Then
					Return True
				End If
			End If

			lX2 = tx3
			lY2 = ty3
		Next

		lX1 = tx1
		lY1 = ty1
	Next
	Return False
End Function
</textarea><br><br>I would never think collision detection and collision response was this complex as it proved to be. <br><br>But if we take one step at a time, eventually we much reach our goal. *wait* Where did this wall come from? <br><br></td></tr></table><br>
<a name="604240"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> I konw it sometime before I have seen it. It's nPoly.<br>It's Not so good as this I am trying to do now. For example they are not overlap.<br>I will try to finish it right now I m trying to make tutorial 3 and it's checking Velocity to find out where the objects collide. Just see the example 3 from the bin of the PolyColly zip. <br>The problem is that just a translation of the polygon.cpp or from the pseutocode from the document are not working.<br>It took me some time to figure out a way for the 1st and 2nd tutorials.<br>So it will take some time to find out how to do tutorial 3.<br>It's a really headache but I will try my best( just bought a book for C I hope it's not to diferent from C++)<br><br>As the tutorial 3 the polycolly it's finished...(in a way) and in the future we will add the ability to rotate. <br><br></td></tr></table><br>
<a name="604352"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess Altitudems is doing the conversion too. I just hope he posts any new sections he converts, so you don't both work on the same thing.<br><br>C and C++ is not the same thing, from what I have been told. However I still have very little (next to none) experience with either. <br><br>Rotate = Nice! Does pollycode use "projections" or some other teqnique? You don't have to worrie about the physics, I think they work. I'll see if I can put it all together soon.<br><br>Anyhow, the pollycode examples are awesome, however they are not simple to use, MaxPhysics will be very easy to use, even for beginners, that is my goal. <br><br>Also I do feel, like you said before, that we are the only onces working on this project. However, if you need help with anything, including C++ conversions, ask in Blitzmax's programming forum. It is very likley you will get more response if you ask direct questions there. Don't assume that anyone, or those who can help, will look here. Contrary to this being a Community project it more feels like a Commercial project. <br><br>So what do you say? 25$ for the Physics Module? <br><br></td></tr></table><br>
<a name="604376"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am still working on the conversions, but I am taking a new aproach. Instead of doing a straight conversion. I'm trying to redesign the structure of the code as I convert. That way everything is more object oriented and easier to use in a real world game. Unfortunetly the code I have is far too broken to post, but possibely this weekend I'll post some code.<br><br>Sorry I havent been very involved publicly. I'm a pretty busy person. I'm a working musician, magazine art director, and operate a design firm, among other things. Its hard to fit in time for Blitz. <br><br></td></tr></table><br>
<a name="604410"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wave: No way to put money on it… Money will destroy relationship and will ruin our lives.<br>We wand to create games and with utilities we will have to have customer support for life time if we wand to be respectful persons.<br>Plus we will gain from the community when this project it’s over and BRL put it to their Modserver (I hope they will )<br><br>Altitudems: Pls don’t disappear again polygons are a must. Pls post your progress.<br>I have a ULM book but for the time sits to shelve. It will be great if you can mail me your sketches of the reconstruction of the code. <br><br>I don’t have a safe mail right now but I will put both of you in my conducts.<br><br>P.S. Whoouaoou… this project have a great learning curve I am glad that I am in it and haven’t been kicked ( till now ) <br><br></td></tr></table><br>
<a name="604622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> Selling it for 25$ was more a joke to see which reads this thread. I to feel that I have gained a lot of experience on the project. Unfortunatly I'm quite sick and tired of programming by now. *sigh*<br><br>Anyhow I do really hope and wish this project will succeed and become something.. <br><br></td></tr></table><br>
<a name="606180"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have worked out the problem with elasticity. Also I have found a good optimization in circle vs circle (takin out the sqr() ).<br><br>What's next?<br><br>Yes, I'm going to put all it together and wish for it to work. <br><br></td></tr></table><br>
<a name="609671"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is it working? <br><br></td></tr></table><br>
<a name="609734"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fetze</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know, how optimized your code is, but I've worked out a couple of optimized Math-Functions some months ago. Maybe they could help?<br><br><pre class=code>
Function Distance:Float(fParX1:Float, fParY1:Float, fParX2:Float = 0, fParY2:Float = 0)
	Return Sqr((fParX1 - fParX2) * (fParX1 - fParX2) + (fParY1 - fParY2) * (fParY1 - fParY2))
End Function

Function DistanceQuad:Float(fParX1:Float, fParY1:Float, fParX2:Float = 0, fParY2:Float = 0)
	Return ((fParX1 - fParX2) * (fParX1 - fParX2) + (fParY1 - fParY2) * (fParY1 - fParY2))
End Function

Function IntDistance:Int(iParX1:Int, iParY1:Int, iParX2:Int = 0, iParY2:Int = 0)
	Return Sqr((iParX1 - iParX2) * (iParX1 - iParX2) + (iParY1 - iParY2) * (iParY1 - iParY2))
End Function

Function IntDistanceQuad:Int(iParX1:Int, iParY1:Int, iParX2:Int = 0, iParY2:Int = 0)
	Return ((iParX1 - iParX2) * (iParX1 - iParX2) + (iParY1 - iParY2) * (iParY1 - iParY2))
End Function

'iParXD = (iParX1 - iParX2)
'iParYD = (iParY1 - iParY2)
Function ApproxDistance:Int(iParXD:Int, iParYD:Int)
	Local iMin:Int
	Local iMax:Int
	
	If iParXD &lt; 0 Then iParXD = -iParXD
	If iParYD &lt; 0 Then iParYD = -iParYD
	If iParXD &lt; iParYD Then
		iMin = iParXD
		iMax = iParYD
	Else
		iMin = iParYD
		iMax = iParXD
	EndIf
	
	Return (((iMax Shl 8) + (iMax Shl 3) - (iMax Shl 4) - (iMax Shl 1) + (iMin Shl 7) - (iMin Shl 5) + (iMin Shl 3) - (iMin Shl 1)) Shr 8)
End Function

Function Angle:Float(fX1:Float, fY1:Float, fX2:Float, fY2:Float)
	Return (ATan2(fY2 - fY1, fX2 - fX1) + 450.0) Mod 360.0
End Function

Function IntAngle:Float(iX1:Int, iY1:Int, iX2:Int, iY2:Int)
	Return (Int(ATan2(iY2 - iY1, iX2 - iX1)) + 450) Mod 360
End Function

Function TransformCoord:Byte(fVarX:Float Var, fVarY:Float Var, fAngle:Float, fParCenterX:Float = 0.0, fParCenterY:Float = 0.0, fScale:Float = 1.0)
	Local fTempAngle:Float = Angle(fParCenterX, fParCenterY, fVarX, fVarY) + fAngle
	Local fTempDist:Float = Distance(fVarX, fVarY, fParCenterX, fParCenterY) * fScale
	fVarX = fParCenterX + Sin(fTempAngle) * fTempDist
	fVarY = fParCenterY - Cos(fTempAngle) * fTempDist
	Return True
End Function

Function IntTransformCoord:Byte(iVarX:Int Var, iVarY:Int Var, iAngle:Int, iParCenterX:Int = 0.0, iParCenterY:Int = 0.0, fScale:Float = 1.0)
	Local iTempAngle:Int = IntAngle(iParCenterX, iParCenterY, iVarX, iVarY) + iAngle
	Local iTempDist:Int = IntDistance(iVarX, iVarY, iParCenterX, iParCenterY) * fScale
	iVarX = iParCenterX + Sin(iTempAngle) * iTempDist
	iVarY = iParCenterY - Cos(iTempAngle) * iTempDist
	Return True
End Function
</pre><br><br>Notice, that my Angles start with "straight up" for 0° and increase turning right. <br><br></td></tr></table><br>
<a name="610244"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think we have those Math-Functions, as vector functions. However ours may not be 100% optimized in all cases. <br><br>Checkout the Vector2D.Bmx file. Take a quick look at these and see if ours are the same or not. Every (Almost) math thingy is in there. <br><br></td></tr></table><br>
<a name="704432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's been 8 months: Did this ever get completed?<br><br>Russell <br><br></td></tr></table><br>
<a name="704909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Armitage 1982</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> i think not :(<br>so bad <br><br></td></tr></table><br>
<a name="706008"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess we are waiting on someone to 'convert' ODE to BlitzMax module format? It exists for B3D, so maybe not too difficult?<br><br>Russell <br><br></td></tr></table><br>
<a name="706013"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >VIP3R</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just so that you know, a JV-ODE module already exists for BlitzMax on Win32 platforms - see the JV-ODE thread in the Blitz3D Userlibs forum area.<br><br>[edit] Actually, it's about time there was a JV-ODE BlitzMax Module thread in here. <br><br></td></tr></table><br>
<a name="707209"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was really hoping for a cross-platform ODE... The Win32 one seems to work great! It'd be nice to have this on all platforms, though. :)<br><br>Russell <br><br></td></tr></table><br>
<a name="707309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >VIP3R</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Russell :)<br><br>Yep, it would be great to have JV-ODE working on all platforms, but unfortunately I don't currently have access to any of the Mac platforms ( PPC / Intel ). <br><br></td></tr></table><br>
<a name="708128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wish I had an extra Mac Mini lying around for ya ;)<br><br><a href="http://www.futurepowerpc.com/scripts/product.asp?PRDCODE=APDT-MA607LLA&amp;REFID=PW" target="_blank">http://www.futurepowerpc.com/scripts/product.asp?PRDCODE=APDT-MA607LLA&amp;REFID=PW</a><br><br>($599US aint too bad a deal, really).<br><br>Russell <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
