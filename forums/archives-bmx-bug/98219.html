<!DOCTYPE html><html lang="en" ><head ><title >Freejoy OSX not working properly</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Freejoy OSX not working properly</h1><a href="forums.php" >Archives Forums</a>/<a href="topics.php?forum=105" >BlitzMax Bug Reports</a>/<a href="#bottom" >Freejoy OSX not working properly</a><br><br>
<a name="1146050"></a>

<a name="1146051"></a>

<a name="1146052"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robb</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> The pub.freejoy module for MacOSX doesn't assign devices correctly.<br><br>It looks like the module allocates Blitzmax Joypads per HID device and not how many Generic Desktop Joystick usage pages are contained within each HID. <br>This means that USB joypad hubs don't work properly with Blitzmax. Freejoy tries to allocate all of the joypad inputs to the same blitzmax device which renders all connected joypads completely unusable. To give an example: <br><br>If your hub has four joypads connected, the buttons and axes will be randomly distributed amongst them - one pad has buttons 1-4, another has the X &amp; Y axes etc.<br><br>Separation of the HUB connected joypads is definitely possible in MacOSX (the joypads work fine in other apps) but anything made with Blitzmax isn't working properly.<br><br>I've raised this issue a few times now, but never seem to get very far in solving the problem. Is there any chance that an update could be made to Freejoy to alter how it enumerates joypads?<br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1150189"></a>

<a name="1150195"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Are you talking about a special type of joypad hub here, or any old usb hub?<br><br>[edit]<br>Just tested with 2 gamepads and 1 dirt-cheap usb hub, and freejoy seems to work. I modified the joycount sample code to toggle ports when space is hit and neither gamepad interfered with the other.<br><br>Can you provide more details of your setup? Are you using a special kind of hub? Does it happen with only 2 gamepads? etc...<br>[/edit]<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1150264"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robb</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, thanks for the reply I *really* appreciate the help.<br><br>It seems to be joypad specific hubs. I've tested with a <a href="http://www.amazon.co.uk/dp/B002IXZ5DE" target="_blank">SNES to USB hub</a> with two sockets. The same thing happens if I use a similar HUB for two PS2 controllers. <br><br>Other OSX apps recognise the hub as two separate usb controllers, but with blitz games input is always split. It doesn't matter if there are one or two controllers connected to the hub - one socket gets the buttons, the other socket gets the dpad. I think the freejoy module is registering only one USB device and trying to map the inputs of two controllers to one blitz 'joypad'.<br><br>This is the USB prober profile for the device:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Low Speed device @ 3 (0x06400000): .............................................   Composite device: "USB GamePad"
    Port Information:   0x001f
           Captive
           Attached to Root Hub
           Internal Device
           Connected
           Enabled
    Device Descriptor   
        Descriptor Version Number:   0x0110
        Device Class:   0   (Composite)
        Device Subclass:   0
        Device Protocol:   0
        Device MaxPacketSize:   8
        Device VendorID/ProductID:   0x0E8F/0x3013   (unknown vendor)
        Device Version Number:   0x0111
        Number of Configurations:   1
        Manufacturer String:   1 "HuiJia "
        Product String:   2 "USB GamePad"
        Serial Number String:   0 (none)
    Configuration Descriptor   
        Length (and contents):   34
            Raw Descriptor (hex)    0000: 09 02 22 00 01 01 00 80  96 09 04 00 00 01 03 00  
            Raw Descriptor (hex)    0010: 00 00 09 21 10 01 00 01  22 CA 00 07 05 81 03 08  
            Raw Descriptor (hex)    0020: 00 08 
        Number of Interfaces:   1
        Configuration Value:   1
        Attributes:   0x80 (bus-powered)
        MaxPower:   300 ma
        Interface #0 - HID   
            Alternate Setting   0
            Number of Endpoints   1
            Interface Class:   3   (HID)
            Interface Subclass;   0
            Interface Protocol:   0
            HID Descriptor   
                Descriptor Version Number:   0x0110
                Country Code:   0
                Descriptor Count:   1
                Descriptor 1   
                    Type:   0x22  (Report Descriptor)
                    Length (and contents):   202
                        Raw Descriptor (hex)    0000: 05 01 09 04 A1 01 85 01  A1 02 75 08 95 04 15 00  
                        Raw Descriptor (hex)    0010: 26 FF 00 35 00 46 FF 00  09 32 09 35 09 30 09 31  
                        Raw Descriptor (hex)    0020: 81 02 75 04 95 01 25 07  46 3B 01 65 14 09 39 81  
                        Raw Descriptor (hex)    0030: 42 65 00 75 01 95 10 25  01 45 01 05 09 19 01 29  
                        Raw Descriptor (hex)    0040: 10 81 02 06 00 FF 75 01  95 04 25 01 45 01 09 01  
                        Raw Descriptor (hex)    0050: 81 02 C0 A1 02 75 08 95  04 46 FF 00 26 FF 00 09  
                        Raw Descriptor (hex)    0060: 02 91 02 C0 C0 05 01 09  04 A1 01 85 02 A1 02 75  
                        Raw Descriptor (hex)    0070: 08 95 04 15 00 26 FF 00  35 00 46 FF 00 09 32 09  
                        Raw Descriptor (hex)    0080: 35 09 30 09 31 81 02 75  04 95 01 25 07 46 3B 01  
                        Raw Descriptor (hex)    0090: 65 14 09 39 81 42 65 00  75 01 95 10 25 01 45 01  
                        Raw Descriptor (hex)    00a0: 05 09 19 01 29 10 81 02  06 00 FF 75 01 95 04 25  
                        Raw Descriptor (hex)    00b0: 01 45 01 09 01 81 02 C0  A1 02 75 08 95 04 46 FF  
                        Raw Descriptor (hex)    00c0: 00 26 FF 00 09 02 91 02  C0 C0 
                    Parsed Report Descriptor:   
                          Usage Page    (Generic Desktop) 
                          Usage (Joystick)    
                              Collection (Application)    
                                ReportID................    (1)  
                                    Collection (Logical)    
                                      Report Size.............    (8)  
                                      Report Count............    (4)  
                                      Logical Minimum.........    (0)  
                                      Logical Maximum.........    (255)  
                                      Physical Minimum........    (0)  
                                      Physical Maximum........    (255)  
                                      Usage (Z)    
                                      Usage (Rz)    
                                      Usage (X)    
                                      Usage (Y)    
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Bitfield) 
                                      Report Size.............    (4)  
                                      Report Count............    (1)  
                                      Logical Maximum.........    (7)  
                                      Physical Maximum........    (315)  
                                      Unit....................    (20)  
                                      Usage (Hat Switch)    
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, Null State, Bitfield) 
                                      Unit....................    (0)  
                                      Report Size.............    (1)  
                                      Report Count............    (16)  
                                      Logical Maximum.........    (1)  
                                      Physical Maximum........    (1)  
                                      Usage Page    (Button) 
                                      Usage Minimum...........    (1)  
                                      Usage Maximum...........    (16)  
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Bitfield) 
                                      Usage Page    (65280) 
                                      Report Size.............    (1)  
                                      Report Count............    (4)  
                                      Logical Maximum.........    (1)  
                                      Physical Maximum........    (1)  
                                      Usage 1 (0x1)    
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Bitfield) 
                                    End Collection     
                                    Collection (Logical)    
                                      Report Size.............    (8)  
                                      Report Count............    (4)  
                                      Physical Maximum........    (255)  
                                      Logical Maximum.........    (255)  
                                      Usage 2 (0x2)    
                                      Output..................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Nonvolatile, Bitfield) 
                                    End Collection     
                              End Collection     
                          Usage Page    (Generic Desktop) 
                          Usage (Joystick)    
                              Collection (Application)    
                                ReportID................    (2)  
                                    Collection (Logical)    
                                      Report Size.............    (8)  
                                      Report Count............    (4)  
                                      Logical Minimum.........    (0)  
                                      Logical Maximum.........    (255)  
                                      Physical Minimum........    (0)  
                                      Physical Maximum........    (255)  
                                      Usage (Z)    
                                      Usage (Rz)    
                                      Usage (X)    
                                      Usage (Y)    
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Bitfield) 
                                      Report Size.............    (4)  
                                      Report Count............    (1)  
                                      Logical Maximum.........    (7)  
                                      Physical Maximum........    (315)  
                                      Unit....................    (20)  
                                      Usage (Hat Switch)    
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, Null State, Bitfield) 
                                      Unit....................    (0)  
                                      Report Size.............    (1)  
                                      Report Count............    (16)  
                                      Logical Maximum.........    (1)  
                                      Physical Maximum........    (1)  
                                      Usage Page    (Button) 
                                      Usage Minimum...........    (1)  
                                      Usage Maximum...........    (16)  
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Bitfield) 
                                      Usage Page    (65280) 
                                      Report Size.............    (1)  
                                      Report Count............    (4)  
                                      Logical Maximum.........    (1)  
                                      Physical Maximum........    (1)  
                                      Usage 1 (0x1)    
                                      Input...................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Bitfield) 
                                    End Collection     
                                    Collection (Logical)    
                                      Report Size.............    (8)  
                                      Report Count............    (4)  
                                      Physical Maximum........    (255)  
                                      Logical Maximum.........    (255)  
                                      Usage 2 (0x2)    
                                      Output..................   (Data, Variable, Absolute, No Wrap, Linear, Preferred State, No Null Position, Nonvolatile, Bitfield) 
                                    End Collection     
                              End Collection     
            Endpoint 0x81 - Interrupt Input   
                Address:   0x81  (IN)
                Attributes:   0x03  (Interrupt no synchronization data endpoint)
                Max Packet Size:   8
                Polling Interval:   8 ms</textarea><br><br>Printing the cookie output in freejoy module gives the following:<br><pre class=code>page=kHIDPage_GenericDesktop usage=4 cookie=1
page=kHIDPage_GenericDesktop usage=50 cookie=2
page=kHIDPage_Button usage=1 cookie=7
page=kHIDPage_Button usage=2 cookie=8
page=kHIDPage_Button usage=3 cookie=9
page=kHIDPage_Button usage=4 cookie=10
page=kHIDPage_Button usage=5 cookie=11
page=kHIDPage_Button usage=6 cookie=12
page=kHIDPage_Button usage=7 cookie=13
page=kHIDPage_Button usage=8 cookie=14
page=kHIDPage_Button usage=9 cookie=15
page=kHIDPage_Button usage=10 cookie=16
page=kHIDPage_Button usage=11 cookie=17
page=kHIDPage_Button usage=12 cookie=18
page=kHIDPage_Button usage=13 cookie=19
page=kHIDPage_Button usage=14 cookie=20
page=kHIDPage_Button usage=15 cookie=21
page=kHIDPage_Button usage=16 cookie=22
page=kHIDPage_GenericDesktop usage=50 cookie=41
page=kHIDPage_GenericDesktop usage=53 cookie=42
page=kHIDPage_GenericDesktop usage=48 cookie=43
page=kHIDPage_GenericDesktop usage=49 cookie=44
page=kHIDPage_GenericDesktop usage=57 cookie=45
page=kHIDPage_GenericDesktop usage=4 cookie=4
page=kHIDPage_GenericDesktop usage=50 cookie=5</pre><br><br>There is also a further set (most likely as there are two ports on the adapter):<br><pre class=code>page=kHIDPage_Button usage=1 cookie=24
page=kHIDPage_Button usage=2 cookie=25
page=kHIDPage_Button usage=3 cookie=26
page=kHIDPage_Button usage=4 cookie=27
page=kHIDPage_Button usage=5 cookie=28
page=kHIDPage_Button usage=6 cookie=29
page=kHIDPage_Button usage=7 cookie=30
page=kHIDPage_Button usage=8 cookie=31
page=kHIDPage_Button usage=9 cookie=32
page=kHIDPage_Button usage=10 cookie=33
page=kHIDPage_Button usage=11 cookie=34
page=kHIDPage_Button usage=12 cookie=35
page=kHIDPage_Button usage=13 cookie=36
page=kHIDPage_Button usage=14 cookie=37
page=kHIDPage_Button usage=15 cookie=38
page=kHIDPage_Button usage=16 cookie=39
page=kHIDPage_GenericDesktop usage=50 cookie=46
page=kHIDPage_GenericDesktop usage=53 cookie=47
page=kHIDPage_GenericDesktop usage=48 cookie=48
page=kHIDPage_GenericDesktop usage=49 cookie=49
page=kHIDPage_GenericDesktop usage=57 cookie=50</pre> <br><br></td></tr></table><br>
<a name="1150304"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Can you give this a try?<br><br>It's based on GLFW and wont work exactly the same as freejoy, but we'll be able to see if it can handle your hardware at least. It can be freejoy-ified later if it works.<br><br>New code for freejoy.mod/freejoy.macosx.c<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
//
// Joystick code from GLFW
//
// Adapted by Mark Sibly for use with BlitzMax
//
// Thanks for GLFW Marcus and Camilla!!!!!
//
//========================================================================
// GLFW - An OpenGL framework
// Platform:    Cocoa/NSOpenGL
// API Version: 2.7
// WWW:         <a href="http://www.glfw.org/" target="_blank">http://www.glfw.org/</a>
//------------------------------------------------------------------------
// Copyright (c) 2009-2010 Camilla Berglund &lt;elmindreda@...;
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would
//    be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not
//    be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source
//    distribution.
//
//========================================================================

#define GL_TRUE 1
#define GL_FALSE 0

/* Key and button state/action definitions */
#define GLFW_RELEASE            0
#define GLFW_PRESS              1

/* Joystick identifiers */
#define GLFW_JOYSTICK_1          0
#define GLFW_JOYSTICK_2          1
#define GLFW_JOYSTICK_3          2
#define GLFW_JOYSTICK_4          3
#define GLFW_JOYSTICK_5          4
#define GLFW_JOYSTICK_6          5
#define GLFW_JOYSTICK_7          6
#define GLFW_JOYSTICK_8          7
#define GLFW_JOYSTICK_9          8
#define GLFW_JOYSTICK_10         9
#define GLFW_JOYSTICK_11         10
#define GLFW_JOYSTICK_12         11
#define GLFW_JOYSTICK_13         12
#define GLFW_JOYSTICK_14         13
#define GLFW_JOYSTICK_15         14
#define GLFW_JOYSTICK_16         15
#define GLFW_JOYSTICK_LAST       GLFW_JOYSTICK_16

/* glfwGetJoystickParam tokens */
#define GLFW_PRESENT              0x00050001
#define GLFW_AXES                 0x00050002
#define GLFW_BUTTONS              0x00050003

#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;

#include &lt;mach/mach.h&gt;
#include &lt;mach/mach_error.h&gt;

#include &lt;CoreFoundation/CoreFoundation.h&gt;
#include &lt;IOKit/IOKitLib.h&gt;
#include &lt;IOKit/IOCFPlugIn.h&gt;
#include &lt;IOKit/hid/IOHIDLib.h&gt;
#include &lt;IOKit/hid/IOHIDKeys.h&gt;
#include &lt;Kernel/IOKit/hidsystem/IOHIDUsageTables.h&gt;

//------------------------------------------------------------------------
// Joystick state
//------------------------------------------------------------------------

typedef struct
{
    int present;
    char product[256];

    IOHIDDeviceInterface** interface;

    int numAxes;
    int numButtons;
    int numHats;

    CFMutableArrayRef axes;
    CFMutableArrayRef buttons;
    CFMutableArrayRef hats;

} _glfwJoystick;

static _glfwJoystick _glfwJoysticks[GLFW_JOYSTICK_LAST + 1];


typedef struct
{
    IOHIDElementCookie cookie;

    long value;

    long min;
    long max;

    long minReport;
    long maxReport;

} _glfwJoystickElement;


void GetElementsCFArrayHandler( const void* value, void* parameter );


//========================================================================
// Adds an element to the specified joystick
//========================================================================

static void addJoystickElement( _glfwJoystick* joystick, CFTypeRef refElement )
{
    long elementType, usagePage, usage;
    CFTypeRef refElementType, refUsagePage, refUsage;

    refElementType = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementTypeKey ) );
    refUsagePage = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementUsagePageKey ) );
    refUsage = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementUsageKey ) );

    CFMutableArrayRef elementsArray = NULL;

    CFNumberGetValue( refElementType, kCFNumberLongType, &amp;elementType );
    CFNumberGetValue( refUsagePage, kCFNumberLongType, &amp;usagePage );
    CFNumberGetValue( refUsage, kCFNumberLongType, &amp;usage );

    if( elementType == kIOHIDElementTypeInput_Axis ||
        elementType == kIOHIDElementTypeInput_Button ||
        elementType == kIOHIDElementTypeInput_Misc )
    {
        switch( usagePage ) /* only interested in kHIDPage_GenericDesktop and kHIDPage_Button */
        {
            case kHIDPage_GenericDesktop:
            {
                switch( usage )
                {
                    case kHIDUsage_GD_X:
                    case kHIDUsage_GD_Y:
                    case kHIDUsage_GD_Z:
                    case kHIDUsage_GD_Rx:
                    case kHIDUsage_GD_Ry:
                    case kHIDUsage_GD_Rz:
                    case kHIDUsage_GD_Slider:
                    case kHIDUsage_GD_Dial:
                    case kHIDUsage_GD_Wheel:
                        joystick-&gt;numAxes++;
                        elementsArray = joystick-&gt;axes;
                        break;
                    case kHIDUsage_GD_Hatswitch:
                        joystick-&gt;numHats++;
                        elementsArray = joystick-&gt;hats;
                        break;
                }

                break;
            }

            case kHIDPage_Button:
                joystick-&gt;numButtons++;
                elementsArray = joystick-&gt;buttons;
                break;
            default:
                break;
        }

        if( elementsArray )
        {
            long number;
            CFTypeRef refType;

            _glfwJoystickElement* element = (_glfwJoystickElement*) malloc( sizeof( _glfwJoystickElement ) );

            CFArrayAppendValue( elementsArray, element );

            refType = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementCookieKey ) );
            if( refType &amp;&amp; CFNumberGetValue( refType, kCFNumberLongType, &amp;number ) )
            {
                element-&gt;cookie = (IOHIDElementCookie) number;
            }

            refType = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementMinKey ) );
            if( refType &amp;&amp; CFNumberGetValue( refType, kCFNumberLongType, &amp;number ) )
            {
                element-&gt;minReport = element-&gt;min = number;
            }

            refType = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementMaxKey ) );
            if( refType &amp;&amp; CFNumberGetValue( refType, kCFNumberLongType, &amp;number ) )
            {
                element-&gt;maxReport = element-&gt;max = number;
            }
        }
    }
    else
    {
        CFTypeRef refElementTop = CFDictionaryGetValue( refElement, CFSTR( kIOHIDElementKey ) );
        if( refElementTop )
        {
            CFTypeID type = CFGetTypeID( refElementTop );
            if( type == CFArrayGetTypeID() ) /* if element is an array */
            {
                CFRange range = { 0, CFArrayGetCount( refElementTop ) };
                CFArrayApplyFunction( refElementTop, range, GetElementsCFArrayHandler, joystick );
            }
        }
    }
}


//========================================================================
// Adds an element to the specified joystick
//========================================================================

void GetElementsCFArrayHandler( const void* value, void* parameter )
{
    if( CFGetTypeID( value ) == CFDictionaryGetTypeID() )
    {
        addJoystickElement( (_glfwJoystick*) parameter, (CFTypeRef) value );
    }
}


//========================================================================
// Returns the value of the specified element of the specified joystick
//========================================================================

static long getElementValue( _glfwJoystick* joystick, _glfwJoystickElement* element )
{
    IOReturn result = kIOReturnSuccess;
    IOHIDEventStruct hidEvent;
    hidEvent.value = 0;

    if( joystick &amp;&amp; element &amp;&amp; joystick-&gt;interface )
    {
        result = (*(joystick-&gt;interface))-&gt;getElementValue( joystick-&gt;interface,
                                                            element-&gt;cookie,
                                                            &amp;hidEvent );
        if( kIOReturnSuccess == result )
        {
            /* record min and max for auto calibration */
            if( hidEvent.value &lt; element-&gt;minReport )
            {
                element-&gt;minReport = hidEvent.value;
            }
            if( hidEvent.value &gt; element-&gt;maxReport )
            {
                element-&gt;maxReport = hidEvent.value;
            }
        }
    }

    /* auto user scale */
    return (long) hidEvent.value;
}


//========================================================================
// Removes the specified joystick
//========================================================================

static void removeJoystick( _glfwJoystick* joystick )
{
    int i;

    if( joystick-&gt;present )
    {
        joystick-&gt;present = GL_FALSE;

        for( i = 0;  i &lt; joystick-&gt;numAxes;  i++ )
        {
            _glfwJoystickElement* axes =
                (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick-&gt;axes, i );
            free( axes );
        }
        CFArrayRemoveAllValues( joystick-&gt;axes );
        joystick-&gt;numAxes = 0;

        for( i = 0;  i &lt; joystick-&gt;numButtons;  i++ )
        {
            _glfwJoystickElement* button =
                (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick-&gt;buttons, i );
            free( button );
        }
        CFArrayRemoveAllValues( joystick-&gt;buttons );
        joystick-&gt;numButtons = 0;

        for( i = 0;  i &lt; joystick-&gt;numHats;  i++ )
        {
            _glfwJoystickElement* hat =
                (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick-&gt;hats, i );
            free( hat );
        }
        CFArrayRemoveAllValues( joystick-&gt;hats );
        joystick-&gt;hats = 0;

        (*(joystick-&gt;interface))-&gt;close( joystick-&gt;interface );
        (*(joystick-&gt;interface))-&gt;Release( joystick-&gt;interface );

        joystick-&gt;interface = NULL;
    }
}


//========================================================================
// Callback for user-initiated joystick removal
//========================================================================

static void removalCallback( void* target, IOReturn result, void* refcon, void* sender )
{
    removeJoystick( (_glfwJoystick*) refcon );
}


//========================================================================
// Polls for joystick events and updates GFLW state
//========================================================================

static void pollJoystickEvents( void )
{
    int i;
    CFIndex j;

    for( i = 0;  i &lt; GLFW_JOYSTICK_LAST + 1;  i++ )
    {
        _glfwJoystick* joystick = &amp;_glfwJoysticks[i];

        if( joystick-&gt;present )
        {
            for( j = 0;  j &lt; joystick-&gt;numButtons;  j++ )
            {
                _glfwJoystickElement* button =
                    (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick-&gt;buttons, j );
                button-&gt;value = getElementValue( joystick, button );
            }

            for( j = 0;  j &lt; joystick-&gt;numAxes;  j++ )
            {
                _glfwJoystickElement* axes =
                    (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick-&gt;axes, j );
                axes-&gt;value = getElementValue( joystick, axes );
            }

            for( j = 0;  j &lt; joystick-&gt;numHats;  j++ )
            {
                _glfwJoystickElement* hat =
                    (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick-&gt;hats, j );
                hat-&gt;value = getElementValue( joystick, hat );
            }
        }
    }
}


//************************************************************************
//****                  GLFW internal functions                       ****
//************************************************************************

//========================================================================
// Initialize joystick interface
//========================================================================

void _glfwInitJoysticks( void )
{
    int deviceCounter = 0;
    IOReturn result = kIOReturnSuccess;
    mach_port_t masterPort = 0;
    io_iterator_t objectIterator = 0;
    CFMutableDictionaryRef hidMatchDictionary = NULL;
    io_object_t ioHIDDeviceObject = 0;

    result = IOMasterPort( bootstrap_port, &amp;masterPort );
    hidMatchDictionary = IOServiceMatching( kIOHIDDeviceKey );
    if( kIOReturnSuccess != result || !hidMatchDictionary )
    {
        if( hidMatchDictionary )
        {
            CFRelease( hidMatchDictionary );
        }

        return;
    }

    result = IOServiceGetMatchingServices( masterPort,
                                           hidMatchDictionary,
                                           &amp;objectIterator );
    if( result != kIOReturnSuccess )
    {
        return;
    }

    if( !objectIterator ) /* there are no joysticks */
    {
        return;
    }

    while( ( ioHIDDeviceObject = IOIteratorNext( objectIterator ) ) )
    {
        CFMutableDictionaryRef hidProperties = 0;
        kern_return_t result;
        CFTypeRef refCF = 0;

        IOCFPlugInInterface** ppPlugInInterface = NULL;
        HRESULT plugInResult = S_OK;
        SInt32 score = 0;

        long usagePage, usage;

        result = IORegistryEntryCreateCFProperties( ioHIDDeviceObject,
                                                    &amp;hidProperties,
                                                    kCFAllocatorDefault,
                                                    kNilOptions );

        if( result != kIOReturnSuccess )
        {
            continue;
        }

        /* Check device type */
        refCF = CFDictionaryGetValue( hidProperties, CFSTR( kIOHIDPrimaryUsagePageKey ) );
        if( refCF )
        {
            CFNumberGetValue( refCF, kCFNumberLongType, &amp;usagePage );
            if( usagePage != kHIDPage_GenericDesktop )
            {
                /* We are not interested in this device */
                continue;
            }
        }

        refCF = CFDictionaryGetValue( hidProperties, CFSTR( kIOHIDPrimaryUsageKey ) );
        if( refCF )
        {
            CFNumberGetValue( refCF, kCFNumberLongType, &amp;usage );

            if( usage != kHIDUsage_GD_Joystick &amp;&amp;
                usage != kHIDUsage_GD_GamePad &amp;&amp;
                usage != kHIDUsage_GD_MultiAxisController )
            {
                /* We are not interested in this device */
                continue;
            }
        }

        _glfwJoystick* joystick = &amp;_glfwJoysticks[deviceCounter];

        joystick-&gt;present = GL_TRUE;

        result = IOCreatePlugInInterfaceForService( ioHIDDeviceObject,
                                                    kIOHIDDeviceUserClientTypeID,
                                                    kIOCFPlugInInterfaceID,
                                                    &amp;ppPlugInInterface,
                                                    &amp;score );

        if( kIOReturnSuccess != result )
        {
            return;
        }

        plugInResult = (*ppPlugInInterface)-&gt;QueryInterface( ppPlugInInterface,
                                                             CFUUIDGetUUIDBytes( kIOHIDDeviceInterfaceID ),
                                                             (void *) &amp;(joystick-&gt;interface) );

        if( plugInResult != S_OK )
        {
            return;
        }

        (*ppPlugInInterface)-&gt;Release( ppPlugInInterface );

        (*(joystick-&gt;interface))-&gt;open( joystick-&gt;interface, 0 );
        (*(joystick-&gt;interface))-&gt;setRemovalCallback( joystick-&gt;interface,
                                                      removalCallback,
                                                      joystick,
                                                      joystick );

        /* Get product string */
        refCF = CFDictionaryGetValue( hidProperties, CFSTR( kIOHIDProductKey ) );
        if( refCF )
        {
            CFStringGetCString( refCF,
                                (char*) &amp;(joystick-&gt;product),
                                256,
                                CFStringGetSystemEncoding() );
        }

        joystick-&gt;numAxes = 0;
        joystick-&gt;numButtons = 0;
        joystick-&gt;numHats = 0;
        joystick-&gt;axes = CFArrayCreateMutable( NULL, 0, NULL );
        joystick-&gt;buttons = CFArrayCreateMutable( NULL, 0, NULL );
        joystick-&gt;hats = CFArrayCreateMutable( NULL, 0, NULL );

        CFTypeRef refTopElement = CFDictionaryGetValue( hidProperties,
                                                        CFSTR( kIOHIDElementKey ) );
        CFTypeID type = CFGetTypeID( refTopElement );
        if( type == CFArrayGetTypeID() )
        {
            CFRange range = { 0, CFArrayGetCount( refTopElement ) };
            CFArrayApplyFunction( refTopElement,
                                  range,
                                  GetElementsCFArrayHandler,
                                  (void*) joystick);
        }

        deviceCounter++;
    }
}


//========================================================================
// Close all opened joystick handles
//========================================================================

void _glfwTerminateJoysticks( void )
{
    int i;

    for( i = 0;  i &lt; GLFW_JOYSTICK_LAST + 1;  i++ )
    {
        _glfwJoystick* joystick = &amp;_glfwJoysticks[i];
        removeJoystick( joystick );
    }
}


//************************************************************************
//****               Platform implementation functions                ****
//************************************************************************

//========================================================================
// Determine joystick capabilities
//========================================================================

int _glfwPlatformGetJoystickParam( int joy, int param )
{
    if( !_glfwJoysticks[joy].present )
    {
        // TODO: Figure out if this is an error
        return GL_FALSE;
    }

    switch( param )
    {
        case GLFW_PRESENT:
            return GL_TRUE;

        case GLFW_AXES:
            return (int) CFArrayGetCount( _glfwJoysticks[joy].axes );

        case GLFW_BUTTONS:
            return (int) CFArrayGetCount( _glfwJoysticks[joy].buttons ) +
                   ((int) CFArrayGetCount( _glfwJoysticks[joy].hats )) * 4;

        default:
            break;
    }

    return GL_FALSE;
}


//========================================================================
// Get joystick axis positions
//========================================================================

int _glfwPlatformGetJoystickPos( int joy, float *pos, int numaxes )
{
    int i;

    if( joy &lt; GLFW_JOYSTICK_1 || joy &gt; GLFW_JOYSTICK_LAST )
    {
        return 0;
    }

    _glfwJoystick joystick = _glfwJoysticks[joy];

    if( !joystick.present )
    {
        // TODO: Figure out if this is an error
        return 0;
    }

    numaxes = numaxes &lt; joystick.numAxes ? numaxes : joystick.numAxes;

    // Update joystick state
    pollJoystickEvents();

    for( i = 0;  i &lt; numaxes;  i++ )
    {
        _glfwJoystickElement* axes =
            (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick.axes, i );

        long readScale = axes-&gt;maxReport - axes-&gt;minReport;

        if( readScale == 0 )
        {
            pos[i] = axes-&gt;value;
        }
        else
        {
            pos[i] = (2.0f * (axes-&gt;value - axes-&gt;minReport) / readScale) - 1.0f;
        }

        //printf("%ld, %ld, %ld\n", axes-&gt;value, axes-&gt;minReport, axes-&gt;maxReport);

        if( i &amp; 1 )
        {
            pos[i] = -pos[i];
        }
    }

    return numaxes;
}


//========================================================================
// Get joystick button states
//========================================================================

int _glfwPlatformGetJoystickButtons( int joy, unsigned char *buttons, int numbuttons )
{
    int i, j, button;

    if( joy &lt; GLFW_JOYSTICK_1 || joy &gt; GLFW_JOYSTICK_LAST )
    {
        return 0;
    }

    _glfwJoystick joystick = _glfwJoysticks[joy];

    if( !joystick.present )
    {
        // TODO: Figure out if this is an error
        return 0;
    }

    // Update joystick state
    pollJoystickEvents();

    for( button = 0;  button &lt; numbuttons &amp;&amp; button &lt; joystick.numButtons;  button++ )
    {
        _glfwJoystickElement* element = (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick.buttons, button );
        buttons[button] = element-&gt;value ? GLFW_PRESS : GLFW_RELEASE;
    }

    // Virtual buttons - Inject data from hats
    // Each hat is exposed as 4 buttons which exposes 8 directions with concurrent button presses

    const int directions[9] = { 1, 3, 2, 6, 4, 12, 8, 9, 0 }; // Bit fields of button presses for each direction, including nil

    for( i = 0;  i &lt; joystick.numHats;  i++ )
    {
        _glfwJoystickElement* hat = (_glfwJoystickElement*) CFArrayGetValueAtIndex( joystick.hats, i );
        int value = hat-&gt;value;
        if( value &lt; 0 || value &gt; 8 )
        {
            value = 8;
        }

        for( j = 0;  j &lt; 4 &amp;&amp; button &lt; numbuttons;  j++ )
        {
            buttons[button++] = directions[value] &amp; (1 &lt;&lt; j) ? GLFW_PRESS : GLFW_RELEASE;
        }
    }

    return button;
}

static int joy_count;
static int joy_id[16];

int JoyCount()
{
	if( !joy_count )
	{
		_glfwInitJoysticks();
		int i;
		for( i=GLFW_JOYSTICK_1;i&lt;=GLFW_JOYSTICK_LAST;++i )
		{
			if( _glfwPlatformGetJoystickParam( i,GLFW_PRESENT ) )
			{
				joy_id[joy_count++]=i;
			}
		}	
	}
	return joy_count;
}

char *JoyCName(int port)
{
	return "MacOSX Joystick";
}

int JoyButtonCaps(int port)
{
	if( port&lt;0 || port&gt;=joy_count ) return 0;
	
	return (1&lt;&lt;_glfwPlatformGetJoystickParam( joy_id[port],GLFW_BUTTONS ))-1;
}

int JoyAxisCaps(int port)
{
	if( port&lt;0 || port&gt;=joy_count ) return 0;
	
	return (1&lt;&lt;_glfwPlatformGetJoystickParam( joy_id[port],GLFW_AXES ))-1;
}

int ReadJoy(int port,int *buttons,float *axis)
{
	if( port&lt;0 || port&gt;=joy_count ) return 0;
	
	unsigned char b[32];
	int n=_glfwPlatformGetJoystickButtons( joy_id[port],b,32 ),i;
	
	*buttons=0;
	for( i=0;i&lt;n;++i ){
		if( b[i] ) *buttons|=(1&lt;&lt;i);
	}
	
	_glfwPlatformGetJoystickPos( joy_id[port],axis,16 );
	
	return 0;
}

void WriteJoy(int port,int channel,float value)
{
}

</textarea><br><br>And modified joycount demo - hit space to change joy port being tested:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' testjoy.bmx

Import Pub.FreeJoy

Strict

If Not JoyCount() RuntimeError "No joystick found!"

Graphics 640,480

Function drawprop(n$,p#,y)
	Local	w
	DrawText n$,0,y
	w=Abs(p)*256
	If p&lt;0
		DrawRect 320-w,y,w,16
	Else
		DrawRect 320,y,w,16
	EndIf
End Function		

Local t=0
Local port=0

While Not KeyHit(KEY_ESCAPE)

	Local n=JoyCount()

	If KeyHit( KEY_SPACE )
		port:+1
		If port=n port=0
	EndIf
	
	Cls

	SetColor 255,255,255
	DrawText "joycount="+n,0,0
	DrawText "JoyName("+port+")="+JoyName(port),0,20
	DrawText "JoyButtonCaps("+port+")="+Bin$(JoyButtonCaps(port)),0,40
	DrawText "JoyAxisCaps("+port+")="+Bin$(JoyAxisCaps(port)),0,60

	For Local i=0 To 31
		SetColor 255,255,255
		If JoyDown(i,port) SetColor 255,0,0
		DrawOval i*16,80,14,14
	Next
	
	SetColor 255,255,0
	drawprop "JoyX=",JoyX(port),100
	drawprop "JoyY:",JoyY(port),120
	drawprop "JoyZ:",JoyZ(port),140
	drawprop "JoyR:",JoyR(port),160
	drawprop "JoyU:",JoyU(port),180
	drawprop "JoyV:",JoyV(port),200
	drawprop "JoyHat:",JoyHat(port),220
	drawprop "JoyWheel:",JoyWheel(port),240
	
	DrawRect 0,280,t,10
	t=(t+1)&amp;511
	
	Flip	
Wend

End
</textarea> <br><br></td></tr></table><br>
<a name="1150328"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robb</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I've compiled the tests and get these results:<br><br>Socket 1 now works perfectly - the dpad corresponds to the R&amp;Z axis and the buttons match up correctly. Amazing!<br><br>Socket 2 isn't yet registered as a separate joypad in blitz - the dpad doesn't work and the buttons register as buttons 16 and over on the other pad<br><br>Great progress though, thanks! :D <br><br></td></tr></table><br>
<a name="1150384"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; Socket 2 isn't yet registered as a separate joypad in blitz - the dpad doesn't work and the buttons register as buttons 16 and over on the other pad<br><br>But that's a FAIL isn't it? SO GLFW doesn't work properly either?<br><br>Alas, that's probably as far as I can go without any actual hardware to play with. Even then, I don't really have a clue what's going on (Why does a normal hub work? Is the SNES/hub thing therefore a 'special' device type? Are there specs somewhere? Sample code?) and given that I'm FAR from an expert on low-level USB coding/drivers (which you apparently have to be just to read a freaking gamepad on the Mac!) combined with the general dearth of information out there re: getting gamepads going on the Mac, it could all just be a massive waste of time!<br><br>Anyway, I'll talk it over with skidracer (who knows far more about this stuff than I do) but right now I'm stuck. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
