<!DOCTYPE html><html lang="en" ><head ><title >No debugger in threaded mode?!</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >No debugger in threaded mode?!</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=110" >BlitzMax Module Tweaks</a>/<a href="#bottom" >No debugger in threaded mode?!</a><br><br>
<a name="1004524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> That can't be right, can it?  How are you meant to debug threaded code?<br><br><pre class=code>Global x:myType = New myType
DebugStop

Type myType
	Field a:Int
	Field b:String
	Field c:Long
End Type</pre><br>Run that and check the debugger.  In single thread mode, you can see the fields in X just fine.  In threaded mode, you can't.<br><br>This is making it virtually impossible to write threaded code.  I have an error somewhere in my code but I have no means of tracing it.  Is this how its meant to work?? <br><br></td></tr></table><br>
<a name="1004534"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats a core problem of threaded code.<br>How do you want to stop code in threaded mode?<br><br>You stop Thread X<br>But that won't interest thread Y, Z, A and B<br><br>So while you have locked X to inspect it other code continues, generating bugs that otherwise don't exist introduce new sideeffects. <br><br></td></tr></table><br>
<a name="1004543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> How do you want to stop code in threaded mode? <br></div>Well, you tell me.  It just seems senseless that you have to work without a debugger of any kind when using threads.  Surely there's a better way?  If you could still debug just the main thread, that'd be something. <br><br></td></tr></table><br>
<a name="1004548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Up to which degree this could work is something that I can't comment on, only Mark and a handfull of others that have indepth enough knowledge on the related core aspects. <br><br></td></tr></table><br>
<a name="1004551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't see why it would be a problem to lock 1 thread while the others are still running.<br>It works fine in Java to do that - of course there are two ways to halt execution there with localized breakpoints and whole program "pause" (which stops all threads in their tracks).<br><br>If the debug layer is "thread safe", then it could very well work properly.<br>However, the IDE is not designed to show multiple thread-stacks, so that would need a rewrite.<br><br>I haven't looked at what goes on in the appstub recently to see what's going on when threading. <br><br></td></tr></table><br>
<a name="1004623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Some threaded environments just pause all threads on debugstop, and step-in/out only the thread where the debugstop was executed until a 'continue' is raised. This way all variables, classes, etc are accesible in a ordered way. That usually works well unless you want to test threads sync with the debugger. <br><br></td></tr></table><br>
<a name="1004688"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a bug in mod/blitz.mod/blitz_gc_ms.c - replace the following<br><pre class=code>int bbGCValidate( void *p ){
	int r;

	BB_LOCK

	r=testMemBit( p ) ? 1 : 0;

	BB_UNLOCK
	return r;
}</pre><br>with<br><pre class=code>int bbGCValidate( void *p ){
	int r;

	BB_LOCK

	r=getBlock( p ) ? 1 : 0;

	BB_UNLOCK
	return r;
}</pre><br>and everything works the way it should. <br><br></td></tr></table><br>
<a name="1004698"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Before I try it, what exactly does that do in laymen's terms? <br><br></td></tr></table><br>
<a name="1004723"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Before I try it, what exactly does that do in laymen's terms? <br></div><br>That's the piece of code that validates whether a block of memory is tracked by the GC. The debugger (appstub.mod/debugger.stdio.bmx) uses it to check that the object reference passed to it (e.g. by the IDE) is really an object. As far as I can tell, it is only used by the debugger. The getBlock function calls testMemBit after the correct pointer arithmetic. <br><br></td></tr></table><br>
<a name="1004730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GaryV</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Before I try it, what exactly does that do in laymen's terms? <br></div>It fixes the bug you are reporting? <br><br></td></tr></table><br>
<a name="1004732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It fixes the bug you are reporting? <br></div>Oh do stop it.<br><br><div class="quote"> That's the piece of code that validates whether a block of memory is tracked by the GC. The debugger (appstub.mod/debugger.stdio.bmx) uses it to check that the object reference passed to it (e.g. by the IDE) is really an object. As far as I can tell, it is only used by the debugger. The getBlock function calls testMemBit after the correct pointer arithmetic. <br></div>Right, just modified it and it works fine now, for the main thread at least.  Should make things a hell of a lot easier.  Thanks!<br><br>Doesn't directly solve the problem of not being able to debug threads, although its possible to work around that by executing the thread function in the main thread for debugging purposes.<br><br>Either way, this is a huge help. <br><br></td></tr></table><br>
<a name="1004753"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Doesn't directly solve the problem of not being able to debug threads, although its possible to work around that by executing the thread function in the main thread for debugging purposes. <br></div><br>Ok, I haven't tested this thoroughly, but here's a very simple implementation for debugging non-main threads. It uses thread-local data and probably has way more overhead than the default debugger. Nevertheless, it seems to work fine. If one thread debug-stops, others continue and ignore any debugging.<br><br>Add this to mod/brl.mod/appstub.mod named e.g. debugger.stdio2.bmx and change the import in appstub.bmx, but do so at your own risk after backups :)<br><br><b>Edit: Old code, dont use!</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict

NoDebug

Private

?Win32
Extern "Win32"
Const SW_SHOW=5
Const SW_RESTORE=9
Function IsIconic( hwnd )
Function GetForegroundWindow()
Function SetForegroundWindow( hwnd )
Function ShowWindow( hwnd,cmdShow )
Function GetCurrentThreadId()
End Extern
?

?MacOS
Extern
Function CGDisplayIsCaptured( displayId )
End Extern
?

Extern
Global bbStringClass:Byte
Global bbArrayClass:Byte
Global bbNullObject:Byte
Global bbEmptyArray:Byte
Global bbEmptyString:Byte
Global brl_blitz_NullFunctionError:Byte Ptr
Function bbIsMainThread()="bbIsMainThread"
Function bbGCValidate:Int( mem:Int ) = "bbGCValidate"
End Extern

Function ToHex$( val )
	Local buf:Short[8]
	For Local k=7 To 0 Step -1
		Local n=(val&amp;15)+Asc("0")
		If n&gt;Asc("9") n=n+(Asc("A")-Asc("9")-1)
		buf[k]=n
		val:Shr 4
	Next
	Return String.FromShorts( buf,8 ).ToLower()
End Function

Function IsAlpha( ch )
	Return (ch&gt;=Asc("a") And ch&lt;=Asc("z")) Or (ch&gt;=Asc("A") And ch&lt;=Asc("Z"))
End Function

Function IsNumeric( ch )
	Return ch&gt;=Asc("0") And ch&lt;=Asc("9")
End Function

Function IsAlphaNumeric( ch )
	Return IsAlpha(ch) Or IsNumeric(ch)
End Function

Function IsUnderscore( ch )
	Return ch=Asc("_")
End Function

Function Ident$( tag$ Var )
	If Not tag Return ""
	If Not IsAlpha( tag[0] ) And Not IsUnderscore( tag[0] ) Return ""
	Local i=1
	While i&lt;tag.length And (IsAlphaNumeric(tag[i]) Or IsUnderscore(tag[i]))
		i:+1
	Wend
	Local id$=tag[..i]
	tag=tag[i..]
	Return id
End Function

Function TypeName$( tag$ Var )

	Local t$=tag[..1]
	tag=tag[1..]

	Select t
	Case "b"
		Return "Byte"
	Case "s"
		Return "Short"
	Case "i"
		Return "Int"
	Case "l"
		Return "Long"
	Case "f"
		Return "Float"
	Case "d"
		Return "Double"
	Case "$"
		Return "String"
	Case "z"
		Return "CString"
	Case "w"
		Return "WString"
	Case ":","?"
		Local id$=Ident( tag )
		While tag And tag[0]=Asc(".")
			tag=tag[1..]
			id=Ident( tag )
		Wend
		If Not id DebugError "Invalid object typetag"
		Return id
	Case "*"
		Return TypeName( tag )+" Ptr"
	Case "["
		While tag[..1]=","
			tag=tag[1..]
			t:+","
		Wend
		If tag[..1]&lt;&gt;"]" DebugError "Invalid array typetag"
		tag=tag[1..]
		Return TypeName( tag )+t+"]"
	Case "("
		If tag[..1]&lt;&gt;")"
			t:+TypeName( tag )
			While tag[..1]=","
				tag=tag[1..]
				t:+","+TypeName( tag )
			Wend
			If tag[..1]&lt;&gt;")" DebugError "Invalid function typetag"
		EndIf
		tag=tag[1..]
		Return TypeName( tag )+t+")"
	End Select

	DebugError "Invalid debug typetag:"+t

End Function

'int offsets into 12 byte DebugStm struct
Const DEBUGSTM_FILE=0
Const DEBUGSTM_LINE=1
Const DEBUGSTM_CHAR=2

'int offsets into 16 byte DebugDecl struct
Const DEBUGDECL_KIND=0
Const DEBUGDECL_NAME=1
Const DEBUGDECL_TYPE=2
Const DEBUGDECL_ADDR=3

'DEBUGDECL_KIND values
Const DEBUGDECLKIND_END=0
Const DEBUGDECLKIND_CONST=1
Const DEBUGDECLKIND_LOCAL=2
Const DEBUGDECLKIND_FIELD=3
Const DEBUGDECLKIND_GLOBAL=4
Const DEBUGDECLKIND_VARPARAM=5
Const DEBUGDECLKIND_TYPEMETHOD=6
Const DEBUGDECLKIND_TYPEFUNCTION=7

'int offsets into 12+n_decls*4 byte DebugScope struct
Const DEBUGSCOPE_KIND=0
Const DEBUGSCOPE_NAME=1
Const DEBUGSCOPE_DECLS=2

'DEBUGSCOPE_KIND values
Const DEBUGSCOPEKIND_FUNCTION=1
Const DEBUGSCOPEKIND_TYPE=2
Const DEBUGSCOPEKIND_LOCAL=3

Function DebugError( t$ )
	WriteStderr "Debugger Error:"+t+"~n"
	End
End Function

Function DebugStmFile$( stm:Int Ptr )
	Return String.FromCString( Byte Ptr stm[DEBUGSTM_FILE] )
End Function

Function DebugStmLine( stm:Int Ptr )
	Return stm[DEBUGSTM_LINE]
End Function

Function DebugStmChar( stm:Int Ptr )
	Return stm[DEBUGSTM_CHAR]
End Function

Function DebugDeclKind$( decl:Int Ptr )
	Select decl[DEBUGDECL_KIND]
	Case DEBUGDECLKIND_CONST Return "Const"
	Case DEBUGDECLKIND_LOCAL Return "Local"
	Case DEBUGDECLKIND_FIELD Return "Field"
	Case DEBUGDECLKIND_GLOBAL Return "Global"
	Case DEBUGDECLKIND_VARPARAM Return "Local"
	End Select
	DebugError "Invalid decl kind"
End Function

Function DebugDeclName$( decl:Int Ptr )
	Return String.FromCString( Byte Ptr decl[DEBUGDECL_NAME] )
End Function

Function DebugDeclType$( decl:Int Ptr )
	Local t$=String.FromCString( Byte Ptr decl[DEBUGDECL_TYPE] )
	Local ty$=TypeName( t )
	Return ty
End Function

Function DebugDeclSize( decl:Int Ptr )

	Local tag=(Byte Ptr Ptr(decl+DEBUGDECL_TYPE))[0][0]

	Select tag
	Case Asc("b") Return 1
	Case Asc("s") Return 2
	Case Asc("l") Return 8
	Case Asc("d") Return 8
	End Select
	
	Return 4

End Function

Function DebugEscapeString$( s$ )
	s=s.Replace( "~~","~~~~")
	s=s.Replace( "~0","~~0" )
	s=s.Replace( "~t","~~t" )
	s=s.Replace( "~n","~~n" )
	s=s.Replace( "~r","~~r" )
	s=s.Replace( "~q","~~q" )
	Return "~q"+s+"~q"
End Function

Function DebugDeclValue$( decl:Int Ptr,inst:Byte Ptr )
	If decl[DEBUGDECL_KIND]=DEBUGDECLKIND_CONST
		Local p:Byte Ptr=Byte Ptr decl[DEBUGDECL_ADDR]
		Return DebugEscapeString(String.FromShorts( Short Ptr(p+12),(Int Ptr (p+8))[0] ))
	EndIf

	Local p:Byte Ptr
	Select decl[DEBUGDECL_KIND]
	Case DEBUGDECLKIND_GLOBAL
		p=Byte Ptr decl[DEBUGDECL_ADDR]
	Case DEBUGDECLKIND_LOCAL,DEBUGDECLKIND_FIELD
		p=Byte Ptr (inst+decl[DEBUGDECL_ADDR])
	Case DEBUGDECLKIND_VARPARAM
		p=Byte Ptr (inst+decl[DEBUGDECL_ADDR])
		p=Byte Ptr ( (Int Ptr p)[0] )
	Default
		DebugError "Invalid decl kind"
	End Select
	
	Local tag=(Byte Ptr Ptr(decl+DEBUGDECL_TYPE))[0][0]
	
	Select tag
	Case Asc("b")
		Return String.FromInt( (Byte Ptr p)[0] )
	Case Asc("s")
		Return String.FromInt( (Short Ptr p)[0] )
	Case Asc("i")
		Return String.FromInt( (Int Ptr p)[0] )
	Case Asc("l")
		Return String.FromLong( (Long Ptr p)[0] )
	Case Asc("f")
		Return String.FromFloat( (Float Ptr p)[0] )
	Case Asc("d")
		Return String.FromDouble( (Double Ptr p)[0] )
	Case Asc("$")
		p=(Byte Ptr Ptr p)[0]
		Local sz=Int Ptr(p+8)[0]
		Local s$=String.FromShorts( Short Ptr(p+12),sz )
		Return DebugEscapeString( s )
	Case Asc("z")
		p=(Byte Ptr Ptr p)[0]
		If Not p Return "Null"
		Local s$=String.FromCString( p )
		Return DebugEscapeString( s )
	Case Asc("w")
		p=(Byte Ptr Ptr p)[0]
		If Not p Return "Null"
		Local s$=String.FromWString( Short Ptr p )
		Return DebugEscapeString( s )
	Case Asc("*"),Asc("?")
		Return "$"+ToHex( (Int Ptr p)[0] )
	Case Asc("(")
		p=(Byte Ptr Ptr p)[0]
		If p=brl_blitz_NullFunctionError Return "Null"
	Case Asc(":")
		p=(Byte Ptr Ptr p)[0]
		If p=Varptr bbNullObject Return "Null"
		If p=Varptr bbEmptyArray Return "Null[]"
		If p=Varptr bbEmptyString Return "Null$"
	Case Asc("[")
		p=(Byte Ptr Ptr p)[0]
		If Not p Return "Null"
		If Not (Int Ptr (p+20))[0] Return "Null"
	Default
		DebugError "Invalid decl typetag:"+Chr(tag)
	End Select
	
	Return "$"+ToHex( Int p )

End Function

Function DebugScopeKind$( scope:Int Ptr )
	Select scope[DEBUGSCOPE_KIND]
	Case DEBUGSCOPEKIND_FUNCTION Return "Function"
	Case DEBUGSCOPEKIND_TYPE Return "Type"
	Case DEBUGSCOPEKIND_LOCAL Return "Local"
	End Select
	DebugError "Invalid scope kind"
End Function

Function DebugScopeName$( scope:Int Ptr )
	Return String.FromCString( Byte Ptr scope[DEBUGSCOPE_NAME] )
End Function

Function DebugScopeDecls:Int Ptr[]( scope:Int Ptr )
	Local n,p:Int Ptr=scope+DEBUGSCOPE_DECLS
	While p[n]&lt;&gt;DEBUGDECLKIND_END
		n:+1
	Wend
	Local decls:Int Ptr[n]
	For Local i=0 Until n
		decls[i]=p+i*4
	Next
	Return decls
End Function

Function DebugObjectScope:Int Ptr( inst:Byte Ptr )
	Local clas:Int Ptr Ptr=(Int Ptr Ptr Ptr inst)[0]
	Return clas[2]
End Function

Extern
Global bbOnDebugStop()
Global bbOnDebugLog( message$ )
Global bbOnDebugEnterStm( stm:Int Ptr )
Global bbOnDebugEnterScope( scope:Int Ptr,inst:Byte Ptr )
Global bbOnDebugLeaveScope()
Global bbOnDebugPushExState()
Global bbOnDebugPopExState()
Global bbOnDebugUnhandledEx( ex:Object )
End Extern

bbOnDebugStop=OnDebugStop
bbOnDebugLog=OnDebugLog
bbOnDebugEnterStm=OnDebugEnterStm
bbOnDebugEnterScope=OnDebugEnterScope
bbOnDebugLeaveScope=OnDebugLeaveScope
bbOnDebugPushExState=OnDebugPushExState
bbOnDebugPopExState=OnDebugPopExState
bbOnDebugUnhandledEx=OnDebugUnhandledEx

?Win32
Global _ideHwnd=GetForegroundWindow();
Global _appHwnd
?

'********** Debugger code here **********

Const MODE_RUN=0
Const MODE_STEP=1
Const MODE_STEPIN=2
Const MODE_STEPOUT=3

Type TScope
	Field scope:Int Ptr,inst:Byte Ptr,stm:Int Ptr
End Type

Type TExState
	Field scopeStackTop
End Type

Type TDbgState
	Field mode,debugLevel,funcLevel
	Field currentScope:TScope=New TScope
	Field scopeStack:TScope[],scopeStackTop
	Field exStateStack:TExState[],exStateStackTop
End Type

?threaded
Extern
Function threads_AllocThreadData()
Function threads_SetThreadData( id,data:Object )
Function threads_GetThreadData:TDbgState( id )
End Extern
?

Function GetDbgState:TDbgState()
?threaded
	Global dbgStateId:Int=threads_AllocThreadData()
	Local dbgState:TDbgState=threads_GetThreadData( dbgStateId )
	If Not dbgState
		dbgState = New TDbgState
		threads_SetThreadData( dbgStateId,dbgState )
	End If
	Return dbgState
?Not threaded
	Global dbgState:TDbgState=New TDbgState
	Return dbgState
?
End Function

'Global mode,debugLevel,funcLevel
'Global currentScope:TScope=New TScope
'Global scopeStack:TScope[],scopeStackTop
'Global exStateStack:TExState[],exStateStackTop

Function ReadDebug$()
	Return ReadStdin()
End Function

Function WriteDebug( t$ )
	WriteStderr "~~&gt;"+t
End Function

Function DumpScope( scope:Int Ptr,inst:Byte Ptr )

	Local decl:Int Ptr=scope+DEBUGSCOPE_DECLS
	
	Local kind$=DebugScopeKind( scope ),name$=DebugScopeName( scope )
	
	If Not name name="&lt;local&gt;"
	
	WriteDebug kind+" "+name+"~n"
	
	While decl[DEBUGDECL_KIND]&lt;&gt;DEBUGDECLKIND_END
	
		Select decl[DEBUGDECL_KIND]
		Case DEBUGDECLKIND_TYPEMETHOD,DEBUGDECLKIND_TYPEFUNCTION
			decl:+4
			Continue
		End Select

		Local kind$=DebugDeclKind( decl )
		Local name$=DebugDeclname( decl )
		Local tipe$=DebugDeclType( decl )
		Local value$=DebugDeclValue( decl,inst )
		
		WriteDebug kind+" "+name+":"+tipe+"="+value+"~n"

		decl:+4	
	Wend
End Function

Function DumpClassScope( clas:Int Ptr,inst:Byte Ptr )

	Local supa:Int Ptr=Int Ptr clas[0]
	
	If Not supa Return
	
	DumpClassScope supa,inst
	
	DumpScope Int Ptr clas[2],inst

End Function

Function DumpObject( inst:Byte Ptr,index )

	Local clas:Int Ptr=(Int Ptr Ptr inst)[0]
	
	If clas=Int Ptr Varptr bbStringClass

		WriteDebug DebugEscapeString(String.FromShorts( Short Ptr(inst+12),(Int Ptr (inst+8))[0] ))+"~n"

		Return

	Else If clas=Int Ptr Varptr bbArrayClass
	
		Local length=(Int Ptr (inst+20))[0]
		
		If Not length Return
		
		Local decl:Int[3]
		decl[0]=DEBUGDECLKIND_LOCAL
		decl[2]=(Int Ptr (inst+8))[0]
		
		Local sz=DebugDeclSize( decl )
		
		Local p:Byte Ptr=Byte Ptr(20+(Int Ptr (inst+12))[0]*4)

		For Local i=1 To 10

			If index&gt;=length Exit
			
			decl[3]=Int(p+index*sz)
		
			Local value$=DebugDeclValue( decl,inst )
			
			WriteDebug "["+index+"]="+value+"~n"
			
			index:+1
			
		Next
		
		If index&lt;length

			WriteDebug "...=$"+ToHex(Int inst)+":"+index+"~n"
	
		EndIf
		
	Else
			
		If Not clas[0]
			WriteDebug "Object~n"
			Return
		EndIf
	
		DumpClassScope clas,inst
	
	EndIf
	
End Function

Function DumpScopeStack()
	Local dbgState:TDbgState = GetDbgState()
	For Local i=Max(dbgState.scopeStackTop-100,0) Until dbgState.scopeStackTop
		Local t:TScope=dbgState.scopeStack[i]
		Local stm:Int Ptr=t.stm
		If Not stm Continue
		WriteDebug "@"+DebugStmFile(stm)+"&lt;"+DebugStmLine(stm)+","+DebugStmChar(stm)+"&gt;~n"
		DumpScope t.scope,t.inst
	Next
End Function

Function UpdateDebug( msg$ )
	Global indebug
	If indebug Return
	indebug=True
	
	Local dbgState:TDbgState = GetDbgState()
	
?Win32
	_appHwnd=GetForegroundWindow();
	'SetForegroundWindow( _ideHwnd );
?
?MacOs
	'fullscreen debug too hard in MacOS!
	If CGDisplayIsCaptured( 0 )
		WriteStdout msg
		End
	EndIf
?
	WriteDebug msg
	Repeat
		WriteDebug "~n"
		Local line$=ReadDebug()

		Select line[..1].ToLower()
		Case "r"
			dbgState.mode=MODE_RUN
			Exit
		Case "s"
			dbgState.mode=MODE_STEP
			dbgState.debugLevel=dbgState.funcLevel
			Exit
		Case "e"
			dbgState.mode=MODE_STEPIN
			Exit
		Case "l"
			dbgState.mode=MODE_STEPOUT
			dbgState.debugLevel=dbgState.scopeStackTop-1
			Exit
		Case "t"
			WriteDebug "StackTrace{~n"
			DumpScopeStack
			WriteDebug "}~n"
		Case "d"
			Local t$=line[1..].Trim()
			Local index
			Local i=t.Find(":")
			If i&lt;&gt;-1
				index=Int( t[i+1..] )
				t=t[..i]
			EndIf
			If t[..1]="$" t=t[1..].Trim()
			If t[..2].ToLower()="0x" t=t[2..].Trim()
			Local pointer = Int( "$"+t )
			If Not (pointer And bbGCValidate(pointer)) Then Continue
			Local inst:Int Ptr=Int Ptr pointer
			
			Local cmd$="ObjectDump@"+ToHex( Int inst )
			If i&lt;&gt;-1 cmd:+":"+index
			WriteDebug cmd$+"{~n"

			DumpObject inst,index
			WriteDebug "}~n"
		Case "h"
			WriteDebug "T - Stack trace~n"
			WriteDebug "R - Run from here~n"
			WriteDebug "S - Step through source code~n"
			WriteDebug "E - Step into function call~n"
			WriteDebug "L - Leave function or local block~n"
			WriteDebug "Q - Quit~n"
			WriteDebug "H - This text~n"
			WriteDebug "Dxxxxxxxx - Dump object at hex address xxxxxxxx~n"
		Case "q"
			End
		End Select
	Forever

?Win32
	If _appHwnd And _appHwnd&lt;&gt;_ideHwnd 
		If IsIconic(_apphwnd)
			ShowWindow _appHwnd,SW_RESTORE
		Else
			ShowWindow _appHwnd,SW_SHOW
		EndIf		
		_apphwnd=0
	EndIf
?
	indebug=False
End Function

Function OnDebugStop()
?Threaded
'	If Not bbIsMainThread() Return
?
	UpdateDebug "DebugStop:~n"
End Function

Function OnDebugLog( message$ )
?Threaded
'	If Not bbIsMainThread() Return
?
	WriteStdout "DebugLog:"+message+"~n"
End Function

Function OnDebugEnterStm( stm:Int Ptr )
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	dbgState.currentScope.stm=stm
	
	Select dbgState.mode
	Case MODE_RUN
		Return
	Case MODE_STEP
		If dbgState.funcLevel&gt;dbgState.debugLevel 
			Return
		EndIf
	Case MODE_STEPOUT
		If dbgState.scopeStackTop&gt;dbgState.debugLevel
			Return
		EndIf
	End Select
	
	UpdateDebug "Debug:~n"
End Function

Function OnDebugEnterScope( scope:Int Ptr,inst:Byte Ptr )
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If dbgState.scopeStackTop=dbgState.scopeStack.length 
		dbgState.scopeStack=dbgState.scopeStack[..dbgState.scopeStackTop * 2 + 32]
		For Local i=dbgState.scopeStackTop Until dbgState.scopeStack.length
			dbgState.scopeStack[i]=New TScope
		Next
	EndIf
	
	dbgState.currentScope=dbgState.scopeStack[dbgState.scopeStackTop]

	dbgState.currentScope.scope=scope
	dbgState.currentScope.inst=inst

	dbgState.scopeStackTop:+1

	If dbgState.currentScope.scope[DEBUGSCOPE_KIND]=DEBUGSCOPEKIND_FUNCTION dbgState.funcLevel:+1

	GCResume	
End Function

Function OnDebugLeaveScope()
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If Not dbgState.scopeStackTop DebugError "scope stack underflow"

	If dbgState.currentScope.scope[DEBUGSCOPE_KIND]=DEBUGSCOPEKIND_FUNCTION dbgState.funcLevel:-1
	
	dbgState.scopeStackTop:-1

	If dbgState.scopeStackTop
		dbgState.currentScope=dbgState.scopeStack[dbgState.scopeStackTop-1]
	Else
		dbgState.currentScope=New TScope
	EndIf

	GCResume	
End Function

Function OnDebugPushExState()
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If dbgState.exStateStackTop=dbgState.exStateStack.length 
		dbgState.exStateStack=dbgState.exStateStack[..dbgState.exStateStackTop * 2 + 32]
		For Local i=dbgState.exStateStackTop Until dbgState.exStateStack.length
			dbgState.exStateStack[i]=New TExState
		Next
	EndIf
	
	dbgState.exStateStack[dbgState.exStateStackTop].scopeStackTop=dbgState.scopeStackTop
	
	dbgState.exStateStackTop:+1

	GCResume	
End Function

Function OnDebugPopExState()
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If Not dbgState.exStateStackTop DebugError "exception stack underflow"

	dbgState.exStateStackTop:-1

	dbgState.scopeStackTop=dbgState.exStateStack[dbgState.exStateStackTop].scopeStackTop
	
	If dbgState.scopeStackTop
		dbgState.currentScope=dbgState.scopeStack[dbgState.scopeStackTop-1]
	Else
		dbgState.currentScope=New TScope
	EndIf

	GCResume	
End Function

Function OnDebugUnhandledEx( ex:Object )
?Threaded
'	If Not bbIsMainThread() Return
?
	GCSuspend
	
	UpdateDebug "Unhandled Exception:"+ex.ToString()+"~n"

	GCResume	
End Function</textarea><br><br>And a test program; default debugger doesn't stop, the above modified version should:<br><pre class=code>SuperStrict

Framework BRL.StandardIO
Import BRL.Threads

Function ThreadFunc:Object(data:Object)
	DebugStop
End Function

TThread.Create(ThreadFunc,Null).Wait</pre> <br><br></td></tr></table><br>
<a name="1006334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm on the verge of knocking this threading lark on the head.<br><br>The code above works fine but when I compile my own game I get the dreaded "EXCEPTION_ACCESS_VIOLATION" and I have no idea why.  My game doesn't even begin to run.  Yet if I use an unmodified appstub, it compiles and runs OK.<br><br>I'm using several third-party mods (MaxMod, TimelineFX, Chaos.Desktopextension) so I don't know if the problem is with one of those, or something else. <br><br></td></tr></table><br>
<a name="1006338"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The code above works fine but when I compile my own game I get the dreaded "EXCEPTION_ACCESS_VIOLATION" and I have no idea why. My game doesn't even begin to run. Yet if I use an unmodified appstub, it compiles and runs OK. <br></div><br>Do you mean the code in <a href="/posts.php?topic=88462#1004753" target="_blank">#12</a>? As I wrote, I didn't really test it much - it's probably to blame for any problems. I'll have to test it with something more complicated. <br><br></td></tr></table><br>
<a name="1006339"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I should have at least tested digesteroids, which didn't work... With this it seems to work:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict

NoDebug

Private

?Win32
Extern "Win32"
Const SW_SHOW=5
Const SW_RESTORE=9
Function IsIconic( hwnd )
Function GetForegroundWindow()
Function SetForegroundWindow( hwnd )
Function ShowWindow( hwnd,cmdShow )
Function GetCurrentThreadId()
End Extern
?

?MacOS
Extern
Function CGDisplayIsCaptured( displayId )
End Extern
?

Extern
Global bbStringClass:Byte
Global bbArrayClass:Byte
Global bbNullObject:Byte
Global bbEmptyArray:Byte
Global bbEmptyString:Byte
Global brl_blitz_NullFunctionError:Byte Ptr
Function bbIsMainThread()="bbIsMainThread"
Function bbGCValidate:Int( mem:Int ) = "bbGCValidate"
End Extern

Function ToHex$( val )
	Local buf:Short[8]
	For Local k=7 To 0 Step -1
		Local n=(val&amp;15)+Asc("0")
		If n&gt;Asc("9") n=n+(Asc("A")-Asc("9")-1)
		buf[k]=n
		val:Shr 4
	Next
	Return String.FromShorts( buf,8 ).ToLower()
End Function

Function IsAlpha( ch )
	Return (ch&gt;=Asc("a") And ch&lt;=Asc("z")) Or (ch&gt;=Asc("A") And ch&lt;=Asc("Z"))
End Function

Function IsNumeric( ch )
	Return ch&gt;=Asc("0") And ch&lt;=Asc("9")
End Function

Function IsAlphaNumeric( ch )
	Return IsAlpha(ch) Or IsNumeric(ch)
End Function

Function IsUnderscore( ch )
	Return ch=Asc("_")
End Function

Function Ident$( tag$ Var )
	If Not tag Return ""
	If Not IsAlpha( tag[0] ) And Not IsUnderscore( tag[0] ) Return ""
	Local i=1
	While i&lt;tag.length And (IsAlphaNumeric(tag[i]) Or IsUnderscore(tag[i]))
		i:+1
	Wend
	Local id$=tag[..i]
	tag=tag[i..]
	Return id
End Function

Function TypeName$( tag$ Var )

	Local t$=tag[..1]
	tag=tag[1..]

	Select t
	Case "b"
		Return "Byte"
	Case "s"
		Return "Short"
	Case "i"
		Return "Int"
	Case "l"
		Return "Long"
	Case "f"
		Return "Float"
	Case "d"
		Return "Double"
	Case "$"
		Return "String"
	Case "z"
		Return "CString"
	Case "w"
		Return "WString"
	Case ":","?"
		Local id$=Ident( tag )
		While tag And tag[0]=Asc(".")
			tag=tag[1..]
			id=Ident( tag )
		Wend
		If Not id DebugError "Invalid object typetag"
		Return id
	Case "*"
		Return TypeName( tag )+" Ptr"
	Case "["
		While tag[..1]=","
			tag=tag[1..]
			t:+","
		Wend
		If tag[..1]&lt;&gt;"]" DebugError "Invalid array typetag"
		tag=tag[1..]
		Return TypeName( tag )+t+"]"
	Case "("
		If tag[..1]&lt;&gt;")"
			t:+TypeName( tag )
			While tag[..1]=","
				tag=tag[1..]
				t:+","+TypeName( tag )
			Wend
			If tag[..1]&lt;&gt;")" DebugError "Invalid function typetag"
		EndIf
		tag=tag[1..]
		Return TypeName( tag )+t+")"
	End Select

	DebugError "Invalid debug typetag:"+t

End Function

'int offsets into 12 byte DebugStm struct
Const DEBUGSTM_FILE=0
Const DEBUGSTM_LINE=1
Const DEBUGSTM_CHAR=2

'int offsets into 16 byte DebugDecl struct
Const DEBUGDECL_KIND=0
Const DEBUGDECL_NAME=1
Const DEBUGDECL_TYPE=2
Const DEBUGDECL_ADDR=3

'DEBUGDECL_KIND values
Const DEBUGDECLKIND_END=0
Const DEBUGDECLKIND_CONST=1
Const DEBUGDECLKIND_LOCAL=2
Const DEBUGDECLKIND_FIELD=3
Const DEBUGDECLKIND_GLOBAL=4
Const DEBUGDECLKIND_VARPARAM=5
Const DEBUGDECLKIND_TYPEMETHOD=6
Const DEBUGDECLKIND_TYPEFUNCTION=7

'int offsets into 12+n_decls*4 byte DebugScope struct
Const DEBUGSCOPE_KIND=0
Const DEBUGSCOPE_NAME=1
Const DEBUGSCOPE_DECLS=2

'DEBUGSCOPE_KIND values
Const DEBUGSCOPEKIND_FUNCTION=1
Const DEBUGSCOPEKIND_TYPE=2
Const DEBUGSCOPEKIND_LOCAL=3

Function DebugError( t$ )
	WriteStderr "Debugger Error:"+t+"~n"
	End
End Function

Function DebugStmFile$( stm:Int Ptr )
	Return String.FromCString( Byte Ptr stm[DEBUGSTM_FILE] )
End Function

Function DebugStmLine( stm:Int Ptr )
	Return stm[DEBUGSTM_LINE]
End Function

Function DebugStmChar( stm:Int Ptr )
	Return stm[DEBUGSTM_CHAR]
End Function

Function DebugDeclKind$( decl:Int Ptr )
	Select decl[DEBUGDECL_KIND]
	Case DEBUGDECLKIND_CONST Return "Const"
	Case DEBUGDECLKIND_LOCAL Return "Local"
	Case DEBUGDECLKIND_FIELD Return "Field"
	Case DEBUGDECLKIND_GLOBAL Return "Global"
	Case DEBUGDECLKIND_VARPARAM Return "Local"
	End Select
	DebugError "Invalid decl kind"
End Function

Function DebugDeclName$( decl:Int Ptr )
	Return String.FromCString( Byte Ptr decl[DEBUGDECL_NAME] )
End Function

Function DebugDeclType$( decl:Int Ptr )
	Local t$=String.FromCString( Byte Ptr decl[DEBUGDECL_TYPE] )
	Local ty$=TypeName( t )
	Return ty
End Function

Function DebugDeclSize( decl:Int Ptr )

	Local tag=(Byte Ptr Ptr(decl+DEBUGDECL_TYPE))[0][0]

	Select tag
	Case Asc("b") Return 1
	Case Asc("s") Return 2
	Case Asc("l") Return 8
	Case Asc("d") Return 8
	End Select
	
	Return 4

End Function

Function DebugEscapeString$( s$ )
	s=s.Replace( "~~","~~~~")
	s=s.Replace( "~0","~~0" )
	s=s.Replace( "~t","~~t" )
	s=s.Replace( "~n","~~n" )
	s=s.Replace( "~r","~~r" )
	s=s.Replace( "~q","~~q" )
	Return "~q"+s+"~q"
End Function

Function DebugDeclValue$( decl:Int Ptr,inst:Byte Ptr )
	If decl[DEBUGDECL_KIND]=DEBUGDECLKIND_CONST
		Local p:Byte Ptr=Byte Ptr decl[DEBUGDECL_ADDR]
		Return DebugEscapeString(String.FromShorts( Short Ptr(p+12),(Int Ptr (p+8))[0] ))
	EndIf

	Local p:Byte Ptr
	Select decl[DEBUGDECL_KIND]
	Case DEBUGDECLKIND_GLOBAL
		p=Byte Ptr decl[DEBUGDECL_ADDR]
	Case DEBUGDECLKIND_LOCAL,DEBUGDECLKIND_FIELD
		p=Byte Ptr (inst+decl[DEBUGDECL_ADDR])
	Case DEBUGDECLKIND_VARPARAM
		p=Byte Ptr (inst+decl[DEBUGDECL_ADDR])
		p=Byte Ptr ( (Int Ptr p)[0] )
	Default
		DebugError "Invalid decl kind"
	End Select
	
	Local tag=(Byte Ptr Ptr(decl+DEBUGDECL_TYPE))[0][0]
	
	Select tag
	Case Asc("b")
		Return String.FromInt( (Byte Ptr p)[0] )
	Case Asc("s")
		Return String.FromInt( (Short Ptr p)[0] )
	Case Asc("i")
		Return String.FromInt( (Int Ptr p)[0] )
	Case Asc("l")
		Return String.FromLong( (Long Ptr p)[0] )
	Case Asc("f")
		Return String.FromFloat( (Float Ptr p)[0] )
	Case Asc("d")
		Return String.FromDouble( (Double Ptr p)[0] )
	Case Asc("$")
		p=(Byte Ptr Ptr p)[0]
		Local sz=Int Ptr(p+8)[0]
		Local s$=String.FromShorts( Short Ptr(p+12),sz )
		Return DebugEscapeString( s )
	Case Asc("z")
		p=(Byte Ptr Ptr p)[0]
		If Not p Return "Null"
		Local s$=String.FromCString( p )
		Return DebugEscapeString( s )
	Case Asc("w")
		p=(Byte Ptr Ptr p)[0]
		If Not p Return "Null"
		Local s$=String.FromWString( Short Ptr p )
		Return DebugEscapeString( s )
	Case Asc("*"),Asc("?")
		Return "$"+ToHex( (Int Ptr p)[0] )
	Case Asc("(")
		p=(Byte Ptr Ptr p)[0]
		If p=brl_blitz_NullFunctionError Return "Null"
	Case Asc(":")
		p=(Byte Ptr Ptr p)[0]
		If p=Varptr bbNullObject Return "Null"
		If p=Varptr bbEmptyArray Return "Null[]"
		If p=Varptr bbEmptyString Return "Null$"
	Case Asc("[")
		p=(Byte Ptr Ptr p)[0]
		If Not p Return "Null"
		If Not (Int Ptr (p+20))[0] Return "Null"
	Default
		DebugError "Invalid decl typetag:"+Chr(tag)
	End Select
	
	Return "$"+ToHex( Int p )

End Function

Function DebugScopeKind$( scope:Int Ptr )
	Select scope[DEBUGSCOPE_KIND]
	Case DEBUGSCOPEKIND_FUNCTION Return "Function"
	Case DEBUGSCOPEKIND_TYPE Return "Type"
	Case DEBUGSCOPEKIND_LOCAL Return "Local"
	End Select
	DebugError "Invalid scope kind"
End Function

Function DebugScopeName$( scope:Int Ptr )
	Return String.FromCString( Byte Ptr scope[DEBUGSCOPE_NAME] )
End Function

Function DebugScopeDecls:Int Ptr[]( scope:Int Ptr )
	Local n,p:Int Ptr=scope+DEBUGSCOPE_DECLS
	While p[n]&lt;&gt;DEBUGDECLKIND_END
		n:+1
	Wend
	Local decls:Int Ptr[n]
	For Local i=0 Until n
		decls[i]=p+i*4
	Next
	Return decls
End Function

Function DebugObjectScope:Int Ptr( inst:Byte Ptr )
	Local clas:Int Ptr Ptr=(Int Ptr Ptr Ptr inst)[0]
	Return clas[2]
End Function

Extern
Global bbOnDebugStop()
Global bbOnDebugLog( message$ )
Global bbOnDebugEnterStm( stm:Int Ptr )
Global bbOnDebugEnterScope( scope:Int Ptr,inst:Byte Ptr )
Global bbOnDebugLeaveScope()
Global bbOnDebugPushExState()
Global bbOnDebugPopExState()
Global bbOnDebugUnhandledEx( ex:Object )
End Extern

bbOnDebugStop=OnDebugStop
bbOnDebugLog=OnDebugLog
bbOnDebugEnterStm=OnDebugEnterStm
bbOnDebugEnterScope=OnDebugEnterScope
bbOnDebugLeaveScope=OnDebugLeaveScope
bbOnDebugPushExState=OnDebugPushExState
bbOnDebugPopExState=OnDebugPopExState
bbOnDebugUnhandledEx=OnDebugUnhandledEx

?Win32
Global _ideHwnd=GetForegroundWindow();
Global _appHwnd
?

'********** Debugger code here **********

Const MODE_RUN=0
Const MODE_STEP=1
Const MODE_STEPIN=2
Const MODE_STEPOUT=3

Type TScope
	Field scope:Int Ptr,inst:Byte Ptr,stm:Int Ptr
End Type

Type TExState
	Field scopeStackTop
End Type

Type TDbgState
	Field mode,debugLevel,funcLevel
	Field currentScope:TScope=New TScope
	Field scopeStack:TScope[],scopeStackTop
	Field exStateStack:TExState[],exStateStackTop
End Type

?threaded
Extern
Function threads_AllocThreadData()
Function threads_SetThreadData( id,data:Object )
Function threads_GetThreadData:TDbgState( id )
End Extern
?

Function GetDbgState:TDbgState()
	Global dbgStateMain:TDbgState=New TDbgState
?threaded
	If bbIsMainThread() Return dbgStateMain
	Global dbgStateId:Int=threads_AllocThreadData()
	Local dbgState:TDbgState=threads_GetThreadData( dbgStateId )
	If Not dbgState
		dbgState = New TDbgState
		threads_SetThreadData( dbgStateId,dbgState )
	End If
	Return dbgState
?Not threaded
	Return dbgStateMain
?
End Function

'Global mode,debugLevel,funcLevel
'Global currentScope:TScope=New TScope
'Global scopeStack:TScope[],scopeStackTop
'Global exStateStack:TExState[],exStateStackTop

Function ReadDebug$()
	Return ReadStdin()
End Function

Function WriteDebug( t$ )
	WriteStderr "~~&gt;"+t
End Function

Function DumpScope( scope:Int Ptr,inst:Byte Ptr )

	Local decl:Int Ptr=scope+DEBUGSCOPE_DECLS
	
	Local kind$=DebugScopeKind( scope ),name$=DebugScopeName( scope )
	
	If Not name name="&lt;local&gt;"
	
	WriteDebug kind+" "+name+"~n"
	
	While decl[DEBUGDECL_KIND]&lt;&gt;DEBUGDECLKIND_END
	
		Select decl[DEBUGDECL_KIND]
		Case DEBUGDECLKIND_TYPEMETHOD,DEBUGDECLKIND_TYPEFUNCTION
			decl:+4
			Continue
		End Select

		Local kind$=DebugDeclKind( decl )
		Local name$=DebugDeclname( decl )
		Local tipe$=DebugDeclType( decl )
		Local value$=DebugDeclValue( decl,inst )
		
		WriteDebug kind+" "+name+":"+tipe+"="+value+"~n"

		decl:+4	
	Wend
End Function

Function DumpClassScope( clas:Int Ptr,inst:Byte Ptr )

	Local supa:Int Ptr=Int Ptr clas[0]
	
	If Not supa Return
	
	DumpClassScope supa,inst
	
	DumpScope Int Ptr clas[2],inst

End Function

Function DumpObject( inst:Byte Ptr,index )

	Local clas:Int Ptr=(Int Ptr Ptr inst)[0]
	
	If clas=Int Ptr Varptr bbStringClass

		WriteDebug DebugEscapeString(String.FromShorts( Short Ptr(inst+12),(Int Ptr (inst+8))[0] ))+"~n"

		Return

	Else If clas=Int Ptr Varptr bbArrayClass
	
		Local length=(Int Ptr (inst+20))[0]
		
		If Not length Return
		
		Local decl:Int[3]
		decl[0]=DEBUGDECLKIND_LOCAL
		decl[2]=(Int Ptr (inst+8))[0]
		
		Local sz=DebugDeclSize( decl )
		
		Local p:Byte Ptr=Byte Ptr(20+(Int Ptr (inst+12))[0]*4)

		For Local i=1 To 10

			If index&gt;=length Exit
			
			decl[3]=Int(p+index*sz)
		
			Local value$=DebugDeclValue( decl,inst )
			
			WriteDebug "["+index+"]="+value+"~n"
			
			index:+1
			
		Next
		
		If index&lt;length

			WriteDebug "...=$"+ToHex(Int inst)+":"+index+"~n"
	
		EndIf
		
	Else
			
		If Not clas[0]
			WriteDebug "Object~n"
			Return
		EndIf
	
		DumpClassScope clas,inst
	
	EndIf
	
End Function

Function DumpScopeStack()
	Local dbgState:TDbgState = GetDbgState()
	For Local i=Max(dbgState.scopeStackTop-100,0) Until dbgState.scopeStackTop
		Local t:TScope=dbgState.scopeStack[i]
		Local stm:Int Ptr=t.stm
		If Not stm Continue
		WriteDebug "@"+DebugStmFile(stm)+"&lt;"+DebugStmLine(stm)+","+DebugStmChar(stm)+"&gt;~n"
		DumpScope t.scope,t.inst
	Next
End Function

Function UpdateDebug( msg$ )
	Global indebug
	If indebug Return
	indebug=True
	
	Local dbgState:TDbgState = GetDbgState()
	
?Win32
	_appHwnd=GetForegroundWindow();
	'SetForegroundWindow( _ideHwnd );
?
?MacOs
	'fullscreen debug too hard in MacOS!
	If CGDisplayIsCaptured( 0 )
		WriteStdout msg
		End
	EndIf
?
	WriteDebug msg
	Repeat
		WriteDebug "~n"
		Local line$=ReadDebug()

		Select line[..1].ToLower()
		Case "r"
			dbgState.mode=MODE_RUN
			Exit
		Case "s"
			dbgState.mode=MODE_STEP
			dbgState.debugLevel=dbgState.funcLevel
			Exit
		Case "e"
			dbgState.mode=MODE_STEPIN
			Exit
		Case "l"
			dbgState.mode=MODE_STEPOUT
			dbgState.debugLevel=dbgState.scopeStackTop-1
			Exit
		Case "t"
			WriteDebug "StackTrace{~n"
			DumpScopeStack
			WriteDebug "}~n"
		Case "d"
			Local t$=line[1..].Trim()
			Local index
			Local i=t.Find(":")
			If i&lt;&gt;-1
				index=Int( t[i+1..] )
				t=t[..i]
			EndIf
			If t[..1]="$" t=t[1..].Trim()
			If t[..2].ToLower()="0x" t=t[2..].Trim()
			Local pointer = Int( "$"+t )
			If Not (pointer And bbGCValidate(pointer)) Then Continue
			Local inst:Int Ptr=Int Ptr pointer
			
			Local cmd$="ObjectDump@"+ToHex( Int inst )
			If i&lt;&gt;-1 cmd:+":"+index
			WriteDebug cmd$+"{~n"

			DumpObject inst,index
			WriteDebug "}~n"
		Case "h"
			WriteDebug "T - Stack trace~n"
			WriteDebug "R - Run from here~n"
			WriteDebug "S - Step through source code~n"
			WriteDebug "E - Step into function call~n"
			WriteDebug "L - Leave function or local block~n"
			WriteDebug "Q - Quit~n"
			WriteDebug "H - This text~n"
			WriteDebug "Dxxxxxxxx - Dump object at hex address xxxxxxxx~n"
		Case "q"
			End
		End Select
	Forever

?Win32
	If _appHwnd And _appHwnd&lt;&gt;_ideHwnd 
		If IsIconic(_apphwnd)
			ShowWindow _appHwnd,SW_RESTORE
		Else
			ShowWindow _appHwnd,SW_SHOW
		EndIf		
		_apphwnd=0
	EndIf
?
	indebug=False
End Function

Function OnDebugStop()
?Threaded
'	If Not bbIsMainThread() Return
?
	UpdateDebug "DebugStop:~n"
End Function

Function OnDebugLog( message$ )
?Threaded
'	If Not bbIsMainThread() Return
?
	WriteStdout "DebugLog:"+message+"~n"
End Function

Function OnDebugEnterStm( stm:Int Ptr )
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	dbgState.currentScope.stm=stm
	
	Select dbgState.mode
	Case MODE_RUN
		Return
	Case MODE_STEP
		If dbgState.funcLevel&gt;dbgState.debugLevel 
			Return
		EndIf
	Case MODE_STEPOUT
		If dbgState.scopeStackTop&gt;dbgState.debugLevel
			Return
		EndIf
	End Select
	
	UpdateDebug "Debug:~n"
End Function

Function OnDebugEnterScope( scope:Int Ptr,inst:Byte Ptr )
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If dbgState.scopeStackTop=dbgState.scopeStack.length 
		dbgState.scopeStack=dbgState.scopeStack[..dbgState.scopeStackTop * 2 + 32]
		For Local i=dbgState.scopeStackTop Until dbgState.scopeStack.length
			dbgState.scopeStack[i]=New TScope
		Next
	EndIf
	
	dbgState.currentScope=dbgState.scopeStack[dbgState.scopeStackTop]

	dbgState.currentScope.scope=scope
	dbgState.currentScope.inst=inst

	dbgState.scopeStackTop:+1

	If dbgState.currentScope.scope[DEBUGSCOPE_KIND]=DEBUGSCOPEKIND_FUNCTION dbgState.funcLevel:+1

	GCResume	
End Function

Function OnDebugLeaveScope()
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If Not dbgState.scopeStackTop DebugError "scope stack underflow"

	If dbgState.currentScope.scope[DEBUGSCOPE_KIND]=DEBUGSCOPEKIND_FUNCTION dbgState.funcLevel:-1
	
	dbgState.scopeStackTop:-1

	If dbgState.scopeStackTop
		dbgState.currentScope=dbgState.scopeStack[dbgState.scopeStackTop-1]
	Else
		dbgState.currentScope=New TScope
	EndIf

	GCResume	
End Function

Function OnDebugPushExState()
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If dbgState.exStateStackTop=dbgState.exStateStack.length 
		dbgState.exStateStack=dbgState.exStateStack[..dbgState.exStateStackTop * 2 + 32]
		For Local i=dbgState.exStateStackTop Until dbgState.exStateStack.length
			dbgState.exStateStack[i]=New TExState
		Next
	EndIf
	
	dbgState.exStateStack[dbgState.exStateStackTop].scopeStackTop=dbgState.scopeStackTop
	
	dbgState.exStateStackTop:+1

	GCResume	
End Function

Function OnDebugPopExState()
?Threaded
'	If Not bbIsMainThread() Return
?
	Local dbgState:TDbgState = GetDbgState()
	GCSuspend

	If Not dbgState.exStateStackTop DebugError "exception stack underflow"

	dbgState.exStateStackTop:-1

	dbgState.scopeStackTop=dbgState.exStateStack[dbgState.exStateStackTop].scopeStackTop
	
	If dbgState.scopeStackTop
		dbgState.currentScope=dbgState.scopeStack[dbgState.scopeStackTop-1]
	Else
		dbgState.currentScope=New TScope
	EndIf

	GCResume	
End Function

Function OnDebugUnhandledEx( ex:Object )
?Threaded
'	If Not bbIsMainThread() Return
?
	GCSuspend
	
	UpdateDebug "Unhandled Exception:"+ex.ToString()+"~n"

	GCResume	
End Function</textarea><br><br>The problem seems to be thread-locals not working early in module init. I suppose this version will also fail to work if any modules launch threads during init... <br><br></td></tr></table><br>
<a name="1006351"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks!  Seems to be working perfectly now.<br><br>This should be officially added to Blitzmax - being able to debug threads is invaluable. <br><br></td></tr></table><br>
<a name="1101824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jtfrench</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi folks,<br><br>We're working a pretty massive multithreaded MiniB3D project, and we're getting some pretty strange crashes involving the Blitz sound modules and thread collisions. When debugging though, it seems the debugger is a bit inconsistent.<br><br>I searched the forums and this thread sounded pretty relevant to the issues we're going through....we're using BlitzMax 1.41...are these changes still relevant? has the multi-threaded debugger support changed since? If not, we may jump into the deep end and try out this module hacking stuff.<br><br>thanks,<br>jason <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
