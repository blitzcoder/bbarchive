<!DOCTYPE html><html lang="en" ><head ><title >Game Animatory v0.05</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Game Animatory v0.05</h1><a href="forums.php" >BlitzPlus Forums</a>/<a href="topics.php?forum=81" >BlitzPlus Programming</a>/<a href="#bottom" >Game Animatory v0.05</a><br><br>
<a name="985682"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gladclef - Ben B</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anouncing the first beta test of my new game animation program!<br>Look, I know it sucks right now, but I'll be improving it some more in the future.<br><br><img src="http://www.polian-studios.com/public_downloads/animator/bigpic.JPG"><br><br>If you guys wouldn't mind helping me test it for bugs (just post them if you find any), that would be greatly appreciated.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;------NOTES------
;this program is intended for the publication of game sequence animations with less-than basic paint functionality
;all global variables and lables and types are capitalized, all locals and functions are lowercase
;more paint tools to come
;-----------------
;[Block]------RELEASE NOTES------
;current version: 0.13
;===V0.5===
;will be released on Blitzbasic.com for debugging
;will include the following:
;10 paint functions (circles, lines, rectangles, pencil, flood fill, zooming capability, changing mouse colors, grabbing mouse colors from the current frame, copy, and paste)
;a menu
;an animated preview bar
;a drawing window with a border, the current frame, and the ability to draw the previous frame behind and next frame in front
;undo/redo functionality
;several hotkeys
;loading/saving program options
;ability to add/delete frames
;the ability to import/export .bmp imagestrips
;auto load last on startup
;the ability to change the size of the current image
;!help file for shortcuts
;===V1.0===
;will be released after debugging has completed (1 week or bugs are fixed, whichever comes later)
;===V1.5===
;until it is debugged, the new version will remain &lt; 2.0
;it will include new functionality, such as:
;a toolbar for the paint functions
;reverse animation
;select boxes
;sideboard image holder (sideboard clipboard)
;command line support for opening images from outside the program
;color exchange
;import and export of .png and .jpg formats
;previews of current projects in action
;rotation and resizing ability
;color swapping within the image
;===V2.0===
;will be released after debugging has completed (1 week or bugs are fixed, whicher comes later)
;===V2++===
;layers
;will be released with:
;other shape selections
;faster alphas
;objects
;more import/export formats
;export to gif + others movies
;text
;filters (fading, cracking, water distortion, halos (post processing effects))
;special effects (particles, paths)
;[End]-------------------------
;[Block]------BUG LOG------
;1) As of the moment, I can't find any bugs other than a minor problem with the "pencil" function.
;It draws blocky for a while, and then it works fine for the entire period of opperation after that. Huh.
;Then again, it draws kinda sketchy anyways. Largely due to the resizing opperation, methinks.
;2) Has problems at SCALE = 1
;Sometimes the program will dramatically slow down when the scale is set to 1x.
;Haven't been able to figure out what's causing the slowdown.
;[End]-------------------
;[Block]------WINDOW VARIABLES------
Global WIDTH = GadgetWidth(Desktop()) ;normal window
Global HEIGHT = GadgetHeight(Desktop())
Global WIN1 = CreateWindow("New File: Game_Animatory v0.13",WIDTH/4,HEIGHT/4,WIDTH/2,minimum(HEIGHT/2,308))
Global CAN1 = CreateCanvas(0,0,ClientWidth(WIN1),ClientHeight(WIN1)-116,WIN1)
Global CAN2 ;for use in resize_maincanvases
Global PREVIEW_CANVAS = CreateCanvas(0,ClientHeight(WIN1)-116,ClientWidth(WIN1),116,WIN1)
SetMinWindowSize WIN1,500,308
SetGadgetLayout CAN1,1,1,1,1
SetGadgetLayout PREVIEW_CANVAS,1,1,0,1
;[End]----------------------------
;[Block]------GLOBAL VARIABLES------
Global ALPHA = 1 ;if 1, then images are alpha'd before drawn (specifically the preview images)
Dim    ANTS(1,1) ;used in paintfunctions_fill (flood fill function) to keep track of tainted pixels
Global BORDER_IMAGE = CreateImage(104,104) ;used to draw a border around the image in the editor
Global BUFFER = CanvasBuffer(CAN1) ;holds the handle of the current buffer
Global C1 = getcolorback(255,255,255) ;sets the default left mouse color to white (see the paint functions)
Global C2 = getcolorback(0,0,0) ;sets the default right mouse color to black
Global CHANGED = 0 ;counts the number of changes made to the image since creation/loading ;used in create_new_file
;Global COL_LEFT = -1 ;the foreground drawing color, -16777216=black, -1=white ;replaced by C1 and C2, for simplicity
;Global COL_RIGHT = -6777216 ;the background drawing color, -16777216=black, -1=white ;replaced by C1 and C2, for simplicity
;Global DIRECTORY$ = CurrentDir$() ;the directory of the current project ;to be used with version 1.5+ for projects
Global DODRAW$ = "BOTH" ;the screen (BOTH/CAN1/PREVIEW) is redrawn only if DODRAW is true
;Global DRAWN = 0 ;whether to draw the next frame, alpha lite, in front of the current frame ;was going to be used with setwintransparenz
;Global DRAWP = 0 ;whether to draw the previous frame, alpha lite, behind the current frame ;was going to be used with setwintransparenz
Global EYECANDY = 1 ;stuff that makes the program look pretty (including shift_preview)
Global FILENAME$ = "New File" ;the default file name for a new file
Global FILLED = 0 ;whether or not the circle and draw functions are filled (see painfunctions_circle and paintfunctions_rectangle)
Global FOCUSX = 50 ;the focus point of the image, for when it doesn't fit in the drawing window
Global FOCUSY = 50 ;the focus point of the image, for when it doesn't fit in the drawing window
Global FONT = LoadFont("COURIER",12)
Global FONT_BIG = LoadFont("COURIER",102)
Global FRAME = 0 ;the current frame
Global FRAMES = 1 ;the total number of frames
Global FUNC$ = "SCALE" ;the current function used for drawing (can be CIRCLE, FILL, LINE, PENCIL, RECTANGLE, SCALE)
;Const  GWL_EXSTYLE = -20 ;for the setwintransparenz function
Global ID$ ;a temporary handle that holds the eventid for the main loop
Dim    IMAGE(3) ;the handle of the main images
Global LT_MD3 = 0 ;records the last time that the middle mouse button was pressed (see userinput_checkfunction_mouse3)
Global MXOFFSET = 0 ;the offset of the mousex() (the difference between the x coordinate of the window and the x coordinate of the window
;Global MYDIRECTORY$ = CurrentDir$() ;the directory in which is located the program ;to be used with the command line later
Global MYOFFSET = 0 ;the offset of the mousey()
Global MXPREVIOUS = 0 ;the previous recorded x location of the mouse
Global MYPREVIOUS = 0 ;the previous recorded y location of the mouse
Global MZ = 0 ;the previous mouse z position
Global NAME$ = "New File" ;the title of the current project/file
Global SCALE# = 3.0 ;for zooming in/out ;a direct translation (2.0 is twice as big &lt;&gt; 200 (for percent))
Global PREVIEW = 0 ;whether or not to draw a preview (the next frame in front of the current one)
Global POSTVIEW = 0 ;whether or not to draw a postview (the previous frame behind the current one)
Dim    TEMP_ARRAY(1) ;for temporarily holding values of other arrays ;see addframe, removeframe
Global TIMER = 0 ;delays the program until millisecs() &gt; TIMER
Dim    UR_STACK%(16) ;used to remember which undo/redo goes with which frame
;Const  VK_C = $43 ;used to tell if the c key is down in the userinput_checkfunction_keyboard function
Global WINX = GadgetX(WIN1) ;to be used as a x refference point in check_windowmoved
Global WINY = GadgetY(WIN1) ;to be used as a y refference point in check_windowmoved
Global WINW = GadgetWidth(WIN1) ;to be used as a width refference point in check_windowmoved
Global WINH = GadgetHeight(WIN1) ;to be used as a height refference point in check_windowmoved
Global WTEXT$ = "SCALE  " ;the current window text (see the set_windowtext_right/set_windowtext_left functions)
;[End]----------------------------
;[Block]------MENU ITEMS------
;CreateMenu					("NAME", ID, parent)
Global MMENU1 = WindowMenu(WIN1)
Global MFILE = CreateMenu	("File", 1, MMENU1)
	CreateMenu					("New", 11, MFILE) ;meant to be used for project files later
	CreateMenu					("Open", 12, MFILE)
	CreateMenu					("Save", 13, MFILE)
	CreateMenu					("Save As", 14, MFILE)
	CreateMenu					("", 0, MFILE)
	CreateMenu					("Exit", 15, MFILE)
Global MFRAME = CreateMenu	("Frame", 2, MMENU1)
	CreateMenu					("Previous", 21, MFRAME)
	CreateMenu					("Jump To...", 22, MFRAME)
	CreateMenu					("Next", 23, MFRAME)
	CreateMenu					("Add Frame", 24, MFRAME)
	CreateMenu					("Remove Frame", 25, MFRAME)
Global MIMAGE = CreateMenu	("Image", 3, MMENU1)
	CreateMenu					("COPY", 31, MIMAGE)
	CreateMenu					("Paste", 32, MIMAGE)
	CreateMenu					("Set Size", 33, MIMAGE)
	Global MPRE = CreateMenu	("Draw Preview", 34, MIMAGE)
	Global MPOST = CreateMenu	("Draw Postview", 35, MIMAGE)
Global MPF = CreateMenu		("Paint Functions", 4, MMENU1) ;(menu) paint functions
	Global MPFCIRC = CreateMenu	("Circle", 41, MPF)
	Global MPFFILL = CreateMenu	("Flood Fill", 42, MPF)
	Global MPFLINE = CreateMenu	("Line", 43, MPF)
	Global MPFPENC = CreateMenu	("Pencil", 44, MPF)
	Global MPFRECT = CreateMenu	("Rectangle", 45, MPF)
	Global MPFSCAL = CreateMenu	("Scale", 46, MPF)
	CreateMenu					("Eye Dropper", 47, MPF)
	CreateMenu					("Choose Mouse Colors", 48, MPF)
	Global MPFOPT = CreateMenu	("Options", 49, MPF)
		Global MFILL = CreateMenu	("Fill", 490, MPFOPT)
Global MOPT = CreateMenu 	("Options", 5, MMENU1) ;(menu) options, for global options
	Global MALPHA = CreateMenu	("Alpha", 51, MOPT)
	Global MEYECANDY = CreateMenu("Eye Candy", 52, MOPT)
Global MHELP = CreateMenu	("Help", 6, MMENU1)
	CreateMenu					("Shortcuts", 61, MHELP)
	CreateMenu					("About", 62, MHELP)
loadoptions() ;loads global options from a file
menu_update() ;checks and disables certain menus
;[End]----------------------
;[Block]------TYPES------
Type ANT ;used for the fill function, behavior of the function resembles ants, see paintfunctions_fill
	Field x
	Field y
End Type
Type IREDO ;Image redo ;for holding the redo image handles
	Field id%
	Field h ;image handle
End Type
Type ITEM ;used to display the neat disapearing text
	Field name$
	Field x#
	Field y#
	Field life_start#
	Field life_end#
	Field image%
End Type
Type IUNDO ;Image undo ;for holding the undo image handles
	Field id%
	Field h ;image handle
End Type
;[End]-----------------
;[Block]------PRE_START------
calculate_offsets() ;for MXOFFSET and MYOFFSET
If 1 = 0 ;creates images usefull for testing/debugging
	IMAGE(0) = CreateImage(100,100) ;the image for the first frame
	SeedRnd(MilliSecs())
	SetBuffer(ImageBuffer(IMAGE(0)))
	For TIMER = 0 To ImageHeight(IMAGE(0))
		Color Rand(255),Rand(255),Rand(255)
		Line 0,TIMER,ImageWidth(IMAGE(0)),TIMER
	Next
	For tempx=1 To FRAMES-1
		IMAGE(tempx) = CreateImage(100,100) ;the image for the first frame
		SetBuffer(ImageBuffer(IMAGE(tempx)))
		For TIMER = 0 To ImageHeight(IMAGE(tempx))
			Color Rand(255),Rand(255),Rand(255)
			Line 0,TIMER,ImageWidth(IMAGE(tempx)),TIMER
		Next
	Next
	SetBuffer(BUFFER)
EndIf
If (load_lastloaded) = 0
	Dim IMAGE(1)
	IMAGE(0) = CreateImage(100,100)
	FRAME = 0
	FRAMES = 1
EndIf
calculate_borderimage() ;for the BORDER_IMAGE
;resize_images(1) ;fast/slow
;[End]---------------------
;------------------------
;------MAIN PROGRAM------
;------------------------
;While KeyDown(1)=0
Repeat
	DebugLog "main"
	time(50) ;delays the program so as not to eat up processor power, including gathering user input
	check_keyboard() ;checks if there is a keyboard button being pressed
	check_mouse() ;checks to see if the user has moved the mouse/pushed a mouse button
	check_windowmoved() ;if the window has been moved or resized, several processes must be called (including update_overlay())
	If MZ &lt;&gt; MouseZ() Then userinput_checkfunction_mousemoved_z() ;checks the functions for when the user tries scrolling the mouse middle button
	If DODRAW="BOTH" Or DODRAW="CAN1" Then draw() ;DODRAW is set to either "PREVIEW" or "", depending
	If DODRAW="BOTH" Or DODRAW="PREVIEW" Then draw_preview() ;DODRAW is set to either "CAN1" or "", depending
	For ITEM.ITEM=Each ITEM
		DebugLog ITEM\name
		draw_item(ITEM\name)
	Next
	;ID is set in the time Function
	If ID = $803 ;big red button
		If CHANGED = 0
			Exit
		Else
			If Confirm ("Would you like to save before exiting?", 1) = 0 Then Exit Else save:Exit
		EndIf
	EndIf
	If ID = $1001 Or ID = 8197 ;menu
		If userinput_checkfunction_menu()=1 ;which menu? (1 is exit)
			If CHANGED = 0
				Exit
			Else
				If Confirm ("Would you like to save before exiting?", 1) = 0 Then Exit Else save:Exit
			EndIf
		EndIf
	EndIf
;Wend
Forever
finish()
;------------------------
;------------------------
;------------------------
;:------FUNCTIONS------
Function addframe(phrame) ;adds a frame to the list of frames before frame "phrame", shifting all the other frames over one
	DebugLog "addframe"
	Local t
	Dim TEMP_ARRAY(FRAMES+1)
	;store the frames coming before said "phrame"
	For t = 0 To phrame
		TEMP_ARRAY(t) = IMAGE(t) ;hold the image handles while the size of the image array is reassigned
	Next
	;make room for teh new frames
	If phrame &lt; FRAMES-1 ;if said "phrame" isn't the last frame
		For t = phrame+1 To FRAMES-1
			TEMP_ARRAY(t+1) = IMAGE(t)
		Next
	EndIf
	;finally, add the new image
	TEMP_ARRAY(phrame+1) = CreateImage(ImageWidth(TEMP_ARRAY(phrame)), ImageHeight(TEMP_ARRAY(phrame)))
	;shift image handles back over to our dear friend IMAGE()
	Dim IMAGE(FRAMES+1)
	For t = 0 To FRAMES
		IMAGE(t) = TEMP_ARRAY(t)
	Next
	FRAMES = FRAMES + 1
	Dim TEMP_ARRAY(1)
	DODRAW = "BOTH"
	;finally, check and set the undo/redo stuff to the correct frames
	For t = 0 To 15
		If UR_STACK(t) &gt; phrame
			UR_STACK(t) = UR_STACK(t) + 1
		EndIf
	Next
End Function
Function alphaimage(image1,shade#,percent#) ;alphas an image to white (shade=100) or black (shade=0) by a percent value and returns the distorted image
	DebugLog "alphaimage"
	Local tempx,tempy,tempcolor
	If ALPHA = 1
		LockBuffer ImageBuffer(image1)
		For tempx=0 To ImageWidth(image1)-1
			For tempy=0 To ImageHeight(image1)-1
				tempcolor=ReadPixelFast(tempx,tempy,ImageBuffer(image1))
				WritePixelFast tempx,tempy, getcolorback( getred(tempcolor)+(shade*255.0/100.0-getred(tempcolor))*percent/100.0 , getgreen(tempcolor)+(shade*255.0/100.0-getgreen(tempcolor))*percent/100.0 , getblue(tempcolor)+(shade*255.0/100.0-getblue(tempcolor))*percent/100.0 ), ImageBuffer(image1)
			Next
		Next
		UnlockBuffer ImageBuffer(image1)
		Return image1
	Else
		Return image1
	EndIf
End Function
Function calculate_offsets() ;finds the differences between the window and canvas coordinates
	DebugLog "calculate_offsets"
	Local a,b,px,py,timer
	a=MouseX(CAN1)
	b=MouseY(CAN1)
	px=MouseX()
	py=MouseY()
	timer=MilliSecs()+100
	While MouseX(CAN1)=a And MouseY(CAN1)=b ;guarantees that the mouse hits the canvas
		If timer&lt;MilliSecs() Then Exit
		If MouseX(CAN1) = a Then MoveMouse(Rand(ClientWidth(Desktop())),MouseY())
		If MouseY(CAN1) = b Then MoveMouse(MouseX(),Rand(ClientHeight(Desktop())))
	Wend
	a = MouseX()
	While MouseX(CAN1)&gt;0 ;
		MoveMouse(MouseX()-1,MouseY())
		If MouseX()&lt;=0 Then Exit ;the &lt; is just for safety
		If MouseX() = a Then Exit Else a = MouseX() ;again, just safety
	Wend
	b = MouseY()
	While MouseY(CAN1)&gt;0
		MoveMouse(MouseX(),MouseY()-1)
		If MouseY()&lt;=0 Then Exit ;the &lt; is just for safety
		If MouseY() = b Then Exit Else b = MouseY() ;again, just safety
	Wend
	MXOFFSET=minimum(MouseX()-GadgetX(WIN1))
	MYOFFSET=minimum(MouseY()-GadgetY(WIN1))
	If MXOFFSET = 0 Then MXOFFSET = 4 ;these values were gained from a successful run
	If MYOFFSET = 0 Then MYOFFSET = 50 ;these values were gained from a successful run
	MoveMouse(px,py)
End Function
Function calculate_borderimage() ;draws the BORDER_IMAGE, which creates a border so that it's easy for the user to tell what it is they're editing
	DebugLog "calculate_borderimage"
	Local b,g,r,t,x#,y#
	If ImageWidth(BORDER_IMAGE) &lt;&gt; ImageWidth(IMAGE(FRAME))+4 Or ImageHeight(BORDER_IMAGE) &lt;&gt; ImageHeight(IMAGE(FRAME))+4
		TFormFilter 0
		ResizeImage BORDER_IMAGE, ImageWidth(IMAGE(FRAME))+4, ImageHeight(IMAGE(FRAME))+4
	EndIf
	;draw an outline, just in case the code following for some reason fails
	SetBuffer ImageBuffer(BORDER_IMAGE)
	Cls
	Color 255,255,255
	Line 2, 0, ImageWidth(BORDER_IMAGE)-3, 0
	Line 2, ImageHeight(BORDER_IMAGE)-1, ImageWidth(BORDER_IMAGE)-3, ImageHeight(BORDER_IMAGE)-1
	Line 0, 2, 0, ImageHeight(BORDER_IMAGE)-3
	Line ImageWidth(BORDER_IMAGE)-1, 2, ImageWidth(BORDER_IMAGE)-1, ImageHeight(BORDER_IMAGE)-3
	Plot 1, 1
	Plot ImageWidth(BORDER_IMAGE)-2, 1
	Plot ImageWidth(BORDER_IMAGE)-2, ImageHeight(BORDER_IMAGE)-2
	Plot 1, ImageHeight(BORDER_IMAGE)-2
	Plot ImageWidth(BORDER_IMAGE)/2, 1
	Plot ImageWidth(BORDER_IMAGE)/2, ImageHeight(BORDER_IMAGE)-2
	Plot 1, ImageHeight(BORDER_IMAGE)/2
	Plot ImageWidth(BORDER_IMAGE)-2, ImageHeight(BORDER_IMAGE)/2
	SetBuffer BUFFER
	;now really draw the border image
;	LockBuffer ImageBuffer(IMAGE(FRAME))
;	LockBuffer ImageBuffer(BORDER_IMAGE)
;	For x = 0 To 1
;		If x = 1 Then x = ImageWidth(IMAGE(FRAME))-1:If x = 0 Then Exit
;		For y = 0 To ImageHeight(IMAGE(FRAME))-1
;			t = ReadPixelFast(x, y, ImageBuffer(IMAGE(FRAME)))
;			r = getred(t)
;			g = getgreen(t)
;			b = getblue(t)
;	;		If r&lt;100 Or r&gt;155 Then r = 255-r Else r = r+100
;	;		If g&lt;100 Or g&gt;155 Then g = 255-g Else g = g+100
;	;		If b&lt;100 Or b&gt;155 Then b = 255-b Else b = b+100
;			r = 255-r
;			g = 255-g
;			b = 255-b
;	;		t = getcolorback(r, g, b)
;			t = getcolorback(255, 255, 255)
;	;		WritePixelFast x+3*Ceil(x/ImageWidth(IMAGE(FRAME))), y+1, t, ImageBuffer(BORDER_IMAGE)
;	;		WritePixelFast x+3*Ceil(x/ImageWidth(IMAGE(FRAME)))+1, y+1, t, ImageBuffer(BORDER_IMAGE)
;			WritePixelFast x+4*Ceil(x/ImageWidth(IMAGE(FRAME))), y+2, t, ImageBuffer(BORDER_IMAGE)
;		Next
;	Next
;	For x = 0 To ImageWidth(IMAGE(FRAME))-1
;		For y = 0 To 1
;			If y = 1 Then y = ImageHeight(IMAGE(FRAME))-1:If y = 0 Then Exit
;			t = ReadPixelFast(x, y, ImageBuffer(IMAGE(FRAME)))
;			r = getred(t)
;			g = getgreen(t)
;			b = getblue(t)
;	;		If r&lt;100 Or r&gt;155 Then r = 255-r Else r = r+100
;	;		If g&lt;100 Or g&gt;155 Then g = 255-g Else g = g+100
;	;		If b&lt;100 Or b&gt;155 Then b = 255-b Else b = b+100
;			r = 255-r
;			g = 255-g
;			b = 255-b
;	;		t = getcolorback(r, g, b)
;			t = getcolorback(255, 255, 255)
;	;		WritePixelFast x+1, y+2*Ceil(y/ImageHeight(IMAGE(FRAME))), t, ImageBuffer(BORDER_IMAGE)
;			WritePixelFast x+2, y+4*Ceil(y/ImageHeight(IMAGE(FRAME))), t, ImageBuffer(BORDER_IMAGE)
;		Next
;	Next
;	t = getcolorback(255,255,255)
;	For x = 0 To 1
;		For y = 0 To 1
;			WritePixelFast x*ImageWidth(BORDER_IMAGE)+1-3*x, y*ImageHeight(BORDER_IMAGE)+1-3*y, t, ImageBuffer(BORDER_IMAGE)
;		Next
;	Next
;	WritePixelFast 1, ImageHeight(BORDER_IMAGE)/2, t, ImageBuffer(BORDER_IMAGE)
;	WritePixelFast ImageWidth(BORDER_IMAGE)-2, ImageHeight(BORDER_IMAGE)/2, t, ImageBuffer(BORDER_IMAGE)
;	WritePixelFast ImageWidth(BORDER_IMAGE)/2, 1, t, ImageBuffer(BORDER_IMAGE)
;	WritePixelFast ImageWidth(BORDER_IMAGE)/2, ImageHeight(BORDER_IMAGE)-2, t, ImageBuffer(BORDER_IMAGE)
;	UnlockBuffer ImageBuffer(IMAGE(FRAME))
;	UnlockBuffer ImageBuffer(BORDER_IMAGE)
End Function
Function changefunc(F$ = "") ;changes the current function
	If F&lt;&gt;""
		FUNC = F
	Else
		Select FUNC
			Case "CIRCLE"
				FUNC = "FILL"
			Case "FILL"
				FUNC = "LINE"
			Case "LINE"
				FUNC = "PENCIL"
			Case "PENCIL"
				FUNC = "RECTANGLE"
			Case "RECTANGLE"
				FUNC = "SCALE"
			Case "SCALE"
				FUNC = "CIRCLE"
		End Select
	EndIf
	create_item FUNC
End Function
Function changefunc_initiate_shift() ;changes the function based on what key is presseed next (must be the first letter of the function name)
	While KeyDown(15) = 1 ;tab key
		If KeyDown(46) = 1 ;C key
			changefunc "CIRCLE"
			Exit
		EndIf
		If KeyDown(33) = 1 ;F key
			changefunc "FILL"
			Exit
		EndIf
		If KeyDown(38) = 1 ;L key
			changefunc "LINE"
			Exit
		EndIf
		If KeyDown(25) = 1 ;P Key
			changefunc "PENCIL"
			Exit
		EndIf
		If KeyDown(19) = 1 ;R Key
			changefunc "RECTANGLE"
			Exit
		EndIf
		If KeyDown(31) = 1 ;S Key
			changefunc "SCALE"
			Exit
		EndIf
	Wend
	While KeyDown(15)+KeyDown(19)+KeyDown(25)+KeyDown(31)+KeyDown(33)+KeyDown(38)+KeyDown(46) &gt; 0
;		If KeyDown(15) = 1 Then killitems():create_item "Press Tab":DODRAW = "CAN1" ;tab key
;		If KeyDown(46) = 1 Then killitems():create_item "Press C":DODRAW = "CAN1";C key
;		If KeyDown(38) = 1 Then killitems():create_item "Press L":DODRAW = "CAN1";L key
;		If KeyDown(25) = 1 Then killitems():create_item "Press P":DODRAW = "CAN1";P Key
;		If KeyDown(19) = 1 Then killitems():create_item "Press R":DODRAW = "CAN1";R Key
;		If KeyDown(31) = 1 Then killitems():create_item "Press S":DODRAW = "CAN1";S Key
		time 30
	Wend
End Function
Function check_keyboard() ;checks if there is a response from the keyboard
	Local tempx
	For tempx = 1 To 237
		If KeyDown(tempx) = 1 Then userinput_checkfunction_keyboard tempx
	Next
End Function
Function check_mouse() ;checks to see if the user has moved the mouse/pushed a mouse button
	DebugLog "check_mouse"
	If MouseDown(1)=1
		userinput_checkfunction_mouse1()
	EndIf
	If MouseDown(2)=1
		userinput_checkfunction_mouse2()
	EndIf
	If MouseDown(3)=1
		userinput_checkfunction_mouse3()
	EndIf
	If MouseX()&lt;&gt;MXPREVIOUS Or MouseY()&lt;&gt;MYPREVIOUS
		userinput_checkfunction_mousemoved()
		MXPREVIOUS = MouseX()
		MYPREVIOUS = MouseY()
	EndIf
	While MouseDown(1)=1 time(50) Wend
	While MouseDown(2)=1 time(50) Wend
End Function
Function check_windowmoved() ;checks if the main (WIN1) window has either been moved or resized
	DebugLog "checkwindowmoved"
	;if it has, then the contained functions must be called
	If  (WINX&lt;&gt;GadgetX(WIN1))  Or  (WINY&lt;&gt;GadgetY(WIN1))  Or  (WINW&lt;&gt;ClientWidth(WIN1))  Or  (WINH&lt;&gt;ClientHeight(WIN1))
		;update the variables
		WINX=GadgetX(WIN1):WINY=GadgetY(WIN1):WINW=minimum(ClientWidth(WIN1),1):WINH=minimum(ClientHeight(WIN1),1)
		;--------------------
		;call the functions
		If  (WINW&lt;&gt;GadgetWidth(WIN1))  Or  (WINH&lt;&gt;GadgetHeight(WIN1)) Then resize_maincanvases(WINW,WINH) ;called because there indeed two main canvases (CAN1 and PREVIEW_CANVAS)
		;------------------
		;call the draw function from the main program
		DODRAW="BOTH"
	EndIf
End Function
Function choosecolor_eyedropper(md) ;choose the mouse color based on the color of the pixel that the mouse is highlighting
	If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
		If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
			x = getx()
			y = gety()
			If md = 1 ;the left mouse button has been pressed
				C1 = ReadPixel(x, y, ImageBuffer(IMAGE(FRAME)))
				Return 1
			EndIf
			If md = 2 ;the right mouse button has been pressed
				C2 = ReadPixel(x, y, ImageBuffer(IMAGE(FRAME)))
				Return 1
			EndIf
		EndIf
	EndIf
	Return 0
End Function
Function choosecolor_pallet(md) ;chooses the mosue color by useing the built in pallet ;mouse down (which mouse button)
	Local t
	If md = 1
		t = RequestColor(getred(C1), getgreen(C1), getblue(C1))
	EndIf
	If md = 2
		t = RequestColor(getred(C2), getgreen(C2), getblue(C2))
	EndIf
	If t = 1
		If md = 1
			C1 = getcolorback(RequestedRed(), RequestedGreen(), RequestedBlue())
		EndIf
		If md = 2
			C2 = getcolorback(RequestedRed(), RequestedGreen(), RequestedBlue())
		EndIf
	EndIf
End Function
Function choosecolor_pallet_initiate_ctrlkey() ;initiates the choosecolor_pallet function using the c key, meant to be compiled
	While MouseDown(1) + MouseDown(2) = 0 time 50 Wend
	If MouseDown(1) = 1 Then choosecolor_pallet (1)
	If MouseDown(2) = 1 Then choosecolor_pallet (2)
	If KeyDown(29) = 1 Or KeyDown(157) = 1 &gt; 0 ;ctrl keys
		killitems
		create_item "Press Ctrl Keys"
		While KeyDown(29) + KeyDown(157) &gt; 0 time 30 Wend
	EndIf
	If MouseDown(1) + MouseDown(2) &gt; 0
		killitems
		create_item "Press Mouse"
		While MouseDown(1) + MouseDown(2) &gt; 0 time 30 Wend
	EndIf
	If KeyDown(29) = 1 Or KeyDown(157) = 1 &gt; 0 ;ctrl keys
		killitems
		create_item "Press Ctrl Keys"
		While KeyDown(29) + KeyDown(157) &gt; 0 time 30 Wend
	EndIf
	If DODRAW = "" Then DODRAW = "CAN1"
	If DODRAW = "PREVIEW" Then DODRAW = "BOTH"
End Function
Function choosecolor_pick(md) ;choose the mouse color based on the mouse position ;mouse down (which mouse button)
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				x = getx()
				y = gety()
				If md = 1
					C1 = ReadPixel(x, y, ImageBuffer(IMAGE(FRAME)))
				EndIf
				If md = 2
					C2 = ReadPixel(x, y, ImageBuffer(IMAGE(FRAME)))
				EndIf
			EndIf
		EndIf
	EndIf
End Function
Function CopyImageToClipboard(himage)
 ;Copy a given Blitz3D image to the clipboard
 ;From "Copying a DIB to the clipboard", by John Simmons
 ;(http://www.codeproject.com)

 Local width,height,sizeBits,sizeInfo,sizeDIB,btmp,x,y,offset,hDIB,pbmi

 width=ImageWidth(himage)
 height=ImageHeight(himage)

 ;calculate bits, DWORD-aligned scanline (Width * BitCount) * Height
 sizeBits=((width*24+31)/32*4)*height
 sizeInfo=40 ;sizeof(BITMAPINFOHEADER)
 sizeDIB=sizeInfo+sizeBits ;total size

 btmp=CreateBank(sizeDIB) ;bank to store DIB

 ;calculate DWORD-aligned offset of bits for proper alignment
 ;we'll use biSize to store each pixel, we can fill it in after
 LockBuffer(ImageBuffer(himage))
 For y=0 To height-1
  offset=((width*24+31)/32*4)*y+sizeInfo ;start of next scanline
  For x=0 To width-1
   PokeInt btmp,0,ReadPixelFast(x,height-1-y,ImageBuffer(himage)) ;biSize
   PokeByte btmp,offset+(x*3),PeekByte(btmp,0) ;blue
   PokeByte btmp,offset+(x*3)+1,PeekByte(btmp,1) ;green
   PokeByte btmp,offset+(x*3)+2,PeekByte(btmp,2) ;red
  Next
 Next
 UnlockBuffer(ImageBuffer(himage))

 ;fill in the info header for our 24-bit DIB
 PokeInt btmp,0,sizeInfo ;biSize
 PokeInt btmp,4,width ;biWidth
 PokeInt btmp,8,height ;biHeight
 PokeShort btmp,12,1 ;biPlanes, must be 1
 PokeShort btmp,14,24 ;biBitCount
 PokeInt btmp,16,0 ;biCompression, RGB=0/RLE8=1/RLE4=2/BITFIELDS=3
 PokeInt btmp,20,sizeBits ;biSizeImage, zeros here mean "default"
 PokeInt btmp,24,0 ;biXPelsPerMeter
 PokeInt btmp,28,0 ;biYPelsPerMeter
 PokeInt btmp,32,0 ;biClrUsed
 PokeInt btmp,36,0 ;biClrImportant

 ;alloc memory block to store our DIB
 hDIB=Api_GlobalAlloc(66,sizeDIB) ;GHND=66, MOVEABLE=2|ZEROINIT=64

 If Not hDIB ;major bummer if we couldn't get memory block
  FreeBank btmp
  Return False ;fail code
 EndIf

 pbmi=Api_GlobalLock(hDIB) ;lock memory and get pointer to it

 Api_RtlCopyMemory(pbmi,btmp,sizeDIB) ;copy DIB to memory

 Api_GlobalUnlock(hDIB) ;unlock the DIB

 ;send the DIB to the clipboard
 If Api_OpenClipboard(0) ;hwnd
  Api_EmptyClipboard() ;free last data
  Api_SetClipboardData(8,hDIB) ;CF_DIB=8, hdata[bitmap]
  Api_CloseClipboard()
 EndIf

 FreeBank btmp
 Return True ;success code
End Function
Function create_item(name$=":)", x#=0, y#=0, life_start#=-1, life_end#=-1, image=0, kill=1, draw=1) ;used as a function to easily create items
	If life_start = -1 Then life_start = MilliSecs()
	If life_end = -1 Then life_end = MilliSecs()+500
	If kill = 1 Then killitems() ;releases all of the current items
	item.ITEM = New ITEM ;to be drawn to let the user know what the current scale is
	item\name = name
	item\life_start = life_start
	item\life_end = life_end
	item\image = image
	If draw = 1 Then draw_item item\name
End Function
Function draw() ;draws the main (CAN1) program
	DebugLog "draw"
	Local tImage, tempImage, tempScaledImage, x, y
	;tempScaledImage is used for the border
	;tImage is used to hold the image variable that is meant to be drawn
	;tempImage is used to hold the resized tImage variable
	SetBuffer (CanvasBuffer(CAN1))
	Cls
	;calculate x and y
	x = GadgetWidth(CAN1)/2-FOCUSX*SCALE
	y = GadgetHeight(CAN1)/2-FOCUSY*SCALE
	;-----------------
	;draws the previous frame
	;------------------------
	;draws a border around the image
	If SCALE &lt;&gt; 1.0
;		DrawImage scaleimagefast(BORDER_IMAGE,SCALE,SCALE), GadgetWidth(CAN1)/2-ImageWidth(IMAGE(FRAME))/2*SCALE-2*SCALE, GadgetHeight(CAN1)/2-ImageHeight(IMAGE(FRAME))/2*SCALE-2*SCALE
		tempScaledImage = scaleimagefast(BORDER_IMAGE, SCALE, SCALE)
		DrawImage tempScaledImage, x-2*SCALE, y-2*SCALE
		FreeImage tempScaledImage
	Else
		DrawImage BORDER_IMAGE, x-2, y-2
	EndIf
	;-------------------------------
	;draw the post/pre-views in the corners ;used to, was a bad idea
	;--------------------------------------
	;draws the image, including calculating the tImage
	If PREVIEW+POSTVIEW &gt; 0 ;if the PREVIEW or POSTVIEW is on (draws a ghost of the previous or next frame in front of/behind the current frame)
		tImage = CopyImage(IMAGE(FRAME))
		If POSTVIEW = 1 And FRAME &gt; 0 Then image_morphwith_image(tImage, IMAGE(FRAME-1), 80, -1, 1) ;morphs 70% of the first image with 30% of the second image, ignoring black pixels on the second image
		If PREVIEW = 1 And FRAME &lt; FRAMES-1 Then image_morphwith_image(tImage, IMAGE(FRAME+1), 80, -1, 1) ;morphs 70% of the first image with 30% of the second image, ignoring black pixels on the second image
	Else
		tImage = IMAGE(FRAME)
	EndIf
	If SCALE &lt;&gt; 1.0
;		DrawImage scaleimagefast(IMAGE(FRAME),SCALE,SCALE), GadgetWidth(CAN1)/2-ImageWidth(IMAGE(FRAME))/2*SCALE, GadgetHeight(CAN1)/2-ImageHeight(IMAGE(FRAME))/2*SCALE
		tempImage = scaleimagefast(tImage, SCALE, SCALE)
		DrawImage tempImage, x, y
		FreeImage tempImage
	Else
		DrawImage tImage, x, y
	EndIf
	If PREVIEW+POSTVIEW &gt; 0 ;if the tImage is a copy of the current image, then free the copy from memory
		FreeImage tImage
	EndIf
	;-------------------------------------------------
	;draws the items, so that they don't flash
	For item.item=Each ITEM
		draw_item item\name
	Next
	;-----------------------------------------
	;finally, draw a green border if there haven't been any changes made
	If CHANGED = 0
		Color 0,255,0
		Rect 0, 0, GadgetWidth(CAN1), GadgetHeight(CAN1), 0
	EndIf
	;-------------------------------------------------------------------
	FlipCanvas (CAN1)
	SetBuffer (BUFFER)
	If DODRAW = "CAN1" Then DODRAW = ""
	If DODRAW = "BOTH" Then DODRAW = "PREVIEW"
End Function
Function draw_item(i$) ;draws the current item according to it's life
	Local c
	For item.ITEM = Each ITEM
		If item\name=i Then Exit
	Next
	SetBuffer CanvasBuffer(CAN1)
	If MilliSecs() &lt;= item\life_end
		c = 255-minimum( (MilliSecs()-item\life_start)/(item\life_end-item\life_start)*255 )
		Color c,c,c
		SetFont FONT_BIG
		Text item\x,item\y,item\name
	Else
		Color 0,0,0
		SetFont FONT_BIG
		Text item\x,item\y,item\name
	EndIf
	FlipCanvas CAN1
	SetBuffer BUFFER
	SetFont FONT
	killitems(1)
End Function
Function draw_preview(drawwhich=0, a=0, b=0) ;draws the preview of the frames; can be 0(all), 1(center), 2(none), 3(simple rectangles), or 4(from frame a to frame b)
	DebugLog "draw_preview"
	Local frame# = frame
	Local x,y,w
	If drawwhich = 0  And  MouseDown(1) = 1
		drawwhich = 3
	EndIf
	w = ImageWidth(IMAGE(FRAME)) * (100.0/ImageHeight(IMAGE(FRAME)))
	x = GadgetWidth(PREVIEW_CANVAS)/2 - w/2
	y = 8
	SetBuffer (CanvasBuffer(PREVIEW_CANVAS))
	Cls
	;draw the images previous to the current
	If drawwhich = 0 Or drawwhich = 3
		For tempx = 1 To Ceil(GadgetWidth(PREVIEW_CANVAS)/2/(w+8))+1
			If DODRAW &lt;&gt; 3 And frame-tempx &gt;= 0 Then
				Local tempImage=scaleimagefast_bypixels(IMAGE(minimum(FRAME-tempx)),w,100)
				DrawBlock alphaimage(tempImage,0,30), x-(w+8)*tempx, y
				FreeImage tempImage
			Else
				Color 50,50,50
				Rect x-(w+8)*tempx,y,w,100,1
			EndIf
		Next
	EndIf
	;---------------------------------------
	;draw the image for the current frame
	If DODRAW &lt;&gt; 0
		If DODRAW &lt;&gt; 3 Then 
			Local tempImage2=scaleimagefast_bypixels(IMAGE(FRAME),w,100)
			DrawBlock alphaimage(tempImage2,100,30), x, y
			FreeImage(tempImage2)
		Else
			Color 200,200,200
			Rect x,y,w,100,1
		EndIf
	EndIf
	;------------------------------------
	;draw the images following the current
	If drawwhich = 0 Or drawwhich = 3
		For tempx = 1 To Ceil(GadgetWidth(PREVIEW_CANVAS)/2/(w+8))+1
;			If 1 = 0 Then
			If DODRAW &lt;&gt; 3 And frame+tempx &lt;= FRAMES-1 Then
				Local tempImage3=scaleimagefast_bypixels(IMAGE(maximum(FRAME+tempx,FRAMES-1)),w,100)
				DrawBlock alphaimage(tempImage3 ,0,30), x+(w+8)*(tempx), y
				FreeImage(tempImage3)
			Else 
				Color 50,50,50
				Rect x+(w+8)*tempx,y,w,100,1
			EndIf
		Next
	EndIf
	;-------------------------------------
	FlipCanvas (PREVIEW_CANVAS)
	SetBuffer (BUFFER)
	If DODRAW = "PREVIEW" Then DODRAW = ""
	If DODRAW = "BOTH" Then DODRAW = "CAN1"
End Function
Function finish() ;quits the program, executing the necessary commands to free up image banks nad whatnot
	DebugLog "finish"
	image_free_all
	ur_free_all
	FreeImage BORDER_IMAGE
	FreeFont FONT
	FreeFont FONT_BIG
	killitems()
	End
End Function
Function getblue#(col#)
	Return col And $FF 
End Function 
Function getcolorback(r,g,b) ;returns a readpixel type value
	Return (b Or (g Shl 8) Or (r Shl 16) Or (255 Shl 24)) 
End Function
Function getgreen#(col#)
	Return  (col Shr 8) And $FF
End Function
Function getred#(col#)	
	Return (col Shr 16) And $FF 
End Function
Function getx%() ;returns the x mouse position relative to the image
	Local x = Floor( (MouseX(CAN1)-( GadgetWidth(CAN1)/2-FOCUSX*SCALE ))/SCALE )
	Return x
End Function
Function gety%() ;returns the y mouse position relative to the image
	Local y = Floor( (MouseY(CAN1)-( GadgetHeight(CAN1)/2-FOCUSY*SCALE ))/SCALE )
	Return y
End Function
Function image_free_all() ;frees all of the images and sets the FRAMES to 0 and FRAME to 0 (not including undo/redo stuff, that's left to ur_free_all)
	DebugLog "image_free_all"
	For FRAME = 0 To FRAMES-1
		FreeImage IMAGE(FRAME)
	Next
	Dim IMAGE(1)
	FRAMES = 0
	FRAME = 0
End Function
Function image_morphwith_image(image1%, image2%, percent1#, percent2#, ignore%) ;morphs percent1% of the first image with percent2% of the second image, ignoring black pixels on the second image
	DebugLog "image_morphwith_image"
	Local b, c1, c2, g, h, p1#, p2#, r, w, x, y
	If percent2 = -1 Then percent2 = 100-percent1
	p1 = percent1/100.0
	p2 = percent2/100.0
	w = ImageWidth(image1)
	h = ImageHeight(image1)
	If w = ImageWidth(image2) And h = ImageHeight(image2) ;if the images are the same dimensions... then morph the images together in the first image
		LockBuffer ImageBuffer(image1)
		LockBuffer ImageBuffer(image2)
		For x = 0 To w-1 ;for every pixel horizontally
			For y = 0 To h-1 ;and every pixel vertically...
				;retrieve the color data
				c1 = ReadPixelFast(x, y, ImageBuffer(image1))
				c2 = ReadPixelFast(x, y, ImageBuffer(image2))
				If getred(c2)&lt;&gt;0 Or getgreen(c2)&lt;&gt;0 Or getblue(c2)&lt;&gt;0 Or ignore=0 ;if the current pixel on the second image isn't black... then morph the pixel
					r = getred(c1)*p1 + getred(c2)*p2
					g = getgreen(c1)*p1 + getgreen(c2)*p2
					b = getblue(c1)*p1 + getblue(c2)*p2
					c1 = getcolorback(r, g, b)
				Else ;if the current pixel on the second image is black
				EndIf
				WritePixelFast x, y, c1, ImageBuffer(image1)
			Next
		Next
		UnlockBuffer ImageBuffer(image1)
		UnlockBuffer ImageBuffer(image2)
	EndIf
End Function
Function jump_frame(phrame = 0) ;gives the user a widowed option for choosing the current frame
	DebugLog "jump_frame"
	;variables
	Local limage%
	Local t% = 0
	;initiate the new window and its gadgets
	Local lwin = CreateWindow("Jump to...", MouseX()-300+MXOFFSET+60, GadgetY(WIN1)-200+MYOFFSET+20, 300, 200, WIN1, 1)
	Local lcan = CreateCanvas(0, 0, 100, 100, lwin)
	Local ltext = CreateTextField(110, 50, 180, 20, lwin)
	DisableGadget ltext
	Local lbar = CreateSlider(110, 10, 180, 20, lwin)
	SetSliderRange lbar, 1, FRAMES
	Local okbut = CreateButton("OK", ClientWidth(lwin)-110, ClientHeight(lwin)-34, 100, 24, lwin)
	;main function loop
	Repeat
		WaitEvent()
		;draw the canvas
		SetBuffer CanvasBuffer(lcan)
		Cls
		limage = scaleimagefast_bypixels(IMAGE(phrame), 100.0, 100.0)
		DrawBlock limage, 0, 0
		FreeImage limage
		FlipCanvas lcan
		SetBuffer BUFFER
		;calculate the phrame
		phrame = SliderValue(lbar)
		SetGadgetText ltext, phrame
		;exit statements
		If EventID() = $401 ;gadget actions
			Select EventSource()
				Case okbut
					t = 1:Exit ;let the rest of the function know that this is the way that the user wants to load the image
			End Select
		EndIf
		If KeyDown(1) = 1 ;esc
			t = 0:Exit
		EndIf
		If EventID() = $803 ;big red button
			t = 0:Exit
		EndIf
	Forever
	If t = 1 ;if ok was pressed
		FRAME = phrame
		DODRAW = "BOTH"
	EndIf
	FreeGadget lwin
	;wait for a different eventid
	While EventID() = $803
		WaitEvent()
	Wend
End Function
Function keypressed(VKKEY$) ;returns whether a key is being pressed according to it's VK keycode (as seen in getkeystate example under extensions)
	DebugLog "keypressed"
	If GetKeyState(VKKEY) = 0 Or GetKeyState(VKKEY) = 1
		Return 0
	Else
		Return 1
	EndIf
End Function
Function killitems(t=0) ;releases all of the current items ;relative to time (will only kill items that have expired)
	DebugLog "killitems"
	For item.ITEM = Each ITEM
		If t=1
			If item\life_end&lt;MilliSecs()
				If item\image&lt;&gt;0 Then FreeImage item\image
				Delete item
				If DODRAW = "" Then DODRAW = "CAN1"
			EndIf
		Else
			If item\image&lt;&gt;0 Then FreeImage item\image
			Delete item
			If DODRAW = "" Then DODRAW = "CAN1"
		EndIf
	Next
End Function
Function load_lastloaded() ;loads the last loaded image into memory
	DebugLog "load_lastloaded"
	Local lfile$, limage%, t, w%, h%
	DebugLog FileType("lastloaded.txt")
	If FileType("lastloaded.txt") = 1
		Local filein = ReadFile("lastloaded.txt")
			lfile = ReadLine(filein)
			w = ReadLine(filein)
			h = ReadLine(filein)
		CloseFile filein
		DebugLog lfile
		DebugLog w
		DebugLog h
		DebugLog FileType(lfile)
		If FileType(lfile) = 1
			limage = LoadImage(lfile)
			ur_free_all
			image_free_all
			FRAMES = Floor(ImageWidth(limage)/w)
			FRAME = 0
			Dim IMAGE(FRAMES)
			For t = 0 To FRAMES-1
				IMAGE(t) = CreateImage(w, h)
				CopyRect t*w, 0, w, h, 0, 0, ImageBuffer(limage), ImageBuffer(IMAGE(t))
			Next
			FreeImage limage
			FOCUSX = ImageWidth(IMAGE(0))/2
			FOCUSY = ImageHeight(IMAGE(0))/2
			FILENAME = lfile
			update_title
			Return 1
		EndIf
	EndIf
	Return 0
End Function
Function loadoptions() ;loads global program options
	Local txt$
	Local filein = ReadFile("prog_opt.txt")
		EYECANDY = ReadInt(filein)
		ALPHA = ReadInt(filein)
		PREVIEW = ReadInt(filein)
		POSTVIEW = ReadInt(filein)
	CloseFile fileout
End Function
Function location_gettail$(location$ = "") ;returns what's right of the / and \ symbols (eg "C:/Documents And Settings/bill.bmp" ==&gt; "bill.bmp")
	DebugLog "location_gettail"
	Local t
	If location = "" Then location = FILENAME
	For t = 1 To Len(location)+1
		If t = Len(location) + 1 Then Exit
		If Left(Right(location, t), 1) = "/" Or Left(Right(location, t), 1) = "\"
			Exit
		EndIf
	Next
	Return Right(location, t-1)
End Function
Function menu_update() ;checks and disables certain menus, also saves changed program options
	DebugLog "menu_update"
	Local changed = 1 ;records whether options have been changed and how many
	;uncheck and check the paintfunctions menus
	UncheckMenu MPFCIRC
	UncheckMenu MPFFILL
	UncheckMenu MPFLINE
	UncheckMenu MPFPENC
	UncheckMenu MPFRECT
	UncheckMenu MPFSCAL
	If FUNC = "CIRCLE" Then CheckMenu MPFCIRC
	If FUNC = "FILL" Then CheckMenu MPFFILL
	If FUNC = "LINE" Then CheckMenu MPFLINE
	If FUNC = "PENCIL" Then CheckMenu MPFPENC
	If FUNC = "RECTANGLE" Then CheckMenu MPFRECT
	If FUNC = "SCALE" Then CheckMenu MPFSCAL
	;check/uncheck other menus
	If ALPHA = 1 Then CheckMenu MALPHA Else UncheckMenu MALPHA
	If EYECANDY = 1 Then CheckMenu MEYECANDY Else UncheckMenu MEYECANDY
	If FILLED = 1 Then CheckMenu MFILL Else UncheckMenu MFILL
	If POSTVIEW = 1 CheckMenu MPOST Else UncheckMenu MPOST
	If PREVIEW = 1 CheckMenu MPRE Else UncheckMenu MPRE
	;if there were any menus to be disabled/enabled, that would happen here
	;write the saveable global options to the options file
	UpdateWindowMenu WIN1
	saveoptions(changed)
End Function
Function minimum#(x#,y#=0.0) ;if x&lt;y, then the function returns y instead
	DebugLog "minimum"
	If x &lt; y
		Return y
	Else
		Return x
	EndIf
End Function
Function maximum#(x#,y#=255.0) ;if x&gt;y, then the function returns y instead
	DebugLog "maximum"
	If x &gt; y
		Return y
	Else
		Return x
	EndIf
End Function
Function move_focus(md) ;changes the location of the focus of the image ;which mouse button has been pressed (can be 1 with the "m" key pressed (for move) or 3)
	DebugLog "move_focus"
	Local mx#, my#, x#, y#
	x = FOCUSX
	y = FOCUSY
	mx = MouseX()
	my = MouseY()
	While MouseDown(md) = 1
		If mx &lt;&gt; MouseX() Or my &lt;&gt; MouseY()
			FOCUSX = FOCUSX - (MouseX()-mx)/SCALE
			FOCUSY = FOCUSY - (MouseY()-my)/SCALE
			FOCUSX = maximum(minimum(FOCUSX),ImageWidth(IMAGE(FRAME)))
			FOCUSY = maximum(minimum(FOCUSY),ImageHeight(IMAGE(FRAME)))
			mx = MouseX()
			my = MouseY()
		EndIf
		draw()
	Wend
End Function
Function new_file() ;kills the current file and creates a new one, gives the user the option of saving changes first
	Local h, id, t, w
	id = EventID()
	t = 0
	If CHANGED &gt; 0 ;how many changes have been made
		t = Proceed("You made " + CHANGED + "changes." + Chr(10) + "Would you like To save your changes First?", 1) ;Chr(10) is a newline character
	EndIf
	If t = 1 ;if the user hit "yes" to save changes
		t = Not(save()) ;returns 1 if the save was successful or 0 if the save was cancelled
	EndIf
	If t = 0 ;if the user hit "no" or changes were saved
		h = ImageHeight(IMAGE(0))
		w = ImageWidth(IMAGE(0))
		ur_free_all
		image_free_all
		Dim IMAGE(1)
		IMAGE(0) = CreateImage(w, h)
		FRAMES = 1
		FOCUSX = w/2
		FOCUSY = h/2
		CHANGED = 0
		FILENAME = "New File"
		update_title
	EndIf
	If t = -1 ;if the user hit "cancel"
	EndIf
	While EventID() = id WaitEvent(10) Wend ;wait for the program to update
End Function
Function open() ;opens an image file and pulls the frames from it
	DebugLog "open"
	Local lfile$, limage, t
	t = 0 ;hold the return value of the request file command
	If CHANGED &gt; 0 ;how many changes have been made
		t = Proceed("You made " + CHANGED + "changes." + Chr(10) + "Would you like To save your changes First?", 1) ;Chr(10) is a newline character
	EndIf
	If t = 1 ;if the user hit "yes" to save changes
		t = Not(save()) ;returns 1 if the save was successful or 0 if the save was cancelled
	EndIf
	;ok, at this point, t will equal 0 if a file is to be loaded or 1 if they wanted to save and didn't, or -1 if they hit cancel to the "save prompt"
	If t = 0 ;if the user does indeed want to load an image
		lfile = RequestFile("Choose an image file to load...", "png;*.jpg;*.bmp,*")
		If lfile &lt;&gt; ""
			If Right(lfile, 4) = ".bmp" Or Right(lfile, 4) = ".png" Or Right(lfile, 4) = ".jpg" Or Right(lfile, 5) = ".jpeg"
				If open_imagestrip(lfile) = 1
					save_lastloaded lfile
					update_title
				EndIf
				draw
				draw_preview
			Else
				Notify "Incorrect file type."
			EndIf
		EndIf
	EndIf
End Function
Function open_imagestrip(lfile$) ;load the imagestrip lfile into the animator
	DebugLog "open_imagestrip" + ":" + lfile
	;declare local variables
	Local lframe% = 0 ;the current frame of the prevew
	Local limage% = LoadImage(lfile)
	Local ltimer% = MilliSecs()
	Local w% = ImageWidth(limage) ;width/height of the total input image
	Local h% = ImageHeight(limage)
	Local w2% = ImageHeight(limage) ;width/height of each frame
	Local h2% = ImageHeight(limage)
	Local t% ;a generic temporary variable
	;create a preview window
	Local lwin = CreateWindow("Load Image Strip", GadgetX(WIN1), GadgetY(WIN1), maximum(minimum(450,w+100),800), maximum(minimum(200,h+100),600), WIN1, 1)
	SetGadgetShape lwin, minimum(MouseX()-maximum(minimum(450,w+100),800)+MXOFFSET+170), minimum(MouseY()-maximum(minimum(200,h+100),600)+MXOFFSET+22), GadgetWidth(lwin), GadgetHeight(lwin)
	;gadgets for the new window
		;canvas/load/cancel buttons
		Local lcan = CreateCanvas(0, 0, ClientWidth(lwin), ClientHeight(lwin), lwin)
		SetBuffer CanvasBuffer(lcan)
		Local loadbut = CreateButton("LOAD", ClientWidth(lcan)-220, ClientHeight(lcan)-34, 100, 24, lcan)
		Local cancelbut = CreateButton("CANCEL", ClientWidth(lcan)-110, ClientHeight(lcan)-34, 100, 24, lcan)
		;width and height textfields
		Local wtext = CreateTextField(ClientWidth(lcan)-420, ClientHeight(lwin)-64, 200, 20, lcan)
		Local htext = CreateTextField(ClientWidth(lcan)-210, ClientHeight(lwin)-64, 200, 20, lcan)
		SetGadgetText wtext, w2
		SetGadgetText htext, h2
;		DisableGadget htext
	;function loop
	Repeat
		WaitEvent 10
		;preview statements
		Cls
		;outline the frames on the original image
		DrawImage(limage, 0, 0)
		Color 255, 255, 255
		For t = 0 To Floor(w/w2)-1
			Rect t*w2, 0, w2, h2, 0
		Next
		;draw a preview box
		Color 130, 130, 130
		Rect GadgetWidth(lcan)-w2-20, 0, w2+20, h2, 1
		If MilliSecs() &gt; ltimer
			ltimer = MilliSecs() + 200
			lframe = lframe + 1
			If lframe &gt; Floor(w/w2)-1 Then lframe = 0
		EndIf
		CopyRect w2*lframe, 0, w2, h2, GadgetWidth(lcan)-w2-10, 0, ImageBuffer(limage), CanvasBuffer(lcan)
		FlipCanvas lcan
		;give the user a chance to edit the width/height
		t = TextFieldText(wtext)
		If t &gt; 0 And t &lt; w+1
			w2 = t
		EndIf
		t = TextFieldText(htext)
		If t &gt; 0 And t &lt; h+1
			h2 = t
		EndIf
		;exit statements
		If EventID() = $401 ;gadget actions
			Select EventSource()
				Case cancelbut ;cancels loading the image
					If Confirm("Cancel loading the image?") = 1 Then t = 1:Exit
				Case loadbut
					t = 1:Exit ;let the rest of the function know that this is the way that the user wants to load the image
			End Select
		EndIf
		If KeyDown(1) = 1 ;esc
			If Confirm("Cancel loading the image?") = 1 Then t = 0:Exit
		EndIf
		If EventID() = $803 ;big red button
			If Confirm("Cancel loading the image?") = 1 Then t = 0:Exit
		EndIf
	Forever
	If t = 1
		;load the image(s)
		ur_free_all
		image_free_all
		w2 = maximum(w2, w-1)
		t = minimum(Floor(w/w2)) ;number of frames to be loaded
		Dim IMAGE(t) ;reset the IMAGE array
		DebugLog w2*t + ":" + 0 + ":" + w2 + ":" + h2
		Local a
		For a = 0 To t - 1 ;create and store a part of the loaded image into each part of the IMAGE array
			IMAGE(a) = CopyImage(limage)
			IMAGE(a) = trimimage(IMAGE(a), w2*a, 0, w2, h2)
		Next
		Flip
		calculate_borderimage
		FRAMES = t
		FOCUSX = ImageWidth(IMAGE(0))/2
		FOCUSY = ImageHeight(IMAGE(0))/2
		CHANGED = 0
		FILENAME = lfile
		update_title
		t = 1
	EndIf
	;get rid of the temporary stuff
	FreeImage limage
	FreeGadget lwin
	ActivateWindow WIN1
	;wait for a different eventid
	While EventID() = $803
		WaitEvent()
	Wend
	Return t
End Function
Function padl$(t$,p = 1) ;pads the left side of string t with spaces up until the string is as long as p
	DebugLog "padl"
	While Len(t)&lt;p
		t = " "+t
	Wend
	Return t
End Function
Function padr$(t$,p = 1) ;pads the right side of string t with spaces up until the string is as long as p
	DebugLog "padr"
	While Len(t)&lt;p
		t = t+" "
	Wend
	Return t
End Function
</textarea><br><br>...And here is a zip file with an executable, the two icons I'm considering, simple documentation, And the source. <a href="http://www.polian-studios.com/public_downloads/animator/game_animatory0.5.zip" target="_blank">http://www.polian-studios.com/public_downloads/animator/game_animatory0.5.zip</a><br><br>BTW: I downloaded resource hacker and tried to add one of the icons to my app, but there wasn't any place in the app to put it. Any suggestions? <br><br></td></tr></table><br>
<a name="985683"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gladclef - Ben B</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here's the rest of the code, since it wouldn't all fit in one post...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function paintfunctions_line(md#=1.0) ;for the pencil function (again, which mouse button)
	DebugLog "paintfunctions_line"
	;declare the variables
	Local image1, pmx, pmy, x, y
	;the current mouse position, relative to the image
	x = getx()
	y = gety()
	;the mouse position at the start of the painfunctions_line function
	pmx = getx()
	pmy = gety()
	;make a copy if the current frame
	image1 = CopyImage(IMAGE(FRAME))
	;main function
	While MouseDown(md) = 1
		SetBuffer ImageBuffer(IMAGE(FRAME))
		;redraw the old image
		DrawBlock image1, 0, 0
		;gets the default color
		If md = 1 ;left mouse button color
			Color getred(C1),getgreen(C1),getblue(C1)
		Else ;right mouse button color
			Color getred(C2),getgreen(C2),getblue(C2)
		EndIf
		x = getx()
		y = gety()
		Line pmx, pmy, x, y
		SetBuffer BUFFER
		draw
		set_windowtext_right "("+pmx+", "+pmy+")/("+x+", "+y+")"
		time 30
	Wend
	FreeImage image1
End Function
Function paintfunctions_rectangle(md#=1.0) ;for the pencil function (again, which mouse button)
	DebugLog "paintfunctions_rectangle"
	;declare the variables
	;a, b, c, and d are x/y/width/height coordinates of the circle
	;f is for filled circle (1 or 0)
	;x, y, pmx, and pmy are to record mouse functions
	Local a, b, c, d, f, image1, pmx, pmy, x, y
	;the current mouse position, relative to the image
	x = getx()
	y = gety()
	;the mouse position at the start of the painfunctions_rectangle function
	pmx = getx()
	pmy = gety()
	;make a copy if the current frame
	image1 = CopyImage(IMAGE(FRAME))
	;main function
	While MouseDown(md) = 1
		SetBuffer ImageBuffer(IMAGE(FRAME))
		;redraw the old image
		DrawBlock image1, 0, 0
		;gets the default color
		If md = 1 ;left mouse button color
			Color getred(C1),getgreen(C1),getblue(C1)
		Else ;right mouse button color
			Color getred(C2),getgreen(C2),getblue(C2)
		EndIf
		;calculate a, b, c, and d
		x = getx()
		y = gety()
		If x-pmx &gt;= 0
			a = pmx
			c = x-pmx+1
		Else
			a = pmx-Abs(x-pmx)
			c = Abs(x-pmx)+1
		EndIf
		If y-pmy &gt;= 0
			b = pmy
			d = y-pmy+1
		Else
			b = pmy-Abs(y-pmy)
			d = Abs(y-pmy)+1
		EndIf
		;determine fill
		If KeyDown(56)=1 Or KeyDown(184)=1 ;alt keys are pressed
			f = Not(FILLED)
		Else ;alt keys are not pressed
			f = FILLED
		EndIf
		;draw
		Rect a, b, c, d, f
		SetBuffer BUFFER
		draw
		set_windowtext_right "("+c+", "+d+")" ;width, height of the shape
		time 30
	Wend
	FreeImage image1
End Function
Function paintfunctions_pencil(md#=1.0) ;for the pencil function (again, which mouse button)
	DebugLog "paintfunctions_pencil"
	Local mx, my, x, y
	x = getx()
	y = gety()
	mx = x
	my = y
	While MouseDown(md) = 1
		SetBuffer ImageBuffer(IMAGE(FRAME))
		;gets the default color
		If md = 1 ;left mouse button color
			Color getred(C1),getgreen(C1),getblue(C1)
		Else ;right mouse button color
			Color getred(C2),getgreen(C2),getblue(C2)
		EndIf
		x = getx()
		y = gety()
		Line mx, my, x, y
		mx = x
		my = y
		SetBuffer BUFFER
		set_windowtext_right "("+x+", "+y+")"
		draw
	Wend
End Function
Function PasteImageFromClipboard()
 ;Paste the clipboard to a new Blitz3D image
 ;From "Copying a DIB to the clipboard", by John Simmons
 ;(http://www.codeproject.com)

 Local hDIB,himage,pbmi,btmp,sizeInfo,sizePal,width,height,bpp
 Local sizeBits,sizeDIB,x,y,offset,index,bytespp

 ;receive the bitmap from the clipboard as a DIB
 If Api_OpenClipboard(0) ;hwnd
  hDIB=Api_GetClipboardData(8) ;CF_DIB=8
  Api_CloseClipboard()
 EndIf

 If Not hDIB ;if we didn't get a DIB, return a dummy image
  himage=CreateImage(1,1)
  Return himage
 EndIf

 pbmi=Api_GlobalLock(hDIB) ;lock memory and get pointer to it

 btmp=CreateBank(40) ;initialize bank, we will resize it later

 Api_RtlMoveMemory(btmp,pbmi,40) ;move info header to bank
 sizeInfo=PeekInt(btmp,0) ;biSize

 ;calculate palette, Clipboard DIBs use the BITMAPINFO struct
 sizePal=PeekInt(btmp,32) ;biClrUsed
 If Not sizePal
  If PeekShort(btmp,14)&lt;16 ;no color table for 16/24/32
   sizePal=1 Shl PeekShort(btmp,14) ;biBitCount, colors=2/16/256
  Else
   sizePal=PeekInt(btmp,16) ;biCompression, 16/32 use BI_BITFIELDS=3
  EndIf
 EndIf
 sizePal=sizePal*4 ;sizeof(RGBQUAD)

 width=PeekInt(btmp,4) ;biWidth
 height=PeekInt(btmp,8) ;biHeight
 bpp=PeekShort(btmp,14) ;biBitCount
 bytespp=bpp/8 ;bytes per pixel

 ;calculate bits, DWORD-aligned scanline (Width * BitCount) * Height
 sizeBits=((width*bpp+31)/32*4)*height
 sizeDIB=sizeInfo+sizePal+sizeBits ;total size

 ResizeBank btmp,sizeDIB ;resize bank to store DIB
 Api_RtlMoveMemory(btmp,pbmi,sizeDIB) ;move DIB to bank

 Api_GlobalUnlock(hDIB) ;unlock the DIB

 himage=CreateImage(width,height) ;new image to write

 ;calculate DWORD-aligned offset of bits for proper alignment
 ;we'll use biSize to store each pixel, we don't need it any more
 LockBuffer(ImageBuffer(himage))
 For y=0 To height-1
  offset=((width*bpp+31)/32*4)*y+sizeInfo+sizePal ;start of next scanline
  For x=0 To width-1
   If bpp=1
    index=PeekByte(btmp,offset+(x/8)) ;1-bit, looks nasty but it works
    ;work out the bit, invert it, bitmask the byte and convert to 0/1
    index=(index And (1 Shl (7-(x Mod 8)))) Shr (7-(x Mod 8))
   EndIf
   If bpp=4
    index=PeekByte(btmp,offset+(x/2)) ;4-bit, work out the nibble
    If x Mod 2 Then index=index And 15 ;get bits 0-3
    If Not x Mod 2 Then index=index Shr 4 ;get bits 4-7
   EndIf
   If bpp=8
    index=PeekByte(btmp,offset+x) ;8-bit, we have our index
   EndIf
   If bpp=24 Or bpp=32 ;get rgb offset
    PokeByte btmp,0,PeekByte(btmp,offset+(x*bytespp)) ;blue
    PokeByte btmp,1,PeekByte(btmp,offset+(x*bytespp)+1) ;green
    PokeByte btmp,2,PeekByte(btmp,offset+(x*bytespp)+2) ;red
   ElseIf bpp=16 ;rgb=565
    PokeByte btmp,0,(PeekShort(btmp,offset+(x*bytespp)) And 31) Shl 3 ;blue
    PokeByte btmp,1,((PeekShort(btmp,offset+(x*bytespp)) And 2016) Shr 5) Shl 2 ;green
    PokeByte btmp,2,((PeekShort(btmp,offset+(x*bytespp)) And 63488) Shr 11) Shl 3 ;red
   Else ;get palette index, 1/4/8-bit
    PokeByte btmp,0,PeekInt(btmp,sizeInfo+(index*4))
    PokeByte btmp,1,PeekInt(btmp,sizeInfo+(index*4)+1)
    PokeByte btmp,2,PeekInt(btmp,sizeInfo+(index*4)+2)
   EndIf
   WritePixelFast x,height-1-y,PeekInt(btmp,0),ImageBuffer(himage) ;biSize
  Next
 Next
 UnlockBuffer(ImageBuffer(himage))

 FreeBank btmp
 Return himage ;image handle

End Function
Function print_about() ;prints the about data
	Local ltext$
	ltext = ltext + "Game Animatory v0.50"+Chr$(10)
	ltext = ltext + "Conception and Design by: Benjamin Bean"+Chr$(10)
	ltext = ltext + Chr$(10)
	ltext = ltext + "Animating your games."+Chr$(10)
	Notify ltext
End Function
Function resize_images(w, h) ;trims the images to the users specified dimensions from within the function
	DebugLog "resize_images"
	;variables
	Local limage%
	Local phrame% = 0 ;used to display the animation with the new dimensions applied
	Local t% = 0, t2% = 0
	Local ltimer% = MilliSecs() + 100 ;used to add a delay between the drawing of the frames
	Local w2 = w, h2 = h, x2 = 0, y2 = 0 ;the new shape of the images
	;initiate the new window and its gadgets
	Local lwin = CreateWindow("Set Image Size...", GadgetWidth(Desktop())/2-minimum(w, 400)/2, GadgetHeight(Desktop())/2-(50)/2-minimum(h+MYOFFSET+MXOFFSET+74, 200)/2, minimum(w, 400), minimum(h+MYOFFSET+MXOFFSET+74, 200), WIN1, 1)
	Local lcan = CreateCanvas(0, 0, w, h, lwin)
		Local lxd = CreateTextField(0, h+10, 20, 20, lwin)
		SetGadgetText lxd, "x:":DisableGadget lxd
	Local lx = CreateTextField(20, h+10, 70, 20, lwin)
	SetGadgetText lx, "0"
		Local lyd = CreateTextField(90, h+10, 20, 20, lwin)
		SetGadgetText lyd, "y:":DisableGadget lyd
	Local ly = CreateTextField(110, h+10, 70, 20, lwin)
	SetGadgetText ly, "0"
		Local lwd = CreateTextField(180, h+10, 20, 20, lwin)
		SetGadgetText lwd, "w:":DisableGadget lwd
	Local lw = CreateTextField(200, h+10, 70, 20, lwin)
	SetGadgetText lw, w2
		Local lhd = CreateTextField(270, h+10, 20, 20, lwin)
		SetGadgetText lhd, "h:":DisableGadget lhd
	Local lh = CreateTextField(290, h+10, 70, 20, lwin)
	SetGadgetText lh, h2
	Local okbut = CreateButton("OK", ClientWidth(lwin)-220, ClientHeight(lwin)-34, 100, 24, lwin)
	Local cancelbut = CreateButton("Cancel", ClientWidth(lwin)-110, ClientHeight(lwin)-34, 100, 24, lwin)
	;main function loop
	Repeat
		WaitEvent 30
		;draw the canvas
		SetBuffer CanvasBuffer(lcan)
		Cls
		limage = CopyImage(IMAGE(phrame))
		limage = trimimage(limage, x2, y2, w2, h2)
		DrawBlock limage, 0, 0
		FreeImage limage
		FlipCanvas lcan
		SetBuffer BUFFER
		;calculate the phrame
		If MilliSecs() &gt; ltimer
			phrame = phrame + 1
			If phrame &gt; FRAMES - 1 Then phrame = 0
			ltimer = MilliSecs() + 100
		EndIf
		;calculate the new x and y coordinates and the new width and height of the image
		x2 = minimum(TextFieldText(lx), 1)
		y2 = minimum(TextFieldText(ly), 1)
		w2 = minimum(TextFieldText(lw), 1)
		h2 = minimum(TextFieldText(lh), 1)
		If w2 &lt;&gt; GadgetWidth(lcan)
			If w2 &gt; ClientWidth(lwin)
				FreeGadget lcan
				If WindowMaximized(lwin) = 0
					MaximizeWindow lwin
					lcan = CreateCanvas(0, 0, w2, h2, lwin)
				EndIf
				w2 = maximum(w2, ClientWidth(lwin))
			EndIf
			FreeGadget lcan
			lcan = CreateCanvas(0, 0, w2, h2, lwin)
		EndIf
		If h2 &lt;&gt; GadgetHeight(lcan)
			If h2 &gt; ClientHeight(lwin)
				FreeGadget lcan
				If WindowMaximized(lwin) = 0
					MaximizeWindow lwin
					lcan = CreateCanvas(0, 0, w2, h2, lwin)
				EndIf
				h2 = maximum(h2, ClientHeight(lwin)-74)
			EndIf
			FreeGadget lcan
			lcan = CreateCanvas(0, 0, w2, h2, lwin)
		EndIf
		;exit statements
		If EventID() = $401 ;gadget actions
			Select EventSource()
				Case cancelbut ;cancels the resize
					t = 0:Exit ;let the rest of the function know that the user doesn't want to resize the frames
				Case okbut
					t = 1:Exit ;let the rest of the function know that this is the way the user wants to resize the frames
			End Select
		EndIf
		If KeyDown(1) = 1 ;esc
			t = 0:Exit ;let the rest of the function know that the user doesn't want to resize the frames
		EndIf
		If EventID() = $803 ;big red button
			t = 0:Exit ;let the rest of the function know that the user doesn't want to resize the frames
		EndIf
	Forever
	If t = 1 ;if ok was pressed
		For t2 = 0 To FRAMES - 1
			IMAGE(t2) = trimimage(IMAGE(t2), x2, y2, w2, h2)
		Next
		calculate_borderimage
		FOCUSX = ImageWidth(IMAGE(0))/2
		FOCUSY = ImageHeight(IMAGE(0))/2
		save_lastloaded FILENAME
		DODRAW = "BOTH"
	EndIf
	FreeGadget lwin
	;wait for a different eventid
	While EventID() = $803
		WaitEvent()
	Wend
	Return t
End Function
Function removeframe(phrame) ;removes frame "phrame" from the list of frames, shifting all the other frames back down
	Local h, t, t2, w
	Dim TEMP_ARRAY(FRAMES-1)
	;store the frames coming before said "phrame"
	If phrame &gt; 0 ;if said phrame isn't the first frame
		For t = 0 To phrame-1
			TEMP_ARRAY(t) = IMAGE(t) ;hold the image handles while the size of the image array is reassigned
		Next
	EndIf
	;store the frames coming after said "phrame"
	If phrame &lt; FRAMES-1 ;if said phrame isn't the last frame
		For t = phrame+1 To FRAMES-1
			TEMP_ARRAY(t-1) = IMAGE(t) ;hold the image handles while the size of the image array is reassigned
		Next
	EndIf
	;finally, remove the old image (after grabbing it's width and height in case a new one has to be created
	w = ImageWidth(IMAGE(phrame))
	h = ImageHeight(IMAGE(phrame))
	FreeImage IMAGE(phrame)
	;shift image handles back over to our dear friend IMAGE()
	Dim IMAGE(minimum(FRAMES-1, 1))
	For t = 0 To minimum(FRAMES-2)
		IMAGE(t) = TEMP_ARRAY(t)
	Next
	;if there aren't any more images left, create one
	If FRAMES = 1
		IMAGE(0) = CreateImage(w, h) ;create a blank image in place of the old one
	Else
		FRAMES = FRAMES - 1
	EndIf
	Dim TEMP_ARRAY(1)
	DODRAW = "BOTH"
	;finally, check and set the undo/redo stuff to the correct frames
	;if the stack item ends up being the removed frame, then terminate all others after that
	For t = 0 To 7
		If UR_STACK(t) &gt; phrame
			UR_STACK(t) = UR_STACK(t) - 1
		Else
			If UR_STACK(t) = phrame ;It's the deleted frame. Kill it and those following.
				For t2 = t To 7
					UR_STACK(t2) = 0
					For iundo.IUNDO = Each IUNDO
						If iundo\id = t2 Then FreeImage iundo\h:Delete iundo
					Next
				Next
				t = 7
			EndIf
		EndIf
	Next
	For t = 8 To 15
		If UR_STACK(t) &gt; phrame
			UR_STACK(t) = UR_STACK(t) - 1
		Else
			If UR_STACK(t) = phrame ;It's the deleted frame. Kill it and those following.
				For t2 = t To 15
					UR_STACK(t2) = 0
					For iredo.IREDO = Each IREDO
						If iredo\id = t2 Then FreeImage iredo\h:Delete iredo
					Next
				Next
				t = 15
			EndIf
		EndIf
	Next
End Function
Function resize_maincanvases(w=500,h=308) ;called if the case that the main (WIN1) window has been resized
	DebugLog "resize_maincanvases"
	Local image1
	;if the main window(WIN1) is less than twice the height of the preview canvas, then it is resized to fit that shape
;	If ClientHeight(WIN1)&lt;GadgetHeight(PREVIEW_CANVAS)*2 Then SetGadgetShape WIN1,GadgetX(WIN1),GadgetY(WIN1),GadgetWidth(WIN1),minimum(GadgetHeight(WIN1)+1,GadgetHeight(PREVIEW_CANVAS)*2)
	;------------------------------------------------------------------------------------------------------------------
	;resize the "main" main canvas (CAN1)
	image1 = CreateImage(GadgetWidth(CAN1),GadgetHeight(CAN1))
	CopyRect 0,0,GadgetWidth(CAN1),GadgetHeight(CAN1),0,0,CanvasBuffer(CAN1),ImageBuffer(image1)
	CAN2 = CAN1 ;1, these four steps create a new canvas of the correct dimensions
	CAN1 = CreateCanvas(0,0,ClientWidth(WIN1),ClientHeight(WIN1)-116,WIN1) ;2
	Local tempImage=scaleimagefast_bypixels(image1,w,h-GadgetHeight(PREVIEW_CANVAS))
	CopyRect 0,0,w,h-GadgetHeight(PREVIEW_CANVAS),0,0,ImageBuffer(tempImage),CanvasBuffer(CAN1)
	FreeImage(tempImage)
	FreeGadget CAN2 ;3
	BUFFER = CanvasBuffer(CAN1) ;4
	FreeImage image1
	;------------------------------------
	;resize the preview canvas (PREVIEW_CANVAS)
	image1 = CreateImage(GadgetWidth(PREVIEW_CANVAS),GadgetHeight(PREVIEW_CANVAS))
	CopyRect 0,0,GadgetWidth(PREVIEW_CANVAS),GadgetHeight(PREVIEW_CANVAS),0,0,CanvasBuffer(PREVIEW_CANVAS),ImageBuffer(image1)
	CAN2 = PREVIEW_CANVAS ;1, these three steps create a new canvas of the correct dimensions
	PREVIEW_CANVAS = CreateCanvas(0,ClientHeight(WIN1)-116,ClientWidth(WIN1),116,WIN1) ;2
	Local tempImage2=scaleimagefast_bypixels(image1,w,minimum(GadgetHeight(PREVIEW_CANVAS)))
	CopyRect 0,0,w,GadgetHeight(PREVIEW_CANVAS),0,0,ImageBuffer(tempImage2),CanvasBuffer(PREVIEW_CANVAS)
	FreeImage(tempImage2)
	FreeGadget CAN2 ;3
	FreeImage image1
	;------------------------------------------
End Function
Function save(saveas = 0) ;saves the current project as a .bmp image strip ;if 1, then it must be a save_as command
	DebugLog "save"
	Local lfilename$, limage, t, t2, w
	If FILENAME &lt;&gt; "New File" And saveas = 0
		t = 0
	Else
		lfilename = RequestFile("Select a filename to save as","png;*.jpg;*.bmp,*",True,location_gettail(FILENAME))
		If lfilename = "" ;the user hit "cancel"
			t = -1
		Else ;the user hit "save"
			If Right(lfilename,4) = ".bmp" Or Right(lfilename,4) = ".jpg" Or Right(lfilename,5) = ".jpeg" Or Right(lfilename,4) = ".png"
				t = 0
				FILENAME = lfilename
				update_title
			Else ;incorrect file type
				t = 1
			EndIf
		EndIf
	EndIf
	If t = 0
		w = ImageWidth(IMAGE(0))
		limage = CreateImage((FRAMES)*w, ImageHeight(IMAGE(0)))
		SetBuffer ImageBuffer(limage)
		For t2 = 0 To FRAMES - 1
			DrawBlock IMAGE(t2), w*t2, 0
		Next
		SetBuffer BUFFER
		SaveImage limage, FILENAME
		CHANGED = 0
		save_lastloaded lfilename
		Return 1 ;the save was successful
	EndIf
	Return 0 ;the save wasn't successful
End Function
Function save_lastloaded(lfile$, w%=-1, h%=-1) ;save the location of the last file loaded (with dimensions for the autoload feature)
	If w = -1 Then w = ImageWidth(IMAGE(0))
	If h = -1 Then h = ImageHeight(IMAGE(0))
	Local fileout = WriteFile("lastloaded.txt")
		WriteLine fileout, lfile
		WriteLine fileout, w
		WriteLine fileout, h
	CloseFile fileout
End Function
Function saveoptions(changed = 1) ;save the global options in a file as long as changed &gt; 0
	If changed &gt; 0 ;if some of the program options have changed, then save the changes
		Local fileout = WriteFile("prog_opt.txt")
			WriteInt fileout, EYECANDY
			WriteInt fileout, ALPHA
			WriteInt fileout, PREVIEW
			WriteInt fileout, POSTVIEW
		CloseFile fileout
	EndIf
End Function
Function scaleimagefast(SrcImage, ScaleX#, ScaleY#) ;this function resizes images 80x faster than the standard resizeimage (tformfilter 0) blitz command
	DebugLog "scaleimagefast"
	;----------------------------------------------
	;many thanks for sswift
	;for posting this code on the blitz pages
	;http://www.blitzbasic.com/codearcs/codearcs.php?code=1303
	;****** HUGE WARNING ******
	;if you are to use this code, be sure to free your images afterwards
	;e.g.
	;tempImage = scaleimagefast(SrcImage, ScaleX#, ScaleY#)
	;drawimage tempImage, x, y
	;freeimage tempImage
	;----------------------------------------------
	Local SrcWidth,  SrcHeight
	Local DestWidth, DestHeight
	Local ScratchImage, DestImage
	Local SrcBuffer, ScratchBuffer, DestBuffer
	Local X1, Y1, X2, Y2
	; Get the width and height of the source image. 	
		SrcWidth  = ImageWidth(SrcImage)
		SrcHeight = ImageHeight(SrcImage)
	; Calculate the width and height of the dest image.
		DestWidth  = Floor(SrcWidth  * ScaleX#)
		DestHeight = Floor(SrcHeight * ScaleY#)
	; If the image does not need to be scaled, just copy the image and exit the function.
		If (SrcWidth = DestWidth) And (SrcHeight = DestHeight) Then Return CopyImage(SrcImage)
	; Create a scratch image that is as tall as the source image, and as wide as the destination image.
		ScratchImage = CreateImage(DestWidth, SrcHeight)
	; Create the destination image.
		DestImage = CreateImage(DestWidth, DestHeight) 
	; Get pointers to the image buffers.
		SrcBuffer     = ImageBuffer(SrcImage)
		ScratchBuffer = ImageBuffer(ScratchImage)
		DestBuffer    = ImageBuffer(DestImage)
	; Duplicate columns from source image to scratch image.
		For X2 = 0 To DestWidth-1
			X1 = Floor(X2 / ScaleX#)
			CopyRect X1, 0, 1, SrcHeight, X2, 0, SrcBuffer, ScratchBuffer
		Next
	; Duplicate rows from scratch image to destination image.
		For Y2 = 0 To DestHeight-1
			Y1 = Floor(Y2 / ScaleY#)
			CopyRect 0, Y1, DestWidth, 1, 0, Y2, ScratchBuffer, DestBuffer
		Next
	; Free the scratch image.
		FreeImage ScratchImage
	; Return the new image.
		Return DestImage
End Function
Function scaleimagefast_bypixels(image1,w#,h#) ;uses scaleimagefast, but takes out the headache of calculating percents
	DebugLog "scaleimagefast_bypixels"
	Local x#,y#
	x = w/ImageWidth(image1)
	y = h/ImageHeight(image1)
	Return scaleimagefast(image1,x,y)
;	FreeImage image1
End Function
;[Block]Function setwintransparenz(WinHandle, Transparenz) ;sets the transparency of the given window
;	debuglog "setwintransparenz"
;	;many thanks to OnkelDetlef for posting this code online
;	;http://www.blitzbasic.com/Community/posts.php?topic=38928
;	api_SetWindowLong(WinHandle,GWL_EXSTYLE,$00080000)
;	api_SetLayeredWindowAttributes(WinHandle,0,Transparenz,2)
;[End]End Function
Function set_windowtext_left(t$="") ;sets the text on the left side of the bottom bar
	Local x, y
	SetGadgetFont WIN1, FONT
	If t = ""
		t = FUNC
	EndIf 
	If Instr(WTEXT, "  ")&gt;0
		For x = 1 To Len(WTEXT)-1
			If Left(Right(WTEXT, x+1), 2) = "  " Then Exit
		Next
		WTEXT = Right(WTEXT, x-1)
	EndIf
	t = padr(t, 127)
	WTEXT = Left(t, Len(t) - Len(WTEXT)) + WTEXT
	SetStatusText WIN1, WTEXT
End Function
Function set_windowtext_right(t$="") ;sets the text on the left side of the bottom bar
	Local x, y
	SetGadgetFont WIN1, FONT
	If t = ""
		t = FRAME
	EndIf 
	If Instr(WTEXT, "  ")&gt;0
		WTEXT = Left(WTEXT, Instr(WTEXT, "  "))
	EndIf
	t = padl(t, 127)
	WTEXT = WTEXT + Right(t, Len(t) - Len(WTEXT))
	SetStatusText WIN1, WTEXT
End Function
Function shift_preview(p#, n#) ;eye candy that shifts the preview smoothly to the left or right ;previous, new
	DebugLog "shift_preview"
	If p &lt;&gt; n And EYECANDY = 1
		Local image1, image2, tempx, w#, x#, y#, x2#, y2#, x3#, y3# ;w, x, and y were derived from draw_preview ;x2 and y2 are derived from draw
		w = ImageWidth(IMAGE(p)) * (100.0/ImageHeight(IMAGE(p))) + 8
		x = GadgetWidth(PREVIEW_CANVAS)/2 - (w-8)/2
		y = 8
		x2 = GadgetWidth(CAN1)/2-FOCUSX*SCALE
		y2 = GadgetHeight(CAN1)/2-FOCUSY*SCALE
		SetBuffer CanvasBuffer(PREVIEW_CANVAS)
		If ALPHA = 1 ;fade out the old frame and fade in the new frame
			Local tempImage=scaleimagefast_bypixels(IMAGE(p),w-8,100)
			DrawBlock alphaimage(tempImage,0,30 ), x, y
			FreeImage(tempImage)
			tempImage=scaleimagefast_bypixels(IMAGE(n),w-8,100)
			DrawBlock alphaimage( tempImage,100,30 ), x-(p-n)*w, y
			FreeImage(tempImage)
			FlipCanvas PREVIEW_CANVAS
		EndIf
		image1 = CreateImage(GadgetWidth(PREVIEW_CANVAS), GadgetHeight(PREVIEW_CANVAS))
		image2 = CreateImage(GadgetWidth(CAN1), GadgetHeight(CAN1))
		CopyRect 0, 0, GadgetWidth(PREVIEW_CANVAS), GadgetHeight(PREVIEW_CANVAS), 0, 0, CanvasBuffer(PREVIEW_CANVAS), ImageBuffer(image1)
		CopyRect 0, 0, GadgetWidth(CAN1), GadgetHeight(CAN1), 0, 0, CanvasBuffer(CAN1), ImageBuffer(image2)
		For tempx=0 To 20 ;the smooth stuff
			SetBuffer CanvasBuffer(PREVIEW_CANVAS) ;the preview bar
				Cls
				If n-p&gt;0
					DrawBlock image1, minimum((p-n)*w/(21-tempx), (p-n)*w), 0
				Else
					DrawBlock image1, maximum((p-n)*w/(21-tempx), (p-n)*w), 0
				EndIf
			FlipCanvas PREVIEW_CANVAS
			SetBuffer CanvasBuffer(CAN1) ;the main canvas
				Cls
				x3 = x-(p-n)*w
				y3 = GadgetY(PREVIEW_CANVAS)-100
				DrawBlock image2, 0, 0
				tempImage=scaleimagefast_bypixels(IMAGE(n), minimum((ImageWidth(IMAGE(n))*SCALE-w)/20*tempx+w,4), minimum((ImageHeight(IMAGE(n))*SCALE-100)/20*tempx+100,4))
				DrawImage tempImage, x3 + (x2-x3)/20*tempx, y3 + (y2-y3)/20*tempx
				FreeImage(tempImage)
			FlipCanvas CAN1
			time 10
		Next
		SetBuffer CanvasBuffer(PREVIEW_CANVAS)
		SetBuffer BUFFER
		FreeImage image1
		FreeImage image2
		If DODRAW = "" Then DODRAW = "PREVIEW"
		If DODRAW = "CAN1" Then DODRAW = "BOTH"
	EndIf
End Function
Function time(t) ;delays the program up until the TIMER variable runs out, then resets the timer variable for t
	DebugLog "time"
	While TIMER &gt; MilliSecs()
		ID = WaitEvent(5)
		If ID&lt;&gt;0 Then Exit
	Wend
	TIMER = MilliSecs() + t
End Function
Function trimimage(image, x, y, w, h) ;trims said image to said dimensions and returns a NEW image, freeing the OLD image from memory ;used for pasting images in the userinput_checkfunction_ctrl function
	Local timage = CreateImage(w,h)
	CopyRect x, y, w, h, 0, 0, ImageBuffer(image), ImageBuffer(timage)
	FreeImage image
	Return timage
End Function
;[Block]---For the ur (undo/redo) functions---
	;imagine a line graph with 0 in the middle with values ranging from 1 to 4 on the right and from 1 to 4 on the left
	;each number is an image
	;the ones on the right are redo images (they are shifted left when the redo hotkey is pressed)
	;the ones on the left are undo images (they are shifted right when the undo hotkey is pressed)
	;the one in the center, on 0, is the actual image
;[End]---                                ---
Function update_title(title$ = "") ;sets the title of the program to the new title + : Game_Animatory vX
	If title = "" Then title = location_gettail(FILENAME)
	title = title + ": Game_Animatory v0.13"
	SetGadgetText WIN1, title
End Function
Function ur_free_all() ;frees all of the undo/redo images ;useful if the current FRAME variable has been changed
	DebugLog "ur_free_all"
	Local t
	For iundo.IUNDO = Each IUNDO
		FreeImage iundo\h
		Delete iundo
	Next
	For iredo.IREDO = Each IREDO
		FreeImage iredo\h
		Delete iredo
	Next
	;also free the FRAME refferences from UR_STACK()
	For t = 0 To 15
		UR_STACK(t) = 0
	Next
End Function
Function ur_redo() ;undoredo_redo, moves the current image into the IUNDO type and replaces it with the soonest IREDO type
	DebugLog "ur_redo"
	If ur_redo_count() &gt; 0
		FRAME = UR_STACK(8) ;switch to the image to which the redo applies
		ur_undo_shiftl() ;must be performed first so as to grab the right image from IMAGE(FRAME)
		ur_redo_shiftl()
		DODRAW = "BOTH"
		For t = 0 To 6
			UR_STACK(7-t) = UR_STACK(6-t)
		Next
		UR_STACK(0) = UR_STACK(8)
		For t = 0 To 6
			DebugLog "    "+UR_STACK(t+8)
			UR_STACK(t+8) = UR_STACK(t+8+1)
			DebugLog UR_STACK(t+8)
		Next
	EndIf
End Function
Function ur_redo_count%() ;counts the number of undo types available
	DebugLog "ur_redo_count"
	Local count
	For iredo.IREDO = Each IREDO
		count=count+1
	Next
	Return count
End Function
Function ur_redo_shiftl() ;shifts all of the redo images left once, including replacing the current image with the closest redo
	DebugLog "ur_redo_shiftl"
	Local count, t
	count = ur_redo_count()
	For t = 0 To count-1
		For iredo.IREDO = Each IREDO
			If iredo\id = t+1
				If iredo\id = 1
					FreeImage(IMAGE(FRAME)) ;replace the current image handle with the undid image handle
					IMAGE(FRAME) = CopyImage(iredo\h)
					FreeImage iredo\h
					Delete iredo ;if it's the last undo in the string, then there's no point in keeping what's useless
				Else
					iredo\id = iredo\id-1 ;shifts all the other undo functions over one
				EndIf
			EndIf
		Next
	Next
End Function
Function ur_redo_shiftr() ;shifts all of the redo images away from the current image by one and places the current one in a new iredo
	;also deletes the last iredo if the iredo count is greater than toomany
	DebugLog "ur_redo_shiftr"
	Local count, t, toomany
	toomany = 8
	count = ur_redo_count()
	For t = 0 To count-1
		For iredo.IREDO = Each IREDO
			If iredo\id = (count-t)
				iredo\id = iredo\id+1
				If (count-t) &gt; toomany ;too many iredos. Kill it
					FreeImage iredo\h
					Delete iredo
				EndIf
			EndIf
		Next
	Next
	iredo.IREDO = New IREDO ;create a new iredo to hold the current image
	iredo\id = 1
	iredo\h = CopyImage(IMAGE(FRAME))
End Function
Function ur_undo() ;undoredo_undo, moves the current image into the IREDO type and replaces it with the soonest IUNDO type
	DebugLog "ur_undo"
	Local t
	If ur_undo_count() &gt; 0
		FRAME = UR_STACK(0) ;switch to the image to which the undo applies
		ur_redo_shiftr() ;must be performed first so as to grab the right image from IMAGE(FRAME)
		ur_undo_shiftr()
		DODRAW = "BOTH"
		For t = 0 To 6
			UR_STACK(15-t) = UR_STACK(14-t)
		Next
		UR_STACK(8) = UR_STACK(0)
		For t = 0 To 6
			DebugLog "    "+UR_STACK(t)
			UR_STACK(t) = UR_STACK(t+1)
			DebugLog UR_STACK(t)
		Next
		;log the undid changes
		CHANGED = CHANGED - 1
	EndIf
End Function
Function ur_undo_count%() ;counts the number of undo types available
	DebugLog "ur_undo_count"
	Local count%
	For iundo.IUNDO = Each IUNDO
		count=count+1
	Next
	Return count
End Function
Function ur_undo_shiftl() ;store a safeish copy of the current image into an undo image
	DebugLog "ur_undo_shiftl"
	Local t, toomany
	toomany = 8
	For iundo.IUNDO = Each IUNDO
		iundo\id = iundo\id+1
		If iundo\id &gt; toomany
			FreeImage iundo\h
			Delete iundo
		EndIf
	Next
	iundo.IUNDO = New IUNDO
	iundo\id = 1
	iundo\h = CopyImage(IMAGE(FRAME))
End Function
Function ur_undo_shiftr() ;shifts all of the undo images right once, including replacing the current image with the closest undo
	DebugLog "ur_undo_shiftr"
	Local count, t
	count = ur_undo_count()
	For t = 0 To count-1
		For iundo.IUNDO = Each IUNDO
			If iundo\id = t+1
				If iundo\id = 1
					FreeImage(IMAGE(FRAME)) ;replace the current image handle with the undid image handle
					IMAGE(FRAME) = CopyImage(iundo\h)
					FreeImage iundo\h
					Delete iundo ;if it's the last undo in the string, then there's no point in keeping what's useless
				Else
					iundo\id = iundo\id-1 ;shifts all the other undo functions over one
				EndIf
			EndIf
		Next
	Next
End Function
Function ur_undo_store() ;store the current image in an iundo and deletes all iredos ;called whenever the user draws something
	DebugLog "ur_undo_store"
	Local t
	;update the undo and redo images
	ur_undo_shiftl()
	For iredo.IREDO = Each IREDO
		FreeImage iredo\h
		Delete iredo
	Next
	;update UR_STACK
	For t = 0 To 6
		UR_STACK(7-t) = UR_STACK(6-t)
	Next
	UR_STACK(0) = FRAME
	For t = 8 To 15
		UR_STACK(t) = -1
	Next
	;log the changes
	CHANGED = CHANGED + 1
End Function
Function userinput_checkfunction_alt(key) ;checks for special alt key functions
	DebugLog "userinput_checkfunction_alt"
	While KeyDown(key) = 1
		;normal keydown stuff
		time 10
	Wend
End Function
Function userinput_checkfunction_ctrl(key) ;checks for special ctrl key functions
	DebugLog "userinput_checkfunction_ctrl"
	Local h, k, phrame, previous_frame, w
	phrame = FRAME ;used again at the end of the function
	While KeyDown(key) = 1
		;normal keydown stuff
		If KeyDown(12) = 1 ;-, for removing a frame (see also key 74)
			removeframe(FRAME)
			FRAME = minimum(FRAME - 1)
			draw():draw_preview():DODRAW = ""
			While KeyDown(12) = 1 time 50 Wend
		EndIf
		If KeyDown(13) = 1 ;+, for adding a frame (see also key 78)
			addframe(FRAME)
			FRAME = FRAME + 1
			draw():draw_preview():DODRAW = ""
			While KeyDown(13) = 1 time 50 Wend
		EndIf
		If KeyDown(21) = 1 ;y, for redo
			ur_redo()
			draw()
			While KeyDown(21) = 1 time 50 Wend
		EndIf
		If KeyDown(31) = 1 ;s, for save
			save
			While KeyDown(31) = 1 time 50 Wend
		EndIf
		If KeyDown(44) = 1 ;z, for undo
			ur_undo()
			draw()
			While KeyDown(44) = 1 time 50 Wend
		EndIf
		If KeyDown(46) = 1 ;c, for copy
			CopyImageToClipboard IMAGE(FRAME)
			While KeyDown(46) = 1 time 50 Wend
		EndIf
		If KeyDown(47) = 1 ;v, for paste
			tempImage = PasteImageFromClipboard()
			w = ImageWidth(IMAGE(FRAME)):h = ImageHeight(IMAGE(FRAME))
			ur_undo_store
			FreeImage IMAGE(FRAME)
			IMAGE(FRAME) = trimimage(CopyImage(tempImage), 0, 0, w, h)
			FreeImage tempImage
			DODRAW = "BOTH":draw()
			While KeyDown(47) = 1 time 50 Wend
		EndIf
		If KeyDown(74) = 1 ;-, for removing a frame (see also key 12)
			removeframe(FRAME)
			FRAME = minimum(FRAME - 1)
			draw():draw_preview():DODRAW = ""
			While KeyDown(74) = 1 time 50 Wend
		EndIf
		If KeyDown(78) = 1 ;+, for adding a frame (see also key 13)
			addframe(FRAME)
			FRAME = FRAME + 1
			draw():draw_preview():DODRAW = ""
			While KeyDown(78) = 1 time 50 Wend
		EndIf
		If KeyDown(200) = 1 ;up, for changing frames
			previous_frame = FRAME
			FRAME = 0
			If FRAME &lt;&gt; previous_frame
				draw
				draw_preview
				create_item FRAME
			EndIf
		EndIf
		If KeyDown(203) = 1 ;left
			previous_frame = FRAME
			FRAME = minimum(FRAME - 1)
			If FRAME &lt;&gt; previous_frame
				draw
				draw_preview
				create_item FRAME
			EndIf
		EndIf
		If KeyDown(205) = 1 ;right
			previous_frame = FRAME
			FRAME = maximum(FRAME+1, FRAMES-1)
			If FRAME &lt;&gt; previous_frame
				draw
				draw_preview
				create_item FRAME
			EndIf
		EndIf
		If KeyDown(208) = 1 ;down
			previous_frame = FRAME
			FRAME = FRAMES-1
			If FRAME &lt;&gt; previous_frame
				draw
				draw_preview
				create_item FRAME
			EndIf
		EndIf
		time 10
	Wend
End Function
Function userinput_checkfunction_keyboard(key) ;checks for any functions associated with the keys
	Local phrame, tempimage
	phrame = FRAME ;used again at end of function
	Select key
		Case 15 ;tab, changes the current drawing function
			changefunc
			While KeyDown(key) = 1 time 50 Wend
		Case 25 ;p, for pick color
			While MouseDown(1) = 0 And MouseDown(2) = 0 time 50 Wend ;waits for input from the mouse
			choosecolor_pick(MouseDown(1) + MouseDown(2)*2) ;picks the color of the left or right mouse buttons
		Case 29 ;ctrl key, left
			userinput_checkfunction_ctrl(key)
		Case 42 ;shift key, left
			userinput_checkfunction_shift(key)
		Case 50 ;m, for moving the image using the left mouse button
			While KeyDown(key) = 1
				time 50
				If MouseDown(1) = 1 Then move_focus 1
			Wend
		Case 54 ;shift key, right
			userinput_checkfunction_shift(key)
		Case 56 ;alt key, left
			userinput_checkfunction_alt(key)
		Case 157 ;ctrl key, right
			userinput_checkfunction_ctrl(key)
		Case 184 ;alt key, right
			userinput_checkfunction_alt(key)
		Case 200 ;up, for changing frames
			shift_preview FRAME, 0
			If FRAME &lt;&gt; 0 Then DODRAW = "BOTH"
			FRAME = 0
			create_item FRAME
		Case 203 ;left
			shift_preview FRAME, minimum(FRAME-1)
			If FRAME &lt;&gt; minimum(FRAME - 1) Then DODRAW = "BOTH"
			FRAME = minimum(FRAME - 1)
			create_item FRAME
		Case 205 ;right
			shift_preview FRAME, maximum(FRAME+1, FRAMES-1)
			If FRAME &lt;&gt; maximum(FRAME+1, FRAMES-1) Then DODRAW = "BOTH"
			FRAME = maximum(FRAME+1, FRAMES-1)
			create_item FRAME
		Case 208 ;down
			shift_preview FRAME, FRAMES-1
			If FRAME &lt;&gt; FRAMES-1 Then DODRAW = "BOTH"
			FRAME = FRAMES-1
			create_item FRAME
	End Select
End Function
Function userinput_checkfunction_shift(key) ;checks for special alt key functions
	While KeyDown(key) = 1
		;normal keydown stuff
		If KeyDown(15) = 1 ;tab, changes the current drawing function
			changefunc_initiate_shift
			While KeyDown(key) = 1 time 50 Wend
		EndIf
		;mouse stuff
		If MouseDown(1) = 1 Or MouseDown(2) = 1
;			choosecolor_pallet_initiate_ctrlkey ;replaced by double clicking off of the image (double clicking is more reliable)
			If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
				If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
					choosecolor_eyedropper MouseDown(1)+MouseDown(2)*2
				EndIf
			EndIf
		EndIf
		time 10
	Wend
End Function
Function userinput_checkfunction_menu() ;checks for functions related to the user's input (d is for eventdata=the menu id)
	DebugLog "userinput_checkfunction_menu"
	Local d% = EventData%(), t%
	Select d
	Case 1 ;MFILE menu
		Case 11 ;new menu
			new_file
		Case 12 ;open menu
			open
 		Case 13 ;save menu
			save
		Case 14 ;save as menu
			save 1
		Case 15 ;exit menu
			Return 1
	Case 2 ;MFRAME menu
		Case 21 ;previous menu
			If FRAME &gt; 0
				FRAME = FRAME-1
				create_item FRAME
				DODRAW = "BOTH"
			EndIf
		Case 22 ;jump to... menu
			If FRAME &gt; FRAMES/2 Then t = 0 Else t = FRAMES-1
			jump_frame t ;presents a windowed menu, giving the user the option of which frame they would like to go to
		Case 23 ;next menu
			If FRAME &lt; FRAMES-1
				FRAME = FRAME+1
				create_item FRAME
				DODRAW = "BOTH"
			EndIf
		Case 24 ;add frame menu
			addframe(FRAME)
			FRAME = FRAME + 1
		Case 25 ;remove frame menu
			removeframe(FRAME)
			FRAME = minimum(FRAME - 1)
	Case 3 ;MIMAGE menu
		Case 31 ;copy menu
			CopyImageToClipboard IMAGE(FRAME)
		Case 32 ;paste menu
			tempImage = PasteImageFromClipboard()
			w = ImageWidth(IMAGE(FRAME)):h = ImageHeight(IMAGE(FRAME))
			ur_undo_store
			FreeImage IMAGE(FRAME)
			IMAGE(FRAME) = trimimage(CopyImage(tempImage), 0, 0, w, h)
			FreeImage tempImage
			DODRAW = "BOTH":draw()
		Case 33 ;set size menu
			resize_images ImageWidth(IMAGE(0)), ImageHeight(IMAGE(0))
		Case 34 ;draw preview menu
			PREVIEW = Not(PREVIEW)
			menu_update() ;checks and disables certain menus, also saves changed program options
			If DODRAW = "" Then DODRAW = "CAN1"
			If DODRAW = "PREVIEW" Then DODRAW = "BOTH"
		Case 35 ;draw postview menu
			POSTVIEW = Not(POSTVIEW)
			menu_update() ;checks and disables certain menus, also saves changed program options
			If DODRAW = "" Then DODRAW = "CAN1"
			If DODRAW = "PREVIEW" Then DODRAW = "BOTH"
	Case 4 ;MPF menu (Paint Functions)
		Case 41 ;circle menu
			changefunc "CIRCLE"
			menu_update
		Case 42 ;flood fill menu
			changefunc "FILL"
			menu_update
		Case 43 ;line menu
			changefunc "LINE"
			menu_update
		Case 44 ;pencil menu
			changefunc "PENCIL"
			menu_update
		Case 45 ;rectangle menu
			changefunc "RECTANGLE"
			menu_update
		Case 46 ;scale menu
			changefunc "SCALE"
			menu_update
		Case 47 ;eye dropper, for gather color data for the mouse from the image
			While MouseDown(1) = 1 Or MouseDown(2) = 1 time 30 Wend
			While MouseDown(1) = 0 And MouseDown(2) = 0 time 30 Wend
			While MouseDown(1) = 1 Or MouseDown(2) = 1 choosecolor_eyedropper(MouseDown(1)+MouseDown(2)*2) Wend
		Case 48 ;choose mouse colors
			While MouseDown(1) = 0 And MouseDown(2) = 0 killitems:create_item "Press Mouse":time 30 Wend
			choosecolor_pallet MouseDown(1)+MouseDown(2)*2
			draw
			While MouseDown(1) = 1 Or MouseDown(2) = 1 killitems:create_item "Release Mouse":time 30 Wend
		Case 49 ;options menu
		Case 490 ;fill menu, of options menu
			FILLED = Not(FILLED)
			menu_update() ;checks and disables certain menus
	Case 5 ;MOPT options menu, for controling global options
		Case 51 ;alpha menu
			ALPHA = Not(ALPHA)
			draw_preview
			menu_update() ;checks and disables certain menus, also saves changed program options
		Case 52 ;eyecandy menu
			EYECANDY = Not(EYECANDY)
			menu_update() ;checks and disables certain menus, also saves changed program options
	Case 6 ;help menu
		Case 61 ;shortcuts menu
			If FileType("help/help.html") = 1
				ExecFile "help\help.html"
			Else
				Notify "Could not find file "+Chr(34)+"help/help.html"+Chr(34), 1
			EndIf
		Case 62 ;about menu
			print_about
	End Select
	While EventID() = $1001
		WaitEvent()
	Wend
	Return 0
End Function
Function userinput_checkfunction_mouse1(p=1) ;checks the functions associated with pressing the left mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse1"
	Local phrame, x%, w#
	phrame = FRAME ;used again at end of function
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				paintfunctions(1) ;let the drawing commence!
			Else
				userinput_checkfunction_mouse1_dblclick()
			EndIf
		Else
			userinput_checkfunction_mouse1_dblclick()
		EndIf
	Else ;functions for the PREVIEW_CANVAS canvas
		w = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
		x = minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ;the frame currently highlighted by the mouse
		create_item x
		shift_preview FRAME, x
		If x &lt;&gt; FRAME Then DODRAW = "BOTH"
		If x &gt;= 0 And x &lt; FRAMES Then FRAME = x
		While MouseDown(1)=1 time(50) Wend
	EndIf
	MXPREVIOUS=MXPREVIOUS-1 ;to force a recalculation of the mouse over function (userinput_checkfunction_mousemoved())
	MYPREVIOUS=MYPREVIOUS-1
End Function
Function userinput_checkfunction_mouse1_dblclick() ;checks the functions related to double clicking the mouse in the CAN1 canvas off of any image
	Local t = MilliSecs()
	While MouseDown(1) = 1 time 30 Wend
	Repeat
		If MilliSecs()-t &gt; 200 Or MouseDown(1) = 1 Then Exit
	Forever
	If MilliSecs()-t &gt; 200
		Return 0
	Else
		choosecolor_pallet 1
		Return 1
	EndIf
	While MouseDown(1) = 1 Or MouseDown(2) = 1
		killitems
		create_item "Press Mouse"
		time 30
	Wend
End Function
Function userinput_checkfunction_mouse2(p=1) ;checks the functions associated with pressing the right mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse2"
	Local phrame, a%, b%, x%, w#
	phrame = FRAME ;used again at end of function
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				paintfunctions(2) ;let the drawing commence!
			Else
				userinput_checkfunction_mouse2_dblclick()
			EndIf
		Else
			userinput_checkfunction_mouse2_dblclick()
		EndIf
	Else ;functions for the PREVIEW_CANVAS canvas
		a = ALPHA:ALPHA = 0 ;same as the left mouse button function, but without the Alpha or Eyecandy functionality
		b = EYECANDY:EYECANDY = 0
		w = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
		x = minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ;the frame currently highlighted by the mouse
		create_item x
		shift_preview FRAME, x
		If x &lt;&gt; FRAME Then DODRAW = "BOTH"
		If x &gt;= 0 And x &lt; FRAMES Then FRAME = x
		While MouseDown(1)=1 time(50) Wend
		ALPHA = a
		EYECANDY = b
	EndIf
End Function
Function userinput_checkfunction_mouse2_dblclick() ;checks the functions related to double clicking the mouse in the CAN1 canvas off of any image
	Local t = MilliSecs()
	While MouseDown(2) = 1 time 30 Wend
	Repeat
		If MilliSecs()-t &gt; 200 Or MouseDown(2) = 1 Then Exit
	Forever
	If MilliSecs()-t &gt; 200
		Return 0
	Else
		choosecolor_pallet 2
		Return 1
	EndIf
	While MouseDown(2) = 1
		killitems
		create_item "Press Mouse"
		time 30
	Wend
End Function
Function userinput_checkfunction_mouse3(p=1) ;checks for the functions associated with pressing the middle mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse3"
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				If MilliSecs() - LT_MD3 &lt;= 200
					FOCUSX = ImageWidth(IMAGE(FRAME))/2
					FOCUSY = ImageHeight(IMAGE(FRAME))/2
					DODRAW = "CAN1"
				Else
					move_focus(3) ;changes the FOCUSX and FOCUSY variables, thereby changing where the image is drawn
				EndIf
			EndIf
		EndIf
	Else ;the PREVIEW_CANVAS canvas
	EndIf
	LT_MD3 = MilliSecs()
End Function
Function userinput_checkfunction_mousemoved() ;checks for any functions related to the changed position of the mouse
	DebugLog "userinput_checkfunction_mousemoved"
	Local x%,y%,w# = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				x = getx()
				y = gety()
				set_windowtext_right "("+x+", "+y+")"
			Else
				set_windowtext_right ( "FRAME " + minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ) ;FRAME: + (MouseX-(widthofpreviewrect)/2)/(widthofpreviewrect)
			EndIf
		Else
			set_windowtext_right ( "FRAME " + minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ) ;FRAME: + (MouseX-(widthofpreviewrect)/2)/(widthofpreviewrect)
		EndIf
	Else ;functions for teh PREVIEW_CANVAS canvas
		set_windowtext_right ( "FRAME " + minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ) ;FRAME: + (MouseX-(widthofpreviewrect)/2)/(widthofpreviewrect)
	EndIf
End Function
Function userinput_checkfunction_mousemoved_z() ;checks for functions related to the user scrolling the mouse middle button
	DebugLog "userinput_checkfunction_mousemoved"
	Local t%, s% ;s stands for speed
	s = MZ - MouseZ()
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If SCALE + s &gt;= 1 And SCALE &gt;= 1
			SCALE = SCALE + s
		Else
			If SCALE &lt; 1.0
				SCALE = maximum(SCALE * 2^s, 1.0)
			Else
				SCALE = 0.5
			EndIf
		EndIf
		If SCALE = 0
			SCALE = 0.5
		EndIf
		If ImageWidth(IMAGE(FRAME))*SCALE&lt;=4 Or ImageHeight(IMAGE(FRAME))*SCALE&lt;=4 Then SCALE = SCALE*2
		If SCALE &gt;= 10 Then SCALE = 10
		Local name$ = SCALE
		create_item name
		DODRAW = "CAN1"
	Else ;functions for teh PREVIEW_CANVAS canvas
		t = FRAME
		FRAME = maximum(minimum(FRAME + s), FRAMES - 1)
		If t &lt;&gt; FRAME ;if the frame has changed
			DODRAW = "BOTH"
		EndIf
	EndIf
	MZ = MouseZ()
End Function
;---------------------
</textarea><br><br>Thanks again. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
