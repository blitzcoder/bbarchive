<!DOCTYPE html><html lang="en" ><head ><title >Need Help, Memory, GAH!</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Need Help, Memory, GAH!</h1><a href="forums.php" >BlitzPlus Forums</a>/<a href="topics.php?forum=81" >BlitzPlus Programming</a>/<a href="#bottom" >Need Help, Memory, GAH!</a><br><br>
<a name="983361"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gladclef - Ben B</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm trying to write a program that lets you animate 2D animations frame-by-frame. The only problem (currently), is that half-way through execution, the program breaks down and starts using up memory like crazy. If you guys wouldn't mind helping me out... What the heck is eating up all of that memory?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;------NOTES------
;this program is intended for the publication of game sequence animations with less-than basic paint functionality
;all global variables and lables and types are capitalized, all locals and functions are lowercase
;more paint tools to come
;-----------------
;------WINDOW VARIABLES------
Global WIDTH = GadgetWidth(Desktop()) ;normal window
Global HEIGHT = GadgetHeight(Desktop())
Global WIN1 = CreateWindow("New File: Game_Animatory v0.00",WIDTH/4,HEIGHT/4,WIDTH/2,minimum(HEIGHT/2,308),0,15)
Global CAN1 = CreateCanvas(0,0,ClientWidth(WIN1),ClientHeight(WIN1)-116,WIN1)
Global CAN2 ;for use in resize_maincanvases
Global PREVIEW_CANVAS = CreateCanvas(0,ClientHeight(WIN1)-116,ClientWidth(WIN1),116,WIN1)
SetMinWindowSize WIN1,500,308
SetGadgetLayout CAN1,1,1,1,1
SetGadgetLayout PREVIEW_CANVAS,1,1,0,1
;----------------------------
;------GLOBAL VARIABLES------
Global ALPHA = 1 ;if 1, then images are alpha'd before drawn (specifically the preview images)
Global BORDER_IMAGE = CreateImage(104,104) ;used to draw a border around the image in the editor
Global BUFFER = CanvasBuffer(CAN1) ;holds the handle of the current buffer
Global COL_LEFT = -1 ;the foreground drawing color, -16777216=black, -1=white
Global COL_RIGHT = -6777216 ;the background drawing color, -16777216=black, -1=white
Global DIRECTORY$ = CurrentDir$() ;the directory of the current project
Global DODRAW$ = "BOTH" ;the screen (BOTH/CAN1/PREVIEW) is redrawn only if DODRAW is true
Global DRAWN = 0 ;whether to draw the next frame, alpha lite, in front of the current frame
Global DRAWP = 0 ;whether to draw the previous frame, alpha lite, behind the current frame
Global EYECANDY = 1 ;stuff that makes the program look pretty (including shift_preview)
Global FOCUSX = 50 ;the focus point of the image, for when it doesn't fit in the drawing window
Global FOCUSY = 50 ;the focus point of the image, for when it doesn't fit in the drawing window
Global FONT = LoadFont("COURIER",12)
Global FONT_BIG = LoadFont("COURIER",102)
Global FRAME = 9 ;the current frame
Global FRAMES = 19 ;the total number of frames
Global FUNC$ = "SCALE" ;the current function used for drawing (can be PENCIL, SCALE)
;Const  GWL_EXSTYLE = -20 ;for the setwintransparenz function
Dim    IMAGE(19) ;the handle of the main images
Global MXOFFSET = 0 ;the offset of the mousex() (the difference between the x coordinate of the window and the x coordinate of the window
Global MYDIRECTORY$ = CurrentDir$() ;the directory in which is located the program
Global MYOFFSET = 0 ;the offset of the mousey()
Global MXPREVIOUS = 0 ;the previous recorded x location of the mouse
Global MYPREVIOUS = 0 ;the previous recorded y location of the mouse
Global NAME$ = "New File" ;the title of the current project
Global SCALE# = 3.0 ;for zooming in/out ;a direct translation (2.0 is twice as big &lt;&gt; 200 (for percent))
Global TIMER = 0 ;delays the program until millisecs() &gt; TIMER
Global WINX = GadgetX(WIN1) ;to be used as a x refference point in check_windowmoved
Global WINY = GadgetY(WIN1) ;to be used as a y refference point in check_windowmoved
Global WINW = GadgetWidth(WIN1) ;to be used as a width refference point in check_windowmoved
Global WINH = GadgetHeight(WIN1) ;to be used as a height refference point in check_windowmoved
Global WTEXT$ = "SCALE  " ;the current window text (see the set_windowtext_right/set_windowtext_left functions)
;----------------------------
;------TYPES------
Type ITEM ;used to display the neat disapearing text
	Field name$
	Field x#
	Field y#
	Field life_start#
	Field life_end#
	Field image%
End Type
;------PRE_START------
calculate_offsets() ;for MXOFFSET and MYOFFSET
IMAGE(0) = CreateImage(100,100) ;the image for the first frame
SeedRnd(MilliSecs())
SetBuffer(ImageBuffer(IMAGE(0)))
For TIMER = 0 To ImageHeight(IMAGE(0))
	Color Rand(255),Rand(255),Rand(255)
	Line 0,TIMER,ImageWidth(IMAGE(0)),TIMER
Next
For tempx=1 To 18
IMAGE(tempx) = CreateImage(100,100) ;the image for the first frame
SetBuffer(ImageBuffer(IMAGE(tempx)))
For TIMER = 0 To ImageHeight(IMAGE(tempx))
	Color Rand(255),Rand(255),Rand(255)
	Line 0,TIMER,ImageWidth(IMAGE(tempx)),TIMER
Next
Next
SetBuffer(BUFFER)
calculate_borderimage() ;for the BORDER_IMAGE
resize_images(1) ;fast/slow
update_overlay(1) ;updates the overlay window ;resize and reposition too
;---------------------
;------------------------
;------MAIN PROGRAM------
;------------------------
While KeyDown(1)=0
	DebugLog "main"
	time(50) ;delays the program so as not to eat up processor power, including gathering user input
	check_keyboard() ;checks if there is a keyboard button being pressed
	check_mouse() ;checks to see if the user has moved the mouse/pushed a mouse button
	check_windowmoved() ;if the window has been moved or resized, several processes must be called (including update_overlay())
	If DODRAW="BOTH" Or DODRAW="CAN1" Then draw() ;DODRAW is set to either "PREVIEW" or "", depending
	If DODRAW="BOTH" Or DODRAW="PREVIEW" Then draw_preview() ;DODRAW is set to either "CAN1" or "", depending
	For ITEM.ITEM=Each ITEM
		DebugLog ITEM\name
		draw_item(ITEM\name)
	Next
	Select EventID()
		Case $803 ;big red button
			Exit
	End Select
Wend
finish()
;------------------------
;------------------------
;------------------------
;------FUNCTIONS------
Function alphaimage(image1,shade#,percent#) ;alphas an image to white (shade=100) or black (shade=0) by a percent value and returns the distorted image
	DebugLog "alphaimage"
	Local tempx,tempy,tempcolor
	If ALPHA = 1
		LockBuffer ImageBuffer(image1)
		For tempx=0 To ImageWidth(image1)-1
			For tempy=0 To ImageHeight(image1)-1
				tempcolor=ReadPixelFast(tempx,tempy,ImageBuffer(image1))
				WritePixelFast tempx,tempy, getcolorback( getred(tempcolor)+(shade*255.0/100.0-getred(tempcolor))*percent/100.0 , getgreen(tempcolor)+(shade*255.0/100.0-getgreen(tempcolor))*percent/100.0 , getblue(tempcolor)+(shade*255.0/100.0-getblue(tempcolor))*percent/100.0 ), ImageBuffer(image1)
			Next
		Next
		UnlockBuffer ImageBuffer(image1)
		Return image1
		FreeImage image1
	Else
		Return image1
		FreeImage image1
	EndIf
End Function
Function calculate_offsets() ;finds the differences between the window and canvas coordinates
	DebugLog "calculate_offsets"
	Local a,b,px,py,timer
	a=MouseX(CAN1)
	b=MouseY(CAN1)
	px=MouseX()
	py=MouseY()
	timer=MilliSecs()+100
	While MouseX(CAN1)=a And MouseY(CAN1)=b ;guarantees that the mouse hits the canvas
		If timer&lt;MilliSecs() Then Exit
		If MouseX(CAN1) = a Then MoveMouse(Rand(ClientWidth(Desktop())),MouseY())
		If MouseY(CAN1) = b Then MoveMouse(MouseX(),Rand(ClientHeight(Desktop())))
	Wend
	a = MouseX()
	While MouseX(CAN1)&gt;0 ;
		MoveMouse(MouseX()-1,MouseY())
		If MouseX()&lt;=0 Then Exit ;the &lt; is just for safety
		If MouseX() = a Then Exit Else a = MouseX() ;again, just safety
	Wend
	b = MouseY()
	While MouseY(CAN1)&gt;0
		MoveMouse(MouseX(),MouseY()-1)
		If MouseY()&lt;=0 Then Exit ;the &lt; is just for safety
		If MouseY() = b Then Exit Else b = MouseY() ;again, just safety
	Wend
	MXOFFSET=minimum(MouseX()-GadgetX(win1))
	MYOFFSET=minimum(MouseY()-GadgetY(win1))
	If MXOFFSET = 0 Then MXOFFSET = 4 ;these values were gained from a successful run
	If MYOFFSET = 0 Then MYOFFSET = 50 ;these values were gained from a successful run
	MoveMouse(px,py)
End Function
Function calculate_borderimage() ;draws the BORDER_IMAGE, which creates a border so that it's easy for the user to tell what it is they're editing
	DebugLog "calculate_borderimage"
	Local b,g,r,t,x#,y#
	LockBuffer ImageBuffer(IMAGE(FRAME))
	LockBuffer ImageBuffer(BORDER_IMAGE)
	For x = 0 To 1
		If x = 1 Then x = ImageWidth(IMAGE(FRAME))-1
		For y = 0 To ImageHeight(IMAGE(FRAME))-1
			t = ReadPixelFast(x, y, ImageBuffer(IMAGE(FRAME)))
			r = getred(t)
			g = getgreen(t)
			b = getblue(t)
;			If r&lt;100 Or r&gt;155 Then r = 255-r Else r = r+100
;			If g&lt;100 Or g&gt;155 Then g = 255-g Else g = g+100
;			If b&lt;100 Or b&gt;155 Then b = 255-b Else b = b+100
			r = 255-r
			g = 255-g
			b = 255-b
	;		t = getcolorback(r, g, b)
			t = getcolorback(255, 255, 255)
;			WritePixelFast x+3*Ceil(x/ImageWidth(IMAGE(FRAME))), y+1, t, ImageBuffer(BORDER_IMAGE)
;			WritePixelFast x+3*Ceil(x/ImageWidth(IMAGE(FRAME)))+1, y+1, t, ImageBuffer(BORDER_IMAGE)
			WritePixelFast x+4*Ceil(x/ImageWidth(IMAGE(FRAME))), y+2, t, ImageBuffer(BORDER_IMAGE)
		Next
	Next
	For x = 0 To ImageWidth(IMAGE(FRAME))-1
		For y = 0 To 1
			If y = 1 Then y = ImageHeight(IMAGE(FRAME))-1
			t = ReadPixelFast(x, y, ImageBuffer(IMAGE(FRAME)))
			r = getred(t)
			g = getgreen(t)
			b = getblue(t)
;			If r&lt;100 Or r&gt;155 Then r = 255-r Else r = r+100
;			If g&lt;100 Or g&gt;155 Then g = 255-g Else g = g+100
;			If b&lt;100 Or b&gt;155 Then b = 255-b Else b = b+100
			r = 255-r
			g = 255-g
			b = 255-b
	;		t = getcolorback(r, g, b)
			t = getcolorback(255, 255, 255)
;			WritePixelFast x+1, y+2*Ceil(y/ImageHeight(IMAGE(FRAME))), t, ImageBuffer(BORDER_IMAGE)
			WritePixelFast x+2, y+4*Ceil(y/ImageHeight(IMAGE(FRAME))), t, ImageBuffer(BORDER_IMAGE)
		Next
	Next
	t = getcolorback(255,255,255)
	For x = 0 To 1
		For y = 0 To 1
			WritePixelFast x*ImageWidth(BORDER_IMAGE)+1-3*x, y*ImageHeight(BORDER_IMAGE)+1-3*y, t, ImageBuffer(BORDER_IMAGE)
		Next
	Next
	WritePixelFast 1, ImageHeight(BORDER_IMAGE)/2, t, ImageBuffer(BORDER_IMAGE)
	WritePixelFast ImageWidth(BORDER_IMAGE)-2, ImageHeight(BORDER_IMAGE)/2, t, ImageBuffer(BORDER_IMAGE)
	WritePixelFast ImageWidth(BORDER_IMAGE)/2, 1, t, ImageBuffer(BORDER_IMAGE)
	WritePixelFast ImageWidth(BORDER_IMAGE)/2, ImageHeight(BORDER_IMAGE)-2, t, ImageBuffer(BORDER_IMAGE)
	UnlockBuffer ImageBuffer(IMAGE(FRAME))
	UnlockBuffer ImageBuffer(BORDER_IMAGE)
End Function
Function check_keyboard() ;checks if there is a response from the keyboard
End Function
Function check_mouse() ;checks to see if the user has moved the mouse/pushed a mouse button
	DebugLog "check_mouse"
	If MouseDown(1)=1
		userinput_checkfunction_mouse1()
	EndIf
	If MouseDown(2)=1
		userinput_checkfunction_mouse2()
	EndIf
	If MouseDown(3)=1
		userinput_checkfunction_mouse3()
	EndIf
	If MouseX()&lt;&gt;MXPREVIOUS Or MouseY()&lt;&gt;MYPREVIOUS
		userinput_checkfunction_mousemoved()
		MXPREVIOUS = MouseX()
		MYPREVIOUS = MouseY()
	EndIf
	While MouseDown(1)=1 time(50) Wend
	While MouseDown(2)=1 time(50) Wend
End Function
Function check_windowmoved() ;checks if the main (WIN1) window has either been moved or resized
	DebugLog "checkwindowmoved"
	;if it has, then the contained functions must be called
	If  (WINX&lt;&gt;GadgetX(WIN1))  Or  (WINY&lt;&gt;GadgetY(WIN1))  Or  (WINW&lt;&gt;ClientWidth(WIN1))  Or  (WINH&lt;&gt;ClientHeight(WIN1))
		;update the variables
		WINX=GadgetX(WIN1):WINY=GadgetY(WIN1):WINW=minimum(ClientWidth(WIN1),1):WINH=minimum(ClientHeight(WIN1),1)
		;--------------------
		;call the functions
		If  (WINW&lt;&gt;GadgetWidth(WIN1))  Or  (WINH&lt;&gt;GadgetHeight(WIN1)) Then resize_maincanvases(WINW,WINH) ;called because there indeed two main canvases (CAN1 and PREVIEW_CANVAS)
		;------------------
		;call the draw function from the main program
		DODRAW="BOTH"
	EndIf
End Function
Function create_item(name$=":)", x#=0, y#=0, life_start#=-1, life_end#=-1, image=0, kill=1, draw=1) ;used as a function to easily create items
	If life_start = -1 Then life_start = MilliSecs()
	If life_end = -1 Then life_end = MilliSecs()+500
	If kill = 1 Then killitems() ;releases all of the current items
	item.ITEM = New ITEM ;to be drawn to let the user know what the current scale is
	item\name = name
	item\life_start = life_start
	item\life_end = life_end
	item\image = image
	If draw = 1 Then draw_item item\name
End Function
Function draw() ;draws the main (CAN1) program
	DebugLog "draw"
	Local x, y
	SetBuffer (CanvasBuffer(CAN1))
	Cls
	;calculate x and y
	x = GadgetWidth(CAN1)/2-FOCUSX*SCALE
	y = GadgetHeight(CAN1)/2-FOCUSY*SCALE
	;-----------------
	;draws the previous frame
	;------------------------
	;draws a border around the image
	If SCALE &lt;&gt; 1.0
;		DrawImage scaleimagefast(BORDER_IMAGE,SCALE,SCALE), GadgetWidth(CAN1)/2-ImageWidth(IMAGE(FRAME))/2*SCALE-2*SCALE, GadgetHeight(CAN1)/2-ImageHeight(IMAGE(FRAME))/2*SCALE-2*SCALE
		Local tempScaledImage = scaleimagefast(BORDER_IMAGE,SCALE,SCALE); , )
		DrawImage(tempScaledImage, x-2*SCALE, y-2*SCALE)
		FreeImage(tempScaledImage)
	Else
		DrawImage BORDER_IMAGE, x-2, y-2
	EndIf
	;-------------------------------
	;draws the image
	If SCALE &lt;&gt; 1.0
;		DrawImage scaleimagefast(IMAGE(FRAME),SCALE,SCALE), GadgetWidth(CAN1)/2-ImageWidth(IMAGE(FRAME))/2*SCALE, GadgetHeight(CAN1)/2-ImageHeight(IMAGE(FRAME))/2*SCALE
		Local tempImage=scaleimagefast(IMAGE(FRAME),SCALE,SCALE)
		DrawImage tempImage, x, y
		FreeImage(tempImage)
	Else
		DrawImage IMAGE(FRAME), x, y
	EndIf
	;---------------
	;draws the items, so that they don't flash
	For item.item=Each item
		draw_item item\name
	Next
	;-----------------------------------------
	FlipCanvas (CAN1)
	SetBuffer (BUFFER)
	If DODRAW = "CAN1" Then DODRAW = ""
	If DODRAW = "BOTH" Then DODRAW = "PREVIEW"
End Function
Function draw_item(i$) ;draws the current item according to it's life
	Local c
	For item.ITEM = Each ITEM
		If item\name=i Then Exit
	Next
	SetBuffer CanvasBuffer(CAN1)
	If MilliSecs() &lt;= item\life_end
		c = 255-minimum( (MilliSecs()-item\life_start)/(item\life_end-item\life_start)*255 )
		Color c,c,c
		SetFont FONT_BIG
		Text item\x,item\y,item\name
	Else
		Color 0,0,0
		Text item\x,item\y,item\name
	EndIf
	FlipCanvas CAN1
	SetBuffer BUFFER
	SetFont FONT
	killitems(1)
End Function
Function draw_preview(drawwhich=0, a=0, b=0) ;draws the preview of the frames; can be 0(all), 1(center), 2(none), 3(simple rectangles), or 4(from frame a to frame b)
	DebugLog "draw_preview"
	Local frame# = FRAME
	Local x,y,w
	If drawwhich = 0  And  MouseDown(1) = 1
		drawwhich = 3
	EndIf
	w = ImageWidth(IMAGE(FRAME)) * (100.0/ImageHeight(IMAGE(FRAME)))
	x = GadgetWidth(PREVIEW_CANVAS)/2 - w/2
	y = 8
	SetBuffer (CanvasBuffer(PREVIEW_CANVAS))
	Cls
	;draw the images previous to the current
	If drawwhich = 0 Or drawwhich = 3
		For tempx = 1 To Ceil(GadgetWidth(PREVIEW_CANVAS)/2/(w+8))
			If dodraw &lt;&gt; 3 Then
				Local tempImage=scaleimagefast_bypixels(IMAGE(minimum(FRAME-tempx)),w,100)
				DrawBlock alphaimage(tempImage,0,30), x-(w+8)*tempx, y Else Color 155,155,155:Rect x-(w+8)*tempx,y,w,100,1
				FreeImage tempImage
			EndIf
		Next
	EndIf
	;---------------------------------------
	;draw the image for the current frame
	If dodraw &lt;&gt; 0
		If dodraw &lt;&gt; 3 Then 
			Local tempImage2=scaleimagefast_bypixels(IMAGE(FRAME),w,100)
			DrawBlock alphaimage(tempImage2,100,30), x, y Else Color 255,255,255:Rect x,y,w,100,1
			FreeImage(tempImage2)
		EndIf
	EndIf
	;------------------------------------
	;draw the images following the current
	If drawwhich = 0 Or drawwhich = 3
		For tempx = 1 To Ceil(GadgetWidth(PREVIEW_CANVAS)/2/(w+8))
			If dodraw &lt;&gt; 3 Then
				Local tempImage3=scaleimagefast_bypixels(IMAGE(maximum(FRAME+tempx,FRAMES-1)),w,100)
				DrawBlock alphaimage(tempImage3 ,0,30), x+(w+8)*(tempx), y 
				FreeImage(tempImage3)
			Else 
				Color 155,155,155:Rect x-(w+8)*tempx,y,w,100,1
			EndIf
		Next
	EndIf
	;-------------------------------------
	FlipCanvas (PREVIEW_CANVAS)
	SetBuffer (BUFFER)
	If DODRAW = "PREVIEW" Then DODRAW = ""
	If DODRAW = "BOTH" Then DODRAW = "CAN1"
End Function
Function finish() ;quits the program, executing the necessary commands to free up image banks nad whatnot
	DebugLog "finish"
	For FRAME = 0 To FRAMES-1
		FreeImage IMAGE(FRAME)
	Next
	FreeImage BORDER_IMAGE
	FreeFont FONT
	FreeFont FONT_BIG
	killitems()
	End
End Function
Function getblue#(col#)
	Return col And $FF 
End Function 
Function getcolorback(r,g,b) ;returns a readpixel type value
	Return (b Or (g Shl 8) Or (r Shl 16) Or (255 Shl 24)) 
End Function
Function getgreen#(col#)
	Return  (col Shr 8) And $FF
End Function
Function getred#(col#)	
	Return (col Shr 16) And $FF 
End Function
Function killitems(t=0) ;releases all of the current items ;relative to time (will only kill items that have expired)
	For item.ITEM = Each ITEM
		If t=1
			If item\life_end&lt;MilliSecs()
				If item\image&lt;&gt;0 Then FreeImage item\image
				Delete item
				If DODRAW = "" Then DODRAW = "CAN1"
			EndIf
		Else
			If item\image&lt;&gt;0 Then FreeImage item\image
			Delete item
			If DODRAW = "" Then DODRAW = "CAN1"
		EndIf
	Next
End Function
Function minimum#(x#,y#=0.0) ;if x&lt;y, then the function returns y instead
	DebugLog "minimum"
	If x &lt; y
		Return y
	Else
		Return x
	EndIf
End Function
Function maximum#(x#,y#=255.0) ;if x&gt;y, then the function returns y instead
	DebugLog "maximum"
	If x &gt; y
		Return y
	Else
		Return x
	EndIf
End Function
Function padl$(t$,p = 1) ;pads the left side of string t with spaces up until the string is as long as p
	While Len(t)&lt;p
		t = " "+t
	Wend
	Return t
End Function
Function padr$(t$,p = 1) ;pads the right side of string t with spaces up until the string is as long as p
	While Len(t)&lt;p
		t = t+" "
	Wend
	Return t
End Function
Function paintfunctions(md#=1.0) ;let the drawing commence! (which mouse button is pressed)
	DebugLog "paintfunctions"
	If md&gt;0
		While MouseDown(md) = 1
			Select FUNC ;the various tools
				Case "PENCIL"
				Case "SCALE"
			End Select
		Wend
		Select FUNC ;the various tools
			Case "PENCIL"
			Case "SCALE"
				If SCALE&gt;=1
					If md = 1 Then SCALE = SCALE + 1
					If md = 2 Then SCALE = SCALE - 1
				Else
					If md = 1 Then SCALE = SCALE * 2
					If md = 2 Then SCALE = SCALE / 2
				EndIf
				If SCALE = 0
					SCALE = 0.5
				EndIf
				If ImageWidth(IMAGE(FRAME))*SCALE&lt;=2 Or ImageHeight(IMAGE(FRAME))*SCALE&lt;=2 Then SCALE = SCALE*2
				If SCALE &gt;= 10 Then SCALE = 10
				Local name$ = SCALE
				create_item name
				DODRAW = "CAN1"
		End Select
	EndIf
End Function
Function resize_images(f=0) ;checks for the need to and resizes the images
	DebugLog "resize_images"
End Function
Function resize_maincanvases(w=500,h=308) ;called if the case that the main (WIN1) window has been resized
	DebugLog "resize_maincanvases"
	Local image1
	;if the main window(WIN1) is less than twice the height of the preview canvas, then it is resized to fit that shape
;	If ClientHeight(WIN1)&lt;GadgetHeight(PREVIEW_CANVAS)*2 Then SetGadgetShape WIN1,GadgetX(WIN1),GadgetY(WIN1),GadgetWidth(WIN1),minimum(GadgetHeight(WIN1)+1,GadgetHeight(PREVIEW_CANVAS)*2)
	;------------------------------------------------------------------------------------------------------------------
	;resize the "main" main canvas (CAN1)
	image1 = CreateImage(GadgetWidth(CAN1),GadgetHeight(CAN1))
	CopyRect 0,0,GadgetWidth(CAN1),GadgetHeight(CAN1),0,0,CanvasBuffer(CAN1),ImageBuffer(image1)
	CAN2 = CAN1 ;1, these four steps create a new canvas of the correct dimensions
	CAN1 = CreateCanvas(0,0,ClientWidth(WIN1),ClientHeight(WIN1)-116,WIN1) ;2
	Local tempImage=scaleimagefast_bypixels(image1,w,h-GadgetHeight(PREVIEW_CANVAS))
	CopyRect 0,0,w,h-GadgetHeight(PREVIEW_CANVAS),0,0,ImageBuffer(tempImage),CanvasBuffer(CAN1)
	FreeImage(tempImage)
	FreeGadget CAN2 ;3
	BUFFER = CanvasBuffer(CAN1) ;4
	FreeImage image1
	;------------------------------------
	;resize the preview canvas (PREVIEW_CANVAS)
	image1 = CreateImage(GadgetWidth(PREVIEW_CANVAS),GadgetHeight(PREVIEW_CANVAS))
	CopyRect 0,0,GadgetWidth(PREVIEW_CANVAS),GadgetHeight(PREVIEW_CANVAS),0,0,CanvasBuffer(PREVIEW_CANVAS),ImageBuffer(image1)
	CAN2 = PREVIEW_CANVAS ;1, these three steps create a new canvas of the correct dimensions
	PREVIEW_CANVAS = CreateCanvas(0,ClientHeight(WIN1)-116,ClientWidth(WIN1),116,WIN1) ;2
	Local tempImage2=scaleimagefast_bypixels(image1,w,minimum(GadgetHeight(PREVIEW_CANVAS)))
	CopyRect 0,0,w,GadgetHeight(PREVIEW_CANVAS),0,0,ImageBuffer(tempImage2),CanvasBuffer(PREVIEW_CANVAS)
	FreeImage(tempImage2)
	FreeGadget CAN2 ;3
	FreeImage image1
	;------------------------------------------
End Function
	; original text by sswift
	; -------------------------------------------------------------------------------------------------------------------------------------
	; This function scales an image an arbitrary amount on the X and Y axis, and returns a pointer to the new image.
	; The original image is not modified.
	;
	; The scale can either be a relative width and height, ie, 0.5 of the width of the original image, or it can be an exact size in pixels.
	; If an exact size is desired, set ExactSize to true.
	;
	; This function is 80x faster than the ScaleImage function that comes with Blitz! 
	; -------------------------------------------------------------------------------------------------------------------------------------
Function scaleimagefast(SrcImage, ScaleX#, ScaleY#) ;this function resizes images 80x faster than the standard resizeimage (tformfilter 0) blitz command
	DebugLog "scaleimagefast"
	;----------------------------------------------
	;many thanks for sswift
	;for posting this code on the blitz pages
	;http://www.blitzbasic.com/codearcs/codearcs.php?code=1303
	;****** HUGE WARNING ******
	;if you are to use this code, be sure to free your images afterwards
	;e.g.
	;tempImage = scaleimagefast(SrcImage, ScaleX#, ScaleY#)
	;drawimage tempImage, x, y
	;freeimage tempImage
	;----------------------------------------------
	Local SrcWidth,  SrcHeight
	Local DestWidth, DestHeight
	Local ScratchImage, DestImage
	Local SrcBuffer, ScratchBuffer, DestBuffer
	Local X1, Y1, X2, Y2
	; Get the width and height of the source image. 	
		SrcWidth  = ImageWidth(SrcImage)
		SrcHeight = ImageHeight(SrcImage)
	; Calculate the width and height of the dest image.
		DestWidth  = Floor(SrcWidth  * ScaleX#)
		DestHeight = Floor(SrcHeight * ScaleY#)
	; If the image does not need to be scaled, just copy the image and exit the function.
		If (SrcWidth = DestWidth) And (SrcHeight = DestHeight) Then Return CopyImage(SrcImage)
	; Create a scratch image that is as tall as the source image, and as wide as the destination image.
		ScratchImage = CreateImage(DestWidth, SrcHeight)
	; Create the destination image.
		DestImage = CreateImage(DestWidth, DestHeight) 
	; Get pointers to the image buffers.
		SrcBuffer     = ImageBuffer(SrcImage)
		ScratchBuffer = ImageBuffer(ScratchImage)
		DestBuffer    = ImageBuffer(DestImage)
	; Duplicate columns from source image to scratch image.
		For X2 = 0 To DestWidth-1
			X1 = Floor(X2 / ScaleX#)
			CopyRect X1, 0, 1, SrcHeight, X2, 0, SrcBuffer, ScratchBuffer
		Next
	; Duplicate rows from scratch image to destination image.
		For Y2 = 0 To DestHeight-1
			Y1 = Floor(Y2 / ScaleY#)
			CopyRect 0, Y1, DestWidth, 1, 0, Y2, ScratchBuffer, DestBuffer
		Next
	; Free the scratch image.
		FreeImage ScratchImage
	; Return the new image.
		Return DestImage
End Function
Function scaleimagefast_bypixels(image1,w#,h#) ;uses scaleimagefast, but takes out the headache of calculating percents
	DebugLog "scaleimagefast_bypixels"
	Local x#,y#
	x = w/ImageWidth(image1)
	y = h/ImageHeight(image1)
	Return scaleimagefast(image1,x,y)
;	FreeImage image1
End Function
;Function setwintransparenz(WinHandle, Transparenz) ;sets the transparency of the given window
;	DebugLog "setwintransparenz"
;	;many thanks to OnkelDetlef for posting this code online
;	;http://www.blitzbasic.com/Community/posts.php?topic=38928
;	api_SetWindowLong(WinHandle,GWL_EXSTYLE,$00080000)
;	api_SetLayeredWindowAttributes(WinHandle,0,Transparenz,2)
;End Function
Function set_windowtext_left(t$="") ;sets the text on the left side of the bottom bar
	Local x, y
	SetGadgetFont WIN1, FONT
	If t = ""
		t = FUNC
	EndIf 
	If Instr(WTEXT, "  ")&gt;0
		For x = 1 To Len(WTEXT)-1
			If Left(Right(WTEXT, x+1), 2) = "  " Then Exit
		Next
		WTEXT = Right(WTEXT, x-1)
	EndIf
	t = padr(t, 127)
	WTEXT = Left(t, Len(t) - Len(WTEXT)) + WTEXT
	SetStatusText WIN1, WTEXT
End Function
Function set_windowtext_right(t$="") ;sets the text on the left side of the bottom bar
	Local x, y
	SetGadgetFont WIN1, FONT
	If t = ""
		t = FRAME
	EndIf 
	If Instr(WTEXT, "  ")&gt;0
		WTEXT = Left(WTEXT, Instr(WTEXT, "  "))
	EndIf
	t = padl(t, 127)
	WTEXT = WTEXT + Right(t, Len(t) - Len(WTEXT))
	SetStatusText WIN1, WTEXT
End Function
Function shift_preview(p#, n#) ;eye candy that shifts the preview smoothly to the left or right ;previous, new
	DebugLog "shift_preview"
	If p &lt;&gt; n And EYECANDY = 1
		Local image1, image2, tempx, w#, x#, y#, x2#, y2#, x3#, y3# ;w, x, and y were derived from draw_preview ;x2 and y2 are derived from draw
		w = ImageWidth(IMAGE(p)) * (100.0/ImageHeight(IMAGE(p))) + 8
		x = GadgetWidth(PREVIEW_CANVAS)/2 - (w-8)/2
		y = 8
		x2 = GadgetWidth(CAN1)/2-FOCUSX*SCALE
		y2 = GadgetHeight(CAN1)/2-FOCUSY*SCALE
		SetBuffer CanvasBuffer(PREVIEW_CANVAS)
		If ALPHA = 1 ;fade out the old frame and fade in the new frame
			Local tempImage=scaleimagefast_bypixels(IMAGE(p),w-8,100)
			DrawBlock alphaimage(tempImage,0,30 ), x, y
			FreeImage(tempImage)
			tempImage=scaleimagefast_bypixels(IMAGE(n),w-8,100)
			DrawBlock alphaimage( tempImage,100,30 ), x-(p-n)*w, y
			FreeImage(tempImage)
			FlipCanvas PREVIEW_CANVAS
		EndIf
		image1 = CreateImage(GadgetWidth(PREVIEW_CANVAS), GadgetHeight(PREVIEW_CANVAS))
		image2 = CreateImage(GadgetWidth(CAN1), GadgetHeight(CAN1))
		CopyRect 0, 0, GadgetWidth(PREVIEW_CANVAS), GadgetHeight(PREVIEW_CANVAS), 0, 0, CanvasBuffer(PREVIEW_CANVAS), ImageBuffer(image1)
		CopyRect 0, 0, GadgetWidth(CAN1), GadgetHeight(CAN1), 0, 0, CanvasBuffer(CAN1), ImageBuffer(image2)
		For tempx=0 To 20 ;the smooth stuff
			SetBuffer CanvasBuffer(PREVIEW_CANVAS) ;the preview bar
				Cls
				If n-p&gt;0
				DrawBlock image1, minimum((p-n)*w/(21-tempx),(p-n)*w), 0
				Else
				DrawBlock image1, maximum((p-n)*w/(21-tempx),(p-n)*w), 0
				EndIf
			FlipCanvas PREVIEW_CANVAS
			SetBuffer CanvasBuffer(CAN1) ;the main canvas
				Cls
				x3 = x-(p-n)*w
				y3 = GadgetY(PREVIEW_CANVAS)-ImageHeight(IMAGE(n))
				DrawBlock image2, 0, 0
				tempImage=scaleimagefast_bypixels(IMAGE(n), minimum((ImageWidth(IMAGE(n))*SCALE-w)/20*tempx+w,4), minimum((ImageHeight(IMAGE(n))*SCALE-100)/20*tempx+100,4))
				DrawImage tempImage, x3 + (x2-x3)/20*tempx, y3 + (y2-y3)/20*tempx
				FreeImage(tempImage)
			FlipCanvas CAN1
			time 10
		Next
		SetBuffer CanvasBuffer(PREVIEW_CANVAS)
		SetBuffer BUFFER
		FreeImage image1
		FreeImage image2
		If DODRAW = "" Then DODRAW = "PREVIEW"
		If DODRAW = "CAN1" Then DODRAW = "BOTH"
	EndIf
End Function
Function time(t) ;delays the program up until the TIMER variable runs out, then resets the timer variable for t
	DebugLog "time"
	While TIMER &gt; MilliSecs()
		WaitEvent(5)
	Wend
	TIMER = MilliSecs() + t
End Function
Function update_overlay(a=0,image1=0) ;update the picture with the previous (and next, optionally) ones
	DebugLog "update_overlay"
End Function
Function update_overlay_previewportion() ;draws either black or the preview canvas to the bottom of the overlay so as to highlight the white box
	DebugLog "update_overlay_previewportion"
End Function
Function userinput_checkfunction_mouse1(p=1) ;checks the functions associated with pressing the left mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse1"
	Local x%, w#
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				paintfunctions(1) ;let the drawing commence!
			EndIf
		EndIf
	Else ;functions for the PREVIEW_CANVAS canvas
		w = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
		x = minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ;the frame currently highlighted by the mouse
		create_item x
		shift_preview FRAME, x
		If x &gt;= 0 And x &lt; FRAMES Then FRAME = x:DODRAW = "BOTH"
		While MouseDown(1)=1 time(50) Wend
	EndIf
	MXPREVIOUS=MXPREVIOUS-1 ;to force a recalculation of the mouse over function (userinput_checkfunction_mousemoved())
	MYPREVIOUS=MYPREVIOUS-1
End Function
Function userinput_checkfunction_mouse2(p=1) ;checks the functions associated with pressing the right mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse2"
	Local a%, b%, x%, w#
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				paintfunctions(2) ;let the drawing commence!
			EndIf
		EndIf
	Else ;functions for the PREVIEW_CANVAS canvas
		a = ALPHA:ALPHA = 0 ;same as the left mouse button function, but without the Alpha or Eyecandy functionality
		b = EYECANDY:EYECANDY = 0
		w = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
		x = minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ;the frame currently highlighted by the mouse
		create_item x
		shift_preview FRAME, x
		If x &gt;= 0 And x &lt; FRAMES Then FRAME = x:DODRAW = "BOTH"
		While MouseDown(1)=1 time(50) Wend
		ALPHA = a
		EYECANDY = b
	EndIf
End Function
Function userinput_checkfunction_mouse3(p=1) ;checks for the functions associated with pressing the middle mouse button ;the button has been P-ressed
End Function
Function userinput_checkfunction_mousemoved() ;checks for any functions related to the changed position of the mouse
	Local x%,y%,w# = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
	DebugLog "userinput_checkfunction_mousemoved"
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				x = Floor( (MouseX(CAN1)-( GadgetWidth(CAN1)/2-FOCUSX*SCALE ))/SCALE )
				y = Floor( (MouseY(CAN1)-( GadgetHeight(CAN1)/2-FOCUSY*SCALE ))/SCALE )
				set_windowtext_right "("+x+", "+y+")"
			EndIf
		EndIf
	Else ;functions for teh PREVIEW_CANVAS canvas
		set_windowtext_right ( "FRAME " + minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ) ;FRAME: + (MouseX-(widthofpreviewrect)/2)/(widthofpreviewrect)
	EndIf
End Function
;---------------------
</textarea><br><br>What you're seeing: The top portion is the current frame in the editor (all images are randomly generated at the moment). The bottom portion is the preview bar with the current frame and some previous and post frames. You can click in the editor to zoom in/out and on the preview to switch frames.<br>Controls: mouse and left/right mouse buttons<br><br>Edit: Bug fixed, see line 515. <br><br></td></tr></table><br>
<a name="983367"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This solves the immediate problem:<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;------NOTES------
;this program is intended for the publication of game sequence animations with less-than basic paint functionality
;all global variables and lables and types are capitalized, all locals and functions are lowercase
;more paint tools to come
;-----------------
;------WINDOW VARIABLES------
Global WIDTH = GadgetWidth(Desktop()) ;normal window
Global HEIGHT = GadgetHeight(Desktop())
Global WIN1 = CreateWindow("New File: Game_Animatory v0.00",WIDTH/4,HEIGHT/4,WIDTH/2,minimum(HEIGHT/2,308),0,15)
Global CAN1 = CreateCanvas(0,0,ClientWidth(WIN1),ClientHeight(WIN1)-116,WIN1)
Global CAN2 ;for use in resize_maincanvases
Global PREVIEW_CANVAS = CreateCanvas(0,ClientHeight(WIN1)-116,ClientWidth(WIN1),116,WIN1)
SetMinWindowSize WIN1,500,308
SetGadgetLayout CAN1,1,1,1,1
SetGadgetLayout PREVIEW_CANVAS,1,1,0,1
;----------------------------
;------GLOBAL VARIABLES------
Global ALPHA = 0 ;if 1, then images are alpha'd before drawn (specifically the preview images)
Global BORDER_IMAGE = CreateImage(104,104) ;used to draw a border around the image in the editor
Global BUFFER = CanvasBuffer(CAN1) ;holds the handle of the current buffer
Global COL_LEFT = -1 ;the foreground drawing color, -16777216=black, -1=white
Global COL_RIGHT = -6777216 ;the background drawing color, -16777216=black, -1=white
Global DIRECTORY$ = CurrentDir$() ;the directory of the current project
Global DODRAW$ = "BOTH" ;the screen (BOTH/CAN1/PREVIEW) is redrawn only if DODRAW is true
Global DRAWN = 0 ;whether to draw the next frame, alpha lite, in front of the current frame
Global DRAWP = 0 ;whether to draw the previous frame, alpha lite, behind the current frame
Global EYECANDY = 1 ;stuff that makes the program look pretty (including shift_preview)
Global FOCUSX = 50 ;the focus point of the image, for when it doesn't fit in the drawing window
Global FOCUSY = 50 ;the focus point of the image, for when it doesn't fit in the drawing window
Global FONT = LoadFont("COURIER",12)
Global FONT_BIG = LoadFont("COURIER",102)
Global FRAME = 9 ;the current frame
Global FRAMES = 19 ;the total number of frames
Global FUNC$ = "SCALE" ;the current function used for drawing (can be PENCIL, SCALE)
;Const  GWL_EXSTYLE = -20 ;for the setwintransparenz function
Dim    IMAGE(19) ;the handle of the main images
Global MXOFFSET = 0 ;the offset of the mousex() (the difference between the x coordinate of the window and the x coordinate of the window
Global MYDIRECTORY$ = CurrentDir$() ;the directory in which is located the program
Global MYOFFSET = 0 ;the offset of the mousey()
Global MXPREVIOUS = 0 ;the previous recorded x location of the mouse
Global MYPREVIOUS = 0 ;the previous recorded y location of the mouse
Global NAME$ = "New File" ;the title of the current project
Global SCALE# = 3.0 ;for zooming in/out ;a direct translation (2.0 is twice as big &lt;&gt; 200 (for percent))
Global TIMER = 0 ;delays the program until millisecs() &gt; TIMER
Global WINX = GadgetX(WIN1) ;to be used as a x refference point in check_windowmoved
Global WINY = GadgetY(WIN1) ;to be used as a y refference point in check_windowmoved
Global WINW = GadgetWidth(WIN1) ;to be used as a width refference point in check_windowmoved
Global WINH = GadgetHeight(WIN1) ;to be used as a height refference point in check_windowmoved
Global WTEXT$ = "SCALE  " ;the current window text (see the set_windowtext_right/set_windowtext_left functions)
;----------------------------
;------TYPES------
Type ITEM ;used to display the neat disapearing text
	Field name$
	Field x#
	Field y#
	Field life_start#
	Field life_end#
	Field image%
End Type
;------PRE_START------
calculate_offsets() ;for MXOFFSET and MYOFFSET
IMAGE(0) = CreateImage(100,100) ;the image for the first frame
SeedRnd(MilliSecs())
SetBuffer(ImageBuffer(IMAGE(0)))
For TIMER = 0 To ImageHeight(IMAGE(0))
	Color Rand(255),Rand(255),Rand(255)
	Line 0,TIMER,ImageWidth(IMAGE(0)),TIMER
Next
For tempx=1 To 18
IMAGE(tempx) = CreateImage(100,100) ;the image for the first frame
SetBuffer(ImageBuffer(IMAGE(tempx)))
For TIMER = 0 To ImageHeight(IMAGE(tempx))
	Color Rand(255),Rand(255),Rand(255)
	Line 0,TIMER,ImageWidth(IMAGE(tempx)),TIMER
Next
Next
SetBuffer(BUFFER)
calculate_borderimage() ;for the BORDER_IMAGE
resize_images(1) ;fast/slow
update_overlay(1) ;updates the overlay window ;resize and reposition too
;---------------------
;------------------------
;------MAIN PROGRAM------
;------------------------
While KeyDown(1)=0
	DebugLog "main"
	time(50) ;delays the program so as not to eat up processor power, including gathering user input
	check_keyboard() ;checks if there is a keyboard button being pressed
	check_mouse() ;checks to see if the user has moved the mouse/pushed a mouse button
	check_windowmoved() ;if the window has been moved or resized, several processes must be called (including update_overlay())
	If DODRAW="BOTH" Or DODRAW="CAN1" Then draw() ;DODRAW is set to either "PREVIEW" or "", depending
	If DODRAW="BOTH" Or DODRAW="PREVIEW" Then draw_preview() ;DODRAW is set to either "CAN1" or "", depending
	For ITEM.ITEM=Each ITEM
		DebugLog ITEM\name
		draw_item(ITEM\name)
	Next
	Select EventID()
		Case $803 ;big red button
			Exit
	End Select
Wend
finish()
;------------------------
;------------------------
;------------------------
;------FUNCTIONS------
Function alphaimage(image1,shade#,percent#) ;alphas an image to white (shade=100) or black (shade=0) by a percent value and returns the distorted image
	DebugLog "alphaimage"
	Local tempx,tempy,tempcolor
	If ALPHA = 1
		LockBuffer ImageBuffer(image1)
		For tempx=0 To ImageWidth(image1)-1
			For tempy=0 To ImageHeight(image1)-1
				tempcolor=ReadPixelFast(tempx,tempy,ImageBuffer(image1))
				WritePixelFast tempx,tempy, getcolorback( getred(tempcolor)+(shade*255.0/100.0-getred(tempcolor))*percent/100.0 , getgreen(tempcolor)+(shade*255.0/100.0-getgreen(tempcolor))*percent/100.0 , getblue(tempcolor)+(shade*255.0/100.0-getblue(tempcolor))*percent/100.0 ), ImageBuffer(image1)
			Next
		Next
		UnlockBuffer ImageBuffer(image1)
		Return image1
		FreeImage image1
	Else
		Return image1
		FreeImage image1
	EndIf
End Function
Function calculate_offsets() ;finds the differences between the window and canvas coordinates
	DebugLog "calculate_offsets"
	Local a,b,px,py,timer
	a=MouseX(CAN1)
	b=MouseY(CAN1)
	px=MouseX()
	py=MouseY()
	timer=MilliSecs()+100
	While MouseX(CAN1)=a And MouseY(CAN1)=b ;guarantees that the mouse hits the canvas
		If timer&lt;MilliSecs() Then Exit
		If MouseX(CAN1) = a Then MoveMouse(Rand(ClientWidth(Desktop())),MouseY())
		If MouseY(CAN1) = b Then MoveMouse(MouseX(),Rand(ClientHeight(Desktop())))
	Wend
	a = MouseX()
	While MouseX(CAN1)&gt;0 ;
		MoveMouse(MouseX()-1,MouseY())
		If MouseX()&lt;=0 Then Exit ;the &lt; is just for safety
		If MouseX() = a Then Exit Else a = MouseX() ;again, just safety
	Wend
	b = MouseY()
	While MouseY(CAN1)&gt;0
		MoveMouse(MouseX(),MouseY()-1)
		If MouseY()&lt;=0 Then Exit ;the &lt; is just for safety
		If MouseY() = b Then Exit Else b = MouseY() ;again, just safety
	Wend
	MXOFFSET=minimum(MouseX()-GadgetX(win1))
	MYOFFSET=minimum(MouseY()-GadgetY(win1))
	If MXOFFSET = 0 Then MXOFFSET = 4 ;these values were gained from a successful run
	If MYOFFSET = 0 Then MYOFFSET = 50 ;these values were gained from a successful run
	MoveMouse(px,py)
End Function
Function calculate_borderimage() ;draws the BORDER_IMAGE, which creates a border so that it's easy for the user to tell what it is they're editing
	DebugLog "calculate_borderimage"
	Local b,g,r,t,x#,y#
	LockBuffer ImageBuffer(IMAGE(FRAME))
	LockBuffer ImageBuffer(BORDER_IMAGE)
	For x = 0 To 1
		If x = 1 Then x = ImageWidth(IMAGE(FRAME))-1
		For y = 0 To ImageHeight(IMAGE(FRAME))-1
			t = ReadPixelFast(x, y, ImageBuffer(IMAGE(FRAME)))
			r = getred(t)
			g = getgreen(t)
			b = getblue(t)
;			If r&lt;100 Or r&gt;155 Then r = 255-r Else r = r+100
;			If g&lt;100 Or g&gt;155 Then g = 255-g Else g = g+100
;			If b&lt;100 Or b&gt;155 Then b = 255-b Else b = b+100
			r = 255-r
			g = 255-g
			b = 255-b
	;		t = getcolorback(r, g, b)
			t = getcolorback(255, 255, 255)
;			WritePixelFast x+3*Ceil(x/ImageWidth(IMAGE(FRAME))), y+1, t, ImageBuffer(BORDER_IMAGE)
;			WritePixelFast x+3*Ceil(x/ImageWidth(IMAGE(FRAME)))+1, y+1, t, ImageBuffer(BORDER_IMAGE)
			WritePixelFast x+4*Ceil(x/ImageWidth(IMAGE(FRAME))), y+2, t, ImageBuffer(BORDER_IMAGE)
		Next
	Next
	For x = 0 To ImageWidth(IMAGE(FRAME))-1
		For y = 0 To 1
			If y = 1 Then y = ImageHeight(IMAGE(FRAME))-1
			t = ReadPixelFast(x, y, ImageBuffer(IMAGE(FRAME)))
			r = getred(t)
			g = getgreen(t)
			b = getblue(t)
;			If r&lt;100 Or r&gt;155 Then r = 255-r Else r = r+100
;			If g&lt;100 Or g&gt;155 Then g = 255-g Else g = g+100
;			If b&lt;100 Or b&gt;155 Then b = 255-b Else b = b+100
			r = 255-r
			g = 255-g
			b = 255-b
	;		t = getcolorback(r, g, b)
			t = getcolorback(255, 255, 255)
;			WritePixelFast x+1, y+2*Ceil(y/ImageHeight(IMAGE(FRAME))), t, ImageBuffer(BORDER_IMAGE)
			WritePixelFast x+2, y+4*Ceil(y/ImageHeight(IMAGE(FRAME))), t, ImageBuffer(BORDER_IMAGE)
		Next
	Next
	t = getcolorback(255,255,255)
	For x = 0 To 1
		For y = 0 To 1
			WritePixelFast x*ImageWidth(BORDER_IMAGE)+1-3*x, y*ImageHeight(BORDER_IMAGE)+1-3*y, t, ImageBuffer(BORDER_IMAGE)
		Next
	Next
	WritePixelFast 1, ImageHeight(BORDER_IMAGE)/2, t, ImageBuffer(BORDER_IMAGE)
	WritePixelFast ImageWidth(BORDER_IMAGE)-2, ImageHeight(BORDER_IMAGE)/2, t, ImageBuffer(BORDER_IMAGE)
	WritePixelFast ImageWidth(BORDER_IMAGE)/2, 1, t, ImageBuffer(BORDER_IMAGE)
	WritePixelFast ImageWidth(BORDER_IMAGE)/2, ImageHeight(BORDER_IMAGE)-2, t, ImageBuffer(BORDER_IMAGE)
	UnlockBuffer ImageBuffer(IMAGE(FRAME))
	UnlockBuffer ImageBuffer(BORDER_IMAGE)
End Function
Function check_keyboard() ;checks if there is a response from the keyboard
End Function
Function check_mouse() ;checks to see if the user has moved the mouse/pushed a mouse button
	DebugLog "check_mouse"
	If MouseDown(1)=1
		userinput_checkfunction_mouse1()
	EndIf
	If MouseDown(2)=1
		userinput_checkfunction_mouse2()
	EndIf
	If MouseX()&lt;&gt;MXPREVIOUS Or MouseY()&lt;&gt;MYPREVIOUS
		userinput_checkfunction_mousemoved()
		MXPREVIOUS = MouseX()
		MYPREVIOUS = MouseY()
	EndIf
	While MouseDown(1)=1 time(50) Wend
	While MouseDown(2)=1 time(50) Wend
End Function
Function check_windowmoved() ;checks if the main (WIN1) window has either been moved or resized
	DebugLog "checkwindowmoved"
	;if it has, then the contained functions must be called
	If  (WINX&lt;&gt;GadgetX(WIN1))  Or  (WINY&lt;&gt;GadgetY(WIN1))  Or  (WINW&lt;&gt;ClientWidth(WIN1))  Or  (WINH&lt;&gt;ClientHeight(WIN1))
		;update the variables
		WINX=GadgetX(WIN1):WINY=GadgetY(WIN1):WINW=minimum(ClientWidth(WIN1),1):WINH=minimum(ClientHeight(WIN1),1)
		;--------------------
		;call the functions
		If  (WINW&lt;&gt;GadgetWidth(WIN1))  Or  (WINH&lt;&gt;GadgetHeight(WIN1)) Then resize_maincanvases(WINW,WINH) ;called because there indeed two main canvases (CAN1 and PREVIEW_CANVAS)
		;------------------
		;call the draw function from the main program
		DODRAW="BOTH"
	EndIf
End Function
Function create_item(name$=":)", x#=0, y#=0, life_start#=-1, life_end#=-1, image=0, kill=1, draw=1) ;used as a function to easily create items
	If life_start = -1 Then life_start = MilliSecs()
	If life_end = -1 Then life_end = MilliSecs()+500
	If kill = 1 Then killitems() ;releases all of the current items
	item.ITEM = New ITEM ;to be drawn to let the user know what the current scale is
	item\name = name
	item\life_start = life_start
	item\life_end = life_end
	item\image = image
	If draw = 1 Then draw_item item\name
End Function
Function draw() ;draws the main (CAN1) program
	DebugLog "draw"
	Local x, y
	SetBuffer (CanvasBuffer(CAN1))
	Cls
	;calculate x and y
	x = GadgetWidth(CAN1)/2-FOCUSX*SCALE
	y = GadgetHeight(CAN1)/2-FOCUSY*SCALE
	;-----------------
	;draws the previous frame
	;------------------------
	;draws a border around the image
	If SCALE &lt;&gt; 1.0
;		DrawImage scaleimagefast(BORDER_IMAGE,SCALE,SCALE), GadgetWidth(CAN1)/2-ImageWidth(IMAGE(FRAME))/2*SCALE-2*SCALE, GadgetHeight(CAN1)/2-ImageHeight(IMAGE(FRAME))/2*SCALE-2*SCALE
		Local tempScaledImage = scaleimagefast(BORDER_IMAGE,SCALE,SCALE); , )
		DrawImage(tempScaledImage, x-2*SCALE, y-2*SCALE)
		FreeImage(tempScaledImage)
	Else
		DrawImage BORDER_IMAGE, x-2, y-2
	EndIf
	;-------------------------------
	;draws the image
	If SCALE &lt;&gt; 1.0
;		DrawImage scaleimagefast(IMAGE(FRAME),SCALE,SCALE), GadgetWidth(CAN1)/2-ImageWidth(IMAGE(FRAME))/2*SCALE, GadgetHeight(CAN1)/2-ImageHeight(IMAGE(FRAME))/2*SCALE
		Local tempImage=scaleimagefast(IMAGE(FRAME),SCALE,SCALE)
		DrawImage tempImage, x, y
		FreeImage(tempImage)
	Else
		DrawImage IMAGE(FRAME), x, y
	EndIf
	;---------------
	FlipCanvas (CAN1)
	SetBuffer (BUFFER)
	If DODRAW = "CAN1" Then DODRAW = ""
	If DODRAW = "BOTH" Then DODRAW = "PREVIEW"
End Function
Function draw_item(i$) ;draws the current item according to it's life
	Local c
	For item.ITEM = Each ITEM
		If item\name=i Then Exit
	Next
	SetBuffer CanvasBuffer(CAN1)
	c = 255-minimum( (MilliSecs()-item\life_start)/(item\life_end-item\life_start)*255 )
	Color c,c,c
	SetFont FONT_BIG
	Text item\x,item\y,item\name
	If MilliSecs()&gt;item\life_end Then Color 0,0,0:Text item\x,item\y,item\name
	FlipCanvas CAN1
	SetBuffer BUFFER
	SetFont FONT
	killitems(1)
End Function
Function draw_preview(drawwhich=0, a=0, b=0) ;draws the preview of the frames; can be 0(all), 1(center), 2(none), 3(simple rectangles), or 4(from frame a to frame b)
	DebugLog "draw_preview"
	Local frame# = FRAME
	Local x,y,w
	If drawwhich = 0  And  MouseDown(1) = 1
		drawwhich = 3
	EndIf
	w = ImageWidth(IMAGE(FRAME)) * (100.0/ImageHeight(IMAGE(FRAME)))
	x = GadgetWidth(PREVIEW_CANVAS)/2 - w/2
	y = 8
	SetBuffer (CanvasBuffer(PREVIEW_CANVAS))
	Cls
	;draw the images previous to the current
	If drawwhich = 0 Or drawwhich = 3
		For tempx = 1 To Ceil(GadgetWidth(PREVIEW_CANVAS)/2/(w+8))
			If dodraw &lt;&gt; 3 Then
				Local tempImage=scaleimagefast_bypixels(IMAGE(minimum(FRAME-tempx)),w,100)
				DrawBlock alphaimage(tempImage,0,30), x-(w+8)*tempx, y Else Color 155,155,155:Rect x-(w+8)*tempx,y,w,100,1
				FreeImage tempImage
			EndIf
		Next
	EndIf
	;---------------------------------------
	;draw the image for the current frame
	If dodraw &lt;&gt; 0
		If dodraw &lt;&gt; 3 Then 
			Local tempImage2=scaleimagefast_bypixels(IMAGE(FRAME),w,100)
			DrawBlock alphaimage(tempImage2,100,30), x, y Else Color 255,255,255:Rect x,y,w,100,1
			FreeImage(tempImage2)
		EndIf
	EndIf
	;------------------------------------
	;draw the images following the current
	If drawwhich = 0 Or drawwhich = 3
		For tempx = 1 To Ceil(GadgetWidth(PREVIEW_CANVAS)/2/(w+8))
			If dodraw &lt;&gt; 3 Then
				Local tempImage3=scaleimagefast_bypixels(IMAGE(maximum(FRAME+tempx,FRAMES-1)),w,100)
				DrawBlock alphaimage(tempImage3 ,0,30), x+(w+8)*(tempx), y 
				FreeImage(tempImage3)
			Else 
				Color 155,155,155:Rect x-(w+8)*tempx,y,w,100,1
			EndIf
		Next
	EndIf
	;-------------------------------------
	FlipCanvas (PREVIEW_CANVAS)
	SetBuffer (BUFFER)
	If DODRAW = "PREVIEW" Then DODRAW = ""
	If DODRAW = "BOTH" Then DODRAW = "CAN1"
End Function
Function finish() ;quits the program, executing the necessary commands to free up image banks nad whatnot
	DebugLog "finish"
	For FRAME = 0 To FRAMES-1
		FreeImage IMAGE(FRAME)
	Next
	FreeImage BORDER_IMAGE
	FreeFont FONT
	FreeFont FONT_BIG
	killitems()
	End
End Function
Function getblue#(col#)
	Return col And $FF 
End Function 
Function getcolorback(r,g,b) ;returns a readpixel type value
	Return (b Or (g Shl 8) Or (r Shl 16) Or (255 Shl 24)) 
End Function
Function getgreen#(col#)
	Return  (col Shr 8) And $FF
End Function
Function getred#(col#)	
	Return (col Shr 16) And $FF 
End Function
Function killitems(t=0) ;releases all of the current items ;relative to time (will only kill items that have expired)
	For item.ITEM = Each ITEM
		If t=1
			If item\life_end&lt;MilliSecs()
				If item\image&lt;&gt;0 Then FreeImage item\image
				Delete item
				If DODRAW = "" Then DODRAW = "CAN1"
			EndIf
		Else
			If item\image&lt;&gt;0 Then FreeImage item\image
			Delete item
			If DODRAW = "" Then DODRAW = "CAN1"
		EndIf
	Next
End Function
Function minimum#(x#,y#=0.0) ;if x&lt;y, then the function returns y instead
	DebugLog "minimum"
	If x &lt; y
		Return y
	Else
		Return x
	EndIf
End Function
Function maximum#(x#,y#=255.0) ;if x&gt;y, then the function returns y instead
	DebugLog "maximum"
	If x &gt; y
		Return y
	Else
		Return x
	EndIf
End Function
Function padl$(t$,p = 1) ;pads the left side of string t with spaces up until the string is as long as p
	While Len(t)&lt;p
		t = " "+t
	Wend
	Return t
End Function
Function padr$(t$,p = 1) ;pads the right side of string t with spaces up until the string is as long as p
	While Len(t)&lt;p
		t = t+" "
	Wend
	Return t
End Function
Function paintfunctions(md#=1.0) ;let the drawing commence! (which mouse button is pressed)
	DebugLog "paintfunctions"
	If md&gt;0
		While MouseDown(md) = 1
			Select FUNC ;the various tools
				Case "PENCIL"
				Case "SCALE"
			End Select
		Wend
		Select FUNC ;the various tools
			Case "PENCIL"
			Case "SCALE"
				If SCALE&gt;=1
					If md = 1 Then SCALE = SCALE + 1
					If md = 2 Then SCALE = SCALE - 1
				Else
					If md = 1 Then SCALE = SCALE * 2
					If md = 2 Then SCALE = SCALE / 2
				EndIf
				If SCALE = 0
					SCALE = 0.5
				EndIf
				If ImageWidth(IMAGE(FRAME))*SCALE&lt;=2 Or ImageHeight(IMAGE(FRAME))*SCALE&lt;=2 Then SCALE = SCALE*2
				If SCALE &gt;= 10 Then SCALE = 10
				Local name$ = SCALE
				create_item name
				DODRAW = "CAN1"
		End Select
	EndIf
End Function
Function resize_images(f=0) ;checks for the need to and resizes the images
	DebugLog "resize_images"
End Function
Function resize_maincanvases(w=500,h=308) ;called if the case that the main (WIN1) window has been resized
	DebugLog "resize_maincanvases"
	Local image1
	;if the main window(WIN1) is less than twice the height of the preview canvas, then it is resized to fit that shape
;	If ClientHeight(WIN1)&lt;GadgetHeight(PREVIEW_CANVAS)*2 Then SetGadgetShape WIN1,GadgetX(WIN1),GadgetY(WIN1),GadgetWidth(WIN1),minimum(GadgetHeight(WIN1)+1,GadgetHeight(PREVIEW_CANVAS)*2)
	;------------------------------------------------------------------------------------------------------------------
	;resize the "main" main canvas (CAN1)
	image1 = CreateImage(GadgetWidth(CAN1),GadgetHeight(CAN1))
	CopyRect 0,0,GadgetWidth(CAN1),GadgetHeight(CAN1),0,0,CanvasBuffer(CAN1),ImageBuffer(image1)
	CAN2 = CAN1 ;1, these four steps create a new canvas of the correct dimensions
	CAN1 = CreateCanvas(0,0,ClientWidth(WIN1),ClientHeight(WIN1)-116,WIN1) ;2
	Local tempImage=scaleimagefast_bypixels(image1,w,h-GadgetHeight(PREVIEW_CANVAS))
	CopyRect 0,0,w,h-GadgetHeight(PREVIEW_CANVAS),0,0,ImageBuffer(tempImage),CanvasBuffer(CAN1)
	FreeImage(tempImage)
	FreeGadget CAN2 ;3
	BUFFER = CanvasBuffer(CAN1) ;4
	FreeImage image1
	;------------------------------------
	;resize the preview canvas (PREVIEW_CANVAS)
	image1 = CreateImage(GadgetWidth(PREVIEW_CANVAS),GadgetHeight(PREVIEW_CANVAS))
	CopyRect 0,0,GadgetWidth(PREVIEW_CANVAS),GadgetHeight(PREVIEW_CANVAS),0,0,CanvasBuffer(PREVIEW_CANVAS),ImageBuffer(image1)
	CAN2 = PREVIEW_CANVAS ;1, these three steps create a new canvas of the correct dimensions
	PREVIEW_CANVAS = CreateCanvas(0,ClientHeight(WIN1)-116,ClientWidth(WIN1),116,WIN1) ;2
	Local tempImage2=scaleimagefast_bypixels(image1,w,minimum(GadgetHeight(PREVIEW_CANVAS)))
	CopyRect 0,0,w,GadgetHeight(PREVIEW_CANVAS),0,0,ImageBuffer(tempImage2),CanvasBuffer(PREVIEW_CANVAS)
	FreeImage(tempImage2)
	FreeGadget CAN2 ;3
	FreeImage image1
	;------------------------------------------
End Function
Function scaleimagefast(SrcImage, ScaleX#, ScaleY#) ;this function resizes images 80x faster than the standard resizeimage (tformfilter 0) blitz command
	DebugLog "scaleimagefast"
	;----------------------------------------------
	;many thanks for sswift
	;for posting this code on the blitz pages
	;http://www.blitzbasic.com/codearcs/codearcs.php?code=1303
	;----------------------------------------------
	Local SrcWidth,  SrcHeight
	Local DestWidth, DestHeight
	Local ScratchImage, DestImage
	Local SrcBuffer, ScratchBuffer, DestBuffer
	Local X1, Y1, X2, Y2
	; Get the width and height of the source image. 	
		SrcWidth  = ImageWidth(SrcImage)
		SrcHeight = ImageHeight(SrcImage)
	; Calculate the width and height of the dest image.
		DestWidth  = Floor(SrcWidth  * ScaleX#)
		DestHeight = Floor(SrcHeight * ScaleY#)
	; If the image does not need to be scaled, just copy the image and exit the function.
		If (SrcWidth = DestWidth) And (SrcHeight = DestHeight) Then Return CopyImage(SrcImage)
	; Create a scratch image that is as tall as the source image, and as wide as the destination image.
		ScratchImage = CreateImage(DestWidth, SrcHeight)
	; Create the destination image.
		DestImage = CreateImage(DestWidth, DestHeight) 
	; Get pointers to the image buffers.
		SrcBuffer     = ImageBuffer(SrcImage)
		ScratchBuffer = ImageBuffer(ScratchImage)
		DestBuffer    = ImageBuffer(DestImage)
	; Duplicate columns from source image to scratch image.
		For X2 = 0 To DestWidth-1
			X1 = Floor(X2 / ScaleX#)
			CopyRect X1, 0, 1, SrcHeight, X2, 0, SrcBuffer, ScratchBuffer
		Next
	; Duplicate rows from scratch image to destination image.
		For Y2 = 0 To DestHeight-1
			Y1 = Floor(Y2 / ScaleY#)
			CopyRect 0, Y1, DestWidth, 1, 0, Y2, ScratchBuffer, DestBuffer
		Next
	; Free the scratch image.
		FreeImage ScratchImage					
	; Free the Destination image (don't always do this, if the image is to be used again)
;		FreeImage DestImage
	; Free the buffers
;		FreeGadget SrcBuffer
;		FreeGadget ScratchBuffer
;		FreeGadget DestBuffer
	; Return the new image.
		Return DestImage
End Function
Function scaleimagefast_bypixels(image1,w#,h#) ;uses scaleimagefast, but takes out the headache of calculating percents
	DebugLog "scaleimagefast_bypixels"
	Local x#,y#
	x = w/ImageWidth(image1)
	y = h/ImageHeight(image1)
	Return scaleimagefast(image1,x,y)
;	FreeImage image1
End Function
;Function setwintransparenz(WinHandle, Transparenz) ;sets the transparency of the given window
;	DebugLog "setwintransparenz"
;	;many thanks to OnkelDetlef for posting this code online
;	;http://www.blitzbasic.com/Community/posts.php?topic=38928
;	api_SetWindowLong(WinHandle,GWL_EXSTYLE,$00080000)
;	api_SetLayeredWindowAttributes(WinHandle,0,Transparenz,2)
;End Function
Function set_windowtext_left(t$="") ;sets the text on the left side of the bottom bar
	Local x, y
	SetGadgetFont WIN1, FONT
	If t = ""
		t = FUNC
	EndIf 
	If Instr(WTEXT, "  ")&gt;0
		For x = 1 To Len(WTEXT)-1
			If Left(Right(WTEXT, x+1), 2) = "  " Then Exit
		Next
		WTEXT = Right(WTEXT, x-1)
	EndIf
	t = padr(t, 127)
	WTEXT = Left(t, Len(t) - Len(WTEXT)) + WTEXT
	SetStatusText WIN1, WTEXT
End Function
Function set_windowtext_right(t$="") ;sets the text on the left side of the bottom bar
	Local x, y
	SetGadgetFont WIN1, FONT
	If t = ""
		t = FRAME
	EndIf 
	If Instr(WTEXT, "  ")&gt;0
		WTEXT = Left(WTEXT, Instr(WTEXT, "  "))
	EndIf
	t = padl(t, 127)
	WTEXT = WTEXT + Right(t, Len(t) - Len(WTEXT))
	SetStatusText WIN1, WTEXT
End Function
Function shift_preview(p#, n#) ;eye candy that shifts the preview smoothly to the left or right ;previous, new
	DebugLog "shift_preview"
	If p &lt;&gt; n And EYECANDY = 1
		Local image1, image2, tempx, w#, x#, y#, x2#, y2#, x3#, y3# ;w, x, and y were derived from draw_preview ;x2 and y2 are derived from draw
		w = ImageWidth(IMAGE(p)) * (100.0/ImageHeight(IMAGE(p))) + 8
		x = GadgetWidth(PREVIEW_CANVAS)/2 - (w-8)/2
		y = 8
		x2 = GadgetWidth(CAN1)/2-FOCUSX*SCALE
		y2 = GadgetHeight(CAN1)/2-FOCUSY*SCALE
		SetBuffer CanvasBuffer(PREVIEW_CANVAS)
		If ALPHA = 1 ;fade out the old frame and fade in the new frame
			Local tempImage=scaleimagefast_bypixels(IMAGE(p),w-8,100)
			DrawBlock alphaimage(tempImage,0,30 ), x, y
			FreeImage(tempImage)
			tempImage=scaleimagefast_bypixels(IMAGE(n),w-8,100)
			DrawBlock alphaimage( tempImage,100,30 ), x-(p-n)*w, y
			FreeImage(tempImage)
			FlipCanvas PREVIEW_CANVAS
		EndIf
		image1 = CreateImage(GadgetWidth(PREVIEW_CANVAS), GadgetHeight(PREVIEW_CANVAS))
		image2 = CreateImage(GadgetWidth(CAN1), GadgetHeight(CAN1))
		CopyRect 0, 0, GadgetWidth(PREVIEW_CANVAS), GadgetHeight(PREVIEW_CANVAS), 0, 0, CanvasBuffer(PREVIEW_CANVAS), ImageBuffer(image1)
		CopyRect 0, 0, GadgetWidth(CAN1), GadgetHeight(CAN1), 0, 0, CanvasBuffer(CAN1), ImageBuffer(image2)
		For tempx=0 To 20 ;the smooth stuff
			SetBuffer CanvasBuffer(PREVIEW_CANVAS) ;the preview bar
				Cls
				If n-p&gt;0
				DrawBlock image1, minimum((p-n)*w/(21-tempx),(p-n)*w), 0
				Else
				DrawBlock image1, maximum((p-n)*w/(21-tempx),(p-n)*w), 0
				EndIf
			FlipCanvas PREVIEW_CANVAS
			SetBuffer CanvasBuffer(CAN1) ;the main canvas
				Cls
				x3 = x-(p-n)*w
				y3 = GadgetY(PREVIEW_CANVAS)-ImageHeight(IMAGE(n))
				DrawBlock image2, 0, 0
				tempImage=scaleimagefast_bypixels(IMAGE(n), minimum((ImageWidth(IMAGE(n))*SCALE-w)/20*tempx+w,4), minimum((ImageHeight(IMAGE(n))*SCALE-100)/20*tempx+100,4))
				DrawImage tempImage, x3 + (x2-x3)/20*tempx, y3 + (y2-y3)/20*tempx
				FreeImage(tempImage)
			FlipCanvas CAN1
			time 30
		Next
		SetBuffer CanvasBuffer(PREVIEW_CANVAS)
		SetBuffer BUFFER
		FreeImage image1
		FreeImage image2
		If DODRAW = "" Then DODRAW = "PREVIEW"
		If DODRAW = "CAN1" Then DODRAW = "BOTH"
	EndIf
End Function
Function time(t) ;delays the program up until the TIMER variable runs out, then resets the timer variable for t
	DebugLog "time"
	While TIMER &gt; MilliSecs()
		WaitEvent(5)
	Wend
	TIMER = MilliSecs() + t
End Function
Function update_overlay(a=0,image1=0) ;update the picture with the previous (and next, optionally) ones
	DebugLog "update_overlay"
End Function
Function update_overlay_previewportion() ;draws either black or the preview canvas to the bottom of the overlay so as to highlight the white box
	DebugLog "update_overlay_previewportion"
End Function
Function userinput_checkfunction_mouse1(p=1) ;checks the functions associated with pressing the left mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse1"
	Local x%, w#
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				paintfunctions(1) ;let the drawing commence!
			EndIf
		EndIf
	Else ;functions for the PREVIEW_CANVAS canvas
		w = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
		x = minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ;the frame currently highlighted by the mouse
		create_item x
		shift_preview FRAME, x
		If x &gt;= 0 And x &lt; FRAMES Then FRAME = x:DODRAW = "BOTH"
		While MouseDown(1)=1 time(50) Wend
	EndIf
	MXPREVIOUS=MXPREVIOUS-1 ;to force a recalculation of the mouse over function (userinput_checkfunction_mousemoved())
	MYPREVIOUS=MYPREVIOUS-1
End Function
Function userinput_checkfunction_mouse2(p=1) ;checks the functions associated with pressing the right mouse button ;the button has been P-ressed
	DebugLog "userinput_checkfunction_mouse2"
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				paintfunctions(2) ;let the drawing commence!
			EndIf
		EndIf
	Else ;functions for the PREVIEW_CANVAS canvas
	EndIf
End Function
Function userinput_checkfunction_mousemoved() ;checks for any functions related to the changed position of the mouse
	Local x%,y%,w# = ImageWidth(IMAGE(FRAME))*100.0/ImageHeight(IMAGE(FRAME))
	DebugLog "userinput_checkfunction_mousemoved"
	If MouseY()-GadgetY(WIN1)-MYOFFSET&lt;ClientHeight(CAN1) ;functions for the CAN1 canvas
		If MouseX(CAN1)&gt;=GadgetWidth(CAN1)/2-FOCUSX*SCALE And MouseX(CAN1)&lt;GadgetWidth(CAN1)/2+(ImageWidth(IMAGE(FRAME))-FOCUSX)*SCALE
			If MouseY(CAN1)&gt;=GadgetHeight(CAN1)/2-FOCUSY*SCALE And MouseY(CAN1)&lt;GadgetHeight(CAN1)/2+(ImageHeight(IMAGE(FRAME))-FOCUSY)*SCALE ;the mouse is over the image
				x = Floor( (MouseX(CAN1)-( GadgetWidth(CAN1)/2-FOCUSX*SCALE ))/SCALE )
				y = Floor( (MouseY(CAN1)-( GadgetHeight(CAN1)/2-FOCUSY*SCALE ))/SCALE )
				set_windowtext_right "("+x+", "+y+")"
			EndIf
		EndIf
	Else ;functions for teh PREVIEW_CANVAS canvas
		set_windowtext_right ( "FRAME " + minimum(maximum(Floor((MouseX(PREVIEW_CANVAS)-(GadgetWidth(PREVIEW_CANVAS)/2-w/2)+4)/(w+8))+FRAME,FRAMES-1)) ) ;FRAME: + (MouseX-(widthofpreviewrect)/2)/(widthofpreviewrect)
	EndIf
End Function
;---------------------

</textarea><br><br>The big issue was that all your usage of scaleImageFast() was returning a newly created image each time drawimage() and drawblock() was called which ended up in hysterical memory usage increase when you used scaled (zoomed) images.<br><br>If you wanna know exactly what changes i made save my file under another name next to your original file and use <a href="http://winmerge.org/" target="_blank">WinMerge</a> to see the differences.<br><br>After my changes there is still a (very small) increase of memory usage when the program was running so you still (probably) got some leak somewhere, but now it's at least usable :^)<br><br>edit: program updated. Now much better. The problems where more of the same as before. <br><br></td></tr></table><br>
<a name="983368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <strike>Sorry, issue is still not resolved :-/</strike><br><br><strike>wait a few more minutes :)</strike><br><br>EDIT: Check my previous post. it's fixed now. <br><br></td></tr></table><br>
<a name="983375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gladclef - Ben B</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome. Would have taken me days, literally, to think of that.<br>Edit: took the bellow suggestion to heart. Have posted the edited program plus the fix in the original code. <br><br></td></tr></table><br>
<a name="983376"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm glad if it helped.<br><br>I know this function scaleImageFast() was written by someone else but anyway here's my advise for the future: Any time you write  (or use) a function or piece of code that creates or claims some resource that it doesn't release again write a **** HUGE WARNING &lt;description&gt; ****  over it.<br><br>I.e. if a function allocates memory, creates/loads images/fonts/sounds etc. without removing them or opens files/network or serial ports without closing them etc. they need to be marked with a **** HUGE WARNING ****<br><br>This is especially important in Blitz+ as this language does not support Callbacks natively, which makes is generally harder to use code-patterns that minimize problems like this :) <br><br></td></tr></table><br>
<a name="985480"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's nothing wrong with my code or the way it's commented.<br><br>"This function scales an image an arbitrary amount on the X and Y axis, and returns a pointer to the new image.<br>The original image is not modified."<br><br>It doesn't get any clearer than that.  Are you saying any function which allocates memory in any way should have a huge warning to people that the function isn't going to magically free the memory on its own when you're done with it?  That's silly. <br><br></td></tr></table><br>
<a name="985500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, sswift I agree with you, and this was not meant as criticism against you personally. Now that I looked at the original submission (in code archives) I saw the comment made by you.<br><br>Clearly it's good to keep functions headers and comments for future use when one copies a function. :-) <br><br></td></tr></table><br>
<a name="985540"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gladclef - Ben B</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry. I copied the function a long time ago and for some reason missed copying the comment. Original post has been fixed to include said comment. Thank you again, sswift, for your brilliant code. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
