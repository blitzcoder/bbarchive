<!DOCTYPE html><html lang="en" ><head ><title >Raster to Vecor Algorythm?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Raster to Vecor Algorythm?</h1><a href="forums.php" >BlitzPlus Forums</a>/<a href="topics.php?forum=81" >BlitzPlus Programming</a>/<a href="#bottom" >Raster to Vecor Algorythm?</a><br><br>
<a name="281081"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi.<br>This is a personnal post.<br>(It does not have anything to do with the other topic, which Bird is dealing with now - for those who know what topic I am talking about).<br><br>I am back to my original duty - creating games, etc...<br><br>I got this tool I have to finish, written in plain Blitz Plus, no external DLLS, etc...<br><br>Now, I got a vector of ints, containning 50 x 50 ints.<br>Each int represents a pixel.<br>So, each int can be either 0 or 1 (reset or set, respectively).<br><br>What I need is an algorythm that would take this 2d black and white bitmap, stored in memory, and convert it to a collection of vectors, in the form (x0, y0, x1, y1).<br><br>Ideally, those vectors should be stored in an ordered way, that is, either clockwise or counter-clockwise.<br><br>It is going to be used to convert hand-drawn polygons to real polygons (don´t ask :D).<br>I have already managed to read the scanned bitmap, convert it to black and white and get rid of noise.<br><br>But now I am not finding a good way to vectorize it.<br>Remember: I must to it on the fly, so I am not interested in using auto-tracing utilities. It has to be done inside my code, in plain Blitz Plus.<br><br>I already have a vague idea on how to do it, but was not able to find out wher the lines start/end.<br><br>For instance, how would the fillowing pattern be vectorized?<br><br>XXX.......<br>..XX......<br>...XX.....<br>....X.....<br>....XXX...<br>......X...<br>.....XXX..<br>......XX..<br>.......X..<br>.......X..<br><br>My point is: I am not able to work on the algorythm before I am able to see what the generated lines would look like for such elementary patterns (10 x 10 pixels).<br><br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="281084"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is easier to follow this way:<br><br>[CODE]<br>XXX....... <br>..XX...... <br>...XX..... <br>....X..... <br>....XXX... <br>......X... <br>.....XXX.. <br>......XX.. <br>.......X.. <br>.......X.. <br>[/CODE]<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="281088"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here´s what I THINK would be the vertices of the vectorized lines for the pattern above:<br><br>[CODE]<br>XXX....... <br>..XX...... <br>...XX..... <br>....X..... <br>....XXX... <br>......X... <br>.....XXX.. <br>......XX.. <br>.......X.. <br>.......X.. <br><br>Becomes:<br><br>X......... <br>..X....... <br>....X..... <br>.......... <br>....X..... <br>......X... <br>.......X.. <br>.......... <br>.......... <br>.......X.. <br>[/CODE]<br><br>Does anyone disagree? Do you believe the vertices should be placed at different positions?<br>If someone figures a good selection of vertices for the pattern in the previous post, please tell me...<br><br>Got my point? My problem is that I am not confident that I can choose the vertices myself, so how can I come up with an algorythm for it?<br><br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="281115"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Help, please?<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="281245"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Im not sure I fully understand what you are trying to acheive?  a spline curve based on averaged positioning maybe? <br><br></td></tr></table><br>
<a name="281263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I do not need it to be a spline.<br>Actualy, it is supposed to be low-resolution.<br>I have a 50 by 50 pixels grid, which has the black-and-white representation of a scanned black-and-white, hand-drawn, bitmap.<br>The example in the previos posts is part of the output of a sample scan; dots are white pixels and X´s are black pixels.<br>What I need is to convert the pixel pattern to a POLYGON.<br>So, I realized that the first step in doing that was to find the line vertices.<br>But I actually NEED the result to be A POLYGON, not a spline or anything smooth.<br>I don´t want to apply any kind of filtering either.<br>I need the original pixels, to stay at their original positions - FOR THE VERTICES, only; all other pixels will be inserted by using the bresenham algorythm, so the final polygon will not (as expected) to be identical to the original pattern.<br>But the vertices must stay ay the exact same positions as they where prior to vectorizing.<br><br>Cheers,<br><br>Rui Barbosa Jr.<br>P.S.: i´ve got to go to sleep. 02:57AM down here; connecting from home. <br><br></td></tr></table><br>
<a name="281310"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Since it's a small sample and all you need is a polygon here's a possible approach:<br><br>1)scan concentric circles emanating from center of sample. <br><br>2)count only pixels at minimum and maximum distances from center using 5 degree of arc increments (play with this increment), consider those as possible vertices.<br><br>3)Store in array of x,y coords. <br><br>4)Lastly, connect stored coords with lines (in same order as they were determined)<br><br>To interpret results, will be the trick, because basically you need to know or determine the number of vertices from the original bitmap. If you know number of verts from original, your program can narrow down candidate verts.<br><br>It won't work in every situation (especially concave polygons), but for convex polygons should be close.<br><br>Andy_A <br><br></td></tr></table><br>
<a name="281323"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> With a little more thought a more direct solution is to scan for vertices like a radar screen.<br><br>1) from center of bitmap, find pixels at minimum and maximum distance from center (min &amp; max radii) at every 0.1 to 2 degree of arc increments (depending on required accuracy). Using Sin/Cos to get coords for every angle from 0 to 359.99 @ 0.1 degree increments. Start with a radius of 1 pixel to a max of Sqr(2)* 25 pixels at each angle to find min/max pixels<br><br>2) store min and max distance values (radius at which pixel was found) in an array with same number of elements as degrees scanned. A 0.1 angle increment requires 3600 element array x 3 (one element for min, one element for max and 1 element for current angle), a 1 degree increment only needs 360 x 3 elements. (ex Dim pixels(Angle#, minRadius#,  maxRadius#)<br><br>3) now process stored min/max distances to determine if there is an average tendency for increasing distances, if so you are finding a convex vertex, decreasing distances indicate a concave vertex. Store these in a candidate distances and angles in a polygon array.<br>4)Convert the distance and angle x,y coords using Sin/Cos. Connect the dots with lines.<br><br>Should work for polygons where sides do not intersect other sides and vertices do not overlap. <br><br></td></tr></table><br>
<a name="281371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi there.<br><br>I guess that the radar screen thing will work, but I would like you guys to take a look a the algo that I have already implemented.<br>Also, I would like to explain why it failed.<br>So, *maybe* you guys could help me find a way to fix this very simplistic algorythm.<br>(Remember: It´s got to be don on the fly, so the less sin/cos/sqr/floats I use, the better).<br><br>[CODE]<br>Algorythm Make Lines List is<br>   clear Result List<br>   backToFirstVertex &lt;-- false<br>   repeat<br>      L &lt;-- 0<br>      v0x, v0y &lt;-- Find The first Vertex of The Polygon<br>      vx, vy &lt;-- Find Position of Closest Pixel<br>      d0 &lt;-- Find direction of Closest Pixel<br>      d &lt;-- d0<br>      while d is same as d0<br>         vx, vy &lt;-- Find Position of Closest Pixel<br>         d &lt;-- Find direction od Closest Pixel<br>         if (vx, vy) is same as (v0x, v0y)<br>         {<br>            backToFirstVertex &lt;-- true<br>            Exit While<br>         }<br>         add 1 to L<br>      wend<br>      if backToFirstVertex<br>      {<br>         exit repeat<br>      }<br>   forever<br>   ;<br>   ; Got here, means that it either got back to <br>   ; the starting point<br>   ; or has changed its original direction<br>   ;<br>   Add to Vertex List: v0x, v1x, d, L<br>return<br><br>Algorythm Find Position of Closest Pixel is<br>   if current position plus (0, -1) is not empty<br>   {<br>      result &lt;-- current position plus (0, -1)<br>   }<br>   if current position plus (+1, -1) is not empty<br>   {<br>      result &lt;-- current position plus (+1, -1)<br>   }<br>   if current position plus (+1, 0) is not empty<br>   {<br>      result &lt;-- current position plus (+1, 0)<br>   }<br>   if current position plus (+1, +1) is not empty<br>   {<br>      result &lt;-- current position plus (+1, +1)<br>   }<br>   if current position plus (0, +1) is not empty<br>   {<br>      result &lt;-- current position plus (0, +1)<br>   }<br>   if current position plus (-1, +1) is not empty<br>   {<br>      result &lt;-- current position plus (-1, +1)<br>   }<br>   if current position plus (-1, 0) is not empty<br>   {<br>      result &lt;-- current position plus (-1, 0)<br>   }<br>   if current position plus (-1, -1) is not empty<br>   {<br>      result &lt;-- current position plus (-1, -1)<br>   }<br>return<br><br><br>Algorythm Find direction of Closest Pixel is<br>   if current position plus (0, -1) is not empty<br>   {<br>      result &lt;-- 0<br>   }<br>   if current position plus (+1, -1) is not empty<br>   {<br>      result &lt;-- 1<br>   }<br>   if current position plus (+1, 0) is not empty<br>   {<br>      result &lt;-- 2<br>   }<br>   if current position plus (+1, +1) is not empty<br>   {<br>      result &lt;-- 3<br>   }<br>   if current position plus (0, +1) is not empty<br>   {<br>      result &lt;-- 4<br>   }<br>   if current position plus (-1, +1) is not empty<br>   {<br>      result &lt;-- 5<br>   }<br>   if current position plus (-1, 0) is not empty<br>   {<br>      result &lt;-- 6<br>   }<br>   if current position plus (-1, -1) is not empty<br>   {<br>      result &lt;-- 7<br>   }<br>return<br><br>[/CODE]<br><br>Of course the implementation is more complicated as it has to check if the target position is inside of the (0, 0) - (49, 49) bounding rectangle among other things.<br><br>The algorythm above actualy works, but has the undesirable effect of finding the "smallest lines".<br>This will explain the problem better:<br><br>[CODE]<br>   .XXXX.....<br>   .....XXXX.<br>   ..........<br><br>Would be considered to be two separeted 4 pixel long lines.<br>See?<br><br>Then I figured: well, while the last line´s lenght is same as the previous one, then this line is still the same line.<br><br>But I also figured that there are lines that look like this:<br><br>   .XXXX.....<br>   .....X....<br>   ......XXXX<br>[/CODE]<br><br>So, what do you think I could do?<br>I believe that the answer is not too far from what I am doing, but I just have not been able to pull it off my head :(<br>Or it could not be that simple, at all...<br><br>Any ideas?<br><br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="281523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rui,<br><br>Here's the radar algo. It will always produce a list of 36 vectors at present. List can be changed by increasing or decreasing sample size.<br><br>CAVEAT: It won't do a poly shaped like the outline of the letter "C" (well, not correctly).<br><br>It take 860+ millisecs to process on a 1Ghz AMD, can be optimized by using readpixelfast. You could also store the image in a bank for further speed increase.<br><br>make sure the polygon you draw does not have "holes/missing pixels" in lines defining polygon.<br><pre class=code>
Graphics 640,480,16,2
SetBuffer BackBuffer()

Dim vec(360,1),vtx(360,1)

Text 0,0,"Hold left mouse button to draw a polygon ih the box"
Text 0,16,"Click right mouse button in box to begin vectorization"

Text 0,48, "ESC To Exit"
Flip


Rect(50,80,52,52,False)
Flip
While Not MouseHit(2)
	If MouseDown(1)
		mx = MouseX()
		my = MouseY()
		If mx &gt; 50 And mx &lt; 101 And my &gt; 80 And my &lt; 131 Then
			Oval mx-1,my-1,2,2,True
		End If
	End If
	Flip
Wend

st = MilliSecs()

;get max values 360 degrees around center point
For i = 0 To 359
	mag(75, 105, i)
Next

;look for increase/decrease at 10 degree intervals	
count = 0
lastMax=0
Max = 0
For i = 0 To 350 Step 10
	increasing = 0
	decreasing = 0
	flat = 0
	currentMax = 1
	For j = 0 To 9
		currentAngle = (i + j) Mod 360
		previousAngle = (currentAngle + 359) Mod 360
		nextAngle = (currentAngle + 1) Mod 360
		
		If vec(currentAngle,1) &gt; vec(previousAngle,1) And vec(currentAngle,1) &lt; vec(nextAngle,1) Then
			currentMax = chkMax(lastMax,vec(nextAngle,1))
			lastMax = currentMax
			incAngle = currentAngle
			increasing = increasing + 1
		End If

		If vec(currentAngle,1) &lt; vec(previousAngle,1) And vec(currentAngle,1) &gt; vec(nextAngle,1) Then
			currentMax = chkMax(lastMax,vec(previousAngle,1))
			lastMax = currentMax
			decAngle = currentAngle
			decreasing = decreasing + 1
		End If
		
		If vec(previousAngle,1) &lt; vec(currentAngle,1) And vec(currentAngle,1) = vec(nextAngle,1) Then
			currentMax = chkMax(lastMax, vec(currentAngle,1))
			lastMax = currentMax
			flatAngle = currentAngle
			flat= flat + 1
		End If
		
		If vec(previousAngle,1) = vec(currentAngle,1) And vec(currentAngle,1) &gt; vec(nextAngle,1) Then
			currentMax = chkMax(lastMax, vec(currentAngle,1))
			lastMax = currentMax
			flatAngle = currentAngle
			flat = flat + 1
		End If
		
		If vec(previousAngle,1) = vec(currentAngle,1) And vec(currentAngle,1) = vec(nextAngle,1) Then
			flatAngle = currentAngle
			flat = flat + 1
		End If
	Next
	If increasing &gt;= decreasing And increasing &gt;= flat Then useAngle = incAngle
	
	If flat &gt;= increasing And flat &gt;= decreasing Then useAngle = flatAngle
	
	If decreasing &gt;= increasing And decreasing &gt;= flat Then useAngle = decAngle

	count = count + 1
	vtx(count,0) = Cos(useAngle)* vec(useAngle,1)+175
	vtx(count,1) = Sin(useAngle)* vec(useAngle,1)+105
Next 

;Draw the vectors in a box to the right
Rect(150,80,52,52,False)
For i = 1 To count-1
	Line vtx(i, 0), vtx(i,1), vtx(i+1,0), vtx(i+1,1)
Next
Line vtx(count,0), vtx(count,1), vtx(1,0), vtx(1,1) ;connect last point to first point
et = MilliSecs() - st

Text 0,400,"Finished vectorizing"
Text 0,415,"Elapsed Time: " + et
Flip

While Not KeyHit(1):Wend
End

;This function finds pixels @ given angle
;and stores max values in vec() array
Function mag(centerX%, centerY%, angle%)
	vec(1,1) = 1
	For i% = 2 To 35
		x% = Cos(angle) * i + centerX
		y% = Sin(angle) * i + centerY
		If x &gt; 50 And x &lt; 101 And y &gt; 80 And y &lt; 131 Then
			If (ReadPixel (x,y) And 16777215) &lt;&gt; 0 Then
				If i &gt; 1 Then
					;compare current max to previous max, save biggest
					max = chkMax( vec(angle,1), i)
					
					vec(angle,1) = max
				End If
			End If
		End If
	Next
End Function
					

Function chkMax(a,b)
	If a &gt;= b Then
		Return a
	Else
		Return b
	End If
;	Return max
End Function
</pre><br><br><br>Cheers,<br><br>Andy <br><br></td></tr></table><br>
<a name="281535"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, Andy_A !<br><br>Man, That one is perfect!<br>Great alorythm...<br>It really works VERY WELL.<br><br>I don´t want to bother you, but do you think that my algorythm could somehow be changed so it could actualy work?<br>Your solution is perfect, and I am going touse it, almost as it is (i will work on a bank, thou).<br><br>But would like to hear from you what you think about the algo I wrote.<br>Maybe you can find a fix for it.<br><br>Cheers,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="281549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I thought about your algo some more because it is inherently faster, and a possible fix is to average out the slope of the line between pixels<br><br>Here's some pseudo-code<br><pre class=code>
Starting with seed pixel
For i = 1 to 10

   Find next pixel (clockwise, could be up,down or right)is slope 1?
      YES: this is a vertical segment, increment magnitude of current vector by 1, slope(i) = 1
      NO: 
         Is slope 0?
         YES: this is a horizontal segment, inc mag of current vector by 1, slope(i) = 0
         NO: get slope of line between pixels, slope(i) = calculated slope
   count = count + 1
   If i &gt; 1 then
       is ABS(slope(i)-slope(i-1)) greater than threshold value?
       YES: Exit from loop
   End If
Next i

For i = 1 to count
   AVG = AVG + slope(i)
Next
   vector = lengthOfLine with slope of AVG/count
   Store in vector in array of length and slope

find pixel 10 searches away from seed pixel position and repeat process above until you encounter seed pixel again.

Connect the vectors
</pre><br><br>You could repeat the process above a couple of times to reduce vector count at the cost of losing accuracy. It should still be fast if your doing all of this in memory.<br><br>That's all I can think of now.<br><br>Andy <br><br></td></tr></table><br>
<a name="281686"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Andy_A!<br><br>Do you want to try something a little bit more difficult?<br>Would you like a challenge?<br><br>If so, the here it is:<br><br>Take an input bitmap, just like the ones you can create with your rastr-to-vector program.<br>Now, for each pixel in the original bitmap, store in the output array (same sizes = 50 x 50) the angle of the line each pixel is in.<br>Angles should be specified with a programmable precision of, which could range from 2 degrees to 45 degrees, in 0.5 degrees steps.<br>You should not modify the original positions of the pixels.<br>The rpogram should only get the angle information for each pixel.<br><br>Do you think you can help me?<br>Please?<br>If I can get this thing working, I will be able to finish my game engine - and I will put your name in the credits.<br><br>Cheers,<br><br>Rui Barbosa Jr.<br>P.S.: How old are you?<br>If you are at least 18 years old, please check our other post, on the Blitz Plus Forum: "Write Blitz Plus Games and Make REAL $$$".<br>(I have no doubt you would be able to create something real cool for us - and get payed for it, with contract and everything - but please read that post, as I am not in charge of that matter anymore). <br><br></td></tr></table><br>
<a name="281879"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Rui,<br><br>Would be glad to try and help, so I am going to restate what I think you said to make sure I've got the right idea.<br><br>1) Start with a seed pixel<br>2) Find all consecutive pixels with same slope/angle and count that as a vector<br>3) repeat until done<br><br>That method will only find angles of 0, 90, 180, 360, 45, 135, 225, and 315. It will also create a relatively long list of vectors.<br><br>If you use the radar algo (slow as it is) and reduce the scanning angle increment from 1 to 0.5, you will end up with a smaller set of vectors than the pixel by pixel method.<br><br>How do you wish to proceed?<br><br>Regards,<br><br>Andy<br><br>P.S. Have read the other post, sounds very interesting and have replied to your email address (Marcos doesn't have his own email addy?).<br><br>I'm mainly interested in the different pokers games and slots. <br><br></td></tr></table><br>
<a name="281995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Andy_A.<br><br>Marcos is going to have his own address on monday.<br><br>Here´s the problem I need to find a solution for:<br><br>1. I have a 50 x 50 bitmap<br>2. This bitmap contains the noise-free scan of a hand-drawn polygon.<br>3. The line width ranges from 1 to 5 pixels.<br>(Different hand-drawn segments can have different widths, in the same bitmap!)<br>4. I need to scan the bitmap, using your algorythm, which gave me very good results.<br>5. BUT, The vectors will be used only to find out what the angle for that 10 degrees arc is.<br>I don´t erase the original pixels and replace them with the line described by the vector.<br>What I have to do is: for every pixel inside of that 10 degrees arc, I store the angle associated to that pixel, which is exactly the angle of the line segment found to be the resulting vector for that arc.<br><br>I hope you understood.<br>Please, let me know if that was not clear.<br><br>It would be great if you could create a function, which I could call and would do this, but it would be even better, if it allowed me to specify some parameters, so that I can change the specs later.<br>Params would be:<br><br>* Box Size (currently 50 pixels, but could be 100, for instance - or 128 pixels, etc...)<br>* Radar Scan Accuracy (Currently 10 degrees, resulting in 36 vectors, but could be 1 degree, resulting in 360 vectors - or 5 degrees, etc...)<br><br>These are the global vars the function would gave to work with:<br><br>Dim workBitmap%(50, 50)  ; Could be (100, 100) <br>                         ; for instance.<br>                         ; Holds the original bitmap<br>                         ; Each cell is a pixel (0 or 1)<br>Dim angle%(50, 50)       ; Angle to be assigned to each<br>                         ; pixel in the bitmap, in degrees.<br>                         ; Integer angles only, ranging from<br>                         ; 0 to 359 degrees.<br><br>So, in a few words, this is what it has to accomplish:<br><br>Assign values to the array angle%(50, 50), based on the original bitmap array workBitmap%(50, 50), using your radar algorythm.<br><br>It would be nice to be able to specify the size (provided the arrays are DIMed accordingly).<br>Also, it would be even better if one could specify the angle to be used by the radar algorythm.<br><br>Please, understand that this doesn´t have anything to do with the company I work for (i.e. casino games).<br>I am just asking you to help me figure out how to progress with my game engine.<br><br>Thank you *so* much for your help, Andy.<br><br>Cheers,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="282207"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thing I understand your requirements bettern now. Didn't take into account the different line width requirement, just traced the outline of the polygon. Will work on this after some rest (it's 2:07 am now). Will get back to you when I have something.<br><br>Andy <br><br></td></tr></table><br>
<a name="282236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Andy_A!<br><br>Thanks for your help.<br><br>If you can help me with that...<br><br>I was thinking about how this could be (efficiently) done.<br><br>One method could be:<br><br>While shooting the radar rays, looking for the max distance, set a flag for each pixel that was already scanned.<br>Then, after that, use some kind of flood-fill algorythm (recursive would be fine, because there wouldn´t be too many pixels to paint), which would then assign the found angle to all pixels between the previous scan-ray and the current-one, or the current one and the next one.<br><br>Cheers,<br><br>Rui Barbosa Jr.<br>P.S.: Thanks for your help.<br>If you don´t feel like writting tht function, please let me know.<br>At the moment, I am writting the hierarchy (bones) part of the engine, but will try to write that function, if you can´t help me.<br>Anyway, when the engine is completed, I will add your name to the credits (as well as other people names - people who helped me on other aspects of the engine). <br><br></td></tr></table><br>
<a name="282584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy_A</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> The radar ras2vec algo took 862+ ms (doh! I left debug on). It take about 750 ms without debug.<br><br>Here are the new algo times<br>   with debug 222 ms<br>without debug 153 ms<br><br>BTW, those are all times for windowed mode (so I could see the pointer while testing)<br><br><br>The new algo creates an exact copy of the sampled bitmap.<br><br>Let me know if this is what you had in mind.<br><pre class=code>

;===============================================================================
; 	Programmer: Andy Amaya
;     Program Name: Bitmap To Vectors
;             Date: Nov 4, 2003
;          Version: 1.003
;===============================================================================


Graphics 640,480,16,2
SetBuffer BackBuffer()

;set bitmap dimensions here
Const imgWide% = 50
Const imgHigh% = 50

;============================== Program Loop ===================================
Repeat
	;storage array for vectors
	;placed in loop to reset elements to zero on every iteration
	Dim vec(imgWide, imgHigh, 1)
	Cls
	Text 0,0,"Hold left mouse button to draw a polygon in the box"
	Text 0,16,"Click right mouse button in box to begin vectorization"
	Text 0,48, "ESC To Exit"
	Text 5,80, "Draw sample bitmap"
	Flip

;set the parameters
	x = 100
	y = 100
	wide = imgWide
	high = imgHigh

;draw in the rectangle to create bitmap
	draw(x, y, wide, high)

;start the timer
	st = MilliSecs()

;convert raster image to vectors
	vectorize (x, y, wide, high)

;stop timer here, we're only measuring time to sample &amp; vectorize
	et = MilliSecs() - st

;draw the stored vectors to the right of sampled bitmap
	drawVectors(x + wide + 10, y, wide, high)

;all done print elapsed time
	Text 160, 80,"Vector Drawing"
	Text 10,300,"Raster to Vector Conversion Complete."
	Text 10,315,"Elapsed Time: " + et
	Flip

;press a key to run again
	WaitKey()

;press ESC to exit
Until KeyHit(1)
End

;===============================  Functions =====================================

Function draw(x%, y%, wide%, high%)
	Rect(x-1, y-1, wide + 2, high + 2, False)
	Flip
	While Not MouseHit(2)
		If MouseDown(1)
			mx = MouseX()
			my = MouseY()
			If mx &gt; x And mx &lt; x + wide + 1 And my &gt; y And my &lt; y + high + 1 Then
				Oval mx-1, my-1, 2, 2, True
			End If
		End If
		Flip
	Wend
End Function

Function vectorize(x%, y%, wide%, high%)
	;Read in pixel color values into an array
	For  j% = y  To y + high
		length = 0	;reset length counter at start of each row
		For i% = x To x + wide

			pix% = ReadPixel (i,j) And 16777215
			If pix &gt; 0 Then pix = 1

			;is pixel ON?
			If pix = 1 Then
				;is this the first pixel in the row?
				If i = x  Then
					;increase vector length
					length = length + 1
					;save x and y coords, and the length
					vec(i-x, j-y,  1) = length
					;make lastX the beginning location of the new vector
					lastX = i-x
					;save pixel state information for next iteration
					lastPix = 1
				Else
				;Not first pixel. Is the prior pixel position lit?
					If lastPix = 1 Then
						;If YES, increase current vector length
						length = length + 1
						;update and save length of the current vector
						vec(lastX, j-y, 1) = length
						;save pixel state information for next iteration
						lastPix = 1
					Else
						;If NO, this is a new vector
						;set vector length to 1
						length = 1
						;save the rowNum, then beginning column of new vector, and the length
						vec(i-x, j-y, 1) = length
						;make lastX the beginning location of the new vector
						lastX = i-x
						;save pixel state information for next iteration
						lastPix = 1
					End If
				End If
			Else
			;pixel is OFF
				;reset lastPix to zero, 
				lastPix = 0
				;reset length to zero
				length = 0
				;set vector array element to zero
				vec(i-x, j-y, 1) = 0
			End If
		Next
	Next
End Function

Function drawVectors(x%, y%, wide%, high%)
	;making a rectangle next to the drawing rectangle
	Rect(x-1, y-1, wide + 2, high + 2, False)
	For j% = 0 To high
		For i% = 0 To wide
			;if length is one, it's a point
			If vec(i, j, 1) = 1 Then Plot x, y
			
			;if length is greater than 1, it's a line
			If vec(i, j, 1) &gt; 1 Then
				length = vec(i, j, 1)
				Line( i+x, j+y, i + x + length, j+y)
			End If
		Next
	Next
End Function


</pre><br><br><br>Cheers,<br><br>Andy <br><br></td></tr></table><br>
<a name="283134"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Andy_A.<br>Yes, that´s almost it...<br>We need the angle of each pixel to be stored in the output array, thou.<br>Actualy, the radar algorythm was just perfect.<br>You would just need to take the angle computed by each vector´s slope and store assign that angle to each pixel within that specific scan (10 degrees arc).<br>Cheers,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="285575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Seldon</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe you already did, but here it is some code I had (not mine though and I don't know the author).<br><br>Function AngleBetween(x#,y#,xx#,yy#)<br>;Calculates the angle between two points.<br>;I had some problems with ATan2 so I wrote my own  :p<br>	<br>If xx-x=&gt;0 And yy-y&gt;=0 Then<br>angle=ATan((yy-y)/(xx-x))<br>ElseIf xx-x&lt;0 And yy-y&gt;=0 Then<br>angle=180+ATan((yy-y)/(xx-x))<br>ElseIf xx-x&lt;0 And yy-y&lt;0 Then<br>angle=180+ATan((yy-y)/(xx-x))<br>ElseIf xx-x=&gt;0 And yy-y&lt;0 Then<br>Angle=360+ATan((yy-y)/(xx-x))<br>End If<br>Return angle<br>End Function <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
