<!DOCTYPE html><html lang="en" ><head ><title >WriteString bug???</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >WriteString bug???</h1><a href="forums.php" >BlitzPlus Forums</a>/<a href="topics.php?forum=81" >BlitzPlus Programming</a>/<a href="#bottom" >WriteString bug???</a><br><br>
<a name="288104"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >cbmeeks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am writing to a file.<br><br>Here is the code:<br><br><pre class=code>
fileout = WriteFile(file$)				
WriteString fileout,"Hello"
WriteInt fileout,TILE_WIDTH
WriteInt fileout,TILE_HEIGHT
CloseFile(fileout)
</pre><br><br>Everything seems to work but when I open the file into a hex editor, I notice it puts 4 bytes in front of "Hello".<br>Why is that?<br><br>Thanks<br><br>cb <br><br></td></tr></table><br>
<a name="288108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> See the docs for explanation, there should be a SeeAlso WriteLine which is recomended method for writing ascii text. <br><br></td></tr></table><br>
<a name="288263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >julianbury</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> fileout = WriteFile(file$)<br>WriteString(fileout,"Hello")<br>WriteInt(fileout,TILE_WIDTH)<br>WriteInt(fileout,TILE_HEIGHT_)<br>CloseFile(fileout) <br><br></td></tr></table><br>
<a name="288321"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >cbmeeks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> julianbury, I tried adding the "(" and ")" but it still did the same thing.<br><br>I switched to WriteLine and it worked.  Well, it actually puts two bytes at the end of each string (0d 0a) but this is the linebreak/return and I can live with that.<br><br>Thanks guys<br><br>cb <br><br></td></tr></table><br>
<a name="288397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jondecker76</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is nothing wrong with writestring - it is supposed to put an integer before the string (4 bytes). This is so that when you use readstring, it knows how many bytes to grab from the file or stream. <br><br></td></tr></table><br>
<a name="288413"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've wondered why it needs a whole 4 bytes for the length of the string. Why not 2? Who uses a string longer than 65535 characters!?<br><br>Or one byte for the number of bytes for the length, followed by the length. Then most short strings would fit in 2 bytes, but a huge string of 15 million characters could still fit into four bytes. That would be a lot more efficient. <br><br></td></tr></table><br>
<a name="288452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warren</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I've wondered why it needs a whole 4 bytes for the length of the string. Why not 2? Who uses a string longer than 65535 characters!?  <br></div><br>I think the answer is ... who cares?  :)<br><br>Are you really storing enough strings in your file where this becomes a storage constraint for you? <br><br></td></tr></table><br>
<a name="288515"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Who uses a string longer than 65535 characters!? <br></div>Well not the programmers of NotePad, that's for sure...<br><br>I'd reckon the Blitz IDE (for example) uses strings larger than 64K. <br><br></td></tr></table><br>
<a name="288521"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WolRon</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could use write string to load in an entire novel which may be larger than 64K (if I'm not mistaken, a string can include the linebreak, return characters so that your program could still print out the format correctly).<br><br>Or you could use it to load in some kind of specific data from a file that recorded a running string of values from something (like an internet connection?) that went on for hours.<br><br>SOMEBODY will find a use for it.<br><br><br>BTW, if you don't want the wasted space by the 2 or 4 characters then use Write/ReadByte instead.  Of course, you would have to know ahead of time how long the string is. <br><br></td></tr></table><br>
<a name="288541"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know, I can write my own string write/read functions.<br><br>And I know that 2 bytes isn't the end of the world.<br><br>But why didn't anyone deciding the format of a string stored in this way (as opposed to null-terminated) do it with a byte for the number of bytes for the length? In 90% of cases it would save 2 bytes per string. It's not much, but it's still a fairly obvious way to do it, and if it saves space, why not? <br><br></td></tr></table><br>
<a name="288549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Blitz strings are allowed to contain nulls Chr$(0) so null termination is out, and HTML pages are a good example of string handling where you could easily break a 64K limit. <br><br></td></tr></table><br>
<a name="288660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know.<br><br>But doing it with a byte to store the length of the length, means you can have any strings up to 4,294,967,295 characters long (as you can now), yet MOST strings will only take up 2 bytes for the "header" rather than always using 4 as they do now.<br><br>Seems a more logical way to do it to me... <br><br></td></tr></table><br>
<a name="288675"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jondecker76</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> i like the way it works now. It is a matter of pure convenience. You can store a string - whether its 2 characters or 10,000 - and not have to worry about how to retrieve it. I'm using it extensively in a project of mine where strings can easily go beyond 10-20,000. Instead of having to write my own parsing routine to find a null terminator character, I just use one function. Sure has made my project a lot easier to deal with.<br><br>Also, its great for saving\loading type collections <br><br></td></tr></table><br>
<a name="288754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's simple enough:<br><br><pre class=code>
Function RottbottReadString$(File)
  LenLen = ReadByte(File)
  For i = 1 To LenLen : SLen$ = SLen$ + Chr$(ReadByte(File)) : Next
  For i = 0 To LenLen - 1
    Len = Len Or (Asc(Mid$(SLen$, i + 1, 1)) Shl i * 8)
  Next
  For i = 1 To Len
    In$ = In$ + Chr$(ReadByte(File))
  Next
End Function
</pre><br><br>You could use a bank with ReadBytes() to make it quite a lot more efficient. The equivalent WriteString would be even simpler. <br><br></td></tr></table><br>
<a name="288835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MSW</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I know, I can write my own string write/read functions. <br><br>And I know that 2 bytes isn't the end of the world. <br><br>But why didn't anyone deciding the format of a string stored in this way (as opposed to null-terminated) do it with a byte for the number of bytes for the length? In 90% of cases it would save 2 bytes per string. It's not much, but it's still a fairly obvious way to do it, and if it saves space, why not? <br> <br></div><br><br>Decideing the string format?<br><br>Um...there really is no set in stone string format, the CPU can't tell the difference between a 4 byte number stored in one of it's registers and a string of 4 characters without some extra overhead provided by the program provided opcodes to present the string onscreen through a font or "print text" routine.<br><br>As such it is up to the developers of the compiler to implament string formats...and Mark has chosen to go with a simple but very flexable structure...internaly within Blitz it makes a lot of sense to use a 32-bit integer to store the length of the associated string...Remember that a string can be passed to various functions (actually a memory "pointer" is PUSHed onto the stack, to be POPed once the function code executes)...and if you had several versions of a string (a "short" string with a 1 byte header..."medium" string with 2 byte header, etc) then this will cause all sorts of problems as during the execution of your application you may pass the same function routine a "short" string most of the time, but every so often a "medium" string is passed because you are 1 character over the 256 character "short" string limit...it is then up to the code in the function to decifer just what sort of string it has been passed...by keeping it simple Blitz can use the exact same core opcodes for strings everywhere within the application...<br><br>You can write your own string file saveing functions...as you have direct knowledge of what strings you will need, how long they are, etc...Mark didn't know what you had in mind when developing Blitz so he kept things much simpler to accomidate as many programing situations as possable...<br><br>I use strings for just about everything, from storeing text as strings are designed to do...to useing them to store graphics, linked lists with parent/child relationships, radix sorting routines, just about everything where I need to have axcess to individual bytes (chars)...strange but true. <br><br></td></tr></table><br>
<a name="288865"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well once the string was read from the file/stream it would be stored however Blitz stores them at the moment, so it wouldn't make processing any more complex. I'm not talking about internal operations on strings, *just* the read/write functions. There's no point saving a even a few hundred k of RAM these days, but that much could make a difference for sending over an internet connection.<br><br>Obviously I can easily write my own read/write functions to do it this way, I'm just wondering why the built in ones don't, it just seems more sensible. I assume it's to save a CPU cycle or two, but that seems kinda pointless. CPU cycles aren't the limiting factor for very many things, especially sending data over a network. <br><br></td></tr></table><br>
<a name="288897"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MSW</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> It doesn't because it would still need some other flag system to indicate if the string it is reading from a file is of the 1, 2, 3, or 4 bytes "header types" (and as a byte is the smallest single construct that can be written/read from a file...this seperate flag system would use it's own byte even if only a couple of bits within it are actualy used...)...and useing a special character to indicate the end of a string is kinda wasteful in that Blitz needs to allocate system memory to store such a string, which it will have to allocate a certan amount...read the string, and if the string is larger then this amount (Blitz hasn't reached that special character) it would have to re-allocate more memory to continue reading in the string...which can be a perfomance issue, but the real problem comes from that special character in that it completely limits what you can do with strings (imagine sending out a packet over the internet with the recieveing computer getting the special character before it gets the rest of the string...<br><br>Remember that there are lots of seldom used characters in a string...what you can do is assign some of these a "flag" like status...then the user may type in some text to send online to another player...in your code you can then stake that string...add the character for one of these special "flags" to it and then add the BIN() values of the variables associated with that flag all into one string...and send it out over the net...the recieveing computer then can "decipher" the string finding that it contains some text to display onscreen and useing the sepecial character "flags" to do other things like move the specific character onscreen, etc...it's going to send out such special flags anyway for each seperate bit of data sent over the net, might as well take advantage of strings to save on packet size (hint: you can use one special character flag to indicate that the next several bytes are part of a block of data...instead of sending the X,Y,Z values of the location of a player as seperate variable values...set up a construct like Packet$ = Char$(special flag) + BIN(playerX) + BIN(PlayerY) + BIN(playerZ)....this will result in a string 17 bytes long (4 byte string "header" + 1 byte special character flag + 4 bytes each for player X,Y, and Z)...sending it as per variable value includes special blitz "flags" so it can decipher what the variable is supposet to be (float, integer, string) so sending a packet containing just playerX, playerY and playerZ may use 24 bytes as each would possably be seperated by a 4 byte flag used to indicate both type of variable and where in the packet it exist)...remember Mark doesn't know exactly what you will be sending across the net and storeing in a file...only you do... <br><br></td></tr></table><br>
<a name="288916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> why would you write numerical values as strings.. why not use:<br><br>writebyte, writefloat, writeshort etc?<br><br>there is also write/readbytes which can write to a stream to/from a bank as well... <br><br>Skully <br><br></td></tr></table><br>
<a name="288983"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It doesn't because it would still need some other flag system to indicate if the string it is reading from a file is of the 1, 2, 3, or 4 bytes "header types" (and as a byte is the smallest single construct that can be written/read from a file...this seperate flag system would use it's own byte even if only a couple of bits within it are actualy used...)...and useing a special character to indicate the end of a string is kinda wasteful in that Blitz needs to allocate system memory to store such a string, which it will have to allocate a certan amount...read the string, and if the string is larger then this amount (Blitz hasn't reached that special character) it would have to re-allocate more memory to continue reading in the string...which can be a perfomance issue, but the real problem comes from that special character in that it completely limits what you can do with strings (imagine sending out a packet over the internet with the recieveing computer getting the special character before it gets the rest of the string... <br></div><br><br>Firstly, I've never mentioned wanting to use null-terminated strings. They aren't an issue at all. I merely mentioned in passing that null-terminated was the other way of storing strings, and NOT the one that I was interested in.<br><br>Nor do I have a problem sending my data over the network, in fact I use BlitzPlay which takes care of all that for me, even as far as compressing floats and ints into strings... so I don't have to worry about the exact format of messages.<br><br>My simple question is, why isn't my suggested string format used by Blitz (or other languages) for reading/writing to streams and files? There seems no logical reason why not, and in 99.9% of cases it is more efficient by 2 bytes per string. <br><br></td></tr></table><br>
<a name="289007"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> A method that polls a stream for arrival of a complete string with the ReadAvail (to avoid blocking) would be even more complicated than your example code above.<br><br>Currently the presence of 4 bytes available on the incoming stream guarantees you can read the string length without blocking. <br><br></td></tr></table><br>
<a name="289165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rottbott</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> A method that polls a stream for arrival of a complete string with the ReadAvail (to avoid blocking) would be even more complicated than your example code above. <br><br>Currently the presence of 4 bytes available on the incoming stream guarantees you can read the string length without blocking. <br></div><br>That's true. You'd have to wait for one byte available, read it, and then decide if you have to wait any longer for the next 1-4 bytes. It's an extra step from what you have to do now, but not a very CPU intensive one. Not too hard to code though if you know the string format? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
