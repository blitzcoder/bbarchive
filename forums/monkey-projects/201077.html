<!DOCTYPE html><html lang="en" ><head ><title >Monkey-JSON</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Monkey-JSON</h1><a href="forums.php" >Monkey Archive Forums</a>/<a href="topics.php?forum=511" >Monkey Projects</a>/<a href="#bottom" >Monkey-JSON</a><br><br>
<a name="2009294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've put together the beginnings of a JSON library for my own purposes and thought it may be of use to others so I've uploaded it to here: <a href="http://code.google.com/p/monkey-json/" target="_blank">http://code.google.com/p/monkey-json/</a><br><br> I've done very little testing, so caveat programmator. I'm sure I'll find plenty wrong with it as I use it, but feel free to make suggestions or patches or fork it or whatever. <br><br></td></tr></table><br>
<a name="2009315"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Have you tried the JSON library that comes with Monkey samples? I have played a bit with it and it works pretty well. What's the point in making another JSON library? <br><br></td></tr></table><br>
<a name="2009319"></a>

<a name="2009321"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> To be honest, no I wasn't aware of the json example. It wouldn't occur to me to dig through an examples folder looking for a fully functional data parsing library that you might expect to be part of the standard library set.<br><br>However, plenty of languages have multiple implementations of the same functionality, and that includes JSON processing libs (of which Python has four, Java has over a dozen). Now Monkey has two. <br><br></td></tr></table><br>
<a name="2009322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, but which implementation is the best? That's my only question. :) <br><br></td></tr></table><br>
<a name="2009327"></a>

<a name="2009328"></a>

<a name="2009329"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've no idea except to say that mine will ultimately be better for me. It looks like the other one is a port from an older blitz language so it's highly likely to be better tested at this point. I'd use that one if I were you.<br><br> I'm not in the business of trying to own the Monkey JSON parsing market, there's even less money in that than the Monkey physics library market.<br><br>Edit: And it looks like the example code does something with unicode escape sequences, which I haven't started looking at seeing as the Monkey docs are completely silent on the subject of strings and unicode. If that works then the example is definitely the better option...  for a few days, anyway. <br><br></td></tr></table><br>
<a name="2009332"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would guess that my library (the one in the examples) is not the best. <br><br></td></tr></table><br>
<a name="2009333"></a>

<a name="2009334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> There you go, that's settled then. Neither one is the best. Write your own. :) <br><br></td></tr></table><br>
<a name="2017148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> wooooo spooky thread ressurection, just in time for halloween!<br><br>muddy_shoes:  I needed a good json library to deserialize my levels from another app I wrote, and yours seems to fit the bill really well since it seems to be really easy to get stuff out of it.  However, I'm a little bit lost on getting an array of objects into my data structures.<br><br>What's the proper way using your json library to take an array of JSONObjects and iterate through them using a For EachIn loop?  I see an ObjectEnumerator in there, but I really don't know how to leverage this.  Let me get you an example of what one of my data structures looks like, in JSON:<br><br><pre class=code>
{
 "Background":"0.png",
 "Balls":[
  {"r":12,"x":240,"y":240,"_mass":1},
  {"r":12,"x":448,"y":240,"_mass":1}],
 "Bumpers":[],
 "Holes":[
  {"r":16,"x":112,"y":416},
  {"r":16,"x":400,"y":416}],
}
</pre><br><br>and so on, and so forth.  Here is some sample code I'm using to parse it in:<br><br><pre class=code>
	Local test:String = LoadString("maps/2.json")
	Local data:JSONDataItem = JSONData.ReadJSON(test)
	Local jsonObject:JSONObject = JSONObject(data)
	Local b:JSONArray = jsonObject.GetItem("Balls")

	For o:JSONObject = EachIn b	'Almost certainly wrong
		'Do another For EachIn in the inner structure and add to our game's true object list
	Next 
</pre><br><br>any help you can provide would be appreciated.  Thanks again for a nice lib :3 <br><br></td></tr></table><br>
<a name="2017149"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this helpful?:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import json

Function Main()

    Local test:String = "{~qBackground~q:~q0.png~q,~qBalls~q:[{~qr~q:12,~qx~q:240,~qy~q:240,~q_mass~q:1},{~qr~q:12,~qx~q:448,~qy~q:240,~q_mass~q:1}],~qBumpers~q:[],~qHoles~q:[{~qr~q:16,~qx~q:112,~qy~q:416},{~qr~q:16,~qx~q:400,~qy~q:416}]}"

    Local data:JSONDataItem = JSONData.ReadJSON(test)
    Local jsonObject:JSONObject = JSONObject(data)
    Local b:JSONArray = JSONArray(jsonObject.GetItem("Balls"))

    For Local di:JSONDataItem = EachIn b
        Local do:JSONObject = JSONObject(di)
        Print do.ToString()
    End 
End 
</textarea><br><br>I'll revisit the lib at some point and see if the recent changes to Monkey can avoid some of the casting that is currently necessary. <br><br></td></tr></table><br>
<a name="2017170"></a>

<a name="2017171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't think casting was gonna work, but it looks like it did.  Nice work dudester, I'll let you know if I run into any other issues down the road!  Thanks a bunch.  Great library, btw.  It is very OO in a way I can easily grasp. <br><br></td></tr></table><br>
<a name="2025105"></a>

<a name="2025106"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've updated this. <br><br>There are a couple of minor utility additions that were handy for me: Clear() methods on JSONObject and JSONArray and GetItem methods on JSONObject that take a default value to return if the requested item doesn't exist.<br><br>The bigger change that might make it worth grabbing for anyone using it in anger is that I've done some optimisation, including cleaning out a load of string additions. It's considerably faster now, especially on Android. <br><br></td></tr></table><br>
<a name="2025151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The bigger change that might make it worth grabbing for anyone using it in anger is that I've done some optimisation, including cleaning out a load of string additions. <br></div><br>Feel free to use/clone the StringBuilder class in Diddy.  It uses a dynamic Int array and has a ToString method that uses the new String.FromChars().<br>It depends on the Arrays utility class, but you could roll out your own.<br><br><a href="http://code.google.com/p/diddy/source/browse/trunk/src/diddy/stringbuilder.monkey" target="_blank">http://code.google.com/p/diddy/source/browse/trunk/src/diddy/stringbuilder.monkey</a> <br><br></td></tr></table><br>
<a name="2025150"></a>

<a name="2025149"></a>

<a name="2025166"></a>

<a name="2025167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just re-used the StringBuilder technique that I used in my LZW compression experiment. It uses an array of strings that are then pulled together with<br><br><pre class=code>
    "".Join(array)
</pre><br><br>I'll maybe do some tests with the Int array technique but that would seem to require copying the input strings to the Int array, so I'm not sure it would be faster.<br><br>I did borrow/steal the ASCII constants from Diddy to save time though. Thanks! <br><br></td></tr></table><br>
<a name="2025174"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Currently testing this. The results so far aren't particularly conclusive. On every platform (that I can test, so no iOS/WP7/XBox included) the addition operation is faster using a string array, as expected, but that's not a big chunk of time. On every other platform than Android, joining an array of strings is faster. On Android though, it's about 50% slower* for collections of short-ish strings, but the advantage disappears once the strings get to 10 chars or so on average.<br><br>The thing is that the other platforms are so fast at doing this stuff that the visible difference is negligible but on Android that 50% can be significant if you're writing large chunks of JSON. I'm going to do some more measuring. It might be a case where it's worth doing something specific for Android.<br><br>*That's with a slightly optimised Join method. The standard Monkey version is slower again. <br><br></td></tr></table><br>
<a name="2025170"></a>

<a name="2025169"></a>

<a name="2025181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, so after some poking around I've got a bit more of a grasp of this. It was a useful exercise as it shook out a couple of improvements that made a big difference.<br><br>To work out representative tests I did some measuring of my own usage of JSON for saving game data. Overall, the average string length is 5-ish, so I've used test strings of five chars. In terms of numbers of strings being put together, there were three interesting cases that I did timings on over 1000 runs on my ZTE Blade.<br><br>First, there are plenty of instances where only one string is added. This may seem odd, but I imagine it's not that uncommon in generalised systems. As it turns out my StringBuilder was a bit dumb about this case so fixing that ended up with:<br><br>JSON SB Num strings: 1<br>Add- avg(ms): 0.007<br>Combine- avg(ms): 0.004<br>Avg Total: 0.011<br><br>Diddy SB Num strings: 1<br>Add- avg(ms): 0.027<br>Combine- avg(ms): 0.028<br>Avg Total: 0.055<br><br><br>The second case was the most common concatenation of 16 strings. Examining this pointed out that I was joining the whole string array even if only part of it was populated. Changing that to pass the used slice of the array resulted in:<br><br>JSON SB Num strings: 16<br>Add- avg(ms): 0.094<br>Combine- avg(ms): 0.174<br>Avg Total: 0.268<br><br>Diddy SB Num strings: 16<br>Add- avg(ms): 0.235<br>Combine- avg(ms): 0.154<br>Avg Total: 0.389<br><br><br>The final case is the current largest concatenation of 6000 or so strings:<br><br>JSON SB Num strings: 6000<br>Add- avg(ms): 18.257<br>Combine- avg(ms): 63.766<br>Avg Total: 82.022995<br><br>Diddy SB Num strings: 6000<br>Add- avg(ms): 61.58<br>Combine- avg(ms): 42.134<br>Avg Total: 103.714005<br><br>On this run I also included a second scenario for the JSONSB which allows for the fact that I can generally know how large the builder array needs to be ahead of time and avoid resizing.<br><br>JSON SB Num strings with size predict: 6000<br>Add- avg(ms): 12.586<br>Combine- avg(ms): 56.68<br>Avg Total: 69.266<br><br>So, for now it seems as if the StringBuilder I've got is the better choice for my usage although there's not a huge amount in it. I'll have to re-run the tests when I eventually get an iOS device just to check if it's still true there. <br><br></td></tr></table><br>
<a name="2034933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> muddy, i'm trying to import the following JSON:<br><br><pre class=code>
{
	"Simple Tap":			[ [ [1] ] ],
	"Double Tap":			[ [ [1],[2] ] ],
	"Triple Tap":			[ [ [1],[2],[3] ] ],
	"Quad Tap":			[ [ [1],[2],[3],[4] ] ],
	"Quad Tap Double Back":		[ [ [1],[2],[4],[3] ] ],
	"Single Double":		[ [ [1,3],[2] ] ],
	"Triple Back and Forth":	[ [ [1],[2,4],[3] ] ],
	"Three Drum Intervals": 	[ [ [1,3],[2],[4] ] ],
	"Angled Triple": 		[ [ [1],[2] ], [ [3],[] ] ],
	"Four Square Reverse": 		[ [ [1],[2] ], [ [3],[4] ] ],
	"Four Square Rounder": 		[ [ [2],[1] ], [ [3],[4] ] ]
}
</pre><br><br>I basically want to name the patterns. How can I get this into a useful array/object?<br><br>Currently, I'm just doing this:<br><br>[monkeycode]<br>g.dPatterns = [<br>	[ [ [1] ] ],<br>	[ [ [1],[2] ] ],<br>	[ [ [1],[2],[3] ] ],<br>	[ [ [1],[2],[3],[4] ] ],<br>	[ [ [1],[2],[4],[3] ] ],<br>	[ [ [1,3],[2] ] ],<br>	[ [ [1],[2,4],[3] ] ],<br>	[ [ [1,3],[2],[4] ] ],<br>	[ [ [1],[2] ], [ [3], [] ] ],<br>	[ [ [1],[2] ], [ [3],[4] ] ],<br>	[ [ [2],[1] ], [ [3],[4] ] ] ]<br>[/monkeycode]<br><br>but, as you can see, there are no names associated with the patterns.<br><br>I want to be able to call up the pattern by number. As the user scrolls thru the available patterns, 0 to array.Length()-1, I can call the display (something like patterns[x][NAME]) and the actual pattern (patterns[x][PATTERN]).<br><br>Or maybe there's a better data object for managing data like this (a dictionary?).<br><br>Thanks! <br><br></td></tr></table><br>
<a name="2034935"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> The JSON library will let your read that and access the pattern arrays by name. You can also parse it out into a StringMap or an array or whatever else you'd like. I can't really follow what the patterns are meant to be to advise how you should store them though.<br><br>Extracting to variable size multi-dimensional arrays like in your example definition that isn't straightforward as you need to count out the elements to size your receiving array. <br><br></td></tr></table><br>
<a name="2034963"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess I need to know, once I load it in, how can I iterate through the objects or reference them? I'd like to get them in an array so I can loop through them but also reference them with a current_pattern variable.<br><br>Print myarray[x][NAME] ' "Single Tap"<br>current_pattern = myarray[x][PATTERN]<br><br>For t:1 to current_pattern.Length() ' or whatever<br>...<br><br>The pattern is just a series of buttons (drums, in this case), displayed in a grid.<br><br>Just saw your example iteration above... will attempt to utilize now... :-) <br><br></td></tr></table><br>
<a name="2034962"></a>

<a name="2034964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I keep getting nulls, so I'm not using this right. :-/<br><br>[monkeycode]<br>	Local levelsJSON:String = LoadString("levels.json")<br>	Local patternData:JSONDataItem = JSONData.ReadJSON(levelsJSON)<br><br>	Local jsonObject:JSONObject = JSONObject(patternData)<br>	Local b:JSONArray = JSONArray(jsonObject.GetItem("Simple Tap"))<br>	<br>	For Local di:JSONDataItem = EachIn b<br>	        Local do:JSONObject = JSONObject(di)<br>	        Print do.ToString()<br>	End<br>[/monkeycode]<br><br>levels.json contains the JSON object I display in #16 above. <br><br></td></tr></table><br>
<a name="2034985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> You get nulls because you're casting "do" to a JSONObject when the element isn't a JSONObject. <br><br></td></tr></table><br>
<a name="2034986"></a>

<a name="2034987"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> It looks like it is. X)<br><br>EDIT: Is it an IntArray?!<br><br>I just copy/pasted the code from your message #9 above, replacing it with my JSON string, and thought it would, POOF!, "just work" (tm).<br><br>Sorry, but... where am I going wrong, exactly?<br><br>I have been reading up on StringMap. That looks like a real good way to go! I just don't know how to get my JSON source into a StringMap. No doubt your lib can do it! <br><br></td></tr></table><br>
<a name="2034989"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> You need to understand your JSON. A JSON Object is defined by curly brackets and contains key:value pairs where the value can be any JSON type. JSON arrays are defined by square brackets containing comma separated lists of any JSON type. This:<br><br><pre class=code>
{
	"Simple Tap": [ [ [1] ] ]
}</pre><br><br>...defines a JSONObject containing one element named "Simple Tap" where the value is a JSONArray that contains a JSONArray that contains a JSONArray that contains an Integer. <br><br></td></tr></table><br>
<a name="2034988"></a>

<a name="2034991"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, and to my program, that array ([ [ [1] ] ]) represents a "board" with one row, with one button, with a tap number of 1.<br><br>+---+<br>| 1 |<br>+---+<br><br>Basically, a 3D array.<br><br><pre class=code>
"Three Drum Intervals":	[ [ [1,3],[2],[4] ] ]
</pre><br><br>That is a board with one row and three buttons (the first of which has sequence order of 1 and 3).<br><br>+-----+---+---+<br>| 1,3 | 2 | 4 |<br>+-----+---+---+<br><br><pre class=code>
"Four Square Rounder": [ [ [2],[1] ], [ [3],[4] ] ]
</pre><br><br>And that board has two rows of various buttons.<br><br>+---+---+<br>| 2 | 1 |<br>+---+---+<br>| 3 | 4 |<br>+---+---+<br><br>Obviously, I want to import these pattern configurations into a monkey object so I can iterate through them, grab a board pattern and display it, etc.<br><br>It looks like I can just use your JSON object to do this. Does it convert those JSON arrays into monkey arrays? It looks like it does.<br><br>When I do this:<br><br>[monkeycode]<br>	Local levelsJSON:String = LoadString("levels.json")<br>	Local patternData:JSONDataItem = JSONData.ReadJSON(levelsJSON)<br>	<br>    Local jsonObject:JSONObject = JSONObject(patternData)<br>    Local b:JSONArray = JSONArray(jsonObject.GetItem("Simple Tap"))<br>	If b = Null Then<br>		Print "It's null"<br>	Else<br>	    For Local di:JSONDataItem = EachIn b<br>			Print di.ToString()<br>	    End<br>	EndIf<br>[/monkeycode]<br><br>it prints out the array.<br><br>Also, how would I iterate through the "root" JSON object? I tried<br><br>[monkeycode]<br>Local b:JSONArray = JSONArray(jsonObject.GetItem(""))<br>[/monkeycode]<br><br>hoping it would grab all the objects for me, but that didn't seem to work. Is there a "root" object? Do I have to explicitly have all this in an object, say, "patterns?"<br><br>Thanks, muddy! Sorry to be such a bother... :-/ <br><br></td></tr></table><br>
<a name="2034995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> The library doesn't automatically convert JSON arrays to Monkey arrays because the JSON arrays can contain any type while Monkey arrays are fixed type. It's up to you to parse the JSON into whatever Monkey representation you want.<br><br>The root object is what you get back from JSONData.ReadJSON. In your case it's a JSONObject, but it could be a JSONArray.<br><br>Here, see if this helps:<br><br>[monkeycode]<br>Import json<br><br>Function To1DIntArray:Int[] (jsonArr:JSONArray)<br>    Local out:Int[] = New Int[jsonArr.values.Count()]<br>    Local i:Int = 0<br>    For Local jdi:JSONDataItem = EachIn jsonArr<br>        out[i] = jdi.ToInt()<br>        i += 1<br>    End<br>    Return out<br>End<br><br>Function To2DIntArray:Int[][] (jsonArr:JSONArray)<br>    Local out:Int[][] = New Int[jsonArr.values.Count()][]<br>    Local i:Int = 0<br>    For Local jdi:JSONDataItem = EachIn jsonArr<br>        out[i] = To1DIntArray(JSONArray(jdi))<br>        i += 1<br>    End<br>    Return out<br>End<br><br>Function To3DIntArray:Int[][][] (jsonArr:JSONArray)<br>    Local out:Int[][][] = New Int[jsonArr.values.Count()][][]<br>    Local i:Int = 0<br>    For Local jdi:JSONDataItem = EachIn jsonArr<br>        out[i] = To2DIntArray(JSONArray(jdi))<br>        i += 1<br>    End<br>    Return out<br>End<br><br>Function Main()<br><br>    Local data:JSONDataItem = JSONData.ReadJSON(test)<br>    Local jsonObject:JSONObject = JSONObject(data)<br>    <br>    Local patternMap:StringMap&lt;Int[][][] &gt; = New StringMap&lt;Int[][][] &gt;<br>        <br>    For Local patternName:String = EachIn jsonObject.Names<br>        Local da:JSONArray = JSONArray(jsonObject.GetItem(patternName))<br>        patternMap.Set(patternName, To3DIntArray(da))<br>    End<br>    <br>    For Local patternName:String = EachIn patternMap.Keys()<br>        Print patternName<br>    End<br>    <br>    Local pattern:Int[][][] = patternMap.Get("Angled Triple")<br>    Print pattern[0][0][0]<br>    Print pattern[0][1][0]<br>    Print pattern[1][0][0]<br>    <br>End<br><br>Global test:String = "{<br>	~qSimple Tap~q:			[ [ [1] ] ],<br>	~qDouble Tap~q:			[ [ [1],[2] ] ],<br>	~qTriple Tap~q:			[ [ [1],[2],[3] ] ],<br>	~qQuad Tap~q:			[ [ [1],[2],[3],[4] ] ],<br>	~qQuad Tap Double Back~q:		[ [ [1],[2],[4],[3] ] ],<br>	~qSingle Double~q:		[ [ [1,3],[2] ] ],<br>	~qTriple Back and Forth~q:	[ [ [1],[2,4],[3] ] ],<br>	~qThree Drum Intervals~q: 	[ [ [1,3],[2],[4] ] ],<br>	~qAngled Triple~q: 		[ [ [1],[2] ], [ [3],[] ] ],<br>	~qFour Square Reverse~q: 		[ [ [1],[2] ], [ [3],[4] ] ],<br>	~qFour Square Rounder~q: 		[ [ [2],[1] ], [ [3],[4] ] ]<br>} "<br>[/monkeycode] <br><br></td></tr></table><br>
<a name="2035005"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> muddy, I'm getting an error that says<br><br>   "Error : Identifier 'Names' cannot be used in this way."<br><br>on the line<br><br>   For Local patternName:String = EachIn jsonObject.Names<br><br>I couldn't run your code to test because I don't know how to make a string span multiple lines, and docs don't tell me. In other languages, there are ways to input a raw string like that ("""), but monkey apparently doesn't like it formatted like above. <br><br></td></tr></table><br>
<a name="2035008"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> That code is directly pasted from my editor. It works as is. If you're getting "Error : Identifier 'Names' cannot be used in this way." then you've clearly pasted parts of it into some other code that has "Strict" set. That's fine, but you can't expect me to debug your changes at a distance.<br><br>The error is just because "Names" is a method. Just add brackets. <br><br></td></tr></table><br>
<a name="2035007"></a>

<a name="2035009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> :D Thanks, muddy. I appreciate your time. <br><br></td></tr></table><br>
<a name="2035051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm loading in the JSON objects just fine now. Thanks, muddy!<br><br>Problem: they're coming in alphabetized! WTF?! That's not right.<br><br>I couldn't determine if it was the maps.keys basic functionality doing that, or if the JSON mod sorted them. (Searching for sort everywhere found nothing.)<br><br>Is there a parameter I can set that says, "Do not alphabetize the names?" I have the objects listed in "level #" order. I could always put another parameter in the JSON, if that's the better way to do it, but I'd rather it not alphabetize unless I specify I need that.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="2035053"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you're referring to the order in which the object element names are enumerated then it's a side-effect of the way that Monkey maps work. You should generally not assume that file order will be preserved when reading in data formats like JSON or XML. <br><br></td></tr></table><br>
<a name="2035057"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK. That's what I was afraid of. Time for a "level" parameter. :-/ <br><br></td></tr></table><br>
<a name="2035579"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> hey hey, it's been a while, and I might be using old code, but I just wanted to let you know that stuff exploded on me when I started using bools in my JSON file.  The reason has to do with Class JSONBool.ToString() and JSONTokenizer.NextToken().  In JSONBool.ToString is apparently used internally as well as externally, and it changes the case of valid bools in a JSON file.  The tokenizer doesn't have a case to check for this change.  To fix the problem, these lines must be changed to the following:<br><br>tokenizer.monkey, line 141:<br>[monkeycode]			Case "t" , "T"[/monkeycode]<br><br>tokenizer.monkey, line 145:<br>[monkeycode]			Case "f" , "F"[/monkeycode]<br><br><br>In addition, method JSONObject.ToJSONString() has a mistake on line 600 -- a Node object doesn't contain the ToString() member, so you need to change where it says v.Key.ToString()  to string(v.Key) if you want this to compile.  It probably wouldn't have come up if it weren't for the fact it's not used anywhere in the library.... <br><br></td></tr></table><br>
<a name="2035604"></a>

<a name="2035605"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> That does look like you're using older code. Could you get the latest version and see if that fixes your problem? I don't use bools a lot, but they do exist in my data files and it all seems fine.<br><br>ToString is different from ToJSONString where the JSON representation is at odds with Monkey/standard representations. Bools should be written out in lower case to JSON, so if you've still got a situation where that's not happening could you give a code example? <br><br></td></tr></table><br>
<a name="2035645"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello,<br><br>Both problems manifest when I try this code:<br><br>[monkeycode]<br>oList = JSONArray(jsonObject.GetItem("Magnets"))<br>if oList &lt;&gt; Null Then <br>For Local i:JSONDataItem = EachIn oList  <br>	' Both errors should manifest on the following line without the fixes<br>	Local x:JSONObject = JSONObject(JSONData.ReadJSON (i.ToJSONString))<br>	Local o:= New Magnet( float(x.GetItem("x")),float(x.GetItem("y")),float(x.GetItem("r")),float(x.GetItem("_energy")))<br>	o.ignoreCueball = bool(x.GetItem("_ignoreCueball"))<br>	Magnets.AddLast(o)<br>Next <br>End If <br>[/monkeycode]<br><br>example JSON file is here:<br><br><div class="quote"> {"Background":"44.png","Balls":[{"r":12,"x":128,"y":224,"_mass":1},{"r":12,"x":488,"y":224,"_mass":1},{"r":12,"x":488,"y":198,"_mass":1},{"r":12,"x":488,"y":172,"_mass":1}],"Bumpers":[],"Fields":[],"Holes":[{"r":16,"x":688,"y":224},{"r":16,"x":192,"y":64},{"r":16,"x":192,"y":400}],"Lines":[{"x":96,"x2":176,"y":224,"y2":32},{"x":704,"x2":592,"y":224,"y2":432},{"x":592,"x2":176,"y":432,"y2":432},{"x":176,"x2":96,"y":432,"y2":224}],"Magnets":[{"r":114,"x":688,"y":224,"_energy":1,"_ignoreCueball":true},{"r":102,"x":192,"y":64,"_energy":-1.5,"_ignoreCueball":false},{"r":97,"x":193,"y":401,"_energy":-1.5,"_ignoreCueball":false}],"Pegs":[]} <br></div><br><br>The problem appears to be how JSONBools are cast -- before fixing the ToJSONString code, I fed a more convoluted series of casts to ReadJSON() which somewhere along the way probably implicitly relied on JSONBool's ToString method, which return capitalized values (something maybe like encapsulating an abstract JSONDataItem in a string() cast and not caring what kind of subclass it was).  Monkey reported it as a downcast error at runtime, but it only tripped on Bools -- all other values returned something ReadJSON didn't choke on.<br><br><br>EDIT:  whatever new code you uploaded to the project site today looks vastly different from what code I have for the parser now.  There's a big char enum, apparent unicode support, and a lot of other stuff I haven't seen before!  I'm not sure I'm ready to integrate it into a live project yet, lol, but I might make a backup and give it a shot and see if anything breaks..... <br><br></td></tr></table><br>
<a name="2035644"></a>

<a name="2035643"></a>

<a name="2035647"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> This runs fine with my up-to-date version of the library:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import json

Function Main:Int()

    Local data:JSONDataItem = JSONData.ReadJSON(test)
    Local jsonObject:JSONObject = JSONObject(data)
    
    Local oList:JSONArray = JSONArray(jsonObject.GetItem("Magnets"))
    if oList &lt;&gt; Null Then
        For Local i:JSONDataItem = EachIn oList
            ' Both errors should manifest on the following line without the fixes
            Local x:JSONObject = JSONObject(JSONData.ReadJSON(i.ToJSONString()))
            Print "Magnet"
            Print float(x.GetItem("x"))
            Print float(x.GetItem("y"))
            Print float(x.GetItem("r"))
            Print float(x.GetItem("_energy"))
            Print x.GetItem("_ignoreCueball")
        Next
    End If
    
    Return 0
End

Global test:String = "{~qBackground~q:~q44.png~q,~qBalls~q:[{~qr~q:12,~qx~q:128,~qy~q:224,~q_mass~q:1},{~qr~q:12,~qx~q:488,~qy~q:224,~q_mass~q:1},{~qr~q:12,~qx~q:488,~qy~q:198,~q_mass~q:1},{~qr~q:12,~qx~q:488,~qy~q:172,~q_mass~q:1}],~qBumpers~q:[],~qFields~q:[],~qHoles~q:[{~qr~q:16,~qx~q:688,~qy~q:224},{~qr~q:16,~qx~q:192,~qy~q:64},{~qr~q:16,~qx~q:192,~qy~q:400}],~qLines~q:[{~qx~q:96,~qx2~q:176,~qy~q:224,~qy2~q:32},{~qx~q:704,~qx2~q:592,~qy~q:224,~qy2~q:432},{~qx~q:592,~qx2~q:176,~qy~q:432,~qy2~q:432},{~qx~q:176,~qx2~q:96,~qy~q:432,~qy2~q:224}],~qMagnets~q:[{~qr~q:114,~qx~q:688,~qy~q:224,~q_energy~q:1,~q_ignoreCueball~q:true},{~qr~q:102,~qx~q:192,~qy~q:64,~q_energy~q:-1.5,~q_ignoreCueball~q:false},{~qr~q:97,~qx~q:193,~qy~q:401,~q_energy~q:-1.5,~q_ignoreCueball~q:false}],~qPegs~q:[]} "
</textarea><br><br>So I can only suggest that you update your module. However, this line:<br><br>[monkeycode]Local x:JSONObject = JSONObject(JSONData.ReadJSON (i.ToJSONString))[/monkeycode]<br><br>Is unnecessarily recreating and then reprocessing the JSON. You only need to do this:<br><br>[monkeycode]Local x:JSONObject = JSONObject(i)[/monkeycode] <br><br></td></tr></table><br>
<a name="2035880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Damien! Help, please...<br><br>I need to convert the value part of the "Game" key into game:StringMap&lt;String&gt;.<br><br><pre class=code>
[{"Game":{"name":"My Game","secure_word":"","secure_status":"0","user_id":"9999","short_description":"Do the best you can!","description":"This game fun game win good like.","game_type":"arcade","version":"1.0","levels":"11","platform":"HTML5, Android, iOS","play_url":"","website_url":"","created":"2012-08-03 02:38:32","updated":"2012-08-07 22:39:16","players_count":"1","scores_count":"3","locked":"0","status":"1"}}]
</pre><br><br>I've tried all kinds of iterations of code without success. I keep getting "can't use Names on null" or somesuch.<br><br>The brackets in the string make me think I might need to get a JSONArray first, but I'm not really sure. So, now it's time to ask for help. :-)<br><br>Thank you! <br><br></td></tr></table><br>
<a name="2035882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK, I've got some code that seems to work. Am I close?! :-)<br><br>[monkeycode]<br>' result is the raw string<br>Local data:JSONDataItem = JSONData.ReadJSON(result)<br>Local jsonObject:JSONObject = JSONObject(data)<br>' since it's a JSON object with one k:v set:<br>Local jobj:JSONObject = JSONObject(jsonObject.GetItem("Game"))<br><br>game.Clear()<br><br>For Local a:String = EachIn jobj.Names()<br>    Local da:String = jobj.GetItem(a)<br>    game.Set(a, da)<br>End<br>[/monkeycode] <br><br></td></tr></table><br>
<a name="2035916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> I figured it out! Score.<br><br>Edit: If there's an error somewhere along the way, how do I detect it and figure out what it is?<br><br>Thanks! <br><br></td></tr></table><br>
<a name="2035912"></a>

<a name="2035956"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> If the JSON is invalid in some way then the library prints some information on what is wrong and where in the string the issue occurred. You seem to be having problems with knowing when you'll get a JSONObject or a JSONArray though and the library can't do much with that. <br><br></td></tr></table><br>
<a name="2036109"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm getting this from Scoreoid:<br><br><pre class=code>
[{"Score":{"id":"3212190","game_id":"747","player_id":"306171","score":"10","created":"2012-08-07 22:50:24","difficulty":"0","platform":"HTML5"}},{"Score":{"id":"3257579","game_id":"747","player_id":"306171","score":"6","created":"2012-08-10 03:59:27","difficulty":"0","platform":"HTML5"}},{"Score":{"id":"3265083","game_id":"747","player_id":"306171","score":"5","created":"2012-08-10 15:38:17","difficulty":"0","platform":"console"}}]
</pre><br><br>I'm using this to parse it into a scores object:<br><br>[monkeycode]<br>result = "{" + result[2 .. - 1] + "}"<br>Local data:JSONDataItem = JSONData.ReadJSON(result)<br>Local jsonObject:JSONObject = JSONObject(data)<br><br>scores.Clear()<br><br>For Local a:String = EachIn jsonObject.Names()<br>	Print a<br>    Local da:JSONObject = JSONObject(jsonObject.GetItem(a))<br>	Local scoreMap:StringMap&lt;String&gt; = New StringMap&lt;String&gt;<br>	For Local b:String = EachIn da.Names()<br>		Local db:String = da.GetItem(b)<br>		scoreMap.Set(b, db)<br>	Next<br>    scores.Set(a, scoreMap)<br>Next<br><br>[/monkeycode]<br><br>But it seems to be grabbing only the first "Score" object. How can I get it to iterate through all score objects? <br><br></td></tr></table><br>
<a name="2036107"></a>

<a name="2036124"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> The original JSON is this:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
[
    {
        "Score": {
            "id": "3212190",
            "game_id": "747",
            "player_id": "306171",
            "score": "10",
            "created": "2012-08-07 22:50:24",
            "difficulty": "0",
            "platform": "HTML5"
        }
    },
    {
        "Score": {
            "id": "3257579",
            "game_id": "747",
            "player_id": "306171",
            "score": "6",
            "created": "2012-08-10 03:59:27",
            "difficulty": "0",
            "platform": "HTML5"
        }
    },
    {
        "Score": {
            "id": "3265083",
            "game_id": "747",
            "player_id": "306171",
            "score": "5",
            "created": "2012-08-10 15:38:17",
            "difficulty": "0",
            "platform": "console"
        }
    }
]
</textarea><br><br>Which is a JSONArray containing several JSONObjects, each of which contains a named element "Score", which is another JSONObject.<br><br>You're then messing about with the string and turning it into this:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
{
    "Score": {
        "id": "3212190",
        "game_id": "747",
        "player_id": "306171",
        "score": "10",
        "created": "2012 - 08 - 07 22:50:24",
        "difficulty": "0",
        "platform": "HTML5"
    }
},
{
    "Score": {
        "id": "3257579",
        "game_id": "747",
        "player_id": "306171",
        "score": "6",
        "created": "2012 - 08 - 10 03:59:27",
        "difficulty": "0",
        "platform": "HTML5"
    }
},
{
    "Score": {
        "id": "3265083",
        "game_id": "747",
        "player_id": "306171",
        "score": "5",
        "created": "2012 - 08 - 10 15:38:17",
        "difficulty": "0",
        "platform": "console"
    }
}
}
</textarea><br><br>Which is a single JSONObject containing one "Score" object followed by a bunch of stuff that gets ignored because the root object is complete.<br><br>I can only assume that your string hacking is motivated by not understanding something about the difference between JSONObjects and JSONArrays or just not being comfortable with classes/casting in general. Forgive me if that's not the case, but it I'd rather ensure that you understand these things than just provide a code solution. I'll post again in a bit with an attempt at explaining. <br><br></td></tr></table><br>
<a name="2036126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I don't know how to iterate through JSON Arrays using your module, so I strip the array brackets and try to use the simple JSON object. This worked for another object I'm receiving, but not this scores object.<br><br>So, after stripping the array brackets, I realize it's multiple objects without a root, so I tried at one point to put them in a root object called "Scores":<br><br>{ "Scores": json_object_from_hacked_string }<br><br>but that didn't work out for me, either, primarily because I didn't know how to iterate through the "score" objects.<br><br>I'd rather understand these things as well, so thank you for your help. <br><br></td></tr></table><br>
<a name="2036132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, if you look at the monkey-JSON project page there is some example code. The first few lines are:<br><br>[monkeycode]<br>    'Read JSON file'<br>    Local test:String = LoadString("jsontest.json")<br>    Local data:JSONDataItem = JSONData.ReadJSON(test)<br><br>    'In this case we know that the root is a JSON object'<br>    'If we didn't, the type can be discovered through the'<br>    'dataType Field or through direct type testing.'<br><br>    Local jsonObject:JSONObject = JSONObject(data)<br>[/monkeycode]<br><br>Note the comment after the ReadJSON line. What it is talking about is that JSON can be put together in multiple ways and parsing it often has an ambiguous resulting type. In this case, the root element could be a JSONArray or a JSONObject. As the library has to handle either eventuality the ReadJSON call doesn't return either of those specific types. Instead it returns a JSONDataItem.<br><br>JSONDataItem is the inherited class of every type of JSON data. JSONArray and JSONObject are both descendants of JSONDataItem as are JSONFloat, JSONString and the other "primitive" data types.<br><br>So, given that, when you call ReadJSON you need to either know what type you're going to get and cast it to the sub-class appropriately or use the dataType field in the returned object to understand what it is. In general, for games (and in your case too) you should know the expected file construction.<br><br>Coming back to your example, the root element is a JSONArray:<br><br>[monkeycode]<br>    Local data:JSONDataItem = JSONData.ReadJSON(result)<br>    Local scoresArr:JSONArray = JSONArray(data)<br>[/monkeycode]  <br><br>Now you have a JSONArray, you can iterate over it like a normal Monkey array. Again, because the elements in the array could be any JSON type, you'll be dealing with JSONDataItems:<br><br>[monkeycode]<br>    For Local di:JSONDataItem = EachIn scoresArr<br>        Print di<br>    End<br>[/monkeycode]<br><br>Result:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
{"Score":{"created":2012 - 08 - 07 22:50:24,"difficulty":0,"game_id":747,"id":3212190,"platform":HTML5,"player_id":306171,"score":10}}
{"Score":{"created":2012 - 08 - 10 03:59:27,"difficulty":0,"game_id":747,"id":3257579,"platform":HTML5,"player_id":306171,"score":6}}
{"Score":{"created":2012 - 08 - 10 15:38:17,"difficulty":0,"game_id":747,"id":3265083,"platform":console,"player_id":306171,"score":5}}
</textarea><br><br>If you want to extract the named score elements then you'd need cast to the JSONObject and use GetItem:<br><br>[monkeycode]<br>    For Local di:JSONDataItem = EachIn scoresArr<br>        Local jo:JSONObject = JSONObject(di)<br>        Local scoreObject:JSONObject = JSONObject(jo.GetItem("Score"))<br>        Print scoreObject<br>    End<br>[/monkeycode]<br><br>Result:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
{"created":2012 - 08 - 07 22:50:24,"difficulty":0,"game_id":747,"id":3212190,"platform":HTML5,"player_id":306171,"score":10}
{"created":2012 - 08 - 10 03:59:27,"difficulty":0,"game_id":747,"id":3257579,"platform":HTML5,"player_id":306171,"score":6}
{"created":2012 - 08 - 10 15:38:17,"difficulty":0,"game_id":747,"id":3265083,"platform":console,"player_id":306171,"score":5}
</textarea> <br><br></td></tr></table><br>
<a name="2036130"></a>

<a name="2036157"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> A-ha! No doubt I've got it now. :-)<br><br>Thank you for that explanation. Very clear and precise. I think the casting from JSONDataItem to whatever-it-is will help the most.<br><br>Also, eagerly anticipating the next pointless diversion. <br><br></td></tr></table><br>
<a name="2037385"></a>

<a name="2037386"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> hey muddy, I haven't looked into it yet, but can this lib also write to /construct a JSON string as well?  I'm thinking I want to store my state settings in a JSON file, and haven't got around to coming up with a template file for that.  I'm kinda hoping I can just hack one in in an ad-hoc way using Monkey-JSON, if it lets you write arbitrarily complex JSONObjects in a simple enough way.<br><br>Any examples for doing this on some of the normal compound types? (If Monkey-JSON can do this at all)<br><br>Edit:  I saw the AddPrim code on the code page.  This looks like it could work.  I will test direct casting for Bools on this lib later, since I had some casting issues with bools before (something like Null vs. 1 for false and true, I forgot exactly what it was, but it's probably something that I'm not accounting for). <br><br></td></tr></table><br>
<a name="2037431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, you just create and populate the required JSON dataitem heirarchy and then call ToJSONString or the WriteJSON function to get the JSON string. The example on the project page includes a section that does this:<br><br>[monkeycode]<br>    Local root:JSONObject = New JSONObject()<br>    root.AddPrim("name",name)<br>    root.AddPrim("width",width)<br>    root.AddPrim("height",height)<br>    root.AddPrim("isBounded",isBounded)<br>        <br>    'JSON objects and arrays can contain objects and arrays'    <br>    Local playerJSON:JSONObject = New JSONObject()<br>    playerJSON.AddPrim("posX",player.position.x)<br>    playerJSON.AddPrim("posY",player.position.y)<br>    root.AddItem("player",playerJSON)<br><br>    'Writing the JSON'<br>    Local jsonString:String = JSONData.WriteJSON(root)<br>[/monkeycode] <br><br></td></tr></table><br>
<a name="2037400"></a>

<a name="2055262"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> EDIT:  Please disregard this post.  It was probably a coding error on my part which I mistook for a bug in monkey-JSON.  Several clean wipes of my state data seems to have fixed whatever was broken in my project's loading. <br><br></td></tr></table><br>
<a name="2055261"></a>

<a name="2055260"></a>

<a name="2062887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CopperCircle</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, just found this great lib, will Monkey JSON work with keys that are not in quotes, my JavaScript output only puts quotes around string values not keys?<br><br>Thanks. <br><br></td></tr></table><br>
<a name="2062905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> JSON specifies that keys are strings and that strings are double-quote delimited:<br><br><a href="http://json.org" target="_blank">http://json.org</a><br><a href="http://stackoverflow.com/questions/2067974/in-json-why-is-each-name-quoted" target="_blank">http://stackoverflow.com/questions/2067974/in-json-why-is-each-name-quoted</a><br><br>I'll see about having quote-less mode, but it's not standard JSON at that point. <br><br></td></tr></table><br>
<a name="2062910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CopperCircle</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, as keys are always strings they shouldn't need the quotes, a quote-less mode would be great. <br><br></td></tr></table><br>
<a name="2062912"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd recommend you look at generating proper JSON via a stringifier rather than just spitting out the JS object literals. The point of a standard is to be standard after all. <br><br></td></tr></table><br>
<a name="2062991"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AndroidAndy</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would also recommend sticking with the standard too.  I was working on consuming some home-grown JSON from a Java server app the other day and the standard libraries for JSON parsing puked with the keys not quoted.  The home-grown JSON had only talked to other "homies" and so never encountered a problem until it went uptown and met with those that had more "refined" JSON taste. <br><br></td></tr></table><br>
<a name="2062922"></a>

<a name="2062927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CopperCircle</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't have control of the javascript lib creating the JSON and it seems it is non-standard, so guess I will have to parse the output or look to change Monkey-JSON.<br><br>Thanks. <br><br></td></tr></table><br>
<a name="2062928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just out of curiosity what's the name of the library you're using that only generates unquoted string ids? <br><br></td></tr></table><br>
<a name="2063007"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CopperCircle</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is a custom one that is part of a CMS I have to connect to, I have asked the developer to change it to standard output.  Thanks. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
