<!DOCTYPE html><html lang="en" ><head ><title >Matrices in minib3d</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='use quaternions and matrices in b3d, language=bmx, category=3D Graphics - Maths'><meta name='author' content='Warner'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=13>3D Graphics - Maths</a>/Matrices in minib3d</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="2498.bmx">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matrices in minib3d by Warner</td><td align="right">2009 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> Last update: 25 jun 2009<br><br>These routines are intended to extend/replace minib3d commands for rotation/position. They use matrices and quaternions.<br>It has a working AlignToVector!<br>Example code is provided below, but first you need to update TMatrix.bmx, TEntity.bmx, TGlobal.bmx and TAnimation.bmx in the minib3d mod folder, and then rebuild.<br>(!)I've posted these files in the comments below, because there wasn't enough room here. (post #3, #4, #5 and #7)<br>TGlobal is mostly the same. I added the command "UpdateEntities" to RenderWorld.<br><br>Has:<br>PositionEntity (ent, x#,y#,z#, glob)<br>TurnEntity (ent, p#,y#,r#, glob)<br>MoveEntity (ent, x#,y#,z#, glob)<br>RotateEntity (ent, p#,y#,r#, glob)<br>EntityParent (ent1, ent2, glob)<br>ScaleEntity (ent, w#,h#,d#)<br>TFormPoint (x#,y#,z#, ent1, ent2)<br>TFormVector (x#,y#,z#, ent1, ent2)<br>EntityPitch (ent1, glob)<br>EntityYaw (ent1, glob)<br>EntityRoll (ent1, glob)<br>AlignToVector (ent1, x#,y#,z#, ang, rate#)<br>PointEntity (ent1, ent2) &lt;- was allready present<br><br>Update History:<br><pre class=code>
00 - posted
01 - TFormVector2/Global MoveEntity2 flag 
02 - Somehow retaining global scaling was allready present, so skip that one.
03 - Revised structure to fit minib3d/Added EntityPitch,Yaw,Roll functions
04 - solved GetMatrix scaling issue
05 - Retaining global scaling was present due to a conincidence. 
     I changed it so scaling isn't retained when using EntityParent's 
     global flag.
06 - Repaired scaling issue
07 - Revised EntityPitch/Yaw/Roll to match RotateEntity.
08 - Added experimental routines AlignToVector2 and PointEntity2
09 - Replaced AlignToVector2, and removed PointEntity2 (replaced 
     by the original minib3d PointEntity) Also, replaced original 
     commands by their counterparts.
10 - The z-axis of PositionEntity2 was inverted.
     Added a 'rate' parameter to AlignToVector2
     Further improvement of the intergration with minib3d
11 - Updated all matrix routines to match the original minib3d 
     routines. It is now compatible with minib3d examples/demos
12 - Whoops, forgot to include TGlobal. Instead of updating entities every 
     time they are moved, an update flag is set. It is processed on 
     RenderWorld or when the matrix is requested.
13   Added TAnimation.bmx so bones are now compatible with the rest.
14   AlignToVector2 and EntityPitch were affected by the latest update. They now seem to be restored.
15   Fixed Global ScaleEntity flag.
</pre><br>Todo:<br>* TFormRotation ? .. Not sure if that could work<br>* General testing/comparing to Blitz3D<br><br>Most of the code is based on other people's code. For instance the math3d routines from Nilum. Thanks! </td></tr><tr ><td class="cell"><pre class="code">Import sidesign.minib3d

Graphics3D 800, 600, 0, 2

CreateLight()

Local cam:TCamera = CreateCamera()
MoveEntity cam, 0, 0, -15

e1:TEntity = CreateCone()
PositionEntity2 e1, -8,  8, 0

e2:TEntity = CreateCube()
PositionEntity2 e2, -2, 8, 0

e3:TEntity = CreateCube()
PositionEntity2 e3,  3, 8, 0

e4:TEntity = CreateCube()
PositionEntity e4, -8,  2, 0

e5:TEntity = CreateCube()
e6:TEntity = CreateCube()
MoveEntity2 e6, 2, 2, 0
EntityParent2 e6, e5
PositionEntity e5, -2, 2, 4

e7:TEntity = CreateCube()
ScaleEntity2 e7, 1, 2, 1
PositionEntity e7, 4, 2, 0 

e8:TEntity  = CreateCube()
e9:TEntity = CreateCube()
ScaleMesh TMesh(e9), 0.1, 0.1, 0.1
EntityColor e9, 255, 0, 0
PositionEntity2 e8, -8, -4, 0

e10:TEntity = CreateCone()
PositionEntity2 e10, -2, -4, 0

e11:TEntity = CreateCone()
PositionEntity2 e11, 2, -4, 0

Repeat

	TurnEntity2 e2, 1, 2, 3
	
	t = t + 4
	MoveEntity2 e3, Sin(t)*0.1, 0, 0
	
	RotateEntity2 e4, 0, 0, t
	
	TurnEntity2 e5, 0, 1, 0
	
	TurnEntity2 e8, 1, 2, 3
	x#=0 y#=0 z#=3
	TFormPoint2 x#,y#,z#, e8, Null
	PositionEntity2 e9, x, y, z
	
	UpdateWorld
	RenderWorld
			
	BeginMax2D
	
	DrawText "PositionEntity2", 120, 140
	DrawText "TurnEntity2", 300, 140
	DrawText "MoveEntity2", 460, 140
	
	DrawText "RotateEntity2", 120, 300
	DrawText "EntityParent2", 300, 300
	DrawText "ScaleEntity2", 460, 300

	DrawText "TFormPoint2", 120, 460
	DrawText "TFormVector2", 120, 480

	TurnEntity2 e10, 0, 0, 1
	
	pt# = EntityPitch2(e10)
	yw# = EntityYaw2(e10)
	rl# = EntityRoll2(e10)
	
	RotateEntity2 e11, pt, yw, rl
		
	DrawText "EntityPitch2:" + pt, 300, 460
	DrawText "EntityYaw2:  " + yw, 300, 480
	DrawText "EntityRoll2: " + rl, 300, 500

	EndMax2D

	Flip
	
Until KeyHit(key_escape)

End</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> GREAT! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jkrankie</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, this will be really useful once you've got those last two features added, nice work :)<br><br>Cheers<br>Charlie <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> TMatrix.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Version 18 june 23:58
Type TMatrix

	Field grid#[4,4]
	
	Function Create:TMatrix()
	
		Local m:TMatrix = New TMatrix
		m.LoadIdentity()
		Return m
		
	End Function
	
	Method New()
		
		If LOG_NEW
			DebugLog "New TMatrix"
		EndIf

	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TMatrix"
		EndIf

	End Method
	
	Method LoadIdentity()
	
		grid[0,0]=1.0 grid[1,0]=0.0 grid[2,0]=0.0 grid[3,0]=0.0
		grid[0,1]=0.0 grid[1,1]=1.0 grid[2,1]=0.0 grid[3,1]=0.0
		grid[0,2]=0.0 grid[1,2]=0.0 grid[2,2]=1.0 grid[3,2]=0.0		
		grid[0,3]=0.0 grid[1,3]=0.0 grid[2,3]=0.0 grid[3,3]=1.0
	
	End Method
	
	' copy - create new copy and returns it
	
	Method Copy:TMatrix()
	
		Local mat:TMatrix=New TMatrix
	
		mat.grid[0,0]=grid[0,0]
		mat.grid[1,0]=grid[1,0]
		mat.grid[2,0]=grid[2,0]
		mat.grid[3,0]=grid[3,0]
		mat.grid[0,1]=grid[0,1]
		mat.grid[1,1]=grid[1,1]
		mat.grid[2,1]=grid[2,1]
		mat.grid[3,1]=grid[3,1]
		mat.grid[0,2]=grid[0,2]
		mat.grid[1,2]=grid[1,2]
		mat.grid[2,2]=grid[2,2]
		mat.grid[3,2]=grid[3,2]
		
		' do not remove
		mat.grid[0,3]=grid[0,3]
		mat.grid[1,3]=grid[1,3]
		mat.grid[2,3]=grid[2,3]
		mat.grid[3,3]=grid[3,3]
		
		Return mat
	
	End Method
	
	' overwrite - overwrites self with matrix passed as parameter
	
	Method Overwrite(mat:TMatrix)
	
		grid[0,0]=mat.grid[0,0]
		grid[1,0]=mat.grid[1,0]
		grid[2,0]=mat.grid[2,0]
		grid[3,0]=mat.grid[3,0]
		grid[0,1]=mat.grid[0,1]
		grid[1,1]=mat.grid[1,1]
		grid[2,1]=mat.grid[2,1]
		grid[3,1]=mat.grid[3,1]
		grid[0,2]=mat.grid[0,2]
		grid[1,2]=mat.grid[1,2]
		grid[2,2]=mat.grid[2,2]
		grid[3,2]=mat.grid[3,2]		
		grid[0,3]=mat.grid[0,3]
		grid[1,3]=mat.grid[1,3]
		grid[2,3]=mat.grid[2,3]
		grid[3,3]=mat.grid[3,3]
		
	End Method
	
	Method Inverse:TMatrix()

		Local mat:TMatrix=New TMatrix
	
		Local tx#=0
		Local ty#=0
		Local tz#=0
	
	  	' The rotational part of the matrix is simply the transpose of the
	  	' original matrix.
	  	mat.grid[0,0] = grid[0,0]
	  	mat.grid[1,0] = grid[0,1]
	  	mat.grid[2,0] = grid[0,2]
	
		mat.grid[0,1] = grid[1,0]
		mat.grid[1,1] = grid[1,1]
		mat.grid[2,1] = grid[1,2]
	
		mat.grid[0,2] = grid[2,0]
		mat.grid[1,2] = grid[2,1]
		mat.grid[2,2] = grid[2,2]
	
		' The right column vector of the matrix should always be [ 0 0 0 1 ]
		' in most cases. . . you don't need this column at all because it'll 
		' never be used in the program, but since this code is used with GL
		' and it does consider this column, it is here.
		mat.grid[0,3] = 0 
		mat.grid[1,3] = 0
		mat.grid[2,3] = 0
		mat.grid[3,3] = 1
	
		' The translation components of the original matrix.
		tx = grid[3,0]
		ty = grid[3,1]
		tz = grid[3,2]
	
		' Result = -(Tm * Rm) To get the translation part of the inverse
		mat.grid[3,0] = -( (grid[0,0] * tx) + (grid[0,1] * ty) + (grid[0,2] * tz) )
		mat.grid[3,1] = -( (grid[1,0] * tx) + (grid[1,1] * ty) + (grid[1,2] * tz) )
		mat.grid[3,2] = -( (grid[2,0] * tx) + (grid[2,1] * ty) + (grid[2,2] * tz) )
	
		Return mat

	End Method

	Method Translate(x#,y#,z#)
	
		grid[3,0] = grid#[0,0]*x# + grid#[1,0]*y# + grid#[2,0]*z# + grid#[3,0]
		grid[3,1] = grid#[0,1]*x# + grid#[1,1]*y# + grid#[2,1]*z# + grid#[3,1]
		grid[3,2] = grid#[0,2]*x# + grid#[1,2]*y# + grid#[2,2]*z# + grid#[3,2]

	End Method
	
	Method Rotate(rx#,ry#,rz#)
	
		Local cos_ang#,sin_ang#
	
		' yaw
	
		cos_ang#=Cos(ry#)
		sin_ang#=Sin(ry#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
		
		' pitch
		
		cos_ang#=Cos(rx#)
		sin_ang#=Sin(rx#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		
		' roll
		
		cos_ang#=Cos(rz#)
		sin_ang#=Sin(rz#)

		m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
	
	End Method
	
	Method RotatePitch(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12

	End Method
	
	Method RotateYaw(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Method RotateRoll(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)

		Local m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		Local m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		Local m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Rem bbdoc: Returns a matrix made from the quaternion
	End Rem
	Method FromQuaternion(x#,y#,z#,w#)
		' Based off of code in Axiom
		
		Local tx# = 2*x
		Local ty# = 2*y
		Local tz# = 2*z
		Local twx# = tx*w
		Local twy# = ty*w
		Local twz# = tz*w
		Local txx# = tx*x
		Local txy# = ty*x
		Local txz# = tz*x
		Local tyy# = ty*y
		Local tyz# = tz*y
		Local tzz# = tz*z
		
		grid[0,0] = 1.0-(tyy+tzz)
		grid[1,0] = txy-twz
		grid[2,0] = txz+twy
		grid[3,0] = 0
		grid[0,1] = txy+twz
		grid[1,1] = 1.0-(txx+tzz)
		grid[2,1] = tyz-twx
		grid[3,1] = 0
		grid[0,2] = txz-twy
		grid[1,2] = tyz+twx
		grid[2,2] = 1.0-(txx+tyy)
		grid[3,2] = 0
		grid[0,3] = 0
		grid[1,3] = 0
		grid[2,3] = 0
		grid[3,3] = 1
		
	End Method
	
	Rem bbdoc: Transforms the matrix by another matrix
	End Rem
	Method Multiply(mat:TMatrix)
	
		Local m00# = grid#[0,0]*mat.grid#[0,0] + grid#[1,0]*mat.grid#[0,1] + grid#[2,0]*mat.grid#[0,2] + grid#[3,0]*mat.grid#[0,3]
		Local m01# = grid#[0,1]*mat.grid#[0,0] + grid#[1,1]*mat.grid#[0,1] + grid#[2,1]*mat.grid#[0,2] + grid#[3,1]*mat.grid#[0,3]
		Local m02# = grid#[0,2]*mat.grid#[0,0] + grid#[1,2]*mat.grid#[0,1] + grid#[2,2]*mat.grid#[0,2] + grid#[3,2]*mat.grid#[0,3]
		Local m03# = grid#[0,3]*mat.grid#[0,0] + grid#[1,3]*mat.grid#[0,1] + grid#[2,3]*mat.grid#[0,2] + grid#[3,3]*mat.grid#[0,3]
		Local m10# = grid#[0,0]*mat.grid#[1,0] + grid#[1,0]*mat.grid#[1,1] + grid#[2,0]*mat.grid#[1,2] + grid#[3,0]*mat.grid#[1,3]
		Local m11# = grid#[0,1]*mat.grid#[1,0] + grid#[1,1]*mat.grid#[1,1] + grid#[2,1]*mat.grid#[1,2] + grid#[3,1]*mat.grid#[1,3]
		Local m12# = grid#[0,2]*mat.grid#[1,0] + grid#[1,2]*mat.grid#[1,1] + grid#[2,2]*mat.grid#[1,2] + grid#[3,2]*mat.grid#[1,3]
		Local m13# = grid#[0,3]*mat.grid#[1,0] + grid#[1,3]*mat.grid#[1,1] + grid#[2,3]*mat.grid#[1,2] + grid#[3,3]*mat.grid#[1,3]
		Local m20# = grid#[0,0]*mat.grid#[2,0] + grid#[1,0]*mat.grid#[2,1] + grid#[2,0]*mat.grid#[2,2] + grid#[3,0]*mat.grid#[2,3]
		Local m21# = grid#[0,1]*mat.grid#[2,0] + grid#[1,1]*mat.grid#[2,1] + grid#[2,1]*mat.grid#[2,2] + grid#[3,1]*mat.grid#[2,3]
		Local m22# = grid#[0,2]*mat.grid#[2,0] + grid#[1,2]*mat.grid#[2,1] + grid#[2,2]*mat.grid#[2,2] + grid#[3,2]*mat.grid#[2,3]
		Local m23# = grid#[0,3]*mat.grid#[2,0] + grid#[1,3]*mat.grid#[2,1] + grid#[2,3]*mat.grid#[2,2] + grid#[3,3]*mat.grid#[2,3]
		Local m30# = grid#[0,0]*mat.grid#[3,0] + grid#[1,0]*mat.grid#[3,1] + grid#[2,0]*mat.grid#[3,2] + grid#[3,0]*mat.grid#[3,3]
		Local m31# = grid#[0,1]*mat.grid#[3,0] + grid#[1,1]*mat.grid#[3,1] + grid#[2,1]*mat.grid#[3,2] + grid#[3,1]*mat.grid#[3,3]
		Local m32# = grid#[0,2]*mat.grid#[3,0] + grid#[1,2]*mat.grid#[3,1] + grid#[2,2]*mat.grid#[3,2] + grid#[3,2]*mat.grid#[3,3]
		Local m33# = grid#[0,3]*mat.grid#[3,0] + grid#[1,3]*mat.grid#[3,1] + grid#[2,3]*mat.grid#[3,2] + grid#[3,3]*mat.grid#[3,3]
	
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method
	
	Rem bbdoc: Transforms a vector by the matrix
	End Rem
	Method TransformVec( rx# Var,ry# Var,rz# Var, addTranslation% = 0 )
	
		Local w# = 1.0/ ( grid[0,3] + grid[1,3] + grid[2,3] + grid[3,3] )
		Local ix# = rx#
		Local iy# = ry#
		Local iz# = -rz#
		
		addTranslation = Min( Max( addTranslation, 0 ), 1 )
		
		rx =  ( ( grid[0,0]*ix ) + ( grid[1,0]*iy ) + ( grid[2,0]*iz ) + grid[3,0] * addTranslation ) * w
		ry =  ( ( grid[0,1]*ix ) + ( grid[1,1]*iy ) + ( grid[2,1]*iz ) + grid[3,1] * addTranslation ) * w
		rz = -( ( grid[0,2]*ix ) + ( grid[1,2]*iy ) + ( grid[2,2]*iz ) + grid[3,2] * addTranslation ) * w
		
	End Method
	
	Rem bbdoc: Transposes the matrix
	End Rem
	Method Transpose()
	
	 Local x:Int,y:Int
	
	 Local a:Double[,] = New Double[4,4]
	
	 For x = 0 To 3
	 For y = 0 To 3
		 a[y,x] = grid[x,y]
	 Next
	 Next
	
	 For x = 0 To 3
	 For y = 0 To 3
		grid[x,y]=a[x,y]
	 Next
	 Next
	
	End Method
	
	
	Rem bbdoc: Sets the translation elements of the matrix
	End Rem
	Method SetTranslate( x#, y#, z# )
		grid[3,0] = x
		grid[3,1] = y
		grid[3,2] = z
	End Method
	
	Rem bbdoc: Scales the rotation elements of the matrix
	End Rem
	Method Scale(x#,y#,z#)
	
		grid[0,0] = grid#[0,0]*x#
		grid[0,1] = grid#[0,1]*x#
		grid[0,2] = grid#[0,2]*x#
	
		grid[1,0] = grid#[1,0]*y#
		grid[1,1] = grid#[1,1]*y#
		grid[1,2] = grid#[1,2]*y#
	
		grid[2,0] = grid#[2,0]*z#
		grid[2,1] = grid#[2,1]*z#
		grid[2,2] = grid#[2,2]*z# 
	
	End Method

	Method Multiply2(i:TMatrix)
				
		Local m00# = grid[0,0] * i.grid[0,0] + grid[0,1] * i.grid[1,0] + grid[0,2] * i.grid[2,0] + grid[0,3] * i.grid[3,0]
		Local m01# = grid[0,0] * i.grid[0,1] + grid[0,1] * i.grid[1,1] + grid[0,2] * i.grid[2,1] + grid[0,3] * i.grid[3,1]
		Local m02# = grid[0,0] * i.grid[0,2] + grid[0,1] * i.grid[1,2] + grid[0,2] * i.grid[2,2] + grid[0,3] * i.grid[3,2]
		Local m03# = grid[0,0] * i.grid[0,3] + grid[0,1] * i.grid[1,3] + grid[0,2] * i.grid[2,3] + grid[0,3] * i.grid[3,3]
		
		Local m10# = grid[1,0] * i.grid[0,0] + grid[1,1] * i.grid[1,0] + grid[1,2] * i.grid[2,0] + grid[1,3] * i.grid[3,0]
		Local m11# = grid[1,0] * i.grid[0,1] + grid[1,1] * i.grid[1,1] + grid[1,2] * i.grid[2,1] + grid[1,3] * i.grid[3,1]
		Local m12# = grid[1,0] * i.grid[0,2] + grid[1,1] * i.grid[1,2] + grid[1,2] * i.grid[2,2] + grid[1,3] * i.grid[3,2]
		Local m13# = grid[1,0] * i.grid[0,3] + grid[1,1] * i.grid[1,3] + grid[1,2] * i.grid[2,3] + grid[1,3] * i.grid[3,3]
		
		Local m20# = grid[2,0] * i.grid[0,0] + grid[2,1] * i.grid[1,0] + grid[2,2] * i.grid[2,0] + grid[2,3] * i.grid[3,0]
		Local m21# = grid[2,0] * i.grid[0,1] + grid[2,1] * i.grid[1,1] + grid[2,2] * i.grid[2,1] + grid[2,3] * i.grid[3,1]
		Local m22# = grid[2,0] * i.grid[0,2] + grid[2,1] * i.grid[1,2] + grid[2,2] * i.grid[2,2] + grid[2,3] * i.grid[3,2]
		Local m23# = grid[2,0] * i.grid[0,3] + grid[2,1] * i.grid[1,3] + grid[2,2] * i.grid[2,3] + grid[2,3] * i.grid[3,3]
				
		Local m30# = grid[3,0] * i.grid[0,0] + grid[3,1] * i.grid[1,0] + grid[3,2] * i.grid[2,0] + grid[3,3] * i.grid[3,0]
		Local m31# = grid[3,0] * i.grid[0,1] + grid[3,1] * i.grid[1,1] + grid[3,2] * i.grid[2,1] + grid[3,3] * i.grid[3,1]
		Local m32# = grid[3,0] * i.grid[0,2] + grid[3,1] * i.grid[1,2] + grid[3,2] * i.grid[2,2] + grid[3,3] * i.grid[3,2]
		Local m33# = grid[3,0] * i.grid[0,3] + grid[3,1] * i.grid[1,3] + grid[3,2] * i.grid[2,3] + grid[3,3] * i.grid[3,3]
		
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method

	Rem bbdoc: Gets the current pitch of the matrix
	End Rem
	Method GetPitch#()

		Local x# = grid[2,0]
		Local y# = grid[2,1]
		Local z# = grid[2,2]
		Return -ATan2( y, Sqr( x*x+z*z ) )
		
	End Method

	Rem bbdoc: Gets the current yaw of the matrix
	End Rem
	Method GetYaw#()
	
		Local x# = grid[2,0]
		Local z# = grid[2,2]	
		Return ATan2( x,z )
		
	End Method
	
	Rem bbdoc: Gets the current roll of the matrix
	End Rem
	Method GetRoll#()
	
		Local iy# = grid[0,1]
		Local jy# = grid[1,1]
		Return ATan2( iy, jy )
	
	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											FromToRotation()
'-----------------------------------------------------------------------------------------------------------------------------------
Rem
 * A Function For creating a rotation matrix that rotates a vector called
 * "from" into another vector called "to".
 * Input : from[3], To[3] which both must be *normalized* non-zero vectors
 * Output: mtx[3][3] -- a 3x3 matrix in colum-major form
 * Authors: Tomas Möller, John Hughes
 *          "Efficiently Building a Matrix to Rotate One Vector to Another"
 *          Journal of Graphics Tools, 4(4):1-4, 1999
EndRem
	Method FromToRotation:TMatrix(ix#,iy#,iz#, jx#,jy#,jz#)

	  Local hvx#, hvz#, hvxy#, hvxz#, hvyz#
	  Local dotu#, dotv#, dotuv#
	  Local u#[3], v#[3]
	  Local c1#,c2#,c3#
	  Local x0#,x1#,x2#
	  Local e#, h#
	  Local i, j
	
	  'v = cross(from, To)
	  v[0] = iy * jz - iz * jy
	  v[1] = iz * jx - ix * jz
	  v[2] = ix * jy - iy * jx
	
	  'e = DOT(from, To);
	  e = ix * jx + iy * jy + iz * jz
	
	  If (Abs(e) &gt; 1.0 - 0.000001) Then     '/* "from" And "to"-vector almost parallel */
	  
	    x0# = Abs(ix)
	    x1# = Abs(iy)
	    x2# = Abs(iz)
	
	    If (x0 &lt; x1)
	      If (x0 &lt; x2)
	        x0 = 1.0 
	 	   x1 = 0.0 
	        x2 = 0.0
	      Else
	        x2 = 1.0 
	        x0 = 0.0 
	        x1 = 0.0
	      End If    
	    Else
	      If (x1 &lt; x2)
	        x1 = 1.0
	        x0 = 0.0
	        x2 = 0.0
	      Else
	        x2 = 1.0
	        x0 = 0.0
	        x1 = 0.0
	 	 End If
	    End If
	
	    u[0] = x0 - ix 
	    u[1] = x1 - iy
	    u[2] = x2 - iz
	
	    v[0] = x0 - jx
	    v[1] = x1 - jy
	    v[2] = x2 - jz
	
	    dotu#  = u[0] * u[0] + u[1] * u[1] + u[2] * u[2]
	    dotv#  = v[0] * v[0] + v[1] * v[1] + v[2] * v[2]
	    dotuv# = u[0] * v[0] + u[1] * v[1] + u[2] * v[2]
	
	    If dotu &lt;&gt; 0 Then c1# = 2.0 / dotu Else c1# = 10000
	    If dotv &lt;&gt; 0 Then c2# = 2.0 / dotv Else c2# = 10000
	    c3# = c1 * c2 * dotuv#
	
          For i = 0 To 2
	      For j = 0 To 2
		   grid[j,i] = - c1 * u[i] * u[j] ..
		               - c2 * v[i] * v[j] ..
		               + c3 * v[i] * u[j]
	      Next
	      grid[i,i] = grid[i,i] + 1.0;
	    Next
		  
	  Else  ' the most common Case, unless "from"="to", Or "from"=-"to" */
	
	    h = 1.0/(1.0 + e)      '/* optimization by Gottfried Chen */
	    hvx = h * v[0]
	    hvz = h * v[2]
	    hvxy = hvx * v[1]
	    hvxz = hvx * v[2]
	    hvyz = hvz * v[1]
	    grid[0,0] = e + hvx * v[0]
	    grid[1,0] = hvxy - v[2]
	    grid[2,0] = hvxz + v[1]
	
	    grid[0,1] = hvxy + v[2]
	    grid[1,1] = e + h * v[1] * v[1]
	    grid[2,1] = hvyz - v[0]
	
	    grid[0,2] = hvxz - v[1]
	    grid[1,2] = hvyz + v[0]
	    grid[2,2] = e + hvz * v[2]
	
	  End If
	
	  grid[3,0] = 0
	  grid[3,1] = 0
	  grid[3,2] = 0
	  grid[0,3] = 0
       grid[1,3] = 0
       grid[2,3] = 0
       grid[3,3] = 1
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											ToQuat()
'-----------------------------------------------------------------------------------------------------------------------------------
'convert to quaternion
	Method ToQuat( qx# Var,qy# Var,qz# Var,qw# Var )
	
	  Local trace# = grid[0,0] + grid[1,1] + grid[2,2] + 1.0
	  Local s#
	
	  If( trace &gt; 0.0001 ) Then
	    s = 0.5 / Sqr(trace)
	    qw = 0.25 / s
	    qx = ( grid[1,2] - grid[2,1] ) * s
	    qy = ( grid[2,0] - grid[0,2] ) * s
	    qz = ( grid[0,1] - grid[1,0] ) * s
	  Else
	    If ( grid[0,0] &gt; grid[1,1]) And (grid[0,0] &gt; grid[2,2]) Then
	      s = 2.0 * Sqr( 1.0 + grid[0,0] - grid[1,1] - grid[2,2])
		 qw = (grid[1,2] - grid[2,1] ) / s
	      qx = 0.25 * s
	      qy = (grid[1,0] + grid[0,1] ) / s
	      qz = (grid[2,0] + grid[0,2] ) / s
	    ElseIf (grid[1,1] &gt; grid[2,2]) Then
	      s = 2.0 * Sqr( 1.0 + grid[1,1] - grid[0,0] - grid[2,2])
	      qw = (grid[2,0] - grid[0,2]) / s
	      qx = (grid[1,0] + grid[0,1] ) / s
	      qy = 0.25 * s
	      qz = (grid[2,1] + grid[1,2] ) / s
	    Else
	      s = 2.0 * Sqr( 1.0 + grid[2,2] - grid[0,0] - grid[1,1] )
	      qw = (grid[0,1] - grid[1,0] ) / s
	      qx = (grid[2,0] + grid[0,2] ) / s
	      qy = (grid[2,1] + grid[1,2] ) / s
	      qz = 0.25 * s
	    End If
	  End If
	
	End Method

End Type


Rem bbdoc: Gets the magnitude of the vector
End Rem
Function Magnitude#( x#, y#, z# )
	Return Sqr( x*x + y*y + z*z )
End Function

Rem bbdoc: Creates a quaternion from an angle and an axis
End Rem
Function Quaternion_FromAngleAxis( angle#, ax#,ay#,az#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	Local ha# = .5*angle
	Local sn# = Sin( ha )
	
	rw# = Cos( ha )
	rx# = sn * ax
	ry# = sn * ay
	rz# = sn * az
	
End Function

Rem bbdoc: Multiplies a quaternion
End Rem
Function Quaternion_MultiplyQuat( x1#,y1#,z1#,w1#, x2#,y2#,z2#,w2#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	rw = w1*w2 - x1*x2 - y1*y2 - z1*z2
	rx = w1*x2 - x1*w2 - y1*z2 - z1*y2
	ry = w1*y2 - y1*w2 - z1*x2 - x1*z2
	rz = w1*z2 - z1*w2 - x1*y2 - y1*x2
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											Interpolate()
'-----------------------------------------------------------------------------------------------------------------------------------
'interpolates matrix
Function InterpolateMatrix:TMatrix(a:TMatrix, alpha#)

	Local m:TMatrix = TMatrix.Create()	
	Local q1_x#, q1_y#, q1_z#, q1_w#
	Local dd#
	
	a.ToQuat(q1_x, q1_y, q1_z, q1_w)	
	If q1_w = 0 Then Return a.Copy()

	'normalize
     If (q1_w &gt; 1) Then		
		dd# = (q1_x*q1_x + q1_y*q1_y + q1_z*q1_z + q1_w*q1_w)
		If dd &lt;&gt; 0 Then
			q1_x = q1_x / dd
			q1_y = q1_y / dd
			q1_z = q1_z / dd
			q1_w = q1_w / dd
		End If
	End If
	
	Local s#
	Local angle#,x#,y#,z#
	
     angle# = 2 * ACos(q1_w)
     s# = Sqr(1 - q1_w * q1_w)

     If (s &lt; 0.001) Then
	     x = q1_x
	     y = q1_y
	     z = q1_z
     Else
	     x = q1_x / s
	     y = q1_y / s
	     z = q1_z / s
     End If

	angle = angle * alpha
	Quaternion_FromAngleAxis(angle, x,y,z, q1_x, q1_y, q1_z, q1_w)	
	m.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
	
	Return m
	
End Function
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> TEntity.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Version 25 june
Type TEntity

	Global entity_list:TList=CreateList()
	Field need_update = True

	Field child_list:TList=CreateList()

	Field parent:TEntity
	
	Field rotmat:TMatrix=TMatrix.Create()'rotation matrix
	Field mat:TMatrix=New TMatrix
	Field px#,py#,pz#,sx#=1.0,sy#=1.0,sz#=1.0,rx#,ry#,rz#,qw#,qx#,qy#,qz#
	
	Field name$
	Field class$
	Field hide=False
	Field order,alpha_order#
	Field auto_fade,fade_near#,fade_far#,fade_alpha#

	Field brush:TBrush=New TBrush
	
	Field cull_radius#
	
	Field radius_x#=1.0,radius_y#=1.0
	Field box_x#=-1.0,box_y#=-1.0,box_z#=-1.0,box_w#=2.0,box_h#=2.0,box_d#=2.0
	Field collision_type
	Field no_collisions,collision:TCollisionImpact[]
	Field pick_mode,obscurer

	Field anim ' true if mesh contains anim data
	Field anim_render ' true to render as anim mesh
	Field anim_mode
	Field anim_time#
	Field anim_speed#
	Field anim_seq
	Field anim_trans
	Field anim_dir=1 ' 1=forward, -1=backward
	Field anim_seqs_first[1]
	Field anim_seqs_last[1]
	Field no_seqs=0
	Field anim_update
	
	Global tformed_x#
	Global tformed_y#
	Global tformed_z#
	
	' used by TCollisions
	Field old_x#
	Field old_y#
	Field old_z#
		
	Field link:TLink ' entity_list tlink, stored for quick removal of entity from list ***note*** not currently used to remove entity from list

	Method CopyEntity:TEntity(parent_ent:TEntity=Null) Abstract
	Method Update() Abstract

	Method New()
	
		If LOG_NEW
			DebugLog "New TEntity"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TEntity"
		EndIf
	
	End Method

	Method FreeEntity()
	
		ListRemove(entity_list,Self)
	
		'RemoveLink link ' remove self from entity list - mem leak!
		
		' remove from collision entity lists
		If collision_type&lt;&gt;0 ListRemove(TCollisionPair.ent_lists[collision_type],Self)
		
		' remove from pick entity list
		If pick_mode&lt;&gt;0 ListRemove(TPick.ent_list,Self)
		
		Local ent:TEntity
		
		' free self from parent's child_list
		If parent&lt;&gt;Null
			For ent=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
		EndIf
		
		parent=Null
		mat=Null
		brush=Null
		link=Null
	
		' free children entities
		For ent=EachIn child_list
			ent.FreeEntity()
			ent=Null
		Next

	End Method

	' Entity movement

	Method PositionEntity(x#,y#,z#,glob=False)
		MQ_Position( x, y, z, glob )
		need_update = True
		'MQ_Update()
	End Method
		
	Method MoveEntity(mx#,my#,mz#)
		MQ_Move( mx, my, mz )
		need_update = True
		'MQ_Update()
	End Method

	Method TranslateEntity(tx#,ty#,tz#,glob=True)
		TFormVector(tx, ty, tz, Null, Self)
		MQ_Move( tformed_x#, tformed_y#, tformed_z# )
		need_update = True
		'MQ_Update()
	End Method
	
	Method ScaleEntity(x#,y#,z#,glob=False)	
		MQ_Scale(x, y, z, glob)
		need_update = True
		'MQ_Update()
	End Method

	Method RotateEntity(x#,y#,z#,glob=False)	
		MQ_Rotate(x,y,z, glob)
		need_update = True
		'MQ_Update()
	End Method

	Method TurnEntity(x#,y#,z#,glob=False)
		If x# &lt;&gt; 0 Then MQ_Turn(x, 1, 0, 0, glob)
		If y# &lt;&gt; 0 Then MQ_Turn(y, 0, 1, 0, glob)
		If z# &lt;&gt; 0 Then MQ_Turn(z, 0, 0, 1, glob)
		need_update = True
		'MQ_Update()
	End Method

	' Function by mongia2
	Method PointEntity(target_ent:TEntity,roll#=0)	
	
		Local x#=target_ent.EntityX#(True)
		Local y#=target_ent.EntityY#(True)
		Local z#=target_ent.EntityZ#(True)

		Local xdiff#=Self.EntityX(True)-x#
		Local ydiff#=Self.EntityY(True)-y#
		Local zdiff#=-(Self.EntityZ(True)-z#) 'I don't know why I needed to invert this .. could be a problem

		Local dist22#=Sqr((xdiff#*xdiff#)+(zdiff#*zdiff#))
		Local pitch#=ATan2(ydiff#,dist22#)
		Local yaw#=ATan2(xdiff#,zdiff#)

		Self.RotateEntity pitch#,yaw#,roll#,True
		
	End Method
		
	' Entity animation

	' load anim seq - copies anim data from mesh to self
	Method LoadAnimSeq(file:String)
	
		If FileType(file)=0 Then Return 0
	
		' mesh that we will load anim seq from
		Local mesh:TMesh=TModel.LoadAnimB3D:TMesh(file)
		
		If anim=False Then Return 0 ' self contains no anim data
		If mesh.anim=False Then Return 0 ' mesh contains no anim data
	
		no_seqs=no_seqs+1
		
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' update anim_seqs array
		anim_seqs_first[no_seqs]=anim_seqs_last[0]
		anim_seqs_last[no_seqs]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		' update anim_seqs_last[0] - sequence 0 is for all frames, so this needs to be increased
		' must be done after updating anim_seqs array above
		anim_seqs_last[0]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		If mesh&lt;&gt;Null

			' go through all bones belonging to self
			For Local bone:TBone=EachIn TMesh(Self).bones
			
				' find bone in mesh that matches bone in self - search based on bone name
				Local mesh_bone:TBone=TBone(TEntity(mesh).FindChild(bone.name$))
			
				If mesh_bone&lt;&gt;Null
			
					' resize self arrays first so the one empty element at the end is removed
					bone.keys.flags=bone.keys.flags[..bone.keys.flags.length-1]
					bone.keys.px=bone.keys.px[..bone.keys.px.length-1]
					bone.keys.py=bone.keys.py[..bone.keys.py.length-1]
					bone.keys.pz=bone.keys.pz[..bone.keys.pz.length-1]
					bone.keys.sx=bone.keys.sx[..bone.keys.sx.length-1]
					bone.keys.sy=bone.keys.sy[..bone.keys.sy.length-1]
					bone.keys.sz=bone.keys.sz[..bone.keys.sz.length-1]
					bone.keys.qw=bone.keys.qw[..bone.keys.qw.length-1]
					bone.keys.qx=bone.keys.qx[..bone.keys.qx.length-1]
					bone.keys.qy=bone.keys.qy[..bone.keys.qy.length-1]
					bone.keys.qz=bone.keys.qz[..bone.keys.qz.length-1]
					
					' add mesh bone key arrays to self bone key arrays
					bone.keys.frames=anim_seqs_last[0]
					bone.keys.flags=bone.keys.flags+mesh_bone.keys.flags
					bone.keys.px=bone.keys.px+mesh_bone.keys.px
					bone.keys.py=bone.keys.py+mesh_bone.keys.py
					bone.keys.pz=bone.keys.pz+mesh_bone.keys.pz
					bone.keys.sx=bone.keys.sx+mesh_bone.keys.sx
					bone.keys.sy=bone.keys.sy+mesh_bone.keys.sy
					bone.keys.sz=bone.keys.sz+mesh_bone.keys.sz
					bone.keys.qw=bone.keys.qw+mesh_bone.keys.qw
					bone.keys.qx=bone.keys.qx+mesh_bone.keys.qx
					bone.keys.qy=bone.keys.qy+mesh_bone.keys.qy
					bone.keys.qz=bone.keys.qz+mesh_bone.keys.qz
				
				EndIf
				
			Next
				
		EndIf
		
		mesh.FreeEntity()
		
		Return no_seqs
	
	End Method
	
	Method ExtractAnimSeq(first_frame,last_frame,seq=0)
	
		no_seqs=no_seqs+1
	
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' if seq specifed then extract anim sequence from within existing sequnce
		Local offset=0
		If seq&lt;&gt;0
			offset=anim_seqs_first[seq]
		EndIf
	
		anim_seqs_first[no_seqs]=first_frame+offset
		anim_seqs_last[no_seqs]=last_frame+offset
		
		Return no_seqs
	
	End Method

	Method Animate(mode=1,speed#=1.0,seq=0,trans=0)
	
		anim_mode=mode
		anim_speed#=speed#
		anim_seq=seq
		anim_trans=trans
		anim_time#=anim_seqs_first[seq]
		anim_update=True ' update anim for all modes (including 0)
		
		If trans&gt;0
			anim_time#=0
		EndIf
		
	End Method
	
	' Updates:
	' 30/01/06 - updated to make anim_time return wrapped value
	Method SetAnimTime(time#,seq=0)
	
		anim_mode=-1 ' use a mode of -1 for setanimtime
		anim_speed#=0
		anim_seq=seq
		anim_trans=0
		anim_time#=time#
		anim_update=False ' set anim_update to false so UpdateWorld won't animate entity

		Local first=anim_seqs_first[anim_seq]
		Local last=anim_seqs_last[anim_seq]
		Local first2last=anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq]
		
		time#=time#+first ' offset time so that anim time of 0 will equal first frame of sequence
		
		If time#&gt;last And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#-first2last
			Until time#&lt;=last
		EndIf
		If time#&lt;first And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#+first2last
			Until time#&gt;=first
		EndIf
		
		TAnimation.AnimateMesh(Self,time#,first,last)

		anim_time#=time# ' update anim_time# to equal time#

	End Method
	
	Method AnimSeq()
	
		Return anim_seq ' current anim sequence
	
	End Method
	
	Method AnimLength()
	
		Return anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq] ' no of frames in anim sequence
	
	End Method

	Method AnimTime#()
	
		' if animation in transition, return 0 (anim_time actually will be somewhere between 0 and 1)
		If anim_trans&gt;0 Then Return 0
		
		' for animate and setanimtime we want to return anim_time starting from 0 and ending at no. of frames in sequence
		If anim_mode&gt;0 Or anim_mode=-1
			Return anim_time#-anim_seqs_first[anim_seq]
		EndIf

		Return 0

	End Method
	
	Method Animating()
	
		If anim_trans&gt;0 Then Return True
		If anim_mode&gt;0 Then Return True
		
		Return False
	
	End Method
		
	' Entity control

	Method EntityColor(r#,g#,b#)
	
		brush.red  =r#/255.0
		brush.green=g#/255.0
		brush.blue =b#/255.0
	
	End Method

	Method EntityAlpha(a#)
	
		brush.alpha=a#
			
	End Method
	
	Method EntityShininess(s#)
	
		brush.shine=s#
	
	End Method

	Method EntityTexture(texture:TTexture,frame=0,index=0)

		brush.tex[index]=texture
		If index+1&gt;brush.no_texs Then brush.no_texs=index+1
		
		If frame&lt;0 Then frame=0
		If frame&gt;texture.no_frames-1 Then frame=texture.no_frames-1 
		brush.tex_frame=frame
	
	End Method
	
	Method EntityBlend(blend_no)
	
		brush.blend=blend_no
		
		If TMesh(Self)&lt;&gt;Null
		
			' overwrite surface blend modes with master blend mode
			For Local surf:TSurface=EachIn TMesh(Self).surf_list
				If surf.brush&lt;&gt;Null
					surf.brush.blend=brush.blend
				EndIf
			Next
			
		EndIf
		
	End Method
	
	Method EntityFX(fx_no)
	
		brush.fx=fx_no
		
	End Method
	
	Method EntityAutoFade(near#,far#)
	
		auto_fade=True
		fade_near=near#
		fade_far=far#
	
	End Method
	
	Method PaintEntity(bru:TBrush)
	
		brush.no_texs=bru.no_texs
		brush.name$=bru.name$
		brush.red#=bru.red#
		brush.green#=bru.green#
		brush.blue#=bru.blue#
		brush.alpha#=bru.alpha#
		brush.shine#=bru.shine#
		brush.blend=bru.blend
		brush.fx=bru.fx
		For Local i=0 To 7
			brush.tex[i]=bru.tex[i]
		Next
	
	End Method
	
	Method EntityOrder(order_no)
	
		order=order_no

		If TCamera(Self)&lt;&gt;Null
			ListRemove(TCamera.cam_list,Self)
			EntityListAdd(TCamera.cam_list)
		EndIf

	End Method
	
	Method ShowEntity()
	
		hide=False
		
	End Method

	Method HideEntity()

		hide=True

	End Method

	Method Hidden()
	
		If hide=True Return True
		
		Local ent:TEntity=parent
		While ent&lt;&gt;Null
			If ent.hide=True Return True
			ent=ent.parent
		Wend
		
		Return False
	
	End Method

	Method NameEntity(e_name$)
	
		name$=e_name$
	
	End Method
	
	Method EntityParent(parent_ent:TEntity,glob=True)	

		MQ_SetParent(parent_ent, glob)	
		need_update = True
		'MQ_Update()
		
	End Method
		
	Method GetParent:TEntity()			
		Return parent	
	End Method

	' Entity state
	Method EntityX#(glob=False)			
		If glob Then
			If need_update Then MQ_Update()
			Return mat.grid[3,0]
		Else
			Return px
		End If
	End Method
	
	Method EntityY#(glob=False)
		If glob Then
			If need_update Then MQ_Update()
			Return mat.grid[3,1]
		Else
			Return py
		End If
	End Method
	
	Method EntityZ#(glob=False)
		If glob Then
			If need_update Then MQ_Update()
			Local v# = mat.grid[3,2]
			Return -v
		Else
			Return pz
		End If
	End Method

	Method EntityPitch#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetPitch()
		Else
			'use local matrix
			Return rotmat.GetPitch()
		End If
	End Method
	
	Method EntityYaw#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetYaw()
		Else
			'use local matrix
			Return rotmat.GetYaw()
		End If
	End Method
	
	Method EntityRoll#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetRoll()
		Else
			'use local matrix
			Return rotmat.GetRoll()
		End If
	End Method
	
	Method EntityClass$()
		
		Return class$
		
	End Method
	
	Method EntityName$()
		
		Return name$
		
	End Method
	
	Method CountChildren()

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1

		Next

		Return no_children

	End Method
	
	Method GetChild:TEntity(child_no)

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

		no_children=no_children+1
			If no_children=child_no Return ent

		Next

		Return Null
	
	End Method
	
	Method FindChild:TEntity(child_name$)
	
		Local cent:TEntity
	
		For Local ent:TEntity=EachIn child_list

			If ent.EntityName$()=child_name$ Return ent

			cent=ent.FindChild(child_name$)
			
			If cent&lt;&gt;Null Return cent
	
		Next

		Return Null
	
	End Method
	
	' Calls function in TPick
	Method EntityPick:TEntity(range#)
	
		Return TPick.EntityPick:TEntity(Self,range#)
	
	End Method
	
	' Calls function in TPick
	Method LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
		Return TPick.LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
	End Method
	
	' Calls function in TPick
	Method EntityVisible(src_entity:TEntity,dest_entity:TEntity)
	
		Return TPick.EntityVisible(src_entity,dest_entity)
	
	End Method
	
	Method EntityDistance#(ent2:TEntity)

		Return Sqr(Self.EntityDistanceSquared#(ent2))

	End Method
	
	' Function by Vertex
	Method DeltaYaw#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		'Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
		
		Return -ATan2(x#,z#)

	End Method
	
	' Function by Vertex
	Method DeltaPitch#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
	
		Return -ATan2(y#,Sqr(x#*x#+z#*z#))
	
	End Method

	Function TFormPoint(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)		

		Local mat1:TMatrix
		Local mat2:TMatrix
		
		'get src matrix	
		If src_ent &lt;&gt; Null Then
			mat1:TMatrix = src_ent.MQ_GetMatrix()
		End If
	
		'get dest matrix
		If dest_ent &lt;&gt; Null Then
			mat2:TMatrix = dest_ent.MQ_GetInvMatrix()
		End If 	
	
		'transform point by matrix
		If src_ent  &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
		If dest_ent &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormVector(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		
		Local mat1:TMatrix
		Local mat2:TMatrix 
	
		'get src matrix	
		If src_ent &lt;&gt; Null Then
			mat1:TMatrix = src_ent.MQ_GetMatrix()
			mat1.grid[3,0] = 0 'remove translation
			mat1.grid[3,1] = 0
			mat1.grid[3,2] = 0
		End If
	
		'get dest matrix
		If dest_ent &lt;&gt; Null Then
			mat2:TMatrix = dest_ent.MQ_GetInvMatrix()		
			mat2.grid[3,0] = 0 'remove translation
			mat2.grid[3,1] = 0
			mat2.grid[3,2] = 0
		End If 	
	
		'transform point by matrix
		If src_ent  &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
		If dest_ent &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormNormal(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		
		TFormVector(x,y,z,src_ent,dest_ent)
		
		x# = tformed_x#
		y# = tformed_y#
		z# = tformed_z#
		
		Local dd# = Magnitude(x,y,z)
		If dd &lt;&gt; 0 Then
			x=x/dd
			y=y/dd
			z=z/dd
		End If
		
		tformed_x#=x		
		tformed_y#=y
		tformed_z#=z
	End Function
	
	Function TFormedX#()
	
		Return tformed_x#
	
	End Function
	
	Function TFormedY#()
	
		Return tformed_y#
	
	End Function
	
	Function TFormedZ#()
	
		Return tformed_z#
	
	End Function
	
	Method GetMatElement#(row,col)
	
		Return mat.grid[row,col]
	
	End Method
	
	' Entity collision
	
	Method ResetEntity()
	
		no_collisions=0
		collision=collision[..0]
		old_x=EntityX(True)
		old_y=EntityY(True)
		old_z=EntityZ(True)
	
	End Method
	
	Method EntityRadius(rx#,ry#=0.0)
	
		radius_x#=rx#
		If ry#=0.0 Then radius_y#=rx# Else radius_y#=ry#
	
	End Method
	
	Method EntityBox(x#,y#,z#,w#,h#,d#)
	
		box_x#=x#
		box_y#=y#
		box_z#=z#
		box_w#=w#
		box_h#=h#
		box_d#=d#
	
	End Method

	Method EntityType(type_no,recursive=False)
	
		' add to collision entity list if new type no&lt;&gt;0 and not previously added
		If collision_type=0 And type_no&lt;&gt;0
		
			If TCollisionPair.ent_lists[type_no]=Null Then TCollisionPair.ent_lists[type_no]=CreateList() ' create new list is one doesn't exist
			
			ListAddLast(TCollisionPair.ent_lists[type_no],Self)
			
		EndIf
		
		' remove from collision entity list if new type no=0 and previously added
		If collision_type&lt;&gt;0 And type_no=0
			ListRemove(TCollisionPair.ent_lists[type_no],Self)
		EndIf
		
		collision_type=type_no
		
		old_x#=EntityX(True)
		old_y#=EntityY(True)
		old_z#=EntityZ(True)
	
		If recursive=True
		
			For Local ent:TEntity=EachIn child_list
			
				ent.EntityType(type_no,True)
			
			Next
		
		EndIf
		
	End Method
	
	Method EntityPickMode(no,obscure=True)
	
		' add to pick entity list if new mode no&lt;&gt;0 and not previously added
		If pick_mode=0 And no&lt;&gt;0
			ListAddLast(TPick.ent_list,Self)
		EndIf
		
		' remove from pick entity list if new mode no=0 and previously added
		If pick_mode&lt;&gt;0 And no=0
			ListRemove(TPick.ent_list,Self)
		EndIf
	
		pick_mode=no
		obscurer=obscure
			
	End Method
	
	Method EntityCollided:TEntity(type_no)

		' if self is source entity and type_no is dest entity
		For Local i=1 To CountCollisions()
			If CollisionEntity(i).collision_type=type_no Then Return CollisionEntity(i)
		Next

		' if self is dest entity and type_no is src entity
		For Local ent:TEntity=EachIn TCollisionPair.ent_lists[type_no]
			For Local i=1 To ent.CountCollisions()
				If CollisionEntity(i)=Self Then Return ent		
			Next
		Next

		Return Null

	End Method
	
	Method CountCollisions()
	
		Return no_collisions
	
	End Method
	
	Method CollisionX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].x#
		
		EndIf
	
	End Method
	
	Method CollisionY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].y#
		
		EndIf
	
	End Method
	
	Method CollisionZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].z#
		
		EndIf
	
	End Method

	Method CollisionNX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nx#
		
		EndIf
	
	End Method
	
	Method CollisionNY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ny#
		
		EndIf
	
	End Method
	
	Method CollisionNZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nz#
		
		EndIf
	
	End Method
	
	Method CollisionTime#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].time#
		
		EndIf
	
	End Method
	
	Method CollisionEntity:TEntity(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ent
		
		EndIf
	
	End Method
	
	Method CollisionSurface:TSurface(index)
	
		If index&gt;0 And index&lt;=no_collisions

			Return collision[index-1].surf
		
		EndIf
	
	End Method
	
	Method CollisionTriangle(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].tri
		
		EndIf
	
	End Method
	
	Method GetEntityType()

		Return collision_type

	End Method
	
	' Sets an entity's mesh cull radius
	Method MeshCullRadius(radius#)
	
		' set to negative no. so we know when user has set cull radius (manual cull)
		' a check in TMesh.GetBounds then prevents negative no. being overwritten by a positive cull radius (auto cull)
		cull_radius#=-radius#
	
	End Method
	
	Method EntityScaleX#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return w
	End Method
	
	Method EntityScaleY#(glob=False)
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return h
	End Method
	
	Method EntityScaleZ#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return d
	End Method

	' Returns an entity's bounding sphere
	Method BoundingSphereNew(sx# Var,sy# Var,sz# Var,sr# Var)

		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=tformed_x
			y=tformed_y
			z=tformed_z
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		sx=x
		sy=y
		sz=z
		sr=radius

	End Method
	
	Function CountAllChildren(ent:TEntity,no_children=0)
		
		Local ent2:TEntity
	
		For ent2=EachIn ent.child_list

			no_children=no_children+1
			
			no_children=TEntity.CountAllChildren(ent2,no_children)

		Next

		Return no_children

	End Function
	
	Method GetChildFromAll:TEntity(child_no,no_children Var,ent:TEntity=Null)

		If ent=Null Then ent=Self
		
		Local ent3:TEntity=Null
		
		For Local ent2:TEntity=EachIn ent.child_list

			no_children=no_children+1
			
			If no_children=child_no Then Return ent2
			
			If ent3=Null
			
				ent3=GetChildFromAll(child_no,no_children,ent2)

			EndIf

		Next

		Return ent3
			
	End Method
	
	' Internal - not recommended for general use

	Method UpdateMat(load_identity=False)
		'MQ_Update()
		need_update = True
		'mat.Overwrite(MQ_GetMatrix())
	End Method
	
	Method AddParent(parent_ent:TEntity)
	
		' self.parent = parent_ent
		parent:TEntity=parent_ent
		
		' add self to parent_ent child list
		If parent&lt;&gt;Null

			mat.Overwrite(parent.mat)
		
			ListAddLast(parent.child_list,Self)
		
		EndIf
		
	End Method
	
	Function UpdateChildren(ent_p:TEntity)
	
		For Local ent_c:TEntity=EachIn ent_p.child_list

			ent_c.mat.Overwrite(ent_p.mat)
			ent_c.UpdateMat()
				
			UpdateChildren(ent_c:TEntity)
			
		Next
	
	End Function

	' unoptimised, unused
	Method EntityDistanceSquared0#(ent2:TEntity)

		Local xd# = ent2.EntityX#(True)-EntityX#(True)
		Local yd# = ent2.EntityY#(True)-EntityY#(True)
		Local zd# = ent2.EntityZ#(True)-EntityZ#(True)
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method
	
	' optimised
	Method EntityDistanceSquared#(ent2:TEntity)

		If need_update Then MQ_Update()
		If ent2.need_update Then ent2.MQ_Update()

		Local xd# = ent2.mat.grid[3,0]-mat.grid[3,0]
		Local yd# = ent2.mat.grid[3,1]-mat.grid[3,1]
		Local zd# = -ent2.mat.grid[3,2]+mat.grid[3,2]
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method

	Method EntityListAdd(list:TList)
	
		' if order&gt;0, drawn first
		' if order&lt;0, drawn last
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=order Or TEntity(llink.Value()).order&lt;=0
	
			link=list.InsertBeforeLink(Self,llink)
			Return
	
		Else ' put entities with order=0 at back of list, so cameras with order=0 are sorted the same as in B3D

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=order Or TEntity(llink.Value()).order&gt;=0
	
			link=list.InsertAfterLink(Self,llink)
			Return

		EndIf

	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											BEGIN MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------

	'returns copy of rotation matrix	
	Method MQ_CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = rotmat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method

'		Local q1_x#, q1_y#, q1_z#, q1_w#
'		Local q2_x#, q2_y#, q2_z#, q2_w#
'		Local q3_x#, q3_y#, q3_z#, q3_w#
'		Local m1:TMatrix = TMatrix.Create()
'		Local m2:TMatrix = TMatrix.Create()
'				
'		Quaternion_FromAngleAxis(  pitch, -1,  0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
'		Quaternion_FromAngleAxis(  yaw,    0,  1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
'		Quaternion_FromAngleAxis(  roll,   0,  0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
'		
'		'convert to matrices	
'		m1.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
'		m2.FromQuaternion(q2_x, q2_y, q2_z, q2_w)
'		
'		'apply
'		rotmat.FromQuaternion(q3_x, q3_y, q3_z, q3_w) 'roll
'		rotmat.Multiply2(m1) 'pitch
'		rotmat.Multiply2(m2) 'yaw
	
	'turn entity
	Method MQ_Rotate( pitch#, yaw#, roll#, glob=False )
	
		rotmat.LoadIdentity()
		rotmat.Rotate(pitch, yaw, roll)
		
		If glob Then
			'get parent inverted rotation matrix
			If parent &lt;&gt; Null Then
				Local m2:TMatrix = TMatrix.Create()
				m2:TMatrix = parent.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
				'apply rotation matrix
				rotmat.Multiply2(m2)
			End If
		End If
		
	End Method

	'turn entity
	Method MQ_Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
				
	End Method

	'turn entity
	Method MQ_Turn2( pitch#,yaw#,roll#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		Local q2_x#, q2_y#, q2_z#, q2_w#
		Local q3_x#, q3_y#, q3_z#, q3_w#
		Local qr_x#, qr_y#, qr_z#, qr_w#
		
		Quaternion_FromAngleAxis( pitch, 1,0,0, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Quaternion_FromAngleAxis( yaw,   0,1,0, q2_x#, q2_y#, q2_z#, q2_w# ) 'create quaternion
		Quaternion_FromAngleAxis( roll,  0,0,1, q3_x#, q3_y#, q3_z#, q3_w# ) 'create quaternion

		Quaternion_MultiplyQuat( q1_x#, q1_y#, q1_z#, q1_w#, q2_x#, q2_y#, q2_z#, q2_w#, qr_x#, qr_y#, qr_z#, qr_w# )
		Quaternion_MultiplyQuat( qr_x#, qr_y#, qr_z#, qr_w#, q3_x#, q3_y#, q3_z#, q3_w#, q1_x#, q1_y#, q1_z#, q1_w# )
		
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method MQ_TransformPoint( ix# Var,iy# Var,iz# Var)
		
		rotmat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method MQ_Position( qx#,qy#,qz#, glob=False )
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then 
				TFormPoint(qx, qy, qz, Null, parent)
				qx = tformed_x
				qy = tformed_y
				qz = tformed_z
			End If
		End If
		
		px = qx
		py = qy
		pz = qz

	End Method

	'move an entity
	Method MQ_Move( qx#,qy#,qz# )
		MQ_TransformPoint(qx,qy,qz) 'transform point by internal matrix
		px = px + qx 'add to position
		py = py + qy
		pz = pz + qz
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat0:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat0 = parent.MQ_GetInvMatrix(scale)
		Else
			mat0 = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = MQ_CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-px,-py, pz)
		
		'combine
		mat1.Multiply2(mat3)
		mat2.Multiply2(mat1)
		mat0.Multiply2(mat2)
		
		Return mat0
		
	End Method

	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local ipz#
			
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(px, py, -pz)
		'rotation
		mat1:TMatrix = rotmat.Copy()

		mat3.Multiply2(mat1)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat3.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat3
		
	End Method

Rem
	'get matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
			
		Local mat1:TMatrix = TMatrix.Create()
		Local isx#,isy#,isz#
		
		If sx = 0 Then isx = 1 Else isx = sx
		If sy = 0 Then isy = 1 Else isy = sy
		If sz = 0 Then isz = 1 Else isz = sz
		mat1.grid[0,0]=rotmat.grid[0,0]/sx
		mat1.grid[0,1]=rotmat.grid[1,0]/sx
		mat1.grid[0,2]=rotmat.grid[2,0]/sx
		mat1.grid[1,0]=rotmat.grid[0,1]/sy
		mat1.grid[1,1]=rotmat.grid[1,1]/sy
		mat1.grid[1,2]=rotmat.grid[2,1]/sy
		mat1.grid[2,0]=rotmat.grid[0,2]/sz
		mat1.grid[2,1]=rotmat.grid[1,2]/sz
		mat1.grid[2,2]=rotmat.grid[2,2]/sz
		mat1.grid[3,0]=-px
		mat1.grid[3,1]=-py
		mat1.grid[3,2]=pz

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1.Multiply2(parent.MQ_GetInvMatrix(scale))
		End If
		
		Return mat1
		
	End Method

	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
				
		Local mat1:TMatrix = TMatrix.Create()
		
		mat1.grid[0,0]=rotmat.grid[0,0]*sx
		mat1.grid[0,1]=rotmat.grid[0,1]*sx
		mat1.grid[0,2]=rotmat.grid[0,2]*sx
		mat1.grid[1,0]=rotmat.grid[1,0]*sy
		mat1.grid[1,1]=rotmat.grid[1,1]*sy
		mat1.grid[1,2]=rotmat.grid[1,2]*sy
		mat1.grid[2,0]=rotmat.grid[2,0]*sz
		mat1.grid[2,1]=rotmat.grid[2,1]*sz
		mat1.grid[2,2]=rotmat.grid[2,2]*sz
		mat1.grid[3,0]=px
		mat1.grid[3,1]=py
		mat1.grid[3,2]=-pz

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat1
		
	End Method
EndRem

	'update attached entity
	Method MQ_Update()
			
		mat.Overwrite(MQ_GetMatrix(True))		
		need_update = False

		'update child_list		
		Local e:TEntity
		For e:TEntity = EachIn child_list
			e.MQ_Update
		Next

	End Method

	'set scaling for an entity
	Method MQ_Scale( w#, h#, d#, glob )
	
		'hiero
		If glob Then
			If parent &lt;&gt; Null Then
				Local esx# = parent.EntityScaleX(True)
				Local esy# = parent.EntityScaleY(True)
				Local esz# = parent.EntityScaleZ(True)
				If esx &lt;&gt; 0 Then w = w / esx
				If esy &lt;&gt; 0 Then h = h / esy
				If esz &lt;&gt; 0 Then d = d / esz
			End If
		End If

		sx = w
		sy = h
		sz = d

	End Method


	'set an entity's parent	
	Method MQ_SetParent(e:TEntity, glob)
	
		Local orgx#,orgy#,orgz#
		Local orgw#,orgh#,orgd#
		Local neww#,newh#,newd#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			TFormPoint(0, 0, 0, Self, Null)
			orgx = tformed_x
			orgy = tformed_y
			orgz = tformed_z
			m1:TMatrix = MQ_GetMatrix(False)
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
			'get scaling
			MQ_GetScaleXYZ(orgw#,orgh#,orgd#)
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.child_list, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then
				TFormPoint(orgx, orgy, orgz, Null, e)
				orgx = tformed_x
				orgy = tformed_y
				orgz = tformed_z
			End If
			'set position
			px = orgx
			py = orgy
			pz = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			m1.Multiply2(m2)
			rotmat.Overwrite(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.child_list, Self

		'get scaling
		MQ_GetScaleXYZ(neww#,newh#,newd#)
		If neww &lt;&gt; 0 Then sx = sx * orgw / neww
		If newh &lt;&gt; 0 Then sy = sy * orgh / newh
		If newd &lt;&gt; 0 Then sz = sz * orgd / newd
	
	End Method

	'get entity scale	
	Method MQ_GetScaleXYZ(width# Var, height# Var, depth# Var, glob=True)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		If glob Then 
			m:TMatrix = MQ_GetMatrix()
		Else
			m:TMatrix = TMatrix.Create()
			m.Scale(sx, sy, sz)
		End If
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											END MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------
End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											AlignToVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function AlignToVector2(e:TEntity, x#, y#, z#, axis=3, rate#=1.0)

	If axis&lt;1 Or axis&gt;3 Then Return

	Local ax#,ay#,az#
	Local dd#
	Local m:TMatrix = TMatrix.Create()
	
	'normalize
	dd# = Magnitude(x,y,z)
	If dd &lt; 0.000001 Then Return
	x = x / dd
	y = y / dd
	z = z / dd	

	'get original axis	
	ax# = (axis=1)
	ay# = (axis=2)
	az# = (axis=3)
	TFormNormal ax, ay, az, e, Null
	ax =  TFormedX()
	ay =  TFormedY()
	az =  TFormedZ()
	
 	'get transformation matrix from org. axis to new one
	m.FromToRotation(ax,ay,-az, x,y,-z)
	
	'interpolate
	If rate &lt; 1.0 Then
		m:TMatrix = InterpolateMatrix(m, rate)
	End If
	
     'apply matrix
	e.rotmat.Multiply2(m)
	e.need_update = True
'	e.MQ_Update()
			 		
End Function

'update entity matrix
Function UpdateEntities()

	Local e:TEntity
	For e:TEntity = EachIn TEntity.entity_list
		If e.need_update Then e.MQ_Update()
	Next

End Function
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> TGlobal.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TGlobal

	Global width,height,mode,depth,rate
	Global ambient_red#=0.5,ambient_green#=0.5,ambient_blue#=0.5

	Global vbo_enabled=False ' this is set in GraphicsInit - will be set to true if USE_VBO is true and the hardware supports vbos

	' anti aliasing globs
	Global aa ' anti_alias true/false
	Global ACSIZE ' accum size
	Global jitter
	Global j#[16,2]

	Function Graphics3D(w,h,d=0,m=0,r=60)

		'mode:
		'0: windowed in debug mode, fullscreen in non-debug mode 
		'1: full-screen always 
		'2: windowed always 

		' change depth values so that Graphics will behave in the same way as Blitz3D-style Graphics3D
		Select m
			Case 0
				?debug
					d=0
				?
				?Not debug
					If d=0 Then d=16
				?
			Case 1
				If d=0 Then d=16
			Case 2
				d=0		
			Default
				d=0		
		End Select
			
		width=w
		height=h
		depth=d
		mode=m
		rate=r
		
		SetGraphicsDriver(GLMax2DDriver()) 
		Graphics(width,height,depth,rate,GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER|GRAPHICS_ACCUMBUFFER)

		GraphicsInit()
								
	End Function

	Function AntiAlias(samples)

		aa=True

		If samples=False Then aa=0;Return
		
		Select samples
			Case 1 RestoreData j2; ACSIZE=2
			Case 2 RestoreData j2; ACSIZE=2
			Case 3 RestoreData j3; ACSIZE=3
			Case 4 RestoreData j4; ACSIZE=4
			Case 5 RestoreData j5; ACSIZE=5
			Case 6 RestoreData j6; ACSIZE=6
			Case 8 RestoreData j8; ACSIZE=8
			Case 9 RestoreData j9; ACSIZE=9
			Case 12 RestoreData j12; ACSIZE=12
			Case 16 RestoreData j16; ACSIZE=16
			Default aa=False; ACSIZE=0; Return
		End Select

		For Local i=0 Until samples
		
			ReadData j[i,0],j[i,1]
		
		Next

	End Function
	
	Function Wireframe(enable)
	
		If enable
			glPolygonMode(GL_FRONT,GL_LINE)
		Else
			glPolygonMode(GL_FRONT,GL_FILL)
		EndIf

	End Function
	
	Function AmbientLight(r#,g#,b#)
	
		ambient_red#=r#/255.0
		ambient_green#=g#/255.0
		ambient_blue#=b#/255.0
	
	End Function
	
	Function ClearCollisions()
	
		For Local col:TCollisionPair=EachIn TCollisionPair.list
			col=Null
		Next

	End Function

	Function Collisions(src_no,dest_no,method_no,response_no=0)
	
		Local col:TCollisionPair=New TCollisionPair
		col.src_type=src_no
		col.des_type=dest_no
		col.col_method=method_no
		col.response=response_no
		
		' check to see if same collision pair already exists
		For Local col2:TCollisionPair=EachIn TCollisionPair.list
			If col2.src_type=col.src_type
				If col2.des_type=col.des_type
					
					' overwrite old method and response values
					col2.col_method=col.col_method
					col2.response=col.response

					Return

				EndIf
			EndIf
		Next
		
		ListAddLast(TCollisionPair.list,col)
	
	End Function
	
	Function ClearWorld(entities=True,brushes=True,textures=True)
	
		If entities
			
			For Local ent:TEntity=EachIn TEntity.entity_list
				ent.FreeEntity()
				ent=Null
			Next
			
			ClearCollisions
			
			ClearList(TPick.ent_list)
			TPick.picked_ent=Null
			TPick.picked_surface=Null
			
		EndIf
		
		If textures
		
			For Local tex:TTexture=EachIn TTexture.tex_list
				tex.FreeTexture()
			Next
		
		EndIf
	
	End Function
			
	Function UpdateWorld(anim_speed#=1.0)
		
		' collision
		
		UpdateCollisions()
		
		' anim
	
		Local first
		Local last

		For Local mesh:TEntity=EachIn TEntity.entity_list
		
			If mesh.anim And mesh.anim_update=True
			
				first=mesh.anim_seqs_first[mesh.anim_seq]
				last=mesh.anim_seqs_last[mesh.anim_seq]
		
				Local anim_start=False

				If mesh.anim_trans&gt;0
					mesh.anim_trans=mesh.anim_trans-1
					If mesh.anim_trans=1 Then anim_start=True
				EndIf
				
				If mesh.anim_trans&gt;0
				
					Local r#=1.0-mesh.anim_time#
					r#=r#/mesh.anim_trans
					mesh.anim_time#=mesh.anim_time+r#
									
					TAnimation.AnimateMesh2(mesh,mesh.anim_time#,first,last)
					
					If anim_start=True Then mesh.anim_time#=first
			
				Else
				
					TAnimation.AnimateMesh(mesh,mesh.anim_time#,first,last)
					
					If mesh.anim_mode=0 Then mesh.anim_update=False ' after updating animation so that animation is in final 'stop' pose - don't update again
		
					If mesh.anim_mode=1
			
						mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
						If mesh.anim_time#&gt;last
							mesh.anim_time#=first+(mesh.anim_time#-last)
						EndIf
					
					EndIf
					
					If mesh.anim_mode=2
					
						If mesh.anim_dir=1
							mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
							If mesh.anim_time#&gt;last
								mesh.anim_time#=mesh.anim_time#-(mesh.anim_speed#*anim_speed#)
								mesh.anim_dir=-1
							EndIf
						EndIf
						
						If mesh.anim_dir=-1
							mesh.anim_time#=mesh.anim_time#-(mesh.anim_speed#*anim_speed#)
							If mesh.anim_time#&lt;first
								mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
								mesh.anim_dir=1
							EndIf
						EndIf
					
					EndIf
					
					If mesh.anim_mode=3
			
						mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
						If mesh.anim_time#&gt;last
							mesh.anim_time#=last
							mesh.anim_mode=0
						EndIf
					
					EndIf
					
				EndIf
							
			EndIf
		
		Next
	
	End Function

	Function RenderWorld()

		UpdateEntities()
	
		' if anti-aliasing enabled then call RenderWorldAA
		If aa Then RenderWorldAA();Return

		For Local cam:TCamera=EachIn TCamera.cam_list

			'If cam.parent_hidden=True Or cam.hidden=True Then Continue
			If cam.Hidden()=True Then Continue

			RenderCamera(cam)

		Next

	End Function
	
	' Same as RenderWorld but with anti-aliasing
	Function RenderWorldAA()
	
		glClear(GL_ACCUM_BUFFER_BIT)
	
		For jitter=0 Until ACSIZE
				
			For Local cam:TCamera=EachIn TCamera.cam_list
	
				'If cam.parent_hidden=True Or cam.hidden=True Then Continue
				If cam.Hidden()=True Then Continue
	
				RenderCamera(cam)
	
			Next
			
			glAccum(GL_ACCUM,1.0/ACSIZE)
	
		Next
		jitter=0
		
		glAccum(GL_RETURN,1.0)
		glFlush()
	
	End Function

	' Render camera - renders all meshes camera can see
	Function RenderCamera(cam:TCamera)

		cam.Update()
	
		For Local light:TLight=EachIn TLight.light_list
	
			light.Update() ' EntityHidden code inside Update
			
		Next

		Local render_list:TList=CreateList:TList()
		
		For Local mesh:TMesh=EachIn TEntity.entity_list
		
			'If mesh.parent_hidden=True Or mesh.hidden=True Or mesh.brush.alpha=0.0 Then Continue
			If mesh.Hidden()=True Or mesh.brush.alpha=0.0 Then Continue
		
			' get new bounds
			mesh.GetBounds()
	
			' Perform frustum cull
			
			Local inview=cam.EntityInFrustum(mesh)

			If inview
			
				If mesh.auto_fade=True Then AutoFade(cam,mesh)
			
				If mesh.Alpha()
			
					mesh.alpha_order#=cam.EntityDistanceSquared#(mesh)
				
				Else
				
					mesh.alpha_order#=0.0
				
				EndIf
			
				RenderListAdd(mesh,render_list)
				
			EndIf
	
		Next

		UpdateSprites(cam,render_list) ' rotate sprites with respect to current cam

		' Draw everything in render list
		For Local mesh2:TMesh=EachIn render_list
		
			mesh2.Update()
	
		Next

	End Function
	
	Function AutoFade(cam:TCamera,mesh:TMesh)

		Local dist#=cam.EntityDistance#(mesh)
		
		If dist&gt;mesh.fade_near And dist&lt;mesh.fade_far
		
			' fade_alpha will be in the range 0 (near) to 1 (far)
			mesh.fade_alpha=(dist-mesh.fade_near)/(mesh.fade_far-mesh.fade_near)
	
		Else
		
			' if entity outside near, far range then set min/max values
			If dist&lt;mesh.fade_near Then mesh.fade_alpha#=0.0 Else mesh.fade_alpha#=1.0
			
		EndIf

	End Function

	Function GraphicsInit()
	
		TTexture.TextureFilter("",9)
	
		glewInit() ' required for ARB funcs

		' get hardware info and set vbo_enabled accordingly
		THardwareInfo.GetInfo()
		'THardwareInfo.DisplayInfo()
		If USE_VBO=True
			vbo_enabled=THardwareInfo.VBOSupport
		EndIf

		If USE_MAX2D=True

			' save the Max2D settings for later - by Oddball
			glPushAttrib GL_ALL_ATTRIB_BITS
			glPushClientAttrib GL_CLIENT_ALL_ATTRIB_BITS
			glMatrixMode GL_MODELVIEW
			glPushMatrix
			glMatrixMode GL_PROJECTION
			glPushMatrix
			glMatrixMode GL_TEXTURE
			glPushMatrix
			glMatrixMode GL_COLOR
			glPushMatrix
		
		EndIf
		
		EnableStates()
		
		glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,GL_SEPARATE_SPECULAR_COLOR)
		glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_TRUE)

		glClearDepth(1.0)						
		glDepthFunc(GL_LEQUAL)
		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)

		glAlphaFunc(GL_GEQUAL,0.5)
		
	End Function
	
	Function EnableStates()
	
		glEnable(GL_LIGHTING)
   		glEnable(GL_DEPTH_TEST)
		glEnable(GL_FOG)
		glEnable(GL_CULL_FACE)
		glEnable(GL_SCISSOR_TEST)
		
		glEnable(GL_NORMALIZE)
		
		glEnableClientState(GL_VERTEX_ARRAY)
		glEnableClientState(GL_COLOR_ARRAY)
		glEnableClientState(GL_NORMAL_ARRAY)
	
	End Function
	
	' Adds mesh to a render list, and inserts mesh into correct position within list depending on order and alpha values
	Function RenderListAdd(mesh:TMesh,List:TList)
	
		' if order&gt;0, drawn first (will appear at back of scene)
		' if order&lt;0, drawn last (will appear at front of scene)
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If mesh.order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=mesh.order
	
			list.InsertBeforeLink(mesh,llink)
			Return
	
		Else If mesh.order&lt;0 ' put entities with order&lt;0 at back of list

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=mesh.order
	
			list.InsertAfterLink(mesh,llink)
			Return

		EndIf
		
		' order=0
		
		If mesh.alpha_order#&gt;0.0
		
			' add alpha entities to near end of list - before entities with order&lt;0

			Repeat
				llink=llink._pred
				If llink=list._head Then Exit
			Until TEntity(llink.Value()).order&gt;=0 And (TEntity(llink.Value()).alpha_order&gt;=mesh.alpha_order Or TEntity(llink.Value()).alpha_order=0.0)

			list.InsertAfterLink(mesh,llink)
			Return
		
		Else
			
			' normal entities - add to list at start - after entities with order&gt;0
		
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=0

			list.InsertBeforeLink(mesh,llink)
			Return
			
		EndIf
		
	End Function

	Function UpdateSprites(cam:TCamera,list:TList)

		For Local sprite:TSprite=EachIn list
		
			If sprite.view_mode&lt;&gt;2
			
				Local x#=sprite.mat.grid[3,0]
				Local y#=sprite.mat.grid[3,1]
				Local z#=sprite.mat.grid[3,2]
			
				sprite.mat.Overwrite(cam.mat)
				sprite.mat.grid[3,0]=x
				sprite.mat.grid[3,1]=y
				sprite.mat.grid[3,2]=z
				sprite.mat_sp.Overwrite(sprite.mat)
				
				If sprite.angle#&lt;&gt;0.0
					sprite.mat_sp.RotateRoll(sprite.angle#)
				EndIf
				
				If sprite.scale_x#&lt;&gt;1.0 Or sprite.scale_y#&lt;&gt;1.0
					sprite.mat_sp.Scale(sprite.scale_x#,sprite.scale_y#,1.0)
				EndIf
				
				If sprite.handle_x#&lt;&gt;0.0 Or sprite.handle_y#&lt;&gt;0.0
					sprite.mat_sp.Translate(-sprite.handle_x#,-sprite.handle_y#,0.0)
				EndIf
				
			Else
			
				sprite.mat_sp.Overwrite(sprite.mat)
				
				If sprite.scale_x#&lt;&gt;1.0 Or sprite.scale_y#&lt;&gt;1.0
					sprite.mat_sp.Scale(sprite.scale_x#,sprite.scale_y#,1.0)
				EndIf
	
			EndIf
			
		Next
	
	End Function
				
End Type
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Tmatrix and Tentity are the same above <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> TAnimation.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TAnimation

	Function AnimateMesh(ent1:TEntity,framef:Float,start_frame,end_frame)
		
		If TMesh(ent1)&lt;&gt;Null
			
			If TMesh(ent1).anim=False Then Return ' mesh contains no anim data
	
			TMesh(ent1).anim_render=True
	
			' cap framef values
			If framef&gt;end_frame Then framef=end_frame
			If framef&lt;start_frame Then framef=start_frame
			
			Local frame=framef ' float to int
	
			For Local bent:TBone=EachIn TMesh(ent1).bones
						
				Local i=0
				Local ii=0
				Local fd1:Float=0 ' anim time since last key
				Local fd2:Float=0 ' anim time until next key
				Local found=False
				Local no_keys=False
				Local w1:Float
				Local x1:Float
				Local y1:Float
				Local z1:Float
				Local w2:Float
				Local x2:Float
				Local y2:Float
				Local z2:Float
				
				Local flag=0
				
				' position
						
				' backwards
				i=frame+1
				Repeat
					i=i-1
					flag=TBone(bent).keys.flags[i]&amp;1
					If flag
						x1=TBone(bent).keys.px[i]
						y1=TBone(bent).keys.py[i]
						z1=TBone(bent).keys.pz[i]
						fd1=framef-i
						found=True
					EndIf
					If i&lt;=start_frame Then i=end_frame+1;ii=ii+1
				Until found=True Or ii&gt;=2
				If found=False Then no_keys=True
				found=False
				ii=0
				
				' forwards
				i=frame
				Repeat
					i=i+1
					If i&gt;end_frame Then i=start_frame;ii=ii+1
					flag=TBone(bent).keys.flags[i]&amp;1
					If flag
						x2=TBone(bent).keys.px[i]
						y2=TBone(bent).keys.py[i]
						z2=TBone(bent).keys.pz[i]
						fd2=i-framef
						found=True
					EndIf
				Until found=True Or ii&gt;=2
				If found=False Then no_keys=True
				found=False
				ii=0
		
				Local px3:Float=0
				Local py3:Float=0
				Local pz3:Float=0
				If no_keys=True ' no keyframes
					px3=TBone(bent).n_px
					py3=TBone(bent).n_py
					pz3=TBone(bent).n_pz
				Else
					If fd1+fd2=0.0 ' one keyframe
						' if only one keyframe, fd1+fd2 will equal 0 resulting in division error and garbage positional values (which can affect children)
						' so we check for this, and if true then positional values equals x1,y1,z1 (same as x2,y2,z2)
						px3=x1
						py3=y1
						pz3=z1
					Else ' more than one keyframe
						px3=(((x2-x1)/(fd1+fd2))*fd1)+x1
						py3=(((y2-y1)/(fd1+fd2))*fd1)+y1
						pz3=(((z2-z1)/(fd1+fd2))*fd1)+z1
					EndIf
				EndIf
				no_keys=False
				
				' store current keyframe for use with transtions
				TBone(bent).kx=px3
				TBone(bent).ky=py3
				TBone(bent).kz=pz3
			
				' rotation
	
				i=frame+1
				Repeat
					i=i-1
					flag=TBone(bent).keys.flags[i]&amp;4
					If flag
						w1=TBone(bent).keys.qw[i]
						x1=TBone(bent).keys.qx[i]
						y1=TBone(bent).keys.qy[i]
						z1=TBone(bent).keys.qz[i]
						fd1=framef-i
						found=True
					EndIf
					If i&lt;=start_frame Then i=end_frame+1;ii=ii+1
				Until found=True Or ii&gt;=2
				If found=False Then no_keys=True
				found=False
				ii=0
				
				' forwards
				i=frame
				Repeat
					i=i+1
					If i&gt;end_frame Then i=start_frame;ii=ii+1
					flag=TBone(bent).keys.flags[i]&amp;4
					If flag
						w2=TBone(bent).keys.qw[i]
						x2=TBone(bent).keys.qx[i]
						y2=TBone(bent).keys.qy[i]
						z2=TBone(bent).keys.qz[i]
						fd2=i-framef
						found=True
					EndIf
				Until found=True Or ii&gt;=2
				If found=False Then no_keys=True
				found=False
				ii=0
	
				' interpolate keys
	
				Local w3:Float=0
				Local x3:Float=0
				Local y3:Float=0
				Local z3:Float=0
				If no_keys=True ' no keyframes
					w3=TBone(bent).n_qw
					x3=TBone(bent).n_qx
					y3=TBone(bent).n_qy
					z3=TBone(bent).n_qz
				Else
					If fd1+fd2=0.0 ' one keyframe
						' if only one keyframe, fd1+fd2 will equal 0 resulting in division error and garbage rotational values (which can affect children)
						' so we check for this, and if true then rotational values equals w1,x1,y1,z1 (same as w2,x2,y2,z2)
						w3=w1
						x3=x1
						y3=y1
						z3=z1
					Else ' more than one keyframe
						Local t:Float=(1.0/(fd1+fd2))*fd1
						TQuaternion.Slerp(x1,y1,z1,w1,x2,y2,z2,w2,x3,y3,z3,w3,t) ' interpolate between prev and next rotations
					EndIf
				EndIf
				no_keys=False
				
				' store current keyframe for use with transtions
				TBone(bent).kqw=w3
				TBone(bent).kqx=x3
				TBone(bent).kqy=y3
				TBone(bent).kqz=z3
		
				TQuaternion.QuatToMat(w3,x3,y3,z3,TBone(bent).rotmat)
	
				'TBone(bent).mat.grid[3,0]=px3
				'TBone(bent).mat.grid[3,1]=py3
				'TBone(bent).mat.grid[3,2]=pz3

				'' store local position/rotation values. will be needed to maintain bone positions when positionentity etc is called
				'Local pitch#=0
				'Local yaw#=0
				'Local roll#=0
				'TQuaternion.QuatToEuler(w3,x3,y3,z3,pitch#,yaw#,roll#)
				'TBone(bent).rx#=-pitch#
				'TBone(bent).ry#=yaw#
				'TBone(bent).rz#=roll#
				
				TBone(bent).px#=px3
				TBone(bent).py#=py3
				TBone(bent).pz#=-pz3
				
				' set mat2 to equal mat
				TBone(bent).mat2.Overwrite(TBone(bent).rotmat)
				TBone(bent).mat2.grid[3,0]=px3
				TBone(bent).mat2.grid[3,1]=py3
				TBone(bent).mat2.grid[3,2]=pz3
				
				' set mat - includes root parent transformation
				' mat is used for store global bone positions, needed when displaying actual bone positions and attaching entities to bones
				'If TBone(bent).parent&lt;&gt;Null
				'	TBone(bent).rotmat.Overwrite(TBone(bent).mat)
				'	'Local new_mat:TMatrix=TBone(bent).parent.mat.Copy()
				'	'new_mat.Multiply(TBone(bent).mat)
				'	'TBone(bent).mat.Overwrite(new_mat)
				'EndIf
				
				' set mat2 - does not include root parent transformation
				' mat2 is used to store local bone positions, and is needed for vertex deform
				If TBone(TBone(bent).parent)&lt;&gt;Null
					Local new_mat:TMatrix=TBone(TBone(bent).parent).mat2.Copy()
					new_mat.Multiply(TBone(bent).mat2)
					TBone(bent).mat2.Overwrite(new_mat)
				EndIf

				' set tform mat
				' A tform mat is needed to transform vertices, and is basically the bone mat multiplied by the inverse reference pose mat
				TBone(bent).tform_mat.Overwrite(TBone(bent).mat2)
				TBone(bent).tform_mat.Multiply(TBone(bent).inv_mat)

				' update bone itselfchildren
				'If TBone(bent).child_list.IsEmpty()&lt;&gt;True Then 
				bent.need_update = True
				'bent.MQ_Update()'UpdateChildren(bent)
								
			Next
								
			' --- vertex deform ---
			VertexDeform(TMesh(ent1))
		
		EndIf
			
	End Function
	
	' AnimateMesh2, used to animate transitions between animations, very similar to AnimateMesh except it
	' interpolates between current animation pose (via saved keyframe) and first keyframe of new animation.
	' framef:Float interpolates between 0 and 1
	
	Function AnimateMesh2(ent1:TEntity,framef:Float,start_frame,end_frame)
		
		If TMesh(ent1)&lt;&gt;Null
	
			If TMesh(ent1).anim=False Then Return ' mesh contains no anim data
			
			TMesh(ent1).anim_render=True
	
			'Local frame=framef ' float to int
	
			For Local bent:TBone=EachIn TMesh(ent1).bones
					
				Local i=0
				Local ii=0
				Local fd1:Float=framef ' fd1 always between 0 and 1 for this function
				Local fd2:Float=1.0-fd1 ' fd1+fd2 always equals 0 for this function
				Local found=False
				Local no_keys=False
				Local w1:Float
				
				' get current keyframe
				Local x1:Float=TBone(bent).kx
				Local y1:Float=TBone(bent).ky
				Local z1:Float=TBone(bent).kz
				
				Local w2:Float
				Local x2:Float
				Local y2:Float
				Local z2:Float
				
				Local flag=0
				
				' position
	
				' forwards
				'i=frame
				i=start_frame-1
				Repeat
					i=i+1
					If i&gt;end_frame Then i=start_frame;ii=ii+1
					flag=TBone(bent).keys.flags[i]&amp;1
					If flag
						x2=TBone(bent).keys.px[i]
						y2=TBone(bent).keys.py[i]
						z2=TBone(bent).keys.pz[i]
						'fd2=i-framef
						found=True
					EndIf
				Until found=True Or ii&gt;=2
				If found=False Then no_keys=True
				found=False
				ii=0
		
				Local px3:Float=0
				Local py3:Float=0
				Local pz3:Float=0
				If no_keys=True ' no keyframes
					px3=TBone(bent).n_px
					py3=TBone(bent).n_py
					pz3=TBone(bent).n_pz
				Else
					If fd1+fd2=0.0 ' one keyframe
						' if only one keyframe, fd1+fd2 will equal 0 resulting in division error and garbage positional values (which can affect children)
						' so we check for this, and if true then positional values equals x1,y1,z1 (same as x2,y2,z2)
						px3=x1
						py3=y1
						pz3=z1
					Else ' more than one keyframe
						px3=(((x2-x1)/(fd1+fd2))*fd1)+x1
						py3=(((y2-y1)/(fd1+fd2))*fd1)+y1
						pz3=(((z2-z1)/(fd1+fd2))*fd1)+z1
					EndIf
				EndIf
				no_keys=False
			
				' get current keyframe
				w1=TBone(bent).kqw
				x1=TBone(bent).kqx
				y1=TBone(bent).kqy
				z1=TBone(bent).kqz
					
				' rotation
	
				' forwards
				'i=frame
				i=start_frame-1
				Repeat
					i=i+1
					If i&gt;end_frame Then i=start_frame;ii=ii+1
					flag=TBone(bent).keys.flags[i]&amp;4
					If flag
						w2=TBone(bent).keys.qw[i]
						x2=TBone(bent).keys.qx[i]
						y2=TBone(bent).keys.qy[i]
						z2=TBone(bent).keys.qz[i]
						'fd2=i-framef
						found=True
					EndIf
				Until found=True Or ii&gt;=2
				If found=False Then no_keys=True
				found=False
				ii=0
	
				' interpolate keys
	
				Local w3:Float=0
				Local x3:Float=0
				Local y3:Float=0
				Local z3:Float=0
				If no_keys=True ' no keyframes
					w3=TBone(bent).n_qw
					x3=TBone(bent).n_qx
					y3=TBone(bent).n_qy
					z3=TBone(bent).n_qz
				Else
					If fd1+fd2=0.0 ' one keyframe
						' if only one keyframe, fd1+fd2 will equal 0 resulting in division error and garbage rotational values (which can affect children)
						' so we check for this, and if true then rotational values equals w1,x1,y1,z1 (same as w2,x2,y2,z2)
						w3=w1
						x3=x1
						y3=y1
						z3=z1
					Else ' more than one keyframe
						Local t:Float=(1.0/(fd1+fd2))*fd1
						TQuaternion.Slerp(x1,y1,z1,w1,x2,y2,z2,w2,x3,y3,z3,w3,t:Float) ' interpolate between prev and next rotations
					EndIf
				EndIf
				no_keys=False
			
				TQuaternion.QuatToMat(w3,x3,y3,z3,TBone(bent).mat)
	
				TBone(bent).mat.grid[3,0]=px3
				TBone(bent).mat.grid[3,1]=py3
				TBone(bent).mat.grid[3,2]=pz3
		
				' store local position/rotation values. will be needed to maintain bone positions when positionentity etc is called
				Local pitch#=0
				Local yaw#=0
				Local roll#=0
				TQuaternion.QuatToEuler(w3,x3,y3,z3,pitch#,yaw#,roll#)
				TBone(bent).rx#=-pitch#
				TBone(bent).ry#=yaw#
				TBone(bent).rz#=roll#
				
				TBone(bent).px#=px3
				TBone(bent).py#=py3
				TBone(bent).pz#=pz3
				
				' set mat2 to equal mat
				TBone(bent).mat2.Overwrite(TBone(bent).mat)
				
				' set mat - includes root parent transformation
				' mat is used for store global bone positions, needed when displaying actual bone positions and attaching entities to bones
				If TBone(bent).parent&lt;&gt;Null
					Local new_mat:TMatrix=TBone(bent).parent.mat.Copy()
					new_mat.Multiply(TBone(bent).mat)
					TBone(bent).mat.Overwrite(new_mat)
				EndIf
				
				' set mat2 - does not include root parent transformation
				' mat2 is used to store local bone positions, and is needed for vertex deform
				If TBone(TBone(bent).parent)&lt;&gt;Null
					Local new_mat:TMatrix=TBone(TBone(bent).parent).mat2.Copy()
					new_mat.Multiply(TBone(bent).mat2)
					TBone(bent).mat2.Overwrite(new_mat)
				EndIf

				' set tform mat
				' A tform mat is needed to transform vertices, and is basically the bone mat multiplied by the inverse reference pose mat
				TBone(bent).tform_mat.Overwrite(TBone(bent).mat2)
				TBone(bent).tform_mat.Multiply(TBone(bent).inv_mat)

				' update bone children
				If TBone(bent).child_list.IsEmpty()&lt;&gt;True Then TEntity.UpdateChildren(bent)
		
			Next
								
			' --- vertex deform ---
			VertexDeform(TMesh(ent1))
		
		EndIf
			
	End Function
	
	Function VertexDeform(ent:TMesh)

		Local ovx:Float,ovy:Float,ovz:Float ' original vertex positions
		Local x:Float,y:Float,z:Float

		Local bone:TBone
		Local weight:Float
		
		Local slink:TLink=TMesh(ent).surf_list.FirstLink() ' used to iterate through surf_list
	
		' cycle through all surfs
		For Local anim_surf:TSurface=EachIn ent.anim_surf_list

			Local surf:TSurface=TSurface(slink.Value:Object())
			
			' mesh shape will be changed, update reset_vbo flag (1=vertices move)
			anim_surf.reset_vbo:|1
				
			Local vid
			Local vid3
			
			For vid=0 Until anim_surf.no_verts
			
				vid3=vid*3

				' BONE 1
						
				If anim_surf.vert_bone1_no[vid]&lt;&gt;0
							
					' get original vertex position
					ovx=surf.vert_coords[vid3+0]'VertexX(vid)
					ovy=surf.vert_coords[vid3+1]'VertexY(vid)
					ovz=surf.vert_coords[vid3+2]'VertexZ(vid)
					
					bone=ent.bones[anim_surf.vert_bone1_no[vid]-1]
					weight:Float=anim_surf.vert_weight1[vid]
					
					' transform vertex position with transform mat
					x= ( bone.tform_mat.grid[0,0]*ovx + bone.tform_mat.grid[1,0]*ovy + bone.tform_mat.grid[2,0]*ovz + bone.tform_mat.grid[3,0] ) * weight
					y= ( bone.tform_mat.grid[0,1]*ovx + bone.tform_mat.grid[1,1]*ovy + bone.tform_mat.grid[2,1]*ovz + bone.tform_mat.grid[3,1] ) * weight
					z= ( bone.tform_mat.grid[0,2]*ovx + bone.tform_mat.grid[1,2]*ovy + bone.tform_mat.grid[2,2]*ovz + bone.tform_mat.grid[3,2] ) * weight
									
					' BONE 2

					If anim_surf.vert_bone2_no[vid]&lt;&gt;0
				
						bone=ent.bones[anim_surf.vert_bone2_no[vid]-1]
						weight=anim_surf.vert_weight2[vid]
						
						' transform vertex position with transform mat
						x:+ ( bone.tform_mat.grid[0,0]*ovx + bone.tform_mat.grid[1,0]*ovy + bone.tform_mat.grid[2,0]*ovz + bone.tform_mat.grid[3,0] ) * weight
						y:+ ( bone.tform_mat.grid[0,1]*ovx + bone.tform_mat.grid[1,1]*ovy + bone.tform_mat.grid[2,1]*ovz + bone.tform_mat.grid[3,1] ) * weight
						z:+ ( bone.tform_mat.grid[0,2]*ovx + bone.tform_mat.grid[1,2]*ovy + bone.tform_mat.grid[2,2]*ovz + bone.tform_mat.grid[3,2] ) * weight
						
						' BONE 3
						
						If anim_surf.vert_bone3_no[vid]&lt;&gt;0

							bone=ent.bones[anim_surf.vert_bone3_no[vid]-1]
							weight=anim_surf.vert_weight3[vid]

							' transform vertex position with transform mat
							x:+ ( bone.tform_mat.grid[0,0]*ovx + bone.tform_mat.grid[1,0]*ovy + bone.tform_mat.grid[2,0]*ovz + bone.tform_mat.grid[3,0] ) * weight
							y:+ ( bone.tform_mat.grid[0,1]*ovx + bone.tform_mat.grid[1,1]*ovy + bone.tform_mat.grid[2,1]*ovz + bone.tform_mat.grid[3,1] ) * weight
							z:+ ( bone.tform_mat.grid[0,2]*ovx + bone.tform_mat.grid[1,2]*ovy + bone.tform_mat.grid[2,2]*ovz + bone.tform_mat.grid[3,2] ) * weight
										
							' BONE 4
							
							If anim_surf.vert_bone4_no[vid]&lt;&gt;0
		
								bone=ent.bones[anim_surf.vert_bone4_no[vid]-1]
								weight=anim_surf.vert_weight4[vid]
								
								' transform vertex position with transform mat
								x:+ ( bone.tform_mat.grid[0,0]*ovx + bone.tform_mat.grid[1,0]*ovy + bone.tform_mat.grid[2,0]*ovz + bone.tform_mat.grid[3,0] ) * weight
								y:+ ( bone.tform_mat.grid[0,1]*ovx + bone.tform_mat.grid[1,1]*ovy + bone.tform_mat.grid[2,1]*ovz + bone.tform_mat.grid[3,1] ) * weight
								z:+ ( bone.tform_mat.grid[0,2]*ovx + bone.tform_mat.grid[1,2]*ovy + bone.tform_mat.grid[2,2]*ovz + bone.tform_mat.grid[3,2] ) * weight
					
							EndIf
					
						EndIf
					
					EndIf
					
					' update vertex position
					'anim_surf.VertexCoords(vid,x,y,z)
					anim_surf.vert_coords[vid3]=x
					anim_surf.vert_coords[vid3+1]=y
					anim_surf.vert_coords[vid3+2]=z
					
				EndIf

			Next
				
			slink=slink.NextLink() ' iterate through surf_list in sync with anim_surf_list
			
		Next
		
	End Function
	
	' this function will normalise weights if their sum doesn't equal 1.0 (unused)
	Function NormaliseWeights(mesh:TMesh)
	
		' cycle through all surfs
		For Local anim_surf:TSurface=EachIn mesh.anim_surf_list
				
			For Local vid=0 Until anim_surf.no_verts

				' normalise weights
		
				Local w1:Float=anim_surf.vert_weight1[vid]
				Local w2:Float=anim_surf.vert_weight2[vid]
				Local w3:Float=anim_surf.vert_weight3[vid]
				Local w4:Float=anim_surf.vert_weight4[vid]
							
				Local wt:Float=w1+w2+w3+w4
					
				' normalise weights if sum of them &lt;&gt; 1.0
																													
				If wt&lt;0.99 Or wt&gt;1.01
		
					Local wm:Float
					If wt&lt;&gt;0.0
						wm=1.0/wt
					Else
						wm=1.0
					EndIf
					w1=w1*wm
					w2=w2*wm
					w3=w3*wm
					w4=w4*wm
		
					anim_surf.vert_weight1[vid]=w1
					anim_surf.vert_weight2[vid]=w2
					anim_surf.vert_weight3[vid]=w3
					anim_surf.vert_weight4[vid]=w4
						
				EndIf
			
			Next
			
		Next
		
	End Function

End Type

Type TAnimationKeys

	Field frames
	Field flags[1]
	Field px:Float[1]
	Field py:Float[1]
	Field pz:Float[1]
	Field sx:Float[1]
	Field sy:Float[1]
	Field sz:Float[1]
	Field qw:Float[1]
	Field qx:Float[1]
	Field qy:Float[1]
	Field qz:Float[1]
	
	Method New()
	
		If LOG_NEW
			DebugLog "New TAnimationKeys"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TAnimationKeys"
		EndIf
	
	End Method
	
	Method Copy:TAnimationKeys()
	
		Local keys:TAnimationKeys=New TAnimationKeys
	
		keys.frames=frames
		keys.flags=flags[..]
		keys.px=px[..]
		keys.py=py[..]
		keys.pz=pz[..]
		keys.sx=sx[..]
		keys.sy=sy[..]
		keys.sz=sz[..]
		keys.qw=qw[..]
		keys.qx=qx[..]
		keys.qy=qy[..]
		keys.qz=qz[..]

		Return keys
	
	End Method
	
End Type
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> it seems to work pretty good<br>how would you get the vector between 2 entities? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> I think it should be the difference between their positions:<br>dx=x2-x1<br>dy=y2-y1<br>dz=z2-z1 <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> oh ok,thanks<br>what is the difference between axis 1,2, or 3<br>i looked at the source but still cant work it out<br><br>EDIT:<br><br>oh axis 3 is z axis 2 is y etc.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Import sidesign.minib3d

Graphics3D 800, 600, 0, 2

CreateLight()

Local cam:TCamera
Local cone:TEntity
Local a#
Local b#
Local x#,y#,z#
Local ex#,ey#,ez#

cam:TCamera = CreateCamera()
MoveEntity cam, 0, 0, -10

cone:TEntity = CreateCone()
RotateMesh TMesh(cone), 90, 0, 0

Local cube:Tentity=CreateCube()

PositionEntity cube,4,4,4

Wireframe 1

Repeat

	
	
	
	x# = 4
	y# = 4
	z# = 4	
	AlignToVector2 cone, x, y, z, 3
		
	RenderWorld
	
	BeginMax2D
		DrawText EntityYaw(cone), 0, 0
	EndMax2D
	Wireframe 1
	
	Flip
	
Until KeyHit(key_escape)

End</textarea><br><br>this makes the cone point at a cube <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Haha .. that's quite nice indeed. Here, I've made the cube move:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Import sidesign.minib3d

Graphics3D 800, 600, 0, 2

CreateLight()

Local cam:TCamera
Local cone:TEntity
Local a#
Local b#
Local x#,y#,z#
Local ex#,ey#,ez#

cam:TCamera = CreateCamera()
MoveEntity cam, 0, 0, -25

cone:TEntity = CreateCone()
RotateMesh TMesh(cone), 90, 0, 0

Local cube:Tentity=CreateCube()

PositionEntity cube,4,4,4

Wireframe 1

Local p#= 0
Repeat
	
	x# = EntityX(cube)
	y# = EntityY(cube)
	z# = EntityZ(cube)
	p=p+1
	TurnEntity cube, Sin(p), 1, 0
	MoveEntity cube, 0, 0, 0.1
	AlignToVector2 cone, x, y, z, 3
		
	RenderWorld
	
	BeginMax2D
		DrawText EntityYaw(cone), 0, 0
	EndMax2D
	Wireframe 1
	
	Flip
	
Until KeyHit(key_escape)

End
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Im installing the new matrix and quat code on a new computer.<br><br>the cone seems to flicker instead of pointing at the cube, is there something wrong with my minib3d code?<br><br>I thought I installed all the files above properly. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Ow .. sorry, it seems I have messed up AlignToVector in the last update. I forgot to mirror the z-axis, giving this strange result.<br>I've updated TEntity.bmx, so it fits again to the rest.<br>Hopefully it works allright again. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Heyho,<br><br>its me again :D<br><br>I really enjoyed working with this, but since Sprites mess up the framerate I would prefer the original idea with TurnEntity2 etc.. I tried to implement the "old" transformationcommands in the new TEntity.bmx etc but with little success. It doesen't crash my app anymore but it just produces weird nonsese :(<br><br>Could you tell me which functions I have to exchange/modify?<br><br>greetings <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Well, I don't remember exactly what I changed. I'm not at home atm, and I can't open the source, so I have to go by memory, which is bad. I believe PositionEntity/RotateEntity/TurnEntity etc and UpdateMat were changed. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> yes, that is what I changed (plus TFormPoint etc) everything with MQ_Update or something like that in it), but still the screen just shows notihg (just black)<br><br>I guess there is still something wrong.<br><br>greetings <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Has the code been fixed? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Fixed in the sense of .. ? I didn't really changed anything big in the meanwhile. Just a few minor tweaks. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Ah from the posts above there seems to be something that broke, just asking if thats been fixed :) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Well, here is my latest mod. I've been using it myself for a few months:<br><a href="http://www.yousendit.com/transfer.php?action=batch_download&amp;batch_id=TzY1K2VsUnJ6NEtGa1E9PQ" target="_blank">http://www.yousendit.com/transfer.php?action=batch_download&amp;batch_id=TzY1K2VsUnJ6NEtGa1E9PQ</a><br>It contains TSceneGraph (for static scenery meshes) TTerrain (roam-based) and the tweaked TEntity.bmx etc.<br>I also made a basic animation system: RecordFrame, PlayFrame, AddFrame and TweenFrame. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Warner :D <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Romanski</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> could you upload it again, warner? pls. the link is broken!! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2009</font></td></tr></table></td></tr><tr ><td class="posttext"> Okay, here it is:<br><a href="http://www.yousendit.com/transfer.php?action=batch_download&amp;batch_id=MVNkanZxa0RxRTNIRGc9PQ" target="_blank">http://www.yousendit.com/transfer.php?action=batch_download&amp;batch_id=MVNkanZxa0RxRTNIRGc9PQ</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Romanski</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> damnit. I am too late, again. sorry. link expired <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jkrankie</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> @warner, if you send me the zip i can host it permanently. i'm charlie@...<br><br>Cheers<br>Charlie <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Panno</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> i need it also please <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> I downloaded it from the most recent post, though I haven't played with it at all yet:<br><br><a href="http://www.hi-toro.com/blitz/sidesign.zip" target="_blank">http://www.hi-toro.com/blitz/sidesign.zip</a> [3.27 MB]<br><br>@Warner, I assume this is OK, but just let me know if you want it removed. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> Ah, thanks! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Romanski</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> ok. thanks for the upload. I tried it but it doesn't work for me. some things are strange/reversed/misplaced. I'm looking for a aligntovector-function that works.<br><br>and this one works best for me(on top of the standard minib3d-mod):<br><br>Function AlignToVector2(ent:TEntity,vx#,vy#,vz#,axis:Int,rate#)<br>	<br>		Local pitch#=Abs(EntityPitch(ent))<br>		Local yaw#=Abs(EntityYaw(ent))<br>		Local roll#=Abs(EntityRoll(ent))<br><br>		Select axis<br>		<br>			Case 1<br>			<br>				Local dest_yaw#=Abs(ATan2(vz#,vx#))<br>				Local dest_roll#=Abs(ATan2(vy#,vx#))<br>			<br>				yaw#=UpdateValue#(yaw#,dest_yaw#,rate#)<br>				roll#=UpdateValue#(roll#,dest_roll#,rate#)<br><br>			Case 2<br>				<br>				Local dest_pitch#=Abs(ATan2(vz#,vy#))<br>				Local dest_roll#=Abs(-ATan2(vx#,vy#))<br>			<br>				pitch#=UpdateValue#(pitch#,dest_pitch#,rate#)<br>				roll#=UpdateValue#(roll#,dest_roll#,rate#)<br><br>			Case 3<br>			<br>				Local dest_pitch#=Abs(-ATan2(vy#,vz#))<br>				Local dest_yaw#=Abs(-ATan2(vx#,vz#))<br>	<br>				pitch#=UpdateValue#(pitch#,dest_pitch#,rate#)<br>				yaw#=UpdateValue#(yaw#,dest_yaw#,rate#)<br><br>		End Select<br>		<br>		RotateEntity ent,pitch#,yaw#,roll#<br>		TurnEntity ent, 0, 180, 0<br>	<br>End Function<br><br><br><br>but this is not 100% working either. there's something about this 160/180 degree thing that I haven't figured out yet. maybe someone will fix it someday... <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> Same problem here, I need a native aligntovector that works, without any of that matrix stuff because I need to ensure compatibility with C++ version of minib3d... <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> we need that bloke from wulfire games with his linear algebra skillz <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>2010</font></td></tr></table></td></tr><tr ><td class="posttext"> I've posted a non-matrix version of AlignToVector in the archive. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>2011</font></td></tr></table></td></tr><tr ><td class="posttext"> For some reason I can't explain there seems to be a bug with the mipmap flag here. I'm currently porting my milkyway background to minib3d and the star background textures are very blurry with your modification. So I switched back to the original 0.53 and without a change at my source the stars are sharp again. But I couldn't find a different between the sources, the textures are loaded with flag 8 and I added ClearTextureFilter() after Graphics3D. Any idea?<br><br>Original (as it should look)<br><img src="http://www.christianhart.de/bb/minib3d/original.jpg"><br><br>Warner<br><img src="http://www.christianhart.de/bb/minib3d/warner.jpg"><br><br>Source+Media+Demos: <a href="http://www.christianhart.de/bb/minib3d/milkywaybmx.zip" target="_blank">Download</a> <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
