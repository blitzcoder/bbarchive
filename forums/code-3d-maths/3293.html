<!DOCTYPE html><html lang="en" ><head ><title >Blitz3D Maths Library</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='Blitz3D Entities compatible Vector - Matrix3 - Matrix4 - Quaternion, language=bb, category=3D Graphics - Maths'><meta name='author' content='Bobysait'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=13>3D Graphics - Maths</a>/Blitz3D Maths Library</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="3293.bb">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitz3D Maths Library by Bobysait</td><td align="right">2016 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> (full code probably too long, so it's split in 4 parts)<br><br>All the maths involved to rebuild a blitz3d like entity system<br>Originally done for a blitzmax 3d engine, all behaviors reproduice perfectly the Turn/Rotate/Move etc ... of the blitz3d entity<br><br><br>Here is a Blitz3d version of the library.<br><br>It also include some color templates to be used as vector.<br><br>Note : The Vector type use a 4 th component "W"<br>originally used for alignement, It's also usefull to store an extra value, like a radius, so a vector can define a sphere.<br><br><br>All class are designed for OOP usage, so they all returns the object passed in the argument of the function.<br>It allows to imbricate function calls in a single line.<br>Also, the functions with "Self" in the name happens the transformation on the first object passed in the argument -&gt; it does not create a new object.<br><br>Local a.Vector = NewVector()<br>Local b.Vector = NewVector()<br>Local c.Vector = VecSub(a,b) -&gt; create a new vector<br>Local d.Vector = VecSelfSub(a,b) -&gt; this will store the result of a-b in a and will return a, so "d" is "a"<br><br>As it's Blitz3D (and not blitzmax), take care of memory leak !<br>If you create an instance of a maths object, don't forget to release it<br>-&gt; Vector quand Quaternion can be freed using "Delete" as they don't store internal objects<br>-&gt; Matrix3 and Matrix4 MUST be freed using Mat3Free(m3) and Mat4Free(m4)<br>(because they store vectors as axis [and position for the matrix4 object])<br><br><br>; Worklog :<br><br>V1.001<br>- Fix an error in VecSub (y was added instead of substract) </td></tr><tr ><td class="cell"><pre class="code">; --------------------------------------------------------------------
; - Maths Library -
; --------------------------------------------------------------------
; - Author  : Bobysait 2016
; - About   : Full compatible with the Blitz3D Entity stuff.
;             the library is a portage of the Bigbang Maths module.
;             whatever, see license aggreement below.
; - license : no restrictions.
;             Feel free to use for any purpose
;             After all, it's just a maths lib.
; --------------------------------------------------------------------</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> The Vector part :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

	; -----------------------------------------
	; - Vector 3 - (Also used to store colors)
	; -----------------------------------------
	Type Vector
		Field X#,Y#,Z#, W#
		End Type ; [W optional -&gt; required on BigBang for alignement]
		
		Function FreeVector		.Vector(v.Vector):Delete v:Return Null: End Function
		
		; Constructors
		Function NewVector		.Vector(x#=0,y#=0,z#=0):Local v.Vector=New Vector:v\X=x:v\Y=y:v\Z=z:v\w=1:Return v:End Function
		Function VecUnit		.Vector() : Return NewVector(1,1,1)											: End Function
		Function VecLeft		.Vector() : Return NewVector(-1,0,0)										: End Function
		Function VecRight		.Vector() : Return NewVector(1,0,0)											: End Function
		Function VecUp			.Vector() : Return NewVector(0,1,0)											: End Function
		Function VecDown		.Vector() : Return NewVector(0,-1,0)										: End Function
		Function VecFront		.Vector() : Return NewVector(0,0,1)											: End Function
		Function VecBack		.Vector() : Return NewVector(0,0,-1)										: End Function
		Function VecForward		.Vector() : Return NewVector(0,0,1)											: End Function
		Function VecBackward	.Vector() : Return NewVector(0,0,-1)										: End Function
		Function VecCopy		.Vector(v.Vector): Return NewVector( v\X,v\Y,v\Z )							: End Function
		Function Vec4Copy		.Vector(v.Vector): Local o.Vector=NewVector( v\X,v\Y,v\Z ):o\W=v\W:Return o	: End Function
		Function VecFromFArray	.Vector(f#[2]) : Return NewVector( f[0],f[1],f[2] )							: End Function
		
		; Set
		Function VecSet			.Vector(v.Vector,x#,y#,z#)	: v\X=x:v\Y=y:v\Z=z:Return v					: End Function
		Function VecSetX		.Vector(v.Vector, x#)		: v\X=x:Return v								: End Function
		Function VecSetY		.Vector(v.Vector, y#)		: v\Y=y:Return v								: End Function
		Function VecSetZ		.Vector(v.Vector, z#)		: v\Z=z:Return v								: End Function
		Function VecSetW		.Vector(v.Vector, w#)		: v\W=w:Return v								: End Function
		Function VecSetVector	.Vector(v.Vector, a.Vector)	: VecSet( v, a\X,a\Y,a\Z):v\W = a\W:Return v	: End Function
		Function VecAssign		.Vector(v.Vector, a.Vector)	: VecSet( v, a\X,a\Y,a\Z):v\W = a\W:Return v	: End Function
		
		; Get
		Function VecX#					(v.Vector)			: Return v\X									: End Function
		Function VecY#					(v.Vector)			: Return v\Y									: End Function
		Function VecZ#					(v.Vector)			: Return v\Z									: End Function
		Function VecW#					(v.Vector)			: Return v\W									: End Function
		
		; scalars
		Function VecScale		.Vector	(v.Vector, a#    )	: Return NewVector(  v\X*a,v\Y*a,v\Z*a)			: End Function
		Function VecSelfScale	.Vector	(v.Vector, a#    )	: Return VecSet(v,v\X*a,v\Y*a,v\Z*a)			: End Function
		Function VecTranslate	.Vector	(v.Vector,x#,y#,z#)	: v\X=v\X+x:v\Y=v\Y+y:v\Z=v\z+z:Return v		: End Function
		Function VecDot#				(v.Vector, a.Vector)	: Return v\X*a\X+v\Y*a\Y+v\Z*a\Z				: End Function
		Function VecLength#				(v.Vector)			: Return Sqr(v\X*v\X+v\Y*v\Y+v\Z*v\Z)			: End Function
		Function VecSqLength#			(v.Vector)			: Return v\X*v\X+v\Y*v\Y+v\Z*v\Z				: End Function
		Function VecNormalize	.Vector	(v.Vector)
			Local l# = Sqr(v\X*v\X+v\Y*v\Y+v\Z*v\Z) : If (l&gt;0.000001) Then l=1.0/l:Return NewVector(v\X*l,v\Y*l,v\Z*l);
			Local x_# = Sgn(v\X), y_# = Sgn(v\Y), z_# = Sgn(v\Z) : If ((x_&lt;&gt;0) or (y_&lt;&gt;0) or (z_&lt;&gt;0)) Then l=1.0/Sqr(x_*x_+y_*y_+z_*z_): Return NewVector(x_*l,y_*l,z_*l);
			Return Vecup();
		End Function
		Function VecSelfNormalize.Vector(v.Vector)
			Local l# = Sqr(v\X*v\X+v\Y*v\Y+v\Z*v\Z) : If (l&gt;0.000001) Then l=1.0/l:Return VecSet(v,v\X*l,v\Y*l,v\Z*l);
			Local x_# = Sgn(v\X), y_# = Sgn(v\Y), z_# = Sgn(v\Z) : If ((x_&lt;&gt;0) or (y_&lt;&gt;0) or (z_&lt;&gt;0)) Then l=1.0/Sqr(x_*x_+y_*y_+z_*z_): Return VecSet(v,x_*l,y_*l,z_*l);
			Return VecSet(v,0,1,0);
		End Function
		
		Function VecSetLength	.Vector	(v.Vector, s#)
			Local l# = v\X*v\X+v\Y*v\Y+v\Z*v\Z : If (l&gt;0.000001) Then l=s/Sqr(l) : v\X=v\X*l:v\Y=v\Y*l:v\Z=v\Z*l :Return v;
			v\X=Sgn(v\X) : v\Y=Sgn(v\Y) : v\Z=Sgn(v\Z) : If ((v\X&lt;&gt;0) Or (v\Y&lt;&gt;0) Or (v\Z&lt;&gt;0)) Then l=s/Sqr(v\X*v\X+v\Y*v\Y+v\Z*v\Z) : v\X=v\X*l : v\Y=v\Y*l : v\Z=v\Z*l :Return v;
			Return VecSet(v, 0,s,0);
		End Function
		
		; Transform
			; vs Vec
			Function VecAdd			.Vector(v.Vector, a.Vector)	: Return NewVector(v\X+a\X,v\Y+a\Y,v\Z+a\Z)		: End Function
			Function VecSelfAdd		.Vector(v.Vector, a.Vector)	: Return VecSet (v,v\X+a\X,v\Y+a\Y,v\Z+a\Z)		: End Function
			Function VecSub			.Vector(v.Vector, a.Vector)	: Return NewVector(v\X-a\X,v\Y-a\Y,v\Z-a\Z)		: End Function
			Function VecSelfSub		.Vector(v.Vector, a.Vector)	: Return VecSet (v,v\X-a\X,v\Y-a\Y,v\Z-a\Z)		: End Function
			Function VecMul			.Vector(v.Vector, a.Vector)	: Return NewVector(v\X*a\X,v\Y*a\Y,v\Z*a\Z)		: End Function
			Function VecSelfMul		.Vector(v.Vector, a.Vector)	: Return VecSet (v,v\X*a\X,v\Y*a\Y,v\Z*a\Z)		: End Function
			Function VecDiv			.Vector(v.Vector, a.Vector)	: Return NewVector(v\X/a\X,v\Y/a\Y,v\Z/a\Z)		: End Function
			Function VecSelfDiv		.Vector(v.Vector, a.Vector)	: Return VecSet (v,v\X/a\X,v\Y/a\Y,v\Z/a\Z)		: End Function
			Function VecMulV		.Vector(v.Vector, a.Vector)	: Return NewVector(v\X*a\X,v\Y*a\Y,v\Z*a\Z)		: End Function
			Function VecSelfMulV	.Vector(v.Vector, a.Vector)	: Return VecSet (v,v\X*a\X,v\Y*a\Y,v\Z*a\Z)		: End Function
			Function VecMulQ		.Vector(v.Vector, q.Quaternion ): Return QuatMulV(q, v)							: End Function
			Function VecSelfMulQ	.Vector(v.Vector, q.Quaternion ): Return QuatSelfMulV(q, v)						: End Function
			Function VecMulM3		.Vector(v.Vector, m.Matrix3 ):Return Mat3MulV(m, v)							: End Function
			Function VecSelfMulM3	.Vector(v.Vector, m.Matrix3 ):Return Mat3SelfMulV(m, v)						: End Function
			Function VecMulM4		.Vector(v.Vector, m.Matrix4 ):Return Mat4MulV(m, v)							: End Function
			Function VecSelfMulM4	.Vector(v.Vector, m.Matrix4 ):Return Mat4SelfMulV(m, v)						: End Function
			Function VecInvert		.Vector(v.Vector)			: Return NewVector(  1.0/v\X,1.0/v\Y, 1.0/v\Z)	: End Function
			Function VecSelfInvert	.Vector(v.Vector)			: Return VecSet(v,1.0/v\X,1.0/v\Y, 1.0/v\Z)	: End Function
			Function VecNegate		.Vector(v.Vector)			: Return NewVector(  -v\X,-v\Y, -v\Z)				: End Function
			Function VecSelfNegate	.Vector(v.Vector)			: Return VecSet(v,-v\X,-v\Y, -v\Z)				: End Function
			Function VecCross		.Vector(v.Vector, a.Vector)	: Return NewVector(  v\Y*a\Z-v\Z*a\Y,v\Z*a\X-v\X*a\Z,v\X*a\Y-v\Y*a\X):End Function
			Function VecSelfCross	.Vector(v.Vector, a.Vector)	: Return VecSet(v,v\Y*a\Z-v\Z*a\Y,v\Z*a\X-v\X*a\Z,v\X*a\Y-v\Y*a\X):End Function
			Function VecPerpendicular.Vector(v.Vector)
				If (Abs(v\X)&gt;Abs(v\Y)) Then Local l1# = Sqr(v\X*v\X+v\Z*v\Z):Return NewVector(v\z/l1,0, -v\X/l1);
				Local l2# = Sqr(v\Y*v\Y+v\Z*v\Z) : Return VecSet(v, 0,v\Z/l2,-v\Y/l2);
			End Function
			Function VecSelfPerpendicular.Vector(v.Vector)
				If (Abs(v\X)&gt;Abs(v\Y)) Then Local l1# = Sqr(v\X*v\X+v\Z*v\Z):Return NewVector(v\z/l1,0, -v\X/l1);
				Local l2# = Sqr(v\Y*v\Y+v\Z*v\Z) : Return VecSet(v, 0,v\Z/l2,-v\Y/l2);
			End Function
			Function VecAddScaled	.Vector(a.Vector,b.Vector, a_Scale#,b_Scale)
				Local v.Vector = New Vector
				v\X = a\X * a_Scale + b\X * b_Scale
				v\Y = a\Y * a_Scale + b\Y * b_Scale
				v\Z = a\Z * a_Scale + b\Z * b_Scale
				v\W = 1
				Return v
			End Function
			Function VecSelfAddScaled	.Vector(a.Vector,b.Vector, a_Scale#,b_Scale)
				a\X = a\X * a_Scale + b\X * b_Scale
				a\Y = a\Y * a_Scale + b\Y * b_Scale
				a\Z = a\Z * a_Scale + b\Z * b_Scale
				Return a
			End Function
			; vs Mat3
			Function VecTransformM3.Vector(v.Vector,m.Matrix3)
				Local o.Vector = New Vector;
				o\X = v\X*m\X\X + v\Y*m\Y\X + v\Z*m\Z\X;
				o\Y = v\X*m\X\Y + v\Y*m\Y\Y + v\Z*m\Z\Y;
				o\Z = v\X*m\X\Z + v\Y*m\Y\Z + v\Z*m\Z\Z;
				o\W = 1
				Return o;
			End Function
			Function VecSelfTransformM3.Vector(v.Vector,m.Matrix3)
				Local lX# = v\X, lY# = v\Y, lZ# = v\Z;
				v\X = lX*m\X\X + lY*m\Y\X + lZ*m\Z\X;
				v\Y = lX*m\X\Y + lY*m\Y\Y + lZ*m\Z\Y;
				v\Z = lX*m\X\Z + lY*m\Y\Z + lZ*m\Z\Z;
				Return v;
			End Function
			Function VecInvertTransformM3.Vector( v.Vector, m.Matrix3 )
				Local m_.Matrix3 = Mat3Invert(m);
				v = VecTransformM3(v, m_);
				FreeMatrix3(m_);
				Return v;
			End Function
			Function VecSelfInvertTransformM3.Vector( v.Vector, m.Matrix3 )
				Local m_.Matrix3 = Mat3Invert(m);
				VecSelfTransformM3(v, m_);
				FreeMatrix3(m_);
				Return v;
			End Function
			
			; vs Mat4
			Function VecTransformM4.Vector(v.Vector,m.Matrix4)
				Local o.Vector = New Vector;
				o\X = v\X*m\X\X + v\Y*m\Y\X + v\Z*m\Z\X + m\P\X;
				o\Y = v\X*m\X\Y + v\Y*m\Y\Y + v\Z*m\Z\Y + m\P\Y;
				o\Z = v\X*m\X\Z + v\Y*m\Y\Z + v\Z*m\Z\Z + m\P\Z;
				o\W = 1
				Return o;
			End Function
			Function VecSelfTransformM4.Vector(v.Vector,m.Matrix4)
				Local lX# = v\X, lY# = v\Y, lZ# = v\Z;
				v\X = lX*m\X\X + lY*m\Y\X + lZ*m\Z\X + m\P\X;
				v\Y = lX*m\X\Y + lY*m\Y\Y + lZ*m\Z\Y + m\P\Y;
				v\Z = lX*m\X\Z + lY*m\Y\Z + lZ*m\Z\Z + m\P\Z;
				Return v;
			End Function
			Function VecInvertTransformM4.Vector( v.Vector, m.Matrix4 )
				Local m_.Matrix4 = Mat4Invert(m);
				v = VecTransformM4(v, m_);
				FreeMatrix4(m_);
				Return v;
			End Function
			Function VecSelfInvertTransformM4.Vector( v.Vector, m.Matrix4 )
				Local m_.Matrix4 = Mat4Invert(m);
				VecSelfTransformM4(v, m_);
				FreeMatrix4(m_);
				Return v;
			End Function
			
		; some smart functions
			; convert to float array
			Function VecArray.Vector(v.Vector, f#[2]) : f[0] = v\X : f[1] = v\Y : f[2] = v\Z : Return v : End Function
			Function VecArray4.Vector(v.Vector, f#[3]) : f[0] = v\X : f[1] = v\Y : f[2] = v\Z : f[3] = v\W : Return v : End Function
			
			; convert to string
			Function VecToString$(v.Vector):Return v\X+" "+v\Y+" "+v\Z: End Function
			Function Vec4ToString$(v.Vector):Return v\X+" "+v\Y+" "+v\Z+" "+v\W: End Function
			Function ColorToString$(v.Vector):Return v\X+" "+v\Y+" "+v\Z+" "+v\W: End Function
			
			; vector pitch and yaw
			Function VecPitch#(v.Vector) : Return -Atan2(v\Y, Sqr(v\X*v\X+v\Z*v\z)) : End Function
			Function VecYaw  #(v.Vector) : Return -Atan2(v\X, v\Z) : End Function
			
			; linear interpolation
			Function VecLerp.Vector(v.Vector, a.Vector, t#) : Return NewVector(v\X+(a\X-v\X)*t, v\Y+(a\Y-v\Y)*t, v\Z+(a\Z-v\Z)*t) : End Function
			Function VecSelfLerp.Vector(v.Vector, a.Vector, t#) : v\x=v\X+(a\X-v\X)*t: v\Y=v\Y+(a\Y-v\Y)*t: v\Z=v\Z+(a\Z-v\Z)*t : Return v: End Function
			
			; Clamp
			Function VecClamp.Vector(v.Vector, vMin.Vector,vMax.Vector)
				Local v_.Vector = VecCopy(v);
				If v_\X &lt; vMin\X Then v_\X=vMin\X;
				If v_\Y &lt; vMin\Y Then v_\Y=vMin\Y;
				If v_\Z &lt; vMin\Z Then v_\Z=vMin\Z;
				If v_\X &gt; vMax\X Then v_\X=vMax\X;
				If v_\Y &gt; vMax\Y Then v_\Y=vMax\Y;
				If v_\Z &gt; vMax\Z Then v_\Z=vMax\Z;
				Return v_;
			End Function
			Function VecSelfClamp.Vector(v.Vector, vMin.Vector,vMax.Vector)
				If v\X &lt; vMin\X Then v\X=vMin\X;
				If v\Y &lt; vMin\Y Then v\Y=vMin\Y;
				If v\Z &lt; vMin\Z Then v\Z=vMin\Z;
				If v\X &gt; vMax\X Then v\X=vMax\X;
				If v\Y &gt; vMax\Y Then v\Y=vMax\Y;
				If v\Z &gt; vMax\Z Then v\Z=vMax\Z;
				Return v;
			End Function
			
			; center
			Function VecCenter.Vector(a.Vector,b.Vector)
				Local v.Vector = New Vector
				v\x = (a\X+b\X)*0.5 : v\Y = (a\Y+b\Y)*0.5 : v\Z = (a\Z+b\Z)*0.5 : v\W = 1 : Return v
			End Function
			Function VecSelfCenter.Vector(v.Vector,b.Vector)
				v\x = (v\X+b\X)*0.5 : v\Y = (v\Y+b\Y)*0.5 : v\Z = (v\Z+b\Z)*0.5 : Return v
			End Function
			
			; bounding sphere
			Function BoundingSphere.Vector(boundMin.Vector, boundMax.Vector)
				Local Center.Vector = New Vector;
				Center\X = (boundMin\X + boundMax\X) * 0.5;
				Center\Y = (boundMin\Y + boundMax\Y) * 0.5;
				Center\Z = (boundMin\Z + boundMax\Z) * 0.5;
				Center\W = Sqr((boundMax\X-boundMin\X)*(boundMax\X-boundMin\X)+(boundMax\Y-boundMin\Y)*(boundMax\Y-boundMin\Y)+(boundMax\Z-boundMin\Z))*0.5
				Return Center;
			End Function
			
			; distances
			Function VecDistance#		(v.Vector, a.Vector): Return Sqr((a\X-v\X)*(a\X-v\X)+(a\Y-v\Y)*(a\Y-v\Y)+(a\Z-v\Z)*(a\Z-v\Z))	: End Function
			Function VecSqDistance#	(v.Vector, a.Vector): Return (a\X-v\X)*(a\X-v\X)+(a\Y-v\Y)*(a\Y-v\Y)+(a\Z-v\Z)*(a\Z-v\Z)		: End Function
			Function VecDistanceXY#	(v.Vector, a.Vector): Return Sqr((a\X-v\X)*(a\X-v\X)+(a\Y-v\Y)*(a\Y-v\Y))						: End Function
			Function VecSqDistanceXY#	(v.Vector, a.Vector): Return (a\X-v\X)*(a\X-v\X)+(a\Y-v\Y)*(a\Y-v\Y)							: End Function
			Function VecDistanceXZ#	(v.Vector, a.Vector): Return Sqr((a\X-v\X)*(a\X-v\X)+(a\Z-v\Z)*(a\Z-v\Z))						: End Function
			Function VecSqDistanceXZ#	(v.Vector, a.Vector): Return (a\X-v\X)*(a\X-v\X)+(a\Z-v\Z)*(a\Z-v\Z)							: End Function
			Function VecDistanceYZ#	(v.Vector, a.Vector): Return Sqr((a\Y-v\Y)*(a\Y-v\Y)+(a\Z-v\Z)*(a\Z-v\Z))						: End Function
			Function VecSqDistanceYZ#	(v.Vector, a.Vector): Return (a\Y-v\Y)*(a\Y-v\Y)+(a\Z-v\Z)*(a\Z-v\Z)							: End Function
			
			; convert to ... (shader-style)
			Function VecXYZ.Vector(v.Vector): Local a.Vector=New Vector: a\X = v\X: a\Y = v\Y: a\Z = v\Z: a\W=1: Return a: End Function
			Function VecXZY.Vector(v.Vector): Local a.Vector=New Vector: a\X = v\X: a\Y = v\Z: a\Z = v\Y: a\W=1: Return a: End Function
			Function VecYXZ.Vector(v.Vector): Local a.Vector=New Vector: a\X = v\Y: a\Y = v\X: a\Z = v\Z: a\W=1: Return a: End Function
			Function VecYZX.Vector(v.Vector): Local a.Vector=New Vector: a\X = v\Y: a\Y = v\Z: a\Z = v\X: a\W=1: Return a: End Function
			Function VecZXY.Vector(v.Vector): Local a.Vector=New Vector: a\X = v\Z: a\Y = v\X: a\Z = v\Y: a\W=1: Return a: End Function
			Function VecZYX.Vector(v.Vector): Local a.Vector=New Vector: a\X = v\Z: a\Y = v\Y: a\Z = v\X: a\W=1: Return a: End Function
			Function VecXY.Vector(v.Vector) : Local a.Vector=New Vector: a\X = v\X: a\Y = v\Y: a\Z = 0.0: a\W=1: Return a: End Function
			Function VecXZ.Vector(v.Vector) : Local a.Vector=New Vector: a\X = v\X: a\Y = v\Z: a\Z = 0.0: a\W=1: Return a: End Function
			Function VecYX.Vector(v.Vector) : Local a.Vector=New Vector: a\X = v\Y: a\Y = v\X: a\Z = 0.0: a\W=1: Return a: End Function
			Function VecYZ.Vector(v.Vector) : Local a.Vector=New Vector: a\X = v\Y: a\Y = v\Z: a\Z = 0.0: a\W=1: Return a: End Function
			Function VecZX.Vector(v.Vector) : Local a.Vector=New Vector: a\X = v\Z: a\Y = v\X: a\Z = 0.0: a\W=1: Return a: End Function
			Function VecZY.Vector(v.Vector) : Local a.Vector=New Vector: a\X = v\Z: a\Y = v\Y: a\Z = 0.0: a\W=1: Return a: End Function
			
		; Vec As Colors
			Function VecR#(v.Vector) : Return v\X : End Function
			Function VecG#(v.Vector) : Return v\Y : End Function
			Function VecB#(v.Vector) : Return v\Z : End Function
			Function VecA#(v.Vector) : Return v\W : End Function
			
			Function VecSetHex.Vector(v.Vector, h%)
				v\W = Float((h Shr(24)) And $FF)/255.0;
				v\X = Float((h Shr(16)) And $FF)/255.0;
				v\Y = Float((h Shr(8)) And $FF)/255.0;
				v\Z = Float(h And $FF)/255.0;
				Return v;
			End Function
			
			Function VecSetColor.Vector(v.Vector,pR#,pG#,pB#,pA#=1.0)
				v\X = pR : v\Y = pG : v\Z = pB : v\W = pA : Return v;
			End Function
			Function VecARGB%(v.Vector): Return Int(v\W*255.0) Shl(24)+Int(v\X*255.0) Shl(16)+Int(v\Y*255.0)Shl(8) + Int(v\Z*255.0) : End Function
			Function VecRGB%(v.Vector) : Return Int(v\X*255.0) Shl(16)+Int(v\Y*255.0)Shl(8) + Int(v\Z*255.0) : End Function
			
			Function VecSetAlpha.Vector(v.Vector, a#): v\W = a: Return v : End Function
			Function VecSetRed.Vector(v.Vector, r#): v\X = r: Return v : End Function
			Function VecSetGreen.Vector(v.Vector, g#): v\Y = g: Return v : End Function
			Function VecSetBlue.Vector(v.Vector, b#): v\Z = b: Return v : End Function
			; Color Templates -&gt; HTML/CSS colors
			.VecColor_Templates
			Data 144
			Data "black",$000000,"white",$FFFFFF,"red",$FF0000,"lime",$00FF00,"blue",$0000FF,"gray",$808080,"grey",$808080,"green",$008000,"cyan",$00FFFF,"medium violet red",$C71585 ; 10
			Data "dark slate blue",$483D8B,"pale violet red",$DB7093,"light steel blue",$B0C4DE,"dodger blue",$1E90FF,"linen",$FAF0E6,"dark slate gray",$2F4F4F,"dark orange",$FF8C00 ; 7
			Data "floral white",$FFFAF0,"light salmon",$FFA07A,"green yellow",$ADFF2F,"light yellow",$FFFFE0,"saddle brown",$8B4513,"navajo white",$FFDEAD,"light slate gray",$778899 ; 7
			Data "white smoke",$F5F5F5,"sandy brown",$F4A460,"ghost white",$F8F8FF,"pale golden rod",$EEE8AA,"dark magenta",$8B008B,"spring green",$00FF7F,"medium sea green",$3CB371 ; 7
			Data "medium spring green",$00FA9A,"light golden rod yellow",$FAFAD2,"peru",$CD853F,"brown",$A52A2A,"forest green",$228B22,"dark golden rod",$B8860B,"cadet blue",$5F9EA0 ; 7
			Data "pale turquoise",$AFEEEE,"light sky blue",$87CEFA,"lavender blush",$FFF0F5,"blanched almond",$FFEBCD,"light sea green",$20B2AA,"tan",$D2B48C,"lemon chiffon",$FFFACD ; 7
			Data "deep sky blue",$00BFFF,"midnight blue",$191970,"medium orchid",$BA55D3,"medium purple",$9370DB,"antique white",$FAEBD7,"dark sea green",$8FBC8F,"dark grey",$A9A9A9 ; 7
			Data "slate gray",$708090,"alice blue",$F0F8FF,"peach puff",$FFDAB9,"misty rose",$FFE4E1,"rosy brown",$BC8F8F,"light cyan",$E0FFFF,"maroon",$800000,"blue violet",$8A2BE2 ; 8
			Data "dark gray",$A9A9A9,"gainsboro",$DCDCDC,"deep pink",$FF1493,"corn silk",$FFF8DC,"chocolate",$D2691E,"sea shell",$FFF5EE,"dark turquoise",$00CED1,"firebrick",$B22222 ; 8
			Data "steel blue",$4682B4,"dark khaki",$BDB76B,"olive drab",$6B8E23,"lawn green",$7CFC00,"indian red",$CD5C5C,"orange red",$FF4500,"golden rod",$DAA520,"magenta",$FF00FF ; 8
			Data "sea green",$2E8B57,"turquoise",$40E0D0,"dark blue",$00008B,"light gray",$D3D3D3,"light grey",$D3D3D3,"light pink",$FFB6C1,"mint cream",$F5FFFA,"pale green",$98FB98 ; 8
			Data "medium blue",$0000CD,"aqua marine",$7FFFD4,"powder blue",$B0E0E6,"light green",$90EE90,"chart reuse",$7FFF00,"indigo",$4B0082,"silver",$C0C0C0,"dark green",$006400 ; 8
			Data "lime green",$32CD32,"slate blue",$6A5ACD,"light blue",$ADD8E6,"royal blue",$4169E1,"dark orchid",$9932CC,"honeydew",$F0FFF0,"fuchsia",$FF00FF,"papaya whip",$FFEFD5 ; 8
			Data "olive",$808000,"coral",$FF7F50,"khaki",$F0E68C,"violet",$EE82EE,"orchid",$DA70D6,"purple",$800080,"dark salmon",$E9967A,"burly wood",$DEB887,"yellow green",$9ACD32 ; 9
			Data "sky blue",$87CEEB,"dark red",$8B0000,"hot pink",$FF69B4,"dim gray",$696969,"dim grey",$696969,"old lace",$FDF5E6,"lavender",$E6E6FA,"orange",$FFA500,"gold",$FFD700 ; 9
			Data "yellow",$FFFF00,"tomato",$FF6347,"salmon",$FA8072,"bisque",$FFE4C4,"sienna",$A0522D,"thistle",$D8BFD8,"crimson",$DC143C,"medium aqua marine",$66CDAA,"teal",$008080 ; 9
			Data "plum",$DDA0DD,"pink",$FFC0CB,"snow",$FFFAFA,"ivory",$FFFFF0,"azure",$F0FFFF,"wheat",$F5DEB3,"beige",$F5F5DC,"moccasin",$FFE4B5,"light coral",$F08080,"Aqua",$00FFFF ; 10
			Data"dark violet",$9400D3,"medium turquoise",$48D1CC,"corn flower blue",$6495ED,"dark olive green",$556B2F,"medium slate blue",$7B68EE,"dark cyan",$008B8B,"navy",$000080 ; 7
			
			Global G_VecColorTemplateCount% = 0
			Global VecColorTemplateNames$[255]
			Global VecColorTemplateValues%[255]
			Function VecRestoreColors()
				Restore VecColor_Templates
				Read G_VecColorTemplateCount
				Local ColName$, Value%, c%
				For c = 0 To G_VecColorTemplateCount-1
					Read VecColorTemplateNames[c]: VecColorTemplateNames[c] = Lower(VecColorTemplateNames[c])
					Read VecColorTemplateValues[c]
				Next
			End Function
			
			Function VecTemplateColor.Vector(name$)
				Local c%, l$ = Lower(name);
				For c = 0 To G_VecColorTemplateCount-1
					If (VecColorTemplateNames[c]=l) Then Return VecSetHex(NewVector(), VecColorTemplateValues[c]);
				Next
				Return NewVector(0,0,0);
			End Function
			
			Function VecTemplateColorId%(name$)
				Local c%, l$ = Lower(name);
				For c = 0 To G_VecColorTemplateCount-1
					If (VecColorTemplateNames[c]=l) Then Return c;
				Next
				Return 0;
			End Function
			
			Function VecTemplateColorById.Vector(pColorId%)
				If ((pColorId&gt;=0) And (pColorId&lt;G_VecColorTemplateCount)) Then Return VecSetHex(NewVector(), VecColorTemplateValues[pColorId]);
				Return NewVector(0,0,0);
			End Function
		
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> The Quaternion part :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	
	; -----------------------------------------
	; - Quaternion -
	; -----------------------------------------
	Type Quaternion
		Field W#, X#, Y#, Z#;
		End Type
		Function FreeQuaternion.Quaternion(q.Quaternion):Delete q:Return Null: End Function
		
		; Constructors
		Function NewQuaternion.Quaternion(w#=1,x#=0,y#=0,z#=0):Local q.Quaternion=New Quaternion: q\W=w:q\X=x:q\Y=y:q\Z=z: Return q:End Function
		Function QuatIdentity.Quaternion(q.Quaternion): q\W=1:q\X=0:q\Y=0:q\Z=0:Return q :End Function
		Function QuatCopy.Quaternion(q.Quaternion):Return NewQuaternion(q\W,q\X,q\Y,q\Z):End Function
		Function QuatFromArray.Quaternion(f#[3]):Return NewQuaternion(f[0],f[1],f[2],f[3]):End Function
		Function QuatFromMat3.Quaternion ( m.Matrix3 )
			Local t# = m\X\X+m\Y\Y+m\Z\Z, q.Quaternion = New Quaternion;
			If( t&gt;0.000001 )
				t = Sqr( t+1.0 )*2.0;
				q\X = (m\Z\Y-m\Y\Z)/t;
				q\Y = (m\X\Z-m\Z\X)/t;
				q\Z = (m\Y\X-m\X\Y)/t;
				q\W = t*.25;
			ElseIf( m\X\X&gt;m\Y\Y And m\X\X&gt;m\Z\Z )
				t=Sqr( m\X\X-m\Y\Y-m\Z\Z+1.0 )*2.0;
				q\X=t*.25;
				q\Y=(m\Y\X+m\X\Y)/t;
				q\Z=(m\X\Z+m\Z\X)/t;
				q\W=(m\Z\Y-m\Y\Z)/t;
			ElseIf( m\Y\Y&gt;m\Z\Z )
				t=Sqr( m\Y\Y-m\Z\Z-m\X\X+1.0 )*2;
				q\X=(m\Y\X+m\X\Y)/t;
				q\Y=t*.25;
				q\Z=(m\Z\Y+m\Y\Z)/t;
				q\W=(m\X\Z-m\Z\X)/t;
			Else
				t=Sqr( m\Z\Z-m\Y\Y-m\X\X+1.0 )*2.0;
				q\X=(m\X\Z+m\Z\X)/t;
				q\Y=(m\Z\Y+m\Y\Z)/t;
				q\Z=t*.25;
				q\W=(m\Y\X-m\X\Y)/t;
			EndIf;
			Return q;
		End Function
		Function QuatFromMat4.Quaternion ( m.Matrix4 )
			Local t# = m\X\X+m\Y\Y+m\Z\Z, q.Quaternion = New Quaternion;
			If( t&gt;0.000001 )
				t = Sqr( t+1.0 )*2.0;
				q\X = (m\Z\Y-m\Y\Z)/t;
				q\Y = (m\X\Z-m\Z\X)/t;
				q\Z = (m\Y\X-m\X\Y)/t;
				q\W = t*.25;
			ElseIf( m\X\X&gt;m\Y\Y And m\X\X&gt;m\Z\Z )
				t=Sqr( m\X\X-m\Y\Y-m\Z\Z+1.0 )*2.0;
				q\X=t*.25;
				q\Y=(m\Y\X+m\X\Y)/t;
				q\Z=(m\X\Z+m\Z\X)/t;
				q\W=(m\Z\Y-m\Y\Z)/t;
			ElseIf( m\Y\Y&gt;m\Z\Z )
				t=Sqr( m\Y\Y-m\Z\Z-m\X\X+1.0 )*2;
				q\X=(m\Y\X+m\X\Y)/t;
				q\Y=t*.25;
				q\Z=(m\Z\Y+m\Y\Z)/t;
				q\W=(m\X\Z-m\Z\X)/t;
			Else
				t=Sqr( m\Z\Z-m\Y\Y-m\X\X+1.0 )*2.0;
				q\X=(m\X\Z+m\Z\X)/t;
				q\Y=(m\Z\Y+m\Y\Z)/t;
				q\Z=t*.25;
				q\W=(m\Y\X-m\X\Y)/t;
			EndIf;
			Return q;
		End Function
		Function QuatFromPitch.Quaternion(p#)	: Return NewQuaternion( Float(Cos(-p*.5)), Float(Sin(-p*.5)), 0.0,0.0 )	: End Function
		Function QuatFromYaw.Quaternion(y#)		: Return NewQuaternion( Float(Cos( y*.5)), 0.0, Float(Sin( y*.5)), 0.0 )	: End Function
		Function QuatFromRoll.Quaternion(r#)	: Return NewQuaternion( Float(Cos(-r*.5)), 0.0, 0.0, Float(Sin(-r*.5)) )	: End Function
		Function QuatFromEulerX.Quaternion(p#)	: Return NewQuaternion( Float(Cos(-p*.5)), Float(Sin(-p*.5)), 0.0,0.0 )	: End Function
		Function QuatFromEulerY.Quaternion(y#)	: Return NewQuaternion( Float(Cos( y*.5)), 0.0, Float(Sin( y*.5)), 0.0 )	: End Function
		Function QuatFromEulerZ.Quaternion(r#)	: Return NewQuaternion( Float(Cos(-r*.5)), 0.0, 0.0, Float(Sin(-r*.5)) )	: End Function
		Function QuatFromEuler.Quaternion(v.Vector)
			Local lX#=v\X*0.5,lY#=v\Y*0.5,lZ#=v\Z*0.5, cx#=Cos(lX),sx#=Sin(lX),cy#=Cos(lY),sy#=Sin(lY),cz#=Cos(lZ),sz#=Sin(lZ);
			Local cxcy#=cx*cy, cxsy#=cx*sy, sxsy#=sx*sy, sxcy#=sx*cy;
			Return QuatSelfNormalize(NewQuaternion(+cxcy*cz-sxsy*sz, +cxsy*sz-sxcy*cz, +cxsy*cz+sxcy*sz, -sxsy*cz-cxcy*sz));
		End Function
		Function QuatFromEulerXYZ.Quaternion(x#,y#,z#)
			Local lX#=x*0.5,lY#=y*0.5,lZ#=z*0.5, cx#=Cos(lX),sx#=Sin(lX),cy#=Cos(lY),sy#=Sin(lY),cz#=Cos(lZ),sz#=Sin(lZ);
			Local cxcy#=cx*cy, cxsy#=cx*sy, sxsy#=sx*sy, sxcy#=sx*cy;
			Return QuatSelfNormalize(NewQuaternion(+cxcy*cz-sxsy*sz, +cxsy*sz-sxcy*cz, +cxsy*cz+sxcy*sz, -sxsy*cz-cxcy*sz));
		End Function
		; set
		Function QuatSet.Quaternion(q.Quaternion, w#=1,x#=0,y#=0,z#=0):q\W=w:q\X=x:q\Y=y:q\Z=z:Return q:End Function
		Function QuatSetQuaternion.Quaternion(q.Quaternion, a.Quaternion):q\W=a\W:q\X=a\X:q\Y=a\Y:q\Z=a\z:Return q:End Function
		Function QuatAssign.Quaternion(q.Quaternion, a.Quaternion):q\W=a\W:q\X=a\X:q\Y=a\Y:q\Z=a\z:Return q:End Function
		Function QuatSetArray.Quaternion(q.Quaternion, a#[3]):q\W=a[0]:q\X=a[1]:q\Y=a[2]:q\Z=a[3]:Return q:End Function
		
		Function QuatSetMat3.Quaternion ( q.Quaternion, m.Matrix3 )
			Local t# = m\X\X+m\Y\Y+m\Z\Z;
			If( t&gt;0.000001 )
				t = Sqr( t+1.0 )*2.0;
				q\X = (m\Z\Y-m\Y\Z)/t;
				q\Y = (m\X\Z-m\Z\X)/t;
				q\Z = (m\Y\X-m\X\Y)/t;
				q\W = t*.25;
			ElseIf( m\X\X&gt;m\Y\Y And m\X\X&gt;m\Z\Z )
				t=Sqr( m\X\X-m\Y\Y-m\Z\Z+1.0 )*2.0;
				q\X=t*.25;
				q\Y=(m\Y\X+m\X\Y)/t;
				q\Z=(m\X\Z+m\Z\X)/t;
				q\W=(m\Z\Y-m\Y\Z)/t;
			ElseIf( m\Y\Y&gt;m\Z\Z )
				t=Sqr( m\Y\Y-m\Z\Z-m\X\X+1.0 )*2;
				q\X=(m\Y\X+m\X\Y)/t;
				q\Y=t*.25;
				q\Z=(m\Z\Y+m\Y\Z)/t;
				q\W=(m\X\Z-m\Z\X)/t;
			Else
				t=Sqr( m\Z\Z-m\Y\Y-m\X\X+1.0 )*2.0;
				q\X=(m\X\Z+m\Z\X)/t;
				q\Y=(m\Z\Y+m\Y\Z)/t;
				q\Z=t*.25;
				q\W=(m\Y\X-m\X\Y)/t;
			EndIf;
			Return q;
		End Function
		Function QuatSetMat4.Quaternion ( q.Quaternion, m.Matrix4 )
			Local t# = m\X\X+m\Y\Y+m\Z\Z;
			If( t&gt;0.000001 )
				t = Sqr( t+1.0 )*2.0;
				q\X = (m\Z\Y-m\Y\Z)/t;
				q\Y = (m\X\Z-m\Z\X)/t;
				q\Z = (m\Y\X-m\X\Y)/t;
				q\W = t*.25;
			ElseIf( m\X\X&gt;m\Y\Y And m\X\X&gt;m\Z\Z )
				t=Sqr( m\X\X-m\Y\Y-m\Z\Z+1.0 )*2.0;
				q\X=t*.25;
				q\Y=(m\Y\X+m\X\Y)/t;
				q\Z=(m\X\Z+m\Z\X)/t;
				q\W=(m\Z\Y-m\Y\Z)/t;
			ElseIf( m\Y\Y&gt;m\Z\Z )
				t=Sqr( m\Y\Y-m\Z\Z-m\X\X+1.0 )*2;
				q\X=(m\Y\X+m\X\Y)/t;
				q\Y=t*.25;
				q\Z=(m\Z\Y+m\Y\Z)/t;
				q\W=(m\X\Z-m\Z\X)/t;
			Else
				t=Sqr( m\Z\Z-m\Y\Y-m\X\X+1.0 )*2.0;
				q\X=(m\X\Z+m\Z\X)/t;
				q\Y=(m\Z\Y+m\Y\Z)/t;
				q\Z=t*.25;
				q\W=(m\Y\X-m\X\Y)/t;
			EndIf;
			Return q;
		End Function
		Function QuatSetPitch.Quaternion(q.Quaternion,p#)
			q\W=Cos(-p*.5): q\X=Sin(-p*.5): q\Y=0: q\Z=0: Return q;
		End Function
		Function QuatSetEulerX.Quaternion(q.Quaternion,p#)
			q\W=Cos(-p*.5): q\X=Sin(-p*.5): q\Y=0: q\Z=0: Return q;
		End Function
		Function QuatSetYaw.Quaternion(q.Quaternion, y#)
			q\W=Float(Cos( y*.5)): q\X=0.0: q\Y=Float(Sin( y*.5)): q\Z=0.0 : Return q;
		End Function
		Function QuatSetEulerY.Quaternion(q.Quaternion, y#)
			q\W=Float(Cos( y*.5)): q\X=0.0: q\Y=Float(Sin( y*.5)): q\Z=0.0 : Return q;
		End Function
		Function QuatSetRoll.Quaternion(q.Quaternion,r#)
			q\W=Float(Cos(-r*.5)) : q\X=0 : q\Y=0 : q\Z=Float(Sin(-r*.5)): Return q;
		End Function
		Function QuatSetEulerZ.Quaternion(q.Quaternion,z#)
			q\W=Float(Cos(-z*.5)) : q\X=0 : q\Y=0 : q\Z=Float(Sin(-z*.5)): Return q;
		End Function
		
		Function QuatSetEuler.Quaternion(q.Quaternion,v.Vector)
			Local lX#=v\X*0.5,lY#=v\Y*0.5,lZ#=v\Z*0.5, cx#=Cos(lX),sx#=Sin(lX),cy#=Cos(lY),sy#=Sin(lY),cz#=Cos(lZ),sz#=Sin(lZ);
			Local cxcy#=cx*cy, cxsy#=cx*sy, sxsy#=sx*sy, sxcy#=sx*cy;
			q\W=+cxcy*cz-sxsy*sz;
			q\X=+cxsy*sz-sxcy*cz;
			q\Y=+cxsy*cz+sxcy*sz;
			q\Z=-sxsy*cz-cxcy*sz;
			Return QuatSelfNormalize(q);
		End Function
		Function QuatSetEulerXYZ.Quaternion(q.Quaternion,x#,y#,z#)
			Local lX#=x*0.5,lY#=y*0.5,lZ#=z*0.5, cx#=Cos(lX),sx#=Sin(lX),cy#=Cos(lY),sy#=Sin(lY),cz#=Cos(lZ),sz#=Sin(lZ);
			Local cxcy#=cx*cy, cxsy#=cx*sy, sxsy#=sx*sy, sxcy#=sx*cy;
			q\W=+cxcy*cz-sxsy*sz;
			q\X=+cxsy*sz-sxcy*cz;
			q\Y=+cxsy*cz+sxcy*sz;
			q\Z=-sxsy*cz-cxcy*sz;
			Return QuatSelfNormalize(q);
		End Function
		Function QuatInvert.Quaternion(q.Quaternion) : Return NewQuaternion(q\W,-q\X,-q\Y,-q\Z) : End Function
		Function QuatSelfInvert.Quaternion(q.Quaternion) : q\X=-q\X:q\Y=-q\Y:q\Z=-q\Z :Return q : End Function
		
		; Convert
		Function QuatToMat3.Matrix3(q.Quaternion)
			Local m.Matrix3 = New Matrix3;
			m\X = VecSet(New Vector, 1.0-2.0*(q\Y*q\Y+q\Z*q\Z),2.0*(q\X*q\Y-q\W*q\Z),2.0*(q\X*q\Z+q\W*q\Y));
			m\Y = VecSet(New Vector, 2.0*(q\X*q\Y+q\W*q\Z),1.0-2.0*(q\X*q\X+q\Z*q\Z),2.0*(q\Y*q\Z-q\W*q\X));
			m\Z = VecSet(New Vector, 2.0*(q\X*q\Z-q\W*q\Y),2.0*(q\Y*q\Z+q\W*q\X),1.0-2.0*(q\X*q\X+q\Y*q\Y));
			Return m;
		End Function
		Function QuatToMat4.Matrix4(q.Quaternion)
			Local m.Matrix4 = New Matrix4;
			m\X = VecSet(New Vector, 1.0-2.0*(q\Y*q\Y+q\Z*q\Z),2.0*(q\X*q\Y-q\W*q\Z),2.0*(q\X*q\Z+q\W*q\Y));
			m\Y = VecSet(New Vector, 2.0*(q\X*q\Y+q\W*q\Z),1.0-2.0*(q\X*q\X+q\Z*q\Z),2.0*(q\Y*q\Z-q\W*q\X));
			m\Z = VecSet(New Vector, 2.0*(q\X*q\Z-q\W*q\Y),2.0*(q\Y*q\Z+q\W*q\X),1.0-2.0*(q\X*q\X+q\Y*q\Y));
			m\P = NewVector();
			Return m;
		End Function
		
		; Get
		Function QuatW#(q.Quaternion):Return q\W: End Function
		Function QuatX#(q.Quaternion):Return q\X: End Function
		Function QuatY#(q.Quaternion):Return q\Y: End Function
		Function QuatZ#(q.Quaternion):Return q\Z: End Function
		Function QuatLength#(q.Quaternion):Return Sqr(q\W*q\W+q\X*q\X+q\Y*q\Y+q\Z*q\Z): End Function
		Function QuatSqLength#(q.Quaternion):Return q\W*q\W+q\X*q\X+q\Y*q\Y+q\Z*q\Z: End Function
		Function QuatScale.Quaternion(q.Quaternion,s#):Return NewQuaternion(q\W*s,q\X*s,q\Y*s,q\Z*s):End Function
		Function QuatSelfScale.Quaternion(q.Quaternion,s#):q\W=q\W*s:q\X=q\X*s:q\Y=q\Y*s:q\Z=q\Z*s:Return q:End Function
		Function QuatNormalize.Quaternion(q.Quaternion)
			Local l#=1.0/Sqr(q\W*q\W + q\X*q\X + q\Y*q\Y + q\Z*q\Z);
			If (l&gt;0.000001) Then Return NewQuaternion(q\W*l,q\X*l,q\Y*l,q\Z*l);
			Return NewQuaternion(1);
		End Function
		Function QuatSelfNormalize.Quaternion(q.Quaternion)
			Local l#=1.0/Sqr(q\W*q\W + q\X*q\X + q\Y*q\Y + q\Z*q\Z);
			If (l&gt;0.000001) Then q\W=q\W*l:q\X=q\X*l:q\Y=q\Y*l:q\Z=q\Z*l:Return q;
			Return QuatSet(q,1,0,0,0);
		End Function
		Function QuatAdd.Quaternion(q.Quaternion, v.Quaternion)
			Local q_.Quaternion=New Quaternion: q_\W=q\W+v\W: q_\X=q\X+v\X: q_\Y=q\Y+v\Y: q_\Z=q\Z+v\Z: Return q_;
		End Function
		Function QuatSelfAdd.Quaternion(q.Quaternion, v.Quaternion)
			q\W=q\W+v\W: q\X=q\X+v\X: q\Y=q\Y+v\Y: q\Z=q\Z+v\Z : Return q;
		End Function
		Function QuatSub.Quaternion(q.Quaternion, v.Quaternion)
			Local q_.Quaternion=New Quaternion: q_\W=q\W-v\W: q_\X=q\X-v\X: q_\Y=q\Y-v\Y: q_\Z=q\Z-v\Z: Return q_;
		End Function
		Function QuatSelfSub.Quaternion(q.Quaternion, v.Quaternion)
			q\W=q\W-v\W: q\X=q\X-v\X: q\Y=q\Y-v\Y: q\Z=q\Z-v\Z : Return q;
		End Function
		Function QuatMul.Quaternion( q.Quaternion, v.Quaternion)
			Local q_.Quaternion = New Quaternion;
			q_\W = q\W*v\W - q\X*v\X - q\Y*v\Y - q\Z*v\Z;
			q_\X = q\W*v\X + q\X*v\W - q\Y*v\Z + q\Z*v\Y;
			q_\Y = q\W*v\Y + q\X*v\Z + q\Y*v\W - q\Z*v\X;
			q_\Z = q\W*v\Z - q\X*v\Y + q\Y*v\X + q\Z*v\W;
			Return q_;
		End Function
		Function QuatSelfMul.Quaternion(q.Quaternion, v.Quaternion)
			Local lw#=q\W, lx#=q\X, ly#=q\Y, lz#=q\Z;
			q\W = lw*v\W - lx*v\X - ly*v\Y - lz*v\Z;
			q\X = lw*v\X + lx*v\W - ly*v\Z + lz*v\Y;
			q\Y = lw*v\Y + lx*v\Z + ly*v\W - lz*v\X;
			q\Z = lw*v\Z - lx*v\Y + ly*v\X + lz*v\W;
			Return q;
		End Function
		Function QuatMulSelf.Quaternion(q.Quaternion, v.Quaternion)
			Local lw#=q\W, lx#=q\X, ly#=q\Y, lz#=q\Z;
			q\W = v\W*lw - v\X*lx - v\Y*ly - v\Z*lz;
			q\X = v\W*lx + v\X*lw - v\Y*lz + v\Z*ly;
			q\Y = v\W*ly + v\X*lz + v\Y*lw - v\Z*lx;
			q\Z = v\W*lz - v\X*ly + v\Y*lx + v\Z*lw;
			Return v;
		End Function
		
		; Transform
		Function QuatMulV.Vector(q.Quaternion, v.Vector)
			Local qw# = 			- q\X*v\X	- q\Y*v\Y	- q\Z*v\Z;
			Local qx# = + q\W*v\X 				- q\Y*v\Z	+ q\Z*v\Y;
			Local qy# = + q\W*v\Y	+ q\X*v\Z				- q\Z*v\X;
			Local qz# = + q\W*v\Z	- q\X*v\Y	+ q\Y*v\X;
			Local o.Vector = New Vector;
			o\X = - qw*q\X + qx*q\W + qy*q\Z - qz*q\Y;
			o\Y = - qw*q\Y - qx*q\Z + qy*q\W + qz*q\X;
			o\Z = - qw*q\Z + qx*q\Y - qy*q\X + qz*q\W;
			o\W = 1
			Return o;
		End Function
		Function QuatMulXYZ.Vector(q.Quaternion, pX#, pY#, pZ#)
			Local qw# = - q\X*pX - q\Y*pY - q\Z*pZ;
			Local qx# = + q\W*pX - q\Y*pZ + q\Z*pY;
			Local qy# = + q\W*pY + q\X*pZ - q\Z*pX;
			Local qz# = + q\W*pZ - q\X*pY + q\Y*pX;
			Local o.Vector = New Vector;
			o\X = - qw*q\X + qx*q\W + qy*q\Z - qz*q\Y;
			o\Y = - qw*q\Y - qx*q\Z + qy*q\W + qz*q\X;
			o\Z = - qw*q\Z + qx*q\Y - qy*q\X + qz*q\W;
			o\W = 1
			Return o;
		End Function
		Function QuatSelfMulV.Vector(q.Quaternion,v.Vector)
			Local qw# = 			- q\X*v\X	- q\Y*v\Y	- q\Z*v\Z;
			Local qx# = + q\W*v\X 				- q\Y*v\Z	+ q\Z*v\Y;
			Local qy# = + q\W*v\Y	+ q\X*v\Z				- q\Z*v\X;
			Local qz# = + q\W*v\Z	- q\X*v\Y	+ q\Y*v\X;
			v\X = - qw*q\X + qx*q\W + qy*q\Z - qz*q\Y;
			v\Y = - qw*q\Y - qx*q\Z + qy*q\W + qz*q\X;
			v\Z = - qw*q\Z + qx*q\Y - qy*q\X + qz*q\W;
			Return v;
		End Function
		
		Function QuatMulVX.Vector(q.Quaternion, x#)
			Local v.Vector = New Vector;
			v\X = q\X*x*q\X + q\W*x*q\W - q\Z*x*q\Z - q\Y*x*q\Y;
			v\Y = q\X*x*q\Y - q\W*x*q\Z - q\Z*x*q\W + q\Y*x*q\X;
			v\Z = q\X*x*q\Z + q\W*x*q\Y + q\Z*x*q\X + q\Y*x*q\W;
			v\W = 1
			Return v;
		End Function
		Function QuatMulVY.Vector(q.Quaternion,y#)
			Local v.Vector = New Vector;
			v\X = q\Y*y*q\X + q\Z*y*q\W + q\W*y*q\Z + q\X*y*q\Y;
			v\Y = q\Y*y*q\Y - q\Z*y*q\Z + q\W*y*q\W - q\X*y*q\X;
			v\Z = q\Y*y*q\Z + q\Z*y*q\Y - q\W*y*q\X - q\X*y*q\W;
			v\W = 1
			Return v;
		End Function
		Function QuatMulVZ.Vector(q.Quaternion,z#)
			Local v.Vector = New Vector;
			v\X = q\Z*z*q\X - q\Y*z*q\W + q\X*z*q\Z - q\W*z*q\Y;
			v\Y = q\Z*z*q\Y + q\Y*z*q\Z + q\X*z*q\W + q\W*z*q\X;
			v\Z = q\Z*z*q\Z - q\Y*z*q\Y - q\X*z*q\X + q\W*z*q\W;
			v\W = 1
			Return v;
		End Function
		
		Function QuatToEuler.Vector(q.Quaternion): Local v.Vector = New Vector: v\X = QuatPitch(q): v\Y = QuatYaw(q): v\Z = QuatRoll(q): v\W = 1: Return v: End Function
		Function QuatPitch#(q.Quaternion)
			Local vx# = 2.0*(q\X*q\Z-q\W*q\Y), vz# = 1.0-2.0*(q\X*q\X+q\Y*q\Y): Return -ATan2( 2.0*(q\Y*q\Z+q\W*q\X), Sqr( vx*vx+vz*vz ) );
		End Function
		Function QuatYaw#(q.Quaternion)		: Return -ATan2( q\X*q\Z-q\W*q\Y, .5 - q\X*q\X - q\Y*q\Y ): End Function
		Function QuatRoll#(q.Quaternion)		: Return  ATan2( q\X*q\Y-q\W*q\Z, .5 - q\X*q\X - q\Z*q\Z ): End Function
		Function QuatI.Vector(q.Quaternion)		: Return NewVector( 1.0-2.0*(q\Y*q\Y+q\Z*q\Z), 2.0*(q\X*q\Y-q\W*q\Z), 2.0*(q\X*q\Z+q\W*q\Y) )	: End Function
		Function QuatRight.Vector(q.Quaternion)	: Return NewVector( 1.0-2.0*(q\Y*q\Y+q\Z*q\Z), 2.0*(q\X*q\Y-q\W*q\Z), 2.0*(q\X*q\Z+q\W*q\Y) )	: End Function
		Function QuatLeft.Vector(q.Quaternion)	: Return NewVector(-1.0+2.0*(q\Y*q\Y+q\Z*q\Z),-2.0*(q\X*q\Y-q\W*q\Z),-2.0*(q\X*q\Z+q\W*q\Y) )	: End Function
		Function QuatJ.Vector(q.Quaternion)		: Return NewVector( 2.0*(q\X*q\Y+q\W*q\Z), 1.0-2.0*(q\X*q\X+q\Z*q\Z), 2.0*(q\Y*q\Z-q\W*q\X) )	: End Function
		Function QuatUp.Vector(q.Quaternion)	: Return NewVector( 2.0*(q\X*q\Y+q\W*q\Z), 1.0-2.0*(q\X*q\X+q\Z*q\Z), 2.0*(q\Y*q\Z-q\W*q\X) )	: End Function
		Function QuatDown.Vector(q.Quaternion)	: Return NewVector(-2.0*(q\X*q\Y+q\W*q\Z),-1.0+2.0*(q\X*q\X+q\Z*q\Z),-2.0*(q\Y*q\Z-q\W*q\X) )	: End Function
		Function QuatK.Vector(q.Quaternion)		: Return NewVector( 2.0*(q\X*q\Z-q\W*q\Y), 2.0*(q\Y*q\Z+q\W*q\X), 1.0-2.0*(q\X*q\X+q\Y*q\Y) ) : End Function
		Function QuatFront.Vector(q.Quaternion) : Return NewVector( 2.0*(q\X*q\Z-q\W*q\Y), 2.0*(q\Y*q\Z+q\W*q\X), 1.0-2.0*(q\X*q\X+q\Y*q\Y) ) : End Function
		Function QuatBack.Vector(q.Quaternion)	: Return NewVector(-2.0*(q\X*q\Z-q\W*q\Y),-2.0*(q\Y*q\Z+q\W*q\X),-1.0+2.0*(q\X*q\X+q\Y*q\Y) )	: End Function
		Function QuatArray.Quaternion(q.Quaternion,f#[3]): f[0]=q\W : f[1]=q\X : f[2]=q\Y : f[3]=q\Z : Return q: End Function
		Function QuatToString$(q.Quaternion) : Return q\W+" "+q\X+" "+q\Y+" "+q\Z : End Function
		
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> The Matrix3 part :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	
	; -----------------------------------------
	; - 3*3 Matrix -
	; -----------------------------------------
	Type Matrix3
		Field X.Vector
		Field Y.Vector
		Field Z.Vector
		End Type
		
		Function FreeMatrix3.Matrix3(m.Matrix3):Delete m\X:Delete m\Y:Delete m\Z: Delete m:Return Null:End Function
		; Constructors
		Function NewMatrix3.Matrix3():Local m.Matrix3=New Matrix3: m\X=New Vector: m\Y=New Vector: m\Z=New Vector: Return Mat3Identity(m):End Function
		Function Mat3Copy.Matrix3(Self.Matrix3):Local o.Matrix3=New Matrix3:o\X=VecCopy(Self\X):o\Y=VecCopy(Self\Y):o\Z=VecCopy(Self\Z):Return o:End Function
		Function Mat3FromVectors.Matrix3(x.Vector,y.Vector,z.Vector):Local m.Matrix3=New Matrix3:m\X=VecCopy(x):m\Y=VecCopy(y):m\Z=VecCopy(z):Return m:End Function
		; Set
		Function Mat3Identity.Matrix3(Self.Matrix3):VecSet(Self\X,1,0,0): VecSet(Self\Y, 0,1,0): VecSet(Self\Z, 0,0,1): Return Self:End Function
		Function Mat3Set.Matrix3(Self.Matrix3,xx#,xy#,xz#,yx#,yy#,yz#,zx#,zy#,zz#)
			Self\X\X=xx:Self\X\Y=xy:Self\X\Z=xz;
			Self\Y\X=yx:Self\Y\Y=yy:Self\Y\Z=yz;
			Self\Z\X=zx:Self\Z\Y=zy:Self\Z\Z=zz;
			Return Self;
		End Function
		Function Mat3SetMat3.Matrix3(Self.Matrix3,q.Matrix3)
			Self\X\X=q\X\X:Self\X\Y=q\X\Y:Self\X\Z=q\X\Z;
			Self\Y\X=q\Y\X:Self\Y\Y=q\Y\Y:Self\Y\Z=q\Y\Z;
			Self\Z\X=q\Z\X:Self\Z\Y=q\Z\Y:Self\Z\Z=q\Z\Z;
			Return Self;
		End Function
		Function Mat3Assign.Matrix3(Self.Matrix3, q.Matrix3)
			Self\X\X = q\X\X: Self\X\Y = q\X\Y: Self\X\Z = q\X\Z: Self\X\W = q\X\W;
			Self\Y\X = q\Y\X: Self\Y\Y = q\Y\Y: Self\Y\Z = q\Y\Z: Self\Y\W = q\Y\W;
			Self\Z\X = q\Z\X: Self\Z\Y = q\Z\Y: Self\Z\Z = q\Z\Z: Self\Z\W = q\Z\W;
			Return Self;
		End Function
		Function Mat3SetArray.Matrix3(Self.Matrix3,f#[8])
			Self\X\X=f[0]:Self\X\Y=f[1]:Self\X\Z=f[2];
			Self\Y\X=f[3]:Self\Y\Y=f[4]:Self\Y\Z=f[5];
			Self\Z\X=f[6]:Self\Z\Y=f[7]:Self\Z\Z=f[8];
			Return Self;
		End Function
		Function Mat3SetVectors.Matrix3(Self.Matrix3,x.Vector,y.Vector,z.Vector):VecAssign(Self\X,x):VecAssign(Self\Y,y):VecAssign(Self\Z,z):Return Self:End Function
		Function Mat3Determinant#(m.Matrix3):Return m\X\X*(m\Y\Y*m\Z\Z-m\Y\Z*m\Z\Y )-m\X\Y*(m\Y\X*m\Z\Z-m\Y\Z*m\Z\X )+m\X\Z*(m\Y\X*m\Z\Y-m\Y\Y*m\Z\X ):End Function
		Function Mat3Invert.Matrix3 (Self.Matrix3)
			Local t# = 1.0 / Mat3Determinant(Self);
			Local o.Matrix3 = New Matrix3;
			o\X= VecSet(New Vector, t*(Self\Y\Y*Self\Z\Z-Self\Y\Z*Self\Z\Y),-t*(Self\X\Y*Self\Z\Z-Self\X\Z*Self\Z\Y), t*(Self\X\Y*Self\Y\Z-Self\X\Z*Self\Y\Y));
			o\Y= VecSet(New Vector,-t*(Self\Y\X*Self\Z\Z-Self\Y\Z*Self\Z\X), t*(Self\X\X*Self\Z\Z-Self\X\Z*Self\Z\X),-t*(Self\X\X*Self\Y\Z-Self\X\Z*Self\Y\X));
			o\Z= VecSet(New Vector, t*(Self\Y\X*Self\Z\Y-Self\Y\Y*Self\Z\X),-t*(Self\X\X*Self\Z\Y-Self\X\Y*Self\Z\X), t*(Self\X\X*Self\Y\Y-Self\X\Y*Self\Y\X));
			Return o;
		End Function
		Function Mat3SelfInvert.Matrix3 (Self.Matrix3)
			Local t# = 1.0 / Mat3Determinant(Self);
			Local lxx#=Self\X\X, lxy#=Self\X\Y, lxz#=Self\X\Z;
			Local lyx#=Self\Y\X, lyy#=Self\Y\Y, lyz#=Self\Y\Z;
			Local lzx#=Self\Z\X, lzy#=Self\Z\Y, lzz#=Self\Z\Z;
			Self\X\X= t*(lyy*lzz-lyz*lzy);
			Self\X\Y=-t*(lxy*lzz-lxz*lzy);
			Self\X\Z= t*(lxy*lyz-lxz*lyy);
			Self\Y\X=-t*(lyx*lzz-lyz*lzx);
			Self\Y\Y= t*(lxx*lzz-lxz*lzx);
			Self\Y\Z=-t*(lxx*lyz-lxz*lyx);
			Self\Z\X= t*(lyx*lzy-lyy*lzx);
			Self\Z\Y=-t*(lxx*lzy-lxy*lzx);
			Self\Z\Z= t*(lxx*lyy-lxy*lyx);
			Return Self;
		End Function
		Function Mat3Transpose.Matrix3(Self.Matrix3)
			Local m.Matrix3= NewMatrix3();
			m\X\X=Self\X\X: m\X\Y=Self\Y\X: m\X\Z=Self\Z\X;
			m\Y\X=Self\X\Y: m\Y\Y=Self\Y\Y: m\Y\Z=Self\Z\Y;
			m\Z\X=Self\X\Z: m\Z\Y=Self\Y\Z: m\Z\Z=Self\Z\Z;
			Return m;
		End Function
		Function Mat3SelfTranspose.Matrix3(Self.Matrix3)
			Local t#;
			t = Self\X\Y: Self\X\Y=Self\Y\X: Self\Y\X=t;
			t = Self\X\Z: Self\X\Z=Self\Z\X: Self\Z\X=t;
			t = Self\Y\Z: Self\Y\Z=Self\Z\Y: Self\Z\Y=t;
			Return Self;
		End Function
		Function Mat3Mul.Matrix3(Self.Matrix3,m.Matrix3)
			Local o.Matrix3 = New Matrix3;
			o\X\X=Self\X\X*m\X\X+Self\Y\X*m\X\Y+Self\Z\X*m\X\Z;
			o\X\Y=Self\X\Y*m\X\X+Self\Y\Y*m\X\Y+Self\Z\Y*m\X\Z;
			o\X\Z=Self\X\Z*m\X\X+Self\Y\Z*m\X\Y+Self\Z\Z*m\X\Z;
			o\Y\X=Self\X\X*m\Y\X+Self\Y\X*m\Y\Y+Self\Z\X*m\Y\Z;
			o\Y\Y=Self\X\Y*m\Y\X+Self\Y\Y*m\Y\Y+Self\Z\Y*m\Y\Z;
			o\Y\Z=Self\X\Z*m\Y\X+Self\Y\Z*m\Y\Y+Self\Z\Z*m\Y\Z;
			o\Z\X=Self\X\X*m\Z\X+Self\Y\X*m\Z\Y+Self\Z\X*m\Z\Z;
			o\Z\Y=Self\X\Y*m\Z\X+Self\Y\Y*m\Z\Y+Self\Z\Y*m\Z\Z;
			o\Z\Z=Self\X\Z*m\Z\X+Self\Y\Z*m\Z\Y+Self\Z\Z*m\Z\Z;
			Return o;
		End Function
		Function Mat3SelfMul.Matrix3(Self.Matrix3,m.Matrix3)
			Local lxx#=Self\X\X, lxy#=Self\X\Y, lxz#=Self\X\Z;
			Local lyx#=Self\Y\X, lyy#=Self\Y\Y, lyz#=Self\Y\Z;
			Local lzx#=Self\Z\X, lzy#=Self\Z\Y, lzz#=Self\Z\Z;
			Self\X\X=lxx*m\X\X+lyx*m\X\Y+lzx*m\X\Z;
			Self\X\Y=lxy*m\X\X+lyy*m\X\Y+lzy*m\X\Z;
			Self\X\Z=lxz*m\X\X+lyz*m\X\Y+lzz*m\X\Z;
			Self\Y\X=lxx*m\Y\X+lyx*m\Y\Y+lzx*m\Y\Z;
			Self\Y\Y=lxy*m\Y\X+lyy*m\Y\Y+lzy*m\Y\Z;
			Self\Y\Z=lxz*m\Y\X+lyz*m\Y\Y+lzz*m\Y\Z;
			Self\Z\X=lxx*m\Z\X+lyx*m\Z\Y+lzx*m\Z\Z;
			Self\Z\Y=lxy*m\Z\X+lyy*m\Z\Y+lzy*m\Z\Z;
			Self\Z\Z=lxz*m\Z\X+lyz*m\Z\Y+lzz*m\Z\Z;
			Return Self;
		End Function
		Function Mat3Transform.Vector(Self.Matrix3,v.Vector)
			Return VecTransformM3(v,Self);
		End Function
		Function Mat3InvertTransform.Vector(Self.Matrix3,v.Vector)
			Local m.Matrix3 = Mat3Invert(Self);
			Local o.Vector = VecTransformM3(v,m);
			FreeMatrix3(m)
			Return o;
		End Function
		Function Mat3Normalize.Matrix3(Self.Matrix3)
			Local tX# = 1.0/Sqr(Self\X\X*Self\X\X+Self\X\Y*Self\X\Y+Self\X\Z*Self\X\Z);
			Local tY# = 1.0/Sqr(Self\Y\X*Self\Y\X+Self\Y\Y*Self\Y\Y+Self\Y\Z*Self\Y\Z);
			Local tZ# = 1.0/Sqr(Self\Z\X*Self\Z\X+Self\Z\Y*Self\Z\Y+Self\Z\Z*Self\Z\Z);
			Local m.Matrix3 = New Matrix3;
			m\X = VecSet(New Vector, Self\X\X*tX, Self\X\Y*tX, Self\X\Z*tX);
			m\Y = VecSet(New Vector, Self\Y\X*tY, Self\Y\Y*tY, Self\Y\Z*tY);
			m\Z = VecSet(New Vector, Self\Z\X*tZ, Self\Z\Y*tZ, Self\Z\Z*tZ);
			Return m;
		End Function
		Function Mat3SelfNormalize.Matrix3(Self.Matrix3)
			VecSelfNormalize(Self\X);
			VecSelfNormalize(Self\Y);
			VecSelfNormalize(Self\Z);
			Return Self;
		End Function
		Function Mat3ToQuat.Quaternion(Self.Matrix3)
			Return QuatFromMat3(Self);
		End Function
		Function Mat3ToMat4.Matrix4(Self.Matrix3)
			Local m.Matrix4 = New Matrix4;
			m\X = VecCopy(Self\X): m\X\W = 0.0;
			m\Y = VecCopy(Self\Y): m\Y\W = 0.0;
			m\Z = VecCopy(Self\Z): m\Z\W = 0.0;
			m\P = NewVector();
			Return m;
		End Function
		Function Mat3MulV.Vector(Self.Matrix3,v.Vector)
			Return NewVector(v\X*Self\X\X+v\Y*Self\Y\X+v\Z*Self\Z\X,v\X*Self\X\Y+v\Y*Self\Y\Y+v\Z*Self\Z\Y,v\X*Self\X\Z+v\Y*Self\Y\Z+v\Z*Self\Z\Z);
		End Function
		Function Mat3SelfMulV.Vector(Self.Matrix3,v.Vector)
			Return VecSet(v,v\X*Self\X\X+v\Y*Self\Y\X+v\Z*Self\Z\X,v\X*Self\X\Y+v\Y*Self\Y\Y+v\Z*Self\Z\Y,v\X*Self\X\Z+v\Y*Self\Y\Z+v\Z*Self\Z\Z);
		End Function
		Function Mat3Row.Vector(Self.Matrix3,pCol%)
			If pCol=2 Then Return VecCopy(Self\Z)
			If pCol=1 Then Return VecCopy(Self\Y)
			Return VecCopy(Self\X)
		End Function
		Function Mat3Cell#(Self.Matrix3,j%,i%)
			If j=2
				If i=2 Then Return Self\Z\Z
				If i=1 Then Return Self\Z\Y
				Return Self\Z\X
			ElseIf j=1
				If i=2 Then Return Self\Y\Z
				If i=1 Then Return Self\Y\Y
				Return Self\Y\X
			EndIf
			If i=2 Then Return Self\X\Z
			If i=1 Then Return Self\X\Y
			Return Self\X\X
		End Function
		Function Mat3I.Vector(Self.Matrix3)
			Return VecCopy(Self\X);
		End Function
		Function Mat3J.Vector(Self.Matrix3)
			Return VecCopy(Self\Y);
		End Function
		Function Mat3K.Vector(Self.Matrix3)
			Return VecCopy(Self\Z);
		End Function
		Function Mat3Array.Matrix3(Self.Matrix3,f#[8])
			f[0]=Self\X\X:f[1]=Self\X\Y:f[2]=Self\X\Z
			f[3]=Self\Y\X:f[4]=Self\Y\Y:f[5]=Self\Y\Z
			f[6]=Self\Z\X:f[7]=Self\Z\Y:f[8]=Self\Z\Z
			Return Self;
		End Function
		Function Mat3ToString$(Self.Matrix3)
			Return	VecToString(Self\X)+Chr(13)+VecToString(Self\Y)+Chr(13)+VecToString(Self\Z);
		End Function
		Function Mat3SetRotation.Matrix3(Self.Matrix3,q.Quaternion)
			Self\X\X = 1.0-2.0*(q\Y*q\Y+q\Z*q\Z);
			Self\X\Y =     2.0*(q\X*q\Y-q\W*q\Z);
			Self\X\Z =     2.0*(q\X*q\Z+q\W*q\Y);
			Self\Y\X =     2.0*(q\X*q\Y+q\W*q\Z);
			Self\Y\Y = 1.0-2.0*(q\X*q\X+q\Z*q\Z);
			Self\Y\Z =     2.0*(q\Y*q\Z-q\W*q\X);
			Self\Z\X =     2.0*(q\X*q\Z-q\W*q\Y);
			Self\Z\Y =     2.0*(q\Y*q\Z+q\W*q\X);
			Self\Z\Z = 1.0-2.0*(q\X*q\X+q\Y*q\Y);
			Return Self;
		End Function
		Function Mat3SetScale.Matrix3(Self.Matrix3,s.Vector)
			VecSelfScale(Self\X, s\X);
			VecSelfScale(Self\Y, s\Y);
			VecSelfScale(Self\Z, s\Z);
			Return Self;
		End Function
</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> The Matrix4 part :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

	; -----------------------------------------
	; - 4*4 Matrix -
	; (actually, Vec objects contain 4 components)
	; -----------------------------------------
	Type Matrix4
		Field X.Vector
		Field Y.Vector
		Field Z.Vector
		Field P.Vector
		End Type
		
		Function FreeMatrix4.Matrix4(m.Matrix4):Delete m\X:Delete m\Y:Delete m\Z:Delete m\P: Delete m: Return Null:End Function
		Function NewMatrix4.Matrix4()
			Local m.Matrix4=New Matrix4;
			m\X=VecSet(New Vector, 1,0,0): m\X\W=0;
			m\Y=VecSet(New Vector, 0,1,0): m\Y\W=0;
			m\Z=VecSet(New Vector, 0,0,1): m\Z\W=0;
			m\P=NewVector(0,0,0): m\P\W=1;
			Return m
		End Function
		Function Mat4Identity.Matrix4(m.Matrix4):m\X=VecSet(New Vector, 1,0,0): m\Y=VecSet(New Vector, 0,1,0): m\Z=VecSet(New Vector,0,0,1): m\P=NewVector(0,0,0):Return m:End Function
		Function Mat4SelfTranslate.Matrix4(m.Matrix4,x#,y#,z#):VecTranslate(m\P,x,y,z):Return m:End Function
		Function Mat4FromAxis.Matrix4(x.Vector, y.Vector, z.Vector, p.Vector)
			Local m.Matrix4 = New Matrix4;
			m\X = VecCopy(x): m\X\W=0;
			m\Y = VecCopy(y): m\Y\W=0;
			m\Z = VecCopy(z): m\Z\W=0;
			If (p&lt;&gt;Null)
				m\P = VecCopy(p);
			Else
				m\P = NewVector();
			EndIf;
			m\P\W=1;
			Return m;
		End Function
		Function Mat4SetMat4.Matrix4(Self.Matrix4, q.Matrix4)
			Self\X\X = q\X\X: Self\X\Y = q\X\Y: Self\X\Z = q\X\Z: Self\X\W = q\X\W;
			Self\Y\X = q\Y\X: Self\Y\Y = q\Y\Y: Self\Y\Z = q\Y\Z: Self\Y\W = q\Y\W;
			Self\Z\X = q\Z\X: Self\Z\Y = q\Z\Y: Self\Z\Z = q\Z\Z: Self\Z\W = q\Z\W;
			Self\P\X = q\P\X: Self\P\Y = q\P\Y: Self\P\Z = q\P\Z: Self\P\W = q\P\W;
			Return Self;
		End Function
		Function Mat4Assign.Matrix4(Self.Matrix4, q.Matrix4)
			Self\X\X = q\X\X: Self\X\Y = q\X\Y: Self\X\Z = q\X\Z: Self\X\W = q\X\W;
			Self\Y\X = q\Y\X: Self\Y\Y = q\Y\Y: Self\Y\Z = q\Y\Z: Self\Y\W = q\Y\W;
			Self\Z\X = q\Z\X: Self\Z\Y = q\Z\Y: Self\Z\Z = q\Z\Z: Self\Z\W = q\Z\W;
			Self\P\X = q\P\X: Self\P\Y = q\P\Y: Self\P\Z = q\P\Z: Self\P\W = q\P\W;
			Return Self;
		End Function
		Function Mat4Set.Matrix4( Self.Matrix4, pXX#,pXY#,pXZ#,pXW#, pYX#,pYY#,pYZ#,pYW#, pZX#,pZY#,pZZ#,pZW#, pPX#,pPY#,pPZ#,pWW# )
			Self\X\X = pXX: Self\X\Y = pXY: Self\X\Z = pXZ: Self\X\W = pXW;
			Self\Y\X = pYX: Self\Y\Y = pYY: Self\Y\Z = pYZ: Self\Y\W = pYW;
			Self\Z\X = pZX: Self\Z\Y = pZY: Self\Z\Z = pZZ: Self\Z\W = pZW;
			Self\P\X = pPX: Self\P\Y = pPY: Self\P\Z = pPZ: Self\P\W = pWW;
			Return Self;
		End Function
		Function Mat4SetMat3.Matrix4(Self.Matrix4,m.Matrix4)
			Self\X\X=m\X\X:Self\X\Y=m\X\Y:Self\X\Z=m\X\Z:Self\X\W=m\X\W;
			Self\Y\X=m\Y\X:Self\Y\Y=m\Y\Y:Self\Y\Z=m\Y\Z:Self\Y\W=m\Y\W;
			Self\Z\X=m\Z\X:Self\Z\Y=m\Z\Y:Self\Z\Z=m\Z\Z:Self\Z\W=m\Z\W;
			Self\P\X=m\P\X:Self\P\Y=m\P\Y:Self\P\Z=m\P\Z:Self\P\W=m\P\W;
			Return Self;
		End Function
		Function Mat4SetArray.Matrix4(Self.Matrix4,pF#[15])
			Self\X\X = pF[ 0]: Self\X\Y = pF[ 1]: Self\X\Z = pF[ 2]: Self\X\W = pF[ 3];
			Self\Y\X = pF[ 4]: Self\Y\Y = pF[ 5]: Self\Y\Z = pF[ 6]: Self\Y\W = pF[ 7];
			Self\Z\X = pF[ 8]: Self\Z\Y = pF[ 9]: Self\Z\Z = pF[10]: Self\Z\W = pF[11];
			Self\P\X = pF[12]: Self\P\Y = pF[13]: Self\P\Z = pF[14]: Self\P\W = pF[15];
			Return Self;
		End Function
		Function Mat4Invert.Matrix4 ( Self.Matrix4 )
			Local m.Matrix4 = NewMatrix4();
			Local t#;
			Local lx# = Self\X\Y*Self\Y\Z - Self\X\Z*Self\Y\Y;
			Local ly# = Self\X\Z*Self\Y\X - Self\X\X*Self\Y\Z;
			Local lz# = Self\X\X*Self\Y\Y - Self\X\Y*Self\Y\X;
			t = 1.0 / (Self\Z\X*lx + Self\Z\Y*ly + Self\Z\Z*lz);
			m\X\Z = t*lx;
			m\Y\Z = t*ly;
			m\Z\Z = t*lz;
			m\P\Z = -(m\X\Z*Self\P\X + m\Y\Z*Self\P\Y + m\Z\Z*Self\P\Z);
			m\X\X = t*(Self\Z\Z*Self\Y\Y-Self\Y\Z*Self\Z\Y);
			m\Y\X = t*(Self\Z\X*Self\Y\Z-Self\Y\X*Self\Z\Z);
			m\Z\X = t*(Self\Z\Y*Self\Y\X-Self\Y\Y*Self\Z\X);
			m\P\X = -(m\X\X*Self\P\X + m\Y\X*Self\P\Y + m\Z\X*Self\P\Z);
			m\X\Y = t*(Self\X\Z*Self\Z\Y-Self\X\Y*Self\Z\Z);
			m\Y\Y = t*(Self\X\X*Self\Z\Z-Self\X\Z*Self\Z\X);
			m\Z\Y = t*(Self\X\Y*Self\Z\X-Self\X\X*Self\Z\Y);
			m\P\Y = -(m\X\Y*Self\P\X + m\Y\Y*Self\P\Y + m\Z\Y*Self\P\Z);
			m\X\W = 0.0: m\Y\W = 0.0: m\Z\W = 0.0: m\P\W = 1.0;
			Return m;
		End Function
		Function Mat4SelfInvert.Matrix4 ( Self.Matrix4 )
			Local t#;
			Local mxx#=Self\X\X, mxy#=Self\X\Y, mxz#=Self\X\Z;
			Local myx#=Self\Y\X, myy#=Self\Y\Y, myz#=Self\Y\Z;
			Local mzx#=Self\Z\X, mzy#=Self\Z\Y, mzz#=Self\Z\Z;
			Local mpx#=Self\P\X, mpy#=Self\P\Y, mpz#=Self\P\Z;
			Local lx# = mxy*myz - mxz*myy;
			Local ly# = mxz*myx - mxx*myz;
			Local lz# = mxx*myy - mxy*myx;
			t = 1.0 / (mzx*lx + mzy*ly + mzz*lz);
			Self\X\Z = t*lx;
			Self\Y\Z = t*ly;
			Self\Z\Z = t*lz;
			Self\P\Z = -(Self\X\Z*mpx + Self\Y\Z*mpy + Self\Z\Z*mpz);
			Self\X\X = t*(mzz*myy-myz*mzy);
			Self\Y\X = t*(mzx*myz-myx*mzz);
			Self\Z\X = t*(mzy*myx-myy*mzx);
			Self\P\X = -(Self\X\X*mpx + Self\Y\X*mpy + Self\Z\X*mpz);
			Self\X\Y = t*(mxz*mzy-mxy*mzz);
			Self\Y\Y = t*(mxx*mzz-mxz*mzx);
			Self\Z\Y = t*(mxy*mzx-mxx*mzy);
			Self\P\Y = -(Self\X\Y*mpx + Self\Y\Y*Self\P\Y + Self\Z\Y*mpz);
			Self\X\W = 0.0: Self\Y\W = 0.0: Self\Z\W = 0.0: Self\P\W = 1.0;
			Return Self;
		End Function
		Function Mat4InvertV .Vector ( Self.Matrix4, v.Vector )
			Local x# = Self\X\Y*Self\Y\Z-Self\X\Z*Self\Y\Y;
			Local y# = Self\X\Z*Self\Y\X-Self\X\X*Self\Y\Z;
			Local z# = Self\X\X*Self\Y\Y-Self\X\Y*Self\Z\X;
			Local t# = 1.0 / (Self\Z\X*x+Self\Z\Y*y+Self\Z\Z*z);
			Local m02# = t*x;
			Local m06# = t*y;
			Local m10# = t*z;
			Local m14# = -t*(Self\P\X*x+Self\P\Y*y+Self\P\Z*z);
			x = Self\Y\Y*Self\Z\Z-Self\Y\Z*Self\Z\Y;
			y = Self\Z\X*Self\Y\Z-Self\Y\X*Self\Z\Z;
			z = Self\Y\X*Self\Z\Y-Self\Y\Y*Self\Z\X;
			Local m00# = t*x;
			Local m04# = t*y;
			Local m08# = t*z;
			Local m12# = -t*(Self\P\X*x+Self\P\Y*y+Self\P\Z*z);
			x = Self\X\Z*Self\Z\Y-Self\X\Y*Self\Z\Z;
			y = Self\X\X*Self\Z\Z-Self\X\Z*Self\Z\X;
			z = Self\X\Y*Self\Z\X-Self\X\X*Self\Z\Y;
			Local m01# = t*x;
			Local m05# = t*y;
			Local m09# = t*z;
			Local m13# = -t*(Self\P\X*x+Self\P\Y*y+Self\P\Z*z);
			Local o.Vector = New Vector;
			o\X = v\X*m00 + v\Y*m04 + v\Z*m08 + m12;
			o\Y = v\X*m01 + v\Y*m05 + v\Z*m09 + m13;
			o\Z = v\X*m02 + v\Y*m06 + v\Z*m10 + m14;
			Return v;
		End Function
		Function Mat4SelfInvertV.Vector(Self.Matrix4,v.Vector)
			Local x# = Self\X\Y*Self\Y\Z-Self\X\Z*Self\Y\Y;
			Local y# = Self\X\Z*Self\Y\X-Self\X\X*Self\Y\Z;
			Local z# = Self\X\X*Self\Y\Y-Self\X\Y*Self\Z\X;
			Local t# = 1.0 / (Self\Z\X*x+Self\Z\Y*y+Self\Z\Z*z);
			Local m02# = t*x;
			Local m06# = t*y;
			Local m10# = t*z;
			Local m14# = -t*(Self\P\X*x+Self\P\Y*y+Self\P\Z*z);
			x = Self\Y\Y*Self\Z\Z-Self\Y\Z*Self\Z\Y;
			y = Self\Z\X*Self\Y\Z-Self\Y\X*Self\Z\Z;
			z = Self\Y\X*Self\Z\Y-Self\Y\Y*Self\Z\X;
			Local m00# = t*x;
			Local m04# = t*y;
			Local m08# = t*z;
			Local m12# = -t*(Self\P\X*x+Self\P\Y*y+Self\P\Z*z);
			x = Self\X\Z*Self\Z\Y-Self\X\Y*Self\Z\Z;
			y = Self\X\X*Self\Z\Z-Self\X\Z*Self\Z\X;
			z = Self\X\Y*Self\Z\X-Self\X\X*Self\Z\Y;
			Local m01# = t*x;
			Local m05# = t*y;
			Local m09# = t*z;
			Local m13# = -t*(Self\P\X*x+Self\P\Y*y+Self\P\Z*z);
			Local lx#=v\X,ly#=v\Y,lz#=v\Z;
			v\X = lx*m00 + ly*m04 + lz*m08 + m12;
			v\Y = lx*m01 + ly*m05 + lz*m09 + m13;
			v\Z = lx*m02 + ly*m06 + lz*m10 + m14;
			Return v;
		End Function
		Function Mat4InvertRot.Matrix4(Self.Matrix4)
			Local tX# = 1.0 / (Self\X\X*Self\X\X+Self\X\Y*Self\X\Y+Self\X\Z*Self\X\Z);
			Local tY# = 1.0 / (Self\Y\X*Self\Y\X+Self\Y\Y*Self\Y\Y+Self\Y\Z*Self\Y\Z);
			Local tZ# = 1.0 / (Self\Z\X*Self\Z\X+Self\Z\Y*Self\Z\Y+Self\Z\Z*Self\Z\Z);
			Local m.Matrix4 = NewMatrix4();
			m\X\X = Self\X\X*tX: m\X\Y = Self\Y\X*tY: m\X\Z = Self\Z\X*tZ: m\X\W = 0.0;
			m\Y\X = Self\X\Y*tX: m\Y\Y = Self\Y\Y*tY: m\Y\Z = Self\Z\Y*tZ: m\Y\W = 0.0;
			m\Z\X = Self\X\Z*tX: m\Z\Y = Self\Y\Z*tY: m\Z\Z = Self\Z\Z*tZ: m\Z\W = 0.0;
			m\P\X = -tX*(Self\P\X*Self\X\X+Self\P\Y*Self\X\Y+Self\P\Z*Self\X\Z);
			m\P\Y = -tY*(Self\P\X*Self\Y\X+Self\P\Y*Self\Y\Y+Self\P\Z*Self\Y\Z);
			m\P\Z = -tZ*(Self\P\X*Self\Z\X+Self\P\Y*Self\Z\Y+Self\P\Z*Self\Z\Z);
			m\P\W = 1.0;
			Return m;
		End Function
		Function Mat4SelfInvertRot.Matrix4(Self.Matrix4)
			Local tX# = 1.0 / (Self\X\X*Self\X\X+Self\X\Y*Self\X\Y+Self\X\Z*Self\X\Z);
			Local tY# = 1.0 / (Self\Y\X*Self\Y\X+Self\Y\Y*Self\Y\Y+Self\Y\Z*Self\Y\Z);
			Local tZ# = 1.0 / (Self\Z\X*Self\Z\X+Self\Z\Y*Self\Z\Y+Self\Z\Z*Self\Z\Z);
			Local mxx#=Self\X\X, mxy#=Self\X\Y, mxz#=Self\X\Z
			Local myx#=Self\Y\X, myy#=Self\Y\Y, myz#=Self\Y\Z
			Local mzx#=Self\Z\X, mzy#=Self\Z\Y, mzz#=Self\Z\Z
			Local mpx#=Self\P\X, mpy#=Self\P\Y, mpz#=Self\P\Z
			Self\X\X = mxx*tX: Self\X\Y = myx*tY: Self\X\Z = mzx*tZ: Self\X\W = 0.0;
			Self\Y\X = mxy*tX: Self\Y\Y = myy*tY: Self\Y\Z = mzy*tZ: Self\Y\W = 0.0;
			Self\Z\X = mxz*tX: Self\Z\Y = myz*tY: Self\Z\Z = mzz*tZ: Self\Z\W = 0.0;
			Self\P\X = -tX*(mpx*mxx+mpy*mxy+mpz*mxz);
			Self\P\Y = -tY*(mpx*myx+mpy*myy+mpz*myz);
			Self\P\Z = -tZ*(mpx*mzx+mpy*mzy+mpz*mzz);
			Self\P\W = 1.0;
			Return Self;
		End Function
		Function Mat4Transpose.Matrix4(Self.Matrix4)
			Local m.Matrix4 = New Matrix4;
			m\X = VecSet(New Vector, Self\X\X, Self\Y\X, Self\Z\X) : m\X\W = Self\P\X;
			m\Y = VecSet(New Vector, Self\X\Y, Self\Y\Y, Self\Z\Y) : m\Y\W = Self\P\Y;
			m\Z = VecSet(New Vector, Self\X\Z, Self\Y\Z, Self\Z\Z) : m\Z\W = Self\P\Z;
			m\P = NewVector(Self\X\W, Self\Y\W, Self\Z\W) : m\P\W = Self\P\W;
			Return m;
		End Function
		Function Mat4SelfTranspose.Matrix4(Self.Matrix4)
			Local t#;
			t = Self\X\Y: Self\X\Y = Self\Y\X: Self\Y\X = t;
			t = Self\X\Z: Self\X\Z = Self\Z\X: Self\Z\X = t;
			t = Self\Y\Z: Self\Y\Z = Self\Z\Y: Self\Z\Y = t;
			t = Self\P\X: Self\P\X = Self\X\W: Self\X\W = t;
			t = Self\P\Y: Self\P\Y = Self\Y\W: Self\Y\W = t;
			t = Self\P\Z: Self\P\Z = Self\Z\W: Self\Z\W = t;
			Return Self;
		End Function
		Function Mat4Determinant#(Self.Matrix4)
			Return Self\X\X*(Self\Y\Y*Self\Z\Z-Self\Y\Z*Self\Z\Y) - Self\X\Y*(Self\Y\X*Self\Z\Z-Self\Y\Z*Self\Z\X) + Self\X\Z*(Self\Y\X*Self\Z\Y-Self\Y\Y*Self\Z\X);
		End Function
		Function Mat4ToMat3.Matrix3(Self.Matrix4)
			Local m.Matrix3 = New Matrix3;
			m\X = VecSet(New Vector, Self\X\X, Self\X\Y, Self\X\Z);
			m\Y = VecSet(New Vector, Self\Y\X, Self\Y\Y, Self\Y\Z);
			m\Z = VecSet(New Vector, Self\Z\X, Self\Z\Y, Self\Z\Z);
			Return m;
		End Function
		Function Mat4Mul.Matrix4(Self.Matrix4,m.Matrix4)
			Local o.Matrix4 = New Matrix4;
			o\X = New Vector:o\Y = New Vector:o\Z = New Vector:o\P = New Vector;
			o\X\X = Self\X\X*m\X\X + Self\Y\X*m\X\Y + Self\Z\X*m\X\Z + Self\P\X*m\X\W;
			o\X\Y = Self\X\Y*m\X\X + Self\Y\Y*m\X\Y + Self\Z\Y*m\X\Z + Self\P\Y*m\X\W;
			o\X\Z = Self\X\Z*m\X\X + Self\Y\Z*m\X\Y + Self\Z\Z*m\X\Z + Self\P\Z*m\X\W;
			o\X\W = Self\X\W*m\X\X + Self\Y\W*m\X\Y + Self\Z\W*m\X\Z + Self\P\W*m\X\W;
			o\Y\X = Self\X\X*m\Y\X + Self\Y\X*m\Y\Y + Self\Z\X*m\Y\Z + Self\P\X*m\Y\W;
			o\Y\Y = Self\X\Y*m\Y\X + Self\Y\Y*m\Y\Y + Self\Z\Y*m\Y\Z + Self\P\Y*m\Y\W;
			o\Y\Z = Self\X\Z*m\Y\X + Self\Y\Z*m\Y\Y + Self\Z\Z*m\Y\Z + Self\P\Z*m\Y\W;
			o\Y\W = Self\X\W*m\Y\X + Self\Y\W*m\Y\Y + Self\Z\W*m\Y\Z + Self\P\W*m\Y\W;
			o\Z\X = Self\X\X*m\Z\X + Self\Y\X*m\Z\Y + Self\Z\X*m\Z\Z + Self\P\X*m\Z\W;
			o\Z\Y = Self\X\Y*m\Z\X + Self\Y\Y*m\Z\Y + Self\Z\Y*m\Z\Z + Self\P\Y*m\Z\W;
			o\Z\Z = Self\X\Z*m\Z\X + Self\Y\Z*m\Z\Y + Self\Z\Z*m\Z\Z + Self\P\Z*m\Z\W;
			o\Z\W = Self\X\W*m\Z\X + Self\Y\W*m\Z\Y + Self\Z\W*m\Z\Z + Self\P\W*m\Z\W;
			o\P\X = Self\X\X*m\P\X + Self\Y\X*m\P\Y + Self\Z\X*m\P\Z + Self\P\X*m\P\W;
			o\P\Y = Self\X\Y*m\P\X + Self\Y\Y*m\P\Y + Self\Z\Y*m\P\Z + Self\P\Y*m\P\W;
			o\P\Z = Self\X\Z*m\P\X + Self\Y\Z*m\P\Y + Self\Z\Z*m\P\Z + Self\P\Z*m\P\W;
			o\P\W = Self\X\W*m\P\X + Self\Y\W*m\P\Y + Self\Z\W*m\P\Z + Self\P\W*m\P\W;
			Return o;
		End Function
		Function Mat4SelfMul.Matrix4(Self.Matrix4,m.Matrix4)
			Local mxx#=Self\X\X, mxy#=Self\X\Y, mxz#=Self\X\Z, mxw#=Self\X\W;
			Local myx#=Self\Y\X, myy#=Self\Y\Y, myz#=Self\Y\Z, myw#=Self\Y\W;
			Local mzx#=Self\Z\X, mzy#=Self\Z\Y, mzz#=Self\Z\Z, mzw#=Self\Z\W;
			Local mpx#=Self\P\X, mpy#=Self\P\Y, mpz#=Self\P\Z, mww#=Self\P\W;
			Self\X\X = mxx*m\X\X + myx*m\X\Y + mzx*m\X\Z + mpx*m\X\W;
			Self\X\Y = mxy*m\X\X + myy*m\X\Y + mzy*m\X\Z + mpy*m\X\W;
			Self\X\Z = mxz*m\X\X + myz*m\X\Y + mzz*m\X\Z + mpz*m\X\W;
			Self\X\W = mxw*m\X\X + myw*m\X\Y + mzw*m\X\Z + mww*m\X\W;
			Self\Y\X = mxx*m\Y\X + myx*m\Y\Y + mzx*m\Y\Z + mpx*m\Y\W;
			Self\Y\Y = mxy*m\Y\X + myy*m\Y\Y + mzy*m\Y\Z + mpy*m\Y\W;
			Self\Y\Z = mxz*m\Y\X + myz*m\Y\Y + mzz*m\Y\Z + mpz*m\Y\W;
			Self\Y\W = mxw*m\Y\X + myw*m\Y\Y + mzw*m\Y\Z + mww*m\Y\W;
			Self\Z\X = mxx*m\Z\X + myx*m\Z\Y + mzx*m\Z\Z + mpx*m\Z\W;
			Self\Z\Y = mxy*m\Z\X + myy*m\Z\Y + mzy*m\Z\Z + mpy*m\Z\W;
			Self\Z\Z = mxz*m\Z\X + myz*m\Z\Y + mzz*m\Z\Z + mpz*m\Z\W;
			Self\Z\W = mxw*m\Z\X + myw*m\Z\Y + mzw*m\Z\Z + mww*m\Z\W;
			Self\P\X = mxx*m\P\X + myx*m\P\Y + mzx*m\P\Z + mpx*m\P\W;
			Self\P\Y = mxy*m\P\X + myy*m\P\Y + mzy*m\P\Z + mpy*m\P\W;
			Self\P\Z = mxz*m\P\X + myz*m\P\Y + mzz*m\P\Z + mpz*m\P\W;
			Self\P\W = mxw*m\P\X + myw*m\P\Y + mzw*m\P\Z + mww*m\P\W;
			Return Self;
		End Function
		Function Mat4Ortho.Matrix4( Self.Matrix4,pLeft#, pRight#, pBottom#, pTop#, pNear#, pFar#)
			If (pLeft = pRight) Then RuntimeError ("left == right");
			If (pBottom = pTop) Then RuntimeError ("bottom == top");
			If (pNear = pFar) Then RuntimeError ("near == far");
			Local r_width	# = 1.0 / (pRight - pLeft);
			Local r_height	# = 1.0 / (pTop - pBottom);
	        Local r_depth	# = 1.0 / (pFar - pNear);
			Local m.Matrix4 = New Matrix4;
			m\X = NewVector(2.0 * (r_width), 0, 0)  : m\X\W = 0;
			m\Y = NewVector(0, 2.0 * (r_height), 0) : m\Y\W = 0;
			m\Z = NewVector(0, 0, -2.0 * (r_depth)) : m\Z\W = 0;
	        m\P = NewVector( -(pRight + pLeft) * r_width, -(pTop + pBottom) * r_height, -(pFar + pNear) * r_depth ) : m\P\W = 1;
	        Return m;
	    End Function
		Function Mat4SetOrtho.Matrix4( Self.Matrix4, pLeft#, pRight#, pBottom#, pTop#, pNear#, pFar#)
			If (pLeft = pRight) Then RuntimeError ("left == right");
			If (pBottom = pTop) Then RuntimeError ("bottom == top");
			If (pNear = pFar) Then RuntimeError ("near == far");
			Local r_width	# = 1.0 / (pRight - pLeft);
			Local r_height	# = 1.0 / (pTop - pBottom);
	        Local r_depth	# = 1.0 / (pFar - pNear);
	        VecSet(Self\X, 2.0 * (r_width),0,0) : Self\X\W = 0;
			VecSet(Self\Y, 0,2.0 * (r_height),0): Self\Y\W = 0;
			VecSet(Self\Z, 0,0,-2.0 * (r_depth)): Self\Z\W = 0;
	        VecSet(Self\P, -(pRight + pLeft) * r_width, -(pTop + pBottom) * r_height, -(pFar + pNear) * r_depth): Self\Z\W = 1;
	        Return Self;
	    End Function
		Function Mat4Frustum.Matrix4( Self.Matrix4, pLeft#, pRight#, pBottom#, pTop#, pNear#, pFar# )
			If (pLeft = pRight) Then RuntimeError ("left == right");
			If (ptop = pbottom) Then RuntimeError ("top == bottom");
			If (pnear = pfar) Then RuntimeError ("near == far");
			If (pnear &lt;= 0.0) Then RuntimeError ("near &lt;= 0.0f");
			If (pfar &lt;= 0.0) Then RuntimeError ("far &lt;= 0.0f");
			Local r_width	#	=	1.0 / (pRight - pLeft);
			Local r_height	#	=	1.0 / (ptop - pbottom);
			Local r_depth	#	=	1.0 / (pnear - pfar);
			Local m.Matrix4 = New Matrix4;
			m\X = NewVector(2.0 * (pnear * r_width), 0, 0)  : m\X\W = 0;
			m\Y = NewVector(0, 2.0 * (pnear * r_height), 0)  : m\Y\W = 0;
			m\Z = NewVector(2.0 * ((pRight + pLeft) * r_width), (ptop + pbottom) * r_height, (pfar + pnear) * r_depth)  : m\Z\W = -1;
			m\P = NewVector(0, 0, 2.0 * (pfar * pnear * r_depth))  : m\P\W = 0;
	        Return m;
		End Function
		Function Mat4SetFrustum.Matrix4( Self.Matrix4, pLeft#, pRight#, pBottom#, pTop#, pNear#, pFar# )
			If (pLeft = pRight) Then RuntimeError ("left == right");
			If (ptop = pbottom) Then RuntimeError ("top == bottom");
			If (pnear = pfar) Then RuntimeError ("near == far");
			If (pnear &lt;= 0.0) Then RuntimeError ("near &lt;= 0.0f");
			If (pfar &lt;= 0.0) Then RuntimeError ("far &lt;= 0.0f");
			Local r_width	#	=	1.0 / (pRight - pLeft);
			Local r_height	#	=	1.0 / (ptop - pbottom);
			Local r_depth	#	=	1.0 / (pnear - pfar);
			VecSet(Self\X, 2.0 * (pnear * r_width), 0, 0)  : Self\X\W = 0;
			VecSet(Self\Y, 0, 2.0 * (pnear * r_height), 0) : Self\Y\W = 0;
			VecSet(Self\Z, 2.0 * ((pRight + pLeft) * r_width), (ptop + pbottom) * r_height, (pfar + pnear) * r_depth)  : Self\Z\W = -1;
			VecSet(Self\P, 0, 0, 2.0 * (pfar * pnear * r_depth))  : Self\P\W = 0;
	        Return Self;
		End Function
		Function Mat4Perspective.Matrix4( Self.Matrix4, fovy#, aspect#, zNear#, zFar#)
			Local f# = 1.0 / Tan(fovy * 0.5);
			Local rangeReciprocal# = 1.0 / (zNear - zFar);
			Local m.Matrix4 = New Matrix4;
			m\X = NewVector(f / aspect,0,0) : m\X\W = 0;
			m\Y = NewVector(0, f, 0) : m\Y\W = 0;
			m\Z = NewVector(0, 0,(zFar + zNear) * rangeReciprocal): m\Z\W = -1;
			m\P = NewVector(0, 0, 2.0 * zFar * zNear * rangeReciprocal): m\P\W = 0;
	        Return m;
		End Function
		Function Mat4SetPerspective.Matrix4( Self.Matrix4, fovy#, aspect#, zNear#, zFar#)
			Local f# = 1.0 / Tan(fovy * 0.5);
			Local rangeReciprocal# = 1.0 / (zNear - zFar);
			VecSet(Self\X, f / aspect,0,0) : Self\X\W = 0;
			VecSet(Self\Y, 0, f, 0) : Self\Y\W = 0;
			VecSet(Self\Z, 0, 0,(zFar + zNear) * rangeReciprocal): Self\Z\W = -1;
			VecSet(Self\P, 0, 0, 2.0 * zFar * zNear * rangeReciprocal): Self\P\W = 0;
	        Return Self;
		End Function
		Function Mat4MulV.Vector(Self.Matrix4, v.Vector)
			Local o.Vector = New Vector;
			o\X = v\X*Self\X\X + v\Y*Self\Y\X + v\Z*Self\Z\X + Self\P\X;
			o\Y = v\X*Self\X\Y + v\Y*Self\Y\Y + v\Z*Self\Z\Y + Self\P\Y;
			o\Z = v\X*Self\X\Z + v\Y*Self\Y\Z + v\Z*Self\Z\Z + Self\P\Z;
			Return o;
		End Function
		Function Mat4MulV2.Vector(Self.Matrix4, v.Vector,out.Vector)
			out\X = v\X*Self\X\X + v\Y*Self\Y\X + v\Z*Self\Z\X + Self\P\X;
			out\Y = v\X*Self\X\Y + v\Y*Self\Y\Y + v\Z*Self\Z\Y + Self\P\Y;
			out\Z = v\X*Self\X\Z + v\Y*Self\Y\Z + v\Z*Self\Z\Z + Self\P\Z;
			Return out;
		End Function
		Function Mat4SelfMulV.Vector(Self.Matrix4, v.Vector)
			Local lx#=v\X, ly#=v\Y, lz#=v\Z;
			v\X = lx*Self\X\X + ly*Self\Y\X + lz*Self\Z\X + Self\P\X;
			v\Y = lx*Self\X\Y + ly*Self\Y\Y + lz*Self\Z\Y + Self\P\Y;
			v\Z = lx*Self\X\Z + ly*Self\Y\Z + lz*Self\Z\Z + Self\P\Z;
			Return v;
		End Function
		Function Mat4Transform.Vector(Self.Matrix4, v.Vector)
			Return VecTransformM4(v,Self);
		End Function
		Function Mat4InvertTransform.Vector(Self.Matrix4, v.Vector)
			Local m.Matrix4 = Mat4Invert(Self);
			v = VecTransformM4(v,m);
			FreeMatrix4(m);
			Return v;
		End Function
		Function Mat4ToQuaternion.Quaternion(Self.Matrix4)
			Return QuatFromMat4(Self);
		End Function
		Function Mat4Row.Vector(Self.Matrix4, pCol%)
			If (pCol = 3) Then Return Vec4Copy(Self\P);
			If (pCol = 2) Then Return Vec4Copy(Self\Z);
			If (pCol = 1) Then Return Vec4Copy(Self\Y);
			Return Vec4Copy(Self\X);
		End Function
		Function Mat4Cell#(Self.Matrix4, j%,i%)
			If (j = 3)
				If i=3 Then Return Self\P\W;
				If i=2 Then Return Self\P\Z;
				If i=1 Then Return Self\P\Y;
				Return Self\P\X;
			ElseIf (j = 2)
				If i=3 Then Return Self\Z\W;
				If i=2 Then Return Self\Z\Z;
				If i=1 Then Return Self\Z\Y;
				Return Self\Z\X;
			ElseIf (j = 1)
				If i=3 Then Return Self\Y\W;
				If i=2 Then Return Self\Y\Z;
				If i=1 Then Return Self\Y\Y;
				Return Self\Y\X;
			EndIf
			If i=3 Then Return Self\X\W;
			If i=2 Then Return Self\X\Z;
			If i=1 Then Return Self\X\Y;
			Return Self\X\X;
		End Function
		Function Mat4X#(Self.Matrix4)
			Return Self\P\X;
		End Function
		Function Mat4Y#(Self.Matrix4)
			Return Self\P\Y;
		End Function
		Function Mat4Z#(Self.Matrix4)
			Return Self\P\Z;
		End Function
		Function Mat4I.Vector(Self.Matrix4):Return VecCopy(Self\X):End Function
		Function Mat4J.Vector(Self.Matrix4):Return VecCopy(Self\Y):End Function
		Function Mat4K.Vector(Self.Matrix4):Return VecCopy(Self\Z):End Function
		Function Mat4Left.Vector(Self.Matrix4):Return VecNegate(Self\X):End Function
		Function Mat4Right.Vector(Self.Matrix4):Return VecCopy(Self\X):End Function
		Function Mat4Down.Vector(Self.Matrix4):Return VecNegate(Self\Y):End Function
		Function Mat4Up.Vector(Self.Matrix4):Return VecCopy(Self\Y):End Function
		Function Mat4Back.Vector(Self.Matrix4):Return VecNegate(Self\Z):End Function
		Function Mat4Front.Vector(Self.Matrix4):Return VecCopy(Self\Z):End Function
		Function Mat4Position.Vector(Self.Matrix4):Return VecCopy(Self\P):End Function
		Function Mat4Normalize.Matrix4(Self.Matrix4)
			Local m.Matrix4 = New Matrix4;
			m\X = VecNormalize(Self\X): m\X\W = 0;
			m\Y = VecNormalize(Self\Y): m\Y\W = 0;
			m\Z = VecNormalize(Self\Z): m\Z\W = 0;
			m\P = VecCopy(Self\P): m\P\W = 1
			Return m;
		End Function
		Function Mat4SelfNormalize.Matrix4(Self.Matrix4)
			VecSelfNormalize(Self\X): Self\X\W = 0;
			VecSelfNormalize(Self\Y): Self\Y\W = 0;
			VecSelfNormalize(Self\Z): Self\Z\W = 0;
			Return Self;
		End Function
		Function Mat4FPtr.Matrix4(Self.Matrix4,f#[15])
			f[0]=Self\X\X:f[1]=Self\X\Y:f[2]=Self\X\Z:f[3]=Self\X\W;
			f[4]=Self\Y\X:f[5]=Self\Y\Y:f[6]=Self\Y\Z:f[7]=Self\Y\W;
			f[8]=Self\Z\X:f[9]=Self\Z\Y:f[10]=Self\Z\Z:f[11]=Self\Z\W;
			f[12]=Self\P\X:f[13]=Self\P\Y:f[14]=Self\P\Z:f[15]=Self\P\W;
			Return Self;
		End Function
		Function Mat4Array.Matrix4(Self.Matrix4,f#[15])
			f[0]=Self\X\X:f[1]=Self\X\Y:f[2]=Self\X\Z:f[3]=Self\X\W;
			f[4]=Self\Y\X:f[5]=Self\Y\Y:f[6]=Self\Y\Z:f[7]=Self\Y\W;
			f[8]=Self\Z\X:f[9]=Self\Z\Y:f[10]=Self\Z\Z:f[11]=Self\Z\W;
			f[12]=Self\P\X:f[13]=Self\P\Y:f[14]=Self\P\Z:f[15]=Self\P\W;
			Return Self;
		End Function
		Function Mat4ToString$(Self.Matrix4)
			Return	Vec4ToString(Self\X)+Chr(13)+Vec4ToString(Self\Y)+Chr(13)+Vec4ToString(Self\Z)+Chr(13)+Vec4ToString(Self\P);
		End Function
		Function Mat4SetPosition.Matrix4(Self.Matrix4,p.Vector)
			Self\P\X = p\X;
			Self\P\Y = p\Y;
			Self\P\Z = p\Z;
			Return Self;
		End Function
		Function Mat4SetRotation.Matrix4(Self.Matrix4,q.Quaternion)
			Local sx# = Sqr(Self\X\X*Self\X\X+Self\X\Y*Self\X\Y+Self\X\Z*Self\X\Z);
			Local sy# = Sqr(Self\Y\X*Self\Y\X+Self\Y\Y*Self\Y\Y+Self\Y\Z*Self\Y\Z);
			Local sz# = Sqr(Self\Z\X*Self\Z\X+Self\Z\Y*Self\Z\Y+Self\Z\Z*Self\Z\Z);
			Self\X\X = sx*(1.0-2.0*(q\Y*q\Y+q\Z*q\Z));
			Self\X\Y = sx*(2.0*(q\X*q\Y-q\W*q\Z));
			Self\X\Z = sx*(2.0*(q\X*q\Z+q\W*q\Y));
			Self\Y\X = sy*(2.0*(q\X*q\Y+q\W*q\Z));
			Self\Y\Y = sy*(1.0-2.0*(q\X*q\X+q\Z*q\Z));
			Self\Y\Z = sy*(2.0*(q\Y*q\Z-q\W*q\X));
			Self\Z\X = sz*(2.0*(q\X*q\Z-q\W*q\Y));
			Self\Z\Y = sz*(2.0*(q\Y*q\Z+q\W*q\X));
			Self\Z\Z = sz*(1.0-2.0*(q\X*q\X+q\Y*q\Y));
			Return Self;
		End Function
		Function Mat4SetScale.Matrix4(Self.Matrix4,s.Vector)
			VecSelfScale(Self\X, s\X/VecLength(Self\X));
			VecSelfScale(Self\Y, s\Y/VecLength(Self\Y));
			VecSelfScale(Self\Z, s\Z/VecLength(Self\Z));
			Return Self;
		End Function
		Function Mat4Scale.Matrix4(Self.Matrix4,s.Vector)
			Local m.Matrix4 = New Matrix4;
			m\X = VecScale(Self\X,s\X) : m\X\W=Self\X\W;
			m\Y = VecScale(Self\Y,s\Y) : m\Y\W=Self\Y\W;
			m\Z = VecScale(Self\Z,s\Z) : m\Z\W=Self\Z\W;
			m\P = VecCopy(Self\P) : m\P\W=Self\P\W;
			Return m;
		End Function
		Function Mat4SelfScale.Matrix4(Self.Matrix4, s.Vector)
			VecSelfScale(Self\X, s\X);
			VecSelfScale(Self\Y, s\Y);
			VecSelfScale(Self\Z, s\Z);
			Return Self;
		End Function
		Function Mat4SetPSR.Matrix4(Self.Matrix4, p.Vector, s.Vector, q.Quaternion)
			Self\X\X = s\X*(1.0-2.0*(q\Y*q\Y+q\Z*q\Z));
			Self\X\Y = s\X*(2.0*(q\X*q\Y-q\W*q\Z));
			Self\X\Z = s\X*(2.0*(q\X*q\Z+q\W*q\Y));
			Self\X\W = 0.0;
			Self\Y\X = s\Y*(2.0*(q\X*q\Y+q\W*q\Z));
			Self\Y\Y = s\Y*(1.0-2.0*(q\X*q\X+q\Z*q\Z));
			Self\Y\Z = s\Y*(2.0*(q\Y*q\Z-q\W*q\X));
			Self\Y\W = 0.0;
			Self\Z\X = s\Z*(2.0*(q\X*q\Z-q\W*q\Y));
			Self\Z\Y = s\Z*(2.0*(q\Y*q\Z+q\W*q\X));
			Self\Z\Z = s\Z*(1.0-2.0*(q\X*q\X+q\Y*q\Y));
			Self\Z\W = 0.0;
			Self\P\X = p\X;
			Self\P\Y = p\Y;
			Self\P\Z = p\Z;
			Self\P\W = 1.0;
			Return Self;
		End Function
		

</textarea> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> nice work Bobysait! perhaps some sample demos to compare with b3d builtin equivalent? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> I'll see if I can make this tomorrow, it's 0h47 here, I'm going to sleep ;)<br><br><br>ps : I didn't mention it, but the vector part also contains some kind of GLSL portability with conversion<br>-&gt; v.xy() v.zx() etc ...<br>There is no documention, but it's a maths library, everything is self-explained <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> I might actually have a use for some of this in my ongoing Newton/OpenB3D fumbling, thanks for posting it! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>2016</font></td></tr></table></td></tr><tr ><td class="posttext"> So, here is a small demo of transformation<br>it shows how to reproduice the blitz-entities transformations using this maths library.<br><br>Also a bench test in the end for creating 10000 pivots and rotate them compared to creating 10000 transforms and rotate them<br><br>/!\ just one note, math stuff in blitz code is slower than anything writen in c/c++ as the internal blitz maths are, so keep in mind a pivot rotation, for example, will still be faster than a rotation of a transform like I did, but, the creation time is a lot faster, so what we loose somewhere is gained somewhere else.<br>Then, this stuff is just for purpose, maths transformation does not require a full "transform" object, most of the time, we just need a vector or a rotation, not a full stuff to rebuild a 4*4 matrix.<br><br>ps : (a ps before the code ... whatever)<br>the sample below also provides working PointEntity and AlignToVector replicants.<br>Hope it helps.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Type Transform
	Field P.Vector;
	Field S.Vector;
	Field R.Quaternion;
End Type
Function NewTransform.Transform()
	Local t.Transform = New Transform;
	t\P = NewVector();
	t\S = NewVector(1,1,1);
	t\R = NewQuaternion(1,0,0,0);
	Return t;
End Function

Function FreeTransform.Transform(t.Transform)
	Delete t\P;
	Delete t\S;
	Delete t\R;
	Return Null;
End Function

;#region Getters
	Function TransformMatrix.Matrix4(t.Transform)
		Return Mat4SetPSR(NewMatrix4(), t\P,t\S,t\R);
	End Function
	Function TransformMatrix3.Matrix3(t.Transform)
		Return Mat3SetScale(QuatToMat3(t\R), t\S)
	End Function
	
	Function TransformX#(t.Transform)
		Return t\P\X;
	End Function
	Function TransformY#(t.Transform)
		Return t\P\Y;
	End Function
	Function TransformZ#(t.Transform)
		Return t\P\Z;
	End Function

	Function TransformPitch#(t.Transform)
		Return QuatPitch(t\R);
	End Function

	Function TransformYaw#(t.Transform)
		Return QuatYaw(t\R);
	End Function

	Function TransformRoll#(t.Transform)
		Return QuatRoll(t\R);
	End Function

	Function TransformScaleX#(t.Transform)
		Return t\S\X
	End Function
	Function TransformScaleY#(t.Transform)
		Return t\S\Y
	End Function
	Function TransformScaleZ#(t.Transform)
		Return t\S\Z
	End Function
;#end region

;#region Transforms
	Function PositionTransform.Transform(t.Transform, x#,y#,z#)
		VecSet(t\P, x,y,z);
		Return t;
	End Function

	Function TranslateTransform.Transform(t.Transform, x#,y#,z#)
		Local v.Vector = NewVector(x,y,z)
		; translate the position
		VecSelfAdd(t\P, v);
		Delete v;
		Return t;
	End Function

	Function MoveTransform.Transform(t.Transform, x#,y#,z#, pLocalScale%=False)
		Local v.Vector = NewVector(x,y,z)
		If (pLocalScale)
			VecSelfAdd ( t\P, VecSelfMul( VecSelfMulQ (v,t\R), t\S) );
		Else
			VecSelfAdd ( t\P, VecSelfMulQ (v,t\R) );
		EndIf
		Delete v;
		Return t;
	End Function

	Function TurnTransform.Transform(t.Transform, x#,y#,z#)
		Local q.Quaternion = QuatFromEulerXYZ(x,y,z);
		QuatSelfMul (t\R, q);
		Delete q;
		Return t;
	End Function

	Function RotateTransform.Transform(t.Transform, x#,y#,z#)
		QuatSetEulerXYZ (t\R, x,y,z);
		Return t;
	End Function
	
	Function PointTransform.Transform(t.Transform, pos.Vector, pRoll#=0.0)
		Local lDir.Vector = VecSelfNormalize(VecSub(pos, t\P));
		RotateTransform ( t, VecPitch (lDir), VecYaw(lDir), pRoll );
		Delete lDir;
		Return t;
	End Function
	
	Function AlignTransform.Transform(t.Transform, pX#,pY#,pZ#, pAxis%, pRate#=1.0)
		Local lDirL# = pX*pX+pY*pY+pZ*pZ : If (lDirL&lt;0.000001) Then Return t;
		lDirL = 1.0/Sqr(lDirL);
		
		Local tvx#, tvy#, tvz#;
		Local cpx#, cpy#, cpz#;
		Local lDx# = pX*lDirL, lDy# = pY*lDirL, lDz# = pZ*lDirL;
		Local an#, dp#, sa#;
		Local q_.Quaternion;
		
		Local qr.Quaternion = t\R;
		Select (pAxis)
			Case 1
				tvx = 1.0-2.0*(qr\Y*qr\Y+qr\Z*qr\Z);
				tvy =     2.0*(qr\X*qr\Y-qr\W*qr\Z);
				tvz =     2.0*(qr\X*qr\Z+qr\W*qr\Y);
			Case 2
				tvx =     2.0*(qr\X*qr\Y+qr\W*qr\Z);
				tvy = 1.0-2.0*(qr\X*qr\X+qr\Z*qr\Z);
				tvz =     2.0*(qr\Y*qr\Z-qr\W*qr\X);
			Default
				tvx =     2.0*(qr\X*qr\Z-qr\W*qr\Y);
				tvy =     2.0*(qr\Y*qr\Z+qr\W*qr\X);
				tvz = 1.0-2.0*(qr\X*qr\X+qr\Y*qr\Y);
		End Select
		
		dp = lDx*tvx+lDy*tvy+lDz*tvz;
		If (dp&gt;=1-0.000001) Then Return t;
		
		If (dp&lt;=-1+.0000001)
			an = pRate * 90.0;
			sa = Sin(an);
			Select (pAxis)
				Case 1
					cpx =     2.0*(qr\X*qr\Y+qr\W*qr\Z);
					cpy = 1.0-2.0*(qr\X*qr\X+qr\Z*qr\Z);
					cpz =     2.0*(qr\Y*qr\Z-qr\W*qr\X);
				Case 2
					cpx =     2.0*(qr\X*qr\Z-qr\W*qr\Y);
					cpy =     2.0*(qr\Y*qr\Z+qr\W*qr\X);
					cpz = 1.0-2.0*(qr\X*qr\X+qr\Y*qr\Y);
				Default
					cpx = 1.0-2.0*(qr\Y*qr\Y+qr\Z*qr\Z);
					cpy =     2.0*(qr\X*qr\Y-qr\W*qr\Z);
					cpz =     2.0*(qr\X*qr\Z+qr\W*qr\Y);
			End Select
			q_ = NewQuaternion ( Cos(an), cpx*sa,cpy*sa,cpz*sa );
			t\R = QuatSelfMul(q_, qr);
			Delete qr;
			Return t;
		EndIf;
		
		an = ACos(dp)*pRate*0.5;
		cpx = lDy*tvz-lDz*tvy;
		cpy = lDz*tvx-lDx*tvz;
		cpz = lDx*tvy-lDy*tvx;
		Local cpL# = Sin(an) / Sqr(cpx*cpx+cpy*cpy+cpz*cpz);
		cpx = cpx * cpL;
		cpy = cpy * cpL;
		cpz = cpz * cpL;
		
		q_ = NewQuaternion ( Cos(an), cpx,cpy,cpz);
		t\R = QuatSelfMul(q_, qr);
		Delete qr;
		Return t;
	End Function
	
	Global TFORMED.Vector = NewVector();
	Function TFormTPoint.Vector(x#,y#,z#, src.Transform, dest.Transform)
		VecSet(TFORMED, x,y,z);
		Local m.Matrix4
		If (src&lt;&gt;Null)
			m = TransformMatrix(src);
			VecSelfMulM4 (TFORMED, m);
			FreeMatrix4(m);
		EndIf
		If (dest&lt;&gt;Null)
			m = Mat4SelfInvert(TransformMatrix(dest));
			VecSelfMulM4 (TFORMED, m);
			FreeMatrix4(m);
		EndIf
		Return TFORMED;
	End Function
	Function TFormTVector.Vector(x#,y#,z#, src.Transform, dest.Transform)
		VecSet(TFORMED, x,y,z);
		Local m.Matrix3
		If (src&lt;&gt;Null)
			m = TransformMatrix3(src);
			VecSelfMulM3 (TFORMED, m);
			FreeMatrix3(m);
		EndIf
		If (dest&lt;&gt;Null)
			m = Mat3SelfInvert(TransformMatrix3(dest));
			VecSelfMulM3 (TFORMED, m);
			FreeMatrix3(m);
		EndIf
		Return TFORMED;
	End Function
	Function TFormTNormal.Vector(x#,y#,z#, src.Transform, dest.Transform)
		VecSet(TFORMED, x,y,z);
		Local m.Matrix3
		If (src&lt;&gt;Null)
			m = TransformMatrix3(src);
			VecSelfMulM3 (TFORMED, m);
			FreeMatrix3(m);
		EndIf
		If (dest&lt;&gt;Null)
			m = Mat3SelfInvert(TransformMatrix3(dest));
			VecSelfMulM3 (TFORMED, m);
			FreeMatrix3(m);
		EndIf
		Return VecSelfNormalize(TFORMED);
	End Function
;#end region



Graphics3d 800,600,0,2
SetBuffer BackBuffer()

Local p0 = CreatePivot()
Local p1 = CreatePivot()
Local t0.Transform = NewTransform()
Local t1.Transform = NewTransform()

PositionEntity (p0, 10,20,30)
PositionTransform (t0, 10,20,30)
PositionEntity (p1, 512,-47,-345.5)
PositionTransform (t1, 512,-47,-345.5)
TurnEntity p1,50,-20,75
TurnTransform t1,50,-20,75

Print " - Position 0 -"
PrintEP(p0)
PrintTP(t0)
Print " - Position 1 -"
PrintEP(p1)
PrintTP(t1)
Print ""

Print " - Rotation 0 -"
PrintER(p0)
PrintTR(t0)
Print " - Rotation 1 -"
PrintER(p1)
PrintTR(t1)
Print ""

PointEntity p1,p0
PointTransform t1,t0\P
Print " - After Point At -"
Print "Position :"
PrintEP(p1)
PrintTP(t1)
Print "Rotation :"
PrintER(p1)
PrintTR(t1)

Local NTests% = 100000
Local tP0=MilliSecs()
For n = 1 To NTests
	temp_P = CreatePivot()
	RotateEntity temp_P, -1,-2,3
	FreeEntity temp_P
Next
Local tP1=MilliSecs()

Local tT0 = MilliSecs()
For n = 1 To NTests
	temp_T.Transform = NewTransform()
	RotateTransform temp_T, -1,-2,3
	FreeTransform temp_T
Next
Local tT1=MilliSecs()

Print "time for "+NTests+" pivot creations and rotation : "+(tP1-tP0)+" ms"
Print "time for "+NTests+" transform creations and rotation : "+(tT1-tT0)+" ms"

TFormPoint ( 1,2,3, p0, p1) : Print TFormedX()+" "+TFormedY()+" "+TFormedZ()
TFormTPoint ( 1,2,3, t0, t1 ) : Print TFORMED\X+" "+TFORMED\Y+" "+TFORMED\Z
TFormVector ( 47,21,-7, p0, p1) : Print TFormedX()+" "+TFormedY()+" "+TFormedZ()
TFormTVector ( 47,21,-7, t0, t1 ) : Print TFORMED\X+" "+TFORMED\Y+" "+TFORMED\Z
TFormNormal ( -52,.2,28.5, p0, p1) : Print TFormedX()+" "+TFormedY()+" "+TFormedZ()
TFormTNormal ( -52,.2,28.5, t0, t1 ) : Print TFORMED\X+" "+TFORMED\Y+" "+TFORMED\Z

WaitKey()
End


Function PrintEP(e)
	Print EntityX(e,1)+" "+EntityY(e,1)+" "+EntityZ(e,1)
End Function

Function PrintTP(t.Transform)
	Print VecToString(t\P)
End Function

Function PrintER(e)
	Print EntityPitch(e,1)+" "+EntityYaw(e,1)+" "+EntityRoll(e,1)
End Function

Function PrintTR(t.Transform)
	Print TransformPitch(t)+" "+TransformYaw(t)+" "+TransformRoll(t)
End Function
</textarea><br><br><br>[edit]<br>TForm functions added to the sample. <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
