<!DOCTYPE html><html lang="en" ><head ><title >BaH.Crypto</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >BaH.Crypto</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=124" >Brucey's Modules</a>/<a href="#bottom" >BaH.Crypto</a><br><br>
<a name="842159"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, it's been such a long time since I came out with a new module (if you don't count the one from a week or so ago :-p ), that I thought I should just knock together something for the weekend.<br><br>The Crypto module uses <a href="http://www.openssl.org/docs/crypto/crypto.html" target="_blank">OpenSSL</a>'s crypto libs ( "libcrypto" on Linux/Mac and "eay32.dll" on Win32) to do all the hard work of ciphering.<br><br>It currently supports BlowFish, CAST, DES, RC2, RC4 and RC5, in various modes (see <b><a href="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation" target="_blank">HERE</a></b> for a good description of the modes and how they work).<br><br>Currently only tested on OS X, which has OpenSSL installed by default. Linux should be okay too, as most distros package OpenSSL, although you may need to download the Dev package.<br><br>On Win32, you'll need the OpenSSL DLLs. I've shipped the MinGW .a and includes, so it might compile. (Haven't tested this yet.. Later today hopefully - once Eskom turn the power back on - bloody rolling blackouts!)<br><br>Available in SVN only until it's all working fine on all platforms...<br><br><a href="http://code.google.com/p/maxmods/wiki/CryptoModule" target="_blank">http://code.google.com/p/maxmods/wiki/CryptoModule</a><br><br>:o)<br><br><br>Oh, and I hope to be adding Digest support in the not too distant future too. (eg. HMAC, MD2, MD5, MDC2, SHA and RIPEMD-160) <br><br></td></tr></table><br>
<a name="842204"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now working fine on Win32... Yay!<br><br>Seems RC5 isn't compiled into the "usual" libs on Windows, so I've left it out of the module on that platform.<br><br>Downloading and installing "Win32 OpenSSL v0.9.8g Light" from <b><a href="http://www.slproweb.com/products/Win32OpenSSL.html" target="_blank">HERE</a></b> is enough to get the examples running. Note, if you want to distribute the libs with your app, you might want to include the libeay32.dll that gets installed into the system32 folder.<br><br>:o) <br><br></td></tr></table><br>
<a name="842228"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Since everything *appears* to be working as expected so far... the first release is now available from <b><a href="http://code.google.com/p/maxmods/downloads/list" target="_blank">HERE</a></b>. <br><br></td></tr></table><br>
<a name="842402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compiled mod, then installed "Win32 OpenSSL v0.9.8g Light".<br><br>BOTH examples give me this error.<br><pre class=code>The procedure entry point EVP_bf_cfb64 could not be located in the dynamic link library libeay32.dll.</pre><br><br>Did I miss anything? <br><br></td></tr></table><br>
<a name="842408"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Haw...  that's strange.<br><br>Originally tested it on XP, worked okay.<br>Just installed OpenSSL on Win2k and it is also working as expected.<br><br>Are you sure that you are using that latest dll? (perhaps there is another on your PATH that is found first?)<br><br>Try copying it into the app dir and see if that works better?<br>(when I installed v0.9.8g onto the win2k, it did ask if I wanted to overwrite the DLLs in System32 - which I said yes to). <br><br></td></tr></table><br>
<a name="842409"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ahh.. the problem was, I initially installed an older version (didn't look to much at the instructions you gave) of the OpenSSL dll, which I placed in the app and sys32 dir.<br><br>After installing v0.9.8g I didn't replace the one in the app dir with the new dll (which the installer placed in sys32).<br><br>Works now :) <br><br></td></tr></table><br>
<a name="842819"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any idea when IDEA will be supported Brucey?<br><br>Also, which encryption in the mod is the fastest? <br><br></td></tr></table><br>
<a name="842826"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> IDEA seems to excluded from most default builds of OpenSSL because of patent issues with Ascom-Tech AG. It appears you need a license for commercial apps.<br><br>As for the fastest, I haven't given them all a thorough test. You might wish to try the different combinations of the algorithms with the various modes. <br><br></td></tr></table><br>
<a name="843075"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> is this module used to encrypt files? <br><br></td></tr></table><br>
<a name="843078"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you like.<br><br>There's an example which shows how to use a TStream for input/output.<br>In theory you could then also use a RamStream and do stuff in-memory, assuming you setup enough space for it (streaming out of ram shouldn't be a problem).<br><br>The other example shows encryption from/to a String.<br><br>Basically, all you need is some kind of data to feed it. <br><br></td></tr></table><br>
<a name="1093386"></a>

<a name="1093387"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi and thank you very much for this module, it is working great.<br><br>However, I've encountered a bug in v1.02/v1.03 when it comes to encrypting larger (&gt;3000 bytes) of data. Basically what i was trying to do was encrypt all my .bmx files, and encountered a segmentation fault on some of the larger files... When calling encryptupdate and or encryptfinal sometimes dumped alot of crap onscreen and then a segmentation fault, some just threw a segmentation fault, and the rest of the files encrypted ok... I did not use the TStream method, instead i used loadtext and then stringtobytearray before encrypting.<br><br>I also looked over you code, and found no errors whatsoever, it looked perfectly clean, so I tried to build the module against various subversions of libssl 0.9.8 stable without any luck. I also tried to compile the module on different stations (intel/amd), but still no luck.<br><br>I also tried passing 2048 bytes at a time to encryptupdate before doing a encryptfinal, but still segmentation fault.<br><br>Strange this segmentation fault, since it happens only to 5% of the files i tried to encrypt, but it seems it happens to only of the larger files.<br><br>Also i tried different ciphers, aes128cbc, aes256cbc, bf-cbc, etc... Still the same result.<br><br>So i beg you please can we try to figure out this problem.... And ofcourse, I'm running linux.<br><br>You've done alot of wonderful work since the time I suggested you to make the gtkwebmozilla module ;) Good work indeed.<br><br>Kind regards from norway, Sub Zero<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1094574"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> The "crap" is part of the memory dump when linux seg faults.<br><br>I'll write up a little test which can handle large files and see how it performs for me.<br>The encrypt_decrypt example isn't really appropriate because you don't really want to do it in a single hit... <br><br></td></tr></table><br>
<a name="1094641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi again.<br><br>It appears to be a problem with your code. I've just written an example which encrypts (and decrypts) the entire text of war and peace (about 3.3mb) and it does this without crashing. Sure, it did take me a while to work out the best method, but if the code is written correctly, it works as you'd expect. :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Framework BaH.Crypto
Import BRL.StandardIO
Import BRL.textstream


' Bogus key And IV: we'd normally set these from another source.
Local key:Byte[] = IntToByteArray([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
Local iv:Byte[] = IntToByteArray([1,2,3,4,5,6,7,8])
Local intext:String = LoadText("war_and_peace.txt")


Local arr:Byte[] = StringToByteArray(intext)
Local length:Int = arr.length

Local tmplen:Int

Local inbuf:Byte[]

Print "Original       : " + length + " bytes"

' +++++++++++++++++++++++++++++++++++++++
' encrypt
' +++++++++++++++++++++++++++++++++++++++

Local ds:String

Local ctx:EVP_CIPHER_CTX = New EVP_CIPHER_CTX.Create()

ctx.EncryptInit(EVP_CIPHER.bf_cbc(), Null, key, iv)

Local count:Int = 0
Const BUF_SIZE:Int = 2048 ' our block size

' size should be big enough to hold the block plus a bit more
Local outbuf:Byte[BUF_SIZE + ctx.GetBlockSize()]
Local outlen:Int


' loop all the full blocks
For Local i:Int = 0 Until length / BUF_SIZE

	If Not ctx.EncryptUpdate(outbuf, outlen, arr[count..count + BUF_SIZE], BUF_SIZE) Then
		Print "Error..."
		End
	End If

	' update input buffer offset
	count :+ BUF_SIZE
	
	' store encrypted
	inbuf :+ outbuf[0..outlen]
	
Next

' encrypt remaining part block
If length Mod BUF_SIZE Then

	If Not ctx.EncryptUpdate(outbuf, outlen, arr[count..count + length Mod BUF_SIZE], length Mod BUF_SIZE) Then
		Print "Error..."
		End
	End If
	
	' update input buffer offset
	count :+ length Mod BUF_SIZE
	
	' store encrypted
	inbuf :+ outbuf[0..outlen]

End If

' Tidy up
If Not ctx.EncryptFinal(outbuf, outlen) Then
	Print "Error..."
	End
End If

' add any padding
inbuf :+ outbuf[0..outlen]

ctx.Cleanup()


Print "Processed      : " + count
Print "Encrypted data : " + inbuf.length
Print "~n"

Local s:String

' +++++++++++++++++++++++++++++++++++++++
' decrypt
' +++++++++++++++++++++++++++++++++++++++


length = inbuf.length

Print "Input data     : " + length + " bytes"

ctx.DecryptInit(EVP_CIPHER.bf_cbc(), Null, key, iv)

outbuf = New Byte[BUF_SIZE + ctx.GetBlockSize() + 10]

count = 0

For Local i:Int = 0 Until length / BUF_SIZE

	If Not ctx.DecryptUpdate(outbuf, outlen, inbuf[count..count + BUF_SIZE], BUF_SIZE)
		Print "Error..."
		End
	End If

	s :+ String.FromBytes(outbuf, outlen)

	count :+ BUF_SIZE
	
Next

If length Mod BUF_SIZE Then

	If Not ctx.DecryptUpdate(outbuf, outlen, inbuf[count..count + length Mod BUF_SIZE], length Mod BUF_SIZE)
		Print "Error..."
		End
	End If

	s :+ String.FromBytes(outbuf, outlen)

	count :+ length Mod BUF_SIZE
End If


If Not ctx.DecryptFinal(outbuf, outLen) Then
	Print "Error..."
	End
End If

s :+ String.FromBytes(outbuf, outlen)

ctx.Cleanup()

Print "Processed      : " + count
Print "Decrypted      : " + s.length + " bytes"
Print "~n"
</textarea> <br><br></td></tr></table><br>
<a name="1094886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, thanks alot for that.... I forgot to post, I also solved the problem using cipherinit/update/final instead, according to your example...<br><br>But thanks, keep up the good work, you're doing great. <br><br></td></tr></table><br>
<a name="1178310"></a>

<a name="1178320"></a>

<a name="1178321"></a>

<a name="1178326"></a>

<a name="1178329"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking back, it might have been because the keylength was wrong (oops)<br><br>By the way, now when i tried to compile your example, i get an error stating GetBlockSize() not found....<br><br>Would this be the equivalent to EVP_MAX_BLOCK_LENGTH ?<br>EVP_MAX_BLOCK_LENGTH<br><br>Edit: Now I know what's wrong... I've downloaded v1.02 from googlecode.... Why don't you put the v1.03 version in hte download section instead ;) <br><br></td></tr></table><br>
<a name="1178340"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, it's probably a good idea. :-) <br><br></td></tr></table><br>
<a name="1178356"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks alot :) <br><br></td></tr></table><br>
<a name="1178968"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm having some problems again:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Framework BRL.Retro
Import BRL.Filesystem
Import BaH.Crypto
'Import BRL.Random
'Import MaxGui.Drivers
'Import BRL.Eventqueue


Local key:Byte[] = IntToByteArray([50,51,52,53,54,55,56,57,58])
Local iv:Byte[] = IntToByteArray([1,2,3,4,5,6,7,8])

Print encrypt("/root/dl.data", "/root/Desktop/dl2.cry", key, iv)
Print decrypt("/root/Desktop/dl2.cry", "/root/Desktop/dl.txt", key, iv)


Function encrypt:Int(infile:String, outfile:String, key:Byte[], iv:Byte[])
  Local inbuf:Byte[]
  Local arr:Byte[]
  Local ctx:EVP_CIPHER_CTX
  Local cipher_:EVP_CIPHER
  Local cipher:String
  Local count:Int
  Const BUF_SIZE:Int = 2048 ' our block size
  Local outlen:Int
  Local i:Int
  Local file:TStream

  If FileMode(infile) &gt; 0
	arr = LoadByteArray(infile)
  Else
    Return -1
  EndIf

  cipher_ = EVP_CIPHER.rc4()

  ctx = New EVP_CIPHER_CTX.Create()
  ctx.CipherInit(cipher_, Null, Null, Null, True)
  ctx.SetKeyLength(key.length)
  ctx.CipherInit(cipher_, Null, key, iv, True)
  Local outbuf:Byte[BUF_SIZE + ctx.GetBlockSize()]
  Local length:Int = arr.length
  count = 0
  ' loop all the full blocks
  For i = 0 Until length / BUF_SIZE
	If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + BUF_SIZE], BUF_SIZE)
	  Return -2
	End If
	' update input buffer offset
	count :+ BUF_SIZE
	' store encrypted
	inbuf :+ outbuf[0..outlen]	
  Next

' encrypt remaining part block
  If length Mod BUF_SIZE
	If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + length Mod BUF_SIZE], length Mod BUF_SIZE)
	  Return -2
	End If	
	' update input buffer offset
	count :+ length Mod BUF_SIZE
	' store encrypted
	inbuf :+ outbuf[0..outlen]
  End If

  ' Tidy up
  If Not ctx.CipherFinal(outbuf, outlen) Then
	Return -2
  End If

  ' add any padding
  inbuf :+ outbuf[0..outlen]
  ctx.Cleanup()
  SaveByteArray(inbuf, outfile)

  ' Clear memory just in case
  For i = 0 Until inbuf.length
    inbuf[i] = 0
  Next
  For i = 0 Until outbuf.length
    outbuf[i] = 0
  Next
  For i = 0 Until arr.length
    arr[i] = 0
  Next
  For i = 0 Until key.length
    key[i] = 0
  Next
  For i = 0 Until iv.length
    iv[i] = 0
  Next

  Return True
End Function


Function decrypt:Int(infile:String, outfile:String, key:Byte[], iv:Byte[])
  Local inbuf:Byte[]
  Local outbuf:Byte[]
  Local arr:Byte[]
  Local ctx:EVP_CIPHER_CTX
  Local cipher_:EVP_CIPHER
  Local cipher:String
  Local count:Int
  Const BUF_SIZE:Int = 2048 ' our block size
  Local outlen:Int
  Local i:Int
  Local file:TStream
  Local length:Int

  If FileMode(infile) &gt; 0
	arr = LoadByteArray(infile)
  Else
    Return -1
  EndIf

  cipher_ = EVP_CIPHER.rc4()

  length = arr.length
  ctx = New EVP_CIPHER_CTX.Create()
  ctx.CipherInit(cipher_, Null, Null, Null, False)
  ctx.SetKeyLength(key.length)
  ctx.CipherInit(cipher_, Null, key, iv, False)
  outbuf = New Byte[BUF_SIZE + ctx.GetBlockSize() + 10]

  count = 0

  For i = 0 Until length / BUF_SIZE
	If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + BUF_SIZE], BUF_SIZE)
	  Return -2
	End If
    inbuf :+ outbuf[0..outlen]
    count :+ BUF_SIZE
  Next

  If length Mod BUF_SIZE
    If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + length Mod BUF_SIZE], length Mod BUF_SIZE)
      Return -2	
    End If
    inbuf :+ outbuf[0..outlen]
    count :+ length Mod BUF_SIZE
  End If


  If Not ctx.CipherFinal(outbuf, outLen)
    Return -2
  End If

  inbuf :+ outbuf[0..outlen]
  ctx.Cleanup()

  SaveByteArray(inbuf, outfile)

  ' Clear memory just in case
  For i = 0 Until inbuf.length
    inbuf[i] = 0
  Next
  For i = 0 Until outbuf.length
    outbuf[i] = 0
  Next
  For i = 0 Until arr.length
    arr[i] = 0
  Next
  For i = 0 Until key.length
    key[i] = 0
  Next
  For i = 0 Until iv.length
    iv[i] = 0
  Next

  Return True

End Function
</textarea><br><br>Encryption/decryption breaks somehow.... Not sure why.. I have a another example where the almost exact same function works, but I'll have to email it to you. There is some strange behaviour.... And the exact same thing happens in windows aswell... I'm guessing it might be a openssl bug for now....<br><br>By the way I tried to send you an email, but it wouldn't let me....<br><br>So I'm posting an example that works like a charm here:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Framework BaH.Crypto
Import BRL.Filesystem
Import BRL.Retro
Import BRL.Random

Global version:String = "1.1"

' Bogus key And IV: we'd normally set these from another source.
'Local key:Byte[] = IntToByteArray([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
'Local iv:Byte[] = IntToByteArray([1,2,3,4,5,6,7,8])

Local commandOK:Int
Local command:String
Local infile:String
Local outfile:String
Local keyfile:String
Local result:Int
Local file:TStream
Local cipher:String

If AppArgs.length &lt; 2
  printHelp()
  End
Else
  command = Trim(AppArgs[1])
  If command &lt;&gt; "help" And command &lt;&gt; "encrypt" And command &lt;&gt; "decrypt" And command &lt;&gt; "makekey"
    printHelp()
    End
  EndIf
  If command = "help"
  	Print "subcrypter v" + version + " (C) SubSoft 2013"
  	Print "--------------------------------"
  	Print "Available ciphers:"
	Print "AES"
  	Print "Blowfish"
    Print "CAST5"
    Print "DES"
  	Print "RC2"
    Print "RC4"
    End
  EndIf
  If AppArgs.length &lt; 3
    printHelp()
    End
  Else
    If command = "makekey"
      cipher = Lower(Trim(AppArgs[2]))
      If cipher &lt;&gt; "aes" And cipher &lt;&gt; "blowfish" And cipher &lt;&gt; "rc2" And cipher &lt;&gt; "cast5" And cipher &lt;&gt; "des" And cipher &lt;&gt; "rc4" And cipher &lt;&gt; "rc5"
        Print "Invalid cipher error"
        End
      EndIf
      file = WriteStream(Trim(AppArgs[3]))
      If cipher = "aes"
		WriteLine(file, anpass(6,1))
		WriteLine(file, anpass(8,1))
		WriteLine(file, "aes_256_cbc")
	  EndIf
      If cipher = "blowfish"
		WriteLine(file, anpass(7,1))
		WriteLine(file, anpass(8,1))
		WriteLine(file, "bf_cbc")
	  EndIf
	  If cipher = "cast5"
		WriteLine(file, anpass(5,1)) '4
		WriteLine(file, anpass(8,1))
		WriteLine(file, "cast5_cbc")
	  EndIf
	  If cipher = "des"
		WriteLine(file, anpass(4,1))
		WriteLine(file, anpass(8,1))
		WriteLine(file, "des_cbc")
	  EndIf
	  If cipher = "rc2"
		WriteLine(file, anpass(5,1))
		WriteLine(file, anpass(8,1))
		WriteLine(file, "rc2_cbc")
	  EndIf
	  If cipher = "rc4"
		WriteLine(file, anpass(9,1))
		WriteLine(file, anpass(8,1))
		WriteLine(file, "rc4")
	  EndIf
	  If cipher = "rc5"
		WriteLine(file, anpass(9,1))
		WriteLine(file, anpass(8,1))
		WriteLine(file, "rc5_32_12_16_cbc")
	  EndIf
      CloseStream(file)
      End
    EndIf
    If command &lt;&gt; "makekey" And AppArgs.length &lt; 5
      printHelp()
      End
    EndIf

    infile  = Trim(AppArgs[2])
	outfile = Trim(AppArgs[3])
	keyfile = Trim(AppArgs[4])
    If Not FileMode(infile) &gt; 0
	  Print "infile: File not found"
	  End
	EndIf
	If Not FileMode(keyfile) &gt; 0
	  Print "keyfile: File not found"
	  End
	EndIf
    
    If AppArgs.length &gt; 4 And command = "encrypt"
	  result = encrypt(infile, outfile, keyfile)
	  If result = -1
	    Print "File not found error"
	    End
	  EndIf
	  If result = -2
	    Print "Encryption error"
	    End
	  EndIf
	  If result = -3
	    Print "Key file error"
	    End
	  EndIf
    EndIf
    If AppArgs.length &gt; 4 And command = "decrypt"
      result = decrypt(infile, outfile, keyfile)
	  If result = -1
	    Print "File not found error"
	    End
	  EndIf
	  If result = -2
	    Print "Encryption error"
	    End
	  EndIf
	  If result = -3
	    Print "Key file error"
	    End
	  EndIf
    EndIf
  EndIf
EndIf

Function printHelp:Int()
  Print "subcrypter v" + version + " (C) SubSoft 2013"
  Print "--------------------------------"
  Print "usage: subcrypter encrypt [infile] [outfile] [keyfile]"
  Print "       subcrypter decrypt [infile] [outfile] [keyfile]"
  Print "       subcrypter makekey [cipher] [keyfile]"
  Print "       subcrypter help (for more information)"
End Function

' +++++++++++++++++++++++++++++++++++++++
' encrypt
' Return codes:
' -1 = File not found error
' -2 = Encrypt error
' -3 = Key file error
' +++++++++++++++++++++++++++++++++++++++
Function encrypt:Int(infile:String, outfile:String, keyfile:String)
  Local inbuf:Byte[]
  Local arr:Byte[]
  Local ctx:EVP_CIPHER_CTX
  Local cipher_:EVP_CIPHER
  Local cipher:String
  Local count:Int
  Const BUF_SIZE:Int = 2048 ' our block size
  Local outlen:Int
  Local i:Int
  Local file:TStream
  Local key:Byte[]
  Local iv:Byte[]

  If FileMode(infile) &gt; 0 And FileMode(keyfile) &gt; 0
	arr = LoadByteArray(infile)
  Else
    Return -1
  EndIf

  ' Read keyfile
  file   = ReadStream(keyfile)
  key    = StringToByteArray(ReadLine(file))
  iv     = StringToByteArray(ReadLine(file))
  cipher = ReadLine(file)
  CloseStream(file)

  If Len(iv) &lt;&gt; 8
    Return -3
  EndIf

  If cipher = "aes_256_cbc"
    If Len(key) &lt; 6 Or Len(key) &gt; 6
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.aes_256_cbc()
	EndIf
  EndIf
  If cipher = "bf_cbc"
    If Len(key) &lt; 3 Or Len(key) &gt; 7
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.bf_cbc()
	EndIf
  EndIf
  If cipher = "cast5_cbc"
    If Len(key) &lt; 4 Or Len(key) &gt; 5
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.cast5_cbc()
	EndIf
  EndIf
  If cipher = "des_cbc"
    If Len(key) &lt; 4 Or Len(key) &gt; 4
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.des_cbc()
	EndIf
  EndIf  
  If cipher = "rc2_cbc"
    If Len(key) &lt; 1 Or Len(key) &gt; 5
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.rc2_cbc()
	EndIf
  EndIf
  If cipher = "rc4"
    If Len(key) &lt; 4 Or Len(key) &gt; 9
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.rc4()
	EndIf
  EndIf
  
  If cipher_ = Null Then Return -3
  
  ctx = New EVP_CIPHER_CTX.Create()
  ctx.CipherInit(cipher_, Null, Null, Null, True)
  ctx.SetKeyLength(key.length)
  ctx.CipherInit(cipher_, Null, key, iv, True)
  Local outbuf:Byte[BUF_SIZE + ctx.GetBlockSize()]
  Local length:Int = arr.length
  count = 0
  ' loop all the full blocks
  For i = 0 Until length / BUF_SIZE
	If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + BUF_SIZE], BUF_SIZE)
	  Return -2
	End If
	' update input buffer offset
	count :+ BUF_SIZE
	' store encrypted
	inbuf :+ outbuf[0..outlen]	
  Next

' encrypt remaining part block
  If length Mod BUF_SIZE
	If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + length Mod BUF_SIZE], length Mod BUF_SIZE)
	  Return -2
	End If	
	' update input buffer offset
	count :+ length Mod BUF_SIZE
	' store encrypted
	inbuf :+ outbuf[0..outlen]
  End If

  ' Tidy up
  If Not ctx.CipherFinal(outbuf, outlen) Then
	Return -2
  End If

  ' add any padding
  inbuf :+ outbuf[0..outlen]
  ctx.Cleanup()
  SaveByteArray(inbuf, outfile)

  ' Clear memory just in case
  For i = 0 Until inbuf.length
    inbuf[i] = 0
  Next
  For i = 0 Until outbuf.length
    outbuf[i] = 0
  Next
  For i = 0 Until arr.length
    arr[i] = 0
  Next
  For i = 0 Until key.length
    key[i] = 0
  Next
  For i = 0 Until iv.length
    iv[i] = 0
  Next

  Return True
End Function


' +++++++++++++++++++++++++++++++++++++++
' decrypt
' Return codes:
' -1 = File not found error
' -2 = Encrypt error
' -3 = Key file error
' +++++++++++++++++++++++++++++++++++++++

Function decrypt:Int(infile:String, outfile:String, keyfile:String)
  Local inbuf:Byte[]
  Local outbuf:Byte[]
  Local arr:Byte[]
  Local ctx:EVP_CIPHER_CTX
  Local cipher_:EVP_CIPHER
  Local cipher:String
  Local count:Int
  Const BUF_SIZE:Int = 2048 ' our block size
  Local outlen:Int
  Local i:Int
  Local file:TStream
  Local key:Byte[]
  Local iv:Byte[]
  Local length:Int

  If FileMode(infile) &gt; 0 And FileMode(keyfile) &gt; 0
	arr = LoadByteArray(infile)
  Else
    Return -1
  EndIf

  ' Read  &amp; check keyfile
  file   = ReadStream(keyfile)
  key    = StringToByteArray(ReadLine(file))
  iv     = StringToByteArray(ReadLine(file))
  cipher = ReadLine(file)
  CloseStream(file)

  If Len(iv) &lt;&gt; 8
    Return -3
  EndIf

  If cipher = "aes_256_cbc"
    If Len(key) &lt; 6 Or Len(key) &gt; 6
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.aes_256_cbc()
	EndIf
  EndIf
  If cipher = "bf_cbc"
    If Len(key) &lt; 3 Or Len(key) &gt; 7
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.bf_cbc()
	EndIf
  EndIf
  If cipher = "cast5_cbc"
    If Len(key) &lt; 4 Or Len(key) &gt; 5
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.cast5_cbc()
	EndIf
  EndIf
  If cipher = "des_cbc"
    If Len(key) &lt; 4 Or Len(key) &gt; 4
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.des_cbc()
	EndIf
  EndIf  
  If cipher = "rc2_cbc"
    If Len(key) &lt; 1 Or Len(key) &gt; 5
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.rc2_cbc()
	EndIf
  EndIf
  If cipher = "rc4"
    If Len(key) &lt; 4 Or Len(key) &gt; 9
	  Return -3
	Else
	  cipher_ = EVP_CIPHER.rc4()
	EndIf
  EndIf
  
  If cipher_ = Null Then Return -3

  length = arr.length
  ctx = New EVP_CIPHER_CTX.Create()
  ctx.CipherInit(cipher_, Null, Null, Null, False)
  ctx.SetKeyLength(key.length)
  ctx.CipherInit(cipher_, Null, key, iv, False)
  outbuf = New Byte[BUF_SIZE + ctx.GetBlockSize() + 10]

  count = 0

  For i = 0 Until length / BUF_SIZE
	If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + BUF_SIZE], BUF_SIZE)
	  Return -2
	End If
    inbuf :+ outbuf[0..outlen]
    count :+ BUF_SIZE
  Next

  If length Mod BUF_SIZE
    If Not ctx.CipherUpdate(outbuf, outlen, arr[count..count + length Mod BUF_SIZE], length Mod BUF_SIZE)
      Return -2	
    End If
    inbuf :+ outbuf[0..outlen]
    count :+ length Mod BUF_SIZE
  End If


  If Not ctx.CipherFinal(outbuf, outLen)
    Return -2
  End If

  inbuf :+ outbuf[0..outlen]
  ctx.Cleanup()

  SaveByteArray(inbuf, outfile)

  ' Clear memory just in case
  For i = 0 Until inbuf.length
    inbuf[i] = 0
  Next
  For i = 0 Until outbuf.length
    outbuf[i] = 0
  Next
  For i = 0 Until arr.length
    arr[i] = 0
  Next
  For i = 0 Until key.length
    key[i] = 0
  Next
  For i = 0 Until iv.length
    iv[i] = 0
  Next

  Return True

End Function

'//Passord Generator
Function anpass:String(anplen:Int, ansens:Int)
  '$anplen = 8;        // Passord Lengde
  '$ansens = 0;        // Passord Case sensitive
  Local antype:Int = Rand(0,1)  ' Alpha/numerisk
  Local anlen:Int = Rand(0,2)   ' Rekke lengde
  Local antcount:Int = 0       ' Posisjon i rekke
  Local anpassword:String = ""
  Local tmpc:Int

  SeedRnd(MilliSecs())  

  Local i:Int = 0
  While i &lt; anplen
    If antype = 0    '// Alpha
      If ansens = 1
        tmpc = Rand (0,1)
      Else 
        tmpc = 1
      EndIf
      If tmpc = 0
        anpassword$ = anpassword$ + Chr(Rand(65,71))  '//65 90 A-F
      EndIf
      If tmpc = 1
        anpassword$ = anpassword$ + Chr(Rand(97,102)) '//97 122 a-f
       EndIf
    EndIf
    If antype = 1    '// Numeric
      anpassword$ = anpassword$ + Chr(Rand(48,57))    '//48 58 0-9
    EndIf
    antcount = antcount + 1
    If antcount &gt; anlen
      If antype = 0
		  antype = 1
		Else 
		  antype = 0
		EndIf
      anlen = Rand(0,2)
      antcount = 0
    EndIf
    i = i + 1
  Wend
  Return anpassword$
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1178995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, I'm not sure why it isn't working in your first example, but if I use the decrypt functions, it seems to work. <br><br></td></tr></table><br>
<a name="1179017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't get it to work even with your large file example when integrating in my larger programs... sometimes it works, sometimes it doesn't, and when turning on debug mode it breaks, and sometimes it works when commenting out import BRL.Eventqueue ! So I have no clue any more <br><br></td></tr></table><br>
<a name="1192448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi<br><br>I've installed the latest ubuntu wich uses libssl-dev_1.0.1c, and i get this message when trying to compile a program using BaH.Crypto:<br><br><pre class=code>
/home/BlitzMax/mod/bah.mod/crypto.mod/crypto.debug.linux.x86.a(crypto.bmx.debug.linux.x86.o): In function `_bah_crypto_EVP_CIPHER_des_cfb':
(code+0x1262): undefined reference to `EVP_des_cfb'
/home/BlitzMax/mod/bah.mod/crypto.mod/crypto.debug.linux.x86.a(crypto.bmx.debug.linux.x86.o): In function `_bah_crypto_EVP_CIPHER_des_ede_cfb':
(code+0x14e7): undefined reference to `EVP_des_ede_cfb'
/home/BlitzMax/mod/bah.mod/crypto.mod/crypto.debug.linux.x86.a(crypto.bmx.debug.linux.x86.o): In function `_bah_crypto_EVP_CIPHER_des_ede3_cfb':
(code+0x16eb): undefined reference to `EVP_des_ede3_cfb'
/home/BlitzMax/mod/bah.mod/crypto.mod/crypto.debug.linux.x86.a(crypto.bmx.debug.linux.x86.o): In function `_bah_crypto_EVP_CIPHER_bf_cfb':
(code+0x18ef): undefined reference to `EVP_bf_cfb'
/home/BlitzMax/mod/bah.mod/crypto.mod/crypto.debug.linux.x86.a(crypto.bmx.debug.linux.x86.o): In function `_bah_crypto_EVP_CIPHER_rc2_cfb':
(code+0x1b74): undefined reference to `EVP_rc2_cfb'
/home/BlitzMax/mod/bah.mod/crypto.mod/crypto.debug.linux.x86.a(crypto.bmx.debug.linux.x86.o): In function `_bah_crypto_EVP_CIPHER_cast5_cfb':
(code+0x1d78): undefined reference to `EVP_cast5_cfb'
</pre><br><br>Might be some changes in the latest libssl-dev? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
