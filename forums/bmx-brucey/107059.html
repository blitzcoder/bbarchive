<!DOCTYPE html><html lang="en" ><head ><title >Operator Overloading</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Operator Overloading</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=124" >Brucey's Modules</a>/<a href="#bottom" >Operator Overloading</a><br><br>
<a name="1323269"></a>

<a name="1325427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hallo, there's a new feature for testing if anyone would like to give it a try. It adds support for operator overloading.<br><br>Operator overloading adds what is known as syntactic sugar to your code, hiding method calls behind standard operators.<br>Supported operators include<br><pre class=code>
* / + - &amp; | ~ :* :/ :+ :- :&amp; :| :~ &lt; &gt; &lt;= &gt;= = &lt;&gt; mod shl shr :mod :shl :shr
</pre><br><br>The syntax is in the form of a method name with the prefix Operator, and the suffix of the operator you want to overload.<br>Return types for conditional operators are usually Int, for assignment-style operators (like :+ , :* etc) there is no return type, and for the rest, your user-defined Type.<br><br>Here are a couple of examples.<br>For assignment addition ( :+ ) where you are adding a float to your user type,<br><pre class=code>
	Method Operator:+(f:Float)
		x :+ f
		y :+ f
	End Method
</pre><br>For assignment addition ( :+ ) where you are adding a another object to your user type,<br><pre class=code>
	Method Operator:+(v:Vec2)
		x :+ v.x
		y :+ v.y
	End Method
</pre><br>For adding ( + ) two objects together.<br><pre class=code>
	Method Operator+:Vec2(v:Vec2)
		Local n:Vec2
		n.x = x + v.x
		n.y = y + v.y
		Return n
	End Method
</pre><br><br>And so on.<br><br>Here's a working example :<br><pre class=code>
SuperStrict

Framework brl.standardio

Local v1:Vec2 = New Vec2(10, 10)
Local v2:Vec2 = New Vec2(15, 20)

Local v3:Vec2 = v1 + v2     ' addition of two vectors
Local v4:Vec2 = v1 + 150.0  ' addition of vector and float

v3 :+ 100.0                 ' addition of float to vector

Print v1.ToString()
Print v2.ToString()
Print v3.ToString()
Print v4.ToString()

Struct Vec2

	Field x:Float
	Field y:Float

	Method New(x:Float, y:Float)
		Self.x = x
		Self.y = y
	End Method

	Method Operator+:Vec2(v:Vec2)
		Local n:Vec2
		n.x = x + v.x
		n.y = y + v.y
		Return n
	End Method
	
	Method Operator+:Vec2(f:Float)
		Local n:Vec2
		n.x = x + f
		n.y = y + f
		Return n
	End Method

	Method Operator:+(f:Float)
		x :+ f
		y :+ f
	End Method
	
	Method ToString:String()
		Return "Vec2(" + x + ", " + y + ")"
	End Method
	
End Struct
</pre><br>Resulting in the output <br><pre class=code>
Vec2(10.0000000, 10.0000000)
Vec2(15.0000000, 20.0000000)
Vec2(125.000000, 130.000000)
Vec2(160.000000, 160.000000)
</pre><br>In this example, it is using Structs, but the same applies to standard Types. (Structs are stack-based, non-garbage managed/collected objects).<br><br>Of course, you can always write in equivalent using methods :<br><pre class=code>
Local v3:Vec2 = v1.Add(v2)
</pre><br>But you may prefer an arguably cleaner syntax of :<br><pre class=code>
Local v3:Vec2 = v1 + v2
</pre><br><br><br>You don't have to use it, but it is available for those that want to... and choice is good, as they say.<br><br>Anyhoo, all feedback is welcome, as usual :-) <br><br></td></tr></table><br>
<a name="1323434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've not tried it yet, but this is an awesome feature to have! <br><br></td></tr></table><br>
<a name="1323599"></a>

<a name="1323600"></a>

<a name="1323601"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I only recently grasped the point of this feature from learning C++!<br><br>Are structs brand-new in bmx-ng? (Out of curiosity, have they come from Monkey2, which now features structs?)<br><br>How do you free them? I've tried a couple of ways to no avail:<br><br><pre class=code>

Struct Test

	Field x:Int
	
	Method Add:Int (a:Int)
		x = x + a
	End Method
	
End Struct

Local t:Test = New Test

t.x = 1
t.Add 1

Print t.x

' ************** OK, LET'S DELETE! **************

t = Null		' Nope! error: incompatible types when assigning to type 'struct _m_untitled1_Test' from type 'BBObject * {aka struct BBObject *}'

't.Delete		' Nope! undefined reference to `_bbObjectDtor'

End
</pre><br><br>Just been looking through maxide-ng to try and find how to add Struct as a keyword, but literally no clue found! Looks like it's defined in bcc, but how do you get the IDE to pick it up and highlight, capitalise, etc? <br><br></td></tr></table><br>
<a name="1323602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> as it is no module defined function name you surely have to edit MaxIDE to support "struct". <br><br><br>@ freeing a struct<br>Hmm, maybe it is just not implemented because nobody made Brucey aware of the missing functionality ;-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1323607"></a>

<a name="1323608"></a>

<a name="1323609"></a>

<a name="1323610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, that's the kind of feature (almost the last one for my concern) that was really missing to blitzmax to make it really confortable !<br><br>So, it would probably just miss the "property" style syntax now and I think BlitzMax would be complete (for the OOP part)<br><br>I hope BlitzMaxNG will fully replace the vanilla version some days, so I don't need to make portability between the two versions and fully use the NG features for myself :p<br>But this won't happen until it becomes easier to install and compile.<br>Maybe there is still a lot of work in that sense<br>Like a simple installer that will get the stuff and batch install everything without the needs to set variables, compile stuff manually etc ...<br>(it's not that hard, but it's not very convenient)<br><br>Anyway, it's already a very good step, so thank you for making support for overloading !<br><br>[edit]<br>Damned ! searching the forum an "How to" install the whole thing, I 've found a topic which link to an old "last version" on github.<br>So, at this moment I said myself "hey ! that's pretty old, but it surely means there is binaries released ?! there must be a category to look for updated version ?"<br>And I click on the bmx-ng section to go to the parent section ... and nothing ... not a damned binary, just the source again. but there Must be something somewhere ... else I wouldn't see the previous page ...<br><br>And it just comes to my eyes after 5 minutes looking every chars on the page<br><br><img src="http://mdt.bigbang.free.fr/temp/download_release_NG.png"><br><br>(for me, the highlighted in orange section was actually not a section ... it just looks like a label -&gt; some kind of general overview "There is 9 releases" , it doesn't look like something "clickable" so my brain skip it as fast as my eyes go on it)<br><br>Maybe I'm a bit stupid, I don't know ... But for me, this is all but explicit.<br>So, maybe there should be a sticky post on the forum to mention it for other idiots like me :) <br><br></td></tr></table><br>
<a name="1323613"></a>

<a name="1323614"></a>

<a name="1323616"></a>

<a name="1323617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've downloaded and built bcc_op, replaced my bin\ copy of bcc, but this doesn't work here:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Type Test

	Field whatever:Int
	
	Method Operator+:Test (t1:Test, t2:Test)

		Local temp:Test = New Test

			temp.whatever = t1.whatever + t2.whatever
		
		Return temp
		
	End Method

End Type

Local t1:Test = New Test

	t1.whatever = 1

Local t2:Test = New Test

	t2.whatever = 2

Local t3:Test = t1 + t2

	Print t3.whatever
</textarea><br><br>Says "Compile Error: Operator + cannot be used with Objects." Do I need to update anything else?<br><br>One thing I don't get from the original example is why the test declares two "New Vec2"s, while the operator just declares "Local n:Vec2". How come the operator doesn't need to 'New' it? <br><br></td></tr></table><br>
<a name="1323615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, the example works. Just tried converting it to use Type, and with New Vec2 added to the methods, it works. Will have to compare... <br><br></td></tr></table><br>
<a name="1323618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, I did a stoopid:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Type Test

	Field whatever:Int
	
	Method Operator+:Test (t:Test) ' *** Just pass the 'other' object here! ***

		Local temp:Test = New Test

			temp.whatever = whatever + t.whatever
		
		Return temp
		
	End Method

End Type

Local t1:Test = New Test

	t1.whatever = 1

Local t2:Test = New Test

	t2.whatever = 2

Local t3:Test = t1 + t2

	Print t3.whatever
</textarea> <br><br></td></tr></table><br>
<a name="1323619"></a>

<a name="1323620"></a>

<a name="1323621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is pretty cool! 3D demo using CSG add/subtract operations with operator overloading:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Import Openb3d.B3dglgraphics

Const CSG_SUBTRACT:Int	= 0 ' Method 0 subtracts mesh2 from mesh1
Const CSG_ADD:Int		= 1 ' Method 1 adds meshes
Const CSG_INTERSECT:Int	= 2 ' Method 2 intersects meshes

Graphics3D 1024, 768, 0, 2

Local cam:TCamera	= CreateCamera ()

	MoveEntity cam, 0, 5, 0
	
Local pivot:TPivot = CreatePivot ()

	MoveEntity pivot, 0, 0, 5

Local light:TLight	= CreateLight ()

	MoveEntity light, -10, 0, 0
	
Local cube1:TMesh	= CreateCube ()

	MoveEntity	cube1, -0.5, -0.5, 5

Local cube2:TMesh	= CreateCube ()

	MoveEntity	cube2, 0.5, 0.5, 5.5

Local cube:TMesh

PointEntity cam, pivot
PointEntity light, pivot

Local timer:Int = MilliSecs ()

Repeat

	Cls
	
	If cube Then TurnEntity cube, 0.25, 0.5, 1.0

	If KeyHit (KEY_EQUALS) Or KeyHit (KEY_NUMADD)
	
		If cube

			FreeEntity cube
			cube = Null

			ShowEntity cube1
			ShowEntity cube2

		EndIf

		cube = cube1 + cube2

		CenterMesh cube
		MoveEntity cube, 0, 0, 5

		HideEntity cube1
		HideEntity cube2
	
		timer = MilliSecs ()
		
	EndIf

	If KeyHit (KEY_MINUS) Or KeyHit (KEY_NUMSUBTRACT)
	
		If cube

			FreeEntity cube
			cube = Null

			ShowEntity cube1
			ShowEntity cube2

		EndIf

		cube = cube1 - cube2

		CenterMesh cube
		MoveEntity cube, 0, 0, 5

		HideEntity cube1
		HideEntity cube2

		timer = MilliSecs ()

	EndIf

	If MilliSecs () - timer &gt; 2000

		If cube

			FreeEntity cube
			cube = Null

			ShowEntity cube1
			ShowEntity cube2

		EndIf

	EndIf
	
	RenderWorld
	
	BeginMax2D
	
		DrawText "Press + to add meshes, - to subtract...", 20, 20
	
	EndMax2D
	
	Flip
	
Until KeyHit (KEY_ESCAPE) Or AppTerminate ()

End

Function CenterMesh:Int (entity:TMesh)
	FitMesh entity, -(MeshWidth (entity) / 2.0), -(MeshHeight (entity) / 2.0), -(MeshDepth (entity) / 2), MeshWidth (entity), MeshHeight (entity), MeshDepth (entity)
End Function
</textarea><br><br>This is with the following added at the end of <i>mod\openb3d.mod\openb3dex.mod\inc\TMesh.bmx</i>:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	Const CSG_SUBTRACT:Int	= 0 ' Method 0 subtracts mesh2 from mesh1
	Const CSG_ADD:Int		= 1 ' Method 1 adds meshes
	Const CSG_INTERSECT:Int	= 2 ' Method 2 intersects meshes

	Method Operator+:TMesh (add_mesh:TMesh)
		Return MeshCSG (Self, add_mesh, CSG_ADD)
	End Method

	Method Operator-:TMesh (add_mesh:TMesh)
		Return MeshCSG (Self, add_mesh, CSG_SUBTRACT)
	End Method
</textarea><br><br>32-bit Windows demo at <a href="http://www.hi-toro.com/blitz/temp/csgoo.zip" target="_blank">http://www.hi-toro.com/blitz/temp/csgoo.zip</a><br><br>(Will rotate for two seconds after adding/subtracting the cubes, then reset to the separate (overlapping) cubes.) <br><br></td></tr></table><br>
<a name="1323636"></a>

<a name="1323742"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just for completion...<br><br>Structs in BMX-NG are allocated on the stack. So say you create an instance of a struct that's a 'local' in a function then when the function goes of out scope the struct instance will also go out scope and that stack allocated struct will also be gone. Therefore you don't need to 'free' it and you also don't need to tell Brucey that he's missed anything :p<br><br>Stack allocations are much faster than dynamic memory management as its simply a case of updating a cpu register ( the stack pointer ) to accommodate for more needed 'local' memory. Dynamic memory management requires hitting up the GC for an allocation which is extremely expensive by comparison - to the point of being incomparable.<br><br>Looks like a good demo there James! <br><br></td></tr></table><br>
<a name="1323641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wouldn't have think about CSG functions using this, but it's a good idea :)<br><br>You could probably add this too<br><pre class=code>
	Method Operator&amp;:TMesh (add_mesh:TMesh)
		Return MeshCSG (Self, add_mesh, CSG_INTERSECT)
	End Method
</pre><br>Intersect acts just like a "&amp;" in theory (the part of the 2 meshes that exists for both) <br><br></td></tr></table><br>
<a name="1323648"></a>

<a name="1323649"></a>

<a name="1323650"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Structs in BMX-NG are allocated on the stack. So say you use a struct in a function then when the function goes of out scope the struct instance will also go out scope and that stack allocated struct will also be gone<br> <br></div><br>Oh, I see... I think! How does that relate to the New versus non-New calls, though?<br><br><div class="quote"> <br>Intersect acts just like a "&amp;" in theory (the part of the 2 meshes that exists for both) <br> <br></div><br><br>Oh, good call -- I'll add that!<br><br>EDIT: Added now -- little Win32 demo with source that shows it:<br><br><a href="http://www.hi-toro.com/blitz/temp/csgoo2.zip" target="_blank">http://www.hi-toro.com/blitz/temp/csgoo2.zip</a> <br><br></td></tr></table><br>
<a name="1323651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hallo :-)<br><br>@Structs<br><div class="quote">  How does that relate to the New versus non-New calls, though? <br></div><br>Using New with Structs is optional...<br><pre class=code>
Struct MyStruct
  Field x:Int
  Field y:Int
End Struct

Local s1:MyStruct
Local s2:MyStruct = New MyStruct
</pre><br>s1 and s2 are initialised in the same way.<br>You can always just use New as you do with Types, and not be concerned about it being optional ;-)<br><br>A Struct instance is not a pointer to an object - like you have with an instance of a Type. It is simply some space allocated from the stack. Since they are not tracked by the GC, they are quick to allocate, and don't need to be freed. They are useful for small data - like a vector - but not so much for larger data, because the stack is limited.<br>When you pass a Struct into a method/function it is passed by value (i.e. the content is copied onto a new part of the stack). When you pass a Type, you pass by reference.<br>Because they are not part of GC, you shouldn't have fields of Types/Arrays/Strings on them - unless you know what you are doing.<br>If you are not sure, just use Types :-)<br><br>Another Struct example<br><pre class=code>
Struct MyStruct
  Field x:Int
  Field y:Int

  Method New(x:Int, y:Int)
    Self.x = x
    Self.y = y
  End Method

  Method New(s:MyStruct)
    x = s.x
    y = s.y
  End Method
End Struct

Local s1:MyStruct = New MyStruct(10, 10)
Local s2:MyStruct = New MyStruct(s1)
</pre> <br><br></td></tr></table><br>
<a name="1323660"></a>

<a name="1323661"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Brucey. I suppose I'm sort of aware you can't really free stack memory within a function, though it's only recently that I've got a proper handle on what stack memory is, so I guess it makes sense that it's only released on exit from a function! [EDIT: Or is it? Isn't it just something that's globally allocated per-function when the program starts, based on the declared variables within? Does it actually get freed at all?]<br><br>I was kind of thinking it's like manually-allocated memory, but of course it's not.<br><br><div class="quote"> <br>If you are not sure, just use Types :-)<br> <br></div><br>I might just do that, though I understand Structs are much quicker since the stack memory is already allocated at startup (I suppose), just like with basic local variables.<br><br>Anyway, glad to have more of a clue about operator overloading now, as it's something I always thought was pointless and confusing, misunderstanding that it was for changing how add/subtract and co worked on basic ints, floats and so on! <br><br></td></tr></table><br>
<a name="1323700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Free<br>Sorry  for the wrong assumption of a "might have been missed" situation. We (James and me) just exposed some missing knowledge.<br>Good to have you on board to explain that subject to us.<br><br><br>@ Overloading<br>Whats the real benefit of having it - compared to Methods like "myVec2.AddVec2(otherVec2)" ?<br><br>In both cases "myVec2" must be aware of how to handle the incoming "other thing" - similar to the operator overloading.<br><br><br>@ Overloading add/subtract int floats ...<br>As much as I remember what Brucey explained: you can only overload operators for types in this NG-implementation. So you need "Methods-capability". Int/Float/String do not allow for such things - and therefor are not available for operator overloading (in the sence of "a:int + b:int").<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1323793"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Derron: yeah, I always misunderstood operator overloading to mean you could change how basic type addition, etc, worked, hence didn't get the point; I get that it's not actually meant for that now. (Does C++ even allow it?)<br><br>As for the benefits, I guess it mainly just allows for a snappier syntax, without the need to remember/look up methods, as in "obj1 = obj2 + obj3". <br><br></td></tr></table><br>
<a name="1325354"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >seriouslee</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Saw this post so I downloaded the branched bcc and gave it a try. Love it, Brucey!!!! Are you planning to merge this into the master branch? <br><br></td></tr></table><br>
<a name="1325358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is already merged into master for some days now.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1325373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >seriouslee</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well... I thought I had tried it but I must have not formatted the Operator part correctly. Duh. Glad it is! Expressions are clearer in my opinion with them for the most part. <br><br></td></tr></table><br>
<a name="1326623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for implementing this feature!!!<br><br>I'm really using it a lot :P <br><br></td></tr></table><br>
<a name="1326647"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm glad it appears to work ;-)<br><br>I really want to add support for generics, but I'm still trying to get my head around it... <br><br></td></tr></table><br>
<a name="1327633"></a>

<a name="1327637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FireballStarfish</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> For some reason, it doesn't work for me.<br>If I try to run the example from post #1, I get this:<br><pre class=code>C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c: In function '__m_untitled3_Vec2__add_TVec2_TVec2':
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c:68:11: error: conversion to non-scalar type requested
  ((struct _m_untitled3_Vec2)bbNullObjectTest(o));
           ^
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c: In function '__m_untitled3_Vec2__add_TVec2_f':
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c:110:11: error: conversion to non-scalar type requested
  ((struct _m_untitled3_Vec2)bbNullObjectTest(o));
           ^
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c: In function '__m_untitled3_Vec2__addeq_v_f':
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c:152:11: error: conversion to non-scalar type requested
  ((struct _m_untitled3_Vec2)bbNullObjectTest(o));
           ^
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c: In function '__m_untitled3_Vec2_ToString':
C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c:182:11: error: conversion to non-scalar type requested
  ((struct _m_untitled3_Vec2)bbNullObjectTest(o));
           ^
Build Error: failed to compile C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled3.bmx.console.debug.win32.x64.c</pre><br><br>This seems to be related the struct rather than the operators though, because if I change the Struct into a Type it works fine, and because I am also having issues with this simple test:<br><pre class=code>SuperStrict
Framework BRL.Blitz

Local s:STest = New STest("a")

Struct STest

	Field s:String
	
	Method New(s:String)
		Self.s = s
	End Method
	
End Struct</pre><br><pre class=code>C:/Programmierung/BlitzMax-NG/tmp/.bmx/untitled1.bmx.console.debug.win32.x64.c:91:47: error: '_m_untitled1_STest' undeclared (first use in this function)
   bbt_s2=__m_untitled1_STest_New_S_ObjectNew(&amp;_m_untitled1_STest,&amp;_s0);
                                               ^</pre><br>I did update to the newest versions of bcc and BRL.Mod; anything else I need to do? <br><br></td></tr></table><br>
<a name="1327710"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Those two issues should be fixed now. <br><br></td></tr></table><br>
<a name="1327724"></a>

<a name="1327726"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is absolutely cool :)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Type TTest
	Field t:Int

	Method New(i:Int)
		Self.t = i
	End Method
	
	Method New(test:TTest)
		Self.t = test.t
	End Method
	
	Method operator:+(i:Int)
		t :+ i
	End Method
	
	Method Operator+:TTest(i:Int)
		Return New TTest(t+i)
	End Method
	
	Method Operator:+(test:TTest)
		t :+ test.t
	End Method
	
	Method operator+:TTest(test:TTest)
		Return New TTest(t+test.t)
	End Method
	
	Method Operator=:Int(test:TTest)
		If t = test.t Then Return True
		Return False
	End Method
End Type

Print "Local test:TTest = new TTest(10)"
Local test:TTest = New TTest(10)
Print test.t
Print

Print "test :+ 20"
test :+ 20
Print test.t
Print

Print "Local test2:TTest = test + 10"
Local test2:TTest = test + 10
Print test2.t
Print

Print "Local test3:TTest = test + test2"
Local test3:TTest = test + test2
Print test3.t
Print

Print "test3 :+ test"
test3 :+ test
Print test3.t
Print

Print "Local test4:TTest = new TTest(test)"
Local test4:TTest = New TTest(test)
Print test4.t
Print

Print "Print (test = test4)"
Print (test = test4)
Print

Print "Print (test = test3)"
Print (test = test3)
</textarea><br>Edit: cause it is even cooler <br><br></td></tr></table><br>
<a name="1327812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
	
	Method operator:+(i:Int)
		t :+ i
	End Method
	
	Method Operator+:TTest(i:Int)
		Return New TTest(t+i)
	End Method
</pre><br><br>How does the compiler know which of both you are calling (param types need to differ - at least this is what I thought).<br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1327817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> The first is Operator followed by <b>:+</b> . Note the : before the +. this is called whenever you do Type :+ Type.<br><br>The second is Operator followed by <b>+</b>, then a return type with :TTest.  Note the : is after the +.  It is not part of the operator, but separating the operator from the return type.  This will be called whenever you do Type = Type + Type.<br><br>So basically, you have two different functions, <b>Operator:+</b> and <b>Operator+</b>.  Both take an Int as a parameter, the second returns a TTest type. <br><br></td></tr></table><br>
<a name="1327857"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> I should not write here with 1 eye open ... just saw "operator +" and "operator + ttest".<br><br><br>BTW: so <br>&gt; [...] This will be called whenever you do Type = Type + Type.<br>is a bit incorrect and should be<br>Type = Type + 1<br><br><br>Why is that ":+" even needed or allowed to get overridden? For me ":+" should always be threatened as shortcut to "a = a + x". So in our example the second override should be:<br><br>Method Operator+:TTest(i:int)<br><br>and should override<br>test = test + 1<br>and<br>test :+ 1<br><br>because even the second one is "implicitely" returning "TTest".<br><br><br>What do I miss / misunderstand?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1327897"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Method Operator+TTest(i:int) doesn;t consider the LValue (the identifier on the left side of the = sign).  It calls the operator method of the right test, adds i then returns test.  You need 2 different versions because you might not want to return a TTest as a result.  For example<br><pre class=code>Type TTest
	Field t:Int
	
	Method New(i:Int)
		Self.t = i
	End Method
	
	Method Operator+:Int(i:Int)
		Return t+i
	End Method
End Type

Local test:TTest = New TTest(10)
Local j:Int = test + 10
Print test.t
Print j

</pre><br>Notice in this example, I overridden + for TTest, but the result returned is an int.  So doing test :+ 1 would not work as it would expect a TTest as a result. <br><br></td></tr></table><br>
<a name="1327911"></a>

<a name="1327988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> What do I miss / misunderstand? <br></div><br>You can set up the 'operator overloading' to return what ever you want it to return. Its up to you make sure the returned value is of the expected type - you are overriding default behavior so clarity in your code is up to you to maintain.<br><br>Personally, I'd keep the returned Type from any method the same as the Type that the method is within. Doing anything else is just asking for some serious brain hurt further down the line, however, as I say, it's up to you, I'm sure there are cases where it would sense to change the returned type but I can't think of any right now.<br><br><pre class=code>
Strict

Type TTest
	Field t:Int
	
	Method New(i:Int)
		Self.t = i
	End Method
	
	Method Operator+:TTest(i:Int)
		t :+ i
		Return Self
	End Method
End Type

Local test:TTest = New TTest(10)
Local j:TTest = test + 10
Print j.t
</pre> <br><br></td></tr></table><br>
<a name="1327966"></a>

<a name="1327972"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Matrix multiplication often results in matrices of different sizes.  For example, a 1x3 matrix multiplied by a 3x1 matrix will result in a 1x1 matrix, and a 3x1 multiplied by a 1x3 will result in a 3x3 matrix.  Such as the example below<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type TMatrix1x3
	Field Array:Float[3]
	
	Method New(c1:Float,c2:Float,c3:Float)
		Array[0] = c1
		Array[1] = c2
		Array[2] = c3
	End Method
	
	Method Operator*:TMatrix1x1(M:TMatrix3x1)
		Return New TMatrix1x1(Array[0]*M.Array[0]+Array[1]*M.Array[1]+Array[2]*M.Array[2])
	End Method
	
	Method ToString:String()
		Return Array[0]+" "+Array[1]+" "+Array[2]
	End Method
End Type

Type TMatrix3x1
	Field Array:Float[3]
	
	Method New(r1:Float,r2:Float,r3:Float)
		Array[0] = r1
		Array[1] = r2
		Array[2] = r3
	End Method
	
	Method Operator*:TMatrix3x3(M:TMatrix1x3)
		Return New TMatrix3x3(Array[0]*M.Array[0],Array[0]*M.Array[1],Array[0]*M.Array[2], ..
							  Array[1]*M.Array[0],Array[1]*M.Array[1],Array[1]*M.Array[2], ..
							  Array[2]*M.Array[0],Array[2]*M.Array[1],Array[2]*M.Array[2])
	End Method
	
	Method ToString:String()
		Return Array[0]+"~n"+Array[1]+"~n"+Array[2]
	End Method
End Type

Type TMatrix1x1
	Field Array:Float
	
	Method New(r:Float)
		Array = r
	End Method
	
	Method ToString:String()
		Return Array
	End Method
End Type

Type TMatrix3x3
	Field Array:Float[3,3]
	
	Method New(r1c1:Float,r1c2:Float,r1c3:Float, ..
			   r2c1:Float,r2c2:Float,r2c3:Float, ..
			   r3c1:Float,r3c2:Float,r3c3:Float)
			Array[0,0] = r1c1; Array[0,1] = r1c2; Array[0,2] = r1c3
			Array[1,0] = r2c1; Array[1,1] = r2c2; Array[1,2] = r2c3
			Array[2,0] = r3c1; Array[2,1] = r3c2; Array[2,2] = r3c3
	End Method
	
	Method Operator:*(M:TMatrix3x3)
		Local NewArray:Float[3,3]
		NewArray[0,0] = Array[0,0]*M.Array[0,0]+Array[0,1]*M.Array[1,0]+Array[0,2]*M.Array[2,0] '1,1
		NewArray[0,1] = Array[0,0]*M.Array[0,1]+Array[0,1]*M.Array[1,1]+Array[0,2]*M.Array[2,1] '1,2
		NewArray[0,2] = Array[0,0]*M.Array[0,2]+Array[0,1]*M.Array[1,2]+Array[0,2]*M.Array[2,2] '1,3
		NewArray[1,0] = Array[1,0]*M.Array[0,0]+Array[1,1]*M.Array[1,0]+Array[1,2]*M.Array[2,0] '2,1
		NewArray[1,1] = Array[1,0]*M.Array[0,1]+Array[1,1]*M.Array[1,1]+Array[1,2]*M.Array[2,1] '2,2
		NewArray[1,2] = Array[1,0]*M.Array[0,2]+Array[1,1]*M.Array[1,2]+Array[1,2]*M.Array[2,2] '2,3
		NewArray[2,0] = Array[2,0]*M.Array[0,0]+Array[2,1]*M.Array[1,0]+Array[2,2]*M.Array[2,0] '3,1
		NewArray[2,1] = Array[2,0]*M.Array[0,1]+Array[2,1]*M.Array[1,1]+Array[2,2]*M.Array[2,1] '3,2
		NewArray[2,2] = Array[2,0]*M.Array[0,2]+Array[2,1]*M.Array[1,2]+Array[2,2]*M.Array[2,2] '3,3
		Array = NewArray
	End Method
							
	
	Method ToString:String()
		Return Array[0,0]+" "+Array[0,1]+" "+Array[0,2]+"~n"+ ..
			   Array[1,0]+" "+Array[1,1]+" "+Array[1,2]+"~n"+ ..
			   Array[2,0]+" "+Array[2,1]+" "+Array[2,2]
	End Method
End Type

Local Matrix1x3:TMatrix1x3 = New TMatrix1x3(1.0,2.0,3.0)
Local Matrix3x1:TMatrix3x1 = New TMatrix3x1(4.0,5.0,6.0)
Local Matrix1x1:TMatrix1x1 = Matrix1x3*Matrix3x1
Local Matrix3x3:TMatrix3x3 = Matrix3x1*Matrix1x3
Local Matrix3x3_2:TMatrix3x3 = New TMatrix3x3(11,12,13,21,22,23,31,32,33)

Print "Matrix1x3 = "
Print Matrix1x3.ToString()
Print

Print "Matrix3x1 ="
Print Matrix3x1.ToString()
Print

Print "Matrix1x3 * Matrix3x1 = "
Print Matrix1x1.ToString()
Print

Print "Matrix3x1 * Matrix1x3 = "
Print Matrix3x3.ToString()
Print

Print "Matrix3x3_2 = "
Print Matrix3x3_2.ToString()
Print

Print "Matrix3x3_2 :* Matrix3x3"
Matrix3x3_2 :* Matrix3x3
Print Matrix3x3_2.ToString()
</textarea><br><br>In this case, a Matrix1x3 :* Matrix3x1 would not work as the result is not a TMatrix1x3. Since a TMatrix3x3 * TMatrix3x3 results in a TMatrix3x3, I can define a :* for it.<br><br>You could argue that you should make a general purpose TMatrix type which can be defined with any dimensions, but that might be unnecessary overkill when only dealing with a couple of matrix sizes.  However, it is nice to have both options available to you so that you can choose whatever is clearest and works best for you. <br><br></td></tr></table><br>
<a name="1327971"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the clarification.<br><br>And yes - for matrices/vectors you are right (vec2+vec3 = vec3). This did not came into my mind. But I am with "col" that I am used to "int + int = int" and "string + int = string" so until it is only used for "internal/encapsulated things" (kept private in a type) I think it could add a lot of convenience.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1327978"></a>

<a name="1327980"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> having more fun.  Chemistry simulation shows what you get when mixing different elements with oxygen. (just an example, probably not scientifically accurate)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Type TMatter
	Field units:Int
	
	Method New(u:Int)
		units = u
	End Method
	
	Method ToString:String() Abstract
End Type

Type THydrogen Extends TMatter

	Method ToString:String()
		Return Units+" units of hydrogen"
	End Method
	
	Method Operator+:TList(M:TMatter)
		If TOxygen(M) Then Return TOxygen(M)+Self
		Local List:TList = CreateList()
		List.AddLast(Self)
		List.AddLast(M)
		Return List
	End Method
End Type

Type TCarbon Extends TMatter
	Method ToString:String()
		Return Units+" units of carbon"
	End Method
	
	Method Operator+:TList(M:TMatter)
		If TOxygen(M) Then Return TOxygen(M)+Self
		Local List:TList = CreateList()
		List.AddLast(Self)
		List.AddLast(M)
		Return List
	End Method

End Type

Type TOxygen Extends TMatter
	Method ToString:String()
		Return Units+" units of oxygen"
	End Method
	
	Method Operator+:TList(M:TMatter)
		Local List:TList = CreateList()
		If THydrogen(M)
				If Units*2 &lt; M.units 'Create Water with some Hydrogen left over
					List.AddLast(New TWater(Units))
					List.Addlast(New THydrogen(m.Units-Units*2))
				Else If Units*2 &gt; M.units 'Create Water with some oxygen left over
					List.AddLast(New TWater(M.Units/2))
					List.AddLast(New TOxygen(units-M.Units/2))
					If M.Units &amp; 1 'odd number of hydrogen units wil leave 1 left
						List.AddLast(New THydrogen(1))
					End If
				Else 'exactly twice as much hydrogen as oxygen
					List.AddLast(New TWater(Units))
				End If
		Else If TCarbon(M)
				If M.Units*2 &lt; units 'Create Co2 with some oxygen left over
					List.AddLast(New TCarbonDioxide(M.Units))
					List.Addlast(New TOxygen(Units-M.Units*2))
				Else If M.Units*2 &gt; units 'Create Co2 with some Carbon left over
					List.AddLast(New TCarbonDioxide(Units/2))
					List.AddLast(New TCarbon(M.units-Units/2))
					If Units &amp; 1 'odd number of Oxygen units wil leave 1 left
						List.AddLast(New TOxygen(1))
					End If
				Else 'exactly twice as much hydrogen as oxygen
					List.AddLast(New TCarbonDioxide(M.Units))
				End If
		Else
			List.AddLast(Self)
			List.AddLast(M)
		End If
		Return List
	End Method
					
End Type

Type TWater Extends TMatter
	Method ToString:String()
		Return Units+" units of water"
	End Method

	Method Operator+:TList(M:TMatter)
		Local List:TList = CreateList()
		List.AddLast(Self)
		List.AddLast(M)
		Return List
	End Method

End Type

Type TCarbonDioxide Extends TMatter
	Method ToString:String()
		Return Units+ " units of carbon dioxide"
	End Method
	
	Method Operator+:TList(M:TMatter)
		Local List:TList = CreateList()
		List.AddLast(Self)
		List.AddLast(M)
		Return List
	End Method

End Type

Local oxygen:TOxygen = New TOxygen(5)
Local hydrogen:THydrogen = New THydrogen(10)
Print oxygen.ToString()+" + "+hydrogen.ToString()+" results in"
For Local Matter:TMatter = EachIn (oxygen + hydrogen)
	Print Matter.ToString()
Next
Print

hydrogen = New THydrogen(15)
Print oxygen.ToString()+" + "+hydrogen.ToString()+" results in"
For Local Matter:TMatter = EachIn (oxygen + hydrogen)
	Print Matter.ToString()
Next
Print

oxygen = New TOxygen(10)
Print oxygen.ToString()+" + "+hydrogen.ToString()+" results in"
For Local Matter:TMatter = EachIn (oxygen + hydrogen)
	Print Matter.ToString()
Next
Print

Local carbon:TCarbon = New TCarbon(10)
Print oxygen.ToString()+" + "+carbon.ToString()+" results in"
For Local Matter:TMatter = EachIn (oxygen + carbon)
	Print Matter.ToString()
Next
Print

Local water:TWater = New TWater(5)
Print oxygen.ToString()+" + "+water.ToString()+" results in"
For Local Matter:TMatter = EachIn (oxygen + water)
	Print Matter.ToString()
Next
Print

Print hydrogen.ToString()+" + "+oxygen.ToString()+" results in"
For Local Matter:TMatter = EachIn (hydrogen + oxygen)
	Print Matter.ToString()
Next
Print

Print hydrogen.ToString()+" + "+carbon.ToString()+" results in"
For Local Matter:TMatter = EachIn (hydrogen + carbon)
	Print Matter.ToString()
Next
Print
</textarea> <br><br></td></tr></table><br>
<a name="1328020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FireballStarfish</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is, or will there be, a way to overload operators on builtin/primitive types, or on already existing types in general?<br>I am mostly asking because this would be required to make any operators involving them act commutatively. For instance with <pre class=code>Type TTest
	Method Operator+:Int(i:Int)
		' ...
	End Method
End Type</pre> I can define the result of "New TTest() + 1", but what about "1 + New TTest()"? <br><br></td></tr></table><br>
<a name="1328023"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> I doubt that, as this would mean to "lazy load" how things are added.<br><br>For now you know on compilation: "int + int = int", if you now have a source file which overrides this behaviour, this would only be valid for files importing the source file which overrode the behaviour.<br>(excuse this "odd" sentence, not my mother tongue). So some modules use "int + int = int" while you additional files might have changed this.<br><br>For custom types you define the new behaviour right where the type is defined. No problem.<br><br><br>What might be possible is for combinations of "internal + custom" - therefor Brucey would have to create another "definition style" (like "method Operator_Int:+TList()". But somehow this feeld "hacky whacky".<br> <br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1328027"></a>

<a name="1328063"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FireballStarfish</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, it probably shouldn't be possible to override Int + Int, that's just asking for trouble.<br>But if, as you say, there was a way to define an operator "backwards", maybe by creating a method named something like "OperatorReverse+:TTest(i:Int)" in addition to "Operator+:TTest(i:Int), then that would still enforce the custom type being one of the operands. There <i>would</i> be a conflict if two custom types tried to define the same operator on each other (two types T1 and T2 both trying to define T1 + T2); but that could only happen if the two types are visible to each other in the first place, so it wouldn't be possible to accidentally alter the behavior of any already existing code by importing a new source file or module, right? <br><br></td></tr></table><br>
<a name="1328058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about <b>Method Operator+:TType(I:Int) Commutative</b>. With the Commutative keyword, you could have the operands in any order, TType + Int or Int + TType.  Leave off the Commutative keyword and order will be enforce, TType + Int only.<br><br>That is probably over complicating things though, having two checks at each operator might slow things down too much. <br><br></td></tr></table><br>
<a name="1328088"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; That is probably over complicating things though, having two checks at each operator might slow things down too much. <br><br><br>I would prefer to have only the "vice versa" option to go. If someone then "crosses" a previously overloaded operator, the compiler should issue an error.<br><br>WHY?<br>Imagine you wrote that operator overloads for "typeA + int = typeA" in your framework.<br>Now somebody is using your framework and knows "ahh, adding a number to typeA-instances leads to typeA" and writes then "(1 + myTypeA).ToString()". It will fail as it might now be a int instead of typeA.<br><br>So what do I suggest is something in the likes of:<br>(incomplete, at it limits functionality too much)<br>- you overload only "+/-/..." but not ":+" as this should be the same<br>- you overload "a + b" but also "b + a"<br>- if something already was overloaded "b + object" then you cannot do that, or your overload must return a compatible type (eg. in both cases a ":object" or ":TBase")<br><br>Of course you loose the detailed adjustability but you win on "you know what happens". As you then loose the ability to return "matrix_1x3" instead of "matrix_3x1" we could also:<br>- enforce that both "orders" have to be defined (typeA + typeB = typeA -and- typeB + typeA = typeB)<br><br>Nonetheless, having "different return types" depending on the order of arguments is something which should behave consistently over all objects. It will just introduce a lot of headache when not playing with matrices but "other objects". Do not forget: others might not know the return type in your certain scenario (you might have overridden it in an extended object) so they assume "normal behaviour".<br><br><br>Regarding "commutative" - subtracting vectors is not commutative, so it is no "generic" keyword suitable for every object-"concat".<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1328371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FireballStarfish</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another, simpler feature request: could we get overloading support for the unary versions of +, - and ~, as well as for ^?<br>(Curiously, :^ doesn't seem to exist in BlitzMax, but perhaps it could be added?) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
