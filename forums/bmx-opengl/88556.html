<!DOCTYPE html><html lang="en" ><head ><title >openGL Wormily (procedural images/normal maps)</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >openGL Wormily (procedural images/normal maps)</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=103" >OpenGL Module</a>/<a href="#bottom" >openGL Wormily (procedural images/normal maps)</a><br><br>
<a name="1005668"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Welcome to a piece of chaos GL code on my way into understanding the basics of it. I've been bouncing all over the place to wedge myself into the concept, but my stuff is probably shamefully crappy at this point.<br><br>HOWEVER, I've decided to share with you my first baby-steps that were finally plenty of fun for me. <br><br>Should anyone of you notice idiotic stuff in there, worthy of poking me for, please, please, do so! It's literally my first piece of openGL code with great help from FreakForFreedom for loading shaders amongst other tips, but I have not been much of a good student thus far. :}<br><br>No images needed... just save the .vert and .frag somewhere.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.GLMax2D
Import brl.StandardIO
Import brl.random
Import brl.PNGLoader
Import pub.glew

AppTitle="openGL-Wormily (pageup/down tail) (hold 'L'+mousemove light.xy) (hold 'K'+mousemove light.z)"

SetGraphicsDriver GLMax2DDriver()
Global Width:Int =1024
Global Height:Int =768
Graphics (Width,Height,0)
SeedRnd(MilliSecs())
Local image_size:Float = 256
Local hsize:Float = image_size*0.5
Global prod_normals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_HEADnormals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_HEADcolor_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_color_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Local nx:Int = 0
Local ny:Int = 0
Local nz:Int = 0
Local nx2:Int = 0
Local ny2:Int = 0
Local nz2:Int = 0
Local mask:Int = 0
For Local x:Float = 0 Until image_size
	For Local y:Float = 0 Until image_size
	
	Local xp:Float = (x-hsize)/hsize*1.2'*(1.0+0.1*Sin(120+y))
	Local yp:Float = (y-hsize)/hsize
	Local xp2:Float = Abs(xp)-0.5
	If xp&lt;0 Then xp2=-xp2
	Local yp2:Float = (y-(hsize*0.5))/hsize
	Local eye_col:Int = 255
	Local eye:Float= Sqr(xp2*xp2+yp2*yp2)
	If eye&lt;=0.25
		eye:/0.25
		eye_col:*eye^4
		eye = 1.0-eye
		xp2=xp2*(eye*6)+xp*(1.0-eye)
		yp2=yp2*(eye*6)+yp*(1.0-eye)
	Else
	xp2 = xp
	yp2 = yp
		
	End If
	yp = (y-hsize)/hsize
	Local alpha:Float= 1.0-Sqr(xp*xp+yp*yp)
	If alpha &gt; 0 Then 
		eye_col:*alpha
		mask = alpha^2*(3-2*alpha)*55
		alpha = alpha^0.5*255
		
		Local zp:Float = 1.0
		Local zp2:Float = 1.0
		Local dot:Float = Sqr(xp*xp+yp*yp)^0.15
		If dot
			zp = 1.0-Sqr(1.0-dot*dot)/hsize
			dot = 1.0/Sqr(dot)
			xp:*dot
			yp:*-dot
			eye = Sqr(xp2*xp2+yp2*yp2)^0.005
			zp2 = 1.0-Sqr(1.0-eye*eye)/hsize
			xp2:*dot
			yp2:*-dot
		End If
		nx = Int((0.5+0.5*xp)*255)
		ny = Int((0.5+0.5*yp)*255)
		nz = Int((0.5+0.5*zp)*255)
		nx2 = Int((0.5+0.5*xp2)*255)
		ny2 = Int((0.5+0.5*yp2)*255)
		nz2 = Int((0.5+0.5*zp2)*255)
		
	Else 
		alpha = 0
	EndIf
	WritePixel(prod_normals_pix,x,y,(Int(alpha) Shl 24)|(nx Shl 16)|(ny Shl 8)|nz)
	WritePixel(prod_HEADnormals_pix,x,y,(Int(alpha) Shl 24)|(nx2 Shl 16)|(ny2 Shl 8)|nz2)
	WritePixel(prod_HEADcolor_pix,x,y,(Int(alpha) Shl 24)|(Int(eye_col) Shl 16)|(Int(eye_col) Shl 8)|Int(eye_col))
	WritePixel(prod_color_pix,x,y,(mask Shl 24)|$99aacc)
	Next
Next

Global vign_pix:TPixmap = CreatePixmap(Width,Height,PF_RGBA8888)
For Local x:Float = 0 Until Width
	For Local y:Float = 0 Until Height
	Local xp:Float = (x-Width*0.5)/Width*0.5
	Local yp:Float = (y-Height*0.5)/Height*0.5
	Local dot:Float = xp*xp+yp*yp
	If dot
		dot = Sqr(dot)^1.5*255
		If RndFloat()&lt;dot-Floor(dot) Then dot:+1 
	End If
	WritePixel(vign_pix,x,y,(Int(dot) Shl 24)|$100000)
	Next
Next

'======================================================================
'======================================================================
glewInit()
glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glEnable(GL_LIGHT1);
glEnable(GL_NORMALIZE);

Local lmKa:Float[] = [0.0, 0.0, 0.0, 1.0 ]
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmKa)

glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 2.0)
glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 0.0)

Local spot_direction:Float[] = [1.0, -1.0, 0.0]
Local spot_exponent:Int = 10
Local spot_cutoff:Int = 180

glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT0, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT0, GL_SPOT_CUTOFF, spot_cutoff);

glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT1, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT1, GL_SPOT_CUTOFF, spot_cutoff);

Local Kc:Float = 1.0;
Local Kl:Float = 1.0;
Local Kq:Float = 0.0;

glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION,Kc);
glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, Kl);
glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, Kq);

glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION,Kc);
glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, Kl);
glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, Kq);

Local light_pos:Float[] = [0.0, 300.0, 200.0, 1.0];
Local light_Ka:Float[]  = [0.2, 0.2, 0.2, 1.0];
Local light_Kd:Float[]  = [1.0, 1.0, 1.0, 1.0];
Local light_Ks:Float[]  = [1.0, 1.0, 1.0, 1.0];

glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
glLightfv(GL_LIGHT0, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT0, GL_SPECULAR, light_Ks);

light_pos = [3400.0, 0.0, 0.0, 1.0];
light_Ka  = [0.0, 0.0, 0.0, 1.0];
light_Kd  = [0.6, 0.4, 0.0, 1.0];
light_Ks  = [1.0, 0.8, 0.3, 1.0];

glLightfv(GL_LIGHT1, GL_POSITION, light_pos);
glLightfv(GL_LIGHT1, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT1, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT1, GL_SPECULAR, light_Ks);

Local  material_Ka:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Kd:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Ks:Float[] = [0.6, 0.6, 0.7, 1.0]
Local  material_Ke:Float[] = [0.0, 0.0, 0.0, 0.0]
Local material_Se:Float = 50.0;

glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material_Ka);
glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material_Kd);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, material_Ke);
glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, material_Se);

glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 		
glShadeModel(GL_SMOOTH);
If glIsEnabled( GL_TEXTURE_2D )=0 Then
	glEnable( GL_TEXTURE_2D )
EndIf
	
Global g_normaltextureID:Int = loadTexture(prod_HEADnormals_pix)
prod_HEADnormals_pix = Null
Global g_textureID:Int = loadTexture(prod_HEADcolor_pix)
prod_HEADcolor_pix = Null
Global g_normaltextureID2:Int = loadTexture(prod_normals_pix)
prod_normals_pix = Null
Global g_textureID2:Int = loadTexture(prod_color_pix)
prod_color_pix = Null
Global vign_textureID:Int = loadTexture(vign_pix)
vign_pix = Null

Global SHADER_L1:Int = LoadShader("shader_l1.vert", "shader_l1.frag")
glUseProgramObjectARB(SHADER_L1)
Global gl_location_norm:Int		=glGetUniformLocationARB(SHADER_L1, "normalTexture")
Global gl_location_color:Int	=glGetUniformLocationARB(SHADER_L1, "colorTexture")
If gl_location_norm &lt;&gt; -1 Then glUniform1iARB(gl_location_norm, 0)
If gl_location_color &lt;&gt; -1 Then glUniform1iARB(gl_location_color, 1)

Global SHADER_L2:Int = LoadShader("shader_l2.vert", "shader_l2.frag")
glUseProgramObjectARB(SHADER_L2)

Local size:Float = 80
Local halfsize:Float = size*0.5

Local poly:Float[8] 

Local pos:Float[2]
Local rox:Float[2]
Local lpos:Float[] = [640.0,-400.0,-900.0]
Local rot:Float[] = [0.0,1.0]
Local strot:Float[] = [0.0,1.0]
Local mousep:Int[] = [MouseX(),MouseY()]
Local roto:Float =0.0
Local rotoadd:Float =0.0
Local x:Float = 640
Local y:Float = 400
Local velx:Float = 0
Local vely:Float = 0
Local t:Int = 0
Local folcount:Int = 200
Local followx:Float[500]
Local followy:Float[500]
Local foldirx:Float
Local foldiry:Float

glClearColor(0.31,0.30,0.25,1.0)

HideMouse()
While Not KeyHit(KEY_ESCAPE)
	glClear(GL_COLOR_BUFFER_BIT)
	If KeyDown(KEY_L)
		lpos[0]:+MouseX()-mousep[0]
		lpos[1]:-MouseY()-mousep[1]
	
	Else If KeyDown(KEY_K)
		lpos[2]:-MouseY()-mousep[1]
	Else
		rotoadd:-(MouseX()-mousep[0])*0.1
	End If
	If KeyDown(KEY_PAGEUP)
		If folcount&lt;500 Then folcount:+1
	End If
	If KeyDown(KEY_PAGEDOWN)
		If folcount&gt;0 Then folcount:-1
	End If
	If MouseX()&lt;50 Or MouseX()&gt;750 Or MouseY()&lt;50 Or MouseY()&gt;550 Then MoveMouse(400,300)
	mousep = [MouseX(),MouseY()]
	roto:+rotoadd
	rotoadd:*0.8
	rot[0] = Sin(roto)
	rot[1] = Cos(roto)
		velx:-Abs(rot[0]-strot[0])*rot[0]*5
		vely:-Abs(rot[1]-strot[1])*rot[1]*5
	If MouseDown(1)
		velx:-rot[0]*0.5
		vely:-rot[1]*0.5
	End If
	strot[0]=rot[0]
	strot[1]=rot[1]
	x:+velx
	y:+vely
	If x&lt;0 Then velx=-velx;x=0
	If x&gt;Width Then velx=-velx;x=Width
	If y&lt;0 Then vely=-vely;y=0
	If y&gt;Height Then vely=-vely;y=Height
	velx:*0.96
	vely:*0.96
	
	light_pos[0] =lpos[0]
	light_pos[1] =lpos[1]
	light_pos[2] = lpos[2]
	glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
	
	glUseProgramObjectARB( SHADER_L2)
	glNormal3f(1.0,0.0,0.0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, vign_textureID)
	DrawRec(Width,0,Width,Height,0,Height,0,0)
	
	glUseProgramObjectARB( SHADER_L1)
	
 	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID)
	
	material_Ks = [0.6, 0.6, 0.7, 1.0]
	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
	DrawQuad(x, y, roto, size)
	
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID2)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID2)
	
	Local tempx:Float = x
	Local tempy:Float = y
	followx[0]=tempx+rot[0]*10
	followy[0]=tempy+rot[1]*10
	DrawQuad(followx[0], followy[0], t*0.5, size*(0.2+Float(folcount)/(folcount+folcount)))
	For Local f:Int= 1 Until folcount
		tempx= followx[f-1]-followx[f]
		tempy= followy[f-1]-followy[f]
		Local dot:Float = tempx*tempx+tempy*tempy
		If dot
			dot = 1.0/Sqr(dot)*5*Float(folcount-f)/folcount
			foldirx = tempx*dot
			foldiry = tempy*dot
		End If
		followx[f]=followx[f-1]-foldirx
		followy[f]=followy[f-1]-foldiry
		DrawQuad(followx[f], followy[f], t*0.5+f*10, size*(0.2+Float(folcount-f)/(folcount+folcount)))
	Next
	t:-4
	
	glUseProgramObjectARB( SHADER_L2)
	glNormal3f(1.0,0.0,0.0);
	glActiveTexture(GL_TEXTURE0);
	glDisable( GL_TEXTURE_2D )
	GLDrawText folcount,10,10
	Flip 1
Wend
glDeleteTextures(1, Varptr g_textureID)
glDeleteTextures(1, Varptr g_normaltextureID)
glDeleteTextures(1, Varptr g_textureID2)
glDeleteTextures(1, Varptr g_normaltextureID2)
glDeleteTextures(1, Varptr vign_textureID)
glDeleteObjectARB(SHADER_L1)
glDeleteObjectARB(SHADER_L2)
glDisable( GL_TEXTURE_2D )
End

Function DrawRec(x1:Float, y1:Float,x2:Float, y2:Float,x3:Float, y3:Float,x4:Float, y4:Float)
	glBegin GL_QUADS
		glTexCoord2f 0,0
		glVertex2f x1,y1
		
		glTexCoord2f 0,1
		glVertex2f x2,y2
		
		glTexCoord2f 1,1
		glVertex2f x3,y3
		
		glTexCoord2f 1,0
		glVertex2f x4,y4
	glEnd
End Function

Function DrawQuad(x:Float, y:Float, rotation:Float, size:Float)
		size:*0.5
		Local poly:Float[8]
		Local rot:Float[]=[Float(Sin(rotation)),Float(Cos(rotation))]
		Local rox:Float[]=[rot[1], -rot[0]]
		Local pos:Float[]=[x,y]
		
		poly[0] = -size*rot[0]+size*rox[0]
		poly[1] = -size*rot[1]+size*rox[1]
		poly[2] = size*rot[0]+size*rox[0]
		poly[3] = size*rot[1]+size*rox[1]
		poly[4] = size*rot[0]-size*rox[0]
		poly[5] = size*rot[1]-size*rox[1]
		poly[6] = -size*rot[0]-size*rox[0]
		poly[7] = -size*rot[1]-size*rox[1]
		
		poly[0]:+pos[0]
		poly[1]:+pos[1]
		poly[2]:+pos[0]
		poly[3]:+pos[1]
		poly[4]:+pos[0]
		poly[5]:+pos[1]
		poly[6]:+pos[0]
		poly[7]:+pos[1]
	
		glBegin GL_QUADS
			glTexCoord2f 0,0
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[0],poly[1]
			
			glTexCoord2f 0,1
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[2],poly[3]
			
			glTexCoord2f 1,1
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[4],poly[5]
			
			glTexCoord2f 1,0
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[6],poly[7]
		glEnd
End Function

Function loadTexture:Int (image:TPixmap)
	Local texture:Int
	glGenTextures(1, Varptr texture)
	
	glBindTexture(GL_TEXTURE_2D, texture)
	glTexImage2D(GL_TEXTURE_2D, 0, 4, image.Width, image.Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.pixels)
	
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR)
	
	Return texture
End Function

Function loadShader:Int(file:String, file2:String)
   Local ProgramObject:Int
   Local VertexShaderObject:Int
   Local FragmentShaderObject:Int

   ProgramObject=glCreateProgramObjectARB()
   VertexShaderObject   = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
   FragmentShaderObject = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
   
   Local fileStream:TStream=OpenFile(file)
   Local fileStream2:TStream=OpenFile(file2)
   
   Local shaderSrcVertex:Byte[FileSize(file)+1]
   Local i:Int=0
   While Not Eof(fileStream)
      shaderSrcVertex[i] = ReadByte(fileStream)
      i:+1
      If i&gt;FileSize(file) Then i = FileSize(file)
   Wend
   CloseFile(fileStream)
   
   Local pointer:Byte Ptr = Varptr shadersrcVertex[0]
   Local laenge:Int=FileSize(file)
   
   glShaderSourceARB(VertexShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(VertexShaderObject)
   
   debugShader(VertexShaderObject)
      
   Local shaderSrcFragment:Byte[FileSize(file2)+1]
   i=0
   While Not Eof(fileStream2)
      shaderSrcFragment[i] = ReadByte(fileStream2)
      i:+1
      If i&gt;FileSize(file2) Then i = FileSize(file2)
   Wend
   CloseFile(fileStream2)
   
   pointer = Varptr shadersrcFragment[0]
   laenge=FileSize(file2)
   
   glShaderSourceARB(FragmentShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(FragmentShaderObject)
   
   debugShader(FragmentShaderObject)
   
   glAttachObjectARB(ProgramObject, VertexShaderObject)
   glAttachObjectARB(ProgramObject, FragmentShaderObject)

   glDeleteObjectARB(VertexShaderObject)
   glDeleteObjectARB(FragmentShaderObject)

   glLinkProgramARB(ProgramObject);
   
   Return ProgramObject
End Function

Function debugShader(shaderObject:Int)
   Local laengedeslogs:Float
   glGetObjectParameterfvARB(shaderObject,GL_OBJECT_INFO_LOG_LENGTH_ARB,Varptr laengedeslogs)


   Local bytearray:Byte[]=New Byte[laengedeslogs]
   Local laenge23:Int=0
   glGetInfoLogARB(shaderObject, laengedeslogs, Varptr(laenge23), Varptr(bytearray[0]));
   Local msg:String=""
   For Local j:Int=0 To laengedeslogs-1
      msg=msg+ Chr(bytearray[j])
   Next
   DebugLog "ShaderLog: "+msg
End Function
</textarea><br><br>shader_l1.frag<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
varying vec3 N;
varying vec3 v;    
uniform sampler2D normalTexture;
uniform sampler2D colorTexture;

varying vec2 vTexCoord;

void main (void)  
{  
	vec4 color = texture2D(normalTexture, vTexCoord);       
	vec4 colorb = texture2D(colorTexture, vTexCoord); 

	if (color.a == 0.0)
	 discard; 
	vec3 L;
	vec3 E;
	vec3 R;

	vec3 Y = N;
	vec3 X;
	vec3 Z;
	X.x = -Y.y;
	X.y = Y.x;
	X.z = Y.z;
	Z = vec3(Y.y * X.z - Y.z * X.y, Y.z * X.x - Y.x * X.z, Y.x * X.y - Y.y * X.x);

	vec3 NC = vec3(1.0-color.r*2,-1.0+color.g*2,-1.0+color.b*2);

	N.x = NC.x*X.x+ NC.y*Y.x+NC.z*Z.x;
	N.y = NC.x*X.y+ NC.y*Y.y+NC.z*Z.y;
	N.z = NC.x*X.z+ NC.y*Y.z+NC.z*Z.z;

	N = normalize(N);
	v.z= -1000+color.a*10;  
	v.y= -v.y;
	int i = 1;
	for(i=0;i&lt;=1;i++)
	{
		vec3 O = (400.0,300.0,-800);
		
		L = normalize(gl_LightSource[i].position.xyz - v);
		E = normalize(-v-O); // we are in Eye Coordinates, so EyePos is (0,0,0)  
		R = -reflect(L,N);  

		vec4 Iamb = gl_FrontLightProduct[i].ambient;    
		vec4 Idiff = gl_FrontLightProduct[i].diffuse * max(dot(N,L), 0.0); 
		vec4 Ispec = gl_FrontLightProduct[i].specular 
					* pow(max(dot(R,E),0.0),0.3*gl_FrontMaterial.shininess);

		gl_FragColor += colorb* (gl_FrontLightModelProduct.sceneColor + Iamb + Idiff)+ Ispec;
	}
	gl_FragColor.a = colorb.a;
}
</textarea><br>shader_l1.vert<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
varying vec2 vTexCoord;
varying vec3 N;
varying vec3 v;

void main(void) 
{
	vec4 ecPos;
	vec3 aux;

   v = vec3(gl_ModelViewMatrix * gl_Vertex);       
   N = normalize(gl_NormalMatrix * gl_Normal);
  
   vTexCoord = gl_MultiTexCoord0.xy;
   vTexCoord.x = -vTexCoord.x;
   gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}
</textarea><br><br>shader_l2.frag<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
uniform sampler2D colorTexture;
varying vec2 vTexCoord;

void main (void)  
{  
	vec4 colormap = texture2D(colorTexture, vTexCoord); 
	gl_FragColor = colormap;
}
</textarea><br>shader_l2.vert<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
varying vec2 vTexCoord;
varying vec3 v;
void main(void) 
{
   v = vec3(gl_ModelViewMatrix * gl_Vertex);       
   
   vTexCoord = gl_MultiTexCoord0.xy;
   gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}
</textarea> <br><br></td></tr></table><br>
<a name="1005691"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Almost there... I get a few shader compilation errors:<br><br><pre class=code>
DebugLog:ShaderLog: Vertex shader was successfully compiled to run on hardware.
DebugLog:ShaderLog: Fragment shader failed to compile with the following errors:
ERROR: 0:29: error(#164) l-value required assign "N" (can't modify a varying)
ERROR: 0:30: error(#164) l-value required assign "N" (can't modify a varying)
ERROR: 0:31: error(#164) l-value required assign "N" (can't modify a varying)
ERROR: 0:33: error(#164) l-value required assign "N" (can't modify a varying)
ERROR: 0:34: error(#164) l-value required assign "v" (can't modify a varying)
ERROR: 0:35: error(#164) l-value required assign "v" (can't modify a varying)
ERROR: 0:39: error(#160) Cannot convert from 'const int' to '3-component vector of float'
ERROR: error(#273) 7 compilation errors.  No code generated
DebugLog:ShaderLog: Vertex shader was successfully compiled to run on hardware.
DebugLog:ShaderLog: Fragment shader was successfully compiled to run on hardware.
</pre><br><br>Never done GLSL (just a bit of HLSL and GC) but managed to fix it :) Here's the fixed shader_l1.frag:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
varying vec3 N;
varying vec3 v;    
uniform sampler2D normalTexture;
uniform sampler2D colorTexture;

varying vec2 vTexCoord;

void main (void)  
{  
	vec4 color = texture2D(normalTexture, vTexCoord);       
	vec4 colorb = texture2D(colorTexture, vTexCoord); 

	if (color.a == 0.0)
	 discard; 
	vec3 L;
	vec3 E;
	vec3 R;

	vec3 Y = N;
	vec3 X;
	vec3 Z;
	X.x = -Y.y;
	X.y = Y.x;
	X.z = Y.z;
	Z = vec3(Y.y * X.z - Y.z * X.y, Y.z * X.x - Y.x * X.z, Y.x * X.y - Y.y * X.x);

	vec3 NC = vec3(1.0-color.r*2,-1.0+color.g*2,-1.0+color.b*2);

	vec3 N2;
	
	N2.x = NC.x*X.x+ NC.y*Y.x+NC.z*Z.x;
	N2.y = NC.x*X.y+ NC.y*Y.y+NC.z*Z.y;
	N2.z = NC.x*X.z+ NC.y*Y.z+NC.z*Z.z;

	N2 = normalize(N2);
	
	vec3 v2 = v;
	
	v2.z= -1000+color.a*10;  
	v2.y= -v2.y;
	int i = 1;
	for(i=0;i&lt;=1;i++)
	{
		vec3 O = vec3(400.0,300.0,-800.0);
		
		L = normalize(gl_LightSource[i].position.xyz - v2);
		E = normalize(-v2-O); // we are in Eye Coordinates, so EyePos is (0,0,0)  
		R = -reflect(L,N2);  

		vec4 Iamb = gl_FrontLightProduct[i].ambient;    
		vec4 Idiff = gl_FrontLightProduct[i].diffuse * max(dot(N2,L), 0.0); 
		vec4 Ispec = gl_FrontLightProduct[i].specular 
					* pow(max(dot(R,E),0.0),0.3*gl_FrontMaterial.shininess);

		gl_FragColor += colorb* (gl_FrontLightModelProduct.sceneColor + Iamb + Idiff)+ Ispec;
	}
	gl_FragColor.a = colorb.a;
}
</textarea><br><br>This is looking very cool yet very strange :) <br><br></td></tr></table><br>
<a name="1005711"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh man, thanks Andrei! I had no idea, because it simply compiled without complains here, but it actually seems like it wasn't working properly compared to how it looks with your fix. (subtle but important different shows in the specular highlights. They were bothering me before a bit. Now they bother me less...HAHA! I mean, it's all a bit arbitrary, since I just try to "fake" geometry by offsetting the "camera" according to the heightmap as a test. It's mathematical snake-oil to some degree. <br><br>But-Wow-that's weird...? <br>&lt;Why would it have difficulties to compile somewhere else?&gt;<br>&lt;Different versions of openGL or glew or so?&gt; <br>&lt;Fascinating.&gt; <br>But it proofs my point that I appreciate but dislike overloaded operators or how ever that's called. I prefer seeing what I'm doing more clearly.<br><br>Thanks Andrei, that's awesome! And thanks! :)<br><br>Here's a slight variation, but it's really cute, I think! :}<br>(hit 'A' to swallow some air at this point, hehe!)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.GLMax2D
Import brl.StandardIO
Import brl.random
Import brl.PNGLoader
Import pub.glew

AppTitle="openGL-Wormily (pageup/down tail) (hold 'L'+mousemove light.xy) (hold 'K'+mousemove light.z)"

SetGraphicsDriver GLMax2DDriver()
Global Width:Int =1024
Global Height:Int =768
Graphics (Width,Height,0)
SeedRnd(MilliSecs())
Local image_size:Float = 256
Local hsize:Float = image_size*0.5
Global prod_normals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_HEADnormals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_HEADcolor_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_color_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Local nx:Int = 0
Local ny:Int = 0
Local nz:Int = 0
Local nx2:Int = 0
Local ny2:Int = 0
Local nz2:Int = 0
Local mask:Int = 0
For Local x:Float = 0 Until image_size
	For Local y:Float = 0 Until image_size
	
	Local xp:Float = (x-hsize)/hsize*1.3'*(1.0+0.1*Sin(120+y))
	Local yp:Float = (y-hsize)/hsize
	Local xp2:Float = Abs(xp)-0.65
	If xp&lt;0 Then xp2=-xp2
	Local yp2:Float = (y-(hsize*0.5))/hsize
	Local eye_col:Int = 255
	Local eye:Float= Sqr(xp2*xp2+yp2*yp2)
	If eye&lt;=0.25
		eye:/0.25
		eye_col:*eye^4
		eye = 1.0-eye
		xp2=xp2*(eye*6)+xp*(1.0-eye)
		yp2=yp2*(eye*6)+yp*(1.0-eye)
	Else
	xp2 = xp
	yp2 = yp
		
	End If
	yp = (y-hsize)/hsize
	Local alpha:Float= 1.0-Sqr(xp*xp+yp*yp)
	If alpha &gt; 0 Then 
		eye_col:*alpha
		mask = alpha^2*(3-2*alpha)*255
		alpha = alpha^0.5*255
		
		Local zp:Float = 1.0
		Local zp2:Float = 1.0
		Local dot:Float = Sqr(xp*xp+yp*yp)^0.15
		If dot
			zp = 1.0-Sqr(1.0-dot*dot)/hsize
			dot = 1.0/Sqr(dot)
			xp:*dot
			yp:*-dot
			eye = Sqr(xp2*xp2+yp2*yp2)^0.005
			zp2 = 1.0-Sqr(1.0-eye*eye)/hsize
			xp2:*dot
			yp2:*-dot
		End If
		nx = Int((0.5+0.5*xp)*255)
		ny = Int((0.5+0.5*yp)*255)
		nz = Int((0.5+0.5*zp)*255)
		nx2 = Int((0.5+0.5*xp2)*255)
		ny2 = Int((0.5+0.5*yp2)*255)
		nz2 = Int((0.5+0.5*zp2)*255)
		
	Else 
		alpha = 0
	EndIf
	WritePixel(prod_normals_pix,x,y,(Int(alpha) Shl 24)|(nx Shl 16)|(ny Shl 8)|nz)
	WritePixel(prod_HEADnormals_pix,x,y,(Int(alpha) Shl 24)|(nx2 Shl 16)|(ny2 Shl 8)|nz2)
	WritePixel(prod_HEADcolor_pix,x,y,(Int(alpha) Shl 24)|(Int(eye_col) Shl 16)|(Int(eye_col) Shl 8)|Int(eye_col))
	WritePixel(prod_color_pix,x,y,(mask Shl 24)|$696a6c)
	Next
Next

Global vign_pix:TPixmap = CreatePixmap(Width,Height,PF_RGBA8888)
For Local x:Float = 0 Until Width
	For Local y:Float = 0 Until Height
	Local xp:Float = (x-Width*0.5)/Width*0.5
	Local yp:Float = (y-Height*0.5)/Height*0.5
	Local dot:Float = xp*xp+yp*yp
	If dot
		dot = Sqr(dot)^1.5*255
		If RndFloat()&lt;dot-Floor(dot) Then dot:+1 
	End If
	WritePixel(vign_pix,x,y,(Int(dot) Shl 24)|$100000)
	Next
Next

'======================================================================
'======================================================================
glewInit()
glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glEnable(GL_LIGHT1);
glEnable(GL_NORMALIZE);

Local lmKa:Float[] = [0.0, 0.0, 0.0, 1.0 ]
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmKa)

glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 2.0)
glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 0.0)

Local spot_direction:Float[] = [1.0, -1.0, 0.0]
Local spot_exponent:Int = 10
Local spot_cutoff:Int = 180

glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT0, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT0, GL_SPOT_CUTOFF, spot_cutoff);

glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT1, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT1, GL_SPOT_CUTOFF, spot_cutoff);

Local Kc:Float = 1.0;
Local Kl:Float = 1.0;
Local Kq:Float = 0.0;

glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION,Kc);
glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, Kl);
glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, Kq);

glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION,Kc);
glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, Kl);
glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, Kq);

Local light_pos:Float[] = [0.0, 300.0, 200.0, 1.0];
Local light_Ka:Float[]  = [0.2, 0.2, 0.2, 1.0];
Local light_Kd:Float[]  = [1.0, 1.0, 1.0, 1.0];
Local light_Ks:Float[]  = [1.0, 1.0, 1.0, 1.0];

glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
glLightfv(GL_LIGHT0, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT0, GL_SPECULAR, light_Ks);

light_pos = [3400.0, 0.0, 0.0, 1.0];
light_Ka  = [0.0, 0.0, 0.0, 1.0];
light_Kd  = [0.6, 0.4, 0.0, 1.0];
light_Ks  = [1.0, 0.8, 0.3, 1.0];

glLightfv(GL_LIGHT1, GL_POSITION, light_pos);
glLightfv(GL_LIGHT1, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT1, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT1, GL_SPECULAR, light_Ks);

Local  material_Ka:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Kd:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Ks:Float[] = [0.6, 0.6, 0.7, 1.0]
Local  material_Ke:Float[] = [0.0, 0.0, 0.0, 0.0]
Local material_Se:Float = 30.0;

glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material_Ka);
glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material_Kd);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, material_Ke);
glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, material_Se);

glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 		
glShadeModel(GL_SMOOTH);
If glIsEnabled( GL_TEXTURE_2D )=0 Then
	glEnable( GL_TEXTURE_2D )
EndIf
	
Global g_normaltextureID:Int = loadTexture(prod_HEADnormals_pix)
prod_HEADnormals_pix = Null
Global g_textureID:Int = loadTexture(prod_HEADcolor_pix)
prod_HEADcolor_pix = Null
Global g_normaltextureID2:Int = loadTexture(prod_normals_pix)
prod_normals_pix = Null
Global g_textureID2:Int = loadTexture(prod_color_pix)
prod_color_pix = Null
Global vign_textureID:Int = loadTexture(vign_pix)
vign_pix = Null

Global SHADER_L1:Int = LoadShader("shader_l1.vert", "shader_l1.frag")
glUseProgramObjectARB(SHADER_L1)
Global gl_location_norm:Int		=glGetUniformLocationARB(SHADER_L1, "normalTexture")
Global gl_location_color:Int	=glGetUniformLocationARB(SHADER_L1, "colorTexture")
If gl_location_norm &lt;&gt; -1 Then glUniform1iARB(gl_location_norm, 0)
If gl_location_color &lt;&gt; -1 Then glUniform1iARB(gl_location_color, 1)

Global SHADER_L2:Int = LoadShader("shader_l2.vert", "shader_l2.frag")
glUseProgramObjectARB(SHADER_L2)

Local size:Float = 80
Local halfsize:Float = size*0.5

Local poly:Float[8] 

Local pos:Float[2]
Local rox:Float[2]
Local lpos:Float[] = [640.0,-400.0,-900.0]
Local rot:Float[] = [0.0,1.0]
Local strot:Float[] = [0.0,1.0]
Local mousep:Int[] = [MouseX(),MouseY()]
Local roto:Float =0.0
Local rotoadd:Float =0.0
Local x:Float = 640
Local y:Float = 400
Local velx:Float = 0
Local vely:Float = 0
Local folcount:Int = 200
Local followx:Float[500]
Local followy:Float[500]
Local foldirx:Float
Local foldiry:Float
Local t:Int = folcount+20

glClearColor(0.31,0.30,0.25,1.0)

HideMouse()
While Not KeyHit(KEY_ESCAPE)
	glClear(GL_COLOR_BUFFER_BIT)
	If KeyDown(KEY_L)
		lpos[0]:+MouseX()-mousep[0]
		lpos[1]:-MouseY()-mousep[1]
	
	Else If KeyDown(KEY_K)
		lpos[2]:-MouseY()-mousep[1]
	Else
		rotoadd:-(MouseX()-mousep[0])*0.1
	End If
	If KeyHit(KEY_A) Then t = 0
	
	If KeyDown(KEY_PAGEUP)
		If folcount&lt;500 Then folcount:+1
	End If
	If KeyDown(KEY_PAGEDOWN)
		If folcount&gt;0 Then folcount:-1
	End If
	If MouseX()&lt;50 Or MouseX()&gt;750 Or MouseY()&lt;50 Or MouseY()&gt;550 Then MoveMouse(400,300)
	mousep = [MouseX(),MouseY()]
	roto:+rotoadd
	rotoadd:*0.8
	rot[0] = Sin(roto)
	rot[1] = Cos(roto)
		velx:-Abs(rot[0]-strot[0])*rot[0]*5
		vely:-Abs(rot[1]-strot[1])*rot[1]*5
	If MouseDown(1)
		velx:-rot[0]*0.5
		vely:-rot[1]*0.5
	End If
	strot[0]=rot[0]
	strot[1]=rot[1]
	x:+velx
	y:+vely
	If x&lt;0 Then velx=-velx;x=0
	If x&gt;Width Then velx=-velx;x=Width
	If y&lt;0 Then vely=-vely;y=0
	If y&gt;Height Then vely=-vely;y=Height
	velx:*0.96
	vely:*0.96
	
	light_pos[0] =lpos[0]
	light_pos[1] =lpos[1]
	light_pos[2] = lpos[2]
	glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
	
	glUseProgramObjectARB( SHADER_L2)
	glNormal3f(1.0,0.0,0.0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, vign_textureID)
	DrawRec(Width,0,Width,Height,0,Height,0,0)
	
	glUseProgramObjectARB( SHADER_L1)
	
 	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID)
	
	material_Ks = [0.6, 0.6, 0.7, 1.0]
	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, [1.0,1.0,1.0]);
	DrawQuad(x, y, roto, size)
	
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID2)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID2)
	
	Local tempx:Float = x
	Local tempy:Float = y
	followx[0]=tempx+rot[0]*10
	followy[0]=tempy+rot[1]*10
	DrawQuad(followx[0], followy[0], roto, size*(0.2+Float(folcount)/(folcount+folcount)))
	Local snakesize:Float = size
	For Local f:Int= 1 Until folcount
		tempx= followx[f-1]-followx[f]
		tempy= followy[f-1]-followy[f]
		Local dot:Float = tempx*tempx+tempy*tempy
		If dot
			dot = 1.0/Sqr(dot)*5*Float(folcount-f)/folcount
			foldirx = tempx*dot
			foldiry = tempy*dot
		End If
		followx[f]=followx[f-1]-foldirx
		followy[f]=followy[f-1]-foldiry
		If f Mod 10 &gt; 6 
			glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, [0.1,0.1,0.1]);	
		Else
			glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, [1.0,1.0,1.0]);
		End If
		Local temp:Float = 1.0-Abs(f-t)*0.1
		If temp&gt;0 Then snakesize:*1.0+(temp*0.05) Else snakesize=size
		DrawQuad(followx[f], followy[f], roto+f*10, snakesize*(0.2+Float(folcount-f)/(folcount+folcount)))
	Next
	If t &lt; folcount+20 Then t:+1
	
	glUseProgramObjectARB( SHADER_L2)
	glNormal3f(1.0,0.0,0.0);
	glActiveTexture(GL_TEXTURE0);
	glDisable( GL_TEXTURE_2D )
	GLDrawText folcount,10,10
	Flip 1
Wend
glDeleteTextures(1, Varptr g_textureID)
glDeleteTextures(1, Varptr g_normaltextureID)
glDeleteTextures(1, Varptr g_textureID2)
glDeleteTextures(1, Varptr g_normaltextureID2)
glDeleteTextures(1, Varptr vign_textureID)
glDeleteObjectARB(SHADER_L1)
glDeleteObjectARB(SHADER_L2)
glDisable( GL_TEXTURE_2D )
End

Function DrawRec(x1:Float, y1:Float,x2:Float, y2:Float,x3:Float, y3:Float,x4:Float, y4:Float)
	glBegin GL_QUADS
		glTexCoord2f 0,0
		glVertex2f x1,y1
		
		glTexCoord2f 0,1
		glVertex2f x2,y2
		
		glTexCoord2f 1,1
		glVertex2f x3,y3
		
		glTexCoord2f 1,0
		glVertex2f x4,y4
	glEnd
End Function

Function DrawQuad(x:Float, y:Float, rotation:Float, size:Float)
		size:*0.5
		Local poly:Float[8]
		Local rot:Float[]=[Float(Sin(rotation)),Float(Cos(rotation))]
		Local rox:Float[]=[rot[1], -rot[0]]
		Local pos:Float[]=[x,y]
		
		poly[0] = -size*rot[0]+size*rox[0]
		poly[1] = -size*rot[1]+size*rox[1]
		poly[2] = size*rot[0]+size*rox[0]
		poly[3] = size*rot[1]+size*rox[1]
		poly[4] = size*rot[0]-size*rox[0]
		poly[5] = size*rot[1]-size*rox[1]
		poly[6] = -size*rot[0]-size*rox[0]
		poly[7] = -size*rot[1]-size*rox[1]
		
		poly[0]:+pos[0]
		poly[1]:+pos[1]
		poly[2]:+pos[0]
		poly[3]:+pos[1]
		poly[4]:+pos[0]
		poly[5]:+pos[1]
		poly[6]:+pos[0]
		poly[7]:+pos[1]
	
		glBegin GL_QUADS
			glTexCoord2f 0,0
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[0],poly[1]
			
			glTexCoord2f 0,1
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[2],poly[3]
			
			glTexCoord2f 1,1
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[4],poly[5]
			
			glTexCoord2f 1,0
			glNormal3f(-rot[0],rot[1],0);
			glVertex2f poly[6],poly[7]
		glEnd
End Function

Function loadTexture:Int (image:TPixmap)
	Local texture:Int
	glGenTextures(1, Varptr texture)
	
	glBindTexture(GL_TEXTURE_2D, texture)
	glTexImage2D(GL_TEXTURE_2D, 0, 4, image.Width, image.Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.pixels)
	
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR)
	
	Return texture
End Function

Function loadShader:Int(file:String, file2:String)
   Local ProgramObject:Int
   Local VertexShaderObject:Int
   Local FragmentShaderObject:Int

   ProgramObject=glCreateProgramObjectARB()
   VertexShaderObject   = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
   FragmentShaderObject = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
   
   Local fileStream:TStream=OpenFile(file)
   Local fileStream2:TStream=OpenFile(file2)
   
   Local shaderSrcVertex:Byte[FileSize(file)+1]
   Local i:Int=0
   While Not Eof(fileStream)
      shaderSrcVertex[i] = ReadByte(fileStream)
      i:+1
      If i&gt;FileSize(file) Then i = FileSize(file)
   Wend
   CloseFile(fileStream)
   
   Local pointer:Byte Ptr = Varptr shadersrcVertex[0]
   Local laenge:Int=FileSize(file)
   
   glShaderSourceARB(VertexShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(VertexShaderObject)
   
   debugShader(VertexShaderObject)
      
   Local shaderSrcFragment:Byte[FileSize(file2)+1]
   i=0
   While Not Eof(fileStream2)
      shaderSrcFragment[i] = ReadByte(fileStream2)
      i:+1
      If i&gt;FileSize(file2) Then i = FileSize(file2)
   Wend
   CloseFile(fileStream2)
   
   pointer = Varptr shadersrcFragment[0]
   laenge=FileSize(file2)
   
   glShaderSourceARB(FragmentShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(FragmentShaderObject)
   
   debugShader(FragmentShaderObject)
   
   glAttachObjectARB(ProgramObject, VertexShaderObject)
   glAttachObjectARB(ProgramObject, FragmentShaderObject)

   glDeleteObjectARB(VertexShaderObject)
   glDeleteObjectARB(FragmentShaderObject)

   glLinkProgramARB(ProgramObject);
   
   Return ProgramObject
End Function

Function debugShader(shaderObject:Int)
   Local laengedeslogs:Float
   glGetObjectParameterfvARB(shaderObject,GL_OBJECT_INFO_LOG_LENGTH_ARB,Varptr laengedeslogs)


   Local bytearray:Byte[]=New Byte[laengedeslogs]
   Local laenge23:Int=0
   glGetInfoLogARB(shaderObject, laengedeslogs, Varptr(laenge23), Varptr(bytearray[0]));
   Local msg:String=""
   For Local j:Int=0 To laengedeslogs-1
      msg=msg+ Chr(bytearray[j])
   Next
   DebugLog "ShaderLog: "+msg
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1005751"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's really cool! I blame you for much of my time going to waste :D<br><br>Right now I'm busy with other stuff, but soon I'll have to work on a bunch of shaders for my own game and I am going to tear your code apart :)<br><br>Also, after pressing 'A', even though I know it will never happen, I somehow expect something to come out the other end :)) <br><br></td></tr></table><br>
<a name="1005766"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOL, HAHAHAHA, I HAD THE EXACT SAME THOUGHT Already... LOL!<br><br>Well, I'm currently trying to understand blooming. The framebuffer stuff is still chewy to me, since everything's still new to me... &lt;THE PAIN&gt;<br><br>I hope I'll understand and can control it today already.<br><br>(You should see what else I wrote a few hours ago..haha...funny strange stuff. It's a great sandbox already!)<br><br>Oh, by the way, if you have questions about the shaders, ask me! It's all very easy stuff at this point! <br><br></td></tr></table><br>
<a name="1006128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> This thing only runs on my machine, really. I wonder if it makes any sense to use openGL, if it's so fragile? I mean, I'm sure I'm doing 90% wrong of what can be done wrong, but... it's scary and challenging to entertain hope.  :{ <br><br></td></tr></table><br>
<a name="1006147"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> It could help if we knew the specs. Are you using an nVidia card or an ATi? (I suspect nVidia).<br><br>Basically, as long as you steer away from the vendor-specific extensions and make sure your shaders are properly written, you should have no problem. OpenGL runs just fine on Win, Linux and Mac OS X.<br><br>I decided to use OpenGL-only and ditch the support for DirectX for now as I'm using lots of low-level stuff, and the last thing I want right now is copy the code 3 times (OGL, DX7, DX9). So I'm just using the one that's cross-platform: OpenGL.<br><br>I am aware that particularly ATi and Intel video cards have lower performance in OpenGL than DX9 and DX7 (Intel), but I'm counting on my optimization skills for now. It's true that I'm not using shaders yet, but so far, I didn't experience any corruption/error even on a VIA Chrome 9 video card which is about as bad as I have personally ever seen. Even though it has shader 2.0 support, it runs at about 40 fps drawing 4 1024x1024 alphablended images. There's no way I can make my game playable on that. Still, there's no errors.<br><br>So, if you're having problems it's because you don't know how to do everything the right way. I remember when I first played with shaders and they ran flawlessly on my ATi card. Then I though I'd test them on my secondary card (nVidia). Surprise! Everything was corrupted (and I mean everything... both pixel and vertex shaders). Just to later find out that I was lucky that my shader ran well, because I was doing lots of fishy stuff.<br><br>Regarding shaders, you could use a proper shader editor and look for errors/warnings. Particularly warnings. It's those that make it run on one setup, but not another.<br><br>Also, if you need help testing (or perhaps coding shaders), I'll happily provide it. :) <br><br></td></tr></table><br>
<a name="1006152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Andrei! I think as soon as I have my code run on my intel mobile gfx board on the laptop, I'll be perfectly thrilled! I'm worried that it doesn't support the GLSL shader stuff, uhm, rather simply "shader stuff".<br><br>It's a tough ride for me, that's for sure. Approaching GL from scratch appears to be a rather complex set of challenges/knowledge-requirement.<br><br>What turned me down a little bit was that I didn't even get Grover's stuff to run on the laptop. Tough to stay encouraged.<br><br>I'm not giving up, though, that's for sure!<br><br>Oddly enough, there are still a lot of very basic system related programming things I havn't dealt with properly. I neatly skipped straight into what I know and manage to accomplish a few pretty things, but when it comes to error checking and throwing exceptions, haha, I'm the ball and not the pitcher. :D<br><br>So, yeah, any little piece of code that inches me towards getting it by example will be a giant boost, that's for sure. I've always learned by understanding what I'm looking at and not teaching myself the theory. Reverse engineering is my way of leaping forward. Sometimes there are some low overhangs though on which I bang my head so hard, in knocks me out, so to say... LOL.<br><br>Eitherway, any help is always BIG TIME appreciated! I'm thrilled to gain control over this, because even now I can feel what's possible and create these little glimpses into it. <br><br></td></tr></table><br>
<a name="1006167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> For example, here's the most primitiv version of how I'm approaching the GLSL use. It's not too thoughtful, that's for sure, but it gets the general idea across...<br><br>And I mean an idea about all the mistakes I'm making!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.GLMax2D
Import pub.glew

AppTitle="openGL-super primitiv shader approach"

SetGraphicsDriver GLMax2DDriver()
Global Width:Int =	800
Global Height:Int =	600
GLGraphics (Width,Height,0)
glewInit()

glMatrixMode (GL_PROJECTION)
glLoadIdentity ()

glOrtho (0, Width, Height, 0, -10, 1000)
glDisable(GL_DEPTH_TEST)
glMatrixMode (GL_MODELVIEW)
glLoadIdentity()
'glTranslatef(0.375, 0.375, 0)

'========== shader VERT
Global sourceShader_vert:String 
sourceShader_vert = "varying vec2 vTexCoord;"
sourceShader_vert :+"varying vec3 N;"
sourceShader_vert :+"varying vec3 v;"
sourceShader_vert :+"void main(void) {"
sourceShader_vert :+"	vec4 ecPos;"
sourceShader_vert :+"	vec3 aux;"
sourceShader_vert :+"	v = vec3(gl_ModelViewMatrix * gl_Vertex);"
sourceShader_vert :+"	N = normalize(gl_NormalMatrix * gl_Normal);"
sourceShader_vert :+"	vTexCoord = gl_MultiTexCoord0.xy;"
sourceShader_vert :+"	vTexCoord.x = -vTexCoord.x;"
sourceShader_vert :+"	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;}"

'========== shader FRAG
Global sourceShader_frag:String 
sourceShader_frag = "varying vec3 N;"
sourceShader_frag :+"varying vec3 v;"
sourceShader_frag :+"uniform sampler2D normalTexture;"
sourceShader_frag :+"uniform sampler2D colorTexture;"
sourceShader_frag :+"varying vec2 vTexCoord;"
sourceShader_frag :+"void main (void){"
sourceShader_frag :+"	vec4 normals = texture2D(normalTexture, vTexCoord);"
sourceShader_frag :+"	vec4 color = texture2D(colorTexture, vTexCoord);"
sourceShader_frag :+"	if (normals.a == 0.0)"
sourceShader_frag :+"	 discard;"
sourceShader_frag :+"	vec3 L;"
sourceShader_frag :+"	vec3 E;"
sourceShader_frag :+"	vec3 R;"
sourceShader_frag :+"	vec3 Y = N;"
sourceShader_frag :+"	vec3 X;"
sourceShader_frag :+"	vec3 Z;"
sourceShader_frag :+"	X.x = -Y.y;"
sourceShader_frag :+"	X.y = Y.x;"
sourceShader_frag :+"	X.z = Y.z;"
sourceShader_frag :+"	Z = vec3(Y.y * X.z - Y.z * X.y, Y.z * X.x - Y.x * X.z, Y.x * X.y - Y.y * X.x);"
sourceShader_frag :+"	vec3 NC = vec3(1.0-normals.r*2,-1.0+normals.g*2,-1.0+normals.b*2);"
sourceShader_frag :+"	vec3 N2;"
sourceShader_frag :+"	N2.x = NC.x*X.x+ NC.y*Y.x+NC.z*Z.x;"
sourceShader_frag :+"	N2.y = NC.x*X.y+ NC.y*Y.y+NC.z*Z.y;"
sourceShader_frag :+"	N2.z = -1.0+normals.b*2;"
sourceShader_frag :+"	N2 = normalize(N2);"
sourceShader_frag :+"	vec3 v2 = v;"
sourceShader_frag :+"	v2.z= -1000+normals.a*10.0;"
sourceShader_frag :+"	v2.y= -v2.y;"
sourceShader_frag :+"		vec3 O = vec3(400.0,300.0,-800.0);"
sourceShader_frag :+"		L = normalize(gl_LightSource[0].position.xyz - v2);"
sourceShader_frag :+"		E = normalize(-v2-O);"
sourceShader_frag :+"		R = -(2 * dot(N2,-L)*N2+L);"
sourceShader_frag :+"		vec4 Iamb = gl_FrontLightProduct[0].ambient;"
sourceShader_frag :+"		vec4 Idiff = gl_FrontLightProduct[0].diffuse * max(dot(N2,L), 0.0);"
sourceShader_frag :+"		vec4 Ispec = gl_FrontLightProduct[0].specular"
sourceShader_frag :+"					* pow(max(dot(R,E),0.0),0.3*gl_FrontMaterial.shininess);"
sourceShader_frag :+"		gl_FragColor += color* (gl_FrontLightModelProduct.sceneColor + Iamb + Idiff)+ Ispec;"
sourceShader_frag :+"	gl_FragColor.a = color.a;"
sourceShader_frag :+"}"

Local image_size:Float = 128
Local hsize:Float = image_size*0.5
Global prod_normals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_color_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Local nx:Int = 0
Local ny:Int = 0
Local nz:Int = 0
Local mask:Float = 0
For Local x:Float = 0 Until image_size
	For Local y:Float = 0 Until image_size
	
	Local xp:Float = (x-hsize)/hsize
	Local yp:Float = (y-hsize)/hsize
	Local alpha:Float= 1.0-Sqr(xp*xp+yp*yp)
	If alpha &gt; 0 Then 
		alpha = alpha^0.5*255
		
		mask = alpha/64
		If mask&gt;1.0 Then mask=1
		mask = mask^2*255	
		
		Local zp:Float = 1.0
		Local dot:Float = Sqr(xp*xp+yp*yp)^0.15
		If dot
			zp = 1.0-Sqr(1.0-dot*dot)/hsize
			dot = 1.0/Sqr(dot)
			xp:*dot
			yp:*-dot
		End If
		nx = Int((0.5+0.5*xp)*255)
		ny = Int((0.5+0.5*yp)*255)
		nz = Int((0.5+0.5*zp)*255)
	Else 
		alpha = 0
		mask = 0
	EndIf
	WritePixel(prod_normals_pix,x,y,(Int(alpha) Shl 24)|(nx Shl 16)|(ny Shl 8)|nz)
	WritePixel(prod_color_pix,x,y,Int(mask) Shl 24|$335566)
	Next
Next

'------------- SETUP Lighting

glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glEnable(GL_NORMALIZE);

Local lmKa:Float[] = [0.0, 0.0, 0.0, 1.0 ]
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmKa)
glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 2.0)
glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 0.0)

Local spot_direction:Float[] = [0.0, 0.0, -1.0]
Local spot_exponent:Int = 10
Local spot_cutoff:Int = 180

glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT0, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT0, GL_SPOT_CUTOFF, spot_cutoff);

glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION,1.0);
glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 1.0);
glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.0);

Local light_pos:Float[] = [Float(Width*0.5), -Float(Height*0.5), -500.0, 1.0];
Local light_Ka:Float[]  = [0.2, 0.2, 0.2, 1.0];
Local light_Kd:Float[]  = [1.0, 1.0, 1.0, 1.0];
Local light_Ks:Float[]  = [1.0, 1.0, 1.0, 1.0];

glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
glLightfv(GL_LIGHT0, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT0, GL_SPECULAR, light_Ks);

Local  material_Ka:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Kd:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Ks:Float[] = [0.6, 0.6, 0.7, 1.0]
Local  material_Ke:Float[] = [0.0, 0.0, 0.0, 0.0]

glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material_Ka);
glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material_Kd);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, material_Ke);
glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 30);

' ------------- setup alpha blending

glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
		
' ------------- setup textures &amp; shader
If Not glIsEnabled( GL_TEXTURE_2D ) Then glEnable( GL_TEXTURE_2D )

Global g_normaltextureID:Int = loadTexture(prod_normals_pix)
prod_normals_pix = Null
Global g_textureID:Int = loadTexture(prod_color_pix)
prod_color_pix = Null
	
Global SHADER_L1:Int = LoadShader(sourceShader_vert, sourceShader_frag)
glUseProgramObjectARB(SHADER_L1)
Global gl_location_norm:Int		=glGetUniformLocationARB(SHADER_L1, "normalTexture")
If gl_location_norm &lt;&gt; -1 Then glUniform1iARB(gl_location_norm, 0)
Global gl_location_color:Int	=glGetUniformLocationARB(SHADER_L1, "colorTexture")
If gl_location_color &lt;&gt; -1 Then glUniform1iARB(gl_location_color, 1)


glClearColor(0.31,0.30,0.25,1.0)
HideMouse()
While Not KeyHit(KEY_ESCAPE)
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	
	glUseProgramObjectARB( SHADER_L1)
	
 	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID)
	
	DrawQuad(MouseX(), MouseY(), 0, 0, 64)
	Flip 0
Wend
ShowMouse()
glDeleteTextures(1, Varptr g_textureID)
glDeleteTextures(1, Varptr g_normaltextureID)
glDeleteObjectARB(SHADER_L1)
glDisable( GL_TEXTURE_2D )
End




' ------------- FUNCTIONS
' openGL draw functions
Function DrawQuad(x:Float, y:Float, z:Float, rotation:Float, size:Float)
	size:*0.5
	Local poly:Float[8]
	Local rot:Float[]=[Float(Sin(rotation)),Float(Cos(rotation))]
	Local rox:Float[]=[rot[1], -rot[0]]
	Local pos:Float[]=[x,y]
	
	poly[0] = -size*rot[0]+size*rox[0]
	poly[1] = -size*rot[1]+size*rox[1]
	poly[2] = size*rot[0]+size*rox[0]
	poly[3] = size*rot[1]+size*rox[1]
	poly[4] = size*rot[0]-size*rox[0]
	poly[5] = size*rot[1]-size*rox[1]
	poly[6] = -size*rot[0]-size*rox[0]
	poly[7] = -size*rot[1]-size*rox[1]
	
	poly[0]:+pos[0]
	poly[1]:+pos[1]
	poly[2]:+pos[0]
	poly[3]:+pos[1]
	poly[4]:+pos[0]
	poly[5]:+pos[1]
	poly[6]:+pos[0]
	poly[7]:+pos[1]
	
	glBegin GL_QUADS
		glTexCoord2f 0,0
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[0],poly[1],z
		
		glTexCoord2f 0,1
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[2],poly[3],z
		
		glTexCoord2f 1,1
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[4],poly[5],z
		
		glTexCoord2f 1,0
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[6],poly[7],z
	glEnd
End Function

' openGL setup functions
Function loadTexture:Int (image:TPixmap)
	Local texture:Int
	glGenTextures(1, Varptr texture)
	
	glBindTexture(GL_TEXTURE_2D, texture)
	glTexImage2D(GL_TEXTURE_2D, 0, 4, image.Width, image.Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.pixels)
	
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR)
	
	Return texture
End Function

Function loadShader:Int(file:String, file2:String)
   Local ProgramObject:Int
   Local VertexShaderObject:Int
   Local FragmentShaderObject:Int
   ProgramObject=glCreateProgramObjectARB()
   VertexShaderObject   = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
   FragmentShaderObject = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

   Local pointer:Byte Ptr = file.ToCString()
   Local laenge:Int=file.Length
   
   glShaderSourceARB(VertexShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(VertexShaderObject)
   
   debugShader(VertexShaderObject)
   
   pointer 	= file2.ToCString()
   laenge	= file2.Length
   
   glShaderSourceARB(FragmentShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(FragmentShaderObject)
   
   debugShader(FragmentShaderObject)
   
   glAttachObjectARB(ProgramObject, VertexShaderObject)
   glAttachObjectARB(ProgramObject, FragmentShaderObject)

   glDeleteObjectARB(VertexShaderObject)
   glDeleteObjectARB(FragmentShaderObject)

   glLinkProgramARB(ProgramObject);
   
   Return ProgramObject
End Function

Function debugShader(shaderObject:Int)
   Local laengedeslogs:Float
   glGetObjectParameterfvARB(shaderObject,GL_OBJECT_INFO_LOG_LENGTH_ARB,Varptr laengedeslogs)


   Local bytearray:Byte[]=New Byte[laengedeslogs]
   Local laenge23:Int=0
   glGetInfoLogARB(shaderObject, laengedeslogs, Varptr(laenge23), Varptr(bytearray[0]));
   Local msg:String=""
   For Local j:Int=0 To laengedeslogs-1
      msg=msg+ Chr(bytearray[j])
   Next
   DebugLog "ShaderLog: "+msg
End Function

</textarea><br><br>or a bit more fun version...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.GLMax2D
Import pub.glew

AppTitle="openGL-super primitiv shader approach"

SetGraphicsDriver GLMax2DDriver()
Global Width:Int =	800
Global Height:Int =	600
GLGraphics (Width,Height,0)
glewInit()

glMatrixMode (GL_PROJECTION)
glLoadIdentity ()

glOrtho (0, Width, Height, 0, -10, 1000)
glDisable(GL_DEPTH_TEST)
glMatrixMode (GL_MODELVIEW)
glLoadIdentity()
'glTranslatef(0.375, 0.375, 0)

'========== shader VERT
Global sourceShader_vert:String 
sourceShader_vert = "varying vec2 vTexCoord;"
sourceShader_vert :+"varying vec3 N;"
sourceShader_vert :+"varying vec3 v;"
sourceShader_vert :+"void main(void) {"
sourceShader_vert :+"	vec4 ecPos;"
sourceShader_vert :+"	vec3 aux;"
sourceShader_vert :+"	v = vec3(gl_ModelViewMatrix * gl_Vertex);"
sourceShader_vert :+"	N = normalize(gl_NormalMatrix * gl_Normal);"
sourceShader_vert :+"	vTexCoord = gl_MultiTexCoord0.xy;"
sourceShader_vert :+"	vTexCoord.x = -vTexCoord.x;"
sourceShader_vert :+"	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;}"

'========== shader FRAG
Global sourceShader_frag:String 
sourceShader_frag = "varying vec3 N;"
sourceShader_frag :+"varying vec3 v;"
sourceShader_frag :+"uniform sampler2D normalTexture;"
sourceShader_frag :+"uniform sampler2D colorTexture;"
sourceShader_frag :+"varying vec2 vTexCoord;"
sourceShader_frag :+"void main (void){"
sourceShader_frag :+"	vec4 normals = texture2D(normalTexture, vTexCoord);"
sourceShader_frag :+"	vec4 color = texture2D(colorTexture, vTexCoord);"
sourceShader_frag :+"	if (normals.a == 0.0)"
sourceShader_frag :+"	 discard;"
sourceShader_frag :+"	vec3 L;"
sourceShader_frag :+"	vec3 E;"
sourceShader_frag :+"	vec3 R;"
sourceShader_frag :+"	vec3 Y = N;"
sourceShader_frag :+"	vec3 X;"
sourceShader_frag :+"	vec3 Z;"
sourceShader_frag :+"	X.x = -Y.y;"
sourceShader_frag :+"	X.y = Y.x;"
sourceShader_frag :+"	X.z = Y.z;"
sourceShader_frag :+"	Z = vec3(Y.y * X.z - Y.z * X.y, Y.z * X.x - Y.x * X.z, Y.x * X.y - Y.y * X.x);"
sourceShader_frag :+"	vec3 NC = vec3(1.0-normals.r*2,-1.0+normals.g*2,-1.0+normals.b*2);"
sourceShader_frag :+"	vec3 N2;"
sourceShader_frag :+"	N2.x = NC.x*X.x+ NC.y*Y.x+NC.z*Z.x;"
sourceShader_frag :+"	N2.y = NC.x*X.y+ NC.y*Y.y+NC.z*Z.y;"
sourceShader_frag :+"	N2.z = -1.0+normals.b*2;"
sourceShader_frag :+"	N2 = normalize(N2);"
sourceShader_frag :+"	vec3 v2 = v;"
sourceShader_frag :+"	v2.z= -1000+normals.a*10.0;"
sourceShader_frag :+"	v2.y= -v2.y;"
sourceShader_frag :+"		vec3 O = vec3(400.0,300.0,-800.0);"
sourceShader_frag :+"		L = normalize(gl_LightSource[0].position.xyz - v2);"
sourceShader_frag :+"		E = normalize(-v2-O);"
sourceShader_frag :+"		R = -(2 * dot(N2,-L)*N2+L);"
sourceShader_frag :+"		vec4 Iamb = gl_FrontLightProduct[0].ambient;"
sourceShader_frag :+"		vec4 Idiff = gl_FrontLightProduct[0].diffuse * max(dot(N2,L), 0.0);"
sourceShader_frag :+"		vec4 Ispec = gl_FrontLightProduct[0].specular"
sourceShader_frag :+"					* pow(max(dot(R,E),0.0),0.3*gl_FrontMaterial.shininess);"
sourceShader_frag :+"		gl_FragColor += color* (gl_FrontLightModelProduct.sceneColor + Iamb + Idiff)+ Ispec;"
sourceShader_frag :+"	gl_FragColor.a = color.a;"
sourceShader_frag :+"}"

Local image_size:Float = 128
Local hsize:Float = image_size*0.5
Global prod_normals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_color_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Local nx:Int = 0
Local ny:Int = 0
Local nz:Int = 0
Local mask:Float = 0
For Local x:Float = 0 Until image_size
	For Local y:Float = 0 Until image_size
	
	Local xp:Float = (x-hsize)/hsize
	Local yp:Float = (y-hsize)/hsize
	Local alpha:Float= 1.0-Sqr(xp*xp+yp*yp)
	If alpha &gt; 0 Then 
		alpha = alpha^0.5*255
		
		mask = alpha/255
		If mask&gt;1.0 Then mask=1
		mask = mask^2*255	
		
		Local zp:Float = 1.0
		Local dot:Float = Sqr(xp*xp+yp*yp)^0.15
		If dot
			zp = 1.0-Sqr(1.0-dot*dot)/hsize
			dot = 1.0/Sqr(dot)
			xp:*dot
			yp:*-dot
		End If
		nx = Int((0.5+0.5*xp)*255)
		ny = Int((0.5+0.5*yp)*255)
		nz = Int((0.5+0.5*zp)*255)
	Else 
		alpha = 0
		mask = 0
	EndIf
	WritePixel(prod_normals_pix,x,y,(Int(alpha) Shl 24)|(nx Shl 16)|(ny Shl 8)|nz)
	WritePixel(prod_color_pix,x,y,Int(mask) Shl 24|$335566)
	Next
Next

'------------- SETUP Lighting

glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glEnable(GL_NORMALIZE);

Local lmKa:Float[] = [0.0, 0.0, 0.0, 1.0 ]
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmKa)
glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 2.0)
glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 0.0)

Local spot_direction:Float[] = [0.0, 0.0, -1.0]
Local spot_exponent:Int = 10
Local spot_cutoff:Int = 180

glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT0, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT0, GL_SPOT_CUTOFF, spot_cutoff);

glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION,1.0);
glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 1.0);
glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.0);

Local light_pos:Float[] = [Float(Width*0.5), -Float(Height*0.5), -500.0, 1.0];
Local light_Ka:Float[]  = [0.2, 0.2, 0.2, 1.0];
Local light_Kd:Float[]  = [1.0, 1.0, 1.0, 1.0];
Local light_Ks:Float[]  = [1.0, 1.0, 1.0, 1.0];

glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
glLightfv(GL_LIGHT0, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT0, GL_SPECULAR, light_Ks);

Local  material_Ka:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Kd:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Ks:Float[] = [0.6, 0.6, 0.7, 1.0]
Local  material_Ke:Float[] = [0.0, 0.0, 0.0, 0.0]

glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material_Ka);
glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material_Kd);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, material_Ke);
glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 10);

' ------------- setup alpha blending

glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
		
' ------------- setup textures &amp; shader
If Not glIsEnabled( GL_TEXTURE_2D ) Then glEnable( GL_TEXTURE_2D )

Global g_normaltextureID:Int = loadTexture(prod_normals_pix)
prod_normals_pix = Null
Global g_textureID:Int = loadTexture(prod_color_pix)
prod_color_pix = Null
	
Global SHADER_L1:Int = LoadShader(sourceShader_vert, sourceShader_frag)
glUseProgramObjectARB(SHADER_L1)
Global gl_location_norm:Int		=glGetUniformLocationARB(SHADER_L1, "normalTexture")
If gl_location_norm &lt;&gt; -1 Then glUniform1iARB(gl_location_norm, 0)
Global gl_location_color:Int	=glGetUniformLocationARB(SHADER_L1, "colorTexture")
If gl_location_color &lt;&gt; -1 Then glUniform1iARB(gl_location_color, 1)

Global num:Int = 500
Global xbuf:Float[num]
Global ybuf:Float[num]

glClearColor(0.31,0.30,0.25,1.0)
While Not KeyHit(KEY_ESCAPE)
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	
	glUseProgramObjectARB( SHADER_L1)
	
 	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID)
	
	If MouseDown(1)
		xbuf[0] = MouseX()
		ybuf[0] = MouseY()
		DrawQuad(xbuf[0], ybuf[0], 0, 0, 64)
	End If
	For Local i:Int = 1 Until num
		xbuf[num-i]=xbuf[num-i-1]
		ybuf[num-i]=ybuf[num-i-1]
		DrawQuad(xbuf[i], ybuf[i], 0, 0, 64*(1.0-Float(i)/500))
	Next
	Flip 0
Wend
glDeleteTextures(1, Varptr g_textureID)
glDeleteTextures(1, Varptr g_normaltextureID)
glDeleteObjectARB(SHADER_L1)
glDisable( GL_TEXTURE_2D )
End




' ------------- FUNCTIONS
' openGL draw functions
Function DrawQuad(x:Float, y:Float, z:Float, rotation:Float, size:Float)
	size:*0.5
	Local poly:Float[8]
	Local rot:Float[]=[Float(Sin(rotation)),Float(Cos(rotation))]
	Local rox:Float[]=[rot[1], -rot[0]]
	Local pos:Float[]=[x,y]
	
	poly[0] = -size*rot[0]+size*rox[0]
	poly[1] = -size*rot[1]+size*rox[1]
	poly[2] = size*rot[0]+size*rox[0]
	poly[3] = size*rot[1]+size*rox[1]
	poly[4] = size*rot[0]-size*rox[0]
	poly[5] = size*rot[1]-size*rox[1]
	poly[6] = -size*rot[0]-size*rox[0]
	poly[7] = -size*rot[1]-size*rox[1]
	
	poly[0]:+pos[0]
	poly[1]:+pos[1]
	poly[2]:+pos[0]
	poly[3]:+pos[1]
	poly[4]:+pos[0]
	poly[5]:+pos[1]
	poly[6]:+pos[0]
	poly[7]:+pos[1]
	
	glBegin GL_QUADS
		glTexCoord2f 0,0
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[0],poly[1],z
		
		glTexCoord2f 0,1
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[2],poly[3],z
		
		glTexCoord2f 1,1
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[4],poly[5],z
		
		glTexCoord2f 1,0
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[6],poly[7],z
	glEnd
End Function

' openGL setup functions
Function loadTexture:Int (image:TPixmap)
	Local texture:Int
	glGenTextures(1, Varptr texture)
	
	glBindTexture(GL_TEXTURE_2D, texture)
	glTexImage2D(GL_TEXTURE_2D, 0, 4, image.Width, image.Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.pixels)
	
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR)
	
	Return texture
End Function

Function loadShader:Int(file:String, file2:String)
   Local ProgramObject:Int
   Local VertexShaderObject:Int
   Local FragmentShaderObject:Int
   ProgramObject=glCreateProgramObjectARB()
   VertexShaderObject   = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
   FragmentShaderObject = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

   Local pointer:Byte Ptr = file.ToCString()
   Local laenge:Int=file.Length
   
   glShaderSourceARB(VertexShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(VertexShaderObject)
   
   debugShader(VertexShaderObject)
   
   pointer 	= file2.ToCString()
   laenge	= file2.Length
   
   glShaderSourceARB(FragmentShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(FragmentShaderObject)
   
   debugShader(FragmentShaderObject)
   
   glAttachObjectARB(ProgramObject, VertexShaderObject)
   glAttachObjectARB(ProgramObject, FragmentShaderObject)

   glDeleteObjectARB(VertexShaderObject)
   glDeleteObjectARB(FragmentShaderObject)

   glLinkProgramARB(ProgramObject);
   
   Return ProgramObject
End Function

Function debugShader(shaderObject:Int)
   Local laengedeslogs:Float
   glGetObjectParameterfvARB(shaderObject,GL_OBJECT_INFO_LOG_LENGTH_ARB,Varptr laengedeslogs)


   Local bytearray:Byte[]=New Byte[laengedeslogs]
   Local laenge23:Int=0
   glGetInfoLogARB(shaderObject, laengedeslogs, Varptr(laenge23), Varptr(bytearray[0]));
   Local msg:String=""
   For Local j:Int=0 To laengedeslogs-1
      msg=msg+ Chr(bytearray[j])
   Next
   DebugLog "ShaderLog: "+msg
End Function

</textarea><br><br>or even wilder... kind of modern art! (I'm digressing, I know!)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.GLMax2D
Import pub.glew

AppTitle="openGL-super primitiv shader approach"

SetGraphicsDriver GLMax2DDriver()
Global Width:Int =	800
Global Height:Int =	600
GLGraphics (Width,Height,0)
glewInit()

glMatrixMode (GL_PROJECTION)
glLoadIdentity ()

glOrtho (0, Width, Height, 0, -10, 1000)
glDisable(GL_DEPTH_TEST)
glMatrixMode (GL_MODELVIEW)
glLoadIdentity()
'glTranslatef(0.375, 0.375, 0)

'========== shader VERT
Global sourceShader_vert:String 
sourceShader_vert = "varying vec2 vTexCoord;"
sourceShader_vert :+"varying vec3 N;"
sourceShader_vert :+"varying vec3 v;"
sourceShader_vert :+"void main(void) {"
sourceShader_vert :+"	vec4 ecPos;"
sourceShader_vert :+"	vec3 aux;"
sourceShader_vert :+"	v = vec3(gl_ModelViewMatrix * gl_Vertex);"
sourceShader_vert :+"	N = normalize(gl_NormalMatrix * gl_Normal);"
sourceShader_vert :+"	vTexCoord = gl_MultiTexCoord0.xy;"
sourceShader_vert :+"	vTexCoord.x = -vTexCoord.x;"
sourceShader_vert :+"	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;}"

'========== shader FRAG
Global sourceShader_frag:String 
sourceShader_frag = "varying vec3 N;"
sourceShader_frag :+"varying vec3 v;"
sourceShader_frag :+"uniform sampler2D normalTexture;"
sourceShader_frag :+"uniform sampler2D colorTexture;"
sourceShader_frag :+"varying vec2 vTexCoord;"
sourceShader_frag :+"void main (void){"
sourceShader_frag :+"	vec4 normals = texture2D(normalTexture, vTexCoord);"
sourceShader_frag :+"	vec4 color = texture2D(colorTexture, vTexCoord);"
sourceShader_frag :+"	if (normals.a == 0.0)"
sourceShader_frag :+"	 discard;"
sourceShader_frag :+"	vec3 L;"
sourceShader_frag :+"	vec3 E;"
sourceShader_frag :+"	vec3 R;"
sourceShader_frag :+"	vec3 Y = N;"
sourceShader_frag :+"	vec3 X;"
sourceShader_frag :+"	vec3 Z;"
sourceShader_frag :+"	X.x = -Y.y;"
sourceShader_frag :+"	X.y = Y.x;"
sourceShader_frag :+"	X.z = Y.z;"
sourceShader_frag :+"	Z = vec3(Y.y * X.z - Y.z * X.y, Y.z * X.x - Y.x * X.z, Y.x * X.y - Y.y * X.x);"
sourceShader_frag :+"	vec3 NC = vec3(1.0-normals.r*2,-1.0+normals.g*2,-1.0+normals.b*2);"
sourceShader_frag :+"	vec3 N2;"
sourceShader_frag :+"	N2.x = NC.x*X.x+ NC.y*Y.x+NC.z*Z.x;"
sourceShader_frag :+"	N2.y = NC.x*X.y+ NC.y*Y.y+NC.z*Z.y;"
sourceShader_frag :+"	N2.z = -1.0+normals.b*2;"
sourceShader_frag :+"	N2 = normalize(N2);"
sourceShader_frag :+"	vec3 v2 = v;"
sourceShader_frag :+"	v2.z= -1000+normals.a*10.0;"
sourceShader_frag :+"	v2.y= -v2.y;"
sourceShader_frag :+"		vec3 O = vec3(400.0,300.0,-800.0);"
sourceShader_frag :+"		L = normalize(gl_LightSource[0].position.xyz - v2);"
sourceShader_frag :+"		E = normalize(-v2-O);"
sourceShader_frag :+"		R = -(2 * dot(N2,-L)*N2+L);"
sourceShader_frag :+"		vec4 Iamb = gl_FrontLightProduct[0].ambient;"
sourceShader_frag :+"		vec4 Idiff = gl_FrontLightProduct[0].diffuse * max(dot(N2,L), 0.0);"
sourceShader_frag :+"		vec4 Ispec = gl_FrontLightProduct[0].specular"
sourceShader_frag :+"					* pow(max(dot(R,E),0.0),0.3*gl_FrontMaterial.shininess);"
sourceShader_frag :+"		gl_FragColor += color* (gl_FrontLightModelProduct.sceneColor + Iamb + Idiff)+ Ispec;"
sourceShader_frag :+"	gl_FragColor.a = color.a;"
sourceShader_frag :+"}"

Local image_size:Float = 128
Local hsize:Float = image_size*0.5
Global prod_normals_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Global prod_color_pix:TPixmap = CreatePixmap(image_size,image_size,PF_RGBA8888)
Local nx:Int = 0
Local ny:Int = 0
Local nz:Int = 0
Local mask:Float = 0
For Local x:Float = 0 Until image_size
	For Local y:Float = 0 Until image_size
	
	Local xp:Float = (x-hsize)/hsize
	Local yp:Float = (y-hsize)/hsize
	Local alpha:Float= 1.0-Sqr(xp*xp+yp*yp)
	If alpha &gt; 0 Then 
		alpha = alpha^0.5*255
		
		mask = alpha/255
		If mask&gt;1.0 Then mask=1
		mask = mask^2*255	
		
		Local zp:Float = 1.0
		Local dot:Float = Sqr(xp*xp+yp*yp)^0.15
		If dot
			zp = 1.0-Sqr(1.0-dot*dot)/hsize
			dot = 1.0/Sqr(dot)
			xp:*dot
			yp:*-dot
		End If
		nx = Int((0.5+0.5*xp)*255)
		ny = Int((0.5+0.5*yp)*255)
		nz = Int((0.5+0.5*zp)*255)
	Else 
		alpha = 0
		mask = 0
	EndIf
	WritePixel(prod_normals_pix,x,y,(Int(alpha) Shl 24)|(nx Shl 16)|(ny Shl 8)|nz)
	WritePixel(prod_color_pix,x,y,Int(mask) Shl 24|$335566)
	Next
Next

'------------- SETUP Lighting

glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
glEnable(GL_NORMALIZE);

Local lmKa:Float[] = [0.0, 0.0, 0.0, 1.0 ]
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmKa)
glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, 2.0)
glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 0.0)

Local spot_direction:Float[] = [0.0, 0.0, -1.0]
Local spot_exponent:Int = 10
Local spot_cutoff:Int = 180

glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction);
glLighti(GL_LIGHT0, GL_SPOT_EXPONENT, spot_exponent);
glLighti(GL_LIGHT0, GL_SPOT_CUTOFF, spot_cutoff);

glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION,1.0);
glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 1.0);
glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.0);

Local light_pos:Float[] = [Float(Width*0.5), -Float(Height*0.5), -500.0, 1.0];
Local light_Ka:Float[]  = [0.2, 0.2, 0.2, 1.0];
Local light_Kd:Float[]  = [1.0, 1.0, 1.0, 1.0];
Local light_Ks:Float[]  = [1.0, 1.0, 1.0, 1.0];

glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
glLightfv(GL_LIGHT0, GL_AMBIENT, light_Ka);
glLightfv(GL_LIGHT0, GL_DIFFUSE, light_Kd);
glLightfv(GL_LIGHT0, GL_SPECULAR, light_Ks);

Local  material_Ka:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Kd:Float[] = [1.0, 1.0, 1.0, 1.0]
Local  material_Ks:Float[] = [0.6, 0.6, 0.7, 1.0]
Local  material_Ke:Float[] = [0.0, 0.0, 0.0, 0.0]

glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, material_Ka);
glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, material_Kd);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, material_Ks);
glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, material_Ke);
glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 10);

' ------------- setup alpha blending

glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
		
' ------------- setup textures &amp; shader
If Not glIsEnabled( GL_TEXTURE_2D ) Then glEnable( GL_TEXTURE_2D )

Global g_normaltextureID:Int = loadTexture(prod_normals_pix)
prod_normals_pix = Null
Global g_textureID:Int = loadTexture(prod_color_pix)
prod_color_pix = Null
	
Global SHADER_L1:Int = LoadShader(sourceShader_vert, sourceShader_frag)
glUseProgramObjectARB(SHADER_L1)
Global gl_location_norm:Int		=glGetUniformLocationARB(SHADER_L1, "normalTexture")
If gl_location_norm &lt;&gt; -1 Then glUniform1iARB(gl_location_norm, 0)
Global gl_location_color:Int	=glGetUniformLocationARB(SHADER_L1, "colorTexture")
If gl_location_color &lt;&gt; -1 Then glUniform1iARB(gl_location_color, 1)

Global num:Int = 1000
Global xbuf:Float[num]
Global ybuf:Float[num]
For Local i:Int = 0 Until num
	xbuf[i]=Width*0.5
	ybuf[i]=Height*0.5
Next
Global timer:Int = 0
glClearColor(0.21,0.30,0.35,1.0)
'HideMouse()
While Not KeyHit(KEY_ESCAPE)
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	
	glUseProgramObjectARB( SHADER_L1)
	
 	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, g_normaltextureID)
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, g_textureID)

	If MouseDown(1)
		xbuf[0] = MouseX()
		ybuf[0] = MouseY()
		DrawQuad(xbuf[0], ybuf[0], 0, 0, 64)
	End If
	Local speed:Float = 0.5+0.4*Sin(timer)
	For Local i:Int = 1 Until num
		xbuf[num-i]:+(xbuf[num-i-1]-xbuf[num-i])*speed
		ybuf[num-i]:+(ybuf[num-i-1]-ybuf[num-i])*speed
		DrawQuad(xbuf[i], ybuf[i], 0, 0, 64*(1.0-Float(i)/1000))
	Next
	timer:+1
	Flip 0
Wend
'ShowMouse()
glDeleteTextures(1, Varptr g_textureID)
glDeleteTextures(1, Varptr g_normaltextureID)
glDeleteObjectARB(SHADER_L1)
glDisable( GL_TEXTURE_2D )
End




' ------------- FUNCTIONS
' openGL draw functions
Function DrawQuad(x:Float, y:Float, z:Float, rotation:Float, size:Float)
	size:*0.5
	Local poly:Float[8]
	Local rot:Float[]=[Float(Sin(rotation)),Float(Cos(rotation))]
	Local rox:Float[]=[rot[1], -rot[0]]
	Local pos:Float[]=[x,y]
	
	poly[0] = -size*rot[0]+size*rox[0]
	poly[1] = -size*rot[1]+size*rox[1]
	poly[2] = size*rot[0]+size*rox[0]
	poly[3] = size*rot[1]+size*rox[1]
	poly[4] = size*rot[0]-size*rox[0]
	poly[5] = size*rot[1]-size*rox[1]
	poly[6] = -size*rot[0]-size*rox[0]
	poly[7] = -size*rot[1]-size*rox[1]
	
	poly[0]:+pos[0]
	poly[1]:+pos[1]
	poly[2]:+pos[0]
	poly[3]:+pos[1]
	poly[4]:+pos[0]
	poly[5]:+pos[1]
	poly[6]:+pos[0]
	poly[7]:+pos[1]
	
	glBegin GL_QUADS
		glTexCoord2f 0,0
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[0],poly[1],z
		
		glTexCoord2f 0,1
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[2],poly[3],z
		
		glTexCoord2f 1,1
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[4],poly[5],z
		
		glTexCoord2f 1,0
		glNormal3f(-rot[0],rot[1],0);
		glVertex3f poly[6],poly[7],z
	glEnd
End Function

' openGL setup functions
Function loadTexture:Int (image:TPixmap)
	Local texture:Int
	glGenTextures(1, Varptr texture)
	
	glBindTexture(GL_TEXTURE_2D, texture)
	glTexImage2D(GL_TEXTURE_2D, 0, 4, image.Width, image.Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.pixels)
	
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR)
	
	Return texture
End Function

Function loadShader:Int(file:String, file2:String)
   Local ProgramObject:Int
   Local VertexShaderObject:Int
   Local FragmentShaderObject:Int
   ProgramObject=glCreateProgramObjectARB()
   VertexShaderObject   = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
   FragmentShaderObject = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

   Local pointer:Byte Ptr = file.ToCString()
   Local laenge:Int=file.Length
   
   glShaderSourceARB(VertexShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(VertexShaderObject)
   
   debugShader(VertexShaderObject)
   
   pointer 	= file2.ToCString()
   laenge	= file2.Length
   
   glShaderSourceARB(FragmentShaderObject,1,Varptr pointer,Varptr laenge)
   glCompileShaderARB(FragmentShaderObject)
   
   debugShader(FragmentShaderObject)
   
   glAttachObjectARB(ProgramObject, VertexShaderObject)
   glAttachObjectARB(ProgramObject, FragmentShaderObject)

   glDeleteObjectARB(VertexShaderObject)
   glDeleteObjectARB(FragmentShaderObject)

   glLinkProgramARB(ProgramObject);
   
   Return ProgramObject
End Function

Function debugShader(shaderObject:Int)
   Local laengedeslogs:Float
   glGetObjectParameterfvARB(shaderObject,GL_OBJECT_INFO_LOG_LENGTH_ARB,Varptr laengedeslogs)


   Local bytearray:Byte[]=New Byte[laengedeslogs]
   Local laenge23:Int=0
   glGetInfoLogARB(shaderObject, laengedeslogs, Varptr(laenge23), Varptr(bytearray[0]));
   Local msg:String=""
   For Local j:Int=0 To laengedeslogs-1
      msg=msg+ Chr(bytearray[j])
   Next
   DebugLog "ShaderLog: "+msg
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1006353"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> That looks pretty.<br><br>First of all, did you check if your intel gfx has shader support? GMA 950 has Shader 2.0 and Vertex 3.0: <a href="http://www.intel.com/products/chipsets/gma950/index.htm" target="_blank">http://www.intel.com/products/chipsets/gma950/index.htm</a><br><br>Newer cards should obviously have better support, however this seems like the most common VGA chip right now.<br><br>I REALLY want to start playing with shaders, but I'm still busy with other important stuff like undo system, copy/cut/paste, multiple selection, particle system, etc. Shaders are somehow at the bottom of my list now :)<br><br>EDIT: Oh and Grover's stuff was never designed for intel cards as far as I know. Deferred rendering is a pretty advanced technique of rendering and in most cases requires support for fancy floating point textures, non-power-of-two textures and 64-bit textures. I'm not sure, but chances are none of this is supported by most Intel cards.<br><br>Try running the simplest example out there, fix the problems (if there are any) and build up on that. <br><br></td></tr></table><br>
<a name="1006357"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> AH, hehehe...wrote "unlimited" undo/redo, copy/cut/paste/insert and shifting as well as particle systems, except multiple selection, actually...I think...nah, that one I havn't done, yet, but meant to for my synth (syntaron), hehe. <br><br>Hmmm, so I guess it's alright if I go at shaders, now! :o))))<br><br>But, yeah, I should probably go and start from the very bottom with testing GL on the laptop. It's an older HP, though, which doesn't even have the 950, but 915GM/910GML (what ever that means). Maybe that's asking for too much to let decent GL stuff with shaders run there, LOL.<br><br>Well, heck, thanks again, Andrei! I always feel encouraged, when I read your replies! And I think I'll always keep fishing for your reactions for that matter already! :} <br><br></td></tr></table><br>
<a name="1006359"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sadly, that "thing" they call graphics card doesn't run shaders :(<br><br>And feel free to fish my reactions. I am highly interested in what you're doing. Particularly because programmer art usually sucks, and so does artist programming. However, you and I seem to be slight exceptions :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
