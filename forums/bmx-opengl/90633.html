<!DOCTYPE html><html lang="en" ><head ><title >single surface rendering?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >single surface rendering?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=103" >OpenGL Module</a>/<a href="#bottom" >single surface rendering?</a><br><br>
<a name="1031003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, I need to be able to render 50,000+ particles on a single surface, they should all be pretty simple untextured circles but I have no idea how open gl works and I cant seem to find any good place to start.  Can anyone point me to a good starting place.  I tried this but I know i must be missing something.  I also didnt know if glpoints are faster than a single surface method.  Sorry about my cluelessness.<br><br><pre class=code>
Function rendergl()
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT )
	
	glPointSize(r)
	
	glBegin(GL_POINTS)
	For Local i:Int = 0 To num
        Local c# = .1 * pointlist[i].rho
        Local x# = 20 * Abs(pointlist[i].vx)
        Local y# = 20 * Abs(pointlist[i].vy)
        
		glColor3f(.3+x,.3+y,c)
		glVertex2f(pointlist[i].x, pointlist[i].y)
	Next	
	glEnd()
	Flip 'flip buffers???
End Function
</pre><br><br>I am also using this at the begining.  I fear I am missing something big<br><br><pre class=code>
SetGraphicsDriver(GLGraphicsDriver())

GLGraphics 1024,768,0,60

</pre> <br><br></td></tr></table><br>
<a name="1031162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was looking at your code and it all looks fine... then it occurred to me... GLGraphicsDriver does not do any OpenGL setup. If you switch it to GLMax2DDriver I bet it will work.<br><br>The GLGraphicsDriver gives you an OpenGL context but it hasn't set up any viewport, projection matrix, or any other GL `state`. So effectively it isn't even possible to draw anything to the screen at that point. You'd need to at least set up a projection e.g. glOrtho2D() or glOrtho() (forget which) and glViewport(), before you'd be able to see anything.<br><br>Secondly, 50000 sprites is a lot for an average computer. I know on my iMac I can do maybe 10-15000 at 60Hz... sprites maybe 32x32 or so.<br><br>To do texturing you need to set up a bunch of other stuff, too. You have to set up the whole `texture environment`, do the texture loading, switch texturing on, define the texture coordinates, etc.<br><br>You should look at using vertex arrays also, they can be up to twice the speed of the immediate-mode code you're using. Also consider display lists which are also faster. But to do this stuff you're going to have to learn quite a bit more OpenGL code.<br><br>Using GL_POINTS you can draw circles with a given point size, you're doing it correctly, provided the graphics driver supports points as large as you're trying to draw. You might also find the points render as squares unless you switch on glEnable(GL_POINT_SMOOTH). It also might not support point sizes less than 1.<br><br>And In OpenGL they're not called surfaces they're called textures ;D <br><br></td></tr></table><br>
<a name="1031309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks IH, that was informative.<br><br>And I only need to use a single texture for them and I know switching textures can cause slowdown so maybe the 15000 can be bumped up a notch... I am really only shooting for 30 hz with sprites about 8x8 or 4x4<br><br>Do you know where I can find some tutorials for gl in bmax?  I mean where do people learn all of this stuff? <br><br></td></tr></table><br>
<a name="1031313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TWH</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Most people learn OpenGL from the <a href="http://nehe.gamedev.net/" target="_blank">NeHE tutorials</a>, allthough they use old, deprecated OpenGL, they are popular. The NeHe's use glBegin/glEnd and the matrixes in OpenGL. The new way to do it is to use VBO's to store vertex data, shaders to render and a matrix library to do the transformations instead of glLoadMatrixf, glMultMatrixf and the Matrix stack (push/pop).<br><br>The Nehe tuts have all been ported to BlitzMax here: <a href="http://www.blitzbasic.com/Community/posts.php?topic=41689" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=41689</a><br><br>But, if you know a little about C and pointers in BMax you should be able to figure out how any C/C++ OpenGL code can be written in Bmax.<br><br>Here's some C/C++ examples of "modern" OpenGL 3.0 use:<br><a href="http://nopper.tv/index.html" target="_blank">http://nopper.tv/index.html</a><br><br>Joe Groff @ Durian software has written a very good introduction on how to do the modern all-shader approach here:<br><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html" target="_blank">http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html</a><br><br>If you want to se what shaders are all about you can try them out in an editor like Ati Rendermonkey (big 100MB) or the simpler <br><a href="http://cg.in.tu-clausthal.de/publications.shtml#shader_maker" target="_blank">ShaderMaker</a><br><br><a href="http://www.pouet.net/prod.php?which=54245" target="_blank"> or tigrous polydraw</a><br><br><br>You can mix old-fasioned OpenGL with shaders. This will probably be supported for a long time, but it isn't "pure" OpenGL 3.0+ The only problem with shaders is old cards (pre GeForce 4-5 and ATi 8500) and integrated intel  chips don't support them. Or.. with the case of intel, don't always support them that well.<br><br>If you want to use fancy shader effects, but also want to run on low-end systems you might want to use the Nvidia Cg toolkit. It has a high-level shader language like GLSL, but you can compile to a variety of other formats, like oldfasioned assembly-style shaders that are more compatible with intel... and perhaps also Ati in some cases. ATi's cards/drivers are very picky about shader syntax. Just ask Taron about his AWSOME GLASS PONG GLSL experiment <a href="http://www.blitzmax.com/Community/posts.php?topic=88966#1011350" target="_blank">http://www.blitzmax.com/Community/posts.php?topic=88966#1011350</a><br><br>Nvidia has a lot of whitepapers and impressive stuff on OpenGL here.<br><a href="http://developer.download.nvidia.com/SDK/9.5/Samples/samples.html" target="_blank">http://developer.download.nvidia.com/SDK/9.5/Samples/samples.html</a><br><br>For instance on how to make a million particle system.... only problem is that you have to do it all on the GPU. You cant sett positions, velocity, color on cpu... that would require sending the data over the bus... :( .. maybe you could do it in batches... 10.000 at a time. Then they live on the gpu for some time going in a certain direction, or following a flowmap.. <br><a href="http://www.2ld.de/gdc2004/" target="_blank">http://www.2ld.de/gdc2004/</a><br><br>Last year I started a particle system that was never finished... Maybe you find some of it useful. It sets texture state once and then draws lots of particles with different colors,positions,velocities.<br><br>Check TParticleSystem.doUpdate(p:TParticle) on how it sets various drawing methods (Bmax Drawimage, QUADS, GL_POINT...)<br><br>It uses glBegin/glEnd for bmax drawimage, tristrip.. but not quads or point sprites so they are fast.<br><br>It could be made a lot faster by using glArrays or VBO's I think. Perhaps also the texture could be done away with if it is rendered by a shader instead.<br><br>Instructions:<br>Click to place a 1000 particles at a time. Press the blue-square button to select render mode:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'written by Torbjoern 16. september 2009
'my goal is 10.000 particles at 60 fps on my hardware (2.8GHz Ati 3850) in debug mode.
'reached the goal by just calling glBegin/glEnd once for each particle.
'... for millions of particles a pure GPU-approach is required.
'color Type for RGB to HSV was taken from the blitzbasic code archive.
SuperStrict
Framework BRL.GlMax2D
Import BRL.Random
Import pub.glew


AppTitle = "torbjoerns opengl particle performance testing app. it renders the astounding particles of ka-zoom."
Global resX:Int=800, resY:Int=600

' Current render method:
Global renderMethod:Int = 0

' Ways to render:
Const RENDER_BLITZMAX_IMAGE:Int = 0
Const RENDER_TRIANGLE_STRIP:Int = 1
Const RENDER_QUADS:Int = 2
Const RENDER_POINT_SPRITE:Int = 3

' way to iterate thru items
Global iterationMethod:Int = 0
Const ITERATE_USING_TLISTS:Int = 0
Const ITERATE_USING_ARRAYS:Int = 1

' Keep track of how many
Global glob_particleCount:Int = 0
Global glob_emitterCount:Int = 0


SetGraphicsDriver GLMax2DDriver()
Graphics resX,resY,0,0
openglcheck()

' Start the main loop
Local game:TGame = New TGame
game.mainloop()
End

' A little class that keeps track of frames per second.
' it could also do millisecs per frame to render...
Type TFPSCounter
	Field frames:Int=0
	Field fps:Int=0
	Field sec:Long = MilliSecs()
	
	Method update()
		If(sec &lt; MilliSecs() )
			sec = MilliSecs() + 1000
			fps = frames
			frames = 0
		EndIf
		frames :+1
	End Method
End Type

'No need to put everything in a class really :P
Type TGame
	Field fpsCounter:TFPSCounter = New TFPSCounter
	Field system:TParticleSystem = New TParticleSystem
	Field timeTaken:Long = 0

	Method mainloop()
		While(Not KeyHit(KEY_ESCAPE) And Not AppTerminate()	)
			Cls
			
			Local perfStart:Long = MilliSecs()
			system.update()	'and render
			timeTaken = MilliSecs() - perfStart
			
			pollInput()
			draw2DInformation()
			fpsCounter.update()		
			
			Flip
			'Delay 16 ' frame limit
		Wend
	End Method
	
	Method pollInput()
			If(MouseHit(1))
				If( MouseY() &lt; GraphicsHeight()-75 ) Then system.createEmitter( MouseX(), MouseY(), 1000 )
			EndIf
			If(MouseHit(2))
				system.removeLastEmitter()
			EndIf
			
			If KeyHit(KEY_SPACE)
				renderMethod :+ 1
				renderMethod = renderMethod Mod 4 ' 4 states. 0 to 3
			EndIf
			
			If KeyHit(KEY_ENTER)
				iterationMethod :+ 1
				iterationMethod = iterationMethod Mod 2 ' 2 states. 0 to 1
			EndIf
	End Method
	
	Method draw2DInformation()
			SetBlend(SOLIDBLEND)
			SetColor(255,255,255)
			DrawText("click to place emitters",15,15)
			DrawText("particles:" + glob_particleCount + ", emitters:" + glob_emitterCount,15,15+15*1)
			DrawText("time to render particles: " + timeTaken+ "ms",15,15+15*2)
			DrawText("fps "+fpsCounter.fps,resX- 100,0)
			
			drawGUI()
	End Method
	
	Method drawGUI()
			Local renderMethodString:String
			Select renderMethod
				Case RENDER_BLITZMAX_IMAGE renderMethodString = "BlitzMax DrawImage -slowest"
				Case RENDER_TRIANGLE_STRIP renderMethodString = "GL_TRIANGLE_STRIP -very slow cause'a glBegin/glEnd"
				Case RENDER_QUADS renderMethodString = "GL_QUADS -fast"
				Case RENDER_POINT_SPRITE renderMethodString = "GL_POINT_SPRITE -fastest"
			End Select
			
			If( squareBtn(0, 15 , GraphicsHeight()-60, 25 , "Render method="+renderMethodString ) )
				renderMethod :+ 1
				renderMethod = renderMethod Mod 4 ' 4 states. 0 to 3
			EndIf
			
			Local iterationMethodString:String
			Select iterationMethod
				Case ITERATE_USING_TLISTS iterationMethodString = "linked lists"
				Case ITERATE_USING_ARRAYS iterationMethodString = "arrays"
			End Select
			If( squareBtn(1, 15 , GraphicsHeight()-30, 25 , "Iteration method="+iterationMethodString ) )
				iterationMethod :+ 1
				iterationMethod = iterationMethod Mod 2 ' 2 states. 0 to 1
			EndIf
	End Method
End Type

Function openglcheck()
	glewInit
	
	Local isDriverSupported:Int = False
	If(GL_POINT_SPRITE_ARB) isDriverSupported = True
	
	Local out:String
	If GL_VERSION_1_1
		If GL_VERSION_1_2
			If GL_VERSION_1_3
				If GL_VERSION_1_4
					If GL_VERSION_1_5
						If GL_VERSION_2_0
							out = "GL 2.0"
						Else
							out = "GL 1.5"
						EndIf
					Else
						out = "GL 1.4"
					EndIf
				Else
					out = "GL 1.3"
				EndIf
			Else
				out = "GL 1.2"
			EndIf
		Else
			out = "GL 1.1"
		EndIf
	Else
		out = "OpenGL version not recognized. GL ?.?"
	EndIf
	Local fSizes:Float[2]
	GLGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, fSizes)
	
	out :+"~nGL_ALIASED_POINT_SIZE_RANGE, the smallest And largest supported sizes For aliased points:"
	For Local i:Float = EachIn fSizes
		out :+ "~n = "+i
	Next
	
	AppTitle = "The little elves checked your rig, it appears that it supports:"
	
	out :+ "~nPoint sprite extensions supported:"
	If(GL_POINT_SPRITE_ARB) Then out :+ "~nGL_POINT_SPRITE_ARB"
	If(GL_ARB_point_sprite) Then out :+ "~nGL_ARB_point_sprite"
	If(GL_ATIX_point_sprites) Then out :+ "~nGL_ATIX_point_sprites"
	If(GL_POINT_SPRITE_NV) Then out :+ "~nGL_POINT_SPRITE_NV"
	If(GL_NV_point_sprite) Then out :+ "~nGL_NV_point_sprite"		
	
	If(Not isDriverSupported)
		Notify("NOTHING! Your hardware or driver isn't good enough.~nYou need at least OpenGL 1.3.")
		End 'end program
	EndIf
	
	Notify out

End Function

Type TColor

	Method RGBColor:TRGBColor() Abstract
	Method HSVColor:THSVColor() Abstract

End Type

Type TRGBColor Extends TColor

	Field _red#,_grn#,_blu#

	Method RGBColor:TRGBColor()
		Return Self
	End Method

	Method HSVColor:THSVColor()
		Local hmin#=_red
		If _grn&lt;hmin hmin=_grn
		If _blu&lt;hmin hmin=_blu
		Local hmax#=_red
		If _grn&gt;hmax hmax=_grn
		If _blu&gt;hmax hmax=_blu
		If hmax-hmin=0 Return THSVColor.CreateHSV( 0,0,hmax )
		Local hue#,delta#=hmax-hmin
		Select hmax
		Case _red hue=(_grn-_blu)/delta
		Case _grn hue=2+(_blu-_red)/delta
		Case _blu hue=4+(_red-_grn)/delta
		End Select
		hue=hue*60
		If hue&lt;0 hue=hue+360
		Return THSVColor.CreateHSV( hue,delta/hmax,hmax )
	End Method

	Method RED#()
		Return _red
	End Method

	Method GREEN#()
		Return _grn
	End Method

	Method BLUE#()
		Return _blu
	End Method
	
	Method Set(r#,g#,b#)
		_red=r
		_grn=g
		_blu=b
	End Method

	Function CreateRGB:TRGBColor( RED#,grn#,blu# )
		Local color:TRGBColor=New TRGBColor
		color._red=RED
		color._grn=grn
		color._blu=blu
		Return color
	End Function

End Type

Type THSVColor Extends TColor

	Field _hue#,_sat#,_val#

	Method RGBColor:TRGBColor()
		If _sat&lt;=0 Return TRGBColor.CreateRGB( _val,_val,_val )
		Local h#=_hue/60
		Local i#=Floor( h )
		Local f#=h-i
		Local p#=_val*(1-_sat)
		Local q#=_val*(1-(_sat*f))
		Local t#=_val*(1-(_sat*(1-f)))
		Select Int(i)
		Case 0 Return TRGBColor.CreateRGB( _val,t,p )
		Case 1 Return TRGBColor.CreateRGB( q,_val,p )
		Case 2 Return TRGBColor.CreateRGB( p,_val,t )
		Case 3 Return TRGBColor.CreateRGB( p,q,_val )
		Case 4 Return TRGBColor.CreateRGB( t,p,_val )
		Case 5 Return TRGBColor.CreateRGB( _val,p,q )
		End Select
	End Method

	Method HSVColor:THSVColor()
		Return Self
	End Method

	Method Hue#()
		Return _hue
	End Method

	Method Saturation#()
		Return _sat
	End Method

	Method Value#()
		Return _val
	End Method

	Function CreateHSV:THSVColor( hue#,sat#,val# )
		If hue&lt;0 hue=hue+360
		If hue&gt;=360 hue=hue-360
		Local color:THSVColor=New THSVColor
		color._hue=hue
		color._sat=sat
		color._val=val
		Return color
	End Function

End Type

Rem
bbdoc: Create a red, green, blue color
returns: A new color object
about: @red, @grn and @blu should be in the range 0 to 1.
End Rem
Function RGBColor:TRGBColor( RED#,grn#,blu# )
	Return TRGBColor.CreateRGB( RED,grn,blu )
End Function

Rem
bbdoc: Create a hue, saturation, value color
returns: A new color object
about: @hue should be in the range 0 to 360, @sat and @val should be in the range 0 to 1.
End Rem
Function HSVColor:THSVColor( hue#,sat#,val# )
	Return THSVColor.CreateHSV( hue,sat,val )
End Function

'my immidiate mode GUI button. "invented it" my selv playing with evaldraw. later read aboutit on sol.gfxile.net and the mollyrocket forums
'borrowed some ideas from there like.

'Instructions for use:
' something like this:
' if squareBtn(0, 0, 15, "launch missiles")  then lunchAllMissiles = true
' Num is the identifier For a certain button.
'The Max num of buttons is set inside this Function

Function squareBtn:Int(num:Int, x# , y#, h# , txt:String) 'width is set by text length
	'is the button pressed. initally we think not.
	Local wasHit:Int = False
	
	'take the string and make the box fit.
	Local w:Float = txt.length*8.4
	
	'Globals and consts inside a function. Like I do in evaldraw to hide details, and make for easy cut-n-paste ability.
	Const numSquareButtons:Int=50
	Global squareButtonActive:Int[numSquareButtons] ' is button down?
	Global squareButtonLastHit:Int[numSquareButtons] ' was it allready clicked?
	Global squareButtonisHot:Int[numSquareButtons] ' is mouse over it?
	Global hasInit:Int = False ' Have all buttons been initalized?
	
	'Initialize all buttons state.
	If hasInit = False
		hasInit = True   
		For Local i:Int = 0 Until numSquareButtons
			squareButtonActive[i] = False;
			squareButtonLastHit[i] = False
			squareButtonisHot[i] = False
		Next
	EndIf
	
	'drawing needs pretty much beautification.
	'Draw the button	
	If MouseDown(1) And squareButtonisHot[num] 'button is active.
		SetColor 0,0,255
		DrawRect(x,y,w,h);
		SetColor(32,127,0)
		DrawRect(x+4,y+4,w-8,h-8);	
	Else If squareButtonisHot[num]
		SetColor 0,0,255
		DrawRect(x,y,w,h);
		SetColor(0,0,0)
		DrawRect(x+4,y+4,w-8,h-8);	
	Else 'no mouseover, not hot, not down
		SetColor 0,0,255
		DrawRect(x, y,w,h);
		SetColor(0,0,0)
		DrawRect(x+4,y+4,w-8,h-8);
	EndIf   
	
	'draw text
	SetColor(255,255,255)
	Local saveBlend:Int = GetBlend()
	SetBlend(LIGHTBLEND)
	SetAlpha 1
	DrawText(txt,x+5,y+h/4)  
	SetBlend(saveBlend)
	
	If Not MouseDown(1) Then squareButtonLastHit[num]=0 'reset, you can now click the button again
	
	' Is mouse over the button?
	If RectCollide(MouseX(),MouseY(),x,y,w,h)
		' then its hot!
		squareButtonisHot[num] = True
		
		'if mouse is over and down, we have a hit, unless it allready was pressed once. dont want it to flicker between states.
		If MouseDown(1) And squareButtonLastHit[num]=0
			squareButtonLastHit[num] = True	
			squareButtonActive[num] = True
			wasHit = True
		EndIf
	Else
		squareButtonActive[num] = False
		squareButtonisHot[num] = False
	EndIf

	
	'return if the button was pressed or not
	Return wasHit
End Function

Function RectCollide:Int(x1#,y1#,x2#,y2#,w#,h#)
	If(x1 &gt;= x2 And x1 &lt;= x2+w)
		If(y1 &gt;= y2 And y1 &lt;= y2+h)
			Return 1;
		EndIf
      EndIf
	Return 0;
End Function

Type TVector3
	Field x:Float, y:Float, z:Float
	
	Method add(addMe:TVector3)
		x :+ addMe.x
		y :+ addMe.y
		z :+ addMe.z
	End Method
End Type

Type TParticle
	Field parentPos:TVector3 = New TVector3
	Field pos:TVector3 = New TVector3
	Field vel:TVector3 = New TVector3
	Field life:Int
	Field r:Int, g:Int, b:Int
	
	Method update()
		pos.add(vel)
		life :-1
	End Method
	
	Method reset()
	
		Local color:TRGBColor=HSVColor( Rand(0,360),1,1 ).RGBColor()

		r = color.Red()*255
		g = color.Green()*255
		b = color.Blue()*255
	
		life = Rand(0,255)
		pos.x = parentPos.x
		pos.y = parentPos.y
		vel.x = Rnd(-1,1)
		vel.y = Rnd(-1,1)
		Local length:Float = Sqr(vel.x*vel.x + vel.y*vel.y)
		vel.x :/ length
		vel.y :/ length
		Local randnum:Float = Rnd(0.1,1)
		vel.x :*randnum
		vel.y :*randnum
		
	End Method
End Type

Type TParticleEmitter
	Field MAX_PARTICLES:Int = 10000
	Field pos:TVector3 = New TVector3
	Field particleList:TList = New TList
	Field particleArray:TParticle[] = New TParticle[MAX_PARTICLES]
	
	Field rate:Float 'particles to emit per update.
	
	Method addNumParticles(num:Int)
		If(num &gt; MAX_PARTICLES) Then num = MAX_PARTICLES
		For Local i:Int = 0 Until num

			Local p:TParticle = New TParticle
			p.parentPos = pos
			p.reset()
			particleList.addLast(p)
			
			particleArray[i] = p
			
		Next
	End Method
	
	Method setPos(x:Float, y:Float, z:Float)
		pos.x = x
		pos.y = y
		pos.z = z
	End Method
End Type

Type TParticleSystem
	Const MAX_EMITTERS:Int = 100
	Field emitterList:TList = New TList
	Field emitterArray:TParticleEmitter[] = New TParticleEmitter[MAX_EMITTERS]
	Field image:TImage' = createParticleImg()
	
	Method New()
		' Create a sprite
		AutoMidHandle 1
		image = createParticleImg()
	End Method
	
	Method update()
		'Additive blending.
		SetBlend LIGHTBLEND
		
		
		
		'Set texture for quad, tristrip, pointsprite
		If(renderMethod &lt;&gt; RENDER_BLITZMAX_IMAGE)
			SetTexturePoint( image )
		EndIf
		
			
		If(renderMethod=RENDER_QUADS)
			glBegin(GL_QUADS)
		
		Else If(renderMethod=RENDER_POINT_SPRITE)
			glEnable GL_POINT_SPRITE
			glTexEnvi GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE 
			glPointSize image.width
			glBegin GL_POINTS
		EndIf
		
		'Loop thru all emitters and their particles. Check if the particle should be rendered or reset. Then update it.
		If iterationMethod = ITERATE_USING_TLISTS
			For Local e:TParticleEmitter = EachIn emitterList
				For Local p:TParticle = EachIn e.particleList
					doUpdate(p)
				Next
			Next
		Else If iterationMethod = ITERATE_USING_ARRAYS
			For Local e:TParticleEmitter = EachIn emitterArray
				For Local p:TParticle = EachIn e.particleArray
					doUpdate(p)
				Next
			Next
		EndIf
		
		If(renderMethod = RENDER_QUADS Or renderMethod = RENDER_POINT_SPRITE)
			glDisable GL_POINT_SPRITE
			glEnd
		EndIf
	End Method
	
	Method doUpdate(p:TParticle)
		'render this particle?
		If(p.life &gt; 0)
			SetAlpha(p.life/255.0)
			SetColor(p.r, p.g, p.b )
			Local x# = p.pos.x
			Local y# = p.pos.y
			Local particleHalfSize:Float = image.width/2.0
			
	
			If(renderMethod=RENDER_BLITZMAX_IMAGE)
				DrawImage image,x,y	
																
			Else If(renderMethod=RENDER_TRIANGLE_STRIP)
				'Gl begin/glEnd cost quite a bit. Could load this into a displaylist and then translate it about insted of positioning the vertexes.
				glBegin(GL_TRIANGLE_STRIP);						' Build Quad From A Triangle Strip
				glTexCoord2d(1,1); glVertex2f(x+particleHalfSize,y+particleHalfSize); '// Top Right
				glTexCoord2d(0,1); glVertex2f(x-particleHalfSize,y+particleHalfSize); '// Top Left
				glTexCoord2d(1,0); glVertex2f(x+particleHalfSize,y-particleHalfSize); '// Bottom Right
				glTexCoord2d(0,0); glVertex2f(x-particleHalfSize,y-particleHalfSize); '// Bottom Left
				glEnd();
				
			Else If(renderMethod=RENDER_QUADS)
				glTexCoord2d(0,1); glVertex2f(x-particleHalfSize,y-particleHalfSize); '// bottom left
				glTexCoord2d(1,1); glVertex2f(x+particleHalfSize,y-particleHalfSize); '// bottom right
				glTexCoord2d(1,0); glVertex2f(x+particleHalfSize,y+particleHalfSize); '// top right
				glTexCoord2d(0,0); glVertex2f(x-particleHalfSize,y+particleHalfSize); '// top left
				
			Else If(renderMethod=RENDER_POINT_SPRITE)						
				glVertex2f(x,y)
			EndIf
		'particle was dead. reset it
		Else
			p.reset()
		EndIf
		
		'update position and life
		p.update()
	End Method
	
	Method createEmitter(x:Float, y:Float, numOfParticlesWanted:Int)
		If(glob_emitterCount &lt; MAX_EMITTERS)
	
			Local e:TParticleEmitter = New TParticleEmitter
			e.setPos(x,y,0)
			e.addNumParticles(numOfParticlesWanted)
			glob_particleCount :+ numOfParticlesWanted
			glob_emitterCount :+ 1
			
			emitterList.addLast(e)	
			
			emitterArray[emitterList.count()-1] = e
		EndIf
	End Method
	
	Method removeLastEmitter()
		If(emitterList.count() &gt; 0)
		emitterArray[emitterList.count()-1] = Null
		emitterList.removeLast()
		glob_particleCount :-1000
		glob_emitterCount :-1
		EndIf
	
	End Method
End Type

'Called once at setup to Create the particle image
Function createParticleImg:TImage()
	SetBlend ALPHABLEND 
	Local sz:Int = 2
	
	Local particle_image:TImage = CreateImage(sz,sz) 
	Local alpha:Float = 1.0 
	Local i:Int
		For i = 1 To sz/2 
				DrawOval (sz/2)-i,(sz/2)-i,i*2,i*2 
				'DrawRect (sz/2)-i,(sz/2)-i,i*2,i*2 
				'Plot (sz/2)-i,(sz/2)-i
				
				'DrawText "HEI",(sz/2)-i,(sz/2)-i

				
				alpha:* 0.65		
				SetColor Rnd(100,200),Rnd(100,200),Rnd(100,200) 
				SetAlpha alpha 	
		Next 	
	GrabImage(particle_image,0,0) ; Cls 	
	Return particle_image
End Function

'takes a blitzmax image at gets its texture handle aka name.
Function SetTexturePoint( image:TImage )
	glBindTexture GL_TEXTURE_2D, TGLImageFrame(image.Frame(0)).name
	glTexParameteri GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR
	glTexParameteri GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR
	glEnable GL_TEXTURE_2D
End Function


</textarea> <br><br></td></tr></table><br>
<a name="1031318"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> well I only have gl 2.0, is there a way to upgrade? (I know nothing about graphics drivers)<br><br>I was able to get 100,000 particles at 30 fps whith your program.  I really need a method to render fluid particles for my physics engine but maybe it is a good idea to do the particle rendering and physics on the gpu since its just sittin there doing nothing while the cpu does everything at the moment... <br><br></td></tr></table><br>
<a name="1031325"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok great examples but ultimately I am a horrible gl programmer ;)<br><br>here is the render function<br><br><pre class=code>
Function render()
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT )
	
	glEnable GL_POINT_SPRITE
	glTexEnvi GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE 
	glPointSize r
	glBegin GL_POINTS

	For Local i:Int = 0 To num
        Local c# = .1 * pointlist[i].rho
        Local x# = 20 * Abs(pointlist[i].vx)
        Local y# = 20 * Abs(pointlist[i].vy)
        
		glColor3f(.3+x,.3+y,c)
		glVertex2f(pointlist[i].x, pointlist[i].y)
	Next	
	glDisable GL_POINT_SPRITE
	glEnd()
	Flip 'flip buffers???
End Function
</pre><br><br>and before it I do<br><br><pre class=code>
SetGraphicsDriver GLMax2DDriver()
GLGraphics 1024,768,0,60
</pre><br><br>I combined yalls advice/program code snippets/nehe tutorials but it still doesnt work... I still think I am doing something stupid, sorry for being such a noob at this haha <br><br></td></tr></table><br>
<a name="1031331"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TWH</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you use GLGraphics you have to set up projection.. edit: The standard BlitzMax Graphics 1024,768',0,60 does' this for you. In the glMax2D driver ResetGLContext it does this:<br><pre class=code>
		glDisable GL_TEXTURE_2D
		glMatrixMode GL_PROJECTION
		glLoadIdentity
		glOrtho 0,gw,gh,0,-1,1
		glMatrixMode GL_MODELVIEW
		glLoadIdentity
		glViewport 0,0,gw,gh
</pre><br><br>Edit. Here's a simple example of using GLGraphics... but for simplicity I guess you might aswell use Graphics. Then you dont have to mess with opengl projection and modelview matrices.<br><br>If you want to learn about the 2 important OpenGL matrixes<br>*GL_PROJECTION<br>*GL_MODELVIEW<br>*there is also a GL_TEXTURE matrix for translating textures about and projecting them onto this for effects like shadowmaps.<br>you can check out <a href="http://www.songho.ca/opengl/gl_transform.html" target="_blank">SongHpo.ca's article</a><br><br>and <a href="http://www.xmission.com/~nate/tutors.html" target="_blank">Nate Robins' OpenGL tutors</a><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
'Framework BRL.GlMax2D
'Import BRL.Random
'Import pub.glew
'Import BRL.standardio
SetGraphicsDriver GLMax2DDriver()
GLGraphics 1024,768,0,60 'need to setup projection!
'Graphics 1024,768',0,60

Type TPoint 
	Field vx#, vy#
	Field x#, y#
End Type

Global num:Int = 100
Global pointlist:TPoint[] = New TPoint[num]

'main
For Local i:Int = 0 Until num
	Local p:TPoint = New TPoint
	p.x = RndFloat() * GraphicsWidth() 
	p.y = RndFloat() * GraphicsHeight() 
	pointlist[i] = p
Next

	'For "real" opengl mode, that is using GLGraphics
	'we have to setup the projection matrix (and for 3D, modelview for moving and looking about)
	'the helper function glOrtho sets up a matrix with no perspective forshortening:
	'you can see what it does here:
	'http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml
	
	'if we were to do it manually we would have to set OpenGL state t
	'glMatrixMode(GL_PROJECTION)
	'and glLoadMatrixf() to load the matrix
	
	glOrtho(0,GraphicsWidth(),0,-GraphicsHeight(), 0, 1) ' -y here because opengls positive y-coord is UP
	
	'Translate everything in our world one screen down so we can see it!
	'this is because we want to draw stuff as normal in 2D, where
	'the upper left coord is (0,0) and lower right is (xres,yres)
	glTranslatef( 0,-GraphicsHeight(),0 )
	
'Glew, opengl extension wrangler is used to se if an extension is supported.
	'glewInit()	
	'If(GL_POINT_SPRITE_ARB)
'		Print "GL_POINT_SPRITE_ARB is supported"
'	Else 
'		Print ""GL_POINT_SPRITE_ARB is not supported"
'	EndIf
	
	'glEnable(GL_POINT_SMOOTH) 'has some problems on ATi (square) use a round texture instead 
	'as described here: 
	'http://stackoverflow.com/questions/1513811/getting-smooth-big-points-in-opengl

	While Not AppTerminate()
		render()
	Wend
End

Function render()
	'glPushMatrix()
	'glTranslatef( 0,-MouseY(),0 )


	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT )
	
	glEnable GL_POINT_SPRITE
	'Sets texture blending mode. Needed for texture?
	'glTexEnvi GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE 
	glPointSize 10.0
	glEnable(GL_POINT_SMOOTH)
	glBegin GL_POINTS

	Local radToDeg# = 180.0 / Pi
	
	For Local i:Int = 0 Until num
		'glColor3f(1,1,0)
		Local mousemove# = MouseX()/  Float(GraphicsWidth()) ' 0-1
		Local ang# = mousemove*2*Pi ' a full circle
		Local rounds# = 2
		Local x# = pointlist[i].x + Cos(rounds*ang*radToDeg)*50
		Local y# = pointlist[i].y + Sin(rounds*ang*radToDeg)*50
		glColor3f(x/GraphicsWidth(),y/GraphicsHeight(),0)
		glVertex2f(x,y)
	Next	
	
	glPointSize 50.0
	glVertex2f(MouseX(), MouseY())

	
	glEnd()
	
	'glPopMatrix()
	Flip 'flip buffers???
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1031348"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok thank TWH! it worked! <br><br></td></tr></table><br>
<a name="1031368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TWH</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great! Two more things! Errors and extensions! OpenGL has an error report mechanism with glGetError(), when debugging you should check for errors at least every frame. You can check after every opengl call if you suspect a certain call that went wrong. Perhaps do an if glGetError&lt;&gt; GL_NO_ERROR then debugstop() <br><br>Each time you call glGetError you remove an <a href="http://www.opengl.org/wiki/GL_error_codes" target="_blank">error code</a>.<br><br>The are a few error codes. See code below. They are like booleans that are flipped on/off. So.. even if you really have 10 invalid enum errors, you only get one. <br><br>Other GL stuff like Framebuffer objects and GLSL shaders have error logging of their own. Like when you compile a shader or put together a FBO.<br><br>If you have multiple errors in a frame you should remove them all. That is, call glGetError until you get GL_NO_ERROR.<br><br>On the previous code I posted I got an invalid enum error each frame because there is no glDisable GL_POINT_SPRITE... in OpenGL 1.0 !!<br><br>You have to use Glew or some other way of initializing extensions. In blitzmax its as easy as glewInit()<br><br>	If(GL_POINT_SPRITE)<br>		Print "GL_POINT_SPRITE is supported"<br>                glEnable(GL_POINT_SPRITE)<br>	Else <br>		Print "GL_POINT_SPRITE is Not supported"<br>	EndIf<br><br>So. Before flip-ing you could check for errors like this:<br><pre class=code>
		?debug
		Local errorCode:Int = glGetError()
		If errorCode = GL_NO_ERROR
			'all ok
		Else
			Print "GL ERROR!"
			If errorCode = GL_INVALID_ENUM Print "invalid enum"
			If errorCode = GL_INVALID_VALUE Print "invalid value"
			If errorCode = GL_INVALID_OPERATION Print "invalid operation"
			If errorCode = GL_STACK_OVERFLOW Print "stack overflow"
			If errorCode = GL_STACK_UNDERFLOW Print "stack underflow"
			If errorCode = GL_OUT_OF_MEMORY Print "GL_OUT_OF_MEMORY"
			If errorCode = GL_TABLE_TOO_LARGE Print "GL_TABLE_TOO_LARGE"
		EndIf
		?
		Flip
</pre> <br><br></td></tr></table><br>
<a name="1031408"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I certainly need to favorite this thread so I can come back and see how to do opengl!  This was very helpful, thanks! <br><br></td></tr></table><br>
<a name="1031433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TWH</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hehe. Great. I've made something new. Well. Ported an <a href="http://www.advsys.net/ken/download.htm" target="_blank">evaldraw</a> script (magfield.kc) to Bmax and added alpha-blended particle lines:<br><br>This way to draw lines has some problems... Its hard to make the lines sharp. Im going to try drawing GL_LINES instead and running a glow filter on the screen in GLSL next.<br><br><img src="http://imgur.com/khDIP.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
SetGraphicsDriver GLMax2DDriver()
Graphics 1024,768,0',0,60 'dont need to setup projection

Global xres# = Float(GraphicsWidth())
Global yres# = Float(GraphicsHeight())

Global nx#=0, ny#=0, sx#=0, sy#=0; 'Pole positions

Local nump:Int=8192
Global px#[NUMP]
Global py#[NUMP]
Global otim#;

For Local i:Int=0 Until NUMP
	px[i] = xres*RndFloat();
	py[i] = yres*RndFloat();
Next
otim = MilliSecs() / 1000.0

'place poles
nx = xres*0.75; 
ny = yres*(0.5-.001);
sx = xres*0.75; 
sy = yres*(0.5+.001);

Const RADTODEG# = 180.0/Pi


SetMaskColor(255,255,255)
Global pixmap:TPixmap = CreatePixmap(16,16,PF_RGBA8888)
DrawCircleGradient(pixmap)
Global particleImg:TGLImageFrame = TGLImageFrame.CreateFromPixmap(pixmap,FILTEREDIMAGE)
Global texture_name:Int = particleImg.name
Global pointplots:Int = 0

initPointSprite()
Global fpsCounter:TFPSCounter = New TFPSCounter

While Not AppTerminate()	
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT )

	If MouseDown(2)
	   nx = MouseX();
	   ny = MouseY();
	EndIf
	
	If MouseDown(1)
	   sx = MouseX()
	   sy = MouseY()
	EndIf
	


	Local mx# = nx-sx; 
	Local my# = ny-sy; 
	Local cx# = (nx+sx)/2.0; 'centerpoint, between north &amp; south.
	Local cy# = (ny+sy)/2.0;
	Local f# = 1.0/Sqr(mx*mx+my*my); '1/distance north&lt;-&gt;south
	mx = mx*f; 
	my = my*f;
   
   	Local hx# = xres*0.5; 
	Local hy# = yres*0.5; 'middle of screen
   	Local tim# = MilliSecs()/1000.0; 
	Local dt# = tim-otim;
	otim = tim;
   
'	Case ALPHABLEND
'			glEnable GL_BLEND
'			glBlendFunc GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA
'			glDisable GL_ALPHA_TEST
'		Case LIGHTBLEND
'			glEnable GL_BLEND
'			glBlendFunc GL_SRC_ALPHA,GL_ONE
'			glDisable GL_ALPHA_TEST
	'SetBlend(LIGHTBLEND)
	glEnable GL_BLEND
	glBlendFunc GL_SRC_ALPHA,GL_ONE
	glDisable GL_ALPHA_TEST 'Important! GL turns this on for text methinks. 
	
	glBindTexture(GL_TEXTURE_2D, texture_name);
	glPointSize 16.0

	Local mousypos# = MouseY() / yres
	Local alpha:Int = 1+(1-mousypos)/2*255

	glBegin GL_POINTS	
   	For Local i:Int=0 Until NUMP
		Local x# = px[i]; 
		Local y# = py[i];
		Local sd# = (x-sx)*(x-sx) + (y-sy)*(y-sy); 'distance to south pole
	      
		Local j# = 0.0
		'Particle out of screen?
		If (Abs(x-hx) &gt;= hx) Or (Abs(y-hy) &gt;= hy)
			j = (xres+yres)*2*RndFloat(); 'Select random point on border
			
			If (j &lt; xres) Then
				x = j; 
				y = 0;
			Else If (j &lt; xres*2)
				x = j-xres;
				y = yres; 
			Else If (j &lt; xres*2+yres)
				x = 0; 
				y = j-xres*2; 
			Else  
				x = xres; 
				y = j-xres*2-yres; 
		      EndIf
		EndIf
	
		'Toushes south. set new pos.
		If sd &lt; 16*16
			Local  a# = (Pi*2)*RndFloat();
			x = Cos(a*RADTODEG)*16+nx;
			y = Sin(a*RADTODEG)*16+ny;
		EndIf
	
		'north direction?
	      Local  nd# = 1.0/( (x-nx)*(x-nx) + (y-ny)*(y-ny) ); '1 over sq dist
	      sd = 1.0/( (x-sx)*(x-sx) + (y-sy)*(y-sy) );
	      Local  vx# = (x-nx)*nd - (x-sx)*sd; 'velocity at point is decidend by dist to north and south.
	      Local  vy# = (y-ny)*nd - (y-sy)*sd;
	
	      f =16.0/Sqr(vx*vx+vy*vy); 'line length
	      'SetColor (i Mod 72)*64+64, (i Mod 80)+128, 64
	      glColor4ub (i Mod 72)*64+64, (i Mod 80)+128, 64, alpha
		'glvertex2f x-vx*f,y-vy*f
		blockscan x-vx*f,y-vy*f,x+vx*f,y+vy*f,2
		'DrawLine(x-vx*f,y-vy*f,x+vx*f,y+vy*f);
	      
	      f = 128*dt/Sqr(vx*vx+vy*vy);
	      x :+ vx*f;
	      y :+ vy*f;
	      
	      px[i] = x;
	      py[i] = y;
	Next
	glEnd
	
	?debug
	checkError()
	?
	
	SetAlpha(1.0)
	SetBlend(MASKBLEND)
	SetColor 255,0,0
	'SetScale(2,2)
	DrawText "N",nx-3,ny-5
	DrawText "S",sx-3,sy-5
	'SetScale(1,1)
	
	glColor3ub(255,255,255)
	SetColor 255,255,255
	DrawText "FPS: "+fpsCounter.fps, 0, 0
	DrawText "points plotted with line algo:"+pointplots ,0,15
	DrawText "move mouse up and down to control alpha:",0,15*2
	pointplots = 0'reset

	Flip(0)
	'Cls
	fpsCounter.update()
Wend

Function checkError()
	Local checkedAllErrors:Int = False
	Local glerrorList$ = ""
	Local numErrors:Int = 0
	While checkedAllErrors=False
		Local errorCode:Int = glGetError()
		If errorCode = GL_NO_ERROR
			checkedAllErrors = True
		Else
			numErrors = numErrors + 1
			If errorCode = GL_INVALID_ENUM glerrorList:+" invalid enum "
			If errorCode = GL_INVALID_VALUE glerrorList:+" invalid value "
			If errorCode = GL_INVALID_OPERATION glerrorList:+" invalid operation "
			If errorCode = GL_STACK_OVERFLOW glerrorList:+" stack overflow "
			If errorCode = GL_STACK_UNDERFLOW glerrorList:+" stack underflow "
			If errorCode = GL_OUT_OF_MEMORY glerrorList:+" GL_OUT_OF_MEMORY "
			If errorCode = GL_TABLE_TOO_LARGE glerrorList:+" GL_TABLE_TOO_LARGE "
		EndIf
	Wend
	If glerrorList &lt;&gt; ""
		Print "#"+numErrors +" glGetErrors this frame: "+glerrorList
	EndIf
End Function

Function initPointSprite()
'Glew, opengl extension wrangler is used To se If an extension is supported.
	glewInit()	
	If(GL_POINT_SPRITE)
		Print "GL_POINT_SPRITE is supported"
		glEnable(GL_POINT_SPRITE)
	Else 
		Print "GL_POINT_SPRITE is Not supported"
		End
	EndIf
	'glEnable( GL_BLEND )
	'glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA ) 'additive without overblending
	'glPointSize( 30.0 )
	
	glActiveTexture(GL_TEXTURE0);
	glEnable( GL_TEXTURE_2D );
	glTexEnvi(GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE); 'Generates tex coords for Point Sprite
	'modes: <a href="http://www.khronos.org/opengles/documentation/opengles1_0/html/glTexEnv.html" target="_blank">http://www.khronos.org/opengles/documentation/opengles1_0/html/glTexEnv.html</a>
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);  'GL_MODULATE, GL_DECAL, GL_BLEND, Or GL_REPLACE.
	
	'Local color:Float[] = [1.0, 0.0, 0.0]
	'glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, color[0] )
	'glBindTexture(GL_TEXTURE_2D, texture_name);
End Function


'im guessing its bresenham. prolly overkill.
'taken from the evaldraw example blockscan.kc
'converted to BMax.
Function blockscan(x0#,y0#,x1#,y1#,blocksiz#)
   'Scale down to blocky pixels
   x0 :/ blocksiz
   y0 :/ blocksiz
   x1 :/ blocksiz
   y1 :/ blocksiz
   Local prec# = 65536.0 '// 2^16
   Local ix:Int = Floor(x0);
   Local ix1:Int = Floor(x1)-ix;
   Local ixi:Int = (ix1&gt;0)*2-1;
   Local iy:Int = Floor(y0);
   Local iy1:Int = Floor(y1)-iy;
   Local iyi:Int = (iy1&gt;0)*2-1;
   Local fx# = x0-ix;
   If (ixi &gt; 0) fx = 1-fx;
   Local  fy# = y0-iy;
   If (iyi &gt; 0) fy = 1-fy;
   Local gx# = Abs(x1-x0)*prec;
   Local idx:Int = Int(gx);
   Local gy# = Abs(y1-y0)*prec;
   Local idy:Int = Int(gy);

   Local id:Int;
   If (ix1 = 0) Then 
	id = -1; idx = 0;
   Else If (iy1 = 0)
	id =  0; idy = 0;
   Else
	id = Int(fy*gx - fx*gy);
   EndIf
   For Local c:Int=Abs(ix1)+Abs(iy1) Until 0 Step -1
	pointplots :+1
	glVertex2f( ix*blocksiz , iy*blocksiz ) 'scale up to screen pixels

      If (id &gt;= 0)
		ix :+ ixi; id :- idy;
      Else 
		iy :+ iyi; id :+ idx; 
	EndIf
   Next
End Function

Function drawCircleGradient(px:TPixmap)
	Local siz:Float = px.width
	Local center:Float = (siz-1) / 2.0
   	For Local y:Int=0 Until siz
   	For Local x:Int=0 Until siz
     	 	Local t:Float = Sqr( (center-x)*(center-x) + (center-y)*(center-y) ) / center
		Local c:Int = 255-255*t
		If( c &lt; 0 ) c = 0
		If( c &gt; 255 ) c = 255
		
		Local a:Int = c 'alpha is same as color gradient
		Local argb:Int = (a Shl 24) + c Shl 16 + c Shl 8 + c
		WritePixel px,x,y,argb      	
   	Next
	Next 
End Function

Type TFPSCounter
	Field frames:Int=0
	Field fps:Int=0
	Field sec:Long = MilliSecs()
	
	Method update()
		Local timenow:Int = MilliSecs()
		If(sec &lt; timenow )
			sec = timenow + 1000
			fps = frames
			frames = 0
		EndIf
		frames :+1
	End Method
End Type
</textarea> <br><br></td></tr></table><br>
<a name="1034866"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok so now I am wondering how I can render at least 10,000 fuzzy dots or fuzzy dot images and then do a threshold filter that will give them a defined border...  I am hopeful that this is all possible in pure bmax gl without the use of shaders so how would I render a fuzzy image 10,000 times efficiently?  I am working my way through the code above but it is a bit over my head... <br><br></td></tr></table><br>
<a name="1035111"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Howitzer</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Nathan, this is Christian from the VRC.  I can't really help ya, just dropping in to say hi. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
