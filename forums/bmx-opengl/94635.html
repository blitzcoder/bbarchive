<!DOCTYPE html><html lang="en" ><head ><title >FBO + GLSL Shader Strangeness</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >FBO + GLSL Shader Strangeness</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=103" >OpenGL Module</a>/<a href="#bottom" >FBO + GLSL Shader Strangeness</a><br><br>
<a name="1086304"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tesuji</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I'm hoping that some of those with more OpenGL experience than myself can help out here.<br><br>I've been playing around with FBOs and GLSL fragment shaders with a view to experiment with some cellular automata (starting with conway's life) and later fluid dynamic processing. Fragment shaders &amp; FBOs show a lot of promise in this area as I can apply a per pixel algorithm off screen very fast and do it all on the GPU. <br><br>However, I've come up against an issue which is slowing progress. For some reason, my texel lookup doesn't appear reliable in that some errors are creeping in over the cause of the feedback cycle.<br><br>I've written a program which hopefully demonstrates this effect. In theory, the shader should smoothly scroll the line down without any corruption.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import "glsl.bmx"

SetGraphicsDriver GLMax2DDriver()
Graphics 800,600
glewInit()

' create FBO buffer and attach image
Local image:TImage = CreateImage(512,512)
Local fbo:TImageBuffer = New TImageBuffer.Create(image)
fbo.Bind();
DrawText "Press &lt;1&gt; to activate shader",64,256
DrawText "Lines should remain straight..",64,256+16
fbo.UnBind()

' compile shaders
Local vsSource:String = ..
"void main()                                                                        ~n"+..
"{                                                                                  ~n"+..
"       // Passing The Texture Coordinate Of Texture Unit 0 To The Fragment Shader  ~n"+..
"        gl_TexCoord[0] = gl_MultiTexCoord0;                                        ~n"+..
"                                                                                   ~n"+..
"       // Transforming The Vertex                                                  ~n"+..
"       gl_Position = ftransform();                                                 ~n"+..
"                                                                                   ~n"+..
"}                                                                                  ~n"

Local fsSource:String = ..
"uniform sampler2D tex0;                          ~n"+..
"uniform vec2 resolution;                         ~n"+..
"                                                 ~n"+..
"void main(void) {                                ~n"+..
"   vec2 uv = gl_TexCoord[0].xy;                  ~n"+..
"   vec2 texelGap = vec2(0.0, 1.0/resolution.y);  ~n"+..
"   vec3 texcol = texture2D(tex0,uv-texelGap).rgb;~n"+..
"   if (texcol.r + texcol.g + texcol.b &gt; 2.5) {   ~n"+..
"       gl_FragColor = vec4(texcol,1.0);          ~n"+..
"   } else {                                      ~n"+..
"       gl_FragColor = vec4(uv.x,uv.y,0.0,1.0);   ~n"+..
"   }                                             ~n"+..
"}                                                ~n"

Local vs:tShaderObject=New tShaderObject
Local error:String = vs.compileVertex(vsSource) ' loadtext("filename.vert")
If error &lt;&gt; Null Then Print "Drat. Shader failed to compile (again) ~n" + error + "~n" + vsSource

Local fs:tShaderObject=New tShaderObject
error = fs.compileFragment(fsSource)
If error &lt;&gt; Null Then Print "Drat. Shader failed to compile (again) ~n" + error + "~n" + fsSource

Local po:tProgramObject=New tProgramObject 
po=tProgramObject.Create("test")
po.AttachVertShader(vs)
po.AttachFragShader(fs)

Print "Shaders Compiled &amp; Linked OK"

Local useShader:Int = False
Local useFBO:Int = True

While Not KeyDown(KEY_ESCAPE) And Not AppTerminate()	

	Cls
	
	' render to FBO with shader
	If useFBO fbo.Bind(); 
	If useShader 
		po.Activate()
		po.setUI1("tex0",0) ' pass to shader sampler2D tex0
		po.setUF2("resolution",ImageWidth(image),ImageHeight(image))
	End If	
    DrawImage image,0,0
    DrawLine 0,16,512,16 'give something to the shader to work with
	If useShader po.DeActivate()
	If useFBO fbo.Unbind(); 

    ' render to screen
    SetColor 255,255,255
	DrawImage image, MouseX(),MouseY()
	DrawText "(1) Shader "+useShader+" (2) FBO "+useFBO,0,0
	
	If KeyHit(KEY_2) Then useFBO = Not useFBO
	If KeyHit(KEY_1) Then useShader = Not useShader
	Flip 1
Wend

End

' -----------------------------

Type TImageBuffer

    Field rb:Int[1]
    Field fb:Int[1]
    Field OrigX:Int,OrigY:Int
    Field OrigW:Int,OrigH:Int
    Field width:Int,height:Int
    Field glTextureId:Int

    Method Create:TImageBuffer(image:TImage,frameNo:Int=0)
        initBuffer(image.width, image.height, TGLImageFrame(Image.frame(frameNo)).name)
        Return Self
    End Method
	
    Method initBuffer(width:Int,height:Int,glTextureId:Int)
        Self.width = width
        Self.height = height
        Self.glTextureId = glTextureId
        generateFBO()
    End Method
	
    Function initGraphics(width:Int,height:Int,bit:Int=0,mode:Int=60)
        SetGraphicsDriver(GLMax2DDriver())
        Graphics width,height,bit,mode
        glewInit()
     End Function
	
     Method generateFBO()
	
        Local W:Int = width
        Local H:Int = height
		
        AdjustTexSize(W , H) 

        glGenFramebuffersEXT(1, fb )
        glGenRenderbuffersEXT(1 , rb) 
	   
        glBindTexture(GL_TEXTURE_2D, glTextureId);
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fb[0]) ; 
	   	   
        glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D,  glTextureId, 0);
        glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rb[0]);
        glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, W, H);
        glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT , GL_DEPTH_ATTACHMENT_EXT , GL_RENDERBUFFER_EXT , rb[0])
	   
        Local status:Int =  glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT)
	   
        Select status
            Case GL_FRAMEBUFFER_COMPLETE_EXT 
                Print "OK" + " : " + Status
            Case GL_FRAMEBUFFER_UNSUPPORTED_EXT
                Print "GL Framebuffer Unsupported - choose different formats"
            Default
                End 
        EndSelect 
   
    End Method
	
    Method bind()
        GetViewport(OrigX,OrigY,OrigW,OrigH)
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fb[0])
        glMatrixMode GL_PROJECTION
        glLoadIdentity
        glOrtho 0,width,0,width,-1,1
        glMatrixMode GL_MODELVIEW 
        glViewport 0,0,width,height
        glScissor 0,0,width,height
    End Method
	
    Method unbind()
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
        glMatrixMode GL_PROJECTION
        glLoadIdentity
        glOrtho 0,OrigW,Origh,0,-1,1
        glMatrixMode GL_MODELVIEW 
        glViewport 0,0,OrigW,OrigH
        glScissor 0,0,OrigW,OrigH
    End Method

	Function AdjustTexSize( width:Int Var,height:Int Var )
	   'calc texture size
	    width=Pow2Size( width )
	    height=Pow2Size( height )
	    Repeat
	        Local t:Int
	        glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
	        glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
	        If t Return
	        If width=1 And height=1 RuntimeError "Unable to calculate tex size"
	        If width&gt;1 width:/2
	        If height&gt;1 height:/2
	    Forever
	End Function
	
	Function Pow2Size:Int( n:Int )
	    Local t:Int=1
	    While t&lt;n
	        t:*2
	    Wend
	    Return t
	End Function
	
End Type

</textarea><br><br>glsl.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Strict
Rem
Module pub.glsl

ModuleInfo "Version: 1.00"
ModuleInfo "Author: Tom Speed set uniforms bodged by ChrisC"
ModuleInfo "License: Blitz Shared Source Code"
ModuleInfo "Copyrights: Unknown"
ModuleInfo "Modserver: PUB"

Import brl.linkedlist
Import brl.standardio
Import brl.filesystem
Import brl.system
Import pub.glew
EndRem

Import brl.linkedlist
Import brl.standardio
Import brl.filesystem
Import brl.system
Import pub.glew

Global ProgramObjectList:TList = CreateList()
Global ShaderObjectList:TList = CreateList()
Global shaderCompileError:String

Global clog:Byte[1024]' = MemAlloc(linked)

'Shader Object Type
Type tShaderObject
	Field ShaderObject:Int
	Field Attached:TList			' Shaders can be attached, or 'referenced by', more than 1 ProgramObject
	Field shaderName:String
	Field source:Byte[]
	Field src:String
	
	Method compile:String(source:String, shaderType:Int)
		Local sourcePtr:Byte Ptr = source.ToCString()
	    Local sourceLength:Int = source.length

		ShaderObject = glCreateShader(shaderType)
		src = source
		glShaderSourceARB(ShaderObject,1, Varptr sourcePtr, Varptr sourceLength)
		glCompileShaderARB(ShaderObject)
		
		Attached = New TList
	    shaderName = "foo "+shaderType
		ListAddLast ShaderObjectList, Self
				
		Return TShaderObject.compileError(ShaderObject)
	End Method
	
	Method compileFragment:String(source:String)
		Return compile(source,GL_FRAGMENT_SHADER)
	End Method

	Method compileVertex:String(source:String)
		Return compile(source,GL_VERTEX_SHADER)
	End Method


	Function compileError:String(id:Int)

		Local error:String = Null
		'Did the shader compile successfuly?
		Local compiled:Int
		glGetObjectParameterivARB(id,GL_OBJECT_COMPILE_STATUS_ARB, Varptr(compiled))
		If Not compiled
			Local logLength:Int
			glGetObjectParameterivARB(id,GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr(logLength))
			Local slen:Int = 0
			glGetInfoLogARB(id,1024,Varptr(slen), Varptr clog[0])
			Local err:String
			For i = 0 To logLength-1
				err:+Chr(clog[i])
			Next
			error = err
		End If
		Return error

	End Function
	
End Type

'Program Object Type
Type tProgramObject
	Field Program:Int		' The ProgramObject
	Field vList:TList		' Vertex shader list. A List of what Vert shaders are attached to this ProgramObject
	Field fList:TList		' Frag shader list. A List of what Frag shaders are attached to this ProgramObject
	Field progName:String
	
	Field vertShaderCount:Int
	Field fragShaderCount:Int



	'----------------------------------------------------
	'tProgramObject.Create(name:String)
	'
	'Creates a new Shader Program Object to which
	'multiple Vert and/or Frag Shaders can be attached to
	'
	'Returns: The newly created Program Objects ID if
	'         successful, or Null if it failed.
	'----------------------------------------------------
	Function Create:tProgramObject(name:String = "null")
		Local p:tProgramObject = New tProgramObject
		
		'Create a new GL ProgramObject
		p.Program = glCreateProgramObjectARB()
		If p.Program=0
			p = Null
			?Debug
				Print "Error: glCreateProgramObjectARB() failed"
			?
			Return Null
		End If
		
		'---------------------------------
		'The amount of Vert &amp; Frag Shaders
		'attached to this Program Object
		'---------------------------------
		p.vertShaderCount = 0
		p.fragShaderCount = 0
	
		'---------------------------------------
		'These lists contain any Vert or Frag
		'Shader Objects Attached to this Program
		'---------------------------------------
		p.vList:TList = CreateList()
		p.fList:TList = CreateList()
		
		'This Program Objects Name
		p.progName = name
		
		'------------------------------
		'Add this Program Object to the
		'Global list of ProgramObjects
		'------------------------------
		ListAddLast ProgramObjectList, p
		Return p
	End Function

	
	'---------------------------------
	'tProgramObject.Activate()
	'
	'Activates (uses!) a ProgramObject
	'---------------------------------
	Method Activate()
		glUseProgramObjectARB(Program)
	End Method

	'----------------------------
	'tProgramObject.DeActivate()
	'
	'Turns off this ProgramObject
	'----------------------------
	Method DeActivate()
		glUseProgramObjectARB(0)
	End Method

	' Get the Uniform Variable Location from a ProgramObject
	Method GetUniLoc:Int(name:String)
		Return glGetUniformLocationARB(Program, Varptr name)
	End Method

	' Get the Attribute Variable Location from a ProgramObject
	Method GetAttribLoc:Int(name:String)
		Return glGetAttribLocationARB(Program, Varptr name)
	End Method
	

	' Set Uniform Variable Integer(s)
	Method setUI1(name:String,val:Int)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI1"
				Return
			End If
		?
		glUniform1iARB(loc,val)
	End Method

	Method setUI2(name:String,val1:Int,val2:Int)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI2"
				Return
			End If
		?
		glUniform2iARB(loc,val1,val2)
	End Method

	Method setUI3(name:String,val1:Int,val2:Int,val3:Int)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI3"
				Return
			End If
		?
		glUniform3iARB(loc,val1,val2,val3)
	End Method

	Method setUI4(name:String,val1:Int,val2:Int,val3:Int,val4:Int)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI4"
				Return
			End If
		?
		glUniform4iARB(loc,val1,val2,val3,val4)
	End Method

	Method getUI1:Int(name:String)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method getUI1"
				Return
			End If
		?
		Local val:Int = 10
		glGetUniformivARB(Program, loc, Varptr(val))
		Return val
	End Method
	
	
	' Set Uniform Variable Float(s)
	Method setUF1(name:String,val:Float)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUF1"
				Return
			End If
		?
		glUniform1fARB(loc,val)
	End Method

	Method setUF2(name:String,val1:Float,val2:Float)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString() )
		?Debug
			If loc&lt;0
				Print "&gt;Error getting Uniform Var Location '"+name+"' in Method setUF2"
				Return
			End If
		?
		glUniform2fARB(loc,val1,val2)
	End Method

	Method setUF3(name:String,val1:Float,val2:Float,val3:Float)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())

		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUF3"
				Return
			End If
		?
		glUniform3fARB(loc, val1, val2, val3)
	End Method

	Method setUF4(name:String,val1:Float,val2:Float,val3:Float,val4:Float)
		Local loc:Int = glGetUniformLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUF4"
				Return
			End If
		?
		glUniform4fARB(loc,val1,val2,val3,val4)
	End Method

	' Set Attribute Variable Short(s)
	Method setAS1(name:String, val1:Short)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS1"
				Return
			End If
		?
		glVertexAttrib1sARB(loc, val1)
	End Method

	Method setAS2(name:String, val1:Short, val2:Short)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS2"
				Return
			End If
		?
		glVertexAttrib2sARB(loc, val1, val2)
	End Method

	Method setAS3(name:String, val1:Short, val2:Short, val3:Short)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS3"
				Return
			End If
		?
		glVertexAttrib3sARB(loc, val1, val2, val3)
	End Method

	Method setAS4(name:String, val1:Short, val2:Short, val3:Short, val4:Short)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS4"
				Return
			End If
		?
		glVertexAttrib4sARB(loc, val1, val2, val3, val4)
	End Method
	
	' Set Attribute Variable Float(s)
	Method setAF1(name:String, val1:Float)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAF1"
				Return
			End If
		?
		glVertexAttrib1fARB(loc, val1)
	End Method

	Method setAF2(name:String, val1:Float, val2:Float)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAF2"
				Return
			End If
		?
		glVertexAttrib2fARB(loc, val1, val2)
	End Method

	Method setAF3(name:String, val1:Float, val2:Float, val3:Float)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS3"
				Return
			End If
		?
		glVertexAttrib3fARB(loc, val1, val2, val3)
	End Method

	Method setAF4(name:String, val1:Float, val2:Float, val3:Float, val4:Float)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAF4"
				Return
			End If
		?
		glVertexAttrib4fARB(loc, val1, val2, val3, val4)
	End Method

	' Set Attribute Variable Double(s)
	Method setAD1(name:String, val1:Double)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD1"
				Return
			End If
		?
		glVertexAttrib1fARB(loc, val1)
	End Method

	Method setAD2(name:String, val1:Double, val2:Double)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD2"
				Return
			End If
		?
		glVertexAttrib2fARB(loc, val1, val2)
	End Method

	Method setAD3(name:String, val1:Double, val2:Double, val3:Double)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD3"
				Return
			End If
		?
		glVertexAttrib3fARB(loc, val1, val2, val3)
	End Method

	Method setAD4(name:String, val1:Double, val2:Double, val3:Double, val4:Double)
		Local loc:Int = glGetAttribLocationARB(Program, name.ToCString())
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD4"
				Return
			End If
		?
		glVertexAttrib4fARB(loc, val1, val2, val3, val4)
	End Method


	'----------------------------------------------------------
	'Attach &amp; Link a Vertex Shader Object to this ProgramObject
	'----------------------------------------------------------
	Method AttachVertShader:Int(myShader:tShaderObject)
		?Debug
			If Program = 0
				Print "Error: Invalid tProgramObject in method AddVertShader()"
				Print "-------------------------------------------------------"
				Print
			Else If Not myShader
				Print "Error: Invalid tShaderObject passed to method AddVertShader()"
				Print "-------------------------------------------------------------"
				Print
				Return
			End If
		?


		'--------------------------
		'Attach &amp; Link a VertShader
		'--------------------------
		glAttachObjectARB(Program, myShader.ShaderObject)
		glLinkProgramARB(Program)


		'-------------------------------
		'Check if it Linked successfully
		'-------------------------------
		Local linked:Int
		glGetObjectParameterivARB(Program,GL_OBJECT_LINK_STATUS_ARB, Varptr(linked))
		
		If Not linked
			?Debug
				'An Error occured during Linking
				'dump the error logfile to console
'				Local clog:Byte Ptr
				Local slen:Int = 0

				glGetInfoLogARB(Program,1023,Varptr slen, Varptr clog[0])
				Local err:String
				Local i:Int
				For i = 0 To slen-1
					err:+Chr(clog[i])
				Next

				Print
				Print "Failed to link VertexShader "+myShader.shaderName
				Print
				Print err+"  "+slen
			?
'			FlushMem
			Return 0
		End If
		?Debug
			Print "VertexShader "+myShader.shaderName+" attached &amp; linked ok!"
			Print
		?
	
		'Add this VertShaderObject to this ProgramObjects list
		ListAddLast vList, myShader

		'Add this ProgramObject to this Shaders 'attached to' list
		ListAddLast myShader.Attached, Self
		Return 1
	End Method

	'------------------------------------------------------------
	'Attach &amp; Link a Fragment Shader Object to this ProgramObject
	'------------------------------------------------------------
	Method AttachFragShader:Int(myShader:tShaderObject)
		?Debug
			If Program = 0
				Print "Error: Invalid tProgramObject in method AddFragShader()"
				Print "-------------------------------------------------------"
				Print
			Else If Not myShader
				Print "Error: Invalid tShaderObject passed to method AddFragShader()"
				Print "-------------------------------------------------------------"
				Print
				Return
			End If
		?


		'--------------------------
		'Attach &amp; Link a FragShader
		'--------------------------
		glAttachObjectARB(Program, myShader.ShaderObject)
		glLinkProgramARB(Program)


		'-------------------------------
		'Check if it Linked successfully
		'-------------------------------
		Local linked:Int
		glGetObjectParameterivARB(Program,GL_OBJECT_LINK_STATUS_ARB, Varptr(linked))

		If Not linked
			?Debug
				'An Error occured during Linking
				'dump the error logfile to console
'				Local clog:Byte Ptr
				Local slen:Int = 0

				glGetInfoLogARB(Program,1023,Varptr slen, Varptr clog[0])
				Local err:String
				Local i:Int
				For i = 0 To slen-1
					err:+Chr(clog[i])
				Next

				Print
				Print "Failed to link FragShader '"+myShader.shaderName+"'"
				Print
				Print err
			?
			
'			FlushMem
			Return 0
		End If

		?Debug
			Print "FragShader '"+myShader.shaderName+"' attached &amp; linked ok!"
			Print
		?
		
		'Add this FragShaderObject to this ProgramObjects list
		ListAddLast fList, myShader
		
		'Add this ProgramObject to this Shaders 'attached to' list
		ListAddLast myShader.Attached, Self
		
		'Return Ok!
		Return 1
	End Method	

	'-------------------------------------------------------
	'Detach a VertShader:tShaderObject from a tProgramObject
	'-------------------------------------------------------
	Method DetachVertShader(vShader:tShaderObject)
		If ListContains(vList,vShader)
			glDetachObjectARB(Program, vShader.ShaderObject)
			RemoveLink(ListFindLink(vList,vShader))
			RemoveLink(ListFindLink(vShader.Attached, Self))
			?Debug
				Print "Detached '"+vShader.shaderName+"' from ProgramObject '"+Self.progName+"'"
			?
		End If
	End Method

	'-------------------------------------------------------
	'Detach a FragShader:tShaderObject from a tProgramObject
	'-------------------------------------------------------
	Method DetachFragShader(fShader:tShaderObject)
		If ListContains(fList,fShader)
			glDetachObjectARB(Program, fShader.ShaderObject)
			RemoveLink(ListFindLink(fList,fShader))
			RemoveLink(ListFindLink(fShader.Attached, Self))
			?Debug
				Print "Detached '"+fShader.shaderName+"' from ProgramObject '"+Self.progName+"'"			
			?
		End If
	End Method
	
	'------------------------------------------------------
	'Dump a list of Shaders attached to this tProgramObject
	'------------------------------------------------------
	Method ListAttachedShaders()
		Print "Vertex Shader(s) attached to ProgramObject '"+Self.progName+"'"
		Print "----------------------------------------------------------------------"
		If vList.Count() = 0
			Print "No Vertex Shaders attached"
		Else
			For Local v:tShaderObject = EachIn vList
				Print v.shaderName
			Next
		End If
		
		Print
		Print "Fragment Shader(s) attached to ProgramObject '"+Self.progName+"'"
		Print "-----------------------------------------------------------------------"
		If fList.Count() = 0
			Print "No Fragment Shaders attached"
		Else
			For Local f:tShaderObject = EachIn fList
				Print f.shaderName
			Next
		End If
		Print
	End Method
End Type

Function DeleteVertShader(vShader:tShaderObject Var)
	If Not vShader Return

	RemoveLink(ListFindLink(ShaderObjectList,vShader))
	
	' Detach this ShaderObject from all ProgramObjects it was attached to
	For Local p:tProgramObject = EachIn ProgramObjectList
		If ListContains(p.vList, vShader)
			p.DetachVertShader(vShader)
		End If
	Next
	
	' Delete the shader
	glDeleteObjectARB(vShader.ShaderObject)
	?Debug
		Print "Deleted ShaderObject '"+vShader.shaderName+"'"
		Print
	?
	vShader = Null
End Function
	
Function DeleteFragShader(fShader:tShaderObject Var)
	If Not fShader Return
	
	RemoveLink(ListFindLink(ShaderObjectList,fShader))
		
	' Detach this ShaderObject from all ProgramObjects it was attached to
	For Local p:tProgramObject = EachIn ProgramObjectList
		If ListContains(p.fList, fShader)
			p.DetachFragShader(fShader)
		End If
	Next
	
	' Delete the shader
	glDeleteObjectARB(fShader.ShaderObject)
	?Debug
		Print "Deleted ShaderObject '"+fShader.shaderName+"'"
		Print
	?
	fShader = Null
End Function
</textarea><br><br>Bizarrely, the effect is amplified on certain GPUs. It is most noticeable on triangle boundaries but it's a lot more visible on my Intel HD3000 than it is on my Radeon 6750M<br><br><img src="http://snafoo.net/downloads/broken_line_trouble_AMD6750M.png"><br><br><img src="http://snafoo.net/downloads/broken_line_trouble_Intel3000HD.png"><br><br>I've searched around the net for clues and my two areas of doubt are :<br>1) is it safe to simply overwrite the same texture with a shader or do I need to implement some sort of double buffering. Have been reading about a ping-pong technique for this sort of thing. If this is true, would be good to see a working example.<br>2) Perhaps I'm not specifying the uv texture coordinates correctly? I've seen a lot of different techniques for propagating this information to fragment shaders and I don't think I've a good enough grounding in OpenGL to know what's right (Max2D is my comfort zone :).<br><br>Any help would be much appreciated. <br><br></td></tr></table><br>
<a name="1086356"></a>

<a name="1086458"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tesuji</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Finally managed to solve it! I'll stick the solution here just in case anyone else comes across the same problem.<br><br>It was as I suspected (or at least appears to be), an issue with the lack of double buffering. Apparently you can't let shaders scribble over the same texture that's being written to without strange things happening. <br>Some interesting links : <br><a href="http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&amp;Number=177638" target="_blank">http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&amp;Number=177638</a><br><a href="http://www.seas.upenn.edu/~cis565/fbo.htm#feedback2" target="_blank">http://www.seas.upenn.edu/~cis565/fbo.htm#feedback2</a><br><br>Here's a reworked version with FBO double buffering added :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import "glsl.bmx"

SetGraphicsDriver GLMax2DDriver()
Graphics 800,600
glewInit()

' create FBO buffer and attach image
Local image:TImage = CreateImage(512,512)
Local image2:TImage = CreateImage(512,512)
Local fbo:TImageDoubleBuffer = New TImageDoubleBuffer.Create(image,image2)
fbo.Bind();
DrawText "Press &lt;1&gt; to activate shader",64,256
DrawText "Lines should remain straight..",64,256+16
fbo.UnBind()

' compile shaders
Local vsSource:String = ..
"void main()                                                                        ~n"+..
"{                                                                                  ~n"+..
"       // Passing The Texture Coordinate Of Texture Unit 0 To The Fragment Shader  ~n"+..
"        gl_TexCoord[0] = gl_MultiTexCoord0;                                        ~n"+..
"                                                                                   ~n"+..
"       // Transforming The Vertex                                                  ~n"+..
"       gl_Position = ftransform();                                                 ~n"+..
"                                                                                   ~n"+..
"}                                                                                  ~n"

Local fsSource:String = ..
"uniform sampler2D tex0;                          ~n"+..
"uniform vec2 resolution;                         ~n"+..
"                                                 ~n"+..
"void main(void) {                                ~n"+..
"   vec2 uv = gl_TexCoord[0].xy;                  ~n"+..
"   vec2 texelGap = vec2(0.0, 1.0/resolution.y);  ~n"+..
"   vec3 texcol = texture2D(tex0,uv-texelGap).rgb;~n"+..
"   if (texcol.r + texcol.g + texcol.b &gt; 2.5) {   ~n"+..
"       gl_FragColor = vec4(texcol,1.0);          ~n"+..
"   } else {                                      ~n"+..
"       gl_FragColor = vec4(uv.x,uv.y,0.0,1.0);   ~n"+..
"   }                                             ~n"+..
"}                                                ~n"

Local vs:tShaderObject=New tShaderObject
Local error:String = vs.compileVertex(vsSource) ' loadtext("filename.vert")
If error &lt;&gt; Null Then Print "Drat. Shader failed to compile (again) ~n" + error + "~n" + vsSource

Local fs:tShaderObject=New tShaderObject
error = fs.compileFragment(fsSource)
If error &lt;&gt; Null Then Print "Drat. Shader failed to compile (again) ~n" + error + "~n" + fsSource

Local po:tProgramObject=New tProgramObject 
po=tProgramObject.Create("test")
po.AttachVertShader(vs)
po.AttachFragShader(fs)

Print "Shaders Compiled &amp; Linked OK"

Local useShader:Int = False
Local useFBO:Int = True

While Not KeyDown(KEY_ESCAPE) And Not AppTerminate()	

	Cls
	
	' render to FBO with shader
	If useFBO fbo.Bind(); 'flipBuffer = Not flipBuffer
	If useShader 
		po.Activate()
		po.setUI1("tex0",0) ' pass to shader sampler2D tex0
		po.setUF2("resolution",ImageWidth(image),ImageHeight(image))
	End If	
	DrawImage fbo.image,0,0
    DrawLine 0,16,512,16 'give something to the shader to work with
	If useShader po.DeActivate()
	If useFBO fbo.Unbind(); 

    ' render to screen
    SetColor 255,255,255
	DrawImage fbo.image,MouseX(),MouseY()
	DrawText "(1) Shader "+useShader+" (2) FBO "+useFBO,0,0
	
	If KeyHit(KEY_2) Then useFBO = Not useFBO
	If KeyHit(KEY_1) Then useShader = Not useShader
	Flip 1
Wend

End

' -----------------------------

Type TImageDoubleBuffer

    Field rb:Int[1]
    Field fb:Int[1]
    Field OrigX:Int,OrigY:Int
    Field OrigW:Int,OrigH:Int
    Field width:Int,height:Int
    Field image:TImage
    Field image1:TImage
    Field image2:TImage
    Field flipBit:Int = False

    Method Create:TImageDoubleBuffer(image1:TImage, image2:TImage)
        Self.image = image1
        Self.image1 = image1
        Self.image2 = image2
        initBuffer(image.width, image.height, TGLImageFrame(image.frame(0)).name)
        Return Self
    End Method
	
    Method initBuffer(width:Int,height:Int,glTextureId:Int)
        Self.width = width
        Self.height = height
        generateFBO()
    End Method
	
    Function initGraphics(width:Int,height:Int,bit:Int=0,mode:Int=60)
        SetGraphicsDriver(GLMax2DDriver())
        Graphics width,height,bit,mode
        glewInit()
     End Function
	
     Method generateFBO()
	
        Local W:Int = width
        Local H:Int = height
		
        AdjustTexSize(W , H) 

        glGenFramebuffersEXT(1, fb )
        glGenRenderbuffersEXT(1 , rb) 
	   
		bindTexture(TGLImageFrame(image.frame(0)).name)
        glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rb[0]);
        glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, W, H);
        glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT , GL_DEPTH_ATTACHMENT_EXT , GL_RENDERBUFFER_EXT , rb[0])
	   
        Local status:Int =  glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT)
	   
        Select status
            Case GL_FRAMEBUFFER_COMPLETE_EXT 
                Print "OK" + " : " + Status
            Case GL_FRAMEBUFFER_UNSUPPORTED_EXT
                Print "GL Framebuffer Unsupported - choose different formats"
            Default
                End 
        EndSelect 
   
    End Method

    Method bindTexture(textureId:Int)
		glBindTexture(GL_TEXTURE_2D, textureId);
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fb[0]) ; 	   	   
        glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D,  textureId, 0);
    End Method
	
    Method bind()
        GetViewport(OrigX,OrigY,OrigW,OrigH)
        bindTexture(TGLImageFrame(image.frame(0)).name)
        glMatrixMode GL_PROJECTION
        glLoadIdentity
        glOrtho 0,width,0,width,-1,1
        glMatrixMode GL_MODELVIEW 
        glViewport 0,0,width,height
        glScissor 0,0,width,height

        ' flip buffers
		If flipBit 
			image = image1
		Else
			image = image2
		End If
		flipBit = Not flipBit
    End Method
	
    Method unbind()
        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
        glMatrixMode GL_PROJECTION
        glLoadIdentity
        glOrtho 0,OrigW,Origh,0,-1,1
        glMatrixMode GL_MODELVIEW 
        glViewport 0,0,OrigW,OrigH
        glScissor 0,0,OrigW,OrigH
    End Method

	Function AdjustTexSize( width:Int Var,height:Int Var )
	   'calc texture size
	    width=Pow2Size( width )
	    height=Pow2Size( height )
	    Repeat
	        Local t:Int
	        glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
	        glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
	        If t Return
	        If width=1 And height=1 RuntimeError "Unable to calculate tex size"
	        If width&gt;1 width:/2
	        If height&gt;1 height:/2
	    Forever
	End Function
	
	Function Pow2Size:Int( n:Int )
	    Local t:Int=1
	    While t&lt;n
	        t:*2
	    Wend
	    Return t
	End Function
	
End Type

</textarea><br><br><br>(Leak plugged) glsl.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Strict
Rem
Module pub.glsl

ModuleInfo "Version: 1.00"
ModuleInfo "Author: Tom Speed set uniforms bodged by ChrisC"
ModuleInfo "License: Blitz Shared Source Code"
ModuleInfo "Copyrights: Unknown"
ModuleInfo "Modserver: PUB"
EndRem

Import brl.linkedlist
Import brl.standardio
Import brl.filesystem
Import brl.system
Import pub.glew

Global ProgramObjectList:TList = CreateList()
Global ShaderObjectList:TList = CreateList()
Global shaderCompileError:String

Global clog:Byte[1024]' = MemAlloc(linked)

'Shader Object Type
Type tShaderObject
	Field ShaderObject:Int
	Field Attached:TList			' Shaders can be attached, or 'referenced by', more than 1 ProgramObject
	Field shaderName:String
	Field source:Byte[]
	Field src:String
	
	Method compile:String(source:String, shaderType:Int)
		Local sourcePtr:Byte Ptr = source.ToCString()
	    Local sourceLength:Int = source.length

		ShaderObject = glCreateShader(shaderType)
		src = source
		glShaderSourceARB(ShaderObject,1, Varptr sourcePtr, Varptr sourceLength)
		glCompileShaderARB(ShaderObject)
		
		Attached = New TList
	    shaderName = "foo "+shaderType
		ListAddLast ShaderObjectList, Self
				
		Return TShaderObject.compileError(ShaderObject)
	End Method
	
	Method compileFragment:String(source:String)
		Return compile(source,GL_FRAGMENT_SHADER)
	End Method

	Method compileVertex:String(source:String)
		Return compile(source,GL_VERTEX_SHADER)
	End Method


	Function compileError:String(id:Int)

		Local error:String = Null
		'Did the shader compile successfuly?
		Local compiled:Int
		glGetObjectParameterivARB(id,GL_OBJECT_COMPILE_STATUS_ARB, Varptr(compiled))
		If Not compiled
			Local logLength:Int
			glGetObjectParameterivARB(id,GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr(logLength))
			Local slen:Int = 0
			glGetInfoLogARB(id,1024,Varptr(slen), Varptr clog[0])
			Local err:String
			For i = 0 To logLength-1
				err:+Chr(clog[i])
			Next
			error = err
		End If
		Return error

	End Function
	
End Type

'Program Object Type
Type tProgramObject
	Field Program:Int		' The ProgramObject
	Field vList:TList		' Vertex shader list. A List of what Vert shaders are attached to this ProgramObject
	Field fList:TList		' Frag shader list. A List of what Frag shaders are attached to this ProgramObject
	Field progName:String
	
	Field vertShaderCount:Int
	Field fragShaderCount:Int



	'----------------------------------------------------
	'tProgramObject.Create(name:String)
	'
	'Creates a new Shader Program Object to which
	'multiple Vert and/or Frag Shaders can be attached to
	'
	'Returns: The newly created Program Objects ID if
	'         successful, or Null if it failed.
	'----------------------------------------------------
	Function Create:tProgramObject(name:String = "null")
		Local p:tProgramObject = New tProgramObject
		
		'Create a new GL ProgramObject
		p.Program = glCreateProgramObjectARB()
		If p.Program=0
			p = Null
			?Debug
				Print "Error: glCreateProgramObjectARB() failed"
			?
			Return Null
		End If
		
		'---------------------------------
		'The amount of Vert &amp; Frag Shaders
		'attached to this Program Object
		'---------------------------------
		p.vertShaderCount = 0
		p.fragShaderCount = 0
	
		'---------------------------------------
		'These lists contain any Vert or Frag
		'Shader Objects Attached to this Program
		'---------------------------------------
		p.vList:TList = CreateList()
		p.fList:TList = CreateList()
		
		'This Program Objects Name
		p.progName = name
		
		'------------------------------
		'Add this Program Object to the
		'Global list of ProgramObjects
		'------------------------------
		ListAddLast ProgramObjectList, p
		Return p
	End Function

	
	'---------------------------------
	'tProgramObject.Activate()
	'
	'Activates (uses!) a ProgramObject
	'---------------------------------
	Method Activate()
		glUseProgramObjectARB(Program)
	End Method

	'----------------------------
	'tProgramObject.DeActivate()
	'
	'Turns off this ProgramObject
	'----------------------------
	Method DeActivate()
		glUseProgramObjectARB(0)
	End Method

	' Get the Uniform Variable Location from a ProgramObject
	Method GetUniLoc:Int(name:String)
		Return glGetUniformLocationARB(Program, Varptr name)
	End Method

	' Get the Attribute Variable Location from a ProgramObject
	Method GetAttribLoc:Int(name:String)
		Return glGetAttribLocationARB(Program, Varptr name)
	End Method
	

	' Set Uniform Variable Integer(s)
	Method setUI1(name:String,val:Int)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI1"
				Return
			End If
		?
		glUniform1iARB(loc,val)
		MemFree namePtr
	End Method

	Method setUI2(name:String,val1:Int,val2:Int)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI2"
				Return
			End If
		?
		glUniform2iARB(loc,val1,val2)
		MemFree namePtr
	End Method

	Method setUI3(name:String,val1:Int,val2:Int,val3:Int)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI3"
				Return
			End If
		?
		glUniform3iARB(loc,val1,val2,val3)
		MemFree namePtr
	End Method

	Method setUI4(name:String,val1:Int,val2:Int,val3:Int,val4:Int)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUI4"
				Return
			End If
		?
		glUniform4iARB(loc,val1,val2,val3,val4)
		MemFree namePtr
		
	End Method

	Method getUI1:Int(name:String)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method getUI1"
				Return
			End If
		?
		Local val:Int = 10
		glGetUniformivARB(Program, loc, Varptr(val))
		MemFree namePtr
		Return val
	End Method
	
	
	' Set Uniform Variable Float(s)
	Method setUF1(name:String,val:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUF1"
				Return
			End If
		?
		glUniform1fARB(loc,val)
		MemFree namePtr
	End Method

	Method setUF2(name:String,val1:Float,val2:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "&gt;Error getting Uniform Var Location '"+name+"' in Method setUF2"
				Return
			End If
		?
		glUniform2fARB(loc,val1,val2)
		MemFree namePtr
	End Method

	Method setUF3(name:String,val1:Float,val2:Float,val3:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)

		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUF3"
				Return
			End If
		?
		glUniform3fARB(loc, val1, val2, val3)
		MemFree namePtr
	End Method

	Method setUF4(name:String,val1:Float,val2:Float,val3:Float,val4:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetUniformLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Uniform Var Location '"+name+"' in Method setUF4"
				Return
			End If
		?
		glUniform4fARB(loc,val1,val2,val3,val4)
		MemFree namePtr
	End Method

	' Set Attribute Variable Short(s)
	Method setAS1(name:String, val1:Short)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS1"
				Return
			End If
		?
		glVertexAttrib1sARB(loc, val1)
		MemFree namePtr
	End Method

	Method setAS2(name:String, val1:Short, val2:Short)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS2"
				Return
			End If
		?
		glVertexAttrib2sARB(loc, val1, val2)
		MemFree namePtr
	End Method

	Method setAS3(name:String, val1:Short, val2:Short, val3:Short)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS3"
				Return
			End If
		?
		glVertexAttrib3sARB(loc, val1, val2, val3)
		MemFree namePtr
	End Method

	Method setAS4(name:String, val1:Short, val2:Short, val3:Short, val4:Short)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS4"
				Return
			End If
		?
		glVertexAttrib4sARB(loc, val1, val2, val3, val4)
		MemFree namePtr
	End Method
	
	' Set Attribute Variable Float(s)
	Method setAF1(name:String, val1:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAF1"
				Return
			End If
		?
		glVertexAttrib1fARB(loc, val1)
		MemFree namePtr
	End Method

	Method setAF2(name:String, val1:Float, val2:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAF2"
				Return
			End If
		?
		glVertexAttrib2fARB(loc, val1, val2)
		MemFree namePtr
	End Method

	Method setAF3(name:String, val1:Float, val2:Float, val3:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAS3"
				Return
			End If
		?
		glVertexAttrib3fARB(loc, val1, val2, val3)
		MemFree namePtr
	End Method

	Method setAF4(name:String, val1:Float, val2:Float, val3:Float, val4:Float)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAF4"
				Return
			End If
		?
		glVertexAttrib4fARB(loc, val1, val2, val3, val4)
		MemFree namePtr
	End Method

	' Set Attribute Variable Double(s)
	Method setAD1(name:String, val1:Double)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD1"
				Return
			End If
		?
		glVertexAttrib1fARB(loc, val1)
		MemFree namePtr
	End Method

	Method setAD2(name:String, val1:Double, val2:Double)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD2"
				Return
			End If
		?
		glVertexAttrib2fARB(loc, val1, val2)
		MemFree namePtr
	End Method

	Method setAD3(name:String, val1:Double, val2:Double, val3:Double)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD3"
				Return
			End If
		?
		glVertexAttrib3fARB(loc, val1, val2, val3)
		MemFree namePtr
	End Method

	Method setAD4(name:String, val1:Double, val2:Double, val3:Double, val4:Double)
	    Local namePtr:Byte Ptr = name.ToCString()
		Local loc:Int = glGetAttribLocationARB(Program, namePtr)
		?Debug
			If loc&lt;0
				Print "Error getting Attribute Var Location '"+name+"' in Method setAD4"
				Return
			End If
		?
		glVertexAttrib4fARB(loc, val1, val2, val3, val4)
		MemFree namePtr
	End Method


	'----------------------------------------------------------
	'Attach &amp; Link a Vertex Shader Object to this ProgramObject
	'----------------------------------------------------------
	Method AttachVertShader:Int(myShader:tShaderObject)
		?Debug
			If Program = 0
				Print "Error: Invalid tProgramObject in method AddVertShader()"
				Print "-------------------------------------------------------"
				Print
			Else If Not myShader
				Print "Error: Invalid tShaderObject passed to method AddVertShader()"
				Print "-------------------------------------------------------------"
				Print
				Return
			End If
		?


		'--------------------------
		'Attach &amp; Link a VertShader
		'--------------------------
		glAttachObjectARB(Program, myShader.ShaderObject)
		glLinkProgramARB(Program)


		'-------------------------------
		'Check if it Linked successfully
		'-------------------------------
		Local linked:Int
		glGetObjectParameterivARB(Program,GL_OBJECT_LINK_STATUS_ARB, Varptr(linked))
		
		If Not linked
			?Debug
				'An Error occured during Linking
				'dump the error logfile to console
'				Local clog:Byte Ptr
				Local slen:Int = 0

				glGetInfoLogARB(Program,1023,Varptr slen, Varptr clog[0])
				Local err:String
				Local i:Int
				For i = 0 To slen-1
					err:+Chr(clog[i])
				Next

				Print
				Print "Failed to link VertexShader "+myShader.shaderName
				Print
				Print err+"  "+slen
			?
'			FlushMem
			Return 0
		End If
		?Debug
			Print "VertexShader "+myShader.shaderName+" attached &amp; linked ok!"
			Print
		?
	
		'Add this VertShaderObject to this ProgramObjects list
		ListAddLast vList, myShader

		'Add this ProgramObject to this Shaders 'attached to' list
		ListAddLast myShader.Attached, Self
		Return 1
	End Method

	'------------------------------------------------------------
	'Attach &amp; Link a Fragment Shader Object to this ProgramObject
	'------------------------------------------------------------
	Method AttachFragShader:Int(myShader:tShaderObject)
		?Debug
			If Program = 0
				Print "Error: Invalid tProgramObject in method AddFragShader()"
				Print "-------------------------------------------------------"
				Print
			Else If Not myShader
				Print "Error: Invalid tShaderObject passed to method AddFragShader()"
				Print "-------------------------------------------------------------"
				Print
				Return
			End If
		?


		'--------------------------
		'Attach &amp; Link a FragShader
		'--------------------------
		glAttachObjectARB(Program, myShader.ShaderObject)
		glLinkProgramARB(Program)


		'-------------------------------
		'Check if it Linked successfully
		'-------------------------------
		Local linked:Int
		glGetObjectParameterivARB(Program,GL_OBJECT_LINK_STATUS_ARB, Varptr(linked))

		If Not linked
			?Debug
				'An Error occured during Linking
				'dump the error logfile to console
'				Local clog:Byte Ptr
				Local slen:Int = 0

				glGetInfoLogARB(Program,1023,Varptr slen, Varptr clog[0])
				Local err:String
				Local i:Int
				For i = 0 To slen-1
					err:+Chr(clog[i])
				Next

				Print
				Print "Failed to link FragShader '"+myShader.shaderName+"'"
				Print
				Print err
			?
			
'			FlushMem
			Return 0
		End If

		?Debug
			Print "FragShader '"+myShader.shaderName+"' attached &amp; linked ok!"
			Print
		?
		
		'Add this FragShaderObject to this ProgramObjects list
		ListAddLast fList, myShader
		
		'Add this ProgramObject to this Shaders 'attached to' list
		ListAddLast myShader.Attached, Self
		
		'Return Ok!
		Return 1
	End Method	

	'-------------------------------------------------------
	'Detach a VertShader:tShaderObject from a tProgramObject
	'-------------------------------------------------------
	Method DetachVertShader(vShader:tShaderObject)
		If ListContains(vList,vShader)
			glDetachObjectARB(Program, vShader.ShaderObject)
			RemoveLink(ListFindLink(vList,vShader))
			RemoveLink(ListFindLink(vShader.Attached, Self))
			?Debug
				Print "Detached '"+vShader.shaderName+"' from ProgramObject '"+Self.progName+"'"
			?
		End If
	End Method

	'-------------------------------------------------------
	'Detach a FragShader:tShaderObject from a tProgramObject
	'-------------------------------------------------------
	Method DetachFragShader(fShader:tShaderObject)
		If ListContains(fList,fShader)
			glDetachObjectARB(Program, fShader.ShaderObject)
			RemoveLink(ListFindLink(fList,fShader))
			RemoveLink(ListFindLink(fShader.Attached, Self))
			?Debug
				Print "Detached '"+fShader.shaderName+"' from ProgramObject '"+Self.progName+"'"			
			?
		End If
	End Method
	
	'------------------------------------------------------
	'Dump a list of Shaders attached to this tProgramObject
	'------------------------------------------------------
	Method ListAttachedShaders()
		Print "Vertex Shader(s) attached to ProgramObject '"+Self.progName+"'"
		Print "----------------------------------------------------------------------"
		If vList.Count() = 0
			Print "No Vertex Shaders attached"
		Else
			For Local v:tShaderObject = EachIn vList
				Print v.shaderName
			Next
		End If
		
		Print
		Print "Fragment Shader(s) attached to ProgramObject '"+Self.progName+"'"
		Print "-----------------------------------------------------------------------"
		If fList.Count() = 0
			Print "No Fragment Shaders attached"
		Else
			For Local f:tShaderObject = EachIn fList
				Print f.shaderName
			Next
		End If
		Print
	End Method
End Type

Function DeleteVertShader(vShader:tShaderObject Var)
	If Not vShader Return

	RemoveLink(ListFindLink(ShaderObjectList,vShader))
	
	' Detach this ShaderObject from all ProgramObjects it was attached to
	For Local p:tProgramObject = EachIn ProgramObjectList
		If ListContains(p.vList, vShader)
			p.DetachVertShader(vShader)
		End If
	Next
	
	' Delete the shader
	glDeleteObjectARB(vShader.ShaderObject)
	?Debug
		Print "Deleted ShaderObject '"+vShader.shaderName+"'"
		Print
	?
	vShader = Null
End Function
	
Function DeleteFragShader(fShader:tShaderObject Var)
	If Not fShader Return
	
	RemoveLink(ListFindLink(ShaderObjectList,fShader))
		
	' Detach this ShaderObject from all ProgramObjects it was attached to
	For Local p:tProgramObject = EachIn ProgramObjectList
		If ListContains(p.fList, fShader)
			p.DetachFragShader(fShader)
		End If
	Next
	
	' Delete the shader
	glDeleteObjectARB(fShader.ShaderObject)
	?Debug
		Print "Deleted ShaderObject '"+fShader.shaderName+"'"
		Print
	?
	fShader = Null
End Function


</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1086375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting, thanks for the examples. <br><br></td></tr></table><br>
<a name="1086442"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been playing around with this. pretty neat! <br><br>I'm guessing that if you want to run a shader on quad, the only way to do it is with FBO? other wise the shader is always drawn at global coordinates and the quad just acts as a small window. <br><br>Also, I'm not sure why, but this program leaks memory pretty badly. <br><br></td></tr></table><br>
<a name="1086453"></a>

<a name="1086459"></a>

<a name="1086460"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tesuji</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure I understand exactly what you mean but you can use shaders without FBOs and not lose too much flexibility. My recent demo <a href="http://blitzbasic.com/Community/posts.php?topic=94580" target="_blank">http://blitzbasic.com/Community/posts.php?topic=94580</a> wasn't using FBOs.<br><br>FBOs do have some advantages though. The main one I'm using is the render to texture feature which allows me to process every pixel *and* record the processed result, ideal for cellular automata. Other benefits include being able to apply a shader to an area larger than the screen and also detach the texture updates from the rendering cycle. e.g. I can do 2 automata shader passes and only display 1.<br><br>eek. thanks for the spot on the leak. Initial investigation shows it's likely to be the glsl.bmx library. setUF2 etc.. don't appear to be release their resources. If I move them outside of the loop, it appears to stop leaking.<br>My money is on the name.ToCString() call. Will look into this further.<br><br>edit - Leakyness was indeed because of those pesky ToCString() calls. I've patched glsl.bmx with the requisite memfrees and included it in the post above. Could really do with rewriting/tidying up that module and re-releasing to the code archives. It's a bit long in the tooth. Here's a 5yr old post indicating how they got added. <a href="http://blitzbasic.com/Community/posts.php?topic=53873#601941" target="_blank">http://blitzbasic.com/Community/posts.php?topic=53873#601941</a><br>Easy mistake to make when you're used to auto memory management.<br><br>Anyhow, back to work on my GLSL Life app. Still loads to do : <img src="http://snafoo.net/downloads/glsl_life_001a.png"><br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1086464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Not sure I understand exactly what you mean but you can use shaders without FBOs and not lose too much flexibility <br></div><br>I meant that even if you set the frag shader to run with the dimensions of your dest image, the shader runs in screen space and your dest image just acts as a viewport into screenspace. As an example, make your image smaller than the window size and attach it to the mouse x/y and see what I mean. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
