<!DOCTYPE html><html lang="en" ><head ><title >What are pointers FOR?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >What are pointers FOR?</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=528" >Monkey Beginners</a>/<a href="#bottom" >What are pointers FOR?</a><br><br>
<a name="2123479"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> So, you make something like this in your "Main_Single.code" thing somewhere:<br><br><pre class=code>
//Psuedo Code Yo....

int main()
{

H_WINDOW *windowMain = new H_WINDOW(//params)


}
</pre><br><br>So I just initialized(HOPEFULLY, I MEAN I MIGHTA TYPE THIS WRONG) a pointer called windowMain, which isn't a variable? or is it a variable with a memory address? I'm confused here, why wouldn't I just use windowMain and simply reference this. I've been told that if you do not master pointers you will be considered as the lowest tier programmer to ever exist, your very creations will rebel against you, and you will lament forever in your failure and pitiful understanding of not only game, but application development...... for all time.<br><br><br>But I'm kinda ok with that, but now I want to understand <br><br>A. Why I really want to know about them since theyre so good for you, not just in any languages, but ALL languages<br><br>B. Theyre super powerful and make things easier... than doing something straight forward apparently.<br><br>C. They streamline design and cut down on waste?<br><br>But here is my problem with pointers:<br><br>A. You keep referencing the same memory address, over and over... so its just a "glorified" way of passing a value? Why do I want to keep doing this? Why not assign values from values and free variables after I am done using them?<br><br>B. The main use of pointers is for memory management, or in the case of C being able to pass variables between functions since C doesnt have classes, only C++ does...<br><br>C. In the case of C++......... why? I'm dumb.<br><br><br>Seriously, I am stupid, please help, everyone I ask says I need to keep reading the same tutorials that I've already read, and to me it makes no sense. I mean 90% of all tutorials keep using pointers and thats in C++ only libs! <br><br>Perhaps I should go off the deep end, try and make apps without pointers and learn through trial and error as to why I need them in application development. Clearly I am an unknowing traveler, unfit for the inner sanctum of internet code champions.... clearly I am the problem.<br><br>Anyway, if anyone could break down the history of pointers, why I need them, and what they do INSTEAD of directly referencing variables between types/classes (apparently something C cant do, but something C++ CAN do, but still chooses not to do when using pointers... errm *scratch head*_ I'd be eternally grateful.. I can draw you really bad pixel art as a reward? Just tell me the genre..... <br><br></td></tr></table><br>
<a name="2123482"></a>

<a name="2123483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You DON'T need them if you are using Monkey, or Java, or similar languages.<br><br>These languages use them 'under the hood', because when you reference an object you are actually passing a pointer.  But they don't let you do fancy things with them as you can with C/C++.  The fancy things can be great for making highly optimised code, but they can also give you great opportunities to make problems for yourself.  <br><br>One important aspect of the difference is that Monkey / Java / C# etc. have 'garbage collection' which means you can forget about objects that can no longer be accessed.  In C / C++, you have to make sure such objects get deleted when you're no longer using them.  The Monkey-style languages reduce your ability to access and control objects exactly as you like - but in return, they make life easier in some respects by managing all the pointers. <br><br></td></tr></table><br>
<a name="2123484"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Like, what fancy things? I don't see what can be fancy about passing something that never changes? Am I wrong here? <br><br></td></tr></table><br>
<a name="2123522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would suggest that you get a copy of Beginning C++ by Ivor Horton (he also has a book on C). And search the internet for pointer use. <a href="http://www.cplusplus.com/" target="_blank">http://www.cplusplus.com/</a> should be a good place to start. Check out <a href="http://www.cplusplus.com/articles/z6vU7k9E/" target="_blank">http://www.cplusplus.com/articles/z6vU7k9E/</a> for argument passing by value, reference and pointer.<br><br>&gt; A. Why I really want to know about them since theyre so good for you, not just in any languages, but ALL languages<br>Not all computer languages support the use of pointers. Languages such as Monkey/Java/C# do all the memory management for you behind the scene, so you do not have to worry so much about memory or about pointers.<br><br>A thing to remember.<br>Other than programming directly in assembly language or machine code. All advanced languages will have run time libraries to do some of the dirty work.<br><br>&gt; B. Theyre super powerful and make things easier... than doing something straight forward apparently.<br><br>What is a pointer? Well the definition is a variable that holds the memory address of another variable.<br><iframe width="560" height="345" src="http://www.youtube.com/embed/W0aE-w61Cb8" frameborder="0" allowfullscreen></iframe><br><br>What does this mean? As modern operating systems allocate the memory that your application and it's data will use; there is no way for you to know where in memory a particular variable or data object is stored. This is where pointers come in. When you allocate memory with the <b>new</b>/<b>malloc</b>, it will return an address where this memory has been allocated. When you have finished doing what you need to do with that memory. You would use <b>free()</b>/<b>delete</b>.<br>The power of a pointer is that it will give you direct access to memory.<br><br>The fancy things Gerry Quinn speaks of are operating on data structures such as walking arrays, using linked lists (do a search on self modifying code as well). Look for "Data Structures and Algorithms for Game Developers". There should be a few books in print and as eBooks, as well as a few web pages on the matter.<br><br>You also need pointers for loading dynamic linked libraries. Without pointers programming a modern computer would be virtually impossible.<br><br>One thing to be aware of is that pointers are a powerful and wielding such power comes with a responsibility. It's very easy to crash a program or the operating system in some cases when not paying attention with the use of pointers. Reassigning a pointer without first freeing any memory that was assigned to it beforehand creates what is known as a memory leak.<br><br>You can find more videos on pointers. Just copy and paste the line below into a web browsers address bar.<br>https://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=c%2B%2B+pointers&amp;tbm=vid <br><br></td></tr></table><br>
<a name="2123521"></a>

<a name="2123512"></a>

<a name="2123511"></a>

<a name="2123510"></a>

<a name="2123509"></a>

<a name="2123508"></a>

<a name="2123507"></a>

<a name="2123506"></a>

<a name="2123505"></a>

<a name="2123504"></a>

<a name="2123503"></a>

<a name="2123502"></a>

<a name="2123501"></a>

<a name="2123500"></a>

<a name="2123499"></a>

<a name="2123498"></a>

<a name="2123497"></a>

<a name="2123496"></a>

<a name="2123495"></a>

<a name="2123494"></a>

<a name="2123492"></a>

<a name="2123493"></a>

<a name="2123490"></a>

<a name="2123491"></a>

<a name="2123487"></a>

<a name="2123488"></a>

<a name="2123489"></a>

<a name="2123486"></a>

<a name="2123514"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> no,thanks to you both,  I THINK I got it now(that video I saw it before but didnt understand the difference between &amp;(get address, use only with original value or to get any other variables memory address, I guess) *(get value at address stored in a pointer, dont use on non pointer initialized variable), someone should simply say "Pointers are C/C++ version of local variables." <br>So I can make a function:<br><br><pre class=code>
//lazy syntax code
int DoMathWithAVar(int* varPassed) //passed into a temporary pointer.. do I initialize it here as NULL?
{
//I believe I could just work with varPassed but I'd rather not, so I guess this is rapidly passing a pointer to another pointer?
int* workMath = &amp;varPassed;

*workMath += *workMath + mathChangeInValue;

Return *workMath; //or do I return
}
</pre><br><br>if this is the case, then I can see the use, especially in concerns of directly managing your own memory in the C/C++ language, perhaps this is what everyone keeps saying when they say "You must do it yourself if you use C/C++!!!"<br>ehh maybe anyway... well thanks this seems var simpler now that I had kind individuals spell it out for me. <br><br></td></tr></table><br>
<a name="2123513"></a>

<a name="2123534"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> someone should simply say "Pointers are C/C++ version of local variables." <br></div>That would be wrong. Pointers are a special kind of data type. The amount of bytes assigned to a pointer depends of the compiler and the target CPU architecture. You should think of them as a memory address data type.<br><br>As for your function code. It wouldn't work. It would complain about conversion between data types. And as you are passing an address, you can only use de-reference. Trying to assign the parameter passed to a pointer variable would just make the pointer variable an alias. <br>int* workMath = &amp;varPassed; // remove &amp; to make it work as an alias.<br><br>See <a href="http://www.learncpp.com/" target="_blank">www.learncpp.com/</a>. Chapters 6 and 7 <br><br></td></tr></table><br>
<a name="2123533"></a>

<a name="2123532"></a>

<a name="2123531"></a>

<a name="2123530"></a>

<a name="2123529"></a>

<a name="2123528"></a>

<a name="2123527"></a>

<a name="2123526"></a>

<a name="2123525"></a>

<a name="2123524"></a>

<a name="2123523"></a>

<a name="2123536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> So it is a memory data type, that can work with memory, and assign values to memory, and return values dereferenced from inside its memory that is stored or POINTED at from inside itself?<br><br>Ok, I get it. ....maybe.<br><br>So to get this straight, a pointer, holds a memory address, which can hold any value type aslong as the pointer is initialized as that type.<br><br>In storage, or within your program, a pointer is a special variable for holding references to location in your programs memory which hold datatypes. And other than the need for working directly with memory for reasons....we do this, generally, so we dont keep making new variables which can increase memory usage in C++ or similar languages? Or do we do this so we initialize pointers<br><br>Assuming all this is correct, why do alot of lib tutorials out there initialize new data types as pointers, and then work directly with them as an alias? Is that so they can easily reference the memory address later in some kind of clean up command? <br><br></td></tr></table><br>
<a name="2123543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> everything in computer memory has an address: code has an address variables have an address  data has an address. the address is the position in memory where the variable, code or data is located. everything is stored as bits. Pointer only point to the location where  a certain data type is stored regardless of its type declaration. variable names are used for the programmer to easily represent memory location for certain data types. with pointers you can access the data it points in any format. for example if you store an integer in memory you can access the address of the integer in bytes format. you can read the first and second byte of a 16 bit int by accessing it with byte ptrs.<br>&gt;local a:int = 35<br>&gt;local b:Byte Ptr = Byte Ptr(a)<br>b[0] would be the first part(8 bit) of the 16 bit integer<br>b[1]  would be the  second part(8 bit) of the 16 bit integer<br>to access "a" as an integer:<br>&gt;local b:int Ptr = Int Ptr(a)<br>b[0] would access the whole integer.<br>b[1] would cause an error as it's beyond the position of the integer. its all a result of the integer ptr definition.<br>if b is a pointer, the address to where the variable "b" is pointing can also be changed like this:<br>&gt;b = b + 1<br>as related to this last definition, in this case b will point to the next integer which is none existing or an address in memory which does not necessarily belong to an integer. <br>or <br>&gt;b = 50<br>be careful with pointers because if you don't know what's in an address that's beyond the length of the stored data then you can easily crash the program or even the computer.<br><br>pointers are quite useful in languages that support them but have a potential to cause many problems in program design as the compiler is limited in the ability to check if a pointer variable is pointing to a valid data address. it's mostly left to the skill of the programmer to stay within the bounds of the ptr type.<br><br>another thing to note: if you are working with Apple operating systems and Windows operating systems. you need to learn about big Endian and little Endian. it's the way data types are stored in the computer by the operating system. do a google look up to find out more. <br><br></td></tr></table><br>
<a name="2123542"></a>

<a name="2123541"></a>

<a name="2123538"></a>

<a name="2123539"></a>

<a name="2123540"></a>

<a name="2123549"></a>

<a name="2123546"></a>

<a name="2123559"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> So it is a memory data type, that can work with memory, and assign values to memory, and return values dereferenced from inside its memory that is stored or POINTED at from inside itself? <br></div><br>A pointer is a special data type/variable that can hold the memory address of another data object. When you declare a pointer; it must match the data type of the object that you wish to get the address of e.g <br>int x = 25; // data type is int<br>int *xPtr = &amp;x; // declare a pointer to memory address of x. The pointer must be of type int as that is what the variable x is<br>char arr[5] = {'a','b','c','d','e',0}; // fixed array of data type char<br>char *arrPtr = arr; //same as char *arrPtr = &amp;arr[0]. The compiler is smart enough to know that arr is an address to the first element, as the  creation of a fixed (i.e hard coded) array automatically allocates memory and returns an address.<br><br>But there is an exception to this rule when declaring a pointer as type <b>void</b>. A void pointer is a generic pointer that can hold the memory address for any data type, but the penalty for doing so means that you have to remember the data type that you are pointing to and use data type casting in the dereferencing.<br><br>The C way to do this is<br>int deref = *(int*)voidPtr; // cast the void pointer back to an int and dereference<br><br>The C++ way is<br>int deref = *static_cast&lt;int*&gt;(voidPtr); // cast the void pointer back to an int and dereference<br><br>If you declared deref as a pointer and remover the deference specifier in front of the cast. You can then use deref as an alias and save typing the full cast as well as memory and speed of execution every time you wished to access the void pointer. <br>See www.learncpp.com/. Chapters 6.13<br><br>You can use a pointer for indirect access or as a handle to a data object/function. A pointer used as a handle can be used to call data object functions and manipulate data object members. When you load a shared library manually at runtime, you have to use the handle so you can create pointers to the functions that the shared library exports. You are basically getting the memory address of those functions. Shared libraries linked at compile time do not need to do this.<br><br><div class="quote"> we do this, generally, so we dont keep making new variables which can increase memory usage in C++ or similar languages? <br></div>One thing you will need to know is how the operating system allocates memory for an application.<br>Here as a number of articles on the subject<br><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank">http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/</a><br><a href="https://www.usna.edu/Users/cs/aviv/classes/ic221/s14/lec/06/lec.html" target="_blank">https://www.usna.edu/Users/cs/aviv/classes/ic221/s14/lec/06/lec.html</a><br><a href="https://en.wikipedia.org/wiki/Data_segment" target="_blank">https://en.wikipedia.org/wiki/Data_segment</a>  (you should follow the links for BSS, Call Statck and Code segment)<br><br>As you can see a lot of stuff get allocated to the stack by default. The stack has a limit, plus things get add to it and removed from it quite a lot. A pointer to something that may end up being removed and then using that pointer to accessed non existent data would throw an exception error and stop program execution. This can happen when the variable goes out of <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)" target="_blank">scope</a> or overwritten.<br><br>You will always be creating variables. Be they pointers or otherwise in the languages that support them.<br><br>The memory usage side.<br>If you create a big data structure on the stack; then you will run out of stack space if you have to create an array of such structures. You would use the <b>new</b> operator to allocate the memory, which returns a memory address that you would store in a pointer (you can call this a handle). To access this new data object/structure(s) on the heap via pointers, you use member of pointer(-&gt;) operator in C/C++.<br>e.g.<br>class MyClass<br>{<br>    int val = 5;<br>    public:<br>    int functionInOjbject( int v ){<br>         return this-&gt;val += v;<br>    }<br>}<br><br>MyClass *ptr2myclass = new MyClass;<br>int result = ptr2myclass-&gt;functionInOjbject(5);<br>delete ptr2myclass; // Finished with it, so release the memory allocated or you could end up with a memory leak.<br><br>Note as you can declare pointers as arrays (the basic container type); there is nothing from stopping you from allocating a number of data objects.<br><br>A couple of related topics<br><a href="http://www.tutorialspoint.com/cplusplus/cpp_references.htm" target="_blank">http://www.tutorialspoint.com/cplusplus/cpp_references.htm</a><br><a href="http://www.tutorialspoint.com/cplusplus/cpp_pointers.htm" target="_blank">http://www.tutorialspoint.com/cplusplus/cpp_pointers.htm</a><br><a href="http://www.thegeekstuff.com/2013/05/cpp-reference-variable/" target="_blank">http://www.thegeekstuff.com/2013/05/cpp-reference-variable/</a><br><br>Function parameters.<br>If you passes a variable holding a data object by value; meaning not as a (*)pointer or by (&amp;)reference. Then you suffer a performance hit in speed and memory if the data object is big. Passing by value makes a copy of the object. This means you are working on a copy and not the original. You would have to return the whole copied object; in affect a new object. Wasteful if you only need to make a minor change or access a few data members.<br><br>I think that the links below should explains the difference of by value, by reference and by pointer.<br><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html" target="_blank">https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html</a><br><a href="http://www.tutorialspoint.com/cplusplus/cpp_functions.htm" target="_blank">http://www.tutorialspoint.com/cplusplus/cpp_functions.htm</a><br><br><div class="quote">  Or do we do this so we initialize pointers <br></div>When you declare a pointer you should initialise it immediately either with the address of the variable that you want it to point to, or as NULL or 0. An uninitialised pointer will have a random data and using it like that can have unusual effects or crash the program/system. <br><br></td></tr></table><br>
<a name="2123547"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah well, no one ever told me all this, it wasn't explained to me very well and having used other languages that apparently handle all the pointers behind the scenes. <br>So all current non C/C++ languages like BASIC and C# use pointers behind the scenes to handle data(variables/code/types/etc) you make in a way that manages the memory efficiently just like in C++? Wow. Seems like theyre important to a basic understanding of any programming language then. I had no idea what they were for and how integral it was to use them in programming. Thanks again everyone. I think I got it now, atleast I am much less afraid of using them beyond the fact using them wrong is not wise. <br><br></td></tr></table><br>
<a name="2123548"></a>

<a name="2123550"></a>

<a name="2123563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you read <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)" target="_blank">Pointer_(computer_programming)</a>. It will show you a number of programming languages; what memory access methods they use and a few examples.<br><br>Edit: Not on topic, but worth knowing.<br>If you have ever seen the function main of a windows GUI application (aka application entry point). You will see that it's defined as<br><br>int CALLBACK WinMain(<br>  _In_ HINSTANCE hInstance,<br>  _In_ HINSTANCE hPrevInstance,<br>  _In_ LPSTR     lpCmdLine,<br>  _In_ int       nCmdShow<br>);<br><br>Sometimes you see CALLBACK as WINAP. These are aliases for what is know as a <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank">calling convention</a>.<br>Another link to read on these.<br><a href="http://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified" target="_blank">http://www.codeproject.com/Articles/1388/Calling-Conventions-Demystified</a> <br><br></td></tr></table><br>
<a name="2123560"></a>

<a name="2123573"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have a question<br><pre class=code>
//
bool* boolVar = new bool;
///
    bool** _boolVar = &amp;boolVar;
    cout &lt;&lt; endl &lt;&lt; _boolVar &lt;&lt; " // " &lt;&lt; &amp;boolVar&lt;&lt; endl &lt;&lt; &amp;_boolVar;
    cout &lt;&lt; endl &lt;&lt; *boolVar;
    cout &lt;&lt; endl &lt;&lt; **_boolVar;
    cout &lt;&lt; endl;

</pre><br><br>This does everything I want, and I can understand evrrything I wanted to about pointers (ehhh, less than more) but I can use them a bit more now and I am reading those tutorials you linked me but I still cant understand, why does bool** _boolVar need to be declared as a double pointer? (or wghatever theyre called) is it because the memory address is a pointer originally?<br><br>Why does bool* _boolVar = boolVar work?<br>bool** _boolVar || bool*_boolVar = *boolVar does not work.<br><br><br>also a smal question when casting a passed array back into a type why does TYPE* (*typeVarName)[int] become equal to TYPE* typeVarName[int][int] is it because the original array of types degraded back into a pointer like ive read arrays being passed degrade into? and then C++ simply adds the extra dimensions? Is it purely syntax rules here?<br><br>I have also understanding of how you can read multi-dimensional arrays if this helps:<br><br>arrType[int][int] == {{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}} == {1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4}<br><br>but I am confused and I did read that article that had an example but I figure I'd ask again.... eh sorry.<br><br>Anyway thanks I can atleast use and work with pointers, they do make life much more entertaining since I have a very nice datatype to work with.<br><br>Oh And about the first example, I did some testing and it does appear everything gets its own memory address, the pointer, the variable it points to, the pointer of the poiinter, the sun, the moon, the stars........... it was a realm eye opener. <br><br></td></tr></table><br>
<a name="2123579"></a>

<a name="2123580"></a>

<a name="2123578"></a>

<a name="2123581"></a>

<a name="2123583"></a>

<a name="2123582"></a>

<a name="2123584"></a>

<a name="2123585"></a>

<a name="2123586"></a>

<a name="2123587"></a>

<a name="2123588"></a>

<a name="2123591"></a>

<a name="2123590"></a>

<a name="2123589"></a>

<a name="2123597"></a>

<a name="2123681"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I will try to answer your questions.<br>&gt; why does bool** _boolVar need to be declared as a double pointer?<br>This is because you are making a pointer to a pointer, which in turn points to the original variable. This is another form of indirection. You can create as many indirection's as you like e.g bool ***_boolBar. But it would get a bit silly and a lot harder to keep track of whats going on.<br><br>So why use a pointer to a pointer? I can think of two reasons.<br>1) Creation and manipulation of <a href="http://www.cplusplus.com/forum/articles/7459/" target="_blank">Dynamic N Multi-Dimensional Arrays</a>.<br>2) Being able to affect the pointer that's being pointed too. <br><br>The second would be more common with the use of functions. When you call a function; you are passing by value no matter whether if you pass by reference or by pointer. You are still making a copy of whats been passed.<br>For example if you pass an object that's 1 mega byte in size by value; then you are copying 1 mega byte of data, where as if you use call by reference or pointer. You are only copying over that reference or pointer. This could be 4-8 bytes depending on the operating system architecture. As you are working on a copy which will be local to that function, any changes will not affect the original. But there are times when you may need to make a change to the pointer it's self while in a function That's when you need a pointer to a pointer. When doing this, you must preserve the original address if you allocated memory on the heap or suffer a memory leak.<br><br>&gt;bool** _boolVar || bool*_boolVar = *boolVar does not work.<br>You are trying to use a logical OR operator on a declaration. C/C++ and a few other languages are a strong typed language. Meaning that variables and data types must be predefined. Plus the the compiler would complain about data type conversion.<br><br>&gt;also a smal question when casting a passed array back into a type why does TYPE* (*typeVarName)[int] become equal to TYPE* typeVarName[int][int] is it because the original array of types degraded back into a pointer like ive read arrays being passed degrade into? and then C++ simply adds the extra dimensions? Is it purely syntax rules here?<br><br>That one would be tricky to answer. If it compiles then you should have got a warning in the build console explaining why.<br><br>&gt; I have also understanding of how you can read multi-dimensional arrays if this helps:<br>arrType[int][int] == {{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}} == {1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4}<br><br>Yes they would be treated as a block. You should be able to examine memory when debugging or using a disassembler.<br>Edit: A small example.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">#include &lt;iostream&gt;

using namespace std;

int main()
{
    unsigned char arrMultiDim[4][4]={
                    {'a','b','c','d'},
                    {'f','g','h','i'},
                    {'j','k','l','m'},
                    {'n','o','p','q'}
                    };

   unsigned char arrMultiPseudo[16]={
                        'a','b','c','d',
                        'f','g','h','i',
                        'j','k','l','m',
                        'n','o','p','q'
                    };
    // Both of these should output the letter l
    cout &lt;&lt; "arrMultiDim: " &lt;&lt; arrMultiDim[2][2] &lt;&lt; endl;
    cout &lt;&lt; "arrMultiPseudo: " &lt;&lt; arrMultiPseudo[2*4+2] &lt;&lt; endl;
    return 0;
}</textarea><br>Now the same program, but with added machine code disassembly. Note that the memory addresses will be different on another machine and this is gdb output.<br>If you want to see actual assembly code. The use the compiler via the command line terminal passing the appropriate compiler option to generate assembler only.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">6  	{
0x40093d	push   rbp
0x40093e	mov    rbp,rsp
0x400941	push   rbx
0x400942	sub    rsp,0x38
0x400946	mov    rax,QWORD PTR fs:0x28
0x40094f	mov    QWORD PTR [rbp-0x18],rax
0x400953	xor    eax,eax
7  	    unsigned char arrMultiDim[4][4]={
8  	                    {'a','b','c','d'},
9  	                    {'f','g','h','i'},
10 	                    {'j','k','l','m'},
11 	                    {'n','o','p','q'}
12 	                    };
0x400955	mov    BYTE PTR [rbp-0x40],0x61
0x400959	mov    BYTE PTR [rbp-0x3f],0x62
0x40095d	mov    BYTE PTR [rbp-0x3e],0x63
0x400961	mov    BYTE PTR [rbp-0x3d],0x64
0x400965	mov    BYTE PTR [rbp-0x3c],0x66
0x400969	mov    BYTE PTR [rbp-0x3b],0x67
0x40096d	mov    BYTE PTR [rbp-0x3a],0x68
0x400971	mov    BYTE PTR [rbp-0x39],0x69
0x400975	mov    BYTE PTR [rbp-0x38],0x6a
0x400979	mov    BYTE PTR [rbp-0x37],0x6b
0x40097d	mov    BYTE PTR [rbp-0x36],0x6c
0x400981	mov    BYTE PTR [rbp-0x35],0x6d
0x400985	mov    BYTE PTR [rbp-0x34],0x6e
0x400989	mov    BYTE PTR [rbp-0x33],0x6f
0x40098d	mov    BYTE PTR [rbp-0x32],0x70
0x400991	mov    BYTE PTR [rbp-0x31],0x71
14 	   unsigned char arrMultiPseudo[16]={
15 	                        'a','b','c','d',
16 	                        'f','g','h','i',
17 	                        'j','k','l','m',
18 	                        'n','o','p','q'
19 	                    };
0x400995	mov    BYTE PTR [rbp-0x30],0x61
0x400999	mov    BYTE PTR [rbp-0x2f],0x62
0x40099d	mov    BYTE PTR [rbp-0x2e],0x63
0x4009a1	mov    BYTE PTR [rbp-0x2d],0x64
0x4009a5	mov    BYTE PTR [rbp-0x2c],0x66
0x4009a9	mov    BYTE PTR [rbp-0x2b],0x67
0x4009ad	mov    BYTE PTR [rbp-0x2a],0x68
0x4009b1	mov    BYTE PTR [rbp-0x29],0x69
0x4009b5	mov    BYTE PTR [rbp-0x28],0x6a
0x4009b9	mov    BYTE PTR [rbp-0x27],0x6b
0x4009bd	mov    BYTE PTR [rbp-0x26],0x6c
0x4009c1	mov    BYTE PTR [rbp-0x25],0x6d
0x4009c5	mov    BYTE PTR [rbp-0x24],0x6e
0x4009c9	mov    BYTE PTR [rbp-0x23],0x6f
0x4009cd	mov    BYTE PTR [rbp-0x22],0x70
0x4009d1	mov    BYTE PTR [rbp-0x21],0x71
20 	    // Both of these should output the letter l
21 	    cout &lt;&lt; "arrMultiDim: " &lt;&lt; arrMultiDim[2][2] &lt;&lt; endl;
0x4009d5	movzx  eax,BYTE PTR [rbp-0x36]
0x4009d9	movzx  ebx,al
0x4009dc	mov    esi,0x400b34
0x4009e1	mov    edi,0x601080
0x4009e6	call   0x400810 &lt;std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)@plt&gt;
0x4009eb	mov    esi,ebx
0x4009ed	mov    rdi,rax
0x4009f0	call   0x4007e0 &lt;std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, unsigned char)@plt&gt;
0x4009f5	mov    esi,0x400840
0x4009fa	mov    rdi,rax
0x4009fd	call   0x400830 &lt;std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))@plt&gt;
22 	    cout &lt;&lt; "arrMultiPseudo: " &lt;&lt; arrMultiPseudo[2*4+2] &lt;&lt; endl;
0x400a02	movzx  eax,BYTE PTR [rbp-0x26]
0x400a06	movzx  ebx,al
0x400a09	mov    esi,0x400b42
0x400a0e	mov    edi,0x601080
0x400a13	call   0x400810 &lt;std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)@plt&gt;
0x400a18	mov    esi,ebx
0x400a1a	mov    rdi,rax
0x400a1d	call   0x4007e0 &lt;std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, unsigned char)@plt&gt;
0x400a22	mov    esi,0x400840
0x400a27	mov    rdi,rax
0x400a2a	call   0x400830 &lt;std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))@plt&gt;
23 	    return 0;
0x400a2f	mov    eax,0x0
24 	}
0x400a34	mov    rdx,QWORD PTR [rbp-0x18]
0x400a38	xor    rdx,QWORD PTR fs:0x28
0x400a41	je     0x400a48 &lt;main()+267&gt;
0x400a43	call   0x400820 &lt;__stack_chk_fail@plt&gt;
0x400a48	add    rsp,0x38
0x400a4c	pop    rbx
0x400a4d	pop    rbp
0x400a4e	ret</textarea><br>The bits of interest are the rbp-0xXX in the  mov BYTE PTR instructions where the arrays are being defined. If you declared a fixed array out side of a function; then the compiler pre-allocates the memory in the .data section and no need for the x86 instruction mov. <br><br></td></tr></table><br>
<a name="2123680"></a>

<a name="2123679"></a>

<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
