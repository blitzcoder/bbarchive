<!DOCTYPE html><html lang="en" ><head ><title >Free an array</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Free an array</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=528" >Monkey Beginners</a>/<a href="#bottom" >Free an array</a><br><br>
<a name="2113126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hub</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi !<br>Is there a way to quickly free and array ?<br>Thanks. <br><br></td></tr></table><br>
<a name="2113127"></a>

<a name="2113131"></a>

<a name="2113134"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I would have thought that setting the array to MyArray=NULL would do the trick and let the GC clean it up when it gets round to it. But GC doesn't work the same on all targets.<br><br>See <a href="http://www.monkey-x.com/docs/html/Programming_App%20config%20settings.html" target="_blank">http://www.monkey-x.com/docs/html/Programming_App%20config%20settings.html</a><br>for GC settings. <br><br></td></tr></table><br>
<a name="2113128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MikeHart</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> use <br><br><pre class=code>yourArray = yourArray.Resize(0)</pre> <br><br></td></tr></table><br>
<a name="2113129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MikeHart</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, that doesn't free it actually. Better read completely before I write. Sorry. <br><br></td></tr></table><br>
<a name="2113136"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hub</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> target = android. <br><br></td></tr></table><br>
<a name="2113137"></a>

<a name="2113138"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> As you are targeting Android. I would suggest looking array reuse rather than trying to free the whole array. I would think that suitable classes that should not be too much of a performance hit for this would be Pool and Stack. <br><br></td></tr></table><br>
<a name="2113143"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hub</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> it's just when i want reload all my data without quit and lauch the app So perhaps resize(0) is in my case a good choice ? <br><br></td></tr></table><br>
<a name="2113141"></a>

<a name="2113225"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>This should cover most of the pitfalls, and behaviors you'll encounter with arrays:</b><br><br>The formal syntax to empty an array is <b>[]</b>. 'Resize' should work just as well. If you need direct control over a block of memory, and its perceivable storage, use 'DataBuffer'. As stated, for dynamically sized arrays, 'Stack', 'Pool', and 'Deque' objects are ideal, unless you intend to roll your own container or storage system. As brought up, large arrays are heavy, just as 'DataBuffers' are, but they can be larger than needed (In the case of storing bytes as an integer array; use 'DataBuffer' here).<br><br>The problem with "freeing" an array in Monkey is that there's no rules regarding "views" of them. With this in mind, a manual discard (If possible) would be dangerous (Like 'DataBuffer.Discard', only less obvious). As a side note, this is also why array slicing can be costly on some targets.<br><br>Just to clarify one point about 'Resize', and why it may be confusing: Because of Monkey's behavior with arrays, calling 'Resize' is the same as creating a copy of the array you use it on. The only difference from the original array is its place in memory under the hood, and the number of elements you request. This isn't a "view slice" of any kind, it's a clone. So, when you call '<b>Resize(0)</b>', you're asking for a clone of your original array, only with zero elements (Blank). <b>In other words: This does not in any way modify the original array</b>, so you need to assign your field/local/whatever to the resized (In the case of 0, blank) array.<br><br>This is why I suggest using '<b>[]</b>', as you can write:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Local A:= New Int[1024]
...
A = [] ' &lt;-- 'A' is now an empty/blank array, and its <b>old</b> contents will be garbage collected eventually.
</textarea><br><br>Now, it should be brought up that an array in Monkey is considered "never 'Null'". That is, they're like 'Strings'; they aren't native or externally declared objects, they're language constructs. Arrays are always safe to use, but their contents are dependent on how you use them; like 'Strings'. So, use of 'Length' on an array or string is always safe, even if it's empty or otherwise considered uninitialized. As a side note, arrays are not comparable like 'Strings' are; you'll need to write your own deep-compare routine.<br><br>With that in mind, however, what is your intention by doing this? If it's about cleaning up an object that you'll no longer use, then don't do anything. Arrays are reference-counted like every other object, they just have special properties. If you want to release the array, don't do anything. As long as you aren't referencing it, or referencing something that's referencing it (Recursive), it'll be taken care of by the garbage collector. This means if you have an object that holds a reference to say, an 'Int[]', and you no longer reference that object, that integer array will be taken care of automatically. (Obviously this applies to other types of arrays)<br><br>But, when your intention is to reset, or to otherwise pool an object that uses an array, this complicates things. It all depends on your setup. For example, you could use a system that allocates fixed-size arrays that pooled objects can reference. It's also possible for you to implicitly attach the storage of an array; like when using '<b>Int[256]</b>' as your field's type, or initially using '<b>New Int[256]</b>' when constructing the object, but not assigning to '[]' (Or using 'Resize' <i><b>and assigning the array</b></i>) when you reset the object for pooling. In such a case, you could treat the content of your array as initially undefined (e.g. potentially non-zero), or you could reset the contents with a loop or function. <b>In the case of object arrays, you're dealing with an array of references to objects, so this gets a lot more dangerous.</b> Because an array of type 'T' (Where 'T' is an object) is telling the compiler to allocate references, keeping the contents non-Null is very bad practice. So, in those situations, assign each element (Reference) to '<b>Null</b>' when "destructing" and/or pooling the object. This also applies to "broker" systems like I mentioned before.<br><br><b>There, that should be just about everything you need to know about arrays and their storage.</b> I hope this helps. <br><br></td></tr></table><br>
<a name="2113187"></a>

<a name="2113155"></a>

<a name="2113157"></a>

<a name="2113152"></a>

<a name="2113154"></a>

<a name="2113151"></a>

<a name="2113156"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hub</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very interesting skng ! Many thanks ! <br><br></td></tr></table><br>
<a name="2113162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> So, in those situations, assign each element (Reference) to 'Null' when "destructing" and/or pooling the object. <br></div>You can also reset references by just assigning to a new array of same size, so no need to iterate nulling each element. In fact, if the array is not referenced any more, array references are also collected properly.<br><br>Take into account that Monkey does not use Ref counting GC. It uses a proper GC on C++ and handle cycles on all targets. <br><br></td></tr></table><br>
<a name="2113163"></a>

<a name="2113164"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ziggy: I already went over array reference-semantics in my post, and doing what you're suggesting is horribly costly for large arrays. For example, an array of 1024 references takes up an entire page on x86, and most x64 systems. From what I've read, this is the same with ARM as well. Now, if we consider Microsoft's track record with Windows (Especially on my system), this isn't a meaningless allocation.<br><br>As for reference counting, I wasn't referring to implementation details, I was referring to the concept. Whether the GC uses recursive "tracing" (Mark/sweep, etc), that isn't relevant when you already understand that an unreferenced object is released. Either way, I suppose it is better to be more verbose, so I agree with the sentiment. <br><br></td></tr></table><br>
<a name="2113165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shinkiro1</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; it's just when i want reload all my data without quit and lauch<br><br>then there is no need to resize the array at all.<br>just overwrite the values in the array.<br><br>as mentioned above, the old objects will be taken care of automatically by the gc. <br><br></td></tr></table><br>
<a name="2113207"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Ancell</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> myArray = [] works too. <br><br></td></tr></table><br>
<a name="2113229"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> As for reference counting, I wasn't referring to implementation details, I was referring to the concept. Whether the GC uses recursive "tracing" (Mark/sweep, etc), that isn't relevant when you already understand that an unreferenced object is released.  <br></div>I see, but ref counting is an implementation detail! :) I suppose you meant a garbage collector in an abstract sense. Mark/Sweep is not a kind of ref counting GC. Ref counting does not handle ref cycles and is very problematic and slower than most proper GC implementations. For this reasons, I considered it was worth mentioning that Monkey does not use any Ref counting based GC. AFAIK, It uses mark&amp;Sweep in C++, but tied to the "after On whatever" method, and generational (which is better) in other targets.<br>You can also enable other GC modes on C++, but I think they're all still non generational (not sure, I think it was like this last time I looked at it).<br><br><div class="quote"> I already went over array reference-semantics in my post, and doing what you're suggesting is horribly costly for large arrays.  <br></div>Yes, my post was not the best post in the world. What I really meant to say is that you do not need to free an array. If you need a new array of the same size with null elements, you can create it directly. (I've found this to be a lot faster in JavaScript than nulling all elements!)<br><br>Anyway, most of the time, you won't need to free an array. If you need to discard array contents because it contains unmanaged memory elements that need to be discarded (such as images loaded into VRam), then you need to Clear each element, but the array only needs to be dimmed to [] as ImmutableOctet(SKNG) wisely says, or just ensure the array itself gets out of scope. <br><br></td></tr></table><br>
<a name="2113227"></a>

<a name="2113226"></a>

<a name="2113224"></a>

<a name="2113223"></a>

<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
