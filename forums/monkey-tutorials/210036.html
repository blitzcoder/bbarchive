<!DOCTYPE html><html lang="en" ><head ><title >Box2D - Get your motor running</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Box2D - Get your motor running</h1><a href="forums.php" >Monkey Archive Forums</a>/<a href="topics.php?forum=513" >Monkey Tutorials</a>/<a href="#bottom" >Box2D - Get your motor running</a><br><br>
<a name="2109739"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Box2D is a powerful physics simulation system that can be used for a developing a variety of monkey games.<br><br>The idea of this series is to help those wanting to take the first few steps using muddy shoe's most excellent port of Erin Cato's box2d engine.<br><br>Download the monkey Box2D module <a href="https://code.google.com/p/monkeybox2d/downloads/list" target="_blank">here</a>, this tutorial code has been tested with release 1.0.12<br><br>And if you want some background reading try the box2d manual which is here - <a href="http://box2d.org/manual.pdf" target="_blank">http://box2d.org/manual.pdf</a><br><br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' box2done.monkey

' F1 - reset
' F2 - add ball

Strict

Import mojo
Import box2d.collision

Const WORLDSCALE#=1.0/8
Const TIMESTEP#=1.0/20			'frantic 2x clock
Const FRAMERATE%=30
Const SPEEDLOOPS%=20
Const POSLOOPS%=20

Class Box2D

	Field world:b2World
	
	Method New()
		Init New b2Vec2(0,10)		
	End

	Method Init:Void(gravity:b2Vec2)
		world = New b2World(gravity,True)	'gravity,dosleep
		world.SetWarmStarting(True)
		Local dbgDraw:=New DebugDraw()		
		dbgDraw.SetDrawScale(1.0/WORLDSCALE)
		dbgDraw.SetFillAlpha(1.0)
		dbgDraw.SetLineThickness(1.0)
		dbgDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit)'| b2DebugDraw.e_pairBit)
		world.SetDebugDraw(dbgDraw)
	End
	
	Method Update:Void()
		world.TimeStep(TIMESTEP, SPEEDLOOPS, POSLOOPS)
		world.ClearForces()
	End	
		
	Method Draw:Void()
		world.DrawDebugData()
	End

	Global FixtureDef:=New b2FixtureDef()
	Global BodyDef:=New b2BodyDef()
	Global Impulse:=New b2Vec2
		
	Method CreateBody:b2Body(x#,y#,bodytype%)
		BodyDef.type = bodytype		
		BodyDef.fixedRotation=False		
		BodyDef.position.Set(x,y)
		Return world.CreateBody(BodyDef)
	End
	
	Method AddRadialFixture:b2Fixture(body:b2Body,r#,bits%,mask%)
		FixtureDef.shape=New b2CircleShape(r*WORLDSCALE)
		FixtureDef.density=10
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		fixture.SetRestitution(0.1)
		fixture.SetFriction(0.9)	
		Return fixture		
	End	 

	Method AddSquareFixture:b2Fixture(body:b2Body,w#,h#,bits%,mask%)
		Local shape:=New b2PolygonShape
		shape.SetAsBox w*WORLDSCALE,h*WORLDSCALE
		FixtureDef.shape=shape
		FixtureDef.density=10
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		fixture.SetRestitution(0.1)
		fixture.SetFriction(0.9)	
		Return fixture		
	End	
	
	Method ApplyImpulse:Void(body:b2Body,x#,y#)
		Impulse.x=x
		Impulse.y=y
		body.ApplyForce Impulse,body.GetPosition()
	End

End

Class DebugDraw Extends b2DebugDraw
    Method Clear:Void()
    End
End


Const STATICBIT%=1
Const DYNAMICBIT%=2

Class Box2DOne Extends App

	Field world:Box2D
	Field renderCount%

	Method OnCreate%()
		ResetWorld
		AddBall
		SetUpdateRate 30
		Return 0
	End
	
	Method ResetWorld:Void()
		world=New Box2D
		Local ground:b2Body
		ground = world.CreateBody(0,20,b2Body.b2_staticBody)
		world.AddSquareFixture(ground,100,10,STATICBIT,DYNAMICBIT)		
	End
	
	Method AddBall:b2Body()
		Local ball:b2Body
		ball = world.CreateBody(10,0,b2Body.b2_Body)
		world.AddRadialFixture(ball,10,DYNAMICBIT,STATICBIT|DYNAMICBIT)		
		world.ApplyImpulse(ball, Rnd(-.1,.1), 0)
		Return ball
	End
	
	Method OnUpdate%()
		If KeyHit(KEY_F1) ResetWorld
		If KeyHit(KEY_F2) AddBall
		world.Update
		Return 0
	End

	Method OnRender%()
		renderCount+=1
		Cls 10,30,160
		world.Draw
		Return 0
	End
End

Function Main%()
	New Box2DOne
	Return 0
End
</textarea><br><br>Step 1 Download and install the box2d module.<br><br>Step 2 Run the above code and play with F1 and F2 keys<br><br>Step 3 Check out in the main class and observe how <br><br>* box2d uses bodies and fixtures to do it's thing<br>* without the random impulse the simulation stacks the balls perfectly<br>* box2d DrawDebugData function replaces any need for placeholder graphics when prototyping<br>* box2d spreads out balls if you add 3 at a time on top of each other <br><br></td></tr></table><br>
<a name="2109737"></a>

<a name="2109520"></a>

<a name="2109519"></a>

<a name="2109480"></a>

<a name="2109479"></a>

<a name="2109478"></a>

<a name="2109477"></a>

<a name="2109476"></a>

<a name="2109475"></a>

<a name="2109576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Duke87</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work!<br><br>I just downloaded box2d 1.0.12<br>I guess u forgot to inlcude:<br><pre class=code>
Function Main:Int()
	New MainDemo
End Function 
</pre><br>to the maindemo.monkey.<br>Performing very well on all targets, but Flash.<br><br>Bye Duke. <br><br></td></tr></table><br>
<a name="2109577"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Today's code is my attempt at simulating a pinball flipper. And a bit of a refactor...<br><br>The shape of the flipper is a bunch of points which I create in a plain old float array then convert to vector of b2Vec2 for use by Box2D.<br><br>Simply treating the flipper as a static body and using Rotate kind of works in a really wrong kind of way.<br><br>However proper solution is to anchor the flipper to the ground with a Revolute joint which gives us everything we need for setting up the mechanics.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' box2dtwo.monkey

' F1 - reset
' F2 - add ball
' Left - left flipper

Strict

Import mojo
Import box2d.collision

Const WORLDSCALE#=1.0/8
Const TIMESTEP#=1.0/20			'frantic 2x clock
Const FRAMERATE%=30
Const SPEEDLOOPS%=20
Const POSLOOPS%=20

' two semicirlces separated by d offset  Oxo

Function FlipperCoords#[](r1#,r2#,d#,n%)
	Local pts:=New Float[n*2]	
	For Local i%=0 Until n
		Local a#=(i+.5)*360.0/n
		Local x#=Cos(a)
		Local y#=Sin(a)		
		If i&lt;n/2
			x=x*r1
			y=y*r1		
		Else
			x=x*r2
			y=y*r2-d
		Endif
		pts[i*2+0]=x
		pts[i*2+1]=y
	Next
	Return pts
End

Class Body
	Global BodyDef:=New b2BodyDef()
	Global FixtureDef:=New b2FixtureDef()
	Global Impulse:=New b2Vec2

	Field parent:b2World
	Field body:b2Body
	Field density#=1
	
	Method New(	world:b2World,x#,y#,bodytype%)
		BodyDef.type = bodytype		
		BodyDef.fixedRotation=False		
		BodyDef.position.Set(x*WORLDSCALE,y*WORLDSCALE)
		body=world.CreateBody(BodyDef)
		parent=world
	End


	Method AddRadialFixture:b2Fixture(r#,bits%,mask%)
		Local shape:=New b2CircleShape(r*WORLDSCALE)
		Local fixture:=AddFixture(shape,bits,mask)		
		fixture.SetRestitution(1)
		fixture.SetFriction(.2)	
		Return fixture		
	End	 
	
	Method AddPolygonFixture:b2Fixture(pts#[],bits%,mask%)	
		Local shape:=New b2PolygonShape		
		Local n%=pts.Length()/2
		Local points:=New 	b2Vec2[n]
		For Local i%=0 Until n
			Local x#=pts[i*2+0]
			Local y#=pts[i*2+1]
			points[i]=New b2Vec2(x,y)
		Next	
		shape.SetAsArray points,n
		Return AddFixture(shape,bits,mask)
	End
	
	Method AddSquareFixture:b2Fixture(w#,h#,bits%,mask%)
		Local shape:=New b2PolygonShape
		shape.SetAsBox w*WORLDSCALE,h*WORLDSCALE
		Return AddFixture(shape,bits,mask)
	End
	
	Method AddFixture:b2Fixture(shape:b2Shape,bits%,mask%)
		FixtureDef.shape=shape
		FixtureDef.density=density
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		Return fixture		
	End	
	
	Method ApplyImpulse:Void(x#,y#)
		Impulse.x=x
		Impulse.y=y
		body.ApplyForce Impulse,body.GetPosition()
	End
		
	Method ApplyTorque:Void(t#)
		body.ApplyTorque t
	End

	Method Rotate:Void(degrees#)
		body.SetAngle body.GetAngle()+degrees*PI/180
	End

End

Class Sim

	Field gravity:b2Vec2
	Field world:b2World
	
	Method New(gravityx#,gravityy#)
		gravity=New b2Vec2(gravityx,gravityy)
		Init gravity		
	End

	Method Init:Void(gravity:b2Vec2)
		world = New b2World(gravity,True)	'gravity,dosleep
		world.SetWarmStarting(True)
		Local dbgDraw:=New DebugDraw()		
		dbgDraw.SetDrawScale(1.0/WORLDSCALE)
		dbgDraw.SetFillAlpha(1.0)
		dbgDraw.SetLineThickness(1.0)
		dbgDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit)'| b2DebugDraw.e_pairBit)
		world.SetDebugDraw(dbgDraw)
	End
			
	Method CreateBody:Body(x#,y#,bodytype%)
		Return New Body(world,x,y,bodytype)
	End
	
	Method CreateRevolute:b2RevoluteJoint(a:Body,b:Body,x#,y#)
		Local r:=New b2RevoluteJointDef
		Local p:=New b2Vec2(x*WORLDSCALE,y*WORLDSCALE)
		r.Initialize(a.body,b.body,p)
		
		r.maxMotorTorque = 20000
		r.motorSpeed = 1000
        	r.enableLimit = True
        	r.enableMotor = True

		r.lowerAngle=PI/3
		r.upperAngle=2*PI/3
		
		Local joint:=world.CreateJoint(r)
		Return b2RevoluteJoint(joint)
	End
	
	Function RemoveFixture:Void(body:b2Body,fixture:b2Fixture)
		body.DestroyFixture fixture
	End
	

	Method Update:Void()
		world.TimeStep(TIMESTEP, SPEEDLOOPS, POSLOOPS)
		world.ClearForces()
	End	
		
	Method Draw:Void()
		world.DrawDebugData()
	End

End

Class DebugDraw Extends b2DebugDraw
    Method Clear:Void()
    End
End


Const STATICBIT%=1
Const DYNAMICBIT%=2

Class Box2DTwo Extends App

	Field world:Sim
	Field ground:Body
	Field flipper:b2RevoluteJoint
	
	Field renderCount%

	Method OnCreate%()
		ResetWorld
		AddBall
		SetUpdateRate 30
		Return 0
	End
		
	Method AddBlock:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateBody(x,y,b2Body.b2_staticBody)
		block.AddSquareFixture(w,h,STATICBIT,DYNAMICBIT)	
		Return block
	End
	
	Method AddFlipper:b2RevoluteJoint(x#,y#)
		Local body:Body
		Local pin:Body
		pin = world.CreateBody(x,y,b2Body.b2_staticBody)
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2		
		Local points:=	FlipperCoords(2,1,8,32)
		body.AddPolygonFixture points,STATICBIT,DYNAMICBIT
		Local joint:=world.CreateRevolute(pin,body,x,y)
		Return joint
	End

	Method ResetWorld:Void()
		world=New Sim(0,10)
		flipper=AddFlipper(80,360)
		ground=AddBlock(0,450,600,10)
	End
	
	Method AddBall:Body()
		Local ball:Body
		ball = world.CreateBody(110,2,b2Body.b2_Body)
		ball.AddRadialFixture(10,DYNAMICBIT,STATICBIT|DYNAMICBIT)		
		ball.ApplyImpulse(Rnd(-.1,.1), 0)
		Return ball
	End
	
	Method OnUpdate%()
		If KeyHit(KEY_F1) ResetWorld
		If KeyHit(KEY_F2) AddBall
		
		If KeyDown(KEY_LEFT) 
			flipper.SetMotorSpeed -1000
		Else
			flipper.SetMotorSpeed 1000
		Endif	
		world.Update
		Return 0
	End

	Method OnRender%()
		renderCount+=1
		Cls 10,30,160
		world.Draw
		Return 0
	End
End

Function Main%()
	New Box2DTwo
	Return 0
End
</textarea><br><br>There are two basic simulations you can do with box2d.<br><br>A top down simulation such as pool or mini-golf where gravity is turned off and the camera faces the ground.<br><br>A side on simulation such as angry birds or worms where the camera is aimed at the horizon and gravity points straight down.<br><br>And remember a successful game doesn't need to simulate a large population of bodies, typically the good ones have particularly low numbers and the attention has gone into tuning the experience in regards to most fun. <br><br></td></tr></table><br>
<a name="2109733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Today's simulation is the start of a quarry wheel loader machine with an arm and bucket that can catch falling balls.<br><br>The code also features a new fixture generator that takes a path of x#,y#,r# points and adds radial and connecting quads fixtures.<br><br>I left the AddStaticEdge function in the code for a future ground contour which we will hopefully be driving across shortly.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' box2dthree.monkey
' F1 - reset
' F2 - add ball
' Arrow Keys - turn motors

Strict

Import mojo
Import box2d.collision

Const WORLDSCALE#=1.0/8
Const TIMESTEP#=1.0/20			'frantic 2x clock
Const FRAMERATE%=30
Const SPEEDLOOPS%=20
Const POSLOOPS%=20

' point list is [x,y,r[,...]]

Global BucketPoints#[]=[
50.0,-80,5,
 0,-40,10,
 0,40,10,
 50,80,5]

Global ArmPoints#[]=[
0.0,0,10,
20,-40,5,
80,-40,5,
100,0,10]


' two semicirlces separated by d offset  Oxo

Function FlipperCoords#[](r1#,r2#,d#,n%)
	Local pts:=New Float[n*2]	
	For Local i%=0 Until n
		Local a#=(i+.5)*360.0/n
		Local x#=Cos(a)
		Local y#=Sin(a)		
		If i&lt;n/2
			x=x*r1
			y=y*r1		
		Else
			x=x*r2
			y=y*r2-d
		Endif
		pts[i*2+0]=x
		pts[i*2+1]=y
	Next
	Return pts
End

Class Body
	Global BodyDef:=New b2BodyDef()
	Global FixtureDef:=New b2FixtureDef()
	Global Impulse:=New b2Vec2

	Field parent:b2World
	Field body:b2Body
	Field density#=1
	
	Method New(	world:b2World,x#,y#,bodytype%)
		BodyDef.type = bodytype		
		BodyDef.fixedRotation=False		
		BodyDef.position.Set(x*WORLDSCALE,y*WORLDSCALE)
		body=world.CreateBody(BodyDef)
		parent=world
	End

	Method AddRadialFixture:b2Fixture(x#,y#,r#,bits%,mask%)
		Local shape:=New b2CircleShape(r*WORLDSCALE)
		If x Or y shape.SetLocalPosition New b2Vec2(x*WORLDSCALE,y*WORLDSCALE)
		Local fixture:=AddFixture(shape,bits,mask)		
		fixture.SetRestitution(.6)
		fixture.SetFriction(.2)	
		Return fixture		
	End	 
	
	Method AddSquareFixture:b2Fixture(w#,h#,bits%,mask%)
		Local shape:=New b2PolygonShape
		shape.SetAsBox w*WORLDSCALE,h*WORLDSCALE
		Return AddFixture(shape,bits,mask)
	End
	
	Method AddPathFixture:Void(points#[],bits%,mask%)
		Local n%=points.Length/3
		For Local i%=0 Until n
			Local x#=points[i*3+0]
			Local y#=points[i*3+1]
			Local r#=points[i*3+2]
			AddRadialFixture x,y,r,bits,mask	
		Next

		For Local i%=0 Until n-1
			Local x0#=points[i*3+0]*WORLDSCALE
			Local y0#=points[i*3+1]*WORLDSCALE
			Local r0#=points[i*3+2]*WORLDSCALE
			Local x1#=points[i*3+3]*WORLDSCALE
			Local y1#=points[i*3+4]*WORLDSCALE
			Local r1#=points[i*3+5]*WORLDSCALE
			Local dx#=x1-x0
			Local dy#=y1-y0
			Local dd#=dx*dx+dy*dy
			Local d#=Sqrt(dd)
			Local tx#=dy/d
			Local ty#=-dx/d			
			Local pts:b2Vec2[4]
			pts[0]=New b2Vec2(x0+r0*tx, y0+r0*ty)
			pts[1]=New b2Vec2(x1+r1*tx, y1+r1*ty)
			pts[2]=New b2Vec2(x1-r1*tx, y1-r1*ty)
			pts[3]=New b2Vec2(x0-r0*tx, y0-r0*ty)
			Local shape:=New b2PolygonShape
			shape.SetAsArray pts,4
			AddFixture(shape,bits,mask)
		Next
	End

	' must be convex
	
	Method AddPolygonFixture:b2Fixture(pts#[],bits%,mask%)	
		Local shape:=New b2PolygonShape		
		Local n%=pts.Length()/2
		Local points:=New 	b2Vec2[n]
		For Local i%=0 Until n
			Local x#=pts[i*2+0]
			Local y#=pts[i*2+1]
			points[i]=New b2Vec2(x,y)
		Next	
		shape.SetAsArray points,n
		Return AddFixture(shape,bits,mask)
	End
	
	' complex geometry welcome, only attach to static bodies as edges have zero mass
		
	Method AddStaticEdge:Void(pts#[],bits%,mask%)	
		Local last%=pts.Length()/2-1
		Local x1#=pts[last*2+0]
		Local y1#=pts[last*2+1]
		For Local i%=0 Until last
			Local x0#=x1
			Local y0#=y1
			x1=pts[i*2+0]
			y1=pts[i*2+1]
			Local p0:=New b2Vec2(x0,y0)
			Local p1:=New b2Vec2(x1,y1)
			Local shape:=New b2PolygonShape		
			shape.SetAsEdge p0,p1
			AddFixture(shape,bits,mask)
		Next	

	End
	
	Method AddFixture:b2Fixture(shape:b2Shape,bits%,mask%)
		FixtureDef.shape=shape
		FixtureDef.density=density
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		Return fixture		
	End	
	
	Method ApplyImpulse:Void(x#,y#)
		Impulse.x=x
		Impulse.y=y
		body.ApplyForce Impulse,body.GetPosition()
	End
		
	Method ApplyTorque:Void(t#)
		body.ApplyTorque t
	End

	Method Rotate:Void(degrees#)
		body.SetAngle body.GetAngle()+degrees*PI/180
	End

End

Class Sim

	Field gravity:b2Vec2
	Field world:b2World
	
	Method New(gravityx#,gravityy#)
		gravity=New b2Vec2(gravityx,gravityy)
		Init gravity		
	End

	Method Init:Void(gravity:b2Vec2)
		world = New b2World(gravity,True)	'gravity,dosleep
		world.SetWarmStarting(True)
		Local dbgDraw:=New DebugDraw()		
		dbgDraw.SetDrawScale(1.0/WORLDSCALE)
		dbgDraw.SetFillAlpha(1.0)
		dbgDraw.SetLineThickness(1.0)
		dbgDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit)'| b2DebugDraw.e_pairBit)
		world.SetDebugDraw(dbgDraw)
	End
			
	Method CreateBody:Body(x#,y#,bodytype%)
		Return New Body(world,x,y,bodytype)
	End
	
	Method CreateRevolute:b2RevoluteJoint(a:Body,b:Body,x#,y#,rad0#,rad1#)
		Local r:=New b2RevoluteJointDef
		Local p:=b.body.GetPosition()		
		r.Initialize(a.body,b.body,p)		
		r.maxMotorTorque = 100000
		r.motorSpeed = 0
        	r.enableLimit = True
        	r.enableMotor = True
		r.lowerAngle=rad0
		r.upperAngle=rad1		
		Local joint:=world.CreateJoint(r)
		Return b2RevoluteJoint(joint)
	End
	
	Function RemoveFixture:Void(body:b2Body,fixture:b2Fixture)
		body.DestroyFixture fixture
	End
	

	Method Update:Void()
		world.TimeStep(TIMESTEP, SPEEDLOOPS, POSLOOPS)
		world.ClearForces()
	End	
		
	Method Draw:Void()
		world.DrawDebugData()
	End

End

Class DebugDraw Extends b2DebugDraw
    Method Clear:Void()
    End
End

Const STATICBIT%=1
Const DYNAMICBIT%=2

Class Part
	Field body:Body
	Field joint:b2RevoluteJoint
	Method New(body0:Body,joint0:b2RevoluteJoint)
		body=body0		
		joint=joint0
	End
End
	
Class Box2DThree Extends App

	Field world:Sim
	Field ground:Body
	Field bucket:Part
	Field arm:Part	
	Field renderCount%

	Method OnCreate%()
		ResetWorld
		AddBall
		SetUpdateRate 30
		Return 0
	End
		
	Method AddBlock:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateBody(x,y,b2Body.b2_staticBody)
		block.AddSquareFixture(w,h,STATICBIT,DYNAMICBIT)	
		Return block
	End
	
	Method AddBucket:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture BucketPoints,STATICBIT,DYNAMICBIT	
		Local joint:=world.CreateRevolute(pin,body,0,0,-PI/4, PI/4)
		Return New Part(body,joint)
	End

	Method AddArm:Part(x#,y#)
		Local body:Body
		Local pin:Body
		pin = world.CreateBody(x,y,b2Body.b2_staticBody)
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture ArmPoints,STATICBIT,DYNAMICBIT	
		Local joint:=world.CreateRevolute(pin,body,x,y,-PI/4, PI/4)
		Return New Part(body,joint)
	End

	Method ResetWorld:Void()
		world=New Sim(0,10)
		arm=AddArm(200,200)		
		bucket=AddBucket(arm.body,320,200)		
		ground=AddBlock(0,450,600,10)
	End
	
	Method AddBall:Body()
		Local ball:Body
		ball = world.CreateBody(300,2,b2Body.b2_Body)
		ball.AddRadialFixture(0,0,10,DYNAMICBIT,STATICBIT|DYNAMICBIT)		
		ball.ApplyImpulse(Rnd(-.1,.1), 0)
		Return ball
	End
	
	Method OnUpdate%()
		If KeyHit(KEY_F1) ResetWorld
		If KeyHit(KEY_F2) AddBall

		Local bucketSpeed#=0		
		Local armSpeed#=0		
		If KeyDown(KEY_LEFT) 
			bucketSpeed=-20
		Endif
		If KeyDown(KEY_RIGHT) 
			bucketSpeed=20
		Endif	
		If KeyDown(KEY_UP) 
			armSpeed=-400
		Endif	
		If KeyDown(KEY_DOWN) 
			armSpeed=400
		Endif	
		arm.joint.SetMotorSpeed armSpeed
		bucket.joint.SetMotorSpeed bucketSpeed

		world.Update
		Return 0
	End

	Method OnRender%()
		renderCount+=1
		Cls 10,30,160
		world.Draw
		Return 0
	End
End

Function Main%()
	New Box2DThree
	Return 0
End
</textarea> <br><br></td></tr></table><br>
<a name="2109694"></a>

<a name="2109693"></a>

<a name="2109692"></a>

<a name="2109690"></a>

<a name="2109691"></a>

<a name="2109735"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> This version adds a chassis, suspension and wheels to the arm bucket attachment.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' box2dfour.monkey
' F1 - reset
' F2 - add ball
' Z,X, Arrows - turn motors

Strict

Import mojo
Import box2d.collision

Const WORLDSCALE#=1.0/8
Const TIMESTEP#=1.0/20			'frantic 2x clock
Const FRAMERATE%=30
Const SPEEDLOOPS%=20
Const POSLOOPS%=20

' point list is [x,y,r[,...]]

Global BucketPoints#[]=[
50.0,-80,5,
 0,-40,10,
 0,40,10,
 50,80,5]

Global ArmPoints#[]=[
0.0,0,10,
20,-40,5,
80,-40,5,
100,0,10]


' two semicirlces separated by d offset  Oxo

Function FlipperCoords#[](r1#,r2#,d#,n%)
	Local pts:=New Float[n*2]	
	For Local i%=0 Until n
		Local a#=(i+.5)*360.0/n
		Local x#=Cos(a)
		Local y#=Sin(a)		
		If i&lt;n/2
			x=x*r1
			y=y*r1		
		Else
			x=x*r2
			y=y*r2-d
		Endif
		pts[i*2+0]=x
		pts[i*2+1]=y
	Next
	Return pts
End

Class Body
	Global BodyDef:=New b2BodyDef()
	Global FixtureDef:=New b2FixtureDef()
	Global Impulse:=New b2Vec2

	Field parent:b2World
	Field body:b2Body
	Field density#=1
	
	Method New(	world:b2World,x#,y#,bodytype%)
		BodyDef.type = bodytype		
		BodyDef.fixedRotation=False		
		BodyDef.position.Set(x*WORLDSCALE,y*WORLDSCALE)
		body=world.CreateBody(BodyDef)
		parent=world
	End

	Method AddRadialFixture:b2Fixture(x#,y#,r#,bits%,mask%)
		Local shape:=New b2CircleShape(r*WORLDSCALE)
		If x Or y shape.SetLocalPosition New b2Vec2(x*WORLDSCALE,y*WORLDSCALE)
		Local fixture:=AddFixture(shape,bits,mask)		
		fixture.SetRestitution(.6)
		fixture.SetFriction(.8)	
		Return fixture		
	End	 
	
	Method AddSquareFixture:b2Fixture(w#,h#,bits%,mask%)
		Local shape:=New b2PolygonShape
		shape.SetAsBox w*WORLDSCALE,h*WORLDSCALE
		Return AddFixture(shape,bits,mask)
	End
	
	Method AddPathFixture:Void(points#[],bits%,mask%)
		Local n%=points.Length/3
		For Local i%=0 Until n
			Local x#=points[i*3+0]
			Local y#=points[i*3+1]
			Local r#=points[i*3+2]
			AddRadialFixture x,y,r,bits,mask	
		Next

		For Local i%=0 Until n-1
			Local x0#=points[i*3+0]*WORLDSCALE
			Local y0#=points[i*3+1]*WORLDSCALE
			Local r0#=points[i*3+2]*WORLDSCALE
			Local x1#=points[i*3+3]*WORLDSCALE
			Local y1#=points[i*3+4]*WORLDSCALE
			Local r1#=points[i*3+5]*WORLDSCALE
			Local dx#=x1-x0
			Local dy#=y1-y0
			Local dd#=dx*dx+dy*dy
			Local d#=Sqrt(dd)
			Local tx#=dy/d
			Local ty#=-dx/d			
			Local pts:b2Vec2[4]
			pts[0]=New b2Vec2(x0+r0*tx, y0+r0*ty)
			pts[1]=New b2Vec2(x1+r1*tx, y1+r1*ty)
			pts[2]=New b2Vec2(x1-r1*tx, y1-r1*ty)
			pts[3]=New b2Vec2(x0-r0*tx, y0-r0*ty)
			Local shape:=New b2PolygonShape
			shape.SetAsArray pts,4
			AddFixture(shape,bits,mask)
		Next
	End

	' must be convex
	
	Method AddPolygonFixture:b2Fixture(pts#[],bits%,mask%)	
		Local shape:=New b2PolygonShape		
		Local n%=pts.Length()/2
		Local points:=New 	b2Vec2[n]
		For Local i%=0 Until n
			Local x#=pts[i*2+0]
			Local y#=pts[i*2+1]
			points[i]=New b2Vec2(x,y)
		Next	
		shape.SetAsArray points,n
		Return AddFixture(shape,bits,mask)
	End
	
	' complex geometry welcome, only attach to static bodies as edges have zero mass
		
	Method AddStaticEdge:Void(pts#[],bits%,mask%)	
		Local last%=pts.Length()/2-1
		Local x1#=pts[last*2+0]
		Local y1#=pts[last*2+1]
		For Local i%=0 Until last
			Local x0#=x1
			Local y0#=y1
			x1=pts[i*2+0]
			y1=pts[i*2+1]
			Local p0:=New b2Vec2(x0,y0)
			Local p1:=New b2Vec2(x1,y1)
			Local shape:=New b2PolygonShape		
			shape.SetAsEdge p0,p1
			AddFixture(shape,bits,mask)
		Next	

	End
	
	Method AddFixture:b2Fixture(shape:b2Shape,bits%,mask%)
		FixtureDef.shape=shape
		FixtureDef.density=density
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		Return fixture		
	End	
	
	Method ApplyImpulse:Void(x#,y#)
		Impulse.x=x
		Impulse.y=y
		body.ApplyForce Impulse,body.GetPosition()
	End
		
	Method ApplyTorque:Void(t#)
		body.ApplyTorque t
	End

	Method Rotate:Void(degrees#)
		body.SetAngle body.GetAngle()+degrees*PI/180
	End

End

Class Sim

	Field gravity:b2Vec2
	Field world:b2World
	
	Method New(gravityx#,gravityy#)
		gravity=New b2Vec2(gravityx,gravityy)
		Init gravity		
	End

	Method Init:Void(gravity:b2Vec2)
		world = New b2World(gravity,True)	'gravity,dosleep
		world.SetWarmStarting(True)
		Local dbgDraw:=New DebugDraw()		
		dbgDraw.SetDrawScale(1.0/WORLDSCALE)
		dbgDraw.SetFillAlpha(1.0)
		dbgDraw.SetLineThickness(1.0)
		dbgDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit)'| b2DebugDraw.e_pairBit)
		world.SetDebugDraw(dbgDraw)
	End
			
	Method CreateBody:Body(x#,y#,bodytype%)
		Return New Body(world,x,y,bodytype)
	End
	
	Method CreateRevolute:b2RevoluteJoint(a:Body,b:Body,rad0#,rad1#)
		Local r:=New b2RevoluteJointDef
		Local p:=b.body.GetPosition()		
		r.Initialize(a.body,b.body,p)		
		r.maxMotorTorque = 20000
		r.motorSpeed = 0        	
        	If rad0 Or rad1 r.enableLimit = True
        	r.enableMotor = True
		r.lowerAngle=rad0
		r.upperAngle=rad1		
		Local joint:=world.CreateJoint(r)
		Return b2RevoluteJoint(joint)
	End
	
	Method CreatePrism:b2PrismaticJoint(a:Body,px#,py#,b:Body,ax#,ay#,force#,speed#)

		Local pdef:=New b2PrismaticJointDef()

		Local axis:=New b2Vec2(ax,ay)				

		Local p:=New b2Vec2(px*WORLDSCALE,py*WORLDSCALE)

'		Local p:=b.body.GetPosition()		

		pdef.Initialize a.body,b.body,p,axis		

		pdef.lowerTranslation = -0.2
		pdef.upperTranslation = 0.6
		pdef.enableLimit = True

		pdef.maxMotorForce = force
		pdef.motorSpeed = speed
		pdef.enableMotor = True

		Local joint:=world.CreateJoint(pdef)

		Return b2PrismaticJoint(joint)
	End
	
	Function RemoveFixture:Void(body:b2Body,fixture:b2Fixture)
		body.DestroyFixture fixture
	End
	

	Method Update:Void()
		world.TimeStep(TIMESTEP, SPEEDLOOPS, POSLOOPS)
		world.ClearForces()
	End	
		
	Method Draw:Void()
		world.DrawDebugData()
	End

End

Class DebugDraw Extends b2DebugDraw
    Method Clear:Void()
    End
End

Const STATICBIT%=1
Const MACHINEBIT%=2
Const ROCKBIT%=4

Const DYNAMICBITS% = MACHINEBIT+ROCKBIT
Const INANIMATEBITS% = STATICBIT+ROCKBIT

Class Part
	Field body:Body
	Field joint:b2RevoluteJoint
	Method New(body0:Body,joint0:b2RevoluteJoint)
		body=body0		
		joint=joint0
	End
End
	
Class Box2DFour Extends App

	Field world:Sim
	Field ground:Body

	Field chasis:Body
	Field bucket:Part

	Field frontwheel:Part
	Field frontaxle:Part
	Field frontshock:b2PrismaticJoint
	Field backwheel:Part
	Field backaxle:Part
	Field backshock:b2PrismaticJoint

	Field arm:Part	
	Field renderCount%

	Method ResetWorld:Void()
		world=New Sim(0,10)
		
		Local x#=300
		Local y#=100

		chasis=AddChasis(x,y,120,40)

		Local wb#=80
		Local wh#=40
		
		frontaxle=AddPivot(chasis,x-wb,y+wh)
		backaxle=AddPivot(chasis,x+wb,y+wh)

		frontwheel=AddWheel(frontaxle.body,x-wb,y+wh,wh)
		backwheel=AddWheel(backaxle.body,x+wb,y+wh,wh)

		frontshock=world.CreatePrism(chasis,x-wb,y-wh,  frontaxle.body,  .1,-1, .1,0)	
		backshock=world.CreatePrism(chasis,x+wb,y-wh,  backaxle.body,  -.1,-1, .1,0)	

		arm=AddArm(chasis,x+50,y-50)		
		bucket=AddBucket(arm.body,x+160,y-50)	
			
		ground=AddBlock(0,450,600,10)
	End

	Method OnCreate%()
		ResetWorld
		AddBall
		SetUpdateRate 30
		Return 0
	End
		
	Method AddBlock:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateBody(x,y,b2Body.b2_staticBody)
		block.AddSquareFixture(w,h,STATICBIT,DYNAMICBITS)	
		Return block
	End
	
	Method AddChasis:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateBody(x,y,b2Body.b2_Body)
		block.AddSquareFixture(w,h,MACHINEBIT,INANIMATEBITS)	
		Return block
	End

	Method AddPivot:Part(pin:Body,x#,y#)
		Local wheel:Body
		wheel = world.CreateBody(x,y,b2Body.b2_Body)
		wheel.density=20	
		Local r#=8
		wheel.AddRadialFixture(0,0,r,MACHINEBIT,INANIMATEBITS)	
		Return New Part(wheel,Null)
	End

	Method AddWheel:Part(pin:Body,x#,y#,r#)
		Local wheel:Body
		wheel = world.CreateBody(x,y,b2Body.b2_Body)
		wheel.density=2	
		wheel.AddRadialFixture(0,0,r,MACHINEBIT,INANIMATEBITS)	
		Local joint:=world.CreateRevolute(pin,wheel,0,0)
		Return New Part(wheel,joint)
	End

	Method AddBucket:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture BucketPoints,MACHINEBIT,INANIMATEBITS	
		Local joint:=world.CreateRevolute(pin,body,-PI/4, PI/4)
		Return New Part(body,joint)
	End

	Method AddArm:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture ArmPoints,MACHINEBIT,INANIMATEBITS	
		Local joint:=world.CreateRevolute(pin,body,-PI/4, PI/4)
		Return New Part(body,joint)
	End
		
	Method AddBall:Body()
		Local ball:Body
		ball = world.CreateBody(300,2,b2Body.b2_Body)
		ball.AddRadialFixture(0,0,10,ROCKBIT,STATICBIT|DYNAMICBITS)		
		ball.ApplyImpulse(Rnd(-.1,.1), 0)
		Return ball
	End
	
	Method OnUpdate%()
		If KeyHit(KEY_F1) ResetWorld
		If KeyHit(KEY_F2) AddBall

		Local bucketSpeed#=0		
		Local armSpeed#=0
		If KeyDown(KEY_LEFT) 
			bucketSpeed=-20
		Endif
		If KeyDown(KEY_RIGHT) 
			bucketSpeed=20
		Endif	
		If KeyDown(KEY_UP) 
			armSpeed=-400
		Endif	
		If KeyDown(KEY_DOWN) 
			armSpeed=400
		Endif	
		If arm And bucket
			arm.joint.SetMotorSpeed armSpeed
			bucket.joint.SetMotorSpeed bucketSpeed
		Endif
		
		Local wheelSpeed#=0		
		If KeyDown(KEY_X)
			wheelSpeed=10
		Endif
		If KeyDown(KEY_Z)
			wheelSpeed=-10
		Endif
		backwheel.joint.SetMotorSpeed wheelSpeed
		frontwheel.joint.SetMotorSpeed wheelSpeed

		world.Update
		Return 0
	End

	Method OnRender%()
		renderCount+=1
		Cls 10,30,160
		world.Draw
		Return 0
	End
End

Function Main%()
	New Box2DFour
	Return 0
End
</textarea><br><br>When playing with the new vehicle note:<br><br>* applying too much rotational force / torque makes the wheel's spin, in future we could reduce torque at low speeds<br>* even with only 3 joints the machine feels like it has a life with mass / density of arm giving it a real character<br>* the box2d prismatic joints allow us to emulate suspension, see the box2d manual for more info <br><br></td></tr></table><br>
<a name="2109734"></a>

<a name="2109758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Today I take a break from vehicles and build a human.<br><br>After making a few marks in a door frame I used a tape measure (mm) to calculate a version of my own skeletal form for simulation purposes.<br><br>There is a bunch of keyboard mappings to control every motor and even without any basic constraints it looks like it will be possible for mini-me to stand balanced and perhaps even take a little walk...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' box2dfive.monkey
' F1 - reset
' F2 - add ball

Strict

Import mojo
Import box2d.collision


' 1m world
'Const WORLDSCALE#=1.0/8

' 1mm world
Const WORLDSCALE#=1.0/8

Const TIMESTEP#=1.0/20			'frantic 2x clock
Const FRAMERATE%=30
Const SPEEDLOOPS%=20
Const POSLOOPS%=20

Class Body
	Global BodyDef:=New b2BodyDef()
	Global FixtureDef:=New b2FixtureDef()
	Global Impulse:=New b2Vec2

	Field parent:b2World
	Field body:b2Body
	Field density#=1
	
	Method New(	world:b2World,x#,y#,bodytype%)
		BodyDef.type = bodytype		
		BodyDef.fixedRotation=False		
		BodyDef.position.Set(x*WORLDSCALE,y*WORLDSCALE)
		body=world.CreateBody(BodyDef)
		parent=world
	End

	Method AddRadialFixture:b2Fixture(x#,y#,r#,bits%,mask%)
		Local shape:=New b2CircleShape(r*WORLDSCALE)
		If x Or y shape.SetLocalPosition New b2Vec2(x*WORLDSCALE,y*WORLDSCALE)
		Local fixture:=AddFixture(shape,bits,mask)		
		fixture.SetRestitution(.6)
		fixture.SetFriction(.8)	
		Return fixture		
	End	 
	
	Method AddSquareFixture:b2Fixture(w#,h#,bits%,mask%)
		Local shape:=New b2PolygonShape
		shape.SetAsBox w*WORLDSCALE,h*WORLDSCALE
		Return AddFixture(shape,bits,mask)
	End
	
	Method AddPathFixture:Void(points#[],bits%,mask%)
		Local n%=points.Length/3
		For Local i%=0 Until n
			Local x#=points[i*3+0]
			Local y#=points[i*3+1]
			Local r#=points[i*3+2]
			AddRadialFixture x,y,r,bits,mask	
		Next

		For Local i%=0 Until n-1
			Local x0#=points[i*3+0]*WORLDSCALE
			Local y0#=points[i*3+1]*WORLDSCALE
			Local r0#=points[i*3+2]*WORLDSCALE
			Local x1#=points[i*3+3]*WORLDSCALE
			Local y1#=points[i*3+4]*WORLDSCALE
			Local r1#=points[i*3+5]*WORLDSCALE
			Local dx#=x1-x0
			Local dy#=y1-y0
			Local dd#=dx*dx+dy*dy
			Local d#=Sqrt(dd)
			Local tx#=dy/d
			Local ty#=-dx/d			
			Local pts:b2Vec2[4]
			pts[0]=New b2Vec2(x0+r0*tx, y0+r0*ty)
			pts[1]=New b2Vec2(x1+r1*tx, y1+r1*ty)
			pts[2]=New b2Vec2(x1-r1*tx, y1-r1*ty)
			pts[3]=New b2Vec2(x0-r0*tx, y0-r0*ty)
			Local shape:=New b2PolygonShape
			shape.SetAsArray pts,4
			AddFixture(shape,bits,mask)
		Next
	End

	' must be convex
	
	Method AddPolygonFixture:b2Fixture(pts#[],bits%,mask%)	
		Local shape:=New b2PolygonShape		
		Local n%=pts.Length()/2
		Local points:=New 	b2Vec2[n]
		For Local i%=0 Until n
			Local x#=pts[i*2+0]
			Local y#=pts[i*2+1]
			points[i]=New b2Vec2(x,y)
		Next	
		shape.SetAsArray points,n
		Return AddFixture(shape,bits,mask)
	End
	
	' complex geometry welcome, only attach to static bodies as edges have zero mass
		
	Method AddStaticEdge:Void(pts#[],bits%,mask%)	
		Local last%=pts.Length()/2-1
		Local x1#=pts[last*2+0]
		Local y1#=pts[last*2+1]
		For Local i%=0 Until last
			Local x0#=x1
			Local y0#=y1
			x1=pts[i*2+0]
			y1=pts[i*2+1]
			Local p0:=New b2Vec2(x0,y0)
			Local p1:=New b2Vec2(x1,y1)
			Local shape:=New b2PolygonShape		
			shape.SetAsEdge p0,p1
			AddFixture(shape,bits,mask)
		Next	

	End
	
	Method AddFixture:b2Fixture(shape:b2Shape,bits%,mask%)
		FixtureDef.shape=shape
		FixtureDef.density=density
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		Return fixture		
	End	
	
	Method ApplyImpulse:Void(x#,y#)
		Impulse.x=x
		Impulse.y=y
		body.ApplyForce Impulse,body.GetPosition()
	End
		
	Method ApplyTorque:Void(t#)
		body.ApplyTorque t
	End

	Method Rotate:Void(degrees#)
		body.SetAngle body.GetAngle()+degrees*PI/180
	End

End

Class Sim

	Field gravity:b2Vec2
	Field world:b2World
	
	Method New(gravityx#,gravityy#)
		gravity=New b2Vec2(gravityx,gravityy)
		Init gravity		
	End

	Method Init:Void(gravity:b2Vec2)
		world = New b2World(gravity,True)	'gravity,dosleep
		world.SetWarmStarting(True)
		Local dbgDraw:=New DebugDraw()		
		dbgDraw.SetDrawScale(1.0/WORLDSCALE)
		dbgDraw.SetFillAlpha(1.0)
		dbgDraw.SetLineThickness(1.0)
		dbgDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit)'| b2DebugDraw.e_pairBit)
		world.SetDebugDraw(dbgDraw)
	End
			
	Method CreateBody:Body(x#,y#)
		Return New Body(world,x,y,b2Body.b2_Body)
	End
	
	Method CreateStatic:Body(x#,y#)
		Return New Body(world,x,y,b2Body.b2_staticBody)
	End

	Method CreateRevolute:b2RevoluteJoint(a:Body,b:Body,rad0#,rad1#)
		Local r:=New b2RevoluteJointDef
		Local p:=b.body.GetPosition()		
		r.Initialize(a.body,b.body,p)		
		r.maxMotorTorque = 20000
		r.motorSpeed = 0        	
        	If rad0 Or rad1 r.enableLimit = True
        	r.enableMotor = True
		r.lowerAngle=rad0
		r.upperAngle=rad1		
		Local joint:=world.CreateJoint(r)
		Return b2RevoluteJoint(joint)
	End
	
	Method CreatePrism:b2PrismaticJoint(a:Body,px#,py#,b:Body,ax#,ay#,force#,speed#)

		Local pdef:=New b2PrismaticJointDef()

		Local axis:=New b2Vec2(ax,ay)				

		Local p:=New b2Vec2(px*WORLDSCALE,py*WORLDSCALE)

'		Local p:=b.body.GetPosition()		

		pdef.Initialize a.body,b.body,p,axis		

		pdef.lowerTranslation = -0.2
		pdef.upperTranslation = 0.6
		pdef.enableLimit = True

		pdef.maxMotorForce = force
		pdef.motorSpeed = speed
		pdef.enableMotor = True

		Local joint:=world.CreateJoint(pdef)

		Return b2PrismaticJoint(joint)
	End
	
	Function RemoveFixture:Void(body:b2Body,fixture:b2Fixture)
		body.DestroyFixture fixture
	End
	

	Method Update:Void()
		world.TimeStep(TIMESTEP, SPEEDLOOPS, POSLOOPS)
		world.ClearForces()
	End	
		
	Method Draw:Void()
		world.DrawDebugData()
	End

End

Class DebugDraw Extends b2DebugDraw
    Method Clear:Void()
    End
End

Const STATICBIT%=1
Const MACHINEBIT%=2
Const ROCKBIT%=4
Const BOTBIT%=8

Const DYNAMICBITS% = MACHINEBIT+ROCKBIT+BOTBIT
Const INANIMATEBITS% = STATICBIT+ROCKBIT

Class Part
	Field body:Body
	Field joint:b2RevoluteJoint
	Method New(body0:Body,joint0:b2RevoluteJoint)
		body=body0		
		joint=joint0
	End
End

Const SimonHeight%=1850
Const SimonChin%=1640
Const SimonHeadRadius%=(SimonHeight-SimonChin)/2
Const SimonHeadPosition%=SimonHeight-SimonHeadRadius
Global SimonMetrics%[]=[
	0,SimonHeadPosition,SimonHeadRadius,	
	0,1600,50,
	0,1400,30,
	0,1250,30,
	0,1000,80,
	0,840,30,
	0,660,5,
	100,560,30,
	0,120,20,
	200,60,10]

Class Biped	
	Const Head%=0
	Const Shoulder%=1
	Const Back%=2
	Const Elbow%=3
	Const Hips%=4
	Const Wrist%=5
	Const Finger%=6
	Const Knee%=7
	Const Ankle%=8
	Const Foot%=9
	
	Const JointNames$[]=["head","shoulder","back","elbow","hips","wrist","finger","knee","ankle","foot"]
	
	Field metrics%[]
	Field world:Sim
	Field parts:Part[10]
	Field hips:Body
	
	Field x#,y#

	Method New (world0:Sim,metrics0%[],x0#,y0#)
		world=world0
		metrics=metrics0
		x=x0
		y=y0
		Local mm#=0.1	
		Local HipX#=mm*metrics[Hips*3+0]
		Local HipY#=mm*metrics[Hips*3+1]
		Local HipR#=mm*metrics[Hips*3+2]
		
		hips = world.CreateBody(x+HipX,y-HipY)
		Local r#=HipR
		hips.AddRadialFixture(0,0,r,BOTBIT,STATICBIT|DYNAMICBITS)		
				
		parts[Hips]=New Part(hips,Null)
		parts[Knee]=AddPart(Hips,Knee,Hips)		
		parts[Ankle]=AddPart(Knee,Ankle,Knee)
		parts[Foot]=AddPart(Ankle,Foot,Ankle)
		
		parts[Back]=AddPart(Hips,Back,Hips)
		parts[Shoulder]=AddPart(Back,Shoulder,Back)
		parts[Head]=AddPart(Shoulder,Head,Shoulder)
		
		parts[Elbow]=AddPart(Shoulder,Elbow,Shoulder)
		parts[Wrist]=AddPart(Elbow,Wrist,Elbow)
		parts[Finger]=AddPart(Wrist,Finger,Wrist)
	End
	
	Method AddPart:Part(parentPin%,metric1%,metric0%)	
		Local pin:=parts[parentPin]		
		Local path#[6]
		Local mm#=0.1
		
		Local x0#=mm*metrics[metric0*3+0]
		Local y0#=mm*metrics[metric0*3+1]
		path[0]=0
		path[1]=0
		path[2]=mm*metrics[metric0*3+2]
		
		path[3]=mm*metrics[metric1*3+0]-x0
		path[4]=y0-mm*metrics[metric1*3+1]
		path[5]=mm*metrics[metric1*3+2]
			
		Local body:=world.CreateBody(x+x0,y-y0)
		body.AddPathFixture path,BOTBIT,INANIMATEBITS	

		Local joint:=world.CreateRevolute(pin.body,body,0,0)',-PI/4, PI/4)
		Return New Part(body,joint)
	End
End

	
Class Box2DFive Extends App

	Field world:Sim
	Field ground:Body
	Field bot:Biped
	Field renderCount%

	Method ResetWorld:Void()
		world=New Sim(0,10)
		bot=New Biped(world,SimonMetrics,200,200)		
		ground=AddBlock(0,450,600,10)
	End

	Method OnCreate%()
		ResetWorld
		SetUpdateRate 30
		Return 0
	End
		
	Method AddBlock:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateStatic(x,y)
		block.AddSquareFixture(w,h,STATICBIT,DYNAMICBITS)	
		Return block
	End

	Method AddChasis:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateBody(x,y)
		block.AddSquareFixture(w,h,MACHINEBIT,INANIMATEBITS)	
		Return block
	End

	Method AddPivot:Part(pin:Body,x#,y#)
		Local wheel:Body
		wheel = world.CreateBody(x,y,b2Body.b2_Body)
		wheel.density=20	
		Local r#=8
		wheel.AddRadialFixture(0,0,r,MACHINEBIT,INANIMATEBITS)	
		Return New Part(wheel,Null)
	End

	Method AddWheel:Part(pin:Body,x#,y#,r#)
		Local wheel:Body
		wheel = world.CreateBody(x,y,b2Body.b2_Body)
		wheel.density=2	
		wheel.AddRadialFixture(0,0,r,MACHINEBIT,INANIMATEBITS)	
		Local joint:=world.CreateRevolute(pin,wheel,0,0)
		Return New Part(wheel,joint)
	End

	Method AddBucket:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture BucketPoints,MACHINEBIT,INANIMATEBITS	
		Local joint:=world.CreateRevolute(pin,body,-PI/4, PI/4)
		Return New Part(body,joint)
	End

	Method AddArm:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture ArmPoints,MACHINEBIT,INANIMATEBITS	
		Local joint:=world.CreateRevolute(pin,body,-PI/4, PI/4)
		Return New Part(body,joint)
	End
		
	Method AddBall:Body()
		Local ball:Body
		ball = world.CreateBody(300,2)
		ball.AddRadialFixture(0,0,10,ROCKBIT,STATICBIT|DYNAMICBITS)		
		ball.ApplyImpulse(Rnd(-.1,.1), 0)
		Return ball
	End
	
	Method OnUpdate%()
		If KeyHit(KEY_F1) ResetWorld
		If KeyHit(KEY_F2) AddBall
		
		Local m0%=KeyDown(KEY_RIGHT)-KeyDown(KEY_LEFT)
		Local m1%=KeyDown(KEY_DOWN)-KeyDown(KEY_UP)
		Local m2%=KeyDown(KEY_X)-KeyDown(KEY_Z)
		Local m3%=KeyDown(KEY_S)-KeyDown(KEY_A)
		Local m4%=KeyDown(KEY_W)-KeyDown(KEY_Q)
		
		Local m5%=KeyDown(KEY_V)-KeyDown(KEY_C)
		Local m6%=KeyDown(KEY_F)-KeyDown(KEY_D)
		Local m7%=KeyDown(KEY_R)-KeyDown(KEY_E)

		bot.parts[Biped.Ankle].joint.SetMotorSpeed m0*2
		bot.parts[Biped.Foot].joint.SetMotorSpeed m1*2

		bot.parts[Biped.Back].joint.SetMotorSpeed m2*2
		bot.parts[Biped.Shoulder].joint.SetMotorSpeed m3*2
		bot.parts[Biped.Head].joint.SetMotorSpeed m4*2
		
		bot.parts[Biped.Elbow].joint.SetMotorSpeed m5*2
		bot.parts[Biped.Wrist].joint.SetMotorSpeed m6*2
		bot.parts[Biped.Finger].joint.SetMotorSpeed m7*2


		world.Update
		Return 0
	End

	Method OnRender%()
		renderCount+=1
		Cls 10,30,160
		world.Draw
		Return 0
	End
End

Function Main%()
	New Box2DFive
	Return 0
End

</textarea> <br><br></td></tr></table><br>
<a name="2109757"></a>

<a name="2109760"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DruggedBunny</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Gah, I missed all this! Will give it a whirl later, sounds cool! <br><br></td></tr></table><br>
<a name="2109782"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Todays version adds constraints to the joints and doubles up on the limbs so min-me now has the correct number.<br><br>Motors are hooked to keyboard speed settings and amount of torque is set to fun / slightly drunk / party mode:<br><br>qw er ty ui<br>as df gh jk<br>zx cv bn m,<br><br>temporarily online here - <a href="http://geom.nz/static/bot.html" target="_blank">http://geom.nz/static/bot.html</a><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' box2dseven.monkey
' F1 - reset
' F2 - add ball

Strict

Import mojo
Import box2d.collision

Const WORLDSCALE#=1.0/8
Const TIMESTEP#=1.0/20			'frantic 2x clock
Const FRAMERATE%=30
Const SPEEDLOOPS%=20
Const POSLOOPS%=20

Const SAHeight%=1850,SAChin%=1640
Const SAHeadRadius%=(SAHeight-SAChin)/2
Const SAHeadPosition%=SAHeight-SAHeadRadius
Global SAMetrics%[]=[
	0,SAHeadPosition,SAHeadRadius,	
	0,1650,50,
	0,1400,50,
	0,1250,40,
	0,1000,80,
	0,840,30,
	0,660,5,
	20,560,30,
	-20,120,20,
	200,60,10]

Class Body
	Global BodyDef:=New b2BodyDef()
	Global FixtureDef:=New b2FixtureDef()
	Global Impulse:=New b2Vec2

	Field parent:b2World
	Field body:b2Body
	Field density#=1
	
	Method New(	world:b2World,x#,y#,bodytype%)
		BodyDef.type = bodytype		
		BodyDef.fixedRotation=False		
		BodyDef.position.Set(x*WORLDSCALE,y*WORLDSCALE)
		body=world.CreateBody(BodyDef)
		parent=world
	End

	Method AddRadialFixture:b2Fixture(x#,y#,r#,bits%,mask%)
		Local shape:=New b2CircleShape(r*WORLDSCALE)
		If x Or y shape.SetLocalPosition New b2Vec2(x*WORLDSCALE,y*WORLDSCALE)
		Local fixture:=AddFixture(shape,bits,mask)		
		fixture.SetRestitution(.6)
		fixture.SetFriction(.8)	
		Return fixture		
	End	 
	
	Method AddSquareFixture:b2Fixture(w#,h#,bits%,mask%)
		Local shape:=New b2PolygonShape
		shape.SetAsBox w*WORLDSCALE,h*WORLDSCALE
		Return AddFixture(shape,bits,mask)
	End
	
	Method AddPathFixture:Void(points#[],bits%,mask%)
		Local n%=points.Length/3
		For Local i%=0 Until n
			Local x#=points[i*3+0]
			Local y#=points[i*3+1]
			Local r#=points[i*3+2]
			AddRadialFixture x,y,r,bits,mask	
		Next

		For Local i%=0 Until n-1
			Local x0#=points[i*3+0]*WORLDSCALE
			Local y0#=points[i*3+1]*WORLDSCALE
			Local r0#=points[i*3+2]*WORLDSCALE
			Local x1#=points[i*3+3]*WORLDSCALE
			Local y1#=points[i*3+4]*WORLDSCALE
			Local r1#=points[i*3+5]*WORLDSCALE
			Local dx#=x1-x0
			Local dy#=y1-y0
			Local dd#=dx*dx+dy*dy
			Local d#=Sqrt(dd)
			Local tx#=dy/d
			Local ty#=-dx/d			
			Local pts:b2Vec2[4]
			pts[0]=New b2Vec2(x0+r0*tx, y0+r0*ty)
			pts[1]=New b2Vec2(x1+r1*tx, y1+r1*ty)
			pts[2]=New b2Vec2(x1-r1*tx, y1-r1*ty)
			pts[3]=New b2Vec2(x0-r0*tx, y0-r0*ty)
			Local shape:=New b2PolygonShape
			shape.SetAsArray pts,4
			AddFixture(shape,bits,mask)
		Next
	End

	' must be convex
	
	Method AddPolygonFixture:b2Fixture(pts#[],bits%,mask%)	
		Local shape:=New b2PolygonShape		
		Local n%=pts.Length()/2
		Local points:=New 	b2Vec2[n]
		For Local i%=0 Until n
			Local x#=pts[i*2+0]
			Local y#=pts[i*2+1]
			points[i]=New b2Vec2(x,y)
		Next	
		shape.SetAsArray points,n
		Return AddFixture(shape,bits,mask)
	End
	
	' complex geometry welcome, only attach to static bodies as edges have zero mass
		
	Method AddStaticEdge:Void(pts#[],bits%,mask%)	
		Local last%=pts.Length()/2-1
		Local x1#=pts[last*2+0]
		Local y1#=pts[last*2+1]
		For Local i%=0 Until last
			Local x0#=x1
			Local y0#=y1
			x1=pts[i*2+0]
			y1=pts[i*2+1]
			Local p0:=New b2Vec2(x0,y0)
			Local p1:=New b2Vec2(x1,y1)
			Local shape:=New b2PolygonShape		
			shape.SetAsEdge p0,p1
			AddFixture(shape,bits,mask)
		Next	

	End
	
	Method AddFixture:b2Fixture(shape:b2Shape,bits%,mask%)
		FixtureDef.shape=shape
		FixtureDef.density=density
		FixtureDef.filter.categoryBits=bits
		FixtureDef.filter.maskBits=mask
		Local fixture:=body.CreateFixture(FixtureDef)
		Return fixture		
	End	
	
	Method ApplyImpulse:Void(x#,y#)
		Impulse.x=x
		Impulse.y=y
		body.ApplyForce Impulse,body.GetPosition()
	End
		
	Method ApplyTorque:Void(t#)
		body.ApplyTorque t
	End

	Method Rotate:Void(degrees#)
		body.SetAngle body.GetAngle()+degrees*PI/180
	End

End

Class Sim

	Field gravity:b2Vec2
	Field world:b2World
	
	Method New(gravityx#,gravityy#)
		gravity=New b2Vec2(gravityx,gravityy)
		Init gravity		
	End

	Method Init:Void(gravity:b2Vec2)
		world = New b2World(gravity,True)	'gravity,dosleep
		world.SetWarmStarting(True)
		Local dbgDraw:=New DebugDraw()		
		dbgDraw.SetDrawScale(1.0/WORLDSCALE)
		dbgDraw.SetFillAlpha(1.0)
		dbgDraw.SetLineThickness(1.0)
		dbgDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit)'| b2DebugDraw.e_pairBit)
		world.SetDebugDraw(dbgDraw)
	End
			
	Method CreateBody:Body(x#,y#)
		Return New Body(world,x,y,b2Body.b2_Body)
	End
	
	Method CreateStatic:Body(x#,y#)
		Return New Body(world,x,y,b2Body.b2_staticBody)
	End

	Method CreateRevolute:b2RevoluteJoint(a:Body,b:Body,rad0#,rad1#)
		Local r:=New b2RevoluteJointDef
		Local p:=b.body.GetPosition()		
		r.Initialize(a.body,b.body,p)		
		r.maxMotorTorque = 2000
		r.motorSpeed = 0        	
        	If rad0 Or rad1 r.enableLimit = True
        	r.enableMotor = True
		r.lowerAngle=rad0
		r.upperAngle=rad1		
		Local joint:=world.CreateJoint(r)
		Return b2RevoluteJoint(joint)
	End
	
	Method CreatePrism:b2PrismaticJoint(a:Body,px#,py#,b:Body,ax#,ay#,force#,speed#)

		Local pdef:=New b2PrismaticJointDef()

		Local axis:=New b2Vec2(ax,ay)				

		Local p:=New b2Vec2(px*WORLDSCALE,py*WORLDSCALE)

'		Local p:=b.body.GetPosition()		

		pdef.Initialize a.body,b.body,p,axis		

		pdef.lowerTranslation = -0.2
		pdef.upperTranslation = 0.6
		pdef.enableLimit = True

		pdef.maxMotorForce = force
		pdef.motorSpeed = speed
		pdef.enableMotor = True

		Local joint:=world.CreateJoint(pdef)

		Return b2PrismaticJoint(joint)
	End
	
	Function RemoveFixture:Void(body:b2Body,fixture:b2Fixture)
		body.DestroyFixture fixture
	End
	

	Method Update:Void()
		world.TimeStep(TIMESTEP, SPEEDLOOPS, POSLOOPS)
		world.ClearForces()
	End	
		
	Method Draw:Void()
		world.DrawDebugData()
	End

End

Class DebugDraw Extends b2DebugDraw
    Method Clear:Void()
    End
End

Const STATICBIT%=1
Const MACHINEBIT%=2
Const ROCKBIT%=4
Const BOTBIT%=8

Const DYNAMICBITS% = MACHINEBIT+ROCKBIT+BOTBIT
Const INANIMATEBITS% = STATICBIT+ROCKBIT

Class Part
	Field body:Body
	Field joint:b2RevoluteJoint
	Method New(body0:Body,joint0:b2RevoluteJoint)
		body=body0		
		joint=joint0
	End
End

Class Metric
	Const Head%=0
	Const Shoulder%=1
	Const Back%=2
	Const Elbow%=3
	Const Hip%=4
	Const Wrist%=5
	Const Finger%=6
	Const Knee%=7
	Const Ankle%=8
	Const Foot%=9		
	Const JointNames$[]=["head","shoulder","back","elbow","hips","wrist","finger","knee","ankle","foot"]	

	Global Constraints%[]=[
		-3,3,
		-1,3,
		-2,6,
		-18,6,
		-4,4,
		-8,1,
		-8,8,
		-5,5,
		-1,14,
		-3,7,
		0,0]

	Field metrics%[]
	Method New(metrics0%[])
		metrics=metrics0
	End
	Const mm#=0.1
	Method GetX#(metric%)
		Return mm*metrics[metric*3+0]
	End
	Method GetY#(metric%)
		Return mm*metrics[metric*3+1]
	End
	Method GetR#(metric%)
		Return mm*metrics[metric*3+2]
	End
	Const rr#=PI/16.0
	Method GetM0#(metric%)
		Return rr*Constraints[metric*2+0]
	End
	Method GetM1#(metric%)
		Return rr*Constraints[metric*2+1]
	End
End

Class Biped
	Field world:Sim
	Field metric:Metric

	Field hips:Body	
	Field x#,y#
	Field parts:Part[16]

	Const Hips%=0
	Const Back%=1
	Const Shoulder%=2
	Const Head%=3
	Const Left%=4
	Const Right%=10
	Const Elbow%=0
	Const Wrist%=1
	Const Finger%=2
	Const Knee%=3
	Const Ankle%=4
	Const Foot%=5		

	Method New (world0:Sim,metrics%[],x0#,y0#)
		world=world0
		metric=New Metric(metrics)

		x=x0
		y=y0
		Local HipX#=metric.GetX(Metric.Hip)
		Local HipY#=metric.GetY(Metric.Hip)
		Local HipR#=metric.GetR(Metric.Hip)
		
		hips = world.CreateBody(x+HipX,y-HipY)
		Local r#=HipR
		hips.AddRadialFixture(0,0,r,BOTBIT,STATICBIT|DYNAMICBITS)		
				
		parts[Hips]=New Part(hips,Null)		
		parts[Back]=AddPart(Hips,Metric.Back,Metric.Hip)
		parts[Shoulder]=AddPart(Back,Metric.Shoulder,Metric.Back)
		parts[Head]=AddPart(Shoulder,Metric.Head,Metric.Shoulder)

		parts[Left+Knee]=AddPart(Hips,Metric.Knee,Metric.Hip)		
		parts[Left+Ankle]=AddPart(Left+Knee,Metric.Ankle,Metric.Knee)
		parts[Left+Foot]=AddPart(Left+Ankle,Metric.Foot,Metric.Ankle)

		parts[Left+Elbow]=AddPart(Shoulder,Metric.Elbow,Metric.Shoulder)
		parts[Left+Wrist]=AddPart(Left+Elbow,Metric.Wrist,Metric.Elbow)
		parts[Left+Finger]=AddPart(Left+Wrist,Metric.Finger,Metric.Wrist)

		parts[Right+Knee]=AddPart(Hips,Metric.Knee,Metric.Hip)		
		parts[Right+Ankle]=AddPart(Right+Knee,Metric.Ankle,Metric.Knee)
		parts[Right+Foot]=AddPart(Right+Ankle,Metric.Foot,Metric.Ankle)

		parts[Right+Elbow]=AddPart(Shoulder,Metric.Elbow,Metric.Shoulder)
		parts[Right+Wrist]=AddPart(Right+Elbow,Metric.Wrist,Metric.Elbow)
		parts[Right+Finger]=AddPart(Right+Wrist,Metric.Finger,Metric.Wrist)
	End
	
	Method AddPart:Part(parent%,metric1%,metric0%)	
		Local pin:=parts[parent]		
		Local path#[6]
		
		Local x0#=metric.GetX(metric0)
		Local y0#=metric.GetY(metric0)
		path[0]=0
		path[1]=0
		path[2]=metric.GetR(metric0)
		
		path[3]=metric.GetX(metric1)-x0
		path[4]=y0-metric.GetY(metric1)
		path[5]=metric.GetR(metric1)
			
		Local body:=world.CreateBody(x+x0,y-y0)
		body.AddPathFixture path,BOTBIT,INANIMATEBITS	
		
		Local m0#=metric.GetM0(metric1)
		Local m1#=metric.GetM1(metric1)

		Local joint:=world.CreateRevolute(pin.body,body,m0,m1)

		Return New Part(body,joint)
	End
End

	
Class Box2DSeven Extends App

	Field world:Sim
	Field ground:Body
	Field bot:Biped
	Field renderCount%

	Method ResetWorld:Void()
		world=New Sim(0,10)
		bot=New Biped(world,SAMetrics,200,400)		
		ground=AddBlock(0,450,600,10)
	End

	Method OnCreate%()
		ResetWorld
		SetUpdateRate 30
		Return 0
	End
		
	Method AddBlock:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateStatic(x,y)
		block.AddSquareFixture(w,h,STATICBIT,DYNAMICBITS)	
		Return block
	End

	Method AddChasis:Body(x#,y#,w#,h#)
		Local block:Body
		block = world.CreateBody(x,y)
		block.AddSquareFixture(w,h,MACHINEBIT,INANIMATEBITS)	
		Return block
	End

	Method AddPivot:Part(pin:Body,x#,y#)
		Local wheel:Body
		wheel = world.CreateBody(x,y,b2Body.b2_Body)
		wheel.density=20	
		Local r#=8
		wheel.AddRadialFixture(0,0,r,MACHINEBIT,INANIMATEBITS)	
		Return New Part(wheel,Null)
	End

	Method AddWheel:Part(pin:Body,x#,y#,r#)
		Local wheel:Body
		wheel = world.CreateBody(x,y,b2Body.b2_Body)
		wheel.density=2	
		wheel.AddRadialFixture(0,0,r,MACHINEBIT,INANIMATEBITS)	
		Local joint:=world.CreateRevolute(pin,wheel,0,0)
		Return New Part(wheel,joint)
	End

	Method AddBucket:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture BucketPoints,MACHINEBIT,INANIMATEBITS	
		Local joint:=world.CreateRevolute(pin,body,-PI/4, PI/4)
		Return New Part(body,joint)
	End

	Method AddArm:Part(pin:Body,x#,y#)
		Local body:Body
		body = world.CreateBody(x,y,b2Body.b2_Body)		
		body.density=2	
		body.AddPathFixture ArmPoints,MACHINEBIT,INANIMATEBITS	
		Local joint:=world.CreateRevolute(pin,body,-PI/4, PI/4)
		Return New Part(body,joint)
	End
		
	Method AddBall:Body()
		Local ball:Body
		ball = world.CreateBody(300,2)
		ball.AddRadialFixture(0,0,10,ROCKBIT,STATICBIT|DYNAMICBITS)		
		ball.ApplyImpulse(Rnd(-.1,.1), 0)
		Return ball
	End
	
	Method OnUpdate%()
		If KeyHit(KEY_F1) ResetWorld
		If KeyHit(KEY_F2) AddBall

		Local m0%=KeyDown(KEY_X)-KeyDown(KEY_Z)
		Local m1%=KeyDown(KEY_S)-KeyDown(KEY_A)
		Local m2%=KeyDown(KEY_W)-KeyDown(KEY_Q)
		
		Local m3%=KeyDown(KEY_V)-KeyDown(KEY_C)
		Local m4%=KeyDown(KEY_F)-KeyDown(KEY_D)
		Local m5%=KeyDown(KEY_R)-KeyDown(KEY_E)

		Local m6%=KeyDown(KEY_N)-KeyDown(KEY_B)
		Local m7%=KeyDown(KEY_H)-KeyDown(KEY_G)
		Local m8%=KeyDown(KEY_Y)-KeyDown(KEY_T)

		Local m9%=KeyDown(KEY_COMMA)-KeyDown(KEY_M)
		Local m10%=KeyDown(KEY_K)-KeyDown(KEY_J)
		Local m11%=KeyDown(KEY_I)-KeyDown(KEY_U)

		Local m12%=KeyDown(KEY_RIGHT)-KeyDown(KEY_LEFT)
		Local m13%=KeyDown(KEY_DOWN)-KeyDown(KEY_UP)

		Local f#=1
		
		bot.parts[Biped.Back].joint.SetMotorSpeed m0*f
		bot.parts[Biped.Shoulder].joint.SetMotorSpeed m1*f
		bot.parts[Biped.Head].joint.SetMotorSpeed m2*f
		
		Const Left%=Biped.Left
		bot.parts[Left+Biped.Elbow].joint.SetMotorSpeed m3*f
		bot.parts[Left+Biped.Wrist].joint.SetMotorSpeed m4*f
		bot.parts[Left+Biped.Finger].joint.SetMotorSpeed m5*f

		bot.parts[Left+Biped.Knee].joint.SetMotorSpeed m6*f
		bot.parts[Left+Biped.Ankle].joint.SetMotorSpeed m7*f
		bot.parts[Left+Biped.Foot].joint.SetMotorSpeed m8*f

		Const Right%=Biped.Right
		bot.parts[Right+Biped.Knee].joint.SetMotorSpeed m9*f
		bot.parts[Right+Biped.Ankle].joint.SetMotorSpeed m10*f
		bot.parts[Right+Biped.Foot].joint.SetMotorSpeed m11*f

		bot.parts[Right+Biped.Elbow].joint.SetMotorSpeed -m3*f
		bot.parts[Right+Biped.Wrist].joint.SetMotorSpeed -m4*f
		bot.parts[Right+Biped.Finger].joint.SetMotorSpeed -m5*f

		'	Const JointNames$[]=["head","neck","shoulder","back","elbow","hips","wrist","finger","knee","ankle","foot"]	

'		bot.parts[Biped.Hips].joint.SetMotorSpeed m13*f
'		bot.parts[Biped.Finger].joint.SetMotorSpeed m12*f
'
		world.Update
		Return 0
	End

	Method OnRender%()
		renderCount+=1
		Cls 10,30,160
		world.Draw
		Return 0
	End
End

Function Main%()
	New Box2DSeven
	Return 0
End
</textarea><br><br>The hips and pelvis need separating they are both spinning at same position which is bad I think.<br><br>This week I am thinking about tackling some of the following:<br><br>- basic motor feedback so mini-me can hold a pose<br>- attachments so mini-me can hold a phone while driving a quarry loader<br>- a four legged friend and a two winged friend <br>- more vehicles with a downhill run with jumps... <br><br></td></tr></table><br>
<a name="2109785"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Motors are hooked to keyboard speed settings and amount of torque is set to fun / slightly drunk / party mode: <br></div><br>LOL! I think I broke his back!<br><br>These are great tutorials skid! Would love to see you attaching some graphics to the objects too. <br><br></td></tr></table><br>
<a name="2109791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks! I just did my first test broadcast. Current graphics blur the hell out so it looks truly hideous on youtube.<br><br>The downhill step will have the viewport attached to a body, will add graphics once that bit is working. <br><br></td></tr></table><br>
<a name="2109796"></a>

<a name="2109797"></a>

<a name="2109800"></a>

<a name="2109801"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am using an app called OBS to broadcast live from chrome to youtube.<br><br>I think I have the bandwidth and just need a bit more computing power for the compression stage.<br><br>This particular performance is called I have no shame.<br><br><iframe width="560" height="345" src="http://www.youtube.com/embed/otAx1_D8078" frameborder="0" allowfullscreen></iframe><br><br>Live broadcast is here.<br><br><iframe width="560" height="345" src="http://www.youtube.com/embed/d9gPWMUL8c0" frameborder="0" allowfullscreen></iframe> <br><br></td></tr></table><br>
<a name="2110120"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skid</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> After struggling with a back bone that could break very easily the penny finally dropped.<br><br>By removing the fixture I attach to the hips in above version the back and upper legs suddenly start behaving extremely well.<br><br>I had tried a weld joint but that gave me very bizarre results.<br><br>Removing the hip fixture however is not without it's own problems. box2d seems to say thats impossible to solve and allows mini-me to hang in what looks like a very unbalanced state.<br><br>Rebuilding mini-me starting with the head and not the hips seems to be the correct fix and the fragile 90 year old breakable pelvis issue seems to be solved.<br><br>Emulating carrying a tray of drinks is one I thought I will add once we have learned to walk. <br><br></td></tr></table><br>
<a name="2115114"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TheRedFox</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for making these available! <br><br></td></tr></table><br>
<a name="2116922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RedGTurtlepa</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks for this! <br><br></td></tr></table><br>
<a name="2116986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SLotman</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know this is an old topic, but since it was resurrected... ^_^<br><br><div class="quote"> A top down simulation such as pool or mini-golf where gravity is turned off and the camera faces the ground <br></div><br>I'd love to see how to implement that! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
