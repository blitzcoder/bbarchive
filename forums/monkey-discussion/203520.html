<!DOCTYPE html><html lang="en" ><head ><title >More modules!</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >More modules!</h1><a href="forums.php" >Monkey Archive Forums</a>/<a href="topics.php?forum=510" >Monkey Discussion</a>/<a href="#bottom" >More modules!</a><br><br>
<a name="2037139"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Ok, there are a few new modules currently under development...<br><br><div class="quote"> <br>* databuffer (glfw/stdcpp/ios/android/html5)<br><br>An updated version of the opengl databuffer, including DataBuffer.Load.<br><br>* stream<br><br>An abstract stream class, much like bmx's. Can read/write databuffers, bytes, shorts, int, floats.<br><br>* datastream (glfw/stdcpp/ios/android/html5)<br><br>Wraps a databuffer for streaming data in/out of a databuffer.<br><br>* filestream (glfw/stdcpp/ios/android)<br><br>For reading/writing files. Currently can only read assets on android, but I believe it's possible to store assets in the 'regular' filesystem (?) so if I get that going you'll be able to access the whole filesystem.<br><br>* tcpstream (glfw/stdcpp/ios/android)<br><br>For creating client socket streams.<br><br>* filesystem( glfw/stdcpp/ios/android)<br><br>For examining file types, listing dirs etc.<br> <br></div><br><br>One issue is just where these module should go in the module tree? I can think of 4 options here:<br><br>* Dump them all in the root module namespace, python style. I don't particularly like this idea (I used to), as I think the current monkey approach of having a small number of publisher/proper-noun top level modules works pretty well. It also makes it easier/cleaner to provide an 'import all' style top level module.<br><br>* Dump them in the monkey module and auto-import them all, ala lang, list etc. I don't like this idea much either, as it dumps a bunch of new identifiers into the global namespace. You can get around this using module paths, but it's still nasty...<br><br>* Dump them in the monkey module and NOT auto-import them. This is better, but I think the monkey modules should only contain modules that 'work everywhere', and that is not gonna be the case with this stuff.<br><br>* Dump them in a whole new top-level module, say, 'brl'. 'Import brl' can perform the usual lazy import everything behavior, but you'd also be able to selectively import stuff. This is my current favorite idea, and I now think maybe all non-essential monkey modules (wrt: translators, which is probably only monkey.lang and monkey.math) like list, map, stack etc should be moved here...eventually...?<br><br>Also, a few notes on target compatibility:<br><br>* None of these work on XNA. There are technical reaons for this (mainly the fact that XNA doesn't seem to be able to do databuffers) but I also think that XNA is reaching the end of the road. I'll continue to support XNA and improve it where possible, but I think my time would be better spent adding this stuff to a win8 target.<br><br>* None of these work on Flash. DataBuffers are possible and I'll probably add them, but Flash apps are generally hosted remotely, so local filesystem access is redundant unless you're writing an 'installable' Flash app. This is certainly possible, but I think the time would be better spent improving other installable targets such as GLFW, win8 etc.<br><br>* HTML5 has no filesystem/file support. There are new FileReader etc objects for dealing with local files in JS but, like Flash, I think HTML5 should remain a 'remotely hosted' target (logically anyway - browsers can still install/cache HTML5 apps with a manifest). There are also technical issues with synchronously reading files in JS - ie: you can't! The file IO objects all operate asynchronously, which means 'read' actually means 'start reading and call this function when finished'. This is similar to image loading issues in HTML5, and is probably something that will need to be addressed eventually, but I don't want to have to put ALL targets through the hassle of having to declare callbacks or something just for the sake of HTML5.<br><br>* HTML5 has no socket support yet. There's the WebSockets API (which I had a hack at a while back with limited success - (could't find a functioning server!) but this will probably entail having to write a custom server that recognizes the WebSocket protocol (which I think is just HTTP on a different port - but still...). Also, it's likely there will be synchronicity problems with WebSockets, ie: you wont be able to just read them, you'll have to start a read operation and (somehow) get notified when it's finished. This is certinaly doable, but the interface probably wont look like the standard socket interface. I should still be able to hack HttpGet and HttpPost functions though...<br><br>That's a fair few 'gotchas', but that was always going to be the case when it came to this stuff. <br><br></td></tr></table><br>
<a name="2037142"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >silentshark</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good stuff - mark, I can see this helping open up all kinds of new possibilities.<br><br>Btw, Did you ever get any further on an in game ad module that was mentioned a whle back? <a href="http://www.monkeycoder.co.nz/Community/posts.php?topic=1652#27878" target="_blank">http://www.monkeycoder.co.nz/Community/posts.php?topic=1652#27878</a><br><br>I appreciate that some of the guys have done some sterling work crafting their own, but things like ads on ios still remain a pain. Easier in game ads would be a big monkey selling point IMHO. <br><br></td></tr></table><br>
<a name="2037143"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jondecker76</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> These all look great!<br><br>I do have a suggestion though, as I'm not sure what your scope of "local filesystem" is.  In the case of flash (or any other target that is hosted remotely) there is still great value in having access to the remote filesystem.  I would use monkey for my web apps if I could, but things like this and the inability to dynamically load images is what is holding it back from this market.<br><br>Still, all good news - thanks for the update <br><br></td></tr></table><br>
<a name="2037148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; but things like ads on ios still remain a pain.<br><br>I agree, but all the ad systems all seem to require low-level tinkering with views/view-controllers etc which makes them very hard to modularize, since these objects are effectively 'singletons'.<br><br>I guess it could  theoretically be done with, say separate view/view-controller etc. modules, but it'd be a hell of a lot of work and really require the design of 'native APIs' something I really didn't/don't want to attempt (I briefly tried with Mojo - gave up pretty quickly).<br><br>So I think ad systems really need to be added at the target level, and I can only think of 2 practical ways to do this.<br><br>* Create a 'mega target' that contains ALL possible ad systems and kludges in the correct one at build time based on an app config setting.<br><br>* Add some kind of 'subtarget' system, where multiple target dirs can share the same target build code. This way, you could have multiple ios targets, eg: ios_adwords and ios_macads or something, each with customized view controller code and project file.<br><br>But, I haven't yet implemented or even tried a Monkey ad system so please correct me if I'm missing something here...<br><br>&gt; In the case of flash (or any other target that is hosted remotely) there is still great value in having access to the remote filesystem.<br><br>Depends what you mean by 'filesystem', 'access' and 'the'!<br><br>By filesystem access, I'm really talking able the ability to create/read/write local files that the app *doesn't* know about - ie: files the app creates at runtime, or files outside the data/ dir etc. In fact, on Android the filesystem can't even see stuff in the data/ dir as assets are (currently anyway) embedded in the apk. Not sure about ios yet.<br><br>Everything in data/ is stuff the app already knows about at compile time, so doesn't really need a filesystem to access it. I guess a 'virtual filesystem' that maps to data/ might be useful, but that's a different problem.<br><br>If you're talking about accessing binary data, then a Flash DataBuffer should be able to help - I hope, haven't tried it yet.<br><br>Again though, I'm not sure what can been done in Flash (eg: perhaps you create files on the server? which API then?) so correct me if I'm wrong. <br><br></td></tr></table><br>
<a name="2037146"></a>

<a name="2037147"></a>

<a name="2037151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Depends what you mean by 'filesystem', 'access' and 'the'! <br></div><br>i haven't noticed if this ability is in there yet-- but i think the value of a Flash filesystem is to load files asynchronously and therefore to have a preloader for all the graphic files.<br><br>This is something I am noticing that is a need lately for most targets, except for maybe glfw, since synchronous is relatively fast.<br><br><div class="quote"> There are also technical issues with synchronously reading files in JS - ie: you can't! <br></div><br>this is what is slowing down miniB3D, but I made a preloader to handle this issue. again, i think there's value on preloaders-- which we can make ourselves, we just need the image file loading utils.<br><br><div class="quote"> but I also think that XNA is reaching the end of the road. <br></div><br>agreed, but if you need ideas, look at Rone's miniB3D handling of databuffer, or the older one i have in there on github for xna. seems to work. <br><br></td></tr></table><br>
<a name="2037182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool module update! :)<br><br>Use Case 1: Loading resources async from a server on web and mobile games is getting more useful these days, especially if the game has a virtual shop. On larger games with loads of graphics this is of even greater importance. It reduces size, reduces initial loading time and allows OnTheFly updates.<br><br>Use Case 2: Monetize Monkey Games using Ads. Some Ads or libs are super easy to implement, others not so. Those others are because they want the viewcontroller or they want the user to attach delegates and initialize it in a particular place. However this can be circumvented by creating an custom class in ObjectiveC that wraps this. The problem then becomes that essential code are part of the xcode project part of things, and not in a sharable monkey module. Chartboost for example just updated their API to NOT use the viewcontroller - so this problem might solve itself over time if that is a sign that API simplicity rules.<br><br>Networking: Async read/write. I see Async using a callback as a benefit on all platforms? A application freeze is usually no good even on windows when reading (for ex) a big map before the next level starts, or maybe I misunderstood that?<br><br>I would assume creating a Databuffer struct/class in C# would be quite simple, I don't see why it need to be XNA specific?<br><br>&gt; * Dump them in a whole new top-level module, say, 'brl'. <br>I like this the best. I have found myself using the diddy ArrayList more and more latley instead of the Monkey List. In some weird logical way it do make sense that the non-language parts are separate from the Monkey core. <br><br></td></tr></table><br>
<a name="2037156"></a>

<a name="2037155"></a>

<a name="2037154"></a>

<a name="2037161"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; * Dump them in a whole new top-level module, say, 'brl'.<br><br>I also prefer this.  And adding 'import brl' to a file is no real imposition any more than adding 'import mojo'. <br><br></td></tr></table><br>
<a name="2037172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I see Async using a callback as a benefit on all platforms? <br></div><br><br>I agree <br><br></td></tr></table><br>
<a name="2037277"></a>

<a name="2037278"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> For websockets check out: <a href="http://cjihrig.com/blog/websockets-in-node-js-0-8-6-for-windows-7/" target="_blank">http://cjihrig.com/blog/websockets-in-node-js-0-8-6-for-windows-7/</a><br><br>I also agree that a callback would be nicer, it seems more natural to respond when messages are received (instead of polling). It also means networking can be done without blocking (depending on target)... One of the major drawbacks with blitzmax networking.<br><br>Are we going to get UDP as well? It is still important for game dev.<br><br>Thinking about it you could probably implement it as an interface that acts as a message reciever for when file is loaded or message received. You could then potentially wrap this in procedural functions that keep in a loop until the callback is received and a 'finished' flag is set.<br><br>That way you give the choice to the user if they want to work procedural or event based. <br><br></td></tr></table><br>
<a name="2037225"></a>

<a name="2037224"></a>

<a name="2037316"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DruggedBunny</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been having a go at writing a BlitzMax-based WebSockets server because of this post... You basically do a 'handshake' over TCP and can then send different types of data back and forth in 'frames' -- it's supposed to be really quick, too.<br><br>I've got the weird "client key -&gt; SHA-1 -&gt; Base64" handshake working so far with some online text-based clients (in Chrome on Windows) and can receive their data... just need to decode it next as it's all messed up, but I know the data is stored in frames and not too hard to get at. Done for tonight though! <br><br></td></tr></table><br>
<a name="2037315"></a>

<a name="2037392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good stuff :D so I wonder the feasibility is to make websockets router invisible to monkey networking commands? <br><br></td></tr></table><br>
<a name="2037402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Regarding async loading, what sort of API would people like to see here? Some pseudo code would be great!<br><br>Should load commands be retrofitted to perform asynchronously, so you still get back an image or sound object, you just can't use it yet? Or should preloading returning a different object, or even no object - the path just gets mapped to a preloaded object so that LoadImage works next time you use it?<br><br>And I hope you guys  aren't talking about callback based async streaming, eg: converting this...<br><br><pre class=code>
Local count:=ReadInt()
For Local i:=0 Until count
  Local strLen:=ReadInt()
  ...read string etc...
</pre><br><br>...to an async version would be pretty nasty - you'd end up having to create a state machine that changes state on each 'read complete' event. For file formats that contain 'chunk lengths' etc, this is a pretty big problem.<br><br>In general, I think async loading would work for loading 'monolithic' objects like images, sounds, entire databuffer 'blobs' etc - but would not be practical for reading files with variable sized chunks, like the above. Of course, it may be sufficient to load a file in one big chunk, then read through it synchronously with a datastream.<br><br>The other approach to all this async stuff is to start looking at threading.<br><br>If all you're after is a 'loading' screen, this could probably be done pretty cheaply/easily already (ignoring HTML5 for now) - all native 'loading' commands could, upon entry, enable a thread that regularly invokes App.OnLoading(), and disables it upon return. This would give you some degree of synchronization - ie: OnLoading would never be called while your Monkey code was executing. It would still be possible to lockup the OnLoading thread if you don't call Load often enough though.<br><br>This could be expanded to a system with 'fibres' (ie: cooperative threads) that can yield to each other. This'd be my preferred approach in a way - with some kind of thread system it'd be possible to implement image etc preloading in pure Monkey, plus a whole lot more of course.<br><br>HTML5 is slowly getting thread support - it already has Worker threads, although these can't access the DOM/canvas/images/sounds etc yet, so aren't useful for async loading problems right now. These threads can however use new FileReadSync objects though which solves the problem above.<br><br>As for the brl modules, I've decided to hold back on the filesystem and filestream modules for now - I really need to expand the loading commands to handle external files first. So for now, you're still stuck with only being able to load things in data/.<br><br>The good news is that databuffers are now working on all targets (thanks Adam/Rone!), can be loaded synchronously (haven't tested on psm yet) and read stream-style using a datastream. These files still need to be in your data/ dir, and there's a new BINARY_FILES data file filter to flag which files can be loaded into a databuffer (currently defaults t *.bin|*.dat). <br><br></td></tr></table><br>
<a name="2037412"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> how about using the async loading functions that are native to html5 and flash (dont know about smartphones), and faking it on the desktop targets<br><br>Im talking about images and sounds, not variable chunk files <br><br></td></tr></table><br>
<a name="2037410"></a>

<a name="2037411"></a>

<a name="2037414"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>That's sort of the first option I mentioned.<br><br>One way to do this would be to add something like...<br><br><pre class=code>
Interface ImageListener
    Method ImageLoaded:Void( image:Image,success:Bool )
End
</pre><br><br>...to mojo graphics, and add an ImageListener param to LoadImage. Ditto for LoadSound/LoadDataBuffer. Perhaps this could be generalized with a Loadable class and LoadableListener interface?<br><br>Should ImageLoaded be allowed to fire at any time? This might cause synchronization problems if it goes off while your code is doing something messy - perhaps the system should guarantee this is only called when your app is idle, ie: has returned from OnUpdate/OnRender etc? Otherwise, confusion arises over which bits of your code need to be re-entrant, as I recently discovered with Qt... <br><br></td></tr></table><br>
<a name="2037413"></a>

<a name="2037434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd definitely vote for the coroutine/yield direction if possible. I'm not a huge fan of the Flash way of loading async images, but it would be better than nothing. The thread method would also be useful for network commands etc. I'd recommend taking a look at the way Unity does coroutines (at least in c#, not the horrid Unityscript), as I think it's got a good balance between power and simplicity.<br><br>Examples:<br>yield return new WaitForSeconds(2);<br>yield return new WaitForEndOfFrame();<br><br>WWW w = new WWW();<br>yield return w; <br><br></td></tr></table><br>
<a name="2037436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Mark: Instead of the whole interfaces approach, wouldn't it be easier to have an "Status" property on the Image (and Sound) classes? I think this would be a lot simpler to implement. A simple status atribute with values like: Empty, Loading, Loaded, and Failed. <br><br>Now, <i>if we could have delegates</i> we could easily have a sort of optional call-back method call for the very unusual scenario when you want to perform an additional acction when the load process has ended, so you get the same functionality that with the listeners, but I think it could be a lot simpler to use. <br><br></td></tr></table><br>
<a name="2037437"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Images etc could also provide a status method easily enough, but there were a couple of requests for a callback based approach and that's just what I came up with off the top of my head. The callback wouldn't be that much harder to implement anyway - all the fun stuff's gonna be in the behind-the-scenes threading...<br><br>If you wanted to skip the callback, you could just pass Null as the ImageListener to LoadImage and use a purely polled approach. The presence of the listener param could still signify an async load though, eg:<br><br>Local img:=LoadImage( "blah.png" )         'sync load<br>Local img:=LoadImage( "blah.png",myapp )   'async/callback/polled load<br>Local img:=LoadImage( "blah.png",Null )    'async/polled load<br><br>I don't think the interface approach would be that hard to use - simplest case, just implement ImageListener in your App subclass and pass your app to LoadImage. Yes, delegates would allow you to wire up different images to different 'loaded' methods of the same object, but I don't think that'd be much of a win since as you say it'd probably be used reasonably rarely anyway.<br><br>Another option would be to just skip the interface and add OnImageLoaded, OnSoundLoaded etc to app - or even just a single OnLoaded (more flexible for external mods). Then, a load flag or enable functions could be used to turn async loading on/off. <br><br></td></tr></table><br>
<a name="2037444"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I do like the simplicity of having a State like Ziggy suggested. An interface is also a simple and a more versatile approach. At first it may be uncommon to some, but it is simple. If using the Interface approach, diddy and other modules can easily implement a State:int and probably will.<br><br>I do not think OnImageLoaded should be in App - with the exception of very simple games I fear that will complicate code and create hard to avoid dependencies, and where does it end? OnBigFileRead, OnConnect..<br><br>The interface approach can be used both by mojo and external libs, additions and improvements will probably be easier to create and share. Simplicity.<br><br>[monkeycode]' Send Image. Note: in IRL code I probably would not do new here<br>Local myTCPStream:Stream = new Stream("192.168.0.1", 6001)<br>myTCPStream.WriteFile( "blah.png", new OnImageSentCallback )<br><br>Class OnImageSentCallback implements StreamOnWriteFileCallback<br>   Method OnWriteFileCallback:Void(file:File)<br>      Print "Congratulations! File "+file.Name+" was successfully sent!"<br>   End  <br>End [/monkeycode]<br>This would mean I could have a class that handles operations for network, resources, and other stuff, myown and monkey intermixed:<br><br>[monkeycode]' Global is some file<br>Global Network:NetworkManager = new NetworkManager <br><br>'In Network Code<br>MonkeyTCPStream.Write( new DataBuffer("Test"), Network ) 'TCPStream.OnSendCallback<br>MonkeyTCPStream.Read( Network ) 'TCPStream.OnReceiveCallback<br><br>'In App Specific Network code<br>MyTCPStream.Send( new MyPacket("Hello world!"), Network ) <br>MyTCPStream.ListenToMyOwnPacket( Network ) ' OnMyOwnPacketReceivedCallback<br><br>Class NetworkManager implements TCPStreamOnSend, TCPStreamOnReceive, MyOwnPacketOnSent, MyOwnPacketOnReceived<br>   <br>   Method OnTCPStreamSend:Void(data:DataBuffer) 'TCPStreamOnSend Interface<br>      Print "We sent "+data.Length+" bytes!"<br>   End <br><br>   Method OnTCPStreamReceive :Void(data:DataBuffer) 'TCPStreamOnReceive Interface<br>      Print "We received "+data.Length+" bytes!"<br>   End <br><br>   Method OnMyOwnPacketSent:Void(pack:MyOwnPacket) ' MyOwnPacketOnSent Interface<br>      Print "Congratulations! File "+file.Name+" was successfully sent!"<br>   End  <br><br>   Method OnMyOwnPacketReceived:Void(pack:MyOwnPacket) 'MyOwnPacketOnReceived Interface<br>      Print "Received "+pack.ID+" from "+pack.FromName+" containing: "+pack.Data<br>   End <br>End [/monkeycode]<br><br>Any class can be used to implement the Interface, even the App class. <br><br></td></tr></table><br>
<a name="2037443"></a>

<a name="2037442"></a>

<a name="2037441"></a>

<a name="2037447"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I implemented threading and coroutines in a subproject of Diddy, but not for HTML5, Flash, or XNA (I need to read up on threading in .NET)<br><br><a href="http://code.google.com/p/diddy/source/browse/#svn%2Ftrunk%2Fsrc%2Fthreading" target="_blank">http://code.google.com/p/diddy/source/browse/#svn%2Ftrunk%2Fsrc%2Fthreading</a> <br><br></td></tr></table><br>
<a name="2037448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> perhaps the system should guarantee this is only called when your app is idle, ie: has returned from OnUpdate/OnRender etc <br></div><br><br>sounds reasonable <br><br></td></tr></table><br>
<a name="2037450"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Xaron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Omg, Marc I love you. Lol. TCP streams! Any ETA on that? I can concentrate on Bluetooth in that case for my MNet module. <br><br></td></tr></table><br>
<a name="2037454"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; An interface is also a simple and a more versatile approach.<br><br>Yes, definitely more flexible and I think it's the right way to go, but simple...?<br><br>I had a quick hack at rewriting this simple HTTPGet asynchronously...<br><br><pre class=code>
Function Main()
	Local stream:=New TCPStream
	
	If stream.Connect( "www.blitzbasic.com",80 )
		Print "Connected!"
		stream.WriteLine "GET / HTTP/1.0"
		stream.WriteLine "Host: www.blitzbasic.com"
		stream.WriteLine ""
		Local n:=0
		While Not stream.Eof()
			Local line:=stream.ReadLine()
			Print line
		Wend
		stream.Close
		Print "BYE!!!!"
	Else
		Print "Failed to connect!"
	Endif
End
</pre><br><br>...and it's pretty heavy going. Reading is easy when you just want to read everything until EOF, but if you want to read X bytes but only Y bytes have arrived, or you need to detect EOL or something, things start getting a bit hairy. You have to start buffering up unread bytes and joining buffers together etc.<br><br>But it possibly just requires a bit of practice - I think I was starting to get the hang of it. I'm definitely gonna leave all the current synchronous stream stuff in there for the sake of general sanity though (and databuffer/file IO etc), and it'll be a while before I can have a good crack at this anyway. Should be interesting! <br><br></td></tr></table><br>
<a name="2037452"></a>

<a name="2037451"></a>

<a name="2037459"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome sounds like this is gonna happen :D <br><br>Could you manipulate the data buffer manually within the interface callback?<br><br>Eg<br><pre class=code>Class MyStreamManager implements StreamListener
	Method OnDataAvailable:Buffer(data:Buffer)
		'check for end of line
		if data contains eol
			line = slice up Until EOL
			
			data = slice after EOL
			
			Return data
		Else
			Return data
		EndIf
	End
End</pre><br><br>The default action would be to return nothing which assumes the data has been dealt with. <br><br></td></tr></table><br>
<a name="2037458"></a>

<a name="2037457"></a>

<a name="2037489"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Async do makes code more complex, but it can be still be only slightly so  :)<br><br>Mark can you share how your async implementation looked like? And perhaps an simple non-async example with the read/write problem that becomes complex in async mode? Btw, nice browser! :)<br><br>Here is my example on the same browser using async. I used this mockup class and interfaces and to test and run:<br>[monkeycode]<br>Interface IOnConnect<br>	Method OnConnect:Void()<br>End<br>Interface IOnConnectFail<br>	Method OnConnectFail:Void()<br>End<br>Interface IOnClose<br>	Method OnClose:Void()<br>End<br>Interface IOnReadLine<br>	Method OnReadLine:Void(lineRead:String)<br>End<br>Interface IOnWriteLine<br>	Method OnWriteLine:Void(lineWritten:String)<br>End<br><br>'Mockup Class for Testing purposes<br>Class TCPStream<br>	' Conned Success only on port = 80 <br>	Method Connect:Bool(url:string, port:Int, onConnect:IOnConnect = null, onConnectFail:IOnConnectFail = null)<br>		If port = 80<br>			If onConnect Then onConnect.OnConnect()<br>			Return true<br>		Else<br>			If onConnectFail Then onConnectFail.OnConnectFail()<br>			Return false<br>		End<br>	End<br>	<br>	Method WriteLine:Void(text:String, onWriteLine:IOnWriteLine = null)<br>		If onWriteLine Then onWriteLine.OnWriteLine(text)<br>	End<br>	<br>	Method ReadLine:String(onReadLine:IOnReadLine = null)<br>		testingCounter -= 1<br>		Local mockData:String = "Reading Line " + testingCounter<br>		If onReadLine Then onReadLine.OnReadLine(mockData)<br>		return mockData<br>	End<br>	<br>	Method Eof:Bool()<br>		Return testingCounter &lt;= 0<br>	End<br>	<br>	Method Close:Void(onCloseCallback:IOnClose = null)<br>		If onCloseCallback Then onCloseCallback.OnClose<br>	End<br>	<br>	Private<br>	Field testingCounter:Int = 5 ' Only for testing<br>End<br>[/monkeycode] I wrote the code above only so I could make sure I got the same result running the sync browser above and mine async browser below. <br><br>Example Async:<br>[monkeycode]<br>Function Main()<br>	New WebBrowser<br>End<br><br>Class WebBrowser implements IOnConnect, IOnConnectFail, IOnClose, IOnReadLine', IOnWriteLine<br>	<br>	Field stream:= New TCPStream<br><br>	Method New()<br>		stream.Connect("www.blitzbasic.com", 80, Self, Self)<br>	End<br>	<br>	Method OnConnect:Void()<br>		Print "Connected!"<br>		stream.WriteLine "GET / HTTP/1.0"<br>		stream.WriteLine "Host: www.blitzbasic.com"<br>		stream.WriteLine ""<br>		Local n:= 0<br>		While Not stream.Eof()<br>			Local line:= stream.ReadLine(Self)<br>		Wend<br>		stream.Close(Self)<br>	End<br>	<br>	Method OnReadLine:Void(line:String)<br>		Print line<br>	End<br>	<br>	Method OnConnectFail:Void()<br>		Print "Failed to connect!"<br>	End	<br><br>	Method OnClose:Void()<br>		Print "BYE!!!!"<br>	End	<br>End<br>[/monkeycode]<br><br>I do agree it is more complex, I find it still quite simple, slightly elegant, perhaps easier to test and it is optional. Or maybe I'm missing the truly painful threaded scenario in this simple web browser? <br><br></td></tr></table><br>
<a name="2037488"></a>

<a name="2037487"></a>

<a name="2037484"></a>

<a name="2037483"></a>

<a name="2037482"></a>

<a name="2037481"></a>

<a name="2037480"></a>

<a name="2037479"></a>

<a name="2037542"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Well, it's a start, but it's not really asynchronous. The Connect is, but after that you go into a synchronous while loop.<br><br>Just to clarify what I think what we're trying to do here: asynchronous (aka non-blocking) IO without the use of threads - something html5/flash etc friendly. If you're assuming threads, then it's all much simpler - just do everything synchronously on a thread! Without threads, all potentially blocking Reads/Writes/Connects etc need to return immediately and use an OnComplete handler to signal completion.<br><br>[edit]Note that when I say 'without threading', I mean without threading the Monkey app - some of this stuff will have to be implemented with threads behind the scenes. The Monkey app will continue to behave as if it's single threaded.[/edit]<br><br>Anyway, your example works because your ReadLine/WriteLine are synchronously executing the callbacks. In real network code, ReadLine/WriteLine will return immediately and the callback will happen later - possibly much later.<br><br>This means a gazillion ReadLines inside the while loop may have executed before the next block of data arrives. Even if these are queued up, something will probably have to block at some point. And the While Eof() means that whatever happens inside the loop, it wont exit until the entire page has been read anyway. If something blocks in the process, everything blocks.<br><br>To execute a sequential series of reads without blocking, each read needs to be triggered by the completion of the previous read, so the while loop might end up like...<br><br><pre class=code>
Interface IOnReadPageComplete
	Method OnReadPageComplete:Void( page:String )
End

Class WebBrowser Implements OnReadLineComplete

	'Can block, so we use a completion hander...
	Method ReadPage:Void( url:String,onComplete:IOnReadPageComplete )
		...
	End

	...eventually executes initial ReadLine to kickstart things...

	'Our new while loop!
	Method OnReadLineComplete:Void( line:String )
		If line 'empty line=Eof.
			'Received another line
			_buf.Push line	   		'push line on a StringStack
			_stream.ReadLine Self   'start reading next line.
		Else
			'Eof!
			Local page:=_buf.Join("")
			_onComplete.OnGetPageComplete( page )
		Endif
	End

	...
	
End
</pre><br><br>Note that this is a pretty easy example! HTTP1.1 is more interesting - pages are sent length/data style and the stream stays open, ie: there's no EOF.<br><br>And then there's how to implement ReadLine in the first place. Given an abstract stream class designed to be extended  by native streams, say...<br><br><pre class=code>
Interface IOnReadComplete
	Method OnReadComplete:Void( buf:DataBuffer,offset:Int,count:Int )
End

Class Stream	'Extended by native TCPStream...
	Method Read:Void( buf:DataBuffer,offset:Int,count:Int,onComplete:IOnReadComplete ) Abstract
End
</pre><br><br>...writing a StreamBuffer or something that wraps this and provides ReadInt, WriteInt, ReadLine, WriteLine etc is pretty intense.<br><br>Finally, some interesting reading:<br><br><a href="http://www.2ality.com/2012/06/continuation-passing-style.html" target="_blank">http://www.2ality.com/2012/06/continuation-passing-style.html</a><br><br>It's JS specific, but covers many of the ideas behind converting sync code to async code. <br><br></td></tr></table><br>
<a name="2037533"></a>

<a name="2037532"></a>

<a name="2037610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I made some seriously good progress on this today!<br><br>For starters, I decided to put off the 'automatic' delivery of async completion events for another day - instead, for now you'll have to 'poll' via an Update() method that triggers all the callbacks. This simplified things immensely though.<br><br>Then, with the addition of a quick 'n' nasty *internal use only* thread module and several hours of head-scratching I ended up with this:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'AsyncTCPSocket module

Interface IOnConnectComplete

	Method OnConnectComplete:Void( connected:Bool,socket:AsyncTCPSocket )

End

Interface IOnReadComplete

	Method OnReadComplete:Void( buf:DataBuffer,offset:Int,count:Int,socket:AsyncTCPSocket )

End

Interface IOnWriteComplete

	Method OnWriteComplete:Void( buf:DataBuffer,offset:Int,count:Int,socket:AsyncTCPSocket )

End

Class AsyncTCPSocket

	Method Connect:Void( host:String,port:Int,onComplete:IOnConnectComplete )
	
	Method Read:Void( buf:DataBuffer,offset:Int,count:Int,onComplete:IOnReadComplete )
	
	Method Write:Void( buf:DataBuffer,offset:Int,count:Int,onComplete:IOnWriteComplete )
	
	Method Update:Bool()
	
	Method Close:Void()

End
</textarea><br><br>This provides a very minimal threading wrapper around the native TCPStream, that works without any data copying or buffer allocation etc - ie: all reads/writes come/go directly from/to the buffers you provide. Yes, it's very low level and might not everyone's cup of tea, but it really just represents the core of a system that can be built on.<br><br>You can queue up to 256 connect/read/write ops and they all execute in sequence in the background, notifying you each time the next one completes. It'd be easy to have different threads handling reads/writes too but I don't know if there's any point...?<br><br>The only catch is that you need to call Update() to invoke the callbacks. This theoretically introduces a bit of lag, as data may have arrived between OnUpdates but you wont be notified until the next OnUpdate when you get to call socket.Update.<br><br>But it works amazingly well! Although I've only tested on PC GLFW and Android so far...<br><br>An AsyncStreamBuffer style wrapper that does slicing and dicing of buffers would be useful and I'll probably get around to one eventually, but I really need a clearer idea of what people are planning to do with this stuff first. I don't know if there's much point in async ReadInt, WriteInt methods with this. On the other hand, ReadLine, WriteLine, ReadUntilEOF are probably useful?<br><br>In general, I think all async libs that use async components will need to be async themselves too. But this isn't such a big deal, as the complexity of dealing with the lower level components is handled by the higher level components, and the completion callbacks get simpler as they bubble up.<br><br>For example, here's a new AsyncHTTPGetter...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Interface IOnGetPageComplete

	Method OnGetPageComplete:Void( page:String,getter:AsyncHTTPGetter )

End

Class AsyncHTTPGetter Implements IOnConnectComplete,IOnReadComplete,IOnWriteComplete

	Method GetPage:Void( host:String,port:Int,onComplete:IOnGetPageComplete )
	
	Method Update:Void()
End
[/code]

Yes, it needs an Update() too, but all this does is invoke Update() on a private internal socket.

So httptest now looks like this:

[codebox]
Import mojo
Import asynchttpgetter

Class MyApp Extends App Implements IOnGetPageComplete

	Field sx:Int,sy:Int
	Field mx:Int,my:Int

	Field getter:=New AsyncHTTPGetter

	Field lines:String[]

	Method OnGetPageComplete:Void( page:String,getter:AsyncHTTPGetter )

		Print "GetPage complete!"

		lines=page.Split( "~n" )
	End
	
	Method OnCreate()
	
		getter.GetPage "www.monkeycoder.co.nz",80,Self
		
		SetUpdateRate 60

	End
	
	Method OnUpdate()
	
		getter.Update 'this is what ultimately triggers the OnPageComplete callback
		
		If MouseDown( 0 ) And Not MouseHit( 0 )
			sx+=MouseX-mx
			sy+=MouseY-my
		Endif
		mx=MouseX
		my=MouseY

	End

	Method OnRender()
		Cls
		Translate 0,sy
		DrawText "Hello world",0,0
		For Local i:=0 Until lines.Length
			DrawText lines[i],0,i*12+12
		Next
	End	
End
</textarea><br><br>This works as smooth as a baby's bottom, with no glitches or hiccups unlike the old version!<br><br>Getting rid of the need for Update() will happen eventually, but it's a reasonably complex problem as it interacts with Mojo at quite a low level. For now, I think Update() is an acceptable compromise. In fact, it's quite nice to be able to control exactly when the callbacks happen. <br><br></td></tr></table><br>
<a name="2037611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Xaron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome stuff Mark! Will that be in the next update? <br><br></td></tr></table><br>
<a name="2037614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Getting rid of the need for Update() will happen eventually, but it's a reasonably complex problem as it interacts with Mojo at quite a low level. <br></div><br>Is it possible to put as much of this as possible into the public domain?  It sounds like it's very mojo-specific, which means I can't include it in monkey-ext. :( <br><br></td></tr></table><br>
<a name="2037616"></a>

<a name="2037617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Well, if you're willing to fund my lavish lifestyle, I'd be happy to give the whole thing away!<br><br>It'll be a while before I tackle this anyway. The whole app architecture needs an overhaul to make it easier to create custom targets etc and this'll probably be part of that. But I have no idea what final form it'll all take. <br><br></td></tr></table><br>
<a name="2037619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> This looks stellar! :D<br><br>100% support the "not threading the monkey app" since there is so much sanity to be solved in that.<br><br>Unless writing a high-performance server is async callbacks in read/write really needed? I can't directly imagine a serious use case for read/write Async callbacks, those 1/Framerate milliseconds can matter for the truly hardcore but only on high performance action games that probably won't work over high latency 3G,4G and wireless internet connections that mobile devices have today anyway! :)<br><br>I like the Update approach, it gives you the power and it is easily understood imo. I did not get how or why it should be removed? I think it is a very acceptable solution.<br><br>I assume above is threaded async, and that thread is syncronized with the main thread before OnUpdate in mojo and when I then later on call networkThing.Update() I simply get the messages in main thread, and except for a almost unnoticable latency loss of maybe 10ms everyone is happy? :) <br><br></td></tr></table><br>
<a name="2037618"></a>

<a name="2037623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> For use cases in a mobile game.<br><br>Http can be used to save and load data from a server - settings,analytics,ad services, and more. TCP I intend to use for sending gameplay information about the game state. Depending on game, but 10 times per second is reasonable with a TCP packet size below 500bytes.<br><br>For debugging networking it is nice to be able to get (maybe from the tcpStream) local IP,Port and Remote IP,Port. Also Monkey should where possible set nagle = false (TCP NODELAY), I think most realtime apps wants that?<br><br>Server side of things:<br>Maybe I should ask if an Accept() is planned as well in the future? I have found that having the server and client in the same language can be very practical, tough not needed. <br><br></td></tr></table><br>
<a name="2037621"></a>

<a name="2037622"></a>

<a name="2037629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; Unless writing a high-performance server is async callbacks in read/write really needed? <br><br>Depends what sort of quality you're after. Reading even a single byte will cause blocking if there's a network glitch, resulting in freezing/choppy gameplay. This may or may not be a problem depending on the quality of the network/server. I doubt any AAA games do any network IO synchronously though.<br><br>I'm also a bit worried about keeping things sweet for the app store too - the ios developer docs stress that you should either use UINetwork (or whatever it's called), or BSD sockets on a separate thread. I couldn't find anything in the official guidelines about networking, but I wouldn't be surprised if the testing process involves hammering the network with a bit of noise!<br><br>Also, if we want WebSockets, we don't have a choice - everything will have to be asynchronous there.<br><br>The queuing system means you basically don't have to worry about writes, so it's only reads that get a bit tricky, which makes sense since this is all about a different way of returning data.<br><br>Here's the callbacks of the httpgetter:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	Method OnConnectComplete:Void( connected:Bool,socket:AsyncTCPSocket )
		If Not connected
			_onComplete.OnGetPageComplete "",Self 'error...
			_socket.Close
			_socket=Null
			Return
		Endif
		WriteString "GET / HTTP/1.0~r~n"
		WriteString "Host: "+_host+"~r~n"
		WriteString "~r~n"
		_socket.Read _buf,0,_buf.Length,Self 'start initial read
	End

	Method OnReadComplete:Void( buf:DataBuffer,offset:Int,count:Int,socket:AsyncTCPSocket )
		If count
			_chars.Push buf.PeekBytes( 0,count )
			_socket.Read _buf,0,_buf.Length,Self  'read more
		Else
			'EOF!
			Local page:=String.FromChars( _chars.ToArray() )
			_onComplete.OnGetPageComplete page,Self
			_socket.Close
			_socket=Null
		Endif
	End
	
	Method OnWriteComplete:Void( buf:DataBuffer,offset:Int,count:Int,socket:AsyncTCPSocket )
	End
</textarea><br><br>Not too heavy?<br><br>Basically, the read bit is just doing a ReadAll. This is something that could be placed in a wrapper class (along with IOnReadAllComplete) as could  a bunch of no hassle Write methods that could have optional callbacks.<br><br>I'm sure there are more 'higher level' read ops that could reused like this - eg: HTTP1.1 chunked transfers - but I don't really know much about tcp usage beyond http and, despite asking around, no one's given me anything else to go on!<br><br>If what you're after is just plain a synchronous TCPStream, but with an async connect, this is doable. In fact, this is where I started out this morning! It works but, on my PC anyway, although the connect was instant, there was a noticeable hiccup before any data arrived. Things are probably sweet after that, but async version is 100% delay free.<br><br>&gt; I assume above is threaded async, and that thread is syncronized with the main thread before OnUpdate in mojo<br><br>It's threaded, but it runs 'freely' - ie: there's no syncing, it's all done with a FIFO queue and 3 cursors. Basically, the Connect/Read/Write methods are adding AsyncOp objects to the queue, which is being greedily plowed through by the thread. Update simply catches up with the thread, dispatching OnComplete's as it goes. It's actually the coolest code I've written in a while! <br><br></td></tr></table><br>
<a name="2037624"></a>

<a name="2037625"></a>

<a name="2037626"></a>

<a name="2037627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; TCP I intend to use for sending gameplay information about the game state. Depending on game, but 10 times per second is reasonable with a TCP packet size below 500bytes.<br><br>What format is this data in (roughly)?<br><br>Here's a thought - would a JSON reader help?<br><br>In fact, with reflection it should be possible to do an async object loader! <br><br></td></tr></table><br>
<a name="2037632"></a>

<a name="2037633"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; It's actually the coolest code I've written in a while! <br><br>It actually sounds awesome as well!<br><br>&gt; In fact, with reflection it should be possible to do an async object loader! <br>Wow! Yeah serialization is probably where "most time is spent" in networking. So that is a really good idea.<br><br>&gt; What format is this data in (roughly)?<br>Json is very readable, and it would certainly work, but I'd lean more towards going binary in this case.<br><br>When bandwidth is of importance and I would say most web or mobile games qualify then I tend to go with reading &amp; writing bytes/shorts/ints/strings directly to the stream using a simple packet protocol.<br><br>I was thinking in order:<br>1. 2bytes = short, size of packet<br>2. 1byte, packet type - my code knows if it is a new game event, a position update, a onFire event, and so on. <br>3. data - We know how to read this because of type in step 2<br><br>I naivly assume here all packets broadcast to all players - since that is enough for my current project. For games with more than 8 players in a game one might want the server to have logic for only sending to relevant receivers.<br><br>UDP already comes with Size included so there I would simply lose the first 2 bytes. And In UDP I might even "gather up" multiple packages sent the same frame in one and use a PacketType for that. In TCP I'd just push everything onto the stream.<br><br>This can easily be built upon the TCPStream, TCPSocket and also work with future UDP support, also easy to implement on a target like NodeJS. <br><br>However I think the question of using JSON for game data is a good one, for smaller games it certainly should work fine, and it might very well work in my current project! If it can be used interchangeably with a binary format (for example if using Interfaces again) it would probably help a lot in debugging. <br><br></td></tr></table><br>
<a name="2037630"></a>

<a name="2037631"></a>

<a name="2037634"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Note: When I talk about bandwidth it is the server I'm concerned about, not the client! <br><br></td></tr></table><br>
<a name="2037636"></a>

<a name="2037637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Actually, for game state blobs I think the best approach is probably just to use a ReadBlock/IOnReadBlockComplete (that reads an int, followed by that many bytes) and just read/write the whole game state in one hit.<br><br>You can then go through it with a DataStream synchronously.<br><br>This means your code for serializing gamestate/actors can remain pretty much the same, eg: <br><br><pre class=code>
Class Actor
   Method Read:Void( stream:Stream )
      stream.Read x,y,state etc
   End

   Method Write:Void( stream:Stream )
      stream.Write x,y,state etc
   End
End
</pre><br><br>In fact, I think 2 new async methods solves pretty much everything, eg:<br><br><pre class=code>
Interface IOnReadAllComplete
   Method OnReadAllComplete:Void( buffer:DataBuffer,offset:Int,count:Int... )
End

Interface IOnReadBlockComplete
   Method OnReadBlockComplete:Void( buffer:DataBuffer,offset:Int,count:Int... )
End

'new methods in AsyncStream

   'read until EOF
   Method ReadAll:Void( buffer:DataBuffer,offset:Int,onComplete:IOnRealAllComplete ) 

   'read length/databuffer
   Method ReadBlock:Void( buffer:DataBuffer,offset:Int,onComplete:IOnReadBlockComplete )

</pre><br><br>(think I prefer ReadChunk...)<br><br>Even with JSON, it's probably easier/cleaner/faster to do this, as long as the data isn't too huge.<br><br>As a bonus, the whole think can be compressed in one hit.<br><br>Or is that too easy...? <br><br></td></tr></table><br>
<a name="2037635"></a>

<a name="2037644"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> With TCP I do not know if the entire packet has been received. So I do not want to start reading a packet until awail tells me I have the number of bytes I seek.<br><br>[This applies even to an Async TCP game server in C#]<br>1. Start Read 2 Bytes (not blocking)<br>2. (later on in callback) On 2 Bytes Read --&gt; From stream I read a short, these 2 bytes are my virtual packet's size<br>3. In same callback I Start a Read of "Size" bytes.<br>4. (later on in callback) On "Size" bytes read --&gt; I parse the data using stream commands<br><br>So when I do a Read I can't do a ReadAll (not for continuous gameplay traffic), I need a Read that specifiyBytes, or I can poll Awail.<br><br>And with Actors, I need to have them ordered on all clients or use an ID to know which actor an update relates to, before I read that specific package if I'm not missing something obvious :)<br><br>This should work without Reflection:<br>[ monkeycode ] <br>[monkeycode]Interface UnitData<br>   Method ID:Int() Property<br>   Method X:Float() Property<br>   Method X:Float() Property<br>   Method Direction:Float() Property<br>End<br><br>' Unit implements UnitData<br>For Local unit:Unit = Eachin UnitList<br>   Send( unit)<br>Next[/monkeycode][ /monkeycode ] <br><br>Using reflection I might send all variables that does not start with _ or something.<br><br>[monkeycode]Class LocalUnit<br>   Field EntityID:Int<br>   Field X#, Y#<br>   Field _test:Int<br>   Field Important:String = "Abc"<br>   Field _localThing:String = "test"<br>End<br>Class RemoteUnit<br>   Field EntityID:Int<br>   Field X#, Y#<br>   Field Important:String = "Abc"<br>End[/monkeycode]<br><br>In Update I'd check all my local units (or units I can control) for any values being changed since last frame, I then send them into the stream starting with the EntityID.<br><br>OnReceive at the other client I packincoming up and using reflection I find the RemoteUnit with this EntityID and populate the data, or create if it does note exist.<br><br>That would be a simple approach, but with dead-reconing and area of interest management I'm not sure it would be that simple. Location based objects needs to be handled differently from raw data like chat. Also the most important thing would likley be delayed events.<br><br>The benefit of reflection is that for each NEW packet I only need to create  an interface, or I only need to add that variable.<br><br>Ex:<br>Player1 clicks button.<br>Player1 sees a button loading animation, button is not activated yet<br>Player2 then gets a message Player1 pressed button, and a timestamp<br>Player2 calucated when this event should happen, and once that frame comes Player2 simulates a buttonPress event<br>Player1 assumes Player2 got the message and after a pre-determined time the button activates for Player1<br>And unless Player2 disconnected, player2 sees the button activated at the the same time<br><br>That is a very common scenario. With a framework around doing above should be quite simple for the end user. <br><br></td></tr></table><br>
<a name="2037643"></a>

<a name="2037642"></a>

<a name="2037641"></a>

<a name="2037640"></a>

<a name="2037639"></a>

<a name="2037650"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; With TCP I do not know if the entire packet has been received. So I do not want to start reading a packet until awail tells me I have the number of bytes I seek.<br><br>You never start reading a packet though - the thread does.<br><br>Currently, the thread just does a single 'read' and then notifies you - and yes, currently it could return less than you asked for.<br><br>But it could just as easily do a full read - eg: if you ask for 16 bytes, it loops until 16 bytes are read. It doesn't matter if it blocks 'coz it's on the thread. This is probably the preferred behaviour.<br><br>Also, you'd never have to even read the length header - the ReadChunk method will do this for you internally - ie: it will handle the callback that contains the length. ReadAll is only for situations like HTTP1.0 where the connection is closed to signify 'end of data'. But in a game we want the connection open all the time so we use ReadChunk instead.<br><br>So the main game recv 'loop' might look like this:<br><br><pre class=code>
Method OnReadChunkComplete:Void( data:DataBuffer,offset,length )
   'OK, data contains an entire message from the server!
   ProcessServerMessage data,length
   'Start receiving next message
   stream.ReadChunk data,0   'OK, next message please!
End

Method ProcessServerMessage( data:DataBuffer,length )
   If data.PeekInt(0)=GAMESTATE_UPDATE
      ...apply gamestate changes...
   ElseIf data.PeekInt(0)=PLAYER_CHAT
      ...etc...
   Endif
End
</pre><br><br>It just needs to be kicked off in OnCreate (or somewhere) with an initial ReadChunk - ie: you don't wait for data and then read it, you start reading before it arrives. After that, server messages keep getting sent to the callback because it keeps asking for them.<br><br>This is pretty much the async equivalent of<br><br><pre class=code>
Repeat
  Local data:=ReadServerMessage()
  ProcessServerMessage data
Forever
</pre><br><br>Sending data is easier - you just wack an entire message into a DataBuffer and use SendChunk, which handles doing the WriteInt(length)/Write(data) for you so the server can read it with ReadChunk.<br><br>And...now I see why there needs to be separate read/write threads...! Otherwise, if the recv thread is waiting for data, it'll hold up any send data.<br><br>&gt; Using reflection I might send all variables that does not start with _ or something.<br><br>IMO, you'd want to send them to a DataStream though, not the socket. Only once you've got an *entire* client message together would you send it with a single WriteChunk.<br><br>I guess there is the issue of extra lag introduced by only sending stuff once after you've packaged it up, in which case you'd have to break things down into smaller chunks and things would get a bit state-machiney. But in a lot of cases just one mega message would work fine I think. <br><br></td></tr></table><br>
<a name="2037649"></a>

<a name="2037647"></a>

<a name="2037646"></a>

<a name="2037645"></a>

<a name="2037654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> This sounds good to me: a nice simple model that everyone can understand. <br><br></td></tr></table><br>
<a name="2037658"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah ok Read/Write Chunk sounds exactly what I was after :)<br><br>What exactly does WriteChunk/ReadChunk do? <br><br>If I want to talk to my NodeJS game server then how do I handle the packets on that side? Or will Chunks only work if the server is in Monkey as well? (only need Accept or similar for that).<br><br>&gt; if you ask for 16 bytes, it loops until 16 bytes are read. This is probably the preferred behaviour.<br><br>It seems either way would work pretty well since it seems I don't have to do a copy on the bytes after the read - I can just leave them in the stream and read them later? I would expect if specifying a size it loops until size recv, else I get OnReadComplete every frame there is at least 1 byte in the buffer? <br><br>There are three Scenarios.<br><br>If I expect 100 bytes and buffer has 100 bytes, np.<br><br>If I expect 100 bytes and buffer has 99 bytes, wait til next update.<br><br>If buffer has 101 bytes when I want to read 100 bytes? Can I just "leave" the 1byte alone in the stream and they will automatically be part of the next OnReadComplete? Or do I need to save them so I can process them when the remaining 99bytes of the second package arrives? <br><br>If my buffer has 100 bytes and I want to read 10 bytes 10 times in a row? Does OnReadComplete return immediately so I can handle "as much as possible" that update then?<br><br>If my buffer has 101 bytes and I want to read 10 bytes 10 times in a row and save 1 byte for next update? <br><br><b>DataStream</b> &lt;-- I think the data stream will make it very simple to handle data, but if I want my game server to run in non monkey, like nodeJS, php, plain C#? Since monkey translates easily, maybe it would be trivial to generate code for this? <br><br></td></tr></table><br>
<a name="2037659"></a>

<a name="2037660"></a>

<a name="2037662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> And about JSON. Here is a nice video html5 multiplayer: <a href="http://www.youtube.com/watch?v=zj1qTrpuXJ8" target="_blank">http://www.youtube.com/watch?v=zj1qTrpuXJ8</a><br><br>If a game JSON Packet looks like this (Assumed FPS Action Game) and we are sending one Actor.<br><pre class=code>
{
     z: 1,
     id: 1234590,
     s: {
       x: 5,
       y: 34,
       v: 3,
       a: 0.46
     } 
}
</pre><br>The size would be: 1 + 4 + 12 + 3 + 4 + 5 + 4 + 5 + 2 =~ 40bytes<br>Extra Actors would mean: ~20 bytes<br><br>In Binary assuming ints and floats are 4 bytes: 4*6 = 24bytes<br>Extra Actors would mean 4*4 = 12 Bytes<br><br>A lot of games would work with Json, but it scales less nicely, so both options are useful. <br><br></td></tr></table><br>
<a name="2037665"></a>

<a name="2037667"></a>

<a name="2037668"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just read all of your conversations and there is not really much I could add but the implementation is sounding really nice! I would say that having json functions as part of monkey is a must! It is a widely used standard and it makes dealing with sending objects very simple across the different targets. The amount of overhead for sending basic game packets is minimal and if there is a gzip option in there then no worries!<br><br>A possible request which could be worked in, is there some way we can feed in an encryption worker object or just have some encryption methods built in so packets can automatically be encrypted before sent. Perhaps the same could apply for compression, set compression on and then all "packets" are compressed.<br><br>I assume UDP will be an option for the platforms that support it?<br><br>All very exciting to see monkey growing up, keep up the good work! <br><br></td></tr></table><br>
<a name="2037680"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> While on topic wanted to share this for html5/flash support. Maybe using <a href="http://socket.io/" target="_blank">http://socket.io/</a> would be useful? If not only for browser support but for <b>heartbeats, timeouts and disconnection</b>. <br><br><div class="quote"> <br><b>Why not just call it `WebSocket` if the actual WebSocket is not present and mimick its API?</b><br>Socket.IO does more than WebSocket, even if WebSocket is selected as the transport and the user is browsing your website with an ultra modern browser. Certain features like <b>heartbeats, timeouts and disconnection support</b> are vital to  <b>realtime applications</b>  but are not provided by the WebSocket API out of the box.<br><br>This is akin to jQuery's decision of creating a feature-rich and simple $.ajax API as opposed to normalizing XMLHttpRequest.<br> <br></div><br><br>EDIT - Never mind, this is for NodeJS servers only. However heartbeats, timeouts and disconnects are always nice :) <br><br></td></tr></table><br>
<a name="2037679"></a>

<a name="2037682"></a>

<a name="2037683"></a>

<a name="2037684"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >vbnz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have wrote html5 and flash native sockets!(tcp)<br>Also io operations (html5).<br>Mark,i can send you source code if you wish!<br>If yes,please give me your email.<br><br>Sincerely, vbnz. <br><br></td></tr></table><br>
<a name="2037686"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>&gt; What exactly does WriteChunk/ReadChunk do? <br><br>They read/write a length value, then read/write that much data. The reading/writing is done on a thread, so it doesn't block the main app. Once length/data have been read/written, OnComplete is called. Whether length is represented as a byte, short or int is an issue. This could be specified in a flag when you call ReadChunk/WriteChunk, or there could be multiple versions of ReadChunk/WriteChunk. It'll probably be in flag though - I suspect there'll be quite a few flags!<br><br>It's not doing anything magical though - just prefixing blocks with a length value. You could do it yourself in client code state-machine style, it's just nice to have this built-in to AsyncStreams, which can do this sort of thing easily.<br><br>&gt; If I want to talk to my NodeJS game server then how do I handle the packets on that side?<br><br>Just read the length byte/short/int then read the actual data. Just like 'normal' code!<br><br>Perhaps the best way of thinking about how AsyncStreams should work is to  think of all the possible ways you can read blocks of data. I can think of:<br><br>* Fixed size blocks - ie: read N bytes. This is what Read/Write currently do.<br><br>* Chunked blocks - ie: read N, then read N bytes of data.<br><br>* Terminated blocks - ie: read data until the value X has been read. Useful for ReadLine (X=10), ReadCString (X=0) etc.<br><br>...any more?<br><br>If these are all built-into AsyncStream via Read(), ReadChunk(), ReadUntil() methods it should make life easier for everyone. Note that these will all have OnComplete handlers.<br><br>Also, async ReadAll is probably not gonna happen - there's no way to make it safe  since there's no guarantee the read data will fit into the databuffer you provide. It could return how much data was read before the buffer filled up, but then it'd be doing effectively the same thing as Read()!<br><br>As for JSON/compression etc, yes this stuff is important, but I don't think JSON/compression modules need to (or should) know anything about AsyncStreams - they can continue to work with plain sync streams and databuffers.<br><br>You can still send/recv JSON objects asynchronously easily though. For example, if you've got a JSON module with functions like, say:<br><br>'Note: these use plain sync streams!<br>Function ReadObjectFromStream:JSONObject( stream:Stream )<br>Function WriteObjectToStream:Void( obj:JSONObject,stream:Stream )<br><br>You can then 'send' a JSONObject async using code like:<br><br><pre class=code>
Function SendJSONObject:Void( obj:JSONObject,stream:AsyncStream )
   Local data:=New DataBuffer( MAX_JSON_SIZE )
   Local dstream:=New DataStream( data )
   WriteObjectToStream( obj,dstream )
   Local length:=dstream.Position
   'possibly compress databuffer here...
   stream.WriteChunk data,length
End
</pre><br><br>And to receive a JSON object...<br><br><pre class=code>
Method OnReadChunkComplete:Void( data:DataBuffer,offset:int,length:int,stream:AsyncStream )
   'possibly decompress databuffer here...
   Local dstream:=new DataStream( data,0,length )
   Local obj:=ReadObjectFromStream( dstream )
   stream.ReadChunk data,data.Length   'kick off the next read...
   '
   'OK, an object has arrived! Do something with it...
   '
End
</pre><br><br>Decompression would go right at the top.<br><br>Hmmm...the SendObject raises an interesting point - Write functions will have to be careful not to overwrite the databuffer used by a previous write that may still be queued...will think about this.<br><br>But sending individual objects is probably not the way to go - you want to send entire messages that may contain many objects, extra control data, message type etc. I guess what I'm trying to say here is that you should probably do 99.9% of your network reading/writing using a synchronous DataStream, and then once you have an entire message ready to send to the client/server/peer, you use ReadChunk/WriteChunk to transfer the underlying DataBuffer. This way, 99.9 of your code can use synchronous streams and not have to worry about callbacks.<br><br>&gt; Mark,i can send you source code if you wish!<br><br>Yes please! email is in my profile... <br><br></td></tr></table><br>
<a name="2037724"></a>

<a name="2037725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dopeyrulz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark,<br>One of the nice things in .net now is the standardized identification of async methods and functions.  If you planning to offer both synchronous and asynchronous methods appending Async to the name might offer a very clear and easy way to differentiate. <br><br></td></tr></table><br>
<a name="2037687"></a>

<a name="2037689"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> I really like the concept of AsyncStreams and how the networking part is turning out! That can't be said too many times :)<br><br>&gt; you should probably do 99.9% of your network reading/writing using a synchronous DataStream<br>Yeah I agree, any other form of abstraction is better to happen at a higher level.<br><br>&gt; ...any more?<br><br>Variable Sized blocks. That would mean we read until the first/last bit of a byte is 1. So and int of value 0 to 127 would take 1 byte, 127 to  16383 would take 2 bytes, 16384 to 2097152 would take up 3 bytes and so on. <br><br>Not saying they are needed, just saying they exist and can be quite handy since "numbers" can just be pushed onto the stream and are automatically optimized. However the bitlogic req to implementing them is the downside.<br><br>Might also be a efficient way to send unicode strings?<br><br>&gt; flags<br><br>I also think flags will do very well for that :) <br><br></td></tr></table><br>
<a name="2037688"></a>

<a name="2037717"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >vbnz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark,I sent you a email! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
