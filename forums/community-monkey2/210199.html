<!DOCTYPE html><html lang="en" ><head ><title >Pyramid of Doom ?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Pyramid of Doom ?</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=530" >Monkey2 Talk</a>/<a href="#bottom" >Pyramid of Doom ?</a><br><br>
<a name="2112911"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's the word for doing this:<br><br><pre class=code>
step1(function (value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(value4) {
                // Do something with value4 
            });
        });
    });
});
</pre><br><br>But can do this using nodejs<br><br><pre class=code>
Q.fcall(promisedStep1)
.then(promisedStep2)
.then(promisedStep3)
.then(promisedStep4)
.then(function (value4) {
    // Do something with value4 
})
.catch(function (error) {
    // Handle any error from all above steps 
})
.done();
</pre><br><br><a href="https://www.npmjs.com/package/q" target="_blank">https://www.npmjs.com/package/q</a><br><br>Will this be possible in MX2 ? <br><br></td></tr></table><br>
<a name="2112912"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >muddy_shoes</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Will which bit be possible in MX2? You can already create chained calls if you want. The primary language feature in your example that isn't in Monkey isn't the way the "pyramid" has been collapsed, it's the passing of functions and inline anonymous declaration of them. <br><br></td></tr></table><br>
<a name="2112913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; create chained calls<br>Ow din't know that ;) <br><br></td></tr></table><br>
<a name="2112925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, so you were talking about the style. I thought you were talking about coroutines and await/async. <i>This is a lot less fun. Grumble, grumble.</i> <br><br></td></tr></table><br>
<a name="2112926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> i can ask now if you want ;) does mx2 have async ? <br><br></td></tr></table><br>
<a name="2112958"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Await, async, yield would be awesome but I get the feeling that those are a long way off and instead we'll get some basic threading library for the release version. Calling it now! <br><br></td></tr></table><br>
<a name="2112994"></a>

<a name="2112995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah...nah...to be honest, I don't know enough about await, async etc (or the alternatives) to be able to make a call at this point.<br><br>I do know that they felt throughly stupid when I had to use them in Winrt. eg: plenty of examples replaced this (not exactly this, but something like it...)...<br><br>LoadImage<br>LoadShader<br>CompileShader<br>CreateVertexBuffer<br>CreateRenderState<br><br>...with something  like...<br><br>LoadImage.Then( <br>LoadShader.Then(<br>CompileShader.Then(<br>CreateVertexBuffer.Then(<br>CreateRenderState.Then(<br>someFlag=true;<br>)))));<br><br>...can't remember exactly how it worked, but it seemed pretty bizarre at the time. The rules for handling exceptions were also very confusing.<br><br>I guess it was to make it impossible to block the GUI thread, but it seemed pretty extreme compared with something like:<br><br>CreateThread( Lambda()<br>  LoadImage<br>  LoadShader<br>  CompileShader<br>  CreateVertexBuffer<br>  CreateRenderState<br>  someFlag=True<br>End )<br><br>...assuming you really even needed to in the first place. Some of the stuff that was async in WinRT didn't really seem like it had to be.<br><br>Perhaps JS has to do it this way because there are no threads? Perhaps it's just a better way to do it? Perhaps there are better ways to do it? Like I say, I'm not really experienced enough here to make a sensible call, so for now async/await etc are on the 'weird, interesting ideas' list. <br><br>And as has been mentioned, I think you can do the pyramid thing already, eg:<br><br><pre class=code>
Step1( Lambda( result1:Result )
  Step2( result1:Result,Lambda( result2:Result )
    Step3( result2:Result,Lambda( result3:Result )
      Step4( result3:Result,Lambda( result4:Result )
        someFlag=True
      End )
    End )
  End )
End )
</pre><br><br>Not all that pretty - and untested! - but again, I just don't know how useful this is in practice. For starters, if the point of the exercise is to prevent the GUI thread blocking, then Step1, Step2, etc will still need to be able to launch a thread to do their work asynchronously (or I guess they could do work 'in chunks' on an idle signal). And if we've got threads, the whole thing can be collapsed into a simple statement sequence running on a separate thread. <br><br></td></tr></table><br>
<a name="2113015"></a>

<a name="2113016"></a>

<a name="2113017"></a>

<a name="2113018"></a>

<a name="2113019"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's easier ways.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">function f ( x )
	if not step1( x ) then return
	if not step2( x ) then return
	if not step3( x ) then return
	if not step4( x ) then return
	step5 x
end</textarea><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">for local x:int = 0 until 32
	if not step1( x ) then continue
	if not step2( x ) then continue
	if not step3( x ) then continue
	if not step4( x ) then continue
	step5 x
end
</textarea><br><br>Fun fact, I once worked with an "engine" for a hugely popular game and it had "if" statements 8 or 9 layers deep. <br><br></td></tr></table><br>
<a name="2113021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; There's easier ways.<br><br>But the point of the 'then' or lambda approaches is to allow the code to run asynchronously - similar to running your code on a thread. Which does indeed seem more intuitive to me, but that's probably largely to do with my background. <br><br></td></tr></table><br>
<a name="2113022"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uhhhh I see, never mind. <br><br></td></tr></table><br>
<a name="2113031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are 3 things now in this topic ;)<br><br><br>1. then()<br>Modern browsers already support ECMAScript 6 specification of Promises.<br><a href="https://github.com/promises-aplus/promises-spec" target="_blank">https://github.com/promises-aplus/promises-spec</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a><br><br>for javascript its a cool thing because your don't have to write many code.<br><br><br><pre class=code>
example code (maybe not the best one)

function getRow(id) {
    return Q.nfcall(db.query,    'SELECT * FROM table WHERE lookUp = ?', id);
}

function insertItem(request, response) {
    var data = JSON.parse(request.body.data);

    security.verifyToken(data.lookUp).then(function(/* no lookupError */) {
        return getRow(data.lookUp); // potentially catch SQL errors here
    }).then(function(row) {
        return helper.insertFeedItem(row[0].id, data.message);
        // What was the `res` it had returned before?
    }).catch(function(someError) { // lookUpError, companyError, insertError
        return { "response": "error", "msg": someError };
    }).done(function(result) {
        response.json(result);
        response.end();
    });
}
</pre><br><br>2. async<br>That weird thing, without that I had many angry clients for some C# projects.<br>Its weird because I don't really know if its a separate thread or a special weird thing :)<br><br>Thing is that you need them to not block your GUI and get those frozen screens.<br>Good information about this: <a href="https://msdn.microsoft.com/en-us/library/hh191443.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/hh191443.aspx</a><br><br>Do we need them in MX2 ???<br>Yes and no, I don't know if MX2 will get threads, or other non blocking things.<br>For example to download stuff in the background, while you push a GUI button [download now], and you don't have to wait for it.<br><br><br>3. chaining<br>-&gt; solved <br><br></td></tr></table><br>
<a name="2113028"></a>

<a name="2113059"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Lua has the concept of coroutines, which are like lightweight threads, but they actually run cooperatively with-in the same thread.  I've used them in the past for mission scripting.  Just found a Lua based system very similar to what I used before.<br><br>The advantage compared to threads is no threading issues like locks, threading race conditions, etc. Or UI/graphics actions that can only be executed in the main thread aren't an issue.<br><br>The disadvantage compared to threads is that a big long function call or loop will block your main thread. And non-trivial to implement in a C++ based system.<br><br><a href="https://github.com/davisdude/Timer" target="_blank">https://github.com/davisdude/Timer</a><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">local timer = require 'timer'

function love.load()
    a = timer.new( function()
        wait( 1 )
        print( 'a' )
        wait( 1 )
        print( 'b' )
        wait( 1 )
        print( 'c' )
        wait( 1 )
        signal( 'B' )
        waitSignal( 'e!!' )
        print( 'e' )
        wait( 1 )
        signal( 'fin' )
        io.write( 'ta' )
    end )
    b = timer.new( function()
        waitSignal( 'B' )
        print( 'd' )
        wait( 1 )
        signal( 'e!!' )
        waitSignal( 'fin' )
        io.write( '-da!' )
    end )
end

function love.update( dt )
    a:update( dt )
    b:update( dt )
end

function love.keypressed( key )
    if key == 'escape' then 
        love.event.quit()
    end
end</textarea> <br><br></td></tr></table><br>
<a name="2113070"></a>

<a name="2113072"></a>

<a name="2113073"></a>

<a name="2113074"></a>

<a name="2113075"></a>

<a name="2113076"></a>

<a name="2113077"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> right, coroutines are not threads... They've been asked for and I remember a short post from Mark showing a working example.   <br><br>Async and await look similar to a coroutines though...  I think they are basically there just to to simplify the syntax for callbacks.  Mark's CreateThread example doesn't accomplish this.   so let's see, async sets up the process. Await spawns a thread and yields back to the main thread(or previous calling thread).  Then once the spawned thread completes the remainder of the async function is executed....  but it's executed in the main thread and in the main threads context/scope.... so that's actually pretty nice and clean.  <br><br>So, one way to fix this without async and await (or polling your thread) would be to add a callback function argument to CreateThread...?<br><pre class=code>CreateThread(
	Lambda()
		LoadImage()
		LoadShader()
		CompileShader()
		CreateVertexBuffer()
		CreateRenderState()
	End,
	Lambda()
		someObject.SetValue(true)
		DoSomethingAfter()
	End,
)
</pre> I think await would look better.<br><pre class=code>MyFunction() Async
	blah.blah

	Await( Lambda()
		LoadImage()
		LoadShader()
		CompileShader()
		CreateVertexBuffer()
		CreateRenderState()
	End)
	
	someObject.SetValue(true)
	DoSomethingAfter()

End</pre><br>what I'd like to see is good builtin messaging between threads and stuff like <br>Parallel.For  :) <br><br></td></tr></table><br>
<a name="2113064"></a>

<a name="2113065"></a>

<a name="2113066"></a>

<a name="2113067"></a>

<a name="2113068"></a>

<a name="2113069"></a>

<a name="2113078"></a>

<a name="2113079"></a>

<a name="2113080"></a>

<a name="2113081"></a>

<a name="2113082"></a>

<a name="2113083"></a>

<a name="2113084"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> or<br><pre class=code>blah.blah
CreateThread( Lambda()
	LoadImage()
	LoadShader()
	CompileShader()
	CreateVertexBuffer()
	CreateRenderState()
	End
).Callback( Lambda()
	someObject.SetValue(true)
	DoSomethingAfter()
	End
)</pre><br><br><strike>change .Callback to .CallbackAdd and you have your 'then's</strike>  ( async/await still looks cleaner though ) <br><br></td></tr></table><br>
<a name="2113213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I vote for dmaz await,async code.<br>Mark you realy need to check those things, because people are going to compare your mx2 with other languages.<br>The new python has it now, nodejs, c# its a new trendy thing :)<br><br>It gives more power then not freezing the gui, but to do some othter background stuff to, like special effects in the background.<br>But then again, its almost or the same as threads... <br><br></td></tr></table><br>
<a name="2113270"></a>

<a name="2113271"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome read about asynchronous experiences from Microsoft's (now ended) internal Midori project...<br><a href="http://joeduffyblog.com/2015/11/19/asynchronous-everything/" target="_blank">http://joeduffyblog.com/2015/11/19/asynchronous-everything/</a><br>Some of links are really good too. <br><br></td></tr></table><br>
<a name="2113285"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> After that link and thinking about this a little more... IMO, Async / Await is the way to go... fast and powerful if built around a scheduler built on structs of course.  then we could do stuff like <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">For Local sm:= Eachin list
	Lambda () Async
		Await( Lambda()
			sm.CalculateState()
			sm.ProcessState()
		End)
		
		sm.DrawState()
	End
End</textarea>  This would be so AWESOME! <br><br></td></tr></table><br>
<a name="2113284"></a>

<a name="2113283"></a>

<a name="2113286"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Awesome read about asynchronous experiences from Microsoft's (now ended) internal Midori project...<br><br>Good find!<br><br>Looking back on my WinRT experience, I think the major problem I had was that I was working primarily in c++, which doesn't yet have async/await, only that crappy '.then{ .then{ .then{ .then{  } } } }' stuff. With await, it all starts to look a lot saner:<br><br>...await LoadImage()<br>...await LoadShader()<br>...await CompileShader()<br>...await CreateVertexBuffer()<br>...await CreateRenderState()<br><br>Part of the problem for me though is that I'm the guy who has to write async versions of LoadImage, LoadShader etc which, given they're built on top of synchronous C code (eg: fread, glCompileShader etc), means lower level threads are unavoidable if the goal is to avoid blocking the UI. And if there are threads, it's tempting to just leave it up to users to wrap sequences of slow ops in a thread!<br><br>Async ops are coroutines though, not full-on threads, but still, the easiest way to implement them in c++ is probably on top of threads.<br><br>MS have in fact implement async/await in c++ using 'fibers' which is a form of lightweight thread:<br><br><a href="https://paoloseverini.wordpress.com/2014/04/22/async-await-in-c/" target="_blank">https://paoloseverini.wordpress.com/2014/04/22/async-await-in-c/</a><br><br>I think this is probably the general approach monkey2 should take if it's to attempt async/await, ie: start with something like plain threads and 'Future&lt;T&gt;' and expand it later to support async/await. <br><br></td></tr></table><br>
<a name="2113294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> sure, but I think the goal shouldn't be just to avoid blocking... I'd like to have quick easy syntax to launch and manage threads at the language level not just through a framework.  so we can do stuff in parallel and take advantage of multiple cores<br><br>that's the first I heard of fibers.  They sound like a solid way to implement async/await for monkey2... I don't think we would really require a preemptive solution so yeah, can't wait!  :)<br><br>[edit] reworded and corrected some typos <br><br></td></tr></table><br>
<a name="2113292"></a>

<a name="2113291"></a>

<a name="2115466"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pharmhaus</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Groovy and C# both have the <a href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator" target="_blank">?. Operator</a>.<br>which is basically a short hand for a null check.<br>It is not async but prevents nesting Ifs when not necessary.<br><pre class=code>
MyInstance?.MyMethod()
</pre><br>Which would be the aquivalent of<br><pre class=code>
If MyInstance Then
    MyInstance.MyMethod()
Endif
</pre><br>It is also chainable like so<br><pre class=code>
MyInstance?.MyProperty?.MyMethod()
</pre><br>It returns the default value for the result type when a return value is expected and the instance is null. <br><br></td></tr></table><br>
<a name="2115464"></a>

<a name="2115465"></a>

<a name="2115467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DruggedBunny</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's pretty cool, actually. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
