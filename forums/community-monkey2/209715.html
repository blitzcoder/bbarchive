<!DOCTYPE html><html lang="en" ><head ><title >Build system</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Build system</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=530" >Monkey2 Talk</a>/<a href="#bottom" >Build system</a><br><br>
<a name="2102092"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Monkey1's 'build everything all the time' system has to go  - translation time isn't so bad, but build times with a monolithic source code file can be terrible, esp. with mingw!<br><br>So monkey2 will translate modules to individual source files, which will only be rebuilt if they have changed, ala blitzmax. The entire program will probably still need to be parsed, but this process should be even faster in monkey2 than it is in monkey1. <br><br>Monkey2 will also include some kind of variant on blitzmax's ultra flexible file import system, where you can just import source/object/library files in-code, and they will be magically compiled/linked for you. <br><br></td></tr></table><br>
<a name="2102175"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>marksibly wrote:</b><br>esp. with mingw! <br></div><br>I recommend to let MinGW go and include LLVM Clang compiler (compatible to GNU C++).<br><br><a href="http://llvm.org/" target="_blank">http://llvm.org/</a><br><div class="quote"> Clang is an "LLVM native" C/C++/Objective-C compiler, which aims to deliver amazingly fast compiles (e.g. about 3x faster than GCC when compiling Objective-C code in a debug configuration), extremely useful error and warning messages and to provide a platform for building great source level tools. The Clang Static Analyzer is a tool that automatically finds bugs in your code, and is a great example of the sort of tool that can be built using the Clang frontend as a library to parse C/C++ code. <br></div><br>Clang is included in the main LLVM package: <a href="http://llvm.org/releases/download.html#3.6.0" target="_blank">http://llvm.org/releases/download.html#3.6.0</a><br><br>About Clang:<br><a href="http://clang.llvm.org/" target="_blank">http://clang.llvm.org/</a><br><div class="quote"> Clang is considered to be a production quality C, Objective-C, C++ and Objective-C++ compiler when targeting X86-32, X86-64, and ARM (other targets may have caveats, but are usually easy to fix). If you are looking for source analysis or source-to-source transformation tools, clang is probably a great solution for you. Clang supports C++11, please see the C++ status page for more information. <br></div><br>Clang supports C++11 and C++14, and parts of C++1z:<br><a href="http://clang.llvm.org/cxx_status.html" target="_blank">http://clang.llvm.org/cxx_status.html</a><br><br><a href="http://clang.llvm.org/docs/UsersManual.html#command-line-options" target="_blank">http://clang.llvm.org/docs/UsersManual.html#command-line-options</a><br><br>Producing 32bit/64bit assembly files:<br><pre class=code>// compile 32bit:
// clang -S -m32 test.c -o test-32bit.S
// compile 64bit:
// clang -S test.c -o test-64bit.S

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    uint64_t a = 0ULL, b = 0ULL;
    scanf( "%lld %lld", &amp;a, &amp;b );
    printf( "64-bit division is %lld\n", a / b );
    return EXIT_SUCCESS;
}</pre> <br><br></td></tr></table><br>
<a name="2102174"></a>

<a name="2102189"></a>

<a name="2102190"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, clang looks like it's come a long way!<br><br>I'll give it a shot and if I have any problems I'll switch back to mingw. <br><br></td></tr></table><br>
<a name="2102205"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using precompiled headers (in addition to precompiled .obj/.lib) with the MX2 library system (Mojo, Windows.h, GLFW.hpp etc.) should also speed-up C++ compilation. <br><br></td></tr></table><br>
<a name="2102333"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EdzUp</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also can we have the ability like max to make modules so we dont have to release source code with stuff ala monkeyX <br><br></td></tr></table><br>
<a name="2102509"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pharmhaus</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> The thing that gets quite complicated in Bmax is that no cross references for modules are allowed.<br>This was really a joy moment to me using monkey when cross importing everything without any problems just worked. <br><br></td></tr></table><br>
<a name="2102541"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The thing that gets quite complicated in Bmax is that no cross references for modules are allowed. <br></div><br><br>Because you add circular dependencies then ... <br>a requires c<br>b requires a<br>c requires b<br>a imports c, which imports b which tries to import a which already tries to import c...<br><br>To avoid such things, you could put all the code lines into one big file - so none of them gets "precompiled" without the other. I assume Monkey is doing such a thing - "Include" instead of "import".<br><br>Maybe the compiler-chain would be able to "try" to recognize such circular dependencies and "include" them in that case - so in the worst case your whole 100+ files project will become a single big (virtual) file. Just to assist the developer in his lazyness of creating base classes:<br><br>a requires cBase<br>b requires aBase<br>c requires bBase<br>aBase, bBase and cBase do not require other files<br><br>There are surely other approaches to fix that problem, maybe it is better to have such things "automated" but I am not sure about this.<br><br>I assume: for "Monkey 2" the BlitzMax-behaviour would come back.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="2102600"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> @Derron: Because you add circular dependencies then ... <br></div><br>There are no circular dependences in Monkey, because all of the required source code is parsed before it even begins to build up identifier references.<br>There's no reason Monkey 2 couldn't do the same thing. <br><br></td></tr></table><br>
<a name="2102632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >degac</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>a requires c<br>b requires a<br>c requires b<br> <br></div><br><br>I still don't understand why the compiler simply doesn't take note (in a list,map etc) of all 'import statement' and check it. It seems a simple work for a pre-compiler. (or maybe I missed something quite obviuos!) <br><br></td></tr></table><br>
<a name="2102641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wooohooo! It has always been a massive ballache in monkey trying to work around the order of compilation. Separating everything and declaring dependencies is a massive win! What is the limitation of this? Currently in some of my modules (unreleased ones I think mostly) in native code I have to hack around the fact that everything is dumped into one file. What are you plans for native code in the build process? If I write some module that requires the internal image object, in native code what will the process be? The same question for 3rd party modules? <br><br></td></tr></table><br>
<a name="2102662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pharmhaus</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Wooohooo! It has always been a massive ballache in monkey trying to work around the order of compilation.<br> <br></div><br>Indeed interfacing with C++ is a pain in Monkey.<br><br><br><br><div class="quote"> <br>declaring dependencies is a massive win! <br> <br></div><br>Only when Interdependencies are allowed. Once the code base is big enough one will realize how constraining Bmax no-interdependency module system is. Even with a multilayer architecture once the magic number of lines is reached thinks get ugly. Like really ugly. <br><br></td></tr></table><br>
<a name="2102666"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Pharmhaus: While I agree that allowing cross referencing between modules is very nice, take into account that having dependency injection in Monkey based on interfaces can help a lot mitigating this situation. <br><br></td></tr></table><br>
<a name="2102692"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> @Pharmhaus: Indeed interfacing with C++ is a pain in <strike>Monkey</strike> <b>any language.</b> <br></div><br>Fixed that for you. <br><br></td></tr></table><br>
<a name="2102691"></a>

<a name="2102726"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> There are no circular dependences in Monkey, because all of the required source code is parsed before it even begins to build up identifier references.<br>There's no reason Monkey 2 couldn't do the same thing. <br></div><br><br>I did not say such a thing (maybe my English isnt the best...). I replied to "Bmax not allowing cross references" - and why BlitzMax does not allow that - while Monkey seems to enable such a coding style. I also explained that it might be the case because Monkey "includes" everything, instead of precompiling individual files (like BlitzMax does it).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="2102845"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Would it be possible to also get the ability to run custom scripts with-in Monkey code?  Like you can with run script build phase in Xcode or makefile projects in Visual Studio.<br><br><pre class=code>#SCRIPT "python CollectAssetsToData.py"</pre><br><br>I have a few projects that have scripts I run manually to copy/convert data files to game ready format, life would be so much easier if it was part of the F5 to Run / F7 to Build process. <br><br></td></tr></table><br>
<a name="2102851"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @nullterm: This can be done in Jungle Ide (and in some other IDEs). I don't think it is specifically a language feature but more of a build toolchain setting. <br><br></td></tr></table><br>
<a name="2102853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >degac</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> @nullterm<br>interesting, but it seems more an IDE features than a language feature.<br>And the second question is: what type of 'language-scripts'?<br>What happens if I copy/use your source code (for example) and there's a #SCRIPT in a language I don't have installed?<br>Adding another level of dependency brings to another complication and MX2 seems to aim to 'simplify/reducing the complexity.<br><br>ps: of course Mark could decide that MX2 setup installs - for example - python or whatelse as 'required' component for using MX2.<br>Brucey did something similar with his own BMK version based on LUA to manage the various configuration (I think!). <br><br></td></tr></table><br>
<a name="2102856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about inline '&gt;' to execute a shell command? eg:<br><br>&gt;g++ -o ${EXE_PATH} ${SRC_PATH}<br>#if CONFIG="debug"<br>&gt;gdb ${EXE_PATH}<br>#endif<br><br>...it's up to the user to make sure g++, gdb (or python or whatever) is installed.<br><br>I think it would be nice to have sort of control over the build process inline, for pre-build/post-build steps etc. <br><br></td></tr></table><br>
<a name="2102858"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> @degan<br>It's not IDE though, to me.  IDE is a tool for editing and launching build process &amp; app.  <br>Build scripts are a part of the build process itself, the same way the compiler parses code and spits out an executable.  It takes raw assets and converts them to game ready format.<br>One example I've used for iOS games is a .py script that packaged up all my .lua and other game config scripts into one .zip like file.  So the game just needed one quick load at the start, and then pull out script from memory.<br><br>@marksibly<br>I'm not picky about syntax. &gt; would work too.<br>Pre-build could also allow for script generated .monkey code.  Like reading an event definition .txt or .json file, and then spitting out all the necessary struct/class code.<br><br>Anytime I can integrate makefile and/or python into a build process, there's no end of cool stuff you can do.  And make your own process alot more efficient too. <br><br></td></tr></table><br>
<a name="2102872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> @marksibly: I like the idea of being able to pass parameters directly to the compiler tool chain. Maybe the translater can parse the source files for compiler directives to build it's own make file to suite the situation instead of having a generic make file that has to be edited manually. <br><br></td></tr></table><br>
<a name="2102883"></a>

<a name="2102884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >degac</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> @nullterm<br><br>I have no doubt that launching scripts for trivial and boring works to speed up building, compiling etc is very useful and I think needed: there are so many steps to 'make' an application (converting assets, compiling, signing, packing etc) that everything is helpful.<br>But - as Mark stated - why just dont' consider to have one 'default' (or supported/preferred) script system for MX2? So it could be used - safely (as all the users should have it installed) - to manage MX2 compilation/building/update etc. (just thinking on Mojo and the problems with different sound/gfx format<br>Of course this doesn't mean that single user can have other script languages for their own use, accessed with &gt; or whatelse. <br><br></td></tr></table><br>
<a name="2102910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> How about inline '&gt;' to execute a shell command? eg:<br><br>&gt;g++ -o ${EXE_PATH} ${SRC_PATH}<br>#if CONFIG="debug"<br>&gt;gdb ${EXE_PATH}<br>#endif<br><br>...it's up to the user to make sure g++, gdb (or python or whatever) is installed.<br><br>I think it would be nice to have sort of control over the build process inline, for pre-build/post-build steps etc. <br></div><br><br>Could be risky unless you build in some kind of warning /security system into the compiler. Someone could create malicious source files otherwise.<br><br>I like the idea but not so sure about using a &gt;. Will there be a proper preprocessing? Eg maybe it would be better to make something like #exec("gcc ${blah}") so we just introduce new preprocess commands instead of a whole new symbol.. <br><br></td></tr></table><br>
<a name="2102911"></a>

<a name="2102912"></a>

<a name="2102913"></a>

<a name="2102915"></a>

<a name="2102916"></a>

<a name="2102917"></a>

<a name="2102918"></a>

<a name="2102919"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Being honest, using &gt; for even more things seems horrible to me. It's a comparison operator, and also a generics identifier. I think it's better to be as consistent as possible and give a single responsibility to symbols. Add to this that there are lots of symbols we're not currently using, such as {, |, \, etc. <br>In a worst case situation, we could define a digraph such as &gt;&gt;, &lt;&lt;, &gt;_ or anything else instead of using a single &gt;<br>If you ask me, a keyword would be much more clear here, something as Exec, Run, Shell or whatever. Much more readable and easy to follow when you haven't still read the manual to find out that a comparison operator at the begining of a line is a shell command.<br><br>A "function" would be much better as you will be wanting to get a bit of control on commands successful completion (check "errorlevel"), and then things will start to look uggly:<br><pre class=code>#If &gt;gcc -E main.c &gt; main.i &lt;&gt; 0 then #Error "Can't compile"</pre><br><br>Much better<br><pre class=code>#If Shell("gcc -E main.c &gt; main.i") &lt;&gt; 0 Then #Error "Can't compile"</pre><br><br>But I still think that having this at language level is not very clean. <br><br></td></tr></table><br>
<a name="2102920"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Skn3, Monkey already has os.Execute that can run external processes at runtime.  How would an external process at build time be different?  <br>Risk, sure? But the same risk/trust that most every language and 3rd party libraries (Monkey, C++, Python, etc) on the planet. <br><br></td></tr></table><br>
<a name="2102921"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> @nullterm: A runtime execute command needs the program to be compiled. AFAIK, we're talking about a compile-time execution command, something that is evaluated by the compiler, and executed only during compilation. As instance, an external tool to convert images, a texturepacker call, a preprocessor built in another language, etc. Seems nice, but I honestly do not see the point of including what I think a pre-build commands into the build toolchain. this all should be executed first, and does not need to be defined at language level. Brucey did very well at BlitzMax by introducing Lua scripting in the build tool, and it did not require any blitzMax language change, because they're different things! In my opinion, this will make language syntax a bit dirty, for no good reasons. <br><br></td></tr></table><br>
<a name="2102922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ziggy, if there was a .monkey-script (as an example, not proposing that) that got execute as a pre-build, that would be just as awesome. <br>It doesn't need to be part of the syntax, but I do like the way Monkey is now with build options (like controlling the GC) in the app's .monkey file.  It also means optional or different steps depending on configuration, like #if debug. <br><br></td></tr></table><br>
<a name="2102929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> agreed with both ziggy and nullterm.  Perhaps the scripts used along the trans-compilation build chain can be "exposed" more.  We have things like the android /templates/ folder, we have config.monkey, and (for jungle IDE users), a way to pre-execute some commands before building.  But they're not all consolidated into one easily-exposed place when creating a build.  Perhaps all of these things can be consolidated into an easy-to-access pre-build script?  Something which specifies what template modifications are to be used, what executes before compilation, and what executes after compilation.  This would allow a lot more things, not just texture packing, but different build configurations, automatic resource editing (for platform-specific icons), package injection and etc.  Trans builds a default version of the script from its built-in target templates, and can be changed a similar way we change config.monkey.<br><br>note:  I often specify preprocessor directives at the top of my main source file rather than in config.monkey because I will occasionally delete build-specific folders.  It would be nice if build scripts and their associated templates lived in a place that wasn't subjected to being deleted upon a clean build.  Maybe something like ./[ENTRYPOINT].config[VERSION]/[TARGET]/  ? <br><br></td></tr></table><br>
<a name="2102937"></a>

<a name="2102938"></a>

<a name="2102939"></a>

<a name="2102940"></a>

<a name="2102941"></a>

<a name="2102953"></a>

<a name="2102954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; #If Shell("gcc -E main.c &gt; main.i") &lt;&gt; 0 Then #Error "Can't compile"<br><br>Nice! Being able to #If is important. But I'm starting to think script code in '#' is not nice! You can do pre-build stuff with it, but not post build, and it'll slow down the parser/semanter when it only needs to slow down build.<br><br>&gt; introducing Lua scripting in the build tool<br><br>I'd like to avoid additional languages if possible. At the least, I think it should be possible to do a lot without resorting to LUA etc...<br><br>Things are actually reaching an interesting point here as I just successfully built/run my first 'hello world'! Here's the output c++ code:<br><br><pre class=code>
// HEADER FILE test.h
namespace mojo{
  static void main();
}

// SOURCE FILE test.cpp
#include &lt;cstdio&gt;
#include "test.h"
namespace mojo{
  void main(){
    puts("Hello World!");
  }
}
int main(){
  mojo::main();
  return  0;
}
</pre><br><br>The next step will be to tackle import etc, so the build process is gonna become a top priority.<br><br>Here's my basic idea of what the build process could look like - pretty much just what BMK does, reduced down to a sane chunk of code:<br><br><pre class=code>
Global REBUILD_ALL:Bool
Global OUTPUT_FILE:String
Global SOURCE_FILES:String[]
Global LIBRARY_FILES:String[]
Global COMPILER_OPTS:String[] 
Global LINKER_OPTS:String[]
Global PRE_BUILD:String[]
Global POST_BUILD:String[]

Function Build:Void()

	For Local pre:=Eachin PRE_BUILD
		Execute pre
	Next

	Local obj_files:=New StringStack

	For Local src:=Eachin SOURCE_FILES
	
		Local obj:=MungSourceFileToObjFileSomehow( src )	'generates a 'hidden' .o file for building
		
		If REBUILD_ALL Or FileTime( src )&gt;FileTime( obj )
		
			Execute "g++ -c "+COMPILER_OPTS.Join( " " )+" -o "+obj+" "+src
		
		Endif
		
		obj_files.Push obj
		
	Next
	
	Execute "g++ "+LINKER_OPTS.Join( " " )+" -o "+OUTPUT_FILE+" "+obj_files.Join( " " )+" "+LIBRARY_FILES.Join( " " )
	
	For Local post:=Eachin POST_BUILD
		Execute post
	Next

End
</pre><br><br>I think just using monkey1's #BLAH+= system would provide a lot of flexibility here - but would it be enough? One thing it's probably lacking is the ability to set CC_OPTS on a 'per .cpp file' or per module level...<br><br>#Import could 'deduce' what you're += to, eg:<br><br>#Import "test.cpp"        'same as: SOURCE_FILES+="${CURENT_DIR}/test.cpp"<br>#Import "Include/*.h"     'same as: COMPILER_OPTS+=" -I${CURRENT_DIR}/include"<br><br>I do think Import when used with extern files should have a '#' prefix, as it's part of the build system, not part of the language. <br><br>Thoughts? <br><br></td></tr></table><br>
<a name="2102955"></a>

<a name="2102956"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> @marksibly: At the least, I think it should be possible to do a lot without resorting to LUA etc... <br></div><br>Lua is a word, not an acronym.  However I agree that bringing in another language is a bad idea. <br><br></td></tr></table><br>
<a name="2102961"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> @Samah: Lua is a word, not an acronym. <br></div><br><br>You should add that to your signature ;)<br><br><a href="http://www.lua.org/about.html" target="_blank">http://www.lua.org/about.html</a><br><div class="quote"> "Lua" (pronounced LOO-ah) means "Moon" in Portuguese. As such, it is neither an acronym nor an abbreviation, but a noun. More specifically, "Lua" is a name, the name of the Earth's moon and the name of the language. Like most names, it should be written in lower case with an initial capital, that is, "Lua". Please do not write it as "LUA", which is both ugly and confusing, because then it becomes an acronym with different meanings for different people. So, please, write "Lua" right! <br></div> <br><br></td></tr></table><br>
<a name="2102973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I think just using monkey1's #BLAH+= system would provide a lot of flexibility here - but would it be enough? One thing it's probably lacking is the ability to set CC_OPTS on a 'per .cpp file' or per module level...<br><br>#Import could 'deduce' what you're += to, eg:<br><br>#Import "test.cpp" 'same as: SOURCE_FILES+="${CURENT_DIR}/test.cpp"<br>#Import "Include/*.h" 'same as: COMPILER_OPTS+=" -I${CURRENT_DIR}/include"<br><br>I do think Import when used with extern files should have a '#' prefix, as it's part of the build system, not part of the language.<br><br>Thoughts?<br> <br></div><br><br>I dig all of it.  With the += and import stuff, one shouldn't have to dig into the build script in many cases, but having the flexibility available is fantastic. <br><br></td></tr></table><br>
<a name="2102975"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; one shouldn't have to dig into the build script in many cases<br><br>Trouble is, it isn't a script - it's monkey code that needs to be built into something itself.<br><br>Perhaps something simple like the above could be built into trans2, but you could run trans2 in a special mode that generated .cpp/.h files, but instead of building just dumped all the #VARs to a text file. This way, 3rd party IDE's and tools could provide their own alternative to the above. <br><br></td></tr></table><br>
<a name="2102978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Personally I don't think that trans shouldn't do all the work and calling scripts should be left out of monkey code. I think that the build system needs to be more modular. Give trans the task of just converting the code and a control application that checks to see if there is a pretrans_HOST-SHELL-SCRIPT/postrans_HOST-SHELL-SCRIPT/configfile within a directory called CONTROL that resides in the projects own directory. The control application can then use the pretrans_HOST-SHELL-SCRIPT to create the build environment for the host ready for trans that will use the configfile to control the translation before passing it over to the compiler tools. The posttrans_HOST-SHELL-SCRIPT does the final clean up tasks. One thing that must be taken into account is if a script returns a value, so if the pretrans_HOST-SHELL-SCRIPT creates it's own compiler options to be passed on. <br><br></td></tr></table><br>
<a name="2102993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I think just using monkey1's #BLAH+= system would provide a lot of flexibility here - but would it be enough? One thing it's probably lacking is the ability to set CC_OPTS on a 'per .cpp file' or per module level... <br></div><br><br>I think for most cases the += system was suitable however in monkey1 support for LIBS for example was limited to certain targets. This needs to be fleshed out.<br><br>There was also the issue of importing library/framework files from your module into the built project. For example I write a steam module and want to copy across headers/dlls/resources(images/sounds/data/etc) at build time. Currently support for this was limited in monkey1.<br><br>There is also another point where the += preprocessor doesn't really suffice, or at least not currently:<br>with iOS there are a ton of features we can extend into the app runtime but require access to the target's main app classes (viewcontroller/appdelegate). The same with Android. Monkey needs a way that a module can define injection/override code somehow into this process. Lets say for example a module needs to handle events on the appdelegate, but this isn't currently managed by Monkey2. Is there a smart way that Monkey2 can inject code in this scenario so Module developers can extend? <br><br></td></tr></table><br>
<a name="2102979"></a>

<a name="2102980"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ferdi</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry if this kinda derail what you all are discussing.  But there were 2 build problems I had in Monkey X.  Well more annoyance than problems.<br><br>1. Adding framework into xcode<br><br>The only way to add any “file.framework” is to open the xcode project file and put the framework in there.<br><br>This is the thread: <a href="http://www.monkey-x.com/Community/posts.php?topic=8326" target="_blank">http://www.monkey-x.com/Community/posts.php?topic=8326</a><br><br>I did some research, but this is a while back and it seems xcode command line is very limited.  Anyway if we can add file.framework from Monkey code that will be great.<br><br>2. Adding a target requires a recompile of transcc<br><br>So my target was only for WINNT.  So I can’t use the GLFW target.  I had to modify the method IsValid and MakeTarget such that it is only for WINNT and to only use Visual C.  I also had to modify builders.monkey to add my new target.<br><br>If transcc can detect there is a new target without recompiling, that will be great. <br><br></td></tr></table><br>
<a name="2103007"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another thought to consider is what if we were able to modify the data/content import lists via processor vars. E.g.<br><br>This would prevent all images importing<br><pre class=code>#IMAGE_DATA_ITEMS = ""</pre><br><br>This would add an item<br><pre class=code>#IMAGE_DATA_ITEMS += "c:\myimage.png;"</pre><br><br>This would add an image import into a specified build subfolder<br><pre class=code>#IMAGE_DATA_ITEMS += "c:\myimage.png=subfolder\blah.png;"</pre><br><br><br>Once monkey has processed these vars, it would split them into key/value pairs and process them one by one. The images/data that exists within the data folder of the project, would be added at the start of building. E.g.:<br><pre class=code>IMAGE_DATA_ITEMS = "
${SRC}\data\image1.png=image1.png;
${SRC}\data\image2.png=image2.png;
${SRC}\data\image3.png=image3.png;
${SRC}\data\image4.png=image4.png;
"</pre><br><br>These data list vars would be different to the current monkey1 data filters. They would still exist, but their job would just be to select which data gets added before build as demonstrated above.<br><br>You could even then have content pipeline commands executed on each of the lists. These could be generic open source command line tools(texture packing, sound sample, encrypting) or even allow the content processors to be written in monkey2 code via preprocessor.<br><br><pre class=code>
#PRE
'each pre block is executed in its own context so we can import module code?
Import skn3.atlas

'set the image processing var
IMAGE_DATA_PROCESS = PackTextures()

'function Monkey2 will call as specified in IMAGE_DATA_PROCESS
Function PackTextures:String(images:String)
	Local items := images.Split(";")

	'iterate over all content imports
	Local atlas := new Atlas
	For Local item := eachin items
		Local pieces := item.Split("=")
		atlas.AddImage(pieces[0])
	Next
	
	'pack the ones we want into textures
	atlas.Save("${TEMP}\atlas.png")
	
	'return the content imports that we still want to copy across to built project
	'Monkey2 will replace the list of imports with whatever was returned here
	'this means that if we have packed images, and dont now want them imported, we can skip them by leaving them out of the return
	return "${TEMP}\atlas.png=atlas.png;"
End
#END</pre><br><br>Content pipeline processor execution should also be run on the entire DATA_ITEMS var This way for example you could automatically pack all images into a texture.<br><br>I like the XNA/mono content pipeline in that it lets you process your content automatically. Monkey/mojo has a very basic version of this already with the way it precompiles image dimensions. It would be awesome to expand this to developers for Monkey2.<br><br>The inline preprocessor script shown above would be nice, no idea if its practical though? I think monkey could definitely still benefit on letting preprocessor vars alter the import data lists though... <br><br></td></tr></table><br>
<a name="2103006"></a>

<a name="2103005"></a>

<a name="2103004"></a>

<a name="2103003"></a>

<a name="2103002"></a>

<a name="2103001"></a>

<a name="2103000"></a>

<a name="2102999"></a>

<a name="2102998"></a>

<a name="2102997"></a>

<a name="2102996"></a>

<a name="2102995"></a>

<a name="2102994"></a>

<a name="2102992"></a>

<a name="2102991"></a>

<a name="2102989"></a>

<a name="2102990"></a>

<a name="2102987"></a>

<a name="2102988"></a>

<a name="2102986"></a>

<a name="2102985"></a>

<a name="2102984"></a>

<a name="2102983"></a>

<a name="2102982"></a>

<a name="2102981"></a>

<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
