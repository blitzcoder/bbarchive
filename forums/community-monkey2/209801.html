<!DOCTYPE html><html lang="en" ><head ><title >Mark, watch this</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Mark, watch this</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=530" >Monkey2 Talk</a>/<a href="#bottom" >Mark, watch this</a><br><br>
<a name="2104483"></a>

<a name="2104484"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshKlint</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Already posted, but worth pointing out:<br><a href="http://www.youtube.com/watch?v=5kj5ApnhPAE" target="_blank">http://www.youtube.com/watch?v=5kj5ApnhPAE</a><br><br>This guy describes my feelings on languages perfectly. <br><br></td></tr></table><br>
<a name="2104507"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I like that talk a lot!<br><br>I 'sort of' like the idea of getting rid of 'implements', eg:<br><br><pre class=code>
interface ILight
   method Color:Color()
   method Range:Float()
end

class Light
   method Color:Color()
      ...blah
   end
   method Range:Float()
      ...blah
   end
end

function Main()
   local light:ILight=new Light    'no problemo!
end
</pre><br><br>I suspect that'll upset some Java users! But I think it's a 'safe' thing to be able to do, and reduces noise significantly.<br><br>On the down side, it isn't as obvious whether or not a class implements an interface, but is that a big deal? <br><br></td></tr></table><br>
<a name="2104510"></a>

<a name="2104511"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>marksibly wrote:</b><br>On the down side, it isn't as obvious whether or not a class implements an interface, but is that a big deal? <br></div><br>It's absolutely horrible. When reading the class code, you don't see that it conforms to an Interface (but you should see this already).<br>You have to search all files for IClassName to know if there is something going on behind the scene, or not. <br><br></td></tr></table><br>
<a name="2104512"></a>

<a name="2104513"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It's absolutely horrible. <br></div><br>I agree, you can not see at a glance what contracts it needs to fulfil.<br><br>Its similar to what I don't like about C# interfaces, you cant tell by just looking at the code if you are using an interface or extending a class:<br>C#:<br><pre class=code>class Foo : Bar</pre><br>Is Bar an interface or the superclass!?!?!<br><br>Java:<br><pre class=code>class Foo implements Bar</pre><br>I know that Bar is an interface... <br><br></td></tr></table><br>
<a name="2104514"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> - <a href="http://golangtutorials.blogspot.de/2011/06/interfaces-in-go.html" target="_blank"><u>Interfaces in Go</u></a> <br><br></td></tr></table><br>
<a name="2104515"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshKlint</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> The point is not the details of Go, but the idea of a niche between C++/Java and script languages. <br><br></td></tr></table><br>
<a name="2104516"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nullterm</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> On the down side, it isn't as obvious whether or not a class implements an interface, but is that a big deal? <br></div><br><br>IMO, I think ya need to keep Implements ILight, more so for human eyes looking and understanding.  I get that the code is smaller/simpler, and that's generally a good/great thing.  But seeing "Implements ILight" instantly tells me that I can plug it into another object that talks to ILight's. <br><br></td></tr></table><br>
<a name="2104517"></a>

<a name="2104518"></a>

<a name="2104519"></a>

<a name="2104520"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> @marksibly: On the down side, it isn't as obvious whether or not a class implements an interface, but is that a big deal? <br></div><br>I can't believe you're even asking that question...<br><br><div class="quote"> @Danilo: It's absolutely horrible. <br></div><br>Completely agree.<br><br><div class="quote"> @nullterm: But seeing "Implements ILight" instantly tells me that I can plug it into another object that talks to ILight's <br></div><br>Exactly. <br><br></td></tr></table><br>
<a name="2104521"></a>

<a name="2104522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> The idea of making interface implementations not obvious does not make interfaces understanding any easier and I suspect code that does infer interfaces usage can be harder to maintain. If I modify an interface, suddenly I'll need to evaluate all classes that where implementing it, to identify which ones do not now, and if I miss any one, the code will fail at runtime. Having explicit implementations will make it a lot easier to identify class implementations, and will allow for this situations where the interface has been modified to be detected at compile time, which makes maintenance a lot better!<br><br>So, while I agree that language needs to be expressive and compact, and be as easy to follow as possible, it should not come to the cost of making it expensier to maintain or to understand. Knowing which classes implement an interface in code, is a design information that should not be hidden by inference. <br><br></td></tr></table><br>
<a name="2104523"></a>

<a name="2104524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; if I miss any one, the code will fail at runtime. <br><br>No, it'd still fail at compile time - if an object doesn't have the required methods, it can't be used in place of an interface. Edit the interface and you still have to edit implementing classes. <br><br></td></tr></table><br>
<a name="2104525"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> @JoshKlint:<br>I just wondered where did Mark get the idea that keywords should be removed now, and it looks like<br>it came from the video, or maybe by looking at GoLang Interfaces (but Go works differently).<br><br>The question is, do ILight and Light automatically work together in Mark's idea? And if ILight and Light<br>are automatically bundled together, how would this work with classes that implement 2, 3 or 4 Interfaces?<br><br>Or was the idea taken from GoLang?<br><br>GoLang simply reverses many things. Where MX1 users say "Class C conforms to Interfaces X,Y,Z", GoLang users write "Class C"<br>and the GoLang compiler automatically detects that the type "Class C" conforms to Interfaces X,Y,Z (if they are defined).<br><br><pre class=code>interface IAnyInterface
   method Color:Color()
   method Range:Float()
end

class Light
   method Color:Color()
      ...blah
   end
   method Range:Float()
      ...blah
   end
end</pre><br>GoLang automatically detects that Light implements/conforms to IAnyInterface.<br>If you remove method Color() from the class, it would not conform to IAnyInterface anymore,<br>and if you add a new method "Length()", it detects that class Light now also confirms to IAnotherInterface.<br><br>While the compiler can detect that automatically, I think it's different for the programmer. Given 3 classes C,D,E<br>the programmer needs to search similarities between the 3 classes to know what Interfaces it conforms to.<br>And then, if he found similarities, he could write:<br><pre class=code>local c:ISomeInterface = new C
local d:ISomeInterface = new D
local e:ISomeInterface = new E</pre><br>I think this completely reverses the meaning of Interfaces as used now<br>(contracts/warranty that the developer implements certain methods) <br><br></td></tr></table><br>
<a name="2104528"></a>

<a name="2104529"></a>

<a name="2104530"></a>

<a name="2104531"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Or was the idea taken from GoLang?<br><br>The idea was taken from the Go video posted at the top. I thought the idea of the compiler pretty much 'auto-writing' all the 'Implements' stuff for you was interesting and worth exploring a bit.<br><br>&gt; I think this completely reverses the meaning of Interfaces as used now<br><br>Not really, I think what it does is reduce 'implements' to the documentation level, ie: if you want to know what a class implements, you read the docs. Classes still have to implement the correct interface methods if they want to be able to be used in place of interfaces, so it's not 'weaker', and the same programs would compile or not compile.<br><br>Rust takes interfaces in an even more interesting direction:<br><br><pre class=code>
interface Drawable
   method Draw:void( x:float,y:float )
end

class Circle
   field radius:float
end

implement Drawable for Circle
   method Draw:void( x:float,y:float )
      DrawCircle( x,y,radius )
   end
end
</pre><br><br>(or something like that...) <br><br></td></tr></table><br>
<a name="2104533"></a>

<a name="2104534"></a>

<a name="2104535"></a>

<a name="2104536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Rust takes interfaces in an even more interesting direction <br></div>I found it to be particulary horrendous (sorry). Having class methods defined and implemented outside the class feels somehow wrong to me. Maybe it's just me, but I like seeing a class source code and having an idea of what the class actually does without having to look what the class could also be doing, because it's defined somewhere else.<br><br>Interfaces defined outside the class look like enforced <a href="http://en.wikipedia.org/wiki/Adapter_pattern" target="_blank">addapter code </a> to me. Enforcing design patterns like this is a bit going too far if you ask me. <br><br></td></tr></table><br>
<a name="2104537"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> "Implements ILight" may be strictly speaking just enforced documentation, but it's a ton of essential programmer documentation for the price of only two words (and you already had to type far more than two words to implement the interface methods).  I'm pretty sure that there are better ways to make a language using Basic syntax more concise, if that is even an ambition! <br><br>Like Ziggy, I like to be able to go to where a class is defined and see quickly what it is and what it does. <br><br></td></tr></table><br>
<a name="2104538"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Self-documenting code is nice. The code itself is the documentation, and HTML etc. can easily be generated from it, including catching all "implements".<br><br>What if you have 5 Interfaces with method Draw(x,y)? For example imported from different libraries.<br>Circle will then automatically confirm to all 5 interfaces?<br>If you write a class with 10 methods, the compiler automatically chooses - out of some hundred or thousands of available interfaces -<br>to what interfaces my class confirms to?<br>With "implements" I tell the compiler what I want to do, and if I forget to implement a certain method, the compiler tells me so.<br>Without telling the compiler about the agreement, it would shift the error message to the first attempt to use a certain method or interface somewhere. <br><br></td></tr></table><br>
<a name="2104539"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Having class methods defined and implemented outside the class feels somehow wrong to me.<br><br>Same here, but aren't you curious why they've done it this way? What would its strengths be? There are already calls for 'class Image Extension' and this definitely is in line with that!<br><br>&gt; I like seeing a class source code and having an idea of what the class actually does without having to look what the class could also be doing, because it's defined somewhere else.<br><br>Yes, but a class can't do everything on it's own, unless it's a butt ugly mega class. This idea definitely has the appeal to me of being able to write lightweight classes that can be used in very flexible ways, ie: ANY class can be made 'Drawable' very easily. Rect and Circle might be in a geom module somewhere. What's the 'correct' alternative to this? It'd involve wrappers/containment/extension or some other extra 'layer' of crud.<br><br>I'm not about to actually implement any of these ideas, but I can definitely see some benefits to both of them. <br><br></td></tr></table><br>
<a name="2104543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Circle will then automatically confirm to all 5 interfaces?<br><br>Yep, and I like that! I think it'd result in far more code being written that used interfaces.<br><br>&gt; If you write a class with 10 methods, the compiler automatically chooses - out of some hundred or thousands of available interfaces - to what interfaces my class confirms to?<br><br>The compiler only has to worry about the interfaces you try and use a class with. If you never convert a class C to an interface I, the compiler never has to check if C implements I.<br><br>&gt; Without telling the compiler about the agreement, it would shift the error message to the first attempt to use a certain method or interface somewhere.<br><br>Errors would occur at exactly the same point, ie: when you tried to convert a class to an interface.<br><br>As you say, you lose some 'self documentation'. But it's kind of interesting to consider that that's all implements is - compulsory documentation/form filling. It doesn't really have to be there. <br><br></td></tr></table><br>
<a name="2104540"></a>

<a name="2104541"></a>

<a name="2104542"></a>

<a name="2104544"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> So what about IDEs with automatic refactoring?  If I want to change a method name in the interface, I need to manually find each and every class that implements it. <br><br></td></tr></table><br>
<a name="2104545"></a>

<a name="2104546"></a>

<a name="2104547"></a>

<a name="2104548"></a>

<a name="2104549"></a>

<a name="2104550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>marksibly wrote:</b><br>Errors would occur at exactly the same point, ie: when you tried to convert a class to an interface.<br><br>As you say, you lose some 'self documentation'. But it's kind of interesting to consider that that's all implements is - compulsory documentation/form filling. It doesn't really have to be there. <br></div><br>I see your point:<br><pre class=code>Strict

Interface Computer
    Method Boot:Void()
    Method Process:Void()
    Method Display:Void()
End

Class PC Implements Computer
    Method Boot:Void()
        Print "PC.Boot()"
    End
    Method Process:Void()
        Print "PC.Process()"
    End
    Method dusplay:Void()
        Print "PC.Display()"
    End
End

Function Main:Int()
    Local pc:= New PC  ' compiles, even if the class is incorrect / incomplete
                       ' (class does not conform to the interface, violating the promise)

    pc.Boot()          ' works
    pc.Process()       ' works

    'pc.Display()       ' Error : Identifier 'Display' not found.
    
    Return 0
End</pre><br>I expected the compiler to be more strict and helpful catching errors/mistakes/typos.<br><br>Can't this be dangerous, if you give such an incorrect / incomplete class instance to an external function/method (C++ for example),<br>or something like that?<br><br>EDIT: OK, the compiler begins to complain when using the Interface somewhere outside.<br><pre class=code>Strict

Interface Computer
    Method Boot:Void()
    Method Process:Void()
    Method Display:Void()
End

Class PC Implements Computer
    Method Boot:Void()
        Print "PC.Boot()"
    End
    Method Process:Void()
        Print "PC.Process()"
    End
    Method dusplay:Void()
        Print "PC.Display()"
    End
End

Function Main:Int()
    f(New PC())
    Return 0
End

Function f:Void(c:Computer)
    c.Boot()
    c.Process()
    c.Display()
End</pre> <br><br></td></tr></table><br>
<a name="2104552"></a>

<a name="2104553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Yes, but a class can't do everything on it's own, unless it's a butt ugly mega class. This idea definitely has the appeal to me of being able to write lightweight classes that can be used in very flexible ways, ie: ANY class can be made 'Drawable' very easily. Rect and Circle might be in a geom module somewhere. <br></div>You say flexible, I read single responsibility being sort of erased. Extension methods are a bit like this, that's true too. I'm not saying it's a bad idea, just I'm afraid it could make it easier to embrace non SOLID design, but maybe it's just me being sort of too strict or something <br><br></td></tr></table><br>
<a name="2104555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pharmhaus</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you like to remove unnecessary code then taking a look at <a href="https://youtu.be/LH75sJAR0hc?t=8m46s" target="_blank">how Scala handles things</a> could maybe help you.<br>It is always astonishing to me how easy it is to write things when the language is well designed and not bloated.<br>Java 8 has changed a little but it still can't compete with dialects like scala in my opinion.<br>It also does concurrent programming well (enough), many modern langauges really suck at this (*cough*). <br><br></td></tr></table><br>
<a name="2104556"></a>

<a name="2104557"></a>

<a name="2104558"></a>

<a name="2104559"></a>

<a name="2104560"></a>

<a name="2104561"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Having class methods defined and implemented outside the class feels somehow wrong to me.  <br></div>I haven't finished the thread yet but I had to comment here.    I totally disagree.  I think go and rust and to a lesser extent obj c (which I dislike the syntax) and all the others are right.  Composition [edit] is a huge benefit to class design.. I whole heartily think it should be implemented.<br><br>edit:<br>and I like rust's syntax better than go's. <br><br></td></tr></table><br>
<a name="2104562"></a>

<a name="2104563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I should clarify that they do this for composition... and it should not replace inheritance <br><br></td></tr></table><br>
<a name="2104564"></a>

<a name="2104565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I'm not about to actually implement any of these ideas <br></div>boo   :) <br><br></td></tr></table><br>
<a name="2104566"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I haven't finished the thread yet but I had to comment here. I totally disagree. I think go and rust and to a lesser extent obj c (which I dislike the syntax) and all the others are right. Composition [edit] is a huge benefit to class design.. I whole heartily think it should be implemented. <br></div>That makes SOLID design more complex and easy to break. <br>I could "buy it" if it was defined to provide interface mapping to actual class defined methods. That would make sense, as a quick interface adapter. But if interface "mapping" AND functiona implementation is defined outside the class, the whole thing seems a lot less robust to me. <br><br></td></tr></table><br>
<a name="2104567"></a>

<a name="2104568"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> While on subject of interfaces... Can we have default method implementation for interfaces? So one can implement the interface in a class, but pick and choose which methods they override. Basically multiple inheritance?<br><br>With regards to the interface switcheroo being suggested... Agh looks fugly. I'm sure it would be something you get used to, but it sure doesn't feel comfortable to think about. The rust style suggested does seem quite good though, however what advantage does it have really? I am probably not thinking hard about it enough... <br><br></td></tr></table><br>
<a name="2104569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shinkiro1</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like how Mark questions what others take as given in a programming language.<br>The feeling that something looks wrong/feels wrong is NOT a good indicator over how useful that feature could be.<br>Speaking for myself, before I learned OO and later Interfaces both concepts looked alien to me in the beginning and I constantly questioned if there was any value to it.<br><br><div class="quote"> <br>The rust style suggested does seem quite good though, however what advantage does it have really? <br> <br></div><br>You can basically extend any class (even other peoples) to fit them in your code. All that while leaving the code/files of others untouched. You simply build on top of it. <br><br></td></tr></table><br>
<a name="2104576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> You can basically extend any class (even other peoples) to fit them in your code. All that while leaving the code/files of others untouched. You simply build on top of it. <br></div><br><br>Oh I see, yeah that could be awesome... Being able to tack interfaced methods onto other classes I could definitely get behind! <br><br></td></tr></table><br>
<a name="2104581"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> If this is going to be supported, I don't think you can really call them interfaces any more as they no longer provide a solid contract.  I can't immediately find all the classes that could be "coerced" to that data type.<br>Interfaces should be implemented exactly as they are in Monkey X, but the functionality suggested in this thread (if added to the language) should be given a new term.  I see no reason why these two functionalities can't exist side-by-side. <br><br></td></tr></table><br>
<a name="2104614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >taumel</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> +1 for interfaces like Mark mentioned them. <br><br></td></tr></table><br>
<a name="2104620"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> (I'm still in the process of reading the thread as I write this.....)<br><br>Making the compiler a bit more dynamic when using interfaces seems like a neat idea (especially if it works like Go), but the problem comes when/if you start hitting limitations of this feature that people don't/won't expect, particularly 1. new coders,  2. coders experienced in languages that don't have this feature (ie:  they're familiar with interfaces but unfamiliar with how they're implemented in mx2), and 3.  Users of languages like Go where mx2's implementation of Interfaces isn't as "auto-magical" as the language they're familiar with;  or at the very least, isn't as "auto-magical" in the same way.<br><br>Getting this wrong could end up earning the feature a bad reputation, even if the idea itself has useful benefit.  Compare the Variant type which some BASICs of the past had to say, Python / Ruby's dynamic typing.... <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
