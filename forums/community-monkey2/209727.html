<!DOCTYPE html><html lang="en" ><head ><title >Please make GC optional</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Please make GC optional</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=530" >Monkey2 Talk</a>/<a href="#bottom" >Please make GC optional</a><br><br>
<a name="2102323"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> While garbage collection can help in some situations such as detecting and breaking circular references, it would be great to be able to disable it entirely and rely on other stuff like smart pointers, which add less overhead (being able to mark references as 'weak' would help with breaking circular refs). I am still not sure that GC is the best way to go in game programming, especially when trying to write low-level stuff with it, like a 3D engine, where every cycle you can save counts. <br><br></td></tr></table><br>
<a name="2102272"></a>

<a name="2102273"></a>

<a name="2102292"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> +1<br><br>Very useful for Frameworks and complete Library Systems. <br><br></td></tr></table><br>
<a name="2102306"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Flad</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah this, as well as a way to put instances/classes into a given memory block as memory performance nowadays is almost always one of the most limiting factors.<br><br>There's a pretty CppCon talk from Mike Acton (Insomniac Games) <a href="https://www.youtube.com/watch?v=rX0ItVEVjHc" target="_blank">https://www.youtube.com/watch?v=rX0ItVEVjHc</a><br><br>In addition Unity is a pretty decent sample of this issue too because fighting the GC seems to be one of the really prominent tasks, developers have to focus on and paradoxically it's much more complicated with languages like C#.<br><br>Another decent read <a href="http://sebastiansylvan.com/2015/04/13/why-most-high-level-languages-are-slow/" target="_blank">http://sebastiansylvan.com/2015/04/13/why-most-high-level-languages-are-slow/</a> <br><br></td></tr></table><br>
<a name="2102309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Please, don't make the GC optional. Providing a good GC is a much better option. Unity one is horrible slow in some situations. <br><br></td></tr></table><br>
<a name="2102324"></a>

<a name="2102325"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> What's the problem in providing the option to disable it, Ziggy? <br><br></td></tr></table><br>
<a name="2102326"></a>

<a name="2102328"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Usually, mixing both GC model and not GC model in the same code causes lots of mem fragmentation, and forces usage of the third-party written apis to be coded now in a managed fashion, now not, depending on the favorite flavor of the module creator. IMHO this adds complexity to the whole language ecosystem for no good reason. Modern GC are fast enough (sometimes faster than manual memory management). <br><br></td></tr></table><br>
<a name="2102329"></a>

<a name="2102330"></a>

<a name="2102331"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> It wouldn't actually make a difference to support both: when disabling GC, the 'weak' keyword could be used to mark weak references, and all pointers could be exported as std::shared_ptr and std::weak_ptr (assuming that the translator uses STL; if not, whatever smart pointer implementation it would use). When GC is enabled, the translator would ignore the 'weak' keyword and export proper code to make everything garbage collected. There would never be a situation where GC and non-GC code is mixed. <br><br></td></tr></table><br>
<a name="2102332"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> If GC is disabled, it's a choice. A choice by the user/king (for some reason)... <br><br></td></tr></table><br>
<a name="2102355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's not a choice if any module relies on proper elimination of circular references. You can have both modes at the same time, as in D, and add complexity to language usage because users will have to deal with 2 memory management models, or just allow one at a time, and expect all module and third party developers to design all their modules without circular references, just in case anyone wants to work without a proper GC. <br><br></td></tr></table><br>
<a name="2102372"></a>

<a name="2102373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like my circular references being handled automatically, thank you very much! +1 to keeping GC 'mandatory'.  Maybe there can be a clearly "unsupported" way to deal with this, like the current #CPP_GC_MODE=0 but with some limited control.  Needs to be global as heck though so it's impossible to mix and match models in the same process.  I think the majority of users will prefer GC being ON, maybe with a small amount of added control such as the ability to force the GC to flush (or to delay it, where possible -- I don't think it is on Android).  Better support for async background processes would pretty much whisk away most remaining GC anxiety to the land of minor concerns.  (Parsing heavy XML/JSON metadata or doing procedural asset generation in another thread would be useful) <br><br>Sincerely, a coding pleb  (nobuyuki) <br><br></td></tr></table><br>
<a name="2102383"></a>

<a name="2102384"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It's not a choice if any module relies on proper elimination of circular references. <br></div>The only problem with that would be that you would be forced to work with GC on when using that framework if you don't want memory leaks. <br><br></td></tr></table><br>
<a name="2102604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shinkiro1</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Giving options can't hurt right? No, it does.<br>There is a cost when giving users options: increased complexity, maintenance (time, money), model is not as simple anymore, probably resulting in longer debug times.<br><br>Therefore I think that MX2 should pick 1 model and only 1. Otherwise it will just become a mess. <br><br></td></tr></table><br>
<a name="2102658"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Skn3</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would agree that that to support two memory management models is a headache! But I can definitely see some benefit of adding some form of "destructor" for objects at least. Currently we just cut all ties to an object and pray. If we had some kind of Destroy() (pseudo destructor) mechanism built into all objects I think that could be a good stop gap.<br><br><pre class=code>Class Base&lt;T&gt;
	Global pool := New Pool&lt;T&gt;
	
	Method New()
		If pool.IsEmpty()
			Return New T
		Else
			Return pool.Pop()
		EndIf
	End
	
	Method Destroy() 'pseudo destructor
		pool.Push(Self)
	End
End

Class Item Extends Base&lt;Item&gt;
End

Function Main:Int()
	Local i:= New Item
	Destroy i
End</pre><br><br>The gc could immediately call Destroy on the object when the internal ref count reaches 0. That way we don't have anything getting freed in an unexpected manor. In teh example above we could change Function Main to:<br><br><pre class=code>Function Main:Int()
	Local i:= New Item
	i = Null
End</pre><br><br>and the Destroy() would get called for the object. <br><br></td></tr></table><br>
<a name="2102657"></a>

<a name="2102656"></a>

<a name="2102654"></a>

<a name="2102653"></a>

<a name="2102647"></a>

<a name="2102648"></a>

<a name="2102645"></a>

<a name="2102646"></a>

<a name="2102638"></a>

<a name="2102637"></a>

<a name="2102660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshKlint</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> My view is that garbage collection is an outdated fad.  Performance never goes out of style. <br><br></td></tr></table><br>
<a name="2102661"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I agree. Apple did it right with its ARC system. <br><br></td></tr></table><br>
<a name="2102663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW_</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm voting no for what it's worth.  It would be a support nightmare for Mark and the other maintainers. <br>Unity is bad example. It's gc is like 8 years old and not designed well in the first place. <br>Mark has already mentioned something about being able to disable the GC for certain things. <br>performance is always my first priority and I've never encountered the kind of GC issues with Bmax/Monkey that would make me want to turn it off. <br><br></td></tr></table><br>
<a name="2102673"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> The idea that any GC implementation is worse than manual handling of memory allocation and deallocation can be discussed. Manually handling of memory can lead to worse performance, specifically when there are lots of deallocations and allocations, and memory starts to get fragmented.<br>When a GC'ed application uses less ram than the available one, collection could never be trigged, and in this situation the whole application is way faster than when it uses weak pointers, which require ref counting, and mem being free and eventually compacted.<br><br>Then, there are several scenarios where a good GC can work wonders in comparison to manually human written unmanaged code, or ref counting based garbage collection. Ref counting (and weak pointers) are a bad idea because when references are met to be zero, memory will be deallocated, even when there's no need to deallocate it just yet. That means all objects being destroyed produce a small performance degradation, and also, all references being set/unset to a given object produce computational costs which are linear. Also, ref counting needs to be atomic on multithread scenarios which is a very bad situation regarding performance.<br><br>That said, the problem with stop-the-world mark&amp;sweep collectors is that they may introduce pauses when they're performing collection (as in D, or Dalvik) and this is very disgusting when used on games, as it introduces pauses. While the whole performance may be better than with manual collection or refcounting, the performance is much more constant when using refcounting or manual collection. But there are very nice GC implementations that minimize a lot these pauses, to the point that they're unnoticeable. (realtime garbage collectors, some generational ones, etc).<br><br>@Snk3: BlitzMax had destructor methods, so maybe we could have them too on Monkey2? I think they where left out of Monkey1 because the Dalvik GC did not support them, but if we're not going the Java route, maybe Mark will add them They can be handy sometimes <br><br></td></tr></table><br>
<a name="2102665"></a>

<a name="2102664"></a>

<a name="2102701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Flad</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd love to learn about those scenarios where a GC will do wonders compared with manually written code (by a reasonably experienced developer). <br><br></td></tr></table><br>
<a name="2102707"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think ziggy mentioned memory fragmentation.  Do reasonably experienced developers love faffing about with that sorta stuff? <br><br></td></tr></table><br>
<a name="2102719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Take any multithread application where you have to increase/decrease the ref counting of weak pointers by using atomic operations. A simple variables reference swap means 3 blocking substractions, 3 blocking additions and 6 blocking comparisons. Compare this to a null garbage collector if memory usage is low, or to a realtime garbage collector. (I would recommend you the book The Metronome, A simpler approach to garbage collection in real-time systems. )<br><br>This site is curious: <a href="https://gist.github.com/spion/3049314" target="_blank">https://gist.github.com/spion/3049314</a> LuaJIT seems to perform faster than C and C++ in those benchmarks. <br><br>Then, I remember some time ago there was a long debate between two microsoft coders, both where trying to get a chinese dictionary sorting algorithm as fast as possible. One coder was using C++ while the other was using C#. Finally C# was marginally faster, but not in a significative way. <br><br></td></tr></table><br>
<a name="2102709"></a>

<a name="2102708"></a>

<a name="2102737"></a>

<a name="2102738"></a>

<a name="2102739"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>ziggy wrote:</b><br>@Snk3: BlitzMax had destructor methods, so maybe we could have them too on Monkey2? I think they where left out of Monkey1 because the Dalvik GC did not support them, but if we're not going the Java route, maybe Mark will add them They can be handy sometimes <br></div><br>Destructors and use of Smart Pointers (and Pool) would be perfectly fine, wouldn't it?<br><br>- <a href="http://en.wikipedia.org/wiki/Destructor_(computer_programming)" target="_blank"><u>Destructor_(computer_programming)</u></a><br><br>- <a href="http://www.boost.org/doc/libs/" target="_blank"><u>Boost Library Documentation</u></a><br><br>-- <a href="http://www.boost.org/doc/libs/1_58_0/libs/smart_ptr/smart_ptr.htm" target="_blank"><u>Smart Pointers</u></a><br>-- <a href="http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/sp_techniques.html" target="_blank"><u>Smart Pointer Programming Techniques</u></a><br><br>-- <a href="http://www.boost.org/doc/libs/1_58_0/libs/pool/doc/html/index.html" target="_blank"><u>Boost.Pool</u></a><br>-- <a href="http://www.boost.org/doc/libs/1_58_0/doc/html/thread.html" target="_blank"><u>Boost.Thread</u></a><br>-- <a href="http://www.boost.org/doc/libs/1_58_0/libs/timer/doc/index.html" target="_blank"><u>Boost Timer library</u></a><br>-- <a href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio.html" target="_blank"><u>Boost.Asio</u></a><br>-- <a href="http://www.boost.org/doc/libs/1_58_0/libs/core/doc/html/core/checked_delete.html" target="_blank"><u>checked_delete</u></a><br><br>- <a href="http://www.codeproject.com/Articles/33623/A-new-approach-to-memory-management-that-solves-th" target="_blank"><u>A new approach to memory management that solves the issues with shared_ptrs</u></a> (contains more links -&gt; see Conclusion) <br><br></td></tr></table><br>
<a name="2102736"></a>

<a name="2102757"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Flad</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you have performance sensible code and you have to do threaded reference counting you're just not what I call a reasonable experienced developer.<br><br>No issue with having GC for those as well as for areas where the improvement in productivity outweights the costs as long as there's a way to layout data structures in a sensible way, related to the given problem, for those who know what they're doing/need. <br><br></td></tr></table><br>
<a name="2102763"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Destructors and use of Smart Pointers (and Pool) would be perfectly fine, wouldn't it? <br></div>Perl was implemented like this and has been proven to not be a very good situation.<br>The most problematic areas with this approach:<br>1.- Slow ref counting when data is shared among threads (atomic operations means all threads are paused for at least a cycle)<br>2.- when a reference reaches 0, the object is released and memory freed. Ok, but that's expensive. What if deallocation is not yet required because the machine has lots of free RAM?Allocating and deallocating RAM is expensive, doing it all the time is an absurd performance loss.<br>3.- In addition to perform worse and add unrequired complexity to multithread handling, it makes circular referenced objects an automatic memory leak.<br><br>As oposite, working with a good GC does not have any of this issues. However, when a GC not designed for realtime applications is used, memory allocation and deallocation is concentrated in bug chunks. This improves performance in a large complex process, but introduces performance variations. That is, a complex process will end earlier (better performance), which is good, but the process will have some tiny pauses while it is being performed (worse stability). This, on a regular server or desktop app, has no importance. but when we're working on a game, we need a real time garbage collector.<br><br>Fortunately, there are realtime garbage collectors that solve this issue completely and very efficiently. The trade off is that they're much more complex to implement, and they're are not default on Android (Dalvik AFAIK) nor in .Net or JavaVM. That's why GC in general is considered to introduce performance degradation on games, because, even when they improve performance in the whole process, they can introduce visual "pauses" on a realtime process. IMHO using a proper GC is the answer. <br><br></td></tr></table><br>
<a name="2102762"></a>

<a name="2102874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think monkey1 ended up with a reasonable solution to GC, and that was pretty much 'don't use new if you don't want GC', as GC is triggered by the new operator.<br><br>As a result of this, the graphics and audio modules ended up being developed in such a way that they don't use New in 'realtime' bits of code, so they never cause GC.<br><br>You can't write a module that magically works with or without GC - either the module manages it's memory issues (via GC or manually) or it doesn't. You can write 2 modules, one with manual GC, one without,  but if the manual version handles memory management issues on its own efficiently, why write the other?<br><br>You can suspend GC, but in realtime situations that will only makes things worse as it'll cause 'lumps' in incremental GC. The only time you should probably suspend GC is when you're messing around with extern libs and pointers.<br><br>So I think the main thing is to add features that make it easier to do manual memory management and avoid the New operator.<br><br>&gt; A new approach to memory management that solves the issues with shared_ptrs (contains more links -&gt; see Conclusion)<br><br>Interesting article! However, I don't see how it'd be possible to do without it ending up being quite heavyweight - wont each object need a list of 'assigned to' objects so it can find it's way back to the root? Gonna take a closer look at this...<br><br>I have been thinking about ref counting in general though, one idea being to pinch b3d's system. B3d used refcounting, but also allowed for manual 'safe' delete via a hidden 'this' pointer in objects, eg:<br><br>Class RefCounted<br>   ...header...<br>   Field this:Object=Self    'real object to actually use<br>   Field refs:int                   'ref count<br>   ...fields...<br>End<br><br>Whenever you used blah.F in b3d, it actually expanded to blah.this.F. 'This' initially just pointed back to the object so was effectively sort of a NOP. But deleting an object would set 'this' to null, so once an object was deleted it magically appeared to be 'null' to every variable. Behind the scenes, an object would still consume memory until refs went to 0. It worked pretty well in b3d and I think the general idea could be useful in monkey2.<br><br>There is still a 'write barrier' involved for assigning a refcounted object to a var, but I think the double dereference of 'this' could be removed in release mode via only using 'this' to when comparing objects, eg:<br><br><pre class=code>
Class Thing RefCounted
   Method Delete:Void()   'only for refcounted as yet...
   End
   Method Update:Void()
   End
End

Local t:=New RefCounted Thing   'probably an idea not to reuse plain 'New'
DoSomeStuff( t )
if t&lt;&gt;Null   'not deleted?
   t.Update()
Endif
</pre><br><br>In debug mode, the 't.Update()' would expand to 't.this.Update()', providing a runtime check that an object hasn't been deleted. But in release mode, it can just be 't.Update()', as the code has (theoretically) already validated the object. If not, they would have got a null object error anyway...<br><br>Of course, as with my 'Value' and 'Const' idea, making 'RefCounted' a compile time thing is a bit of a drawback. But it does dramatically reduce the crap involved in using objects in code as you don't have qualify vars everywhere with Const, Ptr, RefCounted etc, and it allows for some nice optimisations.<br><br>Anyway, just thinking out loud, but one thing's for sure - monkey2 will have GC based on Monkey1's. <br><br></td></tr></table><br>
<a name="2102790"></a>

<a name="2102789"></a>

<a name="2102788"></a>

<a name="2102787"></a>

<a name="2102792"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> And regarding destructors (aka dtors 'coz destructors is a hassle to write) there a 3 main issues here:<br><br>* No guarantee dtors will be called in time, eg: if you're relying on dtors to release videomemory, but are avoiding 'New' for speed, GC never gets called and nothing is released! That's an extreme case, but the point is that dtors will be called 'at some time in the future', and relying on dtors to be called often enough to be used as a memory management tool is probably not a good idea.<br><br>* No guarantee of when dtors will be called. Sure, dtors will (probably) be called inside 'New', but lots of code uses New and it could be in a sensitive section of code, eg: when some global data structure is being modified. I consider this to be different from normal callbacks where an API can make some sort of guarantees about when a callback will be invoked - but 'any time new is called' is kind of dangerous.<br><br>* The 'zombie problem', consider...<br><br><pre class=code>
Class C
   Method Delete:Void()
     Print "Deleting..."
     g=Self
   End
End

Global g:C

Function Main()
   New C
   GCCollect
   If g Print "It's ALIVE!"
End
</pre><br><br>The issue here is that dtors can theoretically 'resurrect' themselves (or other objects) by assigning them to fields/globals. In the above code, if Main tries to use 'g' the app will probably crash, as 'g' has been deleted/deallocated. <br><br>I'm yet to find a clean solution to this, so as things stand normal GC objects wont have dtors. <br><br></td></tr></table><br>
<a name="2102799"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW_</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  but one thing's for sure - monkey2 will have GC based on Monkey1's <br></div><br>I'm glad to hear this. Thanks for letting us know your thoughts on it. <br><br></td></tr></table><br>
<a name="2102798"></a>

<a name="2102810"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Danilo</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <b>marksibly wrote:</b><br>I'm yet to find a clean solution to this, so as things stand normal GC objects wont have dtors. <br></div><br>Maybe an alternative to automatic dtors could be to optionally register a clean-up function/method<br>within New. So the object manager / garbage collector knows what objects want to get informed<br>when they are dying.<br><pre class=code>Class Window
    Method New()
        GCregister(this, addressOf free())
    End
End</pre><br>I guess I'll just need to wait what you come up with. I still think importing and interfacing with (external) libraries<br>is one of the most important aspects, if you want to make MX2 a bit more generalized like BlitzMax.<br>The better and powerful the system is, the more useful add-on modules and lib imports will be made... ;)<br><br>Maybe Mike will write a new book about advanced MX2 topics...? <br><br></td></tr></table><br>
<a name="2102808"></a>

<a name="2102809"></a>

<a name="2102807"></a>

<a name="2102806"></a>

<a name="2102870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JaviCervera</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very enlightening posts, Mark. Thank you for your replies.<br><br>Actually, I already took the "avoid New" approach with a 3D rendering library I have written for Monkey (which is already finished, I will publish it as open source as soon as I write some documentation). The 3D math library relies on some cached objects to perform calculations, and no new vectors, quaternions, or matrices are created between frames. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
