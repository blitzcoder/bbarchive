<!DOCTYPE html><html lang="en" ><head ><title >tile collision</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >tile collision</h1><a href="forums.php" >BlitzPlus Forums</a>/<a href="topics.php?forum=95" >BlitzPlus Beginners Area</a>/<a href="#bottom" >tile collision</a><br><br>
<a name="676664"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >El Neil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi guys and girls.<br><br>i'm making a game where a ball bounces off some platforms and walls. these surfaces are made using a tile map. there are tiles for the four corners and each of the sides, so i can make boxes of any size or shape.<br><br>the ball is affected by gravity and im trying to make it bounce off the surfaces on collision. the problem is that the surfaces are only 10 pixels thick and the ball can travel up to 15 pixels in every game "tick". this means that sometimes the ball passes straight through the surface instead of colliding.<br><br>also, this means that sometimes the ball gets stuck in the surfaces. for example, if the ball bounces onto the floor and the collision is detected in the middle of the floor instead of the edge (because of the glitch), the line of code<br><br>yspeed = (0 - yspeed)<br><br>reverses the direction of travel, but because gravity is affecting the ball, it gets stuck.<br><br>is there a better way to approach all this?<br><br>el neil <br><br></td></tr></table><br>
<a name="676709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DjBigWorm</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had the same problem , I came up with a an idea. I have a low res screen and a pixel only to represent my palyer.  the pixel is able to move 1 pixel or 100 pixels.  and it is always stopped by only another pixel in the road.  The way I approache this was remember where my pixel is at the begining of the main loop.  Then, I figure out what direction I want to travel and count from the original location till i determined that another pixel was in the road.  To maybe simplify this the pixel is a an x loction of 10. I press the right key to travel x+5.  Once I know the I am gonna travel x+5. Another loop check for pixel color from my original location one at a time.  If no other colors were detected along the way then x+5 is applied to my x value.  Now say there is a white pixel in the way of my normal 5 movement speed.  Then when it got to the third pixel the loop would return a 3.  Making my pixel appear to be stopped by the solid wall no matter what speed I was going.<br>;Below might help you out.<br>.make a 320,240 image in black background and make obsticles  in a white color to see this in action.  play with the movement speed and it is always stopped with perfect collision detection:)  Maybe impracticle idea, but it works!!<br><br><br>Graphics 320,240<br>back=LoadImage ("testscreen.bmp")<br>xloc=10<br>yloc=20<br>speed=2 ; the speed that we will travel at<br>.main<br>Repeat<br>	time1 = MilliSecs() ;time at start of processing loop<br>	;start code here<br>DrawBlock back,0,0<br>;choose a random color<br><br>;draw our dot<br><br>currxloc=xloc  ; remember the old xlocation<br>curryloc=yloc<br>Gosub basic_controls<br><br>Color Rnd(255),Rnd(255),Rnd(255)<br>Plot xloc,yloc<br>;xloc is the new location<br>Text 0,0,"speed traveling="+(xloc-currxloc)<br><br>	Flip<br>	;this code must go at the very end of the loop<br>	time2 = MilliSecs() ;time at end of processing loop<br>	time3 = time2 - time1 ;number of miiliseconds to process loop<br>	time4 = fRate - time3 ;number of milliseconds to delay each processing loop to achieve dynamically accurate framerate<br>	If time4=&gt;0<br>		Delay time4 ;delay execution<br>	EndIf<br>Until KeyDown(1) ; escape<br>End<br><br>.basic_controls<br>If KeyDown(205) ;right key<br>If xloc&lt;320<br>xloc=xloc+speed<br>EndIf <br>EndIf <br><br>If KeyDown(203) ;left key<br>If xloc&gt;0<br>xloc=xloc-speed<br>EndIf <br>EndIf<br><br>Gosub checkx_floor<br><br><br><br>If KeyDown(200) ;up key<br>If yloc&gt;0<br>yloc=yloc-speed<br>EndIf <br>EndIf <br><br>If KeyDown(208) ;down key<br>If yloc&lt;240<br>yloc=yloc+speed<br>EndIf <br>EndIf<br>Gosub checky_floor<br>Return<br><br>.checkx_floor ; this goes pixel at at time and sees if we have collided with the floor<br>;check floor left and right<br>dir=xloc-currxloc ; dir is letting us know what dir we are going.<br>counter=0 ; reset the location traveled<br>If dir&gt;0 ; see if the location is positive if so then set the counter positive<br>	counter=1<br>	;Stop<br>EndIf<br>If dir&lt;0 ; see if the location is negative if so then set counter negative<br>	counter=-1<br>EndIf <br>	; check to see if we have changed x location<br>If counter&lt;&gt;0 ; if there was a change in the x location<br>	; starting from the old location count until we hit something or count past 10<br>	xstart=currxloc ; this is the start location of where we are<br>	leave=0<br>	ll=0<br>	Repeat<br>	;read the color<br>	GetColor xstart,yloc<br>If ColorRed ()=0 ; checks to see if we are on a color other than black<br>	okxlocation=xstart<br>	Else<br>	diff=(okxlocation-xloc)<br>	xloc=xloc+diff<br>	;Stop<br>	ll=1<br>EndIf<br>	xstart=xstart+counter ; add a value to where we are<br>	leave=leave+1<br>	Until ll=1 Or leave=speed+1; ll=1 means we are ok to leave the loop<br>EndIf <br>Return<br>.checky_floor<br>dir=yloc-curryloc ; dir is letting us know what dir we are going.<br>counter=0 ; reset the location traveled<br>If dir&gt;0 ; see if the location is positive if so then set the counter positive<br>	counter=1<br>EndIf<br>If dir&lt;0 ; see if the location is negative if so then set counter negative<br>	counter=-1<br>EndIf <br>	; check to see if we have changed x location<br>If counter&lt;&gt;0 ; if there was a change in the x location<br>	; starting from the old location count until we hit something or count past 10<br>	ystart=curryloc ; this is the start location of where we are<br>	leave=0<br>	ll=0<br>Repeat<br>	;read the color<br>	GetColor xloc,ystart<br>	If ColorRed ()=0 ; checks to see if we are on a color other than black<br>		okylocation=ystart<br>		Else<br>		diff=(okylocation-yloc)<br>		yloc=yloc+diff<br>		;Stop<br>		ll=1<br>	EndIf<br>	ystart=ystart+counter ; add a value to where we are<br>	leave=leave+1<br>	Until ll=1 Or leave=speed+1; ll=1 means we are ok to leave the loop<br>EndIf	<br>Return <br><br></td></tr></table><br>
<a name="676715"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> that approach of tracing a line is a good idea, plusI've seen a clever mathematical way to do the same thing before ...<br><br>Also you can increase your logic speed so ticks occur more frequently. <br><br></td></tr></table><br>
<a name="676730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >El Neil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> cheers worm. i had your idea in mind before i posted, but the main reason i didnt do it straight away was that if the ball was 1 pixel away from the wall and moving at a speed of 15 then it would appear to slow down before it bounced. also, as my game is tiled in a 20 x 20 grid and the tiles are objects of type "tile", i have to check each tile in turn for a collision on each loop. there are 4 possible collision directions (up, down, left, right) for each tile, so thats already 1600 possible checks on each loop happening already. adding more checks (ie between the ball and the tiles before i move the ball) would just complicate things. there must be a quiker way of doing it (no offence).<br><br>i dont know :(      i just wanna make some games.<br><br><br>whats the maths way of doing it then, alien?<br><br>thanks again worm. <br><br>neil <br><br></td></tr></table><br>
<a name="676910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> sorry I don't know.  I just know I saw it once.  try posting in the general forum and someone might answer.  Really it's to do with working out the line that the ball is travelling along (and speed) and where it intersects solid objects (using a foumula), plus also the time it hit can be worked out precisely. <br><br></td></tr></table><br>
<a name="677218"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andres</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
Function MoveBall(accuracy# = 1.0)
	Local Distance# = GetDistance(0, 0, BallXSpeed, BallYSpeed)
	Local Angle# = GetAngle(0, 0, BallXSpeed, BallYSpeed)
	For i# = 0 To Distance# Step 0
		BallX = BallX + Cos(Angle#) * Distance# * accuracy#
		BallY = BallY + Cos(Angle#) * Distance# * accuracy#
		i = i + Distance# * accuracy#
		If Collided() Then Return False
	Next
	Return True
End Function

Function GetAngle#(basex, basey, targetx, targety)
	If targety&gt;basey-1 Then
		angle=ACos((targetx-basex)/Sqr((targetx-basex)*(targetx-basex)+(targety-basey)*(targety-basey)))
	Else
		If targetx&gt;basex-1 Then
			angle=270+90-ACos((targetx-basex)/Sqr((targetx-basex)*(targetx-basex)+(targety-basey)*(targety-basey)))
		Else
			angle=360-ACos((targetx-basex)/Sqr((targetx-basex)*(targetx-basex)+(targety-basey)*(targety-basey)))
		EndIf
	EndIf

	If targetx=basex And targety=basey Then Return 0 Else Return angle
End Function

Function GetDistance#(x1#, y1#, x2#, y2#)
	Return Sqr((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
End Function
</pre><br><br>function MoveBall(accuracy#) will move the ball and return true if no collision was detected else will be returned false.<br>accuracy# values can be in range of 0 - 1<br>function Collided() is missing so you'll have to write it yourself though you should already have it. <br><br></td></tr></table><br>
<a name="677381"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >El Neil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> blimey. thank you very much. ive kind of "bodged" it already so it works enough for now, but ill keep your code in case my efforts don't do the job. i basically detected a collision and moved the ball to the edge of the surface manually before drawing it again, giving the illusion that it bounced. i have also limited the speed so the ball can't pass through the wall in one "tick". it should be enough to do what i want but i will probably need your code for next time.<br><br>thank you again andres,<br><br>neil <br><br></td></tr></table><br>
<a name="678002"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andres</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> The accuracy is actually inverted the smaller it is the more accurate it is. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
