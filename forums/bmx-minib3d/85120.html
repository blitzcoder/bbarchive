<!DOCTYPE html><html lang="en" ><head ><title >TurnEntity (Around Axis)</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >TurnEntity (Around Axis)</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=119" >MiniB3D Module</a>/<a href="#bottom" >TurnEntity (Around Axis)</a><br><br>
<a name="962358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>so I tried it myself, searched for it and tried it again, but I cannot figure out how I am able to acheive what I want.<br>The "local" Rotation is a real mess. In my opinion local means to rotate around the axis of an object. But thats not the case. Instead it rotates around the local Z axis, the global Y axis and an weird yaw-dependant X axis. <br>I know, it is like in B3D, i found that out so far, but can someone please help me to implement a _real_ local rotation?<br><br>I tried so far:<br><br>(Dirty code, I know)<br><pre class=code>
Import sidesign.minib3d

Graphics3D(640, 480)
Type rotater
	Field cone:TEntity
	Field axisX:TEntity
	Field axisY:TEntity
	Field axisZ:TEntity
	Method init()
		cone:TEntity = CreateCone()
		axisX:TEntity = CreateCylinder(8, 1, cone)
		ScaleEntity(axisX, 0.1, 3, 0.1)
		EntityColor(axisX, 255, 0, 0)
		RotateEntity(axisX, 0, 0, 90)
		
		axisY:TEntity = CreateCylinder(8, 1, cone)
		ScaleEntity(axisY, 0.1, 3, 0.1)
		EntityColor(axisY, 0, 255, 0)
		
		axisZ:TEntity = CreateCylinder(8, 1, cone)
		ScaleEntity(axisZ, 0.1, 3, 0.1)
		EntityColor(axisZ, 0, 0, 255)
		RotateEntity(axisZ, 90, 0, 0)
EndMethod
End Type

rot1:rotater = New rotater
rot1.init()
rot1.cone.PositionEntity(5, 0, 0)
rot1.cone.EntityColor(255, 255, 255)

rot2:rotater = New rotater
rot2.init()
rot2.cone.PositionEntity(- 5, 0, 0)
rot2.cone.EntityColor(150, 150, 150)


camera:TEntity = CreateCamera()
PositionEntity(camera, 0, 0, - 10)

'Wireframe(True)

While Not KeyHit(KEY_ESCAPE)
    Cls
    TurnEntityAroundAxis(rot1.cone, KeyDown(KEY_UP) - KeyDown(KEY_DOWN), KeyDown(KEY_LEFT) - KeyDown(KEY_RIGHT), KeyDown(KEY_PAGEUP) - KeyDown(KEY_PAGEDOWN))
    TurnEntity(rot2.cone, KeyDown(KEY_UP) - KeyDown(KEY_DOWN), KeyDown(KEY_LEFT) - KeyDown(KEY_RIGHT), KeyDown(KEY_PAGEUP) - KeyDown(KEY_PAGEDOWN))
    RenderWorld
    Flip
Wend
End

Function TurnEntityAroundAxis(pEntity:TEntity, Pitch:Float, Yaw:Float, Roll:Float)
    Local fPitch:Float = EntityPitch(pEntity) + Pitch * Cos(EntityRoll(pEntity))
    Local fYaw:Float = Yaw + EntityYaw(pEntity) + Pitch * Sin(EntityRoll(pEntity))
	DebugLog Sin(EntityRoll(pEntity))
    Local fRoll:Float = EntityRoll(pEntity) + Roll
	RotateEntity(pEntity, fPitch, fYaw, fRoll)
	
End Function
</pre><br><br>Since the Z - Axis is the only real local axis, my plan was to rotate the object around the others dependant from EntityRoll but I have to admit I did not get the concept behind the rotation function. <br>Then I looked up the source but hell I don't know no nothing about matrices :(<br><br>Is here anyone who can give me some advices to solve my problem?<br><br>greetings<br>FTC <br><br></td></tr></table><br>
<a name="962430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've just made these routines, they use Matrices and Quaternions for rotation. There is an internal function, called MQ_Turn, that rotates an entity around an axis:<br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2498" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2498</a><br>Hopefully they help you. <br><br></td></tr></table><br>
<a name="962594"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats great man! I really needed it. <br><br>THANKS!<br><br>greetings <br><br></td></tr></table><br>
<a name="962690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uhm there is a problem still... When using the code with collision the Object's rotation is resetted. EntityYaw2 etc are delivering correct values though and MoveEntity2 local does work as well, but the Mesh itself is stuck in an fixed rotation. I guess there it has something to do with the matrices.<br><br>greetings <br><br></td></tr></table><br>
<a name="962722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> do you mean that the collisions are happening to an entity as if it isnt rotated?<br><br>please provide code sample and model. <br><br></td></tr></table><br>
<a name="962737"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is possible that the code is not (fully) compatible with animated meshes? An example would be a good idea, since I only tested the code with standard CreateCube/CreateCone objects.<br><br>Maybe you could try this version of TEntity. UpdateMat is changed to read the new matrix, and all the original commands refer to their counterparts.<br>That could allready solve some of these issues, since for example TCollisions.bmx uses EntityX/Y/Z. Still, I would have to get further into it to be able to say more about it.<br><br>Note that the commands are wrapped in an ugly manner at this point. As I said, it's just experimental code so far, and I'm cautious when it comes down to building in anything before it is properly tested and working.<br><br>TEntity.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TEntity

	Global entity_list:TList=CreateList()

	Field child_list:TList=CreateList()

	Field parent:TEntity
	
	Field rotmat:TMatrix=TMatrix.Create()'rotation matrix
	Field mat:TMatrix=New TMatrix
	Field px#,py#,pz#,sx#=1.0,sy#=1.0,sz#=1.0,rx#,ry#,rz#,qw#,qx#,qy#,qz#
	
	Field name$
	Field class$
	Field hide=False
	Field order,alpha_order#
	Field auto_fade,fade_near#,fade_far#,fade_alpha#

	Field brush:TBrush=New TBrush
	
	Field cull_radius#
	
	Field radius_x#=1.0,radius_y#=1.0
	Field box_x#=-1.0,box_y#=-1.0,box_z#=-1.0,box_w#=2.0,box_h#=2.0,box_d#=2.0
	Field collision_type
	Field no_collisions,collision:TCollisionImpact[]
	Field pick_mode,obscurer

	Field anim ' true if mesh contains anim data
	Field anim_render ' true to render as anim mesh
	Field anim_mode
	Field anim_time#
	Field anim_speed#
	Field anim_seq
	Field anim_trans
	Field anim_dir=1 ' 1=forward, -1=backward
	Field anim_seqs_first[1]
	Field anim_seqs_last[1]
	Field no_seqs=0
	Field anim_update
	
	Global tformed_x#
	Global tformed_y#
	Global tformed_z#
	
	' used by TCollisions
	Field old_x#
	Field old_y#
	Field old_z#
		
	Field link:TLink ' entity_list tlink, stored for quick removal of entity from list ***note*** not currently used to remove entity from list

	Method CopyEntity:TEntity(parent_ent:TEntity=Null) Abstract
	Method Update() Abstract

	Method New()
	
		If LOG_NEW
			DebugLog "New TEntity"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TEntity"
		EndIf
	
	End Method

	Method FreeEntity()
	
		ListRemove(entity_list,Self)
	
		'RemoveLink link ' remove self from entity list - mem leak!
		
		' remove from collision entity lists
		If collision_type&lt;&gt;0 ListRemove(TCollisionPair.ent_lists[collision_type],Self)
		
		' remove from pick entity list
		If pick_mode&lt;&gt;0 ListRemove(TPick.ent_list,Self)
		
		Local ent:TEntity
		
		' free self from parent's child_list
		If parent&lt;&gt;Null
			For ent=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
		EndIf
		
		parent=Null
		mat=Null
		brush=Null
		link=Null
	
		' free children entities
		For ent=EachIn child_list
			ent.FreeEntity()
			ent=Null
		Next

	End Method

	' Entity movement

	Method PositionEntity(x#,y#,z#,glob=False)	
		PositionEntity2(Self, x,y,z, glob)
	End Method
		
	Method MoveEntity(mx#,my#,mz#)	
		MoveEntity2(Self, mx, my, mz)
	End Method

	Method TranslateEntity(tx#,ty#,tz#,glob=True)	
		MoveEntity2(Self, tx, ty, tz, glob)
	End Method
	
	Method ScaleEntity(x#,y#,z#,glob=False)	
		ScaleEntity2(Self, x, y, z, glob)
	End Method

	Method RotateEntity(x#,y#,z#,glob=False)	
		RotateEntity2(Self,x,y,z,glob)
	End Method

	Method TurnEntity(x#,y#,z#,glob=False)	
		TurnEntity2(Self, x, y, z, glob)
	End Method

	' Function by mongia2
	Method PointEntity(target_ent:TEntity,roll#=0)	
	
		Local x#=target_ent.EntityX#(True)
		Local y#=target_ent.EntityY#(True)
		Local z#=target_ent.EntityZ#(True)

		Local xdiff#=Self.EntityX(True)-x#
		Local ydiff#=Self.EntityY(True)-y#
		Local zdiff#=Self.EntityZ(True)-z#

		Local dist22#=Sqr((xdiff#*xdiff#)+(zdiff#*zdiff#))
		Local pitch#=ATan2(ydiff#,dist22#)
		Local yaw#=ATan2(xdiff#,-zdiff#)

		Self.RotateEntity pitch#,yaw#,roll#,True
		
	End Method
		
	' Entity animation

	' load anim seq - copies anim data from mesh to self
	Method LoadAnimSeq(file:String)
	
		If FileType(file)=0 Then Return 0
	
		' mesh that we will load anim seq from
		Local mesh:TMesh=TModel.LoadAnimB3D:TMesh(file)
		
		If anim=False Then Return 0 ' self contains no anim data
		If mesh.anim=False Then Return 0 ' mesh contains no anim data
	
		no_seqs=no_seqs+1
		
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' update anim_seqs array
		anim_seqs_first[no_seqs]=anim_seqs_last[0]
		anim_seqs_last[no_seqs]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		' update anim_seqs_last[0] - sequence 0 is for all frames, so this needs to be increased
		' must be done after updating anim_seqs array above
		anim_seqs_last[0]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		If mesh&lt;&gt;Null

			' go through all bones belonging to self
			For Local bone:TBone=EachIn TMesh(Self).bones
			
				' find bone in mesh that matches bone in self - search based on bone name
				Local mesh_bone:TBone=TBone(TEntity(mesh).FindChild(bone.name$))
			
				If mesh_bone&lt;&gt;Null
			
					' resize self arrays first so the one empty element at the end is removed
					bone.keys.flags=bone.keys.flags[..bone.keys.flags.length-1]
					bone.keys.px=bone.keys.px[..bone.keys.px.length-1]
					bone.keys.py=bone.keys.py[..bone.keys.py.length-1]
					bone.keys.pz=bone.keys.pz[..bone.keys.pz.length-1]
					bone.keys.sx=bone.keys.sx[..bone.keys.sx.length-1]
					bone.keys.sy=bone.keys.sy[..bone.keys.sy.length-1]
					bone.keys.sz=bone.keys.sz[..bone.keys.sz.length-1]
					bone.keys.qw=bone.keys.qw[..bone.keys.qw.length-1]
					bone.keys.qx=bone.keys.qx[..bone.keys.qx.length-1]
					bone.keys.qy=bone.keys.qy[..bone.keys.qy.length-1]
					bone.keys.qz=bone.keys.qz[..bone.keys.qz.length-1]
					
					' add mesh bone key arrays to self bone key arrays
					bone.keys.frames=anim_seqs_last[0]
					bone.keys.flags=bone.keys.flags+mesh_bone.keys.flags
					bone.keys.px=bone.keys.px+mesh_bone.keys.px
					bone.keys.py=bone.keys.py+mesh_bone.keys.py
					bone.keys.pz=bone.keys.pz+mesh_bone.keys.pz
					bone.keys.sx=bone.keys.sx+mesh_bone.keys.sx
					bone.keys.sy=bone.keys.sy+mesh_bone.keys.sy
					bone.keys.sz=bone.keys.sz+mesh_bone.keys.sz
					bone.keys.qw=bone.keys.qw+mesh_bone.keys.qw
					bone.keys.qx=bone.keys.qx+mesh_bone.keys.qx
					bone.keys.qy=bone.keys.qy+mesh_bone.keys.qy
					bone.keys.qz=bone.keys.qz+mesh_bone.keys.qz
				
				EndIf
				
			Next
				
		EndIf
		
		mesh.FreeEntity()
		
		Return no_seqs
	
	End Method
	
	Method ExtractAnimSeq(first_frame,last_frame,seq=0)
	
		no_seqs=no_seqs+1
	
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' if seq specifed then extract anim sequence from within existing sequnce
		Local offset=0
		If seq&lt;&gt;0
			offset=anim_seqs_first[seq]
		EndIf
	
		anim_seqs_first[no_seqs]=first_frame+offset
		anim_seqs_last[no_seqs]=last_frame+offset
		
		Return no_seqs
	
	End Method

	Method Animate(mode=1,speed#=1.0,seq=0,trans=0)
	
		anim_mode=mode
		anim_speed#=speed#
		anim_seq=seq
		anim_trans=trans
		anim_time#=anim_seqs_first[seq]
		anim_update=True ' update anim for all modes (including 0)
		
		If trans&gt;0
			anim_time#=0
		EndIf
		
	End Method
	
	' Updates:
	' 30/01/06 - updated to make anim_time return wrapped value
	Method SetAnimTime(time#,seq=0)
	
		anim_mode=-1 ' use a mode of -1 for setanimtime
		anim_speed#=0
		anim_seq=seq
		anim_trans=0
		anim_time#=time#
		anim_update=False ' set anim_update to false so UpdateWorld won't animate entity

		Local first=anim_seqs_first[anim_seq]
		Local last=anim_seqs_last[anim_seq]
		Local first2last=anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq]
		
		time#=time#+first ' offset time so that anim time of 0 will equal first frame of sequence
		
		If time#&gt;last And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#-first2last
			Until time#&lt;=last
		EndIf
		If time#&lt;first And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#+first2last
			Until time#&gt;=first
		EndIf
		
		TAnimation.AnimateMesh(Self,time#,first,last)

		anim_time#=time# ' update anim_time# to equal time#

	End Method
	
	Method AnimSeq()
	
		Return anim_seq ' current anim sequence
	
	End Method
	
	Method AnimLength()
	
		Return anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq] ' no of frames in anim sequence
	
	End Method

	Method AnimTime#()
	
		' if animation in transition, return 0 (anim_time actually will be somewhere between 0 and 1)
		If anim_trans&gt;0 Then Return 0
		
		' for animate and setanimtime we want to return anim_time starting from 0 and ending at no. of frames in sequence
		If anim_mode&gt;0 Or anim_mode=-1
			Return anim_time#-anim_seqs_first[anim_seq]
		EndIf

		Return 0

	End Method
	
	Method Animating()
	
		If anim_trans&gt;0 Then Return True
		If anim_mode&gt;0 Then Return True
		
		Return False
	
	End Method
		
	' Entity control

	Method EntityColor(r#,g#,b#)
	
		brush.red  =r#/255.0
		brush.green=g#/255.0
		brush.blue =b#/255.0
	
	End Method

	Method EntityAlpha(a#)
	
		brush.alpha=a#
			
	End Method
	
	Method EntityShininess(s#)
	
		brush.shine=s#
	
	End Method

	Method EntityTexture(texture:TTexture,frame=0,index=0)

		brush.tex[index]=texture
		If index+1&gt;brush.no_texs Then brush.no_texs=index+1
		
		If frame&lt;0 Then frame=0
		If frame&gt;texture.no_frames-1 Then frame=texture.no_frames-1 
		brush.tex_frame=frame
	
	End Method
	
	Method EntityBlend(blend_no)
	
		brush.blend=blend_no
		
		If TMesh(Self)&lt;&gt;Null
		
			' overwrite surface blend modes with master blend mode
			For Local surf:TSurface=EachIn TMesh(Self).surf_list
				If surf.brush&lt;&gt;Null
					surf.brush.blend=brush.blend
				EndIf
			Next
			
		EndIf
		
	End Method
	
	Method EntityFX(fx_no)
	
		brush.fx=fx_no
		
	End Method
	
	Method EntityAutoFade(near#,far#)
	
		auto_fade=True
		fade_near=near#
		fade_far=far#
	
	End Method
	
	Method PaintEntity(bru:TBrush)
	
		brush.no_texs=bru.no_texs
		brush.name$=bru.name$
		brush.red#=bru.red#
		brush.green#=bru.green#
		brush.blue#=bru.blue#
		brush.alpha#=bru.alpha#
		brush.shine#=bru.shine#
		brush.blend=bru.blend
		brush.fx=bru.fx
		For Local i=0 To 7
			brush.tex[i]=bru.tex[i]
		Next
	
	End Method
	
	Method EntityOrder(order_no)
	
		order=order_no

		If TCamera(Self)&lt;&gt;Null
			ListRemove(TCamera.cam_list,Self)
			EntityListAdd(TCamera.cam_list)
		EndIf

	End Method
	
	Method ShowEntity()
	
		hide=False
		
	End Method

	Method HideEntity()

		hide=True

	End Method

	Method Hidden()
	
		If hide=True Return True
		
		Local ent:TEntity=parent
		While ent&lt;&gt;Null
			If ent.hide=True Return True
			ent=ent.parent
		Wend
		
		Return False
	
	End Method

	Method NameEntity(e_name$)
	
		name$=e_name$
	
	End Method
	
	Method EntityParent(parent_ent:TEntity,glob=True)	
		EntityParent2(Self, parent_ent, glob)
	End Method
		
	Method GetParent:TEntity()			
		Return parent	
	End Method

	' Entity state

	Method EntityX#(glob=False)	
		Return EntityX2(Self, glob)
	End Method
	
	Method EntityY#(glob=False)
		Return EntityY2(Self, glob)
	End Method
	
	Method EntityZ#(glob=False)
		Return EntityZ2(Self, glob)	
	End Method

	Method EntityPitch#(glob=False)	
		Return EntityPitch2(Self, glob)
	End Method
	
	Method EntityYaw#(glob=False)	
		Return EntityYaw2(Self, glob)
	End Method
	
	Method EntityRoll#(glob=False)	
		Return EntityRoll2(Self, glob)
	End Method
	
	Method EntityClass$()
		
		Return class$
		
	End Method
	
	Method EntityName$()
		
		Return name$
		
	End Method
	
	Method CountChildren()

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1

		Next

		Return no_children

	End Method
	
	Method GetChild:TEntity(child_no)
	
		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1
			If no_children=child_no Return ent

		Next

		Return Null
	
	End Method
	
	Method FindChild:TEntity(child_name$)
	
		Local cent:TEntity
	
		For Local ent:TEntity=EachIn child_list

			If ent.EntityName$()=child_name$ Return ent

			cent=ent.FindChild(child_name$)
			
			If cent&lt;&gt;Null Return cent
	
		Next

		Return Null
	
	End Method
	
	' Calls function in TPick
	Method EntityPick:TEntity(range#)
	
		Return TPick.EntityPick:TEntity(Self,range#)
	
	End Method
	
	' Calls function in TPick
	Method LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
		Return TPick.LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
	End Method
	
	' Calls function in TPick
	Method EntityVisible(src_entity:TEntity,dest_entity:TEntity)
	
		Return TPick.EntityVisible(src_entity,dest_entity)
	
	End Method
	
	Method EntityDistance#(ent2:TEntity)

		Return Sqr(Self.EntityDistanceSquared#(ent2))

	End Method
	
	' Function by Vertex
	Method DeltaYaw#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		'Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
		
		Return -ATan2(x#,z#)

	End Method
	
	' Function by Vertex
	Method DeltaPitch#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
	
		Return -ATan2(y#,Sqr(x#*x#+z#*z#))
	
	End Method
	
	Function TFormPoint(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)		
		TFormPoint2 x,y,z,src_ent,dest_ent
		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
	End Function

	Function TFormVector(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		TFormVector2 x,y,z,src_ent,dest_ent
		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
	End Function

	Function TFormNormal(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		TFormNormal2(x,y,z,src_ent,dest_ent)
		tformed_x#=x
		tformed_y#=y
		tformed_z#=z
	End Function
	
	Function TFormedX#()
	
		Return tformed_x#
	
	End Function
	
	Function TFormedY#()
	
		Return tformed_y#
	
	End Function
	
	Function TFormedZ#()
	
		Return tformed_z#
	
	End Function
	
	Method GetMatElement#(row,col)
	
		Return mat.grid[row,col]
	
	End Method
	
	' Entity collision
	
	Method ResetEntity()
	
		no_collisions=0
		collision=collision[..0]
		old_x=EntityX(True)
		old_y=EntityY(True)
		old_z=EntityZ(True)
	
	End Method
	
	Method EntityRadius(rx#,ry#=0.0)
	
		radius_x#=rx#
		If ry#=0.0 Then radius_y#=rx# Else radius_y#=ry#
	
	End Method
	
	Method EntityBox(x#,y#,z#,w#,h#,d#)
	
		box_x#=x#
		box_y#=y#
		box_z#=z#
		box_w#=w#
		box_h#=h#
		box_d#=d#
	
	End Method

	Method EntityType(type_no,recursive=False)
	
		' add to collision entity list if new type no&lt;&gt;0 and not previously added
		If collision_type=0 And type_no&lt;&gt;0
		
			If TCollisionPair.ent_lists[type_no]=Null Then TCollisionPair.ent_lists[type_no]=CreateList() ' create new list is one doesn't exist
			
			ListAddLast(TCollisionPair.ent_lists[type_no],Self)
			
		EndIf
		
		' remove from collision entity list if new type no=0 and previously added
		If collision_type&lt;&gt;0 And type_no=0
			ListRemove(TCollisionPair.ent_lists[type_no],Self)
		EndIf
		
		collision_type=type_no
		
		old_x#=EntityX(True)
		old_y#=EntityY(True)
		old_z#=EntityZ(True)
	
		If recursive=True
		
			For Local ent:TEntity=EachIn child_list
			
				ent.EntityType(type_no,True)
			
			Next
		
		EndIf
		
	End Method
	
	Method EntityPickMode(no,obscure=True)
	
		' add to pick entity list if new mode no&lt;&gt;0 and not previously added
		If pick_mode=0 And no&lt;&gt;0
			ListAddLast(TPick.ent_list,Self)
		EndIf
		
		' remove from pick entity list if new mode no=0 and previously added
		If pick_mode&lt;&gt;0 And no=0
			ListRemove(TPick.ent_list,Self)
		EndIf
	
		pick_mode=no
		obscurer=obscure
			
	End Method
	
	Method EntityCollided:TEntity(type_no)

		' if self is source entity and type_no is dest entity
		For Local i=1 To CountCollisions()
			If CollisionEntity(i).collision_type=type_no Then Return CollisionEntity(i)
		Next

		' if self is dest entity and type_no is src entity
		For Local ent:TEntity=EachIn TCollisionPair.ent_lists[type_no]
			For Local i=1 To ent.CountCollisions()
				If CollisionEntity(i)=Self Then Return ent		
			Next
		Next

		Return Null

	End Method
	
	Method CountCollisions()
	
		Return no_collisions
	
	End Method
	
	Method CollisionX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].x#
		
		EndIf
	
	End Method
	
	Method CollisionY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].y#
		
		EndIf
	
	End Method
	
	Method CollisionZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].z#
		
		EndIf
	
	End Method

	Method CollisionNX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nx#
		
		EndIf
	
	End Method
	
	Method CollisionNY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ny#
		
		EndIf
	
	End Method
	
	Method CollisionNZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nz#
		
		EndIf
	
	End Method
	
	Method CollisionTime#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].time#
		
		EndIf
	
	End Method
	
	Method CollisionEntity:TEntity(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ent
		
		EndIf
	
	End Method
	
	Method CollisionSurface:TSurface(index)
	
		If index&gt;0 And index&lt;=no_collisions

			Return collision[index-1].surf
		
		EndIf
	
	End Method
	
	Method CollisionTriangle(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].tri
		
		EndIf
	
	End Method
	
	Method GetEntityType()

		Return collision_type

	End Method
	
	' Sets an entity's mesh cull radius
	Method MeshCullRadius(radius#)
	
		' set to negative no. so we know when user has set cull radius (manual cull)
		' a check in TMesh.GetBounds then prevents negative no. being overwritten by a positive cull radius (auto cull)
		cull_radius#=-radius#
	
	End Method
	
	Method EntityScaleX#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return w
	End Method
	
	Method EntityScaleY#(glob=False)
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return h
	End Method
	
	Method EntityScaleZ#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return d
	End Method

	' Returns an entity's bounding sphere
	Method BoundingSphereNew(sx# Var,sy# Var,sz# Var,sr# Var)

		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=tformed_x
			y=tformed_y
			z=tformed_z
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		sx=x
		sy=y
		sz=z
		sr=radius

	End Method
	
	Function CountAllChildren(ent:TEntity,no_children=0)
		
		Local ent2:TEntity
	
		For ent2=EachIn ent.child_list

			no_children=no_children+1
			
			no_children=TEntity.CountAllChildren(ent2,no_children)

		Next

		Return no_children

	End Function
	
	Method GetChildFromAll:TEntity(child_no,no_children Var,ent:TEntity=Null)

		If ent=Null Then ent=Self
		
		Local ent3:TEntity=Null
		
		For Local ent2:TEntity=EachIn ent.child_list

			no_children=no_children+1
			
			If no_children=child_no Then Return ent2
			
			If ent3=Null
			
				ent3=GetChildFromAll(child_no,no_children,ent2)

			EndIf

		Next

		Return ent3
			
	End Method
	
	' Internal - not recommended for general use

	Method UpdateMat(load_identity=False)	
		mat.Overwrite(MQ_GetMatrix())
	End Method
	
	Method AddParent(parent_ent:TEntity)
	
		' self.parent = parent_ent
		parent:TEntity=parent_ent
		
		' add self to parent_ent child list
		If parent&lt;&gt;Null

			mat.Overwrite(parent.mat)
		
			ListAddLast(parent.child_list,Self)
		
		EndIf
		
	End Method
	
	Function UpdateChildren(ent_p:TEntity)
	
		For Local ent_c:TEntity=EachIn ent_p.child_list

			ent_c.mat.Overwrite(ent_p.mat)
			ent_c.UpdateMat()
				
			UpdateChildren(ent_c:TEntity)
			
		Next
	
	End Function

	' unoptimised, unused
	Method EntityDistanceSquared0#(ent2:TEntity)

		Local xd# = ent2.EntityX#(True)-EntityX#(True)
		Local yd# = ent2.EntityY#(True)-EntityY#(True)
		Local zd# = ent2.EntityZ#(True)-EntityZ#(True)
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method
	
	' optimised
	Method EntityDistanceSquared#(ent2:TEntity)

		Local xd# = ent2.mat.grid[3,0]-mat.grid[3,0]
		Local yd# = ent2.mat.grid[3,1]-mat.grid[3,1]
		Local zd# = -ent2.mat.grid[3,2]+mat.grid[3,2]
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method

	Method EntityListAdd(list:TList)
	
		' if order&gt;0, drawn first
		' if order&lt;0, drawn last
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=order Or TEntity(llink.Value()).order&lt;=0
	
			link=list.InsertBeforeLink(Self,llink)
			Return
	
		Else ' put entities with order=0 at back of list, so cameras with order=0 are sorted the same as in B3D

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=order Or TEntity(llink.Value()).order&gt;=0
	
			link=list.InsertAfterLink(Self,llink)
			Return

		EndIf

	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											BEGIN MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------

	'returns copy of rotation matrix	
	Method MQ_CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = rotmat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method
	
	'turn entity
	Method MQ_Rotate( pitch#, yaw#, roll#, glob=False )

		Local q1_x#, q1_y#, q1_z#, q1_w#
		Local q2_x#, q2_y#, q2_z#, q2_w#
		Local q3_x#, q3_y#, q3_z#, q3_w#
		Local m1:TMatrix = TMatrix.Create()
		Local m2:TMatrix = TMatrix.Create()
				
		Quaternion_FromAngleAxis( -pitch, 1, 0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
		Quaternion_FromAngleAxis(  yaw,   0, 1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
		Quaternion_FromAngleAxis(  roll,  0, 0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
		
		'convert to matrices	
		m1.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
		m2.FromQuaternion(q2_x, q2_y, q2_z, q2_w)
		
		'apply
		rotmat.FromQuaternion(q3_x, q3_y, q3_z, q3_w) 'roll
		rotmat.Multiply2(m1) 'pitch
		rotmat.Multiply2(m2) 'yaw
		
		If glob Then
			'get parent inverted rotation matrix
			If parent &lt;&gt; Null Then
				m2:TMatrix = parent.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
				'apply rotation matrix
				rotmat.Multiply2(m2)
			End If
		End If
		
	End Method
	
	'turn entity
	Method MQ_Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then		
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method MQ_TransformPoint( ix# Var,iy# Var,iz# Var)
		
		rotmat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method MQ_Position( qx#,qy#,qz#, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then TFormPoint2(qx, qy, qz, Null, parent)
		End If
		
		px = qx
		py = qy
		pz = qz

	End Method

	'move an entity
	Method MQ_Move( qx#,qy#,qz# )
	
		MQ_TransformPoint(qx,qy,qz) 'transform point by internal matrix
		px = px + qx 'add to position
		py = py + qy
		pz = pz + qz
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat0:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat0 = parent.MQ_GetInvMatrix(scale)
		Else
			mat0 = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = MQ_CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-px,-py,-pz)
		
		'combine
		mat1.Multiply2(mat3)
		mat2.Multiply2(mat1)
		mat0.Multiply2(mat2)
		
		Return mat0
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
	
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(px, py, pz)		
		'rotation
		mat1:TMatrix = rotmat.Copy()

		mat3.Multiply2(mat1)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat3.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat3
		
	End Method

	'update attached entity
	Method MQ_Update()
	
		Local e:TEntity

		'get matrix transformed by parents
		mat.Overwrite(MQ_GetMatrix())
						
		'update child_list		
		For e:TEntity = EachIn child_list
			e.MQ_Update
		Next

	End Method

	'set scaling for an entity
	Method MQ_Scale( w#, h#, d#, glob )
	
		Local xx#,yy#,zz#
		Local ll#

		If glob Then
			If h &lt;&gt; 0 Then
				xx = 0
				yy = 1 / h
				zz = 0
				TFormVector2 xx, yy, zz, Self, Null
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then h = 1 / ll
			End If
	
			If w &lt;&gt; 0 Then
				xx = 1 / w
				yy = 0
				zz = 0
				TFormVector2 xx, yy, zz, Self, Null
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then w = 1 / ll
			End If
				
			If d &lt;&gt; 0 Then
				xx = 0
				yy = 0
				zz = 1 / w
				TFormVector2 xx, yy, zz, Self, Null
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then d = 1 / ll
			End If
		End If

		sx = w
		sy = h
		sz = d

	End Method


	'set an entity's parent	
	Method MQ_SetParent(e:TEntity, glob)
	
		Local orgx#,orgy#,orgz#
		Local orgw#,orgh#,orgd#
		Local neww#,newh#,newd#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			orgx# = 0
			orgy# = 0
			orgz# = 0
			TFormPoint2(orgx, orgy, orgz, Self, Null)
			m1:TMatrix = MQ_GetMatrix(False)
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
			'get scaling
			MQ_GetScaleXYZ(orgw#,orgh#,orgd#)
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.child_list, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then TFormPoint2(orgx, orgy, orgz, Null, e)
			'set position
			px = orgx
			py = orgy
			pz = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			m1.Multiply2(m2)
			rotmat.Overwrite(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.child_list, Self

		'get scaling
		MQ_GetScaleXYZ(neww#,newh#,newd#)
		If neww &lt;&gt; 0 Then sx = sx * orgw / neww
		If newh &lt;&gt; 0 Then sy = sy * orgh / newh
		If newd &lt;&gt; 0 Then sz = sz * orgd / newd
	
	End Method

	'get entity scale	
	Method MQ_GetScaleXYZ(width# Var, height# Var, depth# Var, glob=True)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		If glob Then 
			m:TMatrix = MQ_GetMatrix()
		Else
			m:TMatrix = TMatrix.Create()
			m.Scale(sx, sy, sz)
		End If
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											END MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------
End Type


'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:TEntity, x#, y#, z#, glob=False )

	If e = Null Then Return
	
	e.MQ_Position( x, y, z, glob )
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:TEntity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	pitch = -pitch
	
	If pitch# &lt;&gt; 0 Then e.MQ_Turn(pitch, 1, 0, 0, glob)
	If yaw#   &lt;&gt; 0 Then e.MQ_Turn(yaw,   0, 1, 0, glob)
	If roll#  &lt;&gt; 0 Then e.MQ_Turn(roll,  0, 0, 1, glob)
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:TEntity, x#, y#, z#, glob=False)

	If e = Null Then Return
	z=-z	

	If glob Then
		TFormVector2(x, y, z, Null, e)
	End If
	
	e.MQ_Move( x, y, z )
	e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:TEntity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	
	e.MQ_Rotate(pitch, yaw, roll, glob)
	e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:TEntity, e2:TEntity, glob=True)

	If e = Null Then Return

	e.MQ_SetParent(e2, glob)	
	If e2 &lt;&gt; Null Then e2.MQ_Update() Else e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:TEntity, sx#, sy#, sz#, glob=False)

	If e = Null Then Return
	e.MQ_Scale(sx, sy, sz, glob)
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	Local mat1:TMatrix
	Local mat2:TMatrix
	
	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.MQ_GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.MQ_GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormVector2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	Local mat1:TMatrix
	Local mat2:TMatrix 

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.MQ_GetMatrix()
		mat1.grid[3,0] = 0 'remove translation
		mat1.grid[3,1] = 0
		mat1.grid[3,2] = 0
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.MQ_GetInvMatrix()		
		mat2.grid[3,0] = 0 'remove translation
		mat2.grid[3,1] = 0
		mat2.grid[3,2] = 0
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormNormal2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormNormal2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	TFormVector2(x,y,z,src,dst)
	Local dd# = Magnitude(x,y,z)
	If dd &lt;&gt; 0 Then
		x=x/dd
		y=y/dd
		z=z/dd
	End If
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityPitch2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityPitch2#(e:TEntity, glob=False)
	If glob Then
		'use global matrix
		Return e.MQ_GetMatrix(False).GetPitch()
	Else
		'use local matrix
		Return e.rotmat.GetPitch()
	End If
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityYaw2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityYaw2#(e:TEntity, glob=False)
	If glob Then
		'use global matrix
		Return e.MQ_GetMatrix(False).GetYaw()
	Else
		'use local matrix
		Return e.rotmat.GetYaw()
	End If
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityRoll2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityRoll2#(e:TEntity, glob=False)
	If glob Then
		'use global matrix
		Return e.MQ_GetMatrix(False).GetRoll()
	Else
		'use local matrix
		Return e.rotmat.GetRoll()
	End If
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											PointEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
'function by mongia2
Function PointEntity2(e:TEntity, e2:TEntity, roll#=0)

	Local ax# = e.px - e2.px
	Local ay# = e.py - e2.py
	Local az# = e.pz - e2.pz

	Local dist22#=Sqr((ax#*ax#)+(az#*az#))
	Local pitch#=ATan2(ay#,dist22#)
	Local yaw#=ATan2(ax#,az#)
	
	RotateEntity2 e, pitch, yaw, 0, True
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											AlignToVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function AlignToVector2(e:TEntity, x#, y#, z#, ang=3)

		Local ax#,ay#,az#
		Local cx#,cy#,cz#
		Local d#,sn#,s#,inverse#
		Local qx#,qy#,qz#,qw#
		Local m:TMatrix
		
		x=-x
		
		' Based on the Axiom engine's Vector3.GetRotationTo method code
		' Which is in turn based on Stan Melax's article in Game Programming Gems
		
		ax# = (ang=1) 'select axis
		ay# = (ang=2)
		az# = (ang=3)
	 
		'Local c:Vector3 = v0.Cross( v1 )
		cx# = y*az - z*ay
		cy# = x*az - z*ax
		cz# = x*ay - y*ax

		'Local d:Double = v0.Dot( v1 )
		d# = x*ax+y*ay+z*az		
		If d &gt;= 1.0 Then 
			qx = 0
			qy = 0
			qz = 0
			qw = 1
		ElseIf d &lt;= -1.0 Then			
			sn# = Sin( 90 ) '=180 degrees turn
			qw# = Cos( 90 )
			qx# = sn * (ang = 3) 'inverted axis
			qy# = sn * (ang = 2)
			qz# = sn * (ang = 1)
		Else	 	
			s# = Sqr( ( 1+d ) * 2 )
			If s &lt;&gt; 0 Then
				inverse# = 1.0 / s 
			Else
				inverse# = 1.0
			End If
			qx = cx * inverse
			qy = cy * inverse
			qz = cz * inverse
			qw = s * 0.5
		End If
		
		m = TMatrix.Create()
		m.FromQuaternion(qx#,qy#,qz#,qw#)		
		e.rotmat.Overwrite(m)
		
		'make global
		If e.parent &lt;&gt; Null Then
			m:TMatrix = e.parent.MQ_GetInvMatrix(False)
			m.grid[3,0] = 0 'remove translation
			m.grid[3,1] = 0
			m.grid[3,2] = 0
			'apply rotation matrix
			e.rotmat.Multiply2(m)
		End If

		'apply
		e.MQ_Update()
	 		
End Function

Function EntityX2#(e:TEntity,glob=False)
	If glob Then
		Return e.MQ_GetMatrix().grid[3,0]
	Else
		Return e.px
	End If
End Function

Function EntityY2#(e:TEntity,glob=False)
	If glob Then
		Return e.MQ_GetMatrix().grid[3,1]
	Else
		Return e.py
	End If
End Function

Function EntityZ2#(e:TEntity,glob=False)
	If glob Then
		Return e.MQ_GetMatrix().grid[3,2]
	Else
		Return e.pz
	End If
End Function
</textarea> <br><br></td></tr></table><br>
<a name="962744"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Blitz3d didnt support animated mesh collision, the collisions happened to the original mesh with no animation. <br><br></td></tr></table><br>
<a name="963464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, I looked into it and I saw indeed there was a problem with collisions. Now I've posted an update that I have tested with the minib3d samples/demo's. So collisions should be working properly now. <br><br></td></tr></table><br>
<a name="963530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I created a sample of my problem:<br><a href="http://www.freetimestudio.de/col_test.zip" target="_blank">http://www.freetimestudio.de/col_test.zip</a><br>I do not want it to be animated, but LoadAnimMesh solves a few Renderingproblems Minib3d has.<br>It uses the old version. With the new version however it does not render anything...<br><br>greetings <br><br></td></tr></table><br>
<a name="963532"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's very nice, thanks. I don't have the older version anymore, but I tried the .exe you compiled, and it does indeed work incorrectly. When I tried the latest version, it then works correct, and renders.<br>Try my .exe:<br><a href="http://abcbasic.comyr.com/col_test.zip" target="_blank">http://abcbasic.comyr.com/col_test.zip</a> <br><br></td></tr></table><br>
<a name="963615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know whats wrong :( Even with the latest version I have nothing displayed. But the programm does not crash (I use Debuglog to find out that)<br><br>greetings <br><br></td></tr></table><br>
<a name="963621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> But the .exe I compiled, does it work? <br><br></td></tr></table><br>
<a name="963624"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, I know what it is .. My fault, sorry :/ stupid, I forgot to add UpdateEntities(). You can call it manually before using RenderWorld(), but it should be built-in. The reason I forgot that, is that RenderWorld is part of TGlobal.<br>In TGlobal.bmx, in the Function RenderWorld, add the line: UpdateEntities(). Example here:<br><br>TGlobal.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TGlobal

	Global width,height,mode,depth,rate
	Global ambient_red#=0.5,ambient_green#=0.5,ambient_blue#=0.5

	Global vbo_enabled=False ' this is set in GraphicsInit - will be set to true if USE_VBO is true and the hardware supports vbos

	' anti aliasing globs
	Global aa ' anti_alias true/false
	Global ACSIZE ' accum size
	Global jitter
	Global j#[16,2]

	Function Graphics3D(w,h,d=0,m=0,r=60)

		'mode:
		'0: windowed in debug mode, fullscreen in non-debug mode 
		'1: full-screen always 
		'2: windowed always 

		' change depth values so that Graphics will behave in the same way as Blitz3D-style Graphics3D
		Select m
			Case 0
				?debug
					d=0
				?
				?Not debug
					If d=0 Then d=16
				?
			Case 1
				If d=0 Then d=16
			Case 2
				d=0		
			Default
				d=0		
		End Select
			
		width=w
		height=h
		depth=d
		mode=m
		rate=r
		
		SetGraphicsDriver(GLMax2DDriver()) 
		Graphics(width,height,depth,rate,GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER|GRAPHICS_ACCUMBUFFER)

		GraphicsInit()
								
	End Function

	Function AntiAlias(samples)

		aa=True

		If samples=False Then aa=0;Return
		
		Select samples
			Case 1 RestoreData j2; ACSIZE=2
			Case 2 RestoreData j2; ACSIZE=2
			Case 3 RestoreData j3; ACSIZE=3
			Case 4 RestoreData j4; ACSIZE=4
			Case 5 RestoreData j5; ACSIZE=5
			Case 6 RestoreData j6; ACSIZE=6
			Case 8 RestoreData j8; ACSIZE=8
			Case 9 RestoreData j9; ACSIZE=9
			Case 12 RestoreData j12; ACSIZE=12
			Case 16 RestoreData j16; ACSIZE=16
			Default aa=False; ACSIZE=0; Return
		End Select

		For Local i=0 Until samples
		
			ReadData j[i,0],j[i,1]
		
		Next

	End Function
	
	Function Wireframe(enable)
	
		If enable
			glPolygonMode(GL_FRONT,GL_LINE)
		Else
			glPolygonMode(GL_FRONT,GL_FILL)
		EndIf

	End Function
	
	Function AmbientLight(r#,g#,b#)
	
		ambient_red#=r#/255.0
		ambient_green#=g#/255.0
		ambient_blue#=b#/255.0
	
	End Function
	
	Function ClearCollisions()
	
		For Local col:TCollisionPair=EachIn TCollisionPair.list
			col=Null
		Next

	End Function

	Function Collisions(src_no,dest_no,method_no,response_no=0)
	
		Local col:TCollisionPair=New TCollisionPair
		col.src_type=src_no
		col.des_type=dest_no
		col.col_method=method_no
		col.response=response_no
		
		' check to see if same collision pair already exists
		For Local col2:TCollisionPair=EachIn TCollisionPair.list
			If col2.src_type=col.src_type
				If col2.des_type=col.des_type
					
					' overwrite old method and response values
					col2.col_method=col.col_method
					col2.response=col.response

					Return

				EndIf
			EndIf
		Next
		
		ListAddLast(TCollisionPair.list,col)
	
	End Function
	
	Function ClearWorld(entities=True,brushes=True,textures=True)
	
		If entities
			
			For Local ent:TEntity=EachIn TEntity.entity_list
				ent.FreeEntity()
				ent=Null
			Next
			
			ClearCollisions
			
			ClearList(TPick.ent_list)
			TPick.picked_ent=Null
			TPick.picked_surface=Null
			
		EndIf
		
		If textures
		
			For Local tex:TTexture=EachIn TTexture.tex_list
				tex.FreeTexture()
			Next
		
		EndIf
	
	End Function
			
	Function UpdateWorld(anim_speed#=1.0)
		
		' collision
		
		UpdateCollisions()
		
		' anim
	
		Local first
		Local last

		For Local mesh:TEntity=EachIn TEntity.entity_list
		
			If mesh.anim And mesh.anim_update=True
			
				first=mesh.anim_seqs_first[mesh.anim_seq]
				last=mesh.anim_seqs_last[mesh.anim_seq]
		
				Local anim_start=False

				If mesh.anim_trans&gt;0
					mesh.anim_trans=mesh.anim_trans-1
					If mesh.anim_trans=1 Then anim_start=True
				EndIf
				
				If mesh.anim_trans&gt;0
				
					Local r#=1.0-mesh.anim_time#
					r#=r#/mesh.anim_trans
					mesh.anim_time#=mesh.anim_time+r#
									
					TAnimation.AnimateMesh2(mesh,mesh.anim_time#,first,last)
					
					If anim_start=True Then mesh.anim_time#=first
			
				Else
				
					TAnimation.AnimateMesh(mesh,mesh.anim_time#,first,last)
					
					If mesh.anim_mode=0 Then mesh.anim_update=False ' after updating animation so that animation is in final 'stop' pose - don't update again
		
					If mesh.anim_mode=1
			
						mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
						If mesh.anim_time#&gt;last
							mesh.anim_time#=first+(mesh.anim_time#-last)
						EndIf
					
					EndIf
					
					If mesh.anim_mode=2
					
						If mesh.anim_dir=1
							mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
							If mesh.anim_time#&gt;last
								mesh.anim_time#=mesh.anim_time#-(mesh.anim_speed#*anim_speed#)
								mesh.anim_dir=-1
							EndIf
						EndIf
						
						If mesh.anim_dir=-1
							mesh.anim_time#=mesh.anim_time#-(mesh.anim_speed#*anim_speed#)
							If mesh.anim_time#&lt;first
								mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
								mesh.anim_dir=1
							EndIf
						EndIf
					
					EndIf
					
					If mesh.anim_mode=3
			
						mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
						If mesh.anim_time#&gt;last
							mesh.anim_time#=last
							mesh.anim_mode=0
						EndIf
					
					EndIf
					
				EndIf
							
			EndIf
		
		Next
	
	End Function

	Function RenderWorld()

		UpdateEntities()
	
		' if anti-aliasing enabled then call RenderWorldAA
		If aa Then RenderWorldAA();Return

		For Local cam:TCamera=EachIn TCamera.cam_list

			'If cam.parent_hidden=True Or cam.hidden=True Then Continue
			If cam.Hidden()=True Then Continue

			RenderCamera(cam)

		Next

	End Function
	
	' Same as RenderWorld but with anti-aliasing
	Function RenderWorldAA()
	
		glClear(GL_ACCUM_BUFFER_BIT)
	
		For jitter=0 Until ACSIZE
				
			For Local cam:TCamera=EachIn TCamera.cam_list
	
				'If cam.parent_hidden=True Or cam.hidden=True Then Continue
				If cam.Hidden()=True Then Continue
	
				RenderCamera(cam)
	
			Next
			
			glAccum(GL_ACCUM,1.0/ACSIZE)
	
		Next
		jitter=0
		
		glAccum(GL_RETURN,1.0)
		glFlush()
	
	End Function

	' Render camera - renders all meshes camera can see
	Function RenderCamera(cam:TCamera)

		cam.Update()
	
		For Local light:TLight=EachIn TLight.light_list
	
			light.Update() ' EntityHidden code inside Update
			
		Next

		Local render_list:TList=CreateList:TList()
		
		For Local mesh:TMesh=EachIn TEntity.entity_list
		
			'If mesh.parent_hidden=True Or mesh.hidden=True Or mesh.brush.alpha=0.0 Then Continue
			If mesh.Hidden()=True Or mesh.brush.alpha=0.0 Then Continue
		
			' get new bounds
			mesh.GetBounds()
	
			' Perform frustum cull
			
			Local inview=cam.EntityInFrustum(mesh)

			If inview
			
				If mesh.auto_fade=True Then AutoFade(cam,mesh)
			
				If mesh.Alpha()
			
					mesh.alpha_order#=cam.EntityDistanceSquared#(mesh)
				
				Else
				
					mesh.alpha_order#=0.0
				
				EndIf
			
				RenderListAdd(mesh,render_list)
				
			EndIf
	
		Next

		UpdateSprites(cam,render_list) ' rotate sprites with respect to current cam

		' Draw everything in render list
		For Local mesh2:TMesh=EachIn render_list
		
			mesh2.Update()
	
		Next

	End Function
	
	Function AutoFade(cam:TCamera,mesh:TMesh)

		Local dist#=cam.EntityDistance#(mesh)
		
		If dist&gt;mesh.fade_near And dist&lt;mesh.fade_far
		
			' fade_alpha will be in the range 0 (near) to 1 (far)
			mesh.fade_alpha=(dist-mesh.fade_near)/(mesh.fade_far-mesh.fade_near)
	
		Else
		
			' if entity outside near, far range then set min/max values
			If dist&lt;mesh.fade_near Then mesh.fade_alpha#=0.0 Else mesh.fade_alpha#=1.0
			
		EndIf

	End Function

	Function GraphicsInit()
	
		TTexture.TextureFilter("",9)
	
		glewInit() ' required for ARB funcs

		' get hardware info and set vbo_enabled accordingly
		THardwareInfo.GetInfo()
		'THardwareInfo.DisplayInfo()
		If USE_VBO=True
			vbo_enabled=THardwareInfo.VBOSupport
		EndIf

		If USE_MAX2D=True

			' save the Max2D settings for later - by Oddball
			glPushAttrib GL_ALL_ATTRIB_BITS
			glPushClientAttrib GL_CLIENT_ALL_ATTRIB_BITS
			glMatrixMode GL_MODELVIEW
			glPushMatrix
			glMatrixMode GL_PROJECTION
			glPushMatrix
			glMatrixMode GL_TEXTURE
			glPushMatrix
			glMatrixMode GL_COLOR
			glPushMatrix
		
		EndIf
		
		EnableStates()
		
		glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,GL_SEPARATE_SPECULAR_COLOR)
		glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_TRUE)

		glClearDepth(1.0)						
		glDepthFunc(GL_LEQUAL)
		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)

		glAlphaFunc(GL_GEQUAL,0.5)
		
	End Function
	
	Function EnableStates()
	
		glEnable(GL_LIGHTING)
   		glEnable(GL_DEPTH_TEST)
		glEnable(GL_FOG)
		glEnable(GL_CULL_FACE)
		glEnable(GL_SCISSOR_TEST)
		
		glEnable(GL_NORMALIZE)
		
		glEnableClientState(GL_VERTEX_ARRAY)
		glEnableClientState(GL_COLOR_ARRAY)
		glEnableClientState(GL_NORMAL_ARRAY)
	
	End Function
	
	' Adds mesh to a render list, and inserts mesh into correct position within list depending on order and alpha values
	Function RenderListAdd(mesh:TMesh,List:TList)
	
		' if order&gt;0, drawn first (will appear at back of scene)
		' if order&lt;0, drawn last (will appear at front of scene)
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If mesh.order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=mesh.order
	
			list.InsertBeforeLink(mesh,llink)
			Return
	
		Else If mesh.order&lt;0 ' put entities with order&lt;0 at back of list

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=mesh.order
	
			list.InsertAfterLink(mesh,llink)
			Return

		EndIf
		
		' order=0
		
		If mesh.alpha_order#&gt;0.0
		
			' add alpha entities to near end of list - before entities with order&lt;0

			Repeat
				llink=llink._pred
				If llink=list._head Then Exit
			Until TEntity(llink.Value()).order&gt;=0 And (TEntity(llink.Value()).alpha_order&gt;=mesh.alpha_order Or TEntity(llink.Value()).alpha_order=0.0)

			list.InsertAfterLink(mesh,llink)
			Return
		
		Else
			
			' normal entities - add to list at start - after entities with order&gt;0
		
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=0

			list.InsertBeforeLink(mesh,llink)
			Return
			
		EndIf
		
	End Function

	Function UpdateSprites(cam:TCamera,list:TList)

		For Local sprite:TSprite=EachIn list
		
			If sprite.view_mode&lt;&gt;2
			
				Local x#=sprite.mat.grid[3,0]
				Local y#=sprite.mat.grid[3,1]
				Local z#=sprite.mat.grid[3,2]
			
				sprite.mat.Overwrite(cam.mat)
				sprite.mat.grid[3,0]=x
				sprite.mat.grid[3,1]=y
				sprite.mat.grid[3,2]=z
				sprite.mat_sp.Overwrite(sprite.mat)
				
				If sprite.angle#&lt;&gt;0.0
					sprite.mat_sp.RotateRoll(sprite.angle#)
				EndIf
				
				If sprite.scale_x#&lt;&gt;1.0 Or sprite.scale_y#&lt;&gt;1.0
					sprite.mat_sp.Scale(sprite.scale_x#,sprite.scale_y#,1.0)
				EndIf
				
				If sprite.handle_x#&lt;&gt;0.0 Or sprite.handle_y#&lt;&gt;0.0
					sprite.mat_sp.Translate(-sprite.handle_x#,-sprite.handle_y#,0.0)
				EndIf
				
			Else
			
				sprite.mat_sp.Overwrite(sprite.mat)
				
				If sprite.scale_x#&lt;&gt;1.0 Or sprite.scale_y#&lt;&gt;1.0
					sprite.mat_sp.Scale(sprite.scale_x#,sprite.scale_y#,1.0)
				EndIf
	
			EndIf
			
		Next
	
	End Function
				
End Type
</textarea> <br><br></td></tr></table><br>
<a name="963999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does it work now? <br><br></td></tr></table><br>
<a name="964021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Patience with me please :) I don't have much time to work with Blitz at the moment. <br><br>Yes it works now and your .exe workd as well :) <br>But, like in Science, a solved Question creates more Questions, I got another thing to solve.<br><br>Standard EntityPitch() gives me values from -"infinite" to +"infinite" and yours provide -90 to 90. Is it possible to get at least values from 0 to 360? ( or to infinite;-) )<br>That would make it much easier to handle the rotation.<br><br>greetings, and great work! <br><br></td></tr></table><br>
<a name="964051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you. I'm afraid that's not possible, because EntityPitch/Yaw/Roll extract their values from the matrix. That means the pitch is affected by the roll and yaw.<br>I got those routines from the math library that is posted in the b3d thread.<br>However, depending on what you are trying to do, you can work around that limitation by keeping track of this pitch yourself, for instance like this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import sidesign.minib3d

Graphics3D 800, 600

CreateLight()

cam = CreateCamera()
cube = CreateCube()
MoveEntity cam, 0, 0, -15

pitch# = 0
yaw# = 0
roll# = 0

Repeat

	pitch = pitch + 1
	RotateEntity cube, pitch, yaw, roll
		
	RenderWorld
	BeginMax2D
	
	DrawText pitch, 0, 0
	DrawText yaw, 0, 20
	DrawText roll, 0, 40
	
	EndMax2D
	
	Flip

Until KeyHit(key_escape)

End
</textarea> <br><br></td></tr></table><br>
<a name="964064"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for this suggestion. I tried it, but it revealed something bad :(<br><br>With the original minib3d i have ~60 fps but with the modified one i have a maximum of 25 fps.<br>Same Code, I just used different minib3d versions to compile it.<br><pre class=code>
		actualRot:float = actualRot + (curRot:float - actualRot) * 0.1
		Cube.RotateEntity(actualRot, 0, 0)
</pre><br>The code itself works, just the thing with the lower frame rate.<br><br>greetings <br><br></td></tr></table><br>
<a name="964120"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> !? That is a big difference indeed. The reason might be that my RotateEntity is slower. I tried to optimise the code for TEntity. You might give that a try. I replaced the my 'Rotate' with the original Rotate code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Version 14 june
Type TEntity

	Global entity_list:TList=CreateList()
	Field need_update = True

	Field child_list:TList=CreateList()

	Field parent:TEntity
	
	Field rotmat:TMatrix=TMatrix.Create()'rotation matrix
	Field mat:TMatrix=New TMatrix
	Field px#,py#,pz#,sx#=1.0,sy#=1.0,sz#=1.0,rx#,ry#,rz#,qw#,qx#,qy#,qz#
	
	Field name$
	Field class$
	Field hide=False
	Field order,alpha_order#
	Field auto_fade,fade_near#,fade_far#,fade_alpha#

	Field brush:TBrush=New TBrush
	
	Field cull_radius#
	
	Field radius_x#=1.0,radius_y#=1.0
	Field box_x#=-1.0,box_y#=-1.0,box_z#=-1.0,box_w#=2.0,box_h#=2.0,box_d#=2.0
	Field collision_type
	Field no_collisions,collision:TCollisionImpact[]
	Field pick_mode,obscurer

	Field anim ' true if mesh contains anim data
	Field anim_render ' true to render as anim mesh
	Field anim_mode
	Field anim_time#
	Field anim_speed#
	Field anim_seq
	Field anim_trans
	Field anim_dir=1 ' 1=forward, -1=backward
	Field anim_seqs_first[1]
	Field anim_seqs_last[1]
	Field no_seqs=0
	Field anim_update
	
	Global tformed_x#
	Global tformed_y#
	Global tformed_z#
	
	' used by TCollisions
	Field old_x#
	Field old_y#
	Field old_z#
		
	Field link:TLink ' entity_list tlink, stored for quick removal of entity from list ***note*** not currently used to remove entity from list

	Method CopyEntity:TEntity(parent_ent:TEntity=Null) Abstract
	Method Update() Abstract

	Method New()
	
		If LOG_NEW
			DebugLog "New TEntity"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TEntity"
		EndIf
	
	End Method

	Method FreeEntity()
	
		ListRemove(entity_list,Self)
	
		'RemoveLink link ' remove self from entity list - mem leak!
		
		' remove from collision entity lists
		If collision_type&lt;&gt;0 ListRemove(TCollisionPair.ent_lists[collision_type],Self)
		
		' remove from pick entity list
		If pick_mode&lt;&gt;0 ListRemove(TPick.ent_list,Self)
		
		Local ent:TEntity
		
		' free self from parent's child_list
		If parent&lt;&gt;Null
			For ent=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
		EndIf
		
		parent=Null
		mat=Null
		brush=Null
		link=Null
	
		' free children entities
		For ent=EachIn child_list
			ent.FreeEntity()
			ent=Null
		Next

	End Method

	' Entity movement

	Method PositionEntity(x#,y#,z#,glob=False)
		MQ_Position( x, y, z, glob )
		need_update = True
		'MQ_Update()
	End Method
		
	Method MoveEntity(mx#,my#,mz#)
		MQ_Move( mx, my, mz )
		need_update = True
		'MQ_Update()
	End Method

	Method TranslateEntity(tx#,ty#,tz#,glob=True)
		TFormVector(tx, ty, tz, Null, Self)
		MQ_Move( tformed_x#, tformed_y#, tformed_z# )
		need_update = True
		'MQ_Update()
	End Method
	
	Method ScaleEntity(x#,y#,z#,glob=False)	
		MQ_Scale(x, y, z, glob)
		need_update = True
		'MQ_Update()
	End Method

	Method RotateEntity(x#,y#,z#,glob=False)	
		MQ_Rotate(x,y,z, glob)
		need_update = True
		'MQ_Update()
	End Method

	Method TurnEntity(x#,y#,z#,glob=False)	
		If x# &lt;&gt; 0 Then MQ_Turn(x, 1, 0, 0, glob)
		If y# &lt;&gt; 0 Then MQ_Turn(y, 0, 1, 0, glob)
		If z# &lt;&gt; 0 Then MQ_Turn(z, 0, 0, 1, glob)
		need_update = True
		'MQ_Update()
	End Method

	' Function by mongia2
	Method PointEntity(target_ent:TEntity,roll#=0)	
	
		Local x#=target_ent.EntityX#(True)
		Local y#=target_ent.EntityY#(True)
		Local z#=target_ent.EntityZ#(True)

		Local xdiff#=Self.EntityX(True)-x#
		Local ydiff#=Self.EntityY(True)-y#
		Local zdiff#=-(Self.EntityZ(True)-z#) 'I don't know why I needed to invert this .. could be a problem

		Local dist22#=Sqr((xdiff#*xdiff#)+(zdiff#*zdiff#))
		Local pitch#=ATan2(ydiff#,dist22#)
		Local yaw#=ATan2(xdiff#,zdiff#)

		Self.RotateEntity pitch#,yaw#,roll#,True
		
	End Method
		
	' Entity animation

	' load anim seq - copies anim data from mesh to self
	Method LoadAnimSeq(file:String)
	
		If FileType(file)=0 Then Return 0
	
		' mesh that we will load anim seq from
		Local mesh:TMesh=TModel.LoadAnimB3D:TMesh(file)
		
		If anim=False Then Return 0 ' self contains no anim data
		If mesh.anim=False Then Return 0 ' mesh contains no anim data
	
		no_seqs=no_seqs+1
		
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' update anim_seqs array
		anim_seqs_first[no_seqs]=anim_seqs_last[0]
		anim_seqs_last[no_seqs]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		' update anim_seqs_last[0] - sequence 0 is for all frames, so this needs to be increased
		' must be done after updating anim_seqs array above
		anim_seqs_last[0]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		If mesh&lt;&gt;Null

			' go through all bones belonging to self
			For Local bone:TBone=EachIn TMesh(Self).bones
			
				' find bone in mesh that matches bone in self - search based on bone name
				Local mesh_bone:TBone=TBone(TEntity(mesh).FindChild(bone.name$))
			
				If mesh_bone&lt;&gt;Null
			
					' resize self arrays first so the one empty element at the end is removed
					bone.keys.flags=bone.keys.flags[..bone.keys.flags.length-1]
					bone.keys.px=bone.keys.px[..bone.keys.px.length-1]
					bone.keys.py=bone.keys.py[..bone.keys.py.length-1]
					bone.keys.pz=bone.keys.pz[..bone.keys.pz.length-1]
					bone.keys.sx=bone.keys.sx[..bone.keys.sx.length-1]
					bone.keys.sy=bone.keys.sy[..bone.keys.sy.length-1]
					bone.keys.sz=bone.keys.sz[..bone.keys.sz.length-1]
					bone.keys.qw=bone.keys.qw[..bone.keys.qw.length-1]
					bone.keys.qx=bone.keys.qx[..bone.keys.qx.length-1]
					bone.keys.qy=bone.keys.qy[..bone.keys.qy.length-1]
					bone.keys.qz=bone.keys.qz[..bone.keys.qz.length-1]
					
					' add mesh bone key arrays to self bone key arrays
					bone.keys.frames=anim_seqs_last[0]
					bone.keys.flags=bone.keys.flags+mesh_bone.keys.flags
					bone.keys.px=bone.keys.px+mesh_bone.keys.px
					bone.keys.py=bone.keys.py+mesh_bone.keys.py
					bone.keys.pz=bone.keys.pz+mesh_bone.keys.pz
					bone.keys.sx=bone.keys.sx+mesh_bone.keys.sx
					bone.keys.sy=bone.keys.sy+mesh_bone.keys.sy
					bone.keys.sz=bone.keys.sz+mesh_bone.keys.sz
					bone.keys.qw=bone.keys.qw+mesh_bone.keys.qw
					bone.keys.qx=bone.keys.qx+mesh_bone.keys.qx
					bone.keys.qy=bone.keys.qy+mesh_bone.keys.qy
					bone.keys.qz=bone.keys.qz+mesh_bone.keys.qz
				
				EndIf
				
			Next
				
		EndIf
		
		mesh.FreeEntity()
		
		Return no_seqs
	
	End Method
	
	Method ExtractAnimSeq(first_frame,last_frame,seq=0)
	
		no_seqs=no_seqs+1
	
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' if seq specifed then extract anim sequence from within existing sequnce
		Local offset=0
		If seq&lt;&gt;0
			offset=anim_seqs_first[seq]
		EndIf
	
		anim_seqs_first[no_seqs]=first_frame+offset
		anim_seqs_last[no_seqs]=last_frame+offset
		
		Return no_seqs
	
	End Method

	Method Animate(mode=1,speed#=1.0,seq=0,trans=0)
	
		anim_mode=mode
		anim_speed#=speed#
		anim_seq=seq
		anim_trans=trans
		anim_time#=anim_seqs_first[seq]
		anim_update=True ' update anim for all modes (including 0)
		
		If trans&gt;0
			anim_time#=0
		EndIf
		
	End Method
	
	' Updates:
	' 30/01/06 - updated to make anim_time return wrapped value
	Method SetAnimTime(time#,seq=0)
	
		anim_mode=-1 ' use a mode of -1 for setanimtime
		anim_speed#=0
		anim_seq=seq
		anim_trans=0
		anim_time#=time#
		anim_update=False ' set anim_update to false so UpdateWorld won't animate entity

		Local first=anim_seqs_first[anim_seq]
		Local last=anim_seqs_last[anim_seq]
		Local first2last=anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq]
		
		time#=time#+first ' offset time so that anim time of 0 will equal first frame of sequence
		
		If time#&gt;last And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#-first2last
			Until time#&lt;=last
		EndIf
		If time#&lt;first And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#+first2last
			Until time#&gt;=first
		EndIf
		
		TAnimation.AnimateMesh(Self,time#,first,last)

		anim_time#=time# ' update anim_time# to equal time#

	End Method
	
	Method AnimSeq()
	
		Return anim_seq ' current anim sequence
	
	End Method
	
	Method AnimLength()
	
		Return anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq] ' no of frames in anim sequence
	
	End Method

	Method AnimTime#()
	
		' if animation in transition, return 0 (anim_time actually will be somewhere between 0 and 1)
		If anim_trans&gt;0 Then Return 0
		
		' for animate and setanimtime we want to return anim_time starting from 0 and ending at no. of frames in sequence
		If anim_mode&gt;0 Or anim_mode=-1
			Return anim_time#-anim_seqs_first[anim_seq]
		EndIf

		Return 0

	End Method
	
	Method Animating()
	
		If anim_trans&gt;0 Then Return True
		If anim_mode&gt;0 Then Return True
		
		Return False
	
	End Method
		
	' Entity control

	Method EntityColor(r#,g#,b#)
	
		brush.red  =r#/255.0
		brush.green=g#/255.0
		brush.blue =b#/255.0
	
	End Method

	Method EntityAlpha(a#)
	
		brush.alpha=a#
			
	End Method
	
	Method EntityShininess(s#)
	
		brush.shine=s#
	
	End Method

	Method EntityTexture(texture:TTexture,frame=0,index=0)

		brush.tex[index]=texture
		If index+1&gt;brush.no_texs Then brush.no_texs=index+1
		
		If frame&lt;0 Then frame=0
		If frame&gt;texture.no_frames-1 Then frame=texture.no_frames-1 
		brush.tex_frame=frame
	
	End Method
	
	Method EntityBlend(blend_no)
	
		brush.blend=blend_no
		
		If TMesh(Self)&lt;&gt;Null
		
			' overwrite surface blend modes with master blend mode
			For Local surf:TSurface=EachIn TMesh(Self).surf_list
				If surf.brush&lt;&gt;Null
					surf.brush.blend=brush.blend
				EndIf
			Next
			
		EndIf
		
	End Method
	
	Method EntityFX(fx_no)
	
		brush.fx=fx_no
		
	End Method
	
	Method EntityAutoFade(near#,far#)
	
		auto_fade=True
		fade_near=near#
		fade_far=far#
	
	End Method
	
	Method PaintEntity(bru:TBrush)
	
		brush.no_texs=bru.no_texs
		brush.name$=bru.name$
		brush.red#=bru.red#
		brush.green#=bru.green#
		brush.blue#=bru.blue#
		brush.alpha#=bru.alpha#
		brush.shine#=bru.shine#
		brush.blend=bru.blend
		brush.fx=bru.fx
		For Local i=0 To 7
			brush.tex[i]=bru.tex[i]
		Next
	
	End Method
	
	Method EntityOrder(order_no)
	
		order=order_no

		If TCamera(Self)&lt;&gt;Null
			ListRemove(TCamera.cam_list,Self)
			EntityListAdd(TCamera.cam_list)
		EndIf

	End Method
	
	Method ShowEntity()
	
		hide=False
		
	End Method

	Method HideEntity()

		hide=True

	End Method

	Method Hidden()
	
		If hide=True Return True
		
		Local ent:TEntity=parent
		While ent&lt;&gt;Null
			If ent.hide=True Return True
			ent=ent.parent
		Wend
		
		Return False
	
	End Method

	Method NameEntity(e_name$)
	
		name$=e_name$
	
	End Method
	
	Method EntityParent(parent_ent:TEntity,glob=True)	

		MQ_SetParent(parent_ent, glob)	
		need_update = True
		'MQ_Update()
		
	End Method
		
	Method GetParent:TEntity()			
		Return parent	
	End Method

	' Entity state
	Method EntityX#(glob=False)			
		If glob Then
			If need_update Then MQ_Update()
			Return mat.grid[3,0]
		Else
			Return px
		End If
	End Method
	
	Method EntityY#(glob=False)
		If glob Then
			If need_update Then MQ_Update()
			Return mat.grid[3,1]
		Else
			Return py
		End If
	End Method
	
	Method EntityZ#(glob=False)
		If glob Then
			If need_update Then MQ_Update()
			Local v# = mat.grid[3,2]
			Return -v
		Else
			Return pz
		End If
	End Method

	Method EntityPitch#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetPitch()
		Else
			'use local matrix
			Return rotmat.GetPitch()
		End If
	End Method
	
	Method EntityYaw#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetYaw()
		Else
			'use local matrix
			Return rotmat.GetYaw()
		End If
	End Method
	
	Method EntityRoll#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetRoll()
		Else
			'use local matrix
			Return rotmat.GetRoll()
		End If
	End Method
	
	Method EntityClass$()
		
		Return class$
		
	End Method
	
	Method EntityName$()
		
		Return name$
		
	End Method
	
	Method CountChildren()

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1

		Next

		Return no_children

	End Method
	
	Method GetChild:TEntity(child_no)

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

		no_children=no_children+1
			If no_children=child_no Return ent

		Next

		Return Null
	
	End Method
	
	Method FindChild:TEntity(child_name$)
	
		Local cent:TEntity
	
		For Local ent:TEntity=EachIn child_list

			If ent.EntityName$()=child_name$ Return ent

			cent=ent.FindChild(child_name$)
			
			If cent&lt;&gt;Null Return cent
	
		Next

		Return Null
	
	End Method
	
	' Calls function in TPick
	Method EntityPick:TEntity(range#)
	
		Return TPick.EntityPick:TEntity(Self,range#)
	
	End Method
	
	' Calls function in TPick
	Method LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
		Return TPick.LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
	End Method
	
	' Calls function in TPick
	Method EntityVisible(src_entity:TEntity,dest_entity:TEntity)
	
		Return TPick.EntityVisible(src_entity,dest_entity)
	
	End Method
	
	Method EntityDistance#(ent2:TEntity)

		Return Sqr(Self.EntityDistanceSquared#(ent2))

	End Method
	
	' Function by Vertex
	Method DeltaYaw#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		'Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
		
		Return -ATan2(x#,z#)

	End Method
	
	' Function by Vertex
	Method DeltaPitch#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
	
		Return -ATan2(y#,Sqr(x#*x#+z#*z#))
	
	End Method

	Function TFormPoint(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)		

		Local mat1:TMatrix
		Local mat2:TMatrix
		
		'get src matrix	
		If src_ent &lt;&gt; Null Then
			mat1:TMatrix = src_ent.MQ_GetMatrix()
		End If
	
		'get dest matrix
		If dest_ent &lt;&gt; Null Then
			mat2:TMatrix = dest_ent.MQ_GetInvMatrix()
		End If 	
	
		'transform point by matrix
		If src_ent  &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
		If dest_ent &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormVector(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		
		Local mat1:TMatrix
		Local mat2:TMatrix 
	
		'get src matrix	
		If src_ent &lt;&gt; Null Then
			mat1:TMatrix = src_ent.MQ_GetMatrix()
			mat1.grid[3,0] = 0 'remove translation
			mat1.grid[3,1] = 0
			mat1.grid[3,2] = 0
		End If
	
		'get dest matrix
		If dest_ent &lt;&gt; Null Then
			mat2:TMatrix = dest_ent.MQ_GetInvMatrix()		
			mat2.grid[3,0] = 0 'remove translation
			mat2.grid[3,1] = 0
			mat2.grid[3,2] = 0
		End If 	
	
		'transform point by matrix
		If src_ent  &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
		If dest_ent &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormNormal(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		
		TFormVector(x,y,z,src_ent,dest_ent)
		
		x# = tformed_x#
		y# = tformed_y#
		z# = tformed_z#
		
		Local dd# = Magnitude(x,y,z)
		If dd &lt;&gt; 0 Then
			x=x/dd
			y=y/dd
			z=z/dd
		End If
		
		tformed_x#=x		
		tformed_y#=y
		tformed_z#=z
	End Function
	
	Function TFormedX#()
	
		Return tformed_x#
	
	End Function
	
	Function TFormedY#()
	
		Return tformed_y#
	
	End Function
	
	Function TFormedZ#()
	
		Return tformed_z#
	
	End Function
	
	Method GetMatElement#(row,col)
	
		Return mat.grid[row,col]
	
	End Method
	
	' Entity collision
	
	Method ResetEntity()
	
		no_collisions=0
		collision=collision[..0]
		old_x=EntityX(True)
		old_y=EntityY(True)
		old_z=EntityZ(True)
	
	End Method
	
	Method EntityRadius(rx#,ry#=0.0)
	
		radius_x#=rx#
		If ry#=0.0 Then radius_y#=rx# Else radius_y#=ry#
	
	End Method
	
	Method EntityBox(x#,y#,z#,w#,h#,d#)
	
		box_x#=x#
		box_y#=y#
		box_z#=z#
		box_w#=w#
		box_h#=h#
		box_d#=d#
	
	End Method

	Method EntityType(type_no,recursive=False)
	
		' add to collision entity list if new type no&lt;&gt;0 and not previously added
		If collision_type=0 And type_no&lt;&gt;0
		
			If TCollisionPair.ent_lists[type_no]=Null Then TCollisionPair.ent_lists[type_no]=CreateList() ' create new list is one doesn't exist
			
			ListAddLast(TCollisionPair.ent_lists[type_no],Self)
			
		EndIf
		
		' remove from collision entity list if new type no=0 and previously added
		If collision_type&lt;&gt;0 And type_no=0
			ListRemove(TCollisionPair.ent_lists[type_no],Self)
		EndIf
		
		collision_type=type_no
		
		old_x#=EntityX(True)
		old_y#=EntityY(True)
		old_z#=EntityZ(True)
	
		If recursive=True
		
			For Local ent:TEntity=EachIn child_list
			
				ent.EntityType(type_no,True)
			
			Next
		
		EndIf
		
	End Method
	
	Method EntityPickMode(no,obscure=True)
	
		' add to pick entity list if new mode no&lt;&gt;0 and not previously added
		If pick_mode=0 And no&lt;&gt;0
			ListAddLast(TPick.ent_list,Self)
		EndIf
		
		' remove from pick entity list if new mode no=0 and previously added
		If pick_mode&lt;&gt;0 And no=0
			ListRemove(TPick.ent_list,Self)
		EndIf
	
		pick_mode=no
		obscurer=obscure
			
	End Method
	
	Method EntityCollided:TEntity(type_no)

		' if self is source entity and type_no is dest entity
		For Local i=1 To CountCollisions()
			If CollisionEntity(i).collision_type=type_no Then Return CollisionEntity(i)
		Next

		' if self is dest entity and type_no is src entity
		For Local ent:TEntity=EachIn TCollisionPair.ent_lists[type_no]
			For Local i=1 To ent.CountCollisions()
				If CollisionEntity(i)=Self Then Return ent		
			Next
		Next

		Return Null

	End Method
	
	Method CountCollisions()
	
		Return no_collisions
	
	End Method
	
	Method CollisionX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].x#
		
		EndIf
	
	End Method
	
	Method CollisionY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].y#
		
		EndIf
	
	End Method
	
	Method CollisionZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].z#
		
		EndIf
	
	End Method

	Method CollisionNX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nx#
		
		EndIf
	
	End Method
	
	Method CollisionNY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ny#
		
		EndIf
	
	End Method
	
	Method CollisionNZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nz#
		
		EndIf
	
	End Method
	
	Method CollisionTime#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].time#
		
		EndIf
	
	End Method
	
	Method CollisionEntity:TEntity(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ent
		
		EndIf
	
	End Method
	
	Method CollisionSurface:TSurface(index)
	
		If index&gt;0 And index&lt;=no_collisions

			Return collision[index-1].surf
		
		EndIf
	
	End Method
	
	Method CollisionTriangle(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].tri
		
		EndIf
	
	End Method
	
	Method GetEntityType()

		Return collision_type

	End Method
	
	' Sets an entity's mesh cull radius
	Method MeshCullRadius(radius#)
	
		' set to negative no. so we know when user has set cull radius (manual cull)
		' a check in TMesh.GetBounds then prevents negative no. being overwritten by a positive cull radius (auto cull)
		cull_radius#=-radius#
	
	End Method
	
	Method EntityScaleX#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return w
	End Method
	
	Method EntityScaleY#(glob=False)
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return h
	End Method
	
	Method EntityScaleZ#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return d
	End Method

	' Returns an entity's bounding sphere
	Method BoundingSphereNew(sx# Var,sy# Var,sz# Var,sr# Var)

		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=tformed_x
			y=tformed_y
			z=tformed_z
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		sx=x
		sy=y
		sz=z
		sr=radius

	End Method
	
	Function CountAllChildren(ent:TEntity,no_children=0)
		
		Local ent2:TEntity
	
		For ent2=EachIn ent.child_list

			no_children=no_children+1
			
			no_children=TEntity.CountAllChildren(ent2,no_children)

		Next

		Return no_children

	End Function
	
	Method GetChildFromAll:TEntity(child_no,no_children Var,ent:TEntity=Null)

		If ent=Null Then ent=Self
		
		Local ent3:TEntity=Null
		
		For Local ent2:TEntity=EachIn ent.child_list

			no_children=no_children+1
			
			If no_children=child_no Then Return ent2
			
			If ent3=Null
			
				ent3=GetChildFromAll(child_no,no_children,ent2)

			EndIf

		Next

		Return ent3
			
	End Method
	
	' Internal - not recommended for general use

	Method UpdateMat(load_identity=False)
		'MQ_Update()
		need_update = True
		'mat.Overwrite(MQ_GetMatrix())
	End Method
	
	Method AddParent(parent_ent:TEntity)
	
		' self.parent = parent_ent
		parent:TEntity=parent_ent
		
		' add self to parent_ent child list
		If parent&lt;&gt;Null

			mat.Overwrite(parent.mat)
		
			ListAddLast(parent.child_list,Self)
		
		EndIf
		
	End Method
	
	Function UpdateChildren(ent_p:TEntity)
	
		For Local ent_c:TEntity=EachIn ent_p.child_list

			ent_c.mat.Overwrite(ent_p.mat)
			ent_c.UpdateMat()
				
			UpdateChildren(ent_c:TEntity)
			
		Next
	
	End Function

	' unoptimised, unused
	Method EntityDistanceSquared0#(ent2:TEntity)

		Local xd# = ent2.EntityX#(True)-EntityX#(True)
		Local yd# = ent2.EntityY#(True)-EntityY#(True)
		Local zd# = ent2.EntityZ#(True)-EntityZ#(True)
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method
	
	' optimised
	Method EntityDistanceSquared#(ent2:TEntity)

		If need_update Then MQ_Update()
		If ent2.need_update Then ent2.MQ_Update()

		Local xd# = ent2.mat.grid[3,0]-mat.grid[3,0]
		Local yd# = ent2.mat.grid[3,1]-mat.grid[3,1]
		Local zd# = -ent2.mat.grid[3,2]+mat.grid[3,2]
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method

	Method EntityListAdd(list:TList)
	
		' if order&gt;0, drawn first
		' if order&lt;0, drawn last
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=order Or TEntity(llink.Value()).order&lt;=0
	
			link=list.InsertBeforeLink(Self,llink)
			Return
	
		Else ' put entities with order=0 at back of list, so cameras with order=0 are sorted the same as in B3D

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=order Or TEntity(llink.Value()).order&gt;=0
	
			link=list.InsertAfterLink(Self,llink)
			Return

		EndIf

	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											BEGIN MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------

	'returns copy of rotation matrix	
	Method MQ_CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = rotmat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method

'		Local q1_x#, q1_y#, q1_z#, q1_w#
'		Local q2_x#, q2_y#, q2_z#, q2_w#
'		Local q3_x#, q3_y#, q3_z#, q3_w#
'		Local m1:TMatrix = TMatrix.Create()
'		Local m2:TMatrix = TMatrix.Create()
'				
'		Quaternion_FromAngleAxis(  pitch, -1,  0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
'		Quaternion_FromAngleAxis(  yaw,    0,  1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
'		Quaternion_FromAngleAxis(  roll,   0,  0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
'		
'		'convert to matrices	
'		m1.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
'		m2.FromQuaternion(q2_x, q2_y, q2_z, q2_w)
'		
'		'apply
'		rotmat.FromQuaternion(q3_x, q3_y, q3_z, q3_w) 'roll
'		rotmat.Multiply2(m1) 'pitch
'		rotmat.Multiply2(m2) 'yaw
	
	'turn entity
	Method MQ_Rotate( pitch#, yaw#, roll#, glob=False )

		Local m2:TMatrix = TMatrix.Create()
	
		rotmat.LoadIdentity()
		rotmat.Rotate(pitch, yaw, roll)
		
		If glob Then
			'get parent inverted rotation matrix
			If parent &lt;&gt; Null Then
				m2:TMatrix = parent.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
				'apply rotation matrix
				rotmat.Multiply2(m2)
			End If
		End If
		
	End Method
	
	'turn entity
	Method MQ_Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then		
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method MQ_TransformPoint( ix# Var,iy# Var,iz# Var)
		
		rotmat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method MQ_Position( qx#,qy#,qz#, glob=False )
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then 
				TFormPoint(qx, qy, qz, Null, parent)
				qx = tformed_x
				qy = tformed_y
				qz = tformed_z
			End If
		End If
		
		px = qx
		py = qy
		pz = qz

	End Method

	'move an entity
	Method MQ_Move( qx#,qy#,qz# )
		MQ_TransformPoint(qx,qy,qz) 'transform point by internal matrix
		px = px + qx 'add to position
		py = py + qy
		pz = pz + qz
	
	End Method

	'get matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
			
		Local mat1:TMatrix = TMatrix.Create()
		Local isx#,isy#,isz#
		
		If sx = 0 Then isx = 1 Else isx = sx
		If sy = 0 Then isy = 1 Else isy = sy
		If sz = 0 Then isz = 1 Else isz = sz
		mat1.grid[0,0]=rotmat.grid[0,0]/sx
		mat1.grid[0,1]=rotmat.grid[1,0]/sx
		mat1.grid[0,2]=rotmat.grid[2,0]/sx
		mat1.grid[1,0]=rotmat.grid[0,1]/sy
		mat1.grid[1,1]=rotmat.grid[1,1]/sy
		mat1.grid[1,2]=rotmat.grid[2,1]/sy
		mat1.grid[2,0]=rotmat.grid[0,2]/sz
		mat1.grid[2,1]=rotmat.grid[1,2]/sz
		mat1.grid[2,2]=rotmat.grid[2,2]/sz
		mat1.grid[3,0]=-px
		mat1.grid[3,1]=-py
		mat1.grid[3,2]=pz

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1.Multiply2(parent.MQ_GetInvMatrix(scale))
		End If
		
		Return mat1
		
	End Method

Rem
	'get inverted matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat0:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat0 = parent.MQ_GetInvMatrix(scale)
		Else
			mat0 = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = MQ_CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-px,-py, pz)
		
		'combine
		mat1.Multiply2(mat3)
		mat2.Multiply2(mat1)
		mat0.Multiply2(mat2)
		
		Return mat0
		
	End Method
EndRem
Rem
	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local ipz#
			
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(px, py, -pz)
		'rotation
		mat1:TMatrix = rotmat.Copy()

		mat3.Multiply2(mat1)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat3.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat3
		
	End Method

EndRem	
	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
			
		Local mat1:TMatrix = TMatrix.Create()
		
		mat1.grid[0,0]=rotmat.grid[0,0]*sx
		mat1.grid[0,1]=rotmat.grid[0,1]*sx
		mat1.grid[0,2]=rotmat.grid[0,2]*sx
		mat1.grid[1,0]=rotmat.grid[1,0]*sy
		mat1.grid[1,1]=rotmat.grid[1,1]*sy
		mat1.grid[1,2]=rotmat.grid[1,2]*sy
		mat1.grid[2,0]=rotmat.grid[2,0]*sz
		mat1.grid[2,1]=rotmat.grid[2,1]*sz
		mat1.grid[2,2]=rotmat.grid[2,2]*sz
		mat1.grid[3,0]=px
		mat1.grid[3,1]=py
		mat1.grid[3,2]=-pz

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat1
		
	End Method


	'update attached entity
	Method MQ_Update()
			
		mat.Overwrite(MQ_GetMatrix(True))		
		need_update = False

		'update child_list		
		Local e:TEntity
		For e:TEntity = EachIn child_list
			e.MQ_Update
		Next

	End Method

	'set scaling for an entity
	Method MQ_Scale( w#, h#, d#, glob )
	
		Local xx#,yy#,zz#
		Local ll#

		If glob Then
			If h &lt;&gt; 0 Then
				xx = 0
				yy = 1 / h
				zz = 0
				TFormVector xx, yy, zz, Self, Null
				xx = tformed_x
				yy = tformed_y
				zz = tformed_z
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then h = 1 / ll
			End If
	
			If w &lt;&gt; 0 Then
				xx = 1 / w
				yy = 0
				zz = 0
				TFormVector xx, yy, zz, Self, Null
				xx = tformed_x
				yy = tformed_y
				zz = tformed_z
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then w = 1 / ll
			End If
				
			If d &lt;&gt; 0 Then
				xx = 0
				yy = 0
				zz = 1 / w
				TFormVector xx, yy, zz, Self, Null
				xx = tformed_x
				yy = tformed_y
				zz = tformed_z				
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then d = 1 / ll
			End If
		End If

		sx = w
		sy = h
		sz = d

	End Method


	'set an entity's parent	
	Method MQ_SetParent(e:TEntity, glob)
	
		Local orgx#,orgy#,orgz#
		Local orgw#,orgh#,orgd#
		Local neww#,newh#,newd#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			TFormPoint(0, 0, 0, Self, Null)
			orgx = tformed_x
			orgy = tformed_y
			orgz = tformed_z
			m1:TMatrix = MQ_GetMatrix(False)
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
			'get scaling
			MQ_GetScaleXYZ(orgw#,orgh#,orgd#)
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.child_list, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then
				TFormPoint(orgx, orgy, orgz, Null, e)
				orgx = tformed_x
				orgy = tformed_y
				orgz = tformed_z
			End If
			'set position
			px = orgx
			py = orgy
			pz = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			m1.Multiply2(m2)
			rotmat.Overwrite(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.child_list, Self

		'get scaling
		MQ_GetScaleXYZ(neww#,newh#,newd#)
		If neww &lt;&gt; 0 Then sx = sx * orgw / neww
		If newh &lt;&gt; 0 Then sy = sy * orgh / newh
		If newd &lt;&gt; 0 Then sz = sz * orgd / newd
	
	End Method

	'get entity scale	
	Method MQ_GetScaleXYZ(width# Var, height# Var, depth# Var, glob=True)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		If glob Then 
			m:TMatrix = MQ_GetMatrix()
		Else
			m:TMatrix = TMatrix.Create()
			m.Scale(sx, sy, sz)
		End If
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											END MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------
End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											AlignToVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function AlignToVector2(e:TEntity, x#, y#, z#, axis=3, rate#=1.0)

	If axis&lt;1 Or axis&gt;3 Then Return

	Local ax#,ay#,az#
	Local dd#
	Local m:TMatrix = TMatrix.Create()
	
	'normalize
	dd# = Magnitude(x,y,z)
	If dd &lt; 0.000001 Then Return
	x = x / dd
	y = y / dd
	z = z / dd	

	'get original axis	
	ax# = (axis=1)
	ay# = (axis=2)
	az# = (axis=3)
	TFormNormal ax, ay, az, e, Null
	ax =  TFormedX()
	ay =  TFormedY()
	az =  TFormedZ()
	
 	'get transformation matrix from org. axis to new one
	m.FromToRotation(ax,ay,az, x,y,z)

	'interpolate
	If rate &lt; 1.0 Then
		m:TMatrix = InterpolateMatrix(m, rate)
	End If
	
     'apply matrix
	e.rotmat.Multiply2(m)	
	e.need_update = True
	'e.MQ_Update()
			 		
End Function

'update entity matrix
Function UpdateEntities()

	Local e:TEntity
	For e:TEntity = EachIn TEntity.entity_list
		If e.need_update Then e.MQ_Update()
	Next

End Function
</textarea> <br><br></td></tr></table><br>
<a name="964126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whatever you did, that was the solution. I have stable 60 fps now.<br>Still, when going up with the "rate" parameter of Graphics3D I am able to get about 250 fps with the original and 65 with yours. Of course there is more than one object and a scene and everything, but still, I think thats quite a difference. <br>I don't have problems with the fps, it fits for me, but maybe, when using more objects it could become a problem.<br><br>greetings :) <br><br></td></tr></table><br>
<a name="964128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could you send an example? Then I could have a look later on this week. (At work tomorrow..) I believe there shouldn't be such a big difference between the two. <br><br></td></tr></table><br>
<a name="964129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >simonh</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think quaternion rotations are always going to be slightly slower than euler ones as there is simply more calculations involved. <br><br></td></tr></table><br>
<a name="964132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would have to make an example, because it is a big programm I am using the rotation in. I can't just cut out a little sample ;)<br>But I am not at home for a couple of days. After that I will make a sample. <br><br>If simonh is right, the definition of "slightly" has to be redone :D<br><br>greetings <br><br></td></tr></table><br>
<a name="965615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am back.<br><br>here is my sample:<br><pre class=code>
SuperStrict

Import sidesign.minib3d

'standard minib3d ~120 fps
'modded minib3d ~37 fps

Type TTurningThingy
	Field HoldPivot:TEntity = CreateSphere()
	Field RotPivot:TEntity = CreateSphere(8, HoldPivot)
	Field ChildObjects:TList = CreateList()
	Function init:TTurningThingy(Pos:TVector, count:Int = 4, dist:Float = 10)
		Local tmp:TTurningThingy = New TTurningThingy
		For Local i:Int = 1 To count
			Local alpha:Float = ((360.0 / count)) * i	
			Local y:Float = Sin(alpha) * dist
			Local z:Float = Cos(alpha) * dist 
			Local ChildObject:TEntity = CreateSphere(8, tmp.RotPivot)
			ChildObject.EntityColor(Rnd(10, 255), Rnd(10, 255), Rnd(10, 255))
			ChildObject.ScaleEntity(1, 2, 1)
			ChildObject.PositionEntity(0, y, z)
			ChildObject.RotateEntity(rnd(0,360),rnd(0,360),rnd(0,360))
			tmp.ChildObjects.AddLast(ChildObject)
			
			Local someSprite:TSprite = CreateSprite(ChildObject)
			someSprite.PositionEntity(0, 5, 0)
			
			tmp.HoldPivot.PositionEntity(Pos.x, Pos.y, Pos.z)
		Next
		Return tmp
	End Function
	Method update()
		For Local tmp:TEntity = EachIn ChildObjects
			tmp.TurnEntity(0, 1, 1)
		Next
		RotPivot.TurnEntity(1, 0, 0)
		HoldPivot.TurnEntity(0, 1, 0)
	End Method
End Type

Graphics3D(640, 480, 32, 2, 1000)

Local camera:TCamera = CreateCamera()
camera.PositionEntity(0, 0, - 20)

Local TurningList:TList = CreateList()
For Local i:Int = 0 To 40
	TurningList.AddLast(TTurningThingy.init(TVector.Create(Rnd(- 50, 50), Rnd(- 50, 50), Rnd(0, 100))))
Next

Local old_ms:Int = MilliSecs()
Local renders:Int
Local fps:Int

While Not KeyHit(KEY_ESCAPE)
	Cls
	For Local tmp:TTurningThingy = EachIn TurningList
		tmp.update()
	Next
	UpdateWorld()
	RenderWorld()
	Flip()
	
	renders = renders + 1
	If MilliSecs() - old_ms &gt;= 1000
		old_ms = MilliSecs()
		fps = renders
		DebugLog fps + " FPS"
		renders=0
	EndIf
Wend
ClearWorld()
End
</pre><br><br>I know, a little bit stupid maybe, but it is an abstraction of what I am doing. In my real code I use Models and Textures, thats why I increased the polys of the sample.<br><br>I guess that it has much to do with the sprites, removing them does make the modded minib3d much faster while with simonh's version does not produce such a difference. <br><br></td></tr></table><br>
<a name="965666"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you, your example is quite helpful. I tried optimizing the code. It would need testing to see if everything still works properly, but maybe it runs faster? On my laptop, the original version runs at 7-8 fps, and the previous modded version 6-7 fps. With this adjustment, both run on 7-8 fps.<br><br>TEntity.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Version 21 june 0:12
Type TEntity

	Global entity_list:TList=CreateList()
	Field need_update = True

	Field child_list:TList=CreateList()

	Field parent:TEntity
	
	Field rotmat:TMatrix=TMatrix.Create()'rotation matrix
	Field mat:TMatrix=New TMatrix
	Field px#,py#,pz#,sx#=1.0,sy#=1.0,sz#=1.0,rx#,ry#,rz#,qw#,qx#,qy#,qz#
	
	Field name$
	Field class$
	Field hide=False
	Field order,alpha_order#
	Field auto_fade,fade_near#,fade_far#,fade_alpha#

	Field brush:TBrush=New TBrush
	
	Field cull_radius#
	
	Field radius_x#=1.0,radius_y#=1.0
	Field box_x#=-1.0,box_y#=-1.0,box_z#=-1.0,box_w#=2.0,box_h#=2.0,box_d#=2.0
	Field collision_type
	Field no_collisions,collision:TCollisionImpact[]
	Field pick_mode,obscurer

	Field anim ' true if mesh contains anim data
	Field anim_render ' true to render as anim mesh
	Field anim_mode
	Field anim_time#
	Field anim_speed#
	Field anim_seq
	Field anim_trans
	Field anim_dir=1 ' 1=forward, -1=backward
	Field anim_seqs_first[1]
	Field anim_seqs_last[1]
	Field no_seqs=0
	Field anim_update
	
	Global tformed_x#
	Global tformed_y#
	Global tformed_z#
	
	' used by TCollisions
	Field old_x#
	Field old_y#
	Field old_z#
		
	Field link:TLink ' entity_list tlink, stored for quick removal of entity from list ***note*** not currently used to remove entity from list

	Method CopyEntity:TEntity(parent_ent:TEntity=Null) Abstract
	Method Update() Abstract

	Method New()
	
		If LOG_NEW
			DebugLog "New TEntity"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TEntity"
		EndIf
	
	End Method

	Method FreeEntity()
	
		ListRemove(entity_list,Self)
	
		'RemoveLink link ' remove self from entity list - mem leak!
		
		' remove from collision entity lists
		If collision_type&lt;&gt;0 ListRemove(TCollisionPair.ent_lists[collision_type],Self)
		
		' remove from pick entity list
		If pick_mode&lt;&gt;0 ListRemove(TPick.ent_list,Self)
		
		Local ent:TEntity
		
		' free self from parent's child_list
		If parent&lt;&gt;Null
			For ent=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
		EndIf
		
		parent=Null
		mat=Null
		brush=Null
		link=Null
	
		' free children entities
		For ent=EachIn child_list
			ent.FreeEntity()
			ent=Null
		Next

	End Method

	' Entity movement

	Method PositionEntity(x#,y#,z#,glob=False)
		MQ_Position( x, y, z, glob )
		need_update = True
		'MQ_Update()
	End Method
		
	Method MoveEntity(mx#,my#,mz#)
		MQ_Move( mx, my, mz )
		need_update = True
		'MQ_Update()
	End Method

	Method TranslateEntity(tx#,ty#,tz#,glob=True)
		TFormVector(tx, ty, tz, Null, Self)
		MQ_Move( tformed_x#, tformed_y#, tformed_z# )
		need_update = True
		'MQ_Update()
	End Method
	
	Method ScaleEntity(x#,y#,z#,glob=False)	
		MQ_Scale(x, y, z, glob)
		need_update = True
		'MQ_Update()
	End Method

	Method RotateEntity(x#,y#,z#,glob=False)	
		MQ_Rotate(x,y,z, glob)
		need_update = True
		'MQ_Update()
	End Method

	Method TurnEntity(x#,y#,z#,glob=False)
		MQ_Turn2(x,y,z,glob)
'		If x# &lt;&gt; 0 Then MQ_Turn(x, 1, 0, 0, glob)
'		If y# &lt;&gt; 0 Then MQ_Turn(y, 0, 1, 0, glob)
'		If z# &lt;&gt; 0 Then MQ_Turn(z, 0, 0, 1, glob)
		need_update = True
		'MQ_Update()
	End Method

	' Function by mongia2
	Method PointEntity(target_ent:TEntity,roll#=0)	
	
		Local x#=target_ent.EntityX#(True)
		Local y#=target_ent.EntityY#(True)
		Local z#=target_ent.EntityZ#(True)

		Local xdiff#=Self.EntityX(True)-x#
		Local ydiff#=Self.EntityY(True)-y#
		Local zdiff#=-(Self.EntityZ(True)-z#) 'I don't know why I needed to invert this .. could be a problem

		Local dist22#=Sqr((xdiff#*xdiff#)+(zdiff#*zdiff#))
		Local pitch#=ATan2(ydiff#,dist22#)
		Local yaw#=ATan2(xdiff#,zdiff#)

		Self.RotateEntity pitch#,yaw#,roll#,True
		
	End Method
		
	' Entity animation

	' load anim seq - copies anim data from mesh to self
	Method LoadAnimSeq(file:String)
	
		If FileType(file)=0 Then Return 0
	
		' mesh that we will load anim seq from
		Local mesh:TMesh=TModel.LoadAnimB3D:TMesh(file)
		
		If anim=False Then Return 0 ' self contains no anim data
		If mesh.anim=False Then Return 0 ' mesh contains no anim data
	
		no_seqs=no_seqs+1
		
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' update anim_seqs array
		anim_seqs_first[no_seqs]=anim_seqs_last[0]
		anim_seqs_last[no_seqs]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		' update anim_seqs_last[0] - sequence 0 is for all frames, so this needs to be increased
		' must be done after updating anim_seqs array above
		anim_seqs_last[0]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		If mesh&lt;&gt;Null

			' go through all bones belonging to self
			For Local bone:TBone=EachIn TMesh(Self).bones
			
				' find bone in mesh that matches bone in self - search based on bone name
				Local mesh_bone:TBone=TBone(TEntity(mesh).FindChild(bone.name$))
			
				If mesh_bone&lt;&gt;Null
			
					' resize self arrays first so the one empty element at the end is removed
					bone.keys.flags=bone.keys.flags[..bone.keys.flags.length-1]
					bone.keys.px=bone.keys.px[..bone.keys.px.length-1]
					bone.keys.py=bone.keys.py[..bone.keys.py.length-1]
					bone.keys.pz=bone.keys.pz[..bone.keys.pz.length-1]
					bone.keys.sx=bone.keys.sx[..bone.keys.sx.length-1]
					bone.keys.sy=bone.keys.sy[..bone.keys.sy.length-1]
					bone.keys.sz=bone.keys.sz[..bone.keys.sz.length-1]
					bone.keys.qw=bone.keys.qw[..bone.keys.qw.length-1]
					bone.keys.qx=bone.keys.qx[..bone.keys.qx.length-1]
					bone.keys.qy=bone.keys.qy[..bone.keys.qy.length-1]
					bone.keys.qz=bone.keys.qz[..bone.keys.qz.length-1]
					
					' add mesh bone key arrays to self bone key arrays
					bone.keys.frames=anim_seqs_last[0]
					bone.keys.flags=bone.keys.flags+mesh_bone.keys.flags
					bone.keys.px=bone.keys.px+mesh_bone.keys.px
					bone.keys.py=bone.keys.py+mesh_bone.keys.py
					bone.keys.pz=bone.keys.pz+mesh_bone.keys.pz
					bone.keys.sx=bone.keys.sx+mesh_bone.keys.sx
					bone.keys.sy=bone.keys.sy+mesh_bone.keys.sy
					bone.keys.sz=bone.keys.sz+mesh_bone.keys.sz
					bone.keys.qw=bone.keys.qw+mesh_bone.keys.qw
					bone.keys.qx=bone.keys.qx+mesh_bone.keys.qx
					bone.keys.qy=bone.keys.qy+mesh_bone.keys.qy
					bone.keys.qz=bone.keys.qz+mesh_bone.keys.qz
				
				EndIf
				
			Next
				
		EndIf
		
		mesh.FreeEntity()
		
		Return no_seqs
	
	End Method
	
	Method ExtractAnimSeq(first_frame,last_frame,seq=0)
	
		no_seqs=no_seqs+1
	
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' if seq specifed then extract anim sequence from within existing sequnce
		Local offset=0
		If seq&lt;&gt;0
			offset=anim_seqs_first[seq]
		EndIf
	
		anim_seqs_first[no_seqs]=first_frame+offset
		anim_seqs_last[no_seqs]=last_frame+offset
		
		Return no_seqs
	
	End Method

	Method Animate(mode=1,speed#=1.0,seq=0,trans=0)
	
		anim_mode=mode
		anim_speed#=speed#
		anim_seq=seq
		anim_trans=trans
		anim_time#=anim_seqs_first[seq]
		anim_update=True ' update anim for all modes (including 0)
		
		If trans&gt;0
			anim_time#=0
		EndIf
		
	End Method
	
	' Updates:
	' 30/01/06 - updated to make anim_time return wrapped value
	Method SetAnimTime(time#,seq=0)
	
		anim_mode=-1 ' use a mode of -1 for setanimtime
		anim_speed#=0
		anim_seq=seq
		anim_trans=0
		anim_time#=time#
		anim_update=False ' set anim_update to false so UpdateWorld won't animate entity

		Local first=anim_seqs_first[anim_seq]
		Local last=anim_seqs_last[anim_seq]
		Local first2last=anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq]
		
		time#=time#+first ' offset time so that anim time of 0 will equal first frame of sequence
		
		If time#&gt;last And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#-first2last
			Until time#&lt;=last
		EndIf
		If time#&lt;first And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#+first2last
			Until time#&gt;=first
		EndIf
		
		TAnimation.AnimateMesh(Self,time#,first,last)

		anim_time#=time# ' update anim_time# to equal time#

	End Method
	
	Method AnimSeq()
	
		Return anim_seq ' current anim sequence
	
	End Method
	
	Method AnimLength()
	
		Return anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq] ' no of frames in anim sequence
	
	End Method

	Method AnimTime#()
	
		' if animation in transition, return 0 (anim_time actually will be somewhere between 0 and 1)
		If anim_trans&gt;0 Then Return 0
		
		' for animate and setanimtime we want to return anim_time starting from 0 and ending at no. of frames in sequence
		If anim_mode&gt;0 Or anim_mode=-1
			Return anim_time#-anim_seqs_first[anim_seq]
		EndIf

		Return 0

	End Method
	
	Method Animating()
	
		If anim_trans&gt;0 Then Return True
		If anim_mode&gt;0 Then Return True
		
		Return False
	
	End Method
		
	' Entity control

	Method EntityColor(r#,g#,b#)
	
		brush.red  =r#/255.0
		brush.green=g#/255.0
		brush.blue =b#/255.0
	
	End Method

	Method EntityAlpha(a#)
	
		brush.alpha=a#
			
	End Method
	
	Method EntityShininess(s#)
	
		brush.shine=s#
	
	End Method

	Method EntityTexture(texture:TTexture,frame=0,index=0)

		brush.tex[index]=texture
		If index+1&gt;brush.no_texs Then brush.no_texs=index+1
		
		If frame&lt;0 Then frame=0
		If frame&gt;texture.no_frames-1 Then frame=texture.no_frames-1 
		brush.tex_frame=frame
	
	End Method
	
	Method EntityBlend(blend_no)
	
		brush.blend=blend_no
		
		If TMesh(Self)&lt;&gt;Null
		
			' overwrite surface blend modes with master blend mode
			For Local surf:TSurface=EachIn TMesh(Self).surf_list
				If surf.brush&lt;&gt;Null
					surf.brush.blend=brush.blend
				EndIf
			Next
			
		EndIf
		
	End Method
	
	Method EntityFX(fx_no)
	
		brush.fx=fx_no
		
	End Method
	
	Method EntityAutoFade(near#,far#)
	
		auto_fade=True
		fade_near=near#
		fade_far=far#
	
	End Method
	
	Method PaintEntity(bru:TBrush)
	
		brush.no_texs=bru.no_texs
		brush.name$=bru.name$
		brush.red#=bru.red#
		brush.green#=bru.green#
		brush.blue#=bru.blue#
		brush.alpha#=bru.alpha#
		brush.shine#=bru.shine#
		brush.blend=bru.blend
		brush.fx=bru.fx
		For Local i=0 To 7
			brush.tex[i]=bru.tex[i]
		Next
	
	End Method
	
	Method EntityOrder(order_no)
	
		order=order_no

		If TCamera(Self)&lt;&gt;Null
			ListRemove(TCamera.cam_list,Self)
			EntityListAdd(TCamera.cam_list)
		EndIf

	End Method
	
	Method ShowEntity()
	
		hide=False
		
	End Method

	Method HideEntity()

		hide=True

	End Method

	Method Hidden()
	
		If hide=True Return True
		
		Local ent:TEntity=parent
		While ent&lt;&gt;Null
			If ent.hide=True Return True
			ent=ent.parent
		Wend
		
		Return False
	
	End Method

	Method NameEntity(e_name$)
	
		name$=e_name$
	
	End Method
	
	Method EntityParent(parent_ent:TEntity,glob=True)	

		MQ_SetParent(parent_ent, glob)	
		need_update = True
		'MQ_Update()
		
	End Method
		
	Method GetParent:TEntity()			
		Return parent	
	End Method

	' Entity state
	Method EntityX#(glob=False)			
		If glob Then
			If need_update Then MQ_Update()
			Return mat.grid[3,0]
		Else
			Return px
		End If
	End Method
	
	Method EntityY#(glob=False)
		If glob Then
			If need_update Then MQ_Update()
			Return mat.grid[3,1]
		Else
			Return py
		End If
	End Method
	
	Method EntityZ#(glob=False)
		If glob Then
			If need_update Then MQ_Update()
			Local v# = mat.grid[3,2]
			Return -v
		Else
			Return pz
		End If
	End Method

	Method EntityPitch#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetPitch()
		Else
			'use local matrix
			Return rotmat.GetPitch()
		End If
	End Method
	
	Method EntityYaw#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetYaw()
		Else
			'use local matrix
			Return rotmat.GetYaw()
		End If
	End Method
	
	Method EntityRoll#(glob=False)	
		If glob Then
			'use global matrix
			Return MQ_GetMatrix(False).GetRoll()
		Else
			'use local matrix
			Return rotmat.GetRoll()
		End If
	End Method
	
	Method EntityClass$()
		
		Return class$
		
	End Method
	
	Method EntityName$()
		
		Return name$
		
	End Method
	
	Method CountChildren()

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1

		Next

		Return no_children

	End Method
	
	Method GetChild:TEntity(child_no)

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

		no_children=no_children+1
			If no_children=child_no Return ent

		Next

		Return Null
	
	End Method
	
	Method FindChild:TEntity(child_name$)
	
		Local cent:TEntity
	
		For Local ent:TEntity=EachIn child_list

			If ent.EntityName$()=child_name$ Return ent

			cent=ent.FindChild(child_name$)
			
			If cent&lt;&gt;Null Return cent
	
		Next

		Return Null
	
	End Method
	
	' Calls function in TPick
	Method EntityPick:TEntity(range#)
	
		Return TPick.EntityPick:TEntity(Self,range#)
	
	End Method
	
	' Calls function in TPick
	Method LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
		Return TPick.LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
	End Method
	
	' Calls function in TPick
	Method EntityVisible(src_entity:TEntity,dest_entity:TEntity)
	
		Return TPick.EntityVisible(src_entity,dest_entity)
	
	End Method
	
	Method EntityDistance#(ent2:TEntity)

		Return Sqr(Self.EntityDistanceSquared#(ent2))

	End Method
	
	' Function by Vertex
	Method DeltaYaw#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		'Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
		
		Return -ATan2(x#,z#)

	End Method
	
	' Function by Vertex
	Method DeltaPitch#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
	
		Return -ATan2(y#,Sqr(x#*x#+z#*z#))
	
	End Method

	Function TFormPoint(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)		

		Local mat1:TMatrix
		Local mat2:TMatrix
		
		'get src matrix	
		If src_ent &lt;&gt; Null Then
			mat1:TMatrix = src_ent.MQ_GetMatrix()
		End If
	
		'get dest matrix
		If dest_ent &lt;&gt; Null Then
			mat2:TMatrix = dest_ent.MQ_GetInvMatrix()
		End If 	
	
		'transform point by matrix
		If src_ent  &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
		If dest_ent &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormVector(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		
		Local mat1:TMatrix
		Local mat2:TMatrix 
	
		'get src matrix	
		If src_ent &lt;&gt; Null Then
			mat1:TMatrix = src_ent.MQ_GetMatrix()
			mat1.grid[3,0] = 0 'remove translation
			mat1.grid[3,1] = 0
			mat1.grid[3,2] = 0
		End If
	
		'get dest matrix
		If dest_ent &lt;&gt; Null Then
			mat2:TMatrix = dest_ent.MQ_GetInvMatrix()		
			mat2.grid[3,0] = 0 'remove translation
			mat2.grid[3,1] = 0
			mat2.grid[3,2] = 0
		End If 	
	
		'transform point by matrix
		If src_ent  &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
		If dest_ent &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormNormal(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)	
		
		TFormVector(x,y,z,src_ent,dest_ent)
		
		x# = tformed_x#
		y# = tformed_y#
		z# = tformed_z#
		
		Local dd# = Magnitude(x,y,z)
		If dd &lt;&gt; 0 Then
			x=x/dd
			y=y/dd
			z=z/dd
		End If
		
		tformed_x#=x		
		tformed_y#=y
		tformed_z#=z
	End Function
	
	Function TFormedX#()
	
		Return tformed_x#
	
	End Function
	
	Function TFormedY#()
	
		Return tformed_y#
	
	End Function
	
	Function TFormedZ#()
	
		Return tformed_z#
	
	End Function
	
	Method GetMatElement#(row,col)
	
		Return mat.grid[row,col]
	
	End Method
	
	' Entity collision
	
	Method ResetEntity()
	
		no_collisions=0
		collision=collision[..0]
		old_x=EntityX(True)
		old_y=EntityY(True)
		old_z=EntityZ(True)
	
	End Method
	
	Method EntityRadius(rx#,ry#=0.0)
	
		radius_x#=rx#
		If ry#=0.0 Then radius_y#=rx# Else radius_y#=ry#
	
	End Method
	
	Method EntityBox(x#,y#,z#,w#,h#,d#)
	
		box_x#=x#
		box_y#=y#
		box_z#=z#
		box_w#=w#
		box_h#=h#
		box_d#=d#
	
	End Method

	Method EntityType(type_no,recursive=False)
	
		' add to collision entity list if new type no&lt;&gt;0 and not previously added
		If collision_type=0 And type_no&lt;&gt;0
		
			If TCollisionPair.ent_lists[type_no]=Null Then TCollisionPair.ent_lists[type_no]=CreateList() ' create new list is one doesn't exist
			
			ListAddLast(TCollisionPair.ent_lists[type_no],Self)
			
		EndIf
		
		' remove from collision entity list if new type no=0 and previously added
		If collision_type&lt;&gt;0 And type_no=0
			ListRemove(TCollisionPair.ent_lists[type_no],Self)
		EndIf
		
		collision_type=type_no
		
		old_x#=EntityX(True)
		old_y#=EntityY(True)
		old_z#=EntityZ(True)
	
		If recursive=True
		
			For Local ent:TEntity=EachIn child_list
			
				ent.EntityType(type_no,True)
			
			Next
		
		EndIf
		
	End Method
	
	Method EntityPickMode(no,obscure=True)
	
		' add to pick entity list if new mode no&lt;&gt;0 and not previously added
		If pick_mode=0 And no&lt;&gt;0
			ListAddLast(TPick.ent_list,Self)
		EndIf
		
		' remove from pick entity list if new mode no=0 and previously added
		If pick_mode&lt;&gt;0 And no=0
			ListRemove(TPick.ent_list,Self)
		EndIf
	
		pick_mode=no
		obscurer=obscure
			
	End Method
	
	Method EntityCollided:TEntity(type_no)

		' if self is source entity and type_no is dest entity
		For Local i=1 To CountCollisions()
			If CollisionEntity(i).collision_type=type_no Then Return CollisionEntity(i)
		Next

		' if self is dest entity and type_no is src entity
		For Local ent:TEntity=EachIn TCollisionPair.ent_lists[type_no]
			For Local i=1 To ent.CountCollisions()
				If CollisionEntity(i)=Self Then Return ent		
			Next
		Next

		Return Null

	End Method
	
	Method CountCollisions()
	
		Return no_collisions
	
	End Method
	
	Method CollisionX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].x#
		
		EndIf
	
	End Method
	
	Method CollisionY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].y#
		
		EndIf
	
	End Method
	
	Method CollisionZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].z#
		
		EndIf
	
	End Method

	Method CollisionNX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nx#
		
		EndIf
	
	End Method
	
	Method CollisionNY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ny#
		
		EndIf
	
	End Method
	
	Method CollisionNZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nz#
		
		EndIf
	
	End Method
	
	Method CollisionTime#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].time#
		
		EndIf
	
	End Method
	
	Method CollisionEntity:TEntity(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ent
		
		EndIf
	
	End Method
	
	Method CollisionSurface:TSurface(index)
	
		If index&gt;0 And index&lt;=no_collisions

			Return collision[index-1].surf
		
		EndIf
	
	End Method
	
	Method CollisionTriangle(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].tri
		
		EndIf
	
	End Method
	
	Method GetEntityType()

		Return collision_type

	End Method
	
	' Sets an entity's mesh cull radius
	Method MeshCullRadius(radius#)
	
		' set to negative no. so we know when user has set cull radius (manual cull)
		' a check in TMesh.GetBounds then prevents negative no. being overwritten by a positive cull radius (auto cull)
		cull_radius#=-radius#
	
	End Method
	
	Method EntityScaleX#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return w
	End Method
	
	Method EntityScaleY#(glob=False)
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return h
	End Method
	
	Method EntityScaleZ#(glob=False)	
		Local w#,h#,d#
		MQ_GetScaleXYZ(w#,h#,d#,glob)
		Return d
	End Method

	' Returns an entity's bounding sphere
	Method BoundingSphereNew(sx# Var,sy# Var,sz# Var,sr# Var)

		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=tformed_x
			y=tformed_y
			z=tformed_z
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		sx=x
		sy=y
		sz=z
		sr=radius

	End Method
	
	Function CountAllChildren(ent:TEntity,no_children=0)
		
		Local ent2:TEntity
	
		For ent2=EachIn ent.child_list

			no_children=no_children+1
			
			no_children=TEntity.CountAllChildren(ent2,no_children)

		Next

		Return no_children

	End Function
	
	Method GetChildFromAll:TEntity(child_no,no_children Var,ent:TEntity=Null)

		If ent=Null Then ent=Self
		
		Local ent3:TEntity=Null
		
		For Local ent2:TEntity=EachIn ent.child_list

			no_children=no_children+1
			
			If no_children=child_no Then Return ent2
			
			If ent3=Null
			
				ent3=GetChildFromAll(child_no,no_children,ent2)

			EndIf

		Next

		Return ent3
			
	End Method
	
	' Internal - not recommended for general use

	Method UpdateMat(load_identity=False)
		'MQ_Update()
		need_update = True
		'mat.Overwrite(MQ_GetMatrix())
	End Method
	
	Method AddParent(parent_ent:TEntity)
	
		' self.parent = parent_ent
		parent:TEntity=parent_ent
		
		' add self to parent_ent child list
		If parent&lt;&gt;Null

			mat.Overwrite(parent.mat)
		
			ListAddLast(parent.child_list,Self)
		
		EndIf
		
	End Method
	
	Function UpdateChildren(ent_p:TEntity)
	
		For Local ent_c:TEntity=EachIn ent_p.child_list

			ent_c.mat.Overwrite(ent_p.mat)
			ent_c.UpdateMat()
				
			UpdateChildren(ent_c:TEntity)
			
		Next
	
	End Function

	' unoptimised, unused
	Method EntityDistanceSquared0#(ent2:TEntity)

		Local xd# = ent2.EntityX#(True)-EntityX#(True)
		Local yd# = ent2.EntityY#(True)-EntityY#(True)
		Local zd# = ent2.EntityZ#(True)-EntityZ#(True)
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method
	
	' optimised
	Method EntityDistanceSquared#(ent2:TEntity)

		If need_update Then MQ_Update()
		If ent2.need_update Then ent2.MQ_Update()

		Local xd# = ent2.mat.grid[3,0]-mat.grid[3,0]
		Local yd# = ent2.mat.grid[3,1]-mat.grid[3,1]
		Local zd# = -ent2.mat.grid[3,2]+mat.grid[3,2]
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method

	Method EntityListAdd(list:TList)
	
		' if order&gt;0, drawn first
		' if order&lt;0, drawn last
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=order Or TEntity(llink.Value()).order&lt;=0
	
			link=list.InsertBeforeLink(Self,llink)
			Return
	
		Else ' put entities with order=0 at back of list, so cameras with order=0 are sorted the same as in B3D

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=order Or TEntity(llink.Value()).order&gt;=0
	
			link=list.InsertAfterLink(Self,llink)
			Return

		EndIf

	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											BEGIN MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------

	'returns copy of rotation matrix	
	Method MQ_CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = rotmat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method

'		Local q1_x#, q1_y#, q1_z#, q1_w#
'		Local q2_x#, q2_y#, q2_z#, q2_w#
'		Local q3_x#, q3_y#, q3_z#, q3_w#
'		Local m1:TMatrix = TMatrix.Create()
'		Local m2:TMatrix = TMatrix.Create()
'				
'		Quaternion_FromAngleAxis(  pitch, -1,  0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
'		Quaternion_FromAngleAxis(  yaw,    0,  1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
'		Quaternion_FromAngleAxis(  roll,   0,  0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
'		
'		'convert to matrices	
'		m1.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
'		m2.FromQuaternion(q2_x, q2_y, q2_z, q2_w)
'		
'		'apply
'		rotmat.FromQuaternion(q3_x, q3_y, q3_z, q3_w) 'roll
'		rotmat.Multiply2(m1) 'pitch
'		rotmat.Multiply2(m2) 'yaw
	
	'turn entity
	Method MQ_Rotate( pitch#, yaw#, roll#, glob=False )

		Local m2:TMatrix = TMatrix.Create()
	
		rotmat.LoadIdentity()
		rotmat.Rotate(pitch, yaw, roll)
		
		If glob Then
			'get parent inverted rotation matrix
			If parent &lt;&gt; Null Then
				m2:TMatrix = parent.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
				'apply rotation matrix
				rotmat.Multiply2(m2)
			End If
		End If
		
	End Method

	'turn entity
	Method MQ_Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then		
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'turn entity
	Method MQ_Turn2( pitch#,yaw#,roll#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		Local q2_x#, q2_y#, q2_z#, q2_w#
		Local q3_x#, q3_y#, q3_z#, q3_w#
		Local qr_x#, qr_y#, qr_z#, qr_w#
		
		Quaternion_FromAngleAxis( pitch, 1,0,0, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Quaternion_FromAngleAxis( yaw,   0,1,0, q2_x#, q2_y#, q2_z#, q2_w# ) 'create quaternion
		Quaternion_FromAngleAxis( roll,  0,0,1, q3_x#, q3_y#, q3_z#, q3_w# ) 'create quaternion

		Quaternion_MultiplyQuat( q1_x#, q1_y#, q1_z#, q1_w#, q2_x#, q2_y#, q2_z#, q2_w#, qr_x#, qr_y#, qr_z#, qr_w# )
		Quaternion_MultiplyQuat( qr_x#, qr_y#, qr_z#, qr_w#, q3_x#, q3_y#, q3_z#, q3_w#, q1_x#, q1_y#, q1_z#, q1_w# )
		
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method MQ_TransformPoint( ix# Var,iy# Var,iz# Var)
		
		rotmat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method MQ_Position( qx#,qy#,qz#, glob=False )
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then 
				TFormPoint(qx, qy, qz, Null, parent)
				qx = tformed_x
				qy = tformed_y
				qz = tformed_z
			End If
		End If
		
		px = qx
		py = qy
		pz = qz

	End Method

	'move an entity
	Method MQ_Move( qx#,qy#,qz# )
		MQ_TransformPoint(qx,qy,qz) 'transform point by internal matrix
		px = px + qx 'add to position
		py = py + qy
		pz = pz + qz
	
	End Method

Rem
	'get inverted matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat0:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat0 = parent.MQ_GetInvMatrix(scale)
		Else
			mat0 = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = MQ_CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-px,-py, pz)
		
		'combine
		mat1.Multiply2(mat3)
		mat2.Multiply2(mat1)
		mat0.Multiply2(mat2)
		
		Return mat0
		
	End Method

	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local ipz#
			
		'scale
		mat3:TMatrix = TMatrix.Create()
		If scale Then mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(px, py, -pz)
		'rotation
		mat1:TMatrix = rotmat.Copy()

		mat3.Multiply2(mat1)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat3.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat3
		
	End Method
EndRem	

	'get matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix(scale=True)
			
		Local mat1:TMatrix = TMatrix.Create()
		Local isx#,isy#,isz#
		
		If sx = 0 Then isx = 1 Else isx = sx
		If sy = 0 Then isy = 1 Else isy = sy
		If sz = 0 Then isz = 1 Else isz = sz
		mat1.grid[0,0]=rotmat.grid[0,0]/sx
		mat1.grid[0,1]=rotmat.grid[1,0]/sx
		mat1.grid[0,2]=rotmat.grid[2,0]/sx
		mat1.grid[1,0]=rotmat.grid[0,1]/sy
		mat1.grid[1,1]=rotmat.grid[1,1]/sy
		mat1.grid[1,2]=rotmat.grid[2,1]/sy
		mat1.grid[2,0]=rotmat.grid[0,2]/sz
		mat1.grid[2,1]=rotmat.grid[1,2]/sz
		mat1.grid[2,2]=rotmat.grid[2,2]/sz
		mat1.grid[3,0]=-px
		mat1.grid[3,1]=-py
		mat1.grid[3,2]=pz

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1.Multiply2(parent.MQ_GetInvMatrix(scale))
		End If
		
		Return mat1
		
	End Method

	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix(scale=True)
			
		Local mat1:TMatrix = TMatrix.Create()
		
		mat1.grid[0,0]=rotmat.grid[0,0]*sx
		mat1.grid[0,1]=rotmat.grid[0,1]*sx
		mat1.grid[0,2]=rotmat.grid[0,2]*sx
		mat1.grid[1,0]=rotmat.grid[1,0]*sy
		mat1.grid[1,1]=rotmat.grid[1,1]*sy
		mat1.grid[1,2]=rotmat.grid[1,2]*sy
		mat1.grid[2,0]=rotmat.grid[2,0]*sz
		mat1.grid[2,1]=rotmat.grid[2,1]*sz
		mat1.grid[2,2]=rotmat.grid[2,2]*sz
		mat1.grid[3,0]=px
		mat1.grid[3,1]=py
		mat1.grid[3,2]=-pz

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1.Multiply2(parent.MQ_GetMatrix(scale))
		End If
		
		Return mat1
		
	End Method

	'update attached entity
	Method MQ_Update()
			
		mat.Overwrite(MQ_GetMatrix(True))		
		need_update = False

		'update child_list		
		Local e:TEntity
		For e:TEntity = EachIn child_list
			e.MQ_Update
		Next

	End Method

	'set scaling for an entity
	Method MQ_Scale( w#, h#, d#, glob )
	
		Local xx#,yy#,zz#
		Local ll#

		If glob Then
			If h &lt;&gt; 0 Then
				xx = 0
				yy = 1 / h
				zz = 0
				TFormVector xx, yy, zz, Self, Null
				xx = tformed_x
				yy = tformed_y
				zz = tformed_z
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then h = 1 / ll
			End If
	
			If w &lt;&gt; 0 Then
				xx = 1 / w
				yy = 0
				zz = 0
				TFormVector xx, yy, zz, Self, Null
				xx = tformed_x
				yy = tformed_y
				zz = tformed_z
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then w = 1 / ll
			End If
				
			If d &lt;&gt; 0 Then
				xx = 0
				yy = 0
				zz = 1 / w
				TFormVector xx, yy, zz, Self, Null
				xx = tformed_x
				yy = tformed_y
				zz = tformed_z				
				ll = Magnitude(xx, yy, zz)
				If ll &lt;&gt; 0 Then d = 1 / ll
			End If
		End If

		sx = w
		sy = h
		sz = d

	End Method


	'set an entity's parent	
	Method MQ_SetParent(e:TEntity, glob)
	
		Local orgx#,orgy#,orgz#
		Local orgw#,orgh#,orgd#
		Local neww#,newh#,newd#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			TFormPoint(0, 0, 0, Self, Null)
			orgx = tformed_x
			orgy = tformed_y
			orgz = tformed_z
			m1:TMatrix = MQ_GetMatrix(False)
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
			'get scaling
			MQ_GetScaleXYZ(orgw#,orgh#,orgd#)
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.child_list, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then
				TFormPoint(orgx, orgy, orgz, Null, e)
				orgx = tformed_x
				orgy = tformed_y
				orgz = tformed_z
			End If
			'set position
			px = orgx
			py = orgy
			pz = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.MQ_GetInvMatrix(False)
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			m1.Multiply2(m2)
			rotmat.Overwrite(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.child_list, Self

		'get scaling
		MQ_GetScaleXYZ(neww#,newh#,newd#)
		If neww &lt;&gt; 0 Then sx = sx * orgw / neww
		If newh &lt;&gt; 0 Then sy = sy * orgh / newh
		If newd &lt;&gt; 0 Then sz = sz * orgd / newd
	
	End Method

	'get entity scale	
	Method MQ_GetScaleXYZ(width# Var, height# Var, depth# Var, glob=True)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		If glob Then 
			m:TMatrix = MQ_GetMatrix()
		Else
			m:TMatrix = TMatrix.Create()
			m.Scale(sx, sy, sz)
		End If
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											END MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------
End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											AlignToVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function AlignToVector2(e:TEntity, x#, y#, z#, axis=3, rate#=1.0)

	If axis&lt;1 Or axis&gt;3 Then Return

	Local ax#,ay#,az#
	Local dd#
	Local m:TMatrix = TMatrix.Create()
	
	'normalize
	dd# = Magnitude(x,y,z)
	If dd &lt; 0.000001 Then Return
	x = x / dd
	y = y / dd
	z = z / dd	

	'get original axis	
	ax# = (axis=1)
	ay# = (axis=2)
	az# = (axis=3)
	TFormNormal ax, ay, az, e, Null
	ax =  TFormedX()
	ay =  TFormedY()
	az =  TFormedZ()
	
 	'get transformation matrix from org. axis to new one
	m.FromToRotation(ax,ay,-az, x,y,-z)
	
	'interpolate
	If rate &lt; 1.0 Then
		m:TMatrix = InterpolateMatrix(m, rate)
	End If
	
     'apply matrix
	e.rotmat.Multiply2(m)
	e.need_update = True
'	e.MQ_Update()
			 		
End Function

'update entity matrix
Function UpdateEntities()

	Local e:TEntity
	For e:TEntity = EachIn TEntity.entity_list
		If e.need_update Then e.MQ_Update()
	Next

End Function
</textarea> <br><br></td></tr></table><br>
<a name="965674"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> it says 'interpolate matrix not found' <br><br></td></tr></table><br>
<a name="965730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is just TEntity.bmx. It also requires TMatrix/TGlobal/TAnimation from the archive entry to work. "InterpolateMatrix" is part of TMatrix.bmx. <br><br></td></tr></table><br>
<a name="965790"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FreetimeCoder</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hm there is a speed-increase. But not a big one. I get ~ 44 fps. But there are no errors an everything seems to work just as well as before.<br><br>greetings <br><br></td></tr></table><br>
<a name="965804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, well back to the drawing board.. I'll look further into it. <br><br></td></tr></table><br>
<a name="968424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I need this too, but I don't know where to get the TMatrix class code. I feel like I'm missing something?? <br><br></td></tr></table><br>
<a name="968642"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's in the archive:<br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2498" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2498</a> <br><br></td></tr></table><br>
<a name="968645"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
