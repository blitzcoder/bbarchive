<!DOCTYPE html><html lang="en" ><head ><title >Matrices</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Matrices</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=119" >MiniB3D Module</a>/<a href="#bottom" >Matrices</a><br><br>
<a name="961576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Resulting code is in archive, see here:<br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2498" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2498</a><br><br>Original post:<br>---------------------------------------------------------------------------<br>I'm working on a set of functions that use matrices in minib3d, since I need a global TurnEntity, and an improved parenting system.<br>It is not complete, but it has Move, Turn and Parent commands.<br>The idea is that this module can later on be intergrated with minib3d's TEntity and TMatrix.<br><br>Because I saw other people working on this as well, and Simon announced he wanted to include quaternions in minib3d, I thought it might be a good idea to post this here. Hopefully someone can jump in with improvements/additions.<br>So if you can contribute anything to it, please do so. On the other hand, if this is not necessary, please tell me, since I find this matrices/quats stuff somewhat difficult to understand.<br><br>To run this, you need Noel's math3d lib from the archive:<br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=1463" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=1463</a><br>It is very helpful, well-written and complete. Thanks Noel.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll# )
		
		q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( vec:Vector3 )
		
		x = vec.x
		y = vec.y
		z = vec.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
	End Method

	'update attached entity
	Method Update()

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
		
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity)
	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If
		
		If e = Null Then Return
		
		parent = e
		ListAddLast parent.children, Self
	
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#) )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll# )

	e.Rotate(pitch, yaw, roll)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity)

	If e = Null Then Return
	e.SetParent(e2)
	e2.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	cam:TCamera = CreateCamera()
	MoveEntity cam, 0, 0, -15
	
	'create an entity
	e1:Entity = Entity.Create(CreateCube())
	'access attached minib3d entity
	EntityColor e1.ent, 0, 255, 0

	'create an entity
	e2:Entity = Entity.Create(CreateCube())
	'move it, and attach it to first entity
	MoveEntity2 e2, 0, 3, 0
	EntityParent2 e2, e1
	
	e3:Entity = Entity.Create(CreateCube())
	MoveEntity2 e3, 0, 3, 0
	EntityParent2 e3, e2
	
	'turn yaw 90 degrees
	'TurnEntity2  e1, 90, 0, 0

	''EXAMPLE3: ScaleEntity2
	''scale entity width 2x
	'ScaleEntity2 e2, 1, 1, 2
	
	Repeat
	
		'ang# = ang# + 1	
		'RotateEntity2 e1, 90, ang#, 0

		TurnEntity2 e1, 0, 1, 1
		TurnEntity2 e2, 0, 1, 0
		TurnEntity2 e3, 0, 1, 0
				
		RenderWorld
		Flip
		
	Until KeyHit(key_escape)
	
	End
</textarea><br>It simulates Blitz3D, however the Yaw is reverted somehow. <br><br></td></tr></table><br>
<a name="961583"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks, should be useful <br><br></td></tr></table><br>
<a name="961595"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Updated: adding 'global' flag for TurnEntity2, and added RotateEntity2.<br>Updated2: added ScaleEntity2 <br><br></td></tr></table><br>
<a name="961623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> could you run this code and see what happens?<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import sidesign.minib3d
Import cower.math3d
Global gfxwidth=800
Global gfxheight=600
AppTitle= "Look for bugs"
Graphics3D gfxwidth,gfxheight
'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)
SeedRnd MilliSecs()
Global bullet_type=1
Global ship_type=2


Global camera:Tcamera=CreateCamera()


Local ship:Tentity=LoadMesh("11.b3d")

EntityRadius ship,2
EntityType ship,ship_Type
EntityPickMode ship,1

HideEntity ship

Global player_ship:Tentity=CopyEntity (ship)

ShowEntity player_Ship

Local player_pivot:TPivot=CreatePivot(player_ship)

Global fighterbullet:Tsprite=LoadSprite("fighterbullet.tga")

HideEntity fighterbullet
EntityRadius fighterbullet,0.5
EntityType fighterbullet,bullet_Type



PositionEntity camera,0,3,-5
Collisions bullet_type,ship_type,1,1
'RotateEntity camera,EntityPitch(player_ship,1),EntityYaw(player_ship,1),EntityRoll(player_Ship,1),1

PositionEntity player_ship,0,0,3
Global player_ship_ent:entity=entity.Create(player_ship)
Local camera_ent:entity=Entity.Create(Camera)
EntityParent2 camera_ent,player_ship_ent

PositionEntity2 camera_ent,0,2,5

While Not KeyHit(KEY_ESCAPE)
Cls
If MouseHit(1)
bullet.Create()
EndIf
bullet.update()
Mouselook(player_ship_ent)
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

'If EntityDistance(player_ship,cube)&lt;50
'MoveEntity2 player_Ship_ent,0,0,1
'Else
'EntityParent2 player_ship_ent,Null
'EndIf

UpdateWorld
RenderWorld

Flip
Wend

Type bullet
Global list:TList=New TList
Field model_handle:Tentity
Field entity_handle:entity
Function Create()
Local t:bullet=New bullet
t.model_handle=CopyEntity (fighterbullet)
t.entity_handle=entity.Create(t.model_handle)
entityparent2(t.entity_handle,player_ship_ent)
bullet.list.addlast(t)
EntityParent2(t.entity_handle,Null)
EndFunction

Function update()
For Local t:bullet=EachIn bullet.list
MoveEntity2 t.entity_handle,0,0,-1
Next
EndFunction
EndType

Function mousespeed(xy:Int)
If xy=1
'DebugLog "x mouse speed: "+Abs(MouseX()-prev_mouse_x)
Local slenkar=(MouseX()-(GraphicsWidth()/2))

Return slenkar
Else
'DebugLog "y mouse speed: "+Abs(MouseY()-prev_mouse_y)
Local slenkar=(MouseY()-(GraphicsHeight()/2))
Return slenkar
EndIf

EndFunction



Function Mouselook(RC:entity)

Local mx#=MouseSpeed(1)
Local my#=MouseSpeed(2)

If RC&lt;&gt;Null
turnentity2(rc,-my,-mx,0)
EndIf

End Function








Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )

		Local e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll# )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( vec:Vector3 )
		
		x = vec.x
		y = vec.y
		z = vec.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
		'scale
		Local mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		Local mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
	End Method

	'update attached entity
	Method Update()

		'get matrix transformed by parents
		Local mat4:Matrix = GetMatrix()
		
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For Local e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity)
	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If
		
		If e = Null Then Return
		
		parent = e
		ListAddLast parent.children, Self
	
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#) )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll# )

	e.Rotate(pitch, yaw, roll)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity)

	If e = Null Then Return
	e.SetParent(e2)
	If e2&lt;&gt;Null
	e2.Update()
	EndIf
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function</textarea><br><br><br>In blitz3d when you parent something to something else,<br>there is an option to have the child have the position and rotation of the parent<br><br>I tried to copy the ships matrix to the bullets matrix but it didnt work.<br><br>also rotateentity needs global and local<br>need entityyaw entitypitch entityroll<br>please compile in strict mode<br>when you parent an entity to NULL it crashes the program<br>thanks<br><br><br>basically i cant get the bullets to have the same rotation as the ship <br><br></td></tr></table><br>
<a name="961633"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> That example is still a bit too advanced for these simple routines.<br>Indeed it is missing the stuff you mention, so that should be a to-do list:<br><pre class=code>
1. Global parameter for Rotate/Position
2. Global parameter for EntityParent
3. Make compatible with Blitz3D
   - invert Yaw ?
</pre><br>As soon as I can work one of these out, I'll post it here.<br>Any suggestions welcome offcourse. <br><br></td></tr></table><br>
<a name="961651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> for entityrotate you seem to be doing it globally.<br><br>for local rotation you could multiply the matrix from q1.tomatrix() with the parent's matrix. if parent =null just return the matrix from q1.tomatrix()<br>same goes for position <br><br></td></tr></table><br>
<a name="961743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> EntityRotate2 acts locally. You can see that if you try the following:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 0, 0, -15

	Local e1:Entity = Entity.Create(CreateCube())
	
	Local e2:Entity = Entity.Create(CreateCone())
	PositionEntity2 e2, 0, 5, 0
	
	EntityParent2 e2, e1
	
	Repeat
	
		TurnEntity2 e1, 1, 0, 0
		RotateEntity2 e2, 90, 0, 0
			
		RenderWorld
		Flip
		
	Until KeyHit(key_escape)
	
	End			
</textarea><br>So I need to do the opposite: calculate what the rotation/position/scaling should be in order to maintain the original position when the entity is attached to another.<br>For now, I'm trying to create TFormPoint. Hopefully if I understand that, I can also create the other stuff.<br><br>The way it works now, is that each Entity has a matrix. In the method "Update" this matrix is multiplied by each parent matrix. So the scale/rotation/position of each child entity is local. <br><br></td></tr></table><br>
<a name="961757"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Update:TFormPoint2<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll# )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( vec:Vector3 )
		
		x = vec.x
		y = vec.y
		z = vec.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1 = mat1.TransformMat(parent.GetInvMatrix())
		End If

		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x, -y, -z)
		'rotation
		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)
		
		Return mat2
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity)
	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If
		
		If e = Null Then Return
		
		parent = e
		ListAddLast parent.children, Self
	
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#) )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll# )

	e.Rotate(pitch, yaw, roll)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity)

	If e = Null Then Return
	e.SetParent(e2)
	If e2 &lt;&gt; Null Then e2.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	p:Vector3 = Vector3.Create(x, y, z)

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 0, 0, -15

	Local e1:Entity = Entity.Create(CreateCube())

	Local e2:Entity = Entity.Create(CreateCube())
	PositionEntity2 e2, 0, 3, 0
	EntityParent2 e2, e1
	
	mx:Entity = Entity.Create(CreateCube())
	EntityColor mx.ent, 255, 0, 0
	PositionEntity2 mx, 0, 3, 0
	EntityParent2 mx, e2
		
	Repeat
	
		TurnEntity2 e1, 0, 1, 1
		
		pv:Vector3 = TFormPoint2(0, 4, 0, Null, e2)
		PositionEntity2 mx, pv.x, pv.y, pv.z
			
		RenderWorld
		Flip
		
	Until KeyHit(key_escape)
	
	End
</textarea> <br><br></td></tr></table><br>
<a name="961795"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> tformpoint works well,<br><br>about rotateentity ,if i rotate an entity locally to 0,0,0 shouldnt it face the same direction as its parent?<br>It does in your example but not mine:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import sidesign.minib3d
Import cower.math3d
Global gfxwidth=800
Global gfxheight=600
AppTitle= "Look for bugs"
Graphics3D gfxwidth,gfxheight
'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)

SeedRnd MilliSecs()
Global bullet_type=1
Global ship_type=2


Global camera:Tcamera=CreateCamera()


Local ship:Tentity=LoadMesh("11.b3d")

EntityRadius ship,2
EntityType ship,ship_Type
EntityPickMode ship,1

HideEntity ship

Global player_ship:Tentity=CopyEntity (ship)

ShowEntity player_Ship

Local player_pivot:TPivot=CreatePivot(player_ship)

Global fighterbullet:Tsprite=LoadSprite("fighterbullet.tga")

HideEntity fighterbullet
EntityRadius fighterbullet,0.5
EntityType fighterbullet,bullet_Type



PositionEntity camera,0,3,-5
Collisions bullet_type,ship_type,1,1
'RotateEntity camera,EntityPitch(player_ship,1),EntityYaw(player_ship,1),EntityRoll(player_Ship,1),1

PositionEntity player_ship,0,0,3
Global player_ship_ent:entity=entity.Create(player_ship)
Local camera_ent:entity=Entity.Create(Camera)
EntityParent2 camera_ent,player_ship_ent

PositionEntity2 camera_ent,0,2,5

While Not KeyHit(KEY_ESCAPE)
Cls
If MouseHit(1)
bullet.Create()
EndIf
bullet.update()
Mouselook(player_ship_ent)
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

'If EntityDistance(player_ship,cube)&lt;50
'MoveEntity2 player_Ship_ent,0,0,1
'Else
'EntityParent2 player_ship_ent,Null
'EndIf

UpdateWorld
RenderWorld

Flip
Wend

Type bullet
Global list:TList=New TList
Field model_handle:Tentity
Field entity_handle:entity
Function Create()
Local t:bullet=New bullet
t.model_handle=CopyEntity (fighterbullet)
t.entity_handle=entity.Create(t.model_handle)
entityparent2(t.entity_handle,player_ship_ent)
RotateEntity2(t.entity_handle,0,0,0)
EntityParent2(t.entity_handle,Null)
Local v:vector3=tformpoint2(0,0,-5,player_ship_ent,Null)
positionentity2(t.entity_handle,v.x,v.y,v.z)
bullet.list.addlast(t)'

EndFunction

Function update()
For Local t:bullet=EachIn bullet.list
MoveEntity2 t.entity_handle,0,0,-1
Next
EndFunction
EndType

Function mousespeed(xy:Int)
If xy=1
'DebugLog "x mouse speed: "+Abs(MouseX()-prev_mouse_x)
Local slenkar=(MouseX()-(GraphicsWidth()/2))

Return slenkar
Else
'DebugLog "y mouse speed: "+Abs(MouseY()-prev_mouse_y)
Local slenkar=(MouseY()-(GraphicsHeight()/2))
Return slenkar
EndIf

EndFunction



Function Mouselook(RC:entity)

Local mx#=MouseSpeed(1)
Local my#=MouseSpeed(2)

If RC&lt;&gt;Null
turnentity2(rc,-my,-mx,0)
EndIf

End Function




Rem
	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 0, 0, -15

	Local e1:Entity = Entity.Create(CreateCone())
	
	Local e2:Entity = Entity.Create(CreateCone())
	PositionEntity2 e2, 0, 5, 0
	
	EntityParent2 e2, e1
	
	Repeat
	
		TurnEntity2 e1, 1, 0, 0
		RotateEntity2 e2, 0, 0, 0
			
		RenderWorld
		Flip
		
	Until KeyHit(key_escape)
	
	End			
EndRem




'create global axes


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll# )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( vec:Vector3 )
		
		x = vec.x
		y = vec.y
		z = vec.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat1 = mat1.TransformMat(parent.GetInvMatrix())
		End If

		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x, -y, -z)
		'rotation
		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)
		
		Return mat2
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity)
	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If
		
		If e = Null Then Return
		
		parent = e
		ListAddLast parent.children, Self
	
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#) )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll# )

	e.Rotate(pitch, yaw, roll)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity)

	If e = Null Then Return
	e.SetParent(e2)
	If e2 &lt;&gt; Null Then e2.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	Local p:Vector3 = Vector3.Create(x, y, z)
	Local mat1:Matrix
	Local mat2:Matrix
	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		 mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function</textarea><br><br><br>becuase its a sprite? <br><br></td></tr></table><br>
<a name="961798"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Update: EntityParent has a 'global' parameter. Also, improved these global routines. Still not completely complete.<br>This example turns a 'spaceship' and fires 'bullets' in the same dir as the ship using the 'global' flag:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
'	Method GetInvMat:Matrix()
		


	'returns copy of rotation matrix	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll# )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( vec:Vector3 )
		
		x = vec.x
		y = vec.y
		z = vec.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		Local mat:Matrix

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat = parent.GetInvMatrix()
		Else
			mat = New Matrix
		End If

		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x,-y,-z)

		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat3.TransformMat(mat2)
		mat = mat2.TransformMat(mat)
		
		Return mat
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity, glob)

		'get global position/rotation
		If glob Then		
			pos:Vector3 = TFormPoint2(0, 0, 0, Self, Null)
			m1:Matrix = GetMatrix()
			m1.m03 = 0 'remove translation
			m1.m13 = 0
			m1.m23 = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, e)
			'set position
			x = pos.x
			y = pos.y
			z = pos.z
			'get parent inverted rotation matrix
			If e = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = e.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.children, Self
	
	End Method
	
	Method GetScaleXYZ:Vector3()
	
		m:Matrix = GetMatrix()
		v1:Vector3 = m.TransformVec(x_axis)
		v2:Vector3 = m.TransformVec(y_axis)
		v3:Vector3 = m.TransformVec(z_axis)		
		Return Vector3.Create(v1.Magnitude(), v2.Magnitude(), v3.Magnitude())
		
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#) )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll# )

	e.Rotate(pitch, yaw, roll)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity, glob=True)

	If e = Null Then Return

	e.SetParent(e2, glob)
	
	If e2 &lt;&gt; Null Then e2.Update() Else e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	p:Vector3 = Vector3.Create(x, y, z)

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 15, 0, 0
	RotateEntity cam, 0, 90, 0

	Local e1:Entity = Entity.Create(CreateCone())
	RotateMesh TMesh(e1.ent), 90, 0, 0

	Local e2:Entity = Entity.Create(CreateCone())
	ScaleMesh TMesh(e2.ent), 0.5, 0.5, 0.5
	RotateMesh TMesh(e2.ent), 90, 0, 0
	EntityColor e2.ent, 255, 0, 0
		
	Repeat
		
		If KeyDown(key_left)  TurnEntity2 e1,  0,  1, 0
		If KeyDown(key_right) TurnEntity2 e1,  0, -1, 0
		If KeyDown(key_up)	  TurnEntity2 e1,  1,  0, 0
		If KeyDown(key_down)  TurnEntity2 e1, -1,  0, 0
		
		If KeyDown(key_space)
			EntityParent2 e2, e1
			PositionEntity2 e2, 0, 0, 0
			RotateEntity2 e2, 0, 0, 0
			EntityParent2 e2, Null, True
		End If
		
		MoveEntity2 e2, 0, 0, 0.1
		
		RenderWorld
		
		BeginMax2D
		DrawText "press space to fire", 0, 20
		DrawText "use cursor keys to move aorund", 0, 0
		EndMax2D
		
		Flip
		
	Until KeyHit(key_escape)
	
	End
</textarea> <br><br></td></tr></table><br>
<a name="961800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> tformpoint works well,<br><br>about rotateentity ,if i rotate an entity locally to 0,0,0 shouldnt it face the same direction as its parent?<br>It does in your example but not mine: <br></div><br>Ow excuse me, missed your posted while typing mine. I'll look into that. Global rotations I find difficult, but maybe I can do something.<br>In the meanwhile, look at the sample above, it fires bullet from a spaceship. (In the opposite direction, but still)<br><br>Edit: you're right. There is something strange going on there.<br>Wait, no, it does seem to work: as long as there is a parent, RotateEntity will be relative to it. I'll try your example. <br><br></td></tr></table><br>
<a name="961807"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Update: added 'global' flag to PositionEntity and RotateEntity:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
'	Method GetInvMat:Matrix()
		


	'returns copy of rotation matrix	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll#, glob=False )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = parent.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(mat)
		End If
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( pos:Vector3, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, parent)
		End If
		
		x = pos.x
		y = pos.y
		z = pos.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		Local mat:Matrix

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat = parent.GetInvMatrix()
		Else
			mat = New Matrix
		End If

		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x,-y,-z)

		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat3.TransformMat(mat2)
		mat = mat2.TransformMat(mat)
		
		Return mat
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity, glob)

		'get global position/rotation
		If glob Then		
			pos:Vector3 = TFormPoint2(0, 0, 0, Self, Null)
			m1:Matrix = GetMatrix()
			m1.m03 = 0 'remove translation
			m1.m13 = 0
			m1.m23 = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, e)
			'set position
			x = pos.x
			y = pos.y
			z = pos.z
			'get parent inverted rotation matrix
			If e = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = e.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.children, Self
	
	End Method
	
	Method GetScaleXYZ:Vector3()
	
		m:Matrix = GetMatrix()
		v1:Vector3 = m.TransformVec(x_axis)
		v2:Vector3 = m.TransformVec(y_axis)
		v3:Vector3 = m.TransformVec(z_axis)		
		Return Vector3.Create(v1.Magnitude(), v2.Magnitude(), v3.Magnitude())
		
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#, glob=False )

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#), glob )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	e.Rotate(pitch, yaw, roll, glob)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity, glob=True)

	If e = Null Then Return

	e.SetParent(e2, glob)
	
	If e2 &lt;&gt; Null Then e2.Update() Else e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	p:Vector3 = Vector3.Create(x, y, z)

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 15, 0, 0
	RotateEntity cam, 0, 90, 0

	Local e1:Entity = Entity.Create(CreateCone())
	RotateMesh TMesh(e1.ent), 90, 0, 0

	Local e2:Entity = Entity.Create(CreateCone())
	ScaleMesh TMesh(e2.ent), 0.5, 0.5, 0.5
	RotateMesh TMesh(e2.ent), 90, 0, 0
	EntityColor e2.ent, 255, 0, 0
		
	Repeat
		
		If KeyDown(key_left)  TurnEntity2 e1,  0,  1, 0
		If KeyDown(key_right) TurnEntity2 e1,  0, -1, 0
		If KeyDown(key_up)	  TurnEntity2 e1,  1,  0, 0
		If KeyDown(key_down)  TurnEntity2 e1, -1,  0, 0
		
		If KeyDown(key_z) 	  MoveEntity2 e1, 0, 0, 0.1
		
		If KeyDown(key_space)
			EntityParent2 e2, e1
			PositionEntity2 e2, 0, 0, 0
			RotateEntity2 e2, 0, 0, 0
			EntityParent2 e2, Null, True
		End If
		
		MoveEntity2 e2, 0, 0, 0.1
		
		RenderWorld
		
		BeginMax2D
		DrawText "press space to fire", 0, 20
		DrawText "use cursor keys+z to move aorund", 0, 0
		EndMax2D
		
		Flip
		
	Until KeyHit(key_escape)
	
	End			
</textarea><br>The orientation is still reversed, but it seems more and more complete.<br>Todo:<br><pre class=code>
-Keep global scaling as well as rot/pos
-EntityPitch/Yaw/Roll  &lt;-- it is a problem to convert from matrix to euler
-Direction is reversed
</pre> <br><br></td></tr></table><br>
<a name="961809"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried it with the latest code and it works, thanks <br><br></td></tr></table><br>
<a name="961813"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> In the meanwhile, I looked at your code.<br>If it allready works, it was not needed, but still I'd like to post it:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import sidesign.minib3d
Import cower.math3d

'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
'	Method GetInvMat:Matrix()
		


	'returns copy of rotation matrix	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll#, glob=False )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		Local m2:Matrix
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = parent.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(mat)
		End If
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( pos:Vector3, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, parent)
		End If
		
		x = pos.x
		y = pos.y
		z = pos.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		Local mat:Matrix

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat = parent.GetInvMatrix()
		Else
			mat = New Matrix
		End If

		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x,-y,-z)

		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat3.TransformMat(mat2)
		mat = mat2.TransformMat(mat)
		
		Return mat
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity, glob)
	
		Local pos:Vector3
		Local m1:Matrix
		Local m2:Matrix

		'get global position/rotation
		If glob Then		
			pos:Vector3 = TFormPoint2(0, 0, 0, Self, Null)
			m1:Matrix = GetMatrix()
			m1.m03 = 0 'remove translation
			m1.m13 = 0
			m1.m23 = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, e)
			'set position
			x = pos.x
			y = pos.y
			z = pos.z
			'get parent inverted rotation matrix
			If e = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = e.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.children, Self
	
	End Method
	
	Method GetScaleXYZ:Vector3()
	
		Local m:Matrix 
		Local v1:Vector3
		Local v2:Vector3
		Local v3:Vector3
		
		m:Matrix = GetMatrix()
		v1:Vector3 = m.TransformVec(x_axis)
		v2:Vector3 = m.TransformVec(y_axis)
		v3:Vector3 = m.TransformVec(z_axis)		
		Return Vector3.Create(v1.Magnitude(), v2.Magnitude(), v3.Magnitude())
		
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#, glob=False )

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#), glob )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return

	e.Rotate(pitch, yaw, roll, glob)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity, glob=True)

	If e = Null Then Return

	e.SetParent(e2, glob)
	
	If e2 &lt;&gt; Null Then e2.Update() Else e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	Local p:Vector3 
	Local mat1:Matrix
	Local mat2:Matrix
	
	p:Vector3 = Vector3.Create(x, y, z)

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function


'-----------------------------------------------------------------------------------------------------------------------------------
'
'												MAIN
'
'-----------------------------------------------------------------------------------------------------------------------------------

	
	Global gfxwidth=800
	Global gfxheight=600
	
	AppTitle= "Look for bugs"
	Graphics3D gfxwidth,gfxheight
		
	SeedRnd MilliSecs()
	
	Global bullet_type=1
	Global ship_type=2
		
	Global camera:TCamera=CreateCamera()
		
	Local ship:TEntity=CreateCone()
	RotateMesh TMesh(ship), 90, 0, 0
		
	EntityRadius ship,2
	EntityType ship,ship_Type
	EntityPickMode ship,1	
	HideEntity ship
	
	Global player_ship:Tentity=CopyEntity (ship)	
	ShowEntity player_Ship
	
	Local player_pivot:TPivot=CreatePivot(player_ship)
	
	Global fighterbullet:TEntity=CreateSphere()	
	HideEntity fighterbullet
	EntityRadius fighterbullet,0.5
	EntityType fighterbullet,bullet_Type
	
	
	
	PositionEntity camera,0,3,-5
	Collisions bullet_type,ship_type,1,1

	
	PositionEntity player_ship,0,0,3
	
	
	Global player_ship_ent:entity=entity.Create(player_ship)
	Local camera_ent:entity=Entity.Create(Camera)
	
	'EntityParent2 camera_ent,player_ship_ent
	
	PositionEntity2 camera_ent,0,2,5
	
	While Not KeyHit(KEY_ESCAPE)
		
		Mouselook(player_ship_ent)
		MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	
		If MouseHit(1)
			bullet.Create()
		EndIf
		
		bullet.update()
		
		UpdateWorld
		RenderWorld
		
		Flip
	Wend
	
	Type bullet
	
		Global list:TList=New TList
		Field model_handle:Entity
		'Field entity_handle:entity
		
		Function Create()
		
			Local t:bullet=New bullet
			
				t.model_handle = Entity.Create(CopyEntity (fighterbullet))
			
				entityparent2(t.model_handle, player_ship_ent)
				
				PositionEntity2 t.model_handle, 0, 0, 0
				RotateEntity2 t.model_handle, 0, 0, 0
				
				bullet.list.addlast(t)
				
				EntityParent2(t.model_handle,Null)
		
		EndFunction
			
		Function update()
			For Local t:bullet=EachIn bullet.list
				MoveEntity2 t.model_handle,0,0,-1
			Next
		EndFunction
	
	EndType
	
	Function mousespeed(xy:Int)
	
		If xy=1
		
			Local slenkar=(MouseX()-(GraphicsWidth()/2))		
			Return slenkar
			
		Else
		
			Local slenkar=(MouseY()-(GraphicsHeight()/2))
			Return slenkar	
			
		EndIf
	
	EndFunction
		
	
	Function Mouselook(RC:entity)
	
		Local mx#=MouseSpeed(1)
		Local my#=MouseSpeed(2)
		
		If RC&lt;&gt;Null
			turnentity2(rc,-my,-mx,0)
		EndIf
	
	End Function
</textarea> <br><br></td></tr></table><br>
<a name="961815"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> its works with meshes but sprites dont work, the bullet i was using was a sprite, <br><br></td></tr></table><br>
<a name="961816"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wait .. &lt;edit&gt; .. But it seems to work with sprites as well?<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import sidesign.minib3d
Import cower.math3d

'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
'	Method GetInvMat:Matrix()
		


	'returns copy of rotation matrix	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll#, glob=False )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		Local m2:Matrix
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = parent.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(mat)
		End If
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( pos:Vector3, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, parent)
		End If
		
		x = pos.x
		y = pos.y
		z = pos.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		Local mat:Matrix

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat = parent.GetInvMatrix()
		Else
			mat = New Matrix
		End If

		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x,-y,-z)

		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat3.TransformMat(mat2)
		mat = mat2.TransformMat(mat)
		
		Return mat
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity, glob)
	
		Local pos:Vector3
		Local m1:Matrix
		Local m2:Matrix

		'get global position/rotation
		If glob Then		
			pos:Vector3 = TFormPoint2(0, 0, 0, Self, Null)
			m1:Matrix = GetMatrix()
			m1.m03 = 0 'remove translation
			m1.m13 = 0
			m1.m23 = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, e)
			'set position
			x = pos.x
			y = pos.y
			z = pos.z
			'get parent inverted rotation matrix
			If e = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = e.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.children, Self
	
	End Method
	
	Method GetScaleXYZ:Vector3()
	
		Local m:Matrix 
		Local v1:Vector3
		Local v2:Vector3
		Local v3:Vector3
		
		m:Matrix = GetMatrix()
		v1:Vector3 = m.TransformVec(x_axis)
		v2:Vector3 = m.TransformVec(y_axis)
		v3:Vector3 = m.TransformVec(z_axis)		
		Return Vector3.Create(v1.Magnitude(), v2.Magnitude(), v3.Magnitude())
		
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#, glob=False )

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, z#), glob )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return

	e.Rotate(pitch, yaw, roll, glob)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity, glob=True)

	If e = Null Then Return

	e.SetParent(e2, glob)
	
	If e2 &lt;&gt; Null Then e2.Update() Else e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	Local p:Vector3 
	Local mat1:Matrix
	Local mat2:Matrix
	
	p:Vector3 = Vector3.Create(x, y, z)

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function


'-----------------------------------------------------------------------------------------------------------------------------------
'
'												MAIN
'
'-----------------------------------------------------------------------------------------------------------------------------------

	
	Global gfxwidth=800
	Global gfxheight=600
	
	AppTitle= "Look for bugs"
	Graphics3D gfxwidth,gfxheight
		
	SeedRnd MilliSecs()
	
	Global bullet_type=1
	Global ship_type=2
		
	Global camera:TCamera=CreateCamera()
		
	Local ship:TEntity=CreateCone()
	RotateMesh TMesh(ship), 90, 0, 0
		
	EntityRadius ship,2
	EntityType ship,ship_Type
	EntityPickMode ship,1	
	HideEntity ship
	
	Global player_ship:Tentity=CopyEntity (ship)	
	ShowEntity player_Ship
	
	Local player_pivot:TPivot=CreatePivot(player_ship)
	
	Global fighterbullet:TEntity=CreateSprite()	
	HideEntity fighterbullet
	EntityRadius fighterbullet,0.5
	EntityType fighterbullet,bullet_Type
	
	
	
	PositionEntity camera,0,3,-5
	Collisions bullet_type,ship_type,1,1

	
	PositionEntity player_ship,0,0,3
	
	
	Global player_ship_ent:entity=entity.Create(player_ship)
	Local camera_ent:entity=Entity.Create(Camera)
	
	'EntityParent2 camera_ent,player_ship_ent
	
	PositionEntity2 camera_ent,0,2,5
	
	While Not KeyHit(KEY_ESCAPE)
		
		Mouselook(player_ship_ent)
		MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	
		If MouseHit(1)
			bullet.Create()
		EndIf
		
		bullet.update()
		
		UpdateWorld
		RenderWorld
		
		Flip
	Wend
	
	Type bullet
	
		Global list:TList=New TList
		Field model_handle:Entity
		'Field entity_handle:entity
		
		Function Create()
		
			Local t:bullet=New bullet
			
				t.model_handle = Entity.Create(CopyEntity (fighterbullet))
			
				entityparent2(t.model_handle, player_ship_ent)
				
				PositionEntity2 t.model_handle, 0, 0, 0
				RotateEntity2 t.model_handle, 0, 0, 0
				
				bullet.list.addlast(t)
				
				EntityParent2(t.model_handle,Null)
		
		EndFunction
			
		Function update()
			For Local t:bullet=EachIn bullet.list
				MoveEntity2 t.model_handle,0,0,-1
			Next
		EndFunction
	
	EndType
	
	Function mousespeed(xy:Int)
	
		If xy=1
		
			Local slenkar=(MouseX()-(GraphicsWidth()/2))		
			Return slenkar
			
		Else
		
			Local slenkar=(MouseY()-(GraphicsHeight()/2))
			Return slenkar	
			
		EndIf
	
	EndFunction
		
	
	Function Mouselook(RC:entity)
	
		Local mx#=MouseSpeed(1)
		Local my#=MouseSpeed(2)
		
		If RC&lt;&gt;Null
			turnentity2(rc,-my,-mx,0)
		EndIf
	
	End Function</textarea> <br><br></td></tr></table><br>
<a name="961817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> i just tried it with sprites and  it works! thanks for all that hard work you did <br><br></td></tr></table><br>
<a name="961825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I now tweaked the wrapper routines so, that the result will match miniB3D/Blitz3D's. Basically, Z is mirrored.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'needs noel's routine from code archive
'http://www.blitzmax.com/codearcs/codearcs.php?code=1463
Import cower.math3d 
Import sidesign.minib3d

'create global axes
Global x_axis:Vector3 = Vector3.Create(1, 0, 0)
Global y_axis:Vector3 = Vector3.Create(0, 1, 0)
Global z_axis:Vector3 = Vector3.Create(0, 0, 1)


Type Entity

	Field mat:Matrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x:Double    'position
	Field y:Double
	Field z:Double
	Field sx:Double   'scaling
	Field sy:Double
	Field sz:Double
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = New Matrix
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function
	
'	Method GetInvMat:Matrix()
		


	'returns copy of rotation matrix	
	Method CopyMat:Matrix()
		
		Local m:Matrix = New Matrix
		m.m00 = mat.m00 m.m01 = mat.m01 m.m02 = mat.m02 m.m03 = mat.m03
		m.m10 = mat.m10 m.m11 = mat.m11 m.m12 = mat.m12 m.m13 = mat.m13
		m.m20 = mat.m20 m.m21 = mat.m21 m.m22 = mat.m22 m.m23 = mat.m23
		m.m30 = mat.m30 m.m31 = mat.m31 m.m32 = mat.m32 m.m33 = mat.m33		
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll#, glob=False )
		
		Local q1:Quaternion = Quaternion.FromAngleAxis( pitch, x_axis )
		Local q2:Quaternion = Quaternion.FromAngleAxis( yaw,   y_axis )
		Local q3:Quaternion = Quaternion.FromAngleAxis( roll,  z_axis )
		
		q1 = q1.MultiplyQuat(q2)
		q1 = q1.MultiplyQuat(q3)
		
		mat = q1.ToMatrix()
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = parent.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(mat)
		End If
		
	End Method

	'turn entity
	Method Turn( ang:Double, ax:Vector3, glob=False )

		Local q:Quaternion = Quaternion.FromAngleAxis(ang, ax) 'create quaternion
		Local m:Matrix = q.ToMatrix()   'convert to matrix

		If glob Then		
			mat = m.TransformMat(mat) 'apply internal matrix to new matrix
		Else
			mat = mat.TransformMat(m) 'apply new matrix to internal matrix
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint:Vector3( vec:Vector3 )
	
		Return mat.TransformVec( vec )
		
	End Method

	'position an entity	
	Method Position( pos:Vector3, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, parent)
		End If
		
		x = pos.x
		y = pos.y
		z = pos.z
		
	End Method

	'move an entity
	Method Move( vec:Vector3 )
		
		vec = TransformPoint(vec) 'transform point by internal matrix
		x = x + vec.x 'add to position
		y = y + vec.y
		z = z + vec.z		
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		Local mat1:Matrix
		Local mat:Matrix

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat = parent.GetInvMatrix()
		Else
			mat = New Matrix
		End If

		
		'get inverted rotation matrix
		mat1 = CopyMat().Transpose()
				
		'scale
		mat3:Matrix = New Matrix
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(-x,-y,-z)

		
		'combine
		mat3 = mat1.TransformMat(mat3)
		mat2 = mat3.TransformMat(mat2)
		mat = mat2.TransformMat(mat)
		
		Return mat
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:Matrix()
	
		Local mat3:Matrix
		Local mat2:Matrix
		
		'scale
		mat3:Matrix = New Matrix
		mat3.Scale(sx, sy, sz)
		'position
		mat2:Matrix = New Matrix
		mat2.Translate(x, y, z)
		'rotation
		mat3 = mat.TransformMat(mat3)
		mat2 = mat2.TransformMat(mat3)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat2 = parent.GetMatrix().TransformMat(mat2)
		End If
		
		Return mat2
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:Matrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:Matrix = GetMatrix()
				
		'apply matrix	
		ent.mat.grid[0,0] = mat4.m00
		ent.mat.grid[1,0] = mat4.m01
		ent.mat.grid[2,0] = mat4.m02
		ent.mat.grid[3,0] = mat4.m03
		
		ent.mat.grid[0,1] = mat4.m10
		ent.mat.grid[1,1] = mat4.m11
		ent.mat.grid[2,1] = mat4.m12
		ent.mat.grid[3,1] = mat4.m13
		
		ent.mat.grid[0,2] = mat4.m20
		ent.mat.grid[1,2] = mat4.m21
		ent.mat.grid[2,2] = mat4.m22
		ent.mat.grid[3,2] = mat4.m23
		
		ent.mat.grid[0,3] = mat4.m30
		ent.mat.grid[1,3] = mat4.m31
		ent.mat.grid[2,3] = mat4.m32
		ent.mat.grid[3,3] = mat4.m33

		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity, glob)

		'get global position/rotation
		If glob Then		
			pos:Vector3 = TFormPoint2(0, 0, 0, Self, Null)
			m1:Matrix = GetMatrix()
			m1.m03 = 0 'remove translation
			m1.m13 = 0
			m1.m23 = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then pos:Vector3 = TFormPoint2(pos.x, pos.y, pos.z, Null, e)
			'set position
			x = pos.x
			y = pos.y
			z = pos.z
			'get parent inverted rotation matrix
			If e = Null Then
				m2:Matrix = New Matrix 'no parent
			Else
				m2:Matrix = e.GetInvMatrix()
				m2.m03 = 0 'remove translation
				m2.m13 = 0
				m2.m23 = 0
			End If
			'apply rotation matrix
			mat = m2.TransformMat(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.children, Self
	
	End Method
	
	Method GetScaleXYZ:Vector3()
	
		m:Matrix = GetMatrix()
		v1:Vector3 = m.TransformVec(x_axis)
		v2:Vector3 = m.TransformVec(y_axis)
		v3:Vector3 = m.TransformVec(z_axis)		
		Return Vector3.Create(v1.Magnitude(), v2.Magnitude(), v3.Magnitude())
		
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#, glob=False )

	If e = Null Then Return
	e.Position( Vector3.Create(x#, y#, -z#), glob )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	pitch = -pitch
	
	If e = Null Then Return
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, x_axis, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   y_axis, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  z_axis, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#)

	z = -z

	If e = Null Then Return	
	e.Move( Vector3.Create(x#, y#, z#) )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	e.Rotate(-pitch, -yaw, roll, glob)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity, glob=True)

	If e = Null Then Return

	e.SetParent(e2, glob)
	
	If e2 &lt;&gt; Null Then e2.Update() Else e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2:Vector3(x#, y#, z#, src:Entity, dst:Entity)

	p:Vector3 = Vector3.Create(x, y, z)

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:Matrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:Matrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then p = mat1.TransformVec(p, 1)'mesh to global
	If dst &lt;&gt; Null Then p = mat2.TransformVec(p, 1)'global to mesh
	Return p

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 0, 0, -15

	Local e1:Entity = Entity.Create(CreateCone())
	RotateMesh TMesh(e1.ent), 90, 0, 0
		
	Repeat

		TurnEntity2 e1, 1, 2, 3
								
		RenderWorld
				
		Flip
		
	Until KeyHit(key_escape)
	
	End			
</textarea> <br><br></td></tr></table><br>
<a name="961851"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll put this code&amp;updates in the archive. <br><br></td></tr></table><br>
<a name="961856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >simonh</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work. Beware using vector objects in this kind of code though - the large number of small objects that are generated can clog the GC and slow things down considerably. <br><br></td></tr></table><br>
<a name="961902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you Simon! I rewrote the math functions it uses so they require no external types. The Methods are Methods for the TMatrix as used in minib3d. Some were allready there, so i've copied them into here for completion:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem bbdoc: Gets the magnitude of the vector
End Rem
Function Magnitude!( x!, y!, z! )
	Return Sqr( x*x + y*y + z*z )
End Function

Rem bbdoc: Creates a quaternion from an angle and an axis
End Rem
Function Quaternion_FromAngleAxis( angle!, ax!,ay!,az!, rx! Var,ry! Var,rz! Var,rw! Var )
	
	Local ha! = .5*angle
	Local sn! = Sin( ha )
	
	rw! = Cos( ha )
	rx! = sn * ax
	ry! = sn * ay
	rz! = sn * az
	
End Function

Rem bbdoc: Multiplies a quaternion
End Rem
Method Quaternion_MultiplyQuat( x1!,y1!,z1!,w1!, x2!,y2!,z2!,w2!, rx! Var,ry! Var,rz! Var,rw! Var )
	
	rw = w1*w2 - x1*x2 - y1*y2 - z1*z2
	rx = w1*x2 - x1*w2 - y1*z2 - z1*y2
	ry = w1*y2 - y1*w2 - z1*x2 - x1*z2
	rz = w1*z2 - z1*w2 - x1*y2 - y1*x2
	
End Method

Rem bbdoc: Returns a matrix made from the quaternion
End Rem
Method FromQuaternion(x!,y!,z!,w!)
	' Based off of code in Axiom
	
	Local tx! = 2*x
	Local ty! = 2*y
	Local tz! = 2*z
	Local twx! = tx*w
	Local twy! = ty*w
	Local twz! = tz*w
	Local txx! = tx*x
	Local txy! = ty*x
	Local txz! = tz*x
	Local tyy! = ty*y
	Local tyz! = tz*y
	Local tzz! = tz*z
	
	grid[0,0] = 1.0-(tyy+tzz)
	grid[1,0] = txy-twz
	grid[2,0] = txz+twy
	grid[0,1] = txy+twz
	grid[1,1] = 1.0-(txx+tzz)
	grid[2,1] = tyz-twx
	grid[0,2] = txz-twy
	grid[1,2] = tyz+twx
	grid[2,2] = 1.0-(txx+tyy)
	
End Method

Rem bbdoc: Transforms the matrix by another matrix
End Rem
Method Multiply(mat:TMatrix)

	Local m00# = grid#[0,0]*mat.grid#[0,0] + grid#[1,0]*mat.grid#[0,1] + grid#[2,0]*mat.grid#[0,2] + grid#[3,0]*mat.grid#[0,3]
	Local m01# = grid#[0,1]*mat.grid#[0,0] + grid#[1,1]*mat.grid#[0,1] + grid#[2,1]*mat.grid#[0,2] + grid#[3,1]*mat.grid#[0,3]
	Local m02# = grid#[0,2]*mat.grid#[0,0] + grid#[1,2]*mat.grid#[0,1] + grid#[2,2]*mat.grid#[0,2] + grid#[3,2]*mat.grid#[0,3]
	Local m03# = grid#[0,3]*mat.grid#[0,0] + grid#[1,3]*mat.grid#[0,1] + grid#[2,3]*mat.grid#[0,2] + grid#[3,3]*mat.grid#[0,3]
	Local m10# = grid#[0,0]*mat.grid#[1,0] + grid#[1,0]*mat.grid#[1,1] + grid#[2,0]*mat.grid#[1,2] + grid#[3,0]*mat.grid#[1,3]
	Local m11# = grid#[0,1]*mat.grid#[1,0] + grid#[1,1]*mat.grid#[1,1] + grid#[2,1]*mat.grid#[1,2] + grid#[3,1]*mat.grid#[1,3]
	Local m12# = grid#[0,2]*mat.grid#[1,0] + grid#[1,2]*mat.grid#[1,1] + grid#[2,2]*mat.grid#[1,2] + grid#[3,2]*mat.grid#[1,3]
	Local m13# = grid#[0,3]*mat.grid#[1,0] + grid#[1,3]*mat.grid#[1,1] + grid#[2,3]*mat.grid#[1,2] + grid#[3,3]*mat.grid#[1,3]
	Local m20# = grid#[0,0]*mat.grid#[2,0] + grid#[1,0]*mat.grid#[2,1] + grid#[2,0]*mat.grid#[2,2] + grid#[3,0]*mat.grid#[2,3]
	Local m21# = grid#[0,1]*mat.grid#[2,0] + grid#[1,1]*mat.grid#[2,1] + grid#[2,1]*mat.grid#[2,2] + grid#[3,1]*mat.grid#[2,3]
	Local m22# = grid#[0,2]*mat.grid#[2,0] + grid#[1,2]*mat.grid#[2,1] + grid#[2,2]*mat.grid#[2,2] + grid#[3,2]*mat.grid#[2,3]
	Local m23# = grid#[0,3]*mat.grid#[2,0] + grid#[1,3]*mat.grid#[2,1] + grid#[2,3]*mat.grid#[2,2] + grid#[3,3]*mat.grid#[2,3]
	Local m30# = grid#[0,0]*mat.grid#[3,0] + grid#[1,0]*mat.grid#[3,1] + grid#[2,0]*mat.grid#[3,2] + grid#[3,0]*mat.grid#[3,3]
	Local m31# = grid#[0,1]*mat.grid#[3,0] + grid#[1,1]*mat.grid#[3,1] + grid#[2,1]*mat.grid#[3,2] + grid#[3,1]*mat.grid#[3,3]
	Local m32# = grid#[0,2]*mat.grid#[3,0] + grid#[1,2]*mat.grid#[3,1] + grid#[2,2]*mat.grid#[3,2] + grid#[3,2]*mat.grid#[3,3]
	Local m33# = grid#[0,3]*mat.grid#[3,0] + grid#[1,3]*mat.grid#[3,1] + grid#[2,3]*mat.grid#[3,2] + grid#[3,3]*mat.grid#[3,3]

	grid[0,0]=m00
	grid[0,1]=m01
	grid[0,2]=m02
	grid[0,3]=m03
	grid[1,0]=m10
	grid[1,1]=m11
	grid[1,2]=m12
	grid[1,3]=m13
	grid[2,0]=m20
	grid[2,1]=m21
	grid[2,2]=m22
	grid[2,3]=m23
	grid[3,0]=m30
	grid[3,1]=m31
	grid[3,2]=m32
	grid[3,3]=m33
	
End Method

Rem bbdoc: Transforms a vector by the matrix
End Rem
Method TransformVec( ix!,iy!,iz!, rx!,ry!,rz!, addTranslation% = 0 )

	Local w! = 1.0/( grid[0,3] + grid[1,3] + grid[2,3] + grid[3,3] )
	
	addTranslation = Min( Max( addTranslation, 0 ), 1 )
	
	rx = ( ( grid[0,0]*ix ) + ( grid[1,0]*iy ) + ( grid[2,0]*iz ) + grid[3,0] * addTranslation ) * w
	ry = ( ( grid[0,1]*ix ) + ( grid[1,1]*iy ) + ( grid[2,1]*iz ) + grid[3,1] * addTranslation ) * w
	rz = ( ( grid[0,2]*ix ) + ( grid[1,2]*iy ) + ( grid[2,2]*iz ) + grid[3,2] * addTranslation ) * w
	
End Method

Rem bbdoc: Transposes the matrix
End Rem
Method Transpose()

 Local x:Int,y:Int

 Local a:Double[,] = New Double[4,4]

 For x = 0 To 3
 For y = 0 To 3
	 a[y,x] = grid[x,y]
 Next
 Next

 For x = 0 To 3
 For y = 0 To 3
	grid[x,y]=a[x,y]
 Next
 Next

End Method


Rem bbdoc: Sets the translation elements of the matrix
End Rem
Method SetTranslate( x!, y!, z! )
	grid[3,0] = x
	grid[3,1] = y
	grid[3,2] = z
End Method

Rem bbdoc: Scales the rotation elements of the matrix
End Rem
Method Scale(x#,y#,z#)

	grid[0,0] = grid#[0,0]*x#
	grid[0,1] = grid#[0,1]*x#
	grid[0,2] = grid#[0,2]*x#

	grid[1,0] = grid#[1,0]*y#
	grid[1,1] = grid#[1,1]*y#
	grid[1,2] = grid#[1,2]*y#

	grid[2,0] = grid#[2,0]*z#
	grid[2,1] = grid#[2,1]*z#
	grid[2,2] = grid#[2,2]*z# 

End Method
</textarea><br>Now I want to convert the other code so it uses these functions, but it should first be complete.<br><br>That brings me down to the following question:<br><br>How should I incorporate EntityPitch/EntityYaw/EntityRoll? If I look for conversion routines from matrix to euler, they all seem to suffer from gimbal lock (or worse).<br>Alternatively, I could add three fields that represent pitch/yaw/roll, that are just used for reading this info, but that would only give the local angles.<br>Anybody knows what to do? <br><br></td></tr></table><br>
<a name="961904"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >simonh</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think Mark used some sort of quat -&gt; euler -&gt; pitch/yaw/roll method. I'm not sure on that though...my memory is somewhat hazy. Did you ever downloaded the B3D source code? It was available via svn for Blitz3D SDK owners for a while. <br><br></td></tr></table><br>
<a name="961925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, I see. Thanks. No, I never got round to downloading the sdk source.<br>I can imagine it would be a great read.<br>[edit] hold that thought .. routine seems not right. <br><br></td></tr></table><br>
<a name="961979"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've now converted everything. Hopefully it still works, I only did a very short test.<br>This is an extended version of 'TMatrix.bmx':<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TMatrix

	Field grid#[4,4]
	
	Function Create:TMatrix()
	
		Local m:TMatrix = New TMatrix
		m.LoadIdentity()
		Return m
		
	End Function
	
	Method New()
		
		If LOG_NEW
			DebugLog "New TMatrix"
		EndIf

	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TMatrix"
		EndIf

	End Method
	
	Method LoadIdentity()
	
		grid[0,0]=1.0 grid[1,0]=0.0 grid[2,0]=0.0 grid[3,0]=0.0
		grid[0,1]=0.0 grid[1,1]=1.0 grid[2,1]=0.0 grid[3,1]=0.0
		grid[0,2]=0.0 grid[1,2]=0.0 grid[2,2]=1.0 grid[3,2]=0.0		
		grid[0,3]=0.0 grid[1,3]=0.0 grid[2,3]=0.0 grid[3,3]=1.0
	
	End Method
	
	' copy - create new copy and returns it
	
	Method Copy:TMatrix()
	
		Local mat:TMatrix=New TMatrix
	
		mat.grid[0,0]=grid[0,0]
		mat.grid[1,0]=grid[1,0]
		mat.grid[2,0]=grid[2,0]
		mat.grid[3,0]=grid[3,0]
		mat.grid[0,1]=grid[0,1]
		mat.grid[1,1]=grid[1,1]
		mat.grid[2,1]=grid[2,1]
		mat.grid[3,1]=grid[3,1]
		mat.grid[0,2]=grid[0,2]
		mat.grid[1,2]=grid[1,2]
		mat.grid[2,2]=grid[2,2]
		mat.grid[3,2]=grid[3,2]
		
		' do not remove
		mat.grid[0,3]=grid[0,3]
		mat.grid[1,3]=grid[1,3]
		mat.grid[2,3]=grid[2,3]
		mat.grid[3,3]=grid[3,3]
		
		Return mat
	
	End Method
	
	' overwrite - overwrites self with matrix passed as parameter
	
	Method Overwrite(mat:TMatrix)
	
		grid[0,0]=mat.grid[0,0]
		grid[1,0]=mat.grid[1,0]
		grid[2,0]=mat.grid[2,0]
		grid[3,0]=mat.grid[3,0]
		grid[0,1]=mat.grid[0,1]
		grid[1,1]=mat.grid[1,1]
		grid[2,1]=mat.grid[2,1]
		grid[3,1]=mat.grid[3,1]
		grid[0,2]=mat.grid[0,2]
		grid[1,2]=mat.grid[1,2]
		grid[2,2]=mat.grid[2,2]
		grid[3,2]=mat.grid[3,2]		
		grid[0,3]=mat.grid[0,3]
		grid[1,3]=mat.grid[1,3]
		grid[2,3]=mat.grid[2,3]
		grid[3,3]=mat.grid[3,3]
		
	End Method
	
	Method Inverse:TMatrix()

		Local mat:TMatrix=New TMatrix
	
		Local tx#=0
		Local ty#=0
		Local tz#=0
	
	  	' The rotational part of the matrix is simply the transpose of the
	  	' original matrix.
	  	mat.grid[0,0] = grid[0,0]
	  	mat.grid[1,0] = grid[0,1]
	  	mat.grid[2,0] = grid[0,2]
	
		mat.grid[0,1] = grid[1,0]
		mat.grid[1,1] = grid[1,1]
		mat.grid[2,1] = grid[1,2]
	
		mat.grid[0,2] = grid[2,0]
		mat.grid[1,2] = grid[2,1]
		mat.grid[2,2] = grid[2,2]
	
		' The right column vector of the matrix should always be [ 0 0 0 1 ]
		' in most cases. . . you don't need this column at all because it'll 
		' never be used in the program, but since this code is used with GL
		' and it does consider this column, it is here.
		mat.grid[0,3] = 0 
		mat.grid[1,3] = 0
		mat.grid[2,3] = 0
		mat.grid[3,3] = 1
	
		' The translation components of the original matrix.
		tx = grid[3,0]
		ty = grid[3,1]
		tz = grid[3,2]
	
		' Result = -(Tm * Rm) To get the translation part of the inverse
		mat.grid[3,0] = -( (grid[0,0] * tx) + (grid[0,1] * ty) + (grid[0,2] * tz) )
		mat.grid[3,1] = -( (grid[1,0] * tx) + (grid[1,1] * ty) + (grid[1,2] * tz) )
		mat.grid[3,2] = -( (grid[2,0] * tx) + (grid[2,1] * ty) + (grid[2,2] * tz) )
	
		Return mat

	End Method

	Method Translate(x#,y#,z#)
	
		grid[3,0] = grid#[0,0]*x# + grid#[1,0]*y# + grid#[2,0]*z# + grid#[3,0]
		grid[3,1] = grid#[0,1]*x# + grid#[1,1]*y# + grid#[2,1]*z# + grid#[3,1]
		grid[3,2] = grid#[0,2]*x# + grid#[1,2]*y# + grid#[2,2]*z# + grid#[3,2]

	End Method
	
	Method Rotate(rx#,ry#,rz#)
	
		Local cos_ang#,sin_ang#
	
		' yaw
	
		cos_ang#=Cos(ry#)
		sin_ang#=Sin(ry#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
		
		' pitch
		
		cos_ang#=Cos(rx#)
		sin_ang#=Sin(rx#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		
		' roll
		
		cos_ang#=Cos(rz#)
		sin_ang#=Sin(rz#)

		m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
	
	End Method
	
	Method RotatePitch(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12

	End Method
	
	Method RotateYaw(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Method RotateRoll(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)

		Local m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		Local m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		Local m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Rem bbdoc: Returns a matrix made from the quaternion
	End Rem
	Method FromQuaternion(x#,y#,z#,w#)
		' Based off of code in Axiom
		
		Local tx# = 2*x
		Local ty# = 2*y
		Local tz# = 2*z
		Local twx# = tx*w
		Local twy# = ty*w
		Local twz# = tz*w
		Local txx# = tx*x
		Local txy# = ty*x
		Local txz# = tz*x
		Local tyy# = ty*y
		Local tyz# = tz*y
		Local tzz# = tz*z
		
		grid[0,0] = 1.0-(tyy+tzz)
		grid[1,0] = txy-twz
		grid[2,0] = txz+twy
		grid[0,1] = txy+twz
		grid[1,1] = 1.0-(txx+tzz)
		grid[2,1] = tyz-twx
		grid[0,2] = txz-twy
		grid[1,2] = tyz+twx
		grid[2,2] = 1.0-(txx+tyy)
		
	End Method
	
	Rem bbdoc: Transforms the matrix by another matrix
	End Rem
	Method Multiply(mat:TMatrix)
	
		Local m00# = grid#[0,0]*mat.grid#[0,0] + grid#[1,0]*mat.grid#[0,1] + grid#[2,0]*mat.grid#[0,2] + grid#[3,0]*mat.grid#[0,3]
		Local m01# = grid#[0,1]*mat.grid#[0,0] + grid#[1,1]*mat.grid#[0,1] + grid#[2,1]*mat.grid#[0,2] + grid#[3,1]*mat.grid#[0,3]
		Local m02# = grid#[0,2]*mat.grid#[0,0] + grid#[1,2]*mat.grid#[0,1] + grid#[2,2]*mat.grid#[0,2] + grid#[3,2]*mat.grid#[0,3]
		Local m03# = grid#[0,3]*mat.grid#[0,0] + grid#[1,3]*mat.grid#[0,1] + grid#[2,3]*mat.grid#[0,2] + grid#[3,3]*mat.grid#[0,3]
		Local m10# = grid#[0,0]*mat.grid#[1,0] + grid#[1,0]*mat.grid#[1,1] + grid#[2,0]*mat.grid#[1,2] + grid#[3,0]*mat.grid#[1,3]
		Local m11# = grid#[0,1]*mat.grid#[1,0] + grid#[1,1]*mat.grid#[1,1] + grid#[2,1]*mat.grid#[1,2] + grid#[3,1]*mat.grid#[1,3]
		Local m12# = grid#[0,2]*mat.grid#[1,0] + grid#[1,2]*mat.grid#[1,1] + grid#[2,2]*mat.grid#[1,2] + grid#[3,2]*mat.grid#[1,3]
		Local m13# = grid#[0,3]*mat.grid#[1,0] + grid#[1,3]*mat.grid#[1,1] + grid#[2,3]*mat.grid#[1,2] + grid#[3,3]*mat.grid#[1,3]
		Local m20# = grid#[0,0]*mat.grid#[2,0] + grid#[1,0]*mat.grid#[2,1] + grid#[2,0]*mat.grid#[2,2] + grid#[3,0]*mat.grid#[2,3]
		Local m21# = grid#[0,1]*mat.grid#[2,0] + grid#[1,1]*mat.grid#[2,1] + grid#[2,1]*mat.grid#[2,2] + grid#[3,1]*mat.grid#[2,3]
		Local m22# = grid#[0,2]*mat.grid#[2,0] + grid#[1,2]*mat.grid#[2,1] + grid#[2,2]*mat.grid#[2,2] + grid#[3,2]*mat.grid#[2,3]
		Local m23# = grid#[0,3]*mat.grid#[2,0] + grid#[1,3]*mat.grid#[2,1] + grid#[2,3]*mat.grid#[2,2] + grid#[3,3]*mat.grid#[2,3]
		Local m30# = grid#[0,0]*mat.grid#[3,0] + grid#[1,0]*mat.grid#[3,1] + grid#[2,0]*mat.grid#[3,2] + grid#[3,0]*mat.grid#[3,3]
		Local m31# = grid#[0,1]*mat.grid#[3,0] + grid#[1,1]*mat.grid#[3,1] + grid#[2,1]*mat.grid#[3,2] + grid#[3,1]*mat.grid#[3,3]
		Local m32# = grid#[0,2]*mat.grid#[3,0] + grid#[1,2]*mat.grid#[3,1] + grid#[2,2]*mat.grid#[3,2] + grid#[3,2]*mat.grid#[3,3]
		Local m33# = grid#[0,3]*mat.grid#[3,0] + grid#[1,3]*mat.grid#[3,1] + grid#[2,3]*mat.grid#[3,2] + grid#[3,3]*mat.grid#[3,3]
	
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method
	
	Rem bbdoc: Transforms a vector by the matrix
	End Rem
	Method TransformVec( rx# Var,ry# Var,rz# Var, addTranslation% = 0 )
	
		Local w# = 1.0/( grid[0,3] + grid[1,3] + grid[2,3] + grid[3,3] )
		Local ix# = rx#
		Local iy# = ry#
		Local iz# = rz#
		
		addTranslation = Min( Max( addTranslation, 0 ), 1 )
		
		rx = ( ( grid[0,0]*ix ) + ( grid[1,0]*iy ) + ( grid[2,0]*iz ) + grid[3,0] * addTranslation ) * w
		ry = ( ( grid[0,1]*ix ) + ( grid[1,1]*iy ) + ( grid[2,1]*iz ) + grid[3,1] * addTranslation ) * w
		rz = ( ( grid[0,2]*ix ) + ( grid[1,2]*iy ) + ( grid[2,2]*iz ) + grid[3,2] * addTranslation ) * w
		
	End Method
	
	Rem bbdoc: Transposes the matrix
	End Rem
	Method Transpose()
	
	 Local x:Int,y:Int
	
	 Local a:Double[,] = New Double[4,4]
	
	 For x = 0 To 3
	 For y = 0 To 3
		 a[y,x] = grid[x,y]
	 Next
	 Next
	
	 For x = 0 To 3
	 For y = 0 To 3
		grid[x,y]=a[x,y]
	 Next
	 Next
	
	End Method
	
	
	Rem bbdoc: Sets the translation elements of the matrix
	End Rem
	Method SetTranslate( x#, y#, z# )
		grid[3,0] = x
		grid[3,1] = y
		grid[3,2] = z
	End Method
	
	Rem bbdoc: Scales the rotation elements of the matrix
	End Rem
	Method Scale(x#,y#,z#)
	
		grid[0,0] = grid#[0,0]*x#
		grid[0,1] = grid#[0,1]*x#
		grid[0,2] = grid#[0,2]*x#
	
		grid[1,0] = grid#[1,0]*y#
		grid[1,1] = grid#[1,1]*y#
		grid[1,2] = grid#[1,2]*y#
	
		grid[2,0] = grid#[2,0]*z#
		grid[2,1] = grid#[2,1]*z#
		grid[2,2] = grid#[2,2]*z# 
	
	End Method

	Method Multiply2(i:TMatrix)
				
		Local m00# = grid[0,0] * i.grid[0,0] + grid[0,1] * i.grid[1,0] + grid[0,2] * i.grid[2,0] + grid[0,3] * i.grid[3,0]
		Local m01# = grid[0,0] * i.grid[0,1] + grid[0,1] * i.grid[1,1] + grid[0,2] * i.grid[2,1] + grid[0,3] * i.grid[3,1]
		Local m02# = grid[0,0] * i.grid[0,2] + grid[0,1] * i.grid[1,2] + grid[0,2] * i.grid[2,2] + grid[0,3] * i.grid[3,2]
		Local m03# = grid[0,0] * i.grid[0,3] + grid[0,1] * i.grid[1,3] + grid[0,2] * i.grid[2,3] + grid[0,3] * i.grid[3,3]
		
		Local m10# = grid[1,0] * i.grid[0,0] + grid[1,1] * i.grid[1,0] + grid[1,2] * i.grid[2,0] + grid[1,3] * i.grid[3,0]
		Local m11# = grid[1,0] * i.grid[0,1] + grid[1,1] * i.grid[1,1] + grid[1,2] * i.grid[2,1] + grid[1,3] * i.grid[3,1]
		Local m12# = grid[1,0] * i.grid[0,2] + grid[1,1] * i.grid[1,2] + grid[1,2] * i.grid[2,2] + grid[1,3] * i.grid[3,2]
		Local m13# = grid[1,0] * i.grid[0,3] + grid[1,1] * i.grid[1,3] + grid[1,2] * i.grid[2,3] + grid[1,3] * i.grid[3,3]
		
		Local m20# = grid[2,0] * i.grid[0,0] + grid[2,1] * i.grid[1,0] + grid[2,2] * i.grid[2,0] + grid[2,3] * i.grid[3,0]
		Local m21# = grid[2,0] * i.grid[0,1] + grid[2,1] * i.grid[1,1] + grid[2,2] * i.grid[2,1] + grid[2,3] * i.grid[3,1]
		Local m22# = grid[2,0] * i.grid[0,2] + grid[2,1] * i.grid[1,2] + grid[2,2] * i.grid[2,2] + grid[2,3] * i.grid[3,2]
		Local m23# = grid[2,0] * i.grid[0,3] + grid[2,1] * i.grid[1,3] + grid[2,2] * i.grid[2,3] + grid[2,3] * i.grid[3,3]
				
		Local m30# = grid[3,0] * i.grid[0,0] + grid[3,1] * i.grid[1,0] + grid[3,2] * i.grid[2,0] + grid[3,3] * i.grid[3,0]
		Local m31# = grid[3,0] * i.grid[0,1] + grid[3,1] * i.grid[1,1] + grid[3,2] * i.grid[2,1] + grid[3,3] * i.grid[3,1]
		Local m32# = grid[3,0] * i.grid[0,2] + grid[3,1] * i.grid[1,2] + grid[3,2] * i.grid[2,2] + grid[3,3] * i.grid[3,2]
		Local m33# = grid[3,0] * i.grid[0,3] + grid[3,1] * i.grid[1,3] + grid[3,2] * i.grid[2,3] + grid[3,3] * i.grid[3,3]
		
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method
		
End Type


Rem bbdoc: Gets the magnitude of the vector
End Rem
Function Magnitude#( x#, y#, z# )
	Return Sqr( x*x + y*y + z*z )
End Function

Rem bbdoc: Creates a quaternion from an angle and an axis
End Rem
Function Quaternion_FromAngleAxis( angle#, ax#,ay#,az#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	Local ha# = .5*angle
	Local sn# = Sin( ha )
	
	rw# = Cos( ha )
	rx# = sn * ax
	ry# = sn * ay
	rz# = sn * az
	
End Function

Rem bbdoc: Multiplies a quaternion
End Rem
Function Quaternion_MultiplyQuat( x1#,y1#,z1#,w1#, x2#,y2#,z2#,w2#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	rw = w1*w2 - x1*x2 - y1*y2 - z1*z2
	rx = w1*x2 - x1*w2 - y1*z2 - z1*y2
	ry = w1*y2 - y1*w2 - z1*x2 - x1*z2
	rz = w1*z2 - z1*w2 - x1*y2 - y1*x2
	
End Function
</textarea><br><br>And this is the code I tried:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import sidesign.minib3d

Type Entity

	Field mat:TMatrix  'rotation matrix
	Field ent:TEntity 'attached entity
	Field x#    'position
	Field y#
	Field z#
	Field sx#   'scaling
	Field sy#
	Field sz#
	Field rx#	  'rotation
	Field ry#
	Field rz#
	
	Field parent:Entity 'parent entity
	Field children:TList 'list of children

	'creates an entity
	Function Create:Entity( te:TEntity )
	
		Local e:Entity

		e:Entity = New Entity
		e.ent = te
		e.mat = TMatrix.Create()
		e.children = CreateList()
		e.sx = 1
		e.sy = 1
		e.sz = 1
		Return e

	End Function

	'returns copy of rotation matrix	
	Method CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = mat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method Rotate( pitch#, yaw#, roll#, glob=False )

		Local q1_x#, q1_y#, q1_z#, q1_w#
		Local q2_x#, q2_y#, q2_z#, q2_w#
		Local q3_x#, q3_y#, q3_z#, q3_w#
		Local m2:TMatrix
				
		Quaternion_FromAngleAxis( pitch, 1, 0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
		Quaternion_FromAngleAxis( yaw,   0, 1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
		Quaternion_FromAngleAxis( roll,  0, 0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
		
		Quaternion_MultiplyQuat( q1_x, q1_y, q1_z, q1_w, q2_x, q2_y, q2_z, q2_w, q1_x, q1_y, q1_z, q1_w)
		Quaternion_MultiplyQuat( q1_x, q1_y, q1_z, q1_w, q3_x, q3_y, q3_z, q3_w, q1_x, q1_y, q1_z, q1_w)
		
		mat.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = parent.GetInvMatrix()
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			'mat = m2.Multiply2(mat)
			mat.Multiply2(m2)
		End If
		
	End Method

	'turn entity
	Method Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then		
			'mat = m.Multiply2(mat) 
			mat.Multiply2(m)'apply internal matrix to new matrix
		Else
			'mat = mat.Multiply2(m) 
			m.Multiply2(mat)'apply new matrix to internal matrix
			mat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method TransformPoint( ix# Var,iy# Var,iz# Var)
		
		mat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method Position( px#,py#,pz#, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then TFormPoint2(px, py, pz, Null, parent)
		End If
		
		x = px
		y = py
		z = pz

	End Method

	'move an entity
	Method Move( px#,py#,pz# )
	
		TransformPoint(px,py,pz) 'transform point by internal matrix
		x = x + px 'add to position
		y = y + py
		z = z + pz
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method GetInvMatrix:TMatrix()
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat = parent.GetInvMatrix()
		Else
			mat = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-x,-y,-z)
		
		'combine
		'mat3 = mat1.TransformMat(mat3)
		'mat2 = mat3.TransformMat(mat2)
		'mat = mat2.TransformMat(mat)
		mat3.Multiply2(mat1)
		mat2.Multiply2(mat3)
		mat.Multiply2(mat2)
		
		Return mat
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method GetMatrix:TMatrix()
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		
		'scale
		mat3:TMatrix = TMatrix.Create()
		mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(x, y, z)
		'rotation
		'mat3 = mat.TransformMat(mat3)
		'mat2 = mat2.TransformMat(mat3)
		mat3.Multiply2(mat)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			'mat3 = parent.GetMatrix().TransformMat(mat3)
			mat3.Multiply2(parent.GetMatrix())
		End If
		
		Return mat3
		
	End Method

	'update attached entity
	Method Update()

		Local mat4:TMatrix
		Local e:Entity

		'get matrix transformed by parents
		mat4:TMatrix = GetMatrix()
		ent.mat.Overwrite(mat4)'MatOverwrite(ent.mat, mat4)
		'ent.mat.Overwrite(mat4)
		
		'apply matrix	
		ent.mat.grid[0,0] = mat4.grid[0,0]
		ent.mat.grid[1,0] = mat4.grid[1,0]
		ent.mat.grid[2,0] = mat4.grid[2,0]
		ent.mat.grid[3,0] = mat4.grid[3,0]
		
		ent.mat.grid[0,1] = mat4.grid[0,1]
		ent.mat.grid[1,1] = mat4.grid[1,1]
		ent.mat.grid[2,1] = mat4.grid[2,1]
		ent.mat.grid[3,1] = mat4.grid[3,1]
		
		ent.mat.grid[0,2] = mat4.grid[0,2]
		ent.mat.grid[1,2] = mat4.grid[1,2]
		ent.mat.grid[2,2] = mat4.grid[2,2]
		ent.mat.grid[3,2] = mat4.grid[3,2]
		
		ent.mat.grid[0,3] = mat4.grid[0,3]
		ent.mat.grid[1,3] = mat4.grid[1,3]
		ent.mat.grid[2,3] = mat4.grid[2,3]
		ent.mat.grid[3,3] = mat4.grid[3,3]
				
		'update children		
		For e:Entity = EachIn children
			e.Update
		Next

	End Method

	'set an entity's parent	
	Method SetParent(e:Entity, glob)
	
		Local orgx#,orgy#,orgz#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			orgx# = 0
			orgy# = 0
			orgz# = 0
			TFormPoint2(orgx, orgy, orgz, Self, Null)
			m1:TMatrix = GetMatrix()
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.children, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then TFormPoint2(orgx, orgy, orgz, Null, e)
			'set position
			x = orgx
			y = orgy
			z = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.GetInvMatrix()
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			'mat = m2.TransformMat(m1)
			m1.Multiply2(m2)
			mat.Overwrite(m1)'MatOverwrite(mat, m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.children, Self
	
	End Method

	'get entity scale	
	Method GetScaleXYZ(width# Var, height# Var, depth# Var)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		m:TMatrix = GetMatrix()
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

End Type

'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:Entity, x#, y#, z#, glob=False )

	If e = Null Then Return
	
	e.Position( x, y, z, glob )
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	pitch = -pitch
	
	If pitch# &lt;&gt; 0 Then e.Turn(pitch, 1, 0, 0, glob)
	If yaw#   &lt;&gt; 0 Then e.Turn(yaw,   0, 1, 0, glob)
	If roll#  &lt;&gt; 0 Then e.Turn(roll,  0, 0, 1, glob)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:Entity, x#, y#, z#, glob=False)

	If e = Null Then Return	

	If glob Then
		TFormVector2(x, y, z, Null, e)
		z = -z
	End If
	
	e.Move( x, y, z )
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:Entity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	e.Rotate(-pitch, -yaw, roll, glob)
	e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:Entity, e2:Entity, glob=True)

	If e = Null Then Return

	e.SetParent(e2, glob)	
	If e2 &lt;&gt; Null Then e2.Update() Else e.Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:Entity, sx#, sy#, sz#)

	If e = Null Then Return
	e.Scale(sx, sy, sz)
	e.Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2(x# Var, y# Var, z# Var, src:Entity, dst:Entity)

	Local mat1:TMatrix
	Local mat2:TMatrix
	
	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormVector2(x# Var, y# Var, z# Var, src:Entity, dst:Entity)

	Local mat1:TMatrix
	Local mat2:TMatrix 

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.GetMatrix()
		mat1.grid[3,0] = 0 'remove translation
		mat1.grid[3,1] = 0
		mat1.grid[3,2] = 0
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.GetInvMatrix()		
		mat2.grid[3,0] = 0 'remove translation
		mat2.grid[3,1] = 0
		mat2.grid[3,2] = 0
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'
'											EXAMPLE
'
'-----------------------------------------------------------------------------------------------------------------------------------

	Graphics3D 800, 600, 0, 2
	
	CreateLight()
	
	Local cam:TCamera = CreateCamera()
	MoveEntity cam, 0, 0, -15

	Local e1:Entity = Entity.Create(CreateCone())
	Local e2:Entity = Entity.Create(CreateCone())
	PositionEntity2 e2, 0, 3, 0
	EntityParent2 e2, e1
						
	Repeat
		
		TurnEntity2 e1, 1, 0, 0
	
		RenderWorld				
		
		Flip
		
	Until KeyHit(key_escape)
	
	End
</textarea><br>The routines for EntityPitch/Yaw/Roll are still missing. I just can't seem to get that right somehow. If this works okay, I will later on update the code archive entry with it.<br><br>Todo:<br><pre class=code>
V-EntityPitch/Yaw/Roll
V-further intergration with minib3d
V-Strict compiling (keep forgetting that, sorry)
</pre> <br><br></td></tr></table><br>
<a name="961984"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> so there's no longer a dependency on cower.math3d? <br><br></td></tr></table><br>
<a name="961985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, indeed, but it does require a minib3d rebuild. <br>I now tried to avoid creating a big number of objects, as Simon suggested.<br>Hopefully later on, these commands can be intergrated with minib3d's common commandset. But I first need to see if and how that would be suitable.<br>I mean, I have no idea if collisions would still work, how b3d animations are done and if everything works allright. <br><br></td></tr></table><br>
<a name="961991"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is an updated version of TEntity.bmx.<br>It includes the new commands.<br>Again, not tested thoroughly, but a quick implementation to see it working.<br><br>TEntity.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TEntity

	Global entity_list:TList=CreateList()

	Field child_list:TList=CreateList()

	Field parent:TEntity
	
	Field rotmat:TMatrix=TMatrix.Create()'rotation matrix
	Field mat:TMatrix=New TMatrix
	Field px#,py#,pz#,sx#=1.0,sy#=1.0,sz#=1.0,rx#,ry#,rz#,qw#,qx#,qy#,qz#
	
	Field name$
	Field class$
	Field hide=False
	Field order,alpha_order#
	Field auto_fade,fade_near#,fade_far#,fade_alpha#

	Field brush:TBrush=New TBrush
	
	Field cull_radius#
	
	Field radius_x#=1.0,radius_y#=1.0
	Field box_x#=-1.0,box_y#=-1.0,box_z#=-1.0,box_w#=2.0,box_h#=2.0,box_d#=2.0
	Field collision_type
	Field no_collisions,collision:TCollisionImpact[]
	Field pick_mode,obscurer

	Field anim ' true if mesh contains anim data
	Field anim_render ' true to render as anim mesh
	Field anim_mode
	Field anim_time#
	Field anim_speed#
	Field anim_seq
	Field anim_trans
	Field anim_dir=1 ' 1=forward, -1=backward
	Field anim_seqs_first[1]
	Field anim_seqs_last[1]
	Field no_seqs=0
	Field anim_update
	
	Global tformed_x#
	Global tformed_y#
	Global tformed_z#
	
	' used by TCollisions
	Field old_x#
	Field old_y#
	Field old_z#
		
	Field link:TLink ' entity_list tlink, stored for quick removal of entity from list ***note*** not currently used to remove entity from list

	Method CopyEntity:TEntity(parent_ent:TEntity=Null) Abstract
	Method Update() Abstract

	Method New()
	
		If LOG_NEW
			DebugLog "New TEntity"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TEntity"
		EndIf
	
	End Method

	Method FreeEntity()
	
		ListRemove(entity_list,Self)
	
		'RemoveLink link ' remove self from entity list - mem leak!
		
		' remove from collision entity lists
		If collision_type&lt;&gt;0 ListRemove(TCollisionPair.ent_lists[collision_type],Self)
		
		' remove from pick entity list
		If pick_mode&lt;&gt;0 ListRemove(TPick.ent_list,Self)
		
		Local ent:TEntity
		
		' free self from parent's child_list
		If parent&lt;&gt;Null
			For ent=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
		EndIf
		
		parent=Null
		mat=Null
		brush=Null
		link=Null
	
		' free children entities
		For ent=EachIn child_list
			ent.FreeEntity()
			ent=Null
		Next

	End Method

	' Entity movement

	Method PositionEntity(x#,y#,z#,glob=False)

		px=x
		py=y
		pz=-z

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null
			
			px=px-parent.EntityX(True)
			py=py-parent.EntityY(True)
			pz=pz+parent.EntityZ(True) ' z reversed
			
			Local prx#=-parent.EntityPitch(True)
			Local pry#=parent.EntityYaw(True)
			Local prz#=parent.EntityRoll(True)
			
			Local psx#=parent.EntityScaleX(True)
			Local psy#=parent.EntityScaleY(True)
			Local psz#=parent.EntityScaleZ(True)
						
			Local new_mat:TMatrix=New TMatrix
			new_mat.LoadIdentity()
			new_mat.Scale(1.0/psx#,1.0/psy#,1.0/psz#)
			new_mat.RotateRoll(-prz)
			new_mat.RotatePitch(-prx)
			new_mat.RotateYaw(-pry)
			new_mat.Translate(px,py,pz)
			
			px=new_mat.grid[3,0]
			py=new_mat.grid[3,1]
			pz=new_mat.grid[3,2]

		EndIf
	
		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method
		
	Method MoveEntity(mx#,my#,mz#)

		mz#=-mz

		Local new_mat:TMatrix=New TMatrix
		new_mat.LoadIdentity()
		new_mat.RotateYaw(ry)
		new_mat.RotatePitch(rx)
		new_mat.RotateRoll(rz)
		new_mat.Translate(mx#,my#,mz#)
	
		mx=new_mat.grid[3,0]
		my=new_mat.grid[3,1]
		mz=new_mat.grid[3,2]
		
		px=px+mx
		py=py+my
		pz=pz+mz

		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		UpdateChildren(Self)

	End Method

	Method TranslateEntity(tx#,ty#,tz#,glob=False)

		'Local tx#=x
		'Local ty#=y
		tz#=-tz#

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null

			Local ax#=-parent.EntityPitch(True)
			Local ay#=parent.EntityYaw(True)
			Local az#=parent.EntityRoll(True)
						
			Local new_mat:TMatrix=New TMatrix
			new_mat.LoadIdentity()
			new_mat.RotateRoll(-az)
			new_mat.RotatePitch(-ax)
			new_mat.RotateYaw(-ay)
			new_mat.Translate(tx,ty,tz)

			tx=new_mat.grid[3,0]
			ty=new_mat.grid[3,1]
			tz=new_mat.grid[3,2]
			
		EndIf
		
		px=px+tx
		py=py+ty
		pz=pz+tz

		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method
	
	Method ScaleEntity(x#,y#,z#,glob=False)

		sx#=x#
		sy#=y#
		sz#=z#

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null
			
			Local ent:TEntity=Self
						
			Repeat

				sx#=sx#/ent.parent.sx#
				sy#=sy#/ent.parent.sy#
				sz#=sz#/ent.parent.sz#
	
				ent=ent.parent
									
			Until ent.parent=Null	
	
		EndIf
	
		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method

	Method RotateEntity(x#,y#,z#,glob=False)

		rx=-x#
		ry=y#
		rz=z#
		
		' conv glob to local. pitch/yaw/roll always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null

			rx=rx+parent.EntityPitch(True)
			ry=ry-parent.EntityYaw(True)
			rz=rz-parent.EntityRoll(True)
		
		EndIf
		
		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method

	Method TurnEntity(x#,y#,z#,glob=False)

		Local tx#=-x
		Local ty#=y
		Local tz#=z

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null

			'
			
		EndIf
				
		rx=rx+tx
		ry=ry+ty
		rz=rz+tz

		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method

	' Function by mongia2
	Method PointEntity(target_ent:TEntity,roll#=0)
	
		Local x#=target_ent.EntityX#(True)
		Local y#=target_ent.EntityY#(True)
		Local z#=target_ent.EntityZ#(True)

		Local xdiff#=Self.EntityX(True)-x#
		Local ydiff#=Self.EntityY(True)-y#
		Local zdiff#=Self.EntityZ(True)-z#

		Local dist22#=Sqr((xdiff#*xdiff#)+(zdiff#*zdiff#))
		Local pitch#=ATan2(ydiff#,dist22#)
		Local yaw#=ATan2(xdiff#,-zdiff#)

		Self.RotateEntity pitch#,yaw#,roll#,True

	End Method
		
	' Entity animation

	' load anim seq - copies anim data from mesh to self
	Method LoadAnimSeq(file:String)
	
		If FileType(file)=0 Then Return 0
	
		' mesh that we will load anim seq from
		Local mesh:TMesh=TModel.LoadAnimB3D:TMesh(file)
		
		If anim=False Then Return 0 ' self contains no anim data
		If mesh.anim=False Then Return 0 ' mesh contains no anim data
	
		no_seqs=no_seqs+1
		
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' update anim_seqs array
		anim_seqs_first[no_seqs]=anim_seqs_last[0]
		anim_seqs_last[no_seqs]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		' update anim_seqs_last[0] - sequence 0 is for all frames, so this needs to be increased
		' must be done after updating anim_seqs array above
		anim_seqs_last[0]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		If mesh&lt;&gt;Null

			' go through all bones belonging to self
			For Local bone:TBone=EachIn TMesh(Self).bones
			
				' find bone in mesh that matches bone in self - search based on bone name
				Local mesh_bone:TBone=TBone(TEntity(mesh).FindChild(bone.name$))
			
				If mesh_bone&lt;&gt;Null
			
					' resize self arrays first so the one empty element at the end is removed
					bone.keys.flags=bone.keys.flags[..bone.keys.flags.length-1]
					bone.keys.px=bone.keys.px[..bone.keys.px.length-1]
					bone.keys.py=bone.keys.py[..bone.keys.py.length-1]
					bone.keys.pz=bone.keys.pz[..bone.keys.pz.length-1]
					bone.keys.sx=bone.keys.sx[..bone.keys.sx.length-1]
					bone.keys.sy=bone.keys.sy[..bone.keys.sy.length-1]
					bone.keys.sz=bone.keys.sz[..bone.keys.sz.length-1]
					bone.keys.qw=bone.keys.qw[..bone.keys.qw.length-1]
					bone.keys.qx=bone.keys.qx[..bone.keys.qx.length-1]
					bone.keys.qy=bone.keys.qy[..bone.keys.qy.length-1]
					bone.keys.qz=bone.keys.qz[..bone.keys.qz.length-1]
					
					' add mesh bone key arrays to self bone key arrays
					bone.keys.frames=anim_seqs_last[0]
					bone.keys.flags=bone.keys.flags+mesh_bone.keys.flags
					bone.keys.px=bone.keys.px+mesh_bone.keys.px
					bone.keys.py=bone.keys.py+mesh_bone.keys.py
					bone.keys.pz=bone.keys.pz+mesh_bone.keys.pz
					bone.keys.sx=bone.keys.sx+mesh_bone.keys.sx
					bone.keys.sy=bone.keys.sy+mesh_bone.keys.sy
					bone.keys.sz=bone.keys.sz+mesh_bone.keys.sz
					bone.keys.qw=bone.keys.qw+mesh_bone.keys.qw
					bone.keys.qx=bone.keys.qx+mesh_bone.keys.qx
					bone.keys.qy=bone.keys.qy+mesh_bone.keys.qy
					bone.keys.qz=bone.keys.qz+mesh_bone.keys.qz
				
				EndIf
				
			Next
				
		EndIf
		
		mesh.FreeEntity()
		
		Return no_seqs
	
	End Method
	
	Method ExtractAnimSeq(first_frame,last_frame,seq=0)
	
		no_seqs=no_seqs+1
	
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' if seq specifed then extract anim sequence from within existing sequnce
		Local offset=0
		If seq&lt;&gt;0
			offset=anim_seqs_first[seq]
		EndIf
	
		anim_seqs_first[no_seqs]=first_frame+offset
		anim_seqs_last[no_seqs]=last_frame+offset
		
		Return no_seqs
	
	End Method

	Method Animate(mode=1,speed#=1.0,seq=0,trans=0)
	
		anim_mode=mode
		anim_speed#=speed#
		anim_seq=seq
		anim_trans=trans
		anim_time#=anim_seqs_first[seq]
		anim_update=True ' update anim for all modes (including 0)
		
		If trans&gt;0
			anim_time#=0
		EndIf
		
	End Method
	
	' Updates:
	' 30/01/06 - updated to make anim_time return wrapped value
	Method SetAnimTime(time#,seq=0)
	
		anim_mode=-1 ' use a mode of -1 for setanimtime
		anim_speed#=0
		anim_seq=seq
		anim_trans=0
		anim_time#=time#
		anim_update=False ' set anim_update to false so UpdateWorld won't animate entity

		Local first=anim_seqs_first[anim_seq]
		Local last=anim_seqs_last[anim_seq]
		Local first2last=anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq]
		
		time#=time#+first ' offset time so that anim time of 0 will equal first frame of sequence
		
		If time#&gt;last And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#-first2last
			Until time#&lt;=last
		EndIf
		If time#&lt;first And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#+first2last
			Until time#&gt;=first
		EndIf
		
		TAnimation.AnimateMesh(Self,time#,first,last)

		anim_time#=time# ' update anim_time# to equal time#

	End Method
	
	Method AnimSeq()
	
		Return anim_seq ' current anim sequence
	
	End Method
	
	Method AnimLength()
	
		Return anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq] ' no of frames in anim sequence
	
	End Method

	Method AnimTime#()
	
		' if animation in transition, return 0 (anim_time actually will be somewhere between 0 and 1)
		If anim_trans&gt;0 Then Return 0
		
		' for animate and setanimtime we want to return anim_time starting from 0 and ending at no. of frames in sequence
		If anim_mode&gt;0 Or anim_mode=-1
			Return anim_time#-anim_seqs_first[anim_seq]
		EndIf

		Return 0

	End Method
	
	Method Animating()
	
		If anim_trans&gt;0 Then Return True
		If anim_mode&gt;0 Then Return True
		
		Return False
	
	End Method
		
	' Entity control

	Method EntityColor(r#,g#,b#)
	
		brush.red  =r#/255.0
		brush.green=g#/255.0
		brush.blue =b#/255.0
	
	End Method

	Method EntityAlpha(a#)
	
		brush.alpha=a#
			
	End Method
	
	Method EntityShininess(s#)
	
		brush.shine=s#
	
	End Method

	Method EntityTexture(texture:TTexture,frame=0,index=0)

		brush.tex[index]=texture
		If index+1&gt;brush.no_texs Then brush.no_texs=index+1
		
		If frame&lt;0 Then frame=0
		If frame&gt;texture.no_frames-1 Then frame=texture.no_frames-1 
		brush.tex_frame=frame
	
	End Method
	
	Method EntityBlend(blend_no)
	
		brush.blend=blend_no
		
		If TMesh(Self)&lt;&gt;Null
		
			' overwrite surface blend modes with master blend mode
			For Local surf:TSurface=EachIn TMesh(Self).surf_list
				If surf.brush&lt;&gt;Null
					surf.brush.blend=brush.blend
				EndIf
			Next
			
		EndIf
		
	End Method
	
	Method EntityFX(fx_no)
	
		brush.fx=fx_no
		
	End Method
	
	Method EntityAutoFade(near#,far#)
	
		auto_fade=True
		fade_near=near#
		fade_far=far#
	
	End Method
	
	Method PaintEntity(bru:TBrush)
	
		brush.no_texs=bru.no_texs
		brush.name$=bru.name$
		brush.red#=bru.red#
		brush.green#=bru.green#
		brush.blue#=bru.blue#
		brush.alpha#=bru.alpha#
		brush.shine#=bru.shine#
		brush.blend=bru.blend
		brush.fx=bru.fx
		For Local i=0 To 7
			brush.tex[i]=bru.tex[i]
		Next
	
	End Method
	
	Method EntityOrder(order_no)
	
		order=order_no

		If TCamera(Self)&lt;&gt;Null
			ListRemove(TCamera.cam_list,Self)
			EntityListAdd(TCamera.cam_list)
		EndIf

	End Method
	
	Method ShowEntity()
	
		hide=False
		
	End Method

	Method HideEntity()

		hide=True

	End Method

	Method Hidden()
	
		If hide=True Return True
		
		Local ent:TEntity=parent
		While ent&lt;&gt;Null
			If ent.hide=True Return True
			ent=ent.parent
		Wend
		
		Return False
	
	End Method

	Method NameEntity(e_name$)
	
		name$=e_name$
	
	End Method
	
	Method EntityParent(parent_ent:TEntity,glob=True)

		'' remove old parent

		' get global values
		Local gpx:Float=EntityX(True)
		Local gpy:Float=EntityY(True)
		Local gpz:Float=EntityZ(True)
		
		Local grx:Float=EntityPitch(True)
		Local gry:Float=EntityYaw(True)
		Local grz:Float=EntityRoll(True)
		
		Local gsx:Float=EntityScaleX(True)
		Local gsy:Float=EntityScaleY(True)
		Local gsz:Float=EntityScaleZ(True)
	
		' remove self from parent's child list
		If parent&lt;&gt;Null
			For Local ent:TEntity=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
			parent=Null
		EndIf

		' entity no longer has parent, so set local values to equal global values
		' must get global values before we reset transform matrix with UpdateMat
		px#=gpx
		py#=gpy
		pz#=-gpz
		rx#=-grx
		ry#=gry
		rz#=grz
		sx#=gsx
		sy#=gsy
		sz#=gsz
		
		''
		
		' No new parent
		If parent_ent=Null
			UpdateMat(True)
			Return
		EndIf
		
		' New parent
	
		If parent_ent&lt;&gt;Null
			
			If glob=True

				AddParent(parent_ent)
				'UpdateMat()

				PositionEntity(gpx,gpy,gpz,True)
				RotateEntity(grx,gry,grz,True)
				ScaleEntity(gsx,gsy,gsz,True)

			Else
			
				AddParent(parent_ent)
				UpdateMat()
				
			EndIf
			
		EndIf

	End Method
		
	Method GetParent:TEntity()
	
		Return parent
	
	End Method

	' Entity state

	Method EntityX#(glob=False)
	
		If glob=False
		
			Return px
		
		Else
		
			Return mat.grid[3,0]
		
		EndIf
	
	End Method
	
	Method EntityY#(glob=False)
	
		If glob=False
		
			Return py
		
		Else
		
			Return mat.grid[3,1]
		
		EndIf
	
	End Method
	
	Method EntityZ#(glob=False)
	
		If glob=False
		
			Return -pz
		
		Else
		
			Return -mat.grid[3,2]
		
		EndIf
	
	End Method

	Method EntityPitch#(glob=False)
		
		If glob=False
		
			Return -rx
			
		Else
		
			Local ang#=ATan2( mat.grid[2,1],Sqr( mat.grid[2,0]*mat.grid[2,0]+mat.grid[2,2]*mat.grid[2,2] ) )
			'Local ang#=ASin(mat.grid[2,1])
			'If ang#=nan Then ang#=0
			If ang#&lt;=0.0001 And ang#&gt;=-0.0001 Then ang#=0
		
			Return ang#
			
		EndIf
			
	End Method
	
	Method EntityYaw#(glob=False)
		
		If glob=False
		
			Return ry
			
		Else
		
			Local a#=mat.grid[2,0]
			Local b#=mat.grid[2,2]
			If a#&lt;=0.0001 And a#&gt;=-0.0001 Then a#=0
			If b#&lt;=0.0001 And b#&gt;=-0.0001 Then b#=0
			Return ATan2(a#,b#)
			
		EndIf
			
	End Method
	
	Method EntityRoll#(glob=False)
		
		If glob=False
		
			Return rz
			
		Else
		
			Local a#=mat.grid[0,1]
			Local b#=mat.grid[1,1]
			If a#&lt;=0.0001 And a#&gt;=-0.0001 Then a#=0
			If b#&lt;=0.0001 And b#&gt;=-0.0001 Then b#=0
			Return ATan2(a#,b#)
			
		EndIf
			
	End Method
	
	Method EntityClass$()
		
		Return class$
		
	End Method
	
	Method EntityName$()
		
		Return name$
		
	End Method
	
	Method CountChildren()

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1

		Next

		Return no_children

	End Method
	
	Method GetChild:TEntity(child_no)
	
		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1
			If no_children=child_no Return ent

		Next

		Return Null
	
	End Method
	
	Method FindChild:TEntity(child_name$)
	
		Local cent:TEntity
	
		For Local ent:TEntity=EachIn child_list

			If ent.EntityName$()=child_name$ Return ent

			cent=ent.FindChild(child_name$)
			
			If cent&lt;&gt;Null Return cent
	
		Next

		Return Null
	
	End Method
	
	' Calls function in TPick
	Method EntityPick:TEntity(range#)
	
		Return TPick.EntityPick:TEntity(Self,range#)
	
	End Method
	
	' Calls function in TPick
	Method LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
		Return TPick.LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
	End Method
	
	' Calls function in TPick
	Method EntityVisible(src_entity:TEntity,dest_entity:TEntity)
	
		Return TPick.EntityVisible(src_entity,dest_entity)
	
	End Method
	
	Method EntityDistance#(ent2:TEntity)

		Return Sqr(Self.EntityDistanceSquared#(ent2))

	End Method
	
	' Function by Vertex
	Method DeltaYaw#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		'Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
		
		Return -ATan2(x#,z#)

	End Method
	
	' Function by Vertex
	Method DeltaPitch#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
	
		Return -ATan2(y#,Sqr(x#*x#+z#*z#))
	
	End Method
	
	Function TFormPoint(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)
	
		Global mat:TMatrix=New TMatrix '***global***
	
		If src_ent&lt;&gt;Null

			mat.Overwrite(src_ent.mat)
			mat.Translate(x#,y#,-z#)
			
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
		
		EndIf

		If dest_ent&lt;&gt;Null

			mat.LoadIdentity()
		
			Local ent:TEntity=dest_ent
			
			Repeat
	
				mat.Scale(1.0/ent.sx,1.0/ent.sy,1.0/ent.sz)
				mat.RotateRoll(-ent.rz)
				mat.RotatePitch(-ent.rx)
				mat.RotateYaw(-ent.ry)
				mat.Translate(-ent.px,-ent.py,-ent.pz)																																																																																																																																																																																																																																																																																																																																									

				ent=ent.parent
			
			Until ent=Null
		
			mat.Translate(x#,y#,-z#)
			
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
			
		EndIf
		
		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormVector(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)
	
		Global mat:TMatrix=New TMatrix '***global***
	
		If src_ent&lt;&gt;Null

			mat.Overwrite(src_ent.mat)
			
			mat.grid[3,0]=0
			mat.grid[3,1]=0
			mat.grid[3,2]=0
			mat.grid[3,3]=1
			mat.grid[0,3]=0
			mat.grid[1,3]=0
			mat.grid[2,3]=0
				
			mat.Translate(x#,y#,-z#)
	
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
		
		EndIf

		If dest_ent&lt;&gt;Null

			mat.LoadIdentity()
			'mat.Translate(x#,y#,z#)
		
			Local ent:TEntity=dest_ent
			
			Repeat
	
				mat.Scale(1.0/ent.sx,1.0/ent.sy,1.0/ent.sz)
				mat.RotateRoll(-ent.rz)
				mat.RotatePitch(-ent.rx)
				mat.RotateYaw(-ent.ry)
				'mat.Translate(-ent.px,-ent.py,-ent.pz)																																																																																																																																																																																																																																																																																																																																									

				ent=ent.parent
			
			Until ent=Null
		
			mat.Translate(x#,y#,-z#)
			
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
			
		EndIf
		
		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
	
	End Function

	Function TFormNormal(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)

		TEntity.TFormVector(x#,y#,z#,src_ent,dest_ent)
		
		Local uv#=Sqr((tformed_x#*tformed_x#)+(tformed_y#*tformed_y#)+(tformed_z#*tformed_z#))
		
		tformed_x#:/uv#
		tformed_y#:/uv#
		tformed_z#:/uv#
	
	End Function
	
	Function TFormedX#()
	
		Return tformed_x#
	
	End Function
	
	Function TFormedY#()
	
		Return tformed_y#
	
	End Function
	
	Function TFormedZ#()
	
		Return tformed_z#
	
	End Function
	
	Method GetMatElement#(row,col)
	
		Return mat.grid[row,col]
	
	End Method
	
	' Entity collision
	
	Method ResetEntity()
	
		no_collisions=0
		collision=collision[..0]
		old_x=EntityX(True)
		old_y=EntityY(True)
		old_z=EntityZ(True)
	
	End Method
	
	Method EntityRadius(rx#,ry#=0.0)
	
		radius_x#=rx#
		If ry#=0.0 Then radius_y#=rx# Else radius_y#=ry#
	
	End Method
	
	Method EntityBox(x#,y#,z#,w#,h#,d#)
	
		box_x#=x#
		box_y#=y#
		box_z#=z#
		box_w#=w#
		box_h#=h#
		box_d#=d#
	
	End Method

	Method EntityType(type_no,recursive=False)
	
		' add to collision entity list if new type no&lt;&gt;0 and not previously added
		If collision_type=0 And type_no&lt;&gt;0
		
			If TCollisionPair.ent_lists[type_no]=Null Then TCollisionPair.ent_lists[type_no]=CreateList() ' create new list is one doesn't exist
			
			ListAddLast(TCollisionPair.ent_lists[type_no],Self)
			
		EndIf
		
		' remove from collision entity list if new type no=0 and previously added
		If collision_type&lt;&gt;0 And type_no=0
			ListRemove(TCollisionPair.ent_lists[type_no],Self)
		EndIf
		
		collision_type=type_no
		
		old_x#=EntityX(True)
		old_y#=EntityY(True)
		old_z#=EntityZ(True)
	
		If recursive=True
		
			For Local ent:TEntity=EachIn child_list
			
				ent.EntityType(type_no,True)
			
			Next
		
		EndIf
		
	End Method
	
	Method EntityPickMode(no,obscure=True)
	
		' add to pick entity list if new mode no&lt;&gt;0 and not previously added
		If pick_mode=0 And no&lt;&gt;0
			ListAddLast(TPick.ent_list,Self)
		EndIf
		
		' remove from pick entity list if new mode no=0 and previously added
		If pick_mode&lt;&gt;0 And no=0
			ListRemove(TPick.ent_list,Self)
		EndIf
	
		pick_mode=no
		obscurer=obscure
			
	End Method
	
	Method EntityCollided:TEntity(type_no)

		' if self is source entity and type_no is dest entity
		For Local i=1 To CountCollisions()
			If CollisionEntity(i).collision_type=type_no Then Return CollisionEntity(i)
		Next

		' if self is dest entity and type_no is src entity
		For Local ent:TEntity=EachIn TCollisionPair.ent_lists[type_no]
			For Local i=1 To ent.CountCollisions()
				If CollisionEntity(i)=Self Then Return ent		
			Next
		Next

		Return Null

	End Method
	
	Method CountCollisions()
	
		Return no_collisions
	
	End Method
	
	Method CollisionX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].x#
		
		EndIf
	
	End Method
	
	Method CollisionY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].y#
		
		EndIf
	
	End Method
	
	Method CollisionZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].z#
		
		EndIf
	
	End Method

	Method CollisionNX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nx#
		
		EndIf
	
	End Method
	
	Method CollisionNY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ny#
		
		EndIf
	
	End Method
	
	Method CollisionNZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nz#
		
		EndIf
	
	End Method
	
	Method CollisionTime#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].time#
		
		EndIf
	
	End Method
	
	Method CollisionEntity:TEntity(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ent
		
		EndIf
	
	End Method
	
	Method CollisionSurface:TSurface(index)
	
		If index&gt;0 And index&lt;=no_collisions

			Return collision[index-1].surf
		
		EndIf
	
	End Method
	
	Method CollisionTriangle(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].tri
		
		EndIf
	
	End Method
	
	Method GetEntityType()

		Return collision_type

	End Method
	
	' Sets an entity's mesh cull radius
	Method MeshCullRadius(radius#)
	
		' set to negative no. so we know when user has set cull radius (manual cull)
		' a check in TMesh.GetBounds then prevents negative no. being overwritten by a positive cull radius (auto cull)
		cull_radius#=-radius#
	
	End Method
	
	Method EntityScaleX#(glob=False)
	
		If glob=True

			If parent&lt;&gt;Null
				
				Local ent:TEntity=Self
					
				Local x#=sx#
							
				Repeat
	
					x#=x#*ent.parent.sx#

					ent=ent.parent
										
				Until ent.parent=Null
				
				Return x#
		
			EndIf

		EndIf
		
		Return sx#
		
	End Method
	
	Method EntityScaleY#(glob=False)
	
		If glob=True

			If parent&lt;&gt;Null
				
				Local ent:TEntity=Self
					
				Local y#=sy#
							
				Repeat
	
					y#=y#*ent.parent.sy#

					ent=ent.parent
										
				Until ent.parent=Null
				
				Return y#
		
			EndIf

		EndIf
		
		Return sy#
		
	End Method
	
	Method EntityScaleZ#(glob=False)
	
		If glob=True

			If parent&lt;&gt;Null
				
				Local ent:TEntity=Self
					
				Local z#=sz#
							
				Repeat
	
					z#=z#*ent.parent.sz#

					ent=ent.parent
										
				Until ent.parent=Null
				
				Return z#
		
			EndIf

		EndIf
		
		Return sz#
		
	End Method

	' Returns an entity's bounding sphere
	Rem
	Method BoundingSphere:TSphere()
	
		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=TFormedX()
			y=TFormedY()
			z=TFormedZ()
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		Local s:TSphere=New TSphere
		s.c.x=x
		s.c.y=y
		s.c.z=z
		s.r=radius
		
		Return s

	End Method
	End Rem

	' Returns an entity's bounding sphere
	Method BoundingSphereNew(sx# Var,sy# Var,sz# Var,sr# Var)

		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=tformed_x
			y=tformed_y
			z=tformed_z
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		sx=x
		sy=y
		sz=z
		sr=radius

	End Method
	
	Function CountAllChildren(ent:TEntity,no_children=0)
		
		Local ent2:TEntity
	
		For ent2=EachIn ent.child_list

			no_children=no_children+1
			
			no_children=TEntity.CountAllChildren(ent2,no_children)

		Next

		Return no_children

	End Function
	
	Method GetChildFromAll:TEntity(child_no,no_children Var,ent:TEntity=Null)

		If ent=Null Then ent=Self
		
		Local ent3:TEntity=Null
		
		For Local ent2:TEntity=EachIn ent.child_list

			no_children=no_children+1
			
			If no_children=child_no Then Return ent2
			
			If ent3=Null
			
				ent3=GetChildFromAll(child_no,no_children,ent2)

			EndIf

		Next

		Return ent3
			
	End Method
	
	' Internal - not recommended for general use

	Method UpdateMat(load_identity=False)

		If load_identity=True
			mat.LoadIdentity()
			mat.Translate(px,py,pz)
			mat.Rotate(rx,ry,rz)
			mat.Scale(sx,sy,sz)
		Else
			mat.Translate(px,py,pz)
			mat.Rotate(rx,ry,rz)
			mat.Scale(sx,sy,sz)
		EndIf
	
	End Method
	
	Method AddParent(parent_ent:TEntity)
	
		' self.parent = parent_ent
		parent:TEntity=parent_ent
		
		' add self to parent_ent child list
		If parent&lt;&gt;Null

			mat.Overwrite(parent.mat)
		
			ListAddLast(parent.child_list,Self)
		
		EndIf
		
	End Method
	
	Function UpdateChildren(ent_p:TEntity)
	
		For Local ent_c:TEntity=EachIn ent_p.child_list

			ent_c.mat.Overwrite(ent_p.mat)
			ent_c.UpdateMat()
				
			UpdateChildren(ent_c:TEntity)
			
		Next
	
	End Function

	' unoptimised, unused
	Method EntityDistanceSquared0#(ent2:TEntity)

		Local xd# = ent2.EntityX#(True)-EntityX#(True)
		Local yd# = ent2.EntityY#(True)-EntityY#(True)
		Local zd# = ent2.EntityZ#(True)-EntityZ#(True)
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method
	
	' optimised
	Method EntityDistanceSquared#(ent2:TEntity)

		Local xd# = ent2.mat.grid[3,0]-mat.grid[3,0]
		Local yd# = ent2.mat.grid[3,1]-mat.grid[3,1]
		Local zd# = -ent2.mat.grid[3,2]+mat.grid[3,2]
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method

	Method EntityListAdd(list:TList)
	
		' if order&gt;0, drawn first
		' if order&lt;0, drawn last
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=order Or TEntity(llink.Value()).order&lt;=0
	
			link=list.InsertBeforeLink(Self,llink)
			Return
	
		Else ' put entities with order=0 at back of list, so cameras with order=0 are sorted the same as in B3D

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=order Or TEntity(llink.Value()).order&gt;=0
	
			link=list.InsertAfterLink(Self,llink)
			Return

		EndIf

	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											BEGIN MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------

	'returns copy of rotation matrix	
	Method MQ_CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = rotmat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method MQ_Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method MQ_Rotate( pitch#, yaw#, roll#, glob=False )

		Local q1_x#, q1_y#, q1_z#, q1_w#
		Local q2_x#, q2_y#, q2_z#, q2_w#
		Local q3_x#, q3_y#, q3_z#, q3_w#
		Local m2:TMatrix
				
		Quaternion_FromAngleAxis( pitch, 1, 0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
		Quaternion_FromAngleAxis( yaw,   0, 1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
		Quaternion_FromAngleAxis( roll,  0, 0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
		
		Quaternion_MultiplyQuat( q1_x, q1_y, q1_z, q1_w, q2_x, q2_y, q2_z, q2_w, q1_x, q1_y, q1_z, q1_w)
		Quaternion_MultiplyQuat( q1_x, q1_y, q1_z, q1_w, q3_x, q3_y, q3_z, q3_w, q1_x, q1_y, q1_z, q1_w)
		
		rotmat.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = parent.MQ_GetInvMatrix()
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			rotmat.Multiply2(m2)
		End If
		
	End Method

	'turn entity
	Method MQ_Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then		
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method MQ_TransformPoint( ix# Var,iy# Var,iz# Var)
		
		rotmat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method MQ_Position( qx#,qy#,qz#, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then TFormPoint2(qx, qy, qz, Null, parent)
		End If
		
		px = qx
		py = qy
		pz = qz

	End Method

	'move an entity
	Method MQ_Move( qx#,qy#,qz# )
	
		MQ_TransformPoint(qx,qy,qz) 'transform point by internal matrix
		px = px + qx 'add to position
		py = py + qy
		pz = pz + qz
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix()
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat0:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat0 = parent.MQ_GetInvMatrix()
		Else
			mat0 = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = MQ_CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-px,-py,-pz)
		
		'combine
		mat3.Multiply2(mat1)
		mat2.Multiply2(mat3)
		mat0.Multiply2(mat2)
		
		Return mat0
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix()
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		
		'scale
		mat3:TMatrix = TMatrix.Create()
		mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(px, py, pz)
		'rotation
		mat3.Multiply2(rotmat)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat3.Multiply2(parent.MQ_GetMatrix())
		End If
		
		Return mat3
		
	End Method

	'update attached entity
	Method MQ_Update()
	
		Local e:TEntity

		'get matrix transformed by parents
		mat.Overwrite(MQ_GetMatrix())
						
		'update child_list		
		For e:TEntity = EachIn child_list
			e.MQ_Update
		Next

	End Method

	'set an entity's parent	
	Method MQ_SetParent(e:TEntity, glob)
	
		Local orgx#,orgy#,orgz#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			orgx# = 0
			orgy# = 0
			orgz# = 0
			TFormPoint2(orgx, orgy, orgz, Self, Null)
			m1:TMatrix = MQ_GetMatrix()
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.child_list, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then TFormPoint2(orgx, orgy, orgz, Null, e)
			'set position
			px = orgx
			py = orgy
			pz = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.MQ_GetInvMatrix()
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			m1.Multiply2(m2)
			rotmat.Overwrite(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.child_list, Self
	
	End Method

	'get entity scale	
	Method MQ_GetScaleXYZ(width# Var, height# Var, depth# Var)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		m:TMatrix = MQ_GetMatrix()
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											END MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------
End Type


'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:TEntity, x#, y#, z#, glob=False )

	If e = Null Then Return
	
	e.MQ_Position( x, y, z, glob )
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:TEntity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	pitch = -pitch
	
	If pitch# &lt;&gt; 0 Then e.MQ_Turn(pitch, 1, 0, 0, glob)
	If yaw#   &lt;&gt; 0 Then e.MQ_Turn(yaw,   0, 1, 0, glob)
	If roll#  &lt;&gt; 0 Then e.MQ_Turn(roll,  0, 0, 1, glob)
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:TEntity, x#, y#, z#, glob=False)

	If e = Null Then Return	

	If glob Then
		TFormVector2(x, y, z, Null, e)
		z = -z
	End If
	
	e.MQ_Move( x, y, z )
	e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:TEntity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	e.MQ_Rotate(-pitch, -yaw, roll, glob)
	e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:TEntity, e2:TEntity, glob=True)

	If e = Null Then Return

	e.MQ_SetParent(e2, glob)	
	If e2 &lt;&gt; Null Then e2.MQ_Update() Else e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:TEntity, sx#, sy#, sz#)

	If e = Null Then Return
	e.MQ_Scale(sx, sy, sz)
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	Local mat1:TMatrix
	Local mat2:TMatrix
	
	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.MQ_GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.MQ_GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormVector2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	Local mat1:TMatrix
	Local mat2:TMatrix 

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.MQ_GetMatrix()
		mat1.grid[3,0] = 0 'remove translation
		mat1.grid[3,1] = 0
		mat1.grid[3,2] = 0
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.MQ_GetInvMatrix()		
		mat2.grid[3,0] = 0 'remove translation
		mat2.grid[3,1] = 0
		mat2.grid[3,2] = 0
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function
</textarea><br><br>TMatrix.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TMatrix

	Field grid#[4,4]
	
	Function Create:TMatrix()
	
		Local m:TMatrix = New TMatrix
		m.LoadIdentity()
		Return m
		
	End Function
	
	Method New()
		
		If LOG_NEW
			DebugLog "New TMatrix"
		EndIf

	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TMatrix"
		EndIf

	End Method
	
	Method LoadIdentity()
	
		grid[0,0]=1.0 grid[1,0]=0.0 grid[2,0]=0.0 grid[3,0]=0.0
		grid[0,1]=0.0 grid[1,1]=1.0 grid[2,1]=0.0 grid[3,1]=0.0
		grid[0,2]=0.0 grid[1,2]=0.0 grid[2,2]=1.0 grid[3,2]=0.0		
		grid[0,3]=0.0 grid[1,3]=0.0 grid[2,3]=0.0 grid[3,3]=1.0
	
	End Method
	
	' copy - create new copy and returns it
	
	Method Copy:TMatrix()
	
		Local mat:TMatrix=New TMatrix
	
		mat.grid[0,0]=grid[0,0]
		mat.grid[1,0]=grid[1,0]
		mat.grid[2,0]=grid[2,0]
		mat.grid[3,0]=grid[3,0]
		mat.grid[0,1]=grid[0,1]
		mat.grid[1,1]=grid[1,1]
		mat.grid[2,1]=grid[2,1]
		mat.grid[3,1]=grid[3,1]
		mat.grid[0,2]=grid[0,2]
		mat.grid[1,2]=grid[1,2]
		mat.grid[2,2]=grid[2,2]
		mat.grid[3,2]=grid[3,2]
		
		' do not remove
		mat.grid[0,3]=grid[0,3]
		mat.grid[1,3]=grid[1,3]
		mat.grid[2,3]=grid[2,3]
		mat.grid[3,3]=grid[3,3]
		
		Return mat
	
	End Method
	
	' overwrite - overwrites self with matrix passed as parameter
	
	Method Overwrite(mat:TMatrix)
	
		grid[0,0]=mat.grid[0,0]
		grid[1,0]=mat.grid[1,0]
		grid[2,0]=mat.grid[2,0]
		grid[3,0]=mat.grid[3,0]
		grid[0,1]=mat.grid[0,1]
		grid[1,1]=mat.grid[1,1]
		grid[2,1]=mat.grid[2,1]
		grid[3,1]=mat.grid[3,1]
		grid[0,2]=mat.grid[0,2]
		grid[1,2]=mat.grid[1,2]
		grid[2,2]=mat.grid[2,2]
		grid[3,2]=mat.grid[3,2]		
		grid[0,3]=mat.grid[0,3]
		grid[1,3]=mat.grid[1,3]
		grid[2,3]=mat.grid[2,3]
		grid[3,3]=mat.grid[3,3]
		
	End Method
	
	Method Inverse:TMatrix()

		Local mat:TMatrix=New TMatrix
	
		Local tx#=0
		Local ty#=0
		Local tz#=0
	
	  	' The rotational part of the matrix is simply the transpose of the
	  	' original matrix.
	  	mat.grid[0,0] = grid[0,0]
	  	mat.grid[1,0] = grid[0,1]
	  	mat.grid[2,0] = grid[0,2]
	
		mat.grid[0,1] = grid[1,0]
		mat.grid[1,1] = grid[1,1]
		mat.grid[2,1] = grid[1,2]
	
		mat.grid[0,2] = grid[2,0]
		mat.grid[1,2] = grid[2,1]
		mat.grid[2,2] = grid[2,2]
	
		' The right column vector of the matrix should always be [ 0 0 0 1 ]
		' in most cases. . . you don't need this column at all because it'll 
		' never be used in the program, but since this code is used with GL
		' and it does consider this column, it is here.
		mat.grid[0,3] = 0 
		mat.grid[1,3] = 0
		mat.grid[2,3] = 0
		mat.grid[3,3] = 1
	
		' The translation components of the original matrix.
		tx = grid[3,0]
		ty = grid[3,1]
		tz = grid[3,2]
	
		' Result = -(Tm * Rm) To get the translation part of the inverse
		mat.grid[3,0] = -( (grid[0,0] * tx) + (grid[0,1] * ty) + (grid[0,2] * tz) )
		mat.grid[3,1] = -( (grid[1,0] * tx) + (grid[1,1] * ty) + (grid[1,2] * tz) )
		mat.grid[3,2] = -( (grid[2,0] * tx) + (grid[2,1] * ty) + (grid[2,2] * tz) )
	
		Return mat

	End Method

	Method Translate(x#,y#,z#)
	
		grid[3,0] = grid#[0,0]*x# + grid#[1,0]*y# + grid#[2,0]*z# + grid#[3,0]
		grid[3,1] = grid#[0,1]*x# + grid#[1,1]*y# + grid#[2,1]*z# + grid#[3,1]
		grid[3,2] = grid#[0,2]*x# + grid#[1,2]*y# + grid#[2,2]*z# + grid#[3,2]

	End Method
	
	Method Rotate(rx#,ry#,rz#)
	
		Local cos_ang#,sin_ang#
	
		' yaw
	
		cos_ang#=Cos(ry#)
		sin_ang#=Sin(ry#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
		
		' pitch
		
		cos_ang#=Cos(rx#)
		sin_ang#=Sin(rx#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		
		' roll
		
		cos_ang#=Cos(rz#)
		sin_ang#=Sin(rz#)

		m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
	
	End Method
	
	Method RotatePitch(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12

	End Method
	
	Method RotateYaw(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Method RotateRoll(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)

		Local m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		Local m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		Local m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Rem bbdoc: Returns a matrix made from the quaternion
	End Rem
	Method FromQuaternion(x#,y#,z#,w#)
		' Based off of code in Axiom
		
		Local tx# = 2*x
		Local ty# = 2*y
		Local tz# = 2*z
		Local twx# = tx*w
		Local twy# = ty*w
		Local twz# = tz*w
		Local txx# = tx*x
		Local txy# = ty*x
		Local txz# = tz*x
		Local tyy# = ty*y
		Local tyz# = tz*y
		Local tzz# = tz*z
		
		grid[0,0] = 1.0-(tyy+tzz)
		grid[1,0] = txy-twz
		grid[2,0] = txz+twy
		grid[0,1] = txy+twz
		grid[1,1] = 1.0-(txx+tzz)
		grid[2,1] = tyz-twx
		grid[0,2] = txz-twy
		grid[1,2] = tyz+twx
		grid[2,2] = 1.0-(txx+tyy)
		
	End Method
	
	Rem bbdoc: Transforms the matrix by another matrix
	End Rem
	Method Multiply(mat:TMatrix)
	
		Local m00# = grid#[0,0]*mat.grid#[0,0] + grid#[1,0]*mat.grid#[0,1] + grid#[2,0]*mat.grid#[0,2] + grid#[3,0]*mat.grid#[0,3]
		Local m01# = grid#[0,1]*mat.grid#[0,0] + grid#[1,1]*mat.grid#[0,1] + grid#[2,1]*mat.grid#[0,2] + grid#[3,1]*mat.grid#[0,3]
		Local m02# = grid#[0,2]*mat.grid#[0,0] + grid#[1,2]*mat.grid#[0,1] + grid#[2,2]*mat.grid#[0,2] + grid#[3,2]*mat.grid#[0,3]
		Local m03# = grid#[0,3]*mat.grid#[0,0] + grid#[1,3]*mat.grid#[0,1] + grid#[2,3]*mat.grid#[0,2] + grid#[3,3]*mat.grid#[0,3]
		Local m10# = grid#[0,0]*mat.grid#[1,0] + grid#[1,0]*mat.grid#[1,1] + grid#[2,0]*mat.grid#[1,2] + grid#[3,0]*mat.grid#[1,3]
		Local m11# = grid#[0,1]*mat.grid#[1,0] + grid#[1,1]*mat.grid#[1,1] + grid#[2,1]*mat.grid#[1,2] + grid#[3,1]*mat.grid#[1,3]
		Local m12# = grid#[0,2]*mat.grid#[1,0] + grid#[1,2]*mat.grid#[1,1] + grid#[2,2]*mat.grid#[1,2] + grid#[3,2]*mat.grid#[1,3]
		Local m13# = grid#[0,3]*mat.grid#[1,0] + grid#[1,3]*mat.grid#[1,1] + grid#[2,3]*mat.grid#[1,2] + grid#[3,3]*mat.grid#[1,3]
		Local m20# = grid#[0,0]*mat.grid#[2,0] + grid#[1,0]*mat.grid#[2,1] + grid#[2,0]*mat.grid#[2,2] + grid#[3,0]*mat.grid#[2,3]
		Local m21# = grid#[0,1]*mat.grid#[2,0] + grid#[1,1]*mat.grid#[2,1] + grid#[2,1]*mat.grid#[2,2] + grid#[3,1]*mat.grid#[2,3]
		Local m22# = grid#[0,2]*mat.grid#[2,0] + grid#[1,2]*mat.grid#[2,1] + grid#[2,2]*mat.grid#[2,2] + grid#[3,2]*mat.grid#[2,3]
		Local m23# = grid#[0,3]*mat.grid#[2,0] + grid#[1,3]*mat.grid#[2,1] + grid#[2,3]*mat.grid#[2,2] + grid#[3,3]*mat.grid#[2,3]
		Local m30# = grid#[0,0]*mat.grid#[3,0] + grid#[1,0]*mat.grid#[3,1] + grid#[2,0]*mat.grid#[3,2] + grid#[3,0]*mat.grid#[3,3]
		Local m31# = grid#[0,1]*mat.grid#[3,0] + grid#[1,1]*mat.grid#[3,1] + grid#[2,1]*mat.grid#[3,2] + grid#[3,1]*mat.grid#[3,3]
		Local m32# = grid#[0,2]*mat.grid#[3,0] + grid#[1,2]*mat.grid#[3,1] + grid#[2,2]*mat.grid#[3,2] + grid#[3,2]*mat.grid#[3,3]
		Local m33# = grid#[0,3]*mat.grid#[3,0] + grid#[1,3]*mat.grid#[3,1] + grid#[2,3]*mat.grid#[3,2] + grid#[3,3]*mat.grid#[3,3]
	
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method
	
	Rem bbdoc: Transforms a vector by the matrix
	End Rem
	Method TransformVec( rx# Var,ry# Var,rz# Var, addTranslation% = 0 )
	
		Local w# = 1.0/( grid[0,3] + grid[1,3] + grid[2,3] + grid[3,3] )
		Local ix# = rx#
		Local iy# = ry#
		Local iz# = rz#
		
		addTranslation = Min( Max( addTranslation, 0 ), 1 )
		
		rx = ( ( grid[0,0]*ix ) + ( grid[1,0]*iy ) + ( grid[2,0]*iz ) + grid[3,0] * addTranslation ) * w
		ry = ( ( grid[0,1]*ix ) + ( grid[1,1]*iy ) + ( grid[2,1]*iz ) + grid[3,1] * addTranslation ) * w
		rz = ( ( grid[0,2]*ix ) + ( grid[1,2]*iy ) + ( grid[2,2]*iz ) + grid[3,2] * addTranslation ) * w
		
	End Method
	
	Rem bbdoc: Transposes the matrix
	End Rem
	Method Transpose()
	
	 Local x:Int,y:Int
	
	 Local a:Double[,] = New Double[4,4]
	
	 For x = 0 To 3
	 For y = 0 To 3
		 a[y,x] = grid[x,y]
	 Next
	 Next
	
	 For x = 0 To 3
	 For y = 0 To 3
		grid[x,y]=a[x,y]
	 Next
	 Next
	
	End Method
	
	
	Rem bbdoc: Sets the translation elements of the matrix
	End Rem
	Method SetTranslate( x#, y#, z# )
		grid[3,0] = x
		grid[3,1] = y
		grid[3,2] = z
	End Method
	
	Rem bbdoc: Scales the rotation elements of the matrix
	End Rem
	Method Scale(x#,y#,z#)
	
		grid[0,0] = grid#[0,0]*x#
		grid[0,1] = grid#[0,1]*x#
		grid[0,2] = grid#[0,2]*x#
	
		grid[1,0] = grid#[1,0]*y#
		grid[1,1] = grid#[1,1]*y#
		grid[1,2] = grid#[1,2]*y#
	
		grid[2,0] = grid#[2,0]*z#
		grid[2,1] = grid#[2,1]*z#
		grid[2,2] = grid#[2,2]*z# 
	
	End Method

	Method Multiply2(i:TMatrix)
				
		Local m00# = grid[0,0] * i.grid[0,0] + grid[0,1] * i.grid[1,0] + grid[0,2] * i.grid[2,0] + grid[0,3] * i.grid[3,0]
		Local m01# = grid[0,0] * i.grid[0,1] + grid[0,1] * i.grid[1,1] + grid[0,2] * i.grid[2,1] + grid[0,3] * i.grid[3,1]
		Local m02# = grid[0,0] * i.grid[0,2] + grid[0,1] * i.grid[1,2] + grid[0,2] * i.grid[2,2] + grid[0,3] * i.grid[3,2]
		Local m03# = grid[0,0] * i.grid[0,3] + grid[0,1] * i.grid[1,3] + grid[0,2] * i.grid[2,3] + grid[0,3] * i.grid[3,3]
		
		Local m10# = grid[1,0] * i.grid[0,0] + grid[1,1] * i.grid[1,0] + grid[1,2] * i.grid[2,0] + grid[1,3] * i.grid[3,0]
		Local m11# = grid[1,0] * i.grid[0,1] + grid[1,1] * i.grid[1,1] + grid[1,2] * i.grid[2,1] + grid[1,3] * i.grid[3,1]
		Local m12# = grid[1,0] * i.grid[0,2] + grid[1,1] * i.grid[1,2] + grid[1,2] * i.grid[2,2] + grid[1,3] * i.grid[3,2]
		Local m13# = grid[1,0] * i.grid[0,3] + grid[1,1] * i.grid[1,3] + grid[1,2] * i.grid[2,3] + grid[1,3] * i.grid[3,3]
		
		Local m20# = grid[2,0] * i.grid[0,0] + grid[2,1] * i.grid[1,0] + grid[2,2] * i.grid[2,0] + grid[2,3] * i.grid[3,0]
		Local m21# = grid[2,0] * i.grid[0,1] + grid[2,1] * i.grid[1,1] + grid[2,2] * i.grid[2,1] + grid[2,3] * i.grid[3,1]
		Local m22# = grid[2,0] * i.grid[0,2] + grid[2,1] * i.grid[1,2] + grid[2,2] * i.grid[2,2] + grid[2,3] * i.grid[3,2]
		Local m23# = grid[2,0] * i.grid[0,3] + grid[2,1] * i.grid[1,3] + grid[2,2] * i.grid[2,3] + grid[2,3] * i.grid[3,3]
				
		Local m30# = grid[3,0] * i.grid[0,0] + grid[3,1] * i.grid[1,0] + grid[3,2] * i.grid[2,0] + grid[3,3] * i.grid[3,0]
		Local m31# = grid[3,0] * i.grid[0,1] + grid[3,1] * i.grid[1,1] + grid[3,2] * i.grid[2,1] + grid[3,3] * i.grid[3,1]
		Local m32# = grid[3,0] * i.grid[0,2] + grid[3,1] * i.grid[1,2] + grid[3,2] * i.grid[2,2] + grid[3,3] * i.grid[3,2]
		Local m33# = grid[3,0] * i.grid[0,3] + grid[3,1] * i.grid[1,3] + grid[3,2] * i.grid[2,3] + grid[3,3] * i.grid[3,3]
		
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method
		
End Type


Rem bbdoc: Gets the magnitude of the vector
End Rem
Function Magnitude#( x#, y#, z# )
	Return Sqr( x*x + y*y + z*z )
End Function

Rem bbdoc: Creates a quaternion from an angle and an axis
End Rem
Function Quaternion_FromAngleAxis( angle#, ax#,ay#,az#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	Local ha# = .5*angle
	Local sn# = Sin( ha )
	
	rw# = Cos( ha )
	rx# = sn * ax
	ry# = sn * ay
	rz# = sn * az
	
End Function

Rem bbdoc: Multiplies a quaternion
End Rem
Function Quaternion_MultiplyQuat( x1#,y1#,z1#,w1#, x2#,y2#,z2#,w2#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	rw = w1*w2 - x1*x2 - y1*y2 - z1*z2
	rx = w1*x2 - x1*w2 - y1*z2 - z1*y2
	ry = w1*y2 - y1*w2 - z1*x2 - x1*z2
	rz = w1*z2 - z1*w2 - x1*y2 - y1*x2
	
End Function
</textarea><br><br>Example program:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import sidesign.minib3d


Graphics3D 800, 600, 0, 2

CreateLight()

Local cam:TCamera = CreateCamera()
MoveEntity cam, 0, 0, -15

e1 = CreateCone()
e2 = CreateCone()

PositionEntity2 e2, 0, 3, 0
EntityParent2 e2, e1
					
Repeat

	TurnEntity2 e1, 1, 0, 1
		
	RenderWorld				
	
	Flip
	
Until KeyHit(key_escape)

End
</textarea> <br><br></td></tr></table><br>
<a name="962057"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got it! Just a stupid type in MQ_Move. Instead of transforming the vector, the position of the entity was transformed by the rotation matrix. It was a good idea to have some sleep in the meanwhile. :) Well, updated the above code, and going further with testing it. <br><br></td></tr></table><br>
<a name="962066"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've now included EntityPitch/Yaw/Roll routines. I translated them from the math code that is posted in the bb.com thread. They seem to work good so far, better than any routine I could find before.<br><br>TEntity.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TEntity

	Global entity_list:TList=CreateList()

	Field child_list:TList=CreateList()

	Field parent:TEntity
	
	Field rotmat:TMatrix=TMatrix.Create()'rotation matrix
	Field mat:TMatrix=New TMatrix
	Field px#,py#,pz#,sx#=1.0,sy#=1.0,sz#=1.0,rx#,ry#,rz#,qw#,qx#,qy#,qz#
	
	Field name$
	Field class$
	Field hide=False
	Field order,alpha_order#
	Field auto_fade,fade_near#,fade_far#,fade_alpha#

	Field brush:TBrush=New TBrush
	
	Field cull_radius#
	
	Field radius_x#=1.0,radius_y#=1.0
	Field box_x#=-1.0,box_y#=-1.0,box_z#=-1.0,box_w#=2.0,box_h#=2.0,box_d#=2.0
	Field collision_type
	Field no_collisions,collision:TCollisionImpact[]
	Field pick_mode,obscurer

	Field anim ' true if mesh contains anim data
	Field anim_render ' true to render as anim mesh
	Field anim_mode
	Field anim_time#
	Field anim_speed#
	Field anim_seq
	Field anim_trans
	Field anim_dir=1 ' 1=forward, -1=backward
	Field anim_seqs_first[1]
	Field anim_seqs_last[1]
	Field no_seqs=0
	Field anim_update
	
	Global tformed_x#
	Global tformed_y#
	Global tformed_z#
	
	' used by TCollisions
	Field old_x#
	Field old_y#
	Field old_z#
		
	Field link:TLink ' entity_list tlink, stored for quick removal of entity from list ***note*** not currently used to remove entity from list

	Method CopyEntity:TEntity(parent_ent:TEntity=Null) Abstract
	Method Update() Abstract

	Method New()
	
		If LOG_NEW
			DebugLog "New TEntity"
		EndIf
	
	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TEntity"
		EndIf
	
	End Method

	Method FreeEntity()
	
		ListRemove(entity_list,Self)
	
		'RemoveLink link ' remove self from entity list - mem leak!
		
		' remove from collision entity lists
		If collision_type&lt;&gt;0 ListRemove(TCollisionPair.ent_lists[collision_type],Self)
		
		' remove from pick entity list
		If pick_mode&lt;&gt;0 ListRemove(TPick.ent_list,Self)
		
		Local ent:TEntity
		
		' free self from parent's child_list
		If parent&lt;&gt;Null
			For ent=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
		EndIf
		
		parent=Null
		mat=Null
		brush=Null
		link=Null
	
		' free children entities
		For ent=EachIn child_list
			ent.FreeEntity()
			ent=Null
		Next

	End Method

	' Entity movement

	Method PositionEntity(x#,y#,z#,glob=False)

		px=x
		py=y
		pz=-z

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null
			
			px=px-parent.EntityX(True)
			py=py-parent.EntityY(True)
			pz=pz+parent.EntityZ(True) ' z reversed
			
			Local prx#=-parent.EntityPitch(True)
			Local pry#=parent.EntityYaw(True)
			Local prz#=parent.EntityRoll(True)
			
			Local psx#=parent.EntityScaleX(True)
			Local psy#=parent.EntityScaleY(True)
			Local psz#=parent.EntityScaleZ(True)
						
			Local new_mat:TMatrix=New TMatrix
			new_mat.LoadIdentity()
			new_mat.Scale(1.0/psx#,1.0/psy#,1.0/psz#)
			new_mat.RotateRoll(-prz)
			new_mat.RotatePitch(-prx)
			new_mat.RotateYaw(-pry)
			new_mat.Translate(px,py,pz)
			
			px=new_mat.grid[3,0]
			py=new_mat.grid[3,1]
			pz=new_mat.grid[3,2]

		EndIf
	
		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method
		
	Method MoveEntity(mx#,my#,mz#)

		mz#=-mz

		Local new_mat:TMatrix=New TMatrix
		new_mat.LoadIdentity()
		new_mat.RotateYaw(ry)
		new_mat.RotatePitch(rx)
		new_mat.RotateRoll(rz)
		new_mat.Translate(mx#,my#,mz#)
	
		mx=new_mat.grid[3,0]
		my=new_mat.grid[3,1]
		mz=new_mat.grid[3,2]
		
		px=px+mx
		py=py+my
		pz=pz+mz

		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		UpdateChildren(Self)

	End Method

	Method TranslateEntity(tx#,ty#,tz#,glob=False)

		'Local tx#=x
		'Local ty#=y
		tz#=-tz#

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null

			Local ax#=-parent.EntityPitch(True)
			Local ay#=parent.EntityYaw(True)
			Local az#=parent.EntityRoll(True)
						
			Local new_mat:TMatrix=New TMatrix
			new_mat.LoadIdentity()
			new_mat.RotateRoll(-az)
			new_mat.RotatePitch(-ax)
			new_mat.RotateYaw(-ay)
			new_mat.Translate(tx,ty,tz)

			tx=new_mat.grid[3,0]
			ty=new_mat.grid[3,1]
			tz=new_mat.grid[3,2]
			
		EndIf
		
		px=px+tx
		py=py+ty
		pz=pz+tz

		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method
	
	Method ScaleEntity(x#,y#,z#,glob=False)

		sx#=x#
		sy#=y#
		sz#=z#

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null
			
			Local ent:TEntity=Self
						
			Repeat

				sx#=sx#/ent.parent.sx#
				sy#=sy#/ent.parent.sy#
				sz#=sz#/ent.parent.sz#
	
				ent=ent.parent
									
			Until ent.parent=Null	
	
		EndIf
	
		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method

	Method RotateEntity(x#,y#,z#,glob=False)

		rx=-x#
		ry=y#
		rz=z#
		
		' conv glob to local. pitch/yaw/roll always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null

			rx=rx+parent.EntityPitch(True)
			ry=ry-parent.EntityYaw(True)
			rz=rz-parent.EntityRoll(True)
		
		EndIf
		
		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method

	Method TurnEntity(x#,y#,z#,glob=False)

		Local tx#=-x
		Local ty#=y
		Local tz#=z

		' conv glob to local. x/y/z always local to parent or global if no parent
		If glob=True And parent&lt;&gt;Null

			'
			
		EndIf
				
		rx=rx+tx
		ry=ry+ty
		rz=rz+tz

		If parent&lt;&gt;Null
		
			mat.Overwrite(parent.mat)
			UpdateMat()
		
		Else ' glob=true or false
		
			UpdateMat(True)
			
		EndIf
		
		If child_list.IsEmpty()&lt;&gt;True Then UpdateChildren(Self)

	End Method

	' Function by mongia2
	Method PointEntity(target_ent:TEntity,roll#=0)
	
		Local x#=target_ent.EntityX#(True)
		Local y#=target_ent.EntityY#(True)
		Local z#=target_ent.EntityZ#(True)

		Local xdiff#=Self.EntityX(True)-x#
		Local ydiff#=Self.EntityY(True)-y#
		Local zdiff#=Self.EntityZ(True)-z#

		Local dist22#=Sqr((xdiff#*xdiff#)+(zdiff#*zdiff#))
		Local pitch#=ATan2(ydiff#,dist22#)
		Local yaw#=ATan2(xdiff#,-zdiff#)

		Self.RotateEntity pitch#,yaw#,roll#,True

	End Method
		
	' Entity animation

	' load anim seq - copies anim data from mesh to self
	Method LoadAnimSeq(file:String)
	
		If FileType(file)=0 Then Return 0
	
		' mesh that we will load anim seq from
		Local mesh:TMesh=TModel.LoadAnimB3D:TMesh(file)
		
		If anim=False Then Return 0 ' self contains no anim data
		If mesh.anim=False Then Return 0 ' mesh contains no anim data
	
		no_seqs=no_seqs+1
		
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' update anim_seqs array
		anim_seqs_first[no_seqs]=anim_seqs_last[0]
		anim_seqs_last[no_seqs]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		' update anim_seqs_last[0] - sequence 0 is for all frames, so this needs to be increased
		' must be done after updating anim_seqs array above
		anim_seqs_last[0]=anim_seqs_last[0]+mesh.anim_seqs_last[0]
	
		If mesh&lt;&gt;Null

			' go through all bones belonging to self
			For Local bone:TBone=EachIn TMesh(Self).bones
			
				' find bone in mesh that matches bone in self - search based on bone name
				Local mesh_bone:TBone=TBone(TEntity(mesh).FindChild(bone.name$))
			
				If mesh_bone&lt;&gt;Null
			
					' resize self arrays first so the one empty element at the end is removed
					bone.keys.flags=bone.keys.flags[..bone.keys.flags.length-1]
					bone.keys.px=bone.keys.px[..bone.keys.px.length-1]
					bone.keys.py=bone.keys.py[..bone.keys.py.length-1]
					bone.keys.pz=bone.keys.pz[..bone.keys.pz.length-1]
					bone.keys.sx=bone.keys.sx[..bone.keys.sx.length-1]
					bone.keys.sy=bone.keys.sy[..bone.keys.sy.length-1]
					bone.keys.sz=bone.keys.sz[..bone.keys.sz.length-1]
					bone.keys.qw=bone.keys.qw[..bone.keys.qw.length-1]
					bone.keys.qx=bone.keys.qx[..bone.keys.qx.length-1]
					bone.keys.qy=bone.keys.qy[..bone.keys.qy.length-1]
					bone.keys.qz=bone.keys.qz[..bone.keys.qz.length-1]
					
					' add mesh bone key arrays to self bone key arrays
					bone.keys.frames=anim_seqs_last[0]
					bone.keys.flags=bone.keys.flags+mesh_bone.keys.flags
					bone.keys.px=bone.keys.px+mesh_bone.keys.px
					bone.keys.py=bone.keys.py+mesh_bone.keys.py
					bone.keys.pz=bone.keys.pz+mesh_bone.keys.pz
					bone.keys.sx=bone.keys.sx+mesh_bone.keys.sx
					bone.keys.sy=bone.keys.sy+mesh_bone.keys.sy
					bone.keys.sz=bone.keys.sz+mesh_bone.keys.sz
					bone.keys.qw=bone.keys.qw+mesh_bone.keys.qw
					bone.keys.qx=bone.keys.qx+mesh_bone.keys.qx
					bone.keys.qy=bone.keys.qy+mesh_bone.keys.qy
					bone.keys.qz=bone.keys.qz+mesh_bone.keys.qz
				
				EndIf
				
			Next
				
		EndIf
		
		mesh.FreeEntity()
		
		Return no_seqs
	
	End Method
	
	Method ExtractAnimSeq(first_frame,last_frame,seq=0)
	
		no_seqs=no_seqs+1
	
		' expand anim_seqs array
		anim_seqs_first=anim_seqs_first[..no_seqs+1]
		anim_seqs_last=anim_seqs_last[..no_seqs+1]
	
		' if seq specifed then extract anim sequence from within existing sequnce
		Local offset=0
		If seq&lt;&gt;0
			offset=anim_seqs_first[seq]
		EndIf
	
		anim_seqs_first[no_seqs]=first_frame+offset
		anim_seqs_last[no_seqs]=last_frame+offset
		
		Return no_seqs
	
	End Method

	Method Animate(mode=1,speed#=1.0,seq=0,trans=0)
	
		anim_mode=mode
		anim_speed#=speed#
		anim_seq=seq
		anim_trans=trans
		anim_time#=anim_seqs_first[seq]
		anim_update=True ' update anim for all modes (including 0)
		
		If trans&gt;0
			anim_time#=0
		EndIf
		
	End Method
	
	' Updates:
	' 30/01/06 - updated to make anim_time return wrapped value
	Method SetAnimTime(time#,seq=0)
	
		anim_mode=-1 ' use a mode of -1 for setanimtime
		anim_speed#=0
		anim_seq=seq
		anim_trans=0
		anim_time#=time#
		anim_update=False ' set anim_update to false so UpdateWorld won't animate entity

		Local first=anim_seqs_first[anim_seq]
		Local last=anim_seqs_last[anim_seq]
		Local first2last=anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq]
		
		time#=time#+first ' offset time so that anim time of 0 will equal first frame of sequence
		
		If time#&gt;last And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#-first2last
			Until time#&lt;=last
		EndIf
		If time#&lt;first And first2last&gt;0 ' check that first2last&gt;0 to prevent infinite loop
			Repeat
				time#=time#+first2last
			Until time#&gt;=first
		EndIf
		
		TAnimation.AnimateMesh(Self,time#,first,last)

		anim_time#=time# ' update anim_time# to equal time#

	End Method
	
	Method AnimSeq()
	
		Return anim_seq ' current anim sequence
	
	End Method
	
	Method AnimLength()
	
		Return anim_seqs_last[anim_seq]-anim_seqs_first[anim_seq] ' no of frames in anim sequence
	
	End Method

	Method AnimTime#()
	
		' if animation in transition, return 0 (anim_time actually will be somewhere between 0 and 1)
		If anim_trans&gt;0 Then Return 0
		
		' for animate and setanimtime we want to return anim_time starting from 0 and ending at no. of frames in sequence
		If anim_mode&gt;0 Or anim_mode=-1
			Return anim_time#-anim_seqs_first[anim_seq]
		EndIf

		Return 0

	End Method
	
	Method Animating()
	
		If anim_trans&gt;0 Then Return True
		If anim_mode&gt;0 Then Return True
		
		Return False
	
	End Method
		
	' Entity control

	Method EntityColor(r#,g#,b#)
	
		brush.red  =r#/255.0
		brush.green=g#/255.0
		brush.blue =b#/255.0
	
	End Method

	Method EntityAlpha(a#)
	
		brush.alpha=a#
			
	End Method
	
	Method EntityShininess(s#)
	
		brush.shine=s#
	
	End Method

	Method EntityTexture(texture:TTexture,frame=0,index=0)

		brush.tex[index]=texture
		If index+1&gt;brush.no_texs Then brush.no_texs=index+1
		
		If frame&lt;0 Then frame=0
		If frame&gt;texture.no_frames-1 Then frame=texture.no_frames-1 
		brush.tex_frame=frame
	
	End Method
	
	Method EntityBlend(blend_no)
	
		brush.blend=blend_no
		
		If TMesh(Self)&lt;&gt;Null
		
			' overwrite surface blend modes with master blend mode
			For Local surf:TSurface=EachIn TMesh(Self).surf_list
				If surf.brush&lt;&gt;Null
					surf.brush.blend=brush.blend
				EndIf
			Next
			
		EndIf
		
	End Method
	
	Method EntityFX(fx_no)
	
		brush.fx=fx_no
		
	End Method
	
	Method EntityAutoFade(near#,far#)
	
		auto_fade=True
		fade_near=near#
		fade_far=far#
	
	End Method
	
	Method PaintEntity(bru:TBrush)
	
		brush.no_texs=bru.no_texs
		brush.name$=bru.name$
		brush.red#=bru.red#
		brush.green#=bru.green#
		brush.blue#=bru.blue#
		brush.alpha#=bru.alpha#
		brush.shine#=bru.shine#
		brush.blend=bru.blend
		brush.fx=bru.fx
		For Local i=0 To 7
			brush.tex[i]=bru.tex[i]
		Next
	
	End Method
	
	Method EntityOrder(order_no)
	
		order=order_no

		If TCamera(Self)&lt;&gt;Null
			ListRemove(TCamera.cam_list,Self)
			EntityListAdd(TCamera.cam_list)
		EndIf

	End Method
	
	Method ShowEntity()
	
		hide=False
		
	End Method

	Method HideEntity()

		hide=True

	End Method

	Method Hidden()
	
		If hide=True Return True
		
		Local ent:TEntity=parent
		While ent&lt;&gt;Null
			If ent.hide=True Return True
			ent=ent.parent
		Wend
		
		Return False
	
	End Method

	Method NameEntity(e_name$)
	
		name$=e_name$
	
	End Method
	
	Method EntityParent(parent_ent:TEntity,glob=True)

		'' remove old parent

		' get global values
		Local gpx:Float=EntityX(True)
		Local gpy:Float=EntityY(True)
		Local gpz:Float=EntityZ(True)
		
		Local grx:Float=EntityPitch(True)
		Local gry:Float=EntityYaw(True)
		Local grz:Float=EntityRoll(True)
		
		Local gsx:Float=EntityScaleX(True)
		Local gsy:Float=EntityScaleY(True)
		Local gsz:Float=EntityScaleZ(True)
	
		' remove self from parent's child list
		If parent&lt;&gt;Null
			For Local ent:TEntity=EachIn parent.child_list
				If ent=Self Then ListRemove(parent.child_list,Self)
			Next
			parent=Null
		EndIf

		' entity no longer has parent, so set local values to equal global values
		' must get global values before we reset transform matrix with UpdateMat
		px#=gpx
		py#=gpy
		pz#=-gpz
		rx#=-grx
		ry#=gry
		rz#=grz
		sx#=gsx
		sy#=gsy
		sz#=gsz
		
		''
		
		' No new parent
		If parent_ent=Null
			UpdateMat(True)
			Return
		EndIf
		
		' New parent
	
		If parent_ent&lt;&gt;Null
			
			If glob=True

				AddParent(parent_ent)
				'UpdateMat()

				PositionEntity(gpx,gpy,gpz,True)
				RotateEntity(grx,gry,grz,True)
				ScaleEntity(gsx,gsy,gsz,True)

			Else
			
				AddParent(parent_ent)
				UpdateMat()
				
			EndIf
			
		EndIf

	End Method
		
	Method GetParent:TEntity()
	
		Return parent
	
	End Method

	' Entity state

	Method EntityX#(glob=False)
	
		If glob=False
		
			Return px
		
		Else
		
			Return mat.grid[3,0]
		
		EndIf
	
	End Method
	
	Method EntityY#(glob=False)
	
		If glob=False
		
			Return py
		
		Else
		
			Return mat.grid[3,1]
		
		EndIf
	
	End Method
	
	Method EntityZ#(glob=False)
	
		If glob=False
		
			Return -pz
		
		Else
		
			Return -mat.grid[3,2]
		
		EndIf
	
	End Method

	Method EntityPitch#(glob=False)
		
		If glob=False
		
			Return -rx
			
		Else
		
			Local ang#=ATan2( mat.grid[2,1],Sqr( mat.grid[2,0]*mat.grid[2,0]+mat.grid[2,2]*mat.grid[2,2] ) )
			'Local ang#=ASin(mat.grid[2,1])
			'If ang#=nan Then ang#=0
			If ang#&lt;=0.0001 And ang#&gt;=-0.0001 Then ang#=0
		
			Return ang#
			
		EndIf
			
	End Method
	
	Method EntityYaw#(glob=False)
		
		If glob=False
		
			Return ry
			
		Else
		
			Local a#=mat.grid[2,0]
			Local b#=mat.grid[2,2]
			If a#&lt;=0.0001 And a#&gt;=-0.0001 Then a#=0
			If b#&lt;=0.0001 And b#&gt;=-0.0001 Then b#=0
			Return ATan2(a#,b#)
			
		EndIf
			
	End Method
	
	Method EntityRoll#(glob=False)
		
		If glob=False
		
			Return rz
			
		Else
		
			Local a#=mat.grid[0,1]
			Local b#=mat.grid[1,1]
			If a#&lt;=0.0001 And a#&gt;=-0.0001 Then a#=0
			If b#&lt;=0.0001 And b#&gt;=-0.0001 Then b#=0
			Return ATan2(a#,b#)
			
		EndIf
			
	End Method
	
	Method EntityClass$()
		
		Return class$
		
	End Method
	
	Method EntityName$()
		
		Return name$
		
	End Method
	
	Method CountChildren()

		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1

		Next

		Return no_children

	End Method
	
	Method GetChild:TEntity(child_no)
	
		Local no_children=0
		
		For Local ent:TEntity=EachIn child_list

			no_children=no_children+1
			If no_children=child_no Return ent

		Next

		Return Null
	
	End Method
	
	Method FindChild:TEntity(child_name$)
	
		Local cent:TEntity
	
		For Local ent:TEntity=EachIn child_list

			If ent.EntityName$()=child_name$ Return ent

			cent=ent.FindChild(child_name$)
			
			If cent&lt;&gt;Null Return cent
	
		Next

		Return Null
	
	End Method
	
	' Calls function in TPick
	Method EntityPick:TEntity(range#)
	
		Return TPick.EntityPick:TEntity(Self,range#)
	
	End Method
	
	' Calls function in TPick
	Method LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
		Return TPick.LinePick:TEntity(x#,y#,z#,dx#,dy#,dz#,radius#=0.0)
	
	End Method
	
	' Calls function in TPick
	Method EntityVisible(src_entity:TEntity,dest_entity:TEntity)
	
		Return TPick.EntityVisible(src_entity,dest_entity)
	
	End Method
	
	Method EntityDistance#(ent2:TEntity)

		Return Sqr(Self.EntityDistanceSquared#(ent2))

	End Method
	
	' Function by Vertex
	Method DeltaYaw#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		'Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
		
		Return -ATan2(x#,z#)

	End Method
	
	' Function by Vertex
	Method DeltaPitch#(ent2:TEntity)
	
		Local x#=ent2.EntityX#(True)-Self.EntityX#(True)
		Local y#=ent2.EntityY#(True)-Self.EntityY#(True)
		Local z#=ent2.EntityZ#(True)-Self.EntityZ#(True)
	
		Return -ATan2(y#,Sqr(x#*x#+z#*z#))
	
	End Method
	
	Function TFormPoint(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)
	
		Global mat:TMatrix=New TMatrix '***global***
	
		If src_ent&lt;&gt;Null

			mat.Overwrite(src_ent.mat)
			mat.Translate(x#,y#,-z#)
			
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
		
		EndIf

		If dest_ent&lt;&gt;Null

			mat.LoadIdentity()
		
			Local ent:TEntity=dest_ent
			
			Repeat
	
				mat.Scale(1.0/ent.sx,1.0/ent.sy,1.0/ent.sz)
				mat.RotateRoll(-ent.rz)
				mat.RotatePitch(-ent.rx)
				mat.RotateYaw(-ent.ry)
				mat.Translate(-ent.px,-ent.py,-ent.pz)																																																																																																																																																																																																																																																																																																																																									

				ent=ent.parent
			
			Until ent=Null
		
			mat.Translate(x#,y#,-z#)
			
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
			
		EndIf
		
		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
		
	End Function

	Function TFormVector(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)
	
		Global mat:TMatrix=New TMatrix '***global***
	
		If src_ent&lt;&gt;Null

			mat.Overwrite(src_ent.mat)
			
			mat.grid[3,0]=0
			mat.grid[3,1]=0
			mat.grid[3,2]=0
			mat.grid[3,3]=1
			mat.grid[0,3]=0
			mat.grid[1,3]=0
			mat.grid[2,3]=0
				
			mat.Translate(x#,y#,-z#)
	
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
		
		EndIf

		If dest_ent&lt;&gt;Null

			mat.LoadIdentity()
			'mat.Translate(x#,y#,z#)
		
			Local ent:TEntity=dest_ent
			
			Repeat
	
				mat.Scale(1.0/ent.sx,1.0/ent.sy,1.0/ent.sz)
				mat.RotateRoll(-ent.rz)
				mat.RotatePitch(-ent.rx)
				mat.RotateYaw(-ent.ry)
				'mat.Translate(-ent.px,-ent.py,-ent.pz)																																																																																																																																																																																																																																																																																																																																									

				ent=ent.parent
			
			Until ent=Null
		
			mat.Translate(x#,y#,-z#)
			
			x#=mat.grid[3,0]
			y#=mat.grid[3,1]
			z#=-mat.grid[3,2]
			
		EndIf
		
		tformed_x#=x#
		tformed_y#=y#
		tformed_z#=z#
	
	End Function

	Function TFormNormal(x#,y#,z#,src_ent:TEntity,dest_ent:TEntity)

		TEntity.TFormVector(x#,y#,z#,src_ent,dest_ent)
		
		Local uv#=Sqr((tformed_x#*tformed_x#)+(tformed_y#*tformed_y#)+(tformed_z#*tformed_z#))
		
		tformed_x#:/uv#
		tformed_y#:/uv#
		tformed_z#:/uv#
	
	End Function
	
	Function TFormedX#()
	
		Return tformed_x#
	
	End Function
	
	Function TFormedY#()
	
		Return tformed_y#
	
	End Function
	
	Function TFormedZ#()
	
		Return tformed_z#
	
	End Function
	
	Method GetMatElement#(row,col)
	
		Return mat.grid[row,col]
	
	End Method
	
	' Entity collision
	
	Method ResetEntity()
	
		no_collisions=0
		collision=collision[..0]
		old_x=EntityX(True)
		old_y=EntityY(True)
		old_z=EntityZ(True)
	
	End Method
	
	Method EntityRadius(rx#,ry#=0.0)
	
		radius_x#=rx#
		If ry#=0.0 Then radius_y#=rx# Else radius_y#=ry#
	
	End Method
	
	Method EntityBox(x#,y#,z#,w#,h#,d#)
	
		box_x#=x#
		box_y#=y#
		box_z#=z#
		box_w#=w#
		box_h#=h#
		box_d#=d#
	
	End Method

	Method EntityType(type_no,recursive=False)
	
		' add to collision entity list if new type no&lt;&gt;0 and not previously added
		If collision_type=0 And type_no&lt;&gt;0
		
			If TCollisionPair.ent_lists[type_no]=Null Then TCollisionPair.ent_lists[type_no]=CreateList() ' create new list is one doesn't exist
			
			ListAddLast(TCollisionPair.ent_lists[type_no],Self)
			
		EndIf
		
		' remove from collision entity list if new type no=0 and previously added
		If collision_type&lt;&gt;0 And type_no=0
			ListRemove(TCollisionPair.ent_lists[type_no],Self)
		EndIf
		
		collision_type=type_no
		
		old_x#=EntityX(True)
		old_y#=EntityY(True)
		old_z#=EntityZ(True)
	
		If recursive=True
		
			For Local ent:TEntity=EachIn child_list
			
				ent.EntityType(type_no,True)
			
			Next
		
		EndIf
		
	End Method
	
	Method EntityPickMode(no,obscure=True)
	
		' add to pick entity list if new mode no&lt;&gt;0 and not previously added
		If pick_mode=0 And no&lt;&gt;0
			ListAddLast(TPick.ent_list,Self)
		EndIf
		
		' remove from pick entity list if new mode no=0 and previously added
		If pick_mode&lt;&gt;0 And no=0
			ListRemove(TPick.ent_list,Self)
		EndIf
	
		pick_mode=no
		obscurer=obscure
			
	End Method
	
	Method EntityCollided:TEntity(type_no)

		' if self is source entity and type_no is dest entity
		For Local i=1 To CountCollisions()
			If CollisionEntity(i).collision_type=type_no Then Return CollisionEntity(i)
		Next

		' if self is dest entity and type_no is src entity
		For Local ent:TEntity=EachIn TCollisionPair.ent_lists[type_no]
			For Local i=1 To ent.CountCollisions()
				If CollisionEntity(i)=Self Then Return ent		
			Next
		Next

		Return Null

	End Method
	
	Method CountCollisions()
	
		Return no_collisions
	
	End Method
	
	Method CollisionX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].x#
		
		EndIf
	
	End Method
	
	Method CollisionY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].y#
		
		EndIf
	
	End Method
	
	Method CollisionZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].z#
		
		EndIf
	
	End Method

	Method CollisionNX#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nx#
		
		EndIf
	
	End Method
	
	Method CollisionNY#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ny#
		
		EndIf
	
	End Method
	
	Method CollisionNZ#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].nz#
		
		EndIf
	
	End Method
	
	Method CollisionTime#(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].time#
		
		EndIf
	
	End Method
	
	Method CollisionEntity:TEntity(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].ent
		
		EndIf
	
	End Method
	
	Method CollisionSurface:TSurface(index)
	
		If index&gt;0 And index&lt;=no_collisions

			Return collision[index-1].surf
		
		EndIf
	
	End Method
	
	Method CollisionTriangle(index)
	
		If index&gt;0 And index&lt;=no_collisions
		
			Return collision[index-1].tri
		
		EndIf
	
	End Method
	
	Method GetEntityType()

		Return collision_type

	End Method
	
	' Sets an entity's mesh cull radius
	Method MeshCullRadius(radius#)
	
		' set to negative no. so we know when user has set cull radius (manual cull)
		' a check in TMesh.GetBounds then prevents negative no. being overwritten by a positive cull radius (auto cull)
		cull_radius#=-radius#
	
	End Method
	
	Method EntityScaleX#(glob=False)
	
		If glob=True

			If parent&lt;&gt;Null
				
				Local ent:TEntity=Self
					
				Local x#=sx#
							
				Repeat
	
					x#=x#*ent.parent.sx#

					ent=ent.parent
										
				Until ent.parent=Null
				
				Return x#
		
			EndIf

		EndIf
		
		Return sx#
		
	End Method
	
	Method EntityScaleY#(glob=False)
	
		If glob=True

			If parent&lt;&gt;Null
				
				Local ent:TEntity=Self
					
				Local y#=sy#
							
				Repeat
	
					y#=y#*ent.parent.sy#

					ent=ent.parent
										
				Until ent.parent=Null
				
				Return y#
		
			EndIf

		EndIf
		
		Return sy#
		
	End Method
	
	Method EntityScaleZ#(glob=False)
	
		If glob=True

			If parent&lt;&gt;Null
				
				Local ent:TEntity=Self
					
				Local z#=sz#
							
				Repeat
	
					z#=z#*ent.parent.sz#

					ent=ent.parent
										
				Until ent.parent=Null
				
				Return z#
		
			EndIf

		EndIf
		
		Return sz#
		
	End Method

	' Returns an entity's bounding sphere
	Rem
	Method BoundingSphere:TSphere()
	
		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=TFormedX()
			y=TFormedY()
			z=TFormedZ()
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		Local s:TSphere=New TSphere
		s.c.x=x
		s.c.y=y
		s.c.z=z
		s.r=radius
		
		Return s

	End Method
	End Rem

	' Returns an entity's bounding sphere
	Method BoundingSphereNew(sx# Var,sy# Var,sz# Var,sr# Var)

		Local x#=EntityX(True)
		Local y#=EntityY(True)
		Local z#=EntityZ(True)

		Local radius#=Abs(cull_radius#) ' use absolute value as cull_radius will be negative value if set by MeshCullRadius (manual cull)

		' if entity is mesh, we need to use mesh centre for culling which may be different from entity position
		If TMesh(Self)
		
			' mesh centre
			x=TMesh(Self).min_x
			y=TMesh(Self).min_y
			z=TMesh(Self).min_z
			x=x+(TMesh(Self).max_x-TMesh(Self).min_x)/2.0
			y=y+(TMesh(Self).max_y-TMesh(Self).min_y)/2.0
			z=z+(TMesh(Self).max_z-TMesh(Self).min_z)/2.0
			
			' transform mesh centre into world space
			TFormPoint x,y,z,Self,Null
			x=tformed_x
			y=tformed_y
			z=tformed_z
			
			' radius - apply entity scale
			Local rx#=radius*EntityScaleX(True)
			Local ry#=radius*EntityScaleY(True)
			Local rz#=radius*EntityScaleZ(True)
			If rx&gt;=ry And rx&gt;=rz
				radius=Abs(rx)
			Else If ry&gt;=rx And ry&gt;=rz
				radius=Abs(ry)
			Else
				radius=Abs(rz)
			EndIf
		
		EndIf

		sx=x
		sy=y
		sz=z
		sr=radius

	End Method
	
	Function CountAllChildren(ent:TEntity,no_children=0)
		
		Local ent2:TEntity
	
		For ent2=EachIn ent.child_list

			no_children=no_children+1
			
			no_children=TEntity.CountAllChildren(ent2,no_children)

		Next

		Return no_children

	End Function
	
	Method GetChildFromAll:TEntity(child_no,no_children Var,ent:TEntity=Null)

		If ent=Null Then ent=Self
		
		Local ent3:TEntity=Null
		
		For Local ent2:TEntity=EachIn ent.child_list

			no_children=no_children+1
			
			If no_children=child_no Then Return ent2
			
			If ent3=Null
			
				ent3=GetChildFromAll(child_no,no_children,ent2)

			EndIf

		Next

		Return ent3
			
	End Method
	
	' Internal - not recommended for general use

	Method UpdateMat(load_identity=False)

		If load_identity=True
			mat.LoadIdentity()
			mat.Translate(px,py,pz)
			mat.Rotate(rx,ry,rz)
			mat.Scale(sx,sy,sz)
		Else
			mat.Translate(px,py,pz)
			mat.Rotate(rx,ry,rz)
			mat.Scale(sx,sy,sz)
		EndIf
	
	End Method
	
	Method AddParent(parent_ent:TEntity)
	
		' self.parent = parent_ent
		parent:TEntity=parent_ent
		
		' add self to parent_ent child list
		If parent&lt;&gt;Null

			mat.Overwrite(parent.mat)
		
			ListAddLast(parent.child_list,Self)
		
		EndIf
		
	End Method
	
	Function UpdateChildren(ent_p:TEntity)
	
		For Local ent_c:TEntity=EachIn ent_p.child_list

			ent_c.mat.Overwrite(ent_p.mat)
			ent_c.UpdateMat()
				
			UpdateChildren(ent_c:TEntity)
			
		Next
	
	End Function

	' unoptimised, unused
	Method EntityDistanceSquared0#(ent2:TEntity)

		Local xd# = ent2.EntityX#(True)-EntityX#(True)
		Local yd# = ent2.EntityY#(True)-EntityY#(True)
		Local zd# = ent2.EntityZ#(True)-EntityZ#(True)
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method
	
	' optimised
	Method EntityDistanceSquared#(ent2:TEntity)

		Local xd# = ent2.mat.grid[3,0]-mat.grid[3,0]
		Local yd# = ent2.mat.grid[3,1]-mat.grid[3,1]
		Local zd# = -ent2.mat.grid[3,2]+mat.grid[3,2]
				
		Return xd*xd + yd*yd + zd*zd
		
	End Method

	Method EntityListAdd(list:TList)
	
		' if order&gt;0, drawn first
		' if order&lt;0, drawn last
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=order Or TEntity(llink.Value()).order&lt;=0
	
			link=list.InsertBeforeLink(Self,llink)
			Return
	
		Else ' put entities with order=0 at back of list, so cameras with order=0 are sorted the same as in B3D

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=order Or TEntity(llink.Value()).order&gt;=0
	
			link=list.InsertAfterLink(Self,llink)
			Return

		EndIf

	End Method
	
	
'-----------------------------------------------------------------------------------------------------------------------------------
'											BEGIN MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------

	'returns copy of rotation matrix	
	Method MQ_CopyMat:TMatrix()
		
		Local m:TMatrix = TMatrix.Create()
		Local i:Int, j:Int
		
		For i = 0 To 3
		For j = 0 To 3
			m.grid[i,j] = rotmat.grid[i,j]
		Next
		Next
		Return m		
	
	End Method
	
	'set scaling for an entity
	Method MQ_Scale( w#, h#, d# )
		sx = w
		sy = h
		sz = d
	End Method

	'set rotation for an entity
	Method MQ_Rotate( pitch#, yaw#, roll#, glob=False )

		Local q1_x#, q1_y#, q1_z#, q1_w#
		Local q2_x#, q2_y#, q2_z#, q2_w#
		Local q3_x#, q3_y#, q3_z#, q3_w#
		Local m2:TMatrix
				
		Quaternion_FromAngleAxis( pitch, 1, 0, 0, q1_x#, q1_y#, q1_z#, q1_w#)
		Quaternion_FromAngleAxis( yaw,   0, 1, 0, q2_x#, q2_y#, q2_z#, q2_w#)
		Quaternion_FromAngleAxis( roll,  0, 0, 1, q3_x#, q3_y#, q3_z#, q3_w#)
		
		Quaternion_MultiplyQuat( q1_x, q1_y, q1_z, q1_w, q2_x, q2_y, q2_z, q2_w, q1_x, q1_y, q1_z, q1_w)
		Quaternion_MultiplyQuat( q1_x, q1_y, q1_z, q1_w, q3_x, q3_y, q3_z, q3_w, q1_x, q1_y, q1_z, q1_w)
		
		rotmat.FromQuaternion(q1_x, q1_y, q1_z, q1_w)
		
		If glob Then
			'get parent inverted rotation matrix
			If parent = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = parent.MQ_GetInvMatrix()
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			rotmat.Multiply2(m2)
		End If
		
	End Method

	'turn entity
	Method MQ_Turn( ang#, vx#,vy#,vz#, glob=False )
			
		Local q1_x#, q1_y#, q1_z#, q1_w#
		
		Quaternion_FromAngleAxis( ang, vx,vy,vz, q1_x#, q1_y#, q1_z#, q1_w# ) 'create quaternion
		Local m:TMatrix = TMatrix.Create()
		m.FromQuaternion(q1_x, q1_y, q1_z, q1_w) 'convert to matrix

		If glob Then		
			rotmat.Multiply2(m)'apply internal matrix to new matrix
		Else
			m.Multiply2(rotmat)'apply new matrix to internal matrix
			rotmat.Overwrite(m)'MatOverwrite(mat, m)
		End If
		
	End Method

	'transform a point by entity's rotation matrix
	Method MQ_TransformPoint( ix# Var,iy# Var,iz# Var)
		
		rotmat.TransformVec( ix#,iy#,iz# )
		
	End Method

	'position an entity	
	Method MQ_Position( qx#,qy#,qz#, glob=False )
				
		If glob Then
			'transform global position into parent
			If parent &lt;&gt; Null Then TFormPoint2(qx, qy, qz, Null, parent)
		End If
		
		px = qx
		py = qy
		pz = qz

	End Method

	'move an entity
	Method MQ_Move( qx#,qy#,qz# )
	
		MQ_TransformPoint(qx,qy,qz) 'transform point by internal matrix
		px = px + qx 'add to position
		py = py + qy
		pz = pz + qz
	
	End Method

	'get inverted matrix, if needed transformed by parent matrices
	Method MQ_GetInvMatrix:TMatrix()
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		Local mat1:TMatrix
		Local mat0:TMatrix

		If (parent &lt;&gt; Null) Then
			'transform by parent matrix
			mat0 = parent.MQ_GetInvMatrix()
		Else
			mat0 = TMatrix.Create()
		End If
		
		'get inverted rotation matrix
		mat1 = MQ_CopyMat()
		mat1.Transpose()
				
		'scale
		mat3:TMatrix = TMatrix.Create()
		If (sx &lt;&gt; 0) And (sy &lt;&gt; 0) And (sz &lt;&gt; 0) Then mat3.Scale(1 / sx, 1 / sy, 1 / sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(-px,-py,-pz)
		
		'combine
		mat3.Multiply2(mat1)
		mat2.Multiply2(mat3)
		mat0.Multiply2(mat2)
		
		Return mat0
		
	End Method
	
	'get matrix, if needed transformed by parent matrices
	Method MQ_GetMatrix:TMatrix()
	
		Local mat3:TMatrix
		Local mat2:TMatrix
		
		'scale
		mat3:TMatrix = TMatrix.Create()
		mat3.Scale(sx, sy, sz)
		'position
		mat2:TMatrix = TMatrix.Create()
		mat2.SetTranslate(px, py, pz)
		'rotation
		mat3.Multiply2(rotmat)
		mat3.Multiply2(mat2)

		If parent &lt;&gt; Null Then
			'transform by parent matrix
			mat3.Multiply2(parent.MQ_GetMatrix())
		End If
		
		Return mat3
		
	End Method

	'update attached entity
	Method MQ_Update()
	
		Local e:TEntity

		'get matrix transformed by parents
		mat.Overwrite(MQ_GetMatrix())
						
		'update child_list		
		For e:TEntity = EachIn child_list
			e.MQ_Update
		Next

	End Method

	'set an entity's parent	
	Method MQ_SetParent(e:TEntity, glob)
	
		Local orgx#,orgy#,orgz#
		Local m1:TMatrix
		Local m2:TMatrix

		'get global position/rotation
		If glob Then
			orgx# = 0
			orgy# = 0
			orgz# = 0
			TFormPoint2(orgx, orgy, orgz, Self, Null)
			m1:TMatrix = MQ_GetMatrix()
			m1.grid[3,0] = 0 'remove translation
			m1.grid[3,1] = 0
			m1.grid[3,2] = 0
		End If

		'remove parent	
		If parent &lt;&gt; Null Then
			ListRemove parent.child_list, Self
			parent = Null
		End If

		'retain global position/rotation					
		If glob Then
			'transform global position into parent
			If e &lt;&gt; Null Then TFormPoint2(orgx, orgy, orgz, Null, e)
			'set position
			px = orgx
			py = orgy
			pz = orgz
			'get parent inverted rotation matrix
			If e = Null Then
				m2:TMatrix = TMatrix.Create() 'no parent
			Else
				m2:TMatrix = e.MQ_GetInvMatrix()
				m2.grid[3,0] = 0 'remove translation
				m2.grid[3,1] = 0
				m2.grid[3,2] = 0
			End If
			'apply rotation matrix
			m1.Multiply2(m2)
			rotmat.Overwrite(m1)
		End If

		If e = Null Then Return
		
		'set parent
		parent = e
		ListAddLast parent.child_list, Self
	
	End Method

	'get entity scale	
	Method MQ_GetScaleXYZ(width# Var, height# Var, depth# Var)
	
		Local m:TMatrix
		Local xx#,xy#,xz#
		Local yx#,yy#,yz#
		Local zx#,zy#,zz#
		
		m:TMatrix = MQ_GetMatrix()
		
		xx#=1 xy#=0 xz#=0
		yx#=0 yy#=1 yz#=0
		zx#=0 zy#=0 zz#=1

		m.TransformVec(xx,xy,xz)
		m.TransformVec(yx,yy,yz)
		m.TransformVec(zx,zy,zz)

		width  = Magnitude(xx,xy,xz)
		height = Magnitude(yx,yy,yz)
		depth  = Magnitude(zx,zy,zz)
		
	End Method

'-----------------------------------------------------------------------------------------------------------------------------------
'											END MATRIX COMMANDS
'-----------------------------------------------------------------------------------------------------------------------------------
End Type


'-----------------------------------------------------------------------------------------------------------------------------------
'											PositionEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function PositionEntity2(e:TEntity, x#, y#, z#, glob=False )

	If e = Null Then Return
	
	e.MQ_Position( x, y, z, glob )
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TurnEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TurnEntity2(e:TEntity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	pitch = -pitch
	
	If pitch# &lt;&gt; 0 Then e.MQ_Turn(pitch, 1, 0, 0, glob)
	If yaw#   &lt;&gt; 0 Then e.MQ_Turn(yaw,   0, 1, 0, glob)
	If roll#  &lt;&gt; 0 Then e.MQ_Turn(roll,  0, 0, 1, glob)
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											MoveEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function MoveEntity2(e:TEntity, x#, y#, z#, glob=False)

	If e = Null Then Return	

	If glob Then
		TFormVector2(x, y, z, Null, e)
		z = -z
	End If
	
	e.MQ_Move( x, y, z )
	e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											RotateEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function RotateEntity2(e:TEntity, pitch#, yaw#, roll#, glob=False )

	If e = Null Then Return
	e.MQ_Rotate(-pitch, -yaw, roll, glob)
	e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityParent2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityParent2(e:TEntity, e2:TEntity, glob=True)

	If e = Null Then Return

	e.MQ_SetParent(e2, glob)	
	If e2 &lt;&gt; Null Then e2.MQ_Update() Else e.MQ_Update()

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											ScaleEntity2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function ScaleEntity2(e:TEntity, sx#, sy#, sz#)

	If e = Null Then Return
	e.MQ_Scale(sx, sy, sz)
	e.MQ_Update()
	
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormPoint2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormPoint2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	Local mat1:TMatrix
	Local mat2:TMatrix
	
	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.MQ_GetMatrix()
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.MQ_GetInvMatrix()
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											TFormVector2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function TFormVector2(x# Var, y# Var, z# Var, src:TEntity, dst:TEntity)

	Local mat1:TMatrix
	Local mat2:TMatrix 

	'get src matrix	
	If src &lt;&gt; Null Then
		mat1:TMatrix = src.MQ_GetMatrix()
		mat1.grid[3,0] = 0 'remove translation
		mat1.grid[3,1] = 0
		mat1.grid[3,2] = 0
	End If

	'get dest matrix
	If dst &lt;&gt; Null Then
		mat2:TMatrix = dst.MQ_GetInvMatrix()		
		mat2.grid[3,0] = 0 'remove translation
		mat2.grid[3,1] = 0
		mat2.grid[3,2] = 0
	End If 	

	'transform point by matrix
	If src &lt;&gt; Null Then mat1.TransformVec(x, y, z, 1)'mesh to global
	If dst &lt;&gt; Null Then mat2.TransformVec(x, y, z, 1)'global to mesh

End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityPitch2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityPitch2#(e:TEntity, glob=False)
	If glob Then
		'use global matrix
		Return e.MQ_GetMatrix().GetPitch()
	Else
		'use local matrix
		Return e.rotmat.GetPitch()
	End If
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityYaw2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityYaw2#(e:TEntity, glob=False)
	If glob Then
		'use global matrix
		Return e.MQ_GetMatrix().GetYaw()
	Else
		'use local matrix
		Return e.rotmat.GetYaw()
	End If
End Function

'-----------------------------------------------------------------------------------------------------------------------------------
'											EntityRoll2()
'-----------------------------------------------------------------------------------------------------------------------------------
Function EntityRoll2#(e:TEntity, glob=False)
	If glob Then
		'use global matrix
		Return e.MQ_GetMatrix().GetRoll()
	Else
		'use local matrix
		Return e.rotmat.GetRoll()
	End If
End Function
</textarea><br><br>TMatrix.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TMatrix

	Field grid#[4,4]
	
	Function Create:TMatrix()
	
		Local m:TMatrix = New TMatrix
		m.LoadIdentity()
		Return m
		
	End Function
	
	Method New()
		
		If LOG_NEW
			DebugLog "New TMatrix"
		EndIf

	End Method
	
	Method Delete()
	
		If LOG_DEL
			DebugLog "Del TMatrix"
		EndIf

	End Method
	
	Method LoadIdentity()
	
		grid[0,0]=1.0 grid[1,0]=0.0 grid[2,0]=0.0 grid[3,0]=0.0
		grid[0,1]=0.0 grid[1,1]=1.0 grid[2,1]=0.0 grid[3,1]=0.0
		grid[0,2]=0.0 grid[1,2]=0.0 grid[2,2]=1.0 grid[3,2]=0.0		
		grid[0,3]=0.0 grid[1,3]=0.0 grid[2,3]=0.0 grid[3,3]=1.0
	
	End Method
	
	' copy - create new copy and returns it
	
	Method Copy:TMatrix()
	
		Local mat:TMatrix=New TMatrix
	
		mat.grid[0,0]=grid[0,0]
		mat.grid[1,0]=grid[1,0]
		mat.grid[2,0]=grid[2,0]
		mat.grid[3,0]=grid[3,0]
		mat.grid[0,1]=grid[0,1]
		mat.grid[1,1]=grid[1,1]
		mat.grid[2,1]=grid[2,1]
		mat.grid[3,1]=grid[3,1]
		mat.grid[0,2]=grid[0,2]
		mat.grid[1,2]=grid[1,2]
		mat.grid[2,2]=grid[2,2]
		mat.grid[3,2]=grid[3,2]
		
		' do not remove
		mat.grid[0,3]=grid[0,3]
		mat.grid[1,3]=grid[1,3]
		mat.grid[2,3]=grid[2,3]
		mat.grid[3,3]=grid[3,3]
		
		Return mat
	
	End Method
	
	' overwrite - overwrites self with matrix passed as parameter
	
	Method Overwrite(mat:TMatrix)
	
		grid[0,0]=mat.grid[0,0]
		grid[1,0]=mat.grid[1,0]
		grid[2,0]=mat.grid[2,0]
		grid[3,0]=mat.grid[3,0]
		grid[0,1]=mat.grid[0,1]
		grid[1,1]=mat.grid[1,1]
		grid[2,1]=mat.grid[2,1]
		grid[3,1]=mat.grid[3,1]
		grid[0,2]=mat.grid[0,2]
		grid[1,2]=mat.grid[1,2]
		grid[2,2]=mat.grid[2,2]
		grid[3,2]=mat.grid[3,2]		
		grid[0,3]=mat.grid[0,3]
		grid[1,3]=mat.grid[1,3]
		grid[2,3]=mat.grid[2,3]
		grid[3,3]=mat.grid[3,3]
		
	End Method
	
	Method Inverse:TMatrix()

		Local mat:TMatrix=New TMatrix
	
		Local tx#=0
		Local ty#=0
		Local tz#=0
	
	  	' The rotational part of the matrix is simply the transpose of the
	  	' original matrix.
	  	mat.grid[0,0] = grid[0,0]
	  	mat.grid[1,0] = grid[0,1]
	  	mat.grid[2,0] = grid[0,2]
	
		mat.grid[0,1] = grid[1,0]
		mat.grid[1,1] = grid[1,1]
		mat.grid[2,1] = grid[1,2]
	
		mat.grid[0,2] = grid[2,0]
		mat.grid[1,2] = grid[2,1]
		mat.grid[2,2] = grid[2,2]
	
		' The right column vector of the matrix should always be [ 0 0 0 1 ]
		' in most cases. . . you don't need this column at all because it'll 
		' never be used in the program, but since this code is used with GL
		' and it does consider this column, it is here.
		mat.grid[0,3] = 0 
		mat.grid[1,3] = 0
		mat.grid[2,3] = 0
		mat.grid[3,3] = 1
	
		' The translation components of the original matrix.
		tx = grid[3,0]
		ty = grid[3,1]
		tz = grid[3,2]
	
		' Result = -(Tm * Rm) To get the translation part of the inverse
		mat.grid[3,0] = -( (grid[0,0] * tx) + (grid[0,1] * ty) + (grid[0,2] * tz) )
		mat.grid[3,1] = -( (grid[1,0] * tx) + (grid[1,1] * ty) + (grid[1,2] * tz) )
		mat.grid[3,2] = -( (grid[2,0] * tx) + (grid[2,1] * ty) + (grid[2,2] * tz) )
	
		Return mat

	End Method

	Method Translate(x#,y#,z#)
	
		grid[3,0] = grid#[0,0]*x# + grid#[1,0]*y# + grid#[2,0]*z# + grid#[3,0]
		grid[3,1] = grid#[0,1]*x# + grid#[1,1]*y# + grid#[2,1]*z# + grid#[3,1]
		grid[3,2] = grid#[0,2]*x# + grid#[1,2]*y# + grid#[2,2]*z# + grid#[3,2]

	End Method
	
	Method Rotate(rx#,ry#,rz#)
	
		Local cos_ang#,sin_ang#
	
		' yaw
	
		cos_ang#=Cos(ry#)
		sin_ang#=Sin(ry#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
		
		' pitch
		
		cos_ang#=Cos(rx#)
		sin_ang#=Sin(rx#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		
		' roll
		
		cos_ang#=Cos(rz#)
		sin_ang#=Sin(rz#)

		m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#
	
	End Method
	
	Method RotatePitch(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m10# = grid#[1,0]*cos_ang + grid#[2,0]*sin_ang
		Local m11# = grid#[1,1]*cos_ang + grid#[2,1]*sin_ang
		Local m12# = grid#[1,2]*cos_ang + grid#[2,2]*sin_ang

		grid[2,0] = grid#[1,0]*-sin_ang + grid#[2,0]*cos_ang
		grid[2,1] = grid#[1,1]*-sin_ang + grid#[2,1]*cos_ang
		grid[2,2] = grid#[1,2]*-sin_ang + grid#[2,2]*cos_ang

		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12

	End Method
	
	Method RotateYaw(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)
	
		Local m00# = grid#[0,0]*cos_ang + grid#[2,0]*-sin_ang#
		Local m01# = grid#[0,1]*cos_ang + grid#[2,1]*-sin_ang#
		Local m02# = grid#[0,2]*cos_ang + grid#[2,2]*-sin_ang#

		grid[2,0] = grid#[0,0]*sin_ang# + grid#[2,0]*cos_ang
		grid[2,1] = grid#[0,1]*sin_ang# + grid#[2,1]*cos_ang
		grid[2,2] = grid#[0,2]*sin_ang# + grid#[2,2]*cos_ang

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Method RotateRoll(ang#)
	
		Local cos_ang#=Cos(ang#)
		Local sin_ang#=Sin(ang#)

		Local m00# = grid#[0,0]*cos_ang# + grid#[1,0]*sin_ang#
		Local m01# = grid#[0,1]*cos_ang# + grid#[1,1]*sin_ang#
		Local m02# = grid#[0,2]*cos_ang# + grid#[1,2]*sin_ang#

		grid[1,0] = grid#[0,0]*-sin_ang# + grid#[1,0]*cos_ang#
		grid[1,1] = grid#[0,1]*-sin_ang# + grid#[1,1]*cos_ang#
		grid[1,2] = grid#[0,2]*-sin_ang# + grid#[1,2]*cos_ang#

		grid[0,0]=m00#
		grid[0,1]=m01#
		grid[0,2]=m02#

	End Method
	
	Rem bbdoc: Returns a matrix made from the quaternion
	End Rem
	Method FromQuaternion(x#,y#,z#,w#)
		' Based off of code in Axiom
		
		Local tx# = 2*x
		Local ty# = 2*y
		Local tz# = 2*z
		Local twx# = tx*w
		Local twy# = ty*w
		Local twz# = tz*w
		Local txx# = tx*x
		Local txy# = ty*x
		Local txz# = tz*x
		Local tyy# = ty*y
		Local tyz# = tz*y
		Local tzz# = tz*z
		
		grid[0,0] = 1.0-(tyy+tzz)
		grid[1,0] = txy-twz
		grid[2,0] = txz+twy
		grid[3,0] = 0
		grid[0,1] = txy+twz
		grid[1,1] = 1.0-(txx+tzz)
		grid[2,1] = tyz-twx
		grid[3,1] = 0
		grid[0,2] = txz-twy
		grid[1,2] = tyz+twx
		grid[2,2] = 1.0-(txx+tyy)
		grid[3,2] = 0
		grid[0,3] = 0
		grid[1,3] = 0
		grid[2,3] = 0
		grid[3,3] = 1
		
	End Method
	
	Rem bbdoc: Transforms the matrix by another matrix
	End Rem
	Method Multiply(mat:TMatrix)
	
		Local m00# = grid#[0,0]*mat.grid#[0,0] + grid#[1,0]*mat.grid#[0,1] + grid#[2,0]*mat.grid#[0,2] + grid#[3,0]*mat.grid#[0,3]
		Local m01# = grid#[0,1]*mat.grid#[0,0] + grid#[1,1]*mat.grid#[0,1] + grid#[2,1]*mat.grid#[0,2] + grid#[3,1]*mat.grid#[0,3]
		Local m02# = grid#[0,2]*mat.grid#[0,0] + grid#[1,2]*mat.grid#[0,1] + grid#[2,2]*mat.grid#[0,2] + grid#[3,2]*mat.grid#[0,3]
		Local m03# = grid#[0,3]*mat.grid#[0,0] + grid#[1,3]*mat.grid#[0,1] + grid#[2,3]*mat.grid#[0,2] + grid#[3,3]*mat.grid#[0,3]
		Local m10# = grid#[0,0]*mat.grid#[1,0] + grid#[1,0]*mat.grid#[1,1] + grid#[2,0]*mat.grid#[1,2] + grid#[3,0]*mat.grid#[1,3]
		Local m11# = grid#[0,1]*mat.grid#[1,0] + grid#[1,1]*mat.grid#[1,1] + grid#[2,1]*mat.grid#[1,2] + grid#[3,1]*mat.grid#[1,3]
		Local m12# = grid#[0,2]*mat.grid#[1,0] + grid#[1,2]*mat.grid#[1,1] + grid#[2,2]*mat.grid#[1,2] + grid#[3,2]*mat.grid#[1,3]
		Local m13# = grid#[0,3]*mat.grid#[1,0] + grid#[1,3]*mat.grid#[1,1] + grid#[2,3]*mat.grid#[1,2] + grid#[3,3]*mat.grid#[1,3]
		Local m20# = grid#[0,0]*mat.grid#[2,0] + grid#[1,0]*mat.grid#[2,1] + grid#[2,0]*mat.grid#[2,2] + grid#[3,0]*mat.grid#[2,3]
		Local m21# = grid#[0,1]*mat.grid#[2,0] + grid#[1,1]*mat.grid#[2,1] + grid#[2,1]*mat.grid#[2,2] + grid#[3,1]*mat.grid#[2,3]
		Local m22# = grid#[0,2]*mat.grid#[2,0] + grid#[1,2]*mat.grid#[2,1] + grid#[2,2]*mat.grid#[2,2] + grid#[3,2]*mat.grid#[2,3]
		Local m23# = grid#[0,3]*mat.grid#[2,0] + grid#[1,3]*mat.grid#[2,1] + grid#[2,3]*mat.grid#[2,2] + grid#[3,3]*mat.grid#[2,3]
		Local m30# = grid#[0,0]*mat.grid#[3,0] + grid#[1,0]*mat.grid#[3,1] + grid#[2,0]*mat.grid#[3,2] + grid#[3,0]*mat.grid#[3,3]
		Local m31# = grid#[0,1]*mat.grid#[3,0] + grid#[1,1]*mat.grid#[3,1] + grid#[2,1]*mat.grid#[3,2] + grid#[3,1]*mat.grid#[3,3]
		Local m32# = grid#[0,2]*mat.grid#[3,0] + grid#[1,2]*mat.grid#[3,1] + grid#[2,2]*mat.grid#[3,2] + grid#[3,2]*mat.grid#[3,3]
		Local m33# = grid#[0,3]*mat.grid#[3,0] + grid#[1,3]*mat.grid#[3,1] + grid#[2,3]*mat.grid#[3,2] + grid#[3,3]*mat.grid#[3,3]
	
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method
	
	Rem bbdoc: Transforms a vector by the matrix
	End Rem
	Method TransformVec( rx# Var,ry# Var,rz# Var, addTranslation% = 0 )
	
		Local w# = 1.0/ ( grid[0,3] + grid[1,3] + grid[2,3] + grid[3,3] )
		Local ix# = rx#
		Local iy# = ry#
		Local iz# = rz#
		
		addTranslation = Min( Max( addTranslation, 0 ), 1 )
		
		rx = ( ( grid[0,0]*ix ) + ( grid[1,0]*iy ) + ( grid[2,0]*iz ) + grid[3,0] * addTranslation ) * w
		ry = ( ( grid[0,1]*ix ) + ( grid[1,1]*iy ) + ( grid[2,1]*iz ) + grid[3,1] * addTranslation ) * w
		rz = ( ( grid[0,2]*ix ) + ( grid[1,2]*iy ) + ( grid[2,2]*iz ) + grid[3,2] * addTranslation ) * w
		
	End Method
	
	Rem bbdoc: Transposes the matrix
	End Rem
	Method Transpose()
	
	 Local x:Int,y:Int
	
	 Local a:Double[,] = New Double[4,4]
	
	 For x = 0 To 3
	 For y = 0 To 3
		 a[y,x] = grid[x,y]
	 Next
	 Next
	
	 For x = 0 To 3
	 For y = 0 To 3
		grid[x,y]=a[x,y]
	 Next
	 Next
	
	End Method
	
	
	Rem bbdoc: Sets the translation elements of the matrix
	End Rem
	Method SetTranslate( x#, y#, z# )
		grid[3,0] = x
		grid[3,1] = y
		grid[3,2] = z
	End Method
	
	Rem bbdoc: Scales the rotation elements of the matrix
	End Rem
	Method Scale(x#,y#,z#)
	
		grid[0,0] = grid#[0,0]*x#
		grid[0,1] = grid#[0,1]*x#
		grid[0,2] = grid#[0,2]*x#
	
		grid[1,0] = grid#[1,0]*y#
		grid[1,1] = grid#[1,1]*y#
		grid[1,2] = grid#[1,2]*y#
	
		grid[2,0] = grid#[2,0]*z#
		grid[2,1] = grid#[2,1]*z#
		grid[2,2] = grid#[2,2]*z# 
	
	End Method

	Method Multiply2(i:TMatrix)
				
		Local m00# = grid[0,0] * i.grid[0,0] + grid[0,1] * i.grid[1,0] + grid[0,2] * i.grid[2,0] + grid[0,3] * i.grid[3,0]
		Local m01# = grid[0,0] * i.grid[0,1] + grid[0,1] * i.grid[1,1] + grid[0,2] * i.grid[2,1] + grid[0,3] * i.grid[3,1]
		Local m02# = grid[0,0] * i.grid[0,2] + grid[0,1] * i.grid[1,2] + grid[0,2] * i.grid[2,2] + grid[0,3] * i.grid[3,2]
		Local m03# = grid[0,0] * i.grid[0,3] + grid[0,1] * i.grid[1,3] + grid[0,2] * i.grid[2,3] + grid[0,3] * i.grid[3,3]
		
		Local m10# = grid[1,0] * i.grid[0,0] + grid[1,1] * i.grid[1,0] + grid[1,2] * i.grid[2,0] + grid[1,3] * i.grid[3,0]
		Local m11# = grid[1,0] * i.grid[0,1] + grid[1,1] * i.grid[1,1] + grid[1,2] * i.grid[2,1] + grid[1,3] * i.grid[3,1]
		Local m12# = grid[1,0] * i.grid[0,2] + grid[1,1] * i.grid[1,2] + grid[1,2] * i.grid[2,2] + grid[1,3] * i.grid[3,2]
		Local m13# = grid[1,0] * i.grid[0,3] + grid[1,1] * i.grid[1,3] + grid[1,2] * i.grid[2,3] + grid[1,3] * i.grid[3,3]
		
		Local m20# = grid[2,0] * i.grid[0,0] + grid[2,1] * i.grid[1,0] + grid[2,2] * i.grid[2,0] + grid[2,3] * i.grid[3,0]
		Local m21# = grid[2,0] * i.grid[0,1] + grid[2,1] * i.grid[1,1] + grid[2,2] * i.grid[2,1] + grid[2,3] * i.grid[3,1]
		Local m22# = grid[2,0] * i.grid[0,2] + grid[2,1] * i.grid[1,2] + grid[2,2] * i.grid[2,2] + grid[2,3] * i.grid[3,2]
		Local m23# = grid[2,0] * i.grid[0,3] + grid[2,1] * i.grid[1,3] + grid[2,2] * i.grid[2,3] + grid[2,3] * i.grid[3,3]
				
		Local m30# = grid[3,0] * i.grid[0,0] + grid[3,1] * i.grid[1,0] + grid[3,2] * i.grid[2,0] + grid[3,3] * i.grid[3,0]
		Local m31# = grid[3,0] * i.grid[0,1] + grid[3,1] * i.grid[1,1] + grid[3,2] * i.grid[2,1] + grid[3,3] * i.grid[3,1]
		Local m32# = grid[3,0] * i.grid[0,2] + grid[3,1] * i.grid[1,2] + grid[3,2] * i.grid[2,2] + grid[3,3] * i.grid[3,2]
		Local m33# = grid[3,0] * i.grid[0,3] + grid[3,1] * i.grid[1,3] + grid[3,2] * i.grid[2,3] + grid[3,3] * i.grid[3,3]
		
		grid[0,0]=m00
		grid[0,1]=m01
		grid[0,2]=m02
		grid[0,3]=m03
		grid[1,0]=m10
		grid[1,1]=m11
		grid[1,2]=m12
		grid[1,3]=m13
		grid[2,0]=m20
		grid[2,1]=m21
		grid[2,2]=m22
		grid[2,3]=m23
		grid[3,0]=m30
		grid[3,1]=m31
		grid[3,2]=m32
		grid[3,3]=m33
		
	End Method

	Rem bbdoc: Gets the current pitch of the matrix
	End Rem
	Method GetPitch#()

		Local x# = grid[0,2]
		Local y# = grid[1,2]
		Local z# = grid[2,2]
		Return -ATan2( y, Sqr( x*x+z*z ) )
		
	End Method

	Rem bbdoc: Gets the current yaw of the matrix
	End Rem
	Method GetYaw#()
	
		Local x# = grid[0,2]
		Local y# = grid[1,2]
		Local z# = grid[2,2]	
		Return -ATan2( x,z )
		
	End Method
	
	Rem bbdoc: Gets the current roll of the matrix
	End Rem
	Method GetRoll#()
	
		Local iy# = grid[1,0]
		Local jy# = grid[1,1]
		Return ATan2( iy, jy )
	
	End Method
		
End Type


Rem bbdoc: Gets the magnitude of the vector
End Rem
Function Magnitude#( x#, y#, z# )
	Return Sqr( x*x + y*y + z*z )
End Function

Rem bbdoc: Creates a quaternion from an angle and an axis
End Rem
Function Quaternion_FromAngleAxis( angle#, ax#,ay#,az#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	Local ha# = .5*angle
	Local sn# = Sin( ha )
	
	rw# = Cos( ha )
	rx# = sn * ax
	ry# = sn * ay
	rz# = sn * az
	
End Function

Rem bbdoc: Multiplies a quaternion
End Rem
Function Quaternion_MultiplyQuat( x1#,y1#,z1#,w1#, x2#,y2#,z2#,w2#, rx# Var,ry# Var,rz# Var,rw# Var )
	
	rw = w1*w2 - x1*x2 - y1*y2 - z1*z2
	rx = w1*x2 - x1*w2 - y1*z2 - z1*y2
	ry = w1*y2 - y1*w2 - z1*x2 - x1*z2
	rz = w1*z2 - z1*w2 - x1*y2 - y1*x2
	
End Function
</textarea><br><br>Example:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import sidesign.minib3d

Graphics3D 800, 600, 0, 2

CreateLight()

Local cam:TCamera = CreateCamera()
MoveEntity cam, 0, 0, -15

e1:TEntity = CreateCone()
e2:TEntity = CreateCone()
PositionEntity2 e2, 0, 3, 0
EntityParent2 e2, e1

cube = CreateCube()
PositionEntity cube, -4, -4, 0

Repeat

	TurnEntity2 e1, 1, 0, 0

	UpdateWorld
	RenderWorld
	
	pt# = EntityPitch2(e2, 1)
	yw# = EntityYaw2(e2, 1)
	rl# = EntityRoll2(e2, 1)	
	
	RotateEntity cube, pt, yw, rl
	
	BeginMax2D
	DrawText pt#, 0, 0
	DrawText yw#, 0, 20
	DrawText rl#, 0, 40
	EndMax2D

	Flip
	
Until KeyHit(key_escape)

End
</textarea><br><br>It seems pretty complete so far. There are two commands missing that I'm aware of: TranslateEntity, but using the 'global' parameter on MoveEntity2 will do the same, and TFormNormal2, which is TFormVector2, only normalized. It won't be a big hassle to add them.<br>I now wanted to see if it would be possible to create a TFormRotation command. If possible, that could be handy. <br><br></td></tr></table><br>
<a name="962074"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> TFormRotation .. skip that for now. I've updated the code in the archives. Hopefully everything is working correctly now.<br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2498" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2498</a> <br><br></td></tr></table><br>
<a name="965143"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> There might be a problem with the version in the code archives.<br><br>The Aligntovector2 function doesnt work when I use all the code from the code archives. The cone dances about instead of pointing at the cube. <br><br></td></tr></table><br>
<a name="965151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops .. you're right. I have updated it. <br><br></td></tr></table><br>
<a name="965168"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes that fixed that demo,thanks<br><br>There still might be something wrong with the code archive though:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict
Import sidesign.minib3d
Global gfxwidth=800
Global gfxheight=600
AppTitle= "Look for bugs"
Graphics3D gfxwidth,gfxheight

SeedRnd MilliSecs()
Global bullet_type=1
Global ship_type=2


Global camera:Tcamera=CreateCamera()


Local ship:Tentity=CreateCube()
EntityRadius ship,2
EntityType ship,ship_Type
EntityPickMode ship,1

HideEntity ship

Global player_ship:Tentity=CopyEntity (ship)

ShowEntity player_Ship

Local player_pivot:TPivot=CreatePivot(player_ship)

Global fighterbullet:Tentity=CreateSphere(8)'LoadSprite("fighterbullet.tga")

HideEntity fighterbullet
EntityRadius fighterbullet,0.5
EntityType fighterbullet,bullet_Type



EntityParent camera,player_ship
PositionEntity camera,0,3,-5
'Collisions bullet_type,ship_type,1,1
'RotateEntity camera,EntityPitch(player_ship,1),EntityYaw(player_ship,1),EntityRoll(player_Ship,1),1
PositionEntity player_ship,0,0,3

While Not KeyHit(KEY_ESCAPE)
Cls
If MouseHit(1)
bullet.Create()
EndIf
bullet.update()
Mouselook(player_ship)
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

UpdateWorld
RenderWorld

Flip
Wend

Type bullet
Global list:TList=New TList
Field model_handle:Tentity
Function Create()
Local t:bullet=New bullet
t.model_handle=CopyEntity (fighterbullet)
TFormPoint(0,0,5,player_ship,Null)
PositionEntity t.model_handle,TFormedX(),TFormedY(),TFormedZ()
RotateEntity t.model_handle,EntityPitch(player_ship),EntityYaw(player_ship),EntityRoll(player_ship)
bullet.list.addlast(t)
EndFunction
Function update()
For Local t:bullet=EachIn bullet.list
MoveEntity t.model_handle,0,0,1
Next
EndFunction
EndType

Function mousespeed(xy:Int)
If xy=1
'DebugLog "x mouse speed: "+Abs(MouseX()-prev_mouse_x)
Local slenkar=(MouseX()-(GraphicsWidth()/2))

Return slenkar
Else
'DebugLog "y mouse speed: "+Abs(MouseY()-prev_mouse_y)
Local slenkar=(MouseY()-(GraphicsHeight()/2))
Return slenkar
EndIf

EndFunction



Function Mouselook(RC:Tentity)

Local mx#=MouseSpeed(1)
Local my#=MouseSpeed(2)

If RC&lt;&gt;Null
TurnEntity player_Ship,-my,-mx,0
EndIf

End Function

</textarea> <br><br></td></tr></table><br>
<a name="965170"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> ?! They go upside down .. :( Strange. Well, inverting EntityPitch does help, I'll look into it:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict
Import sidesign.minib3d
Global gfxwidth=800
Global gfxheight=600
AppTitle= "Look for bugs"
Graphics3D gfxwidth,gfxheight

SeedRnd MilliSecs()
Global bullet_type=1
Global ship_type=2


Global camera:Tcamera=CreateCamera()


Local ship:Tentity=CreateCube()
EntityRadius ship,2
EntityType ship,ship_Type
EntityPickMode ship,1

HideEntity ship

Global player_ship:Tentity=CopyEntity (ship)

ShowEntity player_Ship

Local player_pivot:TPivot=CreatePivot(player_ship)

Global fighterbullet:Tentity=CreateSphere(8)'LoadSprite("fighterbullet.tga")

HideEntity fighterbullet
EntityRadius fighterbullet,0.5
EntityType fighterbullet,bullet_Type



EntityParent camera,player_ship
PositionEntity camera,0,3,-5
'Collisions bullet_type,ship_type,1,1
'RotateEntity camera,EntityPitch(player_ship,1),EntityYaw(player_ship,1),EntityRoll(player_Ship,1),1
PositionEntity player_ship,0,0,3

While Not KeyHit(KEY_ESCAPE)
Cls
If MouseHit(1)
bullet.Create()
EndIf
bullet.update()
Mouselook(player_ship)
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

UpdateWorld
RenderWorld

Flip
Wend

Type bullet
Global list:TList=New TList
Field model_handle:Tentity
Function Create()
Local t:bullet=New bullet
t.model_handle=CopyEntity (fighterbullet)
TFormPoint(0,0,5,player_ship,Null)
PositionEntity t.model_handle,TFormedX(),TFormedY(),TFormedZ()
RotateEntity t.model_handle,-EntityPitch(player_ship),EntityYaw(player_ship),EntityRoll(player_ship)
bullet.list.addlast(t)
EndFunction
Function update()
For Local t:bullet=EachIn bullet.list
MoveEntity t.model_handle,0,0,1
Next
EndFunction
EndType

Function mousespeed(xy:Int)
If xy=1
'DebugLog "x mouse speed: "+Abs(MouseX()-prev_mouse_x)
Local slenkar=(MouseX()-(GraphicsWidth()/2))

Return slenkar
Else
'DebugLog "y mouse speed: "+Abs(MouseY()-prev_mouse_y)
Local slenkar=(MouseY()-(GraphicsHeight()/2))
Return slenkar
EndIf

EndFunction



Function Mouselook(RC:Tentity)

Local mx#=MouseSpeed(1)
Local my#=MouseSpeed(2)

If RC&lt;&gt;Null
TurnEntity player_Ship,-my,-mx,0
EndIf

End Function
</textarea> <br><br></td></tr></table><br>
<a name="965171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> glad to know its something simple :) thanks <br><br></td></tr></table><br>
<a name="965172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> I updated the TMatrix.bmx code in the archive to invert the outcome of Pitch.<br>Thanks for letting me know! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
