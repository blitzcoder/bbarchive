<!DOCTYPE html><html lang="en" ><head ><title >Minib3d Implementing a shader</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Minib3d Implementing a shader</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=119" >MiniB3D Module</a>/<a href="#bottom" >Minib3d Implementing a shader</a><br><br>
<a name="1163165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BLaBZ</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Guys, I'm relatively new to shader's and I'm having a hard time implementing this shader class in minib3d:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TShader
	Field ProgramObject:Int
	
	Method Load:TShader(VertexPath:String, FragmentPath:String)
		Local VertexCode:String, FragmentCode:String
		
		Try
			VertexCode   = LoadText(VertexPath)
			FragmentCode = LoadText(FragmentPath)
		Catch Dummy:Object
			Return Null
		EndTry
		
		Create(VertexCode, FragmentCode)
		
		Return Self
	End Method
	
	Method Create:TShader(VertexCode:String, FragmentCode:String)
		If Not ProgramObject Then ProgramObject = glCreateProgram()
		
		Local VertexShader  :Int = glCreateShader(GL_VERTEX_SHADER)
		Local FragmentShader:Int = glCreateShader(GL_FRAGMENT_SHADER)
		
		Local ErrorMessage:String
		
		_LoadShader(VertexCode, VertexShader)
		glCompileShader(VertexShader)
		
		If _CheckForErrors(VertexShader, ErrorMessage) Then
			glDeleteShader(VertexShader)
			
			Throw ErrorMessage
		EndIf
		
		_LoadShader(FragmentCode, FragmentShader)
		glCompileShader(FragmentShader)
		
		If _CheckForErrors(FragmentShader, ErrorMessage) Then
			glDeleteShader(VertexShader)
			glDeleteShader(FragmentShader)
			
			Throw ErrorMessage
		EndIf
		
		glAttachShader(ProgramObject, VertexShader)
		glAttachShader(ProgramObject, FragmentShader)
		
	'glBindAttribLocation(ProgramObject,0,"vPosition");
		
		glDeleteShader(VertexShader)
		glDeleteShader(FragmentShader)
		
		glLinkProgram(ProgramObject)
		If _CheckForErrors(ProgramObject, ErrorMessage, False) Then Throw ErrorMessage
		
'		glValidateProgram(ProgramObject)
		
		Return Self
	End Method
	
	Method Enable()
		glUseProgram(ProgramObject)
	End Method
	
	Method Disable()
		glUseProgram(0)
	End Method
	
	Method GetUniformLocation:Int(Name:String)
		Return glGetUniformLocationARB(ProgramObject, Name)
	End Method
	
	Method Delete()
		glDeleteObjectARB(ProgramObject)
	End Method
	
	Function _LoadShader(ShaderCode:String, ShaderObject:Int)
		Local ShaderCodeC:Byte Ptr = ShaderCode.ToCString()
		Local ShaderCodeLen:Int    = ShaderCode.Length
		
		glShaderSource(ShaderObject, 1, Varptr ShaderCodeC, Varptr ShaderCodeLen)
		
		MemFree(ShaderCodeC)
	End Function
	
	Function _CheckForErrors:Int(ShaderObject:Int, ErrorString:String Var, Compiled:Int = True)
		Local Successful:Int
		
		If Compiled Then
			glGetShaderiv(ShaderObject, GL_COMPILE_STATUS, Varptr Successful)
		Else
			glGetProgramiv(ShaderObject, GL_LINK_STATUS,    Varptr Successful)
		EndIf
		
		If Not Successful Then
			Local ErrorLength:Int
			'glGetObjectParameterivARB(ShaderObject, GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr ErrorLength)
			glGetShaderiv(ShaderObject,GL_INFO_LOG_LENGTH,Varptr ErrorLength)
			Local Message:Byte Ptr = MemAlloc(ErrorLength), Dummy:Int
			
			glGetInfoLogARB(ShaderObject, ErrorLength, Varptr Dummy, Message)
			
			ErrorString = String.FromCString(Message)
			MemFree(Message)
			
			Return -1
		EndIf
		
		Return 0
	End Function
	
	Function CheckCompability:Int()
		Local Extensions:String = String.FromCString(Byte Ptr glGetString(GL_EXTENSIONS))
		Local GLVersion:String  = String.FromCString(Byte Ptr glGetString(GL_VERSION))
		Local GLVersionInt:Int  = GLVersion[.. 3].Replace(".", "").ToInt()
		
		If Extensions.Find("GL_ARB_shader_objects" ) &gt;= 0 And ..
		   Extensions.Find("GL_ARB_vertex_shader"  ) &gt;= 0 And ..
		   Extensions.Find("GL_ARB_fragment_shader") &gt;= 0 Or GLVersionInt &gt;= 20 Then Return True
		
		Return False
	End Function
End Type

</textarea><br><br><br>I've modified the TMesh class to enable and disable the program object right before and after it calls glDrawElements:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
glPushMatrix()
			
			'Enable shaders
			For Local s:TShader = EachIn Shaders
				s.Enable()
			Next
			
	
			If TSprite(Self)=Null
				glMultMatrixf(mat.grid)
			Else
				glMultMatrixf(mat_sp.grid)
			EndIf
					
			If vbo	
																																																																																																																																																																																																																																																																																
				glDrawElements(GL_TRIANGLES,surf.no_tris*3,GL_UNSIGNED_SHORT,Null)
			Else
	
				'//SMALLFIXES NOTFIXED 'DebugStop IRRmesh+others sometimes crash here under parallels 
				glDrawElements(GL_TRIANGLES,surf.no_tris*3,GL_UNSIGNED_SHORT,surf.tris)	
			EndIf
			
			'Disable shaders
			For Local s:TShader = EachIn Shaders
				s.Disable()
			Next

			glPopMatrix()
</textarea><br><br>The shader code I'm passing in is this:<br><br>Vertex code:<br><pre class=code>
Const VERTEX_CODE:String = .. 
	"attribute vec4 vPosition;~n" + ..
	"void main( void ) {~n" + ..
		"gl_Position = vPosition;~n" + ..
	"}"
</pre><br><br>Fragment code:<br><pre class=code>
Const FRAGMENT_CODE:String = ..
	"precision mediump float;~n" + ..
	"void main(void) {~n" + ..
		"gl_FragColor = vec4(1.0,0.0,0.0,1.0);~n" + ..
	"}"
</pre><br><br>I keep getting this red line across the screen, I have a feeling the problem is with the shader code but I'm not sure if this implementation would work,<br><br>All guidance and tips welcome.<br><br>Thanks alot! <br><br></td></tr></table><br>
<a name="1163254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >angros47</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why have you commented "glBindAttribLocation" ? <br>Without it, you don't pass vertex data to your shader, so it won't work. <br><br></td></tr></table><br>
<a name="1163366"></a>

<a name="1163367"></a>

<a name="1163371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is my old shader class.<br>I won't support this, since my monkey+minib3d TShader class is much better (and old code).<br><br>TShader.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
''
''
'' TShader
'' is for global shaders that replace the fixed pipeline
''

''notes:
'' -- if we're adding mupltiple shader via AddShaderPass(), to which shader is this added to?
'' -- would it be easier to keep adding passes to just one shader, and call that shader?
'' -- or do we force users to add passes to each subsequent shader? including FBOs, FBO display passes...


'GlewInit() ''The gl Extention calls

Const MAXTEXSIZE = 2048 '' lowest common gfx chipset

Type TShader
	Global initsh:Int
	
	Global lastActiveShader:TShader ''keeps the last global shader
	Global currShader:TShader ''current shader, to turn back on when we turn off for fbo
	
	Global totalID:Int 
	Field internalID:Int =0 ''not used by opengl, used internally for a successful, active compile
	
	Field vshaderID:Int =0
	Field fshaderID:Int =0
	
	Field useGLSL:Int =0 ''if we are opengl2.0 or not
	Field useFBO:Int=0
	Global renderflagFBO:Int = 0 ''internal use to see if we need to use the fbo post render
	
	Field textureFBO:TTexture
	Field fbufferID:Int =0
	
	Global rbufferID:Int ''only need one depth buffer???
	Global mbufferID:Int
	Global maintextureFBO:TTexture
		
	Field shader_link:TShader
	
	Global supportFBO:Int=0	
	Global lastRenderedFBO:TTexture 
	
	Field name:String = "" 'for debugging
	
	Function Init:Int()
		''
		'' check for shader support, return false if none
		If initsh Then Return True
		If Not IsSupported() Return False
		
		GlewInit() ''The gl Extention calls
		
		initsh = 1
		TShaderBrush.initsh = 1
		
		Return True
	EndFunction
	
	Method IsValid:Int()
		''used to check if shader has been compiled successfully
		Return internalID
	EndMethod
	
	Function IsSupported:Int()
		''
		Local Extensions:String = String.FromCString(Byte Ptr(glGetString(GL_EXTENSIONS)))
		Local VPSupport:Int = Extensions.Find("GL_ARB_vertex_program") &gt; -1
		Local FPSupport:Int = Extensions.Find("GL_ARB_fragment_program") &gt; -1
		supportFBO = Extensions.Find("GL_EXT_framebuffer_object") &gt; -1
		
		If Not supportFBO
			DebugLog "**No FrameBufferObject support."
		EndIf
		
		If Not(VPSupport)
			DebugLog "**No ARB Vertex Program support."
			Return False
		EndIf
		
		If Not(FPSupport)
			DebugLog "**No ARB Fragment Program support."
			Return False 
		EndIf
		
		Return True
	EndFunction


	Function LoadARB:TShader(vp:Object, fp:Object)
		''input path or stream for vertex arb shaders
		''vp or fp can be null, but not both
		'' arb Opengl 1.5 probability
		Local sh:TShader = New TShader
		
		If Not initsh DebugLog "**Shader error: not init()"; Return sh
		
		While glGetError() &lt;&gt; GL_NO_ERROR ''clear out any existing openGL errors
		Wend
		
		
		''Prepare Vertex program
		If vp &lt;&gt; Null
			''Read File
			Local vpData:TStream =  ReadStream(vp)
			If Not vpData Then DebugLog "**Shader error: no stream"; Return sh
			
			SeekStream( vpData, 0 )
			
			Local vpAssembly:String = Null
			While Not Eof(vpData)
				vpAssembly = vpAssembly + ReadLine(vpData).Trim()+ "~n"
			Wend
			CloseStream(vpData)
	
	
			glGenProgramsARB( 1, Varptr sh.vshaderID )
			glBindProgramARB(GL_VERTEX_PROGRAM_ARB, sh.vshaderID)
			
			'' Compile shader string
			glProgramStringARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, vpAssembly.length, vpAssembly.ToCString() )
				
			If ( glGetError() &lt;&gt; GL_NO_ERROR )
				Print "**Shader Error: Vertex program "+vp.ToString()
				Local error_out:String = String.FromCString(glGetString(GL_PROGRAM_ERROR_STRING_ARB))
				DebugLog( error_out )
	
				Return sh
			End If
			
		EndIf
		
		
		''Prepare Fragment Program
		If fp &lt;&gt; Null
			Local fpData:TStream =  ReadStream(fp)
			If Not fpData Then DebugLog "**Shader error: no stream"; Return sh
			
			SeekStream( fpData, 0 )
			
			Local fpAssembly:String = Null
			While Not Eof(fpData)
				fpAssembly = fpAssembly + ReadLine(fpData).Trim()+ "~n"
			Wend
			CloseStream(fpData)
			
			
			glGenProgramsARB( 1, Varptr sh.fshaderID )
			glBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, sh.fshaderID)
			
			'' Compile shader string
			glProgramStringARB( GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, fpAssembly.length, fpAssembly.ToCString() )
			
			If ( glGetError() &lt;&gt; GL_NO_ERROR )
				Print "**Shader Error: Fragment program "+fp.ToString()
				Local error_out:String = String.FromCString(glGetString(GL_PROGRAM_ERROR_STRING_ARB))
				DebugLog( error_out )
	
				Return sh 
			EndIf
		EndIf
		
		If sh.vshaderID Or sh.fshaderID
			totalID :+1
			sh.internalID = totalID ''validate compiling of shader
			sh.useGLSL =0
			
			Local j:Object
			If fp&lt;&gt;Null Then j=fp Else j=vp
			
			DebugLog "Shader success: "+sh.internalID+" "+j.ToString()
		EndIf
		
		Return sh
		
	EndFunction
	
	Function LoadGLSL:TShader(vp$, fp$)
		Local sh:TShader = New TShader
		If Not initsh DebugLog "**Shader error: not init()"; Return sh
		
		
		'' glsl OpenGL 2.0+
		sh.useGLSL = 1
		
		Return sh
		
	EndFunction
	
	Method Active:Int(on:Int=1)
		'' 0 to turn off and return to fixed pipeline
		If Not initsh Then Return False
		'DebugLog "..shader active"
		If on And internalID
			If vshaderID
				glEnable(GL_VERTEX_PROGRAM_ARB)
				glBindProgramARB(GL_VERTEX_PROGRAM_ARB, vshaderID)
				
			EndIf
			
			If fshaderID
				glEnable(GL_FRAGMENT_PROGRAM_ARB)
				glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, fshaderID)

				'If useFBO
					'glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fbufferID)
				'EndIf
				
			EndIf
			
			currShader = Self
			If lastActiveShader = Null Then lastActiveShader = Self
			
		Else
			glDisable(GL_VERTEX_PROGRAM_ARB)
			glDisable(GL_FRAGMENT_PROGRAM_ARB)
			
			'If useFBO
				'glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
			'EndIf
			
			If lastActiveShader = Self Then lastActiveShader = Null
			
			currShader = Null
			
		EndIf
		
			
		Return True
		
	EndMethod
	
	Method Deactive()
		Active(0)
	EndMethod
	
	
	
	Method SetFragmentLocalParam(index:Int, n1:Float, n2:Float=0.0, n3:Float=0.0, n4:Float=0.0)
	
		Local arr:Float[]

		arr = [n1,n2,n3,n4]
		
		glProgramLocalParameter4fvARB( GL_FRAGMENT_PROGRAM_ARB,index, arr )
		
	EndMethod
	
	Method SetVertexLocalParam(index:Int, n1:Float, n2:Float=0.0, n3:Float=0.0, n4:Float=0.0 )
		
		Local arr:Float[]

		arr = [n1,n2,n3,n4]
		glProgramLocalParameter4fvARB( GL_VERTEX_PROGRAM_ARB,index, arr )
		
	EndMethod
	
	Method SetUniform(index:Int, u1:Float, u2:Float=Null, u3:Float=Null, u4:Float=Null)
		''opengl 2.0
		If Not useGLSL Then Return
		
		If u4 &lt;&gt; Null
			glUniform4fARB(index, u1, u2, u3, u4)
		ElseIf u3 &lt;&gt; Null
			glUniform3fARB(index, u1, u2, u3)
		ElseIf u2 &lt;&gt; Null
			glUniform2fARB(index, u1,  u2)
		Else
			glUniform1fARB(index, u1)
		EndIf
	EndMethod
	
	
	Method SetFBO:TTexture(tex:TTexture=Null, depth:Int=True)
		''this will render this shader's output to a texture whenever the shader is executed
		''may fall back to the FFP render to texture if fbo isn't available
		'' -- i've decided to always use the dpeth buffer, since it's shared
		
		If Not supportFBO Then Return Null
		
		If tex=Null
		
			Local texsize:Int
			If(TGlobal.width &lt; TGlobal.height) Then texsize = TTexture.Pow2Size(TGlobal.height)
			If(TGlobal.width &gt; TGlobal.height) Then texsize = TTexture.Pow2Size(TGlobal.width)
			If texsize &gt; MAXTEXSIZE Then texsize = MAXTEXSIZE
			textureFBO = CreateTexture(texsize ,texsize ,2,1)
		Else
			textureFBO = tex
		EndIf
		
		If Not mainTextureFBO
			Local texsize:Int
			If(TGlobal.width &lt; TGlobal.height) Then texsize = TTexture.Pow2Size(TGlobal.height)
			If(TGlobal.width &gt; TGlobal.height) Then texsize = TTexture.Pow2Size(TGlobal.width)
			If texsize &gt; MAXTEXSIZE Then texsize = MAXTEXSIZE
			mainTextureFBO = CreateTexture(texsize ,texsize ,2,1)
		EndIf

		
		''attach texture
		glGenFramebuffersEXT(1, Varptr fbufferID )
		glBindTexture(GL_TEXTURE_2D, textureFBO.gltex[0])
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fbufferID)
		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, textureFBO.gltex[0], 0)
		
		''attach depth renderbuffer
		'' currently, rbufferID is global to minimize memory use
		'' -- may have problem with setting smaller render buffers than screen
		If (depth And Not rbufferID)
			glGenRenderbuffersEXT(1 , Varptr rbufferID)
		EndIf
		If (depth)
			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbufferID)
			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, textureFBO.width,  textureFBO.height)
			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT , GL_DEPTH_ATTACHMENT_EXT , GL_RENDERBUFFER_EXT , rbufferID)
		EndIf
		
		Local status:Int =  glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT)
		
		Select status
		   	Case GL_FRAMEBUFFER_COMPLETE_EXT
				useFBO = 1
				
				DebugLog "..FBO success"
			Case GL_FRAMEBUFFER_UNSUPPORTED_EXT
				DebugLog "**FBO: unsupported. choose different formats" '' Return Null 
			Default
				DebugLog "**FBO unsuccessful :"+status '' Return Null 
		EndSelect 
		
		''create main FBO texture
		''attach texture
		If Not mbufferID
			glGenFramebuffersEXT(1, Varptr mbufferID )
			glBindTexture(GL_TEXTURE_2D, mainTextureFBO.gltex[0])
			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , mbufferID)
			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, mainTextureFBO.gltex[0], 0)
			
			''attach depth renderbuffer
			'' currently, rbufferID is global to minimize memory use
			'' -- may have problem with setting smaller render buffers than screen
			If (depth)
				glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbufferID)
				glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, mainTextureFBO.width,  mainTextureFBO.height)
				glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT , GL_DEPTH_ATTACHMENT_EXT , GL_RENDERBUFFER_EXT , rbufferID)
			EndIf
			
			
		EndIf
		
		''clean exit
		glBindTexture(GL_TEXTURE_2D, 0)
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)
		
		Return textureFBO
	EndMethod
	
	Method GetFBO:TTexture()
		''returns a texture associated with this FBO
		
		If Not useFBO Then Return Null
		Return textureFBO
		
	EndMethod
	
	Method DeleteFBO()
		useFBO =0
		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, 0, 0)
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
	EndMethod
	
	
	
	
	Method AddFBOPass(tex:TTexture = Null)
		''this command will capture fbo for this shader
		
		If Not useFBO
			SetFBO(tex)
			
		Else
			'' just repeating SetFBO() function
		EndIf
		
		shader_link = Null'' let's think about this, see above notes***************************
	EndMethod
	
	
	Method AddFBODisplay(tex:TTexture = Null)
		''display the tex FBO or last known FBO Pass
	EndMethod
	
	
	Function DisplayFBO(tex:TTexture = Null , alpha:Float=1.0,  override:Int=0)
		''draw a quad in ortho mode
		'' override=true keeps the shader on
		
		If Not tex
			
		EndIf
		
		If Not tex  Then Return
		
		'If tex = mainTextureFBO Then Print "mainfbo"
		
		'Local scWidth:Float = TGlobal.Width
		'Local scHeight:Float = TGlobal.Height
		'Local ssc:Float = mainTextureFBO.Width/Float(tex.width)
		'' UV ratio is the same for 1024x1024 or 512x512
		Local UVW:Float = TGlobal.Width / Float(mainTextureFBO.Width) '(Float(tex.width) *ssc)
		Local UVH:Float =  TGlobal.Height /  Float(mainTextureFBO.Height) '(Float(tex.height) *ssc)
		
		''save shader info
		If Not override Then TShader.ForceOff()
		
		glPushClientAttrib GL_CLIENT_ALL_ATTRIB_BITS
		glPushAttrib GL_ALL_ATTRIB_BITS
		glMatrixMode GL_MODELVIEW
		glPushMatrix
		glMatrixMode GL_PROJECTION
		glPushMatrix
		glMatrixMode GL_TEXTURE
		glPushMatrix
		glLoadIdentity()
		glMatrixMode GL_COLOR
		glPushMatrix 
		glLoadIdentity
		
		glDisable(GL_DEPTH_TEST)
		glDisable(GL_LIGHTING)
		'glEnable(GL_ALPHA_TEST)
		'glEnable(GL_CULL_FACE)
		'BeginMax2D()
		
		glMatrixMode GL_PROJECTION
		glLoadIdentity()
		'Local ratio:Float = (cam.range_far+1)/cam.range_far

		'glOrtho(0.0, TGlobal.Width,  TGlobal.Height, 0.0, -1.0, 1.0)
		glOrtho(-1, 1,  1, -1, -1.0, 1.0)
		glMatrixMode GL_MODELVIEW
		glLoadIdentity()
		'glScalef(ratio,ratio,ratio)

		
		'glDisable(GL_COLOR_MATERIAL)

		'glDisable(GL_FOG)
		'glDisable(GL_DEPTH_TEST)
		'glDisable(GL_BLEND)
		'glDisableClientState(GL_TEXTURE_COORD_ARRAY)
		'glDisableClientState(GL_COLOR_ARRAY)
		'glDisableClientState(GL_NORMAL_ARRAY)
		'glDisableClientState(GL_VERTEX_ARRAY)
		'glBindBuffer(	GL_ARRAY_BUFFER,0)
		
		''allow user to set blend
		glEnable (GL_BLEND)
		'glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

		
		
		glActiveTexture(GL_TEXTURE0)
		glClientActiveTextureARB(GL_TEXTURE0)
		glBindTexture GL_TEXTURE_2D, tex.gltex[0]

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
   		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
		
		glEnable(GL_TEXTURE_2D)
		
		
		Rem
		glMatrixMode(GL_TEXTURE)
		glLoadIdentity()
					
		If tex.u_pos&lt;&gt;0.0 Or tex.v_pos&lt;&gt;0.0
			glTranslatef(tex.u_pos,tex.v_pos,0.0)
		EndIf
		If tex.angle&lt;&gt;0.0
			glRotatef(tex.angle,0.0,0.0,1.0)
		EndIf
		If tex.u_scale&lt;&gt;0.0 Or tex.v_scale&lt;&gt;0.0
			glScalef(tex.u_scale,tex.v_scale,1.0)
		EndIf
		EndRem
		
		'glPolygonMode(GL_FRONT,GL_FILL);

		'glColor4f(alpha,alpha,alpha,alpha)
		glColor4f(1,1,1,1.0)
	
		glBegin GL_QUADS
		
		glTexCoord2f(UVW , UVH)

		glVertex3f (1  ,-1, 0)
		glTexCoord2f(0.0 , UVH)

		glVertex3f (-1 , -1, 0)
		glTexCoord2f(0 , 0)

		glVertex3f (-1 , 1, 0)
		glTexCoord2f(UVW, 0) 

		glVertex3f (1, 1, 0)
		glEnd

		
		glBindTexture GL_TEXTURE_2D,0
		

		'glFrustum(1,1,1,1,1,1)
		glPopAttrib
		glPopClientAttrib 
		glMatrixMode GL_MODELVIEW
		glPopMatrix
		glMatrixMode GL_PROJECTION
		glPopMatrix
		glMatrixMode GL_TEXTURE
		glPopMatrix
		glMatrixMode GL_COLOR
		glPopMatrix 
		
		glEnable(GL_LIGHTING)
		'glEnable(GL_CULL_FACE)
		glEnable(GL_DEPTH_TEST)
		'glDepthFunc(GL_LEQUAL)

		'TGlobal.EnableStates()
		
		If currShader &lt;&gt;Null And Not override Then currShader.Active(1)
		
	EndFunction
	
	Function ClearMainFBO(depth:Int=0)
	
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , mbufferID)
		If depth Then glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbufferID)
		
		glClearColor(0.0,0.0,0.0,0.0)
		'glClearDepth(1.0)
		
		Local bit:Int = GL_COLOR_BUFFER_BIT
		
		If depth
			bit = bit | GL_DEPTH_BUFFER_BIT
		EndIf
		
		glClear(bit)
		
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)
		
	EndFunction
	
	Function RenderBegin() Final
		''one time init, called from TGlobal
		
		If Not initsh Then Return
		
		'Print "begin"
		
		ClearMainFBO(True)
		renderflagFBO = 0
		
	EndFunction
	
	Function Render(mesh:TMesh, cam:TCamera=Null) Final
	''--called from TGlobal.bmx RenderWorld()
		
		If Not mesh Then Return
		
		If Not initsh
			mesh.Update()
			Return
		EndIf
		
		'glEnable(GL_DEPTH_TEST)
		'glDepthFunc(GL_LEQUAL)
		'glDepthMask(True)

		If mesh.shader_brush And mesh.shader_brush.isActive
			''use brush shader
			Local restoreShader:TShader = TShader.currShader
			
			'Local shaderb:TShaderBrush = TShaderBrush(mesh.shader_brush) ''this strips out extended shaders??
			
			''do we have an fbo?
			If mesh.shader_brush.useFBO
			
				renderflagFBO = 1

				'glBindTexture(GL_TEXTURE_2D, 0)

				glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , mesh.shader_brush.fbufferID)
				glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbufferID)

				'glPushAttrib(GL_VIEWPORT_BIT|GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT)
				'glViewport(0,0,TGlobal.Width, TGlobal.Height) ''for smaller textureFBOs
			'Print mesh.shader_brush.shader.name+" "+mesh.shader_brush.shader.fbufferID
				glClearColor(0.0,0.0,0.0,0.0)
				glClear(GL_COLOR_BUFFER_BIT)' | GL_DEPTH_BUFFER_BIT)
				glEnable(GL_DEPTH_TEST)
				glDepthMask(GL_TRUE)

			EndIf

			mesh.shader_brush.RenderBrush( mesh, cam) ''render the brush, not shaderb



Rem
			If mesh.shader_brush.useFBO
				'glPopAttrib()

				glBindTexture(GL_TEXTURE_2D, 0)
				glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
				glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)

				DisplayFBO( mainTextureFBO )
				ClearMainFBO()
				DisplayFBO( mesh.shader_brush.textureFBO )
			EndIf	
EndRem

			''do next shader, iterative
			'If shader.shader_link Then shader.shader_link.Render(mesh, cam)
			
			If restoreShader Then restoreShader.Active(1)

		Else
			''no brush shader, but need to add other objects to mainTextureFBO
			
			If mbufferID 
				'' we use mbuffer because we don't know when the shaderbrush will be activated, so do for all
				
				glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , mbufferID)
				glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbufferID)
				
				mesh.Update()
				
				glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0)
				glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)

			EndIf
			If Not renderflagFBO
				'' this part needed in order to draw properly if theres an unused FBO mbufferID out there
				
				'mesh.Update()
				
			EndIf
		
		EndIf
	
	EndFunction
	
	Method ShaderPass(mesh:TMesh, cam:TCamera)
		''this method is to extend a shader to do its own custom pass
		
	EndMethod
	
	Function RenderPost()
		
		''extend this function for each shader
		
	EndFunction
	
	Function RenderPostProcess() Final

		
		If renderflagFBO Or mbufferID

			DisplayFBO( mainTextureFBO )

		EndIf
		
	EndFunction
	
	
	Method ProcessFBO(tex:TTexture)
		'' function: a special method to draw an full-screen quad using the attached shader from a given FBO texture
		'' -- no depth is used
		'' -- is written back into the attached shader FBO, not displayed on screen
		'' -- smaller textures can be used to save memory, speed
		
		If Not tex Or Not initsh Then Return
		
		Local tempShader:TShader = currShader
		Active(1)
		
		''resize viewport if needed
		Local resizeviewport:Int =0
		If textureFBO.width &lt; mainTextureFBO.width
			Local viewratio_w:Float = TGlobal.width*textureFBO.width / mainTextureFBO.width
			Local viewratio_h:Float = TGlobal.height*textureFBO.height / mainTextureFBO.height
			glPushAttrib(GL_VIEWPORT_BIT)
			glViewport(0,0,viewratio_w,viewratio_h)
			resizeviewport = 1
		EndIf
		
		
		glBindTexture(GL_TEXTURE_2D, 0)
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fbufferID)
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0) 'rbufferID) ''no depth
		
		DisplayFBO(tex, 1.0, True)
		
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)
		
		Active(0)
		If tempShader Then tempShader.Active(1)
		
		If resizeviewport
			glPopAttrib()
		EndIf
	EndMethod
	
	
	Method ReplaceFBO(t:TTexture)
		'' dangerous
		textureFBO = t
	EndMethod
	
	
	Method ClearFBO(depth:Int=0, keepFBOopen:Int=0)

		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fbufferID)
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbufferID)
		
		glClearColor(0.0,0.0,0.0,0.0)
		glClearDepth(1.0)
		
		Local bit:Int = GL_COLOR_BUFFER_BIT
		
		If depth
			bit = bit | GL_DEPTH_BUFFER_BIT
		EndIf
		
		glClear(bit)
		
		If Not keepFBOopen
			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)
		EndIf

	EndMethod
	
	
	Function DisplayMainFBO()
		''-- see TShader Display FBO
		glBindTexture(GL_TEXTURE_2D, 0) 
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0) ''i think you need this
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0) ''i think you need this
		
		DisplayFBO(mainTextureFBO)
		ClearMainFBO()
	EndFunction
	
	
	Function ForceOff()
		If Not initsh Then Return False

		''WARNING this routine will NOT clear currShader
		
		glDisable(GL_VERTEX_PROGRAM_ARB)
		glDisable(GL_FRAGMENT_PROGRAM_ARB)
	EndFunction
EndType

'' Global functions
''
Function InitShaders:Int()
	Return TShader.Init() ''keep this the only function for compatibility
EndFunction

''
'' shaders for individual entities
''
Type TShaderBrush Extends TBrush
	''used for PaintMesh, entity, etc.
	''** you must use InitShaders() or TShader.Init() to begin
	
	Global initsh:Int =0 ''Init by TShader
	
	Field isActive:Int =0 ''also used to disable opengl FFP
	Field shader:TShader = New TShader
	
	Field useFBO:Int =0
	Field fbufferID:Int
	Field textureFBO:TTexture '= New TTexture
	
	Field nullbuffer:Int = $ffff
	Field nullbuffer2:Int = $ffff
	
	Method IsValid:Int()
		Return shader.IsValid()
	EndMethod
	
	Function LoadARB:TShaderBrush(vp:Object, fp:Object)
		'' returns a new shaderbrush
		If Not initsh Then Return Null
		
		Local sh:TShaderBrush = New TShaderBrush
		sh.shader = TShader.LoadARB(vp,fp)
		
		''fail
		If Not sh.IsValid()
			Return sh
		EndIf
		
		sh.isActive = True ''make active immediately
		DebugLog "..brush shader active"
			
		''in order for a shader to use UV coords, need to enable it within the brush by default
		sh.BrushTexture(CreateTexture(1,1,1,1),0,0)
		sh.BrushTexture(CreateTexture(1,1,1,1),0,1)
			
		Return sh
	EndFunction
	
	Method Active(a:Int=1)
		''on 1 /off 0
		If Not initsh Then Return False
		
		If a
			isActive = True
			'DebugLog "..brush shader active"
		Else
			isActive = False
		EndIf
	EndMethod
	
	Method Deactive()
		isActive = False
	EndMethod
	
	Method RenderBrush( mesh:TMesh, cam:TCamera)
		''function: per mesh being rendered

		If Not isActive Or Not initsh Or Not mesh Or Not shader Then Return

		''turn on shader
		shader.Active(1)

		''render
		mesh.Update()
		
		''turn off
		shader.Active(0)


		If useFBO

			glBindTexture(GL_TEXTURE_2D, 0)
			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0)
			
			TShader.DisplayFBO( TShader.mainTextureFBO )
			TShader.ClearMainFBO()
			TShader.DisplayFBO( shader.textureFBO )

		EndIf

		''do next shader, iterative
		'If shader.shader_link Then shader.shader_link.Render(mesh, cam)		
	EndMethod
	


	
	Method SetFragmentLocalParam(index:Int, n1:Float, n2:Float=Null, n3:Float=Null, n4:Float=Null)		
		shader.SetFragmentLocalParam(index, n1, n2, n3, n4 )
	EndMethod
	
	Method SetVertexLocalParam(index:Int, n1:Float, n2:Float=Null, n3:Float=Null, n4:Float=Null)		
		shader.SetVertexLocalParam(index, n1, n2, n3, n4 )
	EndMethod
	
	Method SetVertexLocalParam4x4(index:Int, arr:Float[,] )
		Local x:Int=0, y:Int=0
		For Local i:Int = index To index+3
			'Local f:Float[] = [arr[x,0],arr[x,1],arr[x,2],arr[x,3]]
			shader.SetVertexLocalParam(i, arr[x,0],arr[x,1],arr[x,2],arr[x,3] )
			x:+1
		Next
	EndMethod
	
	Method SetFBO( tex:TTexture=Null, shaderx:TShader=Null, depthFlag:Int=True)
		''this will render this shader's output to a texture whenever the shader is executed
		''default depth to be ON for FBOs
		''Also: this function can take a shader, if it has not been associated with a shader-- used for extended passes
		
		If Not shaderx Then shaderx = shader
		If Not shaderx Then Return ''we MUST have a shader to attach to
		
		shaderx.SetFBO(tex, depthFlag)
		useFBO = True
		fbufferID = shaderx.fbufferID
		textureFBO = shaderx.textureFBO
		
	EndMethod
	
	Method GetFBO:TTexture()
		''returns a texture associated with this FBO
		
		If Not useFBO Then Return Null
		Return textureFBO
		
	EndMethod
	
	Method ReplaceFBO(t:TTexture)
		''not a good idea, as it does an index replace, not a copy-- better to do a bitblit
		textureFBO = t
		shader.textureFBO = t
	EndMethod
	
	Method SetShader(sh:TShader)
		shader = sh
		useFBO = sh.useFBO
		fbufferID = sh.fbufferID
		textureFBO = sh.textureFBO
	EndMethod
	
	
	Method ProcessFBO(t:TTexture)
		'' function: a special method to draw an full-screen quad using the attached shader from a given FBO texture
		'' -- no depth is used
		'' -- is written back into the attached shader FBO, not displayed on screen
		
		shader.ProcessFBO(t)
		
	EndMethod
	
	Function DisplayFBO(t:TTexture, alpha:Int=1.0, override:Int=0)
		''-- see TShader Display FBO
		TShader.DisplayFBO(t, alpha, override)
	EndFunction
	
	Function DisplayMainFBO()
		''-- see TShader Display FBO
		TShader.DisplayMainFBO()
	EndFunction
	
	Method ClearFBO(depth:Int=0)
		shader.ClearFBO(depth)
	EndMethod
	
	Method BeginFBO(depth:Int=0)
		If Not useFBO Then Return
		
		glBindTexture(GL_TEXTURE_2D, 0) 
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fbufferID)
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, TShader.rbufferID)
		'shader.ClearFBO(depth, True) ''keep fbo open
		'glEnable(GL_DEPTH_TEST)
		'glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE)
		
		glClearColor(0.0,0.0,0.0,0.0)
		glClearDepth(1.0)
		
		Local bit:Int = GL_COLOR_BUFFER_BIT
		
		If depth
			bit = bit | GL_DEPTH_BUFFER_BIT
		EndIf
		
		glClear(bit)
		
	EndMethod
	
EndType


Function TextureID:Int(t:TTexture)
	Return t.gltex[0]
EndFunction
</textarea><br><br>TGlobal.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TGlobal

	Global width,height,mode,depth,rate
	Global ambient_red#=0.5,ambient_green#=0.5,ambient_blue#=0.5

	Global vbo_enabled=False ' this is set in GraphicsInit - will be set to true if USE_VBO is true and the hardware supports vbos

	' anti aliasing globs
	Global aa ' anti_alias true/false
	Global ACSIZE ' accum size
	Global jitter
	Global j#[16,2]

	Function Graphics3D(w,h,d=0,m=0,r=60)

		'mode:
		'0: windowed in debug mode, fullscreen in non-debug mode 
		'1: full-screen always 
		'2: windowed always 

		' change depth values so that Graphics will behave in the same way as Blitz3D-style Graphics3D
		Select m
			Case 0
				?debug
					d=0
				?
				?Not debug
					If d=0 Then d=16
				?
			Case 1
				If d=0 Then d=16
			Case 2
				d=0		
			Default
				d=0		
		End Select
			
		width=w
		height=h
		depth=d
		mode=m
		rate=r
		
		SetGraphicsDriver(GLMax2DDriver()) 
		Graphics(width,height,depth,rate,GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER|GRAPHICS_ACCUMBUFFER)

		GraphicsInit()
								
	End Function

	Function AntiAlias(samples)

		aa=True

		If samples=False Then aa=0;Return
		
		Select samples
			Case 1 RestoreData j2; ACSIZE=2
			Case 2 RestoreData j2; ACSIZE=2
			Case 3 RestoreData j3; ACSIZE=3
			Case 4 RestoreData j4; ACSIZE=4
			Case 5 RestoreData j5; ACSIZE=5
			Case 6 RestoreData j6; ACSIZE=6
			Case 8 RestoreData j8; ACSIZE=8
			Case 9 RestoreData j9; ACSIZE=9
			Case 12 RestoreData j12; ACSIZE=12
			Case 16 RestoreData j16; ACSIZE=16
			Default aa=False; ACSIZE=0; Return
		End Select

		For Local i=0 Until samples
		
			ReadData j[i,0],j[i,1]
		
		Next

	End Function
	
	Function Wireframe(enable)
	
		If enable
			glPolygonMode(GL_FRONT,GL_LINE)
		Else
			glPolygonMode(GL_FRONT,GL_FILL)
		EndIf

	End Function
	
	Function AmbientLight(r#,g#,b#)
	
		ambient_red#=r#/255.0
		ambient_green#=g#/255.0
		ambient_blue#=b#/255.0
	
	End Function
	
	Function ClearCollisions()
	
		For Local col:TCollisionPair=EachIn TCollisionPair.list
			col=Null
		Next

	End Function

	Function Collisions(src_no,dest_no,method_no,response_no=0)
	
		Local col:TCollisionPair=New TCollisionPair
		col.src_type=src_no
		col.des_type=dest_no
		col.col_method=method_no
		col.response=response_no
		
		' check to see if same collision pair already exists
		For Local col2:TCollisionPair=EachIn TCollisionPair.list
			If col2.src_type=col.src_type
				If col2.des_type=col.des_type
					
					' overwrite old method and response values
					col2.col_method=col.col_method
					col2.response=col.response

					Return

				EndIf
			EndIf
		Next
		
		ListAddLast(TCollisionPair.list,col)
	
	End Function
	
	Function ClearWorld(entities=True,brushes=True,textures=True)
	
		If entities
			
			For Local ent:TEntity=EachIn TEntity.entity_list
				ent.FreeEntity()
				ent=Null
			Next
			
			ClearCollisions
			
			ClearList(TPick.ent_list)
			TPick.picked_ent=Null
			TPick.picked_surface=Null
			
		EndIf
		
		If textures
		
			For Local tex:TTexture=EachIn TTexture.tex_list
				tex.FreeTexture()
			Next
		
		EndIf
	
	End Function
			
	Function UpdateWorld(anim_speed#=1.0)
		
		' collision
		
		UpdateCollisions()
		
		' anim
	
		Local first
		Local last

		For Local mesh:TEntity=EachIn TEntity.entity_list
		
			If mesh.anim And mesh.anim_update=True
			
				first=mesh.anim_seqs_first[mesh.anim_seq]
				last=mesh.anim_seqs_last[mesh.anim_seq]
		
				Local anim_start=False

				If mesh.anim_trans&gt;0
					mesh.anim_trans=mesh.anim_trans-1
					If mesh.anim_trans=1 Then anim_start=True
				EndIf
				
				If mesh.anim_trans&gt;0
				
					Local r#=1.0-mesh.anim_time#
					r#=r#/mesh.anim_trans
					mesh.anim_time#=mesh.anim_time+r#
									
					TAnimation.AnimateMesh2(mesh,mesh.anim_time#,first,last)
					
					If anim_start=True Then mesh.anim_time#=first
			
				Else
				
					TAnimation.AnimateMesh(mesh,mesh.anim_time#,first,last)
					
					If mesh.anim_mode=0 Then mesh.anim_update=False ' after updating animation so that animation is in final 'stop' pose - don't update again
		
					If mesh.anim_mode=1
			
						mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
						If mesh.anim_time#&gt;last
							mesh.anim_time#=first+(mesh.anim_time#-last)
						EndIf
					
					EndIf
					
					If mesh.anim_mode=2
					
						If mesh.anim_dir=1
							mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
							If mesh.anim_time#&gt;last
								mesh.anim_time#=mesh.anim_time#-(mesh.anim_speed#*anim_speed#)
								mesh.anim_dir=-1
							EndIf
						EndIf
						
						If mesh.anim_dir=-1
							mesh.anim_time#=mesh.anim_time#-(mesh.anim_speed#*anim_speed#)
							If mesh.anim_time#&lt;first
								mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
								mesh.anim_dir=1
							EndIf
						EndIf
					
					EndIf
					
					If mesh.anim_mode=3
			
						mesh.anim_time#=mesh.anim_time#+(mesh.anim_speed#*anim_speed#)
						If mesh.anim_time#&gt;last
							mesh.anim_time#=last
							mesh.anim_mode=0
						EndIf
					
					EndIf
					
				EndIf
							
			EndIf
		
		Next
	
	End Function

	Function RenderWorld()

		' if anti-aliasing enabled then call RenderWorldAA
		If aa Then RenderWorldAA();Return

		For Local cam:TCamera=EachIn TCamera.cam_list

			'If cam.parent_hidden=True Or cam.hidden=True Then Continue
			If cam.Hidden()=True Then Continue

			RenderCamera(cam)

		Next

	End Function
	
	' Same as RenderWorld but with anti-aliasing
	Function RenderWorldAA()
		Local inv:Float = 1.0/ACSIZE
		glClear(GL_ACCUM_BUFFER_BIT)
	
		For jitter=0 Until ACSIZE
			For Local cam:TCamera=EachIn TCamera.cam_list
			
				'If cam.parent_hidden=True Or cam.hidden=True Then Continue
				If cam.Hidden()=True Then Continue
			
				RenderCamera(cam)
			
			Next
			glAccum(GL_ACCUM,inv)
		Next
		Rem
		glEnable( GL_TEXTURE_2D )
		Local textureID:Int
		glGenTextures(1, Varptr(textureID) )
  		glBindTexture(GL_TEXTURE_2D, textureID)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
		'glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, Null)
		glBindTexture(GL_TEXTURE_2D, textureID)
		glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 0,0,width, height, 0)	
		Cls
		For jitter=0 Until ACSIZE
			Local jj:Float = -10.0
			'SetColor(45,60,90)
			glLoadIdentity()'' Load the Identity Matrix To reset our drawing locations  
			glTranslatef(0.0, 0.0, 0.0) 
			
			glBindTexture(GL_TEXTURE_2D, textureID) 
			glBegin(GL_QUADS)  
			glTexCoord2f(0.0, 0.0)  
			glVertex3f(0, 0, 0.0) '' The bottom Left corner  
			glTexCoord2f(0.0, 1.0)  
			glVertex3f(0, jj, 0.0) '' The top Left corner  
			glTexCoord2f(1.0, 1.0)  
			glVertex3f(jj, jj, 0.0) '' The top Right corner  
			glTexCoord2f(1.0, 0.0)  
			glVertex3f(jj, 0, 0.0) '' The bottom Right corner  
			glEnd()  
			
			glAccum(GL_ACCUM,inv)
		Next
		EndRem
		jitter=0
		
		glAccum(GL_RETURN,1.0)
		glFlush()

	End Function

	' Render camera - renders all meshes camera can see

	
	Function RenderCamera(cam:TCamera, skip:Int=0)
		Local test:Int =0
		
		If (Not skip) cam.Update()
	
		
		For Local light:TLight=EachIn TLight.light_list
	
			light.Update() ' EntityHidden code inside Update
			
		Next

		Local render_list:TList=CreateList:TList()
		
		For Local mesh:TMesh=EachIn TEntity.entity_list
		
			'If mesh.parent_hidden=True Or mesh.hidden=True Or mesh.brush.alpha=0.0 Then Continue
			If mesh.Hidden()=True Or mesh.brush.alpha=0.0 Then Continue
		
			' get new bounds
			mesh.GetBounds()
	
			' Perform frustum cull
			
			Local inview=cam.EntityInFrustum(mesh)
'Print "**mesh: "+mesh.class+" "+inview
			If inview
				
				If mesh.auto_fade=True Then AutoFade(cam,mesh)
			
				If mesh.Alpha()
			
					mesh.alpha_order#=cam.EntityDistanceSquared#(mesh)
				
				Else
				
					mesh.alpha_order#=0.0
				
				EndIf
			
				RenderListAdd(mesh,render_list)
				
			EndIf
	
		Next

		UpdateSprites(cam,render_list) ' rotate sprites with respect to current cam
		
		' Draw everything in render list
		'For Local mesh2:TMesh=EachIn render_list
		
		''new for shaders
		TShader.RenderBegin()
		
		Local link:TLink = Null
		If render_list Then link= render_list.FirstLink()
		While link
		
			Local mesh2:TMesh=TMesh(link._value)
			
			If link._succ._value&lt;&gt;link._succ 
				link=link._succ
			Else
				link=Null
			End If
	
			
			If TShader.initsh
			
				'' TShader iterrupts fixed function pipeline here
				TShader.Render(mesh2, cam)

			Else
			
				''else continue fixed function pipeline
				mesh2.Update()
				
			EndIf

		'Next
		Wend
		
		If TShader.initsh
			TShader.RenderPostProcess()
		EndIf

	End Function

	
	''ADAMREDWOODS
	''doesn't draw sprites in back of alpha
	Rem
	Function RenderCamera(cam:TCamera, skip:Int=0)

		If (Not skip) cam.Update()
	
		
		For Local light:TLight=EachIn TLight.light_list
	
			light.Update() ' EntityHidden code inside Update
			
		Next

		UpdateSprites(cam,TEntity.entity_list) ' rotate sprites with respect to current cam
		
		' Draw everything in render list
		Local renderlist2:TList = CreateList()
		
		For Local mesh:TMesh=EachIn TEntity.entity_list
			If mesh.Hidden()=True Or mesh.brush.alpha=0.0 Then Continue
			' get new bounds
			mesh.GetBounds()
	
			' Perform frustum cull
			
			Local inview=cam.EntityInFrustum(mesh)

			If inview	
				If mesh.auto_fade=True Then AutoFade(cam,mesh)
			
				If mesh.Alpha()
					mesh.alpha_order#=cam.EntityDistanceSquared#(mesh)
					ListAddLast renderlist2, mesh
					Continue
				Else
					mesh.alpha_order#=0.0	
				EndIf
			
				'RenderListAdd(mesh,render_list)
				mesh.Update()
			EndIf
			
			
			
	
		Next
		
		For Local mesh:TMesh=EachIn renderlist2
			mesh.Update()
		Next

	End Function
	EndRem
	
	Function AutoFade(cam:TCamera,mesh:TMesh)

		Local dist#=cam.EntityDistance#(mesh)
		
		If dist&gt;mesh.fade_near And dist&lt;mesh.fade_far
		
			' fade_alpha will be in the range 0 (near) to 1 (far)
			mesh.fade_alpha=(dist-mesh.fade_near)/(mesh.fade_far-mesh.fade_near)
	
		Else
		
			' if entity outside near, far range then set min/max values
			If dist&lt;mesh.fade_near Then mesh.fade_alpha#=0.0 Else mesh.fade_alpha#=1.0
			
		EndIf

	End Function

	Function GraphicsInit()
	
		TTexture.TextureFilter("",9)
	
		glewInit() ' required for ARB funcs

		' get hardware info and set vbo_enabled accordingly
		THardwareInfo.GetInfo()
		'THardwareInfo.DisplayInfo()
		If USE_VBO=True
			vbo_enabled=THardwareInfo.VBOSupport
		EndIf

		If USE_MAX2D=True

			' save the Max2D settings for later - by Oddball
			glPushAttrib GL_ALL_ATTRIB_BITS
			glPushClientAttrib GL_CLIENT_ALL_ATTRIB_BITS
			glMatrixMode GL_MODELVIEW
			glPushMatrix
			glMatrixMode GL_PROJECTION
			glPushMatrix
			glMatrixMode GL_TEXTURE
			glPushMatrix
			glMatrixMode GL_COLOR
			glPushMatrix
		
		EndIf
		
		EnableStates()
		
		glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,GL_SEPARATE_SPECULAR_COLOR)
		glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_TRUE)

		glClearDepth(1.0)						
		glDepthFunc(GL_LEQUAL)
		glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)

		glAlphaFunc(GL_GEQUAL,0.5)
		
	End Function
	
	Function EnableStates()
	
		glEnable(GL_LIGHTING)
   		glEnable(GL_DEPTH_TEST)
		glEnable(GL_FOG)
		glEnable(GL_CULL_FACE)
		glEnable(GL_SCISSOR_TEST)
		
		glEnable(GL_NORMALIZE)
		
		glEnableClientState(GL_VERTEX_ARRAY)
		glEnableClientState(GL_COLOR_ARRAY)
		glEnableClientState(GL_NORMAL_ARRAY)
	
	End Function
	
	' Adds mesh to a render list, and inserts mesh into correct position within list depending on order and alpha values
	Function RenderListAdd(mesh:TMesh,List:TList)
	
		' if order&gt;0, drawn first (will appear at back of scene)
		' if order&lt;0, drawn last (will appear at front of scene)
	
		Local llink:TLink=list._head ' get start/end link (llink = local link, so as not to clash with entity's link var)
	
		If mesh.order&gt;0

			' --- add first ---
		
			' add entity to start of list
			' entites with order&gt;0 should be added to the start of the list
		
			' cycle fowards through list until we've passed all entities with order&gt;0, or if entity itself has order&gt;0,
			' it's own position within entities with order&gt;0
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=mesh.order
	
			list.InsertBeforeLink(mesh,llink)
			Return
	
		Else If mesh.order&lt;0 ' put entities with order&lt;0 at back of list

			' --- add last ---
	
			' add entity to end of list
			' only entites with order&lt;=0 should be added to the end of the list
		
			' cycle backwards through list until we've passed all entities with order&lt;0, or if entity itself has order&lt;0,
			' it's own position within entities with order&lt;0
			Repeat
				llink=llink._pred
			Until llink=list._head Or TEntity(llink.Value()).order&gt;=mesh.order
	
			list.InsertAfterLink(mesh,llink)
			Return

		EndIf
		
		' order=0
		
		If mesh.alpha_order#&gt;0.0
		
			' add alpha entities to near end of list - before entities with order&lt;0

			Repeat
				llink=llink._pred
				If llink=list._head Then Exit
			Until TEntity(llink.Value()).order&gt;=0 And (TEntity(llink.Value()).alpha_order&gt;=mesh.alpha_order Or TEntity(llink.Value()).alpha_order=0.0)

			list.InsertAfterLink(mesh,llink)
			Return
		
		Else
			
			' normal entities - add to list at start - after entities with order&gt;0
		
			Repeat
				llink=llink._succ
			Until llink=list._head Or TEntity(llink.Value()).order&lt;=0

			list.InsertBeforeLink(mesh,llink)
			Return
			
		EndIf
		
	End Function

	Function UpdateSprites(cam:TCamera,list:TList)

		'For Local sprite:TSprite=EachIn list
		If Not list Return
		Local link:TLink= list.FirstLink()

		While link
			Local sprite:TSprite=TSprite(link._value)
			
			If link._succ._value&lt;&gt;link._succ
				link=link._succ
			Else
			  link=Null
			End If
If Not sprite Continue
			''--end of list breakout
	
			If sprite.view_mode&lt;&gt;2
			
				Local x#=sprite.mat.grid[3,0]
				Local y#=sprite.mat.grid[3,1]
				Local z#=sprite.mat.grid[3,2]
			
				sprite.mat.Overwrite(cam.mat)
				sprite.mat.grid[3,0]=x
				sprite.mat.grid[3,1]=y
				sprite.mat.grid[3,2]=z
				sprite.mat_sp.Overwrite(sprite.mat)
				
				If sprite.angle#&lt;&gt;0.0
					sprite.mat_sp.RotateRoll(sprite.angle#)
				EndIf
				
				If sprite.scale_x#&lt;&gt;1.0 Or sprite.scale_y#&lt;&gt;1.0
					sprite.mat_sp.Scale(sprite.scale_x#,sprite.scale_y#,1.0)
				EndIf
				
				If sprite.handle_x#&lt;&gt;0.0 Or sprite.handle_y#&lt;&gt;0.0
					sprite.mat_sp.Translate(-sprite.handle_x#,-sprite.handle_y#,0.0)
				EndIf
				
			Else
			
				sprite.mat_sp.Overwrite(sprite.mat)
				
				If sprite.scale_x#&lt;&gt;1.0 Or sprite.scale_y#&lt;&gt;1.0
					sprite.mat_sp.Scale(sprite.scale_x#,sprite.scale_y#,1.0)
				EndIf
	
			EndIf

		'Next
		Wend
	
	End Function
				
End Type
</textarea><br><br>test_shader.txt<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
!!ARBvp1.0
#profile arbvp1
# Constant Parameters
PARAM mvp[4] = { state.matrix.mvp }; # Model-view-projection matrix

# Per-vertex inputs
ATTRIB inPosition = vertex.position; #read position 
ATTRIB inColor    = vertex.color; #read color 
ATTRIB inTexCoord = vertex.texcoord; #read uv coordinate 

# Per-vertex outputs 
OUTPUT outPosition = result.position; #set output xyz 
OUTPUT outColor    = result.color; #set output color 
OUTPUT outTexCoord = result.texcoord; #set output uv 

DP4 outPosition.x, mvp[0], inPosition;   # Transform the x component of the per-vertex position into clip-space 
DP4 outPosition.y, mvp[1], inPosition;   # Transform the y component of the per-vertex position into clip-space 
DP4 outPosition.z, mvp[2], inPosition;   # Transform the z component of the per-vertex position into clip-space 
DP4 outPosition.w, mvp[3], inPosition;   # Transform the w component of the per-vertex position into clip-space 

MOV outColor, inColor;       # Pass the color through unmodified 
MOV outTexCoord, inTexCoord; # Pass the texcoords through unmodified 


END

---splithere---
!!ARBfp1.0
#profile arbfp1
#This fragment program makes stripes on geometries
PARAM c = program.local[0]; #Data passed from local param
TEMP colorX; # internal variable

MOV colorX, fragment.texcoord[0].x; #read u-coordinate into colorX
ADD colorX, colorX, fragment.texcoord[0].y; #add v-coordinate to colorX
ADD colorX, colorX, c.x; #add input from local param
MUL colorX, colorX, 25.0; #multiply by 25
FRC colorX, colorX; #leave only fractional part (x MOD 1)
MUL colorX, colorX, 2.0; #multiply by two
FLR colorX, colorX; #leave only integer part (x = floor(x))

MOV result.color, colorX; #move colorX into result color (rgba)

MOV result.color.a, 1; # set alpha to 1.0

END
</textarea><br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1163413"></a>

<a name="1163420"></a>

<a name="1163422"></a>

<a name="1163423"></a>

<a name="1163425"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ferret</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> This might help.<br><br>First load a shader.<br>Bind the shader just before RenderWorld().<br>Unbind the shader just after RenderWorld().<br><br>This will affect the complete world, single meshes or surfaces is a litle more work.<br><br>TShader.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Type TShader
	Field Vertex:Int, Fragment:Int, Program:Int
	Field IntList:Int[5]
	Field FloatList:Float[5]
	Field TextureList:TTexture[5]
End Type
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_LoadShader:TShader(vertfile:String,fragfile:String)
	Local vfile:String
	Local ffile:String
	
	Local vertstring:Byte Ptr
	Local fragstring:Byte Ptr
	
	Local shader:TShader
	
	vfile= LoadText(vertfile)
	ffile= LoadText(fragfile)
	
	vertstring = vfile.ToCString()
	fragstring = ffile.ToCString()
	
	shader = New TShader
	
	shader.Vertex = glCreateShader(GL_VERTEX_SHADER)
	shader.Fragment = glCreateShader(GL_FRAGMENT_SHADER)
	
	glShaderSource(shader.Vertex, 1, Varptr(vertstring),Null)
	glShaderSource(shader.Fragment, 1, Varptr(fragstring),Null)
	
	glCompileShader(shader.Vertex)
	glCompileShader(shader.Fragment)
	
	shader.Program = glCreateProgram()
	
	glAttachShader(shader.Program,shader.Vertex)
	glAttachShader(shader.Program,shader.Fragment)
	
	glLinkProgram(shader.Program)
	
	glUseProgram(0)
	
	vfile = Null
	ffile = Null
	
	vertstring = Null
	fragstring = Null
	
	Return shader
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_FreeShader:Int(shader:TShader)
	glDetachShader(shader.Program,shader.Vertex)
	glDetachShader(shader.Program,shader.Fragment)
	glDeleteShader(shader.Vertex)
	glDeleteShader(shader.Fragment)
	glDeleteProgram(shader.Program)

	Return 0
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_BindShader:Int(shader:TShader)
	If USE_SHADERS
		glUseProgram(shader.Program)
	
		If shader.IntList[0] Then glUniform1i(glGetUniformLocation(shader.Program, "integerA"),shader.IntList[0])
		If shader.IntList[1] Then glUniform1i(glGetUniformLocation(shader.Program, "integerB"),shader.IntList[1])
		If shader.IntList[2] Then glUniform1i(glGetUniformLocation(shader.Program, "integerC"),shader.IntList[2])
		If shader.IntList[3] Then glUniform1i(glGetUniformLocation(shader.Program, "integerD"),shader.IntList[3])
		If shader.IntList[4] Then glUniform1i(glGetUniformLocation(shader.Program, "integerE"),shader.IntList[4])
			
		If shader.FloatList[0] Then glUniform1i(glGetUniformLocation(shader.Program, "floatA"),shader.FloatList[0])
		If shader.FloatList[1] Then glUniform1i(glGetUniformLocation(shader.Program, "floatB"),shader.FloatList[1])
		If shader.FloatList[2] Then glUniform1i(glGetUniformLocation(shader.Program, "floatC"),shader.FloatList[2])
		If shader.FloatList[3] Then glUniform1i(glGetUniformLocation(shader.Program, "floatD"),shader.FloatList[3])
		If shader.FloatList[4] Then glUniform1i(glGetUniformLocation(shader.Program, "floatE"),shader.FloatList[4])
			
		If shader.TextureList[0] Then glUniform1i(glGetUniformLocation(shader.Program, "textureA"),shader.TextureList[0].id)
		If shader.TextureList[1] Then glUniform1i(glGetUniformLocation(shader.Program, "textureB"),shader.TextureList[1].id)
		If shader.TextureList[2] Then glUniform1i(glGetUniformLocation(shader.Program, "textureC"),shader.TextureList[2].id)
		If shader.TextureList[3] Then glUniform1i(glGetUniformLocation(shader.Program, "textureD"),shader.TextureList[3].id)
		If shader.TextureList[4] Then glUniform1i(glGetUniformLocation(shader.Program, "textureE"),shader.TextureList[4].id)
		
		
	EndIf
		
	Return 0
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_UnBindShader:Int()
	glUseProgram(0)
	
	Return 0
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_ShaderTexture:Int(shader:TShader,texture:TTexture,index:Int=0)
	shader.TextureList[index] = texture
	
	Return 0
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_ShaderInt:Int(shader:TShader,value:Int,index:Int=0)
	shader.IntList[index] = value
	
	Return 0
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function FE_ShaderFloat:Int(shader:TShader,value:Float,index:Int=0)
	shader.FloatList[index] = value
	
	Return 0
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
</textarea><br><br><br>The shader below colors everything green, so when you see allot of green it works :-)<br><br>Shader.vert<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
void main(void)
{
	gl_Position = ftransform();
	
}
</textarea><br><br>Shader.frag<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
void main (void)
{
	gl_FragColor = vec4(0.0,1.0,0.0, 1.0);
}
</textarea><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
