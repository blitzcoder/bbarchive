<!DOCTYPE html><html lang="en" ><head ><title >how to speed up hundreds of sprites?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >how to speed up hundreds of sprites?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=119" >MiniB3D Module</a>/<a href="#bottom" >how to speed up hundreds of sprites?</a><br><br>
<a name="1299757"></a>

<a name="1299758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm creating a racing game on an 3D-terrain with a lot of trees on it. The trees are only sprites all created  from the same pixmap with 256x256pix. Without the trees the game needs 1msec per flip-cycle. Now I'm positioning 300 trees and the performance goes down to 45msec per flip. What do I wrong? Is there a way to speed up a lot of same sprites?<br><br>this is my code:<br><pre class=code>	Local oak:TSprite=LoadSprite(imagePfad + "oak.png",2)
	Oak.SpriteViewmode 1
	oak.HandleSprite 0,-1
	Oak.ScaleSprite 1,3
'
	For Local i%=0 To 300
		Oak.ScaleSprite Rnd(1,3),Rnd(1,3)
		Local loc:TEntity=CopyEntity(oak)
		loc.Scaleentity Rnd(1,2),Rnd(1,2),0
		loc.PositionEntity Rnd(300),0,Rnd(300)
		loc.Entitycolor 155+Rnd(100),155+Rnd(100),0
	Next
</pre><br><br>The performance is also down even when not a single one of the trees is in the camera view. <br><br></td></tr></table><br>
<a name="1299759"></a>

<a name="1299760"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I assume this piece of code is not in your main loop, otherwise, problem fixed ;)<br><br>What happens if you disable alpha on oak.png, does that speed the program up? <br>Or using a 64x64 png? <br><br></td></tr></table><br>
<a name="1299813"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1. Of course sprites are created before main loop starts.<br>2. Changing blendmode did not speed up.<br>3. changing pixmap size to 64x64 did not speed up<br><br>I do not understand the fall off... 300 trees are only 600 triangles. A single 3D modell with 600 triangles would be called "low-poly" and would not cause problems.... <br><br>Is there a problem with 300 surfaces?<br><br>How to optimize something like that? Would it be useful to combine all trees to one mesh/surface?<br><br>(I have to tell, that the graphic device is a Nvidia Gforce 7300gs. Not really a new one....) <br><br></td></tr></table><br>
<a name="1299823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >angros47</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> In OpenB3D and in iMiniB3D it's possible to use batch sprites, that are much faster because only one surface is used. <br><br></td></tr></table><br>
<a name="1299824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes you could try OpenB3d, it could be (best case scenario) you'll only need to change your imported module so changing back and forth will be easily possible.<br><br>Still a weird problem though, especially if the sprites are not even in view. Why should that bother your videocard at all... <br><br>Maybe change the sprites for 4 polygon cross trees, and join them by using the Addmesh() command? I think that should mimic having a single, one surfaced mesh. <br><br></td></tr></table><br>
<a name="1299836"></a>

<a name="1299843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think it's bothering the CPU.<br>The sprites are not in view but they're all still tested for visibility at every RenderWorld.<br><br>Using AddMesh like suggested should improve it, since it'll be a single visibility test instead of 300. <br><br></td></tr></table><br>
<a name="1299889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> it looks like it is not the CPU but the graphic card. When I hide all trees, the CPU works on nearly 100% and the game runs perfect. When I show all trees the game runs like slow motion, but the CPU has 50% prozessor load...<br><br>All the trees need to face towards the camera. Sprite ViewMode=1. So it is difficult to replace it with single surface, or? Will this single surface also have this feature?<br><br>It looks like MidiB3D does not really check, whether a tree is in camera view or not. I recognize that performance also goes down, when all trees are behind camera.<br><br>test results:<br><br>000 trees with HideEntity() need 1msec<br>400 trees with HideEntity() need 3msec<br>400 colored sprites without Texture need 16msec<br>400 textured sprites need 47msec<br><br>I read something about VBOs. Could they help me? <br><br>I read something about Klepto's TFastSprite. Is it stillvaiable? He was not here in forum the last threee years...<br><br>I found this: <a href="http://www.blitzbasic.com/Community/post.php?topic=68860&amp;post=769657" target="_blank">http://www.blitzbasic.com/Community/post.php?topic=68860&amp;post=769657</a><br><br>I now try to build a "in sight check" by my own. I think it will be a workaround but not a solution. <br><br></td></tr></table><br>
<a name="1299891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>it looks like it is not the CPU but the graphic card. When I hide all trees, the CPU works on nearly 100% and the game runs perfect.<br> <br></div><br>CPU could still be part of the problem though: it will then skip checks like EntityInView.<br><br><div class="quote"> <br>Sprite ViewMode=1. So it is difficult to replace it with single surface, or?<br> <br></div><br>Yep, which is why I suggested using cross polygons ;)<br><br><br>TFastSprite: I think OpenB3d already has something similar built in, you could try that. <br><br></td></tr></table><br>
<a name="1299892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >angros47</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> The fastest way to render many sprites, all facing the camera, is using point sprites, but not all opengl versions support them <br><br></td></tr></table><br>
<a name="1299893"></a>

<a name="1299894"></a>

<a name="1299903"></a>

<a name="1299904"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can assure you its not the GPU that is the limiting factor here.<br>Its MiniB3D itself that just doesnt like too many Entities, since it does a lot of work for each one and is rather inefficient in places.<br>Hiding an entity allows MiniB3D to skip most of that work, which is why its faster when doing it.<br><br>But it also depends on which version of MiniB3D your using i guess. As my modified copy of klepto.MinB3dExtNew (the one that includes batchsprites), frustrum culling works as intended and entities out of view cost very little.<br><br>After some testing on my Skylake 6700K + AMD R390, with 1300 sprites on the screen:<br>FrustrumCulling eats maybe 2ms.<br>UpdateSprites is virtually free.<br>Alpha/Order testing and the respective sorting in the render list eats about 7ms.<br>So it looks to be the sheer number of Draw calls and all the setup around each entity that is the bottleneck, IE the driver and consequently the CPU.<br><br>I chose 1300 as that is the max entities i can have on screen and still target 16ms per frame.<br><br>My test, press SPACE to check frustrum culling. Mine jumps from 16 to 0ms when only the dummy cube is shown.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Graphics3D 800,600, 32, 2

Local center:TPivot = CreatePivot()
Local cam:TCamera = CreateCamera(center)
MoveEntity cam, 0,0,-10

Local dummy:TMesh = CreateCube()
MoveEntity dummy, 0,20,0
HideEntity dummy

Local sprites:TSprite[1300]
For Local i:Int = 0 Until sprites.Length
	sprites[i] = LoadSprite( "c:\dump\test2.png", 2|4)
	sprites[i].PositionEntity Rnd(-6,6),Rnd(-6,6), 0
Next

Local frametimer:TTimer = New TTimer
Local rendertimer:TTimer = New TTimer
Repeat
	frametimer.Start()
	
	If KeyHit(KEY_SPACE) Then
		If dummy.Hide Then
			ShowEntity dummy
			MoveEntity cam, 0,20,0
		Else
			HideEntity dummy
			MoveEntity cam, 0,-20,0
		EndIf
	EndIf
	
	TurnEntity center, 0,0.5,0
	
	rendertimer.Start()
	RenderWorld
	rendertimer.Stop()
	
	GLDrawText frametimer.GetString("Frame"), 0,0
	GLDrawText rendertimer.GetString("Render"), 0,16
	Flip 0
	
	frametimer.Stop()
Until AppTerminate() Or KeyHit(KEY_ESCAPE)
End

Type TTimer
	Field Curr:Int
	Field Last:Int	
	Field Total:Int
	Field Count:Int
	
	Method Start()
		Curr = MilliSecs()
	EndMethod
	
	Method Stop()
		Last = MilliSecs() - Curr
		Total :+ Last
		Count :+ 1
		If Count &lt; 0 Then
			Total = 0
			Count = 0
		EndIf
	EndMethod
	
	Method GetString:String( title:String = Null)
		Local s:String
		If title Then s = title + ": "
		s :+ "time=" + String.FromInt(Last)[..5] + " average="
		If Count = 0 Then
			s :+ "0   "
		Else
			s :+ String.FromInt(Total / Count)[..5]
		EndIf
		Return s
	EndMethod
EndType
</textarea> <br><br></td></tr></table><br>
<a name="1299937"></a>

<a name="1299938"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you for your help and responses. It aleays points me to new ideas. Please continue....<br><br>I know only a little about 3D and advanced technics. So some terms are new to me. Is "Frustum culling" what I call "in camera view"? What is "cross polygons"? What are "point sprites"?<br><br>@Angros47<br>your signatur contains "OpenB3D: Minib3d for open-source languages." Do you know more about it? Is OpenB3D a complete replacement for MiniB3D? Will it still be continued? Why do i need a wrapper? Is there a project page?<br><br>Back to my trees.... New test brought out this:<br><br>MiniB3D is very poor in finding out, what is behind camera. If I check the "in camera view" by myself, I need 1msec for that. Here I hide all tree sprites which are more than 47° left or right away from my camera direction<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">	Type TTree
	Global Liste:TList= New TList
	Global oak:TSprite
	Field x#, z#, Sprite:TEntity

....

	Function Add:TTree(x#, y#, z#, b#, h#)
		Local loc:TTree=New TTree
		loc.Sprite=CopyEntity(oak)
		loc.Sprite.ScaleEntity b, h, 0
		loc.x=x
		loc.z=z
		loc.Sprite.PositionEntity x,y,z
		loc.Sprite.Entitycolor 155+Rnd(100),155+Rnd(100),0
		Liste.addlast loc
	End Function



	Function CheckAll()
			Local cameraX#=Camera.EntityX(True)
			Local cameraZ#=Camera.EntityZ(True)
			Local cameraAngle%=(360 + Camera.EntityYaw(True)) Mod 360
	
			For Local loc:TTree=EachIn Liste
				Local angle%=(360-ATan2(loc.X-cameraX ,loc.Z-cameraZ)) Mod 360
				If Abs(angle-cameraAngle)&lt;47
					loc.Sprite.ShowEntity	  			
				Else
					loc.Sprite.HideEntity
				EndIf
			Next
	End Function 
	
End Type
</textarea><br>... but this brings me back to below 16msec. <br><br></td></tr></table><br>
<a name="1300186"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >angros47</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Since I am the main developer of OpenB3D, yes, I know more about it. As you might know, Simon Harris wrote years ago a version of MiniB3D for the iphone, called iMiniB3D. I forked it, porting back to the pc, and added some features. The main difference with MiniB3D is that OpenB3D is written in C++, non in BlitzMax (hence the need of a wrapper). There is a thread on this section, and another thread in FreeBasic website. The main page is on sourceforge. OpenB3D supports all features of vanilla MiniB3D, plus a lot of extensions: terrains, quaternion-based rotations, shadows, shaders, and much more. <br><br></td></tr></table><br>
<a name="1300303"></a>

<a name="1300304"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> First a tip: don't use alpha sprites, use masked sprites with Flag 4 instead, they are much faster and nearly look the same from a distance.<br><br>As a multi-purpose sprite replacement I'm using my own single surface TQuad Type which is still in WIP, but here's a quick example (use WASD/Mouse to fly around and beware: Flip is off):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Framework sidesign.minib3d

Graphics3D 1024, 600, 32, 2

' Camera
Local CAMERA:TCam = New TCam
CAMERA.add()
CAMERA.speed = 0.01
CAMERA.RangeMin = 0.01
CAMERA.RangeMax = 10000

Local q:TQuad
Local quadlist:TList = CreateList()
Local mesh:TMesh = CreateMesh()
Local surf:TSurface = CreateSurface(mesh)

For Local i:Int = 1 To 10000

	q = New TQuad
	q.mesh = mesh
	q.surf = surf
	
	Local s:Float = Rnd(0.5, 5)
	
	q.scalex = s
	q.scaley = s
	q.x = Rnd(-1000, 1000)
	q.y = Rnd(-1000, 1000)
	q.z = Rnd(-1000, 1000)
	
	q.add()
	
	ListAddLast(quadlist, q)
	
Next

MoveMouse GraphicsWidth() / 2, GraphicsHeight() / 2

Repeat

	If KeyHit(KEY_ESCAPE) Then End

	CAMERA.Move
	CAMERA.Update
	
	Local ms:Int = MilliSecs()
	
	For Local q:TQuad = EachIn quadlist

		q.Update(CAMERA.cam)
	
	Next
	
	RenderWorld
	
	Text 0,0,MilliSecs()-ms+"ms"
	
	Flip False

Forever

End


' ------------------------------------------------------------------------------------------------
' Quad Type
' ------------------------------------------------------------------------------------------------
Type TQuad

	Field x:Float = 0.0										' position x
	Field y:Float = 0.0										' position y
	Field z:Float = 0.0										' position z
	
	Field pitch:Float = 0.0
	Field yaw:Float = 0.0
	Field roll:Float = 0.0
	
	Field row:Int = 0										' texture row
	Field col:Int = 0										' texture column
	Field cat:String = ""
	
	Field size:Float = 1.0									' base size
	Field scale:Float = 1.0									' base scale
	Field scalex:Float = 1.0								' current size X
	Field scaley:Float = 1.0								' current size Y
	Field distance:Float = 0.0								' distance to cam
	Field Hidden:Int = 0									' hidden flag
	Field vanish:Float = 1.0								' vanish rate
	Field expanding:Float = 1.0								' expand rate
	
	Field RGB:Int[] = [255, 255, 255, 255]					' star vertex color

	Field RGB1:Int[] = [255, 255, 255, 255]					' nebula vertex color
	Field RGB2:Int[] = [255, 255, 255, 255]					' nebula vertex color
	Field RGB3:Int[] = [255, 255, 255, 255]					' nebula vertex color
	Field RGB4:Int[] = [255, 255, 255, 255]					' nebula vertex color

	Field Alpha:Float = 1.0									' vertex alpha
	Field Alpha1:Float = 1.0								' vertex alpha #1
	Field Alpha2:Float = 1.0								' vertex alpha #2
	Field Alpha3:Float = 1.0								' vertex alpha #3
	Field Alpha4:Float = 1.0								' vertex alpha #4

	Field v:Int = 0											' vertex counter
	Field mesh:TMesh = Null									' mesh pointer
	Field surf:TSurface = Null								' surface pointer

	Field rotation:Float
				
	Global temp:TPivot = CreatePivot()


	' --------------------------------------------------------------------------------------------
	' METHOD: Add new Quad
	' --------------------------------------------------------------------------------------------
	Method Add(col:Int = 0, row:Int = 0)

		' surface setup
		If surf = Null Then surf = surf
		If v + 4 &gt; 32768 Then
			v = 0
			surf = CreateSurface(mesh)
		EndIf

		' add Vertices
		Local V0:Int = AddVertex(surf, 0, 0, 0, 1, 0)
		Local V1:Int = AddVertex(surf, 0, 0, 0, 1, 1)
		Local V2:Int = AddVertex(surf, 0, 0, 0, 0, 1)
		Local V3:Int = AddVertex(surf, 0, 0, 0, 0, 0)

		' color vertices
		VertexColor surf, V0, RGB[0], RGB[1], RGB[2], Alpha
		VertexColor surf, V1, RGB[0], RGB[1], RGB[2], Alpha
		VertexColor surf, V2, RGB[0], RGB[1], RGB[2], Alpha
		VertexColor surf, V3, RGB[0], RGB[1], RGB[2], Alpha

		' connect triangles
		AddTriangle surf, V0, V1, V2
		AddTriangle surf, V0, V2, V3
		
		VertexTexCoords surf, V0, col + 1, row
		VertexTexCoords surf, V1, col + 1, row + 1
		VertexTexCoords surf, V2, col, row + 1
		VertexTexCoords surf, V3, col, row

		' increase vertex counter
		If v &gt;= 4 Then v = V0 + 4 Else v = V0

	End Method



	' --------------------------------------------------------------------------------------------
	' METHOD: Hide a Quad
	' --------------------------------------------------------------------------------------------
	Method Hide()

		distance = 2 ^ 32

		' set vertices
		VertexCoords surf, v + 0, distance, distance, distance
		VertexCoords surf, v + 1, distance, distance, distance
		VertexCoords surf, v + 2, distance, distance, distance
		VertexCoords surf, v + 3, distance, distance, distance

		hidden = 1

	End Method



	' --------------------------------------------------------------------------------------------
	' METHOD: Update a Quad
	' --------------------------------------------------------------------------------------------
	Method Update(target:TEntity)
	
		If Alpha &lt;= 0 Then
		
			Hide
			hidden = 1
						
		Else

			TFormVector scalex, 0, 0, target, Null
			Local X1:Float = TFormedX()
			Local Y1:Float = TFormedY()
			Local Z1:Float = TFormedZ()
	    
			TFormVector 0, scaley, 0, target, Null
			Local X2:Float = TFormedX()
			Local Y2:Float = TFormedY()
			Local Z2:Float = TFormedZ()
			
			' set vertices
			VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
			VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
			VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
			VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
		
			' set colors
			VertexColor surf, v + 0, RGB[0], RGB[1], RGB[2], Alpha
			VertexColor surf, v + 1, RGB[0], RGB[1], RGB[2], Alpha
			VertexColor surf, v + 2, RGB[0], RGB[1], RGB[2], Alpha
			VertexColor surf, v + 3, RGB[0], RGB[1], RGB[2], Alpha
			
			hidden = 0

		EndIf
			
	End Method

	
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateAlpha(a:Float = 1.0)
	
		' set colors
		VertexColor surf, v + 0, RGB[0], RGB[1], RGB[2], Alpha1 * a
		VertexColor surf, v + 1, RGB[0], RGB[1], RGB[2], Alpha2 * a
		VertexColor surf, v + 2, RGB[0], RGB[1], RGB[2], Alpha3 * a
		VertexColor surf, v + 3, RGB[0], RGB[1], RGB[2], Alpha4 * a
			
	End Method

	
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateAllAlpha(a:Float = 1.0)
	
		' set colors
		VertexColor surf, v + 0, RGB[0], RGB[1], RGB[2], a
		VertexColor surf, v + 1, RGB[0], RGB[1], RGB[2], a
		VertexColor surf, v + 2, RGB[0], RGB[1], RGB[2], a
		VertexColor surf, v + 3, RGB[0], RGB[1], RGB[2], a
			
	End Method
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateVertexColors(r:Int = 255, g:Int = 255, b:Int = 255, a:Float = 1.0)
	
		' set colors
		VertexColor surf, v + 0, r, g, b, a * Alpha
		VertexColor surf, v + 1, r, g, b, a * Alpha
		VertexColor surf, v + 2, r, g, b, a * Alpha
		VertexColor surf, v + 3, r, g, b, a * Alpha
			
	End Method
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateScale()
	
		PositionEntity temp, x, y, z
		RotateEntity temp, pitch, yaw, roll
	
		TFormVector scalex, 0, 0, temp, Null
		Local X1:Float = TFormedX()
		Local Y1:Float = TFormedY()
		Local Z1:Float = TFormedZ()
    
		TFormVector 0, scaley, 0, temp, Null
		Local X2:Float = TFormedX()
		Local Y2:Float = TFormedY()
		Local Z2:Float = TFormedZ()
		
		' set vertices
		VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
		VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
		VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
		VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
			
	End Method
		
	
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update a Quad
	' --------------------------------------------------------------------------------------------
	Method UpdateRotation(target:TEntity)
	
		Local PIVOT:TPivot = CreatePivot()
	
		If (Alpha1 + Alpha2 + Alpha3 + Alpha4) &lt;= 0 Then
			
			Hide
			
		Else
					
			PositionEntity PIVOT, x, y, z
	
			PointEntity PIVOT, target
			RotateEntity PIVOT, EntityPitch(target), EntityYaw(target), rotation
			
			TFormVector scalex, 0, 0, PIVOT, Null
			Local X1:Float = TFormedX()
			Local Y1:Float = TFormedY()
			Local Z1:Float = TFormedZ()
	    
			TFormVector 0, scaley, 0, PIVOT, Null
			Local X2:Float = TFormedX()
			Local Y2:Float = TFormedY()
			Local Z2:Float = TFormedZ()
			
			' set vertices
			VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
			VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
			VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
			VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
		
			' set colors
			VertexColor surf, v + 0, RGB1[0], RGB1[1], RGB1[2], Alpha1
			VertexColor surf, v + 1, RGB2[0], RGB2[1], RGB2[2], Alpha2
			VertexColor surf, v + 2, RGB3[0], RGB3[1], RGB3[2], Alpha3
			VertexColor surf, v + 3, RGB4[0], RGB4[1], RGB4[2], Alpha4
			
		End If
		
		FreeEntity PIVOT

	End Method

	Method AlignToTarget(x:Float, y:Float, z:Float, angle:Float = 0.0)
	
		Local PIVOT:TPivot = CreatePivot()
	
		PositionEntity PIVOT, x, y, z
					
		Local yaw:Float,pitch:Float,roll:Float
		Local x1:Float,y1:Float,z1:Float
		Local x2:Float,y2:Float,z2:Float
		Local x3:Float,y3:Float,z3:Float
		
		yaw=-ATan2(x,z)
		
		x1=z*Sin(yaw)+x*Cos(yaw)
		y1=y	
		z1=z*Cos(yaw)-x*Sin(yaw)
		
		pitch=-ATan2(y1,z1)
	
		x2=x1
		y2=y1*Cos(pitch)-z1*Sin(pitch)
		z2=y1*Sin(pitch)+z1*Cos(pitch)
		
		roll= -ATan2(x2, y2)
	
		x3=x2*Cos(roll)-y2*Sin(roll)
		y3=x2*Sin(roll)+y2*Cos(roll)
		z3=z2
	
		If y&lt;0 Then roll:+180
		
		RotateEntity PIVOT, pitch, yaw, roll + angle

		TFormVector scalex, 0, 0, PIVOT, Null
		x1 = TFormedX()
		y1 = TFormedY()
		z1 = TFormedZ()
	    
		TFormVector 0, scaley, 0, PIVOT, Null
		x2 = TFormedX()
		y2 = TFormedY()
		z2 = TFormedZ()
			
		' set vertices
		VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
		VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
		VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
		VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
		
		' set colors
		VertexColor surf, v + 0, RGB1[0], RGB1[1], RGB1[2], Alpha1
		VertexColor surf, v + 1, RGB2[0], RGB2[1], RGB2[2], Alpha2
		VertexColor surf, v + 2, RGB3[0], RGB3[1], RGB3[2], Alpha3
		VertexColor surf, v + 3, RGB4[0], RGB4[1], RGB4[2], Alpha4
		
		FreeEntity PIVOT
				
	End Method
	
End Type

Type TCam

	Field cam:TCamera										' camera entity
	Field parent:TEntity									' camera parent

	Field X:Float = 0.0										' Position X
	Field Y:Float = 0.0										' Position Y
	Field Z:Float = 0.0										' Position Z

	Field OX:Float = 0.0									' Old Position X
	Field OY:Float = 0.0									' Old Position Y
	Field OZ:Float = 0.0									' Old Position Z

	Field OPitch:Float = 0.0								' Old Pitch
	Field OYaw:Float = 0.0									' Old Yaw
	Field ORoll:Float = 0.0									' Old Roll
	
	Field Pitch:Float = 0.0									' Pitch
	Field Yaw:Float = 0.0									' Yaw
	Field Roll:Float = 0.0									' Roll

	Field CLScolor:Int[] = [0, 0, 0]						' Background color
	Field FOGcolor:Int[] = [0, 0, 0]						' Fog color
		
	Field FieldofView:Float = 90.0							' Field of View
	Field FOGmode:Int = False								' Fog Mode
	Field Zoom:Float = 1.0									' Zoom factor

	Field RangeMin:Float = 1.0								' Frustum start
	Field RangeMax:Float = 10000.0							' Frustum end
	Field FOGrangeMin:Float = 1.0							' Fog Frustum start
	Field FOGrangeMax:Float = 10000.0						' Fog Frustum end
	
	Field ViewX:Int = 0										' Viewport X Position
	Field ViewY:Int = 0										' Viewport Y Position
	Field Width:Int = GraphicsWidth()						' Viewport width
	Field Height:Int = GraphicsHeight()						' Viewport height
	
	Field PX:Int											' Projected X
	Field PY:Int											' Projected Y
	
	Const QuatToEuler:Double = 0.00001
	
	Field Speed:Float = 0.1									' Camera Movespeed
	Field RollSpeed:Float = 0.5								' Camera Rollspeed
	Field TurnSpeed:Float = 2.00							' Camera Turnspeed (Mousemove)
	Field Sensitivity:Float = 1.25							' Overall Camera Sensitivity
	
	Field CurrentSpeed:Float								' Current Movespeed
	
	Field Xspeed:Float										' Current X-Vector Speed
	Field Yspeed:Float										' Current Y-Vector Speed
	Field Zspeed:Float										' Current Z-Vector Speed
	
	Field Glob:Int = False									' Local/Global flag


	' --------------------------------------------------------------------------------------------
	' Add new camera
	' --------------------------------------------------------------------------------------------
	Method Add()
	
		cam = CreateCamera(parent)
		
	End Method
	
	' --------------------------------------------------------------------------------------------
	' Show Camera
	' --------------------------------------------------------------------------------------------
	Method Show()
	
		ShowEntity cam
	
	End Method

	' --------------------------------------------------------------------------------------------
	' Hide Camera
	' --------------------------------------------------------------------------------------------
	Method Hide()
	
		HideEntity cam
	
	End Method

	' ----------------------------------------------------------------------------
	' Free Camera movment using Quaternion rotations
	' ----------------------------------------------------------------------------
	Method Move()
		
		Local rolling:Float, tx:Float, ty:Float, Pos:Float
			
		CurrentSpeed:+((KeyDown(KEY_W) - KeyDown(KEY_S)) * Speed)
		
		'CurrentSpeed:*1.0 - (KeyDown(KEY_S) / 25.0)
	
		rolling = (KeyDown(KEY_A) - KeyDown(KEY_D)) * RollSpeed
		
		tx = Normalize(MouseX(), 0, GraphicsWidth(), 1, -1)
		ty = Normalize(MouseY(), 0, GraphicsHeight(), -1, 1)
		
		If ty &lt; 0 Then ty = (Abs(ty) ^ sensitivity) * -1 Else ty = ty ^ sensitivity
		If tx &lt; 0 Then tx = (Abs(tx) ^ sensitivity) * -1 Else tx = tx ^ sensitivity
		
		xspeed = ty * TurnSpeed
		yspeed = tx * TurnSpeed
		zspeed = (rolling * TurnSpeed)
		
		If KeyDown(KEY_X) Then
		
			CurrentSpeed:*0.9
			
			If CurrentSpeed &gt; 0 And CurrentSpeed &lt; 0.01 Then CurrentSpeed = 0.0
			If CurrentSpeed &lt; 0 And CurrentSpeed &gt; - 0.01 Then CurrentSpeed = 0.0
						
		EndIf
		
		MoveEntity cam, 0, 0, currentspeed
						
		Local Quat:TQuaternion = EulerToQuat(0.0, 0.0, 0.0)
		Local Turn_Quat:TQuaternion = EulerToQuat(0.0, 0.0, 0.0)

		If Glob = False
		
			Quat = EulerToQuat(EntityPitch(cam, True), EntityYaw(cam, True), EntityRoll(cam, True))
			Turn_Quat = EulerToQuat(Xspeed, Yspeed, Zspeed)
			Quat = MultiplyQuats( Quat, Turn_Quat )
			Quat = NormalizeQuat( Quat )
			QuatToEuler2(Quat.x, Quat.y, Quat.z, Quat.w, Pitch, Yaw, Roll)
						
		Else
	
			Pitch:+Xspeed
			yaw:+Yspeed
			Roll:+zspeed
			
		EndIf
		
		RotateEntity cam, pitch, yaw, roll
				
		'Update

	End Method

	' --------------------------------------------------------------------------------------------
	' Update Camera
	' --------------------------------------------------------------------------------------------
	Method Update()

		OX = EntityX(cam)
		OY = EntityY(cam)
		OZ = EntityZ(cam)

		OPitch = EntityPitch(cam)
		OYaw = EntityYaw(cam)
		ORoll = EntityRoll(cam)
	
		'PositionEntity cam, x, y, z
		'RotateEntity cam, pitch, yaw, roll
		CameraRange cam, rangemin, rangemax
		CameraFogRange cam, FOGrangemin, FOGrangemax
		CameraClsColor cam, CLScolor[0], CLScolor[1], CLScolor[2]
		CameraZoom cam, zoom
		CameraViewport cam, viewx, viewy, width, Height
	
	End Method
	
	' --------------------------------------------------------------------------------------------
	' Update Camera Position
	' --------------------------------------------------------------------------------------------
	Method UpdatePosition()

		PositionEntity cam, x, y, z
	
	End Method
	
	Method Moved:Int()
	
		If (ox &lt;&gt; x) Or (oy &lt;&gt; y) Or (oz &lt;&gt; z) Then Return True
		
		Return False
			
	End Method
	
	' --------------------------------------------------------------------------------------------
	' Calculate Screen Projection coordinates
	' --------------------------------------------------------------------------------------------
	Method Project(x:Float = 0.0, y:Float = 0.0, z:Float = 0.0)
		
		CameraProject cam, x, y, z
		PX = ProjectedX()
		PY = ProjectedY()
	
	End Method
		
	' --------------------------------------------------------------------------------------------
	' Store current camera position
	' --------------------------------------------------------------------------------------------
	Method GetCameraPosition(glob:Int = False)
	
		X = EntityX(cam, glob)
		Y = EntityY(cam, glob)
		Z = EntityZ(cam, glob)
					
	End Method

	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function EulerToQuat:TQuaternion(pitch:Float,yaw:Float,roll:Float)
	
		Local cr:Float=Cos(-roll/2.0)
		Local cp:Float=Cos(pitch/2.0)
		Local cy:Float=Cos(yaw/2.0)
		Local sr:Float=Sin(-roll/2.0)
		Local sp:Float=Sin(pitch/2.0)
		Local sy:Float=Sin(yaw/2.0)
		Local cpcy:Float=cp*cy
		Local spsy:Float=sp*sy
		Local spcy:Float=sp*cy
		Local cpsy:Float=cp*sy
		
		Local q:TQuaternion=New TQuaternion
		
		q.w:Float=cr*cpcy+sr*spsy
		q.x:Float=sr*cpcy-cr*spsy
		q.y:Float=cr*spcy+sr*cpsy
		q.z:Float=cr*cpsy-sr*spcy
		
		Return q
		
	End Function
	
	
	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function QuatToEuler2(x:Float,y:Float,z:Float,w:Float,pitch:Float Var,yaw:Float Var,roll:Float Var)
	
		Local sint:Float=(2.0*w*y)-(2.0*x*z)
		Local cost_temp:Float=1.0-(sint*sint)
		Local cost:Float
	
		If Abs(cost_temp)&gt;QuatToEuler
	
			cost=Sqr(cost_temp)
	
			Else
	
			cost=0.0
	
		EndIf
	
		Local sinv:Float,cosv:Float,sinf:Float,cosf:Float
		
		If Abs(cost)&gt;QuatToEuler
		
			sinv=((2.0*y*z)+(2.0*w*x))/cost
			cosv=(1.0-(2.0*x*x)-(2.0*y*y))/cost
			sinf=((2.0*x*y)+(2.0*w*z))/cost
			cosf=(1.0-(2.0*y*y)-(2.0*z*z))/cost
			
		Else
			
			sinv=(2.0*w*x)-(2.0*y*z)
			cosv=1.0-(2.0*x*x)-(2.0*z*z)
			sinf=0.0
			cosf=1.0
			
		EndIf
		
		pitch=ATan2(sint,cost)
		yaw=ATan2(sinf,cosf)
		roll=-ATan2(sinv,cosv)
		
	End Function
	
	
	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function MultiplyQuats:TQuaternion(q1:TQuaternion,q2:TQuaternion)
	
		Local q:TQuaternion=New TQuaternion
		
		q.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
		q.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y
		q.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z
		q.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x
	
		Return q
	
	End Function
	
	
	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function NormalizeQuat:TQuaternion(q:TQuaternion)
	
		Local uv:Float=Sqr(q.w*q.w+q.x*q.x+q.y*q.y+q.z*q.z)
	
		q.w=q.w/uv
		q.x=q.x/uv
		q.y=q.y/uv
		q.z=q.z/uv
	
		Return q
	
	End Function

End Type

' ----------------------------------------------------------------------------
' Normalizes a value to a given range
' ----------------------------------------------------------------------------
Function Normalize:Float(value:Float = 128.0, vmin:Float = 0.0, vmax:Float = 255.0, nmin:Float = 0.0, nmax:Float = 1.0)
    
	Return ((value:Float - vmin:Float) / (vmax:Float - vmin:Float)) * (nmax:Float - nmin:Float) + nmin:Float
    
End Function</textarea><br><br>And with simple Entity instancing (copying the quad cube 27 times) it is even possible to show at least 9^3*10000 = <b>7.290.000 QUADS ALWAYS FACING TO CAMERA</b> with about 275 FPS here, just to mention this is still vanilla miniB3D ;-) So it is possible, just play with the code (and my code isn't very optimized yet).<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Framework sidesign.minib3d
Import brl.tgaloader

Graphics3D 1024, 600, 32, 2

' Camera
Local CAMERA:TCam = New TCam
CAMERA.add()
CAMERA.speed = 0.1
CAMERA.RangeMin = 0.01
CAMERA.RangeMax = 10000
CAMERA.update

Local q:TQuad
Local quadlist:TList = CreateList()
Local mesh:TMesh = CreateMesh()
Local surf:TSurface = CreateSurface(mesh)

'Local tex:TTexture = LoadTexture("sun.tga", 2)
'EntityTexture mesh, tex
'TextureBlend tex, 3

For Local i:Int = 1 To 10000

	q = New TQuad
	q.mesh = mesh
	q.surf = surf
	
	Local s:Float = Rnd(0.5, 5)
	
	q.scalex = s
	q.scaley = s
	q.x = Rnd(-1000, 1000)
	q.y = Rnd(-1000, 1000)
	q.z = Rnd(-1000, 1000)
	
	q.add()
	
	ListAddLast(quadlist, q)
	
Next

Local meshes:TEntity[9, 9, 9]
For Local x:Int = 0 To 8 Step 1
	
	For Local y:Int = 0 To 8 Step 1

		For Local z:Int = 0 To 8 Step 1
		
			meshes[x, y, z] = CopyEntity(mesh)
			
			PositionEntity meshes[x, y, z], (x - 4) * 2000, (y - 4) * 2000, (z - 4) * 2000
		
		Next
	
	Next
	
Next

freeEntity mesh

MoveMouse GraphicsWidth() / 2, GraphicsHeight() / 2

Repeat

	If KeyHit(KEY_ESCAPE) Then End

	CAMERA.Move
	
	Local ms:Int = MilliSecs()
	
	For Local q:TQuad = EachIn quadlist

		q.Update(CAMERA.cam)
	
	Next
	
	RenderWorld
	
	Text 0, 0, MilliSecs() - ms + "ms"
	
	Flip False

Forever

End


' ------------------------------------------------------------------------------------------------
' Quad Type
' ------------------------------------------------------------------------------------------------
Type TQuad

	Field x:Float = 0.0										' position x
	Field y:Float = 0.0										' position y
	Field z:Float = 0.0										' position z
	
	Field pitch:Float = 0.0
	Field yaw:Float = 0.0
	Field roll:Float = 0.0
	
	Field row:Int = 0										' texture row
	Field col:Int = 0										' texture column
	Field cat:String = ""
	
	Field size:Float = 1.0									' base size
	Field scale:Float = 1.0									' base scale
	Field scalex:Float = 1.0								' current size X
	Field scaley:Float = 1.0								' current size Y
	Field distance:Float = 0.0								' distance to cam
	Field Hidden:Int = 0									' hidden flag
	Field vanish:Float = 1.0								' vanish rate
	Field expanding:Float = 1.0								' expand rate
	
	Field RGB:Int[] = [255, 255, 255, 255]					' star vertex color

	Field RGB1:Int[] = [255, 255, 255, 255]					' nebula vertex color
	Field RGB2:Int[] = [255, 255, 255, 255]					' nebula vertex color
	Field RGB3:Int[] = [255, 255, 255, 255]					' nebula vertex color
	Field RGB4:Int[] = [255, 255, 255, 255]					' nebula vertex color

	Field Alpha:Float = 1.0									' vertex alpha
	Field Alpha1:Float = 1.0								' vertex alpha #1
	Field Alpha2:Float = 1.0								' vertex alpha #2
	Field Alpha3:Float = 1.0								' vertex alpha #3
	Field Alpha4:Float = 1.0								' vertex alpha #4

	Field v:Int = 0											' vertex counter
	Field mesh:TMesh = Null									' mesh pointer
	Field surf:TSurface = Null								' surface pointer

	Field rotation:Float
				
	Global temp:TPivot = CreatePivot()


	' --------------------------------------------------------------------------------------------
	' METHOD: Add new Quad
	' --------------------------------------------------------------------------------------------
	Method Add(col:Int = 0, row:Int = 0)

		' surface setup
		If surf = Null Then surf = surf
		If v + 4 &gt; 32768 Then
			v = 0
			surf = CreateSurface(mesh)
		EndIf

		' add Vertices
		Local V0:Int = AddVertex(surf, 0, 0, 0, 1, 0)
		Local V1:Int = AddVertex(surf, 0, 0, 0, 1, 1)
		Local V2:Int = AddVertex(surf, 0, 0, 0, 0, 1)
		Local V3:Int = AddVertex(surf, 0, 0, 0, 0, 0)

		' color vertices
		VertexColor surf, V0, RGB[0], RGB[1], RGB[2], Alpha
		VertexColor surf, V1, RGB[0], RGB[1], RGB[2], Alpha
		VertexColor surf, V2, RGB[0], RGB[1], RGB[2], Alpha
		VertexColor surf, V3, RGB[0], RGB[1], RGB[2], Alpha

		' connect triangles
		AddTriangle surf, V0, V1, V2
		AddTriangle surf, V0, V2, V3
		
		VertexTexCoords surf, V0, col + 1, row
		VertexTexCoords surf, V1, col + 1, row + 1
		VertexTexCoords surf, V2, col, row + 1
		VertexTexCoords surf, V3, col, row

		' increase vertex counter
		If v &gt;= 4 Then v = V0 + 4 Else v = V0

	End Method



	' --------------------------------------------------------------------------------------------
	' METHOD: Hide a Quad
	' --------------------------------------------------------------------------------------------
	Method Hide()

		distance = 2 ^ 32

		' set vertices
		VertexCoords surf, v + 0, distance, distance, distance
		VertexCoords surf, v + 1, distance, distance, distance
		VertexCoords surf, v + 2, distance, distance, distance
		VertexCoords surf, v + 3, distance, distance, distance

		hidden = 1

	End Method



	' --------------------------------------------------------------------------------------------
	' METHOD: Update a Quad
	' --------------------------------------------------------------------------------------------
	Method Update(target:TEntity)
	
		If Alpha &lt;= 0 Then
		
			Hide
			hidden = 1
						
		Else

			TFormVector scalex, 0, 0, target, Null
			Local X1:Float = TFormedX()
			Local Y1:Float = TFormedY()
			Local Z1:Float = TFormedZ()
	    
			TFormVector 0, scaley, 0, target, Null
			Local X2:Float = TFormedX()
			Local Y2:Float = TFormedY()
			Local Z2:Float = TFormedZ()
			
			' set vertices
			VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
			VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
			VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
			VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
		
			' set colors
			VertexColor surf, v + 0, RGB[0], RGB[1], RGB[2], Alpha
			VertexColor surf, v + 1, RGB[0], RGB[1], RGB[2], Alpha
			VertexColor surf, v + 2, RGB[0], RGB[1], RGB[2], Alpha
			VertexColor surf, v + 3, RGB[0], RGB[1], RGB[2], Alpha
			
			hidden = 0

		EndIf
			
	End Method

	
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateAlpha(a:Float = 1.0)
	
		' set colors
		VertexColor surf, v + 0, RGB[0], RGB[1], RGB[2], Alpha1 * a
		VertexColor surf, v + 1, RGB[0], RGB[1], RGB[2], Alpha2 * a
		VertexColor surf, v + 2, RGB[0], RGB[1], RGB[2], Alpha3 * a
		VertexColor surf, v + 3, RGB[0], RGB[1], RGB[2], Alpha4 * a
			
	End Method

	
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateAllAlpha(a:Float = 1.0)
	
		' set colors
		VertexColor surf, v + 0, RGB[0], RGB[1], RGB[2], a
		VertexColor surf, v + 1, RGB[0], RGB[1], RGB[2], a
		VertexColor surf, v + 2, RGB[0], RGB[1], RGB[2], a
		VertexColor surf, v + 3, RGB[0], RGB[1], RGB[2], a
			
	End Method
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateVertexColors(r:Int = 255, g:Int = 255, b:Int = 255, a:Float = 1.0)
	
		' set colors
		VertexColor surf, v + 0, r, g, b, a * Alpha
		VertexColor surf, v + 1, r, g, b, a * Alpha
		VertexColor surf, v + 2, r, g, b, a * Alpha
		VertexColor surf, v + 3, r, g, b, a * Alpha
			
	End Method
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update Alpha
	' --------------------------------------------------------------------------------------------
	Method UpdateScale()
	
		PositionEntity temp, x, y, z
		RotateEntity temp, pitch, yaw, roll
	
		TFormVector scalex, 0, 0, temp, Null
		Local X1:Float = TFormedX()
		Local Y1:Float = TFormedY()
		Local Z1:Float = TFormedZ()
    
		TFormVector 0, scaley, 0, temp, Null
		Local X2:Float = TFormedX()
		Local Y2:Float = TFormedY()
		Local Z2:Float = TFormedZ()
		
		' set vertices
		VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
		VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
		VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
		VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
			
	End Method
		
	
	
	' --------------------------------------------------------------------------------------------
	' METHOD: Update a Quad
	' --------------------------------------------------------------------------------------------
	Method UpdateRotation(target:TEntity)
	
		Local PIVOT:TPivot = CreatePivot()
	
		If (Alpha1 + Alpha2 + Alpha3 + Alpha4) &lt;= 0 Then
			
			Hide
			
		Else
					
			PositionEntity PIVOT, x, y, z
	
			PointEntity PIVOT, target
			RotateEntity PIVOT, EntityPitch(target), EntityYaw(target), rotation
			
			TFormVector scalex, 0, 0, PIVOT, Null
			Local X1:Float = TFormedX()
			Local Y1:Float = TFormedY()
			Local Z1:Float = TFormedZ()
	    
			TFormVector 0, scaley, 0, PIVOT, Null
			Local X2:Float = TFormedX()
			Local Y2:Float = TFormedY()
			Local Z2:Float = TFormedZ()
			
			' set vertices
			VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
			VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
			VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
			VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
		
			' set colors
			VertexColor surf, v + 0, RGB1[0], RGB1[1], RGB1[2], Alpha1
			VertexColor surf, v + 1, RGB2[0], RGB2[1], RGB2[2], Alpha2
			VertexColor surf, v + 2, RGB3[0], RGB3[1], RGB3[2], Alpha3
			VertexColor surf, v + 3, RGB4[0], RGB4[1], RGB4[2], Alpha4
			
		End If
		
		FreeEntity PIVOT

	End Method

	Method AlignToTarget(x:Float, y:Float, z:Float, angle:Float = 0.0)
	
		Local PIVOT:TPivot = CreatePivot()
	
		PositionEntity PIVOT, x, y, z
					
		Local yaw:Float,pitch:Float,roll:Float
		Local x1:Float,y1:Float,z1:Float
		Local x2:Float,y2:Float,z2:Float
		Local x3:Float,y3:Float,z3:Float
		
		yaw=-ATan2(x,z)
		
		x1=z*Sin(yaw)+x*Cos(yaw)
		y1=y	
		z1=z*Cos(yaw)-x*Sin(yaw)
		
		pitch=-ATan2(y1,z1)
	
		x2=x1
		y2=y1*Cos(pitch)-z1*Sin(pitch)
		z2=y1*Sin(pitch)+z1*Cos(pitch)
		
		roll= -ATan2(x2, y2)
	
		x3=x2*Cos(roll)-y2*Sin(roll)
		y3=x2*Sin(roll)+y2*Cos(roll)
		z3=z2
	
		If y&lt;0 Then roll:+180
		
		RotateEntity PIVOT, pitch, yaw, roll + angle

		TFormVector scalex, 0, 0, PIVOT, Null
		x1 = TFormedX()
		y1 = TFormedY()
		z1 = TFormedZ()
	    
		TFormVector 0, scaley, 0, PIVOT, Null
		x2 = TFormedX()
		y2 = TFormedY()
		z2 = TFormedZ()
			
		' set vertices
		VertexCoords surf, v + 0, x - x1 - x2, y - y1 - y2, z - z1 - z2
		VertexCoords surf, v + 1, x - x1 + x2, y - y1 + y2, z - z1 + z2
		VertexCoords surf, v + 2, x + x1 + x2, y + y1 + y2, z + z1 + z2
		VertexCoords surf, v + 3, x + x1 - x2, y + y1 - y2, z + z1 - z2
		
		' set colors
		VertexColor surf, v + 0, RGB1[0], RGB1[1], RGB1[2], Alpha1
		VertexColor surf, v + 1, RGB2[0], RGB2[1], RGB2[2], Alpha2
		VertexColor surf, v + 2, RGB3[0], RGB3[1], RGB3[2], Alpha3
		VertexColor surf, v + 3, RGB4[0], RGB4[1], RGB4[2], Alpha4
		
		FreeEntity PIVOT
				
	End Method
	
End Type

Type TCam

	Field cam:TCamera										' camera entity
	Field parent:TEntity									' camera parent

	Field X:Float = 0.0										' Position X
	Field Y:Float = 0.0										' Position Y
	Field Z:Float = 0.0										' Position Z

	Field OX:Float = 0.0									' Old Position X
	Field OY:Float = 0.0									' Old Position Y
	Field OZ:Float = 0.0									' Old Position Z

	Field OPitch:Float = 0.0								' Old Pitch
	Field OYaw:Float = 0.0									' Old Yaw
	Field ORoll:Float = 0.0									' Old Roll
	
	Field Pitch:Float = 0.0									' Pitch
	Field Yaw:Float = 0.0									' Yaw
	Field Roll:Float = 0.0									' Roll

	Field CLScolor:Int[] = [0, 0, 0]						' Background color
	Field FOGcolor:Int[] = [0, 0, 0]						' Fog color
		
	Field FieldofView:Float = 90.0							' Field of View
	Field FOGmode:Int = False								' Fog Mode
	Field Zoom:Float = 1.0									' Zoom factor

	Field RangeMin:Float = 1.0								' Frustum start
	Field RangeMax:Float = 10000.0							' Frustum end
	Field FOGrangeMin:Float = 1.0							' Fog Frustum start
	Field FOGrangeMax:Float = 10000.0						' Fog Frustum end
	
	Field ViewX:Int = 0										' Viewport X Position
	Field ViewY:Int = 0										' Viewport Y Position
	Field Width:Int = GraphicsWidth()						' Viewport width
	Field Height:Int = GraphicsHeight()						' Viewport height
	
	Field PX:Int											' Projected X
	Field PY:Int											' Projected Y
	
	Const QuatToEuler:Double = 0.00001
	
	Field Speed:Float = 0.1									' Camera Movespeed
	Field RollSpeed:Float = 0.5								' Camera Rollspeed
	Field TurnSpeed:Float = 2.00							' Camera Turnspeed (Mousemove)
	Field Sensitivity:Float = 1.25							' Overall Camera Sensitivity
	
	Field CurrentSpeed:Float								' Current Movespeed
	
	Field Xspeed:Float										' Current X-Vector Speed
	Field Yspeed:Float										' Current Y-Vector Speed
	Field Zspeed:Float										' Current Z-Vector Speed
	
	Field Glob:Int = False									' Local/Global flag


	' --------------------------------------------------------------------------------------------
	' Add new camera
	' --------------------------------------------------------------------------------------------
	Method Add()
	
		cam = CreateCamera(parent)
		
	End Method
	
	' --------------------------------------------------------------------------------------------
	' Show Camera
	' --------------------------------------------------------------------------------------------
	Method Show()
	
		ShowEntity cam
	
	End Method

	' --------------------------------------------------------------------------------------------
	' Hide Camera
	' --------------------------------------------------------------------------------------------
	Method Hide()
	
		HideEntity cam
	
	End Method

	' ----------------------------------------------------------------------------
	' Free Camera movment using Quaternion rotations
	' ----------------------------------------------------------------------------
	Method Move()
		
		Local rolling:Float, tx:Float, ty:Float, Pos:Float
			
		CurrentSpeed:+((KeyDown(KEY_W) - KeyDown(KEY_S)) * Speed)
		
		'CurrentSpeed:*1.0 - (KeyDown(KEY_S) / 25.0)
	
		rolling = (KeyDown(KEY_A) - KeyDown(KEY_D)) * RollSpeed
		
		tx = Normalize(MouseX(), 0, GraphicsWidth(), 1, -1)
		ty = Normalize(MouseY(), 0, GraphicsHeight(), -1, 1)
		
		If ty &lt; 0 Then ty = (Abs(ty) ^ sensitivity) * -1 Else ty = ty ^ sensitivity
		If tx &lt; 0 Then tx = (Abs(tx) ^ sensitivity) * -1 Else tx = tx ^ sensitivity
		
		xspeed = ty * TurnSpeed
		yspeed = tx * TurnSpeed
		zspeed = (rolling * TurnSpeed)
		
		If KeyDown(KEY_X) Then
		
			CurrentSpeed:*0.9
			
			If CurrentSpeed &gt; 0 And CurrentSpeed &lt; 0.01 Then CurrentSpeed = 0.0
			If CurrentSpeed &lt; 0 And CurrentSpeed &gt; - 0.01 Then CurrentSpeed = 0.0
						
		EndIf
		
		MoveEntity cam, 0, 0, currentspeed
						
		Local Quat:TQuaternion = EulerToQuat(0.0, 0.0, 0.0)
		Local Turn_Quat:TQuaternion = EulerToQuat(0.0, 0.0, 0.0)

		If Glob = False
		
			Quat = EulerToQuat(EntityPitch(cam, True), EntityYaw(cam, True), EntityRoll(cam, True))
			Turn_Quat = EulerToQuat(Xspeed, Yspeed, Zspeed)
			Quat = MultiplyQuats( Quat, Turn_Quat )
			Quat = NormalizeQuat( Quat )
			QuatToEuler2(Quat.x, Quat.y, Quat.z, Quat.w, Pitch, Yaw, Roll)
						
		Else
	
			Pitch:+Xspeed
			yaw:+Yspeed
			Roll:+zspeed
			
		EndIf
		
		RotateEntity cam, pitch, yaw, roll
				
		'Update

	End Method

	' --------------------------------------------------------------------------------------------
	' Update Camera
	' --------------------------------------------------------------------------------------------
	Method Update()

		OX = EntityX(cam)
		OY = EntityY(cam)
		OZ = EntityZ(cam)

		OPitch = EntityPitch(cam)
		OYaw = EntityYaw(cam)
		ORoll = EntityRoll(cam)
	
		'PositionEntity cam, x, y, z
		'RotateEntity cam, pitch, yaw, roll
		CameraRange cam, rangemin, rangemax
		CameraFogRange cam, FOGrangemin, FOGrangemax
		CameraClsColor cam, CLScolor[0], CLScolor[1], CLScolor[2]
		CameraZoom cam, zoom
		CameraViewport cam, viewx, viewy, width, Height
	
	End Method
	
	' --------------------------------------------------------------------------------------------
	' Update Camera Position
	' --------------------------------------------------------------------------------------------
	Method UpdatePosition()

		PositionEntity cam, x, y, z
	
	End Method
	
	Method Moved:Int()
	
		If (ox &lt;&gt; x) Or (oy &lt;&gt; y) Or (oz &lt;&gt; z) Then Return True
		
		Return False
			
	End Method
	
	' --------------------------------------------------------------------------------------------
	' Calculate Screen Projection coordinates
	' --------------------------------------------------------------------------------------------
	Method Project(x:Float = 0.0, y:Float = 0.0, z:Float = 0.0)
		
		CameraProject cam, x, y, z
		PX = ProjectedX()
		PY = ProjectedY()
	
	End Method
		
	' --------------------------------------------------------------------------------------------
	' Store current camera position
	' --------------------------------------------------------------------------------------------
	Method GetCameraPosition(glob:Int = False)
	
		X = EntityX(cam, glob)
		Y = EntityY(cam, glob)
		Z = EntityZ(cam, glob)
					
	End Method

	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function EulerToQuat:TQuaternion(pitch:Float,yaw:Float,roll:Float)
	
		Local cr:Float=Cos(-roll/2.0)
		Local cp:Float=Cos(pitch/2.0)
		Local cy:Float=Cos(yaw/2.0)
		Local sr:Float=Sin(-roll/2.0)
		Local sp:Float=Sin(pitch/2.0)
		Local sy:Float=Sin(yaw/2.0)
		Local cpcy:Float=cp*cy
		Local spsy:Float=sp*sy
		Local spcy:Float=sp*cy
		Local cpsy:Float=cp*sy
		
		Local q:TQuaternion=New TQuaternion
		
		q.w:Float=cr*cpcy+sr*spsy
		q.x:Float=sr*cpcy-cr*spsy
		q.y:Float=cr*spcy+sr*cpsy
		q.z:Float=cr*cpsy-sr*spcy
		
		Return q
		
	End Function
	
	
	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function QuatToEuler2(x:Float,y:Float,z:Float,w:Float,pitch:Float Var,yaw:Float Var,roll:Float Var)
	
		Local sint:Float=(2.0*w*y)-(2.0*x*z)
		Local cost_temp:Float=1.0-(sint*sint)
		Local cost:Float
	
		If Abs(cost_temp)&gt;QuatToEuler
	
			cost=Sqr(cost_temp)
	
			Else
	
			cost=0.0
	
		EndIf
	
		Local sinv:Float,cosv:Float,sinf:Float,cosf:Float
		
		If Abs(cost)&gt;QuatToEuler
		
			sinv=((2.0*y*z)+(2.0*w*x))/cost
			cosv=(1.0-(2.0*x*x)-(2.0*y*y))/cost
			sinf=((2.0*x*y)+(2.0*w*z))/cost
			cosf=(1.0-(2.0*y*y)-(2.0*z*z))/cost
			
		Else
			
			sinv=(2.0*w*x)-(2.0*y*z)
			cosv=1.0-(2.0*x*x)-(2.0*z*z)
			sinf=0.0
			cosf=1.0
			
		EndIf
		
		pitch=ATan2(sint,cost)
		yaw=ATan2(sinf,cosf)
		roll=-ATan2(sinv,cosv)
		
	End Function
	
	
	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function MultiplyQuats:TQuaternion(q1:TQuaternion,q2:TQuaternion)
	
		Local q:TQuaternion=New TQuaternion
		
		q.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z
		q.x = q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y
		q.y = q1.w*q2.y + q1.y*q2.w + q1.z*q2.x - q1.x*q2.z
		q.z = q1.w*q2.z + q1.z*q2.w + q1.x*q2.y - q1.y*q2.x
	
		Return q
	
	End Function
	
	
	' ----------------------------------------------------------------------------
	' help function of turncam
	' ----------------------------------------------------------------------------
	Function NormalizeQuat:TQuaternion(q:TQuaternion)
	
		Local uv:Float=Sqr(q.w*q.w+q.x*q.x+q.y*q.y+q.z*q.z)
	
		q.w=q.w/uv
		q.x=q.x/uv
		q.y=q.y/uv
		q.z=q.z/uv
	
		Return q
	
	End Function

End Type

' ----------------------------------------------------------------------------
' Normalizes a value to a given range
' ----------------------------------------------------------------------------
Function Normalize:Float(value:Float = 128.0, vmin:Float = 0.0, vmax:Float = 255.0, nmin:Float = 0.0, nmax:Float = 1.0)
    
	Return ((value:Float - vmin:Float) / (vmax:Float - vmin:Float)) * (nmax:Float - nmin:Float) + nmin:Float
    
End Function</textarea><br><br>And for a full masked tree/grass example you can take a look at my old ORCS outdoor code, it has lots of trees using a similar technique: <a href="/post.php?topic=92844&amp;post=1177648" target="_blank">ORCS Billboard</a> <br><br></td></tr></table><br>
<a name="1300308"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> The TQuad.Update method can be optimised with this:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=102120#1298605" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=102120#1298605</a> <br><br></td></tr></table><br>
<a name="1300391"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, but I think it's optimized enough for some trees. Another option is to use the miniB3D Addon "TBatchsprite" - I prefer to create my own system but it could be useful for Peter:<br><br><a href="/posts.php?topic=97982" target="_blank">TBatchSprite -- batch sprites for minib3d</a> <br><br></td></tr></table><br>
<a name="1300430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Midimaster&gt;&gt;you may be interested in these : <br><a href="http://www.blitzbasic.com/Community/posts.php?topic=69532" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=69532</a><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=102163" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=102163</a><br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1324" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1324</a> <br><br></td></tr></table><br>
<a name="1301152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> At the moment I'm in China for 2 weeks. but I will have a look on it, when I'm back... and report...<br><br>by the way... some days ago I flew with "Emirates". In the on board entertaining program there was a car racing game. In the copyright informations I could find out, that it was written in Blitz3D by a french team... <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
