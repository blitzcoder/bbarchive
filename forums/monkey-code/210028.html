<!DOCTYPE html><html lang="en" ><head ><title >Dungeon/room generator for rpg/roguelike and such.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Dungeon/room generator for rpg/roguelike and such.</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=512" >Monkey Code</a>/<a href="#bottom" >Dungeon/room generator for rpg/roguelike and such.</a><br><br>
<a name="2109741"></a>

<a name="2109320"></a>

<a name="2109319"></a>

<a name="2109318"></a>

<a name="2109289"></a>

<a name="2109279"></a>

<a name="2109280"></a>

<a name="2125433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pakz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://i60.tinypic.com/fkzccm.png"><br><br>I tried another way of creating dungeons. I made a few already. Here I create one base room(rect) and then randomly place 10 rooms of random sizes on the map until they touch another room on the right spot. It seems to work allright. It is fast enough.<br><br>I read once that someone used makeroom and makecorridor functions and called these to make maps. I am going to spend more time experimenting with maps in the future.<br><br>The maps look nice enough to play in.<br><br>Here a video of more maps.<br><iframe width="560" height="345" src="http://www.youtube.com/embed/0HhL0J3xBp4" frameborder="0" allowfullscreen></iframe><br>Here another video with more in it.<br><iframe width="560" height="345" src="http://www.youtube.com/embed/QfMuxTgG634" frameborder="0" allowfullscreen></iframe><br>Here a video of a big map with monsters in it:<br><iframe width="560" height="345" src="http://www.youtube.com/embed/6aGGLw4et4I" frameborder="0" allowfullscreen></iframe><br><br>Here the flash applet on my blog : <a href="http://monkeygameprogramming.blogspot.nl/2015/08/monkey-x-random-room-placement-map.html" target="_blank">http://monkeygameprogramming.blogspot.nl/2015/08/monkey-x-random-room-placement-map.html</a><br><br>Here the code :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import mojo

Class room
	Field mapwidth:Int=640/12
	Field mapheight:Int=480/12
	Field tilewidth:Int=12
	Field tileheight:Int=12
	Field map:Int[640/12][]
	Field refreshmaptime:Int=0
	Method New()
        For Local i = 0 Until mapwidth
            map[i] = New Int[mapheight]
        Next
		newmap
	End Method	
	Method update()
		If KeyHit(KEY_SPACE) Then 
		newmap
		refreshmaptime=0
		End If
		refreshmaptime+=1
		If refreshmaptime&gt;200 Then 
			newmap
			refreshmaptime=0
		End If
	End Method
	Method draw()
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			If map[x][y] = 1
				SetColor 150,150,150
				DrawRect 	x*tilewidth,y*tileheight,
							tilewidth,tileheight
			End If
			If map[x][y] = 2
				SetColor 200,200,200
				DrawRect 	x*tilewidth,y*tileheight,
							tilewidth,tileheight
			End If			
		Next
		Next
	End Method
	Method newmap()
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			map[x][y] = 0
		Next
		Next
	    drawrectinmap(Rnd(10,mapwidth-10),Rnd(10,mapheight-10),5,3)
        For Local i=0 Until 10
	        makeroom
        Next
        makewalls
	
	End Method
	Method makewalls()
		' put walls on the map
		For Local y=1 Until mapheight-1
		For Local x=1 Until mapwidth-1
			If map[x][y] = 0
				If map[x+1][y] = 1
					map[x+1][y] = 2
				End If				
			End If
			If map[x][y] = 1
				If map[x+1][y] = 0
					map[x][y] = 2
				End If
			End If
			If map[x][y] = 1
				If map[x][y+1] = 0
					map[x][y] = 2
				End If
			End If
			If map[x][y] = 0
				If map[x][y+1] = 1
					map[x][y+1] = 2
				End If
			End If
		Next
		Next
	End Method
	Method makeroom:Bool()
		'find suitable place to make room
		Local exitloop:Bool=False
		Local cnt:Int=0
		While exitloop = False
			cnt+=1
			If cnt&gt;8000 Then exitloop=True
			Local x:Int=Rnd(5,mapwidth-8)
			Local y:Int=Rnd(5,mapheight-8)
			Local roomw:Int=Rnd(4,8)
			Local roomh:Int=Rnd(4,8)
			Local pass1:Bool=True
			For Local y1=0 Until roomh
			For Local x1=0 Until roomh
				If map[x1+x][y1+y] = 1 Then pass1=False
			Next
			Next
			Local pass2:Bool=False
			If pass1=True Then
				For Local y1=3 To roomh-3
					If map[x-1][y+y1] = 1 Then pass2=True
					If map[x+roomw][y+y1] = 1 Then pass2=True
				Next
 				For Local x1=3 To roomw-3
					If map[x+x1][y-1] = 1 Then pass2 = True
					If map[x+x1][y+roomh] = 1 Then pass2 = True
				Next
			End If
			If pass2 = True Then
				drawrectinmap(x,y,roomw,roomh)
				Return
			End If
		Wend
	End Method
	Method issuitable:Bool(x:Int,y:Int,w:Int,h:Int)
		For Local y1=0 Until h
		For Local x1=0 Until w
			If map[x+x1][y+y1] = 1 Then Return False
		Next
		Next
		Return True
	End Method
	Method drawrectinmap(x:Int,y:Int,w:Int,h:Int)
		For Local y1=0 Until h
		For Local x1=0 Until w
			map[x+x1][y+y1] = 1
		Next
		Next
	End Method
End Class

Global myroom:room = New room()

Class MyGame Extends App
    Method OnCreate()
        SetUpdateRate(60)
    End Method
    Method OnUpdate()        
    	myroom.update
    End Method
    Method OnRender()
        Cls(0,0,0)
        myroom.draw
        SetColor 255,255,255
        DrawText 	"Press spacebar to create new map ",
        			2,2
    End
End


Function Main()
    New MyGame()
End
</textarea><br><br>Here the same one but now with some monsters in it :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Maybe this is useable as a background
' for a simple or more complex role
' playing game. The size of the tiles
' determine if there is more or less
' tiles generated.
'
'
Import mojo


' tile size (smaller =
' more map)
' does not work with size 
' smaller then 2*2 on my
' 740m
Global twidth:Int=6
Global theight:Int=6
' minimum room width and height
Global minroomw:Int=4
Global minroomh:Int=4
' maximum room qwidth and height
Global maxroomw:Int=12
Global maxroomh:Int=12

Class monster
    Field mapwidth:Int=640/twidth
    Field mapheight:Int=480/theight
    Field map:Int[640/twidth][]
    Field x:Int,y:Int
    Field mdelay:Int=0
    Method New()
        For Local i = 0 Until mapwidth
            map[i] = New Int[mapheight]
        Next
        ' find place for monster
        Local exitloop:Bool=False
        While exitloop = False
            Local x1:Int=Rnd(5,mapwidth-5)
            Local y1:Int=Rnd(5,mapheight-5)
            If myroom.map[x1][y1] = 1 Then
                exitloop = True
                Self.x = x1
                Self.y = y1
                map[x][y] = 1
            End If
        Wend        
    End Method
    Method update()
        mdelay+=1
        If mdelay&lt; 15 Then Return
        mdelay=0
        map[x][y]+=1
        If map[x][y] &gt; 1000
            For Local y1=0 Until mapheight
            For Local x1=0 Until mapwidth
                map[x1][y1] = 0
            Next
            Next
            map[x][y]=1
        End If
        Local exitloop:Bool=False
        While exitloop = False            
            Local y2:Int=Rnd(-2,2)
            Local x2:Int=Rnd(-2,2)
            If myroom.map[x+x2][y+y2] = 1
            If map[x+x2][y+y2] &lt;= map[x][y]
                x+=x2
                y+=y2
                exitloop=True
                Return
            End If
            End If
        Wend
    End Method
    Method draw()
        SetColor 255,255,0
        DrawRect x*twidth,y*theight,twidth,theight
    End Method
End Class

Class room
    Field mapwidth:Int=640/twidth
    Field mapheight:Int=480/theight
    Field tilewidth:Int=twidth
    Field tileheight:Int=theight
    Field map:Int[640/twidth][]
    Field refreshmaptime:Int=0
    Field makemonsters:Bool=False
    Method New()
        For Local i = 0 Until mapwidth
            map[i] = New Int[mapheight]
        Next
        newmap
    End Method    
    Method update()
		refreshmaptime+=1
		If refreshmaptime &gt; 500
			refreshmaptime=0
			newmap
		End If
		If KeyHit(KEY_SPACE)
			refreshmaptime = 0
			newmap
		End If
    End Method
    Method draw()
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            If map[x][y] = 1
                SetColor 150,150,150
                DrawRect     x*tilewidth,y*tileheight,
                            tilewidth,tileheight
            End If
            If map[x][y] = 2
                SetColor 200,200,200
                DrawRect     x*tilewidth,y*tileheight,
                            tilewidth,tileheight
            End If            
        Next
        Next
    End Method
    Method newmap()
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            map[x][y] = 0
        Next
        Next
        drawrectinmap(Rnd(10,mapwidth-10),Rnd(10,mapheight-10),5,3)
        For Local i=0 Until (mapwidth*mapheight)/50
            makeroom
        Next
        makewalls
        makemonsters=True
    End Method
    Method makewalls()
        ' put walls on the map
        For Local y=1 Until mapheight-1
        For Local x=1 Until mapwidth-1
            If map[x][y] = 0
                If map[x+1][y] = 1
                    map[x+1][y] = 2
                End If                
            End If
            If map[x][y] = 1
                If map[x+1][y] = 0
                    map[x][y] = 2
                End If
            End If
            If map[x][y] = 1
                If map[x][y+1] = 0
                    map[x][y] = 2
                End If
            End If
            If map[x][y] = 0
                If map[x][y+1] = 1
                    map[x][y+1] = 2
                End If
            End If
        Next
        Next
    End Method
    Method makeroom:Bool()
        'find suitable place to make room
        Local exitloop:Bool=False
        Local cnt:Int=0
        While exitloop = False
            cnt+=1
            If cnt&gt;8000 Then exitloop=True
            Local x:Int=Rnd(5,mapwidth-maxroomw)
            Local y:Int=Rnd(5,mapheight-maxroomh)
            Local roomw:Int=Rnd(minroomw,maxroomw)
            Local roomh:Int=Rnd(minroomh,maxroomh)
            Local pass1:Bool=True
            For Local y1=0 Until roomh
            For Local x1=0 Until roomh
                If map[x1+x][y1+y] = 1 Then pass1=False
            Next
            Next
            Local pass2:Bool=False
            If pass1=True Then
                For Local y1=3 To roomh-3
                    If map[x-1][y+y1] = 1 Then pass2=True
                    If map[x+roomw][y+y1] = 1 Then pass2=True
                Next
                 For Local x1=3 To roomw-3
                    If map[x+x1][y-1] = 1 Then pass2 = True
                    If map[x+x1][y+roomh] = 1 Then pass2 = True
                Next
            End If
            If pass2 = True Then
                drawrectinmap(x,y,roomw,roomh)
                Return
            End If
        Wend
    End Method
    Method issuitable:Bool(x:Int,y:Int,w:Int,h:Int)
        For Local y1=0 Until h
        For Local x1=0 Until w
            If map[x+x1][y+y1] = 1 Then Return False
        Next
        Next
        Return True
    End Method
    Method drawrectinmap(x:Int,y:Int,w:Int,h:Int)
        For Local y1=0 Until h
        For Local x1=0 Until w
            map[x+x1][y+y1] = 1
        Next
        Next
    End Method
End Class

Global myroom:room = New room()
Global mymonster:List&lt;monster&gt; = New List&lt;monster&gt;

Class MyGame Extends App
    Method OnCreate()
        SetUpdateRate(60)                
    End Method
    Method OnUpdate()        
        myroom.update
        For Local i:=Eachin mymonster
            i.update
        Next        
        If myroom.makemonsters= True
        	For Local i:=Eachin mymonster
        		mymonster.Remove i
        	Next
        	For Local i=0 To 640/(twidth*theight)
        		mymonster.AddLast(New monster())
        	Next
        	myroom.makemonsters = False
        End If
    End Method
    Method OnRender()
        Cls(0,0,0)
        myroom.draw
        For Local i:=Eachin mymonster
            i.draw
        Next         
        SetColor 255,255,255
        DrawText     "Monsters in a dungeon. (Press space for new map or wait.)",
                    2,2
    End
End


Function Main()
    New MyGame()
End
</textarea> <br><br></td></tr></table><br>
<a name="2109759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pakz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here something else that I tried. Here a* makes paths across a heightmap like map creating other kind of maps.<br><br><img src="http://i59.tinypic.com/2gt7yub.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import mojo

Global mapwidth:Int = 50
Global mapheight:Int= 50
Global sx:Int 'path start x
Global sy:Int 'path start y
Global ex:Int=mapwidth/2 'path end x
Global ey:Int=mapheight/2 'path end y
Global map:Int[mapwidth][]
Global olmap:Int[mapwidth][]
Global clmap:Int[mapwidth][]
Global pmap:Int[mapwidth][]
' this one refreshes maps
Global waittime:Int=0

Class mapgen
	Field gmap:Int[mapwidth][]
	Field hmap:Int[mapwidth][]
	Field twidth:float,theight:float
	Method New()
	    For Local i = 0 Until mapwidth
            gmap[i] = New Int[mapheight]
            hmap[i] = New Int[mapheight]
        Next    	
        twidth=640/mapwidth
        theight=480/mapheight
        makehmap
        makemap
	End Method
	Method makemap()
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			map[x][y] = hmap[x][y]
		Next
		Next
		ex = Rnd(10,mapwidth-10)
		ey = Rnd(10,mapheight-10)
		Local numpaths:Int = (mapwidth*mapheight)/700
		For Local i=0 Until numpaths			
			sx = ex
			sy = ey
			Local exitloop:Bool=False
			While exitloop = False
				ex = Rnd(10,mapwidth-10)			
				ey = Rnd(10,mapheight-10)
				If sx&lt;&gt;ex And sy&lt;&gt;ey Then
					exitloop = True
				End If
			Wend
			findpath	
			For Local ii:=Eachin path
				Local s:Int=2
				If Int(Rnd(1,5)) = 2
					s=Rnd(2,5)
					Elseif Int(Rnd(1,9)) = 2
					s=8
				End If
				For Local y=-s/2 Until s/2
				For Local x=-s/2 Until s/2
  					gmap[ii.x+x][ii.y+y] = 1
  					pmap[ii.x+x][ii.y+y] = 1
				Next
				Next
			Next
		Next
		' here add the walls
		For Local y=1 Until mapheight-1
		For Local x=1 Until mapwidth-1
			If gmap[x][y] = 0 
			If gmap[x+1][y] = 1
			gmap[x][y]=2
			End If
			End If
			If gmap[x][y] = 1
			If gmap[x+1][y] = 0
			gmap[x+1][y] = 2
			End If
			End If
			If gmap[x][y] = 0
			If gmap[x][y+1] = 1
			gmap[x][y] = 2
			End If
			End If
			If gmap[x][y] = 1
			If gmap[x][y+1] = 0
			gmap[x][y+1] = 2
			End If
			End if
		Next
		Next
	End Method
	Method drawmap()
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			If gmap[x][y] = 1
				SetColor 150,150,150
				DrawRect 	x*twidth,y*theight,
							twidth,theight
			End If
			If gmap[x][y] = 2
				SetColor 200,200,200
				DrawRect 	x*twidth,y*theight,
							twidth,theight
			End If			
		Next
		Next 
	End Method
	Method makehmap()
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			hmap[x][y] = 3
		Next
		Next
		For Local i=0 To (mapwidth*mapheight)/10
			Local w:Int=Rnd(3,8)
			Local h:Int=Rnd(3,8)
			Local x:Int=Rnd(3,mapwidth-8)
			Local y:Int=Rnd(3,mapheight-8)
			For Local y1=-w/2 To w/2
			For Local x1=-h/2 To h/2
				hmap[x+x1][y+y1]+=1
			Next
			Next
		Next
	End Method
	Method drawhmap()		
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			SetColor hmap[x][y]*10,0,0
			DrawRect 	x*twidth,y*theight,
						twidth,theight
		Next
		Next
	End Method
End Class

Class openlist
    Field x:Int
    Field y:Int
    Field f:Int
    Field g:Int
    Field h:Int
    Field px:Int
    Field py:Int
    Method New(	x:Int=0,y:Int=0,f:Int=0,
                g:Int=0,h:Int=0,px:Int=0,
                py:Int=0)
        Self.x=x
        Self.y=y
        Self.f=f
        Self.g=g
        Self.h=h
        Self.px=px
        Self.py=py
    End Method
End Class
Class closedlist
    Field x:Int
    Field y:Int
    Field px:Int
    Field py:Int 
    Method New(x:Int,y:Int,px:Int,py:Int)
        Self.x = x
        Self.y = y
        Self.px = px
        Self.py = py
    End Method
End Class
Class pathnode
    Field x:Int
    Field y:Int
    Method New(x:Int,y:Int)
        Self.x = x
        Self.y = y
    End Method
End Class

Global ol:List&lt;openlist&gt; = New List&lt;openlist&gt;
Global cl:List&lt;closedlist&gt; = New List&lt;closedlist&gt;
Global path:List&lt;pathnode&gt; = New List&lt;pathnode&gt;
Global mymapgen:mapgen

Class MyGame Extends App
    Method OnCreate()
        SetUpdateRate(60)
        For Local i=0 Until mapwidth
            map[i] = New Int[mapheight]
            olmap[i] = New Int[mapheight]
            clmap[i] = New Int[mapheight]
            pmap[i] = New Int[mapheight]
        Next        
        mymapgen = New mapgen()
    End Method
    Method OnUpdate()
    	waittime+=1
    	If waittime&gt;120
    		mapwidth=Rnd(50,150)
    		mapheight=mapwidth
    		map = makearray()
    		olmap = makearray()
    		clmap = makearray()
    		pmap = makearray()
	    	mymapgen = New mapgen()
	    	waittime = 0
    	End If
    End Method
    Method OnRender()
        Cls(0,0,0)
        mymapgen.drawmap
        SetColor 255,255,255        
    End
End

Function makearray:Int[][]()
    Local aa:Int[mapwidth][]
	For Local i=0 Until mapwidth
		aa[i] = New Int[mapheight]
	Next
    Return aa
End Function

Function findpath:Bool()
    If sx = ex And sy = ey Then Return False
    For Local y=0 Until mapheight
    For Local x=0 Until mapwidth
        olmap[x][y] = 0
        clmap[x][y] = 0
    Next
    Next
    ol.Clear
    cl.Clear
    path.Clear
    ol.AddFirst(New openlist(sx,sy))
    Local tx:Int
    Local ty:Int
    Local tf:Int
    Local tg:Int
    Local th:Int
    Local tpx:Int
    Local tpy:Int
    Local newx:Int
    Local newy:Int
    Local lowestf:Int
    olmap[sx][sy] = 1
    While ol.IsEmpty() = False
        lowestf = 100000
        For Local i:=Eachin ol
            If i.f &lt; lowestf
                lowestf = i.f
                tx = i.x
                ty = i.y
                tf = i.f
                tg = i.g
                th = i.h
                tpx = i.px
                tpy = i.py
            End If
        Next
        If tx = ex And ty = ey
            cl.AddLast(New closedlist(tx,ty,tpx,tpy))
            findpathback
            Return True
        Else
            removefromopenlist(tx,ty)
            olmap[tx][ty] = 0
            clmap[tx][ty] = 1
            cl.AddLast(New closedlist(tx,ty,tpx,tpy))
            For Local y=-1 To 1
            For Local x=-1 To 1
                newx = tx+x
                newy = ty+y
                If newx&gt;=0 And newy&gt;=0 And newx&lt;mapwidth And newy&lt;mapheight
                If olmap[newx][newy] = 0
                If clmap[newx][newy] = 0
                    olmap[newx][newy] = 1
                    Local gg:Int
                    If pmap[newx][newy] = 1
                    	gg=1
                    	Else
                    	gg = map[newx][newy]+1
                    End If
                    Local hh = distance(newx,newy,ex,ey)
                    Local ff = gg+hh
                    ol.AddLast(New openlist(newx,newy,ff,gg,hh,tx,ty))
                End If
                End If
                End If
            Next
            Next
        End If
    Wend
    Return False
End Function

Function findpathback:Bool()
    Local x=ex
    Local y=ey
    path.AddFirst(New pathnode(x,y))
    Repeat
        For Local i:=Eachin cl
            If i.x = x And i.y = y
                x = i.px
                y = i.py
                path.AddFirst(New pathnode(x,y))
            End If
        Next
        If x = sx And y = sy Then Return True
    Forever    
End Function

Function removefromopenlist:Void(x1:Int,y1:Int)
    For Local i:=Eachin ol
        If i.x = x1 And i.y = y1
            ol.Remove i
            Exit
        End If
    Next
End Function

Function distance:Int(x1:Int,y1:Int,x2:Int,y2:Int)
    Return Abs(x2-x1)+Abs(y2-y1)
End Function

Function Main()
    New MyGame()
End
</textarea> <br><br></td></tr></table><br>
<a name="2109756"></a>

<a name="2109744"></a>

<a name="2109750"></a>

<a name="2109743"></a>

<a name="2109742"></a>

<a name="2109762"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice maps.  Very similar to what you can get with a cellular automaton, but the straight lines look organically built in to yours, so it seems like they'd be good for ancient buried ruins etc. <br><br></td></tr></table><br>
<a name="2109761"></a>

<a name="2109818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pakz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I put the code from one of my other rpg things and put them with a map generator. <br><br>press g to transport/warp to another level.<br>press m to show map<br>cursors move<br>collect coins<br>Collect health<br><br><img src="http://i59.tinypic.com/5s3h4.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import mojo

' map things
' 1 = wal, 2 = door, 3 = health, 4 = coin,
' 5 = tree, 6 = water, 7 = rock

'map gen part
Global mapwidth:Int = 70
Global mapheight:Int= 60
Global sx:Int 'path start x
Global sy:Int 'path start y
Global ex:Int=mapwidth/2 'path end x
Global ey:Int=mapheight/2 'path end y
Global monmap:Int[mapwidth][]
Global map:Int[mapwidth][]
Global olmap:Int[mapwidth][]
Global clmap:Int[mapwidth][]
Global pmap:Int[mapwidth][]
' this one refreshes maps
Global waittime:Int=0
'  scrolling rpg part
Const tilewidth:Int=20
Const tileheight:Int=20
Global mapx:Int=0
Global mapy:Int=0
Global mapsx:Int=0
Global mapsy:Int=0

Global showmap:Bool=False
Global remakemap:Bool=False

Class tiles
    Field walltile:Image
    Field rocktile:Image
    Field groundtile:Image
    Field moneytile:Image
    Field pixels:Int[tilewidth*tileheight]
    Method New()
    	DebugLog "creating images"
    	walltile = CreateImage(tilewidth,tileheight)
    	rocktile = CreateImage(tilewidth,tileheight)
    	groundtile = CreateImage(tilewidth,tileheight)
    	moneytile = CreateImage(tilewidth,tileheight)
    	DebugLog "drawing in image"
    	Local s:Int=255/tileheight
    	Local ss:Int=tileheight/125
    	For Local y=0 Until tileheight
    		drawr(0,y,tilewidth,y,y*s,y*s,y*s)
    	Next    	
    	DebugLog "finishing image wall"
    	walltile.WritePixels(pixels, 0, 0, tilewidth, tileheight, 0)
    	For Local y=0 Until tileheight
    		Local col:Int=0
    		If y&lt;tileheight/2
    			col=0+((y*s))
    		Else
    			col=(255)-((y*s))
    		End If
    		drawr(0,y,tilewidth,y,col,col/3,0)
    	Next    	
    	DebugLog "finishing image rock"
    	rocktile.WritePixels(pixels, 0, 0, tilewidth, tileheight, 0)

    	For Local y=0 Until tileheight
    		Local col:Int=0
    		If y&lt;tileheight/2
    			col=0+((y*s)/6)
    		Else
    			col=(255/6)-((y*s)/6)
    		End If
    		drawr(0,y,tilewidth,y,col,col,col)
    	Next    	
    	DebugLog "finishing image ground"
    	groundtile.WritePixels(pixels, 0, 0, tilewidth, tileheight, 0)
    	drawo(tilewidth/3,tileheight/3,tilewidth/3,$FFFF0000)
    	DebugLog "finishing image money"    	
    	moneytile.WritePixels(pixels, 0, 0, tilewidth, tileheight, 0)
    End Method
    Method drawo(x1,y1,radius,col)
        For Local y2=-radius To radius
        For Local x2=-radius To radius
            If (y2*y2+x2*x2) &lt;= radius*radius+radius*0.8
                Local x3 = x2+x1
                Local y3 = y2+y1
                Local pc = y3*tilewidth+x3
                If pc&gt;=0 And pc &lt; tilewidth*tileheight
                    pixels[pc] = col
                End If
            End If
        Next
        Next    
	End Method    
    Method drawr(x1,y1,w1,h1,r:Int,g:Int,b:Int)
        For Local y2=y1 Until y1+h1
        For Local x2=x1 Until x1+w1
            Local pc = y2*tilewidth+x2
            If pc &gt;= 0 And pc &lt; tilewidth*tileheight
                pixels[pc] = argb(r,g,b)
            End If
        Next
        Next        
    End Method 
	Function argb:Int(r:Int, g:Int, b:Int ,alpha:Int=255)
        Return (alpha Shl 24) | (r Shl 16) | (g Shl 8) | b          
	End Function    
End Class    


Class monster
    Field lmap:Int[][]
    Field x:Int,y:Int
    Field mdelay:Int=0
    Field monsterspeed:Int
    Field offx:Int,offy:Int
    Field offxt:Int,offyt:Int
    Field mnx:Int,mny:Int
    Method New()
        lmap = makearray()
        ' find place for monster
        Local exitloop:Bool=False
        While exitloop = False
            Local x1:Int=Rnd(5,mapwidth-5)
            Local y1:Int=Rnd(5,mapheight-5)
            If monmap[x1][y1] = 1 Then
                exitloop = True
                lmap[x1][y1]=1
                Self.x = x1
                Self.y = y1
            End If
        Wend
        mnx = Self.x
        mny = Self.y
        offxt = 0
        offyt = 0
        offx = 0
        offy = 0      
        monsterspeed = Rnd(1,15)  
    End Method
    Method update()
    	'Return
        mdelay+=1
        If mdelay&lt; monsterspeed Then Return
        mdelay=0
        If offx&lt;offxt
        	offx+=1        	
        End If
        If offx&gt;offxt
        	offx-=1
        End If
        If offy&lt;offyt
        	offy+=1
        End If
        If offy&gt;offyt
        	offy-=1
        End If
        Local set:Bool=False
        If 	offx=offxt And
        	offy=offyt Then
        	set=True
        End If
        If set=False Then Return
'        DebugLog offx+":"+offxt+","+offy+":"+offyt
        x = mnx
        y = mny

        lmap[x][y]+=1
        If lmap[x][y] &gt; 1000
            For Local y1=0 Until mapheight
            For Local x1=0 Until mapwidth
                lmap[x1][y1] = 0
            Next
            Next
            lmap[x][y]=1
        End If
        Local exitloop:Bool=False
        Local db:Int=0
        While exitloop = False            
        	db+=1
        	If db&gt;200 Then exitloop=True
            Local y2:Int=Rnd(-2,2)
            Local x2:Int=Rnd(-2,2)
            If monmap[x+x2][y+y2] = 1
	            If lmap[x+x2][y+y2] &lt;= lmap[x][y]
	            	offx = 0
	            	offy = 0
	            	offxt = 0
	            	offyt = 0
	            	If x2&lt;0
	            		offxt -= tilewidth
	            	Elseif x2&gt;0
	            		offxt += tilewidth
	            	End If
	            	If y2&lt;0
	            		offyt -= tileheight
	            	Elseif y2&gt;0
	            		offyt += tileheight	            	
	            	End If
	            	'offxt=x2*tilewidth
	            	'offyt=y2*tileheight	            	
	            	mnx=x+x2
	            	mny=y+y2	            	
            	    exitloop=True
                	Return
            	End If
            End If            
        Wend
    End Method
    Method draw()
        SetColor 255,0,0
        Local x1 = (x*tilewidth)
        Local y1 = (y*tileheight)
        x1-=(mapx*tilewidth)
        y1-=(mapy*tileheight)
        x1+=mapsx
        y1+=mapsy
        x1+=offx
        y1+=offy
        DrawRect 	x1-tilewidth,
        			y1,
        			tilewidth,tileheight
        SetColor 255,255,255
        DrawText 	"M",
        			(x1-tilewidth)+(tilewidth/2),
        			y1+tileheight/2,
        			0.5,0.5
    End Method
End Class


Class player
    Field x:Float=3*tilewidth
    Field y:Float=3*tileheight
    Field width:Int = tilewidth
    Field height:Int = tileheight
    Field keys:Int = 0
    Field coins:Int = 0
    Field health:Int = 3
    Field maxhealth:Int=10
End Class

Class mapgen
    Field gmap:Int[mapwidth][]
    Field hmap:Int[mapwidth][]
    Field twidth:Float,theight:Float
    Method New()
        For Local i = 0 Until mapwidth
            gmap[i] = New Int[mapheight]
            hmap[i] = New Int[mapheight]
        Next        
        twidth=640/mapwidth
        theight=480/mapheight
        makehmap
        makemap
    End Method
    Method makemap()
    	DebugLog "make map"
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            map[x][y] = hmap[x][y]
        Next
        Next
        ex = Rnd(10,mapwidth-10)
        ey = Rnd(10,mapheight-10)
        Local numpaths:Int = (mapwidth*mapheight)/700
        DebugLog "make area's"
        For Local i=0 Until numpaths            
            sx = ex
            sy = ey
            Local exitloop:Bool=False
            While exitloop = False
                ex = Rnd(10,mapwidth-10)            
                ey = Rnd(10,mapheight-10)
                If sx&lt;&gt;ex And sy&lt;&gt;ey Then
                    exitloop = True
                End If
            Wend
            findpath    
            For Local ii:=Eachin path
                Local s:Int=2
                If Int(Rnd(1,5)) = 2
                    s=Rnd(2,5)
                    Elseif Int(Rnd(1,9)) = 2
                    s=8
                End If
                For Local y=-s/2 Until s/2
                For Local x=-s/2 Until s/2
                    If     ii.x+x &gt;= 0 And ii.x+x &lt;mapwidth And
                        ii.y+y &gt;= 0 And ii.y+y &lt; mapheight
                      gmap[ii.x+x][ii.y+y] = 1
                      pmap[ii.x+x][ii.y+y] = 1
                     End If
                Next
                Next
            Next
        Next        

		' make monster map
		For Local y=0 Until mapheight
		For Local x=0 Until mapwidth
			If gmap[x][y] = 1
				monmap[x][y] = 1
			End If
		Next
		Next

       	DebugLog "add walls"
        ' here add the walls
        For Local y=1 Until mapheight-1
        For Local x=1 Until mapwidth-1
            If gmap[x][y] = 0 
            If gmap[x+1][y] = 1
            gmap[x][y]=2
            End If
            End If
            If gmap[x][y] = 1
            If gmap[x+1][y] = 0
            gmap[x+1][y] = 2
            End If
            End If
            If gmap[x][y] = 0
            If gmap[x][y+1] = 1
            gmap[x][y] = 2
            End If
            End If
            If gmap[x][y] = 1
            If gmap[x][y+1] = 0
            gmap[x][y+1] = 2
            End If
            End If
        Next
        Next
        DebugLog "set player on map and placecoins"
        ' set player on maptile
        setplayerposition
        DebugLog "place coins"
        placecoins((mapwidth*mapheight)/260)
		DebugLog "place life"
		placehealth((mapwidth*mapheight)/1000)
        ' map conversion
        DebugLog "turn walkable into rock"
        ' turn walkable into rock
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
        	If gmap[x][y] = 0 Then gmap[x][y] = 7
		Next
		Next
		DebugLog "Turn floor into walkable"
		' turn floor into walkable
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            If gmap[x][y] = 1 Then
                gmap[x][y] = 0
            End If
            If gmap[x][y] = 2
                gmap[x][y] = 1
            End If
        Next
        Next
    End Method
    Method drawmap()
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            If gmap[x][y] = 1
                SetColor 150,150,150
                DrawRect     x*twidth,y*theight,
                            twidth,theight
            End If
            If gmap[x][y] = 2
                SetColor 200,200,200
                DrawRect     x*twidth,y*theight,
                            twidth,theight
            End If            
        Next
        Next 
        SetColor 255,255,0
		drawboxedrect(	mapx*twidth,mapy*theight,
						(DeviceWidth/tilewidth)*twidth,
						(DeviceHeight/tileheight)*theight)        
    End Method
    Method makehmap()
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            hmap[x][y] = 3
        Next
        Next
        For Local i=0 To (mapwidth*mapheight)/10
            Local w:Int=Rnd(3,8)
            Local h:Int=Rnd(3,8)
            Local x:Int=Rnd(3,mapwidth-8)
            Local y:Int=Rnd(3,mapheight-8)
            For Local y1=-w/2 To w/2
            For Local x1=-h/2 To h/2
                hmap[x+x1][y+y1]+=1
            Next
            Next
        Next
    End Method
    Method drawhmap()        
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            SetColor hmap[x][y]*10,0,0
            DrawRect     x*twidth,y*theight,
                        twidth,theight
        Next
        Next
    End Method
    Method placehealth(amount:Int)
        For Local i=0 Until amount
            Local exitloop:Bool=False
			Local exloop:Int=0
            While exitloop = False
                Local x:Int=Rnd(0,mapwidth)
                Local y:Int=Rnd(0,mapheight)
                If gmap[x][y] = 1
                    gmap[x][y] = 3 
                    exitloop = True                
                End If
                exloop+=1
                If exloop&gt;100 Then exitloop=True
            Wend                
        Next
    End Method

    Method placecoins(amount:Int)
        For Local i=0 Until amount
            Local exitloop:Bool=False
			Local exloop:Int=0
            While exitloop = False
                Local x:Int=Rnd(0,mapwidth)
                Local y:Int=Rnd(0,mapheight)
                If gmap[x][y] = 1
                    gmap[x][y] = 4 
                    exitloop = True                
                End If
                exloop+=1
                If exloop&gt;100 Then exitloop=True
            Wend                
        Next
    End Method
    Method setplayerposition()
		Local exitloop:Bool=False
		Local eo:Int=0
		While exitloop = False
			eo+=1
			If eo&gt;500 Then
				remakemap = True
				Return
			End If
			Local x:Int=Rnd(mapwidth)
			Local y:Int=Rnd(mapheight)
			If gmap[x][y] = 1
				mapx = x-(DeviceWidth/tilewidth)/2
				mapy = y-(DeviceHeight/tileheight)/2
				p.x = (DeviceWidth)/2
				p.y = (DeviceHeight)/2
				mapsx = 0
				mapsy = 0
				exitloop = True
			End If
		Wend
    End Method
End Class

Class openlist
    Field x:Int
    Field y:Int
    Field f:Int
    Field g:Int
    Field h:Int
    Field px:Int
    Field py:Int
    Method New(    x:Int=0,y:Int=0,f:Int=0,
                g:Int=0,h:Int=0,px:Int=0,
                py:Int=0)
        Self.x=x
        Self.y=y
        Self.f=f
        Self.g=g
        Self.h=h
        Self.px=px
        Self.py=py
    End Method
End Class
Class closedlist
    Field x:Int
    Field y:Int
    Field px:Int
    Field py:Int 
    Method New(x:Int,y:Int,px:Int,py:Int)
        Self.x = x
        Self.y = y
        Self.px = px
        Self.py = py
    End Method
End Class
Class pathnode
    Field x:Int
    Field y:Int
    Method New(x:Int,y:Int)
        Self.x = x
        Self.y = y
    End Method
End Class

Global mytiles:tiles
Global ol:List&lt;openlist&gt; = New List&lt;openlist&gt;
Global cl:List&lt;closedlist&gt; = New List&lt;closedlist&gt;
Global path:List&lt;pathnode&gt; = New List&lt;pathnode&gt;
Global mymonster:List&lt;monster&gt; = New List&lt;monster&gt;

Global mymapgen:mapgen

' the player class in p
Global p:player = New player

Class MyGame Extends App
    Method OnCreate()
    	mytiles = New tiles
        SetUpdateRate(60)
        For Local i=0 Until mapwidth
			monmap[i] = New Int[mapheight]
            map[i] = New Int[mapheight]
            olmap[i] = New Int[mapheight]
            clmap[i] = New Int[mapheight]
            pmap[i] = New Int[mapheight]
        Next        
        mymapgen = New mapgen()
        For Local y=0 Until mapheight
        For Local x=0 Until mapwidth
            map[x][y] = mymapgen.gmap[x][y]
        Next
        Next
        For Local i=0 Until 5
        	mymonster.AddLast(New monster())
       	Next
    End Method
    Method OnUpdate()
        waittime+=1
'        If waittime&gt;120
'		If Rnd(0,100)&gt;98 Then remakemap=True

        For Local i:=Eachin mymonster
            i.update
        Next        


		showmap=False
		If KeyDown(KEY_M)
			showmap=True
		End If
        If 	KeyHit(KEY_T) Or 
        	remakemap=True' Or
        	'waittime&gt;180 Then
			mymonster.Clear        	
 			waittime=0
        	remakemap=False
        	Seed=Millisecs()
            mapwidth=Rnd(30,200)
            mapheight=Rnd(30,200)
            monmap = makearray()
            map = makearray()
            olmap = makearray()
            clmap = makearray()
            pmap = makearray()
            mymapgen = New mapgen()
            For Local y=0 Until mapheight
            For Local x=0 Until mapwidth
                map[x][y] = mymapgen.gmap[x][y]
            Next
            Next
           	For Local i=0 Until (mapwidth*mapheight)/500
        		mymonster.AddLast(New monster())
       		Next            
            If ptc(0,0)
            	remakemap=True
            End If
        End If            
'            waittime = 0
'        End If
        ' scrolling rpg part
        For Local i=0 Until 2
        If p.x &gt; DeviceWidth / 2
            If mapx+(DeviceWidth/tilewidth) &lt; mapwidth-1
                mapsx-=1
                If mapsx &lt; 0 Then 
                    mapsx = tilewidth-1
                    mapx += 1
                Endif
                p.x-=1
            End If
        End If
        Next

        For Local i=0 Until 2
        If p.x &lt; DeviceWidth / 2
            If mapx &gt; 0
                mapsx+=1
                If mapsx &gt; tilewidth Then 
                    mapsx = 0
                    mapx -= 1
                Endif
                p.x+=1
            End If
        End If
        Next
        ' scrolling down
        For Local i=0 Until 2
        If p.y &gt; DeviceHeight / 2
            If mapy+(DeviceHeight/tileheight) &lt; mapheight-1
                mapsy-=1
                If mapsy &lt; 0 Then 
                    mapsy = tileheight-1
                    mapy += 1
                Endif
                p.y-=1
            End If
        End If
        Next
        ' scrolling up
        For Local i=0 Until 2
        If p.y &lt; DeviceHeight / 2
            If mapy &gt; 0
                mapsy+=1                
                If mapsy &gt; tileheight-1 Then 
                    mapsy = 0
                    mapy -= 1
                Endif
                p.y+=1
            End If
        End If
        Next

        
        If KeyDown(KEY_RIGHT)
            ptcs(1,0)
            For Local i=0 Until 2
                If ptc(1,0) = False
                p.x+=1
                End If
            Next
        End If
        If KeyDown(KEY_LEFT)
            ptcs(-1,0)
            For Local i=0 Until 2
                If ptc(-1,0) = False
                p.x-=1
                End If
            Next
        End If
        If KeyDown(KEY_UP)
            ptcs(0,-1)
            For Local i=0 Until 2
                If ptc(0,-1) = False
                p.y-=1
                End If
            Next
        End If
        If KeyDown(KEY_DOWN)
            ptcs(0,1)
            For Local i=0 Until 2
                If ptc(0,1) = False
                p.y+=1
                End If
            Next
        End If        
    End Method
    Method OnRender()
        Cls(0,0,0)
        If remakemap=True Then Return
      	If showmap=True Then
			mymapgen.drawmap
		End If
		If showmap = False		
	        SetColor 255,255,255        
	        drawmap
	        SetColor 255,255,0
	        DrawOval p.x,p.y,p.width,p.height
	        For Local i:=Eachin mymonster
            	i.draw
        	Next         
	        SetColor 0,0,0
	        DrawRect 0,0,DeviceWidth,32
	        SetColor 255,255,255
	        DrawText "Keys : "+p.keys,10,0
	        DrawText "Coins : "+p.coins,10,16
	        DrawText 	"Health : "+p.health+
	        			" of "+p.maxhealth,96,0
	        DrawText 	"Use Cursor keys to move.",
	        			DeviceWidth/2,0
	        DrawText 	"Collect coins, press t = Teleport"+
	        			" to new cavern.",DeviceWidth/2,16
	        DrawText 	"Press m for mapscreen.",
	        			DeviceWidth/2,DeviceHeight-20
	 	End If
    End
End


' player collide with special blocks.
Function ptcs:Int(offsetx:Int=0,offsety:Int=0)
    Local cx = (p.x+offsetx)/tilewidth+mapx
    Local cy = (p.y+offsety)/tileheight+mapy
    For Local y2=cy-1 Until cy+4
    For Local x2=cx-1 Until cx+4
        If     x2&gt;=0 And x2&lt;mapwidth And 
            y2&gt;=0 And y2&lt;mapheight
            If map[x2][y2] &gt; 0
                Local x3 = (x2-mapx)*tilewidth-tilewidth+mapsx
                Local y3 = (y2-mapy)*tileheight+mapsy
                If rectsoverlap(    p.x+offsetx,
                                    p.y+offsety,
                                    p.width,
                                    p.height,
                                    x3,y3,
                                    tilewidth,
                                    tileheight) = True
                    Select map[x2][y2]
                        Case 2
                        If p.keys &gt; 0 
                            map[x2][y2] = 0
                            p.keys-=1
                        End If
                        Case 3 'health
                        If p.health &lt; p.maxhealth
	                        map[x2][y2] = 0
    	                    p.health+=1
    	                    Else
    	                    map[x2][y2] = 0
    	                    p.maxhealth+=1
    	                    p.health+=1
    	                End If
                        Case 4 'coins
                        map[x2][y2] = 0
                        p.coins+=1
                    End Select
                End If
            End If
        End If
    Next
    Next
    Return 0
End Function

'player collide with solid blocks true/false
Function ptc:Bool(offsetx:Int=0,offsety:Int=0)
    Local cx = (p.x+offsetx)/tilewidth+mapx
    Local cy = (p.y+offsety)/tileheight+mapy
    For Local y2=cy-1 Until cy+4
    For Local x2=cx-1 Until cx+4
        If     x2&gt;=0 And x2&lt;mapwidth And y2&gt;=0 And 
            y2&lt;mapheight
            If     map[x2][y2] = 1 Or map[x2][y2] = 2 Or 
                map[x2][y2] = 5 Or map[x2][y2] = 6 Or 
                map[x2][y2] = 7
                Local x3 = (x2-mapx)*tilewidth-tilewidth+mapsx
                Local y3 = (y2-mapy)*tileheight+mapsy
                If rectsoverlap(p.x+offsetx,p.y+offsety,
                                p.width,p.height,x3,y3,
                                tilewidth,tileheight) = True
                    Return True
                End If
            End If
        End If
    Next
    Next
    Return False
End Function



Function drawmap:Void()
    For Local y=0 To DeviceHeight/tileheight
    For Local x=0 To DeviceWidth/tilewidth
        Local x1 = ((x*tilewidth)+mapsx)-tilewidth
        Local y1 = ((y*tileheight)+mapsy)
        Local mw:Int=mapwidth
        Local mh:Int=mapheight
        Local mx:Int=mapx
        Local my:Int=mapy
        If 	x+mapx&lt;mapwidth And
        	x+mapx&gt;0 And
        	y+mapy&lt;mapheight And
        	y+mapy&gt;0
	        Select map[x+mapx][y+mapy]
	        	Case 0 'ground
	        	DrawImage mytiles.groundtile,x1,y1
    	        Case 1'Wall
'        	    SetColor 100,100,100
'            	DrawRect x1,y1,tilewidth,tileheight
				DrawImage mytiles.walltile,x1,y1
	            Case 2'Door
    	        SetColor 200,100,0
        	    DrawRect x1,y1,tilewidth,tileheight
            	Case 3'Health
	            SetColor 200,0,0
    	        DrawOval x1+4,y1+4,tilewidth-8,tileheight-8
        	    SetColor 255,255,255
            	DrawText "H",x1+tilewidth/2,y1+tileheight/2,0.5,0.5
	            Case 4'Coin
    	        'SetColor 255,255,0
        	    'DrawOval x1+4,y1+4,tilewidth-8,tileheight-8
            	'SetColor 255,255,255
            	DrawImage mytiles.moneytile,x1,y1
	            DrawText "$",x1+tilewidth/2,y1+tileheight/2,0.5,0.5
    	        Case 5'tree
        	    SetColor 0,200,0
            	DrawPoly(    [Float(x1+16),y1 ,x1+tilewidth,
                        y1+tileheight , x1,y1+tileheight])
	            Case 6'water
    	        SetColor 0,0,200
        	    DrawRect x1,y1,tilewidth,tileheight
            	Case 7'rock
	            'SetColor 150,50,0
    	        'DrawRect x1,y1+10,tilewidth,tileheight-10
    	        DrawImage mytiles.rocktile,x1,y1
    	        'DrawPoly([Float(x1+tilewidth/2),y1,x1+tilewidth,
    	        '			y1+tileheight,x1,y1+tileheight])
    	        			
        	End Select        
        End If
    Next
    Next
End Function

Function rectsoverlap:Bool(    x1:Int, y1:Int, w1:Int, 
                            h1:Int, x2:Int, y2:Int, 
                            w2:Int, h2:Int)
    If     x1 &gt;= (x2 + w2) Or 
        (x1 + w1) &lt;= x2 Then Return False
    If     y1 &gt;= (y2 + h2) Or 
        (y1 + h1) &lt;= y2 Then Return False
    Return True
End Function

Function drawboxedrect:Void(x:Int,y:Int,w:Int,h:Int)
    DrawLine x,y,x+w,y
    DrawLine x,y,x,y+h
    DrawLine x,y+h,x+w,y+h
    DrawLine x+w,y,x+w,y+h
End Function

Function makearray:Int[][]()
    Local aa:Int[mapwidth][]
    For Local i=0 Until mapwidth
        aa[i] = New Int[mapheight]
    Next
    Return aa
End Function

Function findpath:Bool()
    If sx = ex And sy = ey Then Return False
    For Local y=0 Until mapheight
    For Local x=0 Until mapwidth
        olmap[x][y] = 0
        clmap[x][y] = 0
    Next
    Next
    ol.Clear
    cl.Clear
    path.Clear
    ol.AddFirst(New openlist(sx,sy))
    Local tx:Int
    Local ty:Int
    Local tf:Int
    Local tg:Int
    Local th:Int
    Local tpx:Int
    Local tpy:Int
    Local newx:Int
    Local newy:Int
    Local lowestf:Int
    olmap[sx][sy] = 1
    While ol.IsEmpty() = False
        lowestf = 100000
        For Local i:=Eachin ol
            If i.f &lt; lowestf
                lowestf = i.f
                tx = i.x
                ty = i.y
                tf = i.f
                tg = i.g
                th = i.h
                tpx = i.px
                tpy = i.py
            End If
        Next
        If tx = ex And ty = ey
            cl.AddLast(New closedlist(tx,ty,tpx,tpy))
            findpathback
            Return True
        Else
            removefromopenlist(tx,ty)
            olmap[tx][ty] = 0
            clmap[tx][ty] = 1
            cl.AddLast(New closedlist(tx,ty,tpx,tpy))
            For Local y=-1 To 1
            For Local x=-1 To 1
                newx = tx+x
                newy = ty+y
                If     newx&gt;=0 And newy&gt;=0 And 
                    newx&lt;mapwidth And newy&lt;mapheight
                If olmap[newx][newy] = 0
                If clmap[newx][newy] = 0
                    olmap[newx][newy] = 1
                    Local gg:Int
                    If pmap[newx][newy] = 1
                        gg=1
                        Else
                        gg = map[newx][newy]+1
                    End If
                    Local hh = distance(newx,newy,ex,ey)
                    Local ff = gg+hh
                    ol.AddLast(New openlist(newx,
                                            newy,ff,
                                            gg,hh,
                                            tx,ty))
                End If
                End If
                End If
            Next
            Next
        End If
    Wend
    Return False
End Function

Function findpathback:Bool()
    Local x=ex
    Local y=ey
    path.AddFirst(New pathnode(x,y))
    Repeat
        For Local i:=Eachin cl
            If i.x = x And i.y = y
                x = i.px
                y = i.py
                path.AddFirst(New pathnode(x,y))
            End If
        Next
        If x = sx And y = sy Then Return True
    Forever    
End Function

Function removefromopenlist:Void(x1:Int,y1:Int)
    For Local i:=Eachin ol
        If i.x = x1 And i.y = y1
            ol.Remove i
            Exit
        End If
    Next
End Function

Function distance:Int(x1:Int,y1:Int,x2:Int,y2:Int)
    Return Abs(x2-x1)+Abs(y2-y1)
End Function

Function Main()
    New MyGame()
End
</textarea><br><br>(edit) I put some monsters in it. No collision yet. Made them scroll smoothly <br><br></td></tr></table><br>
<a name="2109799"></a>

<a name="2109802"></a>

<a name="2109795"></a>

<a name="2109794"></a>

<a name="2109793"></a>

<a name="2109792"></a>

<a name="2109789"></a>

<a name="2109783"></a>

<a name="2109781"></a>

<a name="2109803"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very awesome.  I was actually planning on writing a map generator like this myself for the past few weeks, and I was surprised that I missed this thread!  The strategy of using A* to "navigate" a heightmap may end up producing a lot of maps where a* enemy AI strategies are "normalized" quite a bit to a usual behavior.  You may get more oomph out of your enemies' AI by "salting" the levels with a few obstacles which change this behavior.<br><br>I'd love to see versions of both of your generators which have more commenting inside them to explain what strategy it's currently taking, so that it may be easier to tweak/extend these generators more.<br><br>Also, since it seems relevant to the thread:  The strategy used in Nuclear Throne for level generation is yet another interesting way to make a bit more semi-organic maps, one which carves out rooms by having a robot meander until it reaches a set tile limit (with a random chance of spawning identical robots with smaller TTLs)   <a href="http://www.vlambeer.com/2013/04/02/random-level-generation-in-wasteland-kings/" target="_blank">http://www.vlambeer.com/2013/04/02/random-level-generation-in-wasteland-kings/</a> <br><br></td></tr></table><br>
<a name="2109873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tiresius</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I love info on dungeon generation thank you for sharing.  For my little rogue-like I eventually used a simple flood-fill algorithm because I needed to guarantee that there weren't any rooms off on their own and separate.  The way you're building your maps this wouldn't be a problem for you, but I had corridors pushing out of rooms until it hit another open space, so it was possible for two rooms to join with each other and nobody else.<br><br>I want to eventually grow my code into doing different maze patterns, etc.<br><br>Fun stuff !! <br><br></td></tr></table><br>
<a name="2110369"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pakz</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wanted to make another map generator yesterday but got distracted. It would have shapes randomly placed on the map with a random+minimum distance from other objects on the map. I saw a map like that recently on rogue basin I thought.<br><br>I think map generation is fun to think about and make to btw (though difficult for some effects). I still want to try and make a map generator for a platformer so that I can play around in unlimited amounts of levels and have useable code. But I have not gotten to the point that I saw it clear enough to start coding.<br><br>One thing that I read once was to premake map parts that would all fit together or based on a pattern and them mix them into a new map. I still have not tried to make that yet.<br><br>I wish there were more tutorials and text online on map generation written so that a 5 year old can understand it.(reddit:explain it like i'm 5) I have not a clue most of the time what it is about. (like the text in ai books) <br><br></td></tr></table><br>
<a name="2110395"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I wish there were more tutorials and text online on map generation written so that a 5 year old can understand it.(reddit:explain it like i'm 5) I have not a clue most of the time what it is about. (like the text in ai books) <br></div><br><br>The mystery is part of the fun, but also part of what makes it interesting.  It's not one of those "trade secrets" that require some sorta math magician to reverse-engineer the most efficient way, it's more like an art, where you can have a ton of different styles, each producing something unique, interesting, and applicable to its own niche.  That's also why I think this thread is interesting!<br><br>The generator I was writing down on paper before prototyping was going to be one based off large rectangles, connected together with a few "strands" of hallways.  I was hoping that the large rooms would be more conducive to the type of gameplay I wanted, while "gating" a bit of the action so that the pace was more controllable.  Simple concept, but by itself would probably make very boring looking dungeons.  Each of these generators make very interesting things, and I look forward to seeing more of them, to see how they can be imagined as different types of dungeons, etc <br><br></td></tr></table><br>
<a name="2110579"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >impixi</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Impressive results. Thanks for posting your code. <br><br></td></tr></table><br>
<a name="2111008"></a>

<a name="2111009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://i.imgur.com/j1Q34sF.png"><br>The other day I decided to try my own take on a generator based partly on the wandering floor generator used in Nuclear Throne, but spawning rects of variable size within a min/max specification not necessarily square nor directly adjacent to one another.  Press spacebar to regen.<br><br><a href="https://dl.dropboxusercontent.com/u/1417196/wandering_room/index.html" target="_blank">https://dl.dropboxusercontent.com/u/1417196/wandering_room/index.html</a><br><br>The technique starts with a center room, which has an "origin" / pivot point which is moved in a random direction towards the edge of the room.  A second room is generated,  and the edge of the new room is butted up against the edge of the previous room.  It then slides the new room to a random point along the axis perpendicular to the direction the origin point moved.  The origin is then moved to the center of the new room, and the direction is rotated 90, 180, or 270 degrees.  The process then repeats until the specified dungeon size is reached.  There is a threshold for where the pivot "winds"/rotates vs. tends to stay in a straight hallway.  There are also variables for room overlap tendency as the origin moves, min/max room sizes, and min/max dungeon size.<br><br>Not yet implemented is recursive spawning of rooms to create more "tendril-like" and organic floor layouts. <br><br></td></tr></table><br>
<a name="2111007"></a>

<a name="2111005"></a>

<a name="2111006"></a>

<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
