<!DOCTYPE html><html lang="en" ><head ><title >Simple File System</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Simple File System</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=512" >Monkey Code</a>/<a href="#bottom" >Simple File System</a><br><br>
<a name="2054274"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Goodlookinguy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Edit 7/1/2012: A newer version of Monkey broke this code (I think). I haven't tried fixing it because I'm using Monkey JSON for my file system now. If it still works, great! If it doesn't, don't be surprised.</b><br><br><b>Edit 4/5/2013:</b> An even newer version of my JSON file system can be <a href="https://bitbucket.org/Goodlookinguy/xaddon/src/47494a88a945c174ba3809e77353a051bb5b775b/files/cFileSystem.monkey?at=default" target="_blank">grabbed here</a>.<br><br>I had been working on some database specifications and realized that I couldn't use it in Monkey because it has multiple files have to be accessed and altered. So, I came up with this. It's kind of hacky at the moment because I wrote it extremely fast. It works nonetheless and is very, very simple to use.<br><br>Documentation (Generated by JungleIDE): <a href="http://nrgs.org/skyknitters/docs/FileSystemS.monkey.html" target="_blank">http://nrgs.org/skyknitters/docs/FileSystemS.monkey.html</a><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">#Rem
	File: Simple File System (This is not the Complex Compressed File System)
	Author: Nicholas Grant
	Revision: 2
	Purpose: Reading, writing, adding, deleting, copying, moving, of files in the system.
	
	Note(s): Only ASCII is supported in this Monkey implementation. Little Endian and Big Endian
			 most/least to least/most significant byte is supported.
			 
			 The implementation of the classes need some serious cleanup and/or optimization.
	
	010 Editor Structure : <a href="http://nrgs.org/files/structure/FileSystemS.bt" target="_blank">http://nrgs.org/files/structure/FileSystemS.bt</a>
	
	[fixed]TODO: Fix pathing issues! Correctly implement ../ and ./ as well as reading from folder regardless of those[/fixed]
	
#End

Strict

Import mojo

#Rem
	Summary: To read and write values to and from byte form
#End
Class NReader
	
	' - - - - - - - - - - - - - - - - - - - - - -
	' - - - - - - - - P U B L I C - - - - - - - -
	Public
	
	'Summary: Read a byte in str string and return value
	Method ReadByte:Int( str:String, encodingMode:Int = 1 )
		Local ret:Int = str[0]
		If ( ret Mod 128 &lt;&gt; ret )
			ret |= $FFFFFF80
		End
		Return ret
	End
	
	'Summary: Read an unsigned byte in str string and return value
	Method ReadUnsignedByte:Int( str:String, encodingMode:Int = 1 )
		Return str[0]
	End
	
	'Summary: Read a short in str string and return value
	Method ReadShort:Int( str:String, encodingMode:Int = 1 )
		Local ret:Int
		If ( encodingMode = 1 )
			ret = str[1] Shl 8 | str[0]
			If ( ret Mod 32768 &lt;&gt; ret )
				ret |= $FFFF8000
			End
		Else
			ret = str[0] Shl 8 | str[1]
		End
		Return ret
	End
	
	'Summary: Read an unsigned short in str string and return value
	Method ReadUnsignedShort:Int( str:String, encodingMode:Int = 1 )
		If ( encodingMode = 1 )
			Return str[1] Shl 8 | str[0]
		Else
			Return str[0] Shl 8 | str[1]
		End
	End
	
	'Summary: Read an integer in string str and return value
	Method ReadInteger:Int( str:String, encodingMode:Int = 1 )
		Local ret:Int
		If ( encodingMode = 1 )
			ret = str[3] Shl 24 | str[2] Shl 16 |
				  str[1] Shl 8 | str[0]
		Else
			ret = str[0] Shl 24 | str[1] Shl 16 |
				  str[2] Shl 8 | str[3]
		End
		Return ret
	End
	
	'Summary: Read an integer in string str and return value
	Method ReadInt:Int( str:String, encodingMode:Int = 1 )
		Local ret:Int
		If ( encodingMode = 1 )
			ret = str[3] Shl 24 | str[2] Shl 16 |
				  str[1] Shl 8 | str[0]
		Else
			ret = str[0] Shl 24 | str[1] Shl 16 |
				  str[2] Shl 8 | str[3]
		End
		Return ret
	End
	
	'Summary: Writes given value as a byte
	Method WriteByte:String( value:Int, encodingMode:Int = 1 )
		Return String.FromChar( value )
	End
	
	'Summary: Writes given value as an unsigned byte
	Method WriteUnsignedByte:String( value:Int, encodingMode:Int = 1 )
		Return String.FromChar( value )
	End
	
	'Summary: Writes a given value as a short
	Method WriteShort:String( value:Int, encodingMode:Int = 1 )
		Local ret:String = ""
		If ( encodingMode = 1 )
			ret = String.FromChar( value ) + String.FromChar( value Shr 8 )
		Else
			ret = String.FromChar( value Shr 8 ) + String.FromChar( value )
		End
		Return ret
	End
	
	'Summary: Writes a given value as an unsigned short
	Method WriteUnsignedShort:String( value:Int, encodingMode:Int = 1 )
		Local ret:String = ""
		If ( encodingMode = 1 )
			ret = String.FromChar( value ) + String.FromChar( value Shr 8 )
		Else
			ret = String.FromChar( value Shr 8 ) + String.FromChar( value )
		End
		Return ret
	End
	
	'Summary: Writes a given value as an integer
	Method WriteInteger:String( value:Int, encodingMode:Int = 1 )
		Local ret:String = ""
		If ( encodingMode = 1 )
			ret = String.FromChar( value ) + String.FromChar( value Shr 8 ) +
				  String.FromChar( value Shr 16 ) + String.FromChar( value Shr 24 )
		Else
			ret = String.FromChar( value Shr 24 ) + String.FromChar( value Shr 16 ) +
				  String.FromChar( value Shr 8 ) + String.FromChar( value )
		End
		Return ret
	End
	
End

Class NFileSystem
	
	' - - - - - - - - - - - - - - - - - - - - - -
	' - - - - - - - - P R I V A T E - - - - - - -
	Private
	Field _nFileName:String
	
	Field _fileCount:Int,
		  _fileOpen:Bool,
		  _fileNames:String[],
		  _fileIndexes:Int[],
		  _dataIndex:Int,
		  _index:Int,
		  _directory:String
	
	Field _isMonkeySave:Bool
	
	Field _nReader:NReader
	
	Field _version:Int,
		  _data:String
	
	' 1 = Little Endian, 2 = Big Endian
	Field _endianEncoding:Int = 1
	
	' 1 = ASCII, 2 = UTF-8, 3 = UTF-16
	Field _encoding:Int = 1
	
	Field _fileSystemVersion:Int = 1
	
	' - - - - - - - - - - - - - - - - - - - - - -
	' - - - - - - - - M E T H O D S - - - - - - -
	Method Initialize:Void()
		ReadHeader()
		
		'If ( _version &lt; 1 Or _version &gt; 1 )
		'	Error( "SFS Error: File version is not supported!" )
		'End
		
		ReadIndex()
	End
	
	Method ReadByte:Int()
		_index += 1
		Return _nReader.ReadByte( _data[_index-1.._index], _endianEncoding )
	End
	
	Method ReadUnsignedByte:Int()
		_index += 1
		Return _nReader.ReadUnsignedByte( _data[_index-1.._index], _endianEncoding )
	End
	
	Method ReadShort:Int()
		_index += 2
		Return _nReader.ReadShort( _data[_index-2.._index], _endianEncoding )
	End
	
	Method ReadUnsignedShort:Int()
		_index += 2
		Return _nReader.ReadUnsignedShort( _data[_index-2.._index], _endianEncoding )
	End
	
	Method ReadInteger:Int()
		_index += 4
		Return _nReader.ReadInteger( _data[_index-4.._index], _endianEncoding )
	End
	
	Method ReadInt:Int()
		_index += 4
		Return _nReader.ReadInt( _data[_index-4.._index], _endianEncoding )
	End
	
	Method ReadString:String( length:Int )
		_index += length
		Return _data[_index-length.._index]
	End
	
	Method AllocateFileIndexes:Void()
		_fileNames = New String[_fileCount]
		_fileIndexes = New Int[_fileCount]
	End
	
	Method WriteOverExistingFile:Void( fileName:String, data:String )
		Local oldLength:Int = 0
		Local dataIndex:Int = 0
		Local nameLength:Int = 0
		Local fname:String = ""
		
		_index = 6
		
		For Local cnt := 0 To _fileCount - 1
			nameLength = ReadByte()
			fname = ReadString( nameLength )
			dataIndex = 1 + nameLength
			If ( fname = fileName )
				oldLength = ReadInteger()
				_data = _data[0.._index-4] + _nReader.WriteInteger( data.Length() ) + _data[_index.._dataIndex+dataIndex] +
						data + _data[_dataIndex+dataIndex+oldLength..]
			Else
				dataIndex += ReadInteger()
			End
		Next
	End
	
	'Summary: Read file system header
	Method ReadHeader:Void()
		
		' Get Encoding
		_endianEncoding = ReadByte()
		_encoding = ReadByte()
		
		' Get Version
		_version = ReadUnsignedShort()
		
		' Get File Count
		_fileCount = ReadUnsignedShort()
		
	End
	
	Method GetFullPath:String( path:String )
		Local ret:String = ""
		Local realFileName:String = ""
		Local directoryStack:StringStack = New StringStack()
		Local directorySplit:String[]
		
		If ( path[0..1] = "/" )
			directorySplit = path.Split( "/" )
		Else
			directorySplit = ( FixFilePath( _directory + "/" + path ) ).Split( "/" )
		End
		
		directoryStack.Push( "/" )
		
		realFileName = directorySplit[directorySplit.Length()-1]
		
		For Local cnt := 1 To directorySplit.Length() - 2
			If ( directorySplit[cnt] = ".." )
				If ( directoryStack.Length() &gt; 1 )
					directoryStack.Pop()
				Else
					Error( "SFS Error: Cannot go below root directory!" )
				End
			ElseIf ( directorySplit[cnt] = "." Or directorySplit[cnt] = "" )
				' ... Bleh
			Else
				directoryStack.Push( directorySplit[cnt] + "/" )
			End
		Next
		
		directorySplit = directoryStack.ToArray()
		For Local cnt := 0 To directorySplit.Length() - 1
			ret += directorySplit[cnt]
		Next
		
		ret += realFileName
		
		Return ret
	End
	
	Method FixFilePath:String( path:String )
		Return path.Replace( "//", "/" ).Replace( "//", "/" ) ' ...
	End
	
	' - - - - - - - - - - - - - - - - - - - - - -
	' - - - - - - - - P U B L I C - - - - - - - -
	Public
	
	' - - - - - - - - - - - - - - - - - - - - - -
	' - - - - - C O N S T R U C T O R S - - - - -
	
	Method New( fileName:String )
		_nFileName = fileName
		_nReader = New NReader()
		_directory = "/"
		_dataIndex = 6
		_index = 0
	End
	
	Method New()
		_isMonkeySave = True
		_nReader = New NReader()
		_directory = "/"
		_dataIndex = 6
		_index = 0
	End
	
	' - - - - - - - - - - - - - - - - - - - - - -
	' - - - - - - - - M E T H O D S - - - - - - -
	
	'Summary: Clear previous file contents and write a new slate
	Method DeleteAll:Void()
		If ( _isMonkeySave And _fileOpen )
			_data = _nReader.WriteByte(_endianEncoding) + _nReader.WriteByte(_encoding) +
					_nReader.WriteShort(_fileSystemVersion) + _nReader.WriteShort(0)
		End
	End
	
	'Summary: Changes endian encoding
	Method ChangeEndian:Void( endian:String )
		If ( endian = "LE" Or endian = "Little Endian" )
			_endianEncoding = 1
		Else
			_endianEncoding = 2
		End
	End
	
	'Summary: Changes endian encoding
	Method ChangeEndian:Void( endian:Int )
		_endianEncoding = endian
	End
	
	'Summary: Read and store index in memory
	Method ReadIndex:Void()
		AllocateFileIndexes()
		For Local cnt := 0 To _fileCount - 1
			
			Local strlength:Int = ReadByte()
			
			_fileNames[cnt] = ReadString( strlength )
			_fileIndexes[cnt] = ReadInteger()
		Next
		_dataIndex = _index
	End
	
	'Summary: Open and read file into memory
	Method Open:Void()
		_fileOpen = True
		If ( Not _isMonkeySave )
			_data = LoadString( _nFileName )
		Else
			_data = LoadState()
		End
		If ( _data = "" )
			DeleteAll()
		End
		Initialize()
	End
	
	'Summary: Open, clear, and read fresh file system into memory
	Method OpenNew:Void()
		_fileOpen = True
		If ( _isMonkeySave )
			_data = LoadState()
		Else
			Error( "SFS Error: Writing of file " + _nFileName + " is not supported!" )
		End
		DeleteAll()
		Initialize()
	End
	
	'Summary: Reads file and returns contents
	Method ReadFile:String( fileName:String )
		Local index:Int = 0
		Local ret:String = ""
		fileName = GetFullPath( fileName )
		For Local cnt := 0 To _fileCount - 1
			If ( _fileNames[cnt] = fileName )
				Return _data[_dataIndex+index.._dataIndex+index+_fileIndexes[cnt]]
			Else
				index += _fileIndexes[cnt]
			End
		Next
		Error( "SFS Error: File doesn't exist!" )
		Return "" ' Monkey req.
	End
	
	'Summary: Writes file data to memory
	Method WriteFile:Void( fileName:String, data:String )
		If ( _fileOpen )
			Local isNewFile:Bool = True
			fileName = GetFullPath( fileName )
			For Local cnt := 0 To _fileCount - 1
				If ( _fileNames[cnt] = fileName )
					isNewFile = False
					Exit
				End
			Next
			
			If ( Not isNewFile )
				WriteOverExistingFile( fileName, data )
			Else
				' O_O
				_fileCount += 1
				_data = _data[0..4] + _nReader.WriteShort( _fileCount ) + _data[6.._dataIndex] +
						_nReader.WriteByte( fileName.Length() ) + fileName +
						_nReader.WriteInteger( data.Length() ) + _data[_dataIndex..] + data
			End
			
			_index = 6
			ReadIndex()
		Else
			Error( "SFS Error: File was not opened!" )
		End
	End
	
	'Summary: Removes a file from the file system
	Method DeleteFile:Void( fileName:String )
		If ( _fileOpen )
			Local length:Int = 0
			Local dataIndex:Int = 0
			Local nameLength:Int = 0
			Local fname:String = ""
			
			_index = 6
			
			fileName = GetFullPath( fileName )
			
			For Local cnt := 0 To _fileCount - 1
				nameLength = ReadByte()
				fname = ReadString( nameLength )
				#If CONFIG="debug"
				Print "SFS Debug: File Name - " + fname
				#End
				dataIndex = 1 + nameLength
				If ( fname = fileName )
					_fileCount -= 1
					length = ReadInteger()
					_data = _data[0..4] + _nReader.WriteUnsignedShort(_fileCount ) + _data[6.._index-nameLength-5] +
							_data[_index.._dataIndex+dataIndex] + _data[_dataIndex+dataIndex+length..]
				Else
					dataIndex += ReadInteger()
				End
			Next
			
			_index = 6
			ReadIndex()
		Else
			Error( "SFS Error: File was not opened!" )
		End
	End
	
	'Summary: Copy a file from source to destination
	Method CopyFile:Void( source:String, destination:String )
		source = GetFullPath( source )
		destination = GetFullPath( destination )
		If ( source = destination )
			Error( "SFS Error: You cannot copy a file to itself!" )
		End
		If ( _fileOpen )
			WriteFile( destination, ReadFile( source ) )
		Else
			Error( "SFS Error: File was not opened!" )
		End
	End
	
	'Summary: Move a file from source to destination
	Method MoveFile:Void( source:String, destination:String )
		source = GetFullPath( source )
		destination = GetFullPath( destination )
		If ( source = destination )
			Error( "SFS Error: You cannot move a file to itself!" )
		End
		If ( _fileOpen )
			WriteFile( destination, ReadFile( source ) )
			DeleteFile( source )
		Else
			Error( "SFS Error: File was not opened!" )
		End
	End
	
	'Summary: "Close" and remove file data from memory
	Method Close:Void()
		_fileOpen = False
		_data = ""
	End
	
	'Summary: Get the virtual directory specified
	Method GetDirectory:String[]( directory:String )
		Local dir:StringStack = New StringStack()
		Local charIndex:Int = 0
		Local inDirectory:Bool = True
		
		directory = GetFullPath( directory )
		
		For Local cnt := 0 To _fileCount - 1
			If ( directory = _fileNames[cnt][0..directory.Length()] )
				charIndex = directory.Length()
				For charIndex = charIndex To _fileNames[cnt].Length() - 1
					If ( (_fileNames[cnt])[charIndex..charIndex+1] = "/" )
						inDirectory = False
					End
				Next
				If ( inDirectory )
					dir.Push( _fileNames[cnt] )
				End
				inDirectory = True
			End
		Next
		Return dir.ToArray()
	End
	
	'Summary: Change file virtual directory that you're in
	Method ChangeDirectory:Void( directory:String )
		_directory = GetFullPath( directory )
	End
	
	' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	'Summary: Saves data stored in memory to file
	Method ReadAll:String()
		Return _data
	End
	
	'Summary: Write over existing file system data
	Method Write:Void( data:String )
		_data = data
	End
	
	'Summary: Save data if possible
	Method Save:Void()
		If ( _isMonkeySave )
			SaveState( _data )
		Else
			Error( "SFS Error: Writing to file " + _nFileName + " is unsupported!" )
		End
	End
	
End
</textarea><br><br>This is an example test file<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict

Import mojo
Import OpenMapGame.File.FileSystemS '&lt;-- Import from wherever you want

Function Main:Int()
	New Test()
	
	Return 0
End

Class Test Extends App
	Method OnCreate:Int()
		
		Local fileSys:NFileSystem = New NFileSystem()
		
		fileSys.Open()
		
		fileSys.WriteFile( "/test.txt", "Hello World!" )
		fileSys.WriteFile( "/test/file0", "Hello " )
		fileSys.WriteFile( "/test/file1", "World!" )
		
		Print "-- Directory Contents --"
		Local dir:String[] = fileSys.GetDirectory( "test/" )
		
		For Local cnt := 0 To dir.Length() - 1
			Print dir[cnt]
		Next
		
		Print fileSys.ReadFile( "test/file0" ) + fileSys.ReadFile( "test/file1" )
		
		fileSys.Save()
		
		fileSys.Close()
		
		Return 0
	End
End
</textarea><br><br>This will be updated with cleaner code when I have the time. If you get any errors, fix any problems, have criticisms, or whatever, please tell me. I'll attempt to deal with it when I can.<br><br>EDIT 10/22/11: I'm working on a second version that will have iOS compatibility and cached reads, writes, edits, etc. It'll be a while longer though. <br><br></td></tr></table><br>
<a name="2040614"></a>

<a name="2032474"></a>

<a name="2032473"></a>

<a name="2032472"></a>

<a name="2032471"></a>

<a name="2016874"></a>

<a name="2016502"></a>

<a name="2016330"></a>

<a name="2016252"></a>

<a name="2016294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> looks nice, if i have a huge file.. say 500kb and a small file ...say 1kb<br><br>can i access the small file quickly? or does the big file slow it down (loading and parsing)<br><br>For example i could have a saved game of 500kb and an options file of 1kb <br><br></td></tr></table><br>
<a name="2016328"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Goodlookinguy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, theoretically, with the way it's setup. The lower down on the file system it is, the slower it will be. If the 500kb file is first and the 1KB file is next. It should be able to access both files relatively fast.<br><br>It works like<br><br>Stored Index<br>/500kb [stored length: 512000b]<br>/1kb [stored length: 1024b]<br><br>Data starts at: Data Index (After file index)<br><br>To get to position of the file, it takes and adds all previous stored lengths of the files to find the slice location.<br><br>So, the data for /500kb would be at: Data Index to stored length of /500kb<br><br>For the /1kb file, it would be: Data Index + Length of /500kb file to stored length of /1kb <br><br></td></tr></table><br>
<a name="2016299"></a>

<a name="2016302"></a>

<a name="2016303"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> interesting, i may use it later thanks <br><br></td></tr></table><br>
<a name="2016332"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Goodlookinguy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're welcome.<br><br>By the way, here's the quick documentation on it if you want: <a href="http://skyknitters.com/docs/FileSystemS.monkey.html" target="_blank">http://skyknitters.com/docs/FileSystemS.monkey.html</a><br><br>--<br>On this note, after getting some opinions from other people (around me), I'm going to rework how the directories and file index work. The new specifications will speed up file locating if directories are used to separate the data and if a lot of files are used. If very few files are used, it'll actually be a theoretical pinch slower. On the other hand, I'll be able to work some extra things into it easier, that I wanted to do with this one. E.g. A sort function, directory contents that read both files and directories, and data encryption and/or obfuscation. <br><br></td></tr></table><br>
<a name="2016368"></a>

<a name="2016371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Goodlookingguy<br>Have you tested this using ios? As I suspect you may have issues when encoding ints/bytes. Gfk had a problem with his filing system and posted it as a bug, but as it turned out the native class that deals with strings (NSString) on apple devices doesn't like non standard strings. A bit of googling will show up other examples of problems when dealing with apple's own implementation of a string class.<br><br><a href="http://www.monkeycoder.co.nz/Community/posts.php?topic=1653" target="_blank">http://www.monkeycoder.co.nz/Community/posts.php?topic=1653</a> <br><br></td></tr></table><br>
<a name="2016374"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Goodlookinguy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't have a Mac yet and can't test anything with iOS yet. As soon as I get one, in the following months, I'll look into writing a custom string handler if necessary. Or maybe the creator of Monkey can make just that platform act like the rest. Seeing as we're limited to modifying ONE file, it seems unfair to stop us from making these sorts of systems which require the null character in the strings. <br><br></td></tr></table><br>
<a name="2016376"></a>

<a name="2016377"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Or maybe the creator of Monkey can make just that platform act like the rest. <br></div>From what Mark has posted I don't think it's on his list of priorities at the moment. So I would guess if any one is desperate they would have to implement their own solution either as a module or editing the monkey output file directly and then compiling their work. <br><br></td></tr></table><br>
<a name="2016389"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Goodlookinguy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes indeed.<br><br>By any chance, do you know if this problem also affects the LoadState() function in the iOS? If not, I don't think the intended use for this file manager will be a problem.<br><br>Edit: Is it the actual string handling that can't handle null? If not, a simple base64 encode when saving and decode when opening would fix this, right? Just some thoughts in my head. <br><br></td></tr></table><br>
<a name="2016384"></a>

<a name="2016435"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dawlane</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> By any chance, do you know if this problem also affects the LoadState() <br></div>I believe it does as the state file is stored as a string.<br><br><div class="quote"> Edit: Is it the actual string handling that can't handle null? If not, a simple base64 encode when saving and decode when opening would fix this, right? Just some thoughts in my head. <br></div><br>Well from what information I have seen so far NSString isn't capable of handling malformed strings. I believe the usual method is to use a NSData object and parse the data for the relevant information that your looking for.<br><br>At the moment I'm still learning Objective-C and the Foundation Framework.<br><br>So perhaps some who is familiar with the Foundation Framework may be able to explain it better. <br><br></td></tr></table><br>
<a name="2016503"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Goodlookinguy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, thank you very much. I think I'll make an alternative version of this for that platform for the sake of everyone's sanity. I'll just use Base 36 to save space when reading how many bytes.<br><br>---<br>A bug fix for the DeleteFile method not changing the file count length updated. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
