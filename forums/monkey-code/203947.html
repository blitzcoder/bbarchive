<!DOCTYPE html><html lang="en" ><head ><title >Touch Monitor Class</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Touch Monitor Class</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=512" >Monkey Code</a>/<a href="#bottom" >Touch Monitor Class</a><br><br>
<a name="2044311"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Anatol</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>That's going to be a long post, but I thought my touch monitor class might be useful for some other Monkey coders.<br><br>The class monitors any number of touch indices that are supported by the target and records things such as<br><br>* the duration of the touch<br>* the position<br>* the first position/origin (at what coordinates did the touch begin)<br>* the offset relative to the origin<br>* the touch velocity (useful to drag things, etc.)<br>* obviously what touch indices are touching<br>* if a touch has just been released<br><br>And some useful values for multi touch, e.g.<br><br>* the centre position (calculates the centre of multiple touch coordinates)<br>* the average position (usually equals the centre position, but e.g. when one finger is on the left of the screen and three are on the right the average position is more weighted towards the right)<br>* the size (if using 2 or more fingers, what's the size/distance between them)<br>* the size factor (how much increased/decreased the size; useful for pinch gestures)<br><br>Checking if the touch is in a certain area<br><br>* is one or are multiple touches in a certain area?<br>* works with rectangular, circular and elliptic areas (rectangles and ellipses can be rotated)<br>* tons of different methods to use for a lot of different purposes<br><br>The class also has an optional coordinate offset and adjustment ratio which is useful when working with a virtual device size. Enter the correct adjustment ratio and you can work with the virtual values (if your virtual device is 1536x2048 but your actual device is 768x1024 then the adjustment ratio is 2.0 and the TouchMonitor will return virtual values). Set an offset if you have borders, which may happen if the aspect ratio of the virtual device and actual device are different.<br><br>[EDIT] Download (updated version): <a href="http://attic.nugob.org/communities/monkeycoder.co.nz/forum/attachments/touchMonitorTest_2012-12-11.zip" target="_blank">http://attic.nugob.org/communities/monkeycoder.co.nz/forum/attachments/touchMonitorTest_2012-12-11.zip</a><br><br>Screenshot of some information that the class can give you:<br><img src="http://attic.nugob.org/communities/monkeycoder.co.nz/forum/attachments/touchMonitor.png"><br><br>Here's some sample code that demonstrates how to use it. I usually create a Global TouchMonitor instance that can be used for any purpose within the app. Ideally test this with a touch device and use multiple touches:<br>[monkeycode]<br>Strict<br><br>Import mojo<br>Import vector<br>Import touchMonitor<br><br><br>Global Touch:TouchMonitor<br><br><br>Function Main:Int()<br>        New MyApp<br>        Return 0<br>End<br><br><br>Class MyApp Extends App<br>		<br>	Field circleRadius:Float = 50<br>	Field circleVelocity:Vector<br>	Field circleCoord:Vector<br>	<br>	Field rectCoord:Vector<br>	Field showTapInfo:Bool<br>	Field showTouchHoldInfo:Bool<br>	<br>        <br>	Method OnCreate:Int()<br>		SetUpdateRate(60)<br>		Touch = New TouchMonitor(5) ' monitors five touch indices; change the number to monitor more or less indices<br>		<br>		circleVelocity = New Vector<br>		circleCoord = New Vector(DeviceWidth()/2, DeviceHeight()/2)<br>		<br>		rectCoord = New Vector(DeviceWidth()-200, DeviceHeight()-200)<br>		<br>		Return 0<br>	End<br> 	<br>	Method OnUpdate:Int()<br>		' must call this!!!<br>		Touch.Update()<br>		<br>		<br>		'''''''''''''''''''''''''''''''<br>		' SOME EXAMPLES<br>		<br>		<br>		' MONITORING A RECTANGULART AREA ''''''''''''''''''''<br>		<br>		' checks if the user quickly tapped on the rectangle (tap and release in under 0.1 secs)<br>		If Touch.FirstTouchInArea(rectCoord.X, rectCoord.Y, 100, 100) And Touch.Released And Touch.Duration &lt; 100<br>			showTapInfo = Not showTapInfo ' toggle show info<br>		Endif<br>		<br>		' checks if the user touches and holds the touch (for more than 0.5 secs<br>		If Touch.FirstTouchInArea(rectCoord.X, rectCoord.Y, 100, 100) And Touch.Duration &gt; 500<br>			showTouchHoldInfo = True<br>		Endif<br>		<br>		' reset a value on touch release<br>		If Touch.Released<br>			showTouchHoldInfo = False<br>		Endif<br>		<br>		<br>		' MONITORING A CIRCULAR AREA                 ''''''''''''''''''''<br>		<br>		' to drag an element: if the touch is in a circular area then add the touch velocity to the coordinates<br>		If Touch.IsInCircle(circleCoord, circleRadius)<br>			circleVelocity.Set(Touch.Velocity)<br>		Else<br>		' gradually decrease the element velocity when the user isn't dragging the element<br>			circleVelocity.Multiply(0.99)<br>		EndIf<br>		<br>		' add the velocity to the current coordinates (moves the element)<br>		circleCoord.Add(circleVelocity)<br>		<br>		' keep the element within the boundaries of the screen<br>		circleCoord.X = Clamp(circleCoord.X, circleRadius, DeviceWidth() - circleRadius)<br>		circleCoord.Y = Clamp(circleCoord.Y, circleRadius, DeviceHeight() - circleRadius)<br>		<br>		' check if the element is at the edge; if so then reverse the velocity (make it bounce off the edge)<br>		If circleVelocity.X &lt;&gt; 0 And circleCoord.X = circleRadius Or circleCoord.X = DeviceWidth() - circleRadius<br>			circleVelocity.X = -circleVelocity.X<br>		Endif<br>		If circleVelocity.Y &lt;&gt; 0 And circleCoord.Y = circleRadius Or circleCoord.Y = DeviceHeight() - circleRadius<br>			circleVelocity.Y = -circleVelocity.Y<br>		Endif<br>		<br>		<br>		Return 0<br>	End<br>	<br>	Method OnRender:Int()<br>		Cls()<br>		<br>		<br>		' DRAW RECTANGLE AND RELATED INFO '''''''''''''''''''''<br>		<br>		' draw a simple rectangle that changes color if touched/clicked<br>		If Touch.IsInArea(rectCoord.X, rectCoord.Y, 100, 100) Then SetColor(255,0,0)<br>		DrawRect(rectCoord.X, rectCoord.Y, 100, 100)<br>		DrawText("tap quickly", rectCoord.X + 10, rectCoord.Y + 10)<br>		DrawText("or", rectCoord.X + 10, rectCoord.Y + 30)<br>		DrawText("touch hold", rectCoord.X + 10, rectCoord.Y + 50)<br>		<br>		SetColor(255, 255, 255)<br>		<br>		' display something if the user tapped the rectangle<br>		If showTapInfo Then DrawText("Tap the rectangle again to hide this text.", rectCoord.X - 100, rectCoord.Y - 30)<br>		If showTouchHoldInfo Then DrawText("Release the touch to hide this text.", rectCoord.X - 100, rectCoord.Y - 30)<br>		<br>		<br>		' DRAW CIRCLE AND RELATED INFO '''''''''''''''''''''<br>		<br>		' draw a circle (this circle can be dragged according to the code in OnUpdate)<br>		SetColor(255, 128, 0)<br>		DrawCircle(circleCoord.X, circleCoord.Y, 50)<br>		DrawText("drag", circleCoord.X, circleCoord.Y)<br>		<br>		<br>		' VISUALIZE TOUCH POSITIONS ETC. '''''''''''''''''''''<br>		<br>		' draw a circle that shows the touch size (for multi touch only)<br>		SetColor(255, 255, 0)<br>		SetAlpha(0.2)<br>		DrawCircle(Touch.CenterPosition.X, Touch.CenterPosition.Y, Touch.Size/2)<br>		<br>		' center position of multi touch<br>		SetAlpha(1)<br>		DrawText("center position", Touch.CenterPosition.X, Touch.CenterPosition.Y - 30)<br>		SetAlpha(0.3)<br>		DrawCircle(Touch.CenterPosition.X, Touch.CenterPosition.Y, 10)<br>                <br>		' average position of multi touch (this equals the center position above if two fingers are touching the screen, but it is different<br>		' for 3 or more touch indices as it calculates the average position, and not the centre between the minimum and maximum positions;<br>		' e.g, if one finger is touching on the left and three are touching more on the right, the average position will be more weighted to the right)<br>		SetColor(0, 255, 255)<br>		SetAlpha(1)<br>		DrawText("average position", Touch.AveragePosition.X, Touch.AveragePosition.Y + 20)<br>		DrawCircle(Touch.AveragePosition.X, Touch.AveragePosition.Y, 10)<br>                <br>		SetColor(255, 255, 255)<br>		SetAlpha(1)<br>                <br>		' draw some info about each touch index<br>		Local textPositionY:Float = 10<br>		For Local index:= Eachin Touch.TouchDownIndices<br>			DrawText("TOUCH INDEX " + index, 10, textPositionY)<br>			DrawText("     first position: " + Touch.FirstPosition(index).X + ", " + Touch.FirstPosition(index).Y, 10, textPositionY + 25)<br>			DrawText("           position: " + Touch.Position(index).X + ", " + Touch.Position(index).Y, 10, textPositionY + 40)<br>			DrawText("             offset: " + Touch.Offset(index).X + ", " + Touch.Offset(index).Y, 10, textPositionY + 55)<br>			DrawText("           velocity: " + Touch.Velocity(index).X + ", " + Touch.Velocity(index).Y, 10, textPositionY + 70)<br>			DrawText("           duration: " + Touch.Duration(index), 10, textPositionY + 85)<br>			textPositionY += 100<br>			<br>			' visualize each touch index<br>			DrawText("index " + index, Touch.Position(index).X, Touch.Position(index).Y - 40)<br>			SetAlpha(0.3)<br>			DrawCircle(Touch.Position(index).X, Touch.Position(index).Y, 30)<br>			SetAlpha(1)<br>		Next<br>		<br>		' draw touch info (this is mainly useful for multi touch)<br>		If Touch.AnyTouchDown<br>			DrawText("TOUCH INFO (try with multi touch gestures)", 300, 10)<br>			DrawText("           touch size: " + Touch.Size + " (size factor: " + Touch.SizeFactor + ")", 300, 25)<br>			DrawText("     Average position: " + Touch.AveragePosition.X + ", " + Touch.AveragePosition.Y, 300, 40)<br>			DrawText("      Center position: " + Touch.CenterPosition.X + ", " + Touch.CenterPosition.Y, 300, 55)<br>			DrawText("       Average offset: " + Touch.AverageOffset.X + ", " + Touch.AverageOffset.Y, 300, 70)<br>			DrawText("        Center offset: " + Touch.CenterOffset.X + ", " + Touch.CenterOffset.Y, 300, 85)<br>			DrawText("     Average velocity: " + Touch.AverageVelocity.X + ", " + Touch.AverageVelocity.Y, 300, 100)<br>		Endif<br>		<br>		Return 0<br>	End<br>    <br>End<br>[/monkeycode]<br><br>I wrote this class very early on when I was quite new to Monkey, so there are a few things I would probably solve in a different way now, but overall it works very well.<br><br>Also, I have a separate swipe gesture class which extends the Touch class, but I discovered some bugs. I might post this at a later stage.<br><br>(Before I posted the touch monitor class here I found a few bugs which should be fixed now. If you find some more, please let me know.)<br><br>Classes required:<br><br>touchMonitor.monkey [EDIT] updated code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import mojo
Import vector


Class TouchMonitor
	
	Private
	
	Field indices:Int[]
	Field startTime:Int[]
	Field duration:Int[]
	Field previousDuration:Int[]
	Field position:Vector[]
	Field firstPosition:Vector[]
	Field previousPosition:Vector[]
	Field velocity:Vector[]
	Field previousVelocity:Vector[]
	Field offset:Vector[] ' the offset of the touch in relation to the first touch position
	Field previousOffset:Vector[]
	Field touchDown:Bool[]
	Field previousTouchDown:Bool[]
	Field enabled:Bool[]
	Field minPosition:Vector ' stores the minimum X and Y positions of any touching indices
	Field maxPosition:Vector ' stores the maximum X and Y positions of any touching indices
	Field minOffset:Vector ' stores the minimum X and Y offset of any touching indices
	Field maxOffset:Vector ' stores the maximum X and Y offset of any touching indices
	Field size:Float ' stores the size (this is primarily for multi-touch gestures as single touch would always have a size of 1)
	Field firstSize:Float ' saves the first size (a minimum of two touch indices is required and the size must be &gt; 1 to be stored because this is for touch gestures such as pinches)
	Field previousSize:Float ' stores the previous size so that it is possible to calculate a velocity of the size change
	Field sizeFactor:Float
	Field previousSizeFactor:Float
	Field coordinateOffset:Vector ' the offset of the entire coordinate system (to e.g. include a virtual device size)
	Field adjustmentRatio:Float
	Field touchDownIndices:Int[]
	Field previousTouchDownIndices:Int[]
	
	'summary: sets up the object (this is only called via New and the New overload)
	Method Setup:Void(_indices%, _coordinateOffset:Vector, _adjustmentRatio#)
		indices = New Int[_indices]
		For Local i:=0 Until _indices
			indices[i] = i
		Next
		startTime = New Int[_indices]
		duration = New Int[_indices]
		previousDuration = New Int[_indices]
		position = New Vector[_indices]
		firstPosition = New Vector[_indices]
		previousPosition = New Vector[_indices]
		velocity = New Vector[_indices]
		previousVelocity = New Vector[_indices]
		offset = New Vector[_indices]
		previousOffset = New Vector[_indices]
		touchDown = New Bool[_indices]
		previousTouchDown = New Bool[_indices]
		enabled = New Bool[_indices]
		
		ResetAll()
		
		' by default enable all indices
		For Local index:= EachIn indices
			enabled[index] = True
		Next
		
		coordinateOffset = _coordinateOffset
		adjustmentRatio = _adjustmentRatio
	End
	
	'summary: resets all index values to the default, but not the enabled state (note: coordinateOffset is not reset)
	Method Reset:Void(index%=0)
		duration[index] = 0
		position[index] = New Vector'(-999999, -999999) ' set to (-999999, -999999), a high negative value so that this doesn't accidentally trigger anything when the index is not touching
		firstPosition[index] = New Vector'(-999999, -999999) ' set to (-999999, -999999)
		previousPosition[index] = New Vector ' set to (0,0)
		velocity[index] = New Vector ' set to (0,0)
		previousVelocity[index] = New Vector ' set to (0,0)
		offset[index] = New Vector ' set to (0,0)
		previousOffset[index] = New Vector ' set to (0,0)
		touchDown[index] = False
		previousTouchDown[index] = False
	End
	
	'summary: resets the values of all indices to the default (note: coordinateOffset is not reset)
	Method ResetAll:Void()
		For Local index:= EachIn indices
			Reset(index)
		Next
		minPosition = New Vector
		maxPosition = New Vector
		minOffset = New Vector
		maxOffset = New Vector
	End
	
	
	Public
	
	'summary: set up the touch class; indices defines which touch indices will be monitored; if offset is set the position is offset; the adjustment ratio is a multiplicator added to the position and velocity values (this is useful for virtual device sizes that have a different size to the actual pixel size and sets the ratio of dimensions/coordinates on the virtual display based on actual pixel values)
	Method New(_indices%=1, coordinateOffsetX#=0, coordinateOffsetY#=0, _adjustmentRatio#=1)
		Setup(_indices, New Vector(coordinateOffsetX, coordinateOffsetY), _adjustmentRatio)
	End
	
	'summary: Updates the touch position and swipe vectors of all touch indices
	Method Update:Void()
				
		' remember previous min and max position and offset so that it can be used if the touch has just been released
		Local previousMinPosition:Vector = minPosition.Copy
		Local previousMaxPosition:Vector = maxPosition.Copy
		Local previousMinOffset:Vector = minOffset.Copy
		Local previousMaxOffset:Vector = maxOffset.Copy
		
		minPosition.Reset()
		maxPosition.Reset()
		minOffset.Reset()
		maxOffset.Reset()
		
		previousTouchDownIndices = touchDownIndices
		touchDownIndices = touchDownIndices.Resize(0)
		
		For Local index:= EachIn indices
			If Not enabled[index]
				Reset(index)
				Continue
			EndIf
			previousDuration[index] = duration[index]
			previousTouchDown[index] = touchDown[index]
			If TouchHit(index)
				firstPosition[index].X = (TouchX(index) + coordinateOffset.X) * adjustmentRatio
				firstPosition[index].Y = (TouchY(index) + coordinateOffset.Y) * adjustmentRatio
				startTime[index] = Millisecs()
			EndIf
			If TouchDown(index)
				duration[index] = Millisecs() - startTime[index]
				previousPosition[index].X = position[index].X
				previousPosition[index].Y = position[index].Y
				position[index].X = (TouchX(index) + coordinateOffset.X) * adjustmentRatio
				position[index].Y = (TouchY(index) + coordinateOffset.Y) * adjustmentRatio
				If Not previousPosition[index].IsZero
					previousVelocity[index] = velocity[index]
					velocity[index].MakeBetween(previousPosition[index], position[index])
					previousOffset[index] = offset[index]
					offset[index].MakeBetween(firstPosition[index], position[index])
				Endif
				touchDown[index] = True
				touchDownIndices = touchDownIndices.Resize(touchDownIndices.Length + 1)
				touchDownIndices[touchDownIndices.Length - 1] = index
				
				If minPosition.IsZero() And maxPosition.IsZero()
					minPosition.Set(position[index])
					maxPosition.Set(position[index])
				Else
					minPosition.X = Min(minPosition.X, position[index].X)
					minPosition.Y = Min(minPosition.Y, position[index].Y)
					maxPosition.X = Max(maxPosition.X, position[index].X)
					maxPosition.Y = Max(maxPosition.Y, position[index].Y)
				EndIf
				
				If minOffset.IsZero() And maxOffset.IsZero()
					minOffset.Set(offset[index])
					maxOffset.Set(offset[index])
				Else
					minOffset.X = Min(minOffset.X, offset[index].X)
					minOffset.Y = Min(minOffset.Y, offset[index].Y)
					maxOffset.X = Max(maxOffset.X, offset[index].X)
					maxOffset.Y = Max(maxOffset.Y, offset[index].Y)
				EndIf
			Else
				If Not previousTouchDown[index] Then Reset(index) ' this ensures that the moment TouchDown is released the last touch information is retained for one more frame (it's often important to use the last touch information on release, e.g. to add the touch velocity to a dragged object, etc.)
				touchDown[index] = False
			Endif
		Next
		
		previousSize = size
		previousSizeFactor = sizeFactor
		If touchDownIndices.Length &gt; 1
			size = minPosition.DistanceTo(maxPosition)
			If previousTouchDownIndices.Length &lt; 2
				firstSize = size
				minPosition = New Vector
				maxPosition = New Vector
			Endif
			If firstSize &gt; 0 Then sizeFactor = size / firstSize Else sizeFactor = 0
		ElseIf touchDownIndices.Length = 1
			size = 1
			sizeFactor = 1
		Else
			size = 0
			sizeFactor = 0
		EndIf
		
		' if all touch indices were just released (compared to the previous Update call) then keep the previous min and max position and offset values for this one frame because it is often important to have this information when a touch gesture is released
		If AllReleased
			minPosition.Set(previousMinPosition)
			maxPosition.Set(previousMaxPosition)
			minOffset.Set(previousMinOffset)
			maxOffset.Set(previousMaxOffset)
		EndIf
	End
	
	'summary: returns the duration of an touch index in milliseconds
	Method Duration:Int(index%=0) Property
		Return duration[index]
	End
	
	'summary: returns a position vector of the specified touch index
	Method Position:Vector(index%=0) Property
		Return position[index]
	End
	
	'summary: returns a position vector of first touch of the specified touch index (returns a (-999999,-999999) vector if the index is not touching)
	Method FirstPosition:Vector(index%=0) Property
		Return firstPosition[index]
	End
	
	'summary: returns a velocity vector of the specified touch index
	Method Velocity:Vector(index%=0) Property
		Return velocity[index]
	End
	
	'summary: returns a vector of the current touch position in relation to the first touch position
	Method Offset:Vector(index%=0) Property
		Return offset[index]
	End
	
	'summary: returns an array with all indices positions that are currently touching (not touching indices are ignored)
	Method Positions:Vector[]() Property
		Local positions:Vector[]
		positions = New Vector[touchDownIndices.Length]
		Local i:Int
		For Local index:= EachIn touchDownIndices
			positions[i] = position[index]
			i += 1
		Next
		Return positions
	End
	
	'summary: retruns an array with all indices positions that are currently hitting (hit = first touch contact)
	Method HitPositions:Vector[]() Property
		Local positions:Vector[]
		positions = New Vector[0]
		For Local touchDownIndex:= EachIn touchDownIndices
			If TouchHit(touchDownIndex)
				positions = positions.Resize(positions.Length + 1)
				positions[positions.Length - 1] = position[touchDownIndex]
			EndIf
		Next
		Return positions
	End
	
	'summary: returns an array with all indices velocities (returns a (0,0) vector for all indices that are not touching)
	Method Velocities:Vector[]() Property
		Return velocity
	End
	
	'summary: returns an array with all indices offsets (returns a (0,0) vector for all indices that are not touching)
	Method Offsets:Vector[]() Property
		Return offset
	End
	
	'summary: returns an array with all touch indices (i.e. all indices that were defined when the object instance was created)
	Method Indices:Int[]() Property
		Return indices
	End
	
	'summary: returns the number of touch indices this object monitors
	Method NumIndices:Int() Property
		Return indices.Length
	End
	
	'summary: returns True if the touch index was released since the last update
	Method Released:Bool(index%=0) Property
		Return previousTouchDown[index] And Not touchDown[index]
	End
	
	'summary: returns True if all touch indices were released since the last update (i.e. at least one touch index was touching on the previous update and has now been released)
	Method AllReleased:Bool() Property
		Return previousTouchDownIndices.Length &gt; 0 And touchDownIndices.Length = 0
	End
	
	'summary: returns True if the touch index is touching (almost and Alias of TouchDown())
	Method IsTouching:Bool(index%=0) Property
		Return touchDown[index]
	End
	
	'summary: returns True if any index touches the screen
	Method AnyTouchDown:Bool() Property
		For Local index:= EachIn indices
			If TouchDown(index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if the touch index is inside the defined rectangular area (note: the origin of the rotation is assumed the top left corner of the area)
	Method IsInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0, index%=0)
		If rotation = 0 Then Return (TouchDown(index) Or Released(index)) And position[index].X &gt;= positionX And position[index].X &lt;= positionX + width And position[index].Y &gt;= positionY And position[index].Y &lt;= positionY + height ' Or Released ensures that FirstTouchInCircle also validates on release (in the first update call that the index is no longer touching)
		
		' taking into account the rotation (the rotation origin is assumed to be the top left corner of the rectangular area)
		Local localTouchPosition:Vector = New Vector
		localTouchPosition.MakeBetween(New Vector(positionX, positionY), position[index])
		localTouchPosition.Direction -= rotation
		Return (TouchDown(index) Or Released(index)) And localTouchPosition.X &gt;= 0 And localTouchPosition.X &lt;= width And localTouchPosition.Y &gt;= 0 And localTouchPosition.Y &lt;= height ' Or Released ensures that FirstTouchInCircle also validates on release (in the first update call that the index is no longer touching)
	End
	
	'summary: returns True if the touch index is inside the defined rectangular area
	Method IsInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0, index%=0)
		Return IsInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation, index)
	End
	
	'summary: returns True if the touch index hits inside the defined rectangular area (this only returns True on first contact, this makes it useful for buttons)
	Method HitInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0, index%=0)
		Return TouchHit(index) And IsInArea(positionX, positionY, width, height, rotation, index)
	End
	
	'summary: returns True if the touch index hits inside the defined rectangular area (this only returns True on first contact, this makes it useful for buttons)
	Method HitInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0, index%=0)
		Return HitInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation, index)
	End
	
	'summary: returns True if any touch index is inside the defined rectangular area
	Method AnyInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0)
		For Local index:= EachIn indices
			If IsInArea(positionX, positionY, width, height, rotation, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any touch index is inside the defined rectangular area
	Method AnyInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0)
		Return AnyInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation)
	End
	
	'summary: returns True if any touch index hits inside the defined rectangular area (this only returns True on first contact, this makes it useful for buttons)
	Method AnyHitInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0)
		For Local index:= EachIn indices
			If HitInArea(positionX, positionY, width, height, rotation, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any touch index hits inside the defined rectangular area (this only returns True on first contact, this makes it useful for buttons)
	Method AnyHitInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0)
		Return AnyHitInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation)
	End
	
	'summary: returns true if at least the minimum number of indices are in the defined rectangular area (minIndices defines the minimum number of indices that need to be in the defined area to validate)
	Method MultipleInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0, minIndices%=2)
		Local count:Int
		For Local index:= EachIn indices
			If IsInArea(positionX, positionY, width, height, rotation, index) Then count += 1
			If count = minIndices Then Return True
		Next
		Return False
	End
	
	'summary: returns true if at least the minimum number of indices are in the defined rectangular area (minIndices defines the minimum number of indices that need to be in the defined area to validate)
	Method MultipleInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0, minIndices%=2)
		Return MultipleInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation, minIndices)
	End
	
	'summary: returns True if the touch index when the index started to touch is inside the defined rectangular area (i.e. was the touch initiated in a certain area?)
	Method FirstTouchInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0, index%=0)
		If rotation = 0 Then Return (TouchDown(index) Or Released(index)) And firstPosition[index].X &gt;= positionX And firstPosition[index].X &lt;= positionX + width And firstPosition[index].Y &gt;= positionY And firstPosition[index].Y &lt;= positionY + height ' Or Released ensures that FirstTouchInCircle also validates on release (in the first update call that the index is no longer touching)
		
		' taking into account the rotation (the rotation origin is assumed to be the top left corner of the rectangular area)
		Local localTouchPosition:Vector = New Vector
		localTouchPosition.MakeBetween(New Vector(positionX, positionY), firstPosition[index])
		localTouchPosition.Direction -= rotation
		Return (TouchDown(index) Or Released(index)) And localTouchPosition.X &gt;= 0 And localTouchPosition.X &lt;= width And localTouchPosition.Y &gt;= 0 And localTouchPosition.Y &lt;= height ' Or Released ensures that FirstTouchInCircle also validates on release (in the first update call that the index is no longer touching)
	End
	
	'summary: returns True if the touch index when the index started to touch is inside the defined rectangular area (i.e. was the touch initiated in a certain area?)
	Method FirstTouchInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0, index%=0)
		Return FirstTouchInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation, index)
	End
	
	'summary: returns True if at least the minimum number of indices were in the defined rectangular area on first touch (minIndices defines the minimum number of indices that need to be in the defined area to validate)
	Method MultipleFirstTouchInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0, minIndices%=2)
		Local count:Int
		For Local index:= EachIn indices
			If FirstTouchInArea(positionX, positionY, width, height, rotation, index) Then count += 1
			If count = minIndices Then Return True
		Next
		Return False
	End
	
	'summary: returns True if at least the minimum number of indices were in the defined rectangular area on first touch (minIndices defines the minimum number of indices that need to be in the defined area to validate)
	Method MultipleFirstTouchInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0, minIndices%=2)
		Return MultipleFirstTouchInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation, minIndices)
	End
	
	'summary: returns True if any first touch index was/is inside the defined rectangular area
	Method AnyFirstTouchInArea:Bool(positionX#, positionY#, width#, height#, rotation#=0)
		For Local index:= Eachin indices
			If FirstTouchInArea(positionX, positionY, width, height, rotation, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any first touch index was/is inside the defined rectangular area
	Method AnyFirstTouchInArea:Bool(_position:Vector, _dimension:Vector, rotation#=0)
		Return AnyFirstTouchInArea(_position.X, _position.Y, _dimension.X, _dimension.Y, rotation)
	End
	
	'summary: returns True if the touch index is inside the defined circle
	Method IsInCircle:Bool(_position:Vector, radius#, index%=0)
		Return (TouchDown(index) Or Released(index)) And position[index].DistanceTo(_position) &lt;= radius ' Or Released ensures that FirstTouchInCircle also validates on release (in the first update call that the index is no longer touching)
	End
	
	'summary: returns True if the touch index is inside the defined circle
	Method IsInCircle:Bool(positionX#, positionY#, radius#, index%=0)
		Return IsInCircle(New Vector(positionX, positionY), radius, index)
	End
	
	'summary: returns True if the touch index hits inside the defined circle (this only returns True on first contact, this makes it useful for buttons)
	Method HitInCircle:Bool(_position:Vector, radius#, index%=0)
		Return TouchHit(index) And IsInCircle(_position, radius, index)
	End
	
	'summary: returns True if the touch index hits inside the defined circle (this only returns True on first contact, this makes it useful for buttons)
	Method HitInCircle:Bool(positionX#, positionY#, radius#, index%=0)
		Return HitInCircle(New Vector(positionX, positionY), radius, index) 
	End
	
	'summary: returns True if any touch index is inside the defined circle
	Method AnyInCircle:Bool(_position:Vector, radius#)
		For Local index:= EachIn indices
			If IsInCircle(_position, radius, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any touch index is inside the defined circle
	Method AnyInCircle:Bool(positionX#, positionY#, radius#)
		Return AnyInCircle(New Vector(positionX, positionY), radius)
	End
	
	'summary: returns True if the touch hits inside the defined circle (this only returns True on first contact, this makes it useful for buttons)
	Method AnyHitInCircle:Bool(_position:Vector, radius#)
		For Local index:= EachIn indices
			If HitInCircle(_position, radius, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if the touch hits inside the defined circle (this only returns True on first contact, this makes it useful for buttons)
	Method AnyHitInCircle:Bool(positionX#, positionY#, radius#)
		Return AnyHitInCircle(New Vector(positionX, positionY), radius)
	End
	
	'summary: returns true if at least the minimum number of indices are in the defined circle (minIndices defines the minimum number of indices that need to be in the defined circle to validate)
	Method MultipleInCircle:Bool(_position:Vector, radius#, minIndices%=2)
		Local count:Int
		For Local index:= EachIn indices
			If IsInCircle(_position, radius, index) Then count += 1
			If count = minIndices Then Return True
		Next
		Return False
	End
	
	'summary: returns true if at least the minimum number of indices are in the defined circle (minIndices defines the minimum number of indices that need to be in the defined circle to validate)
	Method MultipleInCircle:Bool(positionX#, positionY#, radius#, minIndices%=2)
		Return MultipleInCircle(New Vector(positionX, positionY), radius, minIndices)
	End
	
	'summary: returns True if the touch index when the index started to touch is inside the defined circle (i.e. was the touch initiated in a certain area?)
	Method FirstTouchInCircle:Bool(_position:Vector, radius#, index%=0)
		Return (TouchDown(index) Or Released(index)) And firstPosition[index].DistanceTo(_position) &lt;= radius ' Or Released ensures that FirstTouchInCircle also validates on release (in the first update call that the index is no longer touching)
	End
	
	'summary: returns True if the touch index when the index started to touch is inside the defined circle (i.e. was the touch initiated in a certain area?)
	Method FirstTouchInCircle:Bool(positionX#, positionY#, radius#, index%=0)
		Return FirstTouchInCircle(New Vector(positionX, positionY), radius, index)
	End
	
	'summary: returns true if at least the minimum number of indices were in the defined circle on first touch (minIndices defines the minimum number of indices that need to be in the defined circle to validate)
	Method MultipleFirstTouchInCircle:Bool(_position:Vector, radius#, minIndices%=2)
		Local count:Int
		For Local index:= EachIn indices
			If FirstTouchInCircle(_position, radius, index) Then count += 1
			If count = minIndices Then Return True
		Next
		Return False
	End
	
	'summary: returns true if at least the minimum number of indices were in the defined circle on first touch (minIndices defines the minimum number of indices that need to be in the defined circle to validate)
	Method MultipleFirstTouchInCircle:Bool(positionX#, positionY#, radius#, index%=0)
		Return MultipleFirstTouchInCircle(New Vector(positionX, positionY), radius, index)
	End
	
	'summary: returns True if any first touch index is/was inside the defined circle
	Method AnyFirstTouchInCircle:Bool(_position:Vector, radius#)
		For Local index:= EachIn indices
			If FirstTouchInCircle(_position, radius, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any first touch index is/was inside the defined circle
	Method AnyFirstTouchInCircle:Bool(positionX#, positionY#, radius#)
		Return AnyFirstTouchInCircle(New Vector(positionX, positionY), radius)
	End
	
	'summary: returns True if the touch index is inside the defined ellipse
	Method IsInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0, index%=0)		
		Local x:Float = positionX - position[index].X
		Local y:Float = positionY - position[index].Y
		Local a:Float = radiusX
		Local b:Float = radiusY
		
		If rotation = 0 Then Return (TouchDown(index) Or Released(index)) And (x*x)/(a*a) + (y*y)/(b*b) &lt;= 1
		Return (TouchDown(index) Or Released(index)) And Pow( x * Cos(rotation) - y * Sin(rotation) , 2) / ( a * a ) + Pow( x * Sin(rotation) + y * Cos(rotation) , 2 ) / ( b * b ) &lt;= 1
	End
	
	'summary: returns True if the touch index is inside the defined ellipse
	Method IsInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0, index%=0)
		Return IsInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation, index)
	End
	
	'summary: returns True if the touch index hits inside the defined ellipse (this only returns True on first contact, this makes it useful for buttons)
	Method HitInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0, index%=0)
		Return TouchHit(index) And IsInEllipse(positionX, positionY, radiusX, radiusY, rotation, index)
	End
	
	'summary: returns True if the touch index hits inside the defined ellipse (this only returns True on first contact, this makes it useful for buttons)
	Method HitInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0, index%=0)
		Return HitInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation, index)
	End
	
	'summary: returns True if any touch index is inside the defined ellipse
	Method AnyInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0)
		For Local index:= EachIn indices
			If IsInEllipse(positionX, positionY, radiusX, radiusY, rotation, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any touch index is inside the defined ellipse
	Method AnyInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0)
		Return AnyInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation)
	End
	
	'summary: returns True if any touch index hits inside the defined ellipse
	Method AnyHitInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0)
		For Local index:= EachIn indices
			If HitInEllipse(positionX, positionY, radiusX, radiusY, rotation, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any touch index hits inside the defined ellipse
	Method AnyHitInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0)
		Return AnyHitInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation)
	End
	
	'summary: returns true if at least the minimum number of indices are in the defined ellipse (minIndices defines the minimum number of indices that need to be in the defined ellipse to validate)
	Method MultipleInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#, minIndices%=2)
		Local count:Int
		For Local index:= EachIn indices
			If IsInEllipse(positionX, positionY, radiusX, radiusY, rotation, index) Then count += 1
			If count = minIndices Then Return True
		Next
		Return False
	End
	
	'summary: returns true if at least the minimum number of indices are in the defined ellipse (minIndices defines the minimum number of indices that need to be in the defined ellipse to validate)
	Method MultipleInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0, minIndices%=2)
		Return MultipleInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation, minIndices)
	End
	
	'summary: returns True if the touch index when the index started to touch is inside the defined ellipse (i.e. was the touch initiated in a certain area?)
	Method FirstTouchInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0, index%=0)
		Local x:Float = positionX - firstPosition[index].X
		Local y:Float = positionY - firstPosition[index].Y
		Local a:Float = radiusX
		Local b:Float = radiusY
		
		If rotation = 0 Then Return (TouchDown(index) Or Released(index)) And (x*x)/(a*a) + (y*y)/(b*b) &lt;= 1
		Return (TouchDown(index) Or Released(index)) And Pow( x * Cos(rotation) - y * Sin(rotation) , 2) / ( a * a ) + Pow( x * Sin(rotation) + y * Cos(rotation) , 2 ) / ( b * b ) &lt;= 1
	End
	
	'summary: returns True if the touch index when the index started to touch is inside the defined ellipse (i.e. was the touch initiated in a certain area?)
	Method FirstTouchInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0, index%=0)
		Return FirstTouchInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation, index)
	End
	
	'summary: returns true if at least the minimum number of indices were in the defined ellipse on first touch (minIndices defines the minimum number of indices that need to be in the defined ellipse to validate)
	Method MultipleFirstTouchInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0, minIndices%=2)
		Local count:Int
		For Local index:= EachIn indices
			If FirstTouchInEllipse(positionX, positionY, radiusX, radiusY, rotation, index) Then count += 1
			If count = minIndices Then Return True
		Next
		Return False
	End
	
	'summary: returns true if at least the minimum number of indices were in the defined ellipse on first touch (minIndices defines the minimum number of indices that need to be in the defined ellipse to validate)
	Method MultipleFirstTouchInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0, minIndices%=2)
		Return MultipleFirstTouchInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation, minIndices)
	End
	
	'summary: returns True if any first touch index is/was inside the defined circle
	Method AnyFirstTouchInEllipse:Bool(positionX#, positionY#, radiusX#, radiusY#, rotation#=0)
		For Local index:= EachIn indices
			If FirstTouchInEllipse(positionX, positionY, radiusX, radiusY, rotation, index) Then Return True
		Next
		Return False
	End
	
	'summary: returns True if any first touch index is/was inside the defined circle
	Method AnyFirstTouchInEllipse:Bool(_position:Vector, radius:Vector, rotation#=0)
		Return AnyFirstTouchInEllipse(_position.X, _position.Y, radius.X, radius.Y, rotation)
	End
	
	'summary: returns an array with the currently touching indices
	Method TouchDownIndices:Int[]() Property
		Return touchDownIndices
	End
	
	'summary: returns an array with the currently touching indices
	Method PreviousTouchDownIndices:Int[]() Property
		Return previousTouchDownIndices
	End
	
	'summary: returns the number of currently touching indices
	Method NumTouchDownIndices:Int() Property
		Return touchDownIndices.Length
	End
	
	'summary: returns a position vector with the average position of the specified touch indices (if _indices is set to 0 then all currently monitored indices are taken into account, otherwise the average will be calculated based on the index limit, e.g. only the average between the first two touching indices)
	Method AveragePosition:Vector(_indices:Int=0) Property
		Local averagePosition:Vector = New Vector
		Local previousOrCurrentTouchDownIndices:Int[]
		If AllReleased Then previousOrCurrentTouchDownIndices = previousTouchDownIndices Else previousOrCurrentTouchDownIndices = touchDownIndices ' this ensures that on released the last value is retained for one more update call
		If _indices = 0 Then _indices = previousOrCurrentTouchDownIndices.Length
		For Local index:=0 Until _indices
			averagePosition.Add(position[previousOrCurrentTouchDownIndices[index]])
		Next
		Return averagePosition.Multiply(1.0/_indices)
	End
	
	'summary: returns a position vector with the center position of the specified touch indices (if _indices is set to 0 then all currently monitored indices are taken into account, otherwise the center will be calculated based on the index limit, e.g. only the average between the first two touching indices)
	Method CenterPosition:Vector(_indices:Int=0) Property
		If previousTouchDownIndices.Length = 0 And touchDownIndices.Length = 0 Then Return New Vector ' return a zero vector if no index is touching (this also ensures that the last CenterPosition is retained for one update call on release of all indices)
		If _indices = 1 Then Return position[touchDownIndices[0]]
		Return New Vector((minPosition.X+maxPosition.X)/2.0, (minPosition.Y+maxPosition.Y)/2.0)
	End
	
	
	'summary: returns an offset vector (current position in relation to the first position) with the average offset of the specified touch indices (if _indices is set to 0 then all currently monitored indices are taken into account, otherwise the average will be calculated based on the index limit, e.g. only the average between the first two touching indices)
	Method AverageOffset:Vector(_indices:Int=0) Property
		Local averageOffset:Vector = New Vector
		Local previousOrCurrentTouchDownIndices:Int[]
		If AllReleased Then previousOrCurrentTouchDownIndices = previousTouchDownIndices Else previousOrCurrentTouchDownIndices = touchDownIndices ' this ensures that on released the last value is retained for one more update call
		If _indices = 0 Then _indices = previousOrCurrentTouchDownIndices.Length
		For Local index:=0 Until _indices
			averageOffset.Add(offset[previousOrCurrentTouchDownIndices[index]])
		Next
		Return averageOffset.Multiply(1.0/_indices)
	End
	'note to above: check if previousTouchDownIndices is the best solution (because it will always lack one frame behind; maybe it's better to stay on the frame and then append one frame on release)
	
	'summary: returns an offset vector (current position in relation to the first position) with the center offset of the specified touch indices (if _indices is set to 0 then all currently monitored indices are taken into account, otherwise the center will be calculated based on the index limit, e.g. only the average between the first two touching indices)
	Method CenterOffset:Vector(_indices:Int=0) Property
		If previousTouchDownIndices.Length = 0 And touchDownIndices.Length = 0 Then Return New Vector ' return a zero vector if no index is touching (this also ensures that the last CenterPosition is retained for one update call on release of all indices)
		If _indices = 1 Then Return offset[touchDownIndices[0]]
		Return New Vector((minOffset.X+maxOffset.X)/2.0, (minOffset.Y+ maxOffset.Y)/2.0)
	End
	
	'summary: returns a velocity vector with the average velocity of the specified touch indices (if _indices is set to 0 then all currently monitored indices are taken into account, otherwise the average will be calculated based on the index limit, e.g. only the average between the first two touching indices)
	Method AverageVelocity:Vector(_indices:Int=0) Property
		Local averageVelocity:Vector = New Vector
		Local previousOrCurrentTouchDownIndices:Int[]
		If AllReleased Then previousOrCurrentTouchDownIndices = previousTouchDownIndices Else previousOrCurrentTouchDownIndices = touchDownIndices ' this ensures that on released the last value is retained for one more update call
		If _indices = 0 Then _indices = previousOrCurrentTouchDownIndices.Length
		For Local index:=0 Until _indices
			averageVelocity.Add(velocity[previousOrCurrentTouchDownIndices[index]])
		Next
		Return averageVelocity.Multiply(1.0/_indices)
	End
	'note to above: check if previousTouchDownIndices is the best solution (because it will always lack one frame behind; maybe it's better to stay on the frame and then append one frame on release)
	
	'summary: returns the size of the touch gesture (this is primarily for multi-touch gestures and measures the distance between the two most distant indices; useful for pinch gestures)
	Method Size:Float() Property
		Return size
	End
	
	'summary: returns the size factor, i.e. the multiplicator by which the current size differs from the first/initial size
	Method SizeFactor:Float() Property
		Return sizeFactor
	End
	
	'summary: returns True if the touch index is enabled
	Method IsEnabled:Bool(index%=0) Property
		Return enabled[index]
	End
	
	'summary: returns True if the complete array of touch indices is enabled
	Method AreEnabled:Bool(_indices%[])
		For Local index:= EachIn _indices
			If Not enabled[index] Then Return False
		Next
		Return True
	End
	
	'summary: returns True if the complete array of touch indices is disabled
	Method AreDisabled:Bool(_indices%[])
		For Local index:= EachIn _indices
			If enabled[index] Then Return False
		Next
		Return True
	End
	
	'summary: returns if all indices as defined in New are enabled
	Method AllEnabled:Bool() Property
		Return AreEnabled(indices)
	End
	
	'summary: returns if all indices as defined in New are disabled
	Method AllDisabled:Bool() Property
		Return AreDisabled(indices)
	End
	
	'summary: enables an index
	Method Enable:Void(index%=0)
		enabled[index] = True
	End
	
	'summary: disables an index
	Method Disable:Void(index%=0)
		Reset(index)
		enabled[index] = False
	End
	
	'summary: toggles enable/disable of an index
	Method ToggleEnable:Void(index%=0)
		If enabled[index]
			Disable(index)
		Else
			Enable(index)
		EndIf
	End
	
	'summary: enables all touch indices
	Method EnableAll:Void()
		For Local index:= EachIn indices
			Enable(index)
		Next
	End
	
	'summary: enables all touch indices
	Method DisableAll:Void()
		For Local index:= EachIn indices
			Disable(index)
		Next
		ResetAll()
	End
	
	'summary: toggles enable/disable of all indices (note: this method takes index 0 as a reference, i.e. if index 0 is enabled it will disable all, if index 0 is disabled it will enable all)
	Method ToggleEnableAll:Void(index%=0)
		If enabled[0]
			DisableAll()
		Else
			EnableAll()
		EndIf
	End
	
	'summary: prints useful information about touches and gestures
	Method PrintInfo:Void()
		Print("----- TOUCH INFO -----")
		
		Print("Touch size: " + size + " (size factor: " + sizeFactor + ")")
		Print("Average position: " + AveragePosition.X + ", " + AveragePosition.Y)
		Print("Center position: " + CenterPosition.X + ", " + CenterPosition.Y)
		
		For Local index:=0 Until indices.Length
			Print("TOUCH INDEX " + index)
			Print("     first position: " + firstPosition[index].X + ", " + firstPosition[index].Y)
			Print("     position: " + position[index].X + ", " + position[index].Y)
			Print("     velocity: " + velocity[index].X + ", " + velocity[index].Y + " (direction: " + velocity[index].Direction + ", length: " + velocity[index].Length + ")") ' TODO: for some reason on iOS it doesn't show the velocity here (but I'm sure it gets calculated)
			Print("     offset: " + offset[index].X + ", " + offset[index].Y + " (direction: " + offset[index].Direction + ", length: " + offset[index].Length + ")")
			Print("     duration: " + duration[index])
			If Released(index) Print("     released: YES") Else Print("     released: NO")
		Next
	End
	
End
</textarea><br><br>vector.monkey by Tibit*<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import mojo


' A vector class with a lot of handy functionality for game-programming! 

' In simplicy a vector is an Arrow. It has an length
' and a direction. You can use these properties to 
' make the vector model a Position, a Velocity, a 
' Line, a Distance and many other things that can be
' measured using a length and a direction or anything
' that uses two float pair-values!

' Wikipedia: A vector is what is needed to "carry" the
' point A to the point B; the Latin word vector means "one who carries"
Class Vector
Public
	Field X:Float
	Field Y:Float 

	'Const Zero:Vector = New Vector(0,0)
	
	Method New(x:Float=0,y:Float=0)
		X = x
		Y = y
	End
	
	'	    S E T
	'----------------------------------------------	
	Method Set:Vector( vector:Vector ) 
		X = vector.X 
		Y = vector.Y 
		Return Self	
	End
	Method Set:Vector(x:Float,y:Float ) 
		X = x
		Y = y
		Return Self	
	End
	
	'       R E S E T
	'----------------------------------------------
	Method Reset:Void()
		X = 0
		Y = 0
	End
		
	'		A D D
	'----------------------------------------------	
	Method Add:Vector( vector:Vector ) 
		X += vector.X 
		Y += vector.Y 
		Return Self	
	End
	
	'		S U B T R A C T
	'----------------------------------------------	
	Method Subtract:Vector( vector:Vector ) 
		X = X - vector.X 
		Y = Y - vector.Y 
		Return Self	
	End
	
	'		 D O T  P R O D U C T 
	'---------------------------------------------------
	' Dot Product which is X*X2 + Y*Y2
	'
	'---------------------------------------------------
	Method Dot:Float( Vector:Vector )
		Return ( X * Vector.X + Y * Vector.Y)
	End
	
		'		M U L T I P L Y   V E C T O R 
	'----------------------------------------------
	Method Multiply:Vector( Value:Float )
		X*=Value
		Y*=Value
		Return Self	
	End
		
	' M I R R O R
	'----------------------------------------------------------
	' if the mirrorImage vector is a unit-vector this will 
	' make this vector flip 180 degrees around it
	' So that this vector now points in the exact opppisite 
	' direction To the mirrorImage vector
	' Returns Self, which will be opposite to mirrorImage.
	Method Mirror:Vector( mirrorImage:Vector )
		Local dotprod# = -X * mirrorImage.X - Y * mirrorImage.Y
		X=X+2 * mirrorImage.X * dotprod
		Y=Y+2 * mirrorImage.Y * dotprod
		Return Self
	End
	
	'summary: mirrors the vector so that it points to the exact opposite
	Method PointMirror:Vector() Property
		X = -X
		Y = -Y
		Return Self
	End
	
	' Set the vector to a direction and a length x,y
	' returns Self, which is now pointin the directio
	' provided, with the length provided
	Method MakeField:Vector( direction:Float, length:Float )	
		X = Cos( -direction )*length
		Y = Sin( -direction )*length
		Return Self
	End
	
	'----------------------------------------------
	' Create a copy --&gt; depending on situation you might
	' want to use the VectorPool to do this instead for
	' when extrenme performance is required
	'-----------------------------------------------
	Method Copy:Vector() Property
		Local vector:Vector = New Vector
		vector.X = X
		vector.Y = Y
		Return vector	
	End
	
		'	 C R E A T E   L E F T   N O R M A L
	'----------------------------------------------	
	' Make this an Perpendicular Vector
	' As if you would rotate it 90 degrees Counter Clockwise
	' return ( Y, -X )
	Method LeftNormal:Vector( )
		Local tempX:Float = Y
		Y = -X
		X = tempX
		Return Self
	End

		
	'	 C R E A T E   R I G H T   N O R M A L
	'----------------------------------------------	
	' Make this a Perpendicular Vector
	' Same as rotating it 90 degrees ClockWise
	' return ( -Y, X )
	Method RightNormal:Vector( )
		Local tempY:Float = Y
		Y = X
		X = -tempY
		Return Self
	End
	
	'		N O R M A L I Z E 
	'----------------------------------------------	
	' Purpose: Sets Vector length To ONE but keeps it's direction		
	' Returns Self as a UnitVector
	Method Normalize:Vector()
		Local Length:Float = Self.Length()
		If Length = 0 
			Return Self ' Don't divide by zero, 
			'we do not normalize a zero-vector 
			'since this vector's direction is in
			' mathematical terms all directions!
		Endif
		Set( X / Length, Y / Length ) 'Make length = 1
		Return Self
	End
	
	'   G E T   L E N G T H
	'-----------------------------
	' Get current Length of vector, uses a single sqr operation
	Method Length:Float() Property
		Return Sqrt( X*X + Y*Y )
	End
	
	'	S E T	L E N G T H
	'-------------------------------------
	Method Length:Void( length:Float ) Property
		'If we want to set vector to zero 
		If length = 0 
			X=0 
			Y=0
			Return
		Endif

		If X = 0 And Y = 0
			X = length
		Endif
		
		Normalize()
		Multiply( length )			
	End
	
	Method Resize:Vector(length#)
		Length = length
		Return Self
	End
	
	Method ReduceLength:Vector( amount:Float )
		Local currentAngle:Float = Direction
		Local currentLength:Float = Length		
		Local newLength:Float = currentLength - amount
		If newLength &gt; 0
			MakeField( currentAngle, currentLength - amount  )
		Else 
			Set 0,0
		Endif
		Return Self	
	End
	
	' G E T  D I R E C T I O N
	'----------------------------------------------------
	' Calculates the current direction in degrees
	' in the 0 To &lt; 360 range
	Method Direction:Float() Property
		Local angle:Float = ATan2(-Y, X)
		'If angle &lt; 0 Then angle =+ 360
		Return angle
	End
	
	' S E T  D I R E C T I O N
	'----------------------------------------------
	'
	' Set the angle of this vector without changing the length,
	' has no effect if vector length is 0
	' uses a single sqr operation
	Method Direction:Void( direction:Float ) Property
		MakeField( direction, Length ) 
	End Method
	
	' D I S T A N C E
	'----------------------------------------------	
	' The Distance between the two points
	' This is NOT related to the vectors Length#	
	Method DistanceTo:Float(Other:Vector) 
		Return DistanceTo(Other.X, Other.Y)
	End
	Method DistanceTo:Float(x:Float, y:Float) 
		Local dx:Float = x - X 
		Local dy:Float = y - Y 
		Return Sqrt( dx*dx + dy*dy ) 	
	End
		
'		G E T  A N G L E   B E T W E E N
	'----------------------------------------------
	' If you have two vectors that start at the same position
	' the angle-distance between two vectors Result is from 0 
	' to 180 degrees, because two vectors can not be more than 180 
	' degrees apart, check AngleClockwise &amp; AngleAntiClockwise
	' to get a 0-360 result instead
	' even tough it is counted as they are on the same position,
	' that is not a requirement at all for this to be correct
	Method AngleTo:Float( target:Vector )	
		Local dot:Float = Self.Dot( target )
		
		Local combinedLength:Float = Self.Length()*target.Length()
		If combinedLength = 0 Then Return 0
		
		Local quaski:Float = dot/combinedLength
		
		Local angle:Float = ACos( quaski )
		Return angle
	End
	
	
	' If you have two vectors so they both start at the same position
	' returns the angle from this vector to target vector (in degrees)
	' if you where to go Clockwise to it, result is 0 to 360	
	Method AngleToClockwise:Float( target:Vector )
		Local angle:Float = ATan2(-Y , X)  - ATan2(-target.Y , target.X)
		If angle &lt; 0 Then angle += 360
		If angle &gt;= 360 Then angle -= 360
		Return angle		
	End
	
	' If you have two vectors so they both start at the same position
	' returns the angle fromt this vector to target vector (in degrees)
	' if you where to go AntiClockwise to it, result is 0 to 360	
	Method AngleToAntiClockwise:Float( target:Vector )
		Local angle:Float =  AngleToClockwise(target)-360
		Return -angle
	End	
	
		'		V E C T O R    B E T W E E N
	'----------------------------------------------
	' Change the vector into a vector from Position1 to Position2
	' Return Self, as a vector that goes from first 
	' parameter's position to the second 
	Method MakeBetween:Vector( PositionFrom:Vector , PositionTo:Vector)
		If PositionFrom = Null Or PositionTo = Null Then Return Self
		X = ( PositionTo.X - PositionFrom.X ) 	
		Y = ( PositionTo.Y - PositionFrom.Y )
		Return Self		
	End
	
	' checks if a vector is zero
	Method IsZero:Bool() Property
		Return X = 0 And Y = 0
	End
	
	'summary: clamps the vector values
	Method Clamp:Vector(minX#, maxX#, minY#, maxY#)
		X = math.Clamp(X, minX, maxX)
		Y = math.Clamp(Y, minY, maxY)
		Return Self
	End
	
	'summary: clamps the vector values
	Method Clamp:Vector(min#, max#)
		X = math.Clamp(X, min, max)
		Y = math.Clamp(Y, min, max)
		Return Self
	End
	
	'summary: prints the vector x and y values and the direction and strength
	Method PrintInfo:Void()
		Print(X + ", " + Y + " (direction: " + Direction + ", length: " + Length + ")")
	End

End
</textarea><br><br>* The class works a lot with vectors because I find this is much more useful. I borrowed and slightly adjusted a vector class from Tibit (Thank you!!!): <a href="http://www.monkeycoder.co.nz/Community/posts.php?topic=568#4319" target="_blank">http://www.monkeycoder.co.nz/Community/posts.php?topic=568#4319</a><br><br>I'm sure there are some other similar and useful classes around, e.g. in diddy. If this class suits you, feel free to use and modify it.<br><br>Cheers!<br>Anatol <br><br></td></tr></table><br>
<a name="2042383"></a>

<a name="2042371"></a>

<a name="2042432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great Helper class!<br><br>I think I'll have great use for this when implementing proper pinch zoom<br><br>And happy that you had use of the Vector class :)<br><br>Just curious, what can your swipe gesture class be used for? Sounds cool. <br><br></td></tr></table><br>
<a name="2042433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Anatol</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Tibit, and thanks for the work on the excellent vector class which is extremely useful. When I first started using Monkey I did everything without vectors, but I scrapped it all when I found your class in the forum - vectors just save so much time!<br><br>A pinch gesture should be easy with Touch.SizeFactor that monitors the change in size of a multi touch relative to the original size when the multi touch began.<br><br>I will definitely post the swipe class extensions here but I probably won't have the time this week to clean them up.<br><br>The swipes I've written so far simply check if a swipe goes in a specific direction that can be defined with an angle, and how long the minimum swipe length needs to be in order to validate. Optional you can also set a "velocity coefficient" which just means that if you do a quick flick then the swipe gesture also validates if it's shorter than the defined minimum length. Swipes can also be defined to only validate if they start in a certain area, and if it requires one, two or more fingers to validate.<br><br>I guess it can be extended to more complex gestures, but I didn't need that so far.<br><br>I probably have some more code to share here over the next couple of weeks, one of which is a 3D vector class based on your vector class (thanks again!). I just want to clean it up and add proper comments so that it's easier to read here in the forum. It's just a matter of finding the time... <br><br></td></tr></table><br>
<a name="2043452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ordigdug</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Anatol -- Any luck finding time?  Thanks for sharing. <br><br></td></tr></table><br>
<a name="2043459"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Anatol</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi. Thanks for the interest. I'm on a conference this week, and Wellington is full of Hobbits, which I have to admit is a bit distracting. I'll post the swipe extensions when I'm back, some time next week. <br><br></td></tr></table><br>
<a name="2043834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >pantson</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good stuff.<br>I was looking at implementing a gesture class too.<br>Was going to approach it from a completely different angle so I could detect odd shaped gestures (swirls, ticks etc)<br>May see if I can extend this class, but feel I may have to start again<br><br>If I get anywhere I'll post that up. <br><br></td></tr></table><br>
<a name="2044310"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Anatol</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>OK, here are my swipe gesture classes that extend the touch monitor class above. These are "simple" swipe gestures. You can define any angle and direction for a gesture (with a vector that describes the swipe) and define if the gesture validates with one or more touch indices (fingers). As mentioned earlier, optional you can also set a "velocity coefficient" which just means that if you do a quick flick then the swipe gesture also validates if it's shorter than the defined minimum length. Swipes can also be defined to only validate if they start in a certain area, and if it requires one, two or more fingers to validate.<br><br>PLEASE NOTE: If you earlier downloaded the TouchMonitor from the post above you need to update it. I had to change a few lines to fix a bug in the SwipeGesture class. This archive contains all the updated classes, sample code and the new swipe gestures:<br><br>Download: <a href="http://attic.nugob.org/communities/monkeycoder.co.nz/forum/attachments/touchMonitorTest_2012-12-11.zip" target="_blank">http://attic.nugob.org/communities/monkeycoder.co.nz/forum/attachments/touchMonitorTest_2012-12-11.zip</a><br><br>Screenshot of the swipe gesture sample code (see download or below):<br><img src="http://attic.nugob.org/communities/monkeycoder.co.nz/forum/attachments/swipeGestures.png"><br><br>Here's some sample code that demonstrate how to set up a gesture that has to start in a rectangular area, one that has to start in a circular area and one multi touch gesture.<br>[monkeycode]<br>Strict<br><br>Import mojo<br>Import vector<br>Import swipeGestures<br><br><br>Global Touch:TouchMonitor<br><br><br>Function Main:Int()<br>        New MyApp<br>        Return 0<br>End<br><br><br>Class MyApp Extends App<br>	<br>	Field swipeGestureRectangularArea:SwipeGestureWithRectangularArea<br>	Field swipeGestureCircularArea:SwipeGestureWithCircularArea<br>	Field multiTouchSwipeGesture:SwipeGesture<br>	<br>	Field showSwipeGestureRectangularAreaInfo:Bool<br>	Field showSwipeGestureCircularAreaInfo:Bool<br>	Field showMultiTouchSwipeGestureInfo:Bool<br>	<br>        <br>	Method OnCreate:Int()<br>		SetUpdateRate(60)<br>				<br>		' define a swipe gesture with a rectangular start area that validates if the user swipes a minimum of 200 pixels to the left;<br>		' the 0.1 value in the line below means that swipes that are shorter than 200 pixels can validate if the swipe is quick (a fast flick)<br>		swipeGestureRectangularArea = New SwipeGestureWithRectangularArea(New Vector(-200, 0), 0, DeviceHeight()-50, DeviceWidth(), 50, 0.1)<br>		<br>		' define a swipe gesture with a circular start area that validates if the user swipes a minimum of 100 pixels down<br>		swipeGestureCircularArea = New SwipeGestureWithCircularArea(New Vector(0, 100), DeviceWidth() / 2, DeviceHeight()/2, 100)<br>		<br>		' define a multi touch swipe gesture that requires 2 touch indices to validate (without start area, so this gesture validates anywhere as long as the direction and length validate)<br>		multiTouchSwipeGesture = New SwipeGesture(New Vector(200, 0), , 2) ' 2 defines the number of touch indices (fingers) that need to touch the screen to validate<br>		<br>		Return 0<br>	End<br> 	<br>	Method OnUpdate:Int()<br>				<br>		' MONITORING SWIPE GESTURES ''''''''''''''''''''''<br>		<br>		' swipe gesture with rectangular start area<br>		swipeGestureRectangularArea.Update() ' must call this<br>		If swipeGestureRectangularArea.ValidOnRelease<br>			showSwipeGestureRectangularAreaInfo = Not showSwipeGestureRectangularAreaInfo ' toggle the value of a Bool if the swipe gesture validates<br>		Endif<br>		<br>		' swipe gesture with circular start area<br>		swipeGestureCircularArea.Update() ' must call this<br>		If swipeGestureCircularArea.ValidOnRelease<br>			showSwipeGestureCircularAreaInfo = Not showSwipeGestureCircularAreaInfo ' toggle the value of a Bool if the swipe gesture validates<br>		Endif<br>		<br>		' multi touch swipe gesture<br>		multiTouchSwipeGesture.Update() ' must call this<br>		If multiTouchSwipeGesture.ValidOnRelease<br>			showMultiTouchSwipeGestureInfo = Not showMultiTouchSwipeGestureInfo ' toggle the value of a Bool if the swipe gesture validates<br>		Endif<br>		<br>		Return 0<br>	End<br>	<br>	Method OnRender:Int()<br>		Cls()		<br>		<br>		' VISUALIZE THE RECTANGULAR SWIPE GESTURE AREA ''''''''''''''''''''<br>		SetColor(255, 0, 255)<br>		SetAlpha(0.3)<br>		DrawRect(swipeGestureRectangularArea.StartAreaPosition.X, swipeGestureRectangularArea.StartAreaPosition.Y, swipeGestureRectangularArea.StartAreaWidth, swipeGestureRectangularArea.StartAreaHeight)<br>		SetAlpha(1)<br>		DrawText("swipe 200 pixels to the left (or less if you swipe quickly)", swipeGestureRectangularArea.StartAreaPosition.X + 200, swipeGestureRectangularArea.StartAreaPosition.Y + 10)<br>		<br>		' display something if the rectangular swipe gesture validated on release<br>		If showSwipeGestureRectangularAreaInfo Then DrawText("Swipe to the left again to hide this text.", swipeGestureRectangularArea.StartAreaPosition.X + 200, swipeGestureRectangularArea.StartAreaPosition.Y + 30)<br>		<br>		<br>		' VISUALIZE THE CIRCULAR SWIPE GESTURE AREA ''''''''''''''''''''<br>		SetColor(255, 255, 0)<br>		SetAlpha(0.3)<br>		DrawCircle(swipeGestureCircularArea.StartAreaPosition.X, swipeGestureCircularArea.StartAreaPosition.Y, swipeGestureCircularArea.Radius)<br>		SetAlpha(1)<br>		DrawText("swipe 100 pixels down", swipeGestureCircularArea.StartAreaPosition.X - 50, swipeGestureCircularArea.StartAreaPosition.Y)<br>		<br>		' display something if the rectangular swipe gesture validated on release<br>		If showSwipeGestureCircularAreaInfo Then DrawText("Swipe down again to hide this text.", swipeGestureCircularArea.StartAreaPosition.X - 50, swipeGestureCircularArea.StartAreaPosition.Y + 20)<br>		<br>		<br>		' INFOR FOR THE MULTI TOUCH SWIPE GESTURE AREA ''''''''''''''''''''<br>		SetColor(0, 255, 0)<br>		DrawText("swipe with 2 fingers 200 pixels to the right (anywhere)", DeviceWidth() - 400, 10)<br>		<br>		' display something if the rectangular swipe gesture validated on release<br>		If showMultiTouchSwipeGestureInfo Then DrawText("Swipe with 2 fingers right again to hide this text.", DeviceWidth() - 400, 25)<br>		<br>		<br>		' DRAW SWIPE INFOS<br>		<br>		' swipe gesture with rectangular start area<br>		If swipeGestureRectangularArea.IsSwiping<br>			SetColor(255, 0, 255)<br>			DrawText("RECTANGULAR SWIPE GESTURE INFO", 10, 10)<br>			DrawText("          Length: " + swipeGestureRectangularArea.Offset.Length, 10, 25)<br>			DrawText("           Angle: " + swipeGestureRectangularArea.Offset.Direction, 10, 40)<br>			DrawText("   Center offset: " + swipeGestureRectangularArea.CenterOffset.X + ", " + swipeGestureRectangularArea.CenterOffset.Y, 10, 55)<br>			If swipeGestureRectangularArea.HasValidStartArea<br>				DrawText("valid start area: YES", 10, 70)<br>			Else<br>				DrawText("valid start area: NO ", 10, 70)<br>			Endif<br>		Endif<br>		<br>		' swipe gesture with circular start area<br>		If swipeGestureCircularArea.IsSwiping<br>			SetColor(255, 255, 0)<br>			DrawText("CIRCULAR SWIPE GESTURE INFO", 10, 10)<br>			DrawText("          Length: " + swipeGestureCircularArea.Offset.Length, 10, 25)<br>			DrawText("           Angle: " + swipeGestureCircularArea.Offset.Direction, 10, 40)<br>			DrawText("   Center offset: " + swipeGestureCircularArea.CenterOffset.X + ", " + swipeGestureCircularArea.CenterOffset.Y, 10, 55)<br>			If swipeGestureCircularArea.HasValidStartArea<br>				DrawText("valid start area: YES", 10, 70)<br>			Else<br>				DrawText("valid start area: NO ", 10, 70)<br>			Endif<br>		Endif<br>		<br>		' multi touch swipe gesture<br>		If multiTouchSwipeGesture.IsSwiping<br>			SetColor(0, 255, 0)<br>			DrawText("MULTI TOUCH SWIPE GESTURE INFO", DeviceWidth() - 300, 55)<br>			DrawText("          Length: " + multiTouchSwipeGesture.Offset.Length, DeviceWidth() - 300, 70)<br>			DrawText("           Angle: " + multiTouchSwipeGesture.Offset.Direction, DeviceWidth() - 300, 85)<br>			DrawText("   Center offset: " + multiTouchSwipeGesture.CenterOffset.X + ", " + multiTouchSwipeGesture.CenterOffset.Y, DeviceWidth() - 300, 100)<br>		Endif<br>		<br>		Return 0<br>	End<br>    <br>End<br>[/monkeycode]<br><br>The new swipe gesture classes<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import touchMonitor


Class SwipeGesture Extends TouchMonitor
	
	Private
	
	Field swipe:Vector ' swipe defines the direction and minimum length that is required to validate the gesture
	Field velocityCoefficient:Float ' if set to a value lower than 1 the velocity influences if the swipe gesture validates (e.g. with a value of 0.1 a shorter gesture validates if it is fast enough, i.e. a quick flick); note that touch velocity values may be heavily influenced by the update frame rate
	Field numIndices:Int ' the amount of touch indices required for the touch gesture to validate (e.g. for a 2 finger swipe gesture) 
	Field angleDeviation:Float ' how much may the angle of the swipe gesture deviate from the defined angle? The default tolerance is 45 degrees
	Field hasValidStartArea:Bool ' required for extending classes that require that a gesture starts in a certain area
	
	
	'summary: sets up the object (this is only called via New and New in extending classes)
	Method SetupSwipeGesture:Void(_swipe:Vector, _velocityCoefficient#, _numIndices%, _angleDeviation#=45, _coordinateOffset:Vector, _adjustmentRatio#)
		swipe = _swipe
		velocityCoefficient = _velocityCoefficient
		numIndices = _numIndices
		angleDeviation = _angleDeviation
		
		Setup(_numIndices, _coordinateOffset, _adjustmentRatio)
	End
	
	'summary: updates the touch position and swipe vectors of all touch indices (call this from extending classes)
	Method UpdateTouchMonitor:Void()
		Super.Update()
	End
	
	
	Public
	
	'summary: set up the touch gesture class with an (optional) rectangular start area; if the velocity coefficient is set &lt; 1 then swipes with a higher velocity validate on a shorter offset (similar to the photo app); numIndices defines how many indices need to perform the gesture to validate; indices defines how many touch indices will be monitored (0 upwards); if offset is set the position is offset
	Method New(_swipe:Vector, _velocityCoefficient#=1, _numIndices%=1, _angleDeviation#=45, _coordinateOffsetX#=0, _coordinateOffsetY#=0, _adjustmentRatio#=1)
		SetupSwipeGesture(_swipe, _velocityCoefficient, _numIndices, _angleDeviation, New Vector(_coordinateOffsetX, _coordinateOffsetY), _adjustmentRatio)
		hasValidStartArea = True ' this swipe gesture doesn't monitor where the gesture starts, so the start area always validates
	End
	
	'summary: updates the swipe gesture
	Method Update:Void()
		Super.Update()
		If Not hasValidStartArea Then hasValidStartArea = MultipleFirstTouchInArea(-10000, -10000, 30000, 30000, , numIndices) ' this may look unnecessary, but for multi touch gestures this is the easiest method to check if the gesture had more than one touch index touching (this is important because in many cases fingers of multi touch gestures start and stop touching the screen on different frames, the first touch simply registers if these indices have ever touched the screen during the gesture, so it is not important if they simultaneously touch and release)
		If PreviousTouchDownIndices.Length = 0 Then hasValidStartArea = False 'reset hasValidStartArea if all indices are released (this has 1 frame delay by using previousTouchDownIndices.Length instead of AllReleased so that the start area still validates on release)
	End
	
	'summary: returns True if the gesture starts in the defined start area (also returns True if no start area was defined)
	Method HasValidStartArea:Bool() Property
		Return hasValidStartArea
	End
	
	'summary: returns True if a swipe movement in the defined direction is currently taking place (even if it does not (yet) validate); note: this returns False on release
	Method IsSwiping:Bool() Property
		Return Not AllReleased And hasValidStartArea And CenterOffset.AngleTo(swipe) &lt; angleDeviation
	End
	
	'summary: returns True if a swipe movement in the defined direction is currently taking place or if the swipe was just released (even if it doesn't validate)
	Method IsSwipingOrReleased:Bool() Property
		Return hasValidStartArea And CenterOffset.AngleTo(swipe) &lt; angleDeviation
	End
	
	'summary: returns True if the current touch validates
	Method Valid:Bool() Property
		If Not AllEnabled Then Return False
		Local velocityInfluence:Float = 1
		If velocityCoefficient &lt; 1
			velocityInfluence = velocityCoefficient * AverageVelocity.Length
			If velocityInfluence &lt; 1 Then velocityInfluence = 1 ' ensures that velocity influence is never smaller than 1 (practically this wouldn't make much sense because the velocityCoefficient is typically only used to reduce the required length of a swipe gesture if it is fast enough, not to enforce a longer swipe gesture if it is fast)
		EndIf
		' check if the current touch swipe length is equal or longer than the hypothenuse of a right triangle of which the swipe vector is the adjacent side and angle A is the angle between swipe vector and actual current touch swipe
		Return hasValidStartArea And CenterOffset.Length * velocityInfluence &gt;= swipe.Length / Cos(swipe.AngleTo(CenterOffset)) And CenterOffset.AngleTo(swipe) &lt; angleDeviation
	End
	
	'summary: returns True if the gesture validates on release; note: instead of Not ValidOnRelease() call NotValidOnRelease() because this is more precise (Not ValidOnRelease would also return True if it is valid but hasn't been released at all)
	Method ValidOnRelease:Bool() Property
		Return AllReleased And Valid
	End
	
	'summary: returns True if the gesture doesn't validate on release (this is more precise than simply calling Not ValidOnRelease
	Method NotValidOnRelease:Bool() Property
		Return AllReleased And Not Valid
	End
	
	'summary: returns the swipe vector that defines the direction and minimum length of the swipe gesture to validate
	Method Swipe:Vector() Property
		Return swipe
	End
	
	'summary: sets the swipe vector that defines the direction and minimum length of the swipe gesture to validate (this is hardly ever necessary but may be useful to e.g. reverse a page turn swipe for some languages such as Japanese and Chinese)
	Method Swipe:Void(_swipe:Vector) Property
		swipe.Set(_swipe)
	End
	
End


Class SwipeGestureWithArea Extends SwipeGesture Abstract
	
	Private
	
	Field startAreaPosition:Vector
	
	'summary: sets up the object (this is only called via New and New in extending classes)
	Method SetupSwipeGestureWithArea:Void(_swipe:Vector, _startAreaPosition:Vector, _velocityCoefficient#, _numIndices%, _angleDeviation#=45, _coordinateOffset:Vector, _adjustmentRatio#)
		startAreaPosition = _startAreaPosition
		
		SetupSwipeGesture(_swipe, _velocityCoefficient, _numIndices ,_angleDeviation, _coordinateOffset, _adjustmentRatio)
	End
	
	'summary: returns the start area position
	Method StartAreaPosition:Vector() Property
		Return startAreaPosition
	End
	
	'summary: sets the start area position
	Method StartAreaPosition:Void(_startAreaPosition:Vector) Property
		startAreaPosition.Set(_startAreaPosition)
	End
	
	'summary: sets the start area position
	Method StartAreaPosition:Void(x#, y#)
		startAreaPosition.Set(x, y)
	End
	
End


Class SwipeGestureWithRectangularArea Extends SwipeGestureWithArea
	
	Private
	
	Field startAreaDimension:Vector
	
	'summary: sets up the object (this is only called via NewNew in extending classes)
	Method SetupSwipeGestureWithRectangularArea:Void(_swipe:Vector, _startAreaPosition:Vector, _startAreaDimension:Vector, _velocityCoefficient#, _numIndices%, _angleDeviation#=45, _coordinateOffset:Vector, _adjustmentRatio#)
		startAreaDimension = _startAreaDimension
		
		SetupSwipeGestureWithArea(_swipe, _startAreaPosition, _velocityCoefficient, _numIndices, _angleDeviation, _coordinateOffset, _adjustmentRatio)
	End
	
	
	Public
	
	'summary: set up the touch gesture class with an (optional) rectangular start area; if the velocity coefficient is set &lt; 1 then swipes with a higher velocity validate on a shorter offset (similar to the photo app); numIndices defines how many indices need to perform the gesture to validate; indices defines how many touch indices will be monitored (0 upwards); if offset is set the position is offset
	Method New(_swipe:Vector, _startAreaPosition:Vector=New Vector, _startAreaDimension:Vector=New Vector, _velocityCoefficient#=1, _numIndices%=1, _angleDeviation#=45, _coordinateOffsetX#=0, _coordinateOffsetY#=0, _adjustmentRatio#=1)
		SetupSwipeGestureWithRectangularArea(_swipe, _startAreaPosition, _startAreaDimension, _velocityCoefficient, _numIndices, _angleDeviation, New Vector(_coordinateOffsetX, _coordinateOffsetY), _adjustmentRatio)
	End
	
	'summary: set up the touch gesture class with an (optional) rectangular start area; if the velocity coefficient is set &gt; 0 then swipes with a higher velocity validate on a shorter offset (similar to the photo app; numIndices defines how many indices need to perform the gesture to validate; indices defines how many touch indices will be monitored (0 upwards); if offset is set the position is offset
	Method New(_swipe:Vector, startAreaPositionX#, startAreaPositionY#, startAreaWidth#=0, startAreaHeight#=0, _velocityCoefficient#=1, _numIndices%=1, _angleDeviation#=45, _coordinateOffsetX#=0, _coordinateOffsetY#=0, _adjustmentRatio#=1)
		SetupSwipeGestureWithRectangularArea(_swipe, New Vector(startAreaPositionX, startAreaPositionY), New Vector(startAreaWidth, startAreaHeight), _velocityCoefficient, _numIndices, _angleDeviation, New Vector(_coordinateOffsetX, _coordinateOffsetY), _adjustmentRatio)
	End
	
	'summary: updates the touch position and swipe vectors of all touch indices
	Method Update:Void()
		Super.UpdateTouchMonitor()
		
		If Not hasValidStartArea Then hasValidStartArea = MultipleFirstTouchInArea(startAreaPosition, startAreaDimension, , numIndices)
		If PreviousTouchDownIndices.Length = 0 Then hasValidStartArea = False 'reset hasValidStartArea if all indices are released (this has 1 frame delay by using previousTouchDownIndices.Length instead of AllReleased so that the start area still validates on release)
	End
	
	'summary: returns the start area dimension
	Method StartAreaDimension:Vector() Property
		Return startAreaDimension
	End
	
	'summary: sets the start area dimension
	Method StartAreaDimension:Void(_startAreaDimension:Vector) Property
		startAreaDimension = _startAreaDimension
	End
	
	'summary: sets the start area dimension
	Method StartAreaDimension:Void(width#, height#)
		startAreaDimension.Set(width, height)
	End
	
	'summary: Returns the start area width
	Method StartAreaWidth:Float() Property
		Return startAreaDimension.X
	End
	
	'summary: sets the start area width
	Method StartAreaWidth:Void(width#) Property
		startAreaDimension.X = Abs(width)
	End
	
	'summary: Returns the start area height
	Method StartAreaHeight:Float() Property
		Return startAreaDimension.Y
	End
	
	'summary: sets the start area height
	Method StartAreaHeight:Void(height#) Property
		startAreaDimension.Y = Abs(height)
	End
	
End


Class SwipeGestureWithCircularArea Extends SwipeGestureWithArea
	
	Private
	
	Field radius:Float
	
	'summary: sets up the object (this is only called via New and the New overload)
	Method SetupSwipeGestureWithCircularArea:Void(_swipe:Vector, _startAreaPosition:Vector, _radius#, _velocityCoefficient#, _numIndices%, _angleDeviation#, _coordinateOffset:Vector, _adjustmentRatio#)
		radius = _radius
		
		SetupSwipeGestureWithArea(_swipe, _startAreaPosition, _velocityCoefficient, _numIndices, _angleDeviation, _coordinateOffset, _adjustmentRatio)
	End
	
	
	Public
	
	'summary: set up the touch gesture class with an (optional) circular start area; if the velocity coefficient is set &gt; 0 then swipes with a higher velocity validate on a shorter offset (similar to the photo app; numIndices defines how many indices need to perform the gesture to validate; indices defines how many touch indices will be monitored (0 upwards); if offset is set the position is offset
	Method New(_swipe:Vector, _startAreaPosition:Vector, _radius#, _velocityCoefficient#=1, _numIndices%=1, _angleDeviation#=45, _coordinateOffsetX#=0, _coordinateOffsetY#=0, _adjustmentRatio#=1)
		SetupSwipeGestureWithCircularArea(_swipe, _startAreaPosition, _radius, _velocityCoefficient, _numIndices, _angleDeviation, New Vector(_coordinateOffsetX, _coordinateOffsetY), _adjustmentRatio)
	End
	
	'summary: set up the touch gesture class with an (optional) circular start area; if the velocity coefficient is set &gt; 0 then swipes with a higher velocity validate on a shorter offset (similar to the photo app; numIndices defines how many indices need to perform the gesture to validate; indices defines how many touch indices will be monitored (0 upwards); if offset is set the position is offset
	Method New(_swipe:Vector, startAreaPositionX#, startAreaPositionY#, _radius#, _velocityCoefficient#=1, _numIndices%=1, _angleDeviation#=45, _coordinateOffsetX#=0, _coordinateOffsetY#=0, _adjustmentRatio#=1)
		SetupSwipeGestureWithCircularArea(_swipe, New Vector(startAreaPositionX, startAreaPositionY), _radius, _velocityCoefficient, _numIndices, _angleDeviation, New Vector(_coordinateOffsetX, _coordinateOffsetY), _adjustmentRatio)
	End
	
	'summary: updates the touch position and swipe vectors of all touch indices
	Method Update:Void()
		Super.UpdateTouchMonitor()
		
		If Not hasValidStartArea Then hasValidStartArea = MultipleFirstTouchInCircle(startAreaPosition, radius, numIndices)
		If PreviousTouchDownIndices.Length = 0 Then hasValidStartArea = False 'reset hasValidStartArea if all indices are released (this has 1 frame delay by using previousTouchDownIndices.Length instead of AllReleased so that the start area still validates on release)
	End
	
	'summary: returns the start area radius
	Method Radius:Float() Property
		Return radius
	End
	
	'summary: sets the start area radius
	Method Radius:Void(_radius#) Property
		radius = _radius
	End
	
End
</textarea><br><br>I hope this is helpful for some people. Feel free to post any bugs, improvements, replacements here.<br><br>Cheers!<br>Anatol <br><br></td></tr></table><br>
<a name="2048125"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RobB</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anatol,<br><br>Thank you for a very useful post even for beginners. You have commented so thoroughly, and provided a working example so that even if one doesn't understand how all the code works yet, he can see where to "plug in" to make things "work". I'd suggest in your zip file that you just add some instructions so beginners know to put "vector" and "touchMonitor" in the modules file and the runnable examples in the bananas file. As one who is still learning slowly, but gets lost in the assumed basics sometimes, I appreciate all the help I can get. Your examples make things workable for a beginner and encourage further learning by showing how it all works.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="2048196"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Samah</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks kinda like Diddy's InputCache in terms of functionality. <br><br></td></tr></table><br>
<a name="2049151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rIKmAN</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anatol, thanks for this - very helpful! :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
