<!DOCTYPE html><html lang="en" ><head ><title >Ball to Line Elastic Engine with dynamic collision</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Ball to Line Elastic Engine with dynamic collision</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=512" >Monkey Code</a>/<a href="#bottom" >Ball to Line Elastic Engine with dynamic collision</a><br><br>
<a name="2046798"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> an elastic collision engine. very basic. similar to what I used for my Pool game:<br><a href="http://www.mochimedia.com/games/play/8-ball-hustler" target="_blank">http://www.mochimedia.com/games/play/8-ball-hustler</a><br><br><br> If there is enough interest, I will add ball to ball, ball to Arc, and ball to Circle  collision. <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict
Import mojo

Function Main:Int()
	New Game
	Return 1
End Function


Class Game Extends App

	Field engine:Engine
	Field time:Float
	
	Field ball:Ball2D
	Field count:Float
	Field total:Float
	
	Method OnCreate:Int()
		engine = New Engine()
		
		engine.AddWall(New LineWall(050,050,550,050))'(x1,y1,x2,y2,endpoint=true)  option to check the end point of the line or only the start point
		engine.AddWall(New LineWall(550,050,630,300))
		engine.AddWall(New LineWall(630,300,600,350))
		engine.AddWall(New LineWall(600,350,550,325))
		engine.AddWall(New LineWall(550,325,350,350))
		engine.AddWall(New LineWall(350,350,300,325))
		engine.AddWall(New LineWall(300,325,250,325))
		engine.AddWall(New LineWall(250,325,100,350))
		engine.AddWall(New LineWall(100,350,050,050))
		engine.AddWall(New LineWall(150,200,300,200))
		
		engine.AddWall(New CircleWall(350,200,50))    '(x,y,radius)

		engine.AddBall(New Ball2D(250,250,10,30,2))'(x,y,radius,angle,speed) ' accepts one ball only for now.
		engine.AddBall(New Ball2D(280,150,15,95,2))
		engine.AddBall(New Ball2D(320,150,15,85,2))
		engine.AddBall(New Ball2D(360,150,15,95,5))
		engine.AddBall(New Ball2D(400,100,15,90, 5))
		engine.AddBall(New Ball2D(410,200,15,270,4))
		engine.AddBall(New Ball2D(480,150,15,90,2))
		engine.AddBall(New Ball2D(520,150,15,90,3))

		Shape.SetGlobalFriction(1.0) 'slows down 1-0; 1 = zero slowdown 0 full stop.
		Shape.SetGlobalGravity(0,-0.1) ' gravity along x,y the higher the number the more the gravity pull.
		
		SetUpdateRate 30
		time = Millisecs()
		count = 0
		total = 0
		Return 1
	End Method
	
	Method OnUpdate:Int()
		Return 1
	End Method

	Method OnRender:Int()
	
		Cls()
		time = Millisecs()
		engine.Update()
		time = Millisecs() - time
		total += time
		count += 1
		time = Int(total/count * 100)/100.0
	
	
	
	
		engine.Render()
		DrawText "Average physics calculation time "+time+" Milliseconds",10,10
		Return 1
	End Method
	
End Class


'************************************************************** Engine *****************************************

Class CollisionTrend
 
	Field temp:PVector2D
	
	Field ball:Ball2D=Null
	
	Field obj:Shape=Null
	
	'collision normal
	
	Field cdx:Float
	Field cdy:Float
	
	Field oldL:Float

	Method New()
		temp = New PVector2D()
	End Method

End Class


Class Engine
	Field wallList:List&lt;Shape&gt;
	Field ballList:List&lt;Shape&gt;
	
	Field lastTime:Float
	Field timeFrame:Float

	Field colls:CollisionTrend[99]
	
	Field totalCol:Int
	Field colCount:Int
	
'	Field nearestBall:Ball2D
	
	
	Method New()
		wallList = New List&lt;Shape&gt;
		For Local i:Int = 0 Until 99
			colls[i] = New CollisionTrend
		Next
		ballList = New List&lt;Shape&gt;

	End Method
	
	Method AddWall:Void(wall:Shape)
		wall.node = wallList.AddLast(wall)
	End Method
	
	Method AddBall:Void(ball:Ball2D)
		ball.node = ballList.AddLast(ball)
	End Method
	
	Method RemoveWall:Void(wall:Shape)
	
		If Ball2D(wall) Error "Wrong type, can't remove Ball2D as wall"
		
		wall.node.Remove()
		
	End Method
	
	Method RemoveBall:Void(ball:Ball2D)
		ball.node.Remove()
	End Method

	Method Update:Void()
		
		Local SelfTime:Float = Millisecs()
		
		timeFrame= (SelfTime-lastTime)/16.0
		
		lastTime=SelfTime
		
		If(timeFrame=0.0)
			Return
		End
		
		If(timeFrame&gt;3.0)
			timeFrame=3.0
		End
		
		Local node := ballList.FirstNode()
		
		While node
		
			Ball2D(node.Value()).UpdateIn(timeFrame)
		
			node = node.NextNode()
		
		Wend
		
		totalCol=0
		
		Process()
		
		node = ballList.FirstNode()
		
		While node
		
			Ball2D(node.Value()).UpdateOut(timeFrame)
		
			node = node.NextNode()
		
		Wend
		
	End Method
	

	Method Process:Void()
	
		Local distance:Float=INVALID_DISTANCE
		
		Local done:Int=0
		
		Local tnearestObject:Shape = Null
		
		colCount = -1

		Local ballNode := ballList.FirstNode()

		While ballNode
		
			
			Local ball:Ball2D = Ball2D(ballNode.Value())
			
			Local ball2Node := ballList.LastNode()
			
			While ball2Node
			
				Local ball2 := Ball2D(ball2Node.Value())
								
				If ball = ball2 Exit
				
				If ball.IsMoving() Or ball2.IsMoving() 
					Local balla:Ball2D=Null
					Local ballb:Ball2D=Null
					
					If(ball.L &gt; ball2.L)
					
						balla = ball2
						ballb = ball
						
					Else
					
						balla = ball
						ballb = ball2
						
					Endif
					
					Local oldL:Float = ballb.L
					
					Local d:Float = balla.Distance(ballb)
					
					If d &lt;&gt; INVALID_DISTANCE

						If( d &lt; distance)
						
							distance = d
							
							Self.colCount=0
							
							colls[colCount].ball = ballb
							colls[colCount].obj  = balla
							
							colls[colCount].cdx = balla.cd.x
							colls[colCount].cdy = balla.cd.y
							
							colls[colCount].oldL = oldL
							
						Elseif(d = distance)
						
							Self.colCount += 1
							
							colls[colCount].ball = ballb
							colls[colCount].obj  = balla
							
							colls[colCount].cdx = balla.cd.x
							colls[colCount].cdy = balla.cd.y
							
							colls[colCount].oldL = oldL
							
						Endif
					Endif
				Endif				

				ball2Node = ball2Node.PrevNode()
				
			
			Wend
				
			Local wallNode := wallList.FirstNode()

			While wallNode
				
				Local wall := wallNode.Value()
				
				Local d2:Float = wall.Distance(ball)
				
				If d2 &lt;&gt; INVALID_DISTANCE

					If(d2&lt;distance)
					
						distance = d2
					
						colCount = 0
					
						colls[colCount].ball=Ball2D(ball)
					
						colls[colCount].obj=wall
					
						colls[colCount].cdx=wall.cd.x
					
						colls[colCount].cdy=wall.cd.y
					
						colls[colCount].oldL=0.0
					
					Elseif(d2 = distance)
					
						Self.colCount += 1
						
						colls[colCount].ball = Ball2D(ball)
						
						colls[colCount].obj = wall
						
						colls[colCount].cdx = wall.cd.x
						
						colls[colCount].cdy = wall.cd.y
						
						colls[colCount].oldL = 0.0
						
					Endif
					
				End
				
				wallNode = wallNode.NextNode()
			
			Wend


			ballNode = ballNode.NextNode()
			
		Wend
		
		Local td:Float = 1.0
		
		If(distance = INVALID_DISTANCE)
			
			td = 1.0
			
			done = 1
			
		Else
		
			td = distance
			
		Endif
		
		Local node := ballList.FirstNode()
		
		If td &gt; 0 
		
			While node 

				Ball2D(node.Value()).Advance(td)
				
				node = node.NextNode()
			
			Wend
		
		Endif	
		
		If distance &lt; INVALID_DISTANCE
			For Local i:Int = 0 to colCount
				colls[i].obj.Bounce(colls[i].ball,colls[i].cdx,colls[i].cdy)
			Next
			
		Endif
		
		If(totalCol&gt;=0)
			
			totalCol+=colCount+1
			
		End
		
		If Not done
			Process()
		End
		
	End Method

	Method Render:Void()
		For Local w:Shape = Eachin wallList
			w.Render()
		Next
		Local node := ballList.FirstNode()
		While node
			node.Value().Render()
			node = node.NextNode()
		Wend
	End Method
End Class



'*************************************************** Shape Objects *************************************************


Const INVALID_DISTANCE:Float = 100000000.0

Class Shape

	Field P:PVector2D	'position
	
	Field V:PVector2D	'velocity
	Field D:PVector2D	'direction
	
	Field L:Float		'length
	
	Field cp:PVector2D	'collision point
	
	Field tp:PVector2D
	Field cd:PVector2D
	Field v2:PVector2D
	
	Global Gravityx:Float
	Global Gravityy:Float
	
	Global ApplicableGravityx:Float
	Global ApplicableGravityy:Float
	
	Global SurfaceFriction:Float
	Global ApplicableSurfaceFriction:Float

	Field friction:Float
	Field bounce:Float
	
	Field node:list.Node&lt;Shape&gt;

	Method New()
	
		V = New PVector2D
		v2 = New PVector2D
		D = New PVector2D
		cp = New PVector2D
	End Method
	
	Method Init:Void(vx:Float,vy:Float)
		
		V.Set(vx,vy)
		
		L=V.Magnitude()
		
		If(L&gt;0.0)
			D.Set(V).Normalize()
		Else
			D.Set(0,0)
		End
		
	End Method
	
	Method Init:Void(v:PVector2D)

		V.Set(v)
		
		L=V.Magnitude()
		
		If(L&gt;0.0)
			D.Set(V).Normalize()
		Else
			D.Set(0,0)
		End	
	
	End Method

	Function SetGlobalGravity:Void(gx:Float,gy:Float)
		Gravityx=gx
		Gravityy=gy
		ApplicableGravityx=gx
		ApplicableGravityy=gy
	End Function

	Function SetGlobalFriction:Void(tf:Float)
		SurfaceFriction=tf
		ApplicableSurfaceFriction=tf
	End Function

	Method CollisionDistanceB2RW:Float(ball:Ball2D,tx:Float,ty:Float,tradius:Float)

		If Not ball.MovingToward(tx,ty) Return INVALID_DISTANCE

		'temporary collision normal storage
		tp=Null
		
		' vector from ball position to circle position
		v2.Set(tx,ty).Subtract(ball.P)
		
		'radius between ball And circle
		Local ttotRadiusSq:Float = (ball.radius+tradius)*(ball.radius+tradius)
		
		'distance square between ball And circle
		Local tdistSq:Float = v2.MagnitudeSquare()
		
		'dot product To determine ball distance To circle And direction
		Local dp:Float=ball.D.DotProduct(v2)

		'is ball moving toward circle
		If(dp&gt;0.0)
			

			'position of ball closest To circle
			Local x1:Float=ball.P.x+(dp*ball.D.x)
			Local y1:Float=ball.P.y+(dp*ball.D.y)
			
			'ball distance square to circle
			Local tllSq:Float=(tx-x1)*(tx-x1)+(ty-y1)*(ty-y1)
			
			'maximum distance to circle for collision
			Local tmaxDist:Float=tradius+ball.radius
			
			' did ball pass circle close enough to collide
			If(tllSq&lt;=tmaxDist*tmaxDist)
			
				' using pytagoreans theorem to determin where to position ball at time of collision
				' hypotenus
				Local c:Float=ball.radius+tradius
				
				' side b length
				Local b:Float=Sqrt(tllSq)
				
				' side a length
				Local a:Float=Sqrt(c*c-b*b)
				
				'position of ball x at time of collision
				Local tx2:Float=x1-ball.D.x*a
				
				'position of ball y at time of collision
				Local ty2:Float=y1-ball.D.y*a
				
				'vector x between ball And circle at time of collision
				Local trvx:Float=tx2-ball.P.x
				
				'vector y between ball and circle at time of collision
				Local trvy:Float=ty2-ball.P.y
				
				' how far the ball need to move in order to collide
				Local tdistSq2:Float=trvx*trvx+trvy*trvy
				
				' check if collision happened with in movement vector and if ball is moving toward circle.
				If(tdistSq2&lt;=ball.L*ball.L And v2.DotProduct(trvx,trvy)&gt;=0.0)
				
					' store ball vector at time of collision
					v2.Set(tx-(ball.P.x+trvx),ty-(ball.P.y+trvy))
					
					If((c)&lt;&gt;0.0) ' did ball move at all before collision?
						' store collision normal
						cd.Set(v2.x/c,v2.y/c)
						
					Else
					
						cd.Set(0,0)
						
					End
					'store ball collision point
					cp.Set(ball.P.x+trvx+cd.x*ball.radius,ball.P.y+trvy+cd.y*ball.radius)
					
					tp=cp
					' change ball position to ration between ball collision vector and time frame movement.
					Local t:Float=Sqrt(tdistSq2)/ball.L
					
					Return t
					
				End
				
			End
			
		End
		' no collision
		Return INVALID_DISTANCE
		
	End Method

	Method Bounce:Void(ball:Ball2D,tpx:Float,tpy:Float)
		Return
	End

	Method Bounce2Fixed:Void(ball:Ball2D,dx:Float,dy:Float)
		
		' dot product between ball movement and collision normal
		Local dp:Float=ball.V.DotProduct(dx,dy)
		
		'project ball movement into collision normal and reverst step (step one in creating deflection) 
		v2.Set(-dp*dx,-dp*dy)
		
		'dot product between ball movement and perpendicular collision normal
		dp=ball.V.PerpDotProduct(dx,dy)

		'project ball movement into collision perpendicualr normal and add both vectors (step two in creating deflection)
		v2.Add(dp*dy,-dp*dx)
		
		'replace old movement vector with new movement vector
		ball.V.Set(v2)

		
		'duplicate the whole process again for the spend movement vector.
		
		dp=ball.tv.DotProduct(dx,dy)

		v2.Set(-dp*dx,-dp*dy)

		dp = ball.tv.DotProduct(dy,-dx)

		v2.Add(dp*dy,-dp*dx)

		ball.tv.Set(v2)
	
	End Method
	
	
	Method Distance:Float(b:Ball2D)
		Return INVALID_DISTANCE
	End
	Method Render:Void() Abstract

End Class

'-------------------------------------------------------- line wall ---------------------------------------


Class LineWall Extends Shape
	Field P2:PVector2D
	Field includeEP:int
	
	Method New(x1:Float,y1:Float,x2:Float,y2:Float,includeEP:Int=True)

		Self.P = New PVector2D(x1,y1)
		
		Self.V.Set(x2-x1,y2-y1)
		
		Self.D.Set(Self.V).Normalize()
		
		Self.P2 = New PVector2D(x1,y1).Add(Self.V)
		
		Self.cd = New PVector2D()
		
		Self.includeEP = includeEP
		
	End Method
	
	Method Distance:float(ball:Ball2D)
		tp = Null
		
		'vector from ball position to start of wall
		Local a:Float=ball.P.x-Self.P.x
		Local b:Float=ball.P.y-Self.P.y
		
		'vector from ball position after move to start of wall
		Local a1:Float=ball.P.x+ball.V.x-Self.P.x
		Local b1:Float=ball.P.y+ball.V.y-Self.P.y
		
		'distance from ball position to wall
		Local d1:Float=a * Self.D.y-b* Self.D.x
		
		'distance from ball movement vector end to wall
		Local d2:Float=a1*Self.D.y-b1*Self.D.x

		If(Abs(d1)&lt;ball.radius) ' did ball penetrated line projection
		
			'vector from the ball position to end of wall
			v2.Set(ball.P).Subtract(Self.P.x+Self.V.x, Self.P.y+Self.V.y)
			
			'check to se if ball will collide within lineWall reach
			If(V.DotProduct(v2) &lt;= 0.0 And V.DotProduct(a,b) &gt;= 0.0)
				
				'check for line penetration as a result of floating point error

				'is collisin from the right
				If(d1 &gt; 0.0 And d1 &gt; d2)

					'set the collision normal
					Self.cd.Set(-Self.D.y,Self.D.x)
					' if ball penetrated line 
					Return 0.0
				
				'is collision from the left	
				Elseif(d1&lt;0.0 And d1&lt;d2)
					
					'set the collision normal
					Self.cd.Set(Self.D.y,-Self.D.x)
					Return 0.0
					
				Endif
				
			Endif
			
		Endif
		
		Local t:Float=0.0 'time of collision relative to frame (ration)
		
		
		
		If(d1 &gt; 0.0) 'did collision of ball to line happen from the left
		
			t = (ball.radius - d1) / (d2 - d1) ' get time of collisin ration
			
		Elseif( d1 &lt; 0.0) 'did collision of ball to line happen from the right
			
			t = (ball.radius + d1)/(d1 - d2) 'get time of collision ration
			
		Endif
		
		' is ball moving toward line
		If(d1 &gt; 0.0 And d2 &gt;= d1 Or d1 &lt; 0.0 And d2 &lt;= d1)
			
			'crate a vector from end of wall to ball position 
			v2.Set(ball.P.x - (Self.P.x+Self.V.x), ball.P.y - (Self.P.y+Self.V.y))
			
			'check if ball is to far from end of wall
			If(Self.D.DotProduct(a,b) &gt;= 0.0 And Self.D.DotProduct(v2) &lt; 0.0)
				
				' no collision occured
				Return INVALID_DISTANCE
				
			Endif
			
		Endif
		
		'did collision happen with in movement vector
		If( t &lt;= 1.0 And t &gt;= 0.0)
			
			'store the exact point of collision
			Self.cp.Set(ball.P.x, ball.P.y).Add(ball.V.x * t,ball.V.y * t)
			
			'crate a vector between start of wall and positin of ball at the time of collision
			v2.Set(Self.cp.x - Self.P.x, Self.cp.y - Self.P.y)
			
			'dot product used to determine collision on line
			Local dp:Float = Self.D.DotProduct(v2)
			
			'determin if collision happened after the start of the line 
			If(dp &gt; 0.0)
				
				'vector from end of wall to ball position at time of collision
				v2.Set(Self.cp).Subtract(Self.P.x+Self.V.x, Self.P.y+Self.V.y)
				
				'Self.cp.Set(Self.D).Multiply(dp).Add(Self.P) '************************** 
				
				'determin if collision happened before the end of the line
				If(Self.D.DotProduct(v2) &lt; 0.0)
					'
'					If(Abs(d1) &lt; ball.radius)
					
'						Local diff:Float = ball.radius - Abs(d1)
						
'						ball.P.Add(diff * Self.D.y,-diff * Self.D.x)
						
'					Endif

					' set the collision normal
					Self.cd.Set(Self.D.y,-Self.D.x)
					
					'store it for referal
					Self.tp = Self.cp
					
					'return time of collision ration

					Return t

				Endif

			Endif

		Endif
		
		' if no collision found check for collision agains end points
		
		Local dist:Float = INVALID_DISTANCE
		
		If includeEP ' check for end point if instructed to do so
		
			' find out if there is a collision with the end point
			dist = Self.CollisionDistanceB2RW(ball,Self.P.x+Self.V.x,Self.P.y+Self.V.y,0.0)
			

		Endif
		
		' check for collision with the start point of line
		Local dist2:Float = Self.CollisionDistanceB2RW(ball,Self.P.x,Self.P.y,0.0)

		'find out which collision happened first
		If dist2 &lt; dist
			'store the first collision
			dist = dist2

		Endif
		
		'return the time of collision ratio.
		Return dist
		
	End method
	
	
	'used to determin the new ball movement vector direction
	Method Bounce:Void(ball:Ball2D,dx:Float,dy:Float)
		Bounce2Fixed(ball,dx,dy)
	End
	
	'draw the vector
	Method Render:Void()
		DrawLine(P.x,P.y,P2.x,P2.y)
	End Method
	
	
End Class

'--------------------------------------------------------- circle wall -------------------------------------


Class CircleWall Extends Shape
	
	Field radius:Float ' wall radius
	
	Method New(x:Float,y:Float,radius:Float)
	
		P = New PVector2D(x,y) ' position
		
		cd = New PVector2D ' collision normal
		
		Self.radius = radius 'ball radius
		
	End Method
	
	' get the distance between the ball and the circle wall if with in movent distance
	Method Distance:Float(ball:Ball2D)
		Return  CollisionDistanceB2RW(ball,P.x,P.y,radius)

	End Method
	
	
	'used to determin the new ball movement vector direction
	Method Bounce:Void(ball:Ball2D,dx:Float,dy:Float)

		Bounce2Fixed(ball,dx,dy)

	End Method
	
	Method Render:Void()

		DrawCircle P.x,P.y,radius

	End Method
	
End Class
'---------------------------------------------------------- 2d ball ----------------------------------------



Class Ball2D Extends Shape
	Field radius:Float
	Field mass:float
	Field tv:PVector2D
	
	Method New(pos:PVector2D, radius:Float, angle:Float, speed:Float,mass:float=1.0)
		_Init(pos,radius,angle,speed)
		Self.mass = mass
		cd = New PVector2D
	End Method

	Method New(x:Float,y:Float,radius:Float,angle:Float,speed:Float,mass:Float=1.0)
		
		_Init(New PVector2D(x,y),radius,angle,speed)
		Self.mass = mass
		cd = New PVector2D

	End Method
	
	Method _Init:Void(pos:PVector2D, radius:Float, angle:Float, speed:Float)
		Self.P = New PVector2D(pos.x,pos.y)
		Self.P.Set(pos)
		Self.D.Set(Cos(angle),Sin(angle))		
		Self.V.Set(D).Multiply(speed)
		Self.L = speed
		Self.radius = radius
		Self.tv = New PVector2D
		Self.friction = 1.0
		Self.bounce = 1.0
	End Method
	
	Method UpdateIn:Void(timeFrame:Float)
		
		V.Add(Shape.ApplicableGravityx,Shape.ApplicableGravityy)
		
		V.Multiply(Shape.ApplicableSurfaceFriction)
		
		V.Multiply(timeFrame)
		
		Init(V.x, V.y)
	
	End
	
	Method SetPosition:Void(x:Float,y:Float)
		pos.Set(x,y)
	End Method
	
	Method SetMovement:Void(angle:Float,spd:Float)
		V.Set(D.Set(Cos(angle),Sin(Angle))).Multiply(speed)
		L = spd
	End Method
	
	Method IsMoving:Int()
		
		Return V.x Or V.y
		
	End Method

	Method UpdateOut:Void(timeFrame:Float)
	
		V.Set(tv)
		
		tv.Set(0,0)

		V.Divide(timeFrame)

		If(Abs(V.x)&lt;0.05 And Abs(V.y) &lt; 0.05)
	
			V.Set(0,0)
	
		End

		Init(V.x,V.y)

	End Method
	
	Method MovingToBall:Int(ball:Ball2D)
		
		Return((ball.P.x - P.x) * (V.x - ball.V.x) + (ball.P.y - P.y) * (V.y - ball.V.y)) &gt; 0.0

	End Method

	Method Distance:Float(ball:Ball2D)
		
		Local vx:Float = ball.P.x - Self.P.x
		Local vy:Float = ball.P.y - Self.P.y
		
		If(vx * vx + vy * vy &lt; (Self.radius + ball.radius) * (Self.radius + ball.radius))
			
			If(Self.MovingToBall(ball))
				
				Local len:Float = Sqrt(vx * vx + vy * vy)
				
				Self.cd.x= vx / len
				Self.cd.y= vy / len
				
				Return 0.0
			
			Endif
			
		Endif
		
		If(-vx * ball.V.x - vy * ball.V.y &lt; 0.0)
			
			Return INVALID_DISTANCE
			
		Endif
		
		Local vx1:Float = V.x - ball.V.x
		Local vy1:Float = V.y - ball.V.y
		
		Local totalRadius:Float = radius + ball.radius
		
		Local l1:Float = Sqrt(vx1 * vx1 + vy1 * vy1)
		
		Local dx1:Float = vx1 / l1
		Local dy1:Float = vy1 / l1
		
		Local dp:Float = vx * dx1 + vy * dy1
		
		Local vx2:Float = dp * dx1
		Local vy2:Float = dp * dy1
		
		Local lengt:Float = Sqrt(Pow(ball.P.x - (P.x + vx2),2.0) + Pow(ball.P.y-(P.y + vy2),2.0))
		
		Local diff:Float = totalRadius - lengt
		
		Self.tp=Null
		
		If diff &gt; 0.0
			
			Local moveBack:Float = Sqrt(totalRadius * totalRadius - lengt * lengt)
			
			Local vx4:Float = vx2 - moveBack * dx1
			Local vy4:Float = vy2 - moveBack * dy1
			
			Local l4:Float = Sqrt(vx4 * vx4 + vy4 * vy4)
			
			If l4 &lt;= l1 And vx4 * V.x + vy4 * V.y &gt;= 0.0
			
				Local dist:Float= l4 / l1
				
				Local x1:Float = ball.P.x + ball.V.x * dist
				Local y1:Float = ball.P.y + ball.V.y * dist
				
				Local x2:Float = Self.P.x + V.x * dist
				Local y2:Float = Self.P.y + V.y * dist
				
				Local vx3:Float = x2 - x1
				Local vy3:Float = y2 - y1
				
				l1 = Sqrt(vx3 * vx3 + vy3 * vy3)
				
				If l1 &lt;&gt; 0.0
				
					cd.x = vx3 / l1
					cd.y = vy3 / l1
				
				Else
				
					cd.x = 0.0
					cd.y = 0.0
				
				Endif
				
				cp.x = x1 + cd.x * ball.radius
				cp.y = y1 + cd.y * ball.radius
				
				Self.tp = Self.cp
				
				Return dist
				
			Endif
		Endif
		
		Return INVALID_DISTANCE
	End Method
	



	Method BounceB2B:Void(ball:Ball2D,dx:Float,dy:Float)

		Local vx1:Float = ball.tv.x + ball.V.x
		Local vy1:Float = ball.tv.y + ball.V.y
		
		Local dp:Float = Self.V.x * dx + Self.V.y * dy

		Local a1:Float = dp * dx
		Local b1:Float = dp * dy
		
		dp = V.x * dy - V.y * dx
		
		Local a2:Float = dp * dy
		Local b2:Float = dp *-dx
		
		dp = ball.V.x * dx + ball.V.y * dy
		
		Local a21:Float = dp * dx
		Local b21:Float = dp * dy
		
		dp = ball.V.x * dy - ball.V.y * dx
		
		Local a22:Float = dp * dy
		Local b22:Float = dp *-dx
		
		Local P:Float = mass * a1 + ball.mass * a21
		
		Local Vn:Float = a1 - a21
		
		Local v2fx:Float = (P + Vn * mass)/(mass + ball.mass)
		Local v1fx:Float = v2fx - Vn
		
		P = mass * b1 + ball.mass * b21
		
		Vn = b1 - b21
		
		Local v2fy:Float = (P + Vn * mass) / (mass + ball.mass)
		
		Local v1fy:Float = v2fy - Vn
		
		V.x = friction * ball.friction * a2 + bounce * ball.bounce * v1fx
		V.y = friction * ball.friction * b2 + bounce * ball.bounce * v1fy
		
		ball.V.x = friction * ball.friction * a22 + bounce * ball.bounce * v2fx
		ball.V.y = friction * ball.friction * b22 + bounce * ball.bounce * v2fy

		Init(V.x,V.y)
		
		ball.Init(ball.V.x,ball.V.y)
		
		dp = tv.x * dx + tv.y * dy
		
		a1= dp * dx
		b1= dp * dy
		
		dp = tv.x * dy - tv.y * dx
		
		a2 = dp * dy
		b2 = dp *-dx
		
		dp = ball.tv.x * dx + ball.tv.y * dy
		
		a21 = dp * dx
		b21 = dp * dy
		
		dp = ball.tv.x * dy - ball.tv.y * dx
		
		a22 = dp * dy
		
		b22 = dp * -dx
		P = mass * a1 + ball.mass * a21
		
		Vn = a1 - a21
		
		v2fx = (P + Vn * mass) / (mass + ball.mass)
		v1fx = v2fx - Vn
		
		P = mass * b1 + ball.mass * b21
		
		Vn = b1 - b21
		
		v2fy =(P + Vn * mass) / (mass + ball.mass)
		v1fy = v2fy - Vn
		
		tv.x = friction * ball.friction * a2 + bounce * ball.bounce * v1fx
		tv.y = friction * ball.friction * b2 + bounce * ball.bounce * v1fy
		
		ball.tv.x = friction * ball.friction * a22 + bounce * ball.bounce * v2fx
		ball.tv.y = friction * ball.friction * b22 + bounce * ball.bounce * v2fy
		
		vx1 -= ball.V.x+ ball.tv.x
		vy1 -= ball.V.y+ ball.tv.y
		
		
	End Method




	

	Method Bounce:Void(ball:Ball2D,dx:Float,dy:Float)
		BounceB2B(ball,dx,dy)
	End

	Method Advance:Void(distance:Float)
		Local vx:Float=V.x*distance
		Local vy:Float=V.y*distance
		If(vx=0.0 And vy=0.0)
			Return
		End
		
		V.Subtract(vx,vy)
		
		P.Add(vx,vy)
		
		tv.Add(vx,vy)
		
		L-=Sqrt(vx*vx+vy*vy)
	End
	
	Method MovingToward:Int(x:Float,y:Float)
		Return V.DotProduct(x-P.x,y - P.y)&gt;0
	End Method

	
	Method Update:Void()

		P.Add(V)

	End Method
	
	Method Render:Void()
		
		DrawCircle P.x,P.y,radius
	End Method
	
End Class

Class PVector2D
	Field x:Float
	Field y:Float
	
	Method New(x:Float,y:Float)
		Set(x,y)
	End Method
	
	Method New(v:PVector2D)
		Set(v)
	End Method
	
	Method Set:PVector2D(v:PVector2D)
		x = v.x
		y = v.y
		Return Self
	End Method

	Method Set:PVector2D(x:Float,y:Float)
		Self.x = x
		Self.y = y
		Return Self
	End Method
		
	Method Add:PVector2D(x:Float,y:Float)
		Self.x += x
		Self.y += y
		Return Self
	End Method
	
	Method Add:PVector2D(v:PVector2D)
		Self.x += v.x
		Self.y += v.y
		Return Self
	End Method
	
	Method Add:PVector2D(value:Float)
		Self.x += value
		Self.y += value
		Return Self
	End Method
	
	Method Subtract:PVector2D(x:Float,y:Float)
		Self.x -= x
		Self.y -= y
		Return Self
	End Method
	
	Method Subtract:PVector2D(v:PVector2D)
		Self.x -= v.x
		Self.y -= v.y
		Return Self
	End Method
	
	Method Subtract:PVector2D(value:Float)
		Self.x -= value
		Self.y -= value
		Return Self
	End Method
	
	Method Multiply:PVector2D(x:Float,y:Float)
		Self.x *= x
		Self.y *= y
		Return Self
	End Method
	
	Method Multiply:PVector2D(v:PVector2D)
		Self.x *= v.x
		Self.y *= v.y
		Return Self
	End Method
	
	Method Multiply:PVector2D(value:Float)
		Self.x *= value
		Self.y *= value
		Return Self
	End Method
	
	Method Divide:PVector2D(x:Float,y:Float)
		Self.x /= x
		Self.y /= y
		Return Self
	End Method
	
	Method Divide:PVector2D(v:PVector2D)
		Self.x /= v.x
		Self.y /= v.y
		Return Self
	End Method
	
	Method Divide:PVector2D(value:Float)
		Self.x /= value
		Self.y /= value
		Return Self
	End Method
	
	Method DotProduct:Float(x:Float,y:Float)
		Return Self.x * x + Self.y * y
	End Method
	
	Method DotProduct:Float(v:PVector2D)
		Return Self.x * v.x + Self.y * v.y
	End Method
	
	Method PerpDotProduct:Float(x:Float,y:Float)
		Return Self.x * y - Self.y * x
	End Method
	
	Method PerpDotProduct:Float(v:PVector2D)
		Return Self.x *v.y - Self.y * v.x
	End method
	
	Method MagnitudeSquare:Float()
		Return Self.x * Self.x + Self.y * Self.y
	End Method
	
	Method Magnitude:Float()
		Return Sqrt(MagnitudeSquare())
	End Method
	
	Method Normalize:PVector2D()
		Local len:Float = Magnitude()
		Divide(len,len)
		Return Self
	End Method
		
	Method GetAngle:Float()
		Return ATan2(y,x)
	End Method
	
	Method ToString:String()
		Return x+"  "+y
	End Method
	
	Method Draw:Void(x:Float,y:Float)
		DrawLine(x,y,x+Self.x,y+Self.y)
	End Method
	
End Class


</textarea><br><br>[updated] 11-29-2012<br><br>* added multiple ball to wall collision. (no ball to ball collision)<br><br><br>[updated] 12-21-2012<br><br>*ball 2 ball collision implemented <br><br></td></tr></table><br>
<a name="2045047"></a>

<a name="2045045"></a>

<a name="2044999"></a>

<a name="2044950"></a>

<a name="2043643"></a>

<a name="2043639"></a>

<a name="2043516"></a>

<a name="2043416"></a>

<a name="2043406"></a>

<a name="2043403"></a>

<a name="2043402"></a>

<a name="2043401"></a>

<a name="2043411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very nice. <br><br></td></tr></table><br>
<a name="2043450"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ordigdug</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Really nice.  Please add additional collision elements. Please include more documentation/comments for a newbie like me to understand. <br><br></td></tr></table><br>
<a name="2043517"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks guys.<br><br>I just updated source!<br><br>fixed a couple of bugs and added ball to circle wall collision.<br><br>also I am starting to document it. <br><br></td></tr></table><br>
<a name="2043529"></a>

<a name="2043530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >benmc</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> It works pretty well.<br><br>I gave it a try, and added a square shape to the middle of the poly you had created, and the ball did a lot of strange things with lines at right angles, and when it hit the "tips" of the lines.  The ball also managed to find its way inside the box at one point.<br><br>Here's my box if it saves some time for testing:<br><br>engine.AddWall(New LineWall(250,100,350,100))<br>engine.AddWall(New LineWall(350,100,350,200))<br>engine.AddWall(New LineWall(250,200,350,200))<br>engine.AddWall(New LineWall(250,100,250,200)) <br><br></td></tr></table><br>
<a name="2043536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for testing it Ben.<br><br>did you try it with the latest update? <br><br>I don't see any problems when I tried it right now and with gravity.<br><br>I did fix a bug that was causing it to lock and crash and it had to do with the end points. <br><br></td></tr></table><br>
<a name="2043533"></a>

<a name="2043539"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >benmc</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Jesse seems pretty good.  I tried the same thing as the day before and watched it for a minute or two and didn't see the same thing happened, so maybe it's fixed up.<br><br>This is a great system, probably would have made my last 2 projects much easier :) <br><br></td></tr></table><br>
<a name="2043551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sammy</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very impressive, I am sure it can be used by me in the future. Thank you Jesse! <br><br></td></tr></table><br>
<a name="2043610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arthur</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great!<br>It is impossible to add multiple collidable balls right now? <br><br></td></tr></table><br>
<a name="2043624"></a>

<a name="2043625"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks Veggie and Arthur.<br><br>@Arthur<br><br>It can do multiple ball collision and response but fails with gravity. I have been trying to figure out the gravity factor but it still eludes me.  the problem is that it uses a fixed gravity value integrated to x and/or to y but when the movement is smaller than the gravity factor, l it brings the ball speed back up to the speed of gravity. thats in relationship to a ball at rest with ground or another object.<br>it also since it uses recursion. it goes into an endless loop and crashes. it works fine with out gravity.<br><br>so until I figure it out, I am not going to implement it. unless someone wants to work with me on figuring it out than I'll share the code.<br><br>I have read some articles but are too technical. I barely completed a year of trig in college not much calculus skills here. <br><br></td></tr></table><br>
<a name="2043623"></a>

<a name="2043622"></a>

<a name="2043621"></a>

<a name="2043620"></a>

<a name="2043619"></a>

<a name="2043640"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just added multiple ball to line collision. but no ball to ball collision yet. <br><br></td></tr></table><br>
<a name="2044719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sammy</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was just re-looking over this post, did you manage to get the ball to ball collision working Jesse? <br><br></td></tr></table><br>
<a name="2044814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> The ball to ball collision works just can't get it to play nicely with gravity. I'll try to implement it as soon as I have some free time. I will have to refactor the logic integration in the engine. I'll have it done hopefully by tomorrow. <br><br></td></tr></table><br>
<a name="2044822"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sammy</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK thanks Jesse, I'm looking forward to your update. <br><br></td></tr></table><br>
<a name="2044954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Veggie<br><br> sorry about not posting this earlier but I just forced myself to work on this as I didn't really have any time. So I am tiredly falling asleep as I am typing this but got it done.  <br><br>There might be some bugs as I didn't thoroughly test it before posting it. Any way, gravity and collision works good(I think). but If friction is added then there will be problems unless someone can figure it out, everyone is going to have to wait until I figure it out. <br><br>not too well documented but will add more documentation at a later time. I hope it's helpful to others.<br><br>I still need to add ball to arc collision but unless somebody really need it for their project, It will be a while before I add to it. <br><br></td></tr></table><br>
<a name="2044951"></a>

<a name="2044953"></a>

<a name="2044997"></a>

<a name="2044998"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sammy</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I really appreciate the effort you put into this Jesse. Its such a handy piece of code.<br><br>The code ran fine and was very impressive. The only fly in the ointment was I got this error a when I left it running for a little while:<br><br>Monkey Runtime Error : InternalError: too much recursion<br><br>Any ideas?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Monkey Runtime Error : InternalError: too much recursion

C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;763&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;279&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Users/Dad/Desktop/MonkeyPro66/tmp/temp.monkey&lt;368&gt;
C:/Use</textarea> <br><br></td></tr></table><br>
<a name="2045000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops!<br><br>its a bug that has to do with the collision with both the start point of one line and the end point of another when they are at the same location. when both points are in the same spot it's checking collision agains each other continually and causes the recursion bug.<br><br>for now just add a "False" parameter to the end of the "New LIneWall". That should take care of the recursion bug until I can figure out a real solution.  Do that to lines that have the end point  connected to the start point of another line. Sorry, I will look at it maybe monday. <br><br></td></tr></table><br>
<a name="2045022"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sammy</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK Jesse, again, thanks being so generous with your code. :) <br><br></td></tr></table><br>
<a name="2045049"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> NP! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
