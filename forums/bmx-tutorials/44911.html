<!DOCTYPE html><html lang="en" ><head ><title >Memory management tutorial</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Memory management tutorial</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=112" >BlitzMax Tutorials</a>/<a href="#bottom" >Memory management tutorial</a><br><br>
<a name="499689"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a brief tutorial directed mainly at BlitzPlus/Blitz3D users who are a bit confused by BlitzMax's memory management...<br><br><div class="quote"> <br>***** BlitzMax Memory Management - or, 'where the @*#! did Delete go?!?' *****<br><br>As many users from a Blitz3D or BlitzPlus background have noticed, BlitzMax does not include a 'Delete' command.<br><br>This appears to have caused a great deal of bemusement and head scratching in the Blitz community, which this tutorial will attempt to clear up.<br><br>Note that any references to Blitz3D in the rest of this document also apply to BlitzPlus.<br><br><br>The BASICS<br>----------<br><br>First up, let's have a look at what Blitz3D's Delete command actually does. It really serves 2 purposes:<br><br>1) The object is removed from its 'type list'.<br><br>2) The memory used by the object is returned to the system - this is called 'deallocating' the object.<br><br>Step 1 is necessary due to Blitz3D's type list system, which automatically adds all New-ed objects to their global linked list.<br><br>Step 2 is necessary to prevent memory leaks. A memory leak is when your program has allocated a chunk of memory, used it for something, and then forgotten to deallocate it when it is no longer useful. Since computers have a finite amount of memory, this will eventually cause problems if it happens often enough!<br><br>The first thing about these 2 steps to note is that the global type list system is no longer present in BlitzMax, so step 1 is now completely up to the user - if you have added an object to a linked list (or lists), it is up to you to remove it. <br><br>If all you are wanting to achieve is a system similar to Blitz3D's type list system, then this is as simple as using ListAddLast immediately after you have created an object using New, and using ListRemove immediately before deleting it using Delete - oops, there is no Delete! Ok, using ListRemove *instead* of Delete!<br><br>This still leaves the question of deallocating the object's memory, and this is done in BlitzMax using the FlushMem command. The basic idea behind FlushMem is that it automatically detects 'dead' objects - objects that are no longer in use by your program - and deallocates them for you.<br><br>FlushMem should be placed in your program's 'main loop', and perhaps at other 'hotspots' in your program where you have created a lot of objects - for example, after loading a game level.<br><br>Note that the issue of deallocating objects is completely separate from the issue of type lists. Yes, if you forget to remove an object from a list it will remain 'live', but this is the same as forgetting to delete an object in Blitz3D!<br><br>One final complicating issue: BlitzMax includes a feature that allows you to assign objects to integers. This feature exists mainly to simplify things for beginners so, instead of...<br><br>Local image:TImage=LoadImage( "somepic.png" ) 'normal object to object assignment...<br><br>...you can just go...<br><br>Local image=LoadImage( "somepic.png" )   'assigning an object to an int! What gives?<br><br>However, if you are using this feature in your programs, you *must* later 'free' the object yourself using Release...<br><br>Release image<br><br>You can therefore think of Release as being similar to Blitz3D's FreeImage (or FreeSound, FreeThis, FreeThat etc).<br><br>All-in-all, it's probably best to avoid object-to-int assignments altogther if you are concerned about memory leaks.<br><br>And that's it! Well, not quite, but the above should be enough information for you to be able to write leak-free programs with. I'll go into some of the nitty gritty details below...<br><br><br>***** The nitty gritty part 1 : dead objects *****<br><br>Ok, lets have a look at the question of 'what exactly is a dead object'? Well, a dead object is an object that is no longer referred to by any live objects. In other words, dead objects are objects your program can no longer 'see' - they are therefore completely useless to your program and can be safely deallocated.<br><br>Here are a few examples of when objects become 'dead':<br><br>'example 1<br>Local p:MyType=New MyType	'allocate object 1<br>p=Null				'object 1 is now dead<br><br>'example 2<br>Local p:MyType=New MyType	'allocate object 1<br>Local q:MyType=New MyType	'allocate object 2<br>p=q				'object 1 is now dead, object 2 is still alive<br><br>'example 3<br>Local p:MyType[1]		'allocate object 1 (an array object)<br>p[0]=New MyType			'allocate object 2<br>p=Null				'object 1 and object 2 both now dead<br><br>'example 4<br>Local p:MyType=New MyType	'allocate object 1<br>p.my_type=New MyType		'allocate object 2<br>p.my_type=New MyType		'allocate object 3 - object 2 now dead<br>Local q:MyType=p.my_type<br>p=Null				'object 1 and object 2 dead, object 3 still alive thanks to the q assignment above<br><br>After seeing this sort of thing, there is a tendancy for people to stick '=Null' code all over the place in an attempt to 'force' objects to become dead - but this is generally not necessary.<br><br>Sooner or later, all variables will either be overwritten by new values, or (in the case of Locals and Fields) simply go out of scope. Both of these actions are enough to ensure that dead objects will be correctly detected and deallocated.<br><br>Probably the only good reason to use '=Null' is in the case of global variables, when you know that a global variable will not be modified for a long time, but it also happens to be keeping a large chunk of memory alive that is no longer useful to your program. In this case, an '=Null' is probably the right choice.<br><br>Finally, there is one subtly with FlushMem you should be aware of: FlushMem only deallocates objects which have become dead since the function the FlushMem appears in was entered.<br><br>For this reason, it pays to put FlushMem as 'low' in your code as possible. For most applications, inside the 'main loop' is fine.<br><br><br>***** The nitty gritty part 2 : Tracking memory allocation *****<br><br>BlitzMax provides the MemAlloced() function to determine the amount of memory currently used by your program. However, this should be used with care.<br><br>The best place to use MemAlloced() is inside the 'meatiest' loop in your program. The important thing is that your program does not lose memory over time, and simply using MemAlloced() after executing a few instructions is not generally a good indicator of this. This is because some commands may perform 'first time initialization' allocations - indeed, the BlitzMax runtime occasionally has to reallocate memory itself, to adapt to the needs of your program.<br><br>Here is an example of the 'cleanest' way to use MemAlloced()<br><br>'MemAlloced() example:<br>Strict<br><br>Function Test()<br>	'code you want to test for mem stability here...<br>End Function<br><br>For Local k=1 To 10000<br>	Test<br>	FlushMem<br>	Print MemAlloced()<br>Next<br> <br></div> <br><br></td></tr></table><br>
<a name="499796"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >semar</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you Mark, that's really useful.<br><br>Sergio. <br><br></td></tr></table><br>
<a name="499898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> you should stick this in the wiki Mark :) <br><br></td></tr></table><br>
<a name="500006"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SillyPutty</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> yeah, this topic is extremely important and useful ! :) <br><br></td></tr></table><br>
<a name="500367"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does Flushmem use much CPU time? Let's say for example, there are several hundred variables to clear out?<br><br>Is it generally better to 'flushmem' every loop or wait a few cycles then do the flush?<br><br>When your program closes does Max clean up memory if you forget to take care of the memory management yourself?<br><br>Is it correct to say that Flushmem works locally? <br><br></td></tr></table><br>
<a name="500420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just do it every loop. FlushMem works locally in that it clears anything from the program section it's in, plus stuff called from that section, eg.<br><br><pre class=code>
Repeat

    Cls

    GetControls ()
    RenderGame ()

    FlushMem
    Flip

Until KeyHit (KEY_ESCAPE)
</pre><br><br>This would clear everything in (and before) that Repeat/Until loop, plus the stuff in the two functions. You'd only need to put FlushMem inside those functions if they do a large amount of object creation/nulling or particularly heavy loops. That's really just a matter of judgement/trial and error.<br><br>Max frees stuff at the end if you don't. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
