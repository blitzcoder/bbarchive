<!DOCTYPE html><html lang="en" ><head ><title >Basic OpenGL for the Newbie, Part 1</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Basic OpenGL for the Newbie, Part 1</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=112" >BlitzMax Tutorials</a>/<a href="#bottom" >Basic OpenGL for the Newbie, Part 1</a><br><br>
<a name="477695"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>OpenGL Games Programming with Blitzmax</b><br><br>These tutorials where originally written for C++ programming as part of the GamecodingUK website many years ago - They have now been rewritten to include basic support with the Blitzmax language. Hopefully newcomers to OpenGL can find a use for them<br><br>What is OpenGL ?, Well.. you could say its an interface that connects directly to your graphics card - In english this means... a set of commands that can be used together to produce 2D and 3D programs.<br>OpenGL can bring the Games Programmer alot of good things, but I think one of the most important aspects has to be that you can use that nice shiny 3d card that is sat in your computer to give you silky smooth animation and state-of-the-art graphics. <br><br><b>So you want to program in OpenGL?</b><br><br>Well it's not as hard as you might think, OpenGL is quite a friendly beast and can help out with a lot of the complicated maths routines you need to use when coding a 3D game or app. <br>Thanks to Blitzmax, all the once complicated process of setting up a C++ compiler to use OpenGL is gone !. No more realms of w32 code needed - (believe me you could write 20-30 lines of code just to setup a blank screen !) - Blitzmax has inbuilt commands that can handle all this for us, life couldn't be easier !!.<br><br>But why bother yourself with OpenGL programming, when you can use a readymade 3d engine ??<br><br>Lots of reasons really, but here's a few off the top of my head..<br><br>You can get an understanding of the processes involved.<br><br>As you gradually build up your knowledge, you can start to introduce cutting edge features that can be found in today's games. (such as normal mapping a'la Halflife 2 or Doom 3)<br><br>Tons of tutorials and info can be found for free on the net !.<br><br>Its Fun !!!<br><br>Sooo... lets get going with a quick look through some of the basic features OpenGL has to offer !. <br><br></td></tr></table><br>
<a name="477697"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Setting up an OpenGL window</b><br><br>Type (or paste) the following code into the editor<br><pre class=code>
bglCreateContext(800,600,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER|BGL_FULLSCREEN)
init()

While Not KeyDown(KEY_ESCAPE)
display()
bglSwapBuffers
Wend 
End

Function init()
glClearColor(0.0, 0.0, 0.0, 0.0)
glColor3f(0.0, 0.0, 1.0)
glMatrixMode(GL_PROJECTION)
glLoadIdentity()
gluPerspective(45.0, 800/600, 0.1, 100.0)
End Function

Function display()
glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
glBegin(GL_TRIANGLES)
	glVertex3f( 0.0, 1.0,-10.0)
	glVertex3f(-1.0,-1.0,-10.0)
	glVertex3f( 1.0,-1.0,-10.0)
glEnd()
End Function
</pre><br>Now compile and run it, hopefully you should see a small window containing a blue triangle. It may not do much at the moment but we have just made our first OpenGL program. You can close the window down by pressing the ESCAPE key. <br><br>Looking through the first few lines of code, you should be able to get a general idea of how we set everything up. <br><br>bglCreateContext(800,600,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER|BGL_FULLSCREEN)<br><br>This is the all important line, it resets our screen to a resolution of 800 by 600 pixels - with a colour depth of 32 bits. Notice the 3 flag statements I've used 'BGL_BACKBUFFER, BGL DEPTHBUFFER and lastly BGL_FULLSCREEN - I'm sure you can guess what the last one does !. The first 2 inform our graphics card that we want to use a double buffered screen for a smoother display, the Depthbuffer is also initialised - this is an area of memory that is set aside by our graphics card for working out the all important 'distance' maths calculations - dont worry too much about what these commands do at this stage.<br><br>Have a play with the resolutions and colour depth variable to see the difference a higher res makes to the image displayed. <br>BUT you will also have to change this line of code...<br><br>gluPerspective(45.0, 800/600, 0.1, 100.0)<br><br>This line sets up the 3d display on the screen, making sure that program uses the correct perspective. Notice how it currently passes a value of  1.333 ( 800 / 600 ), This is the offset distance ratio between the with and height. Make sure you change this to be equal to the width and height of your required screen resolution. It is possible to distort the screen by playing with this value.. widescreen, fish eyes.. whatever !. <br><br></td></tr></table><br>
<a name="477698"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>The Display</b><br><br>Lets go back through the previous listing and take a look at the display commands: <br><br>bglCreateContext(800,600,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER|BGL_FULLSCREEN)<br><br>We already know that this is the all important screen setting command. <br><br>glClearColor(0.0, 0.0, 0.0, 0.0)<br><br>This sets the background colour to black ( RGB 0, 0, 0), values can range from 0.0 to 1.0. '0' being black and '1' being the brightest (white). As you've no doubt guessed, the values go in the format of RGB (red, green &amp; blue) - playing around with the values will change the colour. The fourth 0.0 value is an alpha transparency colour which will not be used just yet. <br><br>glColor3f(0.0, 0.0, 1.0);<br><br>This sets the foreground colour, in this case the triangle to blue. You can use this command anywhere you want in the program, usually its before a side of an object (which means that each side or object would have a different colour, as we shall see later on). <br><br>glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)<br>This line clears the buffers that we previously setup, we use this before we put any fresh data on the screen.<br>Think of it as flushing the page clean before we use it again !.<br><br>bglSwapBuffers<br><br>Lastly, this line swaps the display on our screen to that of our off-screen buffer. <br>(By using double buffers, we can draw on a hidden screen - while the previous screen is still showing. This cuts down on flickering, and can smooth out the overall program framerate.) <br><br>As you can see using Blitzmax with OpenGL, the whole process is quite painless. <br>Incase your wondering... if we where to have programmed the same little proggie in proper C++ with directx, it would be around 50 lines long ! <br><br></td></tr></table><br>
<a name="477700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>The Screen Objects</b><br><br>Ok, there is still alot of the commands in the above program that I have yet to explain - but I think for now we will take a look at just what OpenGL is capable of. We will have to get back to the boring stuff later! <br><br>In the example I used (hopefully) you saw a triangle, these are the all important lines that defined the shape: <br><br>glBegin(GL_TRIANGLES);<br>        glVertex3f( 0.0, 1.0, -10.0);<br>        glVertex3f(-1.0,-1.0, -10.0);<br>        glVertex3f( 1.0,-1.0, -10.0);<br>glEnd();<br><br>The glBegin(); command informs OpenGL that we are about to define a shape, similarly the glEnd(); command will close the shape. Every shape or object that we want to use must be defined within the 2 commands. You can have as many shapes as you wish, the only obstacles being speed and memory. <br><br>As you can see inside the glBegin command is the GL_TRIANGLES label - as you can guess, this is because I wanted to use a 3 sided shape. <br><br>Of course there are many different labels to use depending on the amount of points the object will have: <br><br>GL_POINTS <br>individual points <br>GL_LINES <br>pairs of vertices interpreted as individual line segments <br>GL_POLYGON <br>simple convex polygon <br>GL_TRIANGLES <br>triples of vertices interpreted as triangles <br>GL_QUADS <br>four sided polygons <br>GL_LINE_STRIP <br>series of connected line segments <br>GL_LINE_LOOP <br>same as above but connects last line to first<br> <br>Following the glBegin is the 3 vertex co-ordinates that define the shape in 3d space, The '3' in the glVertex3f means that the shape will have 3 sets of co-ordinates (X,Y &amp; Z). It is possible to use glVertex2f but that means we are restricted to 2 plane movement (X and Y - Left &amp; Right, Up &amp; Down), But of course its 3d that interests us. <br><br>As I've previously mentioned the coordinates for the command must be in the format of X, Y &amp; Z. Whatever values you use, please remember that they are not pixel distances but units that GL uses. (So a 10 in the X axis, is not that same as 10 pixels across.) <br><br>In case you're wondering, here's the axis in relation to the co-ords: <br><br>As you can see any X co-ords that are to the left of 0 would be negative.. Any Y co-ords below 0 are also negative.. <br><br>Any co-ords that go into the screen on the Z axis are negative.. <br><br>Lets have a bit of fun, find the start of the triangle code (glBegin) and add the 3 lines of colour command code to it: (the glColor lines) <br><pre class=code>
glBegin(GL_TRIANGLES)
glColor3f(0.0,1.0,0.0)'          // Add me
glVertex3f( 0.0, 1.0, -10.0)
glColor3f(0.0, 0.0, 1.0)'        // Add me
glVertex3f(-1.0,-1.0, -10.0)
glColor3f(1.0, 0.0, 0.0)'        // Add me
glVertex3f( 1.0,-1.0, -10.0)
glEnd();
</pre><br>Upon running the program you should see a multicoloured triangle, As I've previously mentioned the glColor3f command can be inserted anywhere. What is happening here is that we are informing GL that every point of the shape is to be a different colour, GL then tries to smooth the changes for us - making a very pretty job of it. <br><br>Let's try the same thing but this time with a square, just exchange the entire code in the glBegin section of code to: <br><pre class=code>
glBegin(GL_QUADS);
glColor3f(1.0, 1.0, 0.0)
glVertex3f( 1.0, 1.0, -10.0)
glColor3f(0.0, 1.0, 1.0)
glVertex3f(-1.0, 1.0, -10.0)
glColor3f(1.0, 0.0, 1.0)
glVertex3f(-1.0,-1.0, -10.0)
glColor3f(0.0, 0.5, 1.0)
glVertex3f( 1.0,-1.0, -10.0)
glEnd()
</pre><br>As you can see all the Z co-ordinates are set to -10.0, this is so that we have a depth of 10 units into the screen, If we set these as '0' then we would not be able to see the shape as it would be closer to us then the depth of the window can take. (in other words anything positive past '-1' will not be shown) <br><br>Now that most of the boring foundation work is out of the way lets get stuck in and start to piece together a decent project. I have chosen to write a simple Tank Demo, the user will be able to crash about with a toy tank in a 3rd perspective mode. (you will see the tank on the screen infront of you) <br><br>Of course we are along way off from the finished demo and we have much to learn including movement and control. Unfortunately for now its back to the cubes, but believe me, better things are on the horizon. <br><br>Let's start off by looking at movement: <br><br></td></tr></table><br>
<a name="477701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Rotation</b><br><br>In the last tutorial we used the example of a simple square displayed in 2d, this time I want to extend what we have learnt to include a solid 3d cube. <br><br>Enter the following code: <br><pre class=code>
Global width:Int=800
Global height:Int=600
Global angle:Float=0

bglCreateContext(width,height,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER|BGL_FULLSCREEN)
init()

While Not KeyDown(KEY_ESCAPE)
display()
idle_function()
bglSwapBuffers
Wend 
End

Function init()
glClearColor(0.0, 0.0, 0.0, 0.0)
glClearDepth(1.0)
glEnable(GL_CULL_FACE)
glMatrixMode(GL_PROJECTION)
glLoadIdentity()
gluPerspective(45.0, Float(width)/Float(height), 0.1, 100.0)
glMatrixMode(GL_MODELVIEW)
glLoadIdentity()
End Function

Function display()
glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
glLoadIdentity()
glTranslatef(0.0, 0.0, -5.0)
glRotatef(angle, 1.0, 0.0, 0.0)
glBegin(GL_QUADS)
glColor3f(1.0, 1.0, 0.0)
glVertex3f( -1.0, 1.0, -1.0)
glVertex3f(1.0, 1.0, -1.0)
glVertex3f(1.0, -1.0, -1.0)
glVertex3f(-1.0, -1.0, -1.0)
glEnd()
End Function

Function idle_function()
angle:+0.05
If angle&gt;360.0 angle=0.0
End Function
</pre><br>Dont be alarmed just yet !!, its a one sided cube :)<br><br>With most 3d programming you would need to develop routines that hide the sides of the shape that cant be seen, (Hidden Line Removal) - but the ever friendly OpenGL will do all this for us. All we have to do is inform OGL that we wish it to take control of the task, we do this by using the glEnable(GL_CULL_FACE); command. This sets up a simple test that OGL performs on each side of the shape, namely - it looks for sides that are facing away from the screen (backfaces) and does not allow them to be displayed. <br><br><br>So how does it do that?<br>Well, it uses a special calculation based on the co-ordinates - I wont go into it here as its not needed, but if you are planning on advanced 3d programming - you will have to lookup something called 'Dot Product'. <br><br>Luckily we can stay well away from all the nasties, BUT there is a golden rule that MUST be obeyed: <br><br>All your points (co-ordinates) for a shape/side/object must run in an anti-clockwise order. If you follow the example shape you will see the first point of the square is top-left then bottom-left, followed by bottom-right and lastly top-right. We will look into other methods of hidden face removal, but this is the fastest method currently available. It will not crash the program if you make a mistake but may make the face of the shape appear the opposite way round. (That is it will only show when facing away from you.) <br><br>Did you have any problems with the example? <br><br>If it ran too fast for you, change the angle value (0.05) to a lower amount. <br><br>If it ran too slow then try lowering the value.<br><br>If you set it as Fullscreen but it looked distorted, that's because the values in the gluPerspective command need to match that of the screen resolution. <br><br>One thing to remember when designing shapes is to take into consideration the point of origin. In other words - the point 0,0,0 should be slap-bang inside the middle of the object/shape. This is so that when we want to rotate the shape we want it to pivot evenly. At the moment the example is spinning the square around the pivot point as we have yet to define the other sides. <br><br>Let's take a look at some of the other parts of the code that have been added: <br><br>Global width:Int=800<br>Global height:Int=600<br>Global angle:Float=0<br><br>Makes changes easier, using variables rather than hard coding the values. So from now on the width and screen height will be set from here. <br>The ANGLE variable is used to hold the angle of the shape.<br><br>glMatrixMode(GL_PROJECTION)<br>glLoadIdentity()<br>gluPerspective(45.0, Float(width)/Float(height), 0.1, 100.0)<br>glMatrixMode(GL_MODELVIEW)<br>glLoadIdentity()<br><br>The dreaded MatrixMode commands, how I hate this section of code. I cant go into too much detail as I haven't really understood everything about it myself. Basically we have 2 modes to play around with, a world mode (GL_PROJECTION) and the object mode (GL_MODELVIEW).  We are suppose to use the world mode to move around like a sort of camera, BUT it can really cause some very serious errors in our little program if it is not done right. Alot of OGL users prefer to use the object mode and move the objects around the camera, as it really makes life alot easier for the programmer and less prone to mistakes. It seems that this little trick is very widely used - so if its good enough for them, its good enough for us. <br><br>Let's just say the section of code works and leave it as that for now! <br><br>Function idle_function()<br>angle:+0.05<br>If angle&gt;360.0 angle=0.0<br>End Function<br><br>The idle function is another new procedure that we have not needed before, the opengl window is updated with the refresh rate of the screen when it can keep up. Every refresh this procedure will be called into play. We can use it to control the general housekeeping of the game, in this case all it does is to add 0.05 degrees to the variable angle. If it goes over 360 then reset it as 0. If the program ran too fast or slow try changing the value slightly. <br><br>glLoadIdentity();<br>glTranslatef(0.0, 0.0, -5.0);<br>glRotatef(angle, 0.0, 1.0, 0.0);<br><br>The glLoadIdentity() command resets the internal values and angles from the last time the display was updated, glTranslatef(0.0, 0.0, -5.0) moves the camera away from the object alittle giving us a view of the spinning square. I shall go more into detail about it at a later time. <br><br>Finally the glRotatef(angle, 0.0, 1.0, 0.0) command, its taken along time for us to get to it, but at last I can explain how to rotate the shape. <br><br>The first perimeter that opengl expects in this command is the amount of degrees that you want the shape to rotate. In this case I have set the variable 'angle' to hold the info, as you have seen it is slowly increased until it hits 360 (a full circle). The remaining 3 perimeters set which plane of rotation you want to move, its only a case of putting a 1.0 value in the required position. <br><br>To move in the X plane - ( Horizontal ) - use glRotatef(angle,1.0 ,0.0, 0.0); <br><br>For the Y plane - ( Vertical ) - use glRotatef(angle, 0.0, 1.0, 0.0); <br><br>For the Z plane - ( Inwards/depth) - use glRotatef(angle, 0.0, 0.0, 1.0); <br><br>Of course you can set any combination, maybe even using all 3 planes of movement. To set different amounts you would just use 3 different glRotatef commands. Easy isn't it! <br><br>Let's put the remaining sides on the cube and add a different colour to each, then we will get it to rotate by different amounts in all 3 planes. <br><br>NOTE: Remember that we are designing the shape so that the sides are on the outside, think of how the cube will look. The back face (which is facing away from you) - will need to be designed so that the vertex's are in a clockwise order. (instead of anticlockwise like the front facing surface)<br><pre class=code>
Global width:Int=800
Global height:Int=600
Global anglex:Float=0
Global angley:Float=0
Global anglez:Float=0

bglCreateContext(width,height,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER|BGL_FULLSCREEN)
init()

While Not KeyDown(KEY_ESCAPE)
	display()
	idle_function()
	bglSwapBuffers
Wend
End

Function init()
glClearColor(0.0, 0.0, 0.0, 0.0)
glClearDepth(1.0)
glEnable(GL_CULL_FACE)
glMatrixMode(GL_PROJECTION)
glLoadIdentity()
gluPerspective(45.0, Float(width)/Float(height), 0.1, 100.0)
glMatrixMode(GL_MODELVIEW)
glLoadIdentity()
End Function

Function display()
glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
glLoadIdentity()

glTranslatef(0,0,-5.0)
glRotatef(anglex,1.0,0.0,0.0)
glRotatef(angley,0.0,1.0,0.0)
glRotatef(anglez,0.0,0.0,1.0)

glBegin(GL_QUADS)

glColor3f(1.0,1.0,0.0) '// Front Face
glVertex3f(-1.0, -1.0, 1.0)
glVertex3f( 1.0, -1.0, 1.0)
glVertex3f( 1.0, 1.0, 1.0)
glVertex3f(-1.0, 1.0, 1.0)

glColor3f(1.0,0.0,0.4) ' // Back Face
glVertex3f(-1.0, -1.0, -1.0)
glVertex3f(-1.0, 1.0, -1.0)
glVertex3f( 1.0, 1.0, -1.0)
glVertex3f( 1.0, -1.0, -1.0)

glColor3f(1.0,0.2,1.0); '// Top Face
glVertex3f(-1.0, 1.0, -1.0)
glVertex3f(-1.0, 1.0, 1.0)
glVertex3f( 1.0, 1.0, 1.0)
glVertex3f( 1.0, 1.0, -1.0)
glColor3f(0.0,1.0,1.0) '// Bottom Face
glVertex3f(-1.0, -1.0, -1.0)
glVertex3f( 1.0, -1.0, -1.0)
glVertex3f( 1.0, -1.0, 1.0)
glVertex3f(-1.0, -1.0, 1.0)

glColor3f(1.0,0.5,1.0) '// Right face
glVertex3f( 1.0, -1.0, -1.0)
glVertex3f( 1.0, 1.0, -1.0)
glVertex3f( 1.0, 1.0, 1.0)
glVertex3f( 1.0, -1.0, 1.0)

glColor3f(0.5,1.0,1.0); '// Left Face
glVertex3f(-1.0, -1.0, -1.0)
glVertex3f(-1.0, -1.0, 1.0)
glVertex3f(-1.0, 1.0, 1.0)
glVertex3f(-1.0, 1.0, -1.0)
glEnd()
End Function

Function idle_function()
anglex:+0.01; If (anglex&gt;360) anglex=0.0;
angley:+0.02; If (angley&gt;360) angley=0.0;
anglez:+0.03; If (anglez&gt;360) anglez=0.0;
End Function
</pre> <br><br></td></tr></table><br>
<a name="477703"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Translation</b><br><br>So now we know how to rotate a shape how about next we try and move it around the screen. <br><br>Remember the translate command we used in the above example, let's take a look again: <br><br>glClear(GL_COLOR_BUFFER_BIT);<br>glLoadIdentity();<br><br>glTranslatef(0,0,-5.0);<br><br>glRotatef(anglex,1.0,0.0,0.0);<br>glRotatef(angley,0.0,1.0,0.0);<br><br>It's even easier to use then the rotate command, just enter the values you want the screen or shape to move. In this case it is moving the shape away from the screen by adding -5.0 units to its position. Later on in the series we will study camera techniques, but for now let's stick with moving the shape around the camera. <br><br>The parameters are in the same order as the rotate command, that is: X, Y &amp; Z <br><br>Remember that adding a negative number will move it further into the screen - if the shape moves more then 1 unit (positive), the face-culling with automatically cut in and the shape face will disappear. <br><br>Try adjusting the values to move the shape around. <br><br>If you would like to code a quick example then follow the below mini tutorial to produce a pulsating cube based on the code from the previous example. <br><br>Include the following 2 variables somewhere in the top of your program: <br><br>global moveabout:float=-5.0<br>global direction:float=0<br><br>In the IDLE function add the following:<br><br>if (direction==0) moveabout=moveabout-0.01;<br>if (moveabout&lt;=-9.0) direction=1;<br>if (direction==1) moveabout=moveabout+0.01;<br>if (moveabout&gt;=-4.0) direction=0;<br><br>Lastly find the TRANSLATE command in the DISPLAY function, and change it to: <br><br>glTranslatef(0,0,moveabout);<br><br>Voila !, a spinning, moving cube... <br><br>If the cube moves to quickly or slowly change the variables in the IDLE function. (0.01) <br><br>I think its time we put everything we have learnt into practice, how about we start to design a toy tank object. This will be made up of 3 parts: the main body, the turret and lastly the gun barrel - of course it will only be a basic shape, but in time we will learn to get the camera to follow it around and finally texture it. <br><br>I will slowly build up the model one stage at a time so that you can see the process take shape. <br><br>Let's start with the body: <br><br>You can insert the code below into the listing from the previous example, just remember to change the lines that I suggest or things may look a little weird. <br><br>Find: glTranslatef(0,0,-5.0);<br>Change it to: glTranslatef(0,0,-15.0); <br><br>We need to move the object further into the screen, away from the window - as the shape will be pretty big. <br><br>Find: glRotatef(anglez,0.0,0.0,1.0);<br>Change it to: 'glRotatef(anglez,0.0,0.0,1.0); <br><br>We won't need the rotation around the Z axis for now as this will cause the shape to spin too much in odd directions. (you could delete the entire line out if you want)<br><br>Now find the cube object that we defined (between the glBegin and glEnd) - delete all the necessary lines of code. insert the following instead of it: <br><pre class=code>
' ** Tank Body

glBegin(GL_QUADS);

glColor3(0.3,0.8,0.2);        ' Back Face
glVertex3f(4.0, 1.0, -2.0)
glVertex3f(3.0, -1.0, -2.0)
glVertex3f(-3.0, -1.0, -2.0)
glVertex3f(-4.0, 1.0, -2.0)

glColor3f(0.3,0.8,0.2);        ' Front Face
glVertex3f(-4.0, 1.0, 2.0)
glVertex3f(-3.0, -1.0, 2.0)
glVertex3f(3.0, -1.0, 2.0)
glVertex3f(4.0, 1.0, 2.0)

glColor3f(0.3, 0.9,0.3);       ' Left Face
glVertex3f(-4.0, 1.0, -2.0)
glVertex3f(-3.0, -1.0, -2.0)
glVertex3f(-3.0, -1.0, 2.0)
glVertex3f(-4.0, 1.0, 2.0)

glColor3f(0.3, 0.9,0.3);       ' Right Face
glVertex3f(4.0, 1.0, 2.0)
glVertex3f(3.0, -1.0, 2.0)
glVertex3f(3.0, -1.0, -2.0)
glVertex3f(4.0, 1.0, -2.0)

glColor3f(0.3, 1.0,0.2);       ' Top Face
glVertex3f(-4.0, 1.0, -2.0)
glVertex3f(-4.0, 1.0, 2.0)
glVertex3f(4.0, 1.0, 2.0)
glVertex3f(4.0, 1.0, -2.0)

glColor3f(0.3, 1.0,0.2);       ' Bottom Face
glVertex3f(-3.0, -1.0, 2.0)
glVertex3f(-3.0, -1.0, -2.0)
glVertex3f(3.0, -1.0, -2.0)
glVertex3f(3.0, -1.0, 2.0)

glEnd()
</pre><br>Done that? Hopefully you saw the bottom section of the tank happily rotating about. If not the re-check your code for errors..<br><br>Time to define the next section, the turret. <br><br>This will be a separate object from the first part, so instead of editing the existing code we will just be ADDING it. After the end of the first shape (glEnd) - insert the following new code: <br><pre class=code>
' Turret Section

glBegin(GL_QUADS);

glColor3f(0.3,0.8,0.2);         ' Back Face
glVertex3f(-4.0, 1.0, -2.0);
glVertex3f(-2.5, 2.0, -1.5);
glVertex3f(0.5, 2.0, -1.5);
glVertex3f(2.5, 1.0, -2.0);

glColor3f(0.3,0.8,0.2);         ' Front Face
glVertex3f(2.5, 1.0, 2.0);
glVertex3f(0.5, 2.0, 1.5);
glVertex3f(-2.5, 2.0, 1.5);
glVertex3f(-4.0, 1.0, 2.0);

glColor3f(0.3, 0.9,0.3);         ' Left Face
glVertex3f(-4.0, 1.0, 2.0);
glVertex3f(-2.5, 2.0, 1.5);
glVertex3f(-2.5, 2.0, -1.5);
glVertex3f(-4.0, 1.0, -2.0);

glColor3f(0.3, 0.9,0.3);         ' right Face
glVertex3f(0.5, 2.0, 1.5);
glVertex3f(2.5, 1.0, 2.0);
glVertex3f(2.5, 1.0, -2.0);
glVertex3f(0.5, 2.0, -1.5);

glColor3f(0.3, 1.0,0.1);         ' top Face
glVertex3f(0.5, 2.0, -1.5);
glVertex3f(-2.5, 2.0, -1.5);
glVertex3f(-2.5, 2.0, 1.5);
glVertex3f(0.5, 2.0, 1.5);
glEnd();
</pre><br>Now for the last section, the gun itself. As before it will be a separate object so the code below will need to be added after the previous code. <br><pre class=code>
' Gun

glBegin(GL_QUADS);

glColor3f(0.3,0.8,0.2);         ' Back Face
glVertex3f(0.0, 1.2, -0.5)
glVertex3f(0.0, 1.7, -0.5)
glVertex3f(4.0, 1.7, -0.5)
glVertex3f(4.5, 1.2, -0.5)

glColor3f(0.3,0.8,0.2);         ' Front Face
glVertex3f(4.5, 1.2, 0.5)
glVertex3f(4.0, 1.7, 0.5)
glVertex3f(0.0, 1.7, 0.5)
glVertex3f(0.0, 1.2, 0.5)

glColor3f(0.3,0.7,0.3);         ' Top Face
glVertex3f(4.0, 1.7, 0.5)
glVertex3f(4.0, 1.7, -0.5)
glVertex3f(0.0, 1.7, -0.5)
glVertex3f(0.0, 1.7, 0.5)

glColor3f(0.3,0.7,0.2);         ' Bottom Face
glVertex3f(0.0, 1.2, 0.5)
glVertex3f(0.0, 1.2, -0.5)
glVertex3f(4.5, 1.2, -0.5)
glVertex3f(4.5, 1.2, 0.5)

glEnd();
</pre><br>We now have a complete tank !. But as you can see we have a small problem, the sides are being drawn correctly but they are not being drawn in any order. Parts of the tank is being drawn over sections that should be displayed last. The way to combat this is to use a procedure known as Depth Testing, but that's another story for another tutorial.... <br><br></td></tr></table><br>
<a name="477704"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Depth Sorting</b><br><br>So the tank looked kind of strange didn't it? Never mind, let's sort it out... <br><br>OpenGL has the facilities to use Depth Sorting, something that has been unheard of on home PC computers until the arrival of fast processors with plenty of ram on graphic card. Think of it as a large grid that all the objects are placed on, the computer with then look at each horizontal line going through the whole table bit by bit. finally displaying all the objects it found starting from the back to the front. Once again its not hard to do, but can really take its toll on low processor computers. <br><br>Back to Depth Sorting. Hopefully it won't slow up things too much. ;)<br><br>Go through the INIT function until you find the lines: <br><br>glClearDepth(1.0)<br>glEnable(GL_CULL_FACE)<br><br>Insert the following 2 lines of code below the above instructions: <br><br>glEnable(GL_DEPTH_TEST)<br>glDepthFunc(GL_LEQUAL)<br><br>All these 2 lines of code do is to enable the depth test and set what sort of algorithm we should use. <br><br>Now find the DISPLAY function and change the 'glClear(GL_COLOR_BUFFER_BIT)' instruction to: <br><br>glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)<br><br>As you can tell this clears the depth buffer as well as the normal display buffer. <br><br>That's it! Try running the demo again - now you should see the tank in all its glory, spinning around its X and Y axis perfectly without any problems with the 3 separate shapes combined. <br><br></td></tr></table><br>
<a name="477709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Linked Lists</b><br><br>Wouldn't it be nice to control each section of the tank as though they were separate sections and be able to have better control over the camera positioning?. Well, seeing as we have defined 3 objects that make up the tank - lets do just that. <br><br>Instead of going through the whole code listing line by line, I will only be explaining the new or changed lines of code - Most of this tutorial will deal with general coding rather than any OpenGL commands so feel free to change my code if you think you can program any faster routines.  <br><br>Firstly we define a structure called 'CAM' - that will hold all the data to control the camera. <br><br>ROTX = Rotation angle for the X plane<br>ROTY = Rotation angle for the Y plane<br>ROTZ = Rotation angle for the Z plane <br><br>TRANX = Hold the Translation value for the X movement<br>TRANY = Hold the Translation value for the Y movement<br>TRANZ = Hold the Translation value for the Z movement <br><pre class=code>
Type camera_data
    Field rotx:Float
    Field roty:Float
    Field rotz:Float
    Field tranx:Float
    Field trany:Float
    Field tranz:Float
End Type

Global cam:camera_data=New camera_data
</pre><br>Another structure this time called 'OBJECT', This time pointing to an array with enough space defined to hold the data for 5 shapes. <br><br>Notice that I've included some extra variables for scaling and offsetting the position of a shape. (We will use these in later tuts.) <br><pre class=code>
Type object_data
  Field rotx:Float
  Field roty:Float
  Field rotz:Float
  Field tranx:Float
  Field trany:Float
  Field tranz:Float
  Field scalex:Float
  Field scaley:Float
  Field scalez:Float
  Field offsetx:Float
  Field offsety:Float
  Field offsetz:Float
End Type

Global obj:object_data[5]; For loop = 0 To 4
obj[loop] = New object_data; Next
</pre><br>Now that we have a structure for the camera, lets set up the camera to point to a good view of the object. <br><br>cam.tranz=-12<br>cam.rotx=20<br>cam.trany=-1<br><br>Over in the IDLE FUNCTION, I've added two lines of code: <br><br>These will increase the Y ROTATION values of both object 0 &amp; 1, in other words the body and the turret. Seeing as we shall not be moving the gun itself separately from the other 2 parts of the shape, we do not need to change any of the rotation values for it. (Because it will take them from object 1 - the turret). <br><br>obj[0].roty+=0.01;<br>if obj[0].roty&gt;360 obj[0].roty:-360.0;<br>obj[1].roty+=0.03;<br>if obj[1].roty&gt;360 obj[1].roty:-360.0;<br><br>Now we come to the DISPLAY function, firstly I've added the code that will update our position within the world based on the cameras co-ordinates. This will move and rotate the entire world including ALL shapes and objects. <br><br>glTranslatef(cam.tranx,cam.trany,cam.tranz);<br>glRotatef(cam.rotx,1.0f,0.0f,0.0f);<br>glRotatef(cam.roty,0.0f,1.0f,0.0f);<br>glRotatef(cam.rotz,0.0f,0.0f,1.0f);<br><br>We now encase shape 0 (the body) in the two commands glPushMatrix() and glPopMatrix(). <br><br>glPushMatrix() - this will save the current settings that were made when we moved/rotated the camera around the world to the new position. We do this so that we can then move certain shapes around without effecting the position of shapes drawn after it. <br><br>glPopMatrix() - restores the values we saved using the glPushMatrix command, overwriting any current values. if we didn't enclose it with these instructions all shapes that will be displayed will be rotated or translated by the previous shape. (Think of it as a knock-on effect) <br><br>Notice that I've only done it for the body section and not all 3 parts of the tank, this is because I don't want the gun to move independently to the turret. Maybe later on I will want to do this - but not for now. As the turret and the gun are the last 2 sections we are going to draw there is no need to store the world co-ordinates. (if there were more shapes to the world then YES, we would have to save the world co-ords with the Matrix commands) <br><br>After the glPushMatrix() instruction comes the commands that move and rotate the shape to its new position relative to the world. As you can see I'm adding an offset value to the translation, this is because later I may not wish to define a shape around the middle (the pivot). Using the offset I would be able to position the shape anywhere I wanted. (for example: The gun - later I could redesign it so that the pivot point is at the end rather than the middle and move it into place on the turret section using the offset values. ) <br><br>// Body Section<br><br>glPushMatrix();<br>glTranslatef(obj[0].tranx+obj[0].offsetx, obj[0].trany+obj[0].offsety, obj[0].tranz+obj[0].offsetz)<br>             <br>glRotatef(obj[0].rotx, 1.0, 0, 0)<br>glRotatef(obj[0].roty, 0, 1.0, 0)<br>glRotatef(obj[0].rotz, 0, 0, 1.0)<br><br>glBegin(GL_QUADS);<br>glColor3f(0.3f,0.8f,0.2f); // Back Face<br>glVertex3f(4.0f, 1.0f, -2.0f);<br>......<br>glVertex3f(3.0f, -1.0f, 2.0f);<br><br>glEnd();<br>glPopMatrix();<br><br>// Turret Section<br><br>glPushMatrix()<br>glTranslatef(obj[1].tranx+obj[1].offsetx, obj[1].trany+obj[1].offsety, obj[1].tranz+obj[1].offsetz)<br>             <br>glRotatef(obj[1].rotx, 1.0, 0, 0)<br>glRotatef(obj[1].roty, 0, 1.0, 0)<br>glRotatef(obj[1].rotz, 0, 0, 1.0)<br><br>glColor3f(0.3,0.8,0.2); ' Back Face<br>......<br><br>Hopefully you have also noticed that the turret section is using the translate co-ordinates from shape 0 (the body) - this is because we want the the turret and gun to move with the body, so it's easier just to use the same co-ords.<br><br>You should by now be getting the general gist of it, just the gun section to go... this I leave up to you to complete ! ;)<br><br>So by now you should see a multi-jointed tank, rotating around the screen - Here's the complete listing incase you've had problems:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global width:Int=800
Global height:Int=600

Type object_data
  Field rotx:Float
  Field roty:Float
  Field rotz:Float
  Field tranx:Float
  Field trany:Float
  Field tranz:Float
  Field scalex:Float
  Field scaley:Float
  Field scalez:Float
  Field offsetx:Float
  Field offsety:Float
  Field offsetz:Float
  End Type
  
  Type camera_data
    Field rotx:Float
    Field roty:Float
    Field rotz:Float
    Field tranx:Float
    Field trany:Float
    Field tranz:Float
End Type

Global cam:camera_data=New camera_data
Global obj:object_data[5]; For loop = 0 To 4; obj[loop] = New object_data; Next

cam.tranz=-12; cam.rotx=20; cam.trany=-1
bglCreateContext(width,height,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER|BGL_FULLSCREEN)
init()

While Not KeyDown(KEY_ESCAPE)
	display()
	idle_function()
	bglSwapBuffers
Wend
End

Function init()
glClearColor(0.0, 0.0, 0.0, 0.0)
glClearDepth(1.0)
glEnable(GL_CULL_FACE)
glEnable(GL_DEPTH_TEST) 
glDepthFunc(GL_LEQUAL) 
glMatrixMode(GL_PROJECTION)
glLoadIdentity()
gluPerspective(45.0, Float(width)/Float(height), 0.1, 100.0)
glMatrixMode(GL_MODELVIEW)
glLoadIdentity()
End Function

Function display()
glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
glLoadIdentity()

glTranslatef(cam.tranx, cam.trany, cam.tranz)
glRotatef(cam.rotx,1.0,0.0,0.0)
glRotatef(cam.roty,0.0,1.0,0.0)
glRotatef(cam.rotz,0.0,0.0,1.0)

' Body

glPushMatrix()
glTranslatef(obj[0].tranx+obj[0].offsetx, obj[0].trany+obj[0].offsety, obj[0].tranz+obj[0].offsetz)
             
glRotatef(obj[0].rotx, 1.0, 0, 0)
glRotatef(obj[0].roty, 0, 1.0, 0)
glRotatef(obj[0].rotz, 0, 0, 1.0)
             
glBegin(GL_QUADS)

    glColor3f(0.3, 0.8, 0.2)
	glVertex3f( 4.0, 1.0,-2.0)
	glVertex3f( 3.0,-1.0,-2.0)
	glVertex3f( -3.0,-1.0,-2.0)
	glVertex3f( -4.0, 1.0, -2.0)
	
	glColor3f(0.3, 0.8, 0.2)
	glVertex3f(-4.0, 1.0, 2.0)
	glVertex3f(-3.0, -1.0, 2.0)
	glVertex3f(3.0, -1.0, 2.0)
	glVertex3f(4.0, 1.0, 2.0)
	
	glColor3f(0.3, 0.9, 0.3)
	glVertex3f(-4.0, 1.0, -2.0)
	glVertex3f(-3.0, -1.0,-2.0)
	glVertex3f(-3.0, -1.0, 2.0)
	glVertex3f(-4.0, 1.0, 2.0)
	
	glColor3f(0.3, 0.9, 0.3)
	glVertex3f(4.0, 1.0, 2.0)
	glVertex3f(3.0, -1.0, 2.0)
	glVertex3f(3.0, -1.0, -2.0)
	glVertex3f(4.0, 1.0, -2.0)
	
	glColor3f(0.3, 0.9, 0.3)
	glVertex3f(4.0, 1.0, 2.0)
	glVertex3f(3.0, -1.0, 2.0)
	glVertex3f(3.0, -1.0, -2.0)
	glVertex3f(4.0, 1.0, -2.0)
	
	glColor3f(0.3, 1.0, 0.2)
	glVertex3f(-4.0, 1.0, -2.0)
	glVertex3f(-4.0, 1.0, 2.0)
	glVertex3f(4.0, 1.0, 2.0)
	glVertex3f(4.0, 1.0, -2.0)
	
	glColor3f(0.3, 1.0, 0.2)
	glVertex3f(-3.0, -1.0, 2.0)
	glVertex3f(-3.0, -1.0, -2.0)
	glVertex3f(3.0, -1.0, -2.0)
	glVertex3f(3.0, -1.0, 2.0)

glEnd()
glPopMatrix()

' turret
glPushMatrix()
glTranslatef(obj[1].tranx+obj[1].offsetx, obj[1].trany+obj[1].offsety, obj[1].tranz+obj[1].offsetz)
             
glRotatef(obj[1].rotx, 1.0, 0, 0)
glRotatef(obj[1].roty, 0, 1.0, 0)
glRotatef(obj[1].rotz, 0, 0, 1.0)

glBegin(GL_QUADS)
	
	glColor3f(0.3, 0.8, 0.2)
	glVertex3f(-4.0, 1.0, -2.0)
	glVertex3f(-2.5, 2.0, -1.5)
	glVertex3f(0.5, 2.0, -1.5)
	glVertex3f(2.5, 1.0, -2.0)
	
	glColor3f(0.3, 0.8, 0.2)
	glVertex3f(2.5, 1.0, 2.0)
	glVertex3f(0.5, 2.0, 1.5)
	glVertex3f(-2.5, 2.0, 1.5)
	glVertex3f(-4.0, 1.0, 2.0)
	
	glColor3f(0.3, 0.9, 0.3)
	glVertex3f(-4.0, 1.0, 2.0)
	glVertex3f(-2.5, 2.0, 1.5)
	glVertex3f(-2.5, 2.0, -1.5)
	glVertex3f(-4.0, 1.0, -2.0)
	
	glColor3f(0.3, 0.9, 0.3)
	glVertex3f(0.5, 2.0, 1.5)
	glVertex3f(2.5, 1.0, 2.0)
	glVertex3f(2.5, 1.0, -2.0)
	glVertex3f(0.5, 2.0, -1.5)
	
	glColor3f(0.3, 1.0, 0.1)
	glVertex3f(0.5, 2.0, -1.5)
	glVertex3f(-2.5, 2.0, -1.5)
	glVertex3f(-2.5, 2.0, 1.5)
	glVertex3f(0.5, 2.0, 1.5)
	
	glEnd()
glPopMatrix()

' Gun

glPushMatrix()
glTranslatef(obj[2].tranx+obj[2].offsetx, obj[2].trany+obj[2].offsety, obj[2].tranz+obj[2].offsetz)
             
glRotatef(obj[1].rotx, 1.0, 0, 0)
glRotatef(obj[1].roty, 0, 1.0, 0)
glRotatef(obj[1].rotz, 0, 0, 1.0)

glBegin(GL_QUADS);

glColor3f(0.3,0.8,0.2);         ' Back Face
glVertex3f(0.0, 1.2, -0.5)
glVertex3f(0.0, 1.7, -0.5)
glVertex3f(4.0, 1.7, -0.5)
glVertex3f(4.5, 1.2, -0.5)

glColor3f(0.3,0.8,0.2);         ' Front Face
glVertex3f(4.5, 1.2, 0.5)
glVertex3f(4.0, 1.7, 0.5)
glVertex3f(0.0, 1.7, 0.5)
glVertex3f(0.0, 1.2, 0.5)

glColor3f(0.3,0.7,0.3);         ' Top Face
glVertex3f(4.0, 1.7, 0.5)
glVertex3f(4.0, 1.7, -0.5)
glVertex3f(0.0, 1.7, -0.5)
glVertex3f(0.0, 1.7, 0.5)

glColor3f(0.3,0.7,0.2);         ' Bottom Face
glVertex3f(0.0, 1.2, 0.5)
glVertex3f(0.0, 1.2, -0.5)
glVertex3f(4.5, 1.2, -0.5)
glVertex3f(4.5, 1.2, 0.5)

glEnd()

glPopMatrix()

End Function

Function idle_function()
obj[0].roty=obj[0].roty+0.01
If obj[0].roty&gt;360 obj[0].roty=0
obj[1].roty=obj[1].roty+0.03
If obj[1].roty&gt;360 obj[1].roty=0
End Function
</textarea><br><br>There's room for quite a few improvements with the code above, but its a certainly a good start for us.<br><br>(and before you mention it, YES.. there is a poly missing from the front of the gun turret - thats your job !) ;) <br><br></td></tr></table><br>
<a name="477715"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ftbass</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Really intesting topic, very well explained for the beginner I am. (some syntaxic mistakes in functions calls : I had to remove the 'f')<br><br>Keep up the good work :) <br><br></td></tr></table><br>
<a name="477824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AaronK</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> PaulJG, would you be interested in placing these tutorials up on BlitzWiki? www.blitzwiki.org - It'd be a great reference for everyone.<br><br>Cheers<br>Aaron <br><br></td></tr></table><br>
<a name="477953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bradford6</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks PaulJG.<br><br>Here is what I threw together in about 10 minutes after reading your tutorial. (using your code as a template of course :) )<br><br>very nice tutorial. thanks<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' rem OPENGL spinnning cube by Bill Radford V1
Global GW:Int=800
Global GH:Int=600
Global angle:Float=0
Global mode = GL_QUADS
global msg:String
bglCreateContext(GW,GH,32,0,BGL_BACKBUFFER|BGL_DEPTHBUFFER)  ' |BGL_FULLSCREEN)
init()


Repeat 
	click_timer:-1
	If click_timer &lt; 0 Then click_timer = 0
	
	If MouseDown(1) = 1 And click_timer = 0
		glmode = glmode + 1
		If glmode&gt;6 Then glmode = 0
		Select glmode
			Case 0 mode = GL_QUADS ; msg$ = "GL_QUADS"
			Case 1 mode = GL_LINES ; msg$ = "GL_LINES"
			Case 2 mode = GL_POLYGON ; msg$ = "GL_POLYGON"
			Case 3 mode = GL_TRIANGLES ; msg$ = "GL_TRIANGLES"
			Case 4 mode = GL_LINE_STRIP ; msg$ = "GL_LINE_STRIP"
			Case 5 mode = GL_LINE_LOOP ; msg$ = "GL_LINE_LOOP"
			Case 6 mode = GL_POINTS ; msg$ = "GL_POINTS"

		End Select
		click_timer = 50
	EndIf
	
	frametimer(2)
	display(mode)
	
	idle_function()
	bglSwapBuffers
	

Until KeyDown(KEY_ESCAPE)
End

Function init()
	glClearColor(0.0, 0.0, 0.0, 0.0)
	glClearDepth(1.0)
	glEnable(GL_CULL_FACE)
	glMatrixMode(GL_PROJECTION)
	glLoadIdentity()
	gluPerspective(45.0, Float(GW)/Float(GH), 0.1, 100.0)
	glMatrixMode(GL_MODELVIEW)
	glLoadIdentity()
	
End Function

Function display(mode)
	glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	glLoadIdentity()
	glTranslatef(0.0, 0.0, (Sin(angle)*10)-15)
	glRotatef(angle, 0.0, -1.0, 1.0)
	
	glBegin(mode)
		glColor3f(1.0,1.0,0.0) ' Front Face yellow
		glVertex3f(-1.0, -1.0, 1.0)
		glVertex3f( 1.0, -1.0, 1.0)
		glVertex3f( 1.0, 1.0, 1.0)
		glVertex3f(-1.0, 1.0, 1.0)

		glColor3f(0.0,1.0,0.0) ' Back Face Green
		glVertex3f(-1.0, -1.0, -1.0)
		glVertex3f(-1.0, 1.0, -1.0)
		glVertex3f( 1.0, 1.0, -1.0)
		glVertex3f( 1.0, -1.0, -1.0)

		glColor3f(1.0,0.0,0.0) ' Top Face Red
		glVertex3f(-1.0, 1.0, -1.0)
		glVertex3f(-1.0, 1.0, 1.0)
		glVertex3f( 1.0, 1.0, 1.0)
		glVertex3f( 1.0, 1.0, -1.0)

		glColor3f(0.0,0.0,1.0) ' Bottom Face Blue
		glVertex3f(-1.0, -1.0, -1.0)
		glVertex3f( 1.0, -1.0, -1.0)
		glVertex3f( 1.0, -1.0, 1.0)
		glVertex3f(-1.0, -1.0, 1.0)

		glColor3f(0.1,0.1,0.1) ' Right face Gray??
		glVertex3f( 1.0, -1.0, -1.0)
		glVertex3f( 1.0, 1.0, -1.0)
		glVertex3f( 1.0, 1.0, 1.0)
		glVertex3f( 1.0, -1.0, 1.0)

		glColor3f(1.0,1.0,1.0) ' Left Face White
		glVertex3f(-1.0, -1.0, -1.0)
		glVertex3f(-1.0, -1.0, 1.0)
		glVertex3f(-1.0, 1.0, 1.0)
		glVertex3f(-1.0, 1.0, -1.0)
	
		
	glEnd()
	
End Function

Function idle_function()
angle:+.1
If angle&gt;360.0 angle=0.0
End Function


Function frametimer(msecs)
	now = MilliSecs()
	
	Repeat
		passed = MilliSecs()-now
		
	Until passed &gt; msecs 

End Function
</textarea> <br><br></td></tr></table><br>
<a name="477971"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >wedoe</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm a newbie to GL, you made it easier Paul, thanks :)<br>(The nehe-stuff seemd just too much to handle <br>right now, but this is perfect....) <br><br></td></tr></table><br>
<a name="477976"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Me too, and this is just great. Keep it up! <br><br></td></tr></table><br>
<a name="477982"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> @AaronK: Sure, I'd like to get them all up and running first though. ;)<br><br>@Everyone:<br><br>Thanks guys.. they where sitting here on my harddrive getting dusty - so at least someones getting some use out of em. :)<br><br>Theres 13 tuts in total, the last few go quite a way into building a proper 3d engine. I'll keep posting them up as/and when I've got some spare time on my hands.<br>(the blitz community has certainly helped me out enough times over the last few years !)<br><br>It seems the PC OpenGL needs the 'f's on the end of the commands. Some maybe its a compatibility thingy !?. I'll put a note at the top of the first tut. <br><br></td></tr></table><br>
<a name="478006"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ole JR</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> @PaulJG: I think ftbass is talking about the function arguments in your last example.. <br>Example:<br><pre class=code>glColor3f(1.0f,0.2f,1.0f); // Top Face</pre>There's lots of them..<br><br>Isn't it so that the GL functions say something about how many arguments, and what value they take?? <br>glColor3f() is 3 float parameters, that's where the 3f comes in..?<br>So I understand it like this:<br>The number is how many parameters, and the last char is the 'type' of the parameters, ie f = float b = byte and so on..<br>Or I'm I totaly lost here...? <br><br></td></tr></table><br>
<a name="478013"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see what ya mean now.. the last snippet shouldnt work at all - just yet, its still in C++/Glut format.<br><br>I did post up a warning<br><div class="quote"> ***NOTE NOT FINISHED JUST YET !!!! - NOT BLITZMAX COMPATIBLE <br></div><br><br>Still.. if you guys are able to compile it with a bit of working around - save me a job ;)<br><br>@Ole JR: Yeap !, you got it.. there are other commands that take pointers to arrays, as you'll see ;) <br><br></td></tr></table><br>
<a name="478014"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi PaulJG,<br>Thanks for the tutorials... very useful.<br>What people are trying to say is you have left the 'f' on some parms which cause problems in bmx.<br>Check 'Setting up an OpenGl window' where the <br>glVertex3f( 0.0, 1.0,-10.0) is OK (no 'f's)<br>but later, such as 'The Screen Objects', you suggest adding...<br>glColor3f(0.0f,1.0f,0.0f);         // Add me<br>glVertex3f( 0.0f, 1.0f, -10.0f);<br>which causes problems. <br><br></td></tr></table><br>
<a name="478016"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> whoops.. Looks like I havent changed the code descriptions over to blitzmax format (although the main full listings should be alright)- sorry guys, I'll fix it.<br><br>Thanks for pointing it out. <br><br></td></tr></table><br>
<a name="478557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Akira</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excellent tutorials, just what a beginner like me needs.<br><br>BTW, you also need to change the C++ style comments as they cause problems in Blitz too. <br><br></td></tr></table><br>
<a name="479580"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jungle1971</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> WELL DONE PaulJG !!! <br><br>as a bmx/opengl rookie i want to tell you:<br>keep it up and please find the time to complete the<br>tutorials stuff.<br><br>i want to understand the nehe stuff in future.<br>this looks like as a good start for me.<br>i want to see the proper 3dengine :)<br><br>thank you very much for sharing with us<br>jGL <br><br></td></tr></table><br>
<a name="479898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> 3 new tutorials posted - and hopefully all existing bugs squashed !.<br><br>Note that the last tut wont run without some blitmax converting..<br><br>6 more tuts to come !.<br><br>I have to admit, I started playing with the 3dengine source thats building up with the later tuts - and ended up writing a full blown proper engine !!. (but I will find the time to get these tuts finished) ;) <br><br></td></tr></table><br>
<a name="480102"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jungle1971</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> @PaulJG<br><br>&gt; You can download the source code and precompiled exe here.<br><br>there is no download possible, please fix the link.<br>thanks in advance<br><br>jGL <br><br></td></tr></table><br>
<a name="480688"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry jungle, forgot to take that bit out - its left over from the original webpages..<br><br>Unfortunately I wont be posting the source or exe's now my website is gone. <br><br></td></tr></table><br>
<a name="480689"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LeisureSuitLurie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you need a host, email me. <br><br></td></tr></table><br>
<a name="481335"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Updated.. and added final tut for this part.<br><br>Part 2 coming soon...<br><br>Texture Mapping<br>Advanced Texturing<br>Advanced Camera Movement<br>The Workings of a 3d Engine <br><br></td></tr></table><br>
<a name="484352"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Afrohorse</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Keep up the good work Paul - look forward to seeing the rest of the tutorials :) <br><br></td></tr></table><br>
<a name="486303"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MadMunky</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any Chance in making these guides into PDF's so its a little easyer to read and store :) grate tutorial anyways though <br><br></td></tr></table><br>
<a name="487971"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Clyde</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> What a marvelous tutorial indeed, a real top effort and excellent for us mere newbies.<br><br>Excellent Work PaulJG!<br>Any chance of some more!? :) <br><br></td></tr></table><br>
<a name="497116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jungle1971</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> hello pauljg<br><br>still alive ? :)<br>jGL <br><br></td></tr></table><br>
<a name="497232"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PaulJG</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Still alive - just in a different forum.. ;)<br><br>Work on my 3d engine is painfully slow, and holding me up - but at least I can load an X format object/level now.<br><br>Guess your after the remaining tuts ? - ok, I'll start putting them up in the next few days.<br><br>btw guys.. sorry, there will be NO PDF's, zips or downloads - I want to get them off my harddrive !. ;) <br><br></td></tr></table><br>
<a name="520859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jungle1971</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> hello pauljg<br><br>how it is going ? are you so much busy :(<br>i dont want to notice that the OpenGL for Newbie, Part1 tutorial is dead!<br>please pauljg, please take the time it tooks and finish the<br>story, thanks you!<br>cheers<br>jGL <br><br></td></tr></table><br>
<a name="662330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CASO</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compile Error<br> Identifier 'bglCreateContext' not found<br><br>I'm running on version 1.20<br>What's the problem? <br><br></td></tr></table><br>
<a name="662338"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> BlitzGL no longer exists!<br><br>From 'release.doc'...<div class="quote"> * BlitzGL (ie: the 'bgl' commands) has GONE! Instead, use the following:<br><br>bglCreateContext -&gt; GLGraphics<br>bglTexFromPixmap -&gt; GLTexFromPixmap<br>bglAdjustTexSize -&gt; GLAdjustTexSize<br>bglDrawText -&gt; GLDrawText<br>bglSwapBuffers -&gt; Flip <br></div> <br><br></td></tr></table><br>
<a name="669355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Will</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> but OpenGL in blitzmax still works.  Just change bglcreateContext for GLGraphics(width, height, depth) and bglSwapBuffers for flip. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
