<!DOCTYPE html><html lang="en" ><head ><title >Learn Verlet Physics</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Learn Verlet Physics</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=112" >BlitzMax Tutorials</a>/<a href="#bottom" >Learn Verlet Physics</a><br><br>
<a name="957479"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi<br><br>This is just a translated version of my b3d tutorial: sorry its not in OO but that is because I translated it almost directly from b3d<br><br>NOTE: I know this lacks timestep and collision detection etc but the point of this tutorial is to help people that don't get it, get it.<br><br>Here is a tutorial I decided to write for anyone who wants to understand verlet integration but really doesn't know how to decode all of those confusing equations on wikipedia.<br><br>So where to start?  Well verlet integration is based around point masses.  These point masses are bound together by constraints that can be rigid or flexible.  Thats about it.  Now to coding it.<br><br>The pointmass Type itself:<br><br>Each point mass has an <b>x</b> value and a <b>y</b> value as well as an <b>ox</b> (old x) and an <b>oy</b> (old y)  These ox and oy values are used to calculate the velocity of the particle after each frame.  So right now our code for the verlet type would look like this in b3d or bmax:<br><br><pre class=code>Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type
</pre><br><br>now this doesn't do much by itself so we must come up with an update function.  The update function figures out the velocities of each verlet and moves them one step further.  This is easier than it sounds.<br><br>The equation of figuring out the velocity couldn't be simpler<br><br>dx = x - ox<br>dy = y - oy<br><br>dx is the difference between the ox and the current x<br><br>so now we put the current x and y values in our ox and oy fields like this<br><br>ox = x<br>oy = y<br><br>next we add our velocity to the current x and y to simulate a time step forward.<br><br>x = x + dx<br>y = y + dy<br><br>could it be any simpler?  This satisfies newton's first law.  Paraphrased: an object in motion stays in motion unless acted on by another force<br><br>So here is what our type and update function look like in bmax code<br><br><pre class=code>Global pointlist:TList = New TList

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()

	For p:pointmass = EachIn pointlist
		dx# = p.x - p.ox
		dy# = p.y - p.oy
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
	Next

End Function</pre><br><br>now to make a short demo of this, we must add drawing functions and a simple while loop.<br><br><pre class=code>Global pointlist:TList = New TList

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()
	
	For p:pointmass = EachIn pointlist
		DrawOval p.x-4,p.y-4,8,8
		dx# = p.x - p.ox
		dy# = p.y - p.oy
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
	Next

End Function

Function createpointmass:pointmass(x#,y#,vx#,vy#)	' x And y are coords For the verlet. vx And vy are velocity values For the verlet

p:pointmass = New pointmass
p.x = x
p.y = y
p.ox = x-vx	'gives the particle a starting velocity
p.oy = y-vy
pointlist.addlast(p:pointmass)

Return p:pointmass

End Function

Graphics 640,480,0,60

createpointmass(100,100,5,1)

While Not KeyDown(key_escape)
Cls


updatepointmasses()
Flip
Wend
End

</pre><br><br>so the code above simply makes a particle and gives it a velocity.  :-)<br><br>Now I will move on to constraints which I view as wooden rods between verlets.  So how do constraints work?  well constraints are satisfied in a loop by brute force pretty much.  All other methods are either too ineffiecient or just not accurate enough.  The constraint loop goes after the loop that updates velocity and works like this:  if a constraint is too short due to the particles being compressed, then stretch it to make it the right size.  If a constraint is too long because the particles were stretched apart then shrink it to make it the right size.<br><br>The constraint type will look something like this:<br><br><pre class=code>Type constraint
	Field p1:pointmass
	Field p2:pointmass
	Field length#
End Type</pre><br><br>Here are the equations we will use for constraints (not optimized but for simplicity instead)<br><br>find the distance between the constrained verlets:<br>dist = sqr((x1-x2)^2 + (y1-y2)^2)<br><br>get the differences in the x and y values:<br>dx = x1-x2<br>dy = y1-y2<br><br>dist is the distance between 2 particles and length is the length of the constraint. diff is the difference between the two<br><br>diff = dist-length<br><br>diff = diff / length<br><br>dx = dx * .5<br>dy = dy * .5<br><br>and finally the constraint is solved with:<br><br>x1 = x1 - (diff * dx)<br>y1 = y1 - (diff * dy)<br><br>x2 = x2 + (diff *dx)<br>y2 = y2 + (diff * dy)<br><br>If you really want to know how this works it is best to draw it out on graph paper, and do it step by step.<br><br>One final note on constraints before you see the code is that the constraints are updated 5-20 times every loop depending on the accuracy needed for the engine.  This is only necessary when there are many constraints but I will put it in anyway.<br><br>For now here is the update function we are going to use.  this is not for efficiency, it is made so it is easy to understand.<br><br><pre class=code>Function updateconstraints()
	
	For cnt = 0 To CONST_ITERATIONS-1	'this is necessary with many constraints To solve them correctly
		For c:constraint = EachIn constraintlist
			dist# = Sqr((c.p1.x-c.p2.x)^2 + (c.p1.y-c.p2.y)^2)	'distance formula
			
			diff# = dist#-c.length#	'shows the margin of error the update loop has created so it can be corrected
			
			dx# = c.p1.x-c.p2.x	'difference between x's and y's
			dy# = c.p1.y-c.p2.y
			
			If c.length &gt; 0 Then	'prevents a divided by 0 error that may occur
				diff = diff / c.length
			Else
				diff = 0
			EndIf
			
			dx = dx * .5
			dy = dy * .5
			
			c.p1.x = c.p1.x - (diff*dx)
			c.p1.y = c.p1.y - (diff*dy)
			
			c.p2.x = c.p2.x + (diff*dx)
			c.p2.y = c.p2.y + (diff*dy)
		Next
	Next
	
End Function</pre><br><br>Now if we put this all together, we can make a basic demo to show that constraints work.<br><br><pre class=code>Global pointlist:TList = New TList
Global constraintlist:TList = New TList
Global CONST_ITERATIONS = 5

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()
	
	For p:pointmass = EachIn pointlist
		DrawOval p.x-4,p.y-4,8,8
		dx# = p.x - p.ox
		dy# = p.y - p.oy
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
	Next

End Function

Function createpointmass:pointmass(x#,y#,vx#,vy#)	' x And y are coords For the verlet. vx And vy are velocity values For the verlet

p:pointmass = New pointmass
p.x = x
p.y = y
p.ox = x-vx	'gives the particle a starting velocity
p.oy = y-vy
pointlist.addlast(p:pointmass)

Return p:pointmass

End Function


Type constraint
	Field p1:pointmass
	Field p2:pointmass
	Field length#
End Type


Function updateconstraints()
	
	For cnt = 0 To CONST_ITERATIONS-1	'this is necessary with many constraints To solve them correctly
		For c:constraint = EachIn constraintlist
			dist# = Sqr((c.p1.x-c.p2.x)^2 + (c.p1.y-c.p2.y)^2)	'distance formula
			
			diff# = dist#-c.length#	'shows the margin of error the update loop has created so it can be corrected
			
			dx# = c.p1.x-c.p2.x	'difference between x's and y's
			dy# = c.p1.y-c.p2.y
			
			If c.length &gt; 0 Then	'prevents a divided by 0 error that may occur
				diff = diff / c.length
			Else
				diff = 0
			EndIf
			
			dx = dx * .5
			dy = dy * .5
			
			c.p1.x = c.p1.x - (diff*dx)
			c.p1.y = c.p1.y - (diff*dy)
			
			c.p2.x = c.p2.x + (diff*dx)
			c.p2.y = c.p2.y + (diff*dy)
		Next
	Next
	
End Function

Function createconstraint:constraint(p1:pointmass,p2:pointmass)
	
	c:constraint = New constraint
	c.p1 = p1
	c.p2 = p2
	c.length = Sqr((p1.y-p2.y)^2+(p1.x-p2.x)^2)
	
	constraintlist.addlast(c:constraint)
	Return c:constraint
End Function


Function drawconstraints()
	For c:constraint = EachIn constraintlist
		DrawLine c.p1.x,c.p1.y,c.p2.x,c.p2.y
	Next
End Function


Graphics 640,480,0,60

p1:pointmass = createpointmass(100,100,1,0)
p2:pointmass = createpointmass(100,150,0,0)
c:constraint = createconstraint(p1,p2)

While Not KeyDown(key_escape)
Cls


updatepointmasses()
updateconstraints()
drawconstraints()

Flip
Wend
End

</pre><br><br><br>Ok, time for a little demo of a square falling using the same verlet engine in the above post.  I just added some verlets and constraints before the loop<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global pointlist:TList = New TList
Global constraintlist:TList = New TList
Global CONST_ITERATIONS = 5

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()
	
	For p:pointmass = EachIn pointlist
		DrawOval p.x-4,p.y-4,8,8
		dx# = p.x - p.ox
		dy# = p.y - p.oy + .1
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
		
		If p.y &gt; 480 Then
			p.y = 480
			dx = p.x-p.ox
			p.ox = p.x-dx/2
		endif
	Next

End Function

Function createpointmass:pointmass(x#,y#,vx#,vy#)	' x And y are coords For the verlet. vx And vy are velocity values For the verlet

p:pointmass = New pointmass
p.x = x
p.y = y
p.ox = x-vx	'gives the particle a starting velocity
p.oy = y-vy
pointlist.addlast(p:pointmass)

Return p:pointmass

End Function


Type constraint
	Field p1:pointmass
	Field p2:pointmass
	Field length#
End Type


Function updateconstraints()
	
	For cnt = 0 To CONST_ITERATIONS-1	'this is necessary with many constraints To solve them correctly
		For c:constraint = EachIn constraintlist
			dist# = Sqr((c.p1.x-c.p2.x)^2 + (c.p1.y-c.p2.y)^2)	'distance formula
			
			diff# = dist#-c.length#	'shows the margin of error the update loop has created so it can be corrected
			
			dx# = c.p1.x-c.p2.x	'difference between x's and y's
			dy# = c.p1.y-c.p2.y
			
			If c.length &gt; 0 Then	'prevents a divided by 0 error that may occur
				diff = diff / c.length
			Else
				diff = 0
			EndIf
			
			dx = dx * .5
			dy = dy * .5
			
			c.p1.x = c.p1.x - (diff*dx)
			c.p1.y = c.p1.y - (diff*dy)
			
			c.p2.x = c.p2.x + (diff*dx)
			c.p2.y = c.p2.y + (diff*dy)
		Next
	Next
	
End Function

Function createconstraint:constraint(p1:pointmass,p2:pointmass)
	
	c:constraint = New constraint
	c.p1 = p1
	c.p2 = p2
	c.length = Sqr((p1.y-p2.y)^2+(p1.x-p2.x)^2)
	
	constraintlist.addlast(c:constraint)
	Return c:constraint
End Function


Function drawconstraints()
	For c:constraint = EachIn constraintlist
		DrawLine c.p1.x,c.p1.y,c.p2.x,c.p2.y
	Next
End Function


Graphics 640,480,0,60

p1:pointmass = createpointmass(100,100,0,0)
p2:pointmass = createpointmass(100,150,0,0)
p3:pointmass = createpointmass(150,150,0,0)
p4:pointmass = createpointmass(150,100,0,0)

c:constraint = createconstraint(p1,p2)
c1:constraint = createconstraint(p2,p3)
c2:constraint = createconstraint(p3,p4)
c3:constraint = createconstraint(p1,p4)


While Not KeyDown(key_escape)
Cls


updatepointmasses()
updateconstraints()
drawconstraints()

Flip
Wend
End

</textarea><br><br>so run that and see what happens... uh It falls over! so we must support it by adding the following lines to the beginning after all other constraints are created.<br><br><pre class=code>c.constraint = createconstraint(p1,p3)
c.constraint = createconstraint(p2,p4)</pre><br><br>so the code will look like this:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global pointlist:TList = New TList
Global constraintlist:TList = New TList
Global CONST_ITERATIONS = 5

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()
	
	For p:pointmass = EachIn pointlist
		DrawOval p.x-4,p.y-4,8,8
		dx# = p.x - p.ox
		dy# = p.y - p.oy + .1
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
		
		If p.y &gt; 480 Then
			p.y = 480
			dx = p.x-p.ox
			p.ox = p.x-dx/2
		endif
	Next

End Function

Function createpointmass:pointmass(x#,y#,vx#,vy#)	' x And y are coords For the verlet. vx And vy are velocity values For the verlet

p:pointmass = New pointmass
p.x = x
p.y = y
p.ox = x-vx	'gives the particle a starting velocity
p.oy = y-vy
pointlist.addlast(p:pointmass)

Return p:pointmass

End Function


Type constraint
	Field p1:pointmass
	Field p2:pointmass
	Field length#
End Type


Function updateconstraints()
	
	For cnt = 0 To CONST_ITERATIONS-1	'this is necessary with many constraints To solve them correctly
		For c:constraint = EachIn constraintlist
			dist# = Sqr((c.p1.x-c.p2.x)^2 + (c.p1.y-c.p2.y)^2)	'distance formula
			
			diff# = dist#-c.length#	'shows the margin of error the update loop has created so it can be corrected
			
			dx# = c.p1.x-c.p2.x	'difference between x's and y's
			dy# = c.p1.y-c.p2.y
			
			If c.length &gt; 0 Then	'prevents a divided by 0 error that may occur
				diff = diff / c.length
			Else
				diff = 0
			EndIf
			
			dx = dx * .5
			dy = dy * .5
			
			c.p1.x = c.p1.x - (diff*dx)
			c.p1.y = c.p1.y - (diff*dy)
			
			c.p2.x = c.p2.x + (diff*dx)
			c.p2.y = c.p2.y + (diff*dy)
		Next
	Next
	
End Function

Function createconstraint:constraint(p1:pointmass,p2:pointmass)
	
	c:constraint = New constraint
	c.p1 = p1
	c.p2 = p2
	c.length = Sqr((p1.y-p2.y)^2+(p1.x-p2.x)^2)
	
	constraintlist.addlast(c:constraint)
	Return c:constraint
End Function


Function drawconstraints()
	For c:constraint = EachIn constraintlist
		DrawLine c.p1.x,c.p1.y,c.p2.x,c.p2.y
	Next
End Function


Graphics 640,480,0,60

p1:pointmass = createpointmass(100,100,0,0)
p2:pointmass = createpointmass(100,150,0,0)
p3:pointmass = createpointmass(150,150,0,0)
p4:pointmass = createpointmass(150,100,0,0)

c:constraint = createconstraint(p1,p2)
c1:constraint = createconstraint(p2,p3)
c2:constraint = createconstraint(p3,p4)
c3:constraint = createconstraint(p1,p4)

c5:constraint = createconstraint(p2,p4)
c6:constraint = createconstraint(p1,p3)


While Not KeyDown(key_escape)
Cls


updatepointmasses()
updateconstraints()
drawconstraints()

Flip
Wend
End

</textarea><br><br>Now the only thing that needs to be done is a collision engine... the hard part (for me at least) <br><br></td></tr></table><br>
<a name="957928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This looks like good stuff... I'll be sure to read it at some point. Thanks! <br><br></td></tr></table><br>
<a name="958065"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, this is nice. I was able to follow you all the way through and can now say that I understand how this works! Thanks.<br><br>I don't entirely grasp *why* it's necessary to do each of the steps in the constaint processing, but I'm sure it'll become clearer.<br><br>How exactly would someone go about collision detection with this? I guess if you just have shapes falling down the screen you could say that if a pointmass's y coordinate goes past the bottom of the screen you fix it to the bottom, but doesn't it need to calculate some kind of rebound force or something?<br><br>Also how easy it is to adapt this to using springs instead of fixed constraints? <br><br></td></tr></table><br>
<a name="958067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok nice to know it helped some people!  I love teaching.<br><br>it's necessary to do the constraint loop many times because when you have many constraints connected to many verlets, one time through wont solve it, it will get closer every loop it does.  - hope that clears it up a little?<br><br>as for the springs, im not really sure if this is the way you are supposed to do it but there are two things I do (and they work perfectly so I dont see whats wrong with it):<br><br>1. I give each constraint an elasticity variable (the value should be 1 or more... any less and it will explode.)<br>2. in the constraint loop, change this:<br><br><pre class=code>c.p1.x = c.p1.x - (diff*dx)
c.p1.y = c.p1.y - (diff*dy)

c.p2.x = c.p2.x + (diff*dx)
c.p2.y = c.p2.y + (diff*dy)
</pre><br><br>to this:<br><br><pre class=code>c.p1.x = c.p1.x - (diff*dx)/c.elasticity
c.p1.y = c.p1.y - (diff*dy)/c.elasticity

c.p2.x = c.p2.x + (diff*dx)/c.elasticity
c.p2.y = c.p2.y + (diff*dy)/c.elasticity
</pre><br><br><br>and make sure you set the elasticity to at least 1 where the constraints are created so the system doesnt explode. <br><br></td></tr></table><br>
<a name="958073"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> oops I forgot to answer your question about collision detection<br><br>I will post an official tutorial on this sometime later but I don't understand it enough now.   Here is what I am experimenting with right now:<br><br>loop through all verlets and test them against all other verlets for collision because verlets in my engine have a radius and can collide with eachother.<br><br>test for collisions between all constraints and all verlets<br><br>to cause them to collide just change the x and y values to a legal value and position the ox and oy values accordingly<br><br><br>for some good code for basing your collisions off of, here is my math.bmx file<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">'used for line intersect functions

Global Intersection_X#
Global Intersection_Y#
Global Intersection_AB#
Global Intersection_CD#

Function acqrdistance#[](x:Float,y:Float,x2:Float,y2:Float,acqdist:Float)	'x = col point x2 = center of collided circle ditto for y's  acqdist = the distance to acquire between these two points
	
	Local temparay#[]
	Local nx:Float
	Local ny:Float
	Local dx! = x - x2	'doubles because these are the cause of most floating point inacuracy that causes jerking and bouncing around
	Local dy!= y - y2
	Local dist:Float = Sqr(dx*dx + dy*dy)
	
	If dist &lt; acqdist And dist &gt; 0 Then
		
		dx = (dx / dist) * acqdist
		dy = (dy / dist) * acqdist
		nx = x - dx
		ny = y - dy
		
	Else
		nx = x2
		ny = y2
	EndIf
	
	temparay# = [nx,ny]
	
	Return temparay#
	
End Function



Function acqrdistance2#[](x:Float,y:Float,x2:Float,y2:Float,acqdist:Float)	'x = col point x2 = center of collided circle ditto for y's  acqdist = the distance to acquire between these two points
	
	Local temparay#[]
	Local nx:Float
	Local ny:Float
	Local dx! = x - x2	'doubles because these are the cause of most floating point inacuracy that causes jerking and bouncing around
	Local dy!= y - y2
	Local dist:Float = Sqr(dx*dx + dy*dy)
	
	If dist &gt; 0 Then	'took out dist &lt; acqdist
		
		dx = (dx / dist) * acqdist
		dy = (dy / dist) * acqdist
		nx = x + dx
		ny = y + dy
		
	Else
		nx = x2
		ny = y2
	EndIf
	
	temparay# = [nx,ny]
	
	Return temparay#
	
End Function




Function linecircleintersect#[][]( pLineStart#[], pLineEnd#[], pCircleCenter#[], pCircleRadius# )	'many thanks to blitz support for this one!
	
	Local tmpIntersections#[][]
	
	Local p# = pCircleCenter[0], q# = pCircleCenter[1]
	Local m# = (pLineEnd[1]-pLineStart[1])/(pLineEnd[0]-pLineStart[0])
	Local r# = pCircleRadius
	Local t# = pLineEnd[1]- (m*pLineEnd[0])
	Local s# = t-q
	
	Local a# = m*m + 1, b# = (2*m*s) - (2*p), c# = s*s + p*p - (r*r)
	
	Local bsqminfourac# = b*b-4*a*c
	
	If bsqminfourac &gt; 0 Then
		
		bsqminfourac = Sqr(bsqminfourac)
		
		Local x1# = ((-b)+bsqminfourac)/(2*a)
		Local x2# = ((-b)-bsqminfourac)/(2*a)
		
		tmpIntersections = [[x1,(m*x1)+t],[x2,(m*x2)+t]]
		
	ElseIf bsqminfourac = 0 Then
		
		tmpIntersections = [[(-b)/(2*a),(-b*m)/(2*a)+t]]
		
	EndIf
	
	Return tmpIntersections

EndFunction


Function Lines_Intersect:Int(Ax#, Ay#, Bx#, By#, Cx#, Cy#, Dx#, Dy#)	'finds the line intersections... never mind commenting the math.. I dont even understand it anymore
	Local dymcy# = dy - cy
	Local dxmcx# = dx - cx
	
	Local Rn# = (Ay#-Cy#)*(DxmCx#) - (Ax#-Cx#)*(DymCy#)
	Local Rd# = (Bx#-Ax#)*(DymCy#) - (By#-Ay#)*(DxmCx#)
		
	If Rd# = 0 
		
		' Lines are parralel.
		' If Rn# is also 0 Then lines are coincident.  All points intersect. 
		' Otherwise, there is no intersection point.
		Return False
	Else
		' The lines intersect at some point.  Calculate the intersection point.
	Local Sn# = (Ay#-Cy#)*(Bx#-Ax#) - (Ax#-Cx#)*(By#-Ay#)
		Intersection_AB# = Rn# / Rd#
		Intersection_CD# = Sn# / Rd#
		Intersection_X# = Ax# + Intersection_AB#*(Bx#-Ax#)
		Intersection_Y# = Ay# + Intersection_AB#*(By#-Ay#)	
	EndIf
		
	If Intersection_AB#&gt;0 And Intersection_AB#&lt;1 And Intersection_CD#&gt;0 And Intersection_cd#&lt;1
			Return True	
		Else
			Return False
	EndIf


End Function


Function UpdateVerletPolysegCollisions()

Local cnt:Int = 0
Local v:verlet

For cnt = 0 To Verlcount-1
	V:verlet = Verletarray:Verlet[cnt]
	If V.active = True Then
		
		
		checkverletbounds v:verlet
		
		If v.x &lt; activerightbound And v.x &gt; activeleftbound And v.y &gt; activeupbound And v.y &lt; activelowbound Then
			
			If v.ghost = False Then updatepolysegs(v:verlet)
		
		EndIf
		
	EndIf
	
Next

End Function





'|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
'thanks for the following two functions "another JIM"
'Finds out if a point is on the left or right side of a segment
Function LineIntersectOX:Int(lx1:Float, ly1:Float, lx2:Float, ly2:Float, px:Float, py:Float)
	Local newpx:Float
	
	If ((ly1 &lt; py) And (ly2 &gt; py) ..
		Or (ly1 &gt; py) And (ly2 &lt; py)) And (lx1 &gt; px) And (lx2 &gt; px)
		Return True
	End If
	
	Local b:Int = ((ly1 &lt;= py) And (ly2 &gt;= py)) Or ((ly1 &gt;= py) And (ly2 &lt;= py))
	If (b = False)
		Return False
	EndIf
	
	If ly2 = ly1 Then
		Return False
	Else	
		newpx = ((py - ly1) / (ly2 - ly1)) * (lx2 - lx1) + lx1
		If (px &lt; newpx) Return True
	EndIf
	Return False
End Function

'finds out if a point is inside a polygon
Function PointInPoly:Int(px:Float, py:Float, poly:Float[])
	Local i:Int
	Local sum:Int

	For i = 0 To Int(poly.length / 2) - 2
		Local p1x:Float = poly[i * 2]
		Local p1y:Float = poly[i * 2 + 1]
		Local p2x:Float = poly[(i + 1) * 2]
		Local p2y:Float = poly[(i + 1) * 2 + 1]
		
		sum:+LineIntersectOX(p1x, p1y, p2x, p2y, px, py)
	Next
	
	If (poly.length &gt; 4)
		Local p1xd:Float = poly[0]
		Local p1yd:Float = poly[1]
		Local p2xd:Float = poly[poly.length - 2]
		Local p2yd:Float = poly[poly.length - 1]
		
		sum:+LineIntersectOX(p1xd, p1yd, p2xd, p2yd, px, py)
	End If
	
	Return sum Mod 2
End Function
'|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

</textarea><br><br>sorry its not commented yet <br><br></td></tr></table><br>
<a name="958167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great, the springs thing looks really simple to add.<br><br>So for collision detection are you saying that you just detect when a point or edge is inside/overlapping one from another object, and move the points until they don't? <br><br></td></tr></table><br>
<a name="958170"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> yeah for the collision detection I do that but it greatly simplifies things if you make each point mass have a radius with only pointmass-pointmass collisions rather than constraint-pointmass collisions.  My engine will have both as it seems that many modern engines like box2d, chipmunk, and farseer have poly-poly collison so if I want to compete I must include it too.<br><br>You can also use seperating axis theory to give a decent speedup but it unfortunately only works for convex objects. <br><br></td></tr></table><br>
<a name="958266"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about if the points are not very close to each other? Wouldn't that make the tip of a box penetrate another? <br><br></td></tr></table><br>
<a name="958293"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can always approximate a box shape with no penetration... take a look at the verlet max demo in my sig.  but I recommend making verlet-polygon collisions as they are almost essential for any general purpose engine <br><br></td></tr></table><br>
<a name="1000298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fry Crayola</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, Nate, this is good stuff. That sample is instantly impressive.<br><br>Are you still planning on producing a collision detection tutorial? <br><br></td></tr></table><br>
<a name="1000354"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks<br><br><div class="quote"> Are you still planning on producing a collision detection tutorial? <br> <br></div><br><br>yes, when I figure it out! and get it implemented in my own physics engine...<br><br>*sigh* its really confusing because there are so many choices of what to do for collision detection, there is no set standard formula for collision detection with verlet physics.. <br><br></td></tr></table><br>
<a name="1000376"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Damn you Nate! Your hooking me into this stuff again! ;)<br><br>anyway...<br><br>Here is a version with the need for sqr removed... faster :)<br><br>Oh, and I rotated the box for more fun lol<br><br><pre class=code>
Global pointlist:TList = New TList
Global constraintlist:TList = New TList
Global CONST_ITERATIONS = 5

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()
	
	For p:pointmass = EachIn pointlist
		DrawOval p.x-4,p.y-4,8,8
		dx# = p.x - p.ox
		dy# = p.y - p.oy + .1
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
		
		If p.y &gt; 480 Then
			p.y = 480
			dx = p.x-p.ox
			p.ox = p.x-dx/2
		endif
	Next

End Function

Function createpointmass:pointmass(x#,y#,vx#,vy#)	' x And y are coords For the verlet. vx And vy are velocity values For the verlet

p:pointmass = New pointmass
p.x = x
p.y = y
p.ox = x-vx	'gives the particle a starting velocity
p.oy = y-vy
pointlist.addlast(p:pointmass)

Return p:pointmass

End Function


Type constraint
	Field p1:pointmass
	Field p2:pointmass
	Field length#
End Type


Function updateconstraints()
	
	For cnt = 0 To CONST_ITERATIONS-1	'this is necessary with many constraints To solve them correctly
		For c:constraint = EachIn constraintlist
			dist# = ((c.p1.x-c.p2.x)^2 + (c.p1.y-c.p2.y)^2)	'distance formula
			
			diff# = dist#-c.length#	'shows the margin of error the update loop has created so it can be corrected
			
			dx# = c.p1.x-c.p2.x	'difference between x's and y's
			dy# = c.p1.y-c.p2.y
			
			If c.length &gt; 0 Then	'prevents a divided by 0 error that may occur
				diff = diff / c.length
			Else
				diff = 0
			EndIf
			
			dx = dx * .25
			dy = dy * .25
			
			c.p1.x = c.p1.x - (diff*dx)
			c.p1.y = c.p1.y - (diff*dy)
			
			c.p2.x = c.p2.x + (diff*dx)
			c.p2.y = c.p2.y + (diff*dy)
		Next
	Next
	
End Function

Function createconstraint:constraint(p1:pointmass,p2:pointmass)
	
	c:constraint = New constraint
	c.p1 = p1
	c.p2 = p2
	c.length = ((p1.y-p2.y)^2+(p1.x-p2.x)^2)
	
	constraintlist.addlast(c:constraint)
	Return c:constraint
End Function


Function drawconstraints()
	For c:constraint = EachIn constraintlist
		DrawLine c.p1.x,c.p1.y,c.p2.x,c.p2.y
	Next
End Function


Graphics 640,480,0,60

p1:pointmass = createpointmass(125,100,0,0)
p2:pointmass = createpointmass(150,125,0,0)
p3:pointmass = createpointmass(125,150,0,0)
p4:pointmass = createpointmass(100,125,0,0)

c:constraint = createconstraint(p1,p2)
c1:constraint = createconstraint(p2,p3)
c2:constraint = createconstraint(p3,p4)
c3:constraint = createconstraint(p1,p4)

c5:constraint = createconstraint(p2,p4)
c6:constraint = createconstraint(p1,p3)


While Not KeyDown(key_escape)
Cls


updatepointmasses()
updateconstraints()
drawconstraints()

Flip
Wend
End
</pre> <br><br></td></tr></table><br>
<a name="1000379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is funner...<br><br>Space turns the slow drawline on/off<br>Left Control adds random vertical velocities to the points<br>Oh, and I made it a little bouncier and replaced drawoval with an image...<br><br><pre class=code>
Global pointlist:TList = New TList
Global constraintlist:TList = New TList
Global CONST_ITERATIONS = 5

Type pointmass
	Field x#
	Field y#
	Field ox#
	Field oy#
End Type

Function updatepointmasses()
	
	For p:pointmass = EachIn pointlist
		DrawImage im,p.x,p.y
		dx# = p.x - p.ox
		dy# = p.y - p.oy + .1
		
		p.ox = p.x
		p.oy = p.y
		
		p.x = p.x + dx
		p.y = p.y + dy
		
		If p.y &gt; 480 Then
			p.y = 480
			dx = p.x-p.ox
			p.ox = p.x-dx/2
		endif
	Next

End Function

Function createpointmass:pointmass(x#,y#,vx#,vy#)	' x And y are coords For the verlet. vx And vy are velocity values For the verlet

p:pointmass = New pointmass
p.x = x
p.y = y
p.ox = x-vx	'gives the particle a starting velocity
p.oy = y-vy
pointlist.addlast(p:pointmass)

Return p:pointmass

End Function


Type constraint
	Field p1:pointmass
	Field p2:pointmass
	Field length#
End Type


Function updateconstraints()
	
	For cnt = 0 To CONST_ITERATIONS-1	'this is necessary with many constraints To solve them correctly
		For c:constraint = EachIn constraintlist
			dist# = ((c.p1.x-c.p2.x)^2 + (c.p1.y-c.p2.y)^2)	'distance formula
			
			diff# = dist#-c.length#	'shows the margin of error the update loop has created so it can be corrected
			
			dx# = c.p1.x-c.p2.x	'difference between x's and y's
			dy# = c.p1.y-c.p2.y
			
			If c.length &gt; 0 Then	'prevents a divided by 0 error that may occur
				diff = diff / c.length
			Else
				diff = 0
			EndIf
			
			dx = dx * .15
			dy = dy * .15
			
			c.p1.x = c.p1.x - (diff*dx)
			c.p1.y = c.p1.y - (diff*dy)
			
			c.p2.x = c.p2.x + (diff*dx)
			c.p2.y = c.p2.y + (diff*dy)
		Next
	Next
	
End Function

Function createconstraint:constraint(p1:pointmass,p2:pointmass)
	
	c:constraint = New constraint
	c.p1 = p1
	c.p2 = p2
	c.length = ((p1.y-p2.y)^2+(p1.x-p2.x)^2)
	
	constraintlist.addlast(c:constraint)
	Return c:constraint
End Function


Function drawconstraints()
	For c:constraint = EachIn constraintlist
		DrawLine c.p1.x,c.p1.y,c.p2.x,c.p2.y
	Next
End Function


Graphics 640,480,0,60
AutoMidHandle(True)
Global drawlines=False
Global im:TImage=CreateImage(8,8,1,DYNAMICIMAGE|MASKEDIMAGE)
DrawOval 0,0,8,8
GrabImage(im,0,0)
Cls

For ct=0 To 20
x=Rnd(0,590)
y=Rnd(0,100)
p1:pointmass = createpointmass(25+x,y,0,0)
p2:pointmass = createpointmass(50+x,25+y,0,0)
p3:pointmass = createpointmass(25+x,50+y,0,0)
p4:pointmass = createpointmass(x,25+y,0,0)

c:constraint = createconstraint(p1,p2)
c1:constraint = createconstraint(p2,p3)
c2:constraint = createconstraint(p3,p4)
c3:constraint = createconstraint(p1,p4)

c5:constraint = createconstraint(p2,p4)
c6:constraint = createconstraint(p1,p3)
Next

While Not KeyDown(key_escape)
Cls


updatepointmasses()
updateconstraints()
If drawlines Then drawconstraints()
If KeyHit(KEY_SPACE ) Then drawlines=1-drawlines
If KeyHit(KEY_LCONTROL)
	For p:pointmass=EachIn pointlist
		p.y=p.y-Rnd(0,10)
	Next
End If
Flip
Wend
End
</pre> <br><br></td></tr></table><br>
<a name="1000547"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Damn you Nate! Your hooking me into this stuff again! ;)<br><br>anyway...<br><br>Here is a version with the need for sqr removed... faster :)<br><br>Oh, and I rotated the box for more fun lol<br> <br></div><br><br>lol nobody made you read it ;)<br><br>and thanks for the examples<br><br>edit<br>uhhhh skully? did you just take the sqr off of there? lol! idk how that works...<br><br>edit2: what exactly did you change to get rid of the sqr? <br><br></td></tr></table><br>
<a name="1000557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fry Crayola</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks to me like he made the constraint's length variable the square of the actual length, meaning the square root is never required when you're processing the constraints later.<br><br>Pretty common trick for speeding things up if you only need to compare values. <br><br></td></tr></table><br>
<a name="1000562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> exactly... since the comparative values are related by SQR... factor it out!<br><br>The other thing I had to do is:<br><pre class=code>
dx = dx * .25
dy = dy * .25
</pre> <br><br>so it didn't self destruct (which is 0.5^2) <br><br></td></tr></table><br>
<a name="1000571"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmm that just doesnt rest well with me... :/ sqr is not a linear operation like you cant just facor it out... well ill experiment though... <br><br></td></tr></table><br>
<a name="1000592"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sqr(4)/Sqr(4)=1<br>4/4=1<br><br>hmmm<br><br>If Sqr(9)&lt;Sqr(4) then<br>If 3&lt;2 then <br><br></td></tr></table><br>
<a name="1000635"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> sqr(4)/sqr(2) =  irrational number thats not 2 lol<br>4/2 = 2<br><br>sure this works<br><br>If Sqr(9)&lt;Sqr(4) then<br>If 3&lt;2 then <br><br>but then you must take the sqr eventually because you are taking a difference in lengths and dividing dx by that dist or something... hmmmm<br><br>sqr(25) = distance<br>4 and 3 are the x and y components of said vector<br>the following makes said vector length of 1 by dividing the vector x and y by the vector length<br><br>4/sqr(25) = 4/5<br>3/sqr(25) = 3/5<br><br>now for without the sqr, your way I belive<br><br>4/(25*.25) = 4/6.25 close but not quite right<br>3/(25*.25) = 3/6.25 again, close but no cigar :/<br>the bigger the constraint lengths are the worse the error and more unstable it is <br><br></td></tr></table><br>
<a name="1000862"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmmm...<br><br>Ya maybe I just got lucky there... or perhaps there's a balancing act to be done here between exactness and speed which is quite often done... but there's no denying that it works as it is, but the question is... would that come back to haunt you later? <br><br></td></tr></table><br>
<a name="1008419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Demon magic, that's what it is.<br><br>Good tutorial :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
