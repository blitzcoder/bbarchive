<!DOCTYPE html><html lang="en" ><head ><title >Best collisions system?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Best collisions system?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Best collisions system?</a><br><br>
<a name="1148998"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> What would be the best method or collision system that you can program in Blitz3d? No DLLs or physics engines (too expensive and unpredictable), just with Blitz3d. <br><br></td></tr></table><br>
<a name="1149000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> too expensive and unpredictable <br></div><br><br>...? Please be willing to hold an open mind and do some research or you'll never get anywhere. This comment is untrue and, in fact, silly.<br><br>ColDet is the best in my experience. It requires you to use a DLL. <i>Grow up</i> and deal with it. It is free and rock-solid.<br><br>I do not know of any especially good Blitz-code collision systems, mainly because there's no great incentive for anyone to write one: it's quite hard to do well (and collisions are the sort of thing you really want to optimise hard). StevieG's game "Polymaniacs" used - at least the last time I played a demo - a full physics engine implemented purely in B3D, <i>but</i> it just used native collisions behind-the-scenes and had the same limitations (dynamic objects had to be made out of groups of spheres).<br><br>What problem are you trying to solve that is too difficult to handle with the native collision system? <br><br></td></tr></table><br>
<a name="1149028"></a>

<a name="1149029"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the totally mature answer. It's sad how people can get offended by something so minor. I'll take your advice,since I was unaware of the DLL you suggested, but you need to think before you write and purposly try to offend someone. I want you to think about that.<br><br>Good day.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1149037"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Thanks for the totally mature answer. It's sad how people can get offended by something so minor. I'll take your advice,since I was unaware of the DLL you suggested, but you need to think before you write and purposly try to offend someone. I want you to think about that.<br><br>Good day. <br></div><br><br>OK, before you were being silly, but this is an unacceptable response. Don't expect further help if you're going to take this ridiculous attitude.<br><br><i>Grow. Up.</i> <br><br></td></tr></table><br>
<a name="1149039"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you cut it with the Grow Up? The irony is killing me. As for an unacceptable response, YOU are the one who started to get insulting. If you were as mature as you make yourself out to be, you would have simply said that you disagreed with my opinion on DLLs. You didn't have to act like a little kid that had his favorite superhero talked badly about or something.<br><br>You are indeed the one that needs to grow up. <br><br></td></tr></table><br>
<a name="1149062"></a>

<a name="1149063"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> TaGames&gt;&gt;<br>From my tests so far, with Blitz3d you can have/detect collisions between :<br>-&gt;moving collider sphere vs static collider mesh (low tris is better)<br>-&gt;moving collider sphere vs moving collider sphere<br><br>As Yasha explained, if you want to have/detect collisions between 2 moving entities, you need to use one or several colliders sphere on them.<br><br>When there is only one moving collider sphere against one static collider mesh or against one moving collider sphere, the collisions calculations and reponses behave correctly because you can set the collider sphere as the parent of the entity. (you move the collider)<br><br>However when you have to use several colliders sphere to create an approximate collider around the mesh, there can be some errors because you have to set the colliders sphere as childs of the entity and to use ResetEntity() after a collision occurs in order to be able to reposition each collider sphere at their correct position/orientation. (you move the entity)<br>This can provoke errors because when you use ResetEntity() the collision response is off during one frame.<br><br>I have found that when using several colliders sphere as childs of a mesh, it is better to use the collision response "Stop" and then to reposition the entity and the others colliders sphere with the help of TFormPoint().<br><br><br><br>Yasha&gt;&gt;What kinds of collisions have you managed to do with Coldet ?<br>I'm especially curious about the possible shapes for a moving collider vs another moving collider and also about the collisions responses.<br><br><br><br>Does any of you have the NuclearGlory dll or source for collisions ? I haven't found a link where to download it.<br>See : <a href="http://blitzbasic.com/Community/posts.php?topic=31208#332756" target="_blank">http://blitzbasic.com/Community/posts.php?topic=31208#332756</a><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1149080"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've not tested it beyond the demo but blitzbullet seems solid, fast and very feature rich.<br><br>TBH with any kinda modern game you are gonna have to go beyond whats realistically possible with native B3D code, JVODE seems a fairly solid physics engine to although there are some random crashes with it in extensive use. Neither of these are free tho.<br><br>Coldet does seem pretty popular and reputedly robust tho I've not tried it myself. <br><br></td></tr></table><br>
<a name="1149116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks you Rroff and RemiD. I'm now convinced that DLL are not bad and can really aid when programming. No need to insult or be offended. Now i've chanced my mind on DLLS. I find them to be quite usefull. <br><br></td></tr></table><br>
<a name="1149147"></a>

<a name="1149148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> some time ago i tested a "dynamic collision system" made by Simon Harrison, all b3d code, wich has it's limitation but gives some interesting reults, depending on what are you trying to do it could has a chance.<br><br>undubtly, a physics engine is better, but i recall this code just in case.<br><br>include file : "dcol_lib.bb"<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Dynamic collision lib by Simon Harrison (si@...)

; You are free to use this source code how you like, however a credit in any programs that use it would be appreciated.
; Feel free to email me any questions you might have about the code, however please don't necessarily expect a reply.

; Limitations:
; Only works with spheres as source entities
; Only works if the source entity is colliding with one dynamic entity at once

; Functions:
; DCO_SetPair(src_ent,des_ent,src_type,des_type,src_rad=1.0)
; DCO_UpdateA()
; DCO_UpdateB()
; DCO_EntityCollided()
; DCO_CollisionNX()
; DCO_CollisionNY()
; DCO_CollisionNZ()

; * See included example for demonstration of system.

Global DCO_pair_pos
Global DCO_ent
Global DCO_nx#
Global DCO_ny#
Global DCO_nz#

Type DCO_pair

	Field src_ent,src_col,src_type,src_rad
	Field des_ent,des_col,des_type
	
End Type

Function DCO_SetPair(src_ent,des_ent,src_type,des_type,src_rad=1.0)

	c.DCO_pair=New DCO_pair
	
	c\src_ent=src_ent
	c\src_type=src_type
	c\src_rad=src_rad
	
	c\des_ent=des_ent
	c\des_type=des_type
	
	c\src_col=CreatePivot() : EntityRadius c\src_col,src_rad
	c\des_col=CopyEntity(des_ent)
	EntityAlpha c\des_col,0
	
	DCO_pair_pos=DCO_pair_pos+(MeshWidth(c\des_col)*2)
	DCO_pair_pos=DCO_pair_pos+1000
	PositionEntity c\des_col,DCO_pair_pos,DCO_pair_pos,0
	
	EntityType c\src_col,src_type
	EntityType c\des_col,des_type
	
	ResetEntity c\src_col
	ResetEntity c\des_col
	
End Function

Function DCO_UpdateA()

	Local dx#,dy#,dz#,pivo,pivv

	For c.DCO_pair=Each DCO_pair

		dx#=EntityX#(c\src_ent)-EntityX#(c\des_ent)
		dy#=EntityY#(c\src_ent)-EntityY#(c\des_ent)
		dz#=EntityZ#(c\src_ent)-EntityZ#(c\des_ent)

		pivo=CreatePivot()
		pivv=CreatePivot(pivo)
		
		PositionEntity pivo,EntityX#(c\des_col),EntityY#(c\des_col),EntityZ#(c\des_col)
		
		RotateEntity pivo,0,0,0
		
		PositionEntity pivv,dx#,dy#,dz#,False

		RotateEntity pivo,-EntityPitch#(c\des_ent),-EntityYaw#(c\des_ent),-EntityRoll#(c\des_ent)

		PositionEntity c\src_col,EntityX#(pivv,True),EntityY#(pivv,True),EntityZ#(pivv,True)
		
		FreeEntity pivo
		
	Next

End Function

Function DCO_UpdateB()

	Local col,dx#,dy#,dz#,dx2#,dy2#,dz2#,ddx#=0,ddy#=0,ddz#=0,pivo,pivv,pivn
	
	DCO_ent=0
	For c.DCO_pair=Each DCO_pair
				
		col=EntityCollided(c\src_col,c\des_type)
		
		If col=c\des_col
	
			DCO_ent=c\des_ent
	
			dx#=EntityX#(c\src_ent)-EntityX#(c\des_ent)
			dy#=EntityY#(c\src_ent)-EntityY#(c\des_ent)
			dz#=EntityZ#(c\src_ent)-EntityZ#(c\des_ent)
		
			dx2#=EntityX#(c\src_col)-EntityX#(c\des_col)
			dy2#=EntityY#(c\src_col)-EntityY#(c\des_col)
			dz2#=EntityZ#(c\src_col)-EntityZ#(c\des_col)
	
			pivo=CreatePivot()
			pivv=CreatePivot(pivo)
			pivn=CreatePivot(pivo) ; piv used to translate collsion normals
			
			PositionEntity pivo,0,0,0
	
			RotateEntity pivo,-EntityPitch#(c\des_ent),-EntityYaw#(c\des_ent),-EntityRoll#(c\des_ent)
			
			PositionEntity pivv,dx2#,dy2#,dz2#,True
			PositionEntity pivn,CollisionNX#(c\src_col,1),CollisionNY#(c\src_col,1),CollisionNZ#(c\src_col,1),True
			
			RotateEntity pivo,0,0,0
			
			; platform normals
			DCO_nx#=EntityX#(pivn)
			DCO_ny#=EntityY#(pivn)
			DCO_nz#=EntityZ#(pivn)
			
			dx2#=EntityX#(pivv)
			dy2#=EntityY#(pivv)
			dz2#=EntityZ#(pivv)
	
			ddx#=dx2#-dx#
			ddy#=dy2#-dy#
			ddz#=dz2#-dz#
							
			FreeEntity pivo
		
			TranslateEntity c\src_ent,ddx#,ddy#,ddz#
		
			;Exit
		
		EndIf
				
	Next

End Function

Function DCO_EntityCollided()

	Return DCO_ent

End Function

Function DCO_CollisionNX#()

	Return DCO_nx#

End Function

Function DCO_CollisionNY#()

	Return DCO_ny#

End Function

Function DCO_CollisionNZ#()

	Return DCO_nz#

End Function
</textarea><br><br>test program (made by me (mostly based on the original demo))<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Dynamic Collisions Example
; --------------------------
; based on the test program made by Simon Harrison
; modified by Juan Ignacio Odriozola (Charrua)

Include "dcol_lib.bb" ; must be used at start of program

Graphics3D 640,480,0,2
SetBuffer BackBuffer()

Type platfrm
	Field entidad	;entity
End Type


cam=CreateCamera() : PositionEntity cam,0,15,-10 : RotateEntity cam,25,0,0
light=CreateLight()

; Create source entity
Global PlayerRadius# = 1.0
player=CreateSphere() : EntityColor player,0,0,255 : PositionEntity player,0,5,0
guide=CreateCube(player) : EntityColor guide,0,255,255 : ScaleEntity guide,.1,.1,1 : PositionEntity guide,0,.8,.3


; Give sphere a collision type for collisions with non-dynamic objects, i.e. the ground in this case
EntityType player,1 : EntityRadius player,1

room = CreateCube() : ScaleEntity room, 20,20,20 : PositionEntity room, 0,0,10
FlipMesh room
EntityType room,2

s=32
roomTexture=CreateTexture(s,s)
ClsColor 0,200,80
Cls

Color 255,255,255

Rect 0,0,s/2,s/2,1
Rect s/2,s/2,s,s,1

CopyRect 0,0,s,s,0,0,BackBuffer(),TextureBuffer(roomTexture)
ScaleTexture roomTexture,.1,.1

EntityTexture room,roomTexture,0,0

ground = CreatePlane() : EntityType ground,2 : EntityColor ground,0,0,128: EntityAlpha ground,0.8
Mirror=CreateMirror() 


Body1 = CreateCube() : EntityColor Body1,200,200,0 : ScaleEntity Body1,2,1,10 : PositionEntity Body1,-10,10,20
EntityType Body1,2

Body2 = CreateCube() : EntityColor Body2,200,0,200 : ScaleEntity Body2,4,.1,6 : PositionEntity Body2,10,3,18
RotateEntity Body2,-30,0,0
EntityType Body2,2




; NOW THE DYNAMIC STUFF - *** Important comments highlighted by stars ***

; Create first destination entity - platform 1
platform1=CreateCylinder(16) : ScaleEntity platform1,2,.2,2 : EntityColor platform1,255,255,0
PositionEntity platform1,-10,0,8
EntityPickMode platform1,2
plat.platfrm = New platfrm
plat\entidad = platform1


; Create second destination entity - platform 2
platform2=CreateCube() : ScaleEntity platform2,4,1,4 : EntityColor platform2,255,0,0
PositionEntity platform2,10,1,3
EntityPickMode platform2,2
plat.platfrm = New platfrm
plat\entidad = platform2

;another one
platform3=CreateCube() : ScaleEntity platform3,5,.2,5 : EntityColor platform3,0,0,255
PositionEntity platform3,-4,6,28
EntityPickMode platform3,2
plat.platfrm = New platfrm
plat\entidad = platform3

src_type=3 ; assign a collision type for source collision entity (sphere)
des_type=4 ; assign a collision type for destination collision entity (platforms)

; *** Set dynamic collision pairs ***
DCO_SetPair(player,platform1,src_type,des_type,PlayerRadius#) ; parameters - src_entity,des_entity,src_type,des_type,src_radius=1.0
DCO_SetPair(player,platform2,src_type,des_type,PlayerRadius#)
DCO_SetPair(player,platform3,src_type,des_type,PlayerRadius#)

;parar = False


; Set up normal sliding collisions between sphere and plane
;tipo1 = jugador, tipo 2 = sala, esto es para que el jugador choque contra las paredes y el piso
Collisions 1,2,2,2
; *** Enable collisions for dynamic pairs ***

Collisions src_type,des_type,2,2

Global txt1$,txt2$,txt3$
Global estoy=False
Global pvt=CreatePivot()

While Not KeyDown(1)
 
	sph_z#=0
	dy# = 0
	If KeyDown(203)=True Then dy =2
	If KeyDown(205)=True Then dy =-2
	If KeyDown(208)=True Then sph_z=-.4
	If KeyDown(200)=True Then sph_z=.4

	; Make our platforms dynamic - move them!
	If Not EstoyDebajoPlataforma(player) Then 
		MoveEntity platform1,0,Sin(angle#)*0.1,0
		angle#=angle#+1
	End If

	TurnEntity platform2,0,1,0
	
	TranslateEntity platform2,0,0,Sin(angle#)*0.1
	
	MoveEntity platform3,Sin(angle1#)*0.2,0,0 : angle1#=angle1#+1
	
	
	If EstoySobrePlataforma(player) Then
	;	;esto es un parche y no se por que se acelera...
		sph_z = sph_z/5
	Else
		DCO_UpdateA()
		UpdateWorld 0
		DCO_UpdateB()
		MoveEntity player,0,-.3,0
	EndIf

	MoveEntity player,0,sph_y,sph_z
	TurnEntity player,0,dy,0
	
	; *** Usual UpdateWorld call ***
	UpdateWorld
	
	; *** For best results, try experimenting with the order of the above four function calls ***
	
	RenderWorld
	
	; Output dynamic collision information - the dynamic collision system works best if you use these values to implement
	; proper bouncing physics between source entity and destination entity
	Text 0,  0,"EntityCollided: "+DCO_EntityCollided()
	Text 0, 20,"CollisionNX: "+DCO_CollisionNX#()
	Text 0, 40,"CollisionNY: "+DCO_CollisionNY#()
	Text 0, 60,"CollisionNZ: "+DCO_CollisionNZ#()
	
	Flip True

Wend


Function EstoySobrePlataforma(yo)	; player is over a platform

	algo = LinePick(EntityX(yo,True),EntityY(yo,True),EntityZ(yo,True),0,-PlayerRadius#,0)	;linea hacia abajo
	si = False

	If algo Then
		For plat.platfrm = Each platfrm
			If algo = plat\entidad Then
				EntityParent yo,plat\entidad
				si=True
			End If
		Next
	End If

	If Not si Then EntityParent yo,0
		
	Return si
	
End Function

Function EstoyDebajoPlataforma(yo)	; player is under a platform

	
	algo = LinePick(EntityX(yo,True),EntityY(yo,True),EntityZ(yo,True),0,+PlayerRadius#,0)	;linea hacia arriba
	si = False

	If algo Then
		For plat.platfrm = Each platfrm
			If algo = plat\entidad Then
				si=True
			End If
		Next
	End If

	
	Return si
	
End Function
</textarea><br><br>just use arrows keys to move the player<br><br>regards<br><br>Juan<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1149159"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Yasha&gt;&gt;What kinds of collisions have you managed to do with Coldet ?<br>I'm especially curious about the possible shapes for a moving collider vs another moving collider and also about the collisions responses. <br></div><br><br>The main use I have had for ColDet was in a simulation involving a C-shaped arm with four degrees of freedom (all the rotational axes, also moving in Z), twisting and turning around a floating worktop with three degrees of freedom (linear movement in three axes). Both using mesh-based polygonal colliders rather than geometric ones. I tested it pretty hard and had <i>no</i> problems with either stability or performance, both directly controlling the objects to ram them into each other, and with a solver trying to handle scripted animation targets. I did construct some more complex scenes as well, but didn't really stress-test them as much.<br><br>In other words, I am confident that it can handle any dynamic object-object collisions very easily. <i>However</i>, there is a catch when it comes to responses: ColDet doesn't include them - it's a <i>detection</i> library, not a response library. This means no support for sliding collisions, and very limited support for stop-collisions. For my purposes this was no problem as I only needed stop-collisions, and could guarantee than my objects moved slowly enough that they wouldn't actually miss a collision by moving straight through the target object. If however you need a detailed collision response like sliding, or to know when one object would have completely passed through another one, ColDet will not work for you - it really only detects intersections and has no built-in concept of movement. This is what enables it to be so ridiculously fast compared to libraries that do include those things, like B3D itself.<br><br>To help integrate it with more traditional code, I made a modified version of the ColDet.bb file:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Slightly modified version of EliasT's wrapper
; - changed the function names to be tidier
; - added new functions to imitate B3D collision system
; - changed ColDet_Start and ColDet_End to create and free collider list

;------------------------------------------------------------------------
;COLLISION POINT BANK
Global col_point=CreateBank(3*4)

;COLLIDING TRIANGLES BANK
Global col_verts1=CreateBank(9*4)
Global col_verts2=CreateBank(9*4)

;COLLIDING TRIANGLES Index BANK
Global col_tri1=CreateBank(1*4)
Global col_tri2=CreateBank(1*4)


;RAY COLLISION BANKS
Global ray_origin=CreateBank(3*4)
Global ray_direction=CreateBank(3*4)

;sphere centers
Global col_center1=CreateBank(3*4)
Global col_center2=CreateBank(3*4)


;matrix
Global col_dummy_pivot
Global col_matrix = CreateBank(16*4)

;arrays for nx,ny,nz calculations
Dim cnrx1#(0),cnry1#(0),cnrz1#(0)
Dim cnrx2#(0),cnry2#(0),cnrz2#(0)
;------------------------------------------------------------------------






;NEW FUNCTIONS-----------------------------------------------------------


Type Collider
	Field b3d_entity
	Field coldet_entity
	Field hasMoved
	Field colType
	Field pickMode
End Type

Function FreeCollider(c.Collider)
	ColDet_Free_Model c\coldet_entity
	Delete c
End Function


Type CollisionTypePair
	Field t1, t2
End Type


;------------------------------------------------------------------------
;EntityType replacement (creates ColDet meshes and adds to list)
;------------------------------------------------------------------------
Function ColDet_ListAdd(entity, colType)
	Local c.Collider = New Collider
	c\b3d_entity = entity
	c\coldet_entity = ColDet_Make(entity, 1)
	c\colType = colType
	
	ColDet_SetMatrix(c\b3d_entity, c\coldet_entity)
End Function


;------------------------------------------------------------------------
;Remove entity from collision list and delete colmesh
;------------------------------------------------------------------------
Function ColDet_ListRemove(entity)
	Local c.Collider
	For c = Each Collider
		If c\b3d_entity = entity
			FreeCollider c
			Exit
		EndIf
	Next
End Function


;------------------------------------------------------------------------
;Create a dedicated (non-rendering) collider entity (convenience)
;------------------------------------------------------------------------
Function ColDet_CreateCollider(entity, colType)
	ColDet_ListAdd entity, colType
	HideEntity entity
End Function


;------------------------------------------------------------------------
;Create a collision pair
;------------------------------------------------------------------------
Function ColDet_SetCollisionPair(t1, t2)
	Local p.CollisionTypePair = New CollisionTypePair
	p\t1 = t1
	p\t2 = t2
End Function


;------------------------------------------------------------------------
;Check if a pair of collision types have a response set
;------------------------------------------------------------------------
Function ColDet_TypesCollide(t1, t2)
	Local p.CollisionTypePair
	For p = Each CollisionTypePair
		If (p\t1 = t1 And p\t2 = t2) Or (p\t1 = t2 And p\t2 = t1) Then Return True
	Next
End Function


;------------------------------------------------------------------------
;Get the ColDet mesh corresponding to a Blitz entity
;------------------------------------------------------------------------
Function ColDet_GetColDetEntity(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	Return c\coldet_entity
End Function


;------------------------------------------------------------------------
;Get the ColDet collision type from a Blitz entity handle
;------------------------------------------------------------------------
Function ColDet_GetColDetType(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	Return c\colType
End Function


;------------------------------------------------------------------------
;Get the ColDet pick mode from a Blitz entity handle
;------------------------------------------------------------------------
Function ColDet_GetColDetPickmode(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	Return c\pickMode
End Function


;------------------------------------------------------------------------
;Set whether an entity is pickable
;------------------------------------------------------------------------
Function ColDet_SetColDetPickMode(entity, mode)
	Local c.Collider = ColDet_GetCollider(entity)
	c\pickMode = mode
End Function


;------------------------------------------------------------------------
;Get the Collider associated with a Blitz entity handle
;------------------------------------------------------------------------
Function ColDet_GetCollider.Collider(entity)
	Local c.Collider
	For c = Each Collider
		If c\b3d_entity = entity Then Return c
	Next
End Function


;------------------------------------------------------------------------
;CameraPick replacement
;------------------------------------------------------------------------
Function ColDet_CameraPick(camera, viewX, viewY, viewW, viewH)
	Local x#, y#, picked, zdiff# = 1000000;, ptr;, entity, cEntity
	
	x = (viewX - viewW / 2)
	y = - (viewY - viewH / 2)
	TFormPoint x, y, viewW / 2, camera, 0
	PokeFloat ray_origin, 0, EntityX(camera, 1)
	PokeFloat ray_origin, 4, EntityY(camera, 1)
	PokeFloat ray_origin, 8, EntityZ(camera, 1)
	PokeFloat ray_direction, 0, TFormedX()
	PokeFloat ray_direction, 4, TFormedY()
	PokeFloat ray_direction, 8, TFormedZ()
	
	Local c.Collider
	For c = Each Collider
		If c\pickMode		;Entity is pickable
			If MemoryFastPeekByte(c\b3d_entity + $18)		;Entity is visible
				ColDet_SetMatrix c\b3d_entity, c\coldet_entity
				If ColDet_Ray_Collision2(c\coldet_entity, ray_origin, ray_direction)
					ColDet_Collision_Point c\coldet_entity, 0
					TFormPoint PeekFloat(col_point, 0), PeekFloat(col_point, 4), PeekFloat(col_point, 8), 0, camera
					If TFormedZ() &lt; zdiff
						zdiff = TFormedZ()
						picked = c\b3d_entity
					EndIf
				EndIf
			EndIf
		EndIf
	Next
	
	Return picked
End Function


;------------------------------------------------------------------------
;Move an entity unless it collided
;------------------------------------------------------------------------
Function ColDet_MoveEntity(entity, x#, y#, z#)
	Local oldX#, oldY#, oldZ#
	
	oldX = EntityX(entity)
	oldY = EntityY(entity)
	oldZ = EntityZ(entity)
	
	MoveEntity entity, x, y, z
	
	ColDet_ResetAll
	If ColDet_EntityCollided(entity)
		PositionEntity entity, oldX, oldY, oldZ
		ColDet_ResetAll
	EndIf
End Function


;------------------------------------------------------------------------
;Turn an entity unless it collided
;------------------------------------------------------------------------
Function ColDet_TurnEntity(entity, pitch#, yaw#, roll#)
	Local oldP#, oldY#, oldR#, cEntity
	
	oldP = EntityPitch(entity)
	oldY = EntityYaw(entity)
	oldR = EntityRoll(entity)
	cEntity = ColDet_GetColDetEntity(entity)
	
	TurnEntity entity, pitch, yaw, roll
	
	ColDet_ResetAll
	If ColDet_EntityCollided(entity)
		RotateEntity entity, oldP, oldY, oldR
		ColDet_ResetAll
	EndIf
End Function


;------------------------------------------------------------------------
;EntityCollided replacement
;------------------------------------------------------------------------
Function ColDet_EntityCollided(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	
	Local comp.Collider
	For comp = Each Collider
		If comp &lt;&gt; c
			If ColDet_TypesCollide(c\colType, comp\colType)
				If ColDet_Collision(c\coldet_entity, comp\coldet_entity) Then Return True
			EndIf
		EndIf
	Next
End Function


;------------------------------------------------------------------------
;Update the transformation matrices for all ColDet meshes
;------------------------------------------------------------------------
Function ColDet_ResetAll()
	Local c.Collider
	For c = Each Collider
		ColDet_SetMatrix c\b3d_entity, c\coldet_entity
	Next
End Function




;COLDET FUNCTIONS--------------------------------------------------------





;------------------------------------------------------------------------
;Start
;------------------------------------------------------------------------
Function ColDet_Start()
	
	col_dummy_pivot = CreatePivot()
	PokeFloat col_matrix, 12,0
	PokeFloat col_matrix, 28,0
	PokeFloat col_matrix, 44,0
	PokeFloat col_matrix, 60,1
	
	Dim cnrx1#(1),cnry1#(1),cnrz1#(1)
	Dim cnrx2#(1),cnry2#(1),cnrz2#(1)
	
End Function


;------------------------------------------------------------------------
;End
;------------------------------------------------------------------------
Function ColDet_End()
	
	FreeEntity col_dummy_pivot
	FreeBank col_point
	FreeBank col_verts1
	FreeBank col_verts2
	FreeBank col_tri1
	FreeBank col_tri2
	FreeBank ray_origin
	FreeBank ray_direction
	FreeBank col_center1
	FreeBank col_center2
	FreeBank col_matrix
	
	Dim cnrx1#(0),cnry1#(0),cnrz1#(0)
	Dim cnrx2#(0),cnry2#(0),cnrz2#(0)
	
	Local c.Collider
	For c = Each Collider
		FreeCollider c
	Next
	
End Function






;------------------------------------------------------------------------
;This function creates a coldet compatible model.
;By this we mean that we use the global vertex positions of the model,
;since coldet does not work with scales.

;dynamic=0 the model is static.
;dynamic=1 the model moves and/or rotates.
;------------------------------------------------------------------------

Function ColDet_Make(entity,dynamic)
	
	Local model
	Local cbank,count%
	Local surf,tris,verts
	Local v0%,v1%,v2%,point%
	Local vx#,vy#,vz#
	Local rx#,ry#,rz#
	Local px#,py#,pz#
	
	
	Local surfs=CountSurfaces(entity)
	If surfs=0 Return 0
		
;We want a 0 rotated and 0 positioned object object
;We will return it to it's original state after the coldet model is created
		rx=EntityPitch(entity,1)
		ry=EntityYaw(entity,1)
		rz=EntityRoll(entity,1)
		RotateEntity entity,0,0,0,1
		px=EntityX(entity,1)
		py=EntityY(entity,1)
		pz=EntityZ(entity,1)
		PositionEntity entity,0,0,0,1
		
		For i=1 To surfs
			surf=GetSurface(entity,i)
			tris=tris+CountTriangles(surf)
		Next
		
		
;make the coldet model with triangles=tris and  dynamic= 0 or 1
		
;NOTE: If you not asign the tris number the coldet model
;      will still be constructed. The tris no. assignment 
;      is for faster construction speed of the coldet model.
		
		If dynamic&gt;1 dynamic=1
			If dynamic&lt;0 dynamic=0
				
				model=ColDet_Make_Model(tris,dynamic)
				
				cbank=CreateBank(tris*9*4)
				
				
				count=0
				
				For i=1 To surfs
					surf=GetSurface(entity,i)
					
					For k=0 To CountTriangles(surf)-1
						
						v0=TriangleVertex(surf,k,0)
						v1=TriangleVertex(surf,k,1)
						v2=TriangleVertex(surf,k,2)
						
						vx=VertexX(surf,v0)
						vy=VertexY(surf,v0)
						vz=VertexZ(surf,v0)
						TFormPoint vx,vy,vz,entity,0
						PokeFloat cbank,count+0,TFormedX()
						PokeFloat cbank,count+4,TFormedY()
						PokeFloat cbank,count+8,TFormedZ()
						
						vx=VertexX(surf,v1)
						vy=VertexY(surf,v1)
						vz=VertexZ(surf,v1)
						TFormPoint vx,vy,vz,entity,0
						PokeFloat cbank,count+12,TFormedX()
						PokeFloat cbank,count+16,TFormedY()
						PokeFloat cbank,count+20,TFormedZ()
						
						vx=VertexX(surf,v2)
						vy=VertexY(surf,v2)
						vz=VertexZ(surf,v2)
						TFormPoint vx,vy,vz,entity,0
						PokeFloat cbank,count+24,TFormedX()
						PokeFloat cbank,count+28,TFormedY()
						PokeFloat cbank,count+32,TFormedZ()
						
						count=count+36
						
					Next
					
				Next
				
				
				ColDet_Add_Model(model,cbank,tris*9)
				
				FreeBank cbank
				
				ColDet_Finalize(model)
				
				
;set it back to it's original rotation and position
				RotateEntity entity,rx,ry,rz,1
				PositionEntity entity,px,py,pz,1
				
				ColDet_SetMatrix(entity,model)
				
				
				
				Return model
				
End Function






;------------------------------------------------------------------------
;USE THIS ONLY IF YOU CREATE A COLDET MODEL MANUALLY
;This function just makes an "empty" coldet model and specifies the number of tris
;Use this function against the "coldet_make" function if you want
;to add manually triangles to a coldet model.

;NOTE: If you not asign the tris number the coldet model
;      will still be constructed. The tris no. assignment 
;      is for faster construction speed of the coldet model.
;------------------------------------------------------------------------

Function ColDet_Model_Start(tris=0,dynamic=0)
	If dynamic&gt;1 dynamic=1
		If dynamic&lt;0 dynamic=0
			Return ColDet_Make_Model(tris,dynamic)
End Function




;------------------------------------------------------------------------
;USE THIS ONLY IF YOU CREATE A COLDET MODEL MANUALLY
;Add manually a triangle to the coldet model.
;We pass here also the blitz model to get the global vertex positions.
;We rotate the blitz model to 0,0,0 and back to it's original rotation
;because it could be already rotated.
;------------------------------------------------------------------------

Function ColDet_Add_Tri(b_ent,c_ent,vx1#,vy1#,vz1#,vx2#,vy2#,vz2#,vx3#,vy3#,vz3#)
	
	Local tvx1#,tvy1#,tvz1#
	Local tvx2#,tvy2#,tvz2#
	Local tvx3#,tvy3#,tvz3#
	Local px#,py#,pz#
	Local rx#,ry#,rz#
	
	
	
	rx=EntityPitch(b_ent,1)
	ry=EntityYaw(b_ent,1)
	rz=EntityRoll(b_ent,1)
	px=EntityX(b_ent,1)
	py=EntityY(b_ent,1)
	pz=EntityZ(b_ent,1)
	
;We want a 0 rotated and 0 positioned object object
;We will return it to it's original state after the coldet tri is created
	RotateEntity b_ent,0,0,0,1
	PositionEntity b_ent,0,0,0,1
	
	TFormPoint vx1,vy1,vz1,b_ent,0
	tvx1=TFormedX()
	tvy1=TFormedY()
	tvz1=TFormedZ()
	TFormPoint vx2,vy2,vz2,b_ent,0
	tvx2=TFormedX()
	tvy2=TFormedY()
	tvz2=TFormedZ()
	TFormPoint vx3,vy3,vz3,b_ent,0
	tvx3=TFormedX()
	tvy3=TFormedY()
	tvz3=TFormedZ()
	
	ColDet_AddTri(c_ent,tvx1,tvy1,tvz1,tvx2,tvy2,tvz2,tvx3,tvy3,tvz3)
	
;set it back to it's original rotation and position
	RotateEntity b_ent,rx,ry,rz,1
	PositionEntity b_ent,px,py,pz,1
End Function 


;------------------------------------------------------------------------
;USE THIS ONLY IF YOU CREATE A COLDET MODEL MANUALLY
;Finalize the coldet model and set it's matrix
;------------------------------------------------------------------------

Function ColDet_Model_End(b_ent,c_ent)
	ColDet_Finalize(c_ent)
	ColDet_SetMatrix(b_ent,c_ent)
End Function






;------------------------------------------------------------------------
;This function sets the transformation matrix of the coldet model.
;It is neccesary to call it only when moving and rotating
;a dynamic object.
;For Static objects you only need to call it once.

;b_ent=the blitz entity
;c_ent=the coldet entity pointer !
;------------------------------------------------------------------------

Function ColDet_SetMatrix(b_ent,c_ent)
	
;we use a dummy pivot to get pitch,yaw,roll because coldet doesn't work with scale values
	RotateEntity col_dummy_pivot,EntityPitch(b_ent,1),EntityYaw(b_ent,1),EntityRoll(b_ent,1)
	
	PokeFloat col_matrix, 0,GetMatElement(col_dummy_pivot,0,0)
	PokeFloat col_matrix, 4,GetMatElement(col_dummy_pivot,0,1)
	PokeFloat col_matrix, 8,GetMatElement(col_dummy_pivot,0,2)
	
	PokeFloat col_matrix, 16,GetMatElement(col_dummy_pivot,1,0)
	PokeFloat col_matrix, 20,GetMatElement(col_dummy_pivot,1,1)
	PokeFloat col_matrix, 24,GetMatElement(col_dummy_pivot,1,2)
	
	PokeFloat col_matrix, 32,GetMatElement(col_dummy_pivot,2,0)
	PokeFloat col_matrix, 36,GetMatElement(col_dummy_pivot,2,1)
	PokeFloat col_matrix, 40,GetMatElement(col_dummy_pivot,2,2)
	
	PokeFloat col_matrix, 48,EntityX(b_ent,1)
	PokeFloat col_matrix, 52,EntityY(b_ent,1)
	PokeFloat col_matrix, 56,EntityZ(b_ent,1)
	
	
	ColDet_Set_Matrix(c_ent,col_matrix)
	
End Function











;------------------------------------------------------------------------
;Get collision point for 'this' model.
;g=0 for global coordinates
;g=1 for model's local coordinates
;------------------------------------------------------------------------

Function ColDet_Collision_Point(model,g)
	ColDet_GetCollision_Point(model,col_point,g)
End Function

;and return the x,y,z values by these functions
Function Collision_Point_X#()
	Return PeekFloat (col_point,0)
End Function

Function Collision_Point_Y#()
	Return PeekFloat (col_point,4)
End Function

Function Collision_Point_Z#()
	Return PeekFloat (col_point,8)
End Function






;-------------------------------------------------------------------------------
;This function is actually used to get the colliding triangle normal.
;if calc1=true make precalculations for the first model's colliding tri normals
;if calc2=true make precalculations for the second model's colliding tri normals
;-------------------------------------------------------------------------------

Function ColDet_Colliding_Verts(model,calc1,calc2)
	
	ColDet_GetColliding_Verts(model,col_verts1,col_verts2)
	
	
;v0x=0   , v0y=4   , v0z=8
;v1x=12  , v1y=16  , v1z=20
;v2x=24  , v2y=28  , v2z=32
	
	If calc1=True
		cnrx1(0)=PeekFloat(col_verts1,12)-PeekFloat(col_verts1,0)
		cnry1(0)=PeekFloat(col_verts1,16)-PeekFloat(col_verts1,4)
		cnrz1(0)=PeekFloat(col_verts1,20)-PeekFloat(col_verts1,8)
		
		cnrx1(1)=PeekFloat(col_verts1,24)-PeekFloat(col_verts1,12)
		cnry1(1)=PeekFloat(col_verts1,28)-PeekFloat(col_verts1,16)
		cnrz1(1)=PeekFloat(col_verts1,32)-PeekFloat(col_verts1,20)
	EndIf
	
	If calc2=True
		cnrx2(0)=PeekFloat(col_verts2,12)-PeekFloat(col_verts2,0)
		cnry2(0)=PeekFloat(col_verts2,16)-PeekFloat(col_verts2,4)
		cnrz2(0)=PeekFloat(col_verts2,20)-PeekFloat(col_verts2,8)
		
		cnrx2(1)=PeekFloat(col_verts2,24)-PeekFloat(col_verts2,12)
		cnry2(1)=PeekFloat(col_verts2,28)-PeekFloat(col_verts2,16)
		cnrz2(1)=PeekFloat(col_verts2,32)-PeekFloat(col_verts2,20)
	EndIf
	
End Function



Function Colliding_NX1#()
	Return (cnry1(0)*cnrz1(1))-(cnrz1(0)*cnry1(1))
End Function

Function Colliding_NY1#()
	Return (cnrz1(0)*cnrx1(1))-(cnrx1(0)*cnrz1(1))
End Function

Function Colliding_NZ1#()
	Return (cnrx1(0)*cnry1(1))-(cnry1(0)*cnrx1(1))
End Function




Function Colliding_NX2#()
	Return (cnry2(0)*cnrz2(1))-(cnrz2(0)*cnry2(1))
End Function

Function Colliding_NY2#()
	Return (cnrz2(0)*cnrx2(1))-(cnrx2(0)*cnrz2(1))
End Function

Function Colliding_NZ2#()
	Return (cnrx2(0)*cnry2(1))-(cnry2(0)*cnrx2(1))
End Function



;-----------------------------------------------------------------------------
;Get colliding triangle for 'this' model.
;If this=1 then the triangle of the 'other' colliding object will be returned.
;-----------------------------------------------------------------------------

Function ColDet_Colliding_Tri(model,this=0)
	ColDet_GetColliding_Tris(model,col_tri1,col_tri2)
	
	If this=0
		Return PeekInt(col_tri1,0)
	Else
		Return PeekInt(col_tri2,0)
	EndIf
	
End Function

;~IDEal Editor Parameters:
;~F#2D#35#3B#43#50#5E#67#71#7C#85#8E#97#A0#AB#D0#E4#F9#10A#11D#12E
;~F#154#1CE#1DF#20F#223#24D#252#256#25A#269#28A#28E#292#299#29D#2A1#2AC
;~C#Blitz3D</textarea><br><br>It's a B3D-like interface that adds the following commands:<br><br>ColDet_ListAdd(entity, colType): Add a B3D entity to the ColDet system<br>ColDet_ListRemove(entity): Remove a B3D entity from the ColDet system<br>ColDet_CreateCollider(entity, colType): Add a non-rendering B3D entity as a collider<br>ColDet_SetCollisionPair(t1, t2): Define collision detection between two B3D-style collision types (i.e. arbitrary numbers)<br>ColDet_TypesCollide(t1, t2): Check if two types have a response set<br>ColDet_GetColDetEntity(entity): Get the ColDet internal collision object attached to a B3D entity (not normally needed)<br>ColDet_GetColDetType(entity): Check the collision type of an entity<br>ColDet_GetColDetPickmode(entity): Check if an entity is pickable<br>ColDet_SetColDetPickMode(entity, mode): Set whether an entity is pickable<br>ColDet_GetCollider.Collider(entity): Get the collider associated with an entity (internal, not normally needed)<br>ColDet_CameraPick(camera, viewX, viewY, viewW, viewH): CameraPick a ColDet-enabled and pickable entity<br>ColDet_MoveEntity(entity, x#, y#, z#): Move an entity, subject to ColDet collision<br>ColDet_TurnEntity(entity, pitch#, yaw#, roll#): Turn an entity, subject to ColDet collision<br>ColDet_EntityCollided(entity): Test if an entity is currently involved in a collision (not needed if using the above two functions)<br>ColDet_ResetAll(): Update all collision entities to wherever their Blitz entities are right now, not colliding on the way (like ResetEntity)<br><br>As long as you use ColDet_Start and ColDet_End as normal (to initialise and deinitialise the engine), you can avoid using ColDet's own commands.<br><br>Not however that this thin wrapper is 1. subject to the same limitations as ColDet ("collisions" are actually intersections, and if one is the result of movement, the movement is just undone rather than partially-completed; moving all the way through a target will therefore not register), and 2. highly inefficient for more than a small number of colliders, as it involves a lot of list iterations (O(n^2) - for a large number of collision check this will make it significantly slower than B3D's builtin system). <br><br></td></tr></table><br>
<a name="1149173"></a>

<a name="1149180"></a>

<a name="1149181"></a>

<a name="1149182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rroff&gt;&gt;Blitzbullet seems to have interesting functionalities indeed, i will try it. Thanks<br><br><br><br>TaGames&gt;&gt;It depends on what you want to achieve, but Blitz3d collisions works well if you don't need physics behaviors.<br><br><br><br>Charrua&gt;&gt;It shows that it is possible to push a collider sphere with a collider box in Blitz3d... I have to study this code. Thanks.<br><br><br><br><div class="quote"> <br>In other words, I am confident that it can handle any dynamic object-object collisions very easily. However, there is a catch when it comes to responses: ColDet doesn't include them - it's a detection library, not a response library. This means no support for sliding collisions, and very limited support for stop-collisions.<br> <br></div><br><br>Yasha&gt;&gt;<br>Ok i understand what you mean. That's not useful for my current program. I need a kind of collider capsule which has a sliding reponse (for characters) I try to achieve this effect with several colliders sphere.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
