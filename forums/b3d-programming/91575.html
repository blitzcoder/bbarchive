<!DOCTYPE html><html lang="en" ><head ><title >Asteroid Fields</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Asteroid Fields</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Asteroid Fields</a><br><br>
<a name="1042005"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wonder how to create an asteroid field like in the game Freelancer. Watch <a href="http://www.xfire.com/video/258de1/" target="_blank">this video</a> to see what I mean.<br><br>I would like to create<br><br>- an asteroid belt like in our solar system (like a torus)<br>- ice rings around planets (like a flat disc around saturn, look at <a href="http://www.youtube.com/watch?v=mqyIxFHZtR8" target="_blank">this video</a>)<br>- local asteroid/debris clouds (like a distorted sphere)<br>- and the asteroids should be solid, moving, turning<br><br>Looks easy with only a few objects but isn't with thousands and very large fields. How would you realise this? Suggestions from easy to complex are welcome...<br><br>A perfect demo of planetary rings is <a href="http://www.fl-tw.com/Infinity/Media/Videos/asteroids_field.avi" target="_blank">this video</a> from the Infinity Project. <br><br></td></tr></table><br>
<a name="1042014"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >andy_mc</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I really want to play the infinity project, it seems like it's taking forever to come out!!!!<br><br>Maybe frontier should buy the engine and use it to release elite 4 <br><br></td></tr></table><br>
<a name="1042015"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> As long as the title doesn't mean we have to wait infinite for the release? ;-) <br><br></td></tr></table><br>
<a name="1042026"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe you could use a SceneGraph-like structure to hide/show objects in your scene, and use LOD. I would look into a combination of sprites and meshes to create the scene. <br>For instance to create a ring around a planet. You could use a big sprite to create it's far-away view, and use meshes to create the single asteroids when getting closer. <br><br></td></tr></table><br>
<a name="1042065"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You'd have to use a single surface system for far away objects using either very low poly versions of the model or billboards, low LOD poly model for the individual astroids at a medium distance and high poly model for close up.<br><br>For belts/rings I'd probably use an image where each pixel value is a seed for a predetermined debris pattern and build that pattern when close and display the belt texture from a distance. <br><br></td></tr></table><br>
<a name="1042075"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd make a mesh that's hidden from view. Then, I'd iterate through a loop along the lines of this:<br><pre class=code>For i = 0 To NumberOfAsteroidsPerTriangle-1
	For s = 0 To CountSurfaces(AsteroidPlacementMesh)-1
		surf = GetSurface(AsteroidPlacementMesh,s)
		For tri = 0 To CountTriangles(surf)-1
			Create asteroid here and set To autofade
			Position asteroid at random position on triangle
		Next
	Next
Next</pre>For the positioning of the asteroids I would use trilinear interpolation. First I would find a point at a random position between the triangle's first and second vertex. Then, I'd find a random position between that position and the third vertex. Also, I would probably move the asteroids randomly a little along the triangle's normal so it doesn't look like they're all sitting on a flat surface. For the creation of the asteroids, I'd just create a sphere and move each of its vertices by a small, random amount towards or away from the center of the sphere to make it look lumpy and irregular. Then, give them random scales. Also, I might delete asteroids that are colliding with each other, just to be safe. The autofading would prevent too many polygons due to the asteroids. You also might create a model of the surface from far away to keep the asteroids consistent. I hope this helps! <br><br></td></tr></table><br>
<a name="1042153"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm for better understanding I'll post my procedural testbed, perhaps somebody can add some basic code to it that my project gets a little bit "enlightened". I'm really stuck here. The suggestion with the scenegraph makes sense, but the ring contains millions to billions of debris, how must I design the system that only a few (ex. 1000) local debris gets spawned when you enter the rings and continue spawning while flying through the rings? I think this can only be done by procedural noise but I absolutely don't know how to start...<br><br>The ring system is a single mesh with a 1 pixel wide noise texture applied to it using UV coordinates from center to outside, very simple but looks really cool. I tried to polish it with procedural detail textures but it is hard to apply these to the circular ring structure, perhaps with a second UV set or a new surface, but this has priority 999 by now.<br><br>Now here is my simple procedural Saturn planet, if you want you can add my Milkyway Panorama like in the screenshot (see signature) and uncomment the line before the main loop - but the code runs without any external media.<br><br>Movement with mouse/arrows, SHIFT=10x speed, SPACE=Wireframe, 1-3 = show/hide special FX.<br><br><img src="http://www.christianhart.de/bb/asteroids/saturn.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Procedural Saturn"

Graphics3D 800,600,32,2

Dim P%(512),GRAYD#(512)

Const SEED_PLANET%=8		; seed for procedural planet texture
Const SEED_RING%=6			; seed for procedural ring texture
Const SPEED#=0.01			; move speed
Const SCALE#=1.0			; planet scale
Const SEGMENTS%=32			; sphere detail
Const PR%=255				; planet colors RED
Const PG%=192				; planet colors GREEN
Const PB%=128				; planet colors BLUE

Global WIDTH%=GraphicsWidth()
Global HEIGHT%=GraphicsHeight()
Global TIMER%=CreateTimer(60)

Global CAM%,PLANET%,PLANETTEX%,RING%,RINGTEX%,LIGHT,GLOW%,SHADER%

InitNoise()

; Planet
PLANET=CreateSphere(SEGMENTS)
ScaleEntity PLANET,SCALE,SCALE,SCALE
EntityShininess PLANET,0.1
EntityFX PLANET,2
UpdateVertexColors(PLANET,PR,PG,PB,1)
PLANETTEX=CreateRingTexture(1024,SEED_PLANET,1,False)
TextureBlend PLANETTEX,2
RotateTexture PLANETTEX,90
EntityTexture PLANET,PLANETTEX

; Planetary Ring
RING=CreateEllipse(PLANET,1.2,3.0)
RINGTEX=CreateRingTexture(1024,SEED_RING,3,True,"normal",0.95)
EntityTexture RING,RINGTEX
RotateEntity PLANET,5,10,10

; Planet Atmosphere
GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,360,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)
EntityOrder GLOW,1

; Planet Fake Shader
SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.75)

; Light source
LIGHT=CreateLight(1)
RotateEntity LIGHT,0,-90,0
AmbientLight 24,20,16

; Camera
CAM=CreateCamera()
CameraRange CAM,0.001*SCALE,1000*SCALE
MoveEntity CAM,-2*SCALE,0.125*SCALE,-3.5*SCALE
PointEntity CAM,PLANET

MoveMouse WIDTH/2,HEIGHT/2

;Include "milkyway.bb" : MILKYWAY=InitMilkyway(5000,0.5,5,90,500,0,0,0,1,128,192,255,1,0,0,0,1)

;===========================================================================
; main loop
;===========================================================================

While Not KeyHit(1)
	
	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%
	
	; SHIFT = 10x faster cam flight
	If KeyDown(42) Or KeyDown(54) Then multi=10
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; KEYS 1-3 = show/hide special planet FX
	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING
	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW
	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER
	
	; camera movement
	RotateEntity CAM,EntityPitch(CAM)+(MouseYSpeed()/l),EntityYaw(CAM)-(MouseXSpeed()/l),0
	MoveEntity CAM,(KeyDown(205)-KeyDown(203))*multi*SPEED,0,(KeyDown(200)-KeyDown(208))*multi*SPEED
	MoveMouse WIDTH/2,HEIGHT/2
	
	; update atmosphere glow according to camera
	UpdateGlow(GLOW,CAM)
	
	RenderWorld
	
	WaitTimer TIMER
	
	Flip 0
	
Wend

End

;===========================================================================
; updates the vertex colors of a mesh
;===========================================================================

Function UpdateVertexColors(mesh%,r%,g%,b%,a#)
	
	Local s%,surf%,v%
	
	For s=1 To CountSurfaces(mesh)
		
		surf=GetSurface(mesh,s)
		
		For v=0 To CountVertices(surf)-1
			
			VertexColor surf,v,r,g,b,a
			
		Next
		
	Next
	
End Function

;===========================================================================
; creates a fake shader (spherical glow effect), should match planet size
;===========================================================================

Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)
	
	Local shader%=CreateSphere(segments)
	Local tex%=CreateFakeShaderTexture()
	
	ScaleEntity shader,size,size,size
	EntityBlend shader,3
	EntityFX shader,2
	EntityOrder shader,-1
	UpdateVertexColors(shader,r,g,b,a)
	
	TextureBlend tex,2
	EntityTexture shader,tex,0,1
	
	Return shader%
	
End Function

;===========================================================================
; creates fake shader texture
;===========================================================================

Function CreateFakeShaderTexture()
	
	Local tex%=CreateTexture(512,512,64)
	Local tb%=TextureBuffer(tex)
	
	Local x%,y%,i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For x=0 To 511
		
		For y=0 To 511
			
			rgb=255*$1000000+255*$10000+255*$100+255
			WritePixelFast x,y,rgb,tb
			
		Next
		
	Next
	
	For j=0 To 255
		
		col=j*1.0/Exp((255-j)*0.02)
		
		If col&gt;255 Then col=255
		If col&lt;0 Then col=0
		
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create planet atmosphere
;===========================================================================

Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	If segments&gt;360 Then segments=360
	
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		VertexColor surf,v0,r1,g1,b1,al1
		VertexColor surf,v1,r1,g1,b1,al1
		VertexColor surf,v2,r2,g2,b2,al2
		VertexColor surf,v3,r2,g2,b2,al2
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function


;===========================================================================
; update planet atmosphere
;===========================================================================

Function UpdateGlow(mesh%,cam%)
	
	Local radius#,distance#
	Local c1#,a1#,q1#,p1#,h1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#
	
	PointEntity mesh,cam
	
	radius=SCALE
	distance=EntityDistance(cam,PLANET)
	
	; First triangle
	c1=distance
	a1=radius
	q1=a1^2/c1
	p1=c1-q1
	h1=Sqr(p1*q1)
	gamma1=90
	alpha1=ATan(h1/p1)
	beta1=gamma1-alpha1
	
	; Second Triangle
	alpha2=90-(90-beta1)
	b2=a1/Tan(alpha2)
	c2=(Sqr(a1^2+b2^2))/radius
	
	ScaleEntity mesh,c2,c2,c2
	
End Function


;===========================================================================
; create planetary ring mesh
;===========================================================================

Function CreateEllipse(parent%=False,r1#,r2#)
	
	Local mesh%=CreateMesh(parent)
	Local surf%=CreateSurface(mesh)
	Local a1%,a2%,v0%,v1%,v2%,v3%
	
	For a1 = 0 To 359 Step 1
		
		a2=(a1+1) Mod 360
		v0=AddVertex(surf,r1*Cos(a1),0,r1*Sin(a1),0,0) 
		v1=AddVertex(surf,r1*Cos(a2),0,r1*Sin(a2),0,0)
		v2=AddVertex(surf,r2*Cos(a2),0,r2*Sin(a2),1,1)
		v3=AddVertex(surf,r2*Cos(a1),0,r2*Sin(a1),1,1)
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	EntityFX mesh,1+16
	
	Return mesh
	
End Function


;===========================================================================
; create planetary ring texture
;===========================================================================

Function CreateRingTexture(size%=1024,seed%=1,flags%=0,usealpha%=False,method$="normal",fading#=1.0)
	
	Local tex%=CreateTexture(size,1,flags)
	Local buffer%=TextureBuffer(tex)
	
	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#
	
	LockBuffer buffer
	
	For x=0 To size-1
		
		h1=Perlin3D(x*(2048/size),0,0,1024,seed,0,15)
		h2=Perlin3D(0,x*(2048/size),0,512,seed,0,7)
		
		col=Int(Normalize(h1,-1,1,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255
		
		If usealpha Then
			
			If method="soft" Then
				
				; soft rings
				alpha=(Int(Normalize(h2,-1,1,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))/2
				
			Else If method="sharp" Then
				
				; sharp rings
				alpha=Int(Normalize(h2,-1,1,0,1.5)*col) Xor Int(Normalize(h1,-1,1,0,1.5)*col)
				
			Else
				; normal rings
				alpha=Int(Normalize(h2,-1,1,0,1.0)*col)
			EndIf
			
			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255
			
		Else
			
			alpha=255
			
		EndIf
		
		; soft fading to the outer rings
		If x&gt;(size*fading) Then
			
			value=Normalize(x,size*fading,size,1,0)
			
			alpha=alpha*value
			col=col*value
			
		EndIf
		
		rgb=alpha*$1000000+col*$10000+col*$100+col
		
		WritePixelFast x,0,rgb,buffer
		
	Next
	
	UnlockBuffer buffer
	
	Return tex
	
End Function


;===========================================================================
; normalize value
;===========================================================================

Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


;===========================================================================
; fast perlin noise functions
;===========================================================================

Function InitNoise()
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-1,1)
		GRAYD#(256+i)=Rnd(-1,1)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea> <br><br></td></tr></table><br>
<a name="1042160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Unless you want fully procedural, (meaning everything is created first and stays that way) you could try that method that a few of those Blitz "outdoor grass demos" floating around use. As you move, new asteroids are created on the fly around the camera, and ones gone out of range are deleted. You could still use autofade to hide their sudden disappearance/creation. I'd like to look into this code more and see if I could come up with a solution. I've had the same problem trying to figure out how to "en-grass" an entire huge landscape efficiently and realistically.<br><br><b>EDIT:</b> OK. Try putting this after the "planetary ring" creation code:<br><pre class=code>;Asteroid Field
Global asteroidcollection = CreatePivot(PLANET)
For d# = 0 To 360
	Local asteroids = CreateMesh(asteroidcollection)
	Local dist# = Rnd(1.75,2.7)
	PositionEntity asteroids,Cos(d)*dist,Rnd(-0.1,0.1),Sin(d)*dist
	EntityAutoFade asteroids,0,1
	For i = 0 To 160
		Local asteroid = CreateSphere(4)
		Local asteroid_scale# = Rnd(0.00001,0.0015)
		;For s = 1 To CountSurfaces(asteroid)
		;	surf% = GetSurface(asteroid,s)
		;	For v = 0 To CountVertices(surf)-1
		;		VertexCoords surf,v,VertexX(surf,v)+Rnd(-0.5,0.5),VertexY(surf,v)+Rnd(-0.5,0.5),VertexZ(surf,v)+Rnd(-0.5,0.5)
		;	Next
		;Next
		ScaleMesh asteroid,asteroid_scale,asteroid_scale,asteroid_scale
		PositionMesh asteroid,Rnd(-0.3,0.3),Rnd(-0.025,0.025),Rnd(-0.3,0.3)
		AddMesh asteroid,asteroids
		FreeEntity asteroid
	Next
Next</pre><br>Personally, I think it looks pretty good, but the asteroids are still just spheres, and I don't know how I would go about the movement other than just rotating them around the planet. I did try to make the spheres look more like asteroids, but for some reason, it caused the top and bottom of the spheres to disconnect. If you want to see my attempt at making them look like asteroids, uncomment the part in the middle. You could make a couple asteroid models, then each time an asteroid is created, just choose one of them randomly.<br><br><b>EDIT 2:</b> I don't know why, but your program keeps making the camera's position become NaN. I ran into this several times when I was designing a FPS, and I didn't know what to do about it. Also, you can add this code to your main loop to move the asteroids around the planet:<br><pre class=code>TurnEntity asteroidcollection,0,0.001,0</pre><br><br><b>EDIT 3 (so many edits!):</b> I think the NaN problem may have something to do with the fact that you're controlling the camera directly and using MoveEntity, instead of parenting it to a pivot, then moving that. The other game I had problems with didn't use a pivot either. It also might have to do with the scale of your project, I mean, the planet is only 1 Blitz unit in radius! <br><br></td></tr></table><br>
<a name="1042221"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not able to run b3d now, but I thought I post a link to my archive entry on scenegraphs. Hopefully it helps a bit:<br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2650" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2650</a><br>[edit]The scenegraph should not be filled with single objects, but with merged groups of objects.<br>Also, I was thinking about ROAM terrains, but nothing concrete came up.<br>ROAM in short is used to create LOD on terrains. You recursively divide the space into squares. (2 tris)<br>For each new square (or tri) that is created, you check the distance towards the camera. Depending on the distance and the size of the square, it is subdivided again. Big squares that are far away are not subdivided. The closer a square (or tri) is, the further it is subdivided.<br>That results in this kind of structure:<br>-http://www.riemers.net/images/XNA_ROAM.jpg<br>Around the camera, there is much detail, and far away, there is less detail. <br><br></td></tr></table><br>
<a name="1042229"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess you could make two sets of asteroids - one containing large asteroids, and one containing small ones and set the smaller asteroids to have a closer autofade distance. <br><br></td></tr></table><br>
<a name="1042298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> WOW ClayPigeon, this looks really cool and is simple, too. There is only one problem - the density is too low while the RAM consumption too high. I think it would be much better to create and spawn the asteroid blocks in runtime only if the cam is nearby and delete them if they are at a certain distance. I have to investigate this further and take a closer look at Warner's scene graph (which creates all meshes first, too, but I need to check this out). <br><br></td></tr></table><br>
<a name="1042301"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe you could make separate asteroid cluster models and load them into memory and hide them. Then, you could just CopyEntity them whenever you need them. If you're worried about RAM, you could make the separate asteroid block meshes take up more space, then make less asteroid blocks. AFAIK all meshes are stored in VRAM. <br><br></td></tr></table><br>
<a name="1042304"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Krischan <br></div><br>Wow!<br>That is one of the most beautiful scenes I've ever seen requiring no external media! <br><br></td></tr></table><br>
<a name="1042467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> That with the inclusion of the astroid code is a kick ass sample <br><br></td></tr></table><br>
<a name="1042481"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh by the way, <br><br>@ClayPigeon: Regarding how to make the asteroids look more like asteroids - I'm 90% certain it was Rob Farley made some very quick, but effective code for me that does this.<br><br>I doubt it's as artistically great as the aboe, but it's a start for procedural asteroids after all. Perhaps making the texture generated with perlin noise too?<br><pre class=code>
Graphics3D 640,480,32,2
SetBuffer BackBuffer()

light=CreateLight(1)
MoveEntity light,400,150,-60

Global camera
Dim vpos#(1,1)

camera=CreateCamera()
CameraViewport camera,0,0,640,480
MoveEntity camera,0,23,0

CameraRange camera,1,5000
CameraFogMode camera,0
CameraFogColor camera,210,200,150
CameraFogRange camera,200,1000
AmbientLight 35,38,40

CameraClsMode camera,True,True

ClearTextureFilters

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
.run

Global sphere=CreateSphere(Rand(8,32))
PointEntity camera,sphere
tex=CreateTexture(256,256)

SetBuffer TextureBuffer(tex)

ClsColor 128,128,128 
Cls 
If (MilliSecs() Mod 2)
	For f=0 To 256
		For g=0 To 256
				col=Rand(64,192)
			Color col,col+8,col-8
			Plot f,g
		Next
	Next
Else
	For f=0 To 256
		For g=0 To 256
			col=Rand(32,128)
			Color col+32,col,col-32
			Plot f,g
		Next
	Next
End If

For f=1 To 640
	sz#=Rnd(4,12)
	sx=Rand(-128,256)
	sy=Rand(-128,256)
	col=ColorRed()
	Color col,col,col-32
	Oval sx,sy,sz,sz,0
	col=col-4
	Color col,col,col-32
	Oval sx-4,sy,sz-4,sz-4,0
	
	sz#=Rnd(4,12)
	sx=Rand(-128,256)
	sy=Rand(-128,256)
	
	col=Rand(32,128)
	Color col+32,col,col-32
	Oval sx,sy,sz,sz,0
	col=col-4
	Color col,col,col-24
	Oval sx-4,sy,sz-4,sz-4,0
	
Next

SetBuffer BackBuffer() 

EntityTexture sphere,tex 
size#=Rnd(2.0,10.0)
sz#=Rnd(size#,size#*1.5)
ScaleEntity sphere,size#*0.75,sz,size#*0.75
Morph(Sphere)



While Not MouseDown(1)
TurnEntity sphere,0.1,0.1,0.1      
RenderWorld      
Flip 
Wend

FreeEntity sphere
FreeTexture tex
Goto run

End

Function Morph(mesh)
  
Cls
Flip

  surftotal=CountSurfaces(mesh)
  
  For xx= 1 To surftotal
    as1=GetSurface(mesh,xx)
   
    ; record the locations of the verts
    Dim vpos#(CountVertices(as1)-1,3)
  
    For n=0 To CountVertices(as1)-1

      vpos(n,0)=VertexX(as1,n)
      vpos#(n,1)=VertexY(as1,n)
      vpos#(n,2)=VertexZ(as1,n)
      vpos#(n,3)=0
    Next
    
    For n=0 To CountVertices(as1)-1 Step 2
 
      ; change these to make it more or less messy
      xm#=Rnd(-.05,.05)
      ym#=Rnd(-.05,.05)
      zm#=Rnd(-.05,.05)
       
      For nn=0 To CountVertices(as1)-1
  
        ; if the vert has not been monkeyed with monkey away
        If vpos(nn,3)=0
          If vpos(n,0)=vpos(nn,0) And vpos(n,1)=vpos(nn,1) And vpos(n,2)=vpos(nn,2)
            VertexCoords as1,nn,vpos(nn,0)+xm,vpos(nn,1)+ym,vpos(nn,2)+zm
            vpos(nn,3)=1
          EndIf
        EndIf
        
      Next
 
      
    Next
    

  Next
  
  Return mesh
  
End Function</pre> <br><br></td></tr></table><br>
<a name="1042504"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, Malice! That looks neat! It also gave me an idea. What if the asteroids were generated using 3D array, and create a model using the marching cubes algorithm? That sure would look neat if the generation was made just right. It could have holes through it and stuff! <br><br></td></tr></table><br>
<a name="1042517"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, the above is very simple really at the heart of it, basically, just a sphere with the vertices  slightly defpormed randomly, then the whole thing is scaled to make it slightly oblate if not almost spherical.<br>The texturing is a bit messy but that ccan be completely removed in favour of something more workable (the perlin thing till sounds good to me :) )<br><br>As for the idea of giving the asteroids some kind of array, it should be possible to determine the actyual deformations dfone on the verts instead of simply random alterations as they are currently.<br><br>A lot could potentially be done with it, just by substituting in some home-made functions, as it stands, it's just the bare boners really just been dressed over quickly to show that it works.<br>(In my own use of the code, I actually worked with a random Seed value that allowed the asteroid belt to be created the same in the right places, with a different one elsewhere. This also ensured a dispersal of the asteroids and such. <br><br></td></tr></table><br>
<a name="1042527"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> the perlin thing till sounds good to me :) <br></div><br>lol, I never said it was bad. In fact, it might be able to be implemented into the marching cube array idea using 3-dimensional perlin noise. To make the asteroids less spherical, you could do several deformation passes. On the first iteration, a single vertex is moved a random amount. Then each of its neighboring vertices will be moved by the same amount, but dampened by their distance from the original vertex. This, in turn, will move large lumps instead of single vertices. As you iterate through the deformations, decrease the range of vertices moved with the selected one, until you're only moving one vertex. This ought to make a neat lumpy-effect while maintaining the fine surface bumps.<br><br>p.s. That's a neat way of generating a rocky texture! Just Ovals and colored noise! <br><br></td></tr></table><br>
<a name="1042563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> been playing with this lol... possibly to do some quite awe inspiring effects with simple tweaks... <br><br></td></tr></table><br>
<a name="1042567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's my attempt:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 640,480,0,2
SetBuffer BackBuffer()

Global  ASTEROID_SEED = MilliSecs()
SeedRnd ASTEROID_SEED
Global font% = LoadFont("Arial",16,True,True,False)
SetFont font

Gosub Generate

Global camera% = CreateCamera()
PositionEntity camera,0,0,-3

Global light% = CreateLight()
RotateEntity light,0,90,0

While Not KeyHit(1)
	Cls
	
	TurnEntity asteroid,Cos(MilliSecs()*0.1),0.25,Sin(MilliSecs()*0.1)
	
	UpdateWorld
	RenderWorld
	
	If KeyDown(59)
		Color 255,127,95
		Text 0,0,"W - Toggle wireframe"
		Text 0,16,"SPACE - Generate new asteroid"
	Else
		Color 255,255,255
		Text 0,0,"Random seed: "+ASTEROID_SEED
		Text 0,16,"Press F1 for help."
	EndIf
	
	Flip
	
	If KeyHit(17)
		wire = Not wire
		WireFrame wire
	EndIf
	
	If KeyHit(57)
		FreeEntity asteroid
		Gosub Generate
	EndIf
Wend

End

Function Deform(mesh%,amount#,range#)
	For s = 1 To CountSurfaces(mesh)
		surf% = GetSurface(mesh,s)
		;Choose a vertex
		vert% = Rand(CountVertices(surf)-1)
		;Record vertex location
		vx# = VertexX(surf,vert) : vy# = VertexY(surf,vert) : vz# = VertexZ(surf,vert)
		;Deform amount
		dx# = Rnd(-amount,amount) : dy# = Rnd(-amount,amount) : dz# = Rnd(-amount,amount)
		VertexCoords surf,vert,vx+dx,vy+dy,vz+dz
		For v = 0 To CountVertices(surf)-1
			sx# = VertexX(surf,v) : sy# = VertexY(surf,v) : sz# = VertexZ(surf,v)
			dist# = Dist3D(sx,sy,sz,vx,vy,vz)
			If dist &gt;= range
				mult# = 1
			Else If dist = 0
				mult# = 0
			Else
				mult# = Float(dist/range)
			EndIf
			If mult &gt; 0
				VertexCoords surf,v,VertexX(surf,v)+dx*mult,VertexY(surf,v)+dy*mult,VertexZ(surf,v)+dz*mult
			EndIf
		Next
	Next
End Function

Function Dist3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	Return Sqr((x2-x1)^2+(y2-y1)^2+(z2-z1)^2)
End Function

.Generate
asteroid = CreateSphere(32)
EntityFX asteroid,4
EntityColor asteroid,Rand(255),Rand(255),Rand(255)
range# = 1
Repeat
	Deform(asteroid,range*0.1,range)
	range = range-0.01
Until range &lt; 0.5
Return</textarea><br>It's not perfect; it gets these little sticky-outy vertices in the center of each deformation, but you get the idea. <br><br></td></tr></table><br>
<a name="1042805"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> p.s. That's a neat way of generating a rocky texture! Just Ovals and colored noise! <br><br> <br></div><br>Heh yeah it began as an attempt to mimic craters but the resolution isnt too good for that, but it gave a nice enough effect to break up the random noise 'plain-ness' that I left it in :)<br><br>---------------------<br><br>As for your code, I like the effect given to the overall shape, I agree the little spikes could do with flattening, Not sure how they get in there yet.<br><br>One thing, though, which is certainly true from my code too, that for asteroids (understandably due to the almost spherical shape) these things take an awful lot of tris. Not a problem for just one displayed in the example, but when there's a whole asteroid belt of them, combined with a high-poly planet sphere (plus the 'glow mesh and ring too) I can see the poly count rocketing.<br><br>So I added David Bird's polygon reducing code (Press Z to reduce).<br>I'm hoping to use the Delauney Triangulation code (Now that I know how it can be used!) to then re-increase the polycount again.. should be done in a day or two I hope :)<br>'<br>The clipping ussues with the 'spikey' triangles that poke out from the surface seems to get worse with this though, as large 'cracks' apperar in the mesh :(<br><br>Hopefully I might find out what causes the spikes though :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 640,480,0,2
SetBuffer BackBuffer()

; LOD  Reduction by David Bird
;**** Internal data ****
Const MAXTRIS=100000

Dim PR_TriVisible(MAXTRIS)
Dim PR_TriCost#(MAXTRIS)
Dim PR_TriVert(MAXTRIS,3)
Dim PR_TriConnect(MAXTRIS,2)

Global PR_TriangleCount=0,PR_VertexCount=0
Global PR_CurrentSurface


Global  ASTEROID_SEED = MilliSecs()
SeedRnd ASTEROID_SEED
Global font% = LoadFont("Arial",16,True,True,False)
SetFont font

Gosub Generate

Global camera% = CreateCamera()
PositionEntity camera,0,0,-3

Global light% = CreateLight()
RotateEntity light,0,90,0

While Not KeyHit(1)
	Cls
	
	TurnEntity asteroid,Cos(MilliSecs()*0.1),0.25,Sin(MilliSecs()*0.1)
	
	UpdateWorld
	RenderWorld
	
	If KeyDown(59)
		Color 255,127,95
		Text 0,0,"W - Toggle wireframe"
		Text 0,16,"SPACE - Generate new asteroid"
	Else
		Color 255,255,255
		Text 0,0,"Random seed: "+ASTEROID_SEED
		Text 0,16,"Press F1 for help."
	EndIf
		Text 0,32,"Polygons: "+Str(TrisRendered())
	Flip
	
	If KeyHit(44) Then MeshPolygonsReduce(asteroid,32) ; 32 seemed to be an ideal value to use here. (Number of Tri's to remove each tiome 'z' is pressed.

	;If KeyHit(30) ; DelauneyTriangulation to increase Polycount Lefvel--Of-Detail
	
	If KeyHit(17)
		wire = Not wire
		WireFrame wire
	EndIf
	
	If KeyHit(57)
		FreeEntity asteroid
		Gosub Generate
	EndIf
	
Wend

End

Function Deform(mesh%,amount#,range#)
	For s = 1 To CountSurfaces(mesh)
		surf% = GetSurface(mesh,s)
		;Choose a vertex
		vert% = Rand(CountVertices(surf)-1)
		;Record vertex location
		vx# = VertexX(surf,vert) : vy# = VertexY(surf,vert) : vz# = VertexZ(surf,vert)
		;Deform amount
		dx# = Rnd(-amount,amount) : dy# = Rnd(-amount,amount) : dz# = Rnd(-amount,amount)
		VertexCoords surf,vert,vx+dx,vy+dy,vz+dz
		For v = 0 To CountVertices(surf)-1
			sx# = VertexX(surf,v) : sy# = VertexY(surf,v) : sz# = VertexZ(surf,v)
			dist# = Dist3D(sx,sy,sz,vx,vy,vz)
			If dist &gt;= range
				mult# = 1
			Else If dist = 0
				mult# = 0
			Else
				mult# = Float(dist/range)
			EndIf
			If mult &gt; 0
				VertexCoords surf,v,VertexX(surf,v)+dx*mult,VertexY(surf,v)+dy*mult,VertexZ(surf,v)+dz*mult
			EndIf
		Next
	Next
End Function

Function Dist3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	Return Sqr((x2-x1)^2+(y2-y1)^2+(z2-z1)^2)
End Function

.Generate
asteroid = CreateSphere(24)
EntityFX asteroid,4
col=Rand(128)+64
EntityColor asteroid,col,col,col-64
range# = 1
Repeat
	Deform(asteroid,range*0.1,range)
	range = range-0.01
Until range &lt; 0.5
Return



















;============================== Main Function ============================
;MeshPolygonsReduce (mesh, n)
;  inputmesh: The mesh to reduce
;  n: The amount of polygons to reduce from the inputmesh
Function MeshPolygonsReduce(mesh,n)
	;Make sure "mesh" is really a mesh
	If EntityClass$(mesh)&lt;&gt;"Mesh" Then
		RuntimeError "Can't reduce polygons of a "+Lower$(EntityClass$(mesh))
		Return
	End If
	
	If n&lt;=0 Then Return ;Don't need to do anything
	
	;Divide n by the surface count
	n=n/CountSurfaces(mesh)
	If n&lt;1 Then n=1 ;Don't do nothing

	;For every surface
	For surf=1 To CountSurfaces(mesh)
		;Get surface
		PR_CurrentSurface=GetSurface(mesh,surf)

		;Calculate surface data
		CalculateMeshData(mesh)
	
		;Remove n lowest cost polys from mesh
		For i=1 To n
			tri=LeastNeededTriangle()
			If tri&lt;&gt;-1 Then RemoveTriangle(tri)
		Next
	
		;Clear the surface's triangles
		ClearSurface PR_CurrentSurface,False,True

		;Regenerate the mesh with the new level of detail
		For i=0 To PR_TriangleCount
			If PR_TriVisible(i) Then
				AddTriangle PR_CurrentSurface,PR_TriVert(i,0),PR_TriVert(i,1),PR_TriVert(i,2)
			End If
		Next
	Next

	;Update the new mesh's normals
	UpdateNormals mesh
End Function
;-------------------------------------------------------------------------



;********* Internal Functions *********
Function CalculateMeshData(mesh)
	;Clear data
	PR_TriangleCount=0
	PR_VertexCount=0
	
	;Get vertex count
	PR_VertexCount=CountVertices(PR_CurrentSurface)
	
	;Initialise triangles
	PR_TriangleCount=CountTriangles(PR_CurrentSurface)-1
	For triindex=0 To PR_TriangleCount
		For i=0 To 2
			PR_TriVert(triindex,i)=TriangleVertex(PR_CurrentSurface,triindex,i)
		Next
		PR_TriVisible(triindex)=True
	Next
	
	;Process triangles
	For triindex=0 To PR_TriangleCount
		CalculateTriangleCost#(triindex) ;Calculate the triangle's importance
	Next
End Function

Function LeastNeededTriangle()
	;Find minimum cost
	minimumcost#=1000000
	triindex=-1
	For i=0 To PR_TriangleCount
		If PR_TriVisible(i) Then
			If PR_TriCost(i)&lt;minimumcost Then 
				triindex=i
				minimumcost=PR_TriCost(i)
			End If
		End If
	Next
	;Return lowest triangle
	Return triindex
End Function

Function RemoveTriangle(tri)
	PR_TriVisible(tri)=False
	
	;Re-attach vertices
	oldvert=PR_TriVert(tri,PR_TriConnect(tri,0))
	newvert=PR_TriVert(tri,PR_TriConnect(tri,1))
	For i=0 To PR_TriangleCount
		changed=False
		If PR_TriVert(i,0)=oldvert Then PR_TriVert(i,0)=newvert:changed=True
		If PR_TriVert(i,1)=oldvert Then PR_TriVert(i,1)=newvert:changed=True
		If PR_TriVert(i,2)=oldvert Then PR_TriVert(i,2)=newvert:changed=True
		If changed Then ;Recalculate triangle cost if the triangle has been re-attached
			CalculateTriangleCost(i)
		End If
	Next
End Function

Function CalculateTriangleCost#(tri)
	;Calculate the edge sizes of the triangle
	x0#=VertexX(PR_CurrentSurface,PR_TriVert(tri,0)):y0#=VertexY(PR_CurrentSurface,PR_TriVert(tri,0)):z0#=VertexZ(PR_CurrentSurface,PR_TriVert(tri,0))
	x1#=VertexX(PR_CurrentSurface,PR_TriVert(tri,1)):y1#=VertexY(PR_CurrentSurface,PR_TriVert(tri,1)):z1#=VertexZ(PR_CurrentSurface,PR_TriVert(tri,1))
	x2#=VertexX(PR_CurrentSurface,PR_TriVert(tri,2)):y2#=VertexY(PR_CurrentSurface,PR_TriVert(tri,2)):z2#=VertexZ(PR_CurrentSurface,PR_TriVert(tri,2))
	coord0#=Sqr((x0-x1)^2+(y0-y1)^2+(z0-z1)^2)
	coord1#=Sqr((x1-x2)^2+(y1-y2)^2+(z1-z2)^2)
	coord2#=Sqr((x2-x0)^2+(y2-y0)^2+(z2-z0)^2)

	;Pick the best vertice to use when removing the triangle	
	If coord0&lt;coord1 And coord0&lt;coord2 Then n=1
	If coord1&lt;coord0 And coord1&lt;coord2 Then n=2
	If coord2&lt;coord0 And coord2&lt;coord1 Then n=3
	
	Select n
		Case 0
			PR_TriConnect(tri,0)=1:PR_TriConnect(tri,1)=0
		Case 1
			PR_TriConnect(tri,0)=1:PR_TriConnect(tri,1)=0
		Case 2
			PR_TriConnect(tri,0)=2:PR_TriConnect(tri,1)=1
		Case 3
			PR_TriConnect(tri,0)=0:PR_TriConnect(tri,1)=2
	End Select

	;Set the cost to the sum of the triangle's edges
	PR_TriCost#(tri)=coord0+coord1+coord2
End Function









</textarea> <br><br></td></tr></table><br>
<a name="1042808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Freelancer done asteroids by having 'clumps of asteroids' at extreme distance (as long as it was still in the field location), then smaller clumps nearer to the player then when it got to a certain distance the asteroids were created.<br><br>If you look at ALL videos of FreeLancer you will notice some fade at certain distances, for the asteroid fields they are placed within a certain distance from asteroid x, y, z. The Nebulae were created in the same way. <br><br></td></tr></table><br>
<a name="1042822"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did a lot of asteroid work a couple of years ago; I found that Blitz's CreateSphere() is actually a rectangle of vertices wrapped around the sphere.  This gives it two weird features that become apparent when you deform it.  First, it has a seam that will separate and create a rift if you don't carefully match the two vertices at each point along the seam.<br><br>Second, each pole is actually a collection of vertices; one for each column.  So again, you have to first "collect" all the north pole verts and adjust them all the same exact way, or you will have a flowery looking crack.  South pole too.<br><br>All of this is needed for texturing.<br><br>I ended up writing CreateSphere2() which has no seams for my asteroids:<br><br><pre class=code>

Function createsphere2(segments)
	sa#=180.0/segments ; sa=segment angle.  This is for both latitude and longitude (equatorial angle)
	newsphere2=CreateMesh()
	surface=CreateSurface(newsphere2)

	; *** Add the vertexes ***
	
	AddVertex(surface,0,1,0) ; North pole
	For latitude=1 To segments-1
		y#=Cos(sa*latitude) ; This is the y value for all vertices in this latitude
		lateraldistancefromaxis#=Sin(sa*latitude) ; This is needed for next calculations
		For longitude = 1 To segments*2
			x#=Cos(sa*longitude)*lateraldistancefromaxis
			z#=Sin(sa*longitude)*lateraldistancefromaxis
			AddVertex(surface,x,y,z)
		Next
	Next
	AddVertex(surface,0,-1,0) ; South pole
	
	; *** Add the triangles ***
	
	; First the north pole triangles
	For vertex=2 To segments*2
		AddTriangle(surface,vertex-1,0,vertex)
	Next
	AddTriangle(surface,segments*2,0,1)
	
	; Now everything but the poles
	For latitude=1 To segments-2
		For vertex=(latitude-1)*segments*2+1 To latitude*segments*2-1
			AddTriangle(surface,vertex+1,vertex+segments*2,vertex)
			AddTriangle(surface,vertex+1,vertex+segments*2+1,vertex+segments*2)
		Next
		vertex=(latitude-1)*segments*2+1
		AddTriangle(surface,vertex,vertex+segments*2,vertex+segments*4-1)
		AddTriangle(surface,vertex,vertex+segments*4-1,vertex+(segments*2-1))
	Next
	
	; Lastly the south pole triangles
	lastvertex=(segments*2)*(segments-1)+1 ; +2 would be the total number of vertices, +1 is the index of the last vertex (south pole)
	For vertex=lastvertex-1 To lastvertex-segments*2+1 Step -1
		AddTriangle(surface,vertex,lastvertex,vertex-1)
	Next
	AddTriangle(surface,lastvertex-segments*2,lastvertex,lastvertex-1)

	
	;sphere=CreateSphere(segments)
	EntityColor(newsphere2,255,255,255);255,255)
	UpdateNormals(newsphere2)
	Return newsphere2
End Function
</pre> <br><br></td></tr></table><br>
<a name="1042841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's really great to know, Axel, thanks - maybe you should post that in the code archives?<br><br>I did find, that using the Sphere2 removed all those 'cracks' and clipping issues, but unfortunately, I also found I couldn't apply a texture to the Mesh... Maybe somehting to do with the EntityFX or such I've used though...<br><br>Oh, lastly, I noticed in ClayPidgeon's code, this line:<br><pre class=code>
If mult &gt; 0
</pre><br>mult always seems to be &gt;0 so I dabgbled around and found this seems to give some great results when taken as a ratio of "jaggedness" of the surface. <br><br>so just making the line<br><pre class=code>
If (mult=1)
</pre><br>Makes some very jagged asteroids but the tris dont look too 'pointed' which is nice.<br><br>You can try yourself with<br><br><pre class=code>
If (Mult&gt;0.5) and (mult&lt;0.8)</pre><br>or  such for interesting results to maybe strike a good balance! <br><br></td></tr></table><br>
<a name="1042890"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>@Axel Wheeler:</b> What we really need is a CreateGeosphere() code. Basically, what it does is create a sphere, but each face is a triangle, and all its vertices a evenly spaced. It would be perfect for this as it wouldn't cause distortions where there are more verts clumped together a the top and bottom poles of the sphere.<br><br><b>@Malice:</b> You're right, I guess that mult&gt;0 line was sort of redundant because that would mean that the other vert's location would have to be the same as the selected one's. (.'. The distance=0)<br><br>..I still think the "Perlin Noise + 3D Array + Marching Cubes" method is worth a try, only I've never successfully created Perlin noise, and haven't the faintest idea how to use marching cubes. (Maybe someone here has?) <br><br></td></tr></table><br>
<a name="1042920"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Clay: Yeah but it would be difficult to make that scalable.  A d20 shape would be straightforward (don't try to tell me you don't know what a d20 is!), but how to make a command that takes a parameter to indicate how complex it should be?  I couldn't find any general set of triangle-based polyhedra of increasing complexity.  <br><br>So you'd probably need a separate command for each polyhedron. <br><br>A d20 would probably be small for this purpose...?<br><br>Microsoft had a great paper on large triangle-based spherical meshes.  I can't find it now.  It may have worked by starting with a d20 shape and dividing each triangle into 4 new triangles (think about it), and bulging the vertices out to the correct radius, then recursively splitting the triangles further as needed.  That should be doable.  Hmm.  Maybe I'll have a go tomorrow or so.  No promises!<br><br>Regarding deformations, I remember my method picked a random point in space around (or inside) the sphere.  Then it pushed or pulled each vertex based on distance from that point.  In other words it was similar to Clay Pidgeon's code but picking random points rather than limiting it to existing vertices. <br><br></td></tr></table><br>
<a name="1042931"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> The D20 shape (Regular Dodecahedron)  - ands other regular solids) ought to be structured from a basic algorithm, same as there's a similar thing for regular polygons. I dunno what this might be,m though, but if I get the chance later, I'll ask my old friend Google and see what I can find.<br> Biggest problem is, that we're dealing with tri's rather than various polygon shapes for the faces of the 3D shapes : Though working backwards from the angles might be a way to go (gonna be some tricky trig in there I see)<br><br>Opposite to you, Axel, I've been playing with the Perlin noise (though honestly still don't fully understand what it's really doing), and the Marching Cubes thing is alien to me, definitely worth giving it a shot, if only at the very least to try out the other options :) <br><br></td></tr></table><br>
<a name="1042936"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Malice: Just to clear things up, Perlin noise is a method of generating smooth lumpy noise (as opposed to just purely random) while maintaining details on the small scale. The marching cubes algorithm is a method of extracting a solid mesh from a volume. (such as a fluid particles or a density grid) If a density grid (3D array) was created for the asteroids using perlin noise it might look pretty neat.<br>Look here: <a href="http://www.youtube.com/watch?v=-4rA3fdKWQA" target="_blank">Marching Cubes Terrain</a><br>The terrain in the video is being rebuilt every frame in realtime, but it can be done once and stored in a mesh, as long as you don't need it to be destuctable or ever change. <br><br></td></tr></table><br>
<a name="1043014"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Malice: The D20 is an icosahedron.  The dodecahedron is the D12.<br><br>Here is some code that makes an icosahedron and then subdivides it as many times as you want.  Complexity ramps up fast!  Keep the value small at first (like 4 or less) until you see how long it takes.<br><br>Note that normals are wrong because adjacent triangles tend to be normalized the same and so are hard to see (I presume because there are way more triangles than vertices).  Once you've textured it that should be less of a problem.<br><br>The program uses vertex colors just to prove all the vertices and triangles are there.  <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Graphics3D 640,480,32,2
SetBuffer(BackBuffer())
SeedRnd(MilliSecs())

Global Camera=CreateCamera ()
CameraRange(Camera,.01,20)
PositionEntity(Camera,0,0,-3)
Global ico=CreateIcosahedron(2)
Spherize(ico)

EntityFX(ico,6)

Local s=GetSurface(ico,1)
Local v

For v=0 To CountVertices(s)-1
	VertexColor(s,v,Rnd(255),Rnd(255),Rnd(255))
Next

Global sun=CreateLight()
LightColor(sun,200,200,100)
RotateEntity(sun,45,45,0)
AmbientLight(64,64,128)

Const GameUPS=60 ; Updates per second
Local Period=1000/GameUPS 
Local FrameTime=MilliSecs()-Period

Local Tween#, Ticks,i,Remaining,StartTime,Elapsed

While Not KeyHit(1)
	
	StartTime = MilliSecs()
	
	Repeat
		Elapsed=MilliSecs()-FrameTime
	Until Elapsed
	
	Ticks=Elapsed / Period
	Tween=Float(Elapsed Mod Period)/Float(Period)
	
	For i=1 To Ticks
		FrameTime=FrameTime+Period
		If i=Ticks Then
			CaptureWorld
		End If
		UpdateGame()
		UpdateWorld
	Next
	RenderWorld Tween
	
	Remaining = Period - (MilliSecs() - StartTime)
	If Remaining &gt; 1 Then 
		Delay (Remaining-1) ; Free some CPU time
	End If
	
	Flip
	
Wend

End

Function UpdateGame()
	TurnEntity(ico,.1,0,0)
	; ...
End Function



Function CreateIcosahedron(recursions=0)
	Local mesh=CreateMesh()
	Local s=CreateSurface(mesh)
	Local v,t,i,r,newMesh,newS
	Local fifth#=360.0/5.0
	
	;Vertices
	
	AddVertex(s,0,1.1,0)
	
	For i=1 To 5
		v=AddVertex(s,Cos(i*fifth),Sqr(.75)/2.0,Sin(i*360.0/5.0))
	Next
	
	For i=6 To 10
		v=AddVertex(s,Cos((i*fifth)+(fifth/2.0)),-Sqr(.75)/2.0,Sin((i*fifth)+(fifth/2.0)))
	Next
	
	AddVertex(s,0,-1.1,0)
	
	;Triangles
	
	For i=1 To 4
		t=AddTriangle(s,0,i+1,i)
		t=AddTriangle(s,i,i+1,i+5)
	Next
	t=AddTriangle(s,0,1,5)
	t=AddTriangle(s,5,1,10)
	
	For i=7 To 10
		t=AddTriangle(s,i-5,i,i-1)
		t=AddTriangle(s,i-1,i,11)
	Next
	t=AddTriangle(s,1,6,10)
	t=AddTriangle(s,10,6,11)
	
	UpdateNormals(mesh)
	
	For r=1 To recursions
		newMesh=CreateMesh()
		newS=CreateSurface(newMesh)
		For t=0 To CountTriangles(s)-1
			SubdivideTriangle(mesh,s,t,newMesh,newS)
		Next
		FreeEntity(mesh)
		s=newS
		mesh=newMesh
	Next
	
	Return mesh
End Function

Function SubdivideTriangle(mesh,surface,triangle,newMesh,newSurface)
	Local s=surface
	Local t=triangle
	Local ns=newSurface
	
	Local oldv0=TriangleVertex(s,t,0)
	Local oldv1=TriangleVertex(s,t,1)
	Local oldv2=TriangleVertex(s,t,2)
	
	Local v0=AddVertex(ns,VertexX(s,oldv0),VertexY(s,oldv0),VertexZ(s,oldv0))
	Local v1=AddVertex(ns,VertexX(s,oldv1),VertexY(s,oldv1),VertexZ(s,oldv1))
	Local v2=AddVertex(ns,VertexX(s,oldv2),VertexY(s,oldv2),VertexZ(s,oldv2))
	
	Local v01=AddVertex(ns,(VertexX(ns,v0)+VertexX(ns,v1))/2.0,(VertexY(ns,v0)+VertexY(ns,v1))/2.0,(VertexZ(ns,v0)+VertexZ(ns,v1))/2.0)
	Local v12=AddVertex(ns,(VertexX(ns,v1)+VertexX(ns,v2))/2.0,(VertexY(ns,v1)+VertexY(ns,v2))/2.0,(VertexZ(ns,v1)+VertexZ(ns,v2))/2.0)
	Local v20=AddVertex(ns,(VertexX(ns,v2)+VertexX(ns,v0))/2.0,(VertexY(ns,v2)+VertexY(ns,v0))/2.0,(VertexZ(ns,v2)+VertexZ(ns,v0))/2.0)
	
	AddTriangle(ns,v0,v01,v20)
	AddTriangle(ns,v1,v12,v01)
	AddTriangle(ns,v2,v20,v12)
	AddTriangle(ns,v01,v12,v20)
	UpdateNormals(newMesh)
End Function

Function Spherize(m)
	Local s=GetSurface(m,1)
	Local v,alt#
	
	For v=0 To CountVertices(s)
		alt#=Sqr(Sqr(VertexX(s,v)^2+VertexY(s,v)^2)^2+VertexZ(s,v)^2)
		VertexCoords(s,v,VertexX(s,v)/alt,VertexY(s,v)/alt,VertexZ(s,v)/alt)
	Next
	UpdateNormals(m)
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1043076"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Malice: The D20 is an icosahedron. The dodecahedron is the D12.<br> <br></div> Of course... silly me! &gt;.&lt;<br><br>That's some neat code, you really have a good grip on this 3-D Mesh stuff, way better than I.<br>Thanks too, ClayPidgeon I knew what Perlin Noise was 'for', just not how it really works!<br><br>As for that Marchig Cubes stuff, thanks, that makes a lotta sense. The density grid approach is perhaps the most 'realistic' method to describing the asteroid belt! <br><br></td></tr></table><br>
<a name="1043099"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just want to share an update. Now the Saturn has nice procedural ice particle ring details and a shadow. No media required - everything is generated on the fly. One problem is that I don't know how to prevent the short flicker when I create the shadow texture. Any ideas? Another issue is the glow on the nightside, dunno how to darken this side of the glow mesh.<br><br>Here some eye candy shots (again uncomment the milkyway and include the milkyway panorama from my signature to get the cool background, too). Use SHIFT or RMB for faster movement and LMB for 100x Zoom. I recommend to fly closer to the ring with turbo and continue moving without turbo when you are very close to it.<br><br><b>The shadow, created out of two spheres, one distorted</b><br><img src="http://www.christianhart.de/bb/asteroids/shadow.jpg"><br><br><b>Closeup of the ice particles</b><br><img src="http://www.christianhart.de/bb/asteroids/ice_close.jpg"><br><br><b>The shadow transition</b><br><img src="http://www.christianhart.de/bb/asteroids/shadow_transition.jpg"><br><br><b>The ice particles, very much zoomed in</b><br><img src="http://www.christianhart.de/bb/asteroids/ice_zoomed.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Procedural Saturn"

Graphics3D 800,600,32,2

Dim P%(512),GRAYD#(512)

Global density%[1024]

Const SEED_PLANET%=8		; seed for procedural planet texture
Const SEED_RING%=6			; seed for procedural ring texture
Const SPEED#=0.1			; move speed
Const SCALE#=100.0			; planet scale
Const SEGMENTS%=32			; sphere detail
Const RINGDETAIL%=64		; ring segments
Const GLOWSEGMENTS%=32		; glow segments
Const MINRINGRAD#=1.1117	; minimum ring radius
Const MAXRINGRAD#=2.9867	; maximum ring radius
Const PR%=255				; planet colors RED
Const PG%=192				; planet colors GREEN
Const PB%=128				; planet colors BLUE

Global WIDTH%=GraphicsWidth()
Global HEIGHT%=GraphicsHeight()
Global TIMER%=CreateTimer(60)

Global CAM%,PLANET%,PLANETTEX%,RING%,LIGHT,GLOW%,SHADER%
Global RINGTEX%,ICETEX1%,ICETEX2%,ICETEX3%,SHADOWTEX%

InitNoise(1.0)

; Planet
PLANET=CreateSphere(SEGMENTS)
ScaleEntity PLANET,SCALE,SCALE,SCALE
EntityShininess PLANET,0.1
EntityFX PLANET,2
UpdateVertexColors(PLANET,PR,PG,PB,1)
PLANETTEX=CreateRingTexture(1024,SEED_PLANET,1,False)
TextureBlend PLANETTEX,2
RotateTexture PLANETTEX,90
EntityTexture PLANET,PLANETTEX

; Ring System
CreateSaturnRing(512,50000,1+8)

; Planet Atmosphere
GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,GLOWSEGMENTS,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)

; Planet Fake Shader
SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.75)

; Light source
LIGHT=CreateLight(1)
RotateEntity LIGHT,0,-90,0
AmbientLight 0,0,0

; Camera
CAM=CreateCamera()
CameraRange CAM,0.0001*SCALE,1000*SCALE
MoveEntity CAM,-2*SCALE,0.25*SCALE,-3.5*SCALE
PointEntity CAM,PLANET
TurnEntity CAM,0,0,-10

MoveMouse WIDTH/2,HEIGHT/2

;Include "milkyway.bb" : Global MILKYWAY%=InitMilkyway(5000,0.5,5,90,100,0,0,0,1,128,192,255,1,0,0,0,1)

;===========================================================================
; main loop
;===========================================================================

While Not KeyHit(1)
	
	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%,zoom#=1.0,a#
	
	; move ice "particels"
	a=a+0.001 Mod 360
	RotateTexture ICETEX1,a*0.50
	RotateTexture ICETEX2,a*0.75
	RotateTexture ICETEX3,a*1.00
	
	; SHIFT or RMB = 10x faster cam flight
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=10
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; KEYS 1-3 = show/hide special planet FX
	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING
	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW
	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER
	
	; LMB = Ultra Zoom 100x
	If MouseDown(1) Then zoom=100.0 : l=500.0
	
	; camera movement
	RotateEntity CAM,EntityPitch(CAM)+(MouseYSpeed()/l),EntityYaw(CAM)-(MouseXSpeed()/l),EntityRoll(CAM)
	MoveEntity CAM,(KeyDown(205)-KeyDown(203))*multi*SPEED,0,(KeyDown(200)-KeyDown(208))*multi*SPEED
	MoveMouse WIDTH/2,HEIGHT/2
	CameraZoom CAM,zoom
	
	If MILKYWAY Then PositionEntity MILKYWAY,EntityX(CAM),EntityY(CAM),EntityZ(CAM)
	
	; update atmosphere glow according to camera
	UpdateGlow(GLOW,CAM)
	
	RenderWorld
	
	WaitTimer TIMER
	
	Flip 0
	
Wend

End


;===========================================================================
; create procedural ring detail textures using perlin functions
;===========================================================================

Function CreateProceduralRingTextures(size%,detail%,flags%)
	
	Local buffer1%,buffer2%,buffer3%
	Local x%,y%,rgb%,col%,r%,i%
	
	ICETEX1=CreateTexture(size,size,flags)
	ICETEX2=CreateTexture(size,size,flags)
	ICETEX3=CreateTexture(size,size,flags)
	
	buffer1=TextureBuffer(ICETEX1)
	buffer2=TextureBuffer(ICETEX2)
	buffer3=TextureBuffer(ICETEX3)
	
	LockBuffer buffer1
	LockBuffer buffer2
	LockBuffer buffer3
	
	For x=0 To size-1
		For y=0 To size-1
			rgb=128*$10000+128*$100+128
			WritePixelFast x,y,rgb,buffer1
			WritePixelFast x,y,rgb,buffer2
		Next
	Next
	
	For i=1 To detail
		
		; random position
		x=Rand(0,size-1)
		y=Rand(0,size-1)
		
		; random randomized randomizer
		r=Rand(0,Rand(0,Rand(0,255)))
		
		; perlin noise
		col=Normalize(Perlin3D(x,0,y,4,1,0,15),-1,1,128,255)
		col=Normalize(col+r,128,511,128,255)
		
		; layer 1+2: identical perlin noise mixed with random
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer1
		WritePixelFast x,y,rgb,buffer2
		
		; layer 3: starfield like
		col=Normalize(Perlin3D(x,y,0,16,1,0,7),-1,1,0,128)
		col=Normalize(col+r,0,511,0,255)
		If col&lt;0 Then col=0
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer3
		
	Next
	
	UnlockBuffer buffer3
	UnlockBuffer buffer2
	UnlockBuffer buffer1
	
End Function


;===========================================================================
; main call to create the saturn ring system
;===========================================================================

Function CreateSaturnRing(size%=512,detail%=50000,flags%=1+8)
	
	Local v%,surf%
	
	; create procedural ring textures (ICETEX1-3)
	CreateProceduralRingTextures(size,detail,flags)
	
	; create shadow texture
	SHADOWTEX=CreateSaturnShadow(size,3,180,2,64,24,16)
	
	; create main ring texture
	RINGTEX=CreateRingTexture(size,SEED_RING,3,True,"normal",1.0,0.7)
	
	; create planetary ring
	RING=CreateMesh(PLANET)
	EntityFX RING,1+2+16+32
	EntityBlend RING,3
	surf=CreateSurface(RING)
	UpdateSaturnRing(RING,surf,MINRINGRAD,MAXRINGRAD,RINGDETAIL,255,255,255,255,255,255,1.0,1.0)
	
	; init second UV set
	For v=0 To CountVertices(surf)-1
		VertexTexCoords surf,v,VertexX(surf,v),VertexY(surf,v),0,1
	Next
	
	; reposition shadow texture
	PositionTexture SHADOWTEX,0.5,0.5
	
	; user second UV set
	TextureCoords ICETEX1,1
	TextureCoords ICETEX2,1
	TextureCoords ICETEX3,1
	TextureCoords SHADOWTEX,1
	
	; scale textures
	ScaleTexture ICETEX1,1.0/64,1.0/64
	ScaleTexture ICETEX2,1.0/32,1.0/32
	ScaleTexture ICETEX3,1.0/16,1.0/16
	ScaleTexture SHADOWTEX,6,6
	
	; apply to mesh
	EntityTexture RING,RINGTEX,0,1
	EntityTexture RING,ICETEX1,0,2
	EntityTexture RING,ICETEX2,0,3
	EntityTexture RING,ICETEX3,0,4
	EntityTexture RING,SHADOWTEX,0,5
	
	; blend details
	TextureBlend ICETEX1,3
	TextureBlend ICETEX3,3
	
	; rotate ring
	RotateMesh RING,-90,90,0
	
End Function


;===========================================================================
; create planetary ring mesh
;===========================================================================

Function UpdateSaturnRing(FMesh%,FFace%=1,FRadius1#=1.0,FRadius2#=3.0,FSegments%=120,FR1%=255,FG1%=255,FB1%=255,FR2%=255,FG2%=255,FB2%=255,FAlpha1#=1.0,FAlpha2#=1.0)
	
	If FSegments&gt;360 Then FSegments=360
	
	Local Angle%
	Local RV0%,RV1%,RV2%,RV3%
	Local RX0#,RX1#,RX2#,RX3#
	Local RY0#,RY1#,RY2#,RY3#
	Local SX0#,SX1#,SX2#,SX3#
	Local SY0#,SY1#,SY2#,SY3#
	Local U01#,U23#
	
	For Angle=1 To FSegments Step 1
		
		RX0=Sin(Angle*360.0/FSegments)*FRadius1
		RY0=Cos(Angle*360.0/FSegments)*FRadius1
		RX1=Sin(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RY1=Cos(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RX2=Sin(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RY2=Cos(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RX3=Sin(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		RY3=Cos(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		SX0=RX0: SY0=RY0
		SX1=RX0: SY1=RY0
		SX2=RX3: SY2=RY3
		SX3=RX3: SY3=RY3
		U01=0
		U23=0
		
		RV0=AddVertex(FFace,RX0,RY0,0, U01,0)
		RV1=AddVertex(FFace,RX1,RY1,0, 1,0)
		RV2=AddVertex(FFace,RX2,RY2,0, 1,0)
		RV3=AddVertex(FFace,RX3,RY3,0, U23,0)
		
		VertexColor FFace,RV0,FR1,FG1,FB1,FAlpha1
		VertexColor FFace,RV1,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV2,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV3,FR1,FG1,FB1,FAlpha1
		
		AddTriangle FFace,RV0,RV1,RV2
		AddTriangle FFace,RV2,RV3,RV0
		
	Next
	
	Return FMesh
	
End Function


;===========================================================================
; creates the saturn shadow texture using two spheres, simple math and a cam
;===========================================================================

Function CreateSaturnShadow(size%=512,scale#=3.5,angle#=180.0,blur%=2,col%=64,width#=20.0,length#=9.0)
	
	Local sphere1%,sphere2%,tmp%,surf1%,surf2%
	Local v%,x#,y#,z#,tex%
	
	sphere1=CreateSphere(32)
	EntityFX sphere1,1+2
	
	sphere2=CreateSphere(32)
	EntityFX sphere2,1+2
	
	surf1=GetSurface(sphere1,1)
	surf2=GetSurface(sphere2,1)
	
	For v=0 To CountVertices(surf1)-1
		
		x#=VertexX(surf1,v)
		y#=VertexY(surf1,v)
		z#=VertexZ(surf1,v)
		
		VertexCoords surf1,v,x,y,z*Cos(z*width)*Sqr(z*length)
		VertexColor surf1,v,col,col,col
		VertexColor surf2,v,col,col,col
		
	Next
	
	tex=CreateTexture(size,size)
	
	tmp=CreateCamera()
	PositionEntity tmp,0,scale,0
	CameraClsColor tmp,255,255,255
	CameraViewport tmp,0,0,size,size
	PointEntity tmp,sphere1
	
	RenderWorld
	
	FreeEntity sphere1
	FreeEntity sphere2
	FreeEntity tmp
	
	CopyRect 0,0,size,size,0,0,BackBuffer(),TextureBuffer(tex)
	
	If blur Then BlurTexture(tex,blur,blur)
	
	RotateTexture tex,angle
	
	Return tex
	
End Function


;===========================================================================
; blurs the saturn shadow texture for soft transitions
;===========================================================================

Function BlurTexture(Texture, Blur_Quality, Blur_Radius#)
	
	Local BlurMesh[16*4]
	Local Loop
	Local Blur_Cam
	Local BlurRadius#,BlurAngleStep#,BlurShade%,BlurAngle#,Xoff#,Yoff#
	
	Local BLUR_CAM_X# = 65536.0
	Local BLUR_CAM_Y# = 65536.0
	Local BLUR_CAM_Z# = 0.0
	
	If Blur_Quality &gt; 0
		
		Blur_Cam = CreateCamera()
		CameraViewport Blur_Cam, 0, 0, TextureWidth(Texture), TextureHeight(Texture)
		CameraClsColor Blur_Cam, 0, 0, 0
		CameraClsMode  Blur_Cam, True, True						
		CameraRange Blur_Cam, 0.1, 100
		CameraZoom Blur_Cam, 16.0
		RotateEntity Blur_Cam, 90, 0, 0, True
		PositionEntity Blur_Cam, BLUR_CAM_X#, BLUR_CAM_Y#, BLUR_CAM_Z#
		For Loop = 0 To (Blur_Quality*4)-1
			BlurMesh[Loop] = CreateSprite()
		Next
		TextureBlend Texture, 2
		ScaleTexture    Texture, 0.5, 0.5
		PositionTexture Texture, 0.5, 0.5
		
		BlurRadius = Blur_Radius# * (1.0 / 256.0)
		BlurAngleStep = 360.0 / Float(Blur_Quality*4)
		BlurShade = Ceil(255.0 / Float(Blur_Quality*4))
		
		For Loop = 0 To (Blur_Quality*4)-1
			
			EntityTexture BlurMesh[Loop], Texture
			EntityFX BlurMesh[Loop], 1+8
			EntityAlpha BlurMesh[Loop], 1.0 / Float(Loop+1)
			ScaleSprite BlurMesh[Loop], 2, 2
			
			BlurAngle# = BlurAngleStep# * Float(Loop) + 180.0*(Loop Mod 2)
			
			Xoff# = BlurRadius# * Cos(BlurAngle#)
			Yoff# = BlurRadius# * Sin(BlurAngle#)
			
			PositionEntity BlurMesh[Loop], BLUR_CAM_X# + Xoff#, BLUR_CAM_Y# - 16.0, BLUR_CAM_Z# + Yoff#, True
			
		Next
		
		RenderWorld
		
		CopyRect 0, 0, TextureWidth(Texture), TextureHeight(Texture), 0, 0, BackBuffer(), TextureBuffer(Texture)
		
		For Loop = 0 To (Blur_Quality*4)-1
			FreeEntity BlurMesh[Loop]
		Next
		
		FreeEntity Blur_Cam
		
	EndIf
	
	ScaleTexture Texture,1,1
	PositionTexture Texture,0,0
	
End Function


;===========================================================================
; updates the vertex colors of a mesh
;===========================================================================

Function UpdateVertexColors(mesh%,r%,g%,b%,a#)
	
	Local s%,surf%,v%
	
	For s=1 To CountSurfaces(mesh)
		
		surf=GetSurface(mesh,s)
		
		For v=0 To CountVertices(surf)-1
			
			VertexColor surf,v,r,g,b,a
			
		Next
		
	Next
	
End Function


;===========================================================================
; creates a fake shader (spherical glow effect), should match planet size
;===========================================================================

Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)
	
	Local shader%=CreateSphere(segments)
	Local tex%=CreateFakeShaderTexture()
	
	ScaleEntity shader,size,size,size
	EntityBlend shader,3
	EntityFX shader,2
	EntityOrder shader,-1
	UpdateVertexColors(shader,r,g,b,a)
	
	TextureBlend tex,2
	EntityTexture shader,tex,0,1
	
	Return shader%
	
End Function


;===========================================================================
; creates fake shader texture
;===========================================================================

Function CreateFakeShaderTexture()
	
	Local tex%=CreateTexture(512,512,64)
	Local tb%=TextureBuffer(tex)
	
	Local x%,y%,i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For x=0 To 511
		
		For y=0 To 511
			
			rgb=255*$1000000+255*$10000+255*$100+255
			WritePixelFast x,y,rgb,tb
			
		Next
		
	Next
	
	For j=0 To 255
		
		col=j*1.0/Exp((255-j)*0.02)
		
		If col&gt;255 Then col=255
		If col&lt;0 Then col=0
		
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create planet atmosphere
;===========================================================================

Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	If segments&gt;360 Then segments=360
	
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		VertexColor surf,v0,r1,g1,b1,al1
		VertexColor surf,v1,r1,g1,b1,al1
		VertexColor surf,v2,r2,g2,b2,al2
		VertexColor surf,v3,r2,g2,b2,al2
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function


;===========================================================================
; update planet atmosphere
;===========================================================================

Function UpdateGlow(mesh%,cam%)
	
	Local radius#,distance#
	Local c1#,a1#,q1#,p1#,h1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#
	
	PointEntity mesh,cam
	
	radius=SCALE
	distance=EntityDistance(cam,PLANET)
	
	; First triangle
	c1=distance
	a1=radius
	q1=a1^2/c1
	p1=c1-q1
	h1=Sqr(p1*q1)
	gamma1=90
	alpha1=ATan(h1/p1)
	beta1=gamma1-alpha1
	
	; Second Triangle
	alpha2=90-(90-beta1)
	b2=a1/Tan(alpha2)
	c2=(Sqr(a1^2+b2^2))/radius
	
	ScaleEntity mesh,c2,c2,c2
	
End Function


;===========================================================================
; create planetary ring texture
;===========================================================================

Function CreateRingTexture(size%=1024,seed%=1,flags%=0,usealpha%=False,method$="normal",fading#=1.0,range#=0.7)
	
	Local tex%=CreateTexture(size,1,flags)
	Local buffer%=TextureBuffer(tex)
	
	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#
	
	LockBuffer buffer
	
	For x=0 To size-1
		
		h1=Perlin3D(x*(2048/size),0,0,1024,seed,0,15)
		h2=Perlin3D(0,x*(2048/size),0,512,seed,0,7)
		
		col=Int(Normalize(h1,-range,range,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255
		
		If usealpha Then
			
			If method="soft" Then
				
				; soft rings
				alpha=(Int(Normalize(h2,-range,range,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))/2
				
			Else If method="sharp" Then
				
				; sharp rings
				alpha=Int(Normalize(h1,-range,range,0,2.0)*col)*Rnd(0.9,1.1)
				
			Else
				; normal rings
				alpha=Int(Normalize(h2,-range,range,0,1.0)*col)
			EndIf
			
			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255
			
		Else
			
			alpha=255
			
		EndIf
		
		; soft fading to the outer rings
		If x&gt;(size*fading) Then
			
			value=Normalize(x,size*fading,size,1,0)
			
			alpha=alpha*value
			col=col*value
			
		EndIf
		
		density[x]=(col+alpha)/2
		
		rgb=alpha*$1000000+col*$10000+col*$100+col
		
		WritePixelFast x,0,rgb,buffer
		
	Next
	
	UnlockBuffer buffer
	
	Return tex
	
End Function


;===========================================================================
; normalize value
;===========================================================================

Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


;===========================================================================
; fast perlin noise functions
;===========================================================================

Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function


.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea> <br><br></td></tr></table><br>
<a name="1043129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Krischan,<br><br>Now the planet obscures the near side of the ring (it was fine before).  Then again, I have intel onboard video.  <br><br>Also, the shadow lines should be parallel, unless it has moved a lot closer to the sun than it is now... :-)  <br><br>Ring texture looks nice!<br><br>The marching cubes algorithm seems to be based on an earlier marching squares algorithm.  I found a nice description here:<br><br><a href="http://en.wikipedia.org/wiki/Marching_squares" target="_blank">http://en.wikipedia.org/wiki/Marching_squares</a><br><br>Then read the marching cubes article:<br><br><a href="http://en.wikipedia.org/wiki/Marching_cubes" target="_blank">http://en.wikipedia.org/wiki/Marching_cubes</a><br><br>It all makes sense, but looks like a lot of work since you have to create 15 unique meshes, then create rotations and mirror images of these for a total of 256 meshes, then assign to each one a next direction to proceed after that pattern is applied.<br><br>However, after doing all that you would be able to create a mesh out of a noise cloud.<br><br>The actual construction of the mesh should be simple using sswift's AddMeshToSurface() function:<br><br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=575" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=575</a><br><br>(the Blitz3D AddMesh() function adds a new surface each time as well, or at least it did.  That would be weird in this case with so may surfaces, although I don't know what problems that would cause.)<br><br>But the rest looks too complex for real use, but extremely cool to experiment with.  Now I know how they do those pregnancy MRIs where you can see the baby's face.  Whoa... :-) <br><br></td></tr></table><br>
<a name="1043138"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> For the record, I did read somewhere about a spherical terrain algorithm that involved random bisections of the sphere and puffing up one hemisphere while shrinking the other slightly.  You then did this enough times and it all smoothed out.  I tried it and it seemed very time consuming and just kind of strange, with the predictalbe fault lines running everywhere.<br><br>The method I wrote picked a random point in space around or inside the asteroid (not a random vertex) and applied a linear push to each vertex based on distance (stronger push for nearer vertices as I recall).  This code went missing although an older version of it may be around.  If I find it I'll post it.<br><br>(This was for a screensaver that is an updated starfield simulation; like the classic Windows screensaver but vastly updated.  I have to set up my website so I can post it for y'all!  Maybe I'll go do that now! <br><br></td></tr></table><br>
<a name="1043141"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Axel, the shadow is correct, take a look at this original Cassini picture here (and I don't think NASA moved Saturn closer to sun for this picture :-)<br><br><img src="http://nssdc.gsfc.nasa.gov/planetary/image/cassini_saturn_1.jpg"><br><br>For the ring issue it could be the blendmode 3, just uncomment it in the function CreateSaturnRing -&gt; ;EntityBlend RING,3, otherwise leave it and try this: change the line above it to EntityFX RING,1+2+16 (no +32).<br><br>Without the blending it even looks more realistic as the stars behind the ring vanish when ice particle density gets too high. <br><br></td></tr></table><br>
<a name="1043147"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> For an unrealistic but parallel planet shadow just replace the "CreateSaturnShadow" call in the function "CreateSaturnRing" with this one:<br><br>SHADOWTEX=CreateSaturnShadow(size,3,180,2,64,0.1,1000)<br><br>and for a shadow matching the Cassini picture use<br><br>SHADOWTEX=CreateSaturnShadow(size,3,180,2,64,24,8)<br><br><b>Result</b><br><img src="http://www.christianhart.de/bb/asteroids/parallel_shadow.jpg"><br><br>This stretches the second sphere much more without bending the edges too much - the last two values are important, width and length which are used in this line:<br><br>VertexCoords surf1,v,x,y,z*Cos(z*width)*Sqr(z*length) <br><br></td></tr></table><br>
<a name="1043287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> &lt;embarassment mode&gt;<br><br>Oh, yeah.  Planets are round, aren't they?  I was thinking the disk is close to edge-on to the sun, which would produce nearly straight shadows.<br><br>Hey, wait a minute... The sunlight hitting the planet should then be at the appropraite angle as well; is it?  (as in the real photo you posted)  Aha!<br><br>Also, the ring leaves a shadow on the planet as well, but now I'm just being pedantic.  :-)<br><br>As to the EntityBlend fix; it worked fine, thanks.  Georgeous work! <br><br></td></tr></table><br>
<a name="1043356"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shouldn't the shadow be tapered not bevelled? <br><br></td></tr></table><br>
<a name="1043393"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so I wanted to fix my triangle subdivision code because I noticed it left lots of extra vertices in, but then I got carried away and put some more stuff in.  Such as:<br><br>Deform() deforms the mesh by moving each vertex randomly.<br><br>Smooth() pulls each vertex back towards it's neighbors a bit.<br><br>Try various combinations of the above two commands. <br><br>Shows off the power of vertex colors to make a cool looking asteroid.<br><br>Lets you dynamically set the complexity (0=icosahedron only, 1-5=number of subdivisions).  You can go beyond 5 of course by editing the code, but I have no idea what will happen.  5 produces &gt; 10,000 vertices and 20,000 triangles.<br><br>Actually, the smaller ones look better in my opinion.  About a 1 or 2 perhaps.  They look rockier.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global vertexScale=2

Graphics3D 640,480,32,2
SetBuffer(BackBuffer())
SeedRnd(MilliSecs())

Global Camera=CreateCamera ()
PositionEntity(Camera,0,0,-3)

Global ico
CreateAsteroid()

Global sun=CreateLight()
LightColor(sun,200,200,100)
RotateEntity(sun,45,45,0)
AmbientLight(90,90,128)

Const GameUPS=60 ; Updates per second
Local Period=1000/GameUPS 
Local FrameTime=MilliSecs()-Period

Local Tween#, Ticks,i,Remaining,StartTime,Elapsed

While Not KeyHit(1)
	
	If KeyHit(32)
		Deform(ico)
	EndIf
	
	If KeyHit(31)
		Smooth(ico)
	EndIf
	
	If KeyHit(28)
		FreeEntity(ico)
		CreateAsteroid()
	EndIf
	
	If KeyHit(11) ; 0 key
		vertexScale=0
		FreeEntity(ico)
		CreateAsteroid()
	ElseIf KeyHit(2) ; 1 key
		vertexScale=1
		FreeEntity(ico)
		CreateAsteroid()
	ElseIf KeyHit(3) ; 2 key
		vertexScale=2
		FreeEntity(ico)
		CreateAsteroid()
	ElseIf KeyHit(4) ; 3 key
		vertexScale=3
		FreeEntity(ico)
		CreateAsteroid()
	ElseIf KeyHit(5) ; 4 key
		vertexScale=4
		FreeEntity(ico)
		CreateAsteroid()
	ElseIf KeyHit(6) ; 5 key
		vertexScale=5
		FreeEntity(ico)
		CreateAsteroid()
	EndIf
	
	StartTime = MilliSecs()
	
	Repeat
		Elapsed=MilliSecs()-FrameTime
	Until Elapsed
	
	Ticks=Elapsed / Period
	Tween=Float(Elapsed Mod Period)/Float(Period)
	
	For i=1 To Ticks
		FrameTime=FrameTime+Period
		If i=Ticks Then
			CaptureWorld
		End If
		UpdateGame()
		UpdateWorld
	Next
	RenderWorld Tween
	
	Remaining = Period - (MilliSecs() - StartTime)
	If Remaining &gt; 1 Then 
		Delay (Remaining-1) ; Free some CPU time
	End If
	Text(0,0,"Vertices: "+CountVertices(GetSurface(ico,1)))
	Text(0,15,"Triangles: "+CountTriangles(GetSurface(ico,1)))
	Text(0,30,"Hit D to deform to the asteroid.  Repeat as necessary.")
	Text(0,45,"Hit S to smooth the surface.  Repeat as necessary.")
	Text(0,60,"Hit Enter to create a new asteroid.")
	Text(0,75,"Hit 0, 1, 2, 3, 4, or 5 (slow!) to set complexity.  Current value is "+vertexScale)
	Flip
	
Wend

End

Function UpdateGame()
	TurnEntity(ico,1,.2,0)
	PositionEntity(ico,0,0,EntityZ(ico)*.99)
	; ...
End Function

Function CreateAsteroid()
	ico=CreateIcosahedron(vertexScale)
	Spherize(ico)
	EntityFX(ico,2)
	Local s=GetSurface(ico,1)
	Local v
	Local grey#=128,thisGrey#
	For v=0 To CountVertices(s)-1
		thisGrey=grey+Rnd(-100,50)*Rnd(1)
		VertexColor(s,v,thisGrey,thisGrey,thisGrey)
	Next
	PositionEntity(ico,0,0,100)
End Function

Function CreateIcosahedron(recursions=0)
	Local mesh=CreateMesh()
	Local s=CreateSurface(mesh)
	Local v,t,i,r,newMesh,newS
	Local fifth#=360.0/5.0
	
	;Vertices
	
	AddVertex(s,0,1.1,0)
	
	For i=1 To 5
		v=AddVertex(s,Cos(i*fifth),Sqr(.75)/2.0,Sin(i*360.0/5.0))
	Next
	
	For i=6 To 10
		v=AddVertex(s,Cos((i*fifth)+(fifth/2.0)),-Sqr(.75)/2.0,Sin((i*fifth)+(fifth/2.0)))
	Next
	
	AddVertex(s,0,-1.1,0)
	
	;Triangles
	
	For i=1 To 4
		t=AddTriangle(s,0,i+1,i)
		t=AddTriangle(s,i,i+1,i+5)
	Next
	t=AddTriangle(s,0,1,5)
	t=AddTriangle(s,5,1,10)
	
	For i=7 To 10
		t=AddTriangle(s,i-5,i,i-1)
		t=AddTriangle(s,i-1,i,11)
	Next
	t=AddTriangle(s,1,6,10)
	t=AddTriangle(s,10,6,11)
	
	UpdateNormals(mesh)
	
	For r=1 To recursions
		newMesh=CreateMesh()
		newS=CreateSurface(newMesh)
		For t=0 To CountTriangles(s)-1
			SubdivideTriangle(mesh,s,t,newMesh,newS)
		Next
		FreeEntity(mesh)
		s=newS
		mesh=newMesh
	Next
	
	Return mesh
End Function

;Subdivides a triangle into four little triangles
Function SubdivideTriangle(mesh,surface,triangle,newMesh,newSurface)
	Local s=surface
	Local t=triangle
	Local ns=newSurface
	
	Local oldv0=TriangleVertex(s,t,0)
	Local oldv1=TriangleVertex(s,t,1)
	Local oldv2=TriangleVertex(s,t,2)
	
	;Copy the vertices to the new mesh, if they don't already exist
	Local v0=CheckAddVertex(ns,VertexX(s,oldv0),VertexY(s,oldv0),VertexZ(s,oldv0))
	Local v1=CheckAddVertex(ns,VertexX(s,oldv1),VertexY(s,oldv1),VertexZ(s,oldv1))
	Local v2=CheckAddVertex(ns,VertexX(s,oldv2),VertexY(s,oldv2),VertexZ(s,oldv2))
	
	;Add one vertex midway along each side of the triangle, if it doesn't already exist.
	Local v01=CheckAddVertex(ns,(VertexX(ns,v0)+VertexX(ns,v1))/2.0,(VertexY(ns,v0)+VertexY(ns,v1))/2.0,(VertexZ(ns,v0)+VertexZ(ns,v1))/2.0)
	Local v12=CheckAddVertex(ns,(VertexX(ns,v1)+VertexX(ns,v2))/2.0,(VertexY(ns,v1)+VertexY(ns,v2))/2.0,(VertexZ(ns,v1)+VertexZ(ns,v2))/2.0)
	Local v20=CheckAddVertex(ns,(VertexX(ns,v2)+VertexX(ns,v0))/2.0,(VertexY(ns,v2)+VertexY(ns,v0))/2.0,(VertexZ(ns,v2)+VertexZ(ns,v0))/2.0)
	
	;Add the four corner triangles
	AddTriangle(ns,v0,v01,v20)
	AddTriangle(ns,v1,v12,v01)
	AddTriangle(ns,v2,v20,v12)
	
	;Add the center triangle
	AddTriangle(ns,v01,v12,v20)
	
	;Remember to UpdateNormals() the new mesh after the last time you run this function
End Function

;Puts each vertex at radius 1.0
Function Spherize(m)
	Local s=GetSurface(m,1)
	Local v,alt#
	
	For v=0 To CountVertices(s)
		alt#=Sqr(Sqr(VertexX(s,v)^2+VertexY(s,v)^2)^2+VertexZ(s,v)^2)
		VertexCoords(s,v,VertexX(s,v)/alt,VertexY(s,v)/alt,VertexZ(s,v)/alt)
	Next
	UpdateNormals(m)
End Function

;Checks to see if there is already a vertex is already at that location.  If not, makes one.
Function CheckAddVertex(surface,x#,y#,z#)
	Local alreadyThere=False
	Local v, vertex
	For v=0 To CountVertices(surface)-1
		If VertexX(surface,v)=x And VertexY(surface,v)=y And VertexZ(surface,v)=z
			alreadyThere=True
			vertex=v
		EndIf
	Next
	If alreadyThere=False
		vertex=AddVertex(surface,x,y,z)
	EndIf
	
	Return vertex
	
End Function

;Pretty much messes up the asteroid.
Function Deform(mesh)
	Local s=GetSurface(mesh,1)
	Local r#=.8
	Local v
	For v=0 To CountVertices(s)-1
		VertexCoords(s,v,VertexX(s,v)+Rnd(-r,r)*Rnd(1)^2,VertexY(s,v)+Rnd(-r,r)*Rnd(1)^2,VertexZ(s,v)+Rnd(-r,r)*Rnd(1)^2)
	Next
End Function

;Brings the vertices in each triangle closer to each other.
Function Smooth(mesh)
	Local s=GetSurface(mesh,1)
	Local pivot1=CreatePivot()
	Local pivot2=CreatePivot()
	Local v,ov,t,tv,otv
	For t=0 To CountTriangles(s)-1
		For v=0 To 2
			
			Repeat
				ov=Rand(0,2)
			Until ov&lt;&gt;v
			
			tv=TriangleVertex(s,t,v)
			otv=TriangleVertex(s,t,ov)
			PositionEntity(pivot1,VertexX(s,TriangleVertex(s,t,v)),VertexY(s,TriangleVertex(s,t,v)),VertexZ(s,TriangleVertex(s,t,v)))
			PositionEntity(pivot2,VertexX(s,TriangleVertex(s,t,ov)),VertexY(s,TriangleVertex(s,t,ov)),VertexZ(s,TriangleVertex(s,t,ov)))
			PointEntity(pivot1,pivot2)
			MoveEntity(pivot1,0,0,.1*EntityDistance(pivot1,pivot2))
			PointEntity(pivot2,pivot1)
			MoveEntity(pivot2,0,0,.1*EntityDistance(pivot1,pivot2))
			VertexCoords(s,tv,EntityX(pivot1),EntityY(pivot1),EntityZ(pivot1))
			VertexCoords(s,otv,EntityX(pivot2),EntityY(pivot2),EntityZ(pivot2))
		Next
	Next
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1043403"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Rroff: I think it depends on the sun angle, see <a href="http://saturn.jpl.nasa.gov/photos/imagedetails/index.cfm?imageId=854" target="_blank">PIA06424</a> and this is very interesting <a href="http://saturn.jpl.nasa.gov/photos/imagedetails/index.cfm?imageId=2508" target="_blank">PIA08361</a>. I think it should only look cool even if it is not very realistic :-p<br><br><img src="http://saturn.jpl.nasa.gov/multimedia/images/rings/images/PIA08361-br500.jpg"><br><br>@Axel: this is very usable, even with LOD. I suggest two improvements:<br>- in the Function CreateAsteroid: thisGrey=grey+Rnd(-50,50)*Rnd(1)<br>- add UV coordinates that a texture can be applied (cylindrical texture or detail) <br><br></td></tr></table><br>
<a name="1043442"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's nice too, Krischan - I had just cut 'Ellipse' (used 225 degrees instead of 360) so it had a gap facing away from the sun behind the planet  to cheat to get the shadow effect, it's nowhere near as good as 'doing it properly'!<br><br><div class="quote"> Oh, yeah. Planets are round, aren't they? I was thinking the disk is close to edge-on to the sun, which would produce nearly straight shadows <br></div><br><br>Saturn is most oblate of all the planets, around 10% difference between the circumference of the meridian and the equator. It has the lowest density, so the rings appear to "wobble" too, sincve they are equatorial to the planet, but the planet itself has an inclination of around 27 degrees to the orbital plane.<br>The precession of the poles is about half a degree every 50 days or so. <br><br></td></tr></table><br>
<a name="1043473"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Krischan: That looks awesome.<br><br>I had experimented with the grey values, and somehow the light highlights didn't look good to me.<br>'<br>As to UV coords; this is not designed around textures at all; but I'll check it out! <br><br></td></tr></table><br>
<a name="1043513"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Axel Wheeler: Your asteroid deformation code is quite nice. It appears pretty good for what we're aiming for. Nice work! <br><br></td></tr></table><br>
<a name="1043519"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> [img]<br><img src="http://www.utahskies.org/news/2009/01/saturnFromCassini_large.jpg"><br>[/img]<br><br>The real thing, in silhouette via Cassini.  (Hope its size doesn't violate a rule...)<br><br>Krischan; I just re-read the original post.  Don't forget CopyEntity() which will greatly increase the number of asteroids you have on screen.  And while all of the same one would be identical in shape, they could still differ greatly in size and texture (I think).  I don't know about different vertex alpha for each copy; somehow I doubt it.<br><br>So you could have 100 originals and 100 copies of each (or much more, depending on how simple they are.)  Also of course they can rotate differently. <br><br></td></tr></table><br>
<a name="1043653"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome image!<br><br>Going straight on my wallpaper. :) <br><br></td></tr></table><br>
<a name="1043746"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> By the way - today I found a nice video showing 30 years of asteroid discoveries, very stunning:<br><br><a href="http://www.universetoday.com/72151/astounding-video-shows-30-years-of-asteroid-discoveries/" target="_blank">Astounding Video Shows 30 Years of Asteroid Discoveries</a> <br><br></td></tr></table><br>
<a name="1043927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's an amazing video Krischan.  Bookmarked. <br><br></td></tr></table><br>
<a name="1044012"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ClayPigeon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Diddo. Favorited. <br><br></td></tr></table><br>
<a name="1044020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK, I'll try to top the video, no comment, try it yourself. Again - everything is procedural. And Blitz3D only :-D<br><br>Use arrows/mouse and SHIFT or RMB to speed up! Have a nice day at saturn.<br><br><img src="http://www.christianhart.de/bb/asteroids/saturnv2.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Procedural Saturn 2.0"

Graphics3D 800,600,32,2

Dim P%(512),GRAYD#(512),HeightMap#(0,0),NoiseMap#(0,0)
Global minh#=2^16,Maxh#

Global density%[1024]

Global vis%

Type star
	
	Field col%
	Field scale#
	Field x#,y#,z#
	Field visible%
	
End Type

Const SCALEX#		= 5.0	; starfield scale X
Const SCALEY#		= 0.5	; starfield scale Y
Const SCALEZ#		= 5.0	; starfield scale Z
Const MAXSTARS%		= 10000 ; maximum asteroids
Const TurnSpeed#	= 4.0	; cam turn speed
Const RollSpeed#	= 0.5	; cam roll speed
Const CameraSpeed#	= 0.01	; cam move speed
Const SEED_PLANET1%=8		; seed for procedural planet texture
Const SEED_PLANET2%=8		; seed for procedural planet texture
Const SEED_RING1%=6			; seed for procedural ring texture
Const SEED_RING2%=6			; seed for procedural ring texture
Const SCALE#=100.0			; planet scale
Const SEGMENTS%=64			; sphere detail
Const RINGDETAIL%=360		; ring segments
Const GLOWSEGMENTS%=360		; glow segments
Const MINRINGRAD#=0.7		; minimum ring radius
Const MAXRINGRAD#=3.0		; maximum ring radius
Const PR%=255				; planet colors RED
Const PG%=192				; planet colors GREEN
Const PB%=128				; planet colors BLUE

Global WIDTH%=GraphicsWidth()
Global HEIGHT%=GraphicsHeight()
Global TIMER%=CreateTimer(60)

Global CAM%,PLANET%,PLANETTEX%,RING%,LIGHT,GLOW%,SHADER%
Global RINGTEX%,ICETEX1%,ICETEX2%,ICETEX3%,SHADOWTEX%

InitNoise(1.0)

; Planet
PLANET=CreateSphere(SEGMENTS)
ScaleEntity PLANET,SCALE,SCALE,SCALE
EntityShininess PLANET,0.1
EntityFX PLANET,2
UpdateVertexColors(PLANET,PR,PG,PB,1)
PLANETTEX=CreateRingTexture(256,SEED_PLANET1,SEED_PLANET2,1,False,"soft",1.0,1.0)
TextureBlend PLANETTEX,2
RotateTexture PLANETTEX,90
EntityTexture PLANET,PLANETTEX

; Planet Atmosphere
GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,GLOWSEGMENTS,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)

; Planet Fake Shader
SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.6)

; Ring System
CreateSaturnRing(512,50000,1+8,"normal","normal",0.95,0.75,"perlin")

; Light source
LIGHT=CreateLight(1)
RotateEntity LIGHT,0,-90,0
AmbientLight 0,0,0

; Camera
CAM=CreateCamera()
CameraRange CAM,0.0001*SCALE,1000*SCALE
MoveEntity CAM,-1*SCALE,1.0/64*SCALE,-2*SCALE
PointEntity CAM,PLANET

; star quad
Global star=CreateQuad()
HideEntity star

; starfield mesh
Global starfield=CreateMesh()
Global surf=CreateSurface(starfield)
EntityTexture starfield,CreateStarTexture()
EntityFX starfield,1+2+32
EntityBlend starfield,3

; fill star field
AddStars(MAXSTARS,0.01,0.02)

; Milkyway background
;Include "milkyway.bb" : Global MILKYWAY%=InitMilkyway(5000,0.5,5,90,1,0,0,0,1,255,192,255,1,0,0,0,1)

MoveMouse WIDTH/2,HEIGHT/2

;===========================================================================
; main loop
;===========================================================================
While Not KeyHit(1)
	
	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%,zoom#=1.0,a#
	
	; move ice "particels"
	;a=a+0.001 Mod 360
	;RotateTexture ICETEX1,a*0.50
	;RotateTexture ICETEX2,a*0.75
	;RotateTexture ICETEX3,a*1.00
	
	; SHIFT or RMB = 50x faster cam flight
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=50
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; KEYS 1-3 = show/hide special planet FX
	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING
	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW
	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER
	
	; LMB = Ultra Zoom 100x
	If MouseDown(1) Then zoom=100.0 : l=500.0
	
	; camera movement
	Movement(CAM)
	CameraZoom CAM,zoom
	
	If MILKYWAY Then PositionEntity MILKYWAY,EntityX(CAM),EntityY(CAM),EntityZ(CAM)
	
	; update atmosphere glow according to camera
	UpdateGlow(GLOW,CAM)
	
	; calc ring density
	d#=EntityDistance(CAM,PLANET)
	If d&gt;SCALE*MINRINGRAD And d&lt;SCALE*MAXRINGRAD Then
		ds=Int(density[Normalize(d,SCALE*MINRINGRAD,SCALE*MAXRINGRAD,0,512)])
	EndIf
	
	; update asteroids
	UpdateStarfield(CAM,5,1,ds)
	
	; Update Saturn Ring Alpha
	s#=1.0-(1.0/Exp(Abs(EntityY(CAM)*0.5)))
	UpdateVertexColors(RING,255,255,255,s)
	
	RenderWorld
	
	WaitTimer TIMER
	
	; show some stats in the app title
	AppTitle vis+" Stars | "+(ds/2.55)+"% Ring Density"
	
	Flip 0
	
Wend

End


; -----------------------------------------------------------------------------
; simple spaceship freeflight
; -----------------------------------------------------------------------------
Function Movement(cam%,sensitivity#=1.0)
	
	Local roll#,cx#,cz#,tx#,ty#,multi%=1
	
	cx=(KeyDown(205)-KeyDown(203))*CameraSpeed
	cz=(KeyDown(200)-KeyDown(208))*CameraSpeed
	roll=(KeyDown(203)-KeyDown(205))*RollSpeed
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=25
	
	tx=Normalize(MouseX(),0,WIDTH , 1,-1)
	ty=Normalize(MouseY(),0,HEIGHT,-1, 1)
	
	If ty&lt;0 Then ty=(Abs(ty)^sensitivity)*-1 Else ty=ty^sensitivity
	If tx&lt;0 Then tx=(Abs(tx)^sensitivity)*-1 Else tx=tx^sensitivity
	
	TurnEntity cam,ty*TurnSpeed,tx*TurnSpeed,roll*TurnSpeed
	MoveEntity cam,cx*multi,0,cz*multi
	
End Function


; -----------------------------------------------------------------------------
; create a quad
; -----------------------------------------------------------------------------
Function CreateQuad(r%=255,g%=255,b%=255,a#=1.0)
	
	Local mesh%,surf%,v1%,v2%,v3%,v4%
	
	mesh=CreateMesh()
	surf=CreateSurface(mesh)
	
	v1=AddVertex(surf,-1,1,0,1,0)
	v2=AddVertex(surf,1,1,0,0,0)
	v3=AddVertex(surf,-1,-1,0,1,1)
	v4=AddVertex(surf,1,-1,0,0,1)
	
	VertexColor surf,v1,r,g,b,a
	VertexColor surf,v3,r,g,b,a
	VertexColor surf,v2,r,g,b,a
	VertexColor surf,v4,r,g,b,a
	
	AddTriangle(surf,0,1,2)
	AddTriangle(surf,3,2,1)
	
	FlipMesh mesh
	
	Return mesh
	
End Function


; -----------------------------------------------------------------------------
; rebuild starfield mesh
; -----------------------------------------------------------------------------
Function UpdateStarfield(parent%,maxdist#=2.0,fader%=False,ds%)
	
	Local s.star,px#,py#,pz#,d#,a#
	
	Local cx#=EntityX(parent)
	Local cy#=EntityY(parent)
	Local cz#=EntityZ(parent)
	
	Local density%=Int(ds/2.55)
	
	ClearSurface(surf)
	
	vis=0
	
	For s.star = Each star
		
		; calc star position
		px=cx-s\x
		py=cy-s\y
		pz=cz-s\z
		
		; check if star must be moved
		If px&lt;-SCALEX Then s\x=s\x-(SCALEX*2) : s\visible=False : If Rand(100)&lt;density Then s\visible=True
		If px&gt;+SCALEX Then s\x=s\x+(SCALEX*2) : s\visible=False : If Rand(100)&lt;density Then s\visible=True
		If pz&lt;-SCALEZ Then s\z=s\z-(SCALEZ*2) : s\visible=False : If Rand(100)&lt;density Then s\visible=True
		If pz&gt;+SCALEZ Then s\z=s\z+(SCALEZ*2) : s\visible=False : If Rand(100)&lt;density Then s\visible=True
		
		If s\visible Then
			
			; reposition star
			PositionEntity star,s\x,s\y,s\z
			
			; get distance
			d=EntityDistance(star,CAM)
			
			; check if not to far away
			If d&lt;maxdist Then
				
				; star is visible?
				If EntityInView(star,CAM) Then
					
					; align star to cam
					PointEntity star,CAM
					
					ScaleEntity star,s\scale,s\scale,s\scale
					
					; add alpha
					a=1.0 : If fader Then a=Normalize(d,maxdist*0.5,maxdist,1,0)
					
					; add star To starfield again
					AddMeshToSurface(star,surf,starfield,s\col,s\col,s\col,a)
					
					vis=vis+1
					
				EndIf
				
			EndIf
			
		EndIf
		
	Next
	
	Return density
	
End Function


; -----------------------------------------------------------------------------
; add a mesh to another mesh
; -----------------------------------------------------------------------------
Function AddMeshToSurface(mesh,surf,singlesurfaceentity,r%,g%,b%,a#) 
	
	Local vert%[2],vr%[2],vg%[2],vb%[2],va#[2],nx#[2],ny#[2],nz#[2]
	Local surface%,oldvert%,i%,i2%
	
	surface = GetSurface(mesh,1) 
	
	For i = 0 To CountTriangles(surface)-1
		
		For i2 = 0 To 2 
			
			oldvert = TriangleVertex(surface,i,i2)
			
			vr[i2]=r
			vg[i2]=g
			vb[i2]=b
			va[i2]=a
			nx[i2]=VertexNX(surface,oldvert)
			ny[i2]=VertexNY(surface,oldvert)
			nz[i2]=VertexNZ(surface,oldvert)
			
			TFormPoint VertexX(surface,oldvert),VertexY(surface,oldvert),VertexZ(surface,oldvert), mesh,singlesurfaceentity 
			vert[i2] = AddVertex(surf,TFormedX(),TFormedY(),TFormedZ(),VertexU(surface,oldvert),VertexV(surface,oldvert)) 
			VertexNormal surf,vert[i2],nx[i2],ny[i2],nz[i2]
			VertexColor surf,vert[i2],r,g,b,a
			
		Next 
		
		AddTriangle(surf,vert[0],vert[1],vert[2])
		
	Next 
	
End Function


; -----------------------------------------------------------------------------
; add stars to starfield mesh
; -----------------------------------------------------------------------------
Function AddStars(amount%=1,min#=0.01,max#=0.02,addx#=0.0,addy#=0.0,addz#=0.0)
	
	Local i%,s.star
	Local density%=Normalize(Perlin3D(0,0,0,16,1,0,3),-1,1,0,100)
	If density&lt;0 Then density=0 Else If density&gt;100 Then density=100
	
	For i=1 To amount
		
		s.star = New star
		
		s\col=Rand(64,255)
		s\x=addx+Rnd(-SCALEX,SCALEX)
		s\y=addy+Rnd(Rnd(Rnd(Rnd(-SCALEY))),Rnd(Rnd(Rnd(SCALEY))))
		s\z=addz+Rnd(-SCALEZ,SCALEZ)
		s\scale=Rnd(min,max)
		
		If Distance3D(0,0,0,s\x,s\y,s\z)&lt;=2 Then
			
			If Rand(100)&lt;density Then s\visible=True
			
		Else
			
			If Rand(100)&lt;MAXSTARS/2 Then s\visible=True
			
		EndIf
		
	Next
	
End Function


; -----------------------------------------------------------------------------
; simple 3D distance calculation
; -----------------------------------------------------------------------------
Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Local x#=x1-x2
	Local y#=y1-y2
	Local z#=z1-z2
	
	Return Sqr((x*x)+(y*y)+(z*z))
	
End Function


; -----------------------------------------------------------------------------
; create a simple star texture
; -----------------------------------------------------------------------------
Function CreateStarTexture(size%=256,flags%=3)
	
	Local tex%=CreateTexture(size,size,flags)
	Local tb%=TextureBuffer(tex)
	
	Local i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For j=0 To 255
		
		col=255-j
		If col&gt;255 Then col=255
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast (size/2)+(Sin(i)*(j*size/512)),(size/2)+(Cos(i)*(j*size/512)),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create procedural ring detail textures using perlin functions
;===========================================================================
Function CreateProceduralRingTextures(brightness1%=192,brightness2%=160,brightness3%=128,size%,detail%,flags%,noisetype$="perlin")
	
	Local buffer1%,buffer2%,buffer3%
	Local x%,y%,rgb%,rgb1%,rgb2%,col%,r%,i%
	
	If noisetype="fast" Then
		Dim HeightMap(size,size)
		Dim NoiseMap(size+1,size+1)
		FastNoise(size,8,1.2,1)
	EndIf
	
	ICETEX1=CreateTexture(size,size,flags)
	ICETEX2=CreateTexture(size,size,flags)
	ICETEX3=CreateTexture(size,size,flags)
	
	buffer1=TextureBuffer(ICETEX1)
	buffer2=TextureBuffer(ICETEX2)
	buffer3=TextureBuffer(ICETEX3)
	
	LockBuffer buffer1
	LockBuffer buffer2
	LockBuffer buffer3
	
	For x=0 To size-1
		For y=0 To size-1
			rgb1=brightness1*$10000+brightness1*$100+brightness1
			rgb2=brightness2*$10000+brightness2*$100+brightness2
			WritePixelFast x,y,rgb1,buffer1
			WritePixelFast x,y,rgb2,buffer2
		Next
	Next
	
	For i=1 To detail
		
		; random position
		x=Rand(0,size-1)
		y=Rand(0,size-1)
		
		; random randomized randomizer
		r=Rand(0,Rand(0,Rand(0,255)))
		
		; perlin or fast noise
		If noisetype="fast" Then
			col=Normalize(HeightMap(x,0),minh,Maxh,brightness1,255)
		Else
			col=Normalize(Perlin3D(x,0,y,4,1,0,15),-1,1,brightness1,255)
		EndIf
		col=Normalize(col+r,brightness1,511,brightness2,255)
		
		; layer 1+2: identical perlin noise mixed with random
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer1
		WritePixelFast x,y,rgb,buffer2
		
		; layer 3: starfield like
		If noisetype="fast" Then
			col=Normalize(HeightMap(y,x),minh,Maxh,0,128)
		Else
			col=Normalize(Perlin3D(x,y,0,16,1,0,7),-1,1,0,128)
		EndIf
		col=Normalize(col+r,0,511,brightness3,255)
		If col&lt;brightness3 Then col=brightness3
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer3
		
	Next
	
	UnlockBuffer buffer3
	UnlockBuffer buffer2
	UnlockBuffer buffer1
	
End Function


;===========================================================================
; main call to create the saturn ring system
;===========================================================================
Function CreateSaturnRing(size%=512,detail%=50000,flags%=1+8,mode$="normal",style$="cassini",fading#=0.85,range#=0.7,noisetype$="perlin")
	
	Local v%,surf%
	
	; create procedural ring textures (ICETEX1-3)
	CreateProceduralRingTextures(160,192,0,size,detail,flags,noisetype)
	
	; create shadow texture
	If style="cassini" Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,8)
	Else If style="linear" Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,0,100)
	Else
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,16)
	EndIf
	
	; create main ring texture
	RINGTEX=CreateRingTexture(size,SEED_RING1,SEED_RING2,3,True,mode,fading,range)
	
	; create planetary ring
	RING=CreateMesh(PLANET)
	EntityFX RING,1+2+16+32
	;EntityBlend RING,3
	surf=CreateSurface(RING)
	UpdateSaturnRing(RING,surf,MINRINGRAD,MAXRINGRAD,RINGDETAIL,255,255,255,255,255,255,1.0,1.0)
	
	; init second UV set
	For v=0 To CountVertices(surf)-1
		VertexTexCoords surf,v,VertexX(surf,v),VertexY(surf,v),0,1
	Next
	
	; reposition shadow texture
	PositionTexture SHADOWTEX,0.5,0.5
	
	; user second UV set
	TextureCoords ICETEX1,1
	TextureCoords ICETEX2,1
	TextureCoords ICETEX3,1
	TextureCoords SHADOWTEX,1
	
	; scale textures
	ScaleTexture ICETEX1,1.0/64,1.0/64
	ScaleTexture ICETEX2,1.0/16,1.0/16
	ScaleTexture ICETEX3,1.0/8,1.0/8
	ScaleTexture SHADOWTEX,6,6
	
	; apply to mesh
	EntityTexture RING,RINGTEX,0,1
	EntityTexture RING,ICETEX1,0,2
	EntityTexture RING,ICETEX2,0,3
	EntityTexture RING,ICETEX3,0,4
	EntityTexture RING,SHADOWTEX,0,5
	
	; blend details
	TextureBlend ICETEX1,3
	TextureBlend ICETEX3,3
	
	; rotate ring
	RotateMesh RING,-90,90,0
	
End Function


;===========================================================================
; create planetary ring mesh
;===========================================================================
Function UpdateSaturnRing(FMesh%,FFace%=1,FRadius1#=1.0,FRadius2#=3.0,FSegments%=120,FR1%=255,FG1%=255,FB1%=255,FR2%=255,FG2%=255,FB2%=255,FAlpha1#=1.0,FAlpha2#=1.0)
	
	If FSegments&gt;360 Then FSegments=360
	
	Local Angle%
	Local RV0%,RV1%,RV2%,RV3%
	Local RX0#,RX1#,RX2#,RX3#
	Local RY0#,RY1#,RY2#,RY3#
	Local SX0#,SX1#,SX2#,SX3#
	Local SY0#,SY1#,SY2#,SY3#
	Local U01#,U23#
	
	For Angle=1 To FSegments Step 1
		
		RX0=Sin(Angle*360.0/FSegments)*FRadius1
		RY0=Cos(Angle*360.0/FSegments)*FRadius1
		RX1=Sin(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RY1=Cos(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RX2=Sin(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RY2=Cos(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RX3=Sin(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		RY3=Cos(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		SX0=RX0: SY0=RY0
		SX1=RX0: SY1=RY0
		SX2=RX3: SY2=RY3
		SX3=RX3: SY3=RY3
		U01=0
		U23=0
		
		RV0=AddVertex(FFace,RX0,RY0,0, U01,0)
		RV1=AddVertex(FFace,RX1,RY1,0, 1,0)
		RV2=AddVertex(FFace,RX2,RY2,0, 1,0)
		RV3=AddVertex(FFace,RX3,RY3,0, U23,0)
		
		VertexColor FFace,RV0,FR1,FG1,FB1,FAlpha1
		VertexColor FFace,RV1,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV2,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV3,FR1,FG1,FB1,FAlpha1
		
		AddTriangle FFace,RV0,RV1,RV2
		AddTriangle FFace,RV2,RV3,RV0
		
	Next
	
	Return FMesh
	
End Function


;===========================================================================
; creates the saturn shadow texture using two spheres, simple math and a cam
;===========================================================================
Function CreateSaturnShadow(size%=512,scale#=3.5,angle#=180.0,blur%=2,col%=64,width#=20.0,length#=9.0)
	
	Local sphere1%,sphere2%,tmp%,surf1%,surf2%
	Local v%,x#,y#,z#,tex%,add#
	
	sphere1=CreateSphere(32)
	EntityFX sphere1,1+2
	
	sphere2=CreateSphere(32)
	EntityFX sphere2,1+2
	
	surf1=GetSurface(sphere1,1)
	surf2=GetSurface(sphere2,1)
	
	For v=0 To CountVertices(surf1)-1
		
		x#=VertexX(surf1,v)
		y#=VertexY(surf1,v)
		z#=VertexZ(surf1,v)
		
		If z&gt;0 Then add=Sqr(z*length) Else add=1
		
		VertexCoords surf1,v,x,y,z*Cos(width)*add
		VertexColor surf1,v,col,col,col
		VertexColor surf2,v,col,col,col
		
	Next
	
	tex=CreateTexture(size,size)
	
	tmp=CreateCamera()
	PositionEntity tmp,0,scale,0
	CameraClsColor tmp,255,255,255
	CameraViewport tmp,0,0,size,size
	PointEntity tmp,sphere1
	
	RenderWorld
	
	FreeEntity sphere1
	FreeEntity sphere2
	FreeEntity tmp
	
	CopyRect 0,0,size,size,0,0,BackBuffer(),TextureBuffer(tex)
	
	If blur Then BlurTexture(tex,blur,blur)
	
	RotateTexture tex,angle
	
	Return tex
	
End Function


;===========================================================================
; blurs the saturn shadow texture for soft transitions
;===========================================================================
Function BlurTexture(Texture, Blur_Quality, Blur_Radius#)
	
	Local BlurMesh[16*4]
	Local Loop
	Local Blur_Cam
	Local BlurRadius#,BlurAngleStep#,BlurShade%,BlurAngle#,Xoff#,Yoff#
	
	Local BLUR_CAM_X# = 65536.0
	Local BLUR_CAM_Y# = 65536.0
	Local BLUR_CAM_Z# = 0.0
	
	If Blur_Quality &gt; 0
		
		Blur_Cam = CreateCamera()
		CameraViewport Blur_Cam, 0, 0, TextureWidth(Texture), TextureHeight(Texture)
		CameraClsColor Blur_Cam, 0, 0, 0
		CameraClsMode  Blur_Cam, True, True						
		CameraRange Blur_Cam, 0.1, 100
		CameraZoom Blur_Cam, 16.0
		RotateEntity Blur_Cam, 90, 0, 0, True
		PositionEntity Blur_Cam, BLUR_CAM_X#, BLUR_CAM_Y#, BLUR_CAM_Z#
		For Loop = 0 To (Blur_Quality*4)-1
			BlurMesh[Loop] = CreateSprite()
		Next
		TextureBlend Texture, 2
		ScaleTexture    Texture, 0.5, 0.5
		PositionTexture Texture, 0.5, 0.5
		
		BlurRadius = Blur_Radius# * (1.0 / 256.0)
		BlurAngleStep = 360.0 / Float(Blur_Quality*4)
		BlurShade = Ceil(255.0 / Float(Blur_Quality*4))
		
		For Loop = 0 To (Blur_Quality*4)-1
			
			EntityTexture BlurMesh[Loop], Texture
			EntityFX BlurMesh[Loop], 1+8
			EntityAlpha BlurMesh[Loop], 1.0 / Float(Loop+1)
			ScaleSprite BlurMesh[Loop], 2, 2
			
			BlurAngle# = BlurAngleStep# * Float(Loop) + 180.0*(Loop Mod 2)
			
			Xoff# = BlurRadius# * Cos(BlurAngle#)
			Yoff# = BlurRadius# * Sin(BlurAngle#)
			
			PositionEntity BlurMesh[Loop], BLUR_CAM_X# + Xoff#, BLUR_CAM_Y# - 16.0, BLUR_CAM_Z# + Yoff#, True
			
		Next
		
		RenderWorld
		
		CopyRect 0, 0, TextureWidth(Texture), TextureHeight(Texture), 0, 0, BackBuffer(), TextureBuffer(Texture)
		
		For Loop = 0 To (Blur_Quality*4)-1
			FreeEntity BlurMesh[Loop]
		Next
		
		FreeEntity Blur_Cam
		
	EndIf
	
	ScaleTexture Texture,1,1
	PositionTexture Texture,0,0
	
End Function


;===========================================================================
; updates the vertex colors of a mesh
;===========================================================================
Function UpdateVertexColors(mesh%,r%,g%,b%,a#)
	
	Local s%,surf%,v%
	
	For s=1 To CountSurfaces(mesh)
		
		surf=GetSurface(mesh,s)
		
		For v=0 To CountVertices(surf)-1
			
			VertexColor surf,v,r,g,b,a
			
		Next
		
	Next
	
End Function


;===========================================================================
; creates a fake shader (spherical glow effect), should match planet size
;===========================================================================
Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)
	
	Local shader%=CreateSphere(segments)
	Local tex%=CreateFakeShaderTexture()
	
	ScaleEntity shader,size,size,size
	EntityBlend shader,3
	EntityFX shader,2
	EntityOrder shader,-1
	UpdateVertexColors(shader,r,g,b,a)
	
	TextureBlend tex,2
	EntityTexture shader,tex,0,1
	
	Return shader%
	
End Function


;===========================================================================
; creates fake shader texture
;===========================================================================
Function CreateFakeShaderTexture()
	
	Local tex%=CreateTexture(512,512,64)
	Local tb%=TextureBuffer(tex)
	
	Local x%,y%,i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For x=0 To 511
		
		For y=0 To 511
			
			rgb=255*$1000000+255*$10000+255*$100+255
			WritePixelFast x,y,rgb,tb
			
		Next
		
	Next
	
	For j=0 To 255
		
		col=j*1.0/Exp((255-j)*0.02)
		
		If col&gt;255 Then col=255
		If col&lt;0 Then col=0
		
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create planet atmosphere
;===========================================================================
Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	If segments&gt;360 Then segments=360
	
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		VertexColor surf,v0,r1,g1,b1,al1
		VertexColor surf,v1,r1,g1,b1,al1
		VertexColor surf,v2,r2,g2,b2,al2
		VertexColor surf,v3,r2,g2,b2,al2
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function


;===========================================================================
; update planet atmosphere
;===========================================================================
Function UpdateGlow(mesh%,cam%)
	
	Local radius#,distance#
	Local c1#,a1#,q1#,p1#,h1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#
	
	PointEntity mesh,cam
	
	radius=SCALE
	distance=EntityDistance(cam,PLANET)
	
	; First triangle
	c1=distance
	a1=radius
	q1=a1^2/c1
	p1=c1-q1
	h1=Sqr(p1*q1)
	gamma1=90
	alpha1=ATan(h1/p1)
	beta1=gamma1-alpha1
	
	; Second Triangle
	alpha2=90-(90-beta1)
	b2=a1/Tan(alpha2)
	c2=(Sqr(a1^2+b2^2))/radius
	
	ScaleEntity mesh,c2,c2,c2
	
End Function


;===========================================================================
; create planetary ring texture
;===========================================================================
Function CreateRingTexture(size%=1024,seed1%=1,seed2%=2,flags%=0,usealpha%=False,method$="normal",fading#=1.0,range#=0.7)
	
	Local tex%=CreateTexture(size,1,flags)
	Local buffer%=TextureBuffer(tex)
	
	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#
	
	LockBuffer buffer
	
	For x=0 To size-1
		
		h1=Perlin3D(x*(2048/size),0,0,1024,seed1,0,15)
		h2=Perlin3D(0,x*(2048/size),0,512,seed2,0,7)
		
		col=Int(Normalize(h1,-range,range,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255
		
		If usealpha Then
			
			If method="soft" Then
				
				; soft rings
				alpha=(Int(Normalize(h2,-range,range,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))/2.0
				
			Else If method="sharp" Then
				
				; sharp rings
				alpha=Int(Normalize(h1,-range,range,0,1.0)*col)*Rnd(0.98,1.02)
				
			Else
				; normal rings
				alpha=Int(Normalize(h2,-range,range,0,1.0)*col)
			EndIf
			
			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255
			
		Else
			
			alpha=255
			
		EndIf
		
		; soft fading to the outer rings
		If x&gt;(size*fading) Then
			
			value=Normalize(x,size*fading,size,1,0)
			
			alpha=alpha*value
			col=col*value
			
		EndIf
		
		density[x]=alpha;(col+alpha)/2
		
		rgb=alpha*$1000000+col*$10000+col*$100+col
		
		WritePixelFast x,0,rgb,buffer
		
	Next
	
	UnlockBuffer buffer
	
	Return tex
	
End Function


;===========================================================================
; normalize value
;===========================================================================
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


;===========================================================================
; fast perlin noise functions
;===========================================================================
Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

Function FastNoise(size%,Scale#,Multiplier#,wrap%=False)
	
	Local Max_Height#,NoiseMapSize%,ScaleDifference#,StepSize#
	Local N1#,N2#,N3#,N4#,HX#,HY#,IX#,IY#,ICX#,ICY#,NA#,NB#,NC#,ND#
	Local i%,x%,y%,xx%,yy%
	Local v#
	
	Max_Height=Scale
	
	For y=0 To size Step 1
		
		For x=0 To size Step 1
			
			HeightMap(x,y)=Rnd(0,1)
			
		Next
		
	Next
	
	NoiseMapSize=size/2
	Max_Height=Max_Height*Multiplier
	
	Repeat
		
		For y=0 To NoiseMapSize
			
			For x=0 To NoiseMapSize
				
				NoiseMap(x,y)=Rnd(0,Max_Height#)
				
			Next
			
		Next
		
		If wrap Then
			
			For i=0 To NoiseMapSize : NoiseMap(i,0)=NoiseMap(i,NoiseMapSize) : Next
			For i=0 To NoiseMapSize : NoiseMap(0,i)=NoiseMap(NoiseMapSize,i) : Next
			
		EndIf
		
		ScaleDifference=size*1.0/NoiseMapSize
		StepSize=1.0/Float(ScaleDifference)
		
		For y=0 To NoiseMapSize-1
			
			For x=0 To NoiseMapSize-1
				
				N1=NoiseMap(x,  y  )
				N2=NoiseMap(x+1,y  )
				N3=NoiseMap(x,  y+1)
				N4=NoiseMap(x+1,y+1)
				
				HX=x*ScaleDifference
				HY=y*ScaleDifference
				
				IY=0
				
				For yy=0 To ScaleDifference-1
					
					ICY=1.0-((Cos(IY*180.0)+1.0)/2.0)
					
					IX=0	
					
					For xx=0 To ScaleDifference-1
						
						ICX=1.0-((Cos(IX*180.0)+1.0)/2.0)
						
						NA=N1*(1.0-ICX)
						NB=N2*ICX
						NC=N3*(1.0-ICX)
						ND=N4*ICX
						
						v=HeightMap(HX+xx,HY+yy)+(NA+NB)*(1.0-ICY)+(NC+ND)*ICY
						
						If v&gt;Maxh Then Maxh=v
						If v&lt;minh Then minh=v
						
						HeightMap(HX+xx,HY+yy)=v
						
						IX=IX+StepSize
						
					Next
					
					IY=IY+StepSize	
					
				Next
				
			Next
			
		Next
		
		NoiseMapSize=NoiseMapSize/2
		
		Max_Height=Max_Height*Multiplier
		
	Until NoiseMapSize&lt;=2
	
End Function


.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea> <br><br></td></tr></table><br>
<a name="1044313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I see now what you wanted witht he asteroids - presumably to have the particles of the rings shown as the tiny rocks/ice that they are?<br><br>I think this could be achieved, but maybe slow to cope with LOD changes. Only when the 'startfield' density is greater than 33% or so, and only when the camera is within so many units from the 'particles' might they be realised as roid-shaped meshes.<br><br>Also, it may be a little pedantic, but 'realistically', the rings would be thicker when the camera is right up close (i.e. within the rings) although this is hard to convey since the scale of the planet/rings etc. doesn't match the viewport of the camera.<br><br>Anyway, if I'm on the right lines regarding the asteroids, I'll see how I get on :) <br><br></td></tr></table><br>
<a name="1044356"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Malice, this is only a demo of the dust particles, the texture here used is very simple just to show the effect. You could use the same "system" with two or three different types of objects, quads with a better texture for dust and far away particles, ultra lowpoly asteroids and nearby more detailed asteroids, all mixed up (I think in Freelancer you can see that it is mixed but still looks cool).<br><br>Here, the system is built in my saturn demo but <a href="/codearcs.php?code=2758" target="_blank">when you take a look</a> at my code archive entry you can spawn particle fields where you want with a given / changing density. And this is what I wanted, saturn is only a part of it, look at the first post of this thread:<br><br>possible: an asteroid belt like in our solar system (like a torus)<br>possible: ice rings around planets (like a flat disc around saturn)<br>possible: local asteroid/debris clouds (like a distorted sphere)<br>possible: and the asteroids should be solid, moving, turning<br><br>I am not sure how "thick" the rings must be to match reality - I am happy when it looks cool enough that it COULD be realistic even if it is far away from that :-D OK - my saturn has a scale of 100 blitz units and the ring from ca. 100 to 300. According to wikipedia the rings are only a few meters (!) thick, varying across distance from the planet. Saturn has a radius of 60.000km, if we assume the ring has a thickness of 100 meters (0,1km) it should have a vertical size of 0.000166 blitz units, so my ring is 12000 times too thick (0,1*100/60000 compared to -1 to 1 = 2 units) :-) But i doubt that the real ring is 100 meters think, rather 10-30 meters.<br><br>The only open question is how to improve the speed of the particle creation... It is fast but not perfect. <br><br></td></tr></table><br>
<a name="1044360"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Going straight on my wallpaper. :) <br><br>You should take a look at these wallpapers if you love space scenes:<br><br><a href="http://www.wallpapers-room.com/newest/space/" target="_blank">Wallpapers Room</a><br><a href="http://casperium.deviantart.com/gallery/#Sci-Fi" target="_blank">Deviant Art: Casperium</a><br><a href="http://taenaron.deviantart.com/gallery/" target="_blank">Deviant Art: taenaron</a><br><br>My favourite, <a href="http://www.wallpapers-room.com/1553/filter/popular/author-34/15/" target="_blank">Denebola</a>:<br><br><img src="http://content.wallpapers-room.com/presentationBig/Denebola_by_taenaron.jpg"> <br><br></td></tr></table><br>
<a name="1044478"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not much else really comes to mind how to speed up the UpdateStarfield function, though I tried adding an extra Type field "scaled" as a boolean that was checked for and set once the particles were scaled, though it made little visible difference, since the check itself would have possibly countered any speed increase from not repeating the scaling.<br><br>All I can think of to suggest is perhaps:<br><br><br>1) A collision check with the RING to hide it from view when 'right within it', so only the particles would be visible<br>(I tried a quick version relying on the distance and density but really needs to be a collision to avoid flicker at some places)<br><br>2) A separate function to populate (and scale/ position) INITIAL starfield, rather than just the values for the fields, buit actually generate the quads as part of the procedurala setup. Then the first run of the update would ensure all is hidden/shown as required.<br>This prevents the need to re-scale each loop.<br><br>Overall, it's exceedingly fast, the only effects on the rendering speed I've really observed are when first "entering the rings" (i.e. making the particles visible for the first time) WHEN THE PLANET is in view too. This is clearly down to the number of poly's being rendered:<br><br>Planet Mesh (+ Glow and shader etc) ~ 35 000<br>Ring Mesh ~1000<br>Particles at most dense ~1000<br><br>So you can see how the planet ramps up the poly count. The particles themselves are extremely fast so I dont think there's much can be done with them...<br><br>Here's what I have tried to speed up things a little:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
AppTitle "Procedural Saturn 2.0"

Graphics3D 800,600,32,2

Dim P%(512),GRAYD#(512),HeightMap#(0,0),NoiseMap#(0,0)
Global minh#=2^16,Maxh#

Global density%[1024]

Global vis%


Const NOISE_PERLIN=0
Const NOISE_FAST=1

Const RING_LINEAR=0
Const RING_CASSINI=1

Const ALPHA_MODE_NORMAL=0
Const ALPHA_MODE_SMOOTH=1
Const ALPHA_MODE_SHARP=2

Type star
	
	Field col%
	Field scale#
	Field x#,y#,z#
	Field visible%
	
	Field scaled%
End Type

Const SCALEX#		= 5.0	; starfield scale X
Const SCALEY#		= 0.5	; starfield scale Y
Const SCALEZ#		= 5.0	; starfield scale Z
Const MAXSTARS%		= 10000 ; maximum asteroids
Const TurnSpeed#	= 4.0	; cam turn speed
Const RollSpeed#	= 0.5	; cam roll speed
Const CameraSpeed#	= 0.01	; cam move speed
Const SEED_PLANET1%=8		; seed for procedural planet texture
Const SEED_PLANET2%=8		; seed for procedural planet texture
Const SEED_RING1%=6			; seed for procedural ring texture
Const SEED_RING2%=6			; seed for procedural ring texture
Const SCALE#=100.0			; planet scale
Const SEGMENTS%=64			; sphere detail
Const RINGDETAIL%=360		; ring segments
Const GLOWSEGMENTS%=360		; glow segments
Const MINRINGRAD#=0.7		; minimum ring radius
Const MAXRINGRAD#=3.0		; maximum ring radius
Const PR%=255				; planet colors RED
Const PG%=192				; planet colors GREEN
Const PB%=128				; planet colors BLUE

Global WIDTH%=GraphicsWidth()
Global HEIGHT%=GraphicsHeight()
Global TIMER%=CreateTimer(60)

Global CAM%,PLANET%,PLANETTEX%,RING%,LIGHT,GLOW%,SHADER%
Global RINGTEX%,ICETEX1%,ICETEX2%,ICETEX3%,SHADOWTEX%

InitNoise(1.0)

; Planet
PLANET=CreateSphere(SEGMENTS)
ScaleEntity PLANET,SCALE,SCALE,SCALE
EntityShininess PLANET,0.1
EntityFX PLANET,2
UpdateVertexColors(PLANET,PR,PG,PB,1)
PLANETTEX=CreateRingTexture(256,SEED_PLANET1,SEED_PLANET2,1,False,ALPHA_MODE_SMOOTH,1.0,1.0)
TextureBlend PLANETTEX,2
RotateTexture PLANETTEX,90
EntityTexture PLANET,PLANETTEX

; Planet Atmosphere
GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,GLOWSEGMENTS,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)

; Planet Fake Shader
SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.6)

; Ring System
CreateSaturnRing(512,50000,1+8,ALPHA_MODE_NORMAL,RING_LINEAR,0.95,0.75,NOISE_PERLIN)

; Light source
LIGHT=CreateLight(1)
RotateEntity LIGHT,0,-90,0
AmbientLight 0,0,0

; OBLATE PLANET
ScaleMesh PLANET,1,0.9,1
ScaleMesh GLOW,1,0.8,1
ScaleMesh SHADER,1,0.9,1
ScaleMesh RING,1,0.9,1


; Camera
CAM=CreateCamera()
CameraRange CAM,0.0001*SCALE,1000*SCALE
MoveEntity CAM,-1*SCALE,1.0/64*SCALE,-2*SCALE
PointEntity CAM,PLANET

; star quad
Global star=CreateQuad()
HideEntity star

; starfield mesh
Global starfield=CreateMesh()
Global surf=CreateSurface(starfield)
EntityTexture starfield,CreateStarTexture()
EntityFX starfield,1+2+32
EntityBlend starfield,3

; fill star field
AddStars(MAXSTARS,0.01,0.02)

; Milkyway background
;Include "milkyway.bb" : Global MILKYWAY%=InitMilkyway(5000,0.5,5,90,1,0,0,0,1,255,192,255,1,0,0,0,1)

MoveMouse WIDTH Shr 1,HEIGHT Shr 1

;===========================================================================
; main loop
;===========================================================================
While Not KeyHit(1)
	
	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%,zoom#=1.0,a#
	
	; move ice "particles"
	;a=a+0.001 Mod 360
	;RotateTexture ICETEX1,a*0.50
	;RotateTexture ICETEX2,a*0.75
	;RotateTexture ICETEX3,a*1.00
	
	; SHIFT or RMB = 50x faster cam flight
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=50
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; KEYS 1-3 = show/hide special planet FX
	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING
	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW
	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER
	
	; LMB = Ultra Zoom 100x
	If MouseDown(1) Then zoom=100.0 : l=500.0
	
	; camera movement
	Movement(CAM)
	CameraZoom CAM,zoom
	
	If MILKYWAY Then PositionEntity MILKYWAY,EntityX(CAM),EntityY(CAM),EntityZ(CAM)
	
	; update atmosphere glow according to camera
	UpdateGlow(GLOW,CAM)
	
	; calc ring density
	d#=EntityDistance(CAM,PLANET)
	If d&gt;SCALE*MINRINGRAD And d&lt;SCALE*MAXRINGRAD Then
		ds=Int(density[Normalize(d,SCALE*MINRINGRAD,SCALE*MAXRINGRAD,0,512)])
	EndIf
	
	; update asteroids
	UpdateStarfield(RING,CAM,5,1,ds)
	
	; Update Saturn Ring Alpha
	s#=1.0-(1.0/Exp(Abs(EntityY(CAM)*0.5)))
	UpdateVertexColors(RING,255,255,255,s)
	
	RenderWorld
	
	WaitTimer TIMER
	
	; show some stats in the app title
	AppTitle vis+" Stars | "+(ds/2.55)+"% Ring Density | "+TrisRendered()+" Polys"
	
	Flip 0
	
Wend

End


; -----------------------------------------------------------------------------
; simple spaceship freeflight
; -----------------------------------------------------------------------------
Function Movement(cam%,sensitivity#=1.0)
	
	Local roll#,cx#,cz#,tx#,ty#,multi%=1
	
	cx=(KeyDown(205)-KeyDown(203))*CameraSpeed
	cz=(KeyDown(200)-KeyDown(208))*CameraSpeed
	roll=(KeyDown(203)-KeyDown(205))*RollSpeed
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=25
	
	tx=Normalize(MouseX(),0,WIDTH , 1,-1)
	ty=Normalize(MouseY(),0,HEIGHT,-1, 1)
	
	If ty&lt;0 Then ty=(Abs(ty)^sensitivity)*-1 Else ty=ty^sensitivity
	If tx&lt;0 Then tx=(Abs(tx)^sensitivity)*-1 Else tx=tx^sensitivity
	
	TurnEntity cam,ty*TurnSpeed,tx*TurnSpeed,roll*TurnSpeed
	MoveEntity cam,cx*multi,0,cz*multi
	
End Function


; -----------------------------------------------------------------------------
; create a quad
; -----------------------------------------------------------------------------
Function CreateQuad(r%=255,g%=255,b%=255,a#=1.0)
	
	Local mesh%,surf%,v1%,v2%,v3%,v4%
	
	mesh=CreateMesh()
	surf=CreateSurface(mesh)
	
	v1=AddVertex(surf,-1,1,0,1,0)
	v2=AddVertex(surf,1,1,0,0,0)
	v3=AddVertex(surf,-1,-1,0,1,1)
	v4=AddVertex(surf,1,-1,0,0,1)
	
	VertexColor surf,v1,r,g,b,a
	VertexColor surf,v3,r,g,b,a
	VertexColor surf,v2,r,g,b,a
	VertexColor surf,v4,r,g,b,a
	
	AddTriangle(surf,0,1,2)
	AddTriangle(surf,3,2,1)
	
	FlipMesh mesh
	
	Return mesh
	
End Function


; -----------------------------------------------------------------------------
; rebuild starfield mesh
; -----------------------------------------------------------------------------
Function UpdateStarfield(MasterRing%,parent%,maxdist#=2.0,fader%=False,ds%)
	
	Local s.star,px#,py#,pz#,d#,a#
	
	Local cx#=EntityX(parent)
	Local cy#=EntityY(parent)
	Local cz#=EntityZ(parent)
	
	Local density%=Int(ds/2.55)
	Local movecheck=0
	
	ClearSurface(surf)
	
	vis=0
	
	For s.star = Each star
		movecheck=False		
		; calc star position
		px=cx-s\x
		py=cy-s\y
		pz=cz-s\z

		; check if star must be moved
		If px&lt;-SCALEX Then s\x=s\x-(SCALEX Shl 1) :movecheck=True
		If px&gt;+SCALEX Then s\x=s\x+(SCALEX Shl 1) :movecheck=True
		If pz&lt;-SCALEZ Then s\z=s\z-(SCALEZ Shl 1) :movecheck=True
		If pz&gt;SCALEZ Then s\z=s\z+(SCALEZ Shl 1):movecheck=True

		If movecheck Then s\visible=(Rand(100)&lt;density)
	
		If s\visible Then
						
			; reposition star
			PositionEntity star,s\x,s\y,s\z
			
			; get distance
			d=EntityDistance(star,CAM)
			
			; check if not to far away
			If d&lt;maxdist Then
				
				; star is visible?
				If EntityInView(star,CAM) Then
					
					; align star to cam
					PointEntity star,CAM
					
					If (Not(s\scaled))
						ScaleEntity star,s\scale,s\scale,s\scale
						s\scaled=True
					End If
					
					; add alpha
					a=1.0 : If fader Then a=Normalize(d,maxdist*0.5,maxdist,1,0)
					
					; add star To starfield again
					AddMeshToSurface(star,surf,starfield,s\col,s\col,s\col,a)
					
					vis=vis+1
					
				EndIf
				
			EndIf
			
		EndIf
		
	Next

	Return density
	
End Function


; -----------------------------------------------------------------------------
; add a mesh to another mesh
; -----------------------------------------------------------------------------
Function AddMeshToSurface(mesh,surf,singlesurfaceentity,r%,g%,b%,a#) 
	
	Local vert%[2],vr%[2],vg%[2],vb%[2],va#[2],nx#[2],ny#[2],nz#[2]
	Local surface%,oldvert%,i%,i2%
	
	surface = GetSurface(mesh,1) 
	
	For i = 0 To CountTriangles(surface)-1
		
		For i2 = 0 To 2 
			
			oldvert = TriangleVertex(surface,i,i2)
			
			vr[i2]=r
			vg[i2]=g
			vb[i2]=b
			va[i2]=a
			nx[i2]=VertexNX(surface,oldvert)
			ny[i2]=VertexNY(surface,oldvert)
			nz[i2]=VertexNZ(surface,oldvert)
			
			TFormPoint VertexX(surface,oldvert),VertexY(surface,oldvert),VertexZ(surface,oldvert), mesh,singlesurfaceentity 
			vert[i2] = AddVertex(surf,TFormedX(),TFormedY(),TFormedZ(),VertexU(surface,oldvert),VertexV(surface,oldvert)) 
			VertexNormal surf,vert[i2],nx[i2],ny[i2],nz[i2]
			VertexColor surf,vert[i2],r,g,b,a
			
		Next 
		
		AddTriangle(surf,vert[0],vert[1],vert[2])
		
	Next 
	
End Function


; -----------------------------------------------------------------------------
; add stars to starfield mesh
; -----------------------------------------------------------------------------
Function AddStars(amount%=1,min#=0.01,max#=0.02,addx#=0.0,addy#=0.0,addz#=0.0)
	
	Local i%,s.star
	Local density%=Normalize(Perlin3D(0,0,0,16,1,0,3),-1,1,0,100)
	If density&lt;0 Then density=0 Else If density&gt;100 Then density=100
	
	For i=1 To amount
		
		s.star = New star
		
		s\col=Rand(64,255)
		s\x=addx+Rnd(-SCALEX,SCALEX)
		s\y=addy+Rnd(Rnd(Rnd(Rnd(-SCALEY))),Rnd(Rnd(Rnd(SCALEY))))
		s\z=addz+Rnd(-SCALEZ,SCALEZ)
		s\scale=Rnd(min,max)
		
		If Distance3D(0,0,0,s\x,s\y,s\z)&lt;=2 Then
			
			If Rand(100)&lt;density Then s\visible=True
			
		Else
			
			If (Rand(100)&lt;(MAXSTARS Shr 1)) Then s\visible=True
			
		EndIf
		
	Next
	
End Function


; -----------------------------------------------------------------------------
; simple 3D distance calculation
; -----------------------------------------------------------------------------
Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Local x#=x1-x2
	Local y#=y1-y2
	Local z#=z1-z2
	
	Return ((x*x)+(y*y)+(z*z))^0.5
	
End Function


; -----------------------------------------------------------------------------
; create a simple star texture
; -----------------------------------------------------------------------------
Function CreateStarTexture(size%=256,flags%=3)
	
	Local tex%=CreateTexture(size,size,flags)
	Local tb%=TextureBuffer(tex)
	
	Local i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	size=size*0.5
	For j=0 To 255
		
		col=255-j
		If col&gt;255 Then col=255
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360.0 Step 0.5
			
			WritePixelFast (size)+(Sin(i)*(j*size*0.00390625)),(size)+(Cos(i)*(j*size*0.00390625)),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create procedural ring detail textures using perlin functions
;===========================================================================
Function CreateProceduralRingTextures(brightness1%=192,brightness2%=160,brightness3%=128,size%,detail%,flags%,noisetype=NOISE_PERLIN)
	
	Local buffer1%,buffer2%,buffer3%
	Local x%,y%,rgb%,rgb1%,rgb2%,col%,r%,i%

	rgb1=brightness1*$10000+brightness1*$100+brightness1
	rgb2=brightness2*$10000+brightness2*$100+brightness2
	
	If noisetype=NOISE_FAST
		Dim HeightMap(size,size)
		Dim NoiseMap(size+1,size+1)
		FastNoise(size,8,1.2,1)
	EndIf
	
	ICETEX1=CreateTexture(size,size,flags)
	ICETEX2=CreateTexture(size,size,flags)
	ICETEX3=CreateTexture(size,size,flags)
	
	buffer1=TextureBuffer(ICETEX1)
	buffer2=TextureBuffer(ICETEX2)
	buffer3=TextureBuffer(ICETEX3)
	
	LockBuffer buffer1
	LockBuffer buffer2
	LockBuffer buffer3
	
	For x=0 To size-1
		For y=0 To size-1
			WritePixelFast x,y,rgb1,buffer1
			WritePixelFast x,y,rgb2,buffer2
		Next
	Next
	
	For i=1 To detail
		
		; random position
		x=Rand(0,size-1)
		y=Rand(0,size-1)
		
		; random randomized randomizer
		r=Rand(0,Rand(0,Rand(0,255)))
		
		; perlin or fast noise
		If noisetype=NOISE_FAST
			col=Normalize(HeightMap(x,0),minh,Maxh,brightness1,255)
		Else
			col=Normalize(Perlin3D(x,0,y,4,1,0,15),-1,1,brightness1,255)
		EndIf
		col=Normalize(col+r,brightness1,511,brightness2,255)
		
		; layer 1+2: identical perlin noise mixed with random
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer1
		WritePixelFast x,y,rgb,buffer2
		
		; layer 3: starfield like
		If noisetype=NOISE_FAST
			col=Normalize(HeightMap(y,x),minh,Maxh,0,128)
		Else
			col=Normalize(Perlin3D(x,y,0,16,1,0,7),-1,1,0,128)
		EndIf
		col=Normalize(col+r,0,511,brightness3,255)
		If col&lt;brightness3 Then col=brightness3
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer3
		
	Next
	
	UnlockBuffer buffer3
	UnlockBuffer buffer2
	UnlockBuffer buffer1
	
End Function


;===========================================================================
; main call to create the saturn ring system
;===========================================================================
Function CreateSaturnRing(size%=512,detail%=50000,flags%=1+8,mode=ALPHA_MODE_NORMAL,style=RING_LINEAR,fading#=0.85,range#=0.7,noisetype=NOISE_PERLIN)
	
	Local v%,surf%
	
	; create procedural ring textures (ICETEX1-3)
	CreateProceduralRingTextures(160,192,0,size,detail,flags,noisetype)
	
	; create shadow texture
	If style=RING_CASSINI Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,8)
	Else If style=RING_LINEAR Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,0,100)
	Else
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,16)
	EndIf
	
	; create main ring texture
	RINGTEX=CreateRingTexture(size,SEED_RING1,SEED_RING2,3,True,mode,fading,range)
	
	; create planetary ring
	RING=CreateMesh(PLANET)
	EntityFX RING,1+2+16+32
	;EntityBlend RING,3
	surf=CreateSurface(RING)
	UpdateSaturnRing(RING,surf,MINRINGRAD,MAXRINGRAD,RINGDETAIL,255,255,255,255,255,255,1.0,1.0)
	
	; init second UV set
	For v=0 To CountVertices(surf)-1
		VertexTexCoords surf,v,VertexX(surf,v),VertexY(surf,v),0,1
	Next
	
	; reposition shadow texture
	PositionTexture SHADOWTEX,0.5,0.5
	
	; user second UV set
	TextureCoords ICETEX1,1
	TextureCoords ICETEX2,1
	TextureCoords ICETEX3,1
	TextureCoords SHADOWTEX,1
	
	; scale textures
	ScaleTexture ICETEX1,1.0/64,1.0/64
	ScaleTexture ICETEX2,1.0/16,1.0/16
	ScaleTexture ICETEX3,1.0/8,1.0/8
	ScaleTexture SHADOWTEX,6,6
	
	; apply to mesh
	EntityTexture RING,RINGTEX,0,1
	EntityTexture RING,ICETEX1,0,2
	EntityTexture RING,ICETEX2,0,3
	EntityTexture RING,ICETEX3,0,4
	EntityTexture RING,SHADOWTEX,0,5
	
	; blend details
	TextureBlend ICETEX1,3
	TextureBlend ICETEX3,3
	
	; rotate ring
	RotateMesh RING,-90,90,0
	
End Function


;===========================================================================
; create planetary ring mesh
;===========================================================================
Function UpdateSaturnRing(FMesh%,FFace%=1,FRadius1#=1.0,FRadius2#=3.0,FSegments%=120,FR1%=255,FG1%=255,FB1%=255,FR2%=255,FG2%=255,FB2%=255,FAlpha1#=1.0,FAlpha2#=1.0)
	
	If FSegments&gt;360 Then FSegments=360
	
	Local Angle%
	Local RV0%,RV1%,RV2%,RV3%
	Local RX0#,RX1#,RX2#,RX3#
	Local RY0#,RY1#,RY2#,RY3#
	Local SX0#,SX1#,SX2#,SX3#
	Local SY0#,SY1#,SY2#,SY3#
	Local U01#,U23#
	
	For Angle=1 To FSegments Step 1
		
		RX0=Sin(Angle*360.0/FSegments)*FRadius1
		RY0=Cos(Angle*360.0/FSegments)*FRadius1
		RX1=Sin(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RY1=Cos(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RX2=Sin(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RY2=Cos(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RX3=Sin(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		RY3=Cos(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		SX0=RX0: SY0=RY0
		SX1=RX0: SY1=RY0
		SX2=RX3: SY2=RY3
		SX3=RX3: SY3=RY3
		U01=0
		U23=0
		
		RV0=AddVertex(FFace,RX0,RY0,0, U01,0)
		RV1=AddVertex(FFace,RX1,RY1,0, 1,0)
		RV2=AddVertex(FFace,RX2,RY2,0, 1,0)
		RV3=AddVertex(FFace,RX3,RY3,0, U23,0)
		
		VertexColor FFace,RV0,FR1,FG1,FB1,FAlpha1
		VertexColor FFace,RV1,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV2,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV3,FR1,FG1,FB1,FAlpha1
		
		AddTriangle FFace,RV0,RV1,RV2
		AddTriangle FFace,RV2,RV3,RV0
		
	Next
	
	Return FMesh
	
End Function


;===========================================================================
; creates the saturn shadow texture using two spheres, simple math and a cam
;===========================================================================
Function CreateSaturnShadow(size%=512,scale#=3.5,angle#=180.0,blur%=2,col%=64,width#=20.0,length#=9.0)
	
	Local sphere1%,sphere2%,tmp%,surf1%,surf2%
	Local v%,x#,y#,z#,tex%,add#
	
	sphere1=CreateSphere(32)
	EntityFX sphere1,1+2
	
	sphere2=CreateSphere(32)
	EntityFX sphere2,1+2
	
	surf1=GetSurface(sphere1,1)
	surf2=GetSurface(sphere2,1)
	
	For v=0 To CountVertices(surf1)-1
		
		x#=VertexX(surf1,v)
		y#=VertexY(surf1,v)
		z#=VertexZ(surf1,v)
		
		If z&gt;0 Then add=Sqr(z*length) Else add=1
		
		VertexCoords surf1,v,x,y,z*Cos(width)*add
		VertexColor surf1,v,col,col,col
		VertexColor surf2,v,col,col,col
		
	Next
	
	tex=CreateTexture(size,size)
	
	tmp=CreateCamera()
	PositionEntity tmp,0,scale,0
	CameraClsColor tmp,255,255,255
	CameraViewport tmp,0,0,size,size
	PointEntity tmp,sphere1
	
	RenderWorld
	
	FreeEntity sphere1
	FreeEntity sphere2
	FreeEntity tmp
	
	CopyRect 0,0,size,size,0,0,BackBuffer(),TextureBuffer(tex)
	
	If blur Then BlurTexture(tex,blur,blur)
	
	RotateTexture tex,angle
	
	Return tex
	
End Function


;===========================================================================
; blurs the saturn shadow texture for soft transitions
;===========================================================================
Function BlurTexture(Texture, Blur_Quality, Blur_Radius#)
	
	Local BlurMesh[16*4]
	Local Loop
	Local Blur_Cam
	Local BlurRadius#,BlurAngleStep#,BlurShade%,BlurAngle#,Xoff#,Yoff#
	
	Local BLUR_CAM_X# = 65536.0
	Local BLUR_CAM_Y# = 65536.0
	Local BLUR_CAM_Z# = 0.0
	
	If Blur_Quality &gt; 0
		
		Blur_Cam = CreateCamera()
		CameraViewport Blur_Cam, 0, 0, TextureWidth(Texture), TextureHeight(Texture)
		CameraClsColor Blur_Cam, 0, 0, 0
		CameraClsMode  Blur_Cam, True, True						
		CameraRange Blur_Cam, 0.1, 100
		CameraZoom Blur_Cam, 16.0
		RotateEntity Blur_Cam, 90, 0, 0, True
		PositionEntity Blur_Cam, BLUR_CAM_X#, BLUR_CAM_Y#, BLUR_CAM_Z#
		For Loop = 0 To (Blur_Quality*4)-1
			BlurMesh[Loop] = CreateSprite()
		Next
		TextureBlend Texture, 2
		ScaleTexture    Texture, 0.5, 0.5
		PositionTexture Texture, 0.5, 0.5
		
		BlurRadius = Blur_Radius# * (1.0 / 256.0)
		BlurAngleStep = 360.0 / Float(Blur_Quality*4)
		BlurShade = Ceil(255.0 / Float(Blur_Quality*4))
		
		For Loop = 0 To (Blur_Quality*4)-1
			
			EntityTexture BlurMesh[Loop], Texture
			EntityFX BlurMesh[Loop], 1+8
			EntityAlpha BlurMesh[Loop], 1.0 / Float(Loop+1)
			ScaleSprite BlurMesh[Loop], 2, 2
			
			BlurAngle# = BlurAngleStep# * Float(Loop) + 180.0*(Loop Mod 2)
			
			Xoff# = BlurRadius# * Cos(BlurAngle#)
			Yoff# = BlurRadius# * Sin(BlurAngle#)
			
			PositionEntity BlurMesh[Loop], BLUR_CAM_X# + Xoff#, BLUR_CAM_Y# - 16.0, BLUR_CAM_Z# + Yoff#, True
			
		Next
		
		RenderWorld
		
		CopyRect 0, 0, TextureWidth(Texture), TextureHeight(Texture), 0, 0, BackBuffer(), TextureBuffer(Texture)
		
		For Loop = 0 To (Blur_Quality*4)-1
			FreeEntity BlurMesh[Loop]
		Next
		
		FreeEntity Blur_Cam
		
	EndIf
	
	ScaleTexture Texture,1,1
	PositionTexture Texture,0,0
	
End Function


;===========================================================================
; updates the vertex colors of a mesh
;===========================================================================
Function UpdateVertexColors(mesh%,r%,g%,b%,a#)
	
	Local s%,surf%,v%
	
	For s=1 To CountSurfaces(mesh)
		
		surf=GetSurface(mesh,s)
		
		For v=0 To CountVertices(surf)-1
			
			VertexColor surf,v,r,g,b,a
			
		Next
		
	Next
	
End Function


;===========================================================================
; creates a fake shader (spherical glow effect), should match planet size
;===========================================================================
Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)
	
	Local shader%=CreateSphere(segments)
	Local tex%=CreateFakeShaderTexture()
	
	ScaleEntity shader,size,size,size
	EntityBlend shader,3
	EntityFX shader,2
	EntityOrder shader,-1
	UpdateVertexColors(shader,r,g,b,a)
	
	TextureBlend tex,2
	EntityTexture shader,tex,0,1
	
	Return shader%
	
End Function


;===========================================================================
; creates fake shader texture
;===========================================================================
Function CreateFakeShaderTexture()
	
	Local tex%=CreateTexture(512,512,64)
	Local tb%=TextureBuffer(tex)
	
	Local x%,y%,i#,j%,col%
	Local rgb%=255*$1000000+255*$10000+255*$100+255
	
	SetBuffer tb
	LockBuffer tb
	
	For x=0 To 511
		
		For y=0 To 511
			
			WritePixelFast x,y,rgb,tb
			
		Next
		
	Next
	
	For j=0 To 255
		
		col=j*1.0/Exp((255-j)*0.02)
		
		If col&gt;255 Then col=255
		If col&lt;0 Then col=0
		
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create planet atmosphere
;===========================================================================
Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	If segments&gt;360 Then segments=360
	
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		VertexColor surf,v0,r1,g1,b1,al1
		VertexColor surf,v1,r1,g1,b1,al1
		VertexColor surf,v2,r2,g2,b2,al2
		VertexColor surf,v3,r2,g2,b2,al2
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function


;===========================================================================
; update planet atmosphere
;===========================================================================
Function UpdateGlow(mesh%,cam%)
	
	Local radius#,distance#
	Local c1#,a1#,q1#,p1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#
	
	PointEntity mesh,cam
	
	radius=SCALE
	distance=EntityDistance(cam,PLANET)
	
	; First triangle
	c1=distance
	a1=radius
	q1=(a1*a1)/c1
	p1=c1-q1
	gamma1=90
	alpha1=ATan((p1*q1)^0.5/p1)
	beta1=gamma1-alpha1
	
	; Second Triangle
	alpha2=90-(90-beta1)
	b2=a1/Tan(alpha2)
	c2=(((a1*a1+b2*b2))^0.5)/radius
	
	ScaleEntity mesh,c2,c2,c2
	
End Function


;===========================================================================
; create planetary ring texture
;===========================================================================
Function CreateRingTexture(size%=1024,seed1%=1,seed2%=2,flags%=0,usealpha%=False,mode=ALPHA_MODE_NORMAL,fading#=1.0,range#=0.7)
	
	Local tex%=CreateTexture(size,1,flags)
	Local buffer%=TextureBuffer(tex)
	
	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#
	
	LockBuffer buffer
	
	For x=0 To size-1
		
		h1=Perlin3D(x*(2048/size),0,0,1024,seed1,0,15)
		h2=Perlin3D(0,x*(2048/size),0,512,seed2,0,7)
		
		col=Int(Normalize(h1,-range,range,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255
		
		If usealpha Then
			
			If mode=ALPHA_MODE_SMOOTH Then
				
				; soft rings
				alpha=(Int(Normalize(h2,-range,range,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))*0.5
				
			Else If mode=ALPHA_MODE_SHARP Then
				
				; sharp rings
				alpha=Int(Normalize(h1,-range,range,0,1.0)*col)*Rnd(0.98,1.02)
				
			Else
				; normal rings
				alpha=Int(Normalize(h2,-range,range,0,1.0)*col)
			EndIf
			
			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255
			
		Else
			
			alpha=255
			
		EndIf
		
		; soft fading to the outer rings
		If x&gt;(size*fading) Then
			
			value=Normalize(x,size*fading,size,1,0)
			
			alpha=alpha*value
			col=col*value
			
		EndIf
		
		density[x]=alpha;(col+alpha)/2
		
		rgb=alpha*$1000000+col*$10000+col*$100+col
		
		WritePixelFast x,0,rgb,buffer
		
	Next
	
	UnlockBuffer buffer
	
	Return tex
	
End Function


;===========================================================================
; normalize value
;===========================================================================
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


;===========================================================================
; fast perlin noise functions
;===========================================================================
Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

Function FastNoise(size%,Scale#,Multiplier#,wrap%=False)
	
	Local Max_Height#,NoiseMapSize%,ScaleDifference#,StepSize#
	Local N1#,N2#,N3#,N4#,HX#,HY#,IX#,IY#,ICX#,ICY#,NA#,NB#,NC#,ND#
	Local i%,x%,y%,xx%,yy%
	Local v#
	
	Max_Height=Scale
	
	For y=0 To size Step 1
		
		For x=0 To size Step 1
			
			HeightMap(x,y)=Rnd(0,1)
			
		Next
		
	Next
	
	NoiseMapSize=size/2
	Max_Height=Max_Height*Multiplier
	
	Repeat
		
		For y=0 To NoiseMapSize
			
			For x=0 To NoiseMapSize
				
				NoiseMap(x,y)=Rnd(0,Max_Height#)
				
			Next
			
		Next
		
		If wrap Then
			
			For i=0 To NoiseMapSize : NoiseMap(i,0)=NoiseMap(i,NoiseMapSize) : Next
			For i=0 To NoiseMapSize : NoiseMap(0,i)=NoiseMap(NoiseMapSize,i) : Next
			
		EndIf
		
		ScaleDifference=size*1.0/NoiseMapSize
		StepSize=1.0/Float(ScaleDifference)
		
		For y=0 To NoiseMapSize-1
			
			For x=0 To NoiseMapSize-1
				
				N1=NoiseMap(x,  y  )
				N2=NoiseMap(x+1,y  )
				N3=NoiseMap(x,  y+1)
				N4=NoiseMap(x+1,y+1)
				
				HX=x*ScaleDifference
				HY=y*ScaleDifference
				
				IY=0
				
				For yy=0 To ScaleDifference-1
					
					ICY=1.0-((Cos(IY*180.0)+1.0)*0.5)
					
					IX=0	
					
					For xx=0 To ScaleDifference-1
						
						ICX=1.0-((Cos(IX*180.0)+1.0)*0.5)
						
						NA=N1*(1.0-ICX)
						NB=N2*ICX
						NC=N3*(1.0-ICX)
						ND=N4*ICX
						
						v=HeightMap(HX+xx,HY+yy)+(NA+NB)*(1.0-ICY)+(NC+ND)*ICY
						
						If v&gt;Maxh Then Maxh=v
						If v&lt;minh Then minh=v
						
						HeightMap(HX+xx,HY+yy)=v
						
						IX=IX+StepSize
						
					Next
					
					IY=IY+StepSize	
					
				Next
				
			Next
			
		Next
		
		NoiseMapSize=NoiseMapSize*0.5
		
		Max_Height=Max_Height*Multiplier
		
	Until NoiseMapSize&lt;=2
	
End Function


.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea> <br><br></td></tr></table><br>
<a name="1044584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Malice, your particles flicker because of the scale check. Oh and use a {codebox}, you should edit your post...<br><br>Meanwhile I've been able to boost the performance by ca. 100% with a simple trick, I think you can hardly notice the difference (beside that there are a lot more particles in the "air" now). In this stress test I spawn 50.000 particles (vs. 10.000) and approx. 10.000 are shown at 100% - 1.000 "real" particles are added to the single surface mesh and 9.000 fake particles added as single pixels to a sprite texture.<br><br>This sprite is always in front of the cam and simulates the far away particles (the quads there scale about 1 pixel on the screen so I had the idea to use pixels on a texture instead of adding them to a mesh, saving calculation/render time). The transition is nearly seamless, see yourself:<br><br><b>Full scene, ca. 10.000 objects, 90% pixel particles</b><br><img src="http://www.christianhart.de/bb/asteroids/with_pixel_particles.jpg"><br><br><b>Press "4" to show/hide the sprite, here without pixel particles</b><br><img src="http://www.christianhart.de/bb/asteroids/without_pixel_particles.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Procedural Saturn 3.0"

Graphics3D 800,600,32,2

Dim P%(512),GRAYD#(512),HeightMap#(0,0),NoiseMap#(0,0)
Global minh#=2^16,Maxh#

Global density%[1024],ringcolor%[1024]

Global quadparticles%,spritetex%,spritebuf%,pixelparticles%

Type star
	
	Field col%
	Field scale#
	Field x#,y#,z#
	Field visible%
	
End Type

Const SCALEX#		= 2.00	; starfield scale X
Const SCALEY#		= 0.25	; starfield scale Y
Const SCALEZ#		= 2.00	; starfield scale Z
Const MAXSTARS%		= 50000 ; maximum asteroids
Const TurnSpeed#	= 4.00	; cam turn speed
Const RollSpeed#	= 0.50	; cam roll speed
Const CameraSpeed#	= 0.01	; cam move speed
Const SEED_PLANET1%	= 8		; seed for procedural planet texture
Const SEED_PLANET2%	= 8		; seed for procedural planet texture
Const SEED_RING1%	= 6		; seed for procedural ring texture
Const SEED_RING2%	= 6		; seed for procedural ring texture
Const SCALE#		= 100.0	; planet scale
Const SEGMENTS%		= 32	; sphere detail
Const RINGDETAIL%	= 360	; ring segments
Const GLOWSEGMENTS%	= 360	; glow segments
Const MINRINGRAD#	= 0.7	; minimum ring radius
Const MAXRINGRAD#	= 3.0	; maximum ring radius
Const PR%			= 255	; planet colors RED
Const PG%			= 192	; planet colors GREEN
Const PB%			= 128	; planet colors BLUE

Global WIDTH%=GraphicsWidth()
Global HEIGHT%=GraphicsHeight()
Global TIMER%=CreateTimer(60)

Global CAM%,PLANET%,PLANETTEX%,RING%,LIGHT,GLOW%,SHADER%
Global RINGTEX%,ICETEX1%,ICETEX2%,ICETEX3%,SHADOWTEX%

InitNoise(1.0)

; Planet
PLANET=CreateSphere(SEGMENTS)
ScaleEntity PLANET,SCALE,SCALE,SCALE
EntityShininess PLANET,0.1
EntityFX PLANET,2
UpdateVertexColors(PLANET,PR,PG,PB,1)
PLANETTEX=CreateRingTexture(256,SEED_PLANET1,SEED_PLANET2,1,False,"soft",1.0,1.0)
TextureBlend PLANETTEX,2
RotateTexture PLANETTEX,90
EntityTexture PLANET,PLANETTEX

; Planet Atmosphere
GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,GLOWSEGMENTS,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)

; Planet Fake Shader
SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.6)

; Ring System
CreateSaturnRing(512,50000,1+8,"normal","normal",0.95,0.75,"perlin")

; Light source
LIGHT=CreateLight(1)
RotateEntity LIGHT,0,-90,0
AmbientLight 0,0,0

; Camera
CAM=CreateCamera()
CameraRange CAM,0.0001*SCALE,1000*SCALE
MoveEntity CAM,-1*SCALE,1.0/64*SCALE,-2*SCALE
PointEntity CAM,PLANET

; star quad
Global star=CreateQuad()
HideEntity star

; starfield mesh
Global starfield=CreateMesh()
Global surf=CreateSurface(starfield)
EntityTexture starfield,CreateStarTexture(256,4)
EntityFX starfield,1+2+32
EntityBlend starfield,3
EntityOrder starfield,-1

; fill star field
AddStars(MAXSTARS,0.005,0.01)

; static camera sprite (far away particles)
Global sprite=CreateSprite(CAM)
ScaleSprite sprite,WIDTH,HEIGHT
PositionEntity sprite,0,0,WIDTH
EntityColor sprite,255,255,255
EntityBlend sprite,3
EntityOrder sprite,-1

; Milkyway background
;Include "milkyway.bb" : Global MILKYWAY%=InitMilkyway(5000,0.5,5,90,1,0,0,0,1,255,192,255,1,0,0,0,1)

MoveMouse WIDTH/2,HEIGHT/2

;===========================================================================
; main loop
;===========================================================================
While Not KeyHit(1)
	
	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%,sl4%,zoom#=1.0,d#,tmp%,ds%,dc%
	
	; SHIFT or RMB = 50x faster cam flight
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=50
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; KEYS 1-4 = show/hide special planet FX
	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING
	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW
	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER
	If KeyHit(5) Then sl4=1-sl4 : If sl4=1 Then HideEntity sprite Else ShowEntity sprite
	
	; LMB = Ultra Zoom 100x
	If MouseDown(1) Then zoom=100.0 : l=500.0
	
	; camera movement
	Movement(CAM)
	CameraZoom CAM,zoom
	
	If MILKYWAY Then PositionEntity MILKYWAY,EntityX(CAM),EntityY(CAM),EntityZ(CAM)
	
	; update atmosphere glow according to camera
	UpdateGlow(GLOW,CAM)
	
	; calc ring density
	d#=EntityDistance(CAM,PLANET)
	If d&gt;SCALE*MINRINGRAD And d&lt;SCALE*MAXRINGRAD Then
		tmp=Normalize(d,SCALE*MINRINGRAD,SCALE*MAXRINGRAD,0,512)
		ds=Int(density[tmp])
		dc=Int(ringcolor[tmp])
	EndIf
	
	; update asteroids
	UpdateStarfield(CAM,2,1,ds,dc)
	
	; Update Saturn Ring Alpha
	UpdateVertexColors(RING,255,255,255,1.0-(1.0/Exp(Abs(EntityY(CAM)*0.5))))
	
	RenderWorld
	
	WaitTimer TIMER
	
	; show some stats in the app title
	AppTitle quadparticles+" Quads [and "+pixelparticles+" Pixel Particles] | "+(ds/2.55)+"% RING density | "+TrisRendered()+" Tris"
	
	Flip 0
	
Wend

End


; -----------------------------------------------------------------------------
; simple spaceship freeflight
; -----------------------------------------------------------------------------
Function Movement(cam%,sensitivity#=1.0)
	
	Local roll#,cz#,tx#,ty#,multi%=1
	
	cz=(KeyDown(200)-KeyDown(208))*CameraSpeed
	roll=(KeyDown(203)-KeyDown(205))*RollSpeed
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=25
	
	tx=Normalize(MouseX(),0,WIDTH , 1,-1)
	ty=Normalize(MouseY(),0,HEIGHT,-1, 1)
	
	If ty&lt;0 Then ty=(Abs(ty)^sensitivity)*-1 Else ty=ty^sensitivity
	If tx&lt;0 Then tx=(Abs(tx)^sensitivity)*-1 Else tx=tx^sensitivity
	
	TurnEntity cam,ty*TurnSpeed,tx*TurnSpeed,roll*TurnSpeed
	MoveEntity cam,0,0,cz*multi
	
End Function


; -----------------------------------------------------------------------------
; create a quad
; -----------------------------------------------------------------------------
Function CreateQuad(r%=255,g%=255,b%=255,a#=1.0)
	
	Local mesh%,surf%,v1%,v2%,v3%,v4%
	
	mesh=CreateMesh()
	surf=CreateSurface(mesh)
	
	v1=AddVertex(surf,-1,1,0,1,0)
	v2=AddVertex(surf,1,1,0,0,0)
	v3=AddVertex(surf,-1,-1,0,1,1)
	v4=AddVertex(surf,1,-1,0,0,1)
	
	VertexColor surf,v1,r,g,b,a
	VertexColor surf,v3,r,g,b,a
	VertexColor surf,v2,r,g,b,a
	VertexColor surf,v4,r,g,b,a
	
	AddTriangle(surf,0,1,2)
	AddTriangle(surf,3,2,1)
	
	FlipMesh mesh
	
	Return mesh
	
End Function


; -----------------------------------------------------------------------------
; rebuild starfield mesh
; -----------------------------------------------------------------------------
Function UpdateStarfield(parent%,maxdist#=2.0,fader%=False,ds%,dc%)
	
	Local s.star,px#,py#,pz#,d#,a#,rgb%,col%,x%,y%,movecheck%
	
	Local cx#=EntityX(parent)
	Local cy#=EntityY(parent)
	Local cz#=EntityZ(parent)
	
	Local density%=Int(ds/2.55)
	
	ClearSurface(surf)
	
	quadparticles=0
	pixelparticles=0
	
	; delete and create a new texture, acutally faster than clearing it
	If spritetex Then FreeTexture spritetex
	spritetex=CreateTexture(512,512,1)
	spritebuf=TextureBuffer(spritetex)
	EntityTexture sprite,spritetex
	
	LockBuffer spritebuf
	
	For s.star = Each star
		
		movecheck=False
		
		; calc star position
		px=cx-s\x
		py=cy-s\y
		pz=cz-s\z
		
		; check if star must be moved
		If px&lt;-SCALEX Then s\x=s\x-(SCALEX Shl 1) : movecheck=True
		If px&gt;+SCALEX Then s\x=s\x+(SCALEX Shl 1) : movecheck=True
		If pz&lt;-SCALEZ Then s\z=s\z-(SCALEZ Shl 1) : movecheck=True
		If pz&gt;+SCALEZ Then s\z=s\z+(SCALEZ Shl 1) : movecheck=True
		
		If movecheck Then s\visible=(Rand(100)&lt;density)
		
		If s\visible Then
			
			; reposition star
			PositionEntity star,s\x,s\y,s\z
			
			; get distance
			d=Distance3D(cx,cy,cz,s\x,s\y,s\z)
			
			; check if not to far away
			If d&lt;maxdist
				
				TFormPoint s\x,s\y,s\z,0,CAM
				
				; star is visible (in front of cam)?
				If TFormedZ()&gt;0 Then
					
					; fade pixel particles
					col=255
					If fader Then
						col=Int(Normalize(d,0,maxdist,dc,0))
						If col&lt;0 Then col=0 Else If col&gt;dc Then col=dc
					EndIf
					rgb=col*$10000+col*$100+col
					
					; calculate pixel particle 2D position
					CameraProject CAM,s\x,s\y,s\z
					x=Normalize(ProjectedX(),0,WIDTH-1,0,511)
					y=Normalize(ProjectedY(),0,HEIGHT-1,0,511)
					
					; pixel inside texture range? draw to texture!
					If x&gt;0 And x&lt;511 And y&gt;0 And y&lt;511 Then
						WritePixelFast x,y,rgb,spritebuf
						pixelparticles=pixelparticles+1
					EndIf
					
					; distance close enough to cam? spawn quad particle and add it to mesh
					If d&lt;maxdist*0.25 Then
						
						; align star to cam
						PointEntity star,CAM
						
						ScaleEntity star,s\scale,s\scale,s\scale
						
						; add alpha
						a=1.0 : If fader Then a=Normalize(d,0,maxdist*0.25,1,0)
						
						; add star To starfield again
						AddMeshToSurface(star,surf,starfield,s\col,s\col,s\col,a)
						
						quadparticles=quadparticles+1
						
					EndIf
					
				EndIf
				
			EndIf
			
		EndIf
		
	Next
	
	UnlockBuffer spritebuf
	
	Return density
	
End Function


; -----------------------------------------------------------------------------
; add a mesh to another mesh
; -----------------------------------------------------------------------------
Function AddMeshToSurface(mesh,surf,singlesurfaceentity,r%,g%,b%,a#) 
	
	Local vert%[2],vr%[2],vg%[2],vb%[2],va#[2],nx#[2],ny#[2],nz#[2]
	Local surface%,oldvert%,i%,i2%
	
	surface = GetSurface(mesh,1) 
	
	For i = 0 To CountTriangles(surface)-1
		
		For i2 = 0 To 2 
			
			oldvert = TriangleVertex(surface,i,i2)
			
			vr[i2]=r
			vg[i2]=g
			vb[i2]=b
			va[i2]=a
			nx[i2]=VertexNX(surface,oldvert)
			ny[i2]=VertexNY(surface,oldvert)
			nz[i2]=VertexNZ(surface,oldvert)
			
			TFormPoint VertexX(surface,oldvert),VertexY(surface,oldvert),VertexZ(surface,oldvert), mesh,singlesurfaceentity 
			vert[i2] = AddVertex(surf,TFormedX(),TFormedY(),TFormedZ(),VertexU(surface,oldvert),VertexV(surface,oldvert)) 
			VertexNormal surf,vert[i2],nx[i2],ny[i2],nz[i2]
			VertexColor surf,vert[i2],r,g,b,a
			
		Next 
		
		AddTriangle(surf,vert[0],vert[1],vert[2])
		
	Next 
	
End Function


; -----------------------------------------------------------------------------
; add stars to starfield mesh
; -----------------------------------------------------------------------------
Function AddStars(amount%=1,min#=0.01,max#=0.02,addx#=0.0,addy#=0.0,addz#=0.0)
	
	Local i%,s.star
	Local density%=Normalize(Perlin3D(0,0,0,16,1,0,3),-1,1,0,100)
	If density&lt;0 Then density=0 Else If density&gt;100 Then density=100
	
	For i=1 To amount
		
		s.star = New star
		
		s\col=Rand(64,255)
		s\x=addx+Rnd(-SCALEX,SCALEX)
		s\y=addy+Rnd(Rnd(Rnd(Rnd(-SCALEY))),Rnd(Rnd(Rnd(SCALEY))))
		s\z=addz+Rnd(-SCALEZ,SCALEZ)
		s\scale=Rnd(min,max)
		
		If Rand(100)&lt;density Then s\visible=True
			
	Next
	
End Function


; -----------------------------------------------------------------------------
; simple 3D distance calculation
; -----------------------------------------------------------------------------
Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Local x#=x1-x2
	Local y#=y1-y2
	Local z#=z1-z2
	
	Return Sqr((x*x)+(y*y)+(z*z))
	
End Function


; -----------------------------------------------------------------------------
; create a simple star texture
; -----------------------------------------------------------------------------
Function CreateStarTexture(size%=256,flags%=3)
	
	Local tex%=CreateTexture(size,size,flags)
	Local tb%=TextureBuffer(tex)
	
	Local i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For j=0 To 255
		
		col=255-j
		If col&gt;255 Then col=255
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast (size/2)+(Sin(i)*(j*size/512)),(size/2)+(Cos(i)*(j*size/512)),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create procedural ring detail textures using perlin functions
;===========================================================================
Function CreateProceduralRingTextures(brightness1%=192,brightness2%=160,brightness3%=128,size%,detail%,flags%,noisetype$="perlin")
	
	Local buffer1%,buffer2%,buffer3%
	Local x%,y%,rgb%,rgb1%,rgb2%,col%,r%,i%
	
	If noisetype="fast" Then
		Dim HeightMap(size,size)
		Dim NoiseMap(size+1,size+1)
		FastNoise(size,8,1.2,1)
	EndIf
	
	ICETEX1=CreateTexture(size,size,flags)
	ICETEX2=CreateTexture(size,size,flags)
	ICETEX3=CreateTexture(size,size,flags)
	
	buffer1=TextureBuffer(ICETEX1)
	buffer2=TextureBuffer(ICETEX2)
	buffer3=TextureBuffer(ICETEX3)
	
	LockBuffer buffer1
	LockBuffer buffer2
	LockBuffer buffer3
	
	For x=0 To size-1
		For y=0 To size-1
			rgb1=brightness1*$10000+brightness1*$100+brightness1
			rgb2=brightness2*$10000+brightness2*$100+brightness2
			WritePixelFast x,y,rgb1,buffer1
			WritePixelFast x,y,rgb2,buffer2
		Next
	Next
	
	For i=1 To detail
		
		; random position
		x=Rand(0,size-1)
		y=Rand(0,size-1)
		
		; random randomized randomizer
		r=Rand(0,Rand(0,Rand(0,255)))
		
		; perlin or fast noise
		If noisetype="fast" Then
			col=Normalize(HeightMap(x,0),minh,Maxh,brightness1,255)
		Else
			col=Normalize(Perlin3D(x,0,y,4,1,0,15),-1,1,brightness1,255)
		EndIf
		col=Normalize(col+r,brightness1,511,brightness2,255)
		
		; layer 1+2: identical perlin noise mixed with random
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer1
		WritePixelFast x,y,rgb,buffer2
		
		; layer 3: starfield like
		If noisetype="fast" Then
			col=Normalize(HeightMap(y,x),minh,Maxh,0,128)
		Else
			col=Normalize(Perlin3D(x,y,0,16,1,0,7),-1,1,0,128)
		EndIf
		col=Normalize(col+r,0,511,brightness3,255)
		If col&lt;brightness3 Then col=brightness3
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer3
		
	Next
	
	UnlockBuffer buffer3
	UnlockBuffer buffer2
	UnlockBuffer buffer1
	
End Function


;===========================================================================
; main call to create the saturn ring system
;===========================================================================
Function CreateSaturnRing(size%=512,detail%=50000,flags%=1+8,mode$="normal",style$="cassini",fading#=0.85,range#=0.7,noisetype$="perlin")
	
	Local v%,surf%
	
	; create procedural ring textures (ICETEX1-3)
	CreateProceduralRingTextures(160,192,0,size,detail,flags,noisetype)
	
	; create shadow texture
	If style="cassini" Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,8)
	Else If style="linear" Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,0,100)
	Else
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,16)
	EndIf
	
	; create main ring texture
	RINGTEX=CreateRingTexture(size,SEED_RING1,SEED_RING2,3,True,mode,fading,range)
	
	; create planetary ring
	RING=CreateMesh(PLANET)
	EntityFX RING,1+2+16+32
	;EntityBlend RING,3
	surf=CreateSurface(RING)
	UpdateSaturnRing(RING,surf,MINRINGRAD,MAXRINGRAD,RINGDETAIL,255,255,255,255,255,255,1.0,1.0)
	
	; init second UV set
	For v=0 To CountVertices(surf)-1
		VertexTexCoords surf,v,VertexX(surf,v),VertexY(surf,v),0,1
	Next
	
	; reposition shadow texture
	PositionTexture SHADOWTEX,0.5,0.5
	
	; user second UV set
	TextureCoords ICETEX1,1
	TextureCoords ICETEX2,1
	TextureCoords ICETEX3,1
	TextureCoords SHADOWTEX,1
	
	; scale textures
	ScaleTexture ICETEX1,1.0/128,1.0/128
	ScaleTexture ICETEX2,1.0/64,1.0/64
	ScaleTexture ICETEX3,1.0/32,1.0/32
	ScaleTexture SHADOWTEX,6,6
	
	; apply to mesh
	EntityTexture RING,RINGTEX,0,1
	EntityTexture RING,ICETEX1,0,2
	EntityTexture RING,ICETEX2,0,3
	EntityTexture RING,ICETEX3,0,4
	EntityTexture RING,SHADOWTEX,0,5
	
	; blend details
	TextureBlend ICETEX1,3
	TextureBlend ICETEX3,3
	
	; rotate ring
	RotateMesh RING,-90,90,0
	
End Function


;===========================================================================
; create planetary ring mesh
;===========================================================================
Function UpdateSaturnRing(FMesh%,FFace%=1,FRadius1#=1.0,FRadius2#=3.0,FSegments%=120,FR1%=255,FG1%=255,FB1%=255,FR2%=255,FG2%=255,FB2%=255,FAlpha1#=1.0,FAlpha2#=1.0)
	
	If FSegments&gt;360 Then FSegments=360
	
	Local Angle%
	Local RV0%,RV1%,RV2%,RV3%
	Local RX0#,RX1#,RX2#,RX3#
	Local RY0#,RY1#,RY2#,RY3#
	Local SX0#,SX1#,SX2#,SX3#
	Local SY0#,SY1#,SY2#,SY3#
	Local U01#,U23#
	
	For Angle=1 To FSegments Step 1
		
		RX0=Sin(Angle*360.0/FSegments)*FRadius1
		RY0=Cos(Angle*360.0/FSegments)*FRadius1
		RX1=Sin(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RY1=Cos(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RX2=Sin(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RY2=Cos(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RX3=Sin(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		RY3=Cos(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		SX0=RX0: SY0=RY0
		SX1=RX0: SY1=RY0
		SX2=RX3: SY2=RY3
		SX3=RX3: SY3=RY3
		U01=0
		U23=0
		
		RV0=AddVertex(FFace,RX0,RY0,0, U01,0)
		RV1=AddVertex(FFace,RX1,RY1,0, 1,0)
		RV2=AddVertex(FFace,RX2,RY2,0, 1,0)
		RV3=AddVertex(FFace,RX3,RY3,0, U23,0)
		
		VertexColor FFace,RV0,FR1,FG1,FB1,FAlpha1
		VertexColor FFace,RV1,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV2,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV3,FR1,FG1,FB1,FAlpha1
		
		AddTriangle FFace,RV0,RV1,RV2
		AddTriangle FFace,RV2,RV3,RV0
		
	Next
	
	Return FMesh
	
End Function


;===========================================================================
; creates the saturn shadow texture using two spheres, simple math and a cam
;===========================================================================
Function CreateSaturnShadow(size%=512,scale#=3.5,angle#=180.0,blur%=2,col%=64,width#=20.0,length#=9.0)
	
	Local sphere1%,sphere2%,tmp%,surf1%,surf2%
	Local v%,x#,y#,z#,tex%,add#
	
	sphere1=CreateSphere(32)
	EntityFX sphere1,1+2
	
	sphere2=CreateSphere(32)
	EntityFX sphere2,1+2
	
	surf1=GetSurface(sphere1,1)
	surf2=GetSurface(sphere2,1)
	
	For v=0 To CountVertices(surf1)-1
		
		x#=VertexX(surf1,v)
		y#=VertexY(surf1,v)
		z#=VertexZ(surf1,v)
		
		If z&gt;0 Then add=Sqr(z*length) Else add=1
		
		VertexCoords surf1,v,x,y,z*Cos(width)*add
		VertexColor surf1,v,col,col,col
		VertexColor surf2,v,col,col,col
		
	Next
	
	tex=CreateTexture(size,size)
	
	tmp=CreateCamera()
	PositionEntity tmp,0,scale,0
	CameraClsColor tmp,255,255,255
	CameraViewport tmp,0,0,size,size
	PointEntity tmp,sphere1
	
	RenderWorld
	
	FreeEntity sphere1
	FreeEntity sphere2
	FreeEntity tmp
	
	CopyRect 0,0,size,size,0,0,BackBuffer(),TextureBuffer(tex)
	
	If blur Then BlurTexture(tex,blur,blur)
	
	RotateTexture tex,angle
	
	Return tex
	
End Function


;===========================================================================
; blurs the saturn shadow texture for soft transitions
;===========================================================================
Function BlurTexture(Texture, Blur_Quality, Blur_Radius#)
	
	Local BlurMesh[16*4]
	Local Loop
	Local Blur_Cam
	Local BlurRadius#,BlurAngleStep#,BlurShade%,BlurAngle#,Xoff#,Yoff#
	
	Local BLUR_CAM_X# = 65536.0
	Local BLUR_CAM_Y# = 65536.0
	Local BLUR_CAM_Z# = 0.0
	
	If Blur_Quality &gt; 0
		
		Blur_Cam = CreateCamera()
		CameraViewport Blur_Cam, 0, 0, TextureWidth(Texture), TextureHeight(Texture)
		CameraClsColor Blur_Cam, 0, 0, 0
		CameraClsMode  Blur_Cam, True, True						
		CameraRange Blur_Cam, 0.1, 100
		CameraZoom Blur_Cam, 16.0
		RotateEntity Blur_Cam, 90, 0, 0, True
		PositionEntity Blur_Cam, BLUR_CAM_X#, BLUR_CAM_Y#, BLUR_CAM_Z#
		For Loop = 0 To (Blur_Quality*4)-1
			BlurMesh[Loop] = CreateSprite()
		Next
		TextureBlend Texture, 2
		ScaleTexture    Texture, 0.5, 0.5
		PositionTexture Texture, 0.5, 0.5
		
		BlurRadius = Blur_Radius# * (1.0 / 256.0)
		BlurAngleStep = 360.0 / Float(Blur_Quality*4)
		BlurShade = Ceil(255.0 / Float(Blur_Quality*4))
		
		For Loop = 0 To (Blur_Quality*4)-1
			
			EntityTexture BlurMesh[Loop], Texture
			EntityFX BlurMesh[Loop], 1+8
			EntityAlpha BlurMesh[Loop], 1.0 / Float(Loop+1)
			ScaleSprite BlurMesh[Loop], 2, 2
			
			BlurAngle# = BlurAngleStep# * Float(Loop) + 180.0*(Loop Mod 2)
			
			Xoff# = BlurRadius# * Cos(BlurAngle#)
			Yoff# = BlurRadius# * Sin(BlurAngle#)
			
			PositionEntity BlurMesh[Loop], BLUR_CAM_X# + Xoff#, BLUR_CAM_Y# - 16.0, BLUR_CAM_Z# + Yoff#, True
			
		Next
		
		RenderWorld
		
		CopyRect 0, 0, TextureWidth(Texture), TextureHeight(Texture), 0, 0, BackBuffer(), TextureBuffer(Texture)
		
		For Loop = 0 To (Blur_Quality*4)-1
			FreeEntity BlurMesh[Loop]
		Next
		
		FreeEntity Blur_Cam
		
	EndIf
	
	ScaleTexture Texture,1,1
	PositionTexture Texture,0,0
	
End Function


;===========================================================================
; updates the vertex colors of a mesh
;===========================================================================
Function UpdateVertexColors(mesh%,r%,g%,b%,a#)
	
	Local s%,surf%,v%
	
	For s=1 To CountSurfaces(mesh)
		
		surf=GetSurface(mesh,s)
		
		For v=0 To CountVertices(surf)-1
			
			VertexColor surf,v,r,g,b,a
			
		Next
		
	Next
	
End Function


;===========================================================================
; creates a fake shader (spherical glow effect), should match planet size
;===========================================================================
Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)
	
	Local shader%=CreateSphere(segments)
	Local tex%=CreateFakeShaderTexture()
	
	ScaleEntity shader,size,size,size
	EntityBlend shader,3
	EntityFX shader,2
	EntityOrder shader,-1
	UpdateVertexColors(shader,r,g,b,a)
	
	TextureBlend tex,2
	EntityTexture shader,tex,0,1
	
	Return shader%
	
End Function


;===========================================================================
; creates fake shader texture
;===========================================================================
Function CreateFakeShaderTexture()
	
	Local tex%=CreateTexture(512,512,64)
	Local tb%=TextureBuffer(tex)
	
	Local x%,y%,i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For x=0 To 511
		
		For y=0 To 511
			
			rgb=255*$1000000+255*$10000+255*$100+255
			WritePixelFast x,y,rgb,tb
			
		Next
		
	Next
	
	For j=0 To 255
		
		col=j*1.0/Exp((255-j)*0.02)
		
		If col&gt;255 Then col=255
		If col&lt;0 Then col=0
		
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create planet atmosphere
;===========================================================================
Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	If segments&gt;360 Then segments=360
	
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		VertexColor surf,v0,r1,g1,b1,al1
		VertexColor surf,v1,r1,g1,b1,al1
		VertexColor surf,v2,r2,g2,b2,al2
		VertexColor surf,v3,r2,g2,b2,al2
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function


;===========================================================================
; update planet atmosphere
;===========================================================================
Function UpdateGlow(mesh%,cam%)
	
	Local radius#,distance#
	Local c1#,a1#,q1#,p1#,h1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#
	
	PointEntity mesh,cam
	
	radius=SCALE
	distance=EntityDistance(cam,PLANET)
	
	; First triangle
	c1=distance
	a1=radius
	q1=a1^2/c1
	p1=c1-q1
	h1=Sqr(p1*q1)
	gamma1=90
	alpha1=ATan(h1/p1)
	beta1=gamma1-alpha1
	
	; Second Triangle
	alpha2=90-(90-beta1)
	b2=a1/Tan(alpha2)
	c2=(Sqr(a1^2+b2^2))/radius
	
	ScaleEntity mesh,c2,c2,c2
	
End Function


;===========================================================================
; create planetary ring texture
;===========================================================================
Function CreateRingTexture(size%=1024,seed1%=1,seed2%=2,flags%=0,usealpha%=False,method$="normal",fading#=1.0,range#=0.7)
	
	Local tex%=CreateTexture(size,1,flags)
	Local buffer%=TextureBuffer(tex)
	
	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#
	
	LockBuffer buffer
	
	For x=0 To size-1
		
		h1=Perlin3D(x*(2048/size),0,0,1024,seed1,0,15)
		h2=Perlin3D(0,x*(2048/size),0,512,seed2,0,7)
		
		col=Int(Normalize(h1,-range,range,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255
		
		If usealpha Then
			
			If method="soft" Then
				
				; soft rings
				alpha=(Int(Normalize(h2,-range,range,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))/2.0
				
			Else If method="sharp" Then
				
				; sharp rings
				alpha=Int(Normalize(h1,-range,range,0,1.0)*col)*Rnd(0.98,1.02)
				
			Else
				; normal rings
				alpha=Int(Normalize(h2,-range,range,0,1.0)*col)
			EndIf
			
			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255
			
		Else
			
			alpha=255
			
		EndIf
		
		; soft fading to the outer rings
		If x&gt;(size*fading) Then
			
			value=Normalize(x,size*fading,size,1,0)
			
			alpha=alpha*value
			col=col*value
			
		EndIf
		
		density[x]=alpha;(col+alpha)/2
		ringcolor[x]=col
		
		rgb=alpha*$1000000+col*$10000+col*$100+col
		
		WritePixelFast x,0,rgb,buffer
		
	Next
	
	UnlockBuffer buffer
	
	Return tex
	
End Function


;===========================================================================
; normalize value
;===========================================================================
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


;===========================================================================
; fast perlin noise functions
;===========================================================================
Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

Function FastNoise(size%,Scale#,Multiplier#,wrap%=False)
	
	Local Max_Height#,NoiseMapSize%,ScaleDifference#,StepSize#
	Local N1#,N2#,N3#,N4#,HX#,HY#,IX#,IY#,ICX#,ICY#,NA#,NB#,NC#,ND#
	Local i%,x%,y%,xx%,yy%
	Local v#
	
	Max_Height=Scale
	
	For y=0 To size Step 1
		
		For x=0 To size Step 1
			
			HeightMap(x,y)=Rnd(0,1)
			
		Next
		
	Next
	
	NoiseMapSize=size/2
	Max_Height=Max_Height*Multiplier
	
	Repeat
		
		For y=0 To NoiseMapSize
			
			For x=0 To NoiseMapSize
				
				NoiseMap(x,y)=Rnd(0,Max_Height#)
				
			Next
			
		Next
		
		If wrap Then
			
			For i=0 To NoiseMapSize : NoiseMap(i,0)=NoiseMap(i,NoiseMapSize) : Next
			For i=0 To NoiseMapSize : NoiseMap(0,i)=NoiseMap(NoiseMapSize,i) : Next
			
		EndIf
		
		ScaleDifference=size*1.0/NoiseMapSize
		StepSize=1.0/Float(ScaleDifference)
		
		For y=0 To NoiseMapSize-1
			
			For x=0 To NoiseMapSize-1
				
				N1=NoiseMap(x,  y  )
				N2=NoiseMap(x+1,y  )
				N3=NoiseMap(x,  y+1)
				N4=NoiseMap(x+1,y+1)
				
				HX=x*ScaleDifference
				HY=y*ScaleDifference
				
				IY=0
				
				For yy=0 To ScaleDifference-1
					
					ICY=1.0-((Cos(IY*180.0)+1.0)/2.0)
					
					IX=0	
					
					For xx=0 To ScaleDifference-1
						
						ICX=1.0-((Cos(IX*180.0)+1.0)/2.0)
						
						NA=N1*(1.0-ICX)
						NB=N2*ICX
						NC=N3*(1.0-ICX)
						ND=N4*ICX
						
						v=HeightMap(HX+xx,HY+yy)+(NA+NB)*(1.0-ICY)+(NC+ND)*ICY
						
						If v&gt;Maxh Then Maxh=v
						If v&lt;minh Then minh=v
						
						HeightMap(HX+xx,HY+yy)=v
						
						IX=IX+StepSize
						
					Next
					
					IY=IY+StepSize	
					
				Next
				
			Next
			
		Next
		
		NoiseMapSize=NoiseMapSize/2
		
		Max_Height=Max_Height*Multiplier
		
	Until NoiseMapSize&lt;=2
	
End Function


.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea><br><br>EDIT: there are two additional speed improvement in UpdateStarfield():<br><br><b>d=Distance3D(cx,cy,cz,s\x,s\y,s\z)</b> is faster than Entitydistance and <br><br><b>TFormPoint s\x,s\y,s\z,0,CAM : If TFormedZ()&gt;0 Then</b> is faster then EntityInView()<br><br>And the ring transition between ICETEX1-3 and the particles has been optimized to fade more seamless and match the size. <br><br></td></tr></table><br>
<a name="1044684"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very impressive code (;-) <br><br></td></tr></table><br>
<a name="1044926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>d=Distance3D(cx,cy,cz,s\x,s\y,s\z) is faster than Entitydistance and <br><br>TFormPoint s\x,s\y,s\z,0,CAM : If TFormedZ()&gt;0 Then is faster then EntityInView()<br><br> <br></div><br>That's really interesting to know. Presumably faster because the maths is being processed by the CPU rather than GPU when done this way, Or maybe some internal bottleneck with the compiling of the b3D commands/DX 7?<br><br>You really have done wonders with this code, Krischan :)<br><br><br>Edit: Just noticed the "sprite" is still rendered even when far awaay from the ring, or even facing away from it, is this worth even hiding or is it not gonna make enough of a difference? <br><br></td></tr></table><br>
<a name="1067719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MErren</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi There,<br><br>at first: I Love the procedural Saturn Demo !<br><br>i've added a little Texture to the Ring<br><br>Have Fun<br><br><br><br>AppTitle "Procedural Saturn 3.0 a"<br><br>Graphics3D 1024,768,32,2<br><br>Dim P%(512),GRAYD#(512),HeightMap#(0,0),NoiseMap#(0,0)<br>Global minh#=2^16,Maxh#<br><br>Global density%[1024],ringcolor%[1024]<br><br>Global quadparticles%,spritetex%,spritebuf%,pixelparticles%<br><br>Type star<br>	<br>	Field col%<br>	Field scale#<br>	Field x#,y#,z#<br>	Field visible%<br>	<br>End Type<br><br>Const SCALEX#		= 2.00	; starfield scale X<br>Const SCALEY#		= 0.25	; starfield scale Y<br>Const SCALEZ#		= 2.00	; starfield scale Z<br>Const MAXSTARS%		= 50000 ; maximum asteroids<br>Const TurnSpeed#	= 4.00	; cam turn speed<br>Const RollSpeed#	= 0.50	; cam roll speed<br>Const CameraSpeed#	= 0.01	; cam move speed<br>Const SEED_PLANET1%	= 8		; seed for procedural planet texture<br>Const SEED_PLANET2%	= 8		; seed for procedural planet texture<br>Const SEED_RING1%	= 6		; seed for procedural ring texture<br>Const SEED_RING2%	= 6		; seed for procedural ring texture<br>Const SCALE#		= 100.0	; planet scale<br>Const SEGMENTS%		= 32	; sphere detail<br>Const RINGDETAIL%	= 360	; ring segments<br>Const GLOWSEGMENTS%	= 360	; glow segments<br>Const MINRINGRAD#	= 0.7	; minimum ring radius<br>Const MAXRINGRAD#	= 3.0	; maximum ring radius<br>Const PR%			= 255	; planet colors RED<br>Const PG%			= 192	; planet colors GREEN<br>Const PB%			= 128	; planet colors BLUE<br><br>Global WIDTH%=GraphicsWidth()<br>Global HEIGHT%=GraphicsHeight()<br>Global TIMER%=CreateTimer(60)<br><br>Global CAM%,PLANET%,PLANETTEX%,RING%,LIGHT,GLOW%,SHADER%<br>Global RINGTEX%,ICETEX1%,ICETEX2%,ICETEX3%,SHADOWTEX%<br><br>InitNoise(1.0)<br><br>; Planet<br>PLANET=CreateSphere(SEGMENTS)<br>ScaleEntity PLANET,SCALE,SCALE,SCALE<br>EntityShininess PLANET,0.1<br>EntityFX PLANET,2<br>UpdateVertexColors(PLANET,PR,PG,PB,1)<br>PLANETTEX=CreateRingTexture(256,SEED_PLANET1,SEED_PLANET2,1,False,"soft",1.0,1.0)<br>TextureBlend PLANETTEX,2<br>RotateTexture PLANETTEX,90<br>EntityTexture PLANET,PLANETTEX<br><br>; Planet Atmosphere<br>GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,GLOWSEGMENTS,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)<br><br>; Planet Fake Shader<br>SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.6)<br><br>; Ring System<br>CreateSaturnRing(512,50000,1+8,"normal","normal",0.95,0.75,"perlin")<br><br>; Light source<br>LIGHT=CreateLight(1)<br>RotateEntity LIGHT,0,-90,0<br>AmbientLight 0,0,0<br><br>; Camera<br>CAM=CreateCamera()<br>CameraRange CAM,0.0001*SCALE,1000*SCALE<br>MoveEntity CAM,-1*SCALE,1.0/64*SCALE,-2*SCALE<br>PointEntity CAM,PLANET<br><br>; star quad<br>Global star=CreateQuad()<br>HideEntity star<br><br>; starfield mesh<br>Global starfield=CreateMesh()<br>;ScaleEntity starfield,Rnd(.5,3),Rnd(.5,3),Rnd(.5,3)<br>Global surf=CreateSurface(starfield)<br>EntityTexture starfield,CreateStarTexture(256,3)													;Starset<br>EntityFX starfield,1+2+32<br>EntityBlend starfield,4<br>EntityOrder starfield,-1<br><br>; fill star field<br>AddStars(MAXSTARS,0.005,0.01)<br><br>; static camera sprite (far away particles)<br>Global sprite=CreateSprite(CAM)<br>ScaleSprite sprite,WIDTH,HEIGHT<br>PositionEntity sprite,0,0,WIDTH<br>EntityColor sprite,255,155, 55<br>EntityBlend sprite,3<br>EntityOrder sprite,-1<br><br>; Milkyway background<br>;Include "milkyway.bb" : Global MILKYWAY%=InitMilkyway(5000,0.5,5,90,1,0,0,0,1,255,192,255,1,0,0,0,1)<br><br>MoveMouse WIDTH/2,HEIGHT/2<br><br>;===========================================================================<br>; main loop<br>;===========================================================================<br>While Not KeyHit(1)<br>	<br>	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%,sl4%,zoom#=1.0,d#,tmp%,ds%,dc%<br>	<br>	; SHIFT or RMB = 50x faster cam flight<br>	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=50<br>	<br>	; SPACE = Wireframe<br>	If KeyHit(57) Then wf=1-wf : WireFrame wf<br>	<br>	; KEYS 1-4 = show/hide special planet FX<br>	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING<br>	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW<br>	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER<br>	If KeyHit(5) Then sl4=1-sl4 : If sl4=1 Then HideEntity sprite Else ShowEntity sprite<br>	<br>	; LMB = Ultra Zoom 100x<br>	If MouseDown(1) Then zoom=100.0 : l=500.0<br>	<br>	; camera movement<br>	Movement(CAM)<br>	CameraZoom CAM,zoom<br>	<br>	If MILKYWAY Then PositionEntity MILKYWAY,EntityX(CAM),EntityY(CAM),EntityZ(CAM)<br>	<br>	; update atmosphere glow according to camera<br>	UpdateGlow(GLOW,CAM)<br>	<br>	; calc ring density<br>	d#=EntityDistance(CAM,PLANET)<br>	If d&gt;SCALE*MINRINGRAD And d&lt;SCALE*MAXRINGRAD Then<br>		tmp=Normalize(d,SCALE*MINRINGRAD,SCALE*MAXRINGRAD,0,512)<br>		ds=Int(density[tmp])<br>		dc=Int(ringcolor[tmp])<br>	EndIf<br>	<br>	; update asteroids<br>	UpdateStarfield(CAM,2,1,ds,dc)<br>	<br>	; Update Saturn Ring Alpha<br>	UpdateVertexColors(RING,255,255,255,1.0-(1.0/Exp(Abs(EntityY(CAM)*0.5))))<br>	<br>	RenderWorld<br>	<br>	WaitTimer TIMER<br>	<br>	; show some stats in the app title<br>	AppTitle quadparticles+" Quads [and "+pixelparticles+" Pixel Particles] | "+(ds/2.55)+"% RING density | "+TrisRendered()+" Tris"<br>	<br>	Flip 0<br>	<br>Wend<br><br>End<br><br><br>; -----------------------------------------------------------------------------<br>; simple spaceship freeflight<br>; -----------------------------------------------------------------------------<br>Function Movement(cam%,sensitivity#=1.0)<br>	<br>	Local roll#,cz#,tx#,ty#,multi%=1<br>	<br>	cz=(KeyDown(200)-KeyDown(208))*CameraSpeed<br>	roll=(KeyDown(203)-KeyDown(205))*RollSpeed<br>	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=25<br>	<br>	tx=Normalize(MouseX(),0,WIDTH , 1,-1)<br>	ty=Normalize(MouseY(),0,HEIGHT,-1, 1)<br>	<br>	If ty&lt;0 Then ty=(Abs(ty)^sensitivity)*-1 Else ty=ty^sensitivity<br>	If tx&lt;0 Then tx=(Abs(tx)^sensitivity)*-1 Else tx=tx^sensitivity<br>	<br>	TurnEntity cam,ty*TurnSpeed,tx*TurnSpeed,roll*TurnSpeed<br>	MoveEntity cam,0,0,cz*multi<br>	<br>End Function<br><br><br>; -----------------------------------------------------------------------------<br>; create a quad<br>; -----------------------------------------------------------------------------<br>Function CreateQuad(r%=255,g%=255,b%=255,a#=1.0)<br>	<br>	Local mesh%,surf%,v1%,v2%,v3%,v4%<br>	<br>	mesh=CreateMesh()<br>	surf=CreateSurface(mesh)<br>	<br>	v1=AddVertex(surf,-1,1,0,1,0)<br>	v2=AddVertex(surf,1,1,0,0,0)<br>	v3=AddVertex(surf,-1,-1,0,1,1)<br>	v4=AddVertex(surf,1,-1,0,0,1)<br>	<br>	VertexColor surf,v1,r,g,b,a<br>	VertexColor surf,v3,r,g,b,a<br>	VertexColor surf,v2,r,g,b,a<br>	VertexColor surf,v4,r,g,b,a<br>	<br>	AddTriangle(surf,0,1,2)<br>	AddTriangle(surf,3,2,1)<br>	<br>	FlipMesh mesh<br>	<br>	Return mesh<br>	<br>End Function<br><br><br>; -----------------------------------------------------------------------------<br>; rebuild starfield mesh<br>; -----------------------------------------------------------------------------<br>Function UpdateStarfield(parent%,maxdist#=2.0,fader%=False,ds%,dc%)<br>	<br>	Local s.star,px#,py#,pz#,d#,a#,rgb%,col%,x%,y%,movecheck%<br>	<br>	Local cx#=EntityX(parent)<br>	Local cy#=EntityY(parent)<br>	Local cz#=EntityZ(parent)<br>	<br>	Local density%=Int(ds/2.55)<br>	<br>	ClearSurface(surf)<br>	<br>	quadparticles=0<br>	pixelparticles=0<br>	<br>	; delete and create a new texture, acutally faster than clearing it<br>	If spritetex Then FreeTexture spritetex<br>	spritetex=CreateTexture(512,512,1)<br>	spritebuf=TextureBuffer(spritetex)<br>	EntityTexture sprite,spritetex<br>	<br>	LockBuffer spritebuf<br>	<br>	For s.star = Each star<br>		<br>		movecheck=False<br>		<br>		; calc star position<br>		px=cx-s\x<br>		py=cy-s\y<br>		pz=cz-s\z<br>		<br>		; check if star must be moved<br>		If px&lt;-SCALEX Then s\x=s\x-(SCALEX Shl 1) : movecheck=True<br>		If px&gt;+SCALEX Then s\x=s\x+(SCALEX Shl 1) : movecheck=True<br>		If pz&lt;-SCALEZ Then s\z=s\z-(SCALEZ Shl 1) : movecheck=True<br>		If pz&gt;+SCALEZ Then s\z=s\z+(SCALEZ Shl 1) : movecheck=True<br>		<br>		If movecheck Then s\visible=(Rand(100)&lt;density)<br>		<br>		If s\visible Then<br>			<br>			; reposition star<br>			PositionEntity star,s\x,s\y,s\z<br>			<br>			; get distance<br>			d=Distance3D(cx,cy,cz,s\x,s\y,s\z)<br>			<br>			; check if not to far away<br>			If d&lt;maxdist<br>				<br>				TFormPoint s\x,s\y,s\z,0,CAM<br>				<br>				; star is visible (in front of cam)?<br>				If TFormedZ()&gt;0 Then<br>					<br>					; fade pixel particles<br>					col=255<br>					If fader Then<br>						col=Int(Normalize(d,0,maxdist,dc,0))<br>						If col&lt;0 Then col=0 Else If col&gt;dc Then col=dc<br>					EndIf<br>					rgb=col*$10000+col*$100+col<br>					<br>					; calculate pixel particle 2D position<br>					CameraProject CAM,s\x,s\y,s\z<br>					x=Normalize(ProjectedX(),0,WIDTH-1,0,511)<br>					y=Normalize(ProjectedY(),0,HEIGHT-1,0,511)<br>					<br>					; pixel inside texture range? draw to texture!<br>					If x&gt;0 And x&lt;511 And y&gt;0 And y&lt;511 Then<br>						WritePixelFast x,y,rgb,spritebuf<br>						pixelparticles=pixelparticles+1<br>					EndIf<br>					<br>					; distance close enough to cam? spawn quad particle and add it to mesh<br>					If d&lt;maxdist*0.25 Then<br>						<br>						; align star to cam<br>						PointEntity star,CAM<br>						<br>						ScaleEntity star,s\scale,s\scale,s\scale<br>						<br>						; add alpha<br>						a=1.0 : If fader Then a=Normalize(d,0,maxdist*0.25,1,0)<br>						<br>						; add star To starfield again<br>						AddMeshToSurface(star,surf,starfield,s\col,s\col,s\col,a)<br>						<br>						quadparticles=quadparticles+1<br>						<br>					EndIf<br>					<br>				EndIf<br>				<br>			EndIf<br>			<br>		EndIf<br>		<br>	Next<br>	<br>	UnlockBuffer spritebuf<br>	<br>	Return density<br>	<br>End Function<br><br><br>; -----------------------------------------------------------------------------<br>; add a mesh to another mesh<br>; -----------------------------------------------------------------------------<br>Function AddMeshToSurface(mesh,surf,singlesurfaceentity,r%,g%,b%,a#) <br>	<br>	Local vert%[2],vr%[2],vg%[2],vb%[2],va#[2],nx#[2],ny#[2],nz#[2]<br>	Local surface%,oldvert%,i%,i2%<br>	<br>	surface = GetSurface(mesh,1) <br>	<br>	For i = 0 To CountTriangles(surface)-1<br>		<br>		For i2 = 0 To 2 <br>			<br>			oldvert = TriangleVertex(surface,i,i2)<br>			<br>			vr[i2]=r<br>			vg[i2]=g<br>			vb[i2]=b<br>			va[i2]=a<br>			nx[i2]=VertexNX(surface,oldvert)<br>			ny[i2]=VertexNY(surface,oldvert)<br>			nz[i2]=VertexNZ(surface,oldvert)<br>			<br>			TFormPoint VertexX(surface,oldvert),VertexY(surface,oldvert),VertexZ(surface,oldvert), mesh,singlesurfaceentity <br>			vert[i2] = AddVertex(surf,TFormedX(),TFormedY(),TFormedZ(),VertexU(surface,oldvert),VertexV(surface,oldvert)) <br>			VertexNormal surf,vert[i2],nx[i2],ny[i2],nz[i2]<br>			VertexColor surf,vert[i2],r,g,b,a<br>			<br>		Next <br>		<br>		AddTriangle(surf,vert[0],vert[1],vert[2])<br>		<br>	Next <br>	<br>End Function<br><br><br>; -----------------------------------------------------------------------------<br>; add stars to starfield mesh<br>; -----------------------------------------------------------------------------<br>Function AddStars(amount%=1,min#=0.01,max#=0.02,addx#=0.0,addy#=0.0,addz#=0.0)<br>	<br>	Local i%,s.star<br>	Local density%=Normalize(Perlin3D(0,0,0,16,1,0,3),-1,1,0,100)<br>	If density&lt;0 Then density=0 Else If density&gt;100 Then density=100<br>	<br>	For i=1 To amount<br>		<br>		s.star = New star<br>		<br>		s\col=Rand(64,255)<br>		s\x=addx+Rnd(-SCALEX,SCALEX)<br>		s\y=addy+Rnd(Rnd(Rnd(Rnd(-SCALEY))),Rnd(Rnd(Rnd(SCALEY))))<br>		s\z=addz+Rnd(-SCALEZ,SCALEZ)<br>		s\scale=Rnd(min,max)<br>		<br>		If Rand(100)&lt;density Then s\visible=True<br>			<br>	Next<br>	<br>End Function<br><br><br>; -----------------------------------------------------------------------------<br>; simple 3D distance calculation<br>; -----------------------------------------------------------------------------<br>Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)<br>	<br>	Local x#=x1-x2<br>	Local y#=y1-y2<br>	Local z#=z1-z2<br>	<br>	Return Sqr((x*x)+(y*y)+(z*z))<br>	<br>End Function<br><br><br>; -----------------------------------------------------------------------------<br>; create a simple star texture<br>; -----------------------------------------------------------------------------<br>Function CreateStarTexture(size%=256,flags%=3)<br><br>	<br>	Local tex%=CreateTexture(size,size,4)<br>	Local tb%=TextureBuffer(tex)<br> <br>	SetBuffer tb<br>	;LockBuffer tb<br>	<br>	asdu=8000<br>	For as= 1 To asdu<br>	dur=Rnd(50)<br>	Color 170+dur,120,30<br>	Oval 128+Rnd(-50,50),128+Rnd(-50,50),Rnd(10),Rnd(10),1;Rnd(0,1)<br>	Next<br>	<br>	Color 0,0,0<br>	wx=Rnd(-20,20):wy=Rnd(-20,20)<br>	For w = 360 To 100 Step -1 <br>	Oval 128-(w/2),128-(w/2),w-.5+wx,w-.5+wy,0<br>	Oval 128-(w/2),128-(w/2),w+wx,w+wy,0<br>	Oval 128-(w/2),128-(w/2),w+.5+wx,w+.5+wy,0<br>	Next<br>	<br>For schx =0 To 255<br>	For schy =0 To 255	<br>	<br>	GetColor schx,schy <br>	If  ColorRed()=0 And  ColorGreen()=0 And ColorBlue()=0 Then	<br><br>	 RGB1=ReadPixelFast(schx,schy,argb)<br>		 	;r=(RGB1 And $FF0000)Shr 16;separate out the red<br>		 	;g=(RGB1 And $FF00) Shr 8;green<br>		 	;b=RGB1 And $FF;and blue parts of the color<br>		 	;a=(RGB1 And $FF000000)Shr 24<br>			 a=0;add alpha 255; remove any alpha information currently in the texture.<br>		 	newrgb= (a Shl 24) Or (r Shl 16) Or (g Shl 8) Or b; combine the ARGB back into a number<br>			WritePixelFast(schx,schy,newrgb); write the info back to the texture<br>  Else<br>	zc#=zc+.012<br>	rs=ColorRed()<br>	If rs&gt;zc Then rs=rs -zc*1.5 <br>	gs= ColorGreen()<br>	If gs&gt;zc Then gs=gs-zc*1.2 <br>	 bs= ColorBlue()<br>	If bs&gt;zc Then bs=bs-zc<br>	Color rs+Rnd(-5,5),gs+Rnd(-5,5),bs <br>	Plot schx,schy<br> EndIf<br><br>	Next<br>	Next<br> <br><br>		<br>	;UnlockBuffer tb<br>	SetBuffer BackBuffer()<br>	<br>	Return tex<br>	<br>End Function<br><br><br><br>; -----------------------------------------------------------------------------<br>; create a simple star texture<br>; -----------------------------------------------------------------------------<br>Function CreateStoneTexture(size%=256,flags%=3)<br>	<br>	Local tex%=CreateTexture(size,size,flags)<br>	Local tb%=TextureBuffer(tex)<br>	<br>	Local i#,j%,col%,rgb%<br>	<br>	SetBuffer tb<br>	LockBuffer tb<br>	<br>	For j=0 To 255<br>		<br>		col=255-j<br>		If col&gt;255 Then col=255<br>		rgb=col*$1000000+col*$10000+col*$100+col<br>		<br>		For i=0 To 360 Step 0.1<br>			<br>			WritePixelFast (size/2)+(Sin(i)*(j*size/512)),(size/2)+(Cos(i)*(j*size/512)),rgb,tb<br>			<br>		Next<br>		<br>	Next<br>	<br><br>	<br>	UnlockBuffer tb<br>	SetBuffer BackBuffer()<br>	<br>	Return tex<br>	<br>End Function<br><br><br>;===========================================================================<br>; create procedural ring detail textures using perlin functions<br>;===========================================================================<br>Function CreateProceduralRingTextures(brightness1%=192,brightness2%=160,brightness3%=128,size%,detail%,flags%,noisetype$="perlin")<br>	<br>	Local buffer1%,buffer2%,buffer3%<br>	Local x%,y%,rgb%,rgb1%,rgb2%,col%,r%,i%<br>	<br>	If noisetype="fast" Then<br>		Dim HeightMap(size,size)<br>		Dim NoiseMap(size+1,size+1)<br>		FastNoise(size,8,1.2,1)<br>	EndIf<br>	<br>	ICETEX1=CreateTexture(size,size,flags)<br>	ICETEX2=CreateTexture(size,size,flags)<br>	ICETEX3=CreateTexture(size,size,flags)<br>	<br>	buffer1=TextureBuffer(ICETEX1)<br>	buffer2=TextureBuffer(ICETEX2)<br>	buffer3=TextureBuffer(ICETEX3)<br>	<br>	LockBuffer buffer1<br>	LockBuffer buffer2<br>	LockBuffer buffer3<br>	<br>	For x=0 To size-1<br>		For y=0 To size-1<br>			rgb1=brightness1*$10000+brightness1*$100+brightness1<br>			rgb2=brightness2*$10000+brightness2*$100+brightness2<br>			WritePixelFast x,y,rgb1,buffer1<br>			WritePixelFast x,y,rgb2,buffer2<br>		Next<br>	Next<br>	<br>	For i=1 To detail<br>		<br>		; random position<br>		x=Rand(0,size-1)<br>		y=Rand(0,size-1)<br>		<br>		; random randomized randomizer<br>		r=Rand(0,Rand(0,Rand(0,255)))<br>		<br>		; perlin or fast noise<br>		If noisetype="fast" Then<br>			col=Normalize(HeightMap(x,0),minh,Maxh,brightness1,255)<br>		Else<br>			col=Normalize(Perlin3D(x,0,y,4,1,0,15),-1,1,brightness1,255)<br>		EndIf<br>		col=Normalize(col+r,brightness1,511,brightness2,255)<br>		<br>		; layer 1+2: identical perlin noise mixed with random<br>		rgb=col*$10000+col*$100+col<br>		WritePixelFast x,y,rgb,buffer1<br>		WritePixelFast x,y,rgb,buffer2<br>		<br>		; layer 3: starfield like<br>		If noisetype="fast" Then<br>			col=Normalize(HeightMap(y,x),minh,Maxh,0,128)<br>		Else<br>			col=Normalize(Perlin3D(x,y,0,16,1,0,7),-1,1,0,128)<br>		EndIf<br>		col=Normalize(col+r,0,511,brightness3,255)<br>		If col&lt;brightness3 Then col=brightness3<br>		rgb=col*$10000+col*$100+col<br>		WritePixelFast x,y,rgb,buffer3<br>		<br>	Next<br>	<br>	UnlockBuffer buffer3<br>	UnlockBuffer buffer2<br>	UnlockBuffer buffer1<br>	<br>End Function<br><br><br>;===========================================================================<br>; main call to create the saturn ring system<br>;===========================================================================<br>Function CreateSaturnRing(size%=512,detail%=50000,flags%=1+8,mode$="normal",style$="cassini",fading#=0.85,range#=0.7,noisetype$="perlin")<br>	<br>	Local v%,surf%<br>	<br>	; create procedural ring textures (ICETEX1-3)<br>	CreateProceduralRingTextures(160,192,0,size,detail,flags,noisetype)<br>	<br>	; create shadow texture<br>	If style="cassini" Then<br>		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,8)<br>	Else If style="linear" Then<br>		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,0,100)<br>	Else<br>		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,16)<br>	EndIf<br>	<br>	; create main ring texture<br>	RINGTEX=CreateRingTexture(size,SEED_RING1,SEED_RING2,3,True,mode,fading,range)<br>	<br>	; create planetary ring<br>	RING=CreateMesh(PLANET)<br>	EntityFX RING,1+2+16+32<br>	;EntityBlend RING,3<br>	surf=CreateSurface(RING)<br>	UpdateSaturnRing(RING,surf,MINRINGRAD,MAXRINGRAD,RINGDETAIL,255,255,255,255,255,255,1.0,1.0)<br>	<br>	; init second UV set<br>	For v=0 To CountVertices(surf)-1<br>		VertexTexCoords surf,v,VertexX(surf,v),VertexY(surf,v),0,1<br>	Next<br>	<br>	; reposition shadow texture<br>	PositionTexture SHADOWTEX,0.5,0.5<br>	<br>	; user second UV set<br>	TextureCoords ICETEX1,1<br>	TextureCoords ICETEX2,1<br>	TextureCoords ICETEX3,1<br>	TextureCoords SHADOWTEX,1<br>	<br>	; scale textures<br>	ScaleTexture ICETEX1,1.0/128,1.0/128<br>	ScaleTexture ICETEX2,1.0/64,1.0/64<br>	ScaleTexture ICETEX3,1.0/32,1.0/32<br>	ScaleTexture SHADOWTEX,6,6<br>	<br>	; apply to mesh<br>	EntityTexture RING,RINGTEX,0,1<br>	EntityTexture RING,ICETEX1,0,2<br>	EntityTexture RING,ICETEX2,0,3<br>	EntityTexture RING,ICETEX3,0,4<br>	EntityTexture RING,SHADOWTEX,0,5<br>	<br>	; blend details<br>	TextureBlend ICETEX1,3<br>	TextureBlend ICETEX3,3<br>	<br>	; rotate ring<br>	RotateMesh RING,-90,90,0<br>	<br>End Function<br><br><br>;===========================================================================<br>; create planetary ring mesh<br>;===========================================================================<br>Function UpdateSaturnRing(FMesh%,FFace%=1,FRadius1#=1.0,FRadius2#=3.0,FSegments%=120,FR1%=255,FG1%=255,FB1%=255,FR2%=255,FG2%=255,FB2%=255,FAlpha1#=1.0,FAlpha2#=1.0)<br>	<br>	If FSegments&gt;360 Then FSegments=360<br>	<br>	Local Angle%<br>	Local RV0%,RV1%,RV2%,RV3%<br>	Local RX0#,RX1#,RX2#,RX3#<br>	Local RY0#,RY1#,RY2#,RY3#<br>	Local SX0#,SX1#,SX2#,SX3#<br>	Local SY0#,SY1#,SY2#,SY3#<br>	Local U01#,U23#<br>	<br>	For Angle=1 To FSegments Step 1<br>		<br>		RX0=Sin(Angle*360.0/FSegments)*FRadius1<br>		RY0=Cos(Angle*360.0/FSegments)*FRadius1<br>		RX1=Sin(Angle*360.0/FSegments -180.0/FSegments)*FRadius2<br>		RY1=Cos(Angle*360.0/FSegments -180.0/FSegments)*FRadius2<br>		RX2=Sin(Angle*360.0/FSegments +180.0/FSegments)*FRadius2<br>		RY2=Cos(Angle*360.0/FSegments +180.0/FSegments)*FRadius2<br>		RX3=Sin(Angle*360.0/FSegments +360.0/FSegments)*FRadius1<br>		RY3=Cos(Angle*360.0/FSegments +360.0/FSegments)*FRadius1<br>		SX0=RX0: SY0=RY0<br>		SX1=RX0: SY1=RY0<br>		SX2=RX3: SY2=RY3<br>		SX3=RX3: SY3=RY3<br>		U01=0<br>		U23=0<br>		<br>		RV0=AddVertex(FFace,RX0,RY0,0, U01,0)<br>		RV1=AddVertex(FFace,RX1,RY1,0, 1,0)<br>		RV2=AddVertex(FFace,RX2,RY2,0, 1,0)<br>		RV3=AddVertex(FFace,RX3,RY3,0, U23,0)<br>		<br>		VertexColor FFace,RV0,FR1,FG1,FB1,FAlpha1<br>		VertexColor FFace,RV1,FR2,FG2,FB2,FAlpha2<br>		VertexColor FFace,RV2,FR2,FG2,FB2,FAlpha2<br>		VertexColor FFace,RV3,FR1,FG1,FB1,FAlpha1<br>		<br>		AddTriangle FFace,RV0,RV1,RV2<br>		AddTriangle FFace,RV2,RV3,RV0<br>		<br>	Next<br>	<br>	Return FMesh<br>	<br>End Function<br><br><br>;===========================================================================<br>; creates the saturn shadow texture using two spheres, simple math and a cam<br>;===========================================================================<br>Function CreateSaturnShadow(size%=512,scale#=3.5,angle#=180.0,blur%=2,col%=64,width#=20.0,length#=9.0)<br>	<br>	Local sphere1%,sphere2%,tmp%,surf1%,surf2%<br>	Local v%,x#,y#,z#,tex%,add#<br>	<br>	sphere1=CreateSphere(32)<br>	EntityFX sphere1,1+2<br>	<br>	sphere2=CreateSphere(32)<br>	EntityFX sphere2,1+2<br>	<br>	surf1=GetSurface(sphere1,1)<br>	surf2=GetSurface(sphere2,1)<br>	<br>	For v=0 To CountVertices(surf1)-1<br>		<br>		x#=VertexX(surf1,v)<br>		y#=VertexY(surf1,v)<br>		z#=VertexZ(surf1,v)<br>		<br>		If z&gt;0 Then add=Sqr(z*length) Else add=1<br>		<br>		VertexCoords surf1,v,x,y,z*Cos(width)*add<br>		VertexColor surf1,v,col,col,col<br>		VertexColor surf2,v,col,col,col<br>		<br>	Next<br>	<br>	tex=CreateTexture(size,size)<br>	<br>	tmp=CreateCamera()<br>	PositionEntity tmp,0,scale,0<br>	CameraClsColor tmp,255,255,255<br>	CameraViewport tmp,0,0,size,size<br>	PointEntity tmp,sphere1<br>	<br>	RenderWorld<br>	<br>	FreeEntity sphere1<br>	FreeEntity sphere2<br>	FreeEntity tmp<br>	<br>	CopyRect 0,0,size,size,0,0,BackBuffer(),TextureBuffer(tex)<br>	<br>	If blur Then BlurTexture(tex,blur,blur)<br>	<br>	RotateTexture tex,angle<br>	<br>	Return tex<br>	<br>End Function<br><br><br>;===========================================================================<br>; blurs the saturn shadow texture for soft transitions<br>;===========================================================================<br>Function BlurTexture(Texture, Blur_Quality, Blur_Radius#)<br>	<br>	Local BlurMesh[16*4]<br>	Local Loop<br>	Local Blur_Cam<br>	Local BlurRadius#,BlurAngleStep#,BlurShade%,BlurAngle#,Xoff#,Yoff#<br>	<br>	Local BLUR_CAM_X# = 65536.0<br>	Local BLUR_CAM_Y# = 65536.0<br>	Local BLUR_CAM_Z# = 0.0<br>	<br>	If Blur_Quality &gt; 0<br>		<br>		Blur_Cam = CreateCamera()<br>		CameraViewport Blur_Cam, 0, 0, TextureWidth(Texture), TextureHeight(Texture)<br>		CameraClsColor Blur_Cam, 0, 0, 0<br>		CameraClsMode  Blur_Cam, True, True						<br>		CameraRange Blur_Cam, 0.1, 100<br>		CameraZoom Blur_Cam, 16.0<br>		RotateEntity Blur_Cam, 90, 0, 0, True<br>		PositionEntity Blur_Cam, BLUR_CAM_X#, BLUR_CAM_Y#, BLUR_CAM_Z#<br>		For Loop = 0 To (Blur_Quality*4)-1<br>			BlurMesh[Loop] = CreateSprite()<br>		Next<br>		TextureBlend Texture, 2<br>		ScaleTexture    Texture, 0.5, 0.5<br>		PositionTexture Texture, 0.5, 0.5<br>		<br>		BlurRadius = Blur_Radius# * (1.0 / 256.0)<br>		BlurAngleStep = 360.0 / Float(Blur_Quality*4)<br>		BlurShade = Ceil(255.0 / Float(Blur_Quality*4))<br>		<br>		For Loop = 0 To (Blur_Quality*4)-1<br>			<br>			EntityTexture BlurMesh[Loop], Texture<br>			EntityFX BlurMesh[Loop], 1+8<br>			EntityAlpha BlurMesh[Loop], 1.0 / Float(Loop+1)<br>			ScaleSprite BlurMesh[Loop], 2, 2<br>			<br>			BlurAngle# = BlurAngleStep# * Float(Loop) + 180.0*(Loop Mod 2)<br>			<br>			Xoff# = BlurRadius# * Cos(BlurAngle#)<br>			Yoff# = BlurRadius# * Sin(BlurAngle#)<br>			<br>			PositionEntity BlurMesh[Loop], BLUR_CAM_X# + Xoff#, BLUR_CAM_Y# - 16.0, BLUR_CAM_Z# + Yoff#, True<br>			<br>		Next<br>		<br>		RenderWorld<br>		<br>		CopyRect 0, 0, TextureWidth(Texture), TextureHeight(Texture), 0, 0, BackBuffer(), TextureBuffer(Texture)<br>		<br>		For Loop = 0 To (Blur_Quality*4)-1<br>			FreeEntity BlurMesh[Loop]<br>		Next<br>		<br>		FreeEntity Blur_Cam<br>		<br>	EndIf<br>	<br>	ScaleTexture Texture,1,1<br>	PositionTexture Texture,0,0<br>	<br>End Function<br><br><br>;===========================================================================<br>; updates the vertex colors of a mesh<br>;===========================================================================<br>Function UpdateVertexColors(mesh%,r%,g%,b%,a#)<br>	<br>	Local s%,surf%,v%<br>	<br>	For s=1 To CountSurfaces(mesh)<br>		<br>		surf=GetSurface(mesh,s)<br>		<br>		For v=0 To CountVertices(surf)-1<br>			<br>			VertexColor surf,v,r,g,b,a<br>			<br>		Next<br>		<br>	Next<br>	<br>End Function<br><br><br>;===========================================================================<br>; creates a fake shader (spherical glow effect), should match planet size<br>;===========================================================================<br>Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)<br>	<br>	Local shader%=CreateSphere(segments)<br>	Local tex%=CreateFakeShaderTexture()<br>	<br>	ScaleEntity shader,size,size,size<br>	EntityBlend shader,3<br>	EntityFX shader,2<br>	EntityOrder shader,-1<br>	UpdateVertexColors(shader,r,g,b,a)<br>	<br>	TextureBlend tex,2<br>	EntityTexture shader,tex,0,1<br>	<br>	Return shader%<br>	<br>End Function<br><br><br>;===========================================================================<br>; creates fake shader texture<br>;===========================================================================<br>Function CreateFakeShaderTexture()<br>	<br>	Local tex%=CreateTexture(512,512,64)<br>	Local tb%=TextureBuffer(tex)<br>	<br>	Local x%,y%,i#,j%,col%,rgb%<br>	<br>	SetBuffer tb<br>	LockBuffer tb<br>	<br>	For x=0 To 511<br>		<br>		For y=0 To 511<br>			<br>			rgb=255*$1000000+255*$10000+255*$100+255<br>			WritePixelFast x,y,rgb,tb<br>			<br>		Next<br>		<br>	Next<br>	<br>	For j=0 To 255<br>		<br>		col=j*1.0/Exp((255-j)*0.02)<br>		<br>		If col&gt;255 Then col=255<br>		If col&lt;0 Then col=0<br>		<br>		rgb=col*$1000000+col*$10000+col*$100+col<br>		<br>		For i=0 To 360 Step 0.1<br>			<br>			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb<br>			<br>		Next<br>		<br>	Next<br>	<br>	UnlockBuffer tb<br>	SetBuffer BackBuffer()<br>	<br>	Return tex<br>	<br>End Function<br><br><br>;===========================================================================<br>; create planet atmosphere<br>;===========================================================================<br>Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)<br>	<br>	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%<br>	Local mesh=CreateMesh()<br>	Local surf=CreateSurface(mesh)<br>	<br>	If segments&gt;360 Then segments=360<br>	<br>	For angle=1 To segments<br>		<br>		a1=angle*360.0/segments<br>		a2=angle*360.0/segments +360.0/segments<br>		a3=angle*360.0/segments +180.0/segments<br>		a4=angle*360.0/segments -180.0/segments<br>		<br>		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)<br>		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)<br>		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)<br>		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)<br>		<br>		VertexColor surf,v0,r1,g1,b1,al1<br>		VertexColor surf,v1,r1,g1,b1,al1<br>		VertexColor surf,v2,r2,g2,b2,al2<br>		VertexColor surf,v3,r2,g2,b2,al2<br>		<br>		AddTriangle surf,v2,v1,v0<br>		AddTriangle surf,v0,v3,v2<br>		<br>	Next<br>	<br>	If fx&gt;0 Then EntityFX mesh,fx<br>	If blend&gt;0 Then EntityBlend mesh,blend<br>	<br>	<br>	Return mesh<br>	<br>End Function<br><br><br>;===========================================================================<br>; update planet atmosphere<br>;===========================================================================<br>Function UpdateGlow(mesh%,cam%)<br>	<br>	Local radius#,distance#<br>	Local c1#,a1#,q1#,p1#,h1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#<br>	<br>	PointEntity mesh,cam<br>	<br>	radius=SCALE<br>	distance=EntityDistance(cam,PLANET)<br>	<br>	; First triangle<br>	c1=distance<br>	a1=radius<br>	q1=a1^2/c1<br>	p1=c1-q1<br>	h1=Sqr(p1*q1)<br>	gamma1=90<br>	alpha1=ATan(h1/p1)<br>	beta1=gamma1-alpha1<br>	<br>	; Second Triangle<br>	alpha2=90-(90-beta1)<br>	b2=a1/Tan(alpha2)<br>	c2=(Sqr(a1^2+b2^2))/radius<br>	<br>	ScaleEntity mesh,c2,c2,c2<br>	<br>End Function<br><br><br>;===========================================================================<br>; create planetary ring texture<br>;===========================================================================<br>Function CreateRingTexture(size%=1024,seed1%=1,seed2%=2,flags%=0,usealpha%=False,method$="normal",fading#=1.0,range#=0.7)<br>	<br>	Local tex%=CreateTexture(size,1,flags)<br>	Local buffer%=TextureBuffer(tex)<br>	<br>	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#<br>	<br>	LockBuffer buffer<br>	<br>	For x=0 To size-1<br>		<br>		h1=Perlin3D(x*(2048/size),0,0,1024,seed1,0,15)<br>		h2=Perlin3D(0,x*(2048/size),0,512,seed2,0,7)<br>		<br>		col=Int(Normalize(h1,-range,range,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255<br>		<br>		If usealpha Then<br>			<br>			If method="soft" Then<br>				<br>				; soft rings<br>				alpha=(Int(Normalize(h2,-range,range,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))/2.0<br>				<br>			Else If method="sharp" Then<br>				<br>				; sharp rings<br>				alpha=Int(Normalize(h1,-range,range,0,1.0)*col)*Rnd(0.98,1.02)<br>				<br>			Else<br>				; normal rings<br>				alpha=Int(Normalize(h2,-range,range,0,1.0)*col)<br>			EndIf<br>			<br>			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255<br>			<br>		Else<br>			<br>			alpha=255<br>			<br>		EndIf<br>		<br>		; soft fading to the outer rings<br>		If x&gt;(size*fading) Then<br>			<br>			value=Normalize(x,size*fading,size,1,0)<br>			<br>			alpha=alpha*value<br>			col=col*value<br>			<br>		EndIf<br>		<br>		density[x]=alpha;(col+alpha)/2<br>		ringcolor[x]=col<br>		<br>		rgb=alpha*$1000000+col*$10000+col*$100+col<br>		<br>		WritePixelFast x,0,rgb,buffer<br>		<br>	Next<br>	<br>	UnlockBuffer buffer<br>	<br>	Return tex<br>	<br>End Function<br><br><br>;===========================================================================<br>; normalize value<br>;===========================================================================<br>Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)<br>	<br>	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#<br>	<br>End Function<br><br><br>;===========================================================================<br>; fast perlin noise functions<br>;===========================================================================<br>Function InitNoise(range#=0.7)<br>	<br>	Local i%,perm%<br>	<br>	Restore permutation<br>	<br>	For i=0 To 256-1<br>		<br>		Read perm<br>		<br>		P(i)=perm<br>		P(256+i)=perm<br>		<br>		GRAYD#(i)=Rnd(-range,range)<br>		GRAYD#(256+i)=Rnd(-range,range)<br>		<br>	Next<br>	<br>End Function<br><br>Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) <br>	<br>	Local value#,initialSize#,i%<br>	<br>	If seed=0 Then seed=MilliSecs()<br>	<br>	x=x+seed<br>	y=y+seed<br>	z=z+seed<br>	<br>	value=0.0<br>	initialSize=size<br>	<br>	For i = 1 To MinOctaves : size=size/2 : Next<br>	<br>	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves<br>		<br>		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size<br>		size=size/2.0<br>		MaxOctaves=MaxOctaves-1<br>		<br>	Wend<br>	<br>	Return (value/Float(initialSize))<br>	<br>End Function<br><br>Function SmoothNoise#(x#,y#,z#,seed%=0)<br>	<br>	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#<br>	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#<br>	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#<br>	<br>	x=x+seed<br>	y=y+seed<br>	z=z+seed<br>	<br>	x1=(Floor(x) And 255)<br>	y1=(Floor(y) And 255)<br>	z1=(Floor(z) And 255)<br>	<br>	x=x-Floor(x)<br>	y=y-Floor(y)<br>	z=z-Floor(z)<br>	<br>	u=Fade(x)<br>	v=Fade(y)<br>	w=Fade(z)<br>	<br>	a=P(x1)+y1<br>	aa=P(a)+z1<br>	ab=P(a+1)+z1<br>	<br>	b=P(x1+1)+y1<br>	ba=P(b)+z1<br>	bb=P(b+1)+z1<br>	<br>	g1=GRAYD(bb+1)<br>	g2=GRAYD(ab+1)<br>	g3=GRAYD(ba+1)<br>	g4=GRAYD(aa+1)<br>	g5=GRAYD(bb)<br>	g6=GRAYD(ab)<br>	g7=GRAYD(ba)<br>	g8=GRAYD(aa)<br>	<br>	l1=Lerp(u,g2,g1)<br>	l2=Lerp(u,g4,g3)<br>	l3=Lerp(v,l2,l1)<br>	l4=Lerp(u,g6,g5)<br>	l5=Lerp(u,g8,g7)<br>	l6=Lerp(v,l5,l4)<br>	l7=Lerp(w,l6,l3)<br>	<br>	Return l7<br>	<br>End Function<br><br>Function Fade#(t#)<br>	<br>	Return t*t*t*(t*(t*6-15)+10)<br>	<br>End Function<br><br>Function Lerp#(t#,a#,b#)<br>	<br>	Return a+t*(b-a)<br>	<br>End Function<br><br>Function FastNoise(size%,Scale#,Multiplier#,wrap%=False)<br>	<br>	Local Max_Height#,NoiseMapSize%,ScaleDifference#,StepSize#<br>	Local N1#,N2#,N3#,N4#,HX#,HY#,IX#,IY#,ICX#,ICY#,NA#,NB#,NC#,ND#<br>	Local i%,x%,y%,xx%,yy%<br>	Local v#<br>	<br>	Max_Height=Scale<br>	<br>	For y=0 To size Step 1<br>		<br>		For x=0 To size Step 1<br>			<br>			HeightMap(x,y)=Rnd(0,1)<br>			<br>		Next<br>		<br>	Next<br>	<br>	NoiseMapSize=size/2<br>	Max_Height=Max_Height*Multiplier<br>	<br>	Repeat<br>		<br>		For y=0 To NoiseMapSize<br>			<br>			For x=0 To NoiseMapSize<br>				<br>				NoiseMap(x,y)=Rnd(0,Max_Height#)<br>				<br>			Next<br>			<br>		Next<br>		<br>		If wrap Then<br>			<br>			For i=0 To NoiseMapSize : NoiseMap(i,0)=NoiseMap(i,NoiseMapSize) : Next<br>			For i=0 To NoiseMapSize : NoiseMap(0,i)=NoiseMap(NoiseMapSize,i) : Next<br>			<br>		EndIf<br>		<br>		ScaleDifference=size*1.0/NoiseMapSize<br>		StepSize=1.0/Float(ScaleDifference)<br>		<br>		For y=0 To NoiseMapSize-1<br>			<br>			For x=0 To NoiseMapSize-1<br>				<br>				N1=NoiseMap(x,  y  )<br>				N2=NoiseMap(x+1,y  )<br>				N3=NoiseMap(x,  y+1)<br>				N4=NoiseMap(x+1,y+1)<br>				<br>				HX=x*ScaleDifference<br>				HY=y*ScaleDifference<br>				<br>				IY=0<br>				<br>				For yy=0 To ScaleDifference-1<br>					<br>					ICY=1.0-((Cos(IY*180.0)+1.0)/2.0)<br>					<br>					IX=0	<br>					<br>					For xx=0 To ScaleDifference-1<br>						<br>						ICX=1.0-((Cos(IX*180.0)+1.0)/2.0)<br>						<br>						NA=N1*(1.0-ICX)<br>						NB=N2*ICX<br>						NC=N3*(1.0-ICX)<br>						ND=N4*ICX<br>						<br>						v=HeightMap(HX+xx,HY+yy)+(NA+NB)*(1.0-ICY)+(NC+ND)*ICY<br>						<br>						If v&gt;Maxh Then Maxh=v<br>						If v&lt;minh Then minh=v<br>						<br>						HeightMap(HX+xx,HY+yy)=v<br>						<br>						IX=IX+StepSize<br>						<br>					Next<br>					<br>					IY=IY+StepSize	<br>					<br>				Next<br>				<br>			Next<br>			<br>		Next<br>		<br>		NoiseMapSize=NoiseMapSize/2<br>		<br>		Max_Height=Max_Height*Multiplier<br>		<br>	Until NoiseMapSize&lt;=2<br>	<br>End Function<br><br><br>.permutation <br>Data 151,160,137,91,90,15<br>Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23<br>Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33<br>Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166<br>Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244<br>Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196<br>Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123<br>Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42<br>Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9<br>Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228<br>Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107<br>Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254<br>Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 <br><br></td></tr></table><br>
<a name="1096208"></a>

<a name="1096216"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, I forgot to share an update I made a few weeks ago just for fun - I added animated and moving asteroids/rings using sprites for the asteroids with three different layers for variation. Could look even better if better textures are used. But looks now more realistic now in my opinion - closer to Freelancer :-D<br><br>Here is the complete archive with all source and media ready to run: <a href="http://www.christianhart.de/bb/saturn.zip" target="_blank">saturn.zip</a><br><br>I added a Wallpaper Generator, too (I really love this Saturn) - if you want the clean scene as a Wallpaper just change the Graphics3D resolution to your Desktop size, run it and press Space. I created my <a href="/gallery/view_pic.php?id=2255&amp;gallery=&amp;page=1" target="_blank">Gallery Picture</a> with it.<br><br><img src="http://www.christianhart.de/bb/saturn3.jpg"><br><br>And here the new code (needs additional media from the zip):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Procedural Saturn 3.0"

Graphics3D 800,600,32,2

Dim P%(512),GRAYD#(512),HeightMap#(0,0),NoiseMap#(0,0),surf%(2),tex%(2)
Global minh#=2^16,Maxh#

Global density%[1024],ringcolor%[1024]

Global quadparticles%,spritetex%,spritebuf%,pixelparticles%

Type star
	
	Field col%
	Field scale#
	Field x#,y#,z#
	Field visible%
	Field u1#,u2#,v1#,v2#
	Field anim%,animsec%,animtimer%,animdir%
	Field dx#,dy#,dz#
	Field layer%
	
End Type

Const SCALEX#		= 2.00	; starfield scale X
Const SCALEY#		= 0.25	; starfield scale Y
Const SCALEZ#		= 2.00	; starfield scale Z
Const MAXSTARS%		= 50000 ; maximum asteroids
Const TurnSpeed#	= 4.00	; cam turn speed
Const RollSpeed#	= 0.50	; cam roll speed
Const CameraSpeed#	= 0.002	; cam move speed
Const SEED_PLANET1%	= 8		; seed for procedural planet texture
Const SEED_PLANET2%	= 8		; seed for procedural planet texture
Const SEED_RING1%	= 6		; seed for procedural ring texture
Const SEED_RING2%	= 6		; seed for procedural ring texture
Const SCALE#		= 100.0	; planet scale
Const SEGMENTS%		= 32	; sphere detail
Const RINGDETAIL%	= 360	; ring segments
Const GLOWSEGMENTS%	= 360	; glow segments
Const MINRINGRAD#	= 0.7	; minimum ring radius
Const MAXRINGRAD#	= 3.0	; maximum ring radius
Const PR%			= 255	; planet colors RED
Const PG%			= 192	; planet colors GREEN
Const PB%			= 128	; planet colors BLUE
Const RingSpeed#    = 0.0001; ring move speed

Global WIDTH%=GraphicsWidth()
Global HEIGHT%=GraphicsHeight()
Global TIMER%=CreateTimer(60)

Global CAM%,PLANET%,PLANETTEX%,RING%,LIGHT,GLOW%,SHADER%
Global RINGTEX%,ICETEX1%,ICETEX2%,ICETEX3%,SHADOWTEX%

InitNoise(1.0)

; Planet
PLANET=CreateSphere(SEGMENTS)
ScaleEntity PLANET,SCALE,SCALE,SCALE
EntityShininess PLANET,0.1
EntityFX PLANET,2
UpdateVertexColors(PLANET,PR,PG,PB,1)
PLANETTEX=CreateRingTexture(256,SEED_PLANET1,SEED_PLANET2,1,False,"soft",1.0,1.0)
TextureBlend PLANETTEX,2
RotateTexture PLANETTEX,90
EntityTexture PLANET,PLANETTEX

; Planet Atmosphere
GLOW=CreateGlow(0.99*SCALE,1.1*SCALE,GLOWSEGMENTS,1+2+32,3,PR,PG,PB,0.5,0,0,0,0)

; Planet Fake Shader
SHADER=CreateFakeShader(SEGMENTS,SCALE,PR,PG,PB,0.6)

; Ring System
CreateSaturnRing(512,50000,1+8,"normal","normal",0.95,0.75,"fast")

; Light source
LIGHT=CreateLight(1)
RotateEntity LIGHT,0,-90,0
AmbientLight 0,0,0

; Camera
CAM=CreateCamera()
CameraRange CAM,0.0001*SCALE,1000*SCALE
MoveEntity CAM,-1*SCALE,0,-1.8*SCALE
PointEntity CAM,PLANET

; star quad
Global star=CreateQuad()
HideEntity star

; starfield mesh
Global starfield=CreateMesh()
surf(0)=CreateSurface(starfield)
surf(1)=CreateSurface(starfield)
surf(2)=CreateSurface(starfield)
tex(0)=LoadBrush("asteroid1.png",2)
tex(1)=LoadBrush("asteroid2.png",2)
tex(2)=LoadBrush("asteroid3.png",2)
PaintSurface(surf(0),tex(0))
PaintSurface(surf(1),tex(1))
PaintSurface(surf(2),tex(2))
EntityFX starfield,1+2+32
EntityBlend starfield,1
EntityOrder starfield,-2

; fill star field
AddStars(MAXSTARS,0.002,0.005)

; static camera sprite (far away particles)
Global sprite=CreateSprite(CAM)
ScaleSprite sprite,WIDTH,HEIGHT
PositionEntity sprite,0,0,WIDTH
EntityColor sprite,255,255,255
EntityBlend sprite,3
EntityOrder sprite,-1

; Milkyway background
Include "milkyway.bb" : Global MILKYWAY%=InitMilkyway(5000,0.5,5,90,1,0,0,0,1,255,192,255,1,0,0,0,1)

MoveMouse WIDTH/2,HEIGHT/2

;===========================================================================
; main loop
;===========================================================================
While Not KeyHit(1)
	
	Local multi%=1,l#=5.0,wf%,sl1%,sl2%,sl3%,sl4%,zoom#=1.0,d#,tmp%,ds%,dc%,rs#
	
	; SHIFT or RMB = 50x faster cam flight
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=50
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; KEYS 1-4 = show/hide special planet FX
	If KeyHit(2) Then sl1=1-sl1 : If sl1=1 Then HideEntity RING Else ShowEntity RING
	If KeyHit(3) Then sl2=1-sl2 : If sl2=1 Then HideEntity GLOW Else ShowEntity GLOW
	If KeyHit(4) Then sl3=1-sl3 : If sl3=1 Then HideEntity SHADER Else ShowEntity SHADER
	If KeyHit(5) Then sl4=1-sl4 : If sl4=1 Then HideEntity sprite Else ShowEntity sprite
	
	; LMB = Ultra Zoom 100x
	If MouseDown(1) Then zoom=100.0 : l=500.0
	
	; camera movement
	Movement(CAM)
	CameraZoom CAM,zoom
	
	If MILKYWAY Then PositionEntity MILKYWAY,EntityX(CAM),EntityY(CAM),EntityZ(CAM)
	
	; update atmosphere glow according to camera
	UpdateGlow(GLOW,CAM)
	
	; calc ring density
	d#=EntityDistance(CAM,PLANET)
	If d&gt;SCALE*MINRINGRAD And d&lt;SCALE*MAXRINGRAD Then
		tmp=Normalize(d,SCALE*MINRINGRAD,SCALE*MAXRINGRAD,0,512)
		ds=Int(density[tmp])
		dc=Int(ringcolor[tmp])
	EndIf
	
	; update asteroids
	UpdateStarfield(CAM,2,1,ds,dc)
	
	; Update Saturn Ring Alpha
	UpdateVertexColors(RING,255,192,128,1.0-(1.0/Exp(Abs(EntityY(CAM)*0.5))))
	
	rs=rs+RingSpeed
	PositionTexture ICETEX1,0,rs
	PositionTexture ICETEX2,0,rs
	PositionTexture ICETEX3,0,rs
	
	RenderWorld
	
	WaitTimer TIMER
	
	; show some stats in the app title
	AppTitle quadparticles+" Quads [and "+pixelparticles+" Pixel Particles] | "+(ds/2.55)+"% RING density | "+TrisRendered()+" Tris"
	
	Flip 0
	
Wend

End


; -----------------------------------------------------------------------------
; simple spaceship freeflight
; -----------------------------------------------------------------------------
Function Movement(cam%,sensitivity#=1.0)
	
	Local roll#,cz#,tx#,ty#,multi%=1
	
	cz=(KeyDown(200)-KeyDown(208))*CameraSpeed
	roll=(KeyDown(203)-KeyDown(205))*RollSpeed
	If KeyDown(42) Or KeyDown(54) Or MouseDown(2) Then multi=5
	
	tx=Normalize(MouseX(),0,WIDTH , 1,-1)
	ty=Normalize(MouseY(),0,HEIGHT,-1, 1)
	
	If ty&lt;0 Then ty=(Abs(ty)^sensitivity)*-1 Else ty=ty^sensitivity
	If tx&lt;0 Then tx=(Abs(tx)^sensitivity)*-1 Else tx=tx^sensitivity
	
	TurnEntity cam,ty*TurnSpeed,tx*TurnSpeed,roll*TurnSpeed
	MoveEntity cam,0,0,cz*multi
	
End Function


; -----------------------------------------------------------------------------
; create a quad
; -----------------------------------------------------------------------------
Function CreateQuad(r%=255,g%=255,b%=255,a#=1.0)
	
	Local mesh%,surf%,v1%,v2%,v3%,v4%
	
	mesh=CreateMesh()
	surf=CreateSurface(mesh)
	
	v1=AddVertex(surf,-1,1,0,1,0)
	v2=AddVertex(surf,1,1,0,0,0)
	v3=AddVertex(surf,-1,-1,0,1,1)
	v4=AddVertex(surf,1,-1,0,0,1)
	
	VertexColor surf,v1,r,g,b,a
	VertexColor surf,v3,r,g,b,a
	VertexColor surf,v2,r,g,b,a
	VertexColor surf,v4,r,g,b,a
	
	AddTriangle(surf,0,1,2)
	AddTriangle(surf,3,2,1)
	
	FlipMesh mesh
	
	Return mesh
	
End Function


; -----------------------------------------------------------------------------
; rebuild starfield mesh
; -----------------------------------------------------------------------------
Function UpdateStarfield(parent%,maxdist#=2.0,fader%=False,ds%,dc%)
	
	Local s.star,px#,py#,pz#,d#,a#,rgb%,col%,x%,y%,movecheck%
	
	Local cx#=EntityX(parent)
	Local cy#=EntityY(parent)
	Local cz#=EntityZ(parent)
	
	Local density%=Int(ds/2.55)
	
	ClearSurface(surf(0))
	ClearSurface(surf(1))
	ClearSurface(surf(2))
	
	quadparticles=0
	pixelparticles=0
	
	; delete and create a new texture, acutally faster than clearing it
	If spritetex Then FreeTexture spritetex
	spritetex=CreateTexture(512,512,1)
	spritebuf=TextureBuffer(spritetex)
	EntityTexture sprite,spritetex
	
	LockBuffer spritebuf
	
	For s.star = Each star
		
		movecheck=False
		
		; calc star position
		px=cx-s\x
		py=cy-s\y
		pz=cz-s\z
		
		; check if star must be moved
		If px&lt;-SCALEX Then s\x=s\x-(SCALEX Shl 1) : movecheck=True
		If px&gt;+SCALEX Then s\x=s\x+(SCALEX Shl 1) : movecheck=True
		If pz&lt;-SCALEZ Then s\z=s\z-(SCALEZ Shl 1) : movecheck=True
		If pz&gt;+SCALEZ Then s\z=s\z+(SCALEZ Shl 1) : movecheck=True
		
		If movecheck Then s\visible=(Rand(100)&lt;density)
		
		If s\visible Then
			
			s\x=s\x+s\dx
			s\y=s\y+s\dy
			s\z=s\z+s\dz
			
			; reposition star
			PositionEntity star,s\x,s\y,s\z
			
			; get distance
			d=Distance3D(cx,cy,cz,s\x,s\y,s\z)
			
			; check if not to far away
			If d&lt;maxdist
				
				TFormPoint s\x,s\y,s\z,0,CAM
				
				; star is visible (in front of cam)?
				If TFormedZ()&gt;0 Then
					
					; fade pixel particles
					col=255
					If fader Then
						col=Int(Normalize(d,0,maxdist,dc,0))
						If col&lt;0 Then col=0 Else If col&gt;32 Then col=32
					EndIf
					
					rgb=col*$10000+col*$100+col
					
					; calculate pixel particle 2D position
					CameraProject CAM,s\x,s\y,s\z
					x=Normalize(ProjectedX(),0,WIDTH-1,0,511)
					y=Normalize(ProjectedY(),0,HEIGHT-1,0,511)
					
					; pixel inside texture range? draw to texture!
					If x&gt;0 And x&lt;511 And y&gt;0 And y&lt;511 Then
						WritePixelFast x,y,rgb,spritebuf
						pixelparticles=pixelparticles+1
					EndIf
					
					; distance close enough to cam? spawn quad particle and add it to mesh
					If d&lt;maxdist*0.25 Then
						
						; align star to cam
						PointEntity star,CAM
						
						;RotateMesh star,0,0,s\r
						;s\r=s\r+0.01 Mod 360
						
						ScaleEntity star,s\scale,s\scale,s\scale
						
						su=GetSurface(star,1)
						
						sy%=Int(s\anim/4)
						sx%=(s\anim)-(sy*4)
						
						s\u1=sx*0.25
						s\u2=(sx+1)*0.25
						s\v1=sy*0.25
						s\v2=(sy+1)*0.25
						
						If MilliSecs()&gt;s\animsec+s\animtimer Then
							s\anim=s\anim+s\animdir
							If s\anim&gt;15 Then s\anim=0
							If s\anim&lt;0 Then s\anim=15
							s\animsec=MilliSecs()
						EndIf
						
						VertexTexCoords(su,0,s\u2,s\v1)
						VertexTexCoords(su,1,s\u1,s\v1)
						VertexTexCoords(su,2,s\u2,s\v2)
						VertexTexCoords(su,3,s\u1,s\v2)
						
						; add alpha
						a=1.0 : If fader Then a=Normalize(d,0,maxdist*0.25,1.5,0)
						
						; add star To starfield again
						AddMeshToSurface(star,surf(s\layer),starfield,s\col,s\col,s\col,a)
						
						quadparticles=quadparticles+1
						
					EndIf
					
				EndIf
				
			EndIf
			
		EndIf
		
	Next
	
	UnlockBuffer spritebuf
	
	Return density
	
End Function


; -----------------------------------------------------------------------------
; add a mesh to another mesh
; -----------------------------------------------------------------------------
Function AddMeshToSurface(mesh,surf,singlesurfaceentity,r%,g%,b%,a#)
	
	Local vert%[2],vr%[2],vg%[2],vb%[2],va#[2],nx#[2],ny#[2],nz#[2]
	Local surface%,oldvert%,i%,i2%
	
	surface = GetSurface(mesh,1) 
	
	For i = 0 To CountTriangles(surface)-1
		
		For i2 = 0 To 2 
			
			oldvert = TriangleVertex(surface,i,i2)
			
			vr[i2]=r
			vg[i2]=g
			vb[i2]=b
			va[i2]=a
			nx[i2]=VertexNX(surface,oldvert)
			ny[i2]=VertexNY(surface,oldvert)
			nz[i2]=VertexNZ(surface,oldvert)
			
			TFormPoint VertexX(surface,oldvert),VertexY(surface,oldvert),VertexZ(surface,oldvert), mesh,singlesurfaceentity 
			vert[i2] = AddVertex(surf,TFormedX(),TFormedY(),TFormedZ(),VertexU(surface,oldvert),VertexV(surface,oldvert)) 
			VertexNormal surf,vert[i2],nx[i2],ny[i2],nz[i2]
			VertexColor surf,vert[i2],r,g,b,a
			
		Next 
		
		AddTriangle(surf,vert[0],vert[1],vert[2])
		
	Next 
	
End Function


; -----------------------------------------------------------------------------
; add stars to starfield mesh
; -----------------------------------------------------------------------------
Function AddStars(amount%=1,min#=0.01,max#=0.02,addx#=0.0,addy#=0.0,addz#=0.0)
	
	Local i%,s.star
	Local density%=Normalize(Perlin3D(0,0,0,16,1,0,3),-1,1,0,100)
	If density&lt;0 Then density=0 Else If density&gt;100 Then density=100
	
	For i=1 To amount
		
		s.star = New star
		
		s\col=Rand(64,255)
		s\x=addx+Rnd(-SCALEX,SCALEX)
		s\y=addy+Rnd(Rnd(Rnd(Rnd(-SCALEY))),Rnd(Rnd(Rnd(SCALEY))))
		s\z=addz+Rnd(-SCALEZ,SCALEZ)
		s\scale=Rnd(min,max)
		
		s\dx=Rnd(0,RingSpeed*5)
		s\dy=Rnd(-RingSpeed,RingSpeed)
		s\dz=Rnd(-RingSpeed,RingSpeed)
		s\layer=Rand(0,2)
		
		s\anim=Rand(0,15)
		s\animtimer=Rand(30,60)
		s\animsec=MilliSecs()+Rand(s\animtimer)
		
		While s\animdir=0
			s\animdir=Rand(-1,1)
		Wend
		
		If Rand(100)&lt;density Then s\visible=True
		
	Next
	
End Function


; -----------------------------------------------------------------------------
; simple 3D distance calculation
; -----------------------------------------------------------------------------
Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Local x#=x1-x2
	Local y#=y1-y2
	Local z#=z1-z2
	
	Return Sqr((x*x)+(y*y)+(z*z))
	
End Function


;===========================================================================
; create procedural ring detail textures using perlin functions
;===========================================================================
Function CreateProceduralRingTextures(brightness1%=192,brightness2%=160,brightness3%=128,size%,detail%,flags%,noisetype$="perlin")
	
	Local buffer1%,buffer2%,buffer3%
	Local x%,y%,rgb%,rgb1%,rgb2%,col%,r%,i%
	
	If noisetype="fast" Then
		Dim HeightMap(size,size)
		Dim NoiseMap(size+1,size+1)
		FastNoise(size,8,1.2,1)
	EndIf
	
	ICETEX1=CreateTexture(size,size,flags)
	ICETEX2=CreateTexture(size,size,flags)
	ICETEX3=CreateTexture(size,size,flags)
	
	buffer1=TextureBuffer(ICETEX1)
	buffer2=TextureBuffer(ICETEX2)
	buffer3=TextureBuffer(ICETEX3)
	
	LockBuffer buffer1
	LockBuffer buffer2
	LockBuffer buffer3
	
	For x=0 To size-1
		For y=0 To size-1
			rgb1=brightness1*$10000+brightness1*$100+brightness1
			rgb2=brightness2*$10000+brightness2*$100+brightness2
			WritePixelFast x,y,rgb1,buffer1
			WritePixelFast x,y,rgb2,buffer2
		Next
	Next
	
	For i=1 To detail
		
		; random position
		x=Rand(0,size-1)
		y=Rand(0,size-1)
		
		; random randomized randomizer
		r=Rand(0,Rand(0,Rand(0,255)))
		
		; perlin or fast noise
		If noisetype="fast" Then
			col=Normalize(HeightMap(x,0),minh,Maxh,brightness1,255)
		Else
			col=Normalize(Perlin3D(x,0,y,4,1,0,15),-1,1,brightness1,255)
		EndIf
		col=Normalize(col+r,brightness1,511,brightness2,255)
		
		; layer 1+2: identical perlin noise mixed with random
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer1
		WritePixelFast x,y,rgb,buffer2
		
		; layer 3: starfield like
		If noisetype="fast" Then
			col=Normalize(HeightMap(y,x),minh,Maxh,0,128)
		Else
			col=Normalize(Perlin3D(x,y,0,16,1,0,7),-1,1,0,128)
		EndIf
		col=Normalize(col+r,0,511,brightness3,255)
		If col&lt;brightness3 Then col=brightness3
		
		rgb=col*$10000+col*$100+col
		WritePixelFast x,y,rgb,buffer3
		
	Next
	
	UnlockBuffer buffer3
	UnlockBuffer buffer2
	UnlockBuffer buffer1
	
End Function


;===========================================================================
; main call to create the saturn ring system
;===========================================================================
Function CreateSaturnRing(size%=512,detail%=50000,flags%=1+8,mode$="normal",style$="cassini",fading#=0.85,range#=0.7,noisetype$="perlin")
	
	Local v%,surf%
	
	; create procedural ring textures (ICETEX1-3)
	CreateProceduralRingTextures(160,192,0,size,detail,flags,noisetype)
	
	; create shadow texture
	If style="cassini" Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,8)
	Else If style="linear" Then
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,0,100)
	Else
		SHADOWTEX=CreateSaturnShadow(size,3.3,180,2,64,24,16)
	EndIf
	
	; create main ring texture
	RINGTEX=CreateRingTexture(size,SEED_RING1,SEED_RING2,3,True,mode,fading,range)
	
	; create planetary ring
	RING=CreateMesh(PLANET)
	EntityFX RING,1+2+16+32
	;EntityBlend RING,3
	surf=CreateSurface(RING)
	UpdateSaturnRing(RING,surf,MINRINGRAD,MAXRINGRAD,RINGDETAIL,255,255,255,255,255,255,1.0,1.0)
	
	; init second UV set
	For v=0 To CountVertices(surf)-1
		VertexTexCoords surf,v,VertexX(surf,v),VertexY(surf,v),0,1
	Next
	
	; reposition shadow texture
	PositionTexture SHADOWTEX,0.5,0.5
	
	; user second UV set
	TextureCoords ICETEX1,1
	TextureCoords ICETEX2,1
	TextureCoords ICETEX3,1
	TextureCoords SHADOWTEX,1
	
	; scale textures
	ScaleTexture ICETEX1,1.0/128,1.0/128
	ScaleTexture ICETEX2,1.0/64,1.0/64
	ScaleTexture ICETEX3,1.0/32,1.0/32
	ScaleTexture SHADOWTEX,6,6
	
	; apply to mesh
	EntityTexture RING,RINGTEX,0,1
	EntityTexture RING,ICETEX1,0,2
	EntityTexture RING,ICETEX2,0,3
	EntityTexture RING,ICETEX3,0,4
	EntityTexture RING,SHADOWTEX,0,5
	
	; blend details
	TextureBlend ICETEX1,3
	TextureBlend ICETEX3,3
	
	; rotate ring
	RotateMesh RING,-90,90,0
	
End Function


;===========================================================================
; create planetary ring mesh
;===========================================================================
Function UpdateSaturnRing(FMesh%,FFace%=1,FRadius1#=1.0,FRadius2#=3.0,FSegments%=120,FR1%=255,FG1%=255,FB1%=255,FR2%=255,FG2%=255,FB2%=255,FAlpha1#=1.0,FAlpha2#=1.0)
	
	If FSegments&gt;360 Then FSegments=360
	
	Local Angle%
	Local RV0%,RV1%,RV2%,RV3%
	Local RX0#,RX1#,RX2#,RX3#
	Local RY0#,RY1#,RY2#,RY3#
	Local SX0#,SX1#,SX2#,SX3#
	Local SY0#,SY1#,SY2#,SY3#
	Local U01#,U23#
	
	For Angle=1 To FSegments Step 1
		
		RX0=Sin(Angle*360.0/FSegments)*FRadius1
		RY0=Cos(Angle*360.0/FSegments)*FRadius1
		RX1=Sin(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RY1=Cos(Angle*360.0/FSegments -180.0/FSegments)*FRadius2
		RX2=Sin(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RY2=Cos(Angle*360.0/FSegments +180.0/FSegments)*FRadius2
		RX3=Sin(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		RY3=Cos(Angle*360.0/FSegments +360.0/FSegments)*FRadius1
		SX0=RX0: SY0=RY0
		SX1=RX0: SY1=RY0
		SX2=RX3: SY2=RY3
		SX3=RX3: SY3=RY3
		U01=0
		U23=0
		
		RV0=AddVertex(FFace,RX0,RY0,0, U01,0)
		RV1=AddVertex(FFace,RX1,RY1,0, 1,0)
		RV2=AddVertex(FFace,RX2,RY2,0, 1,0)
		RV3=AddVertex(FFace,RX3,RY3,0, U23,0)
		
		VertexColor FFace,RV0,FR1,FG1,FB1,FAlpha1
		VertexColor FFace,RV1,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV2,FR2,FG2,FB2,FAlpha2
		VertexColor FFace,RV3,FR1,FG1,FB1,FAlpha1
		
		AddTriangle FFace,RV0,RV1,RV2
		AddTriangle FFace,RV2,RV3,RV0
		
	Next
	
	Return FMesh
	
End Function


;===========================================================================
; creates the saturn shadow texture using two spheres, simple math and a cam
;===========================================================================
Function CreateSaturnShadow(size%=512,scale#=3.5,angle#=180.0,blur%=2,col%=64,width#=20.0,length#=9.0)
	
	Local sphere1%,sphere2%,tmp%,surf1%,surf2%
	Local v%,x#,y#,z#,tex%,add#
	
	sphere1=CreateSphere(32)
	EntityFX sphere1,1+2
	
	sphere2=CreateSphere(32)
	EntityFX sphere2,1+2
	
	surf1=GetSurface(sphere1,1)
	surf2=GetSurface(sphere2,1)
	
	For v=0 To CountVertices(surf1)-1
		
		x#=VertexX(surf1,v)
		y#=VertexY(surf1,v)
		z#=VertexZ(surf1,v)
		
		If z&gt;0 Then add=Sqr(z*length) Else add=1
		
		VertexCoords surf1,v,x,y,z*Cos(width)*add
		VertexColor surf1,v,col,col,col
		VertexColor surf2,v,col,col,col
		
	Next
	
	tex=CreateTexture(size,size)
	
	tmp=CreateCamera()
	PositionEntity tmp,0,scale,0
	CameraClsColor tmp,255,255,255
	CameraViewport tmp,0,0,size,size
	PointEntity tmp,sphere1
	
	RenderWorld
	
	FreeEntity sphere1
	FreeEntity sphere2
	FreeEntity tmp
	
	CopyRect 0,0,size,size,0,0,BackBuffer(),TextureBuffer(tex)
	
	If blur Then BlurTexture(tex,blur,blur)
	
	RotateTexture tex,angle
	
	Return tex
	
End Function


;===========================================================================
; blurs the saturn shadow texture for soft transitions
;===========================================================================
Function BlurTexture(Texture, Blur_Quality, Blur_Radius#)
	
	Local BlurMesh[16*4]
	Local Loop
	Local Blur_Cam
	Local BlurRadius#,BlurAngleStep#,BlurShade%,BlurAngle#,Xoff#,Yoff#
	
	Local BLUR_CAM_X# = 65536.0
	Local BLUR_CAM_Y# = 65536.0
	Local BLUR_CAM_Z# = 0.0
	
	If Blur_Quality &gt; 0
		
		Blur_Cam = CreateCamera()
		CameraViewport Blur_Cam, 0, 0, TextureWidth(Texture), TextureHeight(Texture)
		CameraClsColor Blur_Cam, 0, 0, 0
		CameraClsMode  Blur_Cam, True, True						
		CameraRange Blur_Cam, 0.1, 100
		CameraZoom Blur_Cam, 16.0
		RotateEntity Blur_Cam, 90, 0, 0, True
		PositionEntity Blur_Cam, BLUR_CAM_X#, BLUR_CAM_Y#, BLUR_CAM_Z#
		For Loop = 0 To (Blur_Quality*4)-1
			BlurMesh[Loop] = CreateSprite()
		Next
		TextureBlend Texture, 2
		ScaleTexture    Texture, 0.5, 0.5
		PositionTexture Texture, 0.5, 0.5
		
		BlurRadius = Blur_Radius# * (1.0 / 256.0)
		BlurAngleStep = 360.0 / Float(Blur_Quality*4)
		BlurShade = Ceil(255.0 / Float(Blur_Quality*4))
		
		For Loop = 0 To (Blur_Quality*4)-1
			
			EntityTexture BlurMesh[Loop], Texture
			EntityFX BlurMesh[Loop], 1+8
			EntityAlpha BlurMesh[Loop], 1.0 / Float(Loop+1)
			ScaleSprite BlurMesh[Loop], 2, 2
			
			BlurAngle# = BlurAngleStep# * Float(Loop) + 180.0*(Loop Mod 2)
			
			Xoff# = BlurRadius# * Cos(BlurAngle#)
			Yoff# = BlurRadius# * Sin(BlurAngle#)
			
			PositionEntity BlurMesh[Loop], BLUR_CAM_X# + Xoff#, BLUR_CAM_Y# - 16.0, BLUR_CAM_Z# + Yoff#, True
			
		Next
		
		RenderWorld
		
		CopyRect 0, 0, TextureWidth(Texture), TextureHeight(Texture), 0, 0, BackBuffer(), TextureBuffer(Texture)
		
		For Loop = 0 To (Blur_Quality*4)-1
			FreeEntity BlurMesh[Loop]
		Next
		
		FreeEntity Blur_Cam
		
	EndIf
	
	ScaleTexture Texture,1,1
	PositionTexture Texture,0,0
	
End Function


;===========================================================================
; updates the vertex colors of a mesh
;===========================================================================
Function UpdateVertexColors(mesh%,r%,g%,b%,a#)
	
	Local s%,surf%,v%
	
	For s=1 To CountSurfaces(mesh)
		
		surf=GetSurface(mesh,s)
		
		For v=0 To CountVertices(surf)-1
			
			VertexColor surf,v,r,g,b,a
			
		Next
		
	Next
	
End Function


;===========================================================================
; creates a fake shader (spherical glow effect), should match planet size
;===========================================================================
Function CreateFakeShader(segments%=64,size#=1.0,r%=255,g%=224,b%=192,a#=0.5)
	
	Local shader%=CreateSphere(segments)
	Local tex%=CreateFakeShaderTexture()
	
	ScaleEntity shader,size,size,size
	EntityBlend shader,3
	EntityFX shader,2
	EntityOrder shader,-1
	UpdateVertexColors(shader,r,g,b,a)
	
	TextureBlend tex,2
	EntityTexture shader,tex,0,1
	
	Return shader%
	
End Function


;===========================================================================
; creates fake shader texture
;===========================================================================
Function CreateFakeShaderTexture()
	
	Local tex%=CreateTexture(512,512,64)
	Local tb%=TextureBuffer(tex)
	
	Local x%,y%,i#,j%,col%,rgb%
	
	SetBuffer tb
	LockBuffer tb
	
	For x=0 To 511
		
		For y=0 To 511
			
			rgb=255*$1000000+255*$10000+255*$100+255
			WritePixelFast x,y,rgb,tb
			
		Next
		
	Next
	
	For j=0 To 255
		
		col=j*1.0/Exp((255-j)*0.02)
		
		If col&gt;255 Then col=255
		If col&lt;0 Then col=0
		
		rgb=col*$1000000+col*$10000+col*$100+col
		
		For i=0 To 360 Step 0.1
			
			WritePixelFast 256+(Sin(i)*j),256+(Cos(i)*j),rgb,tb
			
		Next
		
	Next
	
	UnlockBuffer tb
	SetBuffer BackBuffer()
	
	Return tex
	
End Function


;===========================================================================
; create planet atmosphere
;===========================================================================
Function CreateGlow(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,al1#=0.0,r2%=0,g2%=0,b2%=0,al2#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%,v0%,v1%,v2%,v3%
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	If segments&gt;360 Then segments=360
	
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		VertexColor surf,v0,r1,g1,b1,al1
		VertexColor surf,v1,r1,g1,b1,al1
		VertexColor surf,v2,r2,g2,b2,al2
		VertexColor surf,v3,r2,g2,b2,al2
		
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function


;===========================================================================
; update planet atmosphere
;===========================================================================
Function UpdateGlow(mesh%,cam%)
	
	Local radius#,distance#
	Local c1#,a1#,q1#,p1#,h1#,alpha1#,beta1#,gamma1#,alpha2#,b2#,c2#
	
	PointEntity mesh,cam
	
	radius=SCALE
	distance=EntityDistance(cam,PLANET)
	
	; First triangle
	c1=distance
	a1=radius
	q1=a1^2/c1
	p1=c1-q1
	h1=Sqr(p1*q1)
	gamma1=90
	alpha1=ATan(h1/p1)
	beta1=gamma1-alpha1
	
	; Second Triangle
	alpha2=90-(90-beta1)
	b2=a1/Tan(alpha2)
	c2=(Sqr(a1^2+b2^2))/radius
	
	ScaleEntity mesh,c2,c2,c2
	
End Function


;===========================================================================
; create planetary ring texture
;===========================================================================
Function CreateRingTexture(size%=1024,seed1%=1,seed2%=2,flags%=0,usealpha%=False,method$="normal",fading#=1.0,range#=0.7)
	
	Local tex%=CreateTexture(size,1,flags)
	Local buffer%=TextureBuffer(tex)
	
	Local x%,h1#,h2#,h3#,col%,alpha%,rgb%,value#
	
	LockBuffer buffer
	
	For x=0 To size-1
		
		h1=Perlin3D(x*(2048/size),0,0,1024,seed1,0,15)
		h2=Perlin3D(0,x*(2048/size),0,512,seed2,0,7)
		
		col=Int(Normalize(h1,-range,range,0,255)) : If col&lt;0 Then col=0 Else If col&gt;255 Then col=255
		
		If usealpha Then
			
			If method="soft" Then
				
				; soft rings
				alpha=(Int(Normalize(h2,-range,range,0,1.5)*col)+Int(Normalize(h3,-1,1,0,1.5)*col))/2.0
				
			Else If method="sharp" Then
				
				; sharp rings
				alpha=Int(Normalize(h1,-range,range,0,1.0)*col)*Rnd(0.98,1.02)
				
			Else
				; normal rings
				alpha=Int(Normalize(h2,-range,range,0,1.0)*col)
			EndIf
			
			If alpha&lt;0 Then alpha=0 Else If alpha&gt;255 Then alpha=255
			
		Else
			
			alpha=255
			
		EndIf
		
		; soft fading to the outer rings
		If x&gt;(size*fading) Then
			
			value=Normalize(x,size*fading,size,1,0)
			
			alpha=alpha*value
			col=col*value
			
		EndIf
		
		density[x]=alpha;(col+alpha)/2
		ringcolor[x]=col
		
		rgb=alpha*$1000000+col*$10000+col*$100+col
		
		WritePixelFast x,0,rgb,buffer
		
	Next
	
	UnlockBuffer buffer
	
	Return tex
	
End Function


;===========================================================================
; normalize value
;===========================================================================
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value#-value_min#)/(value_max#-value_min#))*(norm_max#-norm_min#)+norm_min#
	
End Function


;===========================================================================
; fast perlin noise functions
;===========================================================================
Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

Function FastNoise(size%,Scale#,Multiplier#,wrap%=False)
	
	Local Max_Height#,NoiseMapSize%,ScaleDifference#,StepSize#
	Local N1#,N2#,N3#,N4#,HX#,HY#,IX#,IY#,ICX#,ICY#,NA#,NB#,NC#,ND#
	Local i%,x%,y%,xx%,yy%
	Local v#
	
	Max_Height=Scale
	
	For y=0 To size Step 1
		
		For x=0 To size Step 1
			
			HeightMap(x,y)=Rnd(0,1)
			
		Next
		
	Next
	
	NoiseMapSize=size/2
	Max_Height=Max_Height*Multiplier
	
	Repeat
		
		For y=0 To NoiseMapSize
			
			For x=0 To NoiseMapSize
				
				NoiseMap(x,y)=Rnd(0,Max_Height#)
				
			Next
			
		Next
		
		If wrap Then
			
			For i=0 To NoiseMapSize : NoiseMap(i,0)=NoiseMap(i,NoiseMapSize) : Next
			For i=0 To NoiseMapSize : NoiseMap(0,i)=NoiseMap(NoiseMapSize,i) : Next
			
		EndIf
		
		ScaleDifference=size*1.0/NoiseMapSize
		StepSize=1.0/Float(ScaleDifference)
		
		For y=0 To NoiseMapSize-1
			
			For x=0 To NoiseMapSize-1
				
				N1=NoiseMap(x,  y  )
				N2=NoiseMap(x+1,y  )
				N3=NoiseMap(x,  y+1)
				N4=NoiseMap(x+1,y+1)
				
				HX=x*ScaleDifference
				HY=y*ScaleDifference
				
				IY=0
				
				For yy=0 To ScaleDifference-1
					
					ICY=1.0-((Cos(IY*180.0)+1.0)/2.0)
					
					IX=0	
					
					For xx=0 To ScaleDifference-1
						
						ICX=1.0-((Cos(IX*180.0)+1.0)/2.0)
						
						NA=N1*(1.0-ICX)
						NB=N2*ICX
						NC=N3*(1.0-ICX)
						ND=N4*ICX
						
						v=HeightMap(HX+xx,HY+yy)+(NA+NB)*(1.0-ICY)+(NC+ND)*ICY
						
						If v&gt;Maxh Then Maxh=v
						If v&lt;minh Then minh=v
						
						HeightMap(HX+xx,HY+yy)=v
						
						IX=IX+StepSize
						
					Next
					
					IY=IY+StepSize	
					
				Next
				
			Next
			
		Next
		
		NoiseMapSize=NoiseMapSize/2
		
		Max_Height=Max_Height*Multiplier
		
	Until NoiseMapSize&lt;=2
	
End Function


.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1097787"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Graythe</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Absolutely stunning... and stupendously fast! Even on a 2ghz PC relic. <br><br></td></tr></table><br>
<a name="1196279"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Imperium</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good code and optimized graphics can achieve a lot. Amazing work and thank you for sharing! <br><br></td></tr></table><br>
<a name="1205914"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> The feeling of seeing the creations of this man makes me feel and realize that I have much to believe that I am programmer ... : S (Frustrated) <br><br></td></tr></table><br>
<a name="1206090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Yue: <br><br>Same here. :-)<br><br>Was re-checking BlitzTiles 1.02 just now cos I missed that version when he released it.<br><br>Unfortunately I found adding FastExtension(for shadows and more realistic water) gives a MAV in FastExt.bb on:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function ClsColor% (red%, green%, blue%, alpha%=$FF, zValue#=1.0)
	Return ClsColor_ (red, green, blue, alpha, zValue)
End Function
</textarea><br><br>Which is a pitty cos otherwise it might be really cool to use BlitzTiles and FastExt together. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
