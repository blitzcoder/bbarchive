<!DOCTYPE html><html lang="en" ><head ><title >Just showing off something.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Just showing off something.</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Just showing off something.</a><br><br>
<a name="1035884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> oops(object oriented programing syntax) to c++<br><br>it's coming along, not very fast though.  Lots of bugs I'm guessing but haven't really checked.  I haven't done any testing with nested for/next loops , while/wend loops, or if statements so I cannot say they will work.  I haven't even started on how to keep lists of class instances yet,  I have to figure out and test other things first.<br><br>useful? Yes, no, I don't know but it's fun to try and make coding c++ something easier.   Maybe if it gets done correctly I'll make a quick dll creator using oops.<br><br>it will convert:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Comment test for cpp
#include &lt;iostream&gt; 		;Must use this include for using print and other commands
#include &lt;string&gt;			;Must be used to do strings
using namespace std

Class foo 					;Test Comment on Class
	field a% 				;Test Comment on Field
	field b$
	Method addhundo() 	;Test Comment on Method
		a += 100			;Test Comment on Method code
	end method				;Test Comment on Method Exit
	Method addsome(amount%)
		for i = 1 to amount
			a += i
		next
	end method
End Class 					;Test Comment on Class exit

Function Main() 			;Test Comment on function
	foo f					;This creates a new class foo where f is the handle trying to make f.foo = new foo mean the same thing.
	print f.a
	f.addhundo()
	print f.a
	f.b = "Hello World!"
	print f.b
	f.addsome(100)
	print f.a
	Waitkey
end function				;Test Comment on function exit

</textarea><br><br>to:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
// Comment test for cpp
#include &lt;iostream&gt; 		  // Must use this include for using print and other commands
#include &lt;string&gt;			  // Must be used to do strings
using namespace std;

class foo { //Test Comment on Class
public:
	int a;	//Test Comment on Field
	string b;	
	foo ();
	void addhundo ();
	void addsome (int amount);
};//Test Comment on Class exit
foo::foo() { 
	a = 0;
	b = "";
} 
void foo::addhundo() { //Test Comment on Method
	a += 100;//Test Comment on Method code
} //Test Comment on Method Exit
void foo::addsome(int amount) { //addsome(amount%)
	for ( int i = 1 ; i &lt;= amount ; i++ ){
		a += i;
	}
} 
int main(){//Test Comment on function
	foo f					;//This creates a new class foo where f is the handle trying to make f.foo = new foo mean the same thing.
	cout &lt;&lt; f.a &lt;&lt; endl;
	f.addhundo();
	cout &lt;&lt; f.a &lt;&lt; endl;
	f.b = "Hello World!";
	cout &lt;&lt; f.b &lt;&lt; endl;
	f.addsome(100);
	cout &lt;&lt; f.a &lt;&lt; endl;
	system("PAUSE");
}//Test Comment on function exit

</textarea><br><br>Source so far:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
FileName$ = "Test2"
Global file = ReadFile(filename+".OB")
Global file2= WriteFile(filename+".cpp")
Global LineIn$,InClass,InMethod,LineCount
Global ObservedKeySymbol$,ObservedKeyWord$,ObservedNumber$

Convert_OOPS_cpp()
Write_cpp_Code()

CloseFile(file2)	;close the output file so that it can be debuged through blitz
CloseFile(file)		;close the Objective Blitz3D file

End

Type Class
	Field Name$
	Field Name_Lower$
	Field ClassTabs
	Field TypesPointer$
	Field LastPointer$
	Field ParentClass.Class
	Field ContainMethods
	Field Private
	Field Comment$
	Field ExitClassComment$
End Type

Type Fields
	Field Name$
	Field Name_Lower$
	Field VariableType
	Field Tabs
	Field ParentClass.Class
	Field ParentClassName$
	Field Private
	Field Comment$
End Type

Type Method
	Field parentPTR.Class
	Field Name$
	Field Name_Lower$
	Field MethodReturnType%
	Field MethodParameters$
	Field MethodTab
	Field Private
	Field Comment$
	Field ExitMethodComment$
	Field Constructor
End Type
Type MethodCode
	Field Parent.Method
	Field Code$
	Field CodeTabs
	Field CodeComment$
	Field Term
End Type
Type MethodVariable
	Field Name$
	Field VariableType
	Field Parent.Method
	Field Declared
	Field ClassName
End Type

Type Functions
	Field Name$
	Field Name_Lower$
	Field FunctionReturnType%
	Field FunctionParameters$
	Field Comment$
	Field ExitFunctionComment$
End Type
Type FunctionCode
	Field Parent.Functions
	Field Code$
	Field CodeTabs
	Field CodeComment$
End Type
Type FunctionVariable
	Field Name$
	Field VariableType
	Field Parent.Functions
	Field Declared
End Type


Function Convert_OOPS_cpp()
	
Local LineCount,TabCount,T.Class,Name$,OldBS,M.Method,LineRead,C.Class,ParentName$,MC.MethodCode
Local InFunctionFlag,F.Functions

	While Not Eof(file)
		
		LineRead = False
		LineIn$ = ReadLine(file):LineCount = LineCount + 1
		TabCount = RemoveTabs()
		ti = 0 : si = 0

		If Lower(Left$(LineIn$,5)) = "class" Then
			T.Class = ProcessClass.Class(LineIn$,TabCount)
			cf = 0:cm = 0
			M.method = New Method
			M\Name = T\Name
			M\Constructor = True
			M\parentPTR = T
			M\MethodTab = T\ClassTabs + 1
			LineRead = True:InClass = True
		EndIf
		If Lower(Left$(LineIn$,9)) = "end class" Then
			LineRead = True:InClass = False
			For i = 9 To Len(LineIn)
				If Mid$(LineIn,i,1) = ";" Then T\ExitClassComment = "//"+Right$(LineIn,Len(LineIn)-i)
			Next
		EndIf
		
		If Lower(Left$(LineIn$,5)) = "field" Then
			ProcessField(LineIn$, T , TabCount)
			LineRead = True
		EndIf
		If Lower(Left$(LineIn$,8)) = "private:" Then T\Private = True;:LineRead = True
		If Lower(Left$(LineIn$,7)) = "public:" Then T\Private = False;:LineRead = True
	
		If Lower(Left$(LineIn$,10)) = "end method" Then 
			MethodFlag = False:LineRead = True:InMethod = False
			ProcessMethodVariables(M)
			For i = 10 To Len(LineIn)
				If Mid$(LineIn,i,1) = ";" Then M\ExitMethodComment = "//"+Right$(LineIn,Len(LineIn)-i)
			Next
		EndIf
		
		If MethodFlag Then
			LineIn = RemoveRightSideTabs_Spaces$(LineIn)
			If Lower(LineIn) = "return" Then M\MethodReturnType = 0
			MC.MethodCode = New MethodCode
			MC\Parent = M
			MC\CodeTabs = TabCount
			For i = 1 To Len(LineIn)
				If Mid$(LineIn,i,1) =";" Then MC\CodeComment = "//"+Right$(LineIn,Len(LineIn)-i):ti =i
			Next
			If ti &lt;&gt; 0 Then 
				MC\Code = Left$(LineIn,ti-1)
			Else
				MC\Code = LineIn
			EndIf
			LineRead = True
		EndIf

		If Lower(Left$(LineIn$,6)) = "method" Then
			T\ContainMethods = True
			M.Method = New Method
			tm$ =  Right$(LineIn$,Len(LineIn$)-7)
			startx = 0: endx = 0:TypeHandle = 0:Coms = 0
			For j = 1 To Len( tm )
				If Mid$(tm,j,1) = "." Then TypeHandle = j
				If Mid$(tm,j,1) = "(" Then StartX = j
				If Mid$(tm,j,1) = ")" Then EndX = j
				If Mid$(tm,j,1) = ";" Then ComS = j
			Next
			Select True
				Case Mid$(tm,startx-1,1) = "%"
					M\MethodReturnType = 1
				Case Mid$(tm,startx-1,1) = "#"
					M\MethodReturnType = 2
				Case Mid$(tm,startx-1,1) = "$"
					M\MethodReturnType = 3
				Case TypeHandle &lt;&gt; 0 And typehandle &lt; startx
					M\MethodReturnType = 4
			End Select
			M\Comment = "//"+Right$(tm,Len(tm)-coms)
			If M\MethodReturnType&lt;&gt;0 Then 
				M\Name$ = Left$(tm,startx-2)
			Else
				M\Name$ = Left$(tm,startx-1)
			EndIf
			M\Name_Lower = Lower(M\Name)
			If endx - startx &gt; 1 Then M\MethodParameters$ = Mid$(tm,startx+1,(endx-2)-startx+1)
			M\MethodParameters = ProcessMethodParameters$(M)
			M\MethodTab = TabCount
			M\parentPTR = T
			If T\Private = True Then M\Private = True
			MethodFlag = True
			LineRead = True:InMethod = True
		EndIf
		
		If Lower(Left$(LineIn$,12)) = "end function" Then 
			InFunctionFlag = False:LineRead = True
			For i = 10 To Len(LineIn)
				If Mid$(LineIn,i,1) = ";" Then F\ExitFunctionComment = "//"+Right$(LineIn,Len(LineIn)-i)
			Next
		EndIf
		If InFunctionFlag Then
			LineIn = RemoveRightSideTabs_Spaces$(LineIn)
			If Lower(LineIn) = "return" Then F\FunctionReturnType = 0
			If Lower(LineIn) = "waitkey" Then LineIn = "system("+Chr(34)+"PAUSE"+Chr(34)+")"
			FC.FunctionCode = New FunctionCode
			fC\Parent = F
			fC\CodeTabs = TabCount
			For i = 1 To Len(LineIn)
				If Mid$(LineIn,i,1) =";" Then fC\CodeComment = "//"+Right$(LineIn,Len(LineIn)-i):ti =i
			Next
			If ti &lt;&gt; 0 Then 
				fC\Code = Left$(LineIn,ti-1)
			Else
				fC\Code = LineIn
			EndIf
			LineRead = True
		EndIf
		If Lower(Left$(LineIn,9)) = "function " Then
			F.Functions = New Functions
			tm$ = Right$(LineIn,Len(LineIn)-9)
			startx = 0: endx = 0:TypeHandle = 0:Coms = 0
			For j = 1 To Len( tm )
				If Mid$(tm,j,1) = "." Then TypeHandle = j
				If Mid$(tm,j,1) = "(" Then StartX = j
				If Mid$(tm,j,1) = ")" Then EndX = j
				If Mid$(tm,j,1) = ";" Then ComS = j
			Next
			Select True
				Case Mid$(tm,startx-1,1) = "%"
					F\functionReturnType = 1
				Case Mid$(tm,startx-1,1) = "#"
					F\functionReturnType = 2
				Case Mid$(tm,startx-1,1) = "$"
					F\functionReturnType = 3
			End Select
			F\Comment = "//"+Right$(tm,Len(tm)-coms)
			If F\FunctionReturnType&lt;&gt; 0 Then 
				F\Name = Left$(tm,startx-2)
			Else
				F\Name = Left$(tm,startx-1)
			EndIf
			F\Name_Lower = Lower(F\Name)
			If Lower(F\Name) = "main" Then F\Name = F\Name_Lower:F\FunctionReturnType = 1
			If endx - startx &gt; 1 Then F\FunctionParameters = Mid$(tm,startx+1,(endx-2)-startx+1)
			InFunctionFlag = True:LineRead = True
		EndIf
		
		If LineRead = False Then 
			If Left$(LineIn$,1) &lt;&gt; ";" Then
				If LineIn$ &lt;&gt; "" Then tol$ = Objective_Line$(LineIn$):WriteLine(file2,ReplaceTabs$(tol$,TabCount));:WriteLine(file2,"")
			Else
				WriteLine(file2,ReplaceTabs$("//"+Right$(LineIn,Len(LineIn)-1),TabCount))
			EndIf
		EndIf
	Wend
End Function

Function Write_cpp_Code()

	Local T.Class,TT.Class

	For T.Class = Each Class
		
		WriteLine(file2,"")
		
		TT = T\ParentClass
		If TT &lt;&gt; Null Then	
			WriteLine(file2,ReplaceTabs$("class" + " " + T\Name + " { " + T\Comment,T\ClassTabs))
			WriteLine(file2,"public:")
			While TT &lt;&gt; Null 
				ProcessTypesParent(TT)
				TT = TT\ParentClass
			Wend
		Else
			WriteLine(file2,ReplaceTabs$("class" + " " + T\Name+ " { " + T\Comment,T\ClassTabs))
			WriteLine(file2,"public:")
		EndIf
		ProcessTypes(T)
		
		PredeclareMethods(T)
		
		WriteLine(file2,ReplaceTabs$("};"+T\ExitClassComment,T\ClassTabs))
		If T\ContainMethods = True And T\ParentClass = Null Then 
			WriteMethods(T)
		Else
			TT = T\ParentClass
			While TT &lt;&gt; Null
				;WriteParentMethods(TT,T\Name)
				TT = TT\ParentClass
			Wend
			;WriteMethods(T)
		EndIf
	Next
	WriteFunctions()
End Function

Function WriteMethods(T.Class)

	Local M.Method,Method,BS,Code$,mct,LIN$,Name$,MC.MethodCode,F.Fields
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T Then
			
			tBS = 0:mct = 0
			Select True
				Case M\MethodReturnType = 0
					Name = "void"
				Case M\MethodReturnType = 1
					Name = "int"
				Case M\MethodReturnType = 2
					Name = "string"
				Case M\MethodReturnType = 3
					Name = "float"
				Case M\MethodReturnType = 4
					Name = T\Name
			End Select
			
			If Not M\Constructor Then
				LIN$ = Name+" "+T\Name$+"::"+ M\Name$+"("+M\MethodParameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\MethodTab-1))
				For MC.MethodCode = Each MethodCode
					If MC\Parent = M Then
						MC\Code = RemoveRightSideTabs_Spaces$(MC\Code)
						ProcessMethodCode(MC)
						Code= MC\Code
						If MC\Term = True Then
							WriteLine(file2,ReplaceTabs$(Code+MC\CodeComment,MC\CodeTabs-1))
						Else
							WriteLine(file2,ReplaceTabs$(Code+";"+MC\CodeComment,MC\CodeTabs-1))
						EndIf
					EndIf
				Next
			Else
				LIN$ = T\Name$+"::"+ M\Name$+"("+M\MethodParameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\MethodTab-1))
				For F.Fields = Each Fields
					If F\ParentClass = M\parentPTR Then
						Select True
							Case F\VariableType = 0
								WriteLine(file2,ReplaceTabs(F\Name + " = 0;",M\MethodTab))
							Case F\VariableType = 1
								WriteLine(file2,ReplaceTabs(F\Name + " = "+Chr(34)+Chr(34)+";",M\MethodTab))
							Case F\VariableType = 2
								WriteLine(file2,ReplaceTabs(F\Name + " = 0.0;",M\MethodTab))
						End Select
						
					EndIf
				Next
			EndIf
			WriteLine(file2,ReplaceTabs$("}"+" "+M\ExitMethodComment,M\MethodTab-1))
		EndIf
	Next
End Function

Function ProcessClass.Class(LineIn$,TabCount)
	
	Local T.Class,C.Class,TLIN,ParentName$,TI,SI,I
	
	ParentName$ = ""
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then 
			TI = I
		EndIf
	Next
	
	T.Class = New Class
	
	If SI &lt;&gt; 0 Then T\Comment = "//"+Right$(LineIn$,Len(LineIn$) - (SI)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	TLIN = Len(LineIn$)-Len("Class")
	If TLIN &lt;= 0 Then RuntimeError "Error @ Line: "+ LineCount+" Class has no name!"
	
	If TI &lt;&gt; 0 Then ParentName$ = RemoveSpaces$(Mid$(LineIn$,(TI+1),(SI - TI)-2))
	
	If ParentName$ &lt;&gt; "" Then
		For C.Class = Each Class
			If C\Name$=ParentName$ Or C\Name_Lower$=ParentName$ Then 
				T\ParentClass = C:T\Name = Mid$(LineIn$,7,TI - 8)
			EndIf
		Next
	Else
		T\Name = Right$(LineIn$, TLIN - 1)
	EndIf
	
	T\Name_Lower = Lower(T\name)
	T\ClassTabs = TabCount
	T\ContainMethods = False
	
	Return T
	
End Function

Function ProcessField(LineIn$,T.Class,TabCount)
	
	Local FieldName$,F.Fields,I,SI,TI,TP
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then TI = I
		If Mid$(LineIn$,I,1) = "." Then TP = I
	Next
	
	F.Fields = New Fields
	
	If SI &lt;&gt; 0 Then F\Comment = "//"+Right$(LineIn$,Len(LineIn$)-(SI)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	Select True
		Case Right$(LineIn$,1)="%"
			F\VariableType=0
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="$"
			F\VariableType=1
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="#"
			F\VariableType=2
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case TP &lt;&gt; 0
			F\VariableType=3
			F\ParentClassName = Right$(LineIn,Len(LineIn)-tp)
			LineIn = Left$(LineIn,tp-1)
		Default
			F\VariableType=0
	End Select
	
	FieldName$ = Right$(LineIn$,Len(LineIn$)-6)
	F\Name = FieldName
	F\Name_Lower = Lower(FieldName)
	F\ParentClass = T
	F\Tabs = TabCount
	F\Private = T\Private
	
End Function

Function Objective_Line$(Code$,term = True)
	If Left$(Code$,7) = "Global " And InClass = False And InMethod = False Then 
		Code = Right$(Code,Len(Code)-7)
	ElseIf Left$(Code$,7) = "Global " And InClass = True Or InMethod = True
		RuntimeError "Global in Class or Method not allowed @ "+ LineCount
	EndIf
	For i = 1 To Len(Code)
		If Mid$(Code,i,1) = ";" Then 
			tCode$ = " // " +Right$(Code,Len(Code)-i)
			Code = Left$(Code,i-1)
		EndIf
	Next
	If Lower(Left$(Code,6)) = "print " Or Lower(Left$(Code,6)) = "print(" Then 
		Code = "cout &lt;&lt; " + Right$(Code,Len(Code)-6)
		For i = 1 To Len(Code)-1
			If Mid$(tc,i,2) = "+" Then Code = Left$(Code,i-1)+" &lt;&lt; "+ Right$(Code,i+1)
		Next
		Code = Code + " &lt;&lt; endl"
	EndIf
	If Lower(Left$(Code,9)) = "#include " Or Lower(Left$(Code,9)) = "#include&lt;" Then
		Return Code + " " + tcode
	EndIf
	If Lower(Left$(Code,4)) = "for " Or Lower(Left$(Code,4)) = "for(" Then
		
	EndIf
	If term = True Then	Return Code+";" +tcode
	Return Code + tcode
End Function

Function ProcessTypes(T.Class)
	
	Local F.Fields,FT$,Name$
	
	For F.Fields = Each Fields
		FT = ""
		If F\ParentClass = T Then
			Select True
				Case F\VariableType = 0
					Name = "int"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Case F\VariableType = 1
					Name = "string"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Case F\VariableType = 2
					Name = "float"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
			End Select
		EndIf
	Next
	
End Function

Function ProcessTypesParent(T.Class)
	
	Local F.Fields,FT$
	
	For F.Fields = Each Fields
		FT = ""
		
		If F\ParentClass = T And F\Private = False Then
		Select True
				Case F\VariableType = 0
					FT = "%":Name = "int"
				Case F\VariableType = 1
					FT = "$":Name = "string"
				Case F\VariableType = 2
					FT = "#":Name = "float"
			End Select
			WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
		EndIf
	Next
	
End Function

Function PredeclareMethods(T.Class)
	
	Local M.Method,Name$
	For M.Method = Each Method
		If M\parentPTR = T Then 
			Select True
				Case M\MethodReturnType = 0
					Name = "void"
				Case M\MethodReturnType = 1
					Name = "int"
				Case M\MethodReturnType = 2
					Name = "string"
				Case M\MethodReturnType = 3
					Name = "float"
				Case M\MethodReturnType = 4
					Name = T\Name
			End Select
			If M\Constructor Then
				WriteLine(file2,ReplaceTabs$(M\Name + " (" +M\MethodParameters+");",M\MethodTab))
			Else
				WriteLine(file2,ReplaceTabs$(Name + " " + M\Name + " (" +M\MethodParameters+")"+";",M\MethodTab))
			EndIf
		EndIf
	Next
End Function

Function WriteFunctions()
	
	Local F.Functions,Name$,FC.FunctionCode
	For F.Functions = Each Functions
		Select True
			Case F\FunctionReturnType = 0
				Name = "void"
			Case F\FunctionReturnType = 1
				Name = "int"
			Case F\FunctionReturnType = 2
				Name = "string"
			Case F\FunctionReturnType = 3
				Name = "float"
		End Select
		WriteLine(file2,Name+" " + F\Name + "(" +F\FunctionParameters+"){"+F\Comment)
		;WriteLine(file2,"{")
		For FC.functioncode = Each functioncode
			If FC\Parent = F Then
				WriteLine(file2,ReplaceTabs(Objective_Line(FC\Code)+FC\CodeComment,FC\CodeTabs))
			EndIf
		Next
		WriteLine(file2,"}"+F\ExitFunctionComment)
	Next
End Function

Function ProcessMethodParameters$(M.Method)
	If M\MethodParameters = "" Then Return
	Local I, StartX=1,MV.MethodVariable,In$,VN$,CN,TN$,CNSX,T.Class,TI,MVN$
	In = M\MethodParameters
	For I = 1 To Len(In$)
		If TestKeySymbol(Mid$(In,I,1)) Or (I = Len(in)) Then
			If I = Len(In) Then
				VN = Mid$(M\MethodParameters,StartX,(I+1) - StartX)
			Else
				VN = Mid$(M\MethodParameters,StartX,I - StartX)
			EndIf
			If (ObservedKeySymbol &lt;&gt; "." Or CN = True) And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then 
				MV.MethodVariable = New MethodVariable
				MV\Parent = M
				Select True
					Case ObservedKeySymbol = "%"
						MV\VariableType = 1
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case ObservedKeySymbol = "#"
						MV\VariableType = 2
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case ObservedKeySymbol = "$"
						MV\VariableType = 3
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case CN = True
						TN$ = Mid$(In,CNSX,(i+1)- CNSX):CN = False
						For t.class = Each class
							If TN = T\Name Then MV\VariableType = 4:MV\ClassName = T\Name:MV\Name = MVN
						Next
					Default
						MV\VariableType = 1	
						MV\Name = VN
				End Select
				MV\Declared = True
			Else If ObservedKeySymbol = "." And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then
				CN = True:CNSX = I+1:MVN = Mid$(In,StartX,I - StartX)
			EndIf
			TI = I:StartX = I+1
		EndIf
	Next
	Return ReWriteMethodParameters$(M)
End Function

Function ReWriteMethodParameters$(M.Method)
	Local MV.MethodVariable,tParameters$,Name$
	For MV.MethodVariable = Each MethodVariable
		If MV\Parent = M Then
			Select True
				Case MV\VariableType = 1
					Name = "int "
				Case MV\VariableType = 2
					Name = "float "
				Case MV\VariableType = 3
					Name = "string&amp; "
				Case MV\VariableType = 4
					Name = MV\ClassName + " &amp;"
			End Select
			tParameters = tParameters + Name + MV\Name + ","
		EndIf
	Next
	Return Left$(tParameters,Len(tParameters)-1)
End Function

Function ProcessMethodVariables(M.Method)
	Local MC.MethodCode,StartX = 1,MV.MethodVariable,MVUsed,VN$,F.Fields
	For MC.MethodCode = Each MethodCode
		If MC\Parent = M Then
			For i = 1 To Len(MC\Code)
				If TestKeySymbol(Mid$(MC\Code,i,1)) Then
					VN = Mid$(MC\Code,StartX,i - StartX)
					If TestKeyword(VN)= False And VN &lt;&gt; "" Then
						MVUsed = False
						For F.Fields = Each Fields
							If F\ParentClass = M\parentPTR Then
								If VN = F\Name Then MVUsed = True
							EndIf
						Next
						For MV.MethodVariable = Each MethodVariable
							If MV\Name =VN And MV\Parent = M Then MVUsed = True
						Next
						If MVUsed = False Then
							MV.MethodVariable = New MethodVariable
							MV\Parent = M
							Select True
								Case Right$(VN,1) = "%"
									MV\VariableType = 1
									MV\Name = Left$(VN,Len(VN)-1)
								Case Right$(VN,1) = "#"
									MV\VariableType = 2
									MV\Name = Left$(VN,Len(VN)-1)
								Case Right$(VN,1) = "$"
									MV\VariableType = 3
									MV\Name = Left$(VN,Len(VN)-1)
								Default
									MV\VariableType = 1	
									MV\Name = VN
							End Select
						EndIf
					EndIf
					StartX = i + 1
				EndIf
			Next
		EndIf
	Next
End Function

Function ProcessMethodCode(MC.MethodCode)
	Local F.Fields,VariableName$,StartX,MV.MethodVariable,Name$
	StartX = 1

	If Lower(Left$(MC\Code,4)) = "for " Then
		For I = 5 To Len(MC\Code)
			lmc$ = Mid$(MC\Code,i,1)
			If Mid$(MC\Code,i,1) = " "Or  Mid$(MC\Code,i,1) = "="Then VariableName = Mid$(MC\Code,5,i-5):StartX = I:Exit
		Next
		For MV.methodvariable = Each methodvariable
			If MV\Parent = MC\Parent And MV\Name = VariableName Or MV\Name = Left$(VariableName,Len(VariableName)-1) Then
				If MV\Declared &lt;&gt; True Then
					Select True
						Case MV\VariableType = 1
							Name = "int "
						Case MV\VariableType = 2
							Name = "float "
					End Select
					ExitTrue = False
					For I = StartX+1 To Len(MC\Code)
						If TestKeySymbol( Mid$(MC\Code,i,1)) &lt;&gt; True And TestNumber(Mid$(MC\Code,i,1))= False Then
							Tcode$ = "for("+Name+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+";"+MV\Name +"&lt;=" +";" + MV\Name +"++"
							ExitTrue = True
						EndIf
						If ExitTrue Then Exit
					Next
					;MC\Code = 
				EndIf
			Else
				MV.methodVariable = New MethodVariable
				MV\Parent = MC\Parent
				Select True
					Case Right$(VariableName,1) = "%"
						MV\VariableType = 1:MV\Name = Left$(VariableName,Len(VariableName)-1)
					Case Right$(VariableName,1) = "#"
						MV\VariableType = 2:MV\Name = Left$(VariableName,Len(VariableName)-1)
					Default
						MV\VariableType = 1:MV\Name = VariableName 
				End Select
				If MV\Declared &lt;&gt; True Then
					Select True
						Case MV\VariableType = 1
							Name = "int "
						Case MV\VariableType = 2
							Name = "float "
					End Select
					ExitTrue = False
					For I = StartX+1 To Len(MC\Code)
						LMC$ = Mid$(MC\Code,i,1)
						If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
							Tcode$ = "for ( "+Name+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
							ExitTrue = True:TI = i
						EndIf
						If ExitTrue Then Exit
					Next
					ExitTrue = False
					For i = ti To Len(MC\code)
						If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
						If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
					Next
					
					Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
					For i = n2 To Len(MC\Code)
						If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
					Next
					MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
					;MC\Code = 
				EndIf
			EndIf
		Next
		MC\Term = True
	EndIf
	If Lower(MC\Code) = "next" Then MC\Code = "}":MC\Term = True
End Function

; Remove Tabs from the OO code if any, keep track of how many there are
Function RemoveTabs()

	Local tc = 0
	
	While Left$(LineIn$,1) = Chr(9)
		tc = tc + 1
		LineIn$ = Right$(LineIn$,Len(LineIn$)-1)
	Wend
	
	Return tc
	
End Function

; Replace Tabs from the OO code so that the readablity is still present.
Function ReplaceTabs$(In$,Tabs)
	
	Local i
	
	For i = 1 To Tabs
		In$ = Chr(9) + In$
	Next
	
	Return In$
	
End Function

; Remove Spaces from the left side of a sting.
Function RemoveSpaces$(in$)
	
	While Left$(in$,1) = " "
		in$ = Right$(in$,Len(in$)-1)
	Wend
	
	Return in$
	
End Function

; Remove Spaces and tabs on the right side(does not keep track of them)
Function RemoveRightSideTabs_Spaces$(In$)
	
	While Right$(In$,1) = " " Or Right$(In$,1) = Chr(9)
		In$ = Left$(In$,Len(In$)-1)
	Wend
	
	Return In$
	
End Function

.KeyWords ;
Data 12	;amount
Data "for","next"
Data "if","end if","endif","else","elseif","else if"
Data "while","wend" ;13
Data "to","then"

Function TestKeyword(code$)
	Restore KeyWords
	Read amt
	For i = 1 To amt
		Read KW$
		kw = Lower(kw)
		If kw = Lower(code) Or kw+" " = Lower(Left$(code,Len(kw)+1)) Or kw+"(" = Lower(Left$(code,Len(kw)+1))Then ObservedKeyWord = kw :Return True
	Next
	Return False
End Function

.KeySymbols
Data 25;amount
Data ";",":","(",")","&lt;"
Data "&gt;","!","~","`","."
Data ",","{","}","[","]"
Data "=","+","-","*","/"
Data "^"," ","#","$","%"

Function TestKeySymbol(in$)
	Restore keysymbols
	Read amt
	If in = Chr(34) Then Return True
	For i = 1 To amt
		Read kw$
		If kw = in Then ObservedKeySymbol = kw:Return True
	Next
	Return False
End Function

.Numbers
Data 10;amount
Data "0","1","2","3","4","5","6","7","8","9"
Function TestNumber(in$)
	Restore numbers
	Read amt
	For i = 1 To amt
		Read kw$
		If Asc(kw) = Asc(in) Then ObservedNumber = kw:Return True
	Next
	Return False
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1035939"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Depending on what your aim is (are you trying to cover all/most of C++, or just object-orientation?), had you considered compiling to C rather than C++? C is a relatively common compiler target because of its portability, and its small size means it behaves more predictably - fewer bugs simply because there are fewer places for them to appear.<br><br>Object systems do actually exist for C, so it's still possible to create object-oriented C code rather than compiling the whole object model of OOPS down to a procedural arrangement. If you haven't come across them before, do take a look at <a href="http://library.gnome.org/devel/gobject/stable/" target="_blank">GObject</a> (used by GNOME and Vala) and Laurent Deniau's <a href="http://ldeniau.web.cern.ch/ldeniau/oopc.html" target="_blank">"COS" C Object System</a>. <br><br></td></tr></table><br>
<a name="1035956"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not really sure.  I guess I'm just trying to simplify the c++ syntax which I feel is too complex compared to basic.  keeping in mind that c++ is to large to cover completely, I think that if the major syntax points are covered c++ will be mostly covered.   oop is not the real goal in this instance, but it's there so might as well make use of it.  and besides who wouldn't want to program in a new language with about the same syntax as blitz which I like very much.  not to mention that if all goes well you could convert alot of blitz code into c++ for faster programs, other then the blitz 3D and image command sets (which could be coded in c++ in a similar manner (write your own 3d engine anyone?) or even update to dx8 or above , sorry dreaming I really don't know how realistic that is). <br><br></td></tr></table><br>
<a name="1036126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >puki</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think it looks interesting. <br><br></td></tr></table><br>
<a name="1036283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is update 4:<br>for/next work<br>while/wend work<br>if then/ else/ else if / endif work<br>dim myarray[] works  and can be made of type class. ie:<br>dim myarray.foo[100] will make 100 foo instences<br>myarray[n].a = 1  to access the class elements<br>myarray[n].mymethod() to access the class methods<br>fixed a bug with local statment<br>can now inline c++ code in methods and functions with:<br>[cpp] <br>put c++ code here <br>[cpp] or <br>[c++] <br>put c++ code here <br>[c++]<br><br>still trying to figure out how to do lists of classes, I'm thinking something like bmax syntax would work. but then again with inline c++ code you might have to learn how to do it yourself, its complicated to do a translated version of blitz3d's type handleing to a class list.<br>It doesn't translate outside of functions and methods.<br>And blitz3d's 'select true' cannot be done, as c++ uses constants for a selection and not variables so use if /elseif/ elseif/endif to do the same thing.<br><br>also how do you make a c++ dll for blitz3d.  wondering if there is a tutorial some place for that?<br><br>will convert:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Comment test for cpp
#include &lt;iostream&gt; 		;Must use this include for using print and other commands
#include &lt;string&gt;			;Must be used to do strings
#include &lt;new&gt;				;Must be used for dynamic arrays
using namespace std

Class foo 					;Test Comment on Class
	field a% 				;Test Comment on Field
	field b$
	Method addhundo() 	;Test Comment on Method
		a += 100			;Test Comment on Method code
	end method				;Test Comment on Method Exit
	Method addsome(amount%)
		local i%,j
		for i = 1 to amount and j &lt; 10 or j &gt; 0
			while j &lt; 10
				if a = 1000 then
					return
				endif
				a += i
				j++
				print j
				if j = 5 then
					exit
				endif
			wend
			if j = 5 then
				exit
			endif
		next
	end method
End Class 					;Test Comment on Class exit

function dosomething(f.foo)
	f.a = 0
	f.b = "xxxx"
end function

Function make_an_instance.foo()
	foo g
	return g
end function

Function Main() 			;Test Comment on function
	foo f					;This creates a new class foo where f is the handle trying to make f.foo = new foo mean the same thing.
	print f.a
	f.addhundo()
	print f.a
	f.b = "Hello World!"
	print f.b
	f.addsome(100)
	print f.a
	dim myarray[100]
	for i = 0 to 99
		myarray[i] = i
	next
	for i = 0 to 99
		print myarray[99-i]
	next
	dosomething(f)
	print f.a + f.b
	foo m = make_an_instance.foo()
	print m.a + m.b
	Delete myarray
	Waitkey
end function				;Test Comment on function exit


</textarea><br><br>to:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
// Comment test for cpp
#include &lt;iostream&gt; 		  // Must use this include for using print and other commands
#include &lt;string&gt;			  // Must be used to do strings
#include &lt;new&gt;				  // Must be used for dynamic arrays
using namespace std;

class foo { //Test Comment on Class
public:
	int a;	//Test Comment on Field
	string b;	
	foo ();
	void addhundo ();
	void addsome (int amount);
};//Test Comment on Class exit
foo::foo() { 
	a = 0;
	b = "";
} 
void foo::addhundo() { //Test Comment on Method
	a += 100;//Test Comment on Method code
} //Test Comment on Method Exit
void foo::addsome(int amount) { //addsome(amount%)
	int i = 0;int j = 0;
	for ( i = 1 ; i &lt;= amount &amp;&amp; j &lt; 10 || j &gt; 0 ; i++ ){
		while (j &lt; 10){
			if (a == 1000 ){
				return;
			}
			a += i;
			j++;
			cout &lt;&lt; j &lt;&lt; endl;
			if (j == 5 ){
				break;
			}
		}
		if (j == 5 ){
			break;
		}
	}
} 
void dosomething(foo &amp;f){//dosomething(f.foo)
	f.a = 0;;
	f.b = "xxxx";;
}
foo make_an_instance_foo(){//make_an_instance.foo()
	foo g;;
	return g;;
}
int main(){//Test Comment on function
	foo f;;//This creates a new class foo where f is the handle trying to make f.foo = new foo mean the same thing.
	cout &lt;&lt; f.a &lt;&lt; endl;;
	f.addhundo();;
	cout &lt;&lt; f.a &lt;&lt; endl;;
	f.b = "Hello World!";;
	cout &lt;&lt; f.b &lt;&lt; endl;;
	f.addsome(100);;
	cout &lt;&lt; f.a &lt;&lt; endl;;
	int * myarray = new (nothrow) int[100];if (myarray == 0){cout &lt;&lt; "Error: memory could Not be allocated";return 0;};
	for ( int i = 0 ; i &lt;= 99 ; i++ ){
		myarray[i] = i;;
	}
	for ( int i = 0 ; i &lt;= 99 ; i++ ){
		cout &lt;&lt; myarray[99-i] &lt;&lt; endl;;
	}
	dosomething(f);;
	cout &lt;&lt; f.a  &lt;&lt;  f.b &lt;&lt; endl;;
	foo m = make_an_instance_foo();;
	cout &lt;&lt; m.a  &lt;&lt;  m.b &lt;&lt; endl;;
	delete[] myarray;;
	system("PAUSE");;
}//Test Comment on function exit

</textarea><br><br>source:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
FileName$ = "Test2"
Global file = ReadFile(filename+".OB")
Global file2= WriteFile(filename+".cpp")
Global LineIn$,InClass,InMethod,LineCount
Global ObservedKeySymbol$,ObservedKeyWord$,ObservedNumber$
Global cpp

Convert_OOPS_cpp()
Write_cpp_Code()

CloseFile(file2)	;close the output file so that it can be debuged through blitz
CloseFile(file)		;close the Objective Blitz3D file

End

Type Class
	Field Name$
	Field Name_Lower$
	Field ClassTabs
	Field TypesPointer$
	Field LastPointer$
	Field ParentClass.Class
	Field ContainMethods
	Field Private
	Field Comment$
	Field ExitClassComment$
	Field iterator$
End Type

Type Fields
	Field Name$
	Field Name_Lower$
	Field VariableType
	Field Tabs
	Field ParentClass.Class
	Field ParentClassName$
	Field Private
	Field Comment$
End Type

Type Method
	Field parentPTR.Class
	Field Name$
	Field Name_Lower$
	Field ReturnType%
	Field Parameters$
	Field Tabs
	Field Private
	Field Comment$
	Field ExitComment$
	Field Constructor
End Type
Type MethodCode
	Field Parent.Method
	Field Code$
	Field Tabs
	Field Comment$
	Field Term
End Type
Type MethodVariable
	Field Name$
	Field VariableType
	Field Parent.Method
	Field Declared
	Field ClassName$
	Field IsArray
End Type

Type Functions
	Field Name$
	Field Name_Lower$
	Field ReturnType%
	Field Parameters$
	Field Comment$
	Field ExitComment$
	Field ClassName$
End Type
Type FunctionCode
	Field Parent.Functions
	Field Code$
	Field Tabs
	Field Comment$
	Field Term
End Type
Type FunctionVariable
	Field Name$
	Field VariableType
	Field Parent.Functions
	Field Declared
	Field ClassName$
	Field IsArray
End Type

Function Convert_OOPS_cpp()
	
Local LineCount,TabCount,T.Class,Name$,OldBS,M.Method,LineRead,C.Class,ParentName$,MC.MethodCode
Local InFunctionFlag,F.Functions

	While Not Eof(file)
		
		LineIn$ = ReadLine(file):LineCount = LineCount + 1
		TabCount = RemoveTabs()
		ti = 0
		Select True
			Case Lower(Left$(LineIn$,5)) = "class"
				T.Class = ProcessClass.Class(LineIn$,TabCount)
				M.method = New Method
				M\Name = T\Name
				M\Constructor = True
				M\parentPTR = T
				M\Tabs = T\ClassTabs + 1
				InClass = True
	
			Case Lower(Left$(LineIn$,9)) = "end class"
				InClass = False
				For i = 9 To Len(LineIn)
					If Mid$(LineIn,i,1) = ";" Then T\ExitClassComment = "//"+Right$(LineIn,Len(LineIn)-i)
				Next
			
			Case Lower(Left$(LineIn$,5)) = "field"
				ProcessField(LineIn$, T , TabCount)
	
			Case InClass = True And LineRead = False And Lower(Left$(LineIn,6))&lt;&gt; "method" And InMethod = False
				ProcessField(LineIn$, T , TabCount)
			
			Case Lower(Left$(LineIn$,8)) = "private:" : T\Private = True
			
			Case Lower(Left$(LineIn$,7)) = "public:" : T\Private = False
		
			Case Lower(Left$(LineIn$,10)) = "end method" 
				MethodFlag = False:InMethod = False
				For i = 10 To Len(LineIn)
					If Mid$(LineIn,i,1) = ";" Then M\ExitComment = "//"+Right$(LineIn,Len(LineIn)-i)
				Next
			
			Case MethodFlag
				LineIn = RemoveRightSideTabs_Spaces$(LineIn)
				If Lower(LineIn) = "return" Then M\ReturnType = 0
				MC.MethodCode = New MethodCode
				MC\Parent = M
				MC\Tabs = TabCount
				MC\Code = LineIn
	
			Case Lower(Left$(LineIn$,6)) = "method"
				T\ContainMethods = True
				M.Method = New Method
				tm$ =  Right$(LineIn$,Len(LineIn$)-7)
				startx = 0: endx = 0:TypeHandle = 0:Coms = 0
				For j = 1 To Len( tm )
					If Mid$(tm,j,1) = "." Then TypeHandle = j
					If Mid$(tm,j,1) = "(" Then StartX = j
					If Mid$(tm,j,1) = ")" Then EndX = j
					If Mid$(tm,j,1) = ";" Then ComS = j
				Next
				Select True
					Case Mid$(tm,startx-1,1) = "%"
						M\ReturnType = 1
					Case Mid$(tm,startx-1,1) = "#"
						M\ReturnType = 2
					Case Mid$(tm,startx-1,1) = "$"
						M\ReturnType = 3
					Case TypeHandle &lt;&gt; 0 And typehandle &lt; startx
						M\ReturnType = 4
				End Select
				If coms &lt;&gt; 0 Then M\Comment = "//"+Right$(tm,Len(tm)-coms)
				If M\ReturnType&lt;&gt;0 Then 
					M\Name$ = Left$(tm,startx-2)
				Else
					M\Name$ = Left$(tm,startx-1)
				EndIf
				M\Name_Lower = Lower(M\Name)
				If endx - startx &gt; 1 Then M\Parameters$ = Mid$(tm,startx+1,(endx-2)-startx+1)
				M\Parameters = ProcessMethodParameters$(M)
				M\Tabs = TabCount
				M\parentPTR = T
				If T\Private = True Then M\Private = True
				MethodFlag = True
				InMethod = True
			
			Case Lower(Left$(LineIn$,12)) = "end function"
				InFunctionFlag = False
				For i = 10 To Len(LineIn)
					If Mid$(LineIn,i,1) = ";" Then F\ExitComment = "//"+Right$(LineIn,Len(LineIn)-i)
				Next
	
			Case InFunctionFlag ;Then
				LineIn = RemoveRightSideTabs_Spaces$(LineIn)
				If Lower(LineIn) = "waitkey" Then LineIn = "system("+Chr(34)+"PAUSE"+Chr(34)+")"
				FC.FunctionCode = New FunctionCode
				fC\Parent = F
				fC\Tabs = TabCount
				For i = 1 To Len(LineIn)
					If Mid$(LineIn,i,1) =";" Then fC\Comment = "//"+Right$(LineIn,Len(LineIn)-i):ti =i
				Next
				If ti &lt;&gt; 0 Then 
					fC\Code = Left$(LineIn,ti-1)
				Else
					fC\Code = LineIn
				EndIf
	
			Case Lower(Left$(LineIn,9)) = "function "
				F.Functions = New Functions
				tm$ = Right$(LineIn,Len(LineIn)-9)
				startx = 0: endx = 0:TypeHandle = 0:Coms = 0
				For j = 1 To Len( tm )
					If Mid$(tm,j,1) = "." Then TypeHandle = j
					If Mid$(tm,j,1) = "(" Then StartX = j
					If Mid$(tm,j,1) = ")" Then EndX = j
					If Mid$(tm,j,1) = ";" Then ComS = j
				Next
				Select True
					Case Mid$(tm,startx-1,1) = "%"
						F\ReturnType = 1
					Case Mid$(tm,startx-1,1) = "#"
						F\ReturnType = 2
					Case Mid$(tm,startx-1,1) = "$"
						F\ReturnType = 3
					Case typehandle &lt;&gt; 0 And typehandle &lt; startx
						F\ReturnType = 4
						F\classname = Mid$(tm,typehandle+1,(startx-typehandle)-1)
				End Select
				If coms &lt;&gt; 0 Then F\Comment = "//"+Right$(tm,Len(tm)-coms)
				Select True
					Case F\ReturnType &gt; 0 And F\ReturnType&lt;4
						F\Name = Left$(tm,startx-2)
					Case F\ReturnType = 4
						F\Name = Left$(tm,typehandle-1)
					Default
						F\Name = Left$(tm,startx-1)
				End Select
				F\Name_Lower = Lower(F\Name)
				If Lower(F\Name) = "main" Then F\Name = F\Name_Lower:F\ReturnType = 1
				If endx - startx &gt; 1 Then F\Parameters = Mid$(tm,startx+1,(endx-2)-startx+1):ProcessFunctionParameters$(F)
				InFunctionFlag = True
			Default
				If Left$(LineIn$,1) &lt;&gt; ";" Then
					If LineIn$ &lt;&gt; "" Then tol$ = Objective_Line$(LineIn$)+";":WriteLine(file2,ReplaceTabs$(tol$,TabCount));:WriteLine(file2,"")
				Else
					WriteLine(file2,ReplaceTabs$("//"+Right$(LineIn,Len(LineIn)-1),TabCount))
				EndIf
		End Select
	Wend
End Function

Function Write_cpp_Code()

	Local T.Class,TT.Class

	For T.Class = Each Class
		
		WriteLine(file2,"")
		
		TT = T\ParentClass
		If TT &lt;&gt; Null Then	
			WriteLine(file2,ReplaceTabs$("class" + " " + T\Name +":public "+ T\ParentClass\Name+" { " + T\Comment,T\ClassTabs))
			WriteLine(file2,"public:")
		Else
			WriteLine(file2,ReplaceTabs$("class" + " " + T\Name+ " { " + T\Comment,T\ClassTabs))
			WriteLine(file2,"public:")
		EndIf
		ProcessTypes(T)	
		PredeclareMethods(T)
		
		WriteLine(file2,ReplaceTabs$("};"+T\ExitClassComment,T\ClassTabs))
		If T\ContainMethods = True Then WriteMethods(T)
	Next
	WriteFunctions()
End Function

Function WriteMethods(T.Class)

	Local M.Method,Method,BS,Code$,mct,LIN$,Name$,MC.MethodCode,F.Fields
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T Then
			
			Select True
				Case M\ReturnType = 0
					Name = "void"
				Case M\ReturnType = 1
					Name = "int"
				Case M\ReturnType = 2
					Name = "float"
				Case M\ReturnType = 3
					Name = "string"
				Case M\ReturnType = 4
					Name = T\Name
			End Select
			
			If Not M\Constructor Then
				LIN$ = Name+" "+T\Name$+"::"+ M\Name$+"("+M\Parameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\Tabs-1))
				For MC.MethodCode = Each MethodCode
					If MC\Parent = M Then
						MC\Code = RemoveRightSideTabs_Spaces$(MC\Code)
						ProcessMethodCode(MC)
						Code= MC\Code
						If MC\Term = True Then
							WriteLine(file2,ReplaceTabs$(Code+MC\Comment,MC\Tabs-1))
						Else
							WriteLine(file2,ReplaceTabs$(Code+";"+MC\Comment,MC\Tabs-1))
						EndIf
					EndIf
				Next
			Else
				LIN$ = T\Name$+"::"+ M\Name$+"("+M\Parameters+")" + " { " + M\Comment
				WriteLine(file2,ReplaceTabs$(LIN$,M\Tabs-1))
				For F.Fields = Each Fields
					If F\ParentClass = M\parentPTR Then
						Select True
							Case F\VariableType = 0
								WriteLine(file2,ReplaceTabs(F\Name + " = 0;",M\Tabs))
							Case F\VariableType = 1
								WriteLine(file2,ReplaceTabs(F\Name + " = "+Chr(34)+Chr(34)+";",M\Tabs))
							Case F\VariableType = 2
								WriteLine(file2,ReplaceTabs(F\Name + " = 0.0;",M\Tabs))
						End Select
					EndIf
				Next
			EndIf
			WriteLine(file2,ReplaceTabs$("}"+" "+M\ExitComment,M\Tabs-1))
		EndIf
	Next
End Function

Function WriteFunctions()
	
	Local F.Functions,Name$,FC.FunctionCode
	For F.Functions = Each Functions
		Select True
			Case F\ReturnType = 0
				Name = "void"
			Case F\ReturnType = 1
				Name = "int"
			Case F\ReturnType = 2
				Name = "string"
			Case F\ReturnType = 3
				Name = "float"
			Case F\ReturnType = 4
				Name = F\ClassName
		End Select
		If F\ClassName &lt;&gt; "" Then
			WriteLine(file2,Name+" " + F\Name+"_"+Name + "(" +F\Parameters+"){"+F\Comment)
		Else
			WriteLine(file2,Name+" " + F\Name + "(" +F\Parameters+"){"+F\Comment)
		EndIf
		For FC.functioncode = Each functioncode
			If FC\Parent = F Then
				FC\Code = RemoveRightSideTabs_Spaces$(FC\Code)
				ProcessFunctionCode(FC)
				If FC\Term = True Then
					WriteLine(file2,ReplaceTabs(FC\Code+FC\Comment,FC\Tabs))
				Else
					WriteLine(file2,ReplaceTabs(FC\Code+";"+FC\Comment,FC\Tabs))
				EndIf
			EndIf
		Next
		WriteLine(file2,"}"+F\ExitComment)
	Next
End Function

Function ProcessClass.Class(LineIn$,TabCount)

	Local T.Class,C.Class,TLIN,ParentName$,TI,SI,I
	
	ParentName$ = ""
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then 
			TI = I
		EndIf
	Next

	T.Class = New Class
	
	If SI &lt;&gt; 0 Then T\Comment = "//"+Right$(LineIn$,Len(LineIn$) - (SI)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	TLIN = Len(LineIn$)-Len("Class")
	If TLIN &lt;= 0 Then RuntimeError "Error @ Line: "+ LineCount+" Class has no name!"

	If TI &lt;&gt; 0 Then ParentName$ = RemoveSpaces$(Mid$(LineIn$,(TI+1),(SI - TI)-2))
	
	If ParentName$ &lt;&gt; "" Then
		For C.Class = Each Class
			If C\Name$=ParentName$ Or C\Name_Lower$=ParentName$ Then 
				T\ParentClass = C:T\Name = Mid$(LineIn$,7,TI - 7)
			EndIf
		Next
	Else
		T\Name = Right$(LineIn$, TLIN - 1)
	EndIf
	
	T\Name_Lower = Lower(T\name)
	T\ClassTabs = TabCount
	T\ContainMethods = False
	
	Return T
	
End Function

Function ProcessField(LineIn$,T.Class,TabCount)
	
	Local FieldName$,F.Fields,I,SI,TI,TP
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then TI = I
		If Mid$(LineIn$,I,1) = "." Then TP = I
	Next
	
	F.Fields = New Fields
	If Lower(LineIn) = "public:" Then F\Name = "public:":F\VariableType = 999:F\ParentClass = T:F\Tabs=TabCount:Return
	If Lower(LineIn) = "private:" Then F\Name = "private:":F\VariableType = 999:F\ParentClass = T:F\Tabs=TabCount:Return
	If Lower(LineIn) = "protected:" Then F\Name = "protected:":F\VariableType = 999:F\ParentClass = T:F\Tabs=TabCount:Return
	If Lower(Left$(LineIn$,5))= "list&lt;" Or Lower(Left$(LineIn$,5))= "list " Then F\Name = LineIn+";":F\VariableType = 999:F\ParentClass=T:F\Tabs=TabCount:Return
	If SI &lt;&gt; 0 Then F\Comment = "//"+Right$(LineIn$,Len(LineIn$)-(SI)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	Select True
		Case Right$(LineIn$,1)="%"
			F\VariableType=0
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="$"
			F\VariableType=1
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="#"
			F\VariableType=2
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case TP &lt;&gt; 0
			F\VariableType=3
			F\ParentClassName = Right$(LineIn,Len(LineIn)-tp)
			LineIn = Left$(LineIn,tp-1)
		Default
			F\VariableType=0
	End Select
	
	FieldName$ = Right$(LineIn$,Len(LineIn$)-6)
	F\Name = FieldName
	F\Name_Lower = Lower(FieldName)
	F\ParentClass = T
	F\Tabs = TabCount
	F\Private = T\Private
	If Lower(Left$(LineIn$,5))= "list&lt;" Or Lower(Left$(LineIn$,5))= "list " Then F\VariableType = 999
End Function

Function Objective_Line$(code$,term = True)
	Local F.Functions
	If Left$(Code$,7) = "Global " And InClass = False And InMethod = False And InFunction = False Then 
		Code = Right$(Code,Len(Code)-7)
	ElseIf Left$(Code$,7) = "Global " And InClass = True Or InMethod = True Or InFunction = True
		RuntimeError "Global in Class or Method not allowed @ "+ LineCount
	EndIf
	For i = 1 To Len(Code)
		If  Mid$(Code,i,1) = " " Or  Mid$(Code,i,1) = "=" Then LSP = i
		If Mid$(Code,i,1) = ";" Then 
			tCode$ = " // " +Right$(Code,Len(Code)-i)
			Code = Left$(Code,i-1)
		EndIf
		If Mid$(Code,i,1) = "." Then
			If lsp &lt;&gt; 0 Then
				fcode$=Mid$(Code,LSP+1,(i-lsp)-1)
			Else
				fCode$ = Left$(Code,i-1)
			EndIf
			For f.functions = Each functions
				If Lower(fCode) = F\Name_Lower Then Code = Left$(Code,i-1) + "_" + Right$(Code,Len(Code)-i)
			Next
		EndIf
	Next
	If Lower(Left$(Code,6)) = "print " Or Lower(Left$(Code,6)) = "print(" Then 
		Code = "cout &lt;&lt; " + Right$(Code,Len(Code)-6)
		For i = 1 To Len(Code)-1
			If Mid$(Code,i,1) = "+" Then Code = Left$(Code,i-1)+" &lt;&lt; "+ Right$(Code,Len(Code)-i):i = i+3
		Next
		Code = Code + " &lt;&lt; endl"
	EndIf
	If Lower(Left$(Code,9)) = "#include " Or Lower(Left$(Code,9)) = "#include&lt;" Then
		Return Code + " " + tcode
	EndIf
	If Lower(Left$(code,4)) = "dim " Then
		dx = 0:de = 0:dt = 0:di = False:ds = False:df = False
		For I = 5 To Len(Code)
			If Mid$(code,i,1) = "[" Then DX = i
			If Mid$(code,i,1) = "]" Then DE = i
			If Mid$(Code,i,1) = "%" Then DI = True
			If Mid$(Code,i,1) = "$" Then DS = True
			If Mid$(code,i,1) = "#" Then DF = True
			If Mid$(code,i,1) = "." Then DT = i
		Next
		If di = True Or ds = True Or df = True Or DT &lt;&gt; 0 Then
			Select True
				Case di
					Dtype$ = "int"
					name$ =  Mid$(code,5,(DX-1)-5)
				Case ds
					Dtype$ = "string"
					name$ =  Mid$(code,5,(DX-1)-5)
				Case df
					Dtype$ = "float"
					name$ =  Mid$(code,5,(DX-1)-5)
				Case dt &gt; 0
					Dtype$ = Mid$(code,dt+1,dx-dt-1)
					name$ = Mid$(code,5,dt-5)
			End Select
		Else
			Dtype$ = "int"
			name$ = Mid$(code,5,(DX)-5)
		EndIf
		Amount$ = Mid$(Code,dx+1,(de-dx)-1)
		code$ = Dtype$+" * "+name$ + " = new (nothrow) "+dtype$+"["+amount+"];"+"if ("+name+" == 0){cout &lt;&lt; "+Chr(34)+"Error: memory could Not be allocated"+Chr(34)+";return 0;}":Return code+tcode
	EndIf
	If Lower(Left$(Code,7)) =  "delete " Then
		name$ = Mid$(Code,8,(Len(Code)-7))
		Code = "delete[] "+name$
	EndIf
	Return Code + tcode
End Function

Function ProcessTypes(T.Class)
	
	Local F.Fields,FT$,Name$
	
	For F.Fields = Each Fields
		FT = ""
		If F\ParentClass = T Then
			Select True
				Case F\VariableType = 0
					Name = "int"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Case F\VariableType = 1
					Name = "string"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Case F\VariableType = 2
					Name = "float"
					WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
				Default
					WriteLine(file2,ReplaceTabs$(F\Name+Chr(9)+F\Comment,F\Tabs))
			End Select
		EndIf
	Next
	
End Function

Function ProcessTypesParent(T.Class)
	
	Local F.Fields,FT$
	
	For F.Fields = Each Fields
		FT = ""
		
		If F\ParentClass = T And F\Private = False Then
		Select True
				Case F\VariableType = 0
					FT = "%":Name = "int"
				Case F\VariableType = 1
					FT = "$":Name = "string"
				Case F\VariableType = 2
					FT = "#":Name = "float"
			End Select
			WriteLine (file2,ReplaceTabs$(Name + " " + F\Name+";"+Chr(9)+F\Comment,F\Tabs))
		EndIf
	Next
	
End Function

Function PredeclareMethods(T.Class)
	
	Local M.Method,Name$
	For M.Method = Each Method
		If M\parentPTR = T Then 
			Select True
				Case M\ReturnType = 0
					Name = "void"
				Case M\ReturnType = 1
					Name = "int"
				Case M\ReturnType = 2
					Name = "float"
				Case M\ReturnType = 3
					Name = "string"
				Case M\ReturnType = 4
					Name = T\Name
			End Select
			If M\Constructor Then
				WriteLine(file2,ReplaceTabs$(M\Name + " (" +M\Parameters+");",M\Tabs))
			Else
				WriteLine(file2,ReplaceTabs$(Name + " " + M\Name + " (" +M\Parameters+")"+";",M\Tabs))
			EndIf
		EndIf
	Next
End Function

Function ProcessFunctionParameters$(M.Functions)
	If M\Parameters = "" Then Return
	Local I, StartX=1,MV.FunctionVariable,In$,VN$,CN,TN$,CNSX,T.Class,TI,MVN$
	In = M\Parameters
	For I = 1 To Len(In$)
		If TestKeySymbol(Mid$(In,I,1)) Or (I = Len(in)) Then
			If I = Len(In) Then
				VN = Mid$(M\Parameters,StartX,(I+1) - StartX)
			Else
				VN = Mid$(M\Parameters,StartX,I - StartX)
			EndIf
			If (ObservedKeySymbol &lt;&gt; "." Or CN = True) And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then 
				MV.FunctionVariable = New FunctionVariable
				MV\Parent = M
				Select True
					Case ObservedKeySymbol = "%"
						MV\VariableType = 1
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case ObservedKeySymbol = "#"
						MV\VariableType = 2
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case ObservedKeySymbol = "$"
						MV\VariableType = 3
						MV\Name = Mid$(VN,StartX,(I)-startx)
					Case CN = True
						TN$ = Mid$(In,CNSX,(i+1)- CNSX):CN = False
						For t.class = Each class
							If TN = T\Name Then MV\VariableType = 4:MV\ClassName = T\Name:MV\Name = MVN
						Next
					Default
						MV\VariableType = 1	
						MV\Name = VN
				End Select
				MV\Declared = True
			Else If ObservedKeySymbol = "." And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then
				CN = True:CNSX = I+1:MVN = Mid$(In,StartX,I - StartX)
			EndIf
			TI = I:StartX = I+1
		EndIf
	Next
	m\parameters = ReWriteFunctionParameters$(M)
End Function

Function ReWriteFunctionParameters$(M.Functions)
	Local MV.FunctionVariable,tParameters$,Name$
	For MV.FunctionVariable = Each functionVariable
		If MV\Parent = M Then
			Select True
				Case MV\VariableType = 1
					Name = "int "
				Case MV\VariableType = 2
					Name = "float "
				Case MV\VariableType = 3
					Name = "string&amp; "
				Case MV\VariableType = 4
					Name = MV\ClassName + " &amp;"
			End Select
			tParameters = tParameters + Name + MV\Name + ","
		EndIf
	Next
	Return Left$(tParameters,Len(tParameters)-1)
End Function

Function ProcessFunctionCode(MC.FunctionCode)

	Local F.Fields,VariableName$,StartX,MV.FunctionVariable,Name$
	StartX = 1
	If MC\Code = "[cpp]" Or MC\Code = "[c++]" And incpp = False Then incpp = True:MC\Code = "":MC\Term = True:Return
	If MC\Code = "[cpp]" Or MC\Code = "[c++]" And incpp = True Then incpp = False:MC\Code = "":MC\Term = True:Return
	If incpp = True Then Return
	For i = 1 To Len(MC\Code)
		If Mid$(MC\Code,i,1) =";" Then 
			MC\Comment = "//"+Right$(MC\Code,Len(MC\Code)-i)
			MC\Code = Left$(MC\code,i-1):Exit
		EndIf
	Next
	
	If Lower(Left$(MC\Code,6)) = "local " Then
		MC\Code = Right$(MC\Code,Len(MC\Code)-6):LC = 1
		For i = 1 To Len(MC\code)
			If Mid$(MC\Code ,i,1) = "," Or i = Len(MC\code) And  Mid$(MC\Code ,i,1)&lt;&gt;";" Then
				Select True
					Case Mid$(MC\Code ,i-1,1) = "%" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "%")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						EndIf
						CreateFunctionVariable(Name,1,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "#" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "#")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "float "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 9
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"float " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"float "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 9
						EndIf
						CreateFunctionVariable(Name,2,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "$" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "$")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "string "+Left$(MC\Code,lc)+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"string " + Name +" = "+Chr(34)+Chr(34)+";"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"string "+Name+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						EndIf
						CreateFunctionVariable(Name,3,MC\Parent)
					Default
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc))
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 6
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-1)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 8
						EndIf
						CreateFunctionVariable(Name,1,MC\Parent)
				End Select
				lc = i
			EndIf
		Next
		MC\Term = True
	EndIf
	If Lower(Left$(MC\Code,4)) = "for " Then

		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		For I = 5 To Len(MC\Code)
			lmc$ = Mid$(MC\Code,i,1)
			If Mid$(MC\Code,i,1) = " "Or  Mid$(MC\Code,i,1) = "="Then VariableName = Mid$(MC\Code,5,i-5):StartX = I:Exit
		Next
		viu = False
		For MV.Functionvariable = Each Functionvariable
			If MV\Parent = MC\Parent And MV\Name = VariableName Or MV\Name = Left$(VariableName,Len(VariableName)-1) Then
				If MV\Declared = True Then
					ExitTrue = False
					For I = StartX+1 To Len(MC\Code)
						LMC$ = Mid$(MC\Code,i,1)
						If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
							Tcode$ = "for ( "+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
							ExitTrue = True:TI = i
						EndIf
						If ExitTrue Then Exit
					Next
					ExitTrue = False
					For i = ti To Len(MC\code)
						If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
						If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
					Next
					
					Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
					For i = n2 To Len(MC\Code)
						If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
					Next
					MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
					MV\Declared = True
					viu = True
				EndIf
			EndIf
		Next
		If viu = False Then
			MV.FunctionVariable = New FunctionVariable
			MV\Parent = MC\Parent
			Select True
				Case Right$(VariableName,1) = "%"
					MV\VariableType = 1:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Case Right$(VariableName,1) = "#"
					MV\VariableType = 2:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Default
					MV\VariableType = 1:MV\Name = VariableName 
			End Select
			If MV\Declared &lt;&gt; True Then
				Select True
					Case MV\VariableType = 1
						Name = "int "
					Case MV\VariableType = 2
						Name = "float "
				End Select
				ExitTrue = False
				For I = StartX+1 To Len(MC\Code)
					LMC$ = Mid$(MC\Code,i,1)
					If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
						Tcode$ = "for ( "+Name+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
						ExitTrue = True:TI = i
					EndIf
					If ExitTrue Then Exit
				Next
				ExitTrue = False
				For i = ti To Len(MC\code)
					If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
					If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
				Next
				
				Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
				For i = n2 To Len(MC\Code)
					If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
				Next
				MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
			EndIf
		EndIf
		MC\Term = True
	EndIf
	If Lower(MC\Code) = "next" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,3)) = "if " Or Lower(Left$(MC\Code,3)) = "if(" Then
		
		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		MC\Code = Left$(MC\Code,3) + "(" + Right$(MC\Code,Len(MC\Code)-3)
		For i = 3 To Len(MC\Code)
			If Mid$(MC\Code,i,1) = "=" And (Mid$(MC\Code,i-1,2) &lt;&gt; "&lt;=" Or Mid$(MC\Code,i-1,2) &lt;&gt; "&gt;="Or Mid$(MC\Code,i-1,2) &lt;&gt; "!=" )Then 
				MC\Code = Left$(MC\Code,i)+"="+Right$(MC\Code,Len(MC\Code)-i):i = i + 1
			Else If Mid$(MC\Code,i,2) = "&lt;&gt;" Then
				MC\Code = Left$(MC\code,i-1)+"!="+Right$(MC\Code,Len(MC\code)-(i+1))
			EndIf
			If i = Len(MC\Code) Then
				If Mid$(MC\Code,i-3,4) = "then" Then MC\Code = Left$(MC\Code,i-4)+"){":MC\Term = True
			EndIf
		Next
	EndIf
	If Lower(MC\Code) = "else" Then MC\Code = "} else {":MC\Term = True
	If Lower(Left$(MC\Code,8)) = "else if " Then MC\Code = "} else if (" + Right$(MC\Code,Len(MC\code)-8)+"){":MC\Term = True
	If Lower(MC\Code) = "endif" Or Lower(MC\Code) = "end if" Then MC\Code = "}":MC\Term = True
	If Lower(MC\Code) = "wend" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,6)) = "while " Then MC\Code = "while (" + Right$(MC\code,Len(MC\Code)-6) +"){":MC\Term=True
	If Lower(MC\code) = "exit" Then MC\Code = "break"
	If Lower(Left$(MC\Code,6)) = "print " Or Lower(Left$(MC\Code,6)) = "print(" Then 
		MC\Code = "cout &lt;&lt; " + Right$(MC\Code,Len(MC\Code)-6)
		For i = 1 To Len(MC\Code)-1
			If Mid$(MC\Code,i,1) = "+" Then MC\Code = Left$(MC\Code,i-1)+" &lt;&lt; "+ Right$(MC\Code,Len(MC\Code)-i):i = i+3
		Next
		MC\Code = MC\Code + " &lt;&lt; endl"
	EndIf
	If MC\Term = False Then MC\Code = Objective_Line$(MC\Code)
End Function

Function ProcessMethodParameters$(M.Method)
	If M\Parameters = "" Then Return
	Local I, StartX=1,MV.MethodVariable,In$,VN$,CN,TN$,CNSX,T.Class,TI,MVN$
	In = M\Parameters
	For I = 1 To Len(In$)

		If TestKeySymbol(Mid$(In,I,1)) Or (I = Len(in)) Then
			If I = Len(In) Then
				VN = Mid$(M\Parameters,StartX,(I) - StartX)
			Else
				VN = Mid$(M\Parameters,StartX,I - StartX)
			EndIf
			If (ObservedKeySymbol &lt;&gt; "." Or CN = True) And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then 
				MV.MethodVariable = New MethodVariable
				MV\Parent = M
				Select True
					Case ObservedKeySymbol = "%"
						MV\VariableType = 1
						MV\Name = VN
					Case ObservedKeySymbol = "#"
						MV\VariableType = 2
						MV\Name =VN
					Case ObservedKeySymbol = "$"
						MV\VariableType = 3
						MV\Name =VN
					Case CN = True
						TN$ = Mid$(In,CNSX,(i+1)- CNSX):CN = False
						For t.class = Each class
							If TN = T\Name Then MV\VariableType = 4:MV\ClassName = T\Name:MV\Name = MVN
						Next
					Default
						MV\VariableType = 1	
						MV\Name = VN
				End Select
				MV\Declared = True
			Else If ObservedKeySymbol = "." And TestKeySymbol(vn) = False And vn &lt;&gt; "" Then
				CN = True:CNSX = I+1:MVN = Mid$(In,StartX,I - StartX)
			EndIf
			TI = I:StartX = I+1
		EndIf
	Next
	Return ReWriteMethodParameters$(M)
End Function

Function ReWriteMethodParameters$(M.Method)
	Local MV.MethodVariable,tParameters$,Name$
	For MV.MethodVariable = Each MethodVariable
		If MV\Parent = M Then
			Select True
				Case MV\VariableType = 1
					Name = "int "
				Case MV\VariableType = 2
					Name = "float "
				Case MV\VariableType = 3
					Name = "string&amp; "
				Case MV\VariableType = 4
					Name = MV\ClassName + " &amp;"
			End Select
			tParameters = tParameters + Name + MV\Name + ","
		EndIf
	Next
	Return Left$(tParameters,Len(tParameters)-1)
End Function

Function ProcessMethodVariables(M.Method)
	Local MC.MethodCode,StartX = 1,MV.MethodVariable,MVUsed,VN$,F.Fields
	For MC.MethodCode = Each MethodCode
		If MC\Parent = M Then
			For i = 1 To Len(MC\Code)
				If TestKeySymbol(Mid$(MC\Code,i,1)) Then
					VN = Mid$(MC\Code,StartX,i - StartX)
					If TestKeyword(VN)= False And VN &lt;&gt; "" Then
						MVUsed = False
						For F.Fields = Each Fields
							If F\ParentClass = M\parentPTR Then
								If VN = F\Name Then MVUsed = True
							EndIf
						Next
						For MV.MethodVariable = Each MethodVariable
							If MV\Name =VN And MV\Parent = M Then MVUsed = True
						Next
						If MVUsed = False Then
							MV.MethodVariable = New MethodVariable
							MV\Parent = M
							Select True
								Case Right$(VN,1) = "%"
									MV\VariableType = 1
									MV\Name = Left$(VN,Len(VN)-1)
								Case Right$(VN,1) = "#"
									MV\VariableType = 2
									MV\Name = Left$(VN,Len(VN)-1)
								Case Right$(VN,1) = "$"
									MV\VariableType = 3
									MV\Name = Left$(VN,Len(VN)-1)
								Default
									MV\VariableType = 1	
									MV\Name = VN
							End Select
						EndIf
					EndIf
					StartX = i + 1
				EndIf
			Next
		EndIf
	Next
End Function

Function ProcessMethodCode(MC.MethodCode)
	Local F.Fields,VariableName$,StartX,MV.MethodVariable,Name$
	StartX = 1
	If MC\Code = "[cpp]" Or MC\Code = "[c++]" And incpp = False Then incpp = True:MC\Code = "":Return
	If MC\Code = "[cpp]" Or MC\Code = "[c++]" And incpp = True Then incpp = False:MC\Code = "":Return
	If incpp = True Then Return
	For i = 1 To Len(MC\code)
		If Mid$(MC\Code,i,1) =";" Then 
			MC\Comment = "//"+Right$(MC\Code,Len(MC\Code)-i)
			MC\Code = Left$(MC\code,i-1):Exit
		EndIf
	Next
	
	If Lower(Left$(MC\Code,6)) = "local " Then
		MC\Code = Right$(MC\Code,Len(MC\Code)-6):LC = 1
		For i = 1 To Len(MC\code)
			If Mid$(MC\Code ,i,1) = "," Or i = Len(MC\code) And  Mid$(MC\Code ,i,1)&lt;&gt;";" Then
				Select True
					Case Mid$(MC\Code ,i-1,1) = "%" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "%")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 7
						EndIf
						CreateMethodVariable(Name,1,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "#" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "#")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "float "+Name+" = 0.0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"float " + Name +" = 0.0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"float "+Name+" = 0.0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						EndIf
						CreateMethodVariable(Name,2,MC\Parent)
					Case Mid$(MC\Code ,i-1,1) = "$" Or (i = Len(MC\Code) And Right$(MC\Code,1) = "$")
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc)-1)
							MC\Code = "string "+Left$(MC\Code,lc)+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc-1)
							MC\Code = Left$(MC\code,lc)+"string " + Name +" = "+Chr(34)+Chr(34)+";"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-2)
							MC\Code = Left$(MC\Code,lc)+"string "+Name+" = "+Chr(34)+Chr(34)+";"+Right$(MC\Code,Len(MC\Code)-i):i = i + 11
						EndIf
						CreateMethodVariable(Name,3,MC\Parent)
					Default
						If lc = 1 Then
							Name = Mid$(MC\Code ,lc,(i-lc))
							MC\Code = "int "+Left$(MC\Code,lc)+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 6
						ElseIf i = Len(MC\Code) Then
							Name = Mid$(MC\Code,lc+1,Len(MC\Code)-lc)
							MC\Code = Left$(MC\code,lc)+"int " + Name +" = 0;"
						Else
							Name = Mid$(MC\Code ,lc+1,(i-lc)-1)
							MC\Code = Left$(MC\Code,lc)+"int "+Name+" = 0;"+Right$(MC\Code,Len(MC\Code)-i):i = i + 8
						EndIf
						CreateMethodVariable(Name,1,MC\Parent)
				End Select
				lc = i
			EndIf
		Next
		MC\Term = True
	EndIf
	If Lower(Left$(MC\Code,4)) = "for " Then
		
		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		For I = 5 To Len(MC\Code)
			lmc$ = Mid$(MC\Code,i,1)
			If Mid$(MC\Code,i,1) = " "Or  Mid$(MC\Code,i,1) = "="Then VariableName = Mid$(MC\Code,5,i-5):StartX = I:Exit
		Next
		viu = False
		For MV.methodvariable = Each methodvariable
			If MV\Parent = MC\Parent And MV\Name = VariableName Or MV\Name = Left$(VariableName,Len(VariableName)-1) Then
				If MV\Declared = True Then
					ExitTrue = False
					For I = StartX+1 To Len(MC\Code)
						LMC$ = Mid$(MC\Code,i,1)
						If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
							Tcode$ = "for ( "+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
							ExitTrue = True:TI = i
						EndIf
						If ExitTrue Then Exit
					Next
					ExitTrue = False
					For i = ti To Len(MC\code)
						If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
						If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
					Next
					
					Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
					For i = n2 To Len(MC\Code)
						If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
					Next
					MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
					MV\Declared = True
					viu = True
				EndIf
			EndIf
		Next
		If viu = False Then
			MV.methodVariable = New MethodVariable
			MV\Parent = MC\Parent
			Select True
				Case Right$(VariableName,1) = "%"
					MV\VariableType = 1:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Case Right$(VariableName,1) = "#"
					MV\VariableType = 2:MV\Name = Left$(VariableName,Len(VariableName)-1)
				Default
					MV\VariableType = 1:MV\Name = VariableName 
			End Select
			If MV\Declared &lt;&gt; True Then
				Select True
					Case MV\VariableType = 1
						Name = "int "
					Case MV\VariableType = 2
						Name = "float "
				End Select
				ExitTrue = False
				For I = StartX+1 To Len(MC\Code)
					LMC$ = Mid$(MC\Code,i,1)
					If TestKeySymbol( Mid$(MC\Code,i,1)) = True And TestNumber(Mid$(MC\Code,i,1))= False Then
						Tcode$ = "for ( "+Name+MV\Name+Mid$(MC\Code,StartX+1,i-(StartX+1))+" = "
						ExitTrue = True:TI = i
					EndIf
					If ExitTrue Then Exit
				Next
				ExitTrue = False
				For i = ti To Len(MC\code)
					If TestNumber(Mid$(MC\Code,i,1)) = True And n1 = 0 Then n1 = i
					If TestNumber(Mid$(MC\Code,i,1)) &lt;&gt; True And n1 &lt;&gt; 0 Then n2 = i:Exit
				Next
				
				Tcode$ = TCode$ + Mid$(MC\code,n1,n2-n1) + " ; " + MV\Name + " &lt;= "
				For i = n2 To Len(MC\Code)
					If Lower(Mid$(MC\Code,i,3)) = "to " Then I = i + 3:Exit
				Next
				MC\code = Tcode$+ Mid$(MC\Code,i,Len(MC\Code)-(i-1)) + " ; "+MV\Name+"++ ){" 
			EndIf
		EndIf
		MC\Term = True
	EndIf
	If Lower(MC\Code) = "next" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,3)) = "if " Or Lower(Left$(MC\Code,3)) = "if(" Then
		
		For i = 5 To Len(MC\Code)
			If Lower(Mid$(MC\Code,i,4)) = "and " Then MC\Code = Left$(MC\Code,(i-1))+"&amp;&amp; "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
			If Lower(Mid$(MC\code,i,3)) = "or " Then MC\Code = Left$(MC\Code,(i-1))+"|| "+Right$(MC\code,Len(MC\Code)-i-2):i = i + 2
			If Lower(Mid$(MC\Code,i,4)) = "xor " Then MC\Code = Left$(MC\Code,(i-1))+"^ "+Right$(MC\code,Len(MC\Code)-i-3):i = i + 3
		Next
		MC\Code = Left$(MC\Code,3) + "(" + Right$(MC\Code,Len(MC\Code)-3)
		For i = 3 To Len(MC\Code)
			If Mid$(MC\Code,i,1) = "=" And (Mid$(MC\Code,i-1,2) &lt;&gt; "&lt;=" Or Mid$(MC\Code,i-1,2) &lt;&gt; "&gt;="Or Mid$(MC\Code,i-1,2) &lt;&gt; "!=" )Then 
				MC\Code = Left$(MC\Code,i)+"="+Right$(MC\Code,Len(MC\Code)-i):i = i + 1
			Else If Mid$(MC\Code,i,2) = "&lt;&gt;" Then
				MC\Code = Left$(MC\code,i-1)+"!="+Right$(MC\Code,Len(MC\code)-(i+1))
			EndIf
			If i = Len(MC\Code) Then
				If Mid$(MC\Code,i-3,4) = "then" Then MC\Code = Left$(MC\Code,i-4)+"){":MC\Term = True
			EndIf
		Next
	EndIf
	If Lower(MC\Code) = "else" Then MC\Code = "} else {":MC\Term = True
	If Lower(Left$(MC\Code,8)) = "else if " Then MC\Code = "} else if (" + Right$(MC\Code,Len(MC\code)-8)+"){":MC\Term = True
	If Lower(MC\Code) = "endif" Or Lower(MC\Code) = "end if" Then MC\Code = "}":MC\Term = True
	If Lower(MC\Code) = "wend" Then MC\Code = "}":MC\Term = True
	If Lower(Left$(MC\Code,6)) = "while " Then MC\Code = "while (" + Right$(MC\code,Len(MC\Code)-6) +"){":MC\Term=True
	If Lower(MC\code) = "exit" Then MC\Code = "break"
	If Lower(Left$(MC\Code,6)) = "print " Or Lower(Left$(MC\Code,6)) = "print(" Then 
		MC\Code = "cout &lt;&lt; " + Right$(MC\Code,Len(MC\Code)-6)
		For i = 1 To Len(MC\Code)-1
			If Mid$(MC\Code,i,1) = "+" Then MC\Code = Left$(MC\Code,i-1)+" &lt;&lt; "+ Right$(MC\Code,Len(MC\Code)-i):i = i+3
		Next
		MC\Code = MC\Code + " &lt;&lt; endl"
	EndIf
End Function

Function CreateMethodVariable(Name$,vt%,Parent.method)
	Local MV.MethodVariable
	MV.MethodVariable = New MethodVariable
	MV\Name = Name
	MV\VariableType = vt
	MV\Parent = Parent
	MV\Declared = True
End Function

Function CreateFunctionVariable(Name$,vt%,Parent.Functions)
	Local MV.FunctionVariable
	MV.FunctionVariable = New FunctionVariable
	MV\Name = Name
	MV\VariableType = vt
	MV\Parent = Parent
	MV\Declared = True
End Function

; Remove Tabs from the OO code if any, keep track of how many there are
Function RemoveTabs()

	Local tc = 0
	
	While Left$(LineIn$,1) = Chr(9)
		tc = tc + 1
		LineIn$ = Right$(LineIn$,Len(LineIn$)-1)
	Wend
	
	Return tc
	
End Function

; Replace Tabs from the OO code so that the readablity is still present.
Function ReplaceTabs$(In$,Tabs)
	
	Local i
	
	For i = 1 To Tabs
		In$ = Chr(9) + In$
	Next
	
	Return In$
	
End Function

; Remove Spaces from the left side of a sting.
Function RemoveSpaces$(in$)
	
	While Left$(in$,1) = " "
		in$ = Right$(in$,Len(in$)-1)
	Wend
	
	Return in$
	
End Function

; Remove Spaces and tabs on the right side(does not keep track of them)
Function RemoveRightSideTabs_Spaces$(In$)
	
	While Right$(In$,1) = " " Or Right$(In$,1) = Chr(9)
		In$ = Left$(In$,Len(In$)-1)
	Wend
	
	Return In$
	
End Function

.KeyWords ;
Data 12	;amount
Data "for","next"
Data "if","end if","endif","else","elseif","else if"
Data "while","wend" ;13
Data "to","then"

Function TestKeyword(code$)
	Restore KeyWords
	Read amt
	For i = 1 To amt
		Read KW$
		kw = Lower(kw)
		If kw = Lower(code) Or kw+" " = Lower(Left$(code,Len(kw)+1)) Or kw+"(" = Lower(Left$(code,Len(kw)+1))Then ObservedKeyWord = kw :Return True
	Next
	Return False
End Function

.KeySymbols
Data 25;amount
Data ";",":","(",")","&lt;"
Data "&gt;","!","~","`","."
Data ",","{","}","[","]"
Data "=","+","-","*","/"
Data "^"," ","#","$","%"

Function TestKeySymbol(in$)
	Restore keysymbols
	Read amt
	If in = Chr(34) Then Return True
	For i = 1 To amt
		Read kw$
		If kw = in Then ObservedKeySymbol = kw:Return True
	Next
	Return False
End Function

.Numbers
Data 10;amount
Data "0","1","2","3","4","5","6","7","8","9"
Function TestNumber(in$)
	Restore numbers
	Read amt
	For i = 1 To amt
		Read kw$
		If Asc(kw) = Asc(in) Then ObservedNumber = kw:Return True
	Next
	Return False
End Function
</textarea> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
