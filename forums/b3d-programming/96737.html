<!DOCTYPE html><html lang="en" ><head ><title >Follow Interpolation?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Follow Interpolation?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Follow Interpolation?</a><br><br>
<a name="1120279"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, can someone please show a small, example code of how to make a 3D object follow a spline? And make it so the spline is drag and drop? Thank you so much! :) <br><br></td></tr></table><br>
<a name="1120791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't have exactly what you are asking for, but "spline" usually refers to hermite/Catmull-Rom interpolation, rather than linear or cosine.  I do have a function to perform the interpolation itself (below), but what you are asking for would require a significant amount of work (which is probably why nobody responded so far).  I've never seen a blitz program do what you are talking about so you may be on your own there.<br><br>Still, here's the code to find a Catmull-Rom interpolated value between the middle two points in a series of 4 points:<br><br><pre class=code>
Function catmullrom#(v0#,v1#,v2#,v3#,x#)
	v0#=0.5*(v2#-v0#)
	v3#=0.5*(v3#-v1#)
	
	;The above two lines apparently convert from regular Hermite interpolation (which isn't generally useful) to Catmull-Rom (which is).
	
	p#=2.0*(x^3.0)-3.0*(x^2.0) + 1.0
	q#=-2.0*(x^3.0)+3.0*(x^2.0)
	r#=x^3.0-2.0*(x^2.0)+x
	s#=x^3.0-x^2.0
	Return p*v1+q*v2+r*v0+s*v3
End Function
</pre><br><br>You need to feed it the values of 4 points, v0-v3, and the distance between v1-v2 that you want (x).  This should give you a nice smooth curve.  Good luck with the rest Rez! <br><br></td></tr></table><br>
<a name="1120796"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> How would I simply make an object follow a catmullrom? i should have asked it that way... Sorry guys &gt;&lt; <br><br></td></tr></table><br>
<a name="1120818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ginger Tea</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> i should have asked it that way... Sorry guys &gt;&lt; <br></div><br><br>TBH I've never heard of a Catmull-Rom* before, might have encountered it in some form or another, but not this fancy smansy name, a spline I have heard of, iir they are the vector drawing lines used in the likes of corel draw that you can curve.<br><br>In future (not just for you but others in general) I sugest posting a quick mspaint of what you want if anything is visual, like here is a curvy line that I want to follow.<br>And having a wiki link to any fancy words you or the repliers use<br><br>*Cat mulls ROM is what I read and expect someone to post a pic of a cat looking intently at a PCB <br><br></td></tr></table><br>
<a name="1120828"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOL! XD<br><br>Anyway, its EXACTLY like a spline. Infact, in a way, I do believe it IS a spline.<br><br><br>Does anyone have an example of a SPLINE-like line whos "dots" or point a or point b, whatever u want to call them, with an object that goes say.... around in a small circle, and theres like a variable to stop it at either A OR B OR C OR D OR whatever?<br><br>And be able to like drag the point?<br><br>I think it would be useful not just for me, but for the community as a whole, because I think if beginners learn the HARDER stuff FIRST, they are MORE LIKELY to succeed when it comes down to that point, no pun intended. :)<br><br><br>If you are able to make it so u can drag a point and the spline will curve to the correct value, I MAY be able to make it write out each spline's position and what not, and make it so that everyone can create a sort of spline "waypoint" if u know what i mean, to use in their game for ANY OBJECT OF their choosing :)<br><br>Thanks! =D <br><br></td></tr></table><br>
<a name="1120874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Beginners shouldn't learn the hard stuff first. They are more likely to just piece code together and not understand it, then ask questions and get answers they still don't understand, then just ask someone to code it for them. Completely defeats the point.<br><br>I don't entirely know how splines work and the interpolation between them. There definitely is examples in the code archives. I got some good code from there a couple of years back. Actually moving the points is the easy bit. It's just a set of co-ordinates. You asking essentially for someone to code a spline editor.<br><br>Anyways, you'll find the code you need to traverse a spline in the archives somewhere. <br><br></td></tr></table><br>
<a name="1120909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with Ross C.<br><br>For the movement part my first approach would be using a custom type called WayPoint or whatever.  Each instance would have a pivot positioned along the spline.  Then just iterate the type and update the location of your entity.  Then PointEntity it to the next pivot.<br><br>For this to work you would need to know in advance the distance along the line it will move each update.  Of course if this is interactive with the player then this approach won't work, since you won't have that information in advance.<br><br>So the long and the short is: There are too many unanswered questions to really be able to design the system for you, let alone code it.<br><br>If you describe for us what kind of game it is and what the game element(s) involved really need to do maybe we can be more help.<br><br>For example if the entity needs to smoothly move in all three dimensions and be able to curve back on itself, even my code above won't help you because it assumes even spacing in one dimension (it's a traditional f(x) function). <br><br></td></tr></table><br>
<a name="1120915"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok guys. I need some help with this. I've gotten a demo I found in the code archives to allow for dragging of single waypoints... PROBLEM is the "dots" as well as the path that the entity moves on is NOT parented to the selected mouse waypoint... So basically u can move a waypoint. but the objects wont automatically adjust to the new coordinates of the bezier path :(<br><br>I could REALLY use some help with this please and thank you. I added drag and drop to the waypoint, so u can see im at least TRYING :)<br><br>Here's the code: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global Path_x#, Path_y#, Path_z#

Type tWayPoint
	
	Field PathId	; with path it belongs
	Field Entity	; a pivot with position and orientation
	Field cp1		; control point1
	Field cp2		; control point2
	Field nSteps	; number of interpolated steps to the next waypoint
	Field CurrStep	; current step interpolated (from 1 to nSteps)
	Field Pitch#, Yaw#, Roll#
	
	
End Type

Type tPath
	
	Field PathId		;id 
	Field pFirst		;handle to the first on this list
	Field pLast			;same for last
	
	Field WPCount		;quantity of waypoints on this path
	Field CurrentWP		;handlw of the current waypoint, in whic we are
	Field CurrPos		;pivot wiht pos and orientation of the step in the path
						;acrodingly with CurrentStep of the CurrentWP
	
End Type



;wp functions

Function NextWP.tWayPoint(wp.tWayPoint)
	wpTemp.tWayPoint = After wp
	If wpTemp = Null
		wpTemp = FirstWP()
	EndIf
	Return wpTemp
End Function

Function PrevWP.tWayPoint(wp.tWayPoint)
	wpTemp.tWayPoint = Before wp
	If wpTemp = Null
		wpTemp = LastWP()
	EndIf
	Return wpTemp
End Function

Function FirstWP.tWayPoint()
	Return First tWayPoint
End Function


Function LastWP.tWayPoint()
	Return Last tWayPoint
End Function

Function NewWP.tWayPoint(Path.tPath, x#, y#, z#, nSteps=100, pitch#=0, yaw#=0, roll#=0)
	
	wp.tWayPoint = New tWayPoint
	
	wp\PathID = Path\PathId
	
	Path\WPCount = Path\WPCount+1
	If Path\pFirst=0 Then
		Path\pFirst = Handle(wp)
		Path\CurrentWP = Path\pFirst
		PositionEntity Path\CurrPos,x,y,z
		RotateEntity Path\CurrPos,pitch,yaw,roll
	End If
	Path\pLast = Handle(wp)
	wp\Entity = CreatePivot()
	wp\cp1 = CreatePivot(wp\Entity)
	wp\cp2 = CreatePivot(wp\Entity)
	PositionEntity wp\Entity,x,y,z
	wp\nSteps = nSteps
	wp\CurrStep = 0
	wp\pitch = pitch
	wp\yaw = yaw
	wp\roll = roll
	
	Return wp
	
End Function

;path functions


Function PathNextWP.tWayPoint(Path.tPath)
	Local wp.tWayPoint
	If Path\CurrentWP = Path\pLast Then
		Path\CurrentWP = Path\pFirst
	Else
		wp = After PathCurrWP(Path)
		Path\CurrentWP = Handle(wp)
	End If
	Return PathCurrWP(Path)
End Function

Function PathPrevWP.tWayPoint(Path.tPath)
	Local wp.tWayPoint
	If Path\CurrentWP = Path\pFirst Then
		Path\CurrentWP = Path\pLast
	Else
		wp = Before PathCurrWP(Path)
		Path\CurrentWP = Handle(wp)
	End If
	Return PathCurrWP(Path)
End Function

Function PathFirstWP.tWayPoint(Path.tPath)
	Path\CurrentWP = Path\pFirst
	Return PathCurrWP(Path)
End Function

Function PathLastWP.tWayPoint(Path.tPath)
	Path\CurrentWP = Path\pLast
	Return PathCurrWP(Path)
End Function

Function PathCurrWP.tWayPoint(Path.tPath)
	Return Object.tWayPoint(Path\CurrentWP)
End Function

Function NewPath.tPath()
	
	Path.tPath = New tPath
	Path\PathId = Handle(Path)
	Path\CurrPos = CreatePivot()
	
	Return Path
	
End Function


Function InitPath(Path.tPath, Save=False)
	
	;precalculates 2 control points for each WayPoint
	;they are needed for the InterpolatePos function based on a Bezier curve
	
	If Save Then
		CurrentWP = Path\CurrentWP
	End If
	
	CurrWP.tWayPoint = PathFirstWP(Path)
	
	For i=1 To Path\WPCount+1
		
		PrevWP.tWayPoint = PathPrevWP(Path)	;previous	-1
		CurrWP.tWayPoint = PathNextWP(Path)	;actual		 0
		NextWP.tWayPoint = PathNextWP(Path)	;next		+1, so in each loop advance one element
		
		If Save Then
			If Handle(CurrWP)&lt;&gt;Path\CurrentWP Then CurrWP\CurrStep=0
		Else
			CurrWP\CurrStep = 0
		End If
		
		NextAux = CopyEntity(NextWP\Entity)
		PrevAux = CopyEntity(PrevWP\Entity)
		PointEntity CurrWP\Entity,NextAux
		PointEntity PrevAux,NextAux
		
		RotateEntity CurrWP\cp1, EntityPitch(PrevAux,True), EntityYaw(PrevAux,True), EntityRoll(PrevAux,True),True
		Dist# = D3D(CurrWP\Entity,NextAux)
		PositionEntity CurrWP\cp1,0,0,0
		MoveEntity CurrWP\cp1,0,0,-Dist/3.0
		PositionEntity PrevWP\cp2, EntityX(CurrWP\cp1,True), EntityY(CurrWP\cp1,True), EntityZ(CurrWP\cp1,True), True
		MoveEntity CurrWP\cp1,0,0,2*Dist/3
		FreeEntity NextAux
		FreeEntity PrevAux
		
	Next
	
	If Save Then
		Path\CurrentWP = CurrentWP
	Else
		wp.tWayPoint = PathFirstWP(Path)
		PositionEntity Path\CurrPos, EntityX(wp\Entity,True), EntityY(wp\Entity,True), EntityY(wp\Entity,True)
	End If
	
	
End Function

Function InitPaths(Save=True)
	
	For Path.tPath = Each tPath
		
		InitPath(Path,Save)
		
	Next
End Function

Function PathNextPos(Path.tPath, SignalEnd=False)
	
	Local CurrWP.tWayPoint, NextWP.tWayPoint
	
	CurrWP = PathCurrWP(Path)
	
	If CurrWP\CurrStep=CurrWP\nSteps Then
		CurrWP\CurrStep=0
		CurrWP = PathNextWP(Path)
		If Path\CurrentWP = Path\pFirst Then
			If SignalEnd Then Stop=True
		End If
	End If
	
	If Not(Stop) Then
		
		NextWP = PathNextWP(Path)
		CurrWP = PathPrevWP(Path)
		
		t# = (1.0*(Float(CurrWP\CurrStep))) / (Float(CurrWP\nSteps))
		
		InterpolatePos( t, CurrWP\Entity, CurrWP\cp1, CurrWP\cp2, NextWP\Entity)
		
		Pitch# = Interpolate(t,CurrWP\Pitch,NextWP\Pitch)
		Yaw#   = Interpolate(t,CurrWP\Yaw  ,NextWP\Yaw  )
		Roll#  = Interpolate(t,CurrWP\Roll ,NextWP\Roll )
		
		PositionEntity Path\CurrPos, Path_x, Path_y, Path_z
		RotateEntity Path\CurrPos, Pitch, Yaw, Roll
		
		CurrWP\CurrStep = CurrWP\CurrStep + 1
		
		
		Return Path\CurrPos
	Else
		Return -1
	End If
	
End Function

Function PathCurrPos(Path.tPath)
	Return Path\CurrPos
End Function

Function PathsNextPos(SignalEnd=False)
	For Path.tPath = Each tPath
		PathNextPos(Path,SignalEnd)
	Next
End Function

Function Interpolate#(t#, v1#, v2#)
	Return v1 + (v2-v1)*t
End Function

Function InterpolatePos( t#, p1, p2, p3, p4)
	
	x1# = EntityX(p1,True)
	y1# = EntityY(p1,True)
	z1# = EntityZ(p1,True)
	
	x2# = EntityX(p2,True)
	y2# = EntityY(p2,True)
	z2# = EntityZ(p2,True)
	
	x3# = EntityX(p3,True)
	y3# = EntityY(p3,True)
	z3# = EntityZ(p3,True)
	
	x4# = EntityX(p4,True)
	y4# = EntityY(p4,True)
	z4# = EntityZ(p4,True)
	
	Path_x = x1 * (1-t)^3 + 3 * x2 * (1-t)^2 * t + 3 * x3 * (1-t) * t^2 + x4 * t^3 
	Path_y = y1 * (1-t)^3 + 3 * y2 * (1-t)^2 * t + 3 * y3 * (1-t) * t^2 + y4 * t^3 
	Path_z = z1 * (1-t)^3 + 3 * z2 * (1-t)^2 * t + 3 * z3 * (1-t) * t^2 + z4 * t^3 
	
	
End Function


Function PlotPath(camera, Path.tPath)
	
	SaveCurrent = Path\CurrentWP
	
	Color 200,200,200
	
	LockBuffer()
	
	CurrWP.tWayPoint = PathFirstWP(Path)
	
	For wp=1 To Path\WPCount
		
		CurrWP.tWayPoint = PathCurrWP(Path)
		NextWP.tWayPoint = PathNextWP(Path)
		
		t# = 1.0 / CurrWP\nSteps
		tinc# = t	
		
		For i=1 To CurrWP\nSteps
			
			InterpolatePos( t, CurrWP\Entity, CurrWP\cp1, CurrWP\cp2, NextWP\Entity)
			
			CameraProject( camera, Path_x, Path_y, Path_z)
			x=ProjectedX()
			y=ProjectedY()
			If x&gt;0 And x&lt;GraphicsWidth() And y&gt;0 And y&lt;GraphicsHeight()
				WritePixelFast ProjectedX(), ProjectedY(), $FFFFFFFF
			End If
			t = t + tinc
			
		Next
		
	Next
	
	UnlockBuffer()
	
	Path\CurrentWP = SaveCurrent
	
End Function

Function PlotPaths(Camera)
	For Path.tPath = Each tPath
		PlotPath(Camera, Path)
	Next
End Function

Function D3D#(obj1, obj2)
	x# = EntityX(obj1) - EntityX(obj2)
	y# = EntityY(obj1) - EntityY(obj2)
	z# = EntityZ(obj1) - EntityZ(obj2)
	Return Sqr(x*x + y*y + z*z)
End Function

Function Example()
	;
	;	Path following system
	;
	;	
	
	Graphics3D 800,600,0,2
	SetBuffer BackBuffer()
	
	pivotCam=CreatePivot()
	camera = CreateCamera(pivotcam)
	light = CreateLight(2)
	PositionEntity light,20,10,-10
	LightRange light,50
	PositionEntity camera,0,0,-10
	
	Viajero = CreateCone()	;viajero : voyager
	RotateMesh Viajero,90,0,0
	EntityColor Viajero,255,255,0
	Temp = CreateCube()
	ScaleEntity Temp,2,.2,.5
	EntityColor Temp,255,0,0
	EntityParent Temp,Viajero
	EntityPickMode Viajero,2,1
	EntityPickMode temp,2,1
	
	
	; Usage
	;
	;Create some paths	: 
	;						Path_N.tPaht = NewPath()
	;
	
	;Add WayPoints 		:
	;						WP.tWayPoint = NewWP(Path_n.tPath, x#, y#, z#, steps, pitch#, yaw#, roll#)	
	;
	;
	
	; define at least 3 points: 
	;		x,y,z, pitch, yaw, roll	(position and orientation of the waypoint)
	;		Steps are the number of interpolations the system will do to reach the next WayPoint
	;
	;
	
	;Initialize the path:
	;					InitPath(Path_n.tPath), or InitPaths() for init all defined path's
	;
	;InitPath precalculate 2 control points for each waypoint defined on the path, they are needed for the InterpolatePos function
	;wich is based on a Bezier curve.
	
	;
	;To move to the next position: PathNextPos(Path_N), or PathsNextPos() for all
	;
	;this function returns the handle to a pivot that has the newly calculated position and orientation
	;
	
	
	;in this demo:
	;
	;
	;Path1 and Path2 are identical: defined by the same waypoints
	;Path3 and Path4 are identical
	;
	;in the demo, i use Path1 and Path2 for the same object. Path2 is one step ahead Path1 so, we know the next position
	;and force the object to point to the next step.
	;
	;Path3 and Path4 has associated diferent objects and one of them is automatically stepped, the other is stepped under
	;user control (pressing the "A" key)
	;
	
	Restore WayPointDefinition
	
	
	Path1.tPath = NewPath()		;create Path1
	
	EntityParent viajero,Path1\CurrPos
	
	For nPoint = 1 To 4			;define some waypoints
		Read  x# 
		Read  y# 
		Read  z#
		Read Steps
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path1, x,y,z, steps, pitch, yaw, roll)
			;create a visible cube for each way point
		temp = CreateCube(wp\entity)
		PositionEntity temp,0,0,0
		RotateEntity temp,0,0,0
		ScaleEntity temp,.1,.1,.1
		EntityColor temp,255,255,0
		EntityPickMode temp,2,1
		
	Next	
	
	Path3.tPath = NewPath()		;create Path3 from a diferent set of points
	temp = CreateCube(Path3\CurrPos)
	ScaleEntity temp,.3,.3,.3
	EntityColor temp,0,0,255
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path3, x,y,z, pasos, pitch, yaw, roll)
		
			;create a visible cube for each way point
		temp = CreateCube(wp\entity)
		PositionEntity temp,0,0,0
		RotateEntity temp,0,0,0
		ScaleEntity temp,.1,.1,.1
		EntityColor temp,0, 255,255
		EntityPickMode temp, 2, 1
		
		
	Next
	
	Restore WayPointDefinition	;create 2 additional path from the same set of points
	
	Path2.tPath = NewPath()
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path2, x,y,z, pasos, pitch, yaw, roll)
		
	Next	
	
	Path4.tPath = NewPath()
	temp = CreateCube(Path4\CurrPos)
	ScaleEntity temp,.3,.3,.3
	EntityColor temp,0,255,0
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path4, x,y,z, pasos, pitch, yaw, roll)
		
	Next
	
	;at this moment, we have 4 paths, Path1 and Path2 are clones of each other and se same for Path3 and Path4
	
	
	;Initialize each path
	InitPaths()	;after initialization all paths are on The first waypoint and in the step 0
	
	
	Piv1 = PathCurrPos(Path1)	;fist position of Path1
	Piv2 = PathNextPos(Path2)	;second position of Path2
	PointEntity Piv1,Piv2,EntityRoll(piv1)	;point the Voyager to the next step in the path
	
	ShowPaths = True	;controls the plot of the interpolated steps
	
	
	
	
	Repeat
		
		
		mx = MouseX()
		my = MouseY()
		
		
		
		If incameramode = 0
			
			
			
			oldmypos# = mypos#
			
			
			
							;speed# = 0.05
			
			
			
							;If speed# &gt; 10.0 Then speed# = 10.0
			
			
			
							;If speed# &lt; -10.0 Then speed# = -10.0
			
			
			
							;mouse_speed# = MouseSpeed ( speed# )
			
			
			
			If (KeyDown(29) Or KeyDown(157) And KeyHit(19)) Then picked = 0 : whichmode = 1-whichmode
			
			
			
			If whichmode = 0 Then which_mode$ = "Rotation Mode"
			
			
			
			If whichmode = 1 Then which_mode$ = "Position Mode"
			
			
			
			If whichmode &gt; 1 Then whichmode = 0
			
				
				
				If MouseDown(1)
					If picked = False
						picked = Camera_Pick(camera, mX, mY, 150.0, 0.1, 1000.0)
						If picked&lt;&gt;0 
							EntityInView(picked, camera)
							If picked
								wire2 = 1
							EndIf
						Else
							picked = 0
						EndIf
					Else
						PositionEntityFrom2D (camera, picked, mX, mY, 0, 1)
					EndIf
				Else
					wire2 = 0
					picked = False
				EndIf
				
				
				
			EndIf
			
			
		
		If KeyDown(203) Then TurnEntity pivotCam, 0,+.5,0
		If KeyDown(205) Then TurnEntity pivotCam, 0,-.5,0
		If KeyDown(30)	Then PathNextPos(Path4)	;only stepped if A key is held down
		
		If KeyHit(57) Then
			ShowPaths = Not(ShowPaths)
		End If
		
		RenderWorld
		
		If ShowPaths Then
			PlotPath(Camera,Path1)
			PlotPath(Camera,Path3)
		End If
		
		;the path system not only interpolate position from one way point to the next via a bezier curve
		;plus, it interpolate pitch, yaw and roll from WayPoint form the next lineary.
		
		;in this demo, i use the Roll interpolated by the system but i prefere to do the voyager to point to the next waypoint.
		Piv1 = PathNextPos(Path1)	;both path are equal but, Path2 is one step ahead of Path1
		Piv2 = PathNextPos(Path2)	;used to force the entity to Point to the next step
		R# = EntityRoll(Piv1)		;the calculated roll is saved and used to stablish the en roll of the object
		PointEntity Piv1,Piv2
		RotateEntity Piv1, EntityPitch(Piv1), EntityYaw(Piv1), R
		
		;for the boxes, the system use the pitch, yaw and roll interpolated by the system		
		temp = PathNextPos(Path3,True)
		If temp=-1 Then
			DebugLog "end of Path3"
		End If
		
		Text 10,10,"Space to show/hide paths"
		Text 10,30,"&lt;- -&gt; tu turn camera"
		Text 10,50,"A to step Path4"
		Text 10,70,TrisRendered()
		Text 10,90,"picked: "+pickobj
		
		Flip
		
	Until KeyHit(1)
	
	
End Function

Example()

; -----------------------------------------------------------------------------
; PositionEntityFrom2D ()
; -----------------------------------------------------------------------------
; Positions an entity at 3D x/y co-ords translated from given 2D co-ords, at
; specified z position. Useful for positioning an entity at mouse x/y position,
; at its current z depth...
; -----------------------------------------------------------------------------
; PARAMETERS...
; -----------------------------------------------------------------------------
; REQUIRED...
; -----------------------------------------------------------------------------
; entity is the entity to be positioned.
; x2d is the 2D x position you want translated to 3D.
; y2d is the 2D y position you want translated to 3D.
; z3d is the * 3D * z depth at which the translation should occur.
; -----------------------------------------------------------------------------
; OPTIONAL...
; -----------------------------------------------------------------------------
; positionGlobal defaults to false, as per PositionEntity.
; camZoom must be set manually if you've used CameraZoom to change it...
; ----------------------------------------------------------------------------- 

Function MouseSpeed ( speed# )
	Local mXs #=MouseXSpeed ()
	Local mYs #=MouseYSpeed ()
	
	mX = mX + mXs * speed
	mY = mY + mYs * speed
	
	MoveMouse GraphicsWidth ()* .5 , GraphicsHeight ()* .5
	
	mX = Min ( mX , GraphicsWidth ())
	mX = Max ( mX , 0 )
	mY = Min ( mY , GraphicsHeight ())
	mY = Max ( mY , 0 )
	
	Return speed#
	
End Function

Function Max ( a #, b#)
	If a &gt; b Then Return a Else Return b
End Function

Function Min ( a #,b#)
	If a &lt; b Then Return a Else Return b
End Function 

Function CorrectOffset(mesh,offx#=0,offy#=0,offz#=0)
	Local x#,y#,z#, surf,s,v, minx#=100000,miny#=100000,minz#=100000
	Local mw#=MeshWidth(mesh), mh#=MeshHeight(mesh), md#=MeshDepth(mesh)
	For s=1 To CountSurfaces(mesh)
		surf=GetSurface(mesh,s)
		For v=0 To CountVertices(surf)-1
			x=VertexX(surf,v)
			y=VertexY(surf,v)
			z=VertexZ(surf,v)
			If x&lt;minx Then minx=x
			If y&lt;miny Then miny=y
			If z&lt;minz Then minz=z
		Next
	Next
	TFormPoint minx+mw*0.5-offx,miny+mh*0.5-offy,minz+md*0.5-offz,mesh,GetParent(mesh)
	TranslateEntity mesh,TFormedX(),TFormedY(),TFormedZ()
	FitMesh mesh,-mw*0.5+offx,-mh*0.5+offy,-md*0.5+offz,mw,mh,md
End Function



Function Camera_Pick(cam, x#, y#, distance#,onear#=0.1,ofar#=1000.0)
	CameraRange cam,onear,distance
	r = CameraPick(cam, x#, y#)
	CameraRange cam,onear,ofar
	Return r
End Function



Function PositionEntityFrom2D (usecam, entity, x2d#, y2d#, positionGlobal = 0, camZoom# = 1)
	gw = GraphicsWidth ()
	gh = GraphicsHeight ()
	x# = -((gw / 2) - x2d)
	y# = (gh / 2) - y2d
	parent = GetParent (entity)
	EntityParent entity, usecam
	z3d# = Abs (EntityZ (entity))
	div# = (gw / (2 / camZoom)) / z3d
	PositionEntity entity, x / div, y / div, z3d, positionGlobal
	EntityParent entity, parent
End Function


Function GlobalizeVertex (mesh, surface, index)
	vx# = VertexX (surface, index)
	vy# = VertexY (surface, index)
	vz# = VertexZ (surface, index)
	TFormPoint (vx, vy, vz, mesh, 0)
End Function

Function VertexGlobalX# ()
	Return TFormedX ()
End Function

Function VertexGlobalY# ()
	Return TFormedY ()
End Function

Function VertexGlobalZ# ()
	Return TFormedZ ()
End Function

Function VertexProject (usecam, mesh, surface, index)
	GlobalizeVertex (mesh, surface, index)
	CameraProject usecam, VertexGlobalX (), VertexGlobalY (), VertexGlobalZ ()
End Function

Function VertexScreenX ()
	Return ProjectedX ()
End Function

Function VertexScreenY ()
	Return ProjectedY ()
End Function

Function RenderWireFrame( Camera, MeshEntity )
	
	Local SC = CountSurfaces( MeshEntity )
	Local Vert1=0, C1X#, C1Y#, C1Z#
	Local Vert2=0, C2X#, C2Y#, C2Z#
	Local Vert3=0, C3X#, C3Y#, C3Z#
	
	For CS = 1 To SC
		GS = GetSurface( MeshEntity, CS )
		For CT =0 To CountTriangles( GS )-1
			Vert1 = TriangleVertex( GS, CT, 0 )
			Vert2 = TriangleVertex( GS, CT, 1 )
			Vert3 = TriangleVertex( GS, CT, 2 )
			
			TFormPoint VertexX#( GS, Vert1 ), VertexY#( GS, Vert1 ), VertexZ#( GS, Vert1 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C1X# = ProjectedX#()
			C1Y# = ProjectedY#()
			C1Z# = ProjectedZ#()
			TFormPoint VertexX#( GS, Vert2 ), VertexY#( GS, Vert2 ), VertexZ#( GS, Vert2 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C2X# = ProjectedX#()
			C2Y# = ProjectedY#()
			C2Z# = ProjectedZ#()
			TFormPoint VertexX#( GS, Vert3 ), VertexY#( GS, Vert3 ), VertexZ#( GS, Vert3 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C3X# = ProjectedX#()
			C3Y# = ProjectedY#()
			C3Z# = ProjectedZ#()
			
			Color 255, 0, 0
			
			Line C1X#, C1Y#, C2X#, C2Y#
			Line C2X#, C2Y#, C3X#, C3Y#
			Line C3X#, C3Y#, C1X#, C1Y#
		Next
	Next
	
End Function

; Made possible thanks to SSwift and <a href="http://www.sbdev.pwp.blueyonder.co.uk/tut4.htm" target="_blank">http://www.sbdev.pwp.blueyonder.co.uk/tut4.htm</a> !

Function TriMesh (usecam, turnoninviso=False, mesh, r1, g1, b1)
	
	
	
	If EntityInView (mesh, usecam)	
		
		For s = 1 To CountSurfaces (mesh)
			
			surf = GetSurface (mesh, s)
			
			; Parse each triangle in mesh...
			
			For t = 0 To CountTriangles (surf) - 1
				
				; Get triangle's vertice positions... presumably these are
				; in anti-clockwise order (since it appears to work :)
				
				v0 = TriangleVertex (surf, t, 0)
				v1 = TriangleVertex (surf, t, 1)
				v2 = TriangleVertex (surf, t, 2)
				
				If BackFacing (surf, v0, v1, v2, mesh, usecam)
					
					; Get 2D position for each point of triangle...
					
					VertexProject (usecam, mesh, surf, v0)
					vx0 = VertexScreenX ()
					vy0 = VertexScreenY ()
					
					VertexProject (usecam, mesh, surf, v1)
					vx1 = VertexScreenX ()
					vy1 = VertexScreenY ()
					
					VertexProject (usecam, mesh, surf, v2)
					vx2 = VertexScreenX ()
					vy2 = VertexScreenY ()
					
					
					; Draw triangle...
					
					Color r1, g1, b1
					
					Line vx0, vy0, vx1, vy1
					Line vx1, vy1, vx2, vy2
					Line vx2, vy2, vx0, vy0	
					
					Color 255, 255, 255
					
					
					
					If turnoninviso = 1 Then EntityAlpha mesh, 0
					
					
					
				EndIf
				
			Next
			
		Next		
		
	EndIf	
	
End Function

Function BackFacing (surf, v0, v1, v2, mesh, camera)
	
    ;vertex position
    x0# = VertexX (surf, v0): y0# = VertexY (surf, v0): z0# = VertexZ (surf, v0)
    x1# = VertexX (surf, v1): y1# = VertexY (surf, v1): z1# = VertexZ (surf, v1)
    x2# = VertexX (surf, v2): y2# = VertexY (surf, v2): z2# = VertexZ (surf, v2)
    
    ;deltas
    dx1# = x1 - x0: dy1# = y1 - y0: dz1# = z1 - z0
    dx2# = x2 - x0: dy2# = y2 - y0: dz2# = z2 - z0
	
    ;cross product
    cx# = dy1 * dz2 - dy2 * dz1
    cy# = dz1 * dx2 - dz2 * dx1
    cz# = dx1 * dy2 - dx2 * dy1
    
    ;normalize...
    sz# = Sqr (cx * cx + cy * cy + cz * cz)
    cx = cx / sz: cy = cy / sz: cz = cz / sz
    
    ;plane offset
    dt# = -(cx * x0 + cy * y0 + cz * z0)
    
    ;tranform eye to mesh coords
    TFormPoint 0, 0, 0, camera, mesh
    
    Return TFormedX () * cx + TFormedY () * cy + TFormedZ () * cz + dt &gt; 0
    
End Function




Function Delta_Time()
	NewTime = MilliSecs()	
	dt = Float (NewTime - OldTime)/1000
	OldTime = NewTime
	TotalTime = TotalTime + dt
End Function



;fps calc
Function FPS$()
    framecounter_counter=framecounter_counter+1
    If framecounter_time=0 Then framecounter_time=MilliSecs()
    If framecounter_time+1001&lt;MilliSecs() Then
        framecounter_framerate=framecounter_counter
		framecounter_counter=0
        framecounter_time=MilliSecs()
	EndIf
	zsemi$="FPS: "+framecounter_framerate
	Return zsemi$
End Function

End

.WayPointDefinition
;Path 1
Data -3, 0, 0, 100, 0, 0,  0
Data -1, 2,-5, 150, 0, 0, 50
Data  1, 1, 0, 100, 0, 0,  0
Data  3,-2,4, 100, 0, 0,-30
;Path 2
Data -3, 0, 4,  50,  60,   0,   0
Data -1, 3, 5, 100,   0,   0,  60
Data  1, 1, 6,  50,   0, -50,   0
Data  3,-3, 2, 100, -20,   0, -60</textarea><br><br><br>Thanks! :) <br><br></td></tr></table><br>
<a name="1120927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Rez, do you have an e-mail? <br><br></td></tr></table><br>
<a name="1120939"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I do, Kryzon. Why do u ask? :) <br><br></td></tr></table><br>
<a name="1120998"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon's email address is in his profile, so send him one if you don't want to give out your email here.  He may want to tell you not to ask for a "small example" of a complex piece of software to be coded for you, or maybe he wants to tell you to credit Charrua's work above.  :-)<br><br>My thougths on the problem:<br><br>It's not about "parenting" the dots to the waypoint because the relative positions will change.  <br><br>Each time the user moves a waypoint you will probably have to delete and recreate the entire path.  That is because the curve between two points depends on more than just those two points.  So just create a new set of waypoints with the new waypoint position and create a new path based on those waypoints, then delete the old path/waypoints, and move any objects to the new path.  This is likely to be reasonably quick, unless you are dealing with huge paths.<br><br>Also, this is probably easy since you can just call Charrua's existing functions (I haven't looked at them myself to confirm this, but dang it sounded good, didn't it?).<br><br>The question then is, Do you want to update the path while the user is dragging the waypoint, or just have it snap to the new position when the waypoint is released?  You could would try it both ways and see how it runs.  Good luck. <br><br></td></tr></table><br>
<a name="1121036"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi, i found a post about that subject with a sample code that whould help:<br><br><a href="http://blitzbasic.com/Community/posts.php?topic=85377#965678" target="_blank">http://blitzbasic.com/Community/posts.php?topic=85377#965678</a><br><br>following is the code:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,0,6
SetBuffer BackBuffer()
camera = CreateCamera()
light = CreateLight()
PositionEntity camera,0,0,-5

Dim Points(3)
Dim Interpolated(100)

Restore puntos
For i=0 To 3
	points(i) = CreateSphere()
	ScaleEntity points(i),.2,.2,.2
	EntityColor points(i),255,128,128
	Read  x# 
	Read  y# 
	Read  z# 
	PositionEntity points(i),x,y,z
Next

For i=0 To 99
	interpolated(i) = CreateSphere()
	ScaleEntity interpolated(i),.05,.05,.05
	EntityColor interpolated(i),128,128,255
Next

Global current = 0
EntityColor points(0),128,255,128

Global modification = True
Global bezier_x#
Global bezier_y#
Global bezier_z#

Repeat

	If Modification Then Reposition
	
	;TAB to chance Current selected Point
	If KeyHit(15) Then	
		EntityColor points(current),255,128,128
		current = current + 1
		If current = 4 Then current=0
		EntityColor points(current),128,255,128
	End If
	
	;Up Down, Left, Right to move the selected point
	
	If KeyDown(203) Then 
		TranslateEntity points(current), -.01,  0, 0
		modification=True
	End If

	If KeyDown(205) Then 
		TranslateEntity points(current),  .01,  0, 0
		modification=True
	End If

	If KeyDown(200) Then
		TranslateEntity points(current),   0, .01, 0
		modification=True
	End If
		
	If KeyDown(208) Then 
		TranslateEntity points(current),   0, -.01, 0
		modification=True
	End If
	

	RenderWorld
	
	Text 10, 10, "TAB to change selected point (Green one)"
	Text 10, 30, "Cursor keys to translate it"
	
	For i=0 To 3
		CameraProject camera,EntityX(points(i)),EntityY(points(i)),EntityZ(points(i))
		Text ProjectedX()+20,ProjectedY()+20,i
	Next
	
	Flip

Until KeyHit(1)

Function Reposition()
	Local t#
	For i=1 To 100
		t = Float(i/100.0)
		move_interpolate(t,points(0),points(1),points(2),points(3))
		PositionEntity interpolated(i-1),bezier_x,bezier_y,bezier_z
	Next
	modification = False
End Function

.puntos
Data -3,0,0
Data -1,0,0
Data 1,0,0
Data 3,0,0

Function move_interpolate( t#, p1,p2,p3,p4)

	x1# = EntityX(p1,True)
	y1# = EntityY(p1,True)
	z1# = EntityZ(p1,True)
	
	x2# = EntityX(p2,True)
	y2# = EntityY(p2,True)
	z2# = EntityZ(p2,True)

	x3# = EntityX(p3,True)
	y3# = EntityY(p3,True)
	z3# = EntityZ(p3,True)
	
	x4# = EntityX(p4,True)
	y4# = EntityY(p4,True)
	z4# = EntityZ(p4,True)
	
	bezier_x = x1 * (1-t)^3 + 3 * x2 * (1-t)^2 * t + 3 * x3 * (1-t) * t^2 + x4 * t^3 
	bezier_y = y1 * (1-t)^3 + 3 * y2 * (1-t)^2 * t + 3 * y3 * (1-t) * t^2 + y4 * t^3 
	bezier_z = z1 * (1-t)^3 + 3 * z2 * (1-t)^2 * t + 3 * z3 * (1-t) * t^2 + z4 * t^3 
	
	;DebugLog t+", "+bezier_x+", "+bezier_y+", "+bezier_z
	
End Function

</textarea><br><br>basically any changes to one of the 4 poins derives y recalculate the intermediate points. The sample uses 3D objects as dots of the path, to visually see the effect.<br><br>Juan <br><br></td></tr></table><br>
<a name="1121037"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Charrua, I modified your code, alls it needs is to get the dots to follow the waypoints depending on where each waypoint is dragged. and have the object that is ALREADY following the bezier waypoints to re-calculate its coordinates automatically when the user lets go of the mouse and has dragged the waypoint :)<br><br>If you could help, I would appreciate that! :)<br><br>And btw, sorry for not crediting u Charrua, I was in a hurry. Credit goes to Charrua for the creation of the Bezier Waypoint system! :) Thank you, Charrua! :) <br><br></td></tr></table><br>
<a name="1121047"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wanted to share some ideas with you Rez, but your e-mail is not in your profile. So if you could, please send something to mine so I get your address, or untick the "Hide e-mail address" option.<br><br>Bye! <br><br></td></tr></table><br>
<a name="1121050"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sure, Kryzon! Not a problem! I will email u :) <br><br></td></tr></table><br>
<a name="1121072"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> the interpolation part is resolved, you have to ask for "How to Drag an Object in 3D space with the mouse" or something similar.<br><br>see the following from the code archives, it was one of my first readings about interpolation:<br><br><a href="http://www.blitzbasic.co.nz/codearcs/codearcs.php?code=843" target="_blank">http://www.blitzbasic.co.nz/codearcs/codearcs.php?code=843</a><br><br>Juan <br><br></td></tr></table><br>
<a name="1121077"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Charrua! :) Thats CLOSE. but for some reason, the waypoint wont stay ON the line as the line follows the waypoint. plus. i need this to be in 3D. the CLOSEST thing I have right now to what I need, is the awesome Bezier Object follower program u created :) If u could modify THAT to do EXACTLY what it does in the 2d version that u just posted, and make the object follow the newly dragged bezier coordinates, then this case will be SOLVED! :)<br><br>Thanks once again, Charrua, for ALL of your help! Thank you ALL for all of your help! :)<br><br>Kryzon, check ur email. I emailed u :) <br><br></td></tr></table><br>
<a name="1121094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> rez<br>there are 4 points, 2 are for control (most of the time outside the path) and 2 (first and end) wich the path pass through.<br><br>The path following system i wrote, creates the 2 control points based on the waypoints, so they are hidden for you, making it easy for any one wich wants to use this kind of interpolation.<br><br>the 2d version, simply use 2 keys for x and 2 keys for y, you only have to add 2 more keys for z and it is in 3d. Add some turn arround to the camera and you'll see that it is completely 3D.<br><br>juan <br><br></td></tr></table><br>
<a name="1121097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> here it is!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,0,6
SetBuffer BackBuffer()
CameraPiv = CreatePivot()
Camera = CreateCamera(CameraPiv)
Light = CreateLight()
MoveEntity Camera,0,0,-5
;PositionEntity camera,0,0,-5

Dim Points(3)
Dim Interpolated(100)

Restore puntos
For i=0 To 3
	points(i) = CreateSphere()
	ScaleEntity points(i),.2,.2,.2
	EntityColor points(i),255,128,128
	Read  x# 
	Read  y# 
	Read  z# 
	PositionEntity points(i),x,y,z
Next

For i=0 To 99
	interpolated(i) = CreateSphere()
	ScaleEntity interpolated(i),.05,.05,.05
	EntityColor interpolated(i),128,128,255
Next

Global current = 0
EntityColor points(0),128,255,128

Global modification = True
Global bezier_x#
Global bezier_y#
Global bezier_z#

Repeat

	If Modification Then Reposition
	
	;TAB to chance Current selected Point
	If KeyHit(15) Then	
		EntityColor points(current),255,128,128
		current = current + 1
		If current = 4 Then current=0
		EntityColor points(current),128,255,128
	End If
	
	;Up Down, Left, Right to move the selected point
	
	If KeyDown(203) Then 
		TranslateEntity points(current), -.01,  0, 0
		modification=True
	End If

	If KeyDown(205) Then 
		TranslateEntity points(current),  .01,  0, 0
		modification=True
	End If

	If KeyDown(200) Then
		TranslateEntity points(current),   0, .01, 0
		modification=True
	End If
		
	If KeyDown(208) Then 
		TranslateEntity points(current),   0, -.01, 0
		modification=True
	End If
	
	If KeyDown(30) Then 
		TranslateEntity points(current),   0, 0, -.01
		modification=True
	End If
	
	If KeyDown(44) Then 
		TranslateEntity points(current),   0, 0, +.01
		modification=True
	End If

	If KeyDown(31) Then 
		TurnEntity CameraPiv, 0, +0.1, 0
	End If
	
	If KeyDown(45) Then 
		TurnEntity CameraPiv, 0, -0.1, 0
	End If

	

	RenderWorld
	
	Text 10, 10, "TAB to change selected point (Green one)"
	Text 10, 30, "Cursor keys for x and y axis, A/Z to control z axis"
	Text 10, 50, "S/X to turn Camera"
	
	For i=0 To 3
		CameraProject camera,EntityX(points(i)),EntityY(points(i)),EntityZ(points(i))
		Text ProjectedX()+20,ProjectedY()+20,i
	Next
	
	Flip

Until KeyHit(1)

Function Reposition()
	Local t#
	For i=1 To 100
		t = Float(i/100.0)
		move_interpolate(t,points(0),points(1),points(2),points(3))
		PositionEntity interpolated(i-1),bezier_x,bezier_y,bezier_z
	Next
	modification = False
End Function

.puntos
Data -3,0,0
Data -1,0,0
Data 1,0,0
Data 3,0,0

Function move_interpolate( t#, p1,p2,p3,p4)

	x1# = EntityX(p1,True)
	y1# = EntityY(p1,True)
	z1# = EntityZ(p1,True)
	
	x2# = EntityX(p2,True)
	y2# = EntityY(p2,True)
	z2# = EntityZ(p2,True)

	x3# = EntityX(p3,True)
	y3# = EntityY(p3,True)
	z3# = EntityZ(p3,True)
	
	x4# = EntityX(p4,True)
	y4# = EntityY(p4,True)
	z4# = EntityZ(p4,True)
	
	bezier_x = x1 * (1-t)^3 + 3 * x2 * (1-t)^2 * t + 3 * x3 * (1-t) * t^2 + x4 * t^3 
	bezier_y = y1 * (1-t)^3 + 3 * y2 * (1-t)^2 * t + 3 * y3 * (1-t) * t^2 + y4 * t^3 
	bezier_z = z1 * (1-t)^3 + 3 * z2 * (1-t)^2 * t + 3 * z3 * (1-t) * t^2 + z4 * t^3 
	
	;DebugLog t+", "+bezier_x+", "+bezier_y+", "+bezier_z
	
End Function

</textarea><br><br>just a few new lines of code. <br><br></td></tr></table><br>
<a name="1121098"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Charrua. I know THATS 3D but the one u JUST posted from jeppe nielsons thread was 2D. At any rate, do u think that u can make the bezier waypoints drag in YOUR 3D demo u made from AWC, and make the object follow ANYWHERE the bezier waypoint is placed?<br><br>Once again, thank you SO kindly for all of the help! :) <br><br></td></tr></table><br>
<a name="1121108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> you must try to Mix code samples to generata your own code. Most of you are asking for is on these forums, you only have to "learn" the technique and add some other pieces from here and there.<br><br>To drag an object you may do many things, it all depends on you style or needs. One way should be: <br><br>Use CameraProject to know ObjectX,ObjectY (2d on screen)<br>Get MouseX,MouseY and if near ObjectX,ObjectY (some threshold)<br>and if Left Mouse Button Pressed: get MouseX and Y speed and move the object<br>somewhat on x,y direction, try, pray, test, LEARN, see other code ( please don't ask someone else to code your work). There will be no one on this forum wich could make your wishes, this is your dutie. Here you will find so many help, but you must do some effort by your self.<br><br>regards<br><br>Juan <br><br></td></tr></table><br>
<a name="1121111"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can someone else actually help step me through this please? <br><br></td></tr></table><br>
<a name="1121116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Charrua, better idea. Do u think since AWC is freeware, that u could release the part that drags and drops the waypoints, and writes the waypoints data to a file? That would be EXACTLY what im looking for :)<br><br>It would be WONDERFUL of you if u could do that.. Why spend time re-inventing the wheel? :) <br><br></td></tr></table><br>
<a name="1121122"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Thats CLOSE. but for some reason, the waypoint wont stay ON the line as the line follows the waypoint.<br> <br></div><br>The reason is that this was clearly the intended behavior, as it often is in interpolation implementations.  You should not presume that he has the time to change it, since you have no idea how much work that would take.  You should instead learn about splines from a variety of sources and do it yourself.<br><div class="quote"> <br>Do u think since AWC is freeware, that u could release the part that drags and drops the waypoints, and writes the waypoints data to a file? <br>...<br>Why spend time re-inventing the wheel? :) <br> <br></div><br>Because everyone has to reinvent many wheels when they program computers.  That's just the way it is.  His Bezier code included routines to drag and drop waypoints, and if you have trouble writing code to save data to a file, start a thread on that (or better yet, search for one).  <br><br>Limit your threads to one small request each.<br><br>As you yourself stated, Charrua has given you all the functionality you need between the two programs.  You should now be able to extract what you need from both to make most or all of what you want.  Why don't you give it a try and post your own code when you get stuck? <br><br></td></tr></table><br>
<a name="1121148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> I TRIED combining drag and drop with the bezier waypoints. it DID NOT work... the object wouldnt follow the new bezier waypoints new coordinates..... <br><br></td></tr></table><br>
<a name="1121158"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Then post your code and let these folks pick it apart. <br><br></td></tr></table><br>
<a name="1121159"></a>

<a name="1121160"></a>

<a name="1121161"></a>

<a name="1121162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, good point! :)<br><br>As Axel said, I'm limiting my post to 2 small requests each. 1. Can someone please make the "viajero" object follow the NEW coordinates to the dragged bezier waypoints? 2) Can someone make the plotted path change to the correct dragged bezier waypoint's coordinates?<br><br>Here is the code so far: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global Path_x#, Path_y#, Path_z#

Type tWayPoint
	
	Field PathId	; with path it belongs
	Field Entity	; a pivot with position and orientation
	Field cp1		; control point1
	Field cp2		; control point2
	Field nSteps	; number of interpolated steps to the next waypoint
	Field CurrStep	; current step interpolated (from 1 to nSteps)
	Field Pitch#, Yaw#, Roll#
	
	
End Type

Type tPath
	
	Field PathId		;id 
	Field pFirst		;handle to the first on this list
	Field pLast			;same for last
	
	Field WPCount		;quantity of waypoints on this path
	Field CurrentWP		;handlw of the current waypoint, in whic we are
	Field CurrPos		;pivot wiht pos and orientation of the step in the path
						;acrodingly with CurrentStep of the CurrentWP
	
End Type



;wp functions

Function NextWP.tWayPoint(wp.tWayPoint)
	wpTemp.tWayPoint = After wp
	If wpTemp = Null
		wpTemp = FirstWP()
	EndIf
	Return wpTemp
End Function

Function PrevWP.tWayPoint(wp.tWayPoint)
	wpTemp.tWayPoint = Before wp
	If wpTemp = Null
		wpTemp = LastWP()
	EndIf
	Return wpTemp
End Function

Function FirstWP.tWayPoint()
	Return First tWayPoint
End Function


Function LastWP.tWayPoint()
	Return Last tWayPoint
End Function

Function NewWP.tWayPoint(Path.tPath, x#, y#, z#, nSteps=100, pitch#=0, yaw#=0, roll#=0)
	
	wp.tWayPoint = New tWayPoint
	
	wp\PathID = Path\PathId
	
	Path\WPCount = Path\WPCount+1
	If Path\pFirst=0 Then
		Path\pFirst = Handle(wp)
		Path\CurrentWP = Path\pFirst
		PositionEntity Path\CurrPos,x,y,z
		RotateEntity Path\CurrPos,pitch,yaw,roll
	End If
	Path\pLast = Handle(wp)
	wp\Entity = CreatePivot()
	wp\cp1 = CreatePivot(wp\Entity)
	wp\cp2 = CreatePivot(wp\Entity)
	PositionEntity wp\Entity,x,y,z
	wp\nSteps = nSteps
	wp\CurrStep = 0
	wp\pitch = pitch
	wp\yaw = yaw
	wp\roll = roll
	
	Return wp
	
End Function

;path functions


Function PathNextWP.tWayPoint(Path.tPath)
	Local wp.tWayPoint
	If Path\CurrentWP = Path\pLast Then
		Path\CurrentWP = Path\pFirst
	Else
		wp = After PathCurrWP(Path)
		Path\CurrentWP = Handle(wp)
	End If
	Return PathCurrWP(Path)
End Function

Function PathPrevWP.tWayPoint(Path.tPath)
	Local wp.tWayPoint
	If Path\CurrentWP = Path\pFirst Then
		Path\CurrentWP = Path\pLast
	Else
		wp = Before PathCurrWP(Path)
		Path\CurrentWP = Handle(wp)
	End If
	Return PathCurrWP(Path)
End Function

Function PathFirstWP.tWayPoint(Path.tPath)
	Path\CurrentWP = Path\pFirst
	Return PathCurrWP(Path)
End Function

Function PathLastWP.tWayPoint(Path.tPath)
	Path\CurrentWP = Path\pLast
	Return PathCurrWP(Path)
End Function

Function PathCurrWP.tWayPoint(Path.tPath)
	Return Object.tWayPoint(Path\CurrentWP)
End Function

Function NewPath.tPath()
	
	Path.tPath = New tPath
	Path\PathId = Handle(Path)
	Path\CurrPos = CreatePivot()
	
	Return Path
	
End Function


Function InitPath(Path.tPath, Save=False)
	
	;precalculates 2 control points for each WayPoint
	;they are needed for the InterpolatePos function based on a Bezier curve
	
	If Save Then
		CurrentWP = Path\CurrentWP
	End If
	
	CurrWP.tWayPoint = PathFirstWP(Path)
	
	For i=1 To Path\WPCount+1
		
		PrevWP.tWayPoint = PathPrevWP(Path)	;previous	-1
		CurrWP.tWayPoint = PathNextWP(Path)	;actual		 0
		NextWP.tWayPoint = PathNextWP(Path)	;next		+1, so in each loop advance one element
		
		If Save Then
			If Handle(CurrWP)&lt;&gt;Path\CurrentWP Then CurrWP\CurrStep=0
		Else
			CurrWP\CurrStep = 0
		End If
		
		NextAux = CopyEntity(NextWP\Entity)
		PrevAux = CopyEntity(PrevWP\Entity)
		PointEntity CurrWP\Entity,NextAux
		PointEntity PrevAux,NextAux
		
		RotateEntity CurrWP\cp1, EntityPitch(PrevAux,True), EntityYaw(PrevAux,True), EntityRoll(PrevAux,True),True
		Dist# = D3D(CurrWP\Entity,NextAux)
		PositionEntity CurrWP\cp1,0,0,0
		MoveEntity CurrWP\cp1,0,0,-Dist/3.0
		PositionEntity PrevWP\cp2, EntityX(CurrWP\cp1,True), EntityY(CurrWP\cp1,True), EntityZ(CurrWP\cp1,True), True
		MoveEntity CurrWP\cp1,0,0,2*Dist/3
		FreeEntity NextAux
		FreeEntity PrevAux
		
	Next
	
	If Save Then
		Path\CurrentWP = CurrentWP
	Else
		wp.tWayPoint = PathFirstWP(Path)
		PositionEntity Path\CurrPos, EntityX(wp\Entity,True), EntityY(wp\Entity,True), EntityY(wp\Entity,True)
	End If
	
	
End Function

Function InitPaths(Save=True)
	
	For Path.tPath = Each tPath
		
		InitPath(Path,Save)
		
	Next
End Function

Function PathNextPos(Path.tPath, SignalEnd=False)
	
	Local CurrWP.tWayPoint, NextWP.tWayPoint
	
	CurrWP = PathCurrWP(Path)
	
	If CurrWP\CurrStep=CurrWP\nSteps Then
		CurrWP\CurrStep=0
		CurrWP = PathNextWP(Path)
		If Path\CurrentWP = Path\pFirst Then
			If SignalEnd Then Stop=True
		End If
	End If
	
	If Not(Stop) Then
		
		NextWP = PathNextWP(Path)
		CurrWP = PathPrevWP(Path)
		
		t# = (1.0*(Float(CurrWP\CurrStep))) / (Float(CurrWP\nSteps))
		
		InterpolatePos( t, CurrWP\Entity, CurrWP\cp1, CurrWP\cp2, NextWP\Entity)
		
		Pitch# = Interpolate(t,CurrWP\Pitch,NextWP\Pitch)
		Yaw#   = Interpolate(t,CurrWP\Yaw  ,NextWP\Yaw  )
		Roll#  = Interpolate(t,CurrWP\Roll ,NextWP\Roll )
		
		PositionEntity Path\CurrPos, Path_x, Path_y, Path_z
		RotateEntity Path\CurrPos, Pitch, Yaw, Roll
		
		CurrWP\CurrStep = CurrWP\CurrStep + 1
		
		
		Return Path\CurrPos
	Else
		Return -1
	End If
	
End Function

Function PathCurrPos(Path.tPath)
	Return Path\CurrPos
End Function

Function PathsNextPos(SignalEnd=False)
	For Path.tPath = Each tPath
		PathNextPos(Path,SignalEnd)
	Next
End Function

Function Interpolate#(t#, v1#, v2#)
	Return v1 + (v2-v1)*t
End Function

Function InterpolatePos( t#, p1, p2, p3, p4)
	
	x1# = EntityX(p1,True)
	y1# = EntityY(p1,True)
	z1# = EntityZ(p1,True)
	
	x2# = EntityX(p2,True)
	y2# = EntityY(p2,True)
	z2# = EntityZ(p2,True)
	
	x3# = EntityX(p3,True)
	y3# = EntityY(p3,True)
	z3# = EntityZ(p3,True)
	
	x4# = EntityX(p4,True)
	y4# = EntityY(p4,True)
	z4# = EntityZ(p4,True)
	
	Path_x = x1 * (1-t)^3 + 3 * x2 * (1-t)^2 * t + 3 * x3 * (1-t) * t^2 + x4 * t^3 
	Path_y = y1 * (1-t)^3 + 3 * y2 * (1-t)^2 * t + 3 * y3 * (1-t) * t^2 + y4 * t^3 
	Path_z = z1 * (1-t)^3 + 3 * z2 * (1-t)^2 * t + 3 * z3 * (1-t) * t^2 + z4 * t^3 
	
	
End Function


Function PlotPath(camera, Path.tPath)
	
	SaveCurrent = Path\CurrentWP
	
	Color 200,200,200
	
	LockBuffer()
	
	CurrWP.tWayPoint = PathFirstWP(Path)
	
	For wp=1 To Path\WPCount
		
		CurrWP.tWayPoint = PathCurrWP(Path)
		NextWP.tWayPoint = PathNextWP(Path)
		
		t# = 1.0 / CurrWP\nSteps
		tinc# = t	
		
		For i=1 To CurrWP\nSteps
			
			InterpolatePos( t, CurrWP\Entity, CurrWP\cp1, CurrWP\cp2, NextWP\Entity)
			
			CameraProject( camera, Path_x, Path_y, Path_z)
			x=ProjectedX()
			y=ProjectedY()
			If x&gt;0 And x&lt;GraphicsWidth() And y&gt;0 And y&lt;GraphicsHeight()
				WritePixelFast ProjectedX(), ProjectedY(), $FFFFFFFF
			End If
			t = t + tinc
			
		Next
		
	Next
	
	UnlockBuffer()
	
	Path\CurrentWP = SaveCurrent
	
End Function

Function PlotPaths(Camera)
	For Path.tPath = Each tPath
		PlotPath(Camera, Path)
	Next
End Function

Function D3D#(obj1, obj2)
	x# = EntityX(obj1) - EntityX(obj2)
	y# = EntityY(obj1) - EntityY(obj2)
	z# = EntityZ(obj1) - EntityZ(obj2)
	Return Sqr(x*x + y*y + z*z)
End Function

Function Example()
	;
	;	Path following system
	;
	;	
	
	Graphics3D 800,600,0,2
	SetBuffer BackBuffer()
	
	pivotCam=CreatePivot()
	camera = CreateCamera(pivotcam)
	light = CreateLight(2)
	PositionEntity light,20,10,-10
	LightRange light,50
	PositionEntity camera,0,0,-10
	
	Viajero = CreateCone()	;viajero : voyager
	RotateMesh Viajero,90,0,0
	EntityColor Viajero,255,255,0
	Temp = CreateCube()
	ScaleEntity Temp,2,.2,.5
	EntityColor Temp,255,0,0
	EntityParent Temp,Viajero
	EntityPickMode Viajero,2,1
	EntityPickMode temp,2,1
	
	
	; Usage
	;
	;Create some paths	: 
	;						Path_N.tPaht = NewPath()
	;
	
	;Add WayPoints 		:
	;						WP.tWayPoint = NewWP(Path_n.tPath, x#, y#, z#, steps, pitch#, yaw#, roll#)	
	;
	;
	
	; define at least 3 points: 
	;		x,y,z, pitch, yaw, roll	(position and orientation of the waypoint)
	;		Steps are the number of interpolations the system will do to reach the next WayPoint
	;
	;
	
	;Initialize the path:
	;					InitPath(Path_n.tPath), or InitPaths() for init all defined path's
	;
	;InitPath precalculate 2 control points for each waypoint defined on the path, they are needed for the InterpolatePos function
	;wich is based on a Bezier curve.
	
	;
	;To move to the next position: PathNextPos(Path_N), or PathsNextPos() for all
	;
	;this function returns the handle to a pivot that has the newly calculated position and orientation
	;
	
	
	;in this demo:
	;
	;
	;Path1 and Path2 are identical: defined by the same waypoints
	;Path3 and Path4 are identical
	;
	;in the demo, i use Path1 and Path2 for the same object. Path2 is one step ahead Path1 so, we know the next position
	;and force the object to point to the next step.
	;
	;Path3 and Path4 has associated diferent objects and one of them is automatically stepped, the other is stepped under
	;user control (pressing the "A" key)
	;
	
	Restore WayPointDefinition
	
	
	Path1.tPath = NewPath()		;create Path1
	
	EntityParent viajero,Path1\CurrPos
	
	For nPoint = 1 To 4			;define some waypoints
		Read  x# 
		Read  y# 
		Read  z#
		Read Steps
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path1, x,y,z, steps, pitch, yaw, roll)
			;create a visible cube for each way point
		temp = CreateCube(wp\entity)
		PositionEntity temp,0,0,0
		RotateEntity temp,0,0,0
		ScaleEntity temp,.1,.1,.1
		EntityColor temp,255,255,0
		EntityPickMode temp,2,1
		
	Next	
	
	Path3.tPath = NewPath()		;create Path3 from a diferent set of points
	temp = CreateCube(Path3\CurrPos)
	ScaleEntity temp,.3,.3,.3
	EntityColor temp,0,0,255
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path3, x,y,z, pasos, pitch, yaw, roll)
		
			;create a visible cube for each way point
		temp = CreateCube(wp\entity)
		PositionEntity temp,0,0,0
		RotateEntity temp,0,0,0
		ScaleEntity temp,.1,.1,.1
		EntityColor temp,0, 255,255
		EntityPickMode temp, 2, 1
		
		
	Next
	
	Restore WayPointDefinition	;create 2 additional path from the same set of points
	
	Path2.tPath = NewPath()
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path2, x,y,z, pasos, pitch, yaw, roll)
		
	Next	
	
	Path4.tPath = NewPath()
	temp = CreateCube(Path4\CurrPos)
	ScaleEntity temp,.3,.3,.3
	EntityColor temp,0,255,0
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path4, x,y,z, pasos, pitch, yaw, roll)
		
	Next
	
	;at this moment, we have 4 paths, Path1 and Path2 are clones of each other and se same for Path3 and Path4
	
	
	;Initialize each path
	InitPaths()	;after initialization all paths are on The first waypoint and in the step 0
	
	
	Piv1 = PathCurrPos(Path1)	;fist position of Path1
	Piv2 = PathNextPos(Path2)	;second position of Path2
	PointEntity Piv1,Piv2,EntityRoll(piv1)	;point the Voyager to the next step in the path
	
	ShowPaths = True	;controls the plot of the interpolated steps
	
	
	
	
	Repeat
		
		
		mx = MouseX()
		my = MouseY()
		
		
		
		If incameramode = 0
			
			
			
			oldmypos# = mypos#
			
			
			
							;speed# = 0.05
			
			
			
							;If speed# &gt; 10.0 Then speed# = 10.0
			
			
			
							;If speed# &lt; -10.0 Then speed# = -10.0
			
			
			
							;mouse_speed# = MouseSpeed ( speed# )
			
			
			
			If (KeyDown(29) Or KeyDown(157) And KeyHit(19)) Then picked = 0 : whichmode = 1-whichmode
			
			
			
			If whichmode = 0 Then which_mode$ = "Rotation Mode"
			
			
			
			If whichmode = 1 Then which_mode$ = "Position Mode"
			
			
			
			If whichmode &gt; 1 Then whichmode = 0
			
				
				
				If MouseDown(1)
					If picked = False
						picked = Camera_Pick(camera, mX, mY, 150.0, 0.1, 1000.0)
						If picked&lt;&gt;0 
							EntityInView(picked, camera)
							If picked
								wire2 = 1
							EndIf
						Else
							picked = 0
						EndIf
					Else
						PositionEntityFrom2D (camera, picked, mX, mY, 0, 1)
					EndIf
				Else
					wire2 = 0
					picked = False
				EndIf
				
				
				
			EndIf
			
			
		
		If KeyDown(203) Then TurnEntity pivotCam, 0,+.5,0
		If KeyDown(205) Then TurnEntity pivotCam, 0,-.5,0
		If KeyDown(30)	Then PathNextPos(Path4)	;only stepped if A key is held down
		
		If KeyHit(57) Then
			ShowPaths = Not(ShowPaths)
		End If
		
		RenderWorld
		
		If ShowPaths Then
			PlotPath(Camera,Path1)
			PlotPath(Camera,Path3)
		End If
		
		;the path system not only interpolate position from one way point to the next via a bezier curve
		;plus, it interpolate pitch, yaw and roll from WayPoint form the next lineary.
		
		;in this demo, i use the Roll interpolated by the system but i prefere to do the voyager to point to the next waypoint.
		Piv1 = PathNextPos(Path1)	;both path are equal but, Path2 is one step ahead of Path1
		Piv2 = PathNextPos(Path2)	;used to force the entity to Point to the next step
		R# = EntityRoll(Piv1)		;the calculated roll is saved and used to stablish the en roll of the object
		PointEntity Piv1,Piv2
		RotateEntity Piv1, EntityPitch(Piv1), EntityYaw(Piv1), R
		
		;for the boxes, the system use the pitch, yaw and roll interpolated by the system		
		temp = PathNextPos(Path3,True)
		If temp=-1 Then
			DebugLog "end of Path3"
		End If
		
		Text 10,10,"Space to show/hide paths"
		Text 10,30,"&lt;- -&gt; tu turn camera"
		Text 10,50,"A to step Path4"
		Text 10,70,TrisRendered()
		Text 10,90,"picked: "+pickobj
		
		Flip
		
	Until KeyHit(1)
	
	
End Function

Example()

; -----------------------------------------------------------------------------
; PositionEntityFrom2D ()
; -----------------------------------------------------------------------------
; Positions an entity at 3D x/y co-ords translated from given 2D co-ords, at
; specified z position. Useful for positioning an entity at mouse x/y position,
; at its current z depth...
; -----------------------------------------------------------------------------
; PARAMETERS...
; -----------------------------------------------------------------------------
; REQUIRED...
; -----------------------------------------------------------------------------
; entity is the entity to be positioned.
; x2d is the 2D x position you want translated to 3D.
; y2d is the 2D y position you want translated to 3D.
; z3d is the * 3D * z depth at which the translation should occur.
; -----------------------------------------------------------------------------
; OPTIONAL...
; -----------------------------------------------------------------------------
; positionGlobal defaults to false, as per PositionEntity.
; camZoom must be set manually if you've used CameraZoom to change it...
; ----------------------------------------------------------------------------- 

Function MouseSpeed ( speed# )
	Local mXs #=MouseXSpeed ()
	Local mYs #=MouseYSpeed ()
	
	mX = mX + mXs * speed
	mY = mY + mYs * speed
	
	MoveMouse GraphicsWidth ()* .5 , GraphicsHeight ()* .5
	
	mX = Min ( mX , GraphicsWidth ())
	mX = Max ( mX , 0 )
	mY = Min ( mY , GraphicsHeight ())
	mY = Max ( mY , 0 )
	
	Return speed#
	
End Function

Function Max ( a #, b#)
	If a &gt; b Then Return a Else Return b
End Function

Function Min ( a #,b#)
	If a &lt; b Then Return a Else Return b
End Function 

Function CorrectOffset(mesh,offx#=0,offy#=0,offz#=0)
	Local x#,y#,z#, surf,s,v, minx#=100000,miny#=100000,minz#=100000
	Local mw#=MeshWidth(mesh), mh#=MeshHeight(mesh), md#=MeshDepth(mesh)
	For s=1 To CountSurfaces(mesh)
		surf=GetSurface(mesh,s)
		For v=0 To CountVertices(surf)-1
			x=VertexX(surf,v)
			y=VertexY(surf,v)
			z=VertexZ(surf,v)
			If x&lt;minx Then minx=x
			If y&lt;miny Then miny=y
			If z&lt;minz Then minz=z
		Next
	Next
	TFormPoint minx+mw*0.5-offx,miny+mh*0.5-offy,minz+md*0.5-offz,mesh,GetParent(mesh)
	TranslateEntity mesh,TFormedX(),TFormedY(),TFormedZ()
	FitMesh mesh,-mw*0.5+offx,-mh*0.5+offy,-md*0.5+offz,mw,mh,md
End Function



Function Camera_Pick(cam, x#, y#, distance#,onear#=0.1,ofar#=1000.0)
	CameraRange cam,onear,distance
	r = CameraPick(cam, x#, y#)
	CameraRange cam,onear,ofar
	Return r
End Function



Function PositionEntityFrom2D (usecam, entity, x2d#, y2d#, positionGlobal = 0, camZoom# = 1)
	gw = GraphicsWidth ()
	gh = GraphicsHeight ()
	x# = -((gw / 2) - x2d)
	y# = (gh / 2) - y2d
	parent = GetParent (entity)
	EntityParent entity, usecam
	z3d# = Abs (EntityZ (entity))
	div# = (gw / (2 / camZoom)) / z3d
	PositionEntity entity, x / div, y / div, z3d, positionGlobal
	EntityParent entity, parent
End Function


Function GlobalizeVertex (mesh, surface, index)
	vx# = VertexX (surface, index)
	vy# = VertexY (surface, index)
	vz# = VertexZ (surface, index)
	TFormPoint (vx, vy, vz, mesh, 0)
End Function

Function VertexGlobalX# ()
	Return TFormedX ()
End Function

Function VertexGlobalY# ()
	Return TFormedY ()
End Function

Function VertexGlobalZ# ()
	Return TFormedZ ()
End Function

Function VertexProject (usecam, mesh, surface, index)
	GlobalizeVertex (mesh, surface, index)
	CameraProject usecam, VertexGlobalX (), VertexGlobalY (), VertexGlobalZ ()
End Function

Function VertexScreenX ()
	Return ProjectedX ()
End Function

Function VertexScreenY ()
	Return ProjectedY ()
End Function

Function RenderWireFrame( Camera, MeshEntity )
	
	Local SC = CountSurfaces( MeshEntity )
	Local Vert1=0, C1X#, C1Y#, C1Z#
	Local Vert2=0, C2X#, C2Y#, C2Z#
	Local Vert3=0, C3X#, C3Y#, C3Z#
	
	For CS = 1 To SC
		GS = GetSurface( MeshEntity, CS )
		For CT =0 To CountTriangles( GS )-1
			Vert1 = TriangleVertex( GS, CT, 0 )
			Vert2 = TriangleVertex( GS, CT, 1 )
			Vert3 = TriangleVertex( GS, CT, 2 )
			
			TFormPoint VertexX#( GS, Vert1 ), VertexY#( GS, Vert1 ), VertexZ#( GS, Vert1 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C1X# = ProjectedX#()
			C1Y# = ProjectedY#()
			C1Z# = ProjectedZ#()
			TFormPoint VertexX#( GS, Vert2 ), VertexY#( GS, Vert2 ), VertexZ#( GS, Vert2 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C2X# = ProjectedX#()
			C2Y# = ProjectedY#()
			C2Z# = ProjectedZ#()
			TFormPoint VertexX#( GS, Vert3 ), VertexY#( GS, Vert3 ), VertexZ#( GS, Vert3 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C3X# = ProjectedX#()
			C3Y# = ProjectedY#()
			C3Z# = ProjectedZ#()
			
			Color 255, 0, 0
			
			Line C1X#, C1Y#, C2X#, C2Y#
			Line C2X#, C2Y#, C3X#, C3Y#
			Line C3X#, C3Y#, C1X#, C1Y#
		Next
	Next
	
End Function

; Made possible thanks to SSwift and &lt;a href="http://www.sbdev.pwp.blueyonder.co.uk/tut4.htm" target="_blank"&gt;http://www.sbdev.pwp.blueyonder.co.uk/tut4.htm&lt;/a&gt; !

Function TriMesh (usecam, turnoninviso=False, mesh, r1, g1, b1)
	
	
	
	If EntityInView (mesh, usecam)	
		
		For s = 1 To CountSurfaces (mesh)
			
			surf = GetSurface (mesh, s)
			
			; Parse each triangle in mesh...
			
			For t = 0 To CountTriangles (surf) - 1
				
				; Get triangle's vertice positions... presumably these are
				; in anti-clockwise order (since it appears to work :)
				
				v0 = TriangleVertex (surf, t, 0)
				v1 = TriangleVertex (surf, t, 1)
				v2 = TriangleVertex (surf, t, 2)
				
				If BackFacing (surf, v0, v1, v2, mesh, usecam)
					
					; Get 2D position for each point of triangle...
					
					VertexProject (usecam, mesh, surf, v0)
					vx0 = VertexScreenX ()
					vy0 = VertexScreenY ()
					
					VertexProject (usecam, mesh, surf, v1)
					vx1 = VertexScreenX ()
					vy1 = VertexScreenY ()
					
					VertexProject (usecam, mesh, surf, v2)
					vx2 = VertexScreenX ()
					vy2 = VertexScreenY ()
					
					
					; Draw triangle...
					
					Color r1, g1, b1
					
					Line vx0, vy0, vx1, vy1
					Line vx1, vy1, vx2, vy2
					Line vx2, vy2, vx0, vy0	
					
					Color 255, 255, 255
					
					
					
					If turnoninviso = 1 Then EntityAlpha mesh, 0
					
					
					
				EndIf
				
			Next
			
		Next		
		
	EndIf	
	
End Function

Function BackFacing (surf, v0, v1, v2, mesh, camera)
	
    ;vertex position
    x0# = VertexX (surf, v0): y0# = VertexY (surf, v0): z0# = VertexZ (surf, v0)
    x1# = VertexX (surf, v1): y1# = VertexY (surf, v1): z1# = VertexZ (surf, v1)
    x2# = VertexX (surf, v2): y2# = VertexY (surf, v2): z2# = VertexZ (surf, v2)
    
    ;deltas
    dx1# = x1 - x0: dy1# = y1 - y0: dz1# = z1 - z0
    dx2# = x2 - x0: dy2# = y2 - y0: dz2# = z2 - z0
	
    ;cross product
    cx# = dy1 * dz2 - dy2 * dz1
    cy# = dz1 * dx2 - dz2 * dx1
    cz# = dx1 * dy2 - dx2 * dy1
    
    ;normalize...
    sz# = Sqr (cx * cx + cy * cy + cz * cz)
    cx = cx / sz: cy = cy / sz: cz = cz / sz
    
    ;plane offset
    dt# = -(cx * x0 + cy * y0 + cz * z0)
    
    ;tranform eye to mesh coords
    TFormPoint 0, 0, 0, camera, mesh
    
    Return TFormedX () * cx + TFormedY () * cy + TFormedZ () * cz + dt &gt; 0
    
End Function




Function Delta_Time()
	NewTime = MilliSecs()	
	dt = Float (NewTime - OldTime)/1000
	OldTime = NewTime
	TotalTime = TotalTime + dt
End Function



;fps calc
Function FPS$()
    framecounter_counter=framecounter_counter+1
    If framecounter_time=0 Then framecounter_time=MilliSecs()
    If framecounter_time+1001&lt;MilliSecs() Then
        framecounter_framerate=framecounter_counter
		framecounter_counter=0
        framecounter_time=MilliSecs()
	EndIf
	zsemi$="FPS: "+framecounter_framerate
	Return zsemi$
End Function

End

.WayPointDefinition
;Path 1
Data -3, 0, 0, 100, 0, 0,  0
Data -1, 2,-5, 150, 0, 0, 50
Data  1, 1, 0, 100, 0, 0,  0
Data  3,-2,4, 100, 0, 0,-30
;Path 2
Data -3, 0, 4,  50,  60,   0,   0
Data -1, 3, 5, 100,   0,   0,  60
Data  1, 1, 6,  50,   0, -50,   0
Data  3,-3, 2, 100, -20,   0, -60</textarea><br><br>I've already added drag drop :)<br><br><br>Thanks alot for all of your help so far, and your help in the future! :)<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121178"></a>

<a name="1121179"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> The waypoints entities are pivots, so they are invisible. <br>You are dragging cubes not associated in any way with the PathFollowingSystem.<br><br>The idea, as i said, depends on what your need, now and tomorrow. If you tomorrow wants to delete a waypoint or add waypoints, any explanations wich works today will start to fail. <br><br>As the path following sistem explain: you mus create a path, then add waypoints and then InitPath, then you can use Next/Previous to travel the path.<br><br>If you modify (or wants to) a waypoint, you have to: modify the x,y,z position of the Waypoint's entity and then recalculate the path (InitPath)<br><br>to do so, there are many techniques, first you can Link the Cube (that shows the position of the waypoint) to the waypoint in some way. I do it by naming the Cube with the handle of the WayPoint (then i get the object easily).<br><br>i do only 3 changes, 2 of them to link the cube to the waypoint object:<br>""<br><br>and after drag, to translate the new Picked entity position to the waypoint\entity<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global Path_x#, Path_y#, Path_z#

Type tWayPoint
	
	Field PathId	; with path it belongs
	Field Entity	; a pivot with position and orientation
	Field cp1		; control point1
	Field cp2		; control point2
	Field nSteps	; number of interpolated steps to the next waypoint
	Field CurrStep	; current step interpolated (from 1 to nSteps)
	Field Pitch#, Yaw#, Roll#
	
	
End Type

Type tPath
	
	Field PathId		;id 
	Field pFirst		;handle to the first on this list
	Field pLast			;same for last
	
	Field WPCount		;quantity of waypoints on this path
	Field CurrentWP		;handlw of the current waypoint, in whic we are
	Field CurrPos		;pivot wiht pos and orientation of the step in the path
						;acrodingly with CurrentStep of the CurrentWP
	
End Type



;wp functions

Function NextWP.tWayPoint(wp.tWayPoint)
	wpTemp.tWayPoint = After wp
	If wpTemp = Null
		wpTemp = FirstWP()
	EndIf
	Return wpTemp
End Function

Function PrevWP.tWayPoint(wp.tWayPoint)
	wpTemp.tWayPoint = Before wp
	If wpTemp = Null
		wpTemp = LastWP()
	EndIf
	Return wpTemp
End Function

Function FirstWP.tWayPoint()
	Return First tWayPoint
End Function


Function LastWP.tWayPoint()
	Return Last tWayPoint
End Function

Function NewWP.tWayPoint(Path.tPath, x#, y#, z#, nSteps=100, pitch#=0, yaw#=0, roll#=0)
	
	wp.tWayPoint = New tWayPoint
	
	wp\PathID = Path\PathId
	
	Path\WPCount = Path\WPCount+1
	If Path\pFirst=0 Then
		Path\pFirst = Handle(wp)
		Path\CurrentWP = Path\pFirst
		PositionEntity Path\CurrPos,x,y,z
		RotateEntity Path\CurrPos,pitch,yaw,roll
	End If
	Path\pLast = Handle(wp)
	wp\Entity = CreatePivot()
	wp\cp1 = CreatePivot(wp\Entity)
	wp\cp2 = CreatePivot(wp\Entity)
	PositionEntity wp\Entity,x,y,z
	wp\nSteps = nSteps
	wp\CurrStep = 0
	wp\pitch = pitch
	wp\yaw = yaw
	wp\roll = roll
	
	Return wp
	
End Function

;path functions


Function PathNextWP.tWayPoint(Path.tPath)
	Local wp.tWayPoint
	If Path\CurrentWP = Path\pLast Then
		Path\CurrentWP = Path\pFirst
	Else
		wp = After PathCurrWP(Path)
		Path\CurrentWP = Handle(wp)
	End If
	Return PathCurrWP(Path)
End Function

Function PathPrevWP.tWayPoint(Path.tPath)
	Local wp.tWayPoint
	If Path\CurrentWP = Path\pFirst Then
		Path\CurrentWP = Path\pLast
	Else
		wp = Before PathCurrWP(Path)
		Path\CurrentWP = Handle(wp)
	End If
	Return PathCurrWP(Path)
End Function

Function PathFirstWP.tWayPoint(Path.tPath)
	Path\CurrentWP = Path\pFirst
	Return PathCurrWP(Path)
End Function

Function PathLastWP.tWayPoint(Path.tPath)
	Path\CurrentWP = Path\pLast
	Return PathCurrWP(Path)
End Function

Function PathCurrWP.tWayPoint(Path.tPath)
	Return Object.tWayPoint(Path\CurrentWP)
End Function

Function NewPath.tPath()
	
	Path.tPath = New tPath
	Path\PathId = Handle(Path)
	Path\CurrPos = CreatePivot()
	
	Return Path
	
End Function


Function InitPath(Path.tPath, Save=False)
	
	;precalculates 2 control points for each WayPoint
	;they are needed for the InterpolatePos function based on a Bezier curve
	
	If Save Then
		CurrentWP = Path\CurrentWP
	End If
	
	CurrWP.tWayPoint = PathFirstWP(Path)
	
	For i=1 To Path\WPCount+1
		
		PrevWP.tWayPoint = PathPrevWP(Path)	;previous	-1
		CurrWP.tWayPoint = PathNextWP(Path)	;actual		 0
		NextWP.tWayPoint = PathNextWP(Path)	;next		+1, so in each loop advance one element
		
		If Save Then
			If Handle(CurrWP)&lt;&gt;Path\CurrentWP Then CurrWP\CurrStep=0
		Else
			CurrWP\CurrStep = 0
		End If
		
		NextAux = CopyEntity(NextWP\Entity)
		PrevAux = CopyEntity(PrevWP\Entity)
		PointEntity CurrWP\Entity,NextAux
		PointEntity PrevAux,NextAux
		
		RotateEntity CurrWP\cp1, EntityPitch(PrevAux,True), EntityYaw(PrevAux,True), EntityRoll(PrevAux,True),True
		Dist# = D3D(CurrWP\Entity,NextAux)
		PositionEntity CurrWP\cp1,0,0,0
		MoveEntity CurrWP\cp1,0,0,-Dist/3.0
		PositionEntity PrevWP\cp2, EntityX(CurrWP\cp1,True), EntityY(CurrWP\cp1,True), EntityZ(CurrWP\cp1,True), True
		MoveEntity CurrWP\cp1,0,0,2*Dist/3
		FreeEntity NextAux
		FreeEntity PrevAux
		
	Next
	
	If Save Then
		Path\CurrentWP = CurrentWP
	Else
		wp.tWayPoint = PathFirstWP(Path)
		PositionEntity Path\CurrPos, EntityX(wp\Entity,True), EntityY(wp\Entity,True), EntityY(wp\Entity,True)
	End If
	
	
End Function

Function InitPaths(Save=True)
	
	For Path.tPath = Each tPath
		
		InitPath(Path,Save)
		
	Next
End Function

Function PathNextPos(Path.tPath, SignalEnd=False)
	
	Local CurrWP.tWayPoint, NextWP.tWayPoint
	
	CurrWP = PathCurrWP(Path)
	
	If CurrWP\CurrStep=CurrWP\nSteps Then
		CurrWP\CurrStep=0
		CurrWP = PathNextWP(Path)
		If Path\CurrentWP = Path\pFirst Then
			If SignalEnd Then Stop=True
		End If
	End If
	
	If Not(Stop) Then
		
		NextWP = PathNextWP(Path)
		CurrWP = PathPrevWP(Path)
		
		t# = (1.0*(Float(CurrWP\CurrStep))) / (Float(CurrWP\nSteps))
		
		InterpolatePos( t, CurrWP\Entity, CurrWP\cp1, CurrWP\cp2, NextWP\Entity)
		
		Pitch# = Interpolate(t,CurrWP\Pitch,NextWP\Pitch)
		Yaw#   = Interpolate(t,CurrWP\Yaw  ,NextWP\Yaw  )
		Roll#  = Interpolate(t,CurrWP\Roll ,NextWP\Roll )
		
		PositionEntity Path\CurrPos, Path_x, Path_y, Path_z
		RotateEntity Path\CurrPos, Pitch, Yaw, Roll
		
		CurrWP\CurrStep = CurrWP\CurrStep + 1
		
		
		Return Path\CurrPos
	Else
		Return -1
	End If
	
End Function

Function PathCurrPos(Path.tPath)
	Return Path\CurrPos
End Function

Function PathsNextPos(SignalEnd=False)
	For Path.tPath = Each tPath
		PathNextPos(Path,SignalEnd)
	Next
End Function

Function Interpolate#(t#, v1#, v2#)
	Return v1 + (v2-v1)*t
End Function

Function InterpolatePos( t#, p1, p2, p3, p4)
	
	x1# = EntityX(p1,True)
	y1# = EntityY(p1,True)
	z1# = EntityZ(p1,True)
	
	x2# = EntityX(p2,True)
	y2# = EntityY(p2,True)
	z2# = EntityZ(p2,True)
	
	x3# = EntityX(p3,True)
	y3# = EntityY(p3,True)
	z3# = EntityZ(p3,True)
	
	x4# = EntityX(p4,True)
	y4# = EntityY(p4,True)
	z4# = EntityZ(p4,True)
	
	Path_x = x1 * (1-t)^3 + 3 * x2 * (1-t)^2 * t + 3 * x3 * (1-t) * t^2 + x4 * t^3 
	Path_y = y1 * (1-t)^3 + 3 * y2 * (1-t)^2 * t + 3 * y3 * (1-t) * t^2 + y4 * t^3 
	Path_z = z1 * (1-t)^3 + 3 * z2 * (1-t)^2 * t + 3 * z3 * (1-t) * t^2 + z4 * t^3 
	
	
End Function


Function PlotPath(camera, Path.tPath)
	
	SaveCurrent = Path\CurrentWP
	
	Color 200,200,200
	
	LockBuffer()
	
	CurrWP.tWayPoint = PathFirstWP(Path)
	
	For wp=1 To Path\WPCount
		
		CurrWP.tWayPoint = PathCurrWP(Path)
		NextWP.tWayPoint = PathNextWP(Path)
		
		t# = 1.0 / CurrWP\nSteps
		tinc# = t	
		
		For i=1 To CurrWP\nSteps
			
			InterpolatePos( t, CurrWP\Entity, CurrWP\cp1, CurrWP\cp2, NextWP\Entity)
			
			CameraProject( camera, Path_x, Path_y, Path_z)
			x=ProjectedX()
			y=ProjectedY()
			If x&gt;0 And x&lt;GraphicsWidth() And y&gt;0 And y&lt;GraphicsHeight()
				WritePixelFast ProjectedX(), ProjectedY(), $FFFFFFFF
			End If
			t = t + tinc
			
		Next
		
	Next
	
	UnlockBuffer()
	
	Path\CurrentWP = SaveCurrent
	
End Function

Function PlotPaths(Camera)
	For Path.tPath = Each tPath
		PlotPath(Camera, Path)
	Next
End Function

Function D3D#(obj1, obj2)
	x# = EntityX(obj1) - EntityX(obj2)
	y# = EntityY(obj1) - EntityY(obj2)
	z# = EntityZ(obj1) - EntityZ(obj2)
	Return Sqr(x*x + y*y + z*z)
End Function

Function Example()
	;
	;	Path following system
	;
	;	
	
	Graphics3D 800,600,0,2
	SetBuffer BackBuffer()
	
	pivotCam=CreatePivot()
	camera = CreateCamera(pivotcam)
	light = CreateLight(2)
	PositionEntity light,20,10,-10
	LightRange light,50
	PositionEntity camera,0,0,-10
	
	Viajero = CreateCone()	;viajero : voyager
	RotateMesh Viajero,90,0,0
	EntityColor Viajero,255,255,0
	Temp = CreateCube()
	ScaleEntity Temp,2,.2,.5
	EntityColor Temp,255,0,0
	EntityParent Temp,Viajero
	EntityPickMode Viajero,2,1
	EntityPickMode temp,2,1
	
	
	; Usage
	;
	;Create some paths	: 
	;						Path_N.tPaht = NewPath()
	;
	
	;Add WayPoints 		:
	;						WP.tWayPoint = NewWP(Path_n.tPath, x#, y#, z#, steps, pitch#, yaw#, roll#)
	;
	;
	
	; define at least 3 points: 
	;		x,y,z, pitch, yaw, roll	(position and orientation of the waypoint)
	;		Steps are the number of interpolations the system will do to reach the next WayPoint
	;
	;
	
	;Initialize the path:
	;					InitPath(Path_n.tPath), or InitPaths() for init all defined path's
	;
	;InitPath precalculate 2 control points for each waypoint defined on the path, they are needed for the InterpolatePos function
	;wich is based on a Bezier curve.
	
	;
	;To move to the next position: PathNextPos(Path_N), or PathsNextPos() for all
	;
	;this function returns the handle to a pivot that has the newly calculated position and orientation
	;
	
	
	;in this demo:
	;
	;
	;Path1 and Path2 are identical: defined by the same waypoints
	;Path3 and Path4 are identical
	;
	;in the demo, i use Path1 and Path2 for the same object. Path2 is one step ahead Path1 so, we know the next position
	;and force the object to point to the next step.
	;
	;Path3 and Path4 has associated diferent objects and one of them is automatically stepped, the other is stepped under
	;user control (pressing the "A" key)
	;
	
	Restore WayPointDefinition
	
	
	Path1.tPath = NewPath()		;create Path1
	
	EntityParent viajero,Path1\CurrPos
	
	For nPoint = 1 To 4			;define some waypoints
		Read  x# 
		Read  y# 
		Read  z#
		Read Steps
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path1, x,y,z, steps, pitch, yaw, roll)
		;create a visible cube for each way point
		
		temp = CreateCube(wp\entity)
		
		;------------------------------------------------------------------------------ start added
		NameEntity temp,Handle(wp)
		;------------------------------------------------------------------------------ end added

		
		PositionEntity temp,0,0,0
		RotateEntity temp,0,0,0
		ScaleEntity temp,.1,.1,.1
		EntityColor temp,255,255,0
		EntityPickMode temp,2,1
		
	Next	
	
	Path3.tPath = NewPath()		;create Path3 from a diferent set of points
	temp = CreateCube(Path3\CurrPos)
	ScaleEntity temp,.3,.3,.3
	EntityColor temp,0,0,255
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path3, x,y,z, pasos, pitch, yaw, roll)
		
			;create a visible cube for each way point
		temp = CreateCube(wp\entity)
		
		;------------------------------------------------------------------------------ start added
		NameEntity temp,Handle(wp)
		;------------------------------------------------------------------------------ end added

		
		PositionEntity temp,0,0,0
		RotateEntity temp,0,0,0
		ScaleEntity temp,.1,.1,.1
		EntityColor temp,0, 255,255
		EntityPickMode temp, 2, 1
		
		
	Next
	
	Restore WayPointDefinition	;create 2 additional path from the same set of points
	
	Path2.tPath = NewPath()
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path2, x,y,z, pasos, pitch, yaw, roll)
		
	Next	
	
	Path4.tPath = NewPath()
	temp = CreateCube(Path4\CurrPos)
	ScaleEntity temp,.3,.3,.3
	EntityColor temp,0,255,0
	
	For nPoint = 1 To 4
		Read  x# 
		Read  y# 
		Read  z# 
		Read Pasos
		Read Pitch#
		Read yaw#
		Read roll
		
		wp.tWayPoint = NewWP(Path4, x,y,z, pasos, pitch, yaw, roll)
		
	Next
	
	;at this moment, we have 4 paths, Path1 and Path2 are clones of each other and se same for Path3 and Path4
	
	
	;Initialize each path
	InitPaths()	;after initialization all paths are on The first waypoint and in the step 0
	
	
	Piv1 = PathCurrPos(Path1)	;fist position of Path1
	Piv2 = PathNextPos(Path2)	;second position of Path2
	PointEntity Piv1,Piv2,EntityRoll(piv1)	;point the Voyager to the next step in the path
	
	ShowPaths = True	;controls the plot of the interpolated steps
	
	
	;solo mueve la entidad blitz asociada a un waypoint pero el sistema nuca se entera:
	;hay que reinicializar el camino, de acuerdo a la nueva posicion
	
	;hay que encontrar el waypoint asociado a ese objeto? no hay que reinicializar el camino
	;probablemente reinicializar todo? o mejor, encontrar a que path pertenece el elemento ...
	
	Repeat
		
		
		mx = MouseX()
		my = MouseY()
		
		
		
		If incameramode = 0
			
			
			
			oldmypos# = mypos#
			
			
			
							;speed# = 0.05
			
			
			
							;If speed# &gt; 10.0 Then speed# = 10.0
			
			
			
							;If speed# &lt; -10.0 Then speed# = -10.0
			
			
			
							;mouse_speed# = MouseSpeed ( speed# )
			
			
			
			If (KeyDown(29) Or KeyDown(157) And KeyHit(19)) Then picked = 0 : whichmode = 1-whichmode
			
			
			
			If whichmode = 0 Then which_mode$ = "Rotation Mode"
			
			
			
			If whichmode = 1 Then which_mode$ = "Position Mode"
			
			
			
			If whichmode &gt; 1 Then whichmode = 0
			
				
				
				If MouseDown(1)
					If picked = False
						picked = Camera_Pick(camera, mX, mY, 150.0, 0.1, 1000.0)
						If picked&lt;&gt;0 
							EntityInView(picked, camera)
							If picked
								wire2 = 1
							EndIf
						Else
							picked = 0
						EndIf
					Else
						PositionEntityFrom2D (camera, picked, mX, mY, 0, 1)
						;------------------------------------------------------------------------------ start added
						If EntityName(picked)&lt;&gt;"" Then
							wpTemp.tWayPoint = Object.tWayPoint(EntityName(picked))
							PositionEntity wpTemp\Entity, EntityX(picked,True), EntityY(picked,True), EntityZ(picked,True)
							InitPaths()
						End If
						;------------------------------------------------------------------------------- end added
					EndIf
				Else
					wire2 = 0
					picked = False
				EndIf
				
				
				
			EndIf
			
			
		
		If KeyDown(203) Then TurnEntity pivotCam, 0,+.5,0
		If KeyDown(205) Then TurnEntity pivotCam, 0,-.5,0
		If KeyDown(30)	Then PathNextPos(Path4)	;only stepped if A key is held down
		
		If KeyHit(57) Then
			ShowPaths = Not(ShowPaths)
		End If
		
		RenderWorld
		
		If ShowPaths Then
			PlotPath(Camera,Path1)
			PlotPath(Camera,Path3)
		End If
		
		;the path system not only interpolate position from one way point to the next via a bezier curve
		;plus, it interpolate pitch, yaw and roll from WayPoint form the next lineary.
		
		;in this demo, i use the Roll interpolated by the system but i prefere to do the voyager to point to the next waypoint.
		Piv1 = PathNextPos(Path1)	;both path are equal but, Path2 is one step ahead of Path1
		Piv2 = PathNextPos(Path2)	;used to force the entity to Point to the next step
		R# = EntityRoll(Piv1)		;the calculated roll is saved and used to stablish the en roll of the object
		PointEntity Piv1,Piv2
		RotateEntity Piv1, EntityPitch(Piv1), EntityYaw(Piv1), R
		
		;for the boxes, the system use the pitch, yaw and roll interpolated by the system		
		temp = PathNextPos(Path3,True)
		If temp=-1 Then
			DebugLog "end of Path3"
		End If
		
		Text 10,10,"Space to show/hide paths"
		Text 10,30,"&lt;- -&gt; tu turn camera"
		Text 10,50,"A to step Path4"
		Text 10,70,TrisRendered()
		Text 10,90,"picked: "+pickobj
		
		Flip
		
	Until KeyHit(1)
	
	
End Function

Example()

; -----------------------------------------------------------------------------
; PositionEntityFrom2D ()
; -----------------------------------------------------------------------------
; Positions an entity at 3D x/y co-ords translated from given 2D co-ords, at
; specified z position. Useful for positioning an entity at mouse x/y position,
; at its current z depth...
; -----------------------------------------------------------------------------
; PARAMETERS...
; -----------------------------------------------------------------------------
; REQUIRED...
; -----------------------------------------------------------------------------
; entity is the entity to be positioned.
; x2d is the 2D x position you want translated to 3D.
; y2d is the 2D y position you want translated to 3D.
; z3d is the * 3D * z depth at which the translation should occur.
; -----------------------------------------------------------------------------
; OPTIONAL...
; -----------------------------------------------------------------------------
; positionGlobal defaults to false, as per PositionEntity.
; camZoom must be set manually if you've used CameraZoom to change it...
; ----------------------------------------------------------------------------- 

Function MouseSpeed ( speed# )
	Local mXs #=MouseXSpeed ()
	Local mYs #=MouseYSpeed ()
	
	mX = mX + mXs * speed
	mY = mY + mYs * speed
	
	MoveMouse GraphicsWidth ()* .5 , GraphicsHeight ()* .5
	
	mX = Min ( mX , GraphicsWidth ())
	mX = Max ( mX , 0 )
	mY = Min ( mY , GraphicsHeight ())
	mY = Max ( mY , 0 )
	
	Return speed#
	
End Function

Function Max ( a #, b#)
	If a &gt; b Then Return a Else Return b
End Function

Function Min ( a #,b#)
	If a &lt; b Then Return a Else Return b
End Function 

Function CorrectOffset(mesh,offx#=0,offy#=0,offz#=0)
	Local x#,y#,z#, surf,s,v, minx#=100000,miny#=100000,minz#=100000
	Local mw#=MeshWidth(mesh), mh#=MeshHeight(mesh), md#=MeshDepth(mesh)
	For s=1 To CountSurfaces(mesh)
		surf=GetSurface(mesh,s)
		For v=0 To CountVertices(surf)-1
			x=VertexX(surf,v)
			y=VertexY(surf,v)
			z=VertexZ(surf,v)
			If x&lt;minx Then minx=x
			If y&lt;miny Then miny=y
			If z&lt;minz Then minz=z
		Next
	Next
	TFormPoint minx+mw*0.5-offx,miny+mh*0.5-offy,minz+md*0.5-offz,mesh,GetParent(mesh)
	TranslateEntity mesh,TFormedX(),TFormedY(),TFormedZ()
	FitMesh mesh,-mw*0.5+offx,-mh*0.5+offy,-md*0.5+offz,mw,mh,md
End Function



Function Camera_Pick(cam, x#, y#, distance#,onear#=0.1,ofar#=1000.0)
	CameraRange cam,onear,distance
	r = CameraPick(cam, x#, y#)
	CameraRange cam,onear,ofar
	Return r
End Function



Function PositionEntityFrom2D (usecam, entity, x2d#, y2d#, positionGlobal = 0, camZoom# = 1)
	gw = GraphicsWidth ()
	gh = GraphicsHeight ()
	x# = -((gw / 2) - x2d)
	y# = (gh / 2) - y2d
	parent = GetParent (entity)
	EntityParent entity, usecam
	z3d# = Abs (EntityZ (entity))
	div# = (gw / (2 / camZoom)) / z3d
	PositionEntity entity, x / div, y / div, z3d, positionGlobal
	EntityParent entity, parent
End Function


Function GlobalizeVertex (mesh, surface, index)
	vx# = VertexX (surface, index)
	vy# = VertexY (surface, index)
	vz# = VertexZ (surface, index)
	TFormPoint (vx, vy, vz, mesh, 0)
End Function

Function VertexGlobalX# ()
	Return TFormedX ()
End Function

Function VertexGlobalY# ()
	Return TFormedY ()
End Function

Function VertexGlobalZ# ()
	Return TFormedZ ()
End Function

Function VertexProject (usecam, mesh, surface, index)
	GlobalizeVertex (mesh, surface, index)
	CameraProject usecam, VertexGlobalX (), VertexGlobalY (), VertexGlobalZ ()
End Function

Function VertexScreenX ()
	Return ProjectedX ()
End Function

Function VertexScreenY ()
	Return ProjectedY ()
End Function

Function RenderWireFrame( Camera, MeshEntity )
	
	Local SC = CountSurfaces( MeshEntity )
	Local Vert1=0, C1X#, C1Y#, C1Z#
	Local Vert2=0, C2X#, C2Y#, C2Z#
	Local Vert3=0, C3X#, C3Y#, C3Z#
	
	For CS = 1 To SC
		GS = GetSurface( MeshEntity, CS )
		For CT =0 To CountTriangles( GS )-1
			Vert1 = TriangleVertex( GS, CT, 0 )
			Vert2 = TriangleVertex( GS, CT, 1 )
			Vert3 = TriangleVertex( GS, CT, 2 )
			
			TFormPoint VertexX#( GS, Vert1 ), VertexY#( GS, Vert1 ), VertexZ#( GS, Vert1 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C1X# = ProjectedX#()
			C1Y# = ProjectedY#()
			C1Z# = ProjectedZ#()
			TFormPoint VertexX#( GS, Vert2 ), VertexY#( GS, Vert2 ), VertexZ#( GS, Vert2 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C2X# = ProjectedX#()
			C2Y# = ProjectedY#()
			C2Z# = ProjectedZ#()
			TFormPoint VertexX#( GS, Vert3 ), VertexY#( GS, Vert3 ), VertexZ#( GS, Vert3 ), MeshEntity, 0
			CameraProject Camera, TFormedX#(), TFormedY#(), TFormedZ#()
			C3X# = ProjectedX#()
			C3Y# = ProjectedY#()
			C3Z# = ProjectedZ#()
			
			Color 255, 0, 0
			
			Line C1X#, C1Y#, C2X#, C2Y#
			Line C2X#, C2Y#, C3X#, C3Y#
			Line C3X#, C3Y#, C1X#, C1Y#
		Next
	Next
	
End Function

; Made possible thanks to SSwift and &lt;a href="http://www.sbdev.pwp.blueyonder.co.uk/tut4.htm" target="_blank"&gt;http://www.sbdev.pwp.blueyonder.co.uk/tut4.htm&lt;/a&gt; !

Function TriMesh (usecam, turnoninviso=False, mesh, r1, g1, b1)
	
	
	
	If EntityInView (mesh, usecam)	
		
		For s = 1 To CountSurfaces (mesh)
			
			surf = GetSurface (mesh, s)
			
			; Parse each triangle in mesh...
			
			For t = 0 To CountTriangles (surf) - 1
				
				; Get triangle's vertice positions... presumably these are
				; in anti-clockwise order (since it appears to work :)
				
				v0 = TriangleVertex (surf, t, 0)
				v1 = TriangleVertex (surf, t, 1)
				v2 = TriangleVertex (surf, t, 2)
				
				If BackFacing (surf, v0, v1, v2, mesh, usecam)
					
					; Get 2D position for each point of triangle...
					
					VertexProject (usecam, mesh, surf, v0)
					vx0 = VertexScreenX ()
					vy0 = VertexScreenY ()
					
					VertexProject (usecam, mesh, surf, v1)
					vx1 = VertexScreenX ()
					vy1 = VertexScreenY ()
					
					VertexProject (usecam, mesh, surf, v2)
					vx2 = VertexScreenX ()
					vy2 = VertexScreenY ()
					
					
					; Draw triangle...
					
					Color r1, g1, b1
					
					Line vx0, vy0, vx1, vy1
					Line vx1, vy1, vx2, vy2
					Line vx2, vy2, vx0, vy0	
					
					Color 255, 255, 255
					
					
					
					If turnoninviso = 1 Then EntityAlpha mesh, 0
					
					
					
				EndIf
				
			Next
			
		Next		
		
	EndIf	
	
End Function

Function BackFacing (surf, v0, v1, v2, mesh, camera)
	
    ;vertex position
    x0# = VertexX (surf, v0): y0# = VertexY (surf, v0): z0# = VertexZ (surf, v0)
    x1# = VertexX (surf, v1): y1# = VertexY (surf, v1): z1# = VertexZ (surf, v1)
    x2# = VertexX (surf, v2): y2# = VertexY (surf, v2): z2# = VertexZ (surf, v2)
    
    ;deltas
    dx1# = x1 - x0: dy1# = y1 - y0: dz1# = z1 - z0
    dx2# = x2 - x0: dy2# = y2 - y0: dz2# = z2 - z0
	
    ;cross product
    cx# = dy1 * dz2 - dy2 * dz1
    cy# = dz1 * dx2 - dz2 * dx1
    cz# = dx1 * dy2 - dx2 * dy1
    
    ;normalize...
    sz# = Sqr (cx * cx + cy * cy + cz * cz)
    cx = cx / sz: cy = cy / sz: cz = cz / sz
    
    ;plane offset
    dt# = -(cx * x0 + cy * y0 + cz * z0)
    
    ;tranform eye to mesh coords
    TFormPoint 0, 0, 0, camera, mesh
    
    Return TFormedX () * cx + TFormedY () * cy + TFormedZ () * cz + dt &gt; 0
    
End Function




Function Delta_Time()
	NewTime = MilliSecs()	
	dt = Float (NewTime - OldTime)/1000
	OldTime = NewTime
	TotalTime = TotalTime + dt
End Function



;fps calc
Function FPS$()
    framecounter_counter=framecounter_counter+1
    If framecounter_time=0 Then framecounter_time=MilliSecs()
    If framecounter_time+1001&lt;MilliSecs() Then
        framecounter_framerate=framecounter_counter
		framecounter_counter=0
        framecounter_time=MilliSecs()
	EndIf
	zsemi$="FPS: "+framecounter_framerate
	Return zsemi$
End Function

End

.WayPointDefinition
;Path 1
Data -3, 0, 0, 100, 0, 0,  0
Data -1, 2,-5, 150, 0, 0, 50
Data  1, 1, 0, 100, 0, 0,  0
Data  3,-2,4, 100, 0, 0,-30
;Path 2
Data -3, 0, 4,  50,  60,   0,   0
Data -1, 3, 5, 100,   0,   0,  60
Data  1, 1, 6,  50,   0, -50,   0
Data  3,-3, 2, 100, -20,   0, -60
</textarea><br><br>but... if you don't understand how the Path following system work, then any other changes will require other people intervention. Please try to use tools that you understand, or take the time to learn some technique before to start a new idea. I know that our imagination normally goes in another speed, but try to code and make real some basic ideas first. Know exactly what each one does and then, only then, try a new step.<br><br>(my english is terrible, hope you understand what i tried to say..)<br><br>Juan<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121180"></a>

<a name="1121182"></a>

<a name="1121183"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> OMG! THIS IS PERFECT, CHARRUA! =D This is EXACTLY what I invisioned! And ur right about the delete thing. HOWEVER. BECAUSE I am creating a small editor WHICH I am releasing in the Code archives for everyone when it's finished, AND because it SAVES the NEW coordinates to a FILE and writes out an EXAMPLE of how to USE it, this is PERFECT and does NOT REQUIRE deletion of a waypoint! :)<br><br>Btw, ur english is JUST fine, I understand u enough to get the point! :)<br><br><br>Thanks alot, Charrua! :)<br><br><br>U shall be added to the credits! :) I CANNOT thank u enough! :)<br><br>EDIT: I DID notice a SMALL glitch. when u hold the mouse down, then move the mouse a little, the dots keep going o.o Other than that, its PERFECT! :)<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121185"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> there should be some refinements<br><br>i call InitPaths() wich reinitialize All the paths defined, if you think it twice, it should be good to initialize only the path that contain the waypoint modified... if you use only one path this isn't necesary<br><br>when dragging it should be good to limit the axis on wich changes are made, or give the user the hability to select wich axis is edited... only two at a time or only one...<br><br><br>juan <br><br></td></tr></table><br>
<a name="1121186"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> this "strange behavior" is related (i supose) not with InitPath, is related to the way the x,y,z position and orientation of the waypoint is done, for this is that i sugested to limit/select wich axis is edited. I saw that efect and as i see the x,y position on screen don't change but the z position is being modified and so, the path (visible dots). <br><br></td></tr></table><br>
<a name="1121187"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok. Ill add axis limiting in a bit. right now, ive found a few more things i would like to fix. :) I will do each of these problems, one step at a time.<br><br>1st problem is keeping the moving object at a constant speed no matter HOW stretched out the bezier waypoint path is :) <br><br></td></tr></table><br>
<a name="1121188"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> ja ja<br>this is a subject for a tesis...<br><br>in the system i made, the amount of steps is defined when the Waypoint is created and independent of the distance of the path that follow the waypoints.<br><br>for this reason the speed is diferent, i saw some work's about this subject but one aproach should be, to calculate the distance of the path between each pair of waypoint and, then redefine the \nSteps acordingly<br><br>remember that each modification you made on the variables (stored on the tWayPont or another object) will be reflected after InitPath <br><br></td></tr></table><br>
<a name="1121189"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's what I have so far: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Function NewWP.tWayPoint(Path.tPath, x#, y#, z#, nSteps=100, pitch#=0, yaw#=0, roll#=0)
	
	wp.tWayPoint = New tWayPoint
	
	wp\PathID = Path\PathId
	
	Path\WPCount = Path\WPCount+1
	If Path\pFirst=0 Then
		Path\pFirst = Handle(wp)
		Path\CurrentWP = Path\pFirst
		PositionEntity Path\CurrPos,x,y,z
		RotateEntity Path\CurrPos,pitch,yaw,roll
	End If
	Path\pLast = Handle(wp)
	wp\Entity = CreatePivot()
	wp\cp1 = CreatePivot(wp\Entity)
	wp\cp2 = CreatePivot(wp\Entity)
	PositionEntity wp\Entity,x,y,z
	wp\nSteps = 100 ;nSteps
	wp\CurrStep = 0
	wp\pitch = pitch
	wp\yaw = yaw
	wp\roll = roll
	
	Return wp
	
End Function</textarea> <br><br></td></tr></table><br>
<a name="1121211"></a>

<a name="1121212"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> i guess you missread or don't understood my #33 post.<br><br>if two waypoints are 200 blitz units distant from each other and another pair is 2000 (ten times) blitz units distant, making \nSteps constant implies that the distance between steps will be 10 times bigger. <br><br>if you need a constant speed you have to work on the subject a little more:<br>recalculate nSteps as a function of the distance between 2 adjacent waypoints (that guarantees constant speed between any pair of waypoint, but not between two interpolated points!)<br><br>as i said, that is a subject for a more mathematical aproach, far away of my path following system (and knowledge sorry)<br><br>i read somewhere (don't remember) that some one else work on a "constant speed between 2 interpolated points over a bezier curve"<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121218"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> if its 3d, does anyone happen to know which thread that charrua is talking about? that is VERY useful information :) <br><br></td></tr></table><br>
<a name="1121268"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does anyone know where I can find this post? :) <br><br></td></tr></table><br>
<a name="1121269"></a>

<a name="1121270"></a>

<a name="1121271"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GitTech</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://www.blitzbasic.com/Community/posts.php?topic=96737#1121188" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=96737#1121188</a><br><br><br>:-)<br><br><br><br>EDIT: I assume you mean the "#33 post" Charrua is refering to?<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121273"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> No, I mean post #35 :) <br><br></td></tr></table><br>
<a name="1121300"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> can anyone else help? :) I would greatly appreciate it! :) <br><br></td></tr></table><br>
<a name="1121322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Code Archives -&gt; Algorithms -&gt; CTRL+F to search for "constant" by Warpy. <br><br></td></tr></table><br>
<a name="1121379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awe crap &gt;&lt; This is 2D.. AND its blitzmax.... :/ Im not able to convert that to 3D OR Blitzbasic... :/<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 800,800,0

Local ax=50,ay=50,bx=400,by=50,cx=350,cy=750,dx=750,dy=750
t1#=0
t2#=0
speed#=0 'Speed of clever speed changing version
x1#=ax
y1#=ay
x2#=ax
y2#=ay
While Not KeyHit(KEY_ESCAPE)
	SetColor 100,100,100
	bezier(ax,ay,bx,by,cx,cy,dx,dy) 'draw the curve
	
	ox1#=x1
	oy1#=y1
	ox2#=x2
	oy2#=y2
	
	'CLEVER SPEED CHANGING VERSION
	t1:+speed
	If t1&gt;1 Then t1=0
	a#=t1
	b#=1-t1
	x1#=ax*b*b*b + 3*bx*b*b*a + 3*cx*b*a*a + dx*a*a*a
	y1#=ay*b*b*b + 3*by*b*b*a + 3*cy*b*a*a + dy*a*a*a
	SetColor 255,255,0
	DrawRect x1-3,y1-3,7,7

	'Calculate 'speed' of curve at this point. 
	vx#=-3*ax*b*b + 3*bx*b*(b-2*a) + 3*cx*a*(2*b-a) + dx*3*a*a
	vy#=-3*ay*b*b + 3*by*b*(b-2*a) + 3*cy*a*(2*b-a) + dy*3*a*a
	d#=Sqr(vx*vx+vy*vy)

	'Watch out, magic ahead!

	speed#=1/d 'Make the ball moves less along the curve the 'faster' the curve is at this point, so the ball's *actual* cartesian velocity should stay roughly constant

	'You missed the magic! Go back!

	'Check what the actual speed is
	movedist1#=Sqr((ox1-x1)^2+(oy1-y1)^2)
	DrawText movedist1,0,0

	'Boring old version, t increments at a constant rate
	t2:+.001
	If t2&gt;1 Then t2=0
	a#=t2
	b#=1-t2
	x2#=ax*b*b*b + 3*bx*b*b*a + 3*cx*b*a*a + dx*a*a*a
	y2#=ay*b*b*b + 3*by*b*b*a + 3*cy*b*a*a + dy*a*a*a
	SetColor 0,0,255
	DrawRect x2-3,y2-3,7,7

	'Check what the actual speed is
	movedist2#=Sqr((ox2-x2)^2+(oy2-y2)^2)
	DrawText movedist2,0,15

	Flip
	Cls
Wend

'DON'T BE DECEIVED! This is just a plain old bezier-drawing function, to show the curve the balls are moving along
Function bezier(ax#,ay#,bx#,by#,cx#,cy#,dx#,dy#)
	DrawLine ax,ay,bx,by
	DrawLine cx,cy,dx,dy
	ox#=ax
	oy#=ay
	For t#=0 To 1 Step .01
		a#=t
		b#=1-t
		x#=ax*b*b*b + 3*bx*b*b*a + 3*cx*b*a*a + dx*a*a*a
		y#=ay*b*b*b + 3*by*b*b*a + 3*cy*b*a*a + dy*a*a*a
		DrawRect x-1,y-1,3,3
		DrawLine ox,oy,x,y
		ox=x
		oy=y
	Next
End Function</textarea> <br><br></td></tr></table><br>
<a name="1121530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone? :/ <br><br></td></tr></table><br>
<a name="1121540"></a>

<a name="1121541"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> the translation to Blitz3D involve change the DrawText and DrawLine to Text and Line, "t1:+speed" to t1=t1+speed and "t2:+0.001" to t2=t2+0.001<br><br>KEY_ESCAPE is a constant with the value 1 (same for blitz)<br><br>the mathematical part don't need any changes. 3d only adds the z axis, try to compare the bezier interpolation warpy uses (in 2d) with the Interpolate_Pos in the waypoint system, you'll see that the Math part is the same, with a new z component. <br><br>as i said before, these forums has many nice pieces of code, assemble them to suit your needs is "your work", came on, nothing is going to happen without work. We can help, but no one work's for you.<br><br>BlitzMax Warpy's code translated to Blitz3D<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 800,800,0

Const KEY_ESCAPE=1

Local ax=50,ay=50,bx=400,by=50,cx=350,cy=750,dx=750,dy=750
t1#=0
t2#=0
speed#=0 ;Speed of clever speed changing version
x1#=ax
y1#=ay
x2#=ax
y2#=ay

While Not KeyHit(KEY_ESCAPE)

	Color 100,100,100	;SetColor 100,100,100
	
	bezier(ax,ay,bx,by,cx,cy,dx,dy) ;draw the curve
	
	ox1#=x1
	oy1#=y1
	ox2#=x2
	oy2#=y2
	
	;CLEVER SPEED CHANGING VERSION
	
	t1 = t1+speed	;t1:+speed
	
	If t1&gt;1 Then t1=0
	a#=t1
	b#=1-t1
	x1#=ax*b*b*b + 3*bx*b*b*a + 3*cx*b*a*a + dx*a*a*a
	y1#=ay*b*b*b + 3*by*b*b*a + 3*cy*b*a*a + dy*a*a*a
	Color 255,255,0		;SetColor 255,255,0
	Rect  x1-3,y1-3,7,7	;DrawRect x1-3,y1-3,7,7

	;Calculate 'speed' of curve at this point. 
	vx#=-3*ax*b*b + 3*bx*b*(b-2*a) + 3*cx*a*(2*b-a) + dx*3*a*a
	vy#=-3*ay*b*b + 3*by*b*(b-2*a) + 3*cy*a*(2*b-a) + dy*3*a*a
	d#=Sqr(vx*vx+vy*vy)

	;Watch out, magic ahead!

	speed#=1/d ;Make the ball moves less along the curve the 'faster' the curve is at this point, so the ball's *actual* cartesian velocity should stay roughly constant

	;You missed the magic! Go back!

	;Check what the actual speed is
	movedist1#=Sqr((ox1-x1)^2+(oy1-y1)^2)
	Text 0, 0, movedist1	;DrawText movedist1,0,0

	;Boring old version, t increments at a constant rate
	t2 = t2+0.001	;t2:+.001
	If t2&gt;1 Then t2=0
	a#=t2
	b#=1-t2
	x2#=ax*b*b*b + 3*bx*b*b*a + 3*cx*b*a*a + dx*a*a*a
	y2#=ay*b*b*b + 3*by*b*b*a + 3*cy*b*a*a + dy*a*a*a
	Color 0,0,255		;SetColor 0,0,255
	Rect x2-3,y2-3,7,7	;DrawRect x2-3,y2-3,7,7

	;Check what the actual speed is
	movedist2#=Sqr((ox2-x2)^2+(oy2-y2)^2)
	Text 0, 15, movedist2	;DrawText movedist2,0,15

	Flip
	
	Cls
	
Wend

;DON'T BE DECEIVED! This is just a plain old bezier-drawing Function, To show the curve the balls are moving along
Function bezier(ax#,ay#,bx#,by#,cx#,cy#,dx#,dy#)

	Line ax,ay,bx,by	;DrawLine ax,ay,bx,by
	Line cx,cy,dx,dy	;DrawLine cx,cy,dx,dy
	ox#=ax
	oy#=ay
	For t#=0 To 1 Step .01
		a#=t
		b#=1-t
		x#=ax*b*b*b + 3*bx*b*b*a + 3*cx*b*a*a + dx*a*a*a
		y#=ay*b*b*b + 3*by*b*b*a + 3*cy*b*a*a + dy*a*a*a
		Rect x-1,y-1,3,3	;DrawRect x-1,y-1,3,3
		Line ox,oy,x,y		;DrawLine ox,oy,x,y
		ox=x
		oy=y
	Next
End Function
</textarea><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121542"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Isnt there a way u can modify ur bezier waypoint code? <br><br></td></tr></table><br>
<a name="1121617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RifRaf</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow <br><br></td></tr></table><br>
<a name="1142598"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Verry Nice! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
