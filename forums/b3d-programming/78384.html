<!DOCTYPE html><html lang="en" ><head ><title >Blitz3D now can control a WiiMote! (I hope)</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Blitz3D now can control a WiiMote! (I hope)</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Blitz3D now can control a WiiMote! (I hope)</a><br><br>
<a name="879214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's my weekend work about WiiMote's<br><br>Hope some one found that interesting<br><br>First some .decls<br><br>file wii_kernel32.decls<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

.lib "Kernel32.dll" 

wiiCreateFile%(lpFileName$, dwDesiredAccess, dwShareMode, lpSecurrityAttributes, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile) : "CreateFileA"
wiiCreateFileOverlapped%(lpFileName$, dwDesiredAccess, dwShareMode, lpSecurrityAttributes*, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile) : "CreateFileA"
wiiCloseHandle%(hObject) : "CloseHandle" 
wiiWriteFile%(hFile, lpBuffer*, nNumberOfBytesToWrite, lpNumberOfBytesWritten*, lpOverlapped) : "WriteFile" 
wiiReadFile%(hFile, lpBuffer*, nNumberOfBytesToRead, lpNumberOfBytesRead*, lpOverlapped*) : "ReadFile"
wiiWaitForSingleObject%(nHandle, dwMilliseconds) : "WaitForSingleObject"
wiiCreateEvent%(lpSecurityAttributes*, bManualReset, bInitialState, lpName ) : "CreateEventA"
wiiResetEvent%(hEvent) : "ResetEvent"
wiiCancelIo%(hFile) : "CancelIo"
</textarea><br><br>file wii_hid.decls<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

.lib "Hid.dll"

wiiHidD_GetAttributes%(HidDeviceObject, Attributes*): "HidD_GetAttributes"
wiiHidD_GetHidGuid%(HidGuid*) : "HidD_GetHidGuid"
</textarea><br><br>file wii_setupapi.decls<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

.lib "setupapi.dll"

wiiSetupDiDestroyDeviceInfoList%(DeviceInfoSet) : "SetupDiDestroyDeviceInfoList"
wiiSetupDiEnumDeviceInterfaces%(DeviceInfoSet, DeviceInfoData, InterfaceClassGuid*, MemberIndex, DeviceInterfaceData*) : "SetupDiEnumDeviceInterfaces"
wiiSetupDiGetClassDevs%(ClassGuid*, Enumerator$, hwndParent, Flags) : "SetupDiGetClassDevsA"
wiiSetupDiGetDeviceInterfaceDetail%(DeviceInfoSet, DeviceInterfaceData*, DeviceInterfaceDetailData, DeviceInterfaceDetailDataSize, RequiredSize*, DeviceInfoData) : "SetupDiGetDeviceInterfaceDetailA"
wiiSetupDiGetDeviceInterfaceDetail2%(DeviceInfoSet, DeviceInterfaceData*, DeviceInterfaceDetailData*, DeviceInterfaceDetailDataSize, RequiredSize*, DeviceInfoData) : "SetupDiGetDeviceInterfaceDetailA"
</textarea><br><br>and finally, one .bb: Wimote1.bb<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;
;	I hope this should be of interest for some one else
;	I try to do the things easy, and I ask for help.... ...., wait, wait, ....
;		 but no one seems to be working with wiimotes in Blitz3d.
;
;							so that's my weekend work!
;
;
;	If some one need translation, ask me, I do what I can
;															(only if i's necesary)
;
;								Juan Ignacio Odriozola
;									jio@...


;*********************************************************************************
;
;	WiiMote desde Blitz3d
;
;		.decls necesarios: wii_hid.decls, wii_kernel32.decls, wii_setupapi.decls
;		(en las definiciones de las funciones se les ha incorporado wii como prefijo)
;
;	ObtenerHID: Busca un WiiMote, si lo encuentra fija HIDHandle para escritura y
;				ReadHandle para lectura solapada. Devuelve true o false según exito o no.
;
;	Escribir(Cantidad)	;transmite 22 bytes siempre (HIDHandle)
;						;previo hay que inicializar OutputReportData con la info a Tx
;						;Cantidad indica cuantos he inicializado, para que la rutina
;						;borre el resto del buffer
;
;	Leer(TOut)		;Ordena una lectura (ReadHandle), espera recibir 22 bytes o TOut
;					;Si operación de lectura exitosa devuelve True, si TOut devuelve False
;
;			Si Lectura exitosa: WiiMote\DReporting = Tipo de reporte recibido
;								WiiMote\RxCount	= cantidad de bytes recibidos
;								ReadBuffer contiene los bytes recibidos
;
;
;	Si BlueSolei ha detectado alguna vez al WiiMote, es encontrado en la lista por
;	ObtenerHID, se le asigna un HIDHandle y un ReadHandle.
;	Leer puede dar TimeOut porque el WiiMote se ha apagado, se quedó sin batería etc.
;
;
;
;	Uso: Teclas 1, 2, 3, 4 Prenden/Apagan los leds del WiiMote
;		 Tecla 5 apaga los 4 leds
;		 Tecla 6: Activa/Desactiva vibración (rumble)
;
;		 Esc: Fin del programa
;		 Depurando = true/false: debug on/off
;
;
;
;	"Básicamente traduje un programa Visual Basic 6" originalmente escrito por Jean Axelson
;	para la comunicación con HID, pensado en forma genérica para cualquier dispositivo USB
;	modificado por:  para encontrar un WiiMote.
;
;	Escribí las .decls desde el .bas de Visual en el que se declaraban las api's para visual.
;
;	modifique unas cuantas cosas, tanto que no se parece mucho al original, para que pudieran
;	ser usadas desde Blitz3d.
;
;	por ahora estoy conforme, espero le sirva a alguien más.
;
;
;	Referencias:
;
;	Trabajo original de Jean Axelson	
;					www.Lvr.com/hidpage.htm
;	Primera modificación para WiiMote
;					2007/1/9 tokkyo (http://onakasuita.org/wii/)
;					see <a href="http://www.wiili.org/index.php/Wiimote" target="_blank">http://www.wiili.org/index.php/Wiimote</a> For details
;
;
;	mucha información
;	<a href="http://wiibrew.org/index.php?title=Wiimote" target="_blank">http://wiibrew.org/index.php?title=Wiimote</a>	&lt;&lt;&lt;&lt;&lt; Gracias mil!
;	
;
;*********************************************************************************



Const REGISTER_IR 					 = $04b00030
Const REGISTER_IR_SENSITIVITY_1 	 = $04b00000
Const REGISTER_IR_SENSITIVITY_2 	 = $04b0001a
Const REGISTER_IR_MODE 				 = $04b00033

Const REGISTER_EXTENSION_INIT 		 = $04a40040
Const REGISTER_EXTENSION_TYPE 		 = $04a400fe
Const REGISTER_EXTENSION_CALIBRATION = $04a40020


Global HIDHandle
Global ReadHandle
Global MyDeviceDetected=False

Global OutputReportData = CreateBank(255)
Global ReadBuffer 		= CreateBank( 22)
Global Security 		= CreateBank( 12)
Global HIDOverlapped 	= CreateBank( 20)

Global EventObject
Global Depurando=True

Type Controller

	Field Rumble = False
	Field TxContinuo = False
	Field Led1 = False
	Field Led2 = False
	Field Led3 = False
	Field Led4 = False
	
	Field IrMode = 0	;off, basic, extended, full: 00, 01, 03, 05
	Field DReporting	;Primer byte de la respuesta
	Field DRNoConocido
	Field RxCount
	Field Energia
	
	Field Botones1	; . . . + Up Dn Rg Lf
	Field Botones2	; H . . - A  B  1  2
	
	Field Boton_A 		= False
	Field Boton_B 		= False
	Field Boton_Minus 	= False
	Field Boton_Home 	= False
	Field Boton_Plus 	= False
	Field Boton_One 	= False
	Field Boton_Two 	= False
	Field Boton_Up 		= False
	Field Boton_Down 	= False
	Field Boton_Left 	= False
	Field Boton_Right 	= False

	Field AccelX
	Field Accely
	Field AccelZ
	
	Field PMx	;coordenadas del punto medio de P1 y P2 (IR)
	Field PMy

	Field P1x	;para los 4 puntos IR
	Field P1y
	Field P1t	;-1 si no se ve, o si no un campo Presente
	
	Field P2x
	Field P2y
	Field P2t

	Field P3x
	Field P3y
	Field P3t
	
	Field P4x
	Field P4y
	Field P4t
	
End Type

Global WiiMote.Controller = New Controller

SetBuffer BackBuffer()

MyDeviceDetected = ObtenerHID()

SolicitarEstado()

NoIR()

ModoDeRespuesta($31)

;continuous = off: solo tx si hay cambios
;

Repeat
	Cls

	LeoTeclado()
	
	If Leer(10) Then
		EvaluoRecepcion
	Else
		;time out
		Locate 10,100
		Write "TimeOut"
	End If

	;muestro variables del WiiMote
	;los últimos valores recibidos
	Locate 10,10
	Write WiiMote\AccelX
	Locate 40,10
	Write WiiMote\AccelY
	Locate 70,10
	Write WiiMote\AccelZ
	
	Locate 100,10
	Write "Batt: "+WiiMote\Energia
	
	Locate 180,10
	If WiiMote\Led1 Then 
		Write "1"
	Else
		Write "."
	End If
	
	Locate 190,10
	If WiiMote\Led2 Then 
		Write "1"
	Else
		Write "."
	End If
	
	Locate 200,10
	If WiiMote\Led3 Then 
		Write "1"
	Else
		Write "."
	End If
	
	Locate 210,10
	If WiiMote\Led4 Then 
		Write "1"
	Else
		Write "."
	End If
	
	
	Locate 10,30
	Write Right$(Bin$(WiiMote\Botones1),8) + "-" +Right$(Bin$(WiiMote\Botones2),8)
	
	Locate 200,30
	Write "?: "+WiiMote\DRNoConocido


	Flip True

Until KeyHit(1)

FreeBank HIDOverlapped

If MyDeviceDetected Then
	Result = wiiCloseHandle(HIDHandle)
	Result = wiiCloseHandle(ReadHandle)
End If

FreeBank Security
FreeBank OutputReportData
FreeBank ReadBuffer


End

;****************************************************************************************

Function LeoTeclado()

	If KeyHit(2) Then	;tecla 1
		WiiMote\Led1 = Not(WiiMote\Led1)
		ActualizarLeds()
	End If
	If KeyHit(3) Then	;tecla 2
		WiiMote\Led2 = Not(WiiMote\Led2)
		ActualizarLeds()
	End If
	If KeyHit(4) Then	;tecla 3
		WiiMote\Led3 = Not(WiiMote\Led3)
		ActualizarLeds()
	End If
	If KeyHit(5) Then	;tecla 4
		WiiMote\Led4 = Not(WiiMote\Led4)
		ActualizarLeds()
	End If
	If KeyHit(6) Then	;tecla 5 apaga todos los leds
		;leds apagados, rumble off
		ControlarLeds(False,False,False,False)
		Escribir(2)
		SolicitarEstado()
	End If
	If KeyHit(7) Then
		WiiMote\Rumble = Not(WiiMote\Rumble)
		ActualizarLeds()
	End If
End Function


Function ActualizarLeds()
	ControlarLeds(WiiMote\Led4,WiiMote\Led3,WiiMote\Led2,WiiMote\Led1)
End Function


Function ControlarLeds(l1,l2,l3,l4)
											;LEDS		0x11
	Dato=0
	If l1 Then Dato=$80
	If l2 Then Dato=Dato Or $40
	If l3 Then Dato=Dato Or $20
	If l4 Then Dato=Dato Or $10
	If WiiMote\Rumble Then Dato=Dato Or $01
	PokeByte(OutputReportData,0,$11)
	PokeByte(OutputReportData,1,Dato)
	Escribir(2)
End Function

Function NoIR()
	;disable IR
	PokeByte(OutputReportData,0,$13)
	PokeByte(OutputReportData,1,  0)
	Escribir(2)
	PokeByte(OutputReportData,0,$1A)
	PokeByte(OutputReportData,1,  0)
	Escribir(2)
	WiiMote\P1t = -1
	WiiMote\P2t = -1
	WiiMote\P3t = -1
	WiiMote\P4t = -1
End Function

Function ModoDeRespuesta(tipo)
											;TYPE		0x12
	PokeByte(OutputReportData,0,$12)
	PokeByte(OutputReportData,1,  0)
	PokeByte(OutputReportData,2,tipo)
	Escribir(3)
End Function

Function SolicitarEstado()
											;STATUS		0x15
	PokeByte(OutputReportData,0,$15)
	PokeByte(OutputReportData,1,  0)
	Escribir(2)	;status
End Function


; rutinas que analizan los datos del buffer de lectura
; son invocadas desde EvaluoRecepción, dependiento del tipo de reporte.

Function DeglozarBotones()
	Byte1 = PeekByte(ReadBuffer,1)
	Byte2 = PeekByte(ReadBuffer,2)
	WiiMote\Botones1 	= Byte1 And $1F	;0001 1111
	WiiMote\Botones2 	= Byte2 And $9F	;1001 1111
	WiiMote\Boton_A 	= (Byte2 And $08) &lt;&gt; 0
	WiiMote\Boton_B 	= (Byte2 And $04) &lt;&gt; 0
	WiiMote\Boton_Minus = (Byte2 And $10) &lt;&gt; 0
	WiiMote\Boton_Home 	= (Byte2 And $80) &lt;&gt; 0
	WiiMote\Boton_Plus 	= (Byte1 And $10) &lt;&gt; 0
	WiiMote\Boton_One 	= (Byte2 And $02) &lt;&gt; 0
	WiiMote\Boton_Two 	= (Byte2 And $01) &lt;&gt; 0
	WiiMote\Boton_Up 	= (Byte1 And $08) &lt;&gt; 0
	WiiMote\Boton_Down 	= (Byte1 And $04) &lt;&gt; 0
	WiiMote\Boton_Left 	= (Byte1 And $01) &lt;&gt; 0
	WiiMote\Boton_Right = (Byte1 And $02) &lt;&gt; 0
End Function

Function DeglozarAceleraciones()
	WiiMote\AccelX = PeekByte(ReadBuffer,3)
	WiiMote\AccelY = PeekByte(ReadBuffer,4)
	WiiMote\AccelZ = PeekByte(ReadBuffer,5)
End Function


Function EvaluoRecepcion()
	;se llama solo si se ha recibido ok	
	
	Select WiiMote\DReporting
		Case $20
			;status
			WiiMote\Energia = PeekByte(ReadBuffer,6)
			WiiMote\Led1 = (PeekByte(ReadBuffer,3) And $80) &lt;&gt; 0
			WiiMote\Led2 = (PeekByte(ReadBuffer,3) And $40) &lt;&gt; 0
			WiiMote\Led3 = (PeekByte(ReadBuffer,3) And $20) &lt;&gt; 0
			WiiMote\Led4 = (PeekByte(ReadBuffer,3) And $10) &lt;&gt; 0
			WiiMote\TxContinuo = (PeekByte(ReadBuffer,3) And $08) &lt;&gt; 0
		Case $21
			;Read
			
		Case $22
			;write
		
		Case $30
			DeglozarBotones()
		Case $31
			DeglozarBotones()
			DeglozarAceleraciones()
		Case $32
			DeglozarBotones()
		Case $33
			DeglozarBotones()
			DeglozarAceleraciones()
		Case $34
			DeglozarBotones()
		Case $35
			DeglozarBotones()
			DeglozarAceleraciones()
		Case $36
			DeglozarBotones()
		Case $37
			DeglozarBotones()
			DeglozarAceleraciones()
		Case $3D
		
		Case $3E
			DeglozarBotones()
		Case $3F
			DeglozarBotones()
		
		Default
			WiiMote\DRNoConocido = WiiMote\DRNoConocido + 1
	End Select
	
End Function

;funciones más que necesarias
;ObtenerHID, Leer, Escribir

Function Leer(TOut)

	;1) Si dispositivo no detectado, trata de encontrar uno
	;
	;2) Si dispositivo encotrado, manda leer
	;		si Lectura completada con éxito: devuelve true =&gt; ReadBuffer tiene lo recibido
	;		si TOut: cancela la lectura y devuelve false
	
	
	LecturaOk = False
	
	If MyDeviceDetected = False Then
		;intento encontrar uno
	    MyDeviceDetected = ObtenerHID()
	End If
	
	If MyDeviceDetected Then
		;si hay uno
		WAIT_TIMEOUT = $102
		WAIT_OBJECT_0 = $0
		
		NBRx = CreateBank(4)
		;Inicio la operación de lectura
		Result = wiiReadFile(ReadHandle, ReadBuffer, 22, NBRx, HIDOverlapped)
		;Regresa inmediatamente
		WiiMote\RxCount = PeekInt(NBRx,0)
		FreeBank NBRx
		;ahora espero a que lleguen los 22 o timeout
		Result = wiiWaitForSingleObject(EventObject, TOut)	;esto espera mismo.
		
		;ahora hay que evaluar los casos.
		
		Select Result
		    Case WAIT_OBJECT_0
	        	;ReadFile has completed
				WiiMote\DReporting = PeekByte(ReadBuffer,0)
				LecturaOk = True
	
		    Case WAIT_TIMEOUT
		        ;Timeout
		        ;Cancelo la operación
				Result = wiiCancelIo(ReadHandle)
				LecturaOk = False
	
			Default
				LecturaOk = False
	
		End Select
	
		wiiResetEvent(EventObject)
		
	End If
	
	Return LecturaOk		;true si habia un witmote y rx ok sin time out
							;false si habio uno y time out, o no habia y sigue sin haber

End Function



Function Escribir(Cantidad)

	;si dispositivo no detectado, trata de encontrar uno
	;si ya hay uno
	;	previo al llamado hay que ubicar en OutputReportData los datos a transmitir
	;	Cantidad indica cuantos hay en el buffer
	;	siempre se transmiten 22
	
	NumeroDeBytesEscritos = 0
	
	If MyDeviceDetected = False Then
	    MyDeviceDetected = ObtenerHID()
	Else
		OutBuffer=CreateBank(22)
		;copio de OutputReportData a OutBuffer solo Cantidad bytes
		;el resto se borra
		For i=0 To 21
			If i&lt;Cantidad Then
				PokeByte(OutBuffer,i,PeekByte(OutputReportData,i))
			Else
				PokeByte(OutBuffer,i,0)
			End If
		Next
		Temp = CreateBank(4)
		Result = wiiWriteFile(HIDHandle, OutputReportData, 22, Temp, 0)
		NumeroDeBytesEscritos = PeekInt(Temp,0)
		FreeBank Temp
		FreeBank OutBuffer
	End If
	
	Return NumeroDeBytesEscritos

End Function



Function ObtenerHID()

	;busca en la lista de dispositivos el primer WiiMote
	;si lo encuentra, abre dos archivos HIDHandle para escritura 
	;y ReadHandle para lectura Overlapped
	;devuelve MyDeviceDetected que indica si la operación fué exitosa
	
	FILE_SHARE_READ = $1
	FILE_SHARE_WRITE = $2
	GENERIC_READ = $80000000
	GENERIC_WRITE = $40000000
	OPEN_EXISTING = 3
	FILE_FLAG_OVERLAPPED = $40000000
	
	GUID = CreateBank(16)	;long, int, int, array(0..7) byte
	;son estructuras, en las que el primer elemento (4 bytes) indica su tamaño
	;se pasan por referencia y hay que inicializar su tamaño antes de usarlas
	
	MyDeviceInterfaceDetailData = CreateBank(5)
	PokeInt(MyDeviceInterfaceDetailData,0,5)
	
	MyDeviceInfoData = CreateBank(28)
	PokeInt(MyDeviceInfoData,0,28)

	MyDeviceInterfaceData = CreateBank(28)
	PokeInt(MyDeviceInterfaceData,0,28)
	
	;esta estructura es escrita por HidD_GetAttributes, de ella se saca Vendedor, producto y versión
	DeviceAttributes = CreateBank(10)	;size(4), VendorID, ProductID, Version 2,2,2.
	
	DeviceInfoSet=0
	DevicePathName$=""
	Flags = 16 + 2
	DetailData=0
	LastDevice=False
	Detectado = False
	
	;Security es una estructura con tres variables tipo long
	PokeInt(Security, 0,  12)	;length 
	PokeInt(Security, 4,   0)	;lpSecurityDescriptor
	PokeInt(Security, 8,True)	;bInheritHandle
	
	
	HIDHandle = -1

	Result = wiiHidD_GetHidGuid(GUID)
	
	If Depurando Then
		DebugLog t
		DebugLog Hex(PeekInt(GUID,0))
		DebugLog Right$(Hex(PeekShort(GUID,4)),4)
		DebugLog Right$(Hex(PeekShort(GUID,6)),4)
		For i=8 To 15
			DebugLog Right$(Hex(PeekByte(GUID,i)),2)
		Next
	End If
	
	DeviceInfoSet = wiiSetupDiGetClassDevs(GUID,"",0,Flags)
	
	MemberIndex=0
	
	Needed = CreateBank(4)
	
	
	Repeat
	
		;PokeInt(MyDeviceInterfaceData,0,28)
		Result = wiiSetupDiEnumDeviceInterfaces(DeviceInfoSet,0,GUID,MemberIndex,MyDeviceInterfaceData)
		    
		If Result = 0 Then 
			LastDevice = True
		Else
	
			;PokeInt(MyDeviceInfoData,0,28)
			
			;tercer parámetro por valor
	        Result = wiiSetupDiGetDeviceInterfaceDetail(DeviceInfoSet, MyDeviceInterfaceData, 0, 0, Needed, 0)
	        
	        DetailData = PeekInt(Needed,0)
	
			;PokeInt(MyDeviceInterfaceDetailData,0,5)
	        
	        DetailDataBuffer = CreateBank(DetailData)
			Cuantos = DetailData
			PokeInt(DetailDataBuffer,0,5)
			
			;tercer parámetro por referencia
			Result = wiiSetupDiGetDeviceInterfaceDetail2(DeviceInfoSet, MyDeviceInterfaceData, DetailDataBuffer, DetailData, Needed, 0)
			
			strtmp$ = ""
			For i=4 To Cuantos-1
				strtmp$ = strtmp$ + Chr$(PeekByte(DetailDataBuffer,i))
			Next
			DebugLog strtmp$
			
			FreeBank DetailDataBuffer
			
			DevicePathName$ = strtmp$
			
			HIDHandle = wiiCreateFileOverlapped(DevicePathName, GENERIC_READ Or GENERIC_WRITE, (FILE_SHARE_READ Or FILE_SHARE_WRITE), Security, OPEN_EXISTING, 0, 0)
	
			If Depurando Then DebugLog "Handle ID: "+HIDHandle
	        
			Result = wiiHidD_GetAttributes(HIDHandle, DeviceAttributes)
			
			VendorID = PeekShort(DeviceAttributes,4)
			ProductID = PeekShort(DeviceAttributes,6)
			
			If Depurando Then DebugLog "VendorID : "+Hex(VendorID)+"  Product: "+Hex(ProductID)
	
			If (VendorID = $057E) And (ProductID = $0306) Then
	           	Detectado = True
				ReadHandle = wiiCreateFileOverlapped(DevicePathName, GENERIC_READ Or GENERIC_WRITE, (FILE_SHARE_READ Or FILE_SHARE_WRITE), Security, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0)
				;preparativos para la transferencia solapada
				If EventObject = 0 Then
					EventObject = wiiCreateEvent(Security,True,True,"")
				End If
				;HIDOverlapped es una estructura con 5 variables tipo Long
				;Internal, InternalHigh, Offset, OffsetHigh, hEvent
				PokeInt(HIDOverlapped, 8,0)				;offset
				PokeInt(HIDOverlapped,12,0)				;offsethigh
				PokeInt(HIDOverlapped,16,EventObject)	;hEvent
				
				If Depurando Then DebugLog "WiiMote encontrado"
	        Else
				Detectado = False
				If Depurando Then DebugLog "No es el que yo busco"
				Result = wiiCloseHandle(HIDHandle)
	        End If
	
		End If
		
		MemberIndex = MemberIndex+1
	
	Until (LastDevice = True) Or (Detectado = True)
	
	FreeBank Needed
	
	Result = wiiSetupDiDestroyDeviceInfoList(DeviceInfoSet)

	FreeBank GUID
	FreeBank MyDeviceInterfaceData
	FreeBank MyDeviceInterfaceDetailData
	FreeBank MyDeviceInfoData
	FreeBank DeviceAttributes

	Return Detectado

End Function
</textarea> <br><br></td></tr></table><br>
<a name="879251"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Uncle</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool, Ive been also wanting this for B3D so thanks for your effort.  Unfortunately I can't test it until I back home in a few days.  Have you managed to map all the features, including IR Dot Size? <br><br></td></tr></table><br>
<a name="879324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> it's still in beta stage<br><br>only detect, read and write and in the example some way's to do some specific tasks: read buttons, set led's, read accel's etc. <br><br>Init IR, I saw is not easy, the rest seem's to be simple.<br><br>Feedback will be appreciated!<br><br>Juan <br><br></td></tr></table><br>
<a name="879550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Panno</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> cool <br><br></td></tr></table><br>
<a name="954332"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi<br><br>time to update<br><br>now manages the IR dots (all three modes: basic, extenden and full)<br>now can set the IR sensibility<br>and some other details were added<br><br>still hope that this should be useful for someone!<br>part of this work is in spanish, sorry, request translation as needed.<br><br>have fun<br><br>the .decls are still the same as avobe<br><br>wii_lib.bb mus be included<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;*********************************************************************************
;
;	WiiMote desde Blitz3d
;
;	Autor: Juan Ignacio Odriozola
;			jio@...
;
;			Charrua en la comunidad BLITZ
;
;	La publico asi como está y pueden usarla sin restricciones y sin derecho a pataleo!
;	(in english: is free, as is and with no warranties!)
;
;	favor ralimentar errores, son bien benidos los aportes, comentarios y críticas que
;	sirvan para hacer crecer este trabajo
;
;	please report any bug you found, i wait for feedback, comentaries and criticism with the
;	purpose of make this work better.
;
;	no estaría mal que me incluyeran o me dieran al menos el crédito de haber hecho esta librería
;	please give me some credit, atleast for doing this lib!
;
;
;	If you need help or translation I'll try to do my best.
;
;	understand that is easily For me To publish this in spanish and translate as much as you request
;
;		decls necesarios: wii_hid.decls, wii_kernel32.decls, wii_setupapi.decls
;		en las definiciones de las funciones se les ha incorporado wii como prefijo
;
;	ObtenerHID: Busca un WiiMote, si lo encuentra fija HIDHandle para escritura y
;				ReadHandle para lectura solapada. Devuelve true o false según exito o no.
;
;	Escribir(Cantidad)	;transmite 22 bytes siempre (HIDHandle)
;						;previo hay que inicializar OutputReportData con la info a Tx
;						;Cantidad indica cuantos he inicializado, para que la rutina
;						;borre el resto del buffer
;
;	Leer(TOut)		;Ordena una lectura (ReadHandle), espera recibir 22 bytes o TOut
;					;Si operación de lectura exitosa devuelve True, si TOut devuelve False
;
;			Si Lectura exitosa: WiiMote\DReporting = Tipo de reporte recibido
;								WiiMote\RxCount	= cantidad de bytes recibidos
;								ReadBuffer contiene los bytes recibidos
;
;
;	Leer puede dar TimeOut porque el WiiMote se ha apagado, se quedó sin batería etc.
;	
;	visit
;	<a href="http://wiibrew.org/index.php?title=Wiimote" target="_blank">http://wiibrew.org/index.php?title=Wiimote</a>	&lt;&lt;&lt;&lt;&lt; Gracias mil!
;	for more information
;	
;
;*********************************************************************************

Const WiiLevel1 	 = 1
Const WiiLevel2 	 = 2
Const WiiLevel3 	 = 3
Const WiiLevel4 	 = 4
Const WiiLevel5 	 = 5
Const WiiLevelMaximo = 6

Const IR_Off	  = 0
Const IR_Basic	  = 1
Const IR_Extended = 3
Const IR_Full	  = 5

Const REGISTER_IR 					 = $04b00030	;el 04 en todos es lo que activa
Const REGISTER_IR_SENSITIVITY_1 	 = $04b00000	;el bit 2 para indicar que son
Const REGISTER_IR_SENSITIVITY_2 	 = $04b0001a	;registros!
Const REGISTER_IR_MODE 				 = $04b00033

Global HIDHandle
Global ReadHandle
Global MyDeviceDetected=False
Global EventObject

Global IntercalarDemora=False
Global DemorarEscritura=False


Global Datos	 		= CreateBank(65536)	;el reporte de lectura ($21) devuelve un offset de 2 bytes
											;y "DeglozarLectura" lo utiliza para guardar los datos leídos aqui
											;WiiMote Tiene 3 variables que hay que verificar
											;luego de cada reporte $21.
											
Global OutputReportData = CreateBank(256)	;?? no controlé requerimientos de los comandos HID usb
Global ReadBuffer 		= CreateBank( 22)
Global Security 		= CreateBank( 12)
Global HIDOverlapped 	= CreateBank( 20)


Type PuntoIR
	Field x	; en el rango 0..1023
	Field y	; en el rango 0..767
	Field t	;Tamaño relevante si IRMode = Extended o Full, si -1 no detectado en todos los modos
	;relevantes solo si IRMode = Full
	Field i	;intensidad
	Field xMax
	Field xMin
	Field yMax
	Field yMin
	Field Indice
End Type

Type Controller

	Field Rumble = False
	Field TxContinuo = False
	Field Led1 = False
	Field Led2 = False
	Field Led3 = False
	Field Led4 = False
	
	Field IrMode = 0	;off, basic, extended, full: 00, 01, 03, 05
	Field DReporting	;Primer byte de la respuesta
	Field DRNoConocido
	Field RxCount
	Field Energia
	
	Field Botones1	; . . . + Up Dn Rg Lf
	Field Botones2	; H . . - A  B  1  2
	
	Field Boton_A 		= False
	Field Boton_B 		= False
	Field Boton_Minus 	= False
	Field Boton_Home 	= False
	Field Boton_Plus 	= False
	Field Boton_One 	= False
	Field Boton_Two 	= False
	Field Boton_Up 		= False
	Field Boton_Down 	= False
	Field Boton_Left 	= False
	Field Boton_Right 	= False

	Field AccelX
	Field AccelY
	Field AccelZ
	
	Field Calibrado=False
	
	Field AccelXrel#
	Field AccelYrel#
	Field AccelZrel#
	
	;LeerCalibración fija Calibrado a True e inicializa las siguientes 6 variables
	;si se ha calibrado entonces AccelXrel, AccelYrel y AccelZrel son relevantes y
	;reflejan el valor de los acelerómetros relativo al valor calibrado. El  valor calibrado
	;es el que el wiimote refleja si se encuentra horizontal y quietito!
	Field AX0
	Field AY0
	Field AZ0
	
	Field AXG
	Field AYG
	Field AZG
	
	Field PMx#	;coordenadas del punto medio
	Field PMy#
	Field PMDist#
	Field P1P2Dist#
	
	Field LosCuatro	;indica si están o no siendo vistos los cuatro

	Field P1.PuntoIR
	Field P2.PuntoIR
	Field P3.PuntoIR
	Field P4.PuntoIR

	Field L_Leidos		;para comando de lectura de eeprom y registros
	Field L_DirPrimero
	Field L_Error
End Type

;al incluir la libreria, se crean estas variables
Global WiiMote.Controller = New Controller
WiiMote\P1.PuntoIR = New PuntoIR
WiiMote\P2.PuntoIR = New PuntoIR
WiiMote\P3.PuntoIR = New PuntoIR
WiiMote\P4.PuntoIR = New PuntoIR

Function Detectar%(IRMode=IR_Extended,Sensibilidad=WiiLevelMaximo,Continuo=False)
	Local Inicio, TimeOut, Result
	IntercalarDemora = True

	Inicio = MilliSecs()
	Repeat
		If MilliSecs()&gt;Inicio+2000 Then TimeOut=True
	Until ObtenerHID() Or TimeOut
	MyDeviceDetected = False
	
	If Not TimeOut Then
		MyDeviceDetected = True
	
		;leemos calibracion
		If Not LeerCalibracion() Then
			;si no salio la primera, probamos otra vez
			DemorarEscritura = True
			Result = LeerCalibracion()
		End If
		
		HabilitarIR(IRMode,Sensibilidad)
	
		;el modo de respuesta tiene que coincidir con lo que se fije como IRMode
		
		Select WiiMote\IrMode
			Case IR_Off
				ModoDeRespuesta($31,Continuo)	; Botones y Aceleración
				
			Case IR_Basic
				ModoDeRespuesta($37,Continuo)	; Botones, Aceleración e IR 10 bytes
		
			Case IR_Extended
			
				ModoDeRespuesta($33,Continuo)	; Botones Aceleración e IR 12 bytes
			
			Case IR_Full
				ModoDeRespuesta($3E,Continuo)	; Botones Aceleración e IR 36 bytes entrelazado
		
		End Select
		
		SolicitarEstado()
		
	End If	;TimeOut

	IntercalarDemora = False

	Return MyDeviceDetected

End Function


Function ActualizarLeds()
	ControlarLeds(WiiMote\Led4,WiiMote\Led3,WiiMote\Led2,WiiMote\Led1)
End Function

Function NoIR()
	;disable IR
	PokeByte(OutputReportData,0,$13)
	PokeByte(OutputReportData,1,  0)
	Escribir(2)
	PokeByte(OutputReportData,0,$1A)
	PokeByte(OutputReportData,1,  0)
	Escribir(2)
	WiiMote\P1\t = -1
	WiiMote\P2\t = -1
	WiiMote\P3\t = -1
	WiiMote\P4\t = -1
	WiiMote\IrMode = 0	;off
End Function

Function HabilitarIR(Modo,Sensibilidad)
	Local i, d
	
	PokeByte(OutputReportData,0,$13)
	PokeByte(OutputReportData,1,  4)
	Escribir(2)
	
	PokeByte(OutputReportData,0,$1A)
	PokeByte(OutputReportData,1,  4)
	Escribir(2)
	
	PokeByte(Datos,0,$08)
	EscribirMemoria(REGISTER_IR,1)
		
	Select Sensibilidad
		Case WiiLevel1
			Restore Level1
			
		Case WiiLevel2
			Restore Level2
			
		Case WiiLevel3
			Restore Level3
			
		Case WiiLevel4
			Restore Level4
			
		Case WiiLevel5
			Restore Level5
			
		Case WiiLevelMaximo
			Restore Level6
			
	End Select
	
	For i=0 To 8
		Read d
		PokeByte(Datos,i,d)
	Next
	EscribirMemoria(REGISTER_IR_SENSITIVITY_1,9)
	
	For i=0 To 1
		Read d
		PokeByte(Datos,i,d)
	Next
	EscribirMemoria(REGISTER_IR_SENSITIVITY_2,2)
	
	WiiMote\IrMode = Modo
	PokeByte(Datos,0,Modo)
	EscribirMemoria(REGISTER_IR_MODE,1)
	
	PokeByte(Datos,0,$08)
	EscribirMemoria(REGISTER_IR,1)
	
	
	DemorarEscritura=False
	
	If Modo = IR_Basic Then
		WiiMote\P1\t=1
		WiiMote\P2\t=1
		WiiMote\P3\t=1
		WiiMote\P4\t=1
	End If

	
End Function

;[Block] Definicion de los niveles para sensibildad IR
.Level1
Data	$02, $00, $00, $71, $01, $00, $64, $00, $fe
Data	$fd, $05

.Level2
Data	$02, $00, $00, $71, $01, $00, $96, $00, $b4
Data	$b3, $04

.Level3
Data	$02, $00, $00, $71, $01, $00, $aa, $00, $64
Data	$63, 03

.Level4
Data	$02, $00, $00, $71, $01, $00, $c8, $00, $36
Data	$35, $03

.Level5
Data	$07, $00, $00, $71, $01, $00, $72, $00, $20
Data	$1f, $03

.Level6
Data $02, $00, $00, $71, $01, $00, $90, $00, $41
Data $40, $00
;[End Block]

; rutinas que envían solicitudes específicas

Function ControlarLeds(l1,l2,l3,l4)
											;LEDS		0x11
	Local Dato=0
	If l1 Then Dato=$80
	If l2 Then Dato=Dato Or $40
	If l3 Then Dato=Dato Or $20
	If l4 Then Dato=Dato Or $10
	PokeByte(OutputReportData,0,$11)
	PokeByte(OutputReportData,1,Dato)
	Escribir(2)
End Function

Function ModoDeRespuesta(tipo,Continuo=False)
	Local m										;TYPE		0x12
	PokeByte(OutputReportData,0,$12)


	If Continuo Then
		m=4
	Else
		m=0
	End If
	
	PokeByte(OutputReportData,1,  m)
	
	PokeByte(OutputReportData,2,tipo)

	Escribir(3)

End Function

Function SolicitarEstado()
											;STATUS		0x15
	PokeByte(OutputReportData,0,$15)
	PokeByte(OutputReportData,1,  0)
	Escribir(2)	;status
End Function

Function EscribirMemoria(Direccion,Cantidad)
	Local i										;Write Mem	0x16

	;previamente escribir Cantidad Datos en el banco Datos
	;luego llamar EscribirMemoria pasando Cantidad, el Offset del primero
	;o dirección que se manda escribir


	;Dirección	$04aaaaaa para acceder al Registro de control aaaaaa
	;			$00aaaaaa para acceder a la celda de eeprom aaaaaa

	PokeByte(OutputReportData,0,$16)
	PokeByte(OutputReportData,1,( (Direccion And $FF000000) Shr 24))
	PokeByte(OutputReportData,2,  (Direccion And $00FF0000) Shr 16)
	PokeByte(OutputReportData,3,  (Direccion And $0000FF00) Shr  8)
	PokeByte(OutputReportData,4,  (Direccion And $000000FF)       )
	
	PokeByte(OutputReportData,5,(Cantidad And $000000FF))
	
	;ahora transfiero de datos hacia OutputReportData
	For i=0 To Cantidad-1
		PokeByte(OutputReportData,i+6,PeekByte(Datos,i))
	Next
	
	Escribir(6+Cantidad)
	
	If IntercalarDemora Then Delay 100
	
End Function

Function LeerCalibracion()

	Local Ok = False
	Local TimeOut = False
	Local Inicio
	LeerMemoria($16,7)
	
	
	Inicio = MilliSecs()
	
	Repeat
	
		If Leer(0) Then
			EvaluoRecepcion()
			If WiiMote\DReporting=$21 Then Ok=True	;llego lo que mandé leer
		End If
		If MilliSecs() &gt; Inicio+1000 Then TimeOut=True
		
	Until Ok Or TimeOut
	
	If Ok Then
		WiiMote\AX0 = PeekByte(Datos,WiiMote\L_DirPrimero+0)
		WiiMote\AY0 = PeekByte(Datos,WiiMote\L_DirPrimero+1)
		WiiMote\AZ0 = PeekByte(Datos,WiiMote\L_DirPrimero+2)
		
		WiiMote\AXG = PeekByte(Datos,WiiMote\L_DirPrimero+4)
		WiiMote\AYG = PeekByte(Datos,WiiMote\L_DirPrimero+5)
		WiiMote\AZG = PeekByte(Datos,WiiMote\L_DirPrimero+6)
		
		WiiMote\Calibrado=True
		
	End If
	
	Return Ok
	
End Function

Function LeerMemoria(Direccion,Cantidad)
											;Read Mem	0x17

	;Dirección	$04aaaaaa para acceder al Registro de control aaaaaa
	;			$00aaaaaa para acceder a la celda de eeprom aaaaaa

	PokeByte(OutputReportData,0,$17)
	
	PokeByte(OutputReportData,1,( (Direccion And $FF000000) Shr 24))
	PokeByte(OutputReportData,2,  (Direccion And $00FF0000) Shr 16)
	PokeByte(OutputReportData,3,  (Direccion And $0000FF00) Shr  8)
	PokeByte(OutputReportData,4,  (Direccion And $000000FF)       )
	
	PokeByte(OutputReportData,5,(Cantidad And $0000FF00) Shr  8)
	PokeByte(OutputReportData,6,(Cantidad And $000000FF))
	
	Escribir(7)
	
End Function

; rutinas que analizan los datos del buffer de lectura
; son invocadas desde EvaluoRecepción, dependiento del tipo de reporte.

Function DeglozarLectura()
	;0x21 devuelve: BB BB Botones
	;SE FF FF DD .. DD
	;S	Cantidad-1, Cantidad: 1..16
	;E	0 si ok, errores vienen aca
	;FF FF offset o dirección del primero de la lista (ojo que se envia una addr de 3 bytes)
	;		y solo vuelven los dos menos significativos.
	;DD..DD datos desde el offset: 6 al 21 máximo 16
	Local i
	WiiMote\L_Leidos = ((PeekByte(ReadBuffer,3) And $F0) Shr 4)+1
	WiiMote\L_DirPrimero = (PeekByte(ReadBuffer,4) Shl 8) Or (PeekByte(ReadBuffer,5))
	WiiMote\L_Error = PeekByte(ReadBuffer,3) And $0F
	If WiiMote\L_Error = 0 Then
		;trasnsfiero de un banco a otro.
		;tengo en cuenta Dirección del primero que viene en FF FF
		For i=0 To WiiMote\L_Leidos-1
			PokeByte(Datos,WiiMote\L_DirPrimero+i,PeekByte(ReadBuffer,i+6))
		Next
	End If
End Function

Function DeglozarBotones()
	Local Byte1, Byte2
	Byte1 = PeekByte(ReadBuffer,1)
	Byte2 = PeekByte(ReadBuffer,2)
	WiiMote\Botones1 	= Byte1 And $1F	;0001 1111
	WiiMote\Botones2 	= Byte2 And $9F	;1001 1111
	WiiMote\Boton_A 	= (Byte2 And $08) &lt;&gt; 0
	WiiMote\Boton_B 	= (Byte2 And $04) &lt;&gt; 0
	WiiMote\Boton_Minus = (Byte2 And $10) &lt;&gt; 0
	WiiMote\Boton_Home 	= (Byte2 And $80) &lt;&gt; 0
	WiiMote\Boton_Plus 	= (Byte1 And $10) &lt;&gt; 0
	WiiMote\Boton_One 	= (Byte2 And $02) &lt;&gt; 0
	WiiMote\Boton_Two 	= (Byte2 And $01) &lt;&gt; 0
	WiiMote\Boton_Up 	= (Byte1 And $08) &lt;&gt; 0
	WiiMote\Boton_Down 	= (Byte1 And $04) &lt;&gt; 0
	WiiMote\Boton_Left 	= (Byte1 And $01) &lt;&gt; 0
	WiiMote\Boton_Right = (Byte1 And $02) &lt;&gt; 0
End Function

Function DeglozarAceleraciones()
	Local Byte1, Byte2
	Select WiiMote\DReporting
		Case $3E
			;interleaved primer paquete 
			WiiMote\AccelX = PeekByte(ReadBuffer,3)
			;xMNxxxxx los bits 65 de los bytes 1 y 2 tienen los bits 54 y 76 de Z
			Byte1 = PeekByte(ReadBuffer,1) And $60
			Byte2 = PeekByte(ReadBuffer,2) And $60
			WiiMote\AccelZ = (Byte2 Shl 1) Or (Byte1 Shr 1)
		Case $3F
			;interleaved segundo paquete 10 32 de z
			WiiMote\AccelY = PeekByte(ReadBuffer,3)
			;xMNxxxxx los bits 65 de los bytes 1 y 2 tienen los bits 10 y 32 de Z
			Byte1 = PeekByte(ReadBuffer,1) And $60
			Byte2 = PeekByte(ReadBuffer,2) And $60
			WiiMote\AccelZ = (Byte2 Shr 3) Or (Byte1 Shr 5)
		Default
			WiiMote\AccelX = PeekByte(ReadBuffer,3)
			WiiMote\AccelY = PeekByte(ReadBuffer,4)
			WiiMote\AccelZ = PeekByte(ReadBuffer,5)
	End Select
	
	If WiiMote\Calibrado Then
		
		WiiMote\AccelXrel = Float(Float(WiiMote\AccelX - WiiMote\AX0) / Float(WiiMote\AXG))
		WiiMote\AccelYrel = Float(Float(WiiMote\AccelY - WiiMote\AY0) / Float(WiiMote\AYG))
		WiiMote\AccelZrel = Float(Float(WiiMote\AccelZ - WiiMote\AZ0) / Float(WiiMote\AZG))
		
	End If
		
End Function

Function DeglozarIR()
	Local Ir1, Ir2, Ir3, Ir4, Ir5, Ir6, Ir7, Ir8, Ir9, Ir10, Desp
	Local CantidadDePuntosVistos = 0
	Select WiiMote\IrMode
	
		Case IR_Basic
			;depende de si WiiMote\DReporting es 36 o 37
			
			
			Desp = 3
			If WiiMote\DReporting = $37 Then Desp= 6
			
			Ir1    = PeekByte(ReadBuffer,Desp  )
			Ir2    = PeekByte(ReadBuffer,Desp+1)
			Ir3    = PeekByte(ReadBuffer,Desp+2)
			Ir4    = PeekByte(ReadBuffer,Desp+3)
			Ir5    = PeekByte(ReadBuffer,Desp+4)
			Ir6    = PeekByte(ReadBuffer,Desp+5)
			Ir7    = PeekByte(ReadBuffer,Desp+6)
			Ir8    = PeekByte(ReadBuffer,Desp+7)
			Ir9    = PeekByte(ReadBuffer,Desp+8)
			Ir10   = PeekByte(ReadBuffer,Desp+9)
			
			WiiMote\P1\x = Ir1 + (Ir3 And $30) Shl 4
			WiiMote\P1\y = (Ir2 + (Ir3 And $C0) Shl 2)
			If WiiMote\P1\y&lt;0 Then
				WiiMote\P1\t = -1
			Else
				WiiMote\P1\t = 1
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
				
			End If
			
			
			WiiMote\P2\x = Ir4 + (Ir3 And $03) Shl 8
			WiiMote\P2\y = (Ir5 + (Ir3 And $0C) Shl 6)
			If WiiMote\P2\y&lt;0 Then
				WiiMote\P2\t = -1
			Else
				WiiMote\P2\t = 1
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			End If
			
			WiiMote\P3\x = Ir6 + (Ir8 And $30) Shl 4
			WiiMote\P3\y = (Ir7 + (Ir8 And $C0) Shl 2)
			If WiiMote\P3\y&lt;0 Then
				WiiMote\P3\t = -1
			Else
				WiiMote\P3\t = 1
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			End If
			
			WiiMote\P4\x = Ir9 + (Ir8 And $03) Shl 8
			WiiMote\P4\y = (Ir10+ (Ir8 And $0C) Shl 6)
			If WiiMote\P4\y&lt;0 Then
				WiiMote\P4\t = -1
			Else
				WiiMote\P4\t = 1
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			End If
			
			
		Case IR_Extended
			;Extended	DataReportingMode = $33
			
			Ir1    = PeekByte(ReadBuffer,6)
			Ir2    = PeekByte(ReadBuffer,7)
			Ir3    = PeekByte(ReadBuffer,8)
			
			If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
				WiiMote\P1\x = Ir1 + (Ir3 And $30) Shl 4
				WiiMote\P1\y = (Ir2 + (Ir3 And $C0) Shl 2)
				WiiMote\P1\t = Ir3 And $0F
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			Else
				WiiMote\P1\t = -1
			End If
		
			Ir1    = PeekByte(ReadBuffer, 9)
			Ir2    = PeekByte(ReadBuffer,10)
			Ir3    = PeekByte(ReadBuffer,11)
			If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
				WiiMote\P2\x = Ir1 + (Ir3 And $30) Shl 4
				WiiMote\P2\y = (Ir2 + (Ir3 And $C0) Shl 2)
				WiiMote\P2\t = Ir3 And $0F
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			Else
				WiiMote\P2\t = -1
			End If
			
			Ir1    = PeekByte(ReadBuffer,12)
			Ir2    = PeekByte(ReadBuffer,13)
			Ir3    = PeekByte(ReadBuffer,14)
			If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
				WiiMote\P3\x = Ir1 + (Ir3 And $30) Shl 4
				WiiMote\P3\y = (Ir2 + (Ir3 And $C0) Shl 2)
				WiiMote\P3\t = Ir3 And $0F
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			Else
				WiiMote\P3\t = -1
			End If
			
			Ir1    = PeekByte(ReadBuffer,15)
			Ir2    = PeekByte(ReadBuffer,16)
			Ir3    = PeekByte(ReadBuffer,17)
			If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
				WiiMote\P4\x = Ir1 + (Ir3 And $30) Shl 4
				WiiMote\P4\y = (Ir2 + (Ir3 And $C0) Shl 2)
				WiiMote\P4\t = Ir3 And $0F
				CantidadDePuntosVistos = CantidadDePuntosVistos + 1
			Else
				WiiMote\P4\t = -1
			End If
			
		Case IR_Full
			;full	DataReportingMode 3E / 3F
			
			If WiiMote\DReporting = $3E Then
				;primer bloque de 9 bytes
				Ir1    = PeekByte(ReadBuffer,4)
				Ir2    = PeekByte(ReadBuffer,5)
				Ir3    = PeekByte(ReadBuffer,6)
				
				If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
					WiiMote\P1\x = Ir1 + (Ir3 And $30) Shl 4
					WiiMote\P1\y = (Ir2 + (Ir3 And $C0) Shl 2)
					WiiMote\P1\t = Ir3 And $0F
					CantidadDePuntosVistos = CantidadDePuntosVistos + 1
				Else
					WiiMote\P1\t = -1
				End If
			
				Ir1    = PeekByte(ReadBuffer,13)
				Ir2    = PeekByte(ReadBuffer,14)
				Ir3    = PeekByte(ReadBuffer,15)
				If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
					WiiMote\P2\x = Ir1 + (Ir3 And $30) Shl 4
					WiiMote\P2\y = (Ir2 + (Ir3 And $C0) Shl 2)
					WiiMote\P2\t = Ir3 And $0F
					CantidadDePuntosVistos = CantidadDePuntosVistos + 1
				Else
					WiiMote\P2\t = -1
				End If
				
				
				; i xMax, xMin, yMax, yMin
				WiiMote\P1\xMax = PeekByte(ReadBuffer, 7)
				WiiMote\P1\yMax = PeekByte(ReadBuffer, 8)
				WiiMote\P1\xMin = PeekByte(ReadBuffer, 9)
				WiiMote\P1\yMin = PeekByte(ReadBuffer,10)
				WiiMote\P1\i    = PeekByte(ReadBuffer,12)
				
				WiiMote\P2\xMax = PeekByte(ReadBuffer,16)
				WiiMote\P2\yMax = PeekByte(ReadBuffer,17)
				WiiMote\P2\xMin = PeekByte(ReadBuffer,18)
				WiiMote\P2\yMin = PeekByte(ReadBuffer,19)
				WiiMote\P2\i    = PeekByte(ReadBuffer,21)

			End If
			
			If WiiMote\DReporting = $3F Then
				;segundo bloque de 9 bytes
				Ir1    = PeekByte(ReadBuffer, 4)
				Ir2    = PeekByte(ReadBuffer, 5)
				Ir3    = PeekByte(ReadBuffer, 6)
				If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
					WiiMote\P3\x = Ir1 + (Ir3 And $30) Shl 4
					;WiiMote\P3\y = 768 - (Ir2 + (Ir3 And $C0) Shl 2)
					WiiMote\P3\y = (Ir2 + (Ir3 And $C0) Shl 2)
					WiiMote\P3\t = Ir3 And $0F
					CantidadDePuntosVistos = CantidadDePuntosVistos + 1
				Else
					WiiMote\P3\t = -1
				End If
				
				Ir1    = PeekByte(ReadBuffer,13)
				Ir2    = PeekByte(ReadBuffer,14)
				Ir3    = PeekByte(ReadBuffer,15)
				If Ir1&lt;&gt;255 And Ir2&lt;&gt;255 And Ir3&lt;&gt;255 Then
					WiiMote\P4\x = Ir1 + (Ir3 And $30) Shl 4
					WiiMote\P4\y = (Ir2 + (Ir3 And $C0) Shl 2)
					;WiiMote\P4\y = 768 - (Ir2 + (Ir3 And $C0) Shl 2)
					WiiMote\P4\t = Ir3 And $0F
					CantidadDePuntosVistos = CantidadDePuntosVistos + 1
				Else
					WiiMote\P4\t = -1
				End If

				; i xMax, xMin, yMax, yMin
				WiiMote\P3\xMax = PeekByte(ReadBuffer, 7)
				WiiMote\P3\yMax = PeekByte(ReadBuffer, 8)
				WiiMote\P3\xMin = PeekByte(ReadBuffer, 9)
				WiiMote\P3\yMin = PeekByte(ReadBuffer,10)
				WiiMote\P3\i    = PeekByte(ReadBuffer,12)
				
				WiiMote\P4\xMax = PeekByte(ReadBuffer,16)
				WiiMote\P4\yMax = PeekByte(ReadBuffer,17)
				WiiMote\P4\xMin = PeekByte(ReadBuffer,18)
				WiiMote\P4\yMin = PeekByte(ReadBuffer,19)
				WiiMote\P4\i    = PeekByte(ReadBuffer,21)


			End If

	End Select
	
	
	If WiiMote\P1\t &lt;&gt; -1 And WiiMote\P2\t &lt;&gt; -1 Then
		;calculo punto medio:
		WiiMote\PMx = (WiiMote\P1\x + WiiMote\P2\x) / 2
		WiiMote\PMy = (WiiMote\P1\y + WiiMote\P2\y) / 2
		;evaluo distancia de P1 a P2 en pixels
		WiiMote\P1P2Dist = Sqr ((WiiMote\P1\x-WiiMote\P2\x)*(WiiMote\P1\x-WiiMote\P2\x) + (WiiMote\P1\y-WiiMote\P2\y)*(WiiMote\P1\y-WiiMote\P2\y))
	Else
		WiiMote\PMx = -1
		WiiMote\PMy = -1
	End If
	
	If CantidadDePuntosVistos=4 Then
		WiiMote\LosCuatro = True
	Else
		WiiMote\LosCuatro = False
	End If
	
	
End Function


Function EvaluoRecepcion()

	;Leer() espera por un paquete
	;Carga DReporting acorde al paquete recibido desde el WiiMote
	;en función del mismo es que se degloza la información que ha llegado.
	Local StrTemp$, i
	Select WiiMote\DReporting
		Case 0
			;si time out queda en 0
			
		Case $20
			;status
			WiiMote\Energia = PeekByte(ReadBuffer,6)
			WiiMote\Led1 = (PeekByte(ReadBuffer,3) And $80) &lt;&gt; 0
			WiiMote\Led2 = (PeekByte(ReadBuffer,3) And $40) &lt;&gt; 0
			WiiMote\Led3 = (PeekByte(ReadBuffer,3) And $20) &lt;&gt; 0
			WiiMote\Led4 = (PeekByte(ReadBuffer,3) And $10) &lt;&gt; 0
			WiiMote\TxContinuo = (PeekByte(ReadBuffer,3) And $08) &lt;&gt; 0
		Case $21
			;Read
			DeglozarBotones()
			DeglozarLectura()
			
		Case $22
			;write
			
		Case $30
			DeglozarBotones()
		Case $31
			DeglozarBotones()
			DeglozarAceleraciones()
		Case $32
			DeglozarBotones()
		Case $33
			DeglozarBotones()
			DeglozarAceleraciones()
			DeglozarIR()
		Case $34
			DeglozarBotones()
		Case $35
			DeglozarBotones()
			DeglozarAceleraciones()
		Case $36
			DeglozarBotones()
			DeglozarIR()
		Case $37
			DeglozarBotones()
			DeglozarAceleraciones()
			DeglozarIR()
		Case $3D
		
		Case $3E
			;aqui la aceleracion viene diferente
			DeglozarBotones()
			DeglozarAceleraciones()
			DeglozarIR()
		Case $3F
			;aqui la aceleracion viene diferente
			DeglozarBotones()
			DeglozarAceleraciones()
			DeglozarIR()
		
		Default
			;si vino algo desconocido, se cuenta
			WiiMote\DRNoConocido = WiiMote\DRNoConocido + 1
	End Select
	
End Function

;funciones más que necesarias
;ObtenerHID, Leer, Escribir

Function Leer(TOut)
	Local LecturaOk, NBRx, Result
	Local WAIT_TIMEOUT = $102
	Local WAIT_OBJECT_0 = $0
	;1) Si dispositivo no detectado, trata de encontrar uno
	;
	;2) Si dispositivo encotrado, manda leer
	;		si Lectura completada con éxito: devuelve true =&gt; ReadBuffer tiene lo recibido
	;		si TOut: cancela la lectura y devuelve false
	
	
	LecturaOk = False
	
	If MyDeviceDetected = False Then
		;intento encontrar uno
	    MyDeviceDetected = ObtenerHID()
	End If
	
	If MyDeviceDetected Then
		;si hay uno
		NBRx = CreateBank(4)
		;Inicio la operación de lectura
		Result = wiiReadFile(ReadHandle, ReadBuffer, 22, NBRx, HIDOverlapped)
		;Regresa inmediatamente
		WiiMote\RxCount = PeekInt(NBRx,0)
		FreeBank NBRx
		;ahora espero a que lleguen los 22 o timeout
		Result = wiiWaitForSingleObject(EventObject, TOut)	;esto espera mismo.
		
		;ahora hay que evaluar los casos.
		
		Select Result
		    Case WAIT_OBJECT_0
	        	;ReadFile has completed
				WiiMote\DReporting = PeekByte(ReadBuffer,0)
				LecturaOk = True
	
		    Case WAIT_TIMEOUT
		        ;Timeout
		        ;Cancelo la operación
				;WiiMote\DReporting = 0	;si luego de time out se llama a EvaluoRecepcion
										;esta no hace nada y no se toman datos erroneos
				Result = wiiCancelIo(ReadHandle)
				LecturaOk = False
	
			Default
				LecturaOk = False
				;WiiMote\DReporting = 0
	
		End Select
	
		wiiResetEvent(EventObject)
		
	End If
	
	Return LecturaOk		;true si habia un witmote y rx ok sin time out
							;false si habio uno y time out, o no habia y sigue sin haber

End Function

Function Escribir(Cantidad)

	;si dispositivo no detectado, trata de encontrar uno
	;si ya hay uno
	;	previo al llamado hay que ubicar en OutputReportData los datos a transmitir
	;	Cantidad indica cuantos hay en el buffer
	;	siempre se transmiten 22
	
	Local NumeroDeBytesEscritos = 0
	Local OutBuffer, i, Temp, UnoSolo, StrTemp$, Result
	If MyDeviceDetected = False Then
	    MyDeviceDetected = ObtenerHID()
	Else
		OutBuffer=CreateBank(22)
		;copio de OutputReportData a OutBuffer solo Cantidad bytes
		;el resto se borra
		For i=0 To 21
			If i&lt;Cantidad Then
				PokeByte(OutBuffer,i,PeekByte(OutputReportData,i))
			Else
				PokeByte(OutBuffer,i,0)
			End If
		Next
		Temp = CreateBank(4)
		
		;segun Rumble activo bit 1 del byte 1 del buffer: Buffer(1) = Buffer(1) Or 1
		If WiiMote\Rumble Then PokeByte(OutputReportData,1,(PeekByte(OutputReportData,1) Or 1))
		
		If DemorarEscritura Then
			;escribimos byte a byte esperando 50ms entre bytes
			UnoSolo = CreateBank(1)
			For i=0 To 21
				PokeByte(UnoSolo,0,PeekByte(OutputReportData,i))
				Result = wiiWriteFile(HIDHandle, UnoSolo, 1, Temp, 0)
				Delay 50
			Next
			FreeBank UnoSolo
		Else
			Result = wiiWriteFile(HIDHandle, OutputReportData, 22, Temp, 0)
			NumeroDeBytesEscritos = PeekInt(Temp,0)
		End If
		FreeBank Temp
		FreeBank OutBuffer
		
		If IntercalarDemora Then Delay 100
		
	End If
	
	Return NumeroDeBytesEscritos

End Function


Function ObtenerHID()

	;busca en la lista de dispositivos el primer WiiMote
	;si lo encuentra, abre dos archivos HIDHandle para escritura 
	;y ReadHandle para lectura Overlapped
	;devuelve MyDeviceDetected que indica si la operación fué exitosa
	
	FILE_SHARE_READ = $1
	FILE_SHARE_WRITE = $2
	GENERIC_READ = $80000000
	GENERIC_WRITE = $40000000
	OPEN_EXISTING = 3
	FILE_FLAG_OVERLAPPED = $40000000
	
	GUID = CreateBank(16)	;long, int, int, array(0..7) byte
	;son estructuras, en las que el primer elemento (4 bytes) indica su tamaño
	;se pasan por referencia y hay que inicializar su tamaño antes de usarlas
	
	MyDeviceInterfaceDetailData = CreateBank(5)
	PokeInt(MyDeviceInterfaceDetailData,0,5)
	
	MyDeviceInfoData = CreateBank(28)
	PokeInt(MyDeviceInfoData,0,28)

	MyDeviceInterfaceData = CreateBank(28)
	PokeInt(MyDeviceInterfaceData,0,28)
	
	;esta estructura es escrita por HidD_GetAttributes, de ella se saca Vendedor, producto y versión
	DeviceAttributes = CreateBank(10)	;size(4), VendorID, ProductID, Version 2,2,2.
	
	DeviceInfoSet=0
	DevicePathName$=""
	Flags = 16 + 2
	DetailData=0
	LastDevice=False
	Detectado = False
	
	;Security es una estructura con tres variables tipo long
	PokeInt(Security, 0,  12)	;length 
	PokeInt(Security, 4,   0)	;lpSecurityDescriptor
	PokeInt(Security, 8,True)	;bInheritHandle
	
	
	HIDHandle = -1

	Result = wiiHidD_GetHidGuid(GUID)
	
		
	DeviceInfoSet = wiiSetupDiGetClassDevs(GUID,"",0,Flags)
	
	MemberIndex=0
	
	Needed = CreateBank(4)
	
	
	Repeat
	
		Result = wiiSetupDiEnumDeviceInterfaces(DeviceInfoSet,0,GUID,MemberIndex,MyDeviceInterfaceData)
		    
		If Result = 0 Then 
			LastDevice = True
		Else
	
	
			;tercer parámetro por valor
	        Result = wiiSetupDiGetDeviceInterfaceDetail(DeviceInfoSet, MyDeviceInterfaceData, 0, 0, Needed, 0)
	        
	        DetailData = PeekInt(Needed,0)
	
        
	        DetailDataBuffer = CreateBank(DetailData)
			Cuantos = DetailData
			PokeInt(DetailDataBuffer,0,5)
			
			;tercer parámetro por referencia
			Result = wiiSetupDiGetDeviceInterfaceDetail2(DeviceInfoSet, MyDeviceInterfaceData, DetailDataBuffer, DetailData, Needed, 0)
			
			strtmp$ = ""
			For i=4 To Cuantos-1
				strtmp$ = strtmp$ + Chr$(PeekByte(DetailDataBuffer,i))
			Next

			FreeBank DetailDataBuffer
			
			DevicePathName$ = strtmp$
			
			HIDHandle = wiiCreateFileOverlapped(DevicePathName, GENERIC_READ Or GENERIC_WRITE, (FILE_SHARE_READ Or FILE_SHARE_WRITE), Security, OPEN_EXISTING, 0, 0)
	
			Result = wiiHidD_GetAttributes(HIDHandle, DeviceAttributes)
			
			VendorID = PeekShort(DeviceAttributes,4)
			ProductID = PeekShort(DeviceAttributes,6)
			
			If (VendorID = $057E) And (ProductID = $0306) Then
	           	Detectado = True
				ReadHandle = wiiCreateFileOverlapped(DevicePathName, GENERIC_READ Or GENERIC_WRITE, (FILE_SHARE_READ Or FILE_SHARE_WRITE), Security, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0)
				;preparativos para la transferencia solapada
				If EventObject = 0 Then
					EventObject = wiiCreateEvent(Security,True,True,"")
				End If
				;HIDOverlapped es una estructura con 5 variables tipo Long
				;Internal, InternalHigh, Offset, OffsetHigh, hEvent
				PokeInt(HIDOverlapped, 8,0)				;offset
				PokeInt(HIDOverlapped,12,0)				;offsethigh
				PokeInt(HIDOverlapped,16,EventObject)	;hEvent
	        Else
				Detectado = False
				Result = wiiCloseHandle(HIDHandle)
	        End If
	
		End If
		
		MemberIndex = MemberIndex+1
	
	Until (LastDevice = True) Or (Detectado = True)
	
	FreeBank Needed
	
	Result = wiiSetupDiDestroyDeviceInfoList(DeviceInfoSet)

	FreeBank GUID
	FreeBank MyDeviceInterfaceData
	FreeBank MyDeviceInterfaceDetailData
	FreeBank MyDeviceInfoData
	FreeBank DeviceAttributes

	Return Detectado

End Function



Function WiiLiberoRecursos()

	NoIR()
	
	FreeBank HIDOverlapped
	
	If MyDeviceDetected Then
		Result = wiiCloseHandle(HIDHandle)
		Result = wiiCloseHandle(ReadHandle)
	End If
	
	FreeBank Security
	FreeBank OutputReportData
	FreeBank ReadBuffer

End Function
</textarea><br><br><br>and an example of usage: wiimote.bb:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;*********************************************************************************
;
;	WiiMote desde Blitz3d
;
; Ejemplo de uso de wii_lib.bb
;
; Intenta detectar un wiimote
; y muestra por pantalla el estado de los acelerómetros, botones y leds ir
; permite prender apagar los leds del control y activar/desactivar el rumble
;
; fija el pitch y el roll de un objeto blitz (azul) acorde al estado de los
; acelerómetros (se realiza un promedio para suavizar los cambios instantáneos)
;
; se grafica la posición de los puntos IR vistos y del punto medio calculado
; entre P1 y P2
;
; nótese que P1, P2, P3 y P4 son simplemente los puntos ir vistos en el orden en que
; entran en el campo de visión de la camara ir instalada en el wiimote.
;

Graphics3D 1024,768,0,1

Include "wii_lib.bb"

Global WiiOk = Detectar(IR_Extended,WiiLevel3,True)
DebugLog wiiok

;Parámetros de Detectar: IRMode, Sensibilidad, Continuo

; IRMode
; valores posibles para IRMode: IR_Off, IR_Basic, IR_Extended, IR_Full
; IR_Off indica que no queremos que el wiimote vea ni reporte los puntos ir
; los otros tres idican la cantidad de información que deseamos recibir
; por ej, el tamaño y la intensidad con que se ve el punto ir solo se reporta
; si el modo es IR_Full. 
; IR_Basic solo reporta coordenadas
; IR_Extended reporta coordenadas y tamaño del punto visto
; IR_Full reporta coordenadas, tamaño, intensidad y area vista definida para cada punto por
; xMax, yMax, xMin, yMin
;
; Sensibilidad
; valores posibles: WiiLevel1, WiiLevel2, WiiLevel3, WiiLevel4, WiiLevel5 y WiiLevelMaximo
; hay que probar el que mejor funcione para cada caso particular
;
; el último parámetro (continuo) indica si queremos que el control envíe paquetes continuamente o
; solo si hay cambios. En modo continuo (true) se reciben unos 100 paquetes por segundo

SetBuffer BackBuffer()

Global Camara = CreateCamera()
PositionEntity Camara,0,2,-5
Global Luz = CreateLight()
PositionEntity Luz,-3,5,-10
Global Control = CreateCube()
ScaleMesh Control,0.3,0.2,1
EntityColor Control,0,0,128

PointEntity Camara,Control
PointEntity Luz,Control

Global PromPitch#[50]
Global PromRoll#[50]
Global Pasada,Suavizado = 20

Local Cuadros = 0
Local Paquetes = 0
Local Tinicial = MilliSecs()
Local Cuadros_=0
Local Paquetes_=0
Local Result

Global RollAcum#,PitchAcum#
Global xTexto=20, yTexto

Repeat
	Cls
	yTexto = 390
	
	Cuadros_ = Cuadros_ + 1

	LeoTeclado()
	
	;a 60 fps, pueden y seguramente han venido mas de un paquete
	;asi leo el primero de la cola y luego hago un bucle para leer el resto
	If WiiOk Then
		If Leer(5) Then
			EvaluoRecepcion
			Paquetes_=Paquetes_+1
			While Leer(0)
				EvaluoRecepcion
				Paquetes_=Paquetes_+1
			Wend
		End If
	End If
	;la info que despliego es la del último paquete recibido
	
	If MilliSecs() &gt; Tinicial + 1000 Then
		Tinicial = MilliSecs()
		Cuadros = Cuadros_
		Cuadros_=0
		Paquetes = Paquetes_
		Paquetes_ = 0
	End If
	
	UpdateWorld()
	RenderWorld()
	
	If WiiOk Then
		Mostrar("fps:"+Cuadros+", P:" + Paquetes)
		MuestroEstadoWiiMote()
		EvaluoAcelerometros()
	Else
		Mostrar("WiiMote no presente, fps:"+Cuadros)
	End If
	
	Flip True

Until KeyHit(1)

WiiLiberoRecursos()


End

;****************************************************************************************

Function LeoTeclado()

	Mostrar("ESC = Exit, 1..4 toggle leds, 5=all off, 6 toggle rumble")

	If KeyHit(2) Then	;tecla 1
		WiiMote\Led1 = Not(WiiMote\Led1)
		ActualizarLeds()
	End If
	If KeyHit(3) Then	;tecla 2
		WiiMote\Led2 = Not(WiiMote\Led2)
		ActualizarLeds()
	End If
	If KeyHit(4) Then	;tecla 3
		WiiMote\Led3 = Not(WiiMote\Led3)
		ActualizarLeds()
	End If
	If KeyHit(5) Then	;tecla 4
		WiiMote\Led4 = Not(WiiMote\Led4)
		ActualizarLeds()
	End If
	If KeyHit(6) Then	;tecla 5 apaga todos los leds
		;leds apagados, rumble off
		ControlarLeds(False,False,False,False)
		Escribir(2)
		SolicitarEstado()
	End If

	If KeyHit(7) Then
		WiiMote\Rumble = Not(WiiMote\Rumble)
		ActualizarLeds()
	End If
	
		
End Function

Function MuestroEstadoWiiMote()
	Local temp$
	
	Mostrar "AccelXRel: " + WiiMote\AccelXRel
	Mostrar "AccelYRel: " + WiiMote\AccelYRel
	Mostrar "AccelZRel: " + WiiMote\AccelZRel
	Mostrar "Batt     ; " + WiiMote\Energia

	temp$ = Right$(Bin$(WiiMote\Botones1),8) + "-" +Right$(Bin$(WiiMote\Botones2),8)
	
	If WiiMote\Led1 Then 
		temp = temp + "    1 "
	Else
		temp = temp + "    . "
	End If
	
	If WiiMote\Led2 Then 
		temp = temp + "1 "
	Else
		temp = temp + ". "
	End If
	
	If WiiMote\Led3 Then 
		temp = temp + "1 "
	Else
		temp = temp + ". "
	End If
	
	If WiiMote\Led4 Then 
		temp = temp + "1 "
	Else
		temp = temp + ". "
	End If

	Mostrar temp
	
	If WiiMote\IrMode&lt;&gt;0 Then
	
		Color 255,0,0
		Rect 0,0,1024,768,False
		
		
		If WiiMote\P1\t&lt;&gt;-1 Then
			Color 0,255,0
			If WiiMote\P1\t&gt;0 Then
				Oval WiiMote\P1\x, WiiMote\P1\y, WiiMote\P1\t, WiiMote\P1\t, True
			Else
				Oval WiiMote\P1\x, WiiMote\P1\y, 2, 2, True
			End If
		End If
		
		If WiiMote\P2\t&lt;&gt;-1 Then
			Color 0,0,255
			If WiiMote\P2\t&gt;0 Then
				Oval WiiMote\P2\x, WiiMote\P2\y, WiiMote\P2\t, WiiMote\P2\t, True
			Else
				Oval WiiMote\P2\x, WiiMote\P2\y, 2, 2, True
			End If
		End If
		
		If WiiMote\P3\t&lt;&gt;-1 Then
			Color 255,255,0
			If WiiMote\P3\t&gt;0 Then
				Oval WiiMote\P3\x, WiiMote\P3\y, WiiMote\P3\t, WiiMote\P3\t, True
			Else
				Oval WiiMote\P3\x , WiiMote\P3\y, 2, 2, True
			End If
		End If
		
		If WiiMote\P4\t&lt;&gt;-1 Then
			Color 0,255,255
			If WiiMote\P4\t&gt;0 Then
				Oval WiiMote\P4\x, WiiMote\P4\y, WiiMote\P4\t, WiiMote\P4\t, True
			Else
				Oval WiiMote\P4\x, WiiMote\P4\y, 2, 2, True
			End If
		End If
		
		If WiiMote\P1\t&lt;&gt;-1 And WiiMote\P2\t&lt;&gt;-1 Then
			Color 128,128,128
			Oval WiiMote\PMx, WiiMote\PMy, 4, 4, True
			Color 255,255,255
			temp = "P1P2: " + WiiMote\P1P2Dist
			Mostrar temp
		End If

		Color 255,255,255
		If WiiMote\P1\t&lt;&gt;-1 Then
			temp = Str(WiiMote\P1\x)+", "
			temp = temp + Str(WiiMote\P1\y)+", "
			temp = temp + Str(WiiMote\P1\t)
			If WiiMote\IrMode = IR_Full Then
				temp = temp + ", "+WiiMote\P1\i
			End If
			Text WiiMote\P1\x + 10,WiiMote\P1\y, "P1"
			Mostrar temp
			
		End If
	
		If WiiMote\P2\t&lt;&gt;-1 Then
			temp = Str(WiiMote\P2\x)+", "
			temp = temp + Str(WiiMote\P2\y)+", "
			temp = temp + Str(WiiMote\P2\t)
			If WiiMote\IrMode = IR_Full Then
				temp = temp + ", "+WiiMote\P2\i
			End If
			Text WiiMote\P2\x+10,WiiMote\P2\y,"P2"
			Mostrar temp
		End If
	
		If WiiMote\P3\t&lt;&gt;-1 Then
			temp = Str(WiiMote\P3\x)+", "
			temp = temp + Str(WiiMote\P3\y)+", "
			temp = temp + Str(WiiMote\P3\t)
			If WiiMote\IrMode = IR_Full Then
				temp = temp + ", "+WiiMote\P3\i
			End If
			Text WiiMote\P3\x + 10,WiiMote\P3\y ,"P3"
			Mostrar temp
		End If
	
		If WiiMote\P4\t&lt;&gt;-1 Then
			temp = Str(WiiMote\P4\x)+", "
			temp = temp + Str(WiiMote\P4\y)+", "
			temp = temp + Str(WiiMote\P4\t)
			If WiiMote\IrMode = IR_Full Then
				temp = temp + ", "+WiiMote\P4\i
			End If
			Text WiiMote\P4\x + 10,WiiMote\P4\y,"P4"
			Mostrar temp
		End If
		
	End If
End Function

Function EvaluoAcelerometros()
	
	Local i, temp$
	
	Pasada = Pasada + 1
	If Pasada = Suavizado Then Pasada = 0
	
	PromPitch[Pasada] = WiiMote\AccelYrel
	
	PromRoll[Pasada] = WiiMote\AccelXrel
	
	PitchAcum = 0
	RollAcum  = 0
	For i=1 To Suavizado
		PitchAcum = PitchAcum + PromPitch[i]
		RollAcum  = RollAcum  + PromRoll[i]
	Next
	
	PitchAcum = PitchAcum/Suavizado
	RollAcum = RollAcum/Suavizado
	
	RotateEntity Control,300*PitchAcum,0,-300*RollAcum
	
End Function

Function Mostrar(stramostrar$)
	;xTexto, yTexto son globales
	;esta rutina va mostrando renglon a renglo, incrementando y
	Text xTexto,yTexto,stramostrar
	yTexto = yTexto + 20
End Function
</textarea> <br><br></td></tr></table><br>
<a name="954415"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ZJP</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yessss. Thx<br>Time to post here <a href="http://www.blitzbasic.com/Community/topics.php?forum=94" target="_blank">http://www.blitzbasic.com/Community/topics.php?forum=94</a> ;-)<br><br>JP <br><br></td></tr></table><br>
<a name="966379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ZJP</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Have you got an example with the IR sensor?<br><br>JP <br><br></td></tr></table><br>
<a name="966385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi<br><br>the wiimote has a camera that has some recogn software that detects up to 4 ir dots, it has an ir filter to block normal sun ligth but any strong light should make the software fail. <br>The wiimote only report the x,y position of the dots detected (if any) and some other information like size. It depend on the ir mode: Basic, extenden or full.<br><br>the sensor bar (bad name!) is not a sensor, it is composed of IR emiters (leds) that are seen by the wiimote camera (the real sensor!), knowing the position of the sensor bar and the distance between the 2 ir emiter that the sensor bar has and some trigonometric calculus and some asumptions and simplifications is it pósible to estimate the wiimote position in the 3d space, or at least to where is heading or facing....<br><br>i don't have a "sensor bar" i use ir emiters home made so i place each one where i want. To do so, you only have to get some ir leds (940 nm recommended) a battery and a resistor to limit the current throug the led.<br><br>if you want to make one, tell me and i post a simple diagram with some equations to get the value of the resistor and some precautions to not blow the led.<br><br>Juan <br><br></td></tr></table><br>
<a name="966614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ZJP</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br>Thx. IR cam tested with GlovePIE. Can you post a Blitz3D example?<br><br>JP <br><br></td></tr></table><br>
<a name="966619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> in the update (post #5), the second codebox has an example, on it, it show the status of the buttons, you could toggle the 4 leds with the number key 1..4 and turn off all with 5. Puls, read the accelerometers and rotate the blitz blue cube on the center of the screen acordingly and show (if any) the reported IR dots.<br><br>At initialization the code sets ir mode to extended and an intermediate sensibilit of the ir camera. <br><br>I'm having troubles to make the code work under Vista. Under xp i have no problems. Before run the app you have to connect the wiimote with BlueSolei or the bluetooth stack you use. But i supose you know how to do it if you are using GlobePie.<br><br>you have to constantly call Leer (read) and if Leer=True then you can call<br>EvaluoRecepcion (EvaluateReception) that routine set all the variables on the WiiMote variable (type Controller) so after calling EvaluoRecepcion you can use any variable inside WiiMote, particullary the fields P1, P2, P3 and P4 are type PuntoIR:<br><br>Type PuntoIR<br>	Field x	; en el rango 0..1023<br>	Field y	; en el rango 0..767<br>	Field t	;Tamaño relevante si IRMode = Extended o Full, si -1 no detectado en todos los modos<br>	;relevantes solo si IRMode = Full<br>	Field i	;intensidad<br>	Field xMax<br>	Field xMin<br>	Field yMax<br>	Field yMin<br>	Field Indice<br>End Type<br><br>the fields x,y are self explanatories (hope)<br>the field t = -1 signals ir dot not seen, but if it is 1 or more signal the size reported by the wiimote, the field i signals the intensity. xMax, etc are a rectangle that surounds the dot seeing by the camera and are reading only if the mode of operation is Full.<br><br>i have no code or equations for the sensor bar because first i don't have one, and second i don't need one. I'm working with four dots at the same time but not only 4 ir emiters, i'm switching on more than 4 dots (microcontroller based) and knowing wich are on at any time i can read and keep track of more than the four that read the camera. Of course time multiplexed so i have less samples per second of each dot. I know my app is particular so my interest in the sensor bar is 0. I use the wiimote only for the ir dots and to have a first tool to work on. In the middle proces i'been developing my own ir camera analyzing the video signal. The wiimote gives me the chance to test some code/hardware before my ir camera get's ready.<br><br>Juan <br><br></td></tr></table><br>
<a name="966621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ZJP</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thx. I'm testing this. ;)<br><br>JP <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
