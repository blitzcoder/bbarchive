<!DOCTYPE html><html lang="en" ><head ><title >EntityExists()?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >EntityExists()?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >EntityExists()?</a><br><br>
<a name="330999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mrtricks</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is there a command that you can call to find out if an entity (or mesh) exists, and that you haven't Freed it? <br><br></td></tr></table><br>
<a name="331000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think EntityClass() might work...<br><br>Edit: Nah, forget it, that didn't work <br><br></td></tr></table><br>
<a name="331001"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PsychicParrot</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you check if it's either void or 0? I think you may be able to. I don't think there is an entityexists as such, though :( <br><br></td></tr></table><br>
<a name="331004"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jhocking</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> A couple weeks ago I was asking about the same thing.  I/we concluded nothing like this exists in the commands, and a lot of people told me I'm a bad programmer for writing routines in which it is possible for my functions to attempt to do something with an entity which no longer exists.  Frankly though I think this would be a very useful command.  No matter how careful you are, in a large program you can never be 100% sure, so basic error trapping with an EntityExists command is vital.<br><br>What I couldn't understand is that people think checking if a load was successful before using loaded data makes sense, but these same people think checking if an entity exists before using it is lazy.  The way I see it, if it'll crash your program then it's something to check for.<br><br>Psychicparrot: That only helps for a specific handle.  You can check if a specific handle has been set to zero (since handles are just integer variables,) but you can't check if the entity a handle points to actually exists. <br><br></td></tr></table><br>
<a name="331013"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PsychicParrot</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I see what you mean. If you use freeentity, though, the handle should go to 0 shouldn't it? <br><br></td></tr></table><br>
<a name="331023"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jhocking</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> No.  Again, handles are just integer variables, not some special entity-related data structure.  Not only does that mean FreeEntity has no way of knowing about the handles, you can make as many handles as you want.  You can (and should) set handles for an entity to 0 when you free an entity, but that can be a non-trivial task for complex code if there are multiple handles in various places, like fields of various type objects.  In many cases you cannot really be 100% sure you've zeroed all handles pointing to a given entity. <br><br></td></tr></table><br>
<a name="331027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PsychicParrot</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmmm. Pity, that! Shockwave has an Entityexist command and (even though some might say it's bad programming!) it really IS a useful command to have.<br><br>I guess the only way to do this would be to build functions that took over the role of the loadentity and freeentity commands, so instead of using those you call the functions which update info stored in types .. messy! <br><br></td></tr></table><br>
<a name="331506"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ken Lynch</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> This has been asked for time and time again. I came across the need for it several times, including when writing a homing missile system. There may be several missiles following one enemy, but when the enemy is destroyed the other missiles needed to know. The best way I've found round the lack of this command is to encapsulate all entities into type structures, this way you can delete the type and all references to that type now end up as NULL. <br><br></td></tr></table><br>
<a name="331602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> The way I got around this one was to have a entitytype which had ID$ and the entity itself then when the entity was freed I deleted the ID and the type entry. This means any call to EntityExist( ID$ ) would search the type and if it doesnt exist I just return false else I return true =). The only trouble is there is a small overhead on the copying of entities. <br><br></td></tr></table><br>
<a name="331607"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> IMHO an EntityExist Command is not needed.<br><pre class=code>
Function EntityFree(entity%)
	FreeEntity entity%
End Function ;Returns 0 by default

;Use
myentity=EntityFree(myentity)

If myentity 
	EntityExist=True
Else
	EntityExist=False
EndIf</pre> <br><br></td></tr></table><br>
<a name="331610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jhocking</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's bass ackwards.  If you can't figure out which handles point to an entity when freeing it, how can you figure out which entity the handle points to for checking if it exists?  That is, how can you tell which myentity variable to check?<br><br>Imagine a situation like your average simulation game (RTS, whatever.)  A potentially limitless number of entities can be created at any time, and any of those enitities can be destroyed at any time.  Now imagine coding some AI where multiple entities decide to attack one other entity.  When that other entity is destroyed, it is non-trivial to convey that fact back to the attacking entities (so that they stop checking the position of the target, for example) in the open ended situation of an RTS game.<br><br>The little trick you described would work well if you had a strictly limited number of entities, all created from the beginning of the game, but then the trick would be useless in that situation.<br><br>ADDITION: Wait, re-reading your post I don't think you understand the problem.  If there is only one handle to an entity that's easy to deal with.  Then it is pretty obvious what handle points to that entity since there is only one handle.  Your trick is needlessly obfuscating the code; just make the next line after freeing the entity myentity=0 and don't bother with a special entity free function.  The problem is if multiple handles exist to a single entity.  This situation is especially problematic if the handles are buried in the fields of multiple type objects.  In that situation it is really difficult (impossible basically) to know all the handles which point to a given entity and set them all to 0.<br><br><br>@Ken and edzup: Could you post some code demonstrating what you are talking about?  That sounds pretty useful but I'm not exactly understanding what you described.<br><br>Wait, I think I get it.  Instead of making additional handles pointing to an entity, you make handles to a type object which has, as one of its fields, the handle to the entity.  Then when you need to access that entity you do so by accessing the type object first, and then the field of the type object.  Thus only one direct handle to the entity exists.  Hm, this would work very well actually.  Do you understand the trick they suggested, mrtricks?  Because this should solve the problem. <br><br></td></tr></table><br>
<a name="331647"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MadJack</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> My own experience with this is that if your code is correct (i.e. pointer/s to a deleted object are cleared on object deletion), then it souldn't be a problem.<br><br>Practically though, I have a lot of objects checking/referencing each other per updateworld and I'm only a so-so coder and so I've taken to hiding deleted objects and then freeing them in the next updateworld.<br><br>So ok, you can point out how wrong I am now to do this.. <br><br></td></tr></table><br>
<a name="331697"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've not yet updated to the latest versio of B3D but was under the impression (for some reason) that an EntityExists() function had been added. I'm obviously mistaken. Booo! C'mon, lets have it. Trying to keep track of multiple handles to the same ent etc. is an unwelcome extra headache for the programmer, IMO. <br><br></td></tr></table><br>
<a name="331759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> The reason why one would need such a command, is because there is no other form of recordkeeping implemented in the beginning of the app. There is truly no such thing as infinite objects as they are limited by the amount of physical memory your hardware possesses.<br><br>The code above works, give it a try. I could only imagine how bloated Blitz3D would be, if a command was in added for every scenerio. This is something a Blitz programmer can control. <br><br></td></tr></table><br>
<a name="331974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Aside from that, how could an entity exist command be written?<br><br>Assuming that an entity handle is a pointer to an area of memory, how could Blitz know if that was a valid memory address short of keeping and searching through a list of all handles, which would be expanded each time an entity was created and edited each time an entry was removed.  IMO this would be quite slow. <br><br></td></tr></table><br>
<a name="332402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> A couple of solutions spring to mind (well, OK, I had to think about it for a bit :) ...<br><br>1) Use multiple indirection: When Blitz creates an entity, create an internal pointer to that entity and return the address of this pointer as the entity's handle (i.e. the handle will be a-pointer-to-a-pointer-to-an-entity). Then, when an entity is freed, set the internal pointer to NULL. <br><br>An EntityExists(handle) function would then only have to check to see if the handle points to a NULL pointer in order to see if the entity exists or not.<br><br>This mechanism would work even if your prog had multiple handles to the same entity.<br><br>Downsides: the internal pointer (4 bytes) would have to remain in mem for the duration of the prog. Accessing entities through their handles would have a slight overhead due to the multiple indirection. Then again, I think Blitz already does this: I'm pretty sure Blitz entity handles aren't direct pointers to the actual entity's data. I could be wrong.<br><br><br>2) Store unique entity IDs in a binary tree (or some-such suitable structure): So, each time an entity is created, we get a pointer to it which, when converted to an integer, represents a unique entity ID. Next, add this ID to the tree and in it's node have the pointer to the entity. Again, return the address of this pointer as the entity handle.<br><br>An EntityExists(handle) function would then have to dereference the handle (to get the pointer to the actual entity), convert it to an ID integer, and then search the tree for it. If it's in the tree then the entity exists, otherwise it doesn't. This should be quicker than it sounds!<br><br>When an entity is freed, it's tree node can be deleted which will also mean the 4 bytes used as the entity's internal pointer is freed also, unlike the first method, above.<br><br>Hope some of that made sense! :)<br><br>[EDIT] I guess I should have made it clear that the solutions I offer above are not for implementation in Blitz code, but rather how I figure it would be possible for Mark to implement a native EntityExists() function. Not that I know jack about the internal workings of B3D, of course. :P <br><br></td></tr></table><br>
<a name="332423"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ChrML</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Argh, this isn't hard. When you create a camera, you create it the normal way:<br><br>mesh = LoadMesh("mesh.3ds")<br><br><br>When you free it, you first free it, and then set it's value to 0:<br><br>FreeEntity mesh<br>mesh = 0<br><br><br>Then when you want to check if it exists, just do:<br><br>if mesh&lt;&gt;0 then<br>  ;code if mesh exists<br>else<br>  ;code if mesh NOT exists<br>endif<br><br><br>The variable mesh after loading the model is really just a 32 bit integer telling the position of the model in the memory. It's nothing more. So, just free it, and set the pointer value back to 0, so you can check if it exists later. Just make sure that you DON'T first set it to 0, and then free it, because that will cause it to try freeing a model at memory offset 0, which doesn't exists; Memory Access Violation. And don't just set it to 0 without freeing it first, cuz then it will never be unloaded, and then cause memoryleak (memory that gets used, but not freed) until the blitz appliaction closes. Also, an another common mistake is this:<br><br>mesh = LoadMesh("somemesh.3ds")<br>mesh = LoadMesh("anothermesh.3ds")<br><br>This will load a mesh into the memory, and put the pointer for using/freeing later into 'mesh', but then it loads an another model into the memory, and puts the pointer too into 'mesh'. That will make you loose the first pointer; you will not be able to free the first one again; memoryleak. <br><br></td></tr></table><br>
<a name="332424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ChrML</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woops, bug in the first line :P. I meant:<br><br>When you load a mesh, you load it in the normal way: <br><br></td></tr></table><br>
<a name="332468"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jhocking</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> ChrML, thanks for trying to help, but you're not understanding the problem.  We can't set the handle to 0 (or at least we aren't sure the handle has been set to 0) because we don't know where all the handles are.  There are multiple handles to the entity, an unknown number created as fields of type objects, not just one clearly known handle.  Setting one clearly known handle to 0 is easy, setting an unknown number of multiple handles in unknown type objects to 0 is difficult.<br><br>At any rate, other peoples' suggestions work.  In particular, Ken and edzup's suggestion regarding referencing type ID's instead of entity handles works well. <br><br></td></tr></table><br>
<a name="332496"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ChrML</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, I use the same system for multiple types. If there are multiple handles, and you want to free them all, then just:<br><br>For tmp.mytype = each mytype<br>  if tmp.mytype&lt;&gt;0 then<br>    FreeEntity tmp.mytype<br>    tmp.mytype = 0<br>  endif<br>Next<br><br><br>For my weapon system I have huge number of types both for the declarations loaded from a .mis file, types for the weapons placed in the world, and types for the weapon in your inventory. Many types refer to eachother with my id system. Like:<br><br>Weapon gets loaded into the declaration system, with the id 'ingram' for example. Then my PlaceWeapon command in my custom script system places it in the world, with the parameter 'ingram' then. Which means, when you pick the weapon, it checks the master record telling accuracy, firerate, type of gun etc..., and loads the info from there. Then when you pick it, the weapon in the inventory type also gets the same id as the master record has to get more info when it shoots.<br><br>Here's an example on how you can solve this:<br><br><pre class=code>
Type Models
  Field id$,filename$,model
End Type


Function LoadModel(filename$,id$)
  For tmp.Models = each Models
    if tmp.Models\id$ = id$ then
      RuntimeError "Two models can't have same ID!"
    endif
  Next

  tmp.Models = New Models
  tmp.Models\id$ = id$
  tmp.Models\filename$ = filename$ ;store it just incase
  tmp.Models\model = LoadModel(filename$)

  if tmp.Models\model&lt;&gt;0 then
    RuntimeError "Error loading "+filename$+"! Illegal filename?"
  endif
End Function


Function KillModel(id$)
  For tmp.Models = Each Models
    if tmp.Models\id$ = id$ then
      FreeEntity tmp.Models\model
      Delete tmp.Models   ;no need to put it back to 0 here, cuz we delete the type entry
    endif
  Next
End Function
</pre><br><br>Then we just make similar functions for moving them, etc... This is just an example though! :) Handling multiple pointers with unknown number of types is never difficult. Just make sure you think of all bugs before you test :P. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
