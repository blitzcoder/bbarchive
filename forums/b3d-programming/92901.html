<!DOCTYPE html><html lang="en" ><head ><title >How are shadows done these days?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >How are shadows done these days?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >How are shadows done these days?</a><br><br>
<a name="1060486"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking for information or links on shadows! <br><br></td></tr></table><br>
<a name="1060499"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are several methods, but what you want will depend on both the style of your game (i.e. how much "cheating" you can get away with that wouldn't necessarily look right in a different enironment), and how much performance you're willing to sacrifice for aesthetics. There are a few standard methods, however:<br><br>1) Copied, flattened mesh. Use a second copy of the mesh that has been flattened in Y, to multiply against the floor. Accuracy is good, but it requires a lot of crushing of vertices, which is processor-intensive, and there's no easy way to have a floor that's anything other than flat, or other objects in the way.<br><br>2) Projective shadows. Using a second, black-on-white, render from the perspective of the light, create a shadow texture. Project this onto the environment using:<br>a) a flat floor. Same disadvantages as above, but slightly better performance because you're usign a render;<br>b) a "towel" flexible quad mesh; just about OK for rough terrain but doesn't work for walls or other objects;<br>c) a dynamic shadow mesh reconstructed each frame. Pretty heavy on the processor but produces good results.<br>This method(s) can produce high-quality shadows but it's dependent on the shadow texture render quality. FastExt (which you should have anyway as it's very good in many ways) does this for whole scenes, and SSwift's shadow system does it for individual meshes (higher quality, at cost of performance). There is no <i>good</i> way for this method to provide self-shadows, or any shadows cast on animated meshes. This is easy to implement, but very hard to implement well.<br><br>Either of the above methods can easily be changed to use generic "blob" shadows if you don't want the associated cost of a shadow render (on most machines however, the render is probably the fastest part).<br><br>3) Stencil shadows. These use some multipass rendering tricks to apply shadows as a postprocess step to the whole screen (so the shadows can't be applied per-object, and rendering them has a constant performance cost). However, in order to set up the render you need to project shadow meshes from casters, which is extremely prohibitive using Blitz3D's internal mesh handling. There may be ways around this but as far as I know nobody has researched the matter. Also, no existing system is compatible with animated B3D meshes.<br><br>There are a few variations and combinations of these basic ideas, and a ton of code archive examples, but that's the main part. Other shadow alorithms, such as shadow mapping using the Z-buffer, haven't been successfully implemented in Blitz3D to the best of my knowledge (which is a pity, the Z-buffer method is <b>easily</b> the best).<br><br>TL;DR: Get FastExt for pre-packaged shadows. Otherwise, check the code archives, or ask again for help if you're having real difficulty and someone will share theirs. <br><br></td></tr></table><br>
<a name="1060516"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thought FastExt was bugged with latest version of blitz. Any ready to go solutions without using FastExt as I don't want to pay for yet another addon. <br><br></td></tr></table><br>
<a name="1060517"></a>

<a name="1060518"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pre-baked lightmaps are still the best way to do shadows in Blitz3D. FastExt has some useful stuff you can use for limited dynamic shadows.<br><br>Shadowmaps + PSSM is badly needed :(<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just need dynamic ones for the players. <br><br></td></tr></table><br>
<a name="1060555"></a>

<a name="1060556"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MikhailV</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> o_O FastExt was bugged with latest version of blitz? Are you sure?<br>You are mistaken. Check latest version 1.17<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060558"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> For me shadows are also the real feature lack in Blitz3D. ODE works, and fancy postprocessing stuff isn't really needed imho when the Design is good. DC's stencil shadows unfort. only support a single light, might be ok for outdoor things, but I can't rely on that.<br><br>I know, Blitz3D wouldn't be the language someone should use to create the negt gen, end of all best shadow algorithm, but I can't stop thinking about it. Maybe I come up with something the sooner or later. <br><br>Other than that, as far as I know, there is only the ashadow lib for Blitz3D, but when you're browsing the 3d engine database on devmaster.net, there are many DLLs you could use instead, open source, ready to be wrapped for Blitz3D. There is for instance a Irrlicht Wrapper for Freebasic. Irrlicht might not be next gen, but it has shadows and much more. <br><br>There are more engines, and some of them really do offer a lot, including wrappable sourcecode. But for now I am searching for a powerful, simple shadow addon for good old Blitz3D. I think Shadow Volumes, Stencil Shadows are not the way to go. Ehrm... AFK to try something :) ... <br><br></td></tr></table><br>
<a name="1060566"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> JFK: <a href="https://sites.google.com/site/nangdongseng/downloads/Shadow.zip?attredirects=0&amp;d=1" target="_blank">https://sites.google.com/site/nangdongseng/downloads/Shadow.zip?attredirects=0&amp;d=1</a><br><br>Simple and high-res, if you don't mind the CPU load.<br><br><br>One of these days I still mean to go back and have another shot at implementing Z-buffer shadows... it must be possible in B3D; everyone else has them... <br><br></td></tr></table><br>
<a name="1060584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Yasha, that's not bad, tho not perfect and as you said a framerate killer. I am currently experimenting with what I understand is Depth Light Mapping. It won't be fast, but maybe pretty flexible and sophisticated. There is one problem I got right now. I'd need a orthographic projection camera WITH working fog, to make a depth render from the point of view of the light.<br><br>Unfort. in Blitz Fog doesn't seem to work with the orthographic projection camera. Maybe somebody can help me, is it possible to combine CameraZoom and ScaleEntity in a way that gives me an (almost) orthographic projection with CamerProjMode 1, with about the same viewport as a standard camera using default values ? <br><br></td></tr></table><br>
<a name="1060586"></a>

<a name="1060587"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's the same thing I'm talking about (I think). Unfortunately using fog is (in my opinion) a non-starter: you only have 8-bit depth precision, which is fine for a proof-of-concept demo but not good enough for real ingame use on complex, detailed meshes. I've been looking around to see if there's any other way to get the necessary data... nothing yet, but rest assured it will become public very quickly if I find out anything.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060646"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Haven't looked at Yasha's link yet - but would it be possible if its CPU heavy to thread it with fastpointer? <br><br></td></tr></table><br>
<a name="1060694"></a>

<a name="1060699"></a>

<a name="1060886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi again. To my surprise, emulating a zbuffer using fog was straight forward, but I expected to get at least 768 levels, I was wrong. Although it's really impressive how things are simplified by such a radical approach. I don't know much about 3D math, so I was cheating a lot, I used a lookuptable that would give the 3d location of a certain render x,y,fogcolor, in fact a perspective-un-correction, turning that data back into orthographic projection.<br><br>Sawtheeth / Stairs artefacts due to rounding errors in depth determination by fog is horrible with these 8 Bits. When watched in wireframes, the potential becomes visible. A Resource-Hugger, of course. A spotlights takes 64k Verts and 32kTris. But when I think of the hardware power we most likely will see in the next years, I think this could be useable (o course, not with fog).<br>What I mean is: why does everybody always talk about shadows where shadows don't exist in reality, only the absence of light. So why don't we work with the light right away? Because there is an empty hall with a little NPC in the middle? Well I don't want such a leveldesign anyway :)<br><br>I am currently trying to access the ZBuffer, but zbuffer.bb with zbuffer.decls and zbuffer.dll, that was released here some time ago (don't remember by who) simply refuses to work on my machine. It says userlib not found,but it's all there. I also tried to use DevilsChild's Shadowlib with a long list of wrapped DX7 functions in userlibs, but I couldn't make it work. Those commands, Lockbuffer, LockZWrites, ENabeZBuffer, DisableZWrites and so on are confusing me kind of, I don't know DirectX personally, I always sent Mark to them...<br><br>Any Ideas for Zbuffer access? Would be nice to have an individual CameraViewport for the ZBuffer, then use eg. ReadPixel on the backbuffer to get the depth of a certain pixel.With more than 8 Bit, of course.<br><br>Here's something VERY experimental: (Note, it will on the first run create ans save a lookup table named cache.z,this may take a while)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Experimantal Shadow Technic: Projected Light Towel
; Fog is used to emulate a ZBuffer. Unfort. with only 256 levels of grey.
; So, this is a Tech demo only. Direct Access to the ZBuffer would however
; make it a serious approach IMO.
; Hit W to see its potetial.

; note: when you alter PhotonCamZoom# or the size of the Depthbuffer (look_w..) or fog range
; then the file "cache.z" must be recreated. If so, then just delete it before you run the code.

; note: all thrown together in a hurry, just a test.

Graphics3D 800,600,32,2
SetBuffer BackBuffer()
WBuffer 1


;WireFrame 1
AmbientLight 20,20,20
;AmbientLight 127,127,127


; init entity iteration------------------------
Global Cycle_bank=CreateBank(16)
Const  Cycle_NextEntity=4
Const  Cycle_LastEntity=8
Global Cycle_FirstEntity=CreatePivot()
Global Cycle_CurrentEntityPointer=Cycle_FirstEntity
;----------------------------------------------------



Global fogrange#=20.0 ; this will also be the max range of the projected light!

Global PhotoCamZoom#=1.0

Global look_w=140 ; can't go higher due to 64k (w*h*4) vertices limit and the need for unshared verts (tried shared ones, a mess due to alpha sawtheeth)
Global look_h=105

; That's BTW a good sample about the inconsistency of hardware vertices limits. While most cards support the amount just set in the previous lines,
; my laptop (S3 card) simply don't show the mesh until I go under this:
look_w=120
look_h=90




Global test_r=255
Global test_g=255
Global test_b=255

Dim sh_scrn(look_w,look_h)
Dim rgb_scrn(look_w,look_h)
Global sstep#=10.0



; projected light mesh
Global PhotonMesh=CreateMesh()
Global PhotonSurf=CreateSurface(PhotonMesh)
Dim PhotonVerts(look_w,look_h,3) ; vertex handles of the towel
Dim PhotonCache(look_w,look_h)   ; storing last depth render for cache 
Dim PhotonDepth(look_w,look_h)   ; depth render quick access array

For y=0 To look_h-1
 For x=0 To look_w-1
  x2#=(x-(Floor(look_w/2)))*0.05
  y2#=(y-(Floor(look_h/2)))*0.05
  x2b#=((x+1)-(Floor(look_w/2)))*0.05
  y2b#=((y+1)-(Floor(look_h/2)))*0.05
  PhotonVerts(x,y,0)=AddVertex(PhotonSurf,x2 , y2  ,0) 
  PhotonVerts(x,y,1)=AddVertex(PhotonSurf,x2b, y2  ,0) 
  PhotonVerts(x,y,2)=AddVertex(PhotonSurf,x2b, y2b ,0) 
  PhotonVerts(x,y,3)=AddVertex(PhotonSurf,x2 , y2b ,0) 
 Next
Next


For y=0 To look_h-2
 For x=0 To look_w-2
  t1=AddTriangle(PhotonSurf,PhotonVerts(x,y,0),PhotonVerts(x,y,1),PhotonVerts(x,y,2) )
  t2=AddTriangle(PhotonSurf,PhotonVerts(x,y,0),PhotonVerts(x,y,2),PhotonVerts(x,y,3) )
 Next
Next


; simple scene...
Global camera=CreateCamera()
Global scene_center=CreatePivot()
maincam_targetpiv=CreatePivot()


light=CreateLight(3) ; position and angle of this light will be used for the light mesh projection
test_range#=2.2
LightRange light,test_range# ; actually this may be very low, we don't want it to enlight things in the shade
PositionEntity light,0,-2,7 ; note, this important position for the system
PointEntity light,scene_center

light_cube=CreateCone(12,1,light)
RotateMesh light_cube,-90,0,0
ScaleEntity light_cube,0.2,0.2,0.1
EntityFX light_cube,1
;EntityAlpha light_cube,0.3
EntityColor light_cube,255,255,0



Global PhotonCamPiv=CreatePivot()
Global PhotonCam=CreateCamera(PhotonCamPiv)
CameraProjMode PhotonCam,0
Global helper=CreatePivot()

dis#=10

For i=0 To 30
 c=CreateCube()
 PositionEntity c,Rnd(-10,10),Rnd(-6,-4),Rnd(-10,10)
 RotateEntity c,0,Rand(360),0
 ScaleEntity c,3,1,3
 EntityPickMode c,2
Next

w1=CreateCube() ;walls
ScaleEntity w1,10,10,1
TranslateEntity w1,0,0,10

w2=CreateCube()
ScaleEntity w2,10,10,1
TranslateEntity w2,0,0,-10

w3=CreateCube()
ScaleEntity w3,1,10,10
TranslateEntity w3,10,0,0

w4=CreateCube()
ScaleEntity w4,1,10,10
TranslateEntity w4,-10,0,0

w5=CreateCube() ; ceil
ScaleEntity w5,10,1,10
TranslateEntity w5,0,10,0

col=CreateCylinder()
ScaleEntity col,0.5,10,0.5
TranslateEntity col,-5,0,-5

col=CreateCylinder()
ScaleEntity col,0.5,10,0.5
TranslateEntity col,0,0,-5


npc=CreateSphere(10) ; would work with aniomated B3D too
ScaleEntity npc,2,5,2


EntityFX npc,1

npc_x#=-5





;-------------------------------- create or load fogdensity/xyz lookup table...

; (I am trying to achieve 3*256 shades of grey here, I'm afraid they are still only 256)
Dim lookupX#(look_w,768)
Dim lookupY#(look_h,768)
Dim lookupZ#(768)



 CameraProjMode camera,0
 CameraProjMode PhotonCam,1
 CameraFogMode PhotonCam,1
 CameraFogColor PhotonCam,1,2,3 ; seems I an get only 256 levels here! Any ideas?
 CameraFogRange PhotonCam,0,fogrange#
 CameraViewport(PhotonCam,0,0,look_w,look_h)
 CameraZoom PhotonCam,PhotoCamZoom#


lookupfile$="cacheZ.z"
If FileType(lookupfile$)=0

dumm=CreateCube()
EntityFX dumm,1
ScaleEntity dumm,1000,1000,0.001
EntityPickMode dumm,2

CameraRange PhotonCam,0.001,100.0
EntityParent dumm, PhotonCam
PositionEntity PhotonCam,32000,0,0

print "caching lookup table, please stand by..."
For i=0 To 767 
 PositionEntity dumm,0,0,(fogrange#/768.0)*Float(i)
 ;RenderWorld()
 ;Flip
 For x=0 To look_w-1
  pick=CameraPick(PhotonCam,x,0)
  lookupX#(x,i)=PickedX()-32000
 Next
 For y=0 To look_h-1
  pick=CameraPick(PhotonCam,0,y)
  lookupY#(y,i)=PickedY()
 Next
 If KeyHit(1) Then End
 pick=CameraPick(PhotonCam,0,0)
 lookupZ#(i)=PickedZ()
Next


FreeEntity dumm
PositionEntity PhotonCam,0,0,0

Else
 re=ReadFile(lookupfile$) ; load file
 For i=0 To 767
  For x=0 To look_w-1
   lookupX#(x,i)=ReadFloat(re)
  Next
  For y=0 To look_h-1
   lookupY#(y,i)=ReadFloat(re)
  Next
  lookupZ#(i)=ReadFloat(re)
 Next
 CloseFile re
EndIf


; save generated
If FileType(lookupfile$)=0
 wr=WriteFile(lookupfile$)
 For i=0 To 767
  For x=0 To look_w-1
   WriteFloat wr,lookupX#(x,i)
  Next
  For y=0 To look_h-1
   WriteFloat wr,lookupY#(y,i)
  Next
  WriteFloat wr,lookupZ#(i)
 Next
 CloseFile wr
EndIf
CameraProjMode camera,1
CameraProjMode PhotonCam,0



ft=MilliSecs()
MoveMouse GraphicsWidth()/1.8,GraphicsHeight()/1.8

a#=326
While KeyHit(1)=0 ; MMMMMMMMMMMMMMMMMMMMMMMMMMMMM MAINLOOP MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 npc_x#=npc_x+.1
 If npc_x&gt;12 Then npc_x=-12
 PositionEntity npc,npc_x,0,0
 TurnEntity npc,1,2,3
 If KeyDown(200)
  test_range#=test_range#*1.1
  If test_range#&gt;20 Then test_range#=20
  LightRange light, test_range#
 EndIf
 If KeyDown(208)
  test_range#=test_range#*0.9
  If test_range#&lt;0.1 Then test_range#=0.1
  LightRange light, test_range#
 EndIf

 If KeyDown(203)
  a#=a#+2
 EndIf
 If KeyDown(205)
  a#=a#-2
 EndIf
 If KeyHit(17) Then 
  wire =wire Xor 1
  If wire=0 Then WireFrame 0
 EndIf

 PositionEntity light,( (GraphicsWidth()/2)-MouseX() )/40.0,((GraphicsHeight()/2)-MouseY())/40.0,7 ; note, this important position for the system
 PointEntity light,scene_center


 If a#&gt;360 Then a#=0
 If a#&lt;0 Then a#=360
 PositionEntity camera,Sin(a#)*dis,0,Cos(a#)*dis
 PointEntity camera,maincam_targetpiv
 UpdateWorld()
 LetThereBeLight(light)
 If wire&lt;&gt;0 Then WireFrame 1
 RenderWorld()
 If wire&lt;&gt;0 Then WireFrame 0
 Color 255,0,0
 Text 250,0,"Tris:"+TrisRendered()
 Text 150,0,"FPS:"+1000/ft
 Text 350,0,"left,right, up, down,W,mouse"
 Text 150,16,"DXlight range:"+test_range+" Eye :"+a
 ; Flip ; currently flipped in LetThereBeLight(l), to make the DepthBuffer visible
 ms=MilliSecs()
 ft=ms-ms2
 ms2=ms
Wend

End
;-----------------------------------------------------------------------







Function LetThereBeLight(l)
 CameraProjMode camera,0
 CameraProjMode PhotonCam,1
 CameraFogMode PhotonCam,1
 CameraFogRange PhotonCam,0,fogrange#
 CameraViewport(PhotonCam,0,0,look_w,look_h)
 CameraZoom PhotonCam,PhotoCamZoom#
 PositionEntity PhotonCam,EntityX(l),EntityY(l),EntityZ(l),1
 RotateEntity PhotonCam,EntityPitch(l),EntityYaw(l),EntityRoll(l),1
 CameraRange PhotonCam,0.01,100
 HideEntity PhotonMesh

 While MoreEntities()
  e=NextEntity()
  If EntityClass$(e)="Mesh"
   EntityFX e,1
   EntityColor e,255,255,255
  EndIf
 Wend

 RenderWorld()

 LockBuffer BackBuffer()
 For y=0 To look_h-1
  For x=0 To look_w-1
   rgb=ReadPixelFast(x,y) And $ffffff
   dist# = ((rgb And $FF0000) Shr 16)+((rgb And $FF00) Shr 8)+((rgb And $FF) )
   dist=767-dist
   If dist&lt;0 Then dist=0
   If dist&gt;767 Then dist=767
   PhotonDepth(x,y)=dist
  Next
 Next
 UnlockBuffer BackBuffer()

 Flip

 For y=0 To look_h-2
  For x=0 To look_w-2
;    If PhotonDepth(x,y) &lt;&gt; PhotonCache(x,y) Then ; this condition worked with shared vertices, but now no more, so update all verts anyway.
     VertexCoords PhotonSurf, PhotonVerts(x,y,0),lookupX#(x,PhotonDepth(x,y)),lookupY#(y,PhotonDepth(x,y)) ,lookupZ#(PhotonDepth(x,y)) ;* 0.9
     VertexCoords PhotonSurf, PhotonVerts(x,y,1),lookupX#(x+1,PhotonDepth(x+1,y)),lookupY#(y,PhotonDepth(x+1,y)) ,lookupZ#(PhotonDepth(x+1,y)) ;* 0.9
     VertexCoords PhotonSurf, PhotonVerts(x,y,2),lookupX#(x+1,PhotonDepth(x+1,y+1)),lookupY#(y+1,PhotonDepth(x+1,y+1)) ,lookupZ#(PhotonDepth(x+1,y+1)) ;* 0.9
     VertexCoords PhotonSurf, PhotonVerts(x,y,3),lookupX#(x,PhotonDepth(x,y+1)),lookupY#(y+1,PhotonDepth(x,y+1)) ,lookupZ#(PhotonDepth(x,y+1)) ;* 0.9
     ;PhotonCache(x,y)=PhotonDepth(x,y) ; this actuallly is needed only by the (inactive) conditional Vertex Update
;    EndIf
  Next
 Next

;Goto nada0 ; hiding in-air-tris, skip it to compare fps

tol#=40.0 ; tolerance in hiding in-air-tris

For y=0 To look_h-2
 For x=0 To look_w-2
  d1=PhotonDepth(x,y)
  d2=PhotonDepth(x+1,y)
  d3=PhotonDepth(x+1,y+1)
  d4=PhotonDepth(x,y+1)
  dmin#=d1
  If d2&lt;dmin Then dmin=d2
  If d3&lt;dmin Then dmin=d3
  If d4&lt;dmin Then dmin=d4

  dmax#=d1
  If d2&gt;dmax Then dmax=d2
  If d3&gt;dmax Then dmax=d3
  If d4&gt;dmax Then dmax=d4
  d#=Abs(dmax-dmin)

  If d&gt;tol# Then
   For ii=0 To 3
    VertexColor PhotonSurf,PhotonVerts(x,y,ii),test_r,test_g,test_b,0.0
   Next
  Else
   For ii=0 To 3
    VertexColor PhotonSurf,PhotonVerts(x,y,ii),test_r,test_g,test_b,1.0 - (Float(PhotonDepth(x,y))/767.0 )
   Next
  EndIf

 Next
Next
.nada0



 CameraProjMode camera,1
 CameraProjMode PhotonCam,0
 ShowEntity PhotonMesh
 PositionEntity PhotonMesh,EntityX(l),EntityY(l),EntityZ(l),1
 RotateEntity PhotonMesh,EntityPitch(l),EntityYaw(l),EntityRoll(l),1

 While MoreEntities()
  ; this is where we set the scene objects back to their original FX etc.
  ; (in this demo the orig settings are not known, there for just zeroing FX)
  e= NextEntity()
  If EntityClass$(e)="Mesh"
   EntityFX e,0
  EndIf
 Wend
 EntityFX PhotonMesh,2 Or 4 Or 8 Or 16
 EntityBlend PhotonMesh,3
 ; unfort a little offset is required, esp with only 256 levels,to reduce stairs/sawtheeth artefacts
 MoveEntity PhotonMesh,0,0,-0.2
 s#=0.95
 ScaleEntity PhotonMesh,s,s,s,1

End Function







Function MoreEntities() ; check if there are more entities (more than the first dummy pivot)!
 RtlMoveMemory2(Cycle_bank,Cycle_CurrentEntityPointer+Cycle_NextEntity,4)
 If PeekInt(Cycle_bank,0)&lt;&gt;0
  Return True
 Else
  Cycle_CurrentEntityPointer=Cycle_FirstEntity
 EndIf
End Function


Function NextEntity()
 Local entity
 RtlMoveMemory2(Cycle_bank,Cycle_CurrentEntityPointer+Cycle_NextEntity,4)
 entity=PeekInt(Cycle_bank,0)
 Cycle_CurrentEntityPointer = entity
 Return entity
End Function


Function EntityExists(entity)
 While MoreEntities()
  If NextEntity()=entity Then Return True
 Wend
End Function

</textarea><br>does expect kernell32.decls with at least this:<br>.lib "kernel32.dll" <br>RtlMoveMemory2%(Destination*,Source,Length) : "RtlMoveMemory"<br><br>It's a projected Towel Mesh. The smart (well, rather a quick hack) bit (IMO) is the determination of xyz, based on fog density/darkness and screen coordinate of a given pixel.<br><br>Yes, it's really ugly, but the projections are right and the system doesn't care at all what is light and what's not. Even shadows on the ceil are done without any special action. It would be pretty easy to use this, if the towel resolultion and hardware power is high enough. 64kVerts limits make it a but rough. Towels could however be assembled with multiple patches. Press W to see the vertex resolution, rather than the fog-Depth-Resolution.<br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> While it's fun to do some experiments, I do not really have the time and skils to develop something good by my own. Some refreshing from-scratch-coding is ok, but I'll concentrate on solutions that can be adopted.<br><br>This page is informative, not too scientific:<br><a href="http://www.devmaster.net/articles/shadows/" target="_blank">http://www.devmaster.net/articles/shadows/</a><br><br>I would tend to Perspective Depth Mapping, with some kind of multisample/softening method.<br><br>But what's really imporant IMO is: we can't just go and add shadows to our game that is running slowly already by the huge amount of Tris, Picks and so on. We can have shadows, yes, but a game must be designed with this significant perfomence hit in mind. In other words, it should run extremly fast without shadows. VIS occlusion, LOD and much more should be the base of it. <br><br></td></tr></table><br>
<a name="1060701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Heh, we really have been looking at the same things...<br><br>The problem with depth mapping is that a lot of cards don't seem to actually store the Z-buffer in an accessible location; as far as I can tell this means that the old DLLs that copied the Z-buffer to the BackBuffer weren't guaranteed to work on a lot of hardware, especially modern hardware. In my own little experiments I wasn't able to get any such thing to happen, no matter what (on the other hand I really don't know what I'm doing with DirectX... try asking Mark or Mikhail instead).<br><br>All current games that have depth mapped shadows implement them with  shaders. Partly this is because the depth information is then available in place, but it's also partly because the per-pixel lighting transformation is a massive operation and is <i>only</i> feasible for real-time use if done in hardware - you can't do it on a loop on the CPU. This means that even if someone finds a way to copy the Z-buffer, you'll still need to farm out the heavy processing to a DLL with access to pixel shaders for any kind of speed (involving a lot of copying images through memory, since you'd need to get it "out" of DX7 and "in" again when done - itself not a very fast way of doing things).<br><br>All told I think the only practical global illumination system for DX7 is stencil shadows. With a bit of prodding there are a few articles floating around that explain how to get soft-shadows out of them. Obviously you'd need to replace the B3D animation system to use with animated characters though.... although this isn't necessarily as hard a task as it sounds. <br><br></td></tr></table><br>
<a name="1060708"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> But stencil shadows are slow too, no? The higher that number of vertices, the more complex shadow volumes will be. Working with a lowres ghost mesh for the volume creation is complicating things (unless your LOD allows it out of the box, so to say) and may be a bit inaccurate.<br><br>Even when the method I just tried seems silly, there is so few math in it, it can be really fast. I may try to fool the fog or something, or to hack the ZBuffer. Could we make a function that is seeking the ZBuffer on a computer, using characteristic depth relationships of a sequence of pixels/numbers?<br><br>Imagine pixelperfect alignement of 10 quads, each one covering a pixel in a sequence, each one with an individual Z-Offset to the camera, eg. the first 10 pixels in the first line of the screen. Each one has a knwon ratio to the first one, as a factor. Now simply search for a sequence of numbers (be it 32,24,16 bit) with the same ratios to oneantother. Shouldn't this work? It might be slow, then again it has to be done only once on a machine. I'd search for it around the backbuffer(), maybe. Maybe I'll try to implement this later tonight... <br><br></td></tr></table><br>
<a name="1060712"></a>

<a name="1060713"></a>

<a name="1060714"></a>

<a name="1060715"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can think of three problems with that right off the bat:<br><br>1) (least important) A golden rule when dealing with memory on a low-level is: <i>never assume</i> that you've "found" something, because it could really be anything. Yeah, I know this one isn't really important... the chances of a random structure imitating your key numbers are very small, and since you only have to do it once, you could easily make it a hundred or a thousand depths for extra safety at no noticeable cost. But it's a valid point of principle.<br><br>2) The depth buffer stores floats of some kind. I don't know offhand how it works, but you might find floating-point accuracy issues make it impossible to get an exact match in this way (as in, the search values you expect to find aren't the same as the depths the Z-buffer computes, even though your maths is correct).<br><br>3) (most important) This idea will only work if the Z-buffer is located in accessible memory, and not hidden somewhere on the GPU. My earlier observation about being unable to copy it indicates this isn't true on all cards, or even most cards. It may simply not be there for you to find!<br><br>The annoying thing is that all of this would be unnecessary, if only Microsoft maintained older versions of DirectX documentation that would actually explain the details for us. As far as I can tell, this is not the case.<br><br>It also doesn't solve the problem of the massive amount of computation for actually rendering the shadowed scene... at the moment, I'm inclined to think that stencils, and the associated speed costs of volume meshes, are still faster than trying to use this method  without a native shader capability.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060883"></a>

<a name="1060884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess you're right about that. Contrary to the XBox where the Zbuffer lies within regular adress space and sweet things like depth of field can be done easily and fast, on the PC there has always been a lack of proper Z-Buffer access, Only some hacks were possible, and they were all diffrent on diffrent hardware and DX versions, see also here:<br><a href="http://aras-p.info/texts/D3D9GPUHacks.html" target="_blank">http://aras-p.info/texts/D3D9GPUHacks.html</a><br><br>Anyway, I was thinking about to find an other solution to the problem. Just for the fun of it, I converted the fog to a custom made fog emulation made of a number of alphaed, black quads. Unfort. I seem to be unable to use more than 256 shades of alpha again (I mean, when I set alpha to less than 0.002 then it will be zero). So, again this 8 Bit limit, grrrr! But at least the alignement is now much better than with System fog 8 Bit - for some mysterious reason.<br><br>So if there's anybody who knows how to display an object alphablended with less then 0.002 opacity, let me know. If I can manage to get more than 256 levels of depth somehow, this would result in useful projected shadows. Currently it is smoothed and everything. Rendered to a srceen overlay quad, 4x sampling, giving me a kind of shadow and gloom at the same time...<br><br>I should get back to the topic, excuse me.<br><br>When I consider all pros and cons of what's best right now for Blitz3D Shadows, then my conclusion is:<br><br>It depends on the kind of game, really. Let's say we want indoor FPS with realistic projection, then Stencil Shadows may be an option, but let's be honest, when you want to do them right (eg. not casting on the backside of receivers etc.) and you want them smooth and fading out in the distance, and two shadows should not add their darkness if they're overlapping, this is all rather resources-binding. Therefor I'd say Sswifts old shadow system is still one of the best solutions around. All you have to do is divide your content budget by 2, use 25k Tris instead of 50, and 7 NPC instead of 14 etc. And yes, implement it in a way that allows to turn it off and use simple blobs instead.<br><br>I still have to see the Blitz3D stencil shadows with the features I just listed. Any links?<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060890"></a>

<a name="1060891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> ...what examples are you thinking of? Because as for the issue of shadows multiplying when overlapping and appearing on the backside of receivers - those are problems with SSwift's system, that don't affect stencils at all! Take a look at Devil's Shadow System for a nice pluggable example.<br><br>I don't think there are any examples of smooth stencil shadows or autofading (you wouldn't use fading anyway most likely, as it's a different approach to it), but these can both be done - the real problem has always been the fact you can't use it with B3D animations.<br><br>Altogether though because of the animation issue I would still agree with you that SSwift-style projective texture shadows (FastExt uses the same method) are the best simple, pluggable solution.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1061108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Would it be conceivable to do something along the lines of PSSM whereby rendering only a range within the precision of an 8-bit buffer for close up shadows and then render again everything beyond that range for another 8-bit resolve? as distant shadows loosing precision isn't such a big issue. <br><br></td></tr></table><br>
<a name="1061248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> This might work. Maybe slow, but it should work. <br><br></td></tr></table><br>
<a name="1061260"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could be an issue tho if you have a large building at a distance that your in the shadow of tho I guess amongst other potential problems. <br><br></td></tr></table><br>
<a name="1061325"></a>

<a name="1061326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I made some further tests. Simple Idea, great effect - in theory:<br><br>I will use VertexColor to color each vertex according to its world coordinate (within a certain, positive range), so xyz becomes rgb. This works nicely. Now the idea: take a render from both, eye and light point of view. The eye render tells us, what point in space can bee seen at all. The light render will tell us which of those the eye can see can also bee seen by the light. Only these points are considered "lit and relevant to the eye". They are then painted to a texture that can be used as screen overlay, or as perspective mapping. The point is, all the visibility checks, even the obscuring by geometry checks, are done by this ICU method with a rgb color space.<br><br>I then use a reverse lookup table in space, that's fast, but it requires 16 MB of ram, and I haven't got an idea how this could be solved with a higher preceision like 48 Bit colors onscreen, if we once had such RGB values onscreen.<br><br>There's a further problem with all these rendered zbuffer and color space substitutes: they are a little bit different on all graphics cards. They are dithered and the result will look different on various machines.<br><br>Additionally, the artefacts, as described in the code, are hard to fight. It might be an ideal way of shadow mapping if the sampling resolution would be high enough. But rendering and reading buffers in Blitz is limited to thumps, what is needed is a 1:1 screen resolution render for the color space info. With Pixelshaders this might be an option.<br><br>Anyway, here's the code:<br>to see it in plain vanilla ICU mode use these settings:<br><br>Global look_w=128<br>Global look_h=96 <br>Global icu2rel=1<br>Global sshr=0<br>Global blurmode=0<br><br>it runs pretty fast this way, but most of the points are missed due to low sampling rate etc, as you'll see.<br><br><br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Experimantal Shadow Technic: determine visibility by 2 ICU colormaps. VertexColor
; is used to encode 8 Bit 3D coordinates in each rendered pixel.
; all colors that are visible from within both renders  (eye +light perspectives)
; will be lit point in space.

; Heavy rounding error artefacts and sampling problems due to low resolution.

; hit space to see the color space renders etc.

; Note: since it is using Vertices, it may not work with animated B3D again! grrr!

; NOTE: userlibs required!  In kernel32.decls you need this:


;.lib "kernel32.dll" 
;RtlMoveMemory2%(Destination*,Source,Length) : "RtlMoveMemory"


;of course without semicolons




Graphics3D 800,600,32,2

SetBuffer BackBuffer()
WBuffer 1


AmbientLight 20,20,20


Global demo_mode
Global wire

Global nshades#=768
Global fogrange#=20.0 ; this will also be the max range of the projected light!
Global f_divider#=256.0/fogrange#

Global PhotoCamZoom#=1.0

Global look_w=128 ;512 ;128;256 ; texturemap width (attention: max=graphicswidth/icu2rel !) Note: needs to be in 4:3 ratio with look_h ! Needs to be power of 2, eg 64,128,256...
Global look_h=96  ;384 ;96 ;192
Global icu2rel=2 ;oversampling (1 to 4): render from light view will be N times bigger for higher precision (eg look_w=256 and icu2rel=2, render will be 512x384)
Global sshr=2; (0,1,2,3) additional bitshift oversampling (shr N)
Global blurmode=1 ;(0/1) initially define if blur by multi quad overlay (slow)
blur#=0.014


Dim icu1#(look_w,look_h,2)
Dim icu2#(look_w,look_h,2)
Dim PhotonCache(look_w,look_h)
Global RGB_2_XYZ=CreateBank(256*256*256)

;create screen overlay quad
Global ol_quad=CreateMesh()
surf=CreateSurface(ol_quad)
v0=AddVertex(surf,-1,-1,0)
VertexTexCoords(surf,v0,0,   1   ,0 ,0)
v1=AddVertex(surf, 1,-1,0)
VertexTexCoords(surf,v1,1   ,1   ,0 ,0)
v2=AddVertex(surf, 1, 1,0)
VertexTexCoords(surf,v2,1   ,0   ,0 ,0)
v3=AddVertex(surf,-1, 1,0)
VertexTexCoords(surf,v3,0   ,0   ,0 ,0)

tr=AddTriangle(surf,v0,v1,v2)
tr=AddTriangle(surf,v0,v2,v3)

Global ol_quadtex=CreateTexture(look_w,look_w,0)
Global ol_quadtex_yo=Floor(look_w-look_h)/2.0
TextureBlend ol_quadtex,2
EntityFX ol_quad,17
EntityBlend ol_quad,1  ;3;3
EntityTexture ol_quad,ol_quadtex,0,0

q_al#=0.1 ; alpha of shadow overlay
If blurmode=0 Then Goto noblur
q_al#=0.01

TranslateEntity ol_quad,-blur#,-blur#,0
EntityAlpha ol_quad,q_al#

q2=CopyEntity(ol_quad,ol_quad)
TranslateEntity q2,blur*2.0,0,0

q3=CopyEntity(ol_quad,ol_quad)
TranslateEntity q3,blur*2.0,blur*2.0,0

q4=CopyEntity(ol_quad,ol_quad)
TranslateEntity q4,0,blur*2.0,0

EntityAlpha q2,q_al#
EntityAlpha q3,q_al#
EntityAlpha q4,q_al#

.noblur


EntityAlpha ol_quad,q_al#

HideEntity ol_quad





; simple scene...
Global camera=CreateCamera()
CameraRange camera,0.5,100
EntityParent ol_quad,camera
TranslateEntity ol_quad,0,0,1.0
Global scene_center=CreatePivot()
maincam_targetpiv=CreatePivot()


light=CreateLight(3) ; position and angle of this light will be used for the light mesh projection
test_range#=16.7
LightRange light,test_range# ; actually this may be very low, we don't want it to enlight things in the shade
PositionEntity light,0,-2,7 ; note, this important position for the system
PointEntity light,scene_center

Global light_cube=CreateCone(12,1,light)
RotateMesh light_cube,-90,0,0
ScaleEntity light_cube,0.2,0.2,0.1
EntityFX light_cube,1
;EntityAlpha light_cube,0.3
EntityColor light_cube,255,255,0



Global PhotonCamPiv=CreatePivot()
Global PhotonCam=CreateCamera(PhotonCamPiv)
CameraProjMode PhotonCam,0
Global helper=CreatePivot()


; simple test textures
Global walltex=CreateTexture(256,256)
Color 120,120,80
Rect 0,0,256,256,1
For i=0 To 20000
 r=Rand(10,40)
 Color 120+r,120+r,80+r
 rx=Rand(256)
 ry=Rand(256)
 Plot rx,ry

 r=-r
 If ry0 Then r=0
 Color 120+r,120+r,80+r
 Plot rx,ry-1
 Plot rx-1,ry-1
 Plot rx+1,ry-1
Next

For j=0 To 255 Step 32
 For i=0 To 300 Step 64
  jo=-(Floor(j/32) And 1)*32
  Color 40,40,20
  Rect jo+i,j+1,63,31,0
  Color 180,180,150
  Rect jo+i+1,j,63,31,0
 Next
Next

CopyRect 0,0,256,256,0,0,BackBuffer(),TextureBuffer(walltex)

Global white =CreateTexture(16,16)
Color 255,255,255
Rect 0,0,16,16,1
CopyRect 0,0,16,16,0,0,BackBuffer(),TextureBuffer(white)



CameraProjMode camera,1
CameraProjMode PhotonCam,0


; world design...
; init entity iteration------------------------
Global Cycle_bank=CreateBank(16)
Const  Cycle_NextEntity=4
Const  Cycle_LastEntity=8
Global Cycle_FirstEntity=CreatePivot()
Global Cycle_CurrentEntityPointer=Cycle_FirstEntity
;----------------------------------------------------

; from here on, created entities can be parsed with MoreEntities function.
dis#=10
For i=0 To 30
 c=CreateCube()
 PositionEntity c,Rnd(-10,10),Rnd(-6,-4),Rnd(-10,10)
 RotateEntity c,0,Rand(360),0
 ScaleEntity c,3,1,3
 EntityPickMode c,2
 EntityTexture c,walltex
Next

w1=CreateCube() ;walls
ScaleEntity w1,10,10,1
TranslateEntity w1,0,0,10
EntityTexture w1,walltex

w2=CreateCube()
ScaleEntity w2,10,10,1
TranslateEntity w2,0,0,-10
EntityTexture w2,walltex

w3=CreateCube()
ScaleEntity w3,1,10,10
TranslateEntity w3,10,0,0
EntityTexture w3,walltex

w4=CreateCube()
ScaleEntity w4,1,10,10
TranslateEntity w4,-10,0,0
EntityTexture w4,walltex

w5=CreateCube() ; ceil
ScaleEntity w5,10,1,10
TranslateEntity w5,0,10,0
EntityTexture w5,walltex

col=CreateCylinder()
ScaleEntity col,0.5,10,0.5
TranslateEntity col,-5,0,-5
EntityTexture col,walltex

col=CreateCylinder()
ScaleEntity col,0.5,10,0.5
TranslateEntity col,0,0,-5
EntityTexture col,walltex


npc=CreateSphere(20)
EntityTexture npc,walltex
ScaleEntity npc,2,5,2


EntityFX npc,1

npc_x#=-5



Global Cycle_EndMarker=CreatePivot()




Type e_vert
Field x#
Field y#
Field z#
Field depth#
Field ent
Field sur
Field ind
Field red#
Field green#
Field blue#
Field alpha#
End Type



Type rem_mat
 Field index
End Type






ft=MilliSecs()
MoveMouse GraphicsWidth()/1.8,GraphicsHeight()/2.0

Color 255,0,0
a#=50 
While KeyHit(1)=0 ; MMMMMMMMMMMMMMMMMMMMMMMMMMMMM MAINLOOP MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 npc_x#=npc_x+.1
 If npc_x&gt;12 Then npc_x=-12
 PositionEntity npc,npc_x,0,0
 TurnEntity npc,1,2,3
 If KeyDown(200)
  test_range#=test_range#*1.1
  If test_range#&gt;20 Then test_range#=20
  LightRange light, test_range#
 EndIf
 If KeyDown(208)
  test_range#=test_range#*0.9
  If test_range#&lt;0.1 Then test_range#=0.1
  LightRange light, test_range#
 EndIf

;  a#=a#+2
 If KeyDown(203)
  a#=a#+2
 EndIf
 If KeyDown(205)
  a#=a#-2
 EndIf
 If KeyHit(17) Then 
  wire =wire Xor 1
  If wire=0 Then WireFrame 0
 EndIf
 If KeyHit(57) Then
  demo_mode=demo_mode+1
  If demo_mode&gt;3 Then demo_mode=0
 EndIf
; PositionEntity light,( (GraphicsWidth()/2)-MouseX() )/40.0,((GraphicsHeight()/2)-MouseY())/40.0,7 ; note, this important position for the system
 PositionEntity light, Sin( ((GraphicsWidth()/2)-MouseX())/2 )*7.5, ((GraphicsHeight()/2)-MouseY())/40.0, Cos(((GraphicsWidth()/2)-MouseX())/2 )*7.5 ; note, this important position for the system
 PointEntity light,scene_center
 If a#&gt;359 Then a#=0
 If a#&lt;0 Then a#=359
 PositionEntity camera,Sin(a#)*dis,0,Cos(a#)*dis
 PointEntity camera,maincam_targetpiv

 UpdateWorld()
 LetThereBeLight(light)

 If wire&lt;&gt;0 Then Wireframe 1
 RenderWorld()
 If wire&lt;&gt;0 Then WireFrame 0


 Color 255,0,0
 Text 250,0,"Tris:"+TrisRendered()
 Text 150,0,"FPS:"+1000/ft
 Text 350,0,"left,right, up, down,w,space,mouse"
 Text 150,16,"DXlight range:"+test_range+" Eye :"+a
 If demo_mode=0 Then Flip 0; to hide the color space maps
 ms=MilliSecs()
 ft=ms-ms2
 ms2=ms
Wend

End
;-----------------------------------------------------------------------










Function LetThereBeLight(l)

;erase some arrays
 For y=0 To look_h-1
  For x=0 To look_w-1
    PhotonCache(x,y)=0
  Next
 Next

 HideEntity light_cube
 CameraProjMode camera,0
 CameraProjMode PhotonCam,1
 CameraFogMode PhotonCam,0
 CameraFogRange PhotonCam,0,fogrange#*2.0
 CameraViewport(PhotonCam,0,0,look_w,look_h)
 CameraZoom PhotonCam,PhotoCamZoom#
 PositionEntity PhotonCam,EntityX(camera,1),EntityY(camera,1),EntityZ(camera,1),1
 RotateEntity PhotonCam,EntityPitch(camera,1),EntityYaw(camera,1),EntityRoll(camera,1),1
 CameraRange PhotonCam,0.01,100
 HideEntity ol_quad


; coloring world (RGB-encode vertices locations)
 While MoreEntities()
  e=NextEntity()
  If EntityClass$(e)="Mesh"
   For su=1 To CountSurfaces(e)
    surf=GetSurface(e,su)
    For v=0 To CountVertices(surf)-1
     enti.e_vert = New e_vert
        enti\ent=e
        enti\sur=surf
        enti\ind=v
        enti\red#=VertexRed(surf,v)
        enti\green#=VertexGreen(surf,v)
        enti\blue#=VertexBlue(surf,v)
        enti\alpha#=VertexAlpha#(surf,v)

       TFormPoint VertexX(surf,v),VertexY(surf,v),VertexZ(surf,v),e,0
       dis__x#=TFormedX()+10.0
       dis__y#=TFormedY()+10.0
       dis__z#=TFormedZ()+10.0

       bri__x#=255.0-(255.0 / fogrange#) * dis__x#
       If bri__x#&lt;0 Then bri__x#=0
       If bri__x#&gt;255 Then bri__x#=255

       bri__y#=255.0-(255.0 / fogrange#) * dis__y#
       If bri__y#&lt;0 Then bri__y#=0
       If bri__y#&gt;255 Then bri__y#=255

       bri__z#=255.0-(255.0 / fogrange#) * dis__z#
       If bri__z#&lt;0 Then bri__z#=0
       If bri__z#&gt;255 Then bri__z#=255
       VertexColor surf, v, bri__x#, bri__y#, bri__z#,1.0 
    Next
   Next

   EntityFX e,2 Or 1;4
   EntityColor e,255,255,255
   EntityTexture e,white
  EndIf
 Wend


; render color space from player perspective
 RenderWorld()

 LockBuffer BackBuffer()
 For y=0 To look_h-1
  For x=0 To look_w-1
   rgb=ReadPixelFast(x,y) And $ffffff
   ; store texel world coords (rgb encoded)
   icu1#(x,y,0)=(255-(rgb And $FF0000) Shr 16) 
   icu1#(x,y,1)=(255-(rgb And $FF00) Shr 8) 
   icu1#(x,y,2)=(255-rgb And $FF) ;/f_divider#
  Next
 Next
 UnlockBuffer BackBuffer()

 If demo_mode=1 Then  Flip 0 ; too see color space from eye



;render color space from lights point of view

 PositionEntity PhotonCam,EntityX(l),EntityY(l),EntityZ(l),1
 RotateEntity PhotonCam,EntityPitch(l),EntityYaw(l),EntityRoll(l),1
 CameraViewport(PhotonCam,0,0,look_w*icu2rel,look_h*icu2rel) ; allow higher precision

 RenderWorld()

 LockBuffer BackBuffer()
 For y=0 To look_h*icu2rel-1
  For x=0 To look_w*icu2rel-1
   x2=x/icu2rel
   y2=y/icu2rel
   rgb=ReadPixelFast(x,y) And $ffffff
   icu2#(x2,y2,0)=(255-(rgb And $FF0000) Shr 16) 
   icu2#(x2,y2,1)=(255-(rgb And $FF00) Shr 8) 
   icu2#(x2,y2,2)=(255-rgb And $FF) 
   ; store flag in rgb encoded array index (reverse lookup table), and allow oversampling by bitshifting
    rr.rem_mat = New rem_mat ; will have to erase this matrix point later, so store its bank index
    rr\index=((icu2#(x2,y2,0)Shr sshr)Shl 16)Or((icu2#(x2,y2,1)Shr sshr)Shl 8)Or((icu2#(x2,y2,2)Shr sshr))
    PokeByte RGB_2_XYZ,rr\index ,1
  Next
 Next
 UnlockBuffer BackBuffer()


 CameraViewport(PhotonCam,0,0,look_w,look_h) 
 PositionEntity PhotonCam,EntityX(camera,1),EntityY(camera,1),EntityZ(camera,1),1
 RotateEntity PhotonCam,EntityPitch(camera,1),EntityYaw(camera,1),EntityRoll(camera,1),1

; The following is calculating the visability of each shadow overlay texel
; set a shadow texels only if it was seen on both color space renders (point that can be seen from the eye and from the light as well)

 For y=0 To look_h-1
  For x=0 To look_w-1
   p=PeekByte( RGB_2_XYZ, ((icu1#(x,y,0)Shr sshr)Shl 16)+((icu1#(x,y,1)Shr sshr)Shl 8)+((icu1#(x,y,2)Shr sshr))  )
   If p=1
    CameraProject PhotonCam, icu1#(x,y,0)/f_divider#-10.0,icu1#(x,y,1)/f_divider#-10.0,icu1#(x,y,2)/f_divider# -10.0
    xx=ProjectedX#()
    yy=ProjectedY#()
    If (xx&gt;=0) And (yy&gt;=0) And (xx&lt;look_w) And (yy&lt;look_h) Then
     PhotonCache(xx,yy)=1 ; will later write this pixel
    EndIf
   EndIf
  Next
 Next



; clean up matrix changes
 For rr.rem_mat = Each rem_mat
  PokeByte RGB_2_XYZ,rr\index,0
 Next
 For rr.rem_mat = Each rem_mat
  Delete rr
 Next




;; artefacts filter attempt....fill single isolated shadow texels
; For y=1 To look_h-2
;  For x=1 To look_w-2
;   If (PhotonCache(x,y)=0) And (PhotonCache(x-1,y)=1) And (PhotonCache(x,y-1)=1) And (PhotonCache(x+1,y)=1) And (PhotonCache(x,y+1)=1) Then
;    PhotonCache(x,y)=1
;   EndIf
;  Next
; Next


If demo_mode=2 Then Flip 0; to see color space from light



; finally write the texels to the screen
 Color 0,0,0
 Rect 0,0,look_w,look_h,1

 LockBuffer()
 For y=0 To look_h-1
  For x=0 To look_w-1
   If PhotonCache(x,y)&lt;&gt;0 Then
    WritePixelFast x,y,$ffffff
   EndIf
  Next
 Next
 UnlockBuffer()
 CopyRect 0,0,look_w,look_h,0,ol_quadtex_yo,BackBuffer(), TextureBuffer(ol_quadtex)



 For enti.e_vert = Each e_vert ; restore original vertex colors of scene
     VertexColor enti\sur,enti\ind,enti\red#,enti\green#,enti\blue#,enti\alpha#
 Next
 For enti.e_vert = Each e_vert ; free types
    Delete enti
 Next

;


If demo_mode=3 Then Flip 0; to see shadow mapping

 While MoreEntities()
  ; this is where we set the scene objects back to their original state, FX etc. wise.
  ; (in this demo the orig settings are not known, there for just zeroing FX)
  e= NextEntity()
  If EntityClass$(e)="Mesh"
   EntityFX e,0
   EntityColor e,255,255,255
   EntityTexture e,walltex
  EndIf
 Wend

 CameraProjMode camera,1
 CameraProjMode PhotonCam,0
 ShowEntity ol_quad
 ShowEntity light_cube

End Function




; NOTE: userlibs required!  In kernel32.decls you need this:


;.lib "kernel32.dll" 
;RtlMoveMemory2%(Destination*,Source,Length) : "RtlMoveMemory"


;of course without semicolons






Function MoreEntities() ; iterate all world content entities
 RtlMoveMemory2(Cycle_bank,Cycle_CurrentEntityPointer+Cycle_NextEntity,4)
 If PeekInt(Cycle_bank,0)&lt;&gt;Cycle_EndMarker
  Return True
 Else
  Cycle_CurrentEntityPointer=Cycle_FirstEntity
 EndIf
End Function


Function NextEntity()
 Local entity
 RtlMoveMemory2(Cycle_bank,Cycle_CurrentEntityPointer+Cycle_NextEntity,4)
 entity=PeekInt(Cycle_bank,0)
 Cycle_CurrentEntityPointer = entity
 Return entity
End Function


Function EntityExists(entity)
 While MoreEntities()
  If NextEntity()=entity Then Return True
 Wend
End Function

</textarea><br><br><br>So, as a new conclusion here's my question: Is there any way to use Pixelshaders with Blitz3D ?<br><br>Thanks.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1061359"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Beautiful! Absolutely magnificent! Codearc this for posterity! That really is a wonderful effect, even with the artifacts.<br><br><div class="quote"> Is there any way to use Pixelshaders with Blitz3D ? <br></div><br><br>...no.<br><br>At least, not without copying a buffer into memory (....sigh... once again not helping much with the Z-buffer) and over to a DLL written for DX8+/OpenGL, and copying it back again when done. While this does have the potential to be hepful for some postprocessing techniques, I doubt this is one of them.<br><br>The other option would be to go over to SoftPixelEngine and pretend as though Blitz3D has always supported DX9 and OpenGL (i.e. total 3D engine replacement). Best shot from a practical point of view, but it does feel like a bit of a cop-out from the challenge angle. <br><br></td></tr></table><br>
<a name="1061372"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you. :)  Replacement of the 3D engine is ok IMO. I was waiting a long time for a DX9isation of Blitz3D, then waited for MAX3D before I'd buy BMAX, but honestly, Blitz3D offered so much and there was so few missing, it wasn't completely unbearable. But now I guess it's about time to use the hardware to its limits. That also means access to Shaders. While I love BASIC languages, ASM that is used with shaders is also fascinating. <br><br>I couldn't run SoftPixelEngine. I am browsing  Devmaster.net and there's a huge amount of engines out there, it's almost a pain to read about all of them. There are however a few candidates. But since this thread was opened by Rob and he is "just back", I am sure he wants to know how to do shaows in Blitz3D.<br><br>It would however be a good idea to have a (sticky?) thread to discuss kind of how-to DX9ize your Blitz3D, including ports and engine replacements. <br><br></td></tr></table><br>
<a name="1061440"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats a really nice effort. <br><br></td></tr></table><br>
<a name="1061589"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can say with certainty that a good shade can be done in Blitz3D, but requires more than the programmer, and lack of knowledge as is mine greatly appreciate Fastext.<br><br><br><img src="http://s3.subirimagenes.com/otros/5613945palmera.jpg"> <br><br></td></tr></table><br>
<a name="1061641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Indeed, the fastext shadow system may be one of the best full systems for Blitz.<br><br>Some more infos: I tested Freebasic and its Wrapper for Irrlicht. My old card doesn't support OpenGL 1.4 so most of the advanced examples didn't work, but the non-shader stencil shadows were extremly slow, pretty much useless that way. <br><br></td></tr></table><br>
<a name="1062731"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yasha - I just revisited the SHADOWS demo of Kalisme, from the link given by you.<br><br>When I first tried it, it was flickering and so on, but then I spent some time and modded it to do a lot of things, and more and more I thought what a bril coder kalimse is. Since the ortho cam mode is kind of broken on my machine, I first modded it to use a standard cam. Camerazoom 100, then move 100 units away, range 100 to 200, that's almost like the real ortho cam. Then I added support for multiple lights. I thought It doesn't make sense to have more than 3 active lights (cpu load), so I wrote a system that activates the 3 closest lights. I added fading by distance and now it looks really nice when you move your TPS npc around in the scene full of lights. Adding support for animated NPCs was a bit confusing since HideEntity does reset the animation, but the caster clones must be hidden, so I am using SetAnimTime, this works, excluding for transitions.<br><br>I've added a Tris load (high detail flipped sphere) with two texture layers, and it still used to run pretty fast.<br><br>Then I modded it to use a simple map mesh, made with maplet, with about 40kVerts and 15kTris. I had to mod the code so it will work with multisurface meshes. The implementation was rather easy, just it didn't work :/, but not only were the projections wrong and shadows missing or misplayed, it was also extremly slow. When  I used the simple 1 surface flat, flipped sphere that actually has more Tris than the level map, it was running smoothly, relative fast. <br><br>Why is it such a diffrence to parse 13 surfaces with 15kTris, compared to 1 surface<br>with maybe 40kTris? <br><br></td></tr></table><br>
<a name="1062736"></a>

<a name="1062742"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Who's Kalisme? (very confused... I only linked to my own shadow system..?)<br><br>(EDIT: Ah, I see he made a similar thing a while back)<br><br>Anyway surfaces represent each "block" of verts and polygons to be uploaded to the video card. 13 surfaces mean 13 uploads with associated open, copy, close of streams; one surface means only one upload. Modern computers are insanely fast at crunching polygons so the number of surfaces is usually a far bigger bottleneck, even when the number of verts and polys is lower.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1062777"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops, I confused things again. I think they call it Alz..ehrm..thingie :). So this was by you? Hats off, you've got my respect, that's some really nice code and it was a great pleasure to mod it. Just sent you a mail. <br><br></td></tr></table><br>
<a name="1062840"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uh, I've got one more question: does that mean when I check vertexX etc. of the vertices of a surface, open, copy, close of streams is forced each time I get these informations? I though these things are done only when something is changed, or with renderworld() no? <br><br></td></tr></table><br>
<a name="1062844"></a>

<a name="1062847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> <strike>(Sorry I haven't responded to the email yet... haven't had time to analyse the problem - the shadow code is quite old)</strike> Replied.<br><br>No, it doesn't. Vertex information is taken from the reference copies of the meshes in the Blitz3D engine, which is entirely CPU/memory. These are uploaded to the GPU every time RenderWorld is called. For the same reason, changing a vertex property with VertexCoords, VertexTexCoords etc. should have no noticeable cost by itself (O(1) access time). This incidentally is also why you can't get vertex positions after bone deformation: the vertex position is calculated every frame <i>in the same step</i> as being passed to DirectX.<br><br>The other time things are changed are if you use the Blitz collision system; changing a vertex position will mark that the collision mesh needs to be updated, although it won't actually happen until the next time you use a Pick or UpdateWorld (which is why people recommend doing all your mesh stuff at once, then doing all your picks at once).<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1062848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks a lot for these informations. I've just seen, when the map mesh is loaded then (tho the map has only about 15 kTris) the shadow system seems to create up to 120k  additional Tris, so I think there must be something wrong. Of crouse, these dynamicly created shadow entity triangles must be uploaded for each render. So, no surprise it's so slow (besides projection doesn't work right). BTW I removed the cellshading part and most of the remed lines, so now it's really compact, even more than the original.<br><br>In reality the number of triangles per shadow should not be higher than about a dozen or two or so, as long as the receiver isn't a hi detail surface, like a shpere or so.<br><br>So when I got 3 Casters in the scene, there shouldn't be 120 kTris for shadows. Therefor I am optimistic that the system could be rather effective. Currently there seem to be a lot of Triangles that are way further away from the light than the light range is set to, this seems to be unnecessary. So a per-triangle-distance check should be added.<br><br>I also wonder if there are problems with ceils etc. in a building that has multiple floors. Will this project the shadow not only to the floor and maybe the ceil, but to all floors and all ceils? And if so, could this be turned off somehow? <br><br></td></tr></table><br>
<a name="1062854"></a>

<a name="1062855"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep FastExt is awesome.  I seldom buy user-made addons but FastExt is a no-brainer.  If you use Blitz3D these days, it's an absolute must.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063287"></a>

<a name="1063288"></a>

<a name="1063289"></a>

<a name="1063291"></a>

<a name="1063292"></a>

<a name="1063293"></a>

<a name="1063294"></a>

<a name="1063318"></a>

<a name="1063330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bare with me as this isn't a topic I'm familiar with in any detail and what I'm suggesting may be mind numbling obvious and used all the time or even not feasible - hopefully its not exactly the method your doing above.<br><br>Wouldn't it be possible for single surface meshes, especially for object self shadowing, to generate realtime dynamic lightmaps by unwrapping the polygons to a (mipmap disabled) lightmap texture, assigning each value in the lightmap texture a unique color based on its x,y coords then rendering the object from the lights point of view, rebuilding the lightmap based on walking the render buffer using the unique rgb values to work out the x,y positions that can be seen in the light camera view and setting those as lit? this means you can vary the lightmap texture size and light camera viewpoint resolutions for speed without compromising too much on precision.<br><br>This also lets you render other objects in the scene with their entity color set to black to occlude pixels that would otherwise be lit and do extra lighting.<br><br>EDIT: Guess on objects too far from the light this might have issues with the precision of rendering from the light point of view. The more I think about it I guess the more limited it is tho it might have potential with blitz for certain things depending on how fast you can read the render buffer color values.<br><br>EDIT2: Tho even if its possible to get someting working IIRC readpixelfast is quite slow on windows 7 compared to XP :(<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063396"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> It definitely has advantages to use a color texture instead of vertex colors, but there's one thing that I don't seem to understand: if you encode X/Y only, and not Z, wouldn't that mean the camera must be static? Or do you mean the information of what lightmap texel color code represents what screen XY coordinate is updated dynamilcy? Or maybe you meant the texels that can be seen on the lights render will be painted white (or be incremented in a multi light environment), anything else black (on a parallel "real" lightmap). This would surely work, but it may be very slow. You'd best draw to the backbuffer, then copyrect. Or maybe to a imagebuffer, not shure what's faster, well, trying is easy. It would however be a very fast Lightmapper. There's only one problem, it's the same with all these render tricks: because the light render may be taken from a completely diffrent angle than the players eye render, some pixels that are distant to the eye may be close to the light, resuliting in moire artefacts. There may be ways to reduce these artefacts. eg. when there are two pixels of color B and D, and the eye wants to know if the light can see color C, then the light may say "I can see B and D, so yes, it's likely that I would also see C, if they were not that far away". <br><br></td></tr></table><br>
<a name="1063405"></a>

<a name="1063406"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its similiar to a lightmapper but a bit more limited.<br><br>Not really sure how to explain it concisely.<br><br>Like a lightmapper you unwrap the geometry you want shadowed and give each polygon its own space in a large "lightmap" texture.<br><br>You also need 2 textures, one will be cleared with the ambient light color and used to render the lightmap in the final render stage, the other has each pixel assigned to a color computed from that pixel's x/y coordinate in the texture. With 24 bit color this gives us plenty of unique colors to play with. This texture should also have mipmaps disabled to ensure as much precision as possible.<br><br>Render the geometry you want shadowed from the light view point with only the multicolored texture stage and not its usual diffuse, etc. stages, fog disabled and fullbright enabled to again ensure precision of the color data.<br><br>Walk through each pixel in the light view point buffer, decode the x/y coordinates from the color picked, set this x/y position in the final lightmap texture to white as a lit pixel, this automatically leaves occluded pixels in shadow.<br><br>Render the scene again as normal with the lightmap and diffuse textures.<br><br>This would give realtime lightmapping of quake 3 kinda quality obviously not ideal and has some distance precision issues but most point lights in normal useage have a low enough light radius that it won't be an issue and for directional lights i.e. sunlight you can render from a phantom position nearer the player so that the shadows around the player are high quality. (tho you'd also need some tricks to make sure distant pixels weren't all dark).<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063440"></a>

<a name="1063492"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anti-aliasing might screw this up a bit if the user forces it on but probably something that can be worked around.<br><br>Think I should be able to have a rough version of this coded in a day or so, some of its a little beyond my present experience tho.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063542"></a>

<a name="1063543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was also thinking about it. Your description is exactly what I thought. There are several points I got to mention, since all the depth buffer emulation tricks I tried recently do have the same problem: the precision of the system is dynamic and depends on the angle between user camera and light camera. If these angles are similar, the result is good. But if for exampe the light is in 180 deg. opposite to the player cam, then there will be massive sampling artefacts, resulting in almost useless data. B: the colors on the screen are not really as you tell them to be, they are dithered, resulting in slight inaccuracies, probably even patterns.<br><br>But let us assume it's possible to solve these problems somehow, then there is one thing you must keep in mind: This system allows lights, they may be dynamic. A dynamic lightmap is created, that's factastic. You don't need a single-surface Mesh, it may contain many surfaces, but they all need the lightmap texture and UV Set on the second texture layer. The only problem is: All entities must use the same lightmap. It may or may not be tricky to have NPCs useing the same lightmap as the Level Map.<br><br>Besides NPCs, this is really a simple thing if you let a Lightmapper UVmap your Map mesh for you, not really a need for UV-mapping in the code, just take something pre-wrapped, vertexcolor and dynamic texel size turned off etc.<br><br>Coloring the texels could be something like this:<br><br>rgb= (x shl 12) or y<br><br>and to read it:<br><br>x= (rgb shr 12)<br>y=rgb and %111111111111<br><br>then simply color every pixel in the texture, it doesn'T matter if it wil be in use or not. 12 Bit allow pixel adresses of 0 to 4095. (Tho, copyrect a 4096 texture may be a little slow :) probably try one of those 256ers, friendly offered by Maplet, first)<br><br>But as noted, inaccuracies with dithering or as you said antialiasing may cause problems, even overflows from Y to X... Turning off mipmapping is neccessary, but it also demonstrates the core problem: distant objects will show only a few of the colors that are actually on their surface.<br><br>Please don't take this for negative nay-saying. I see a very high potential in the idea. Just let's fix those problems somehow, especially the sampling rate problems.<br><br>How about this: let's say there are two colors recognized, 2 Pixels side by side, and they have a certain (rather small) color distance that suggests that it is not a geometry contour, but only a distant object , then those hypotetic colors between them may be considered "found" as well - something like that maybe.<br><br>PixelShaders would really be great for something like that.  There you could simply copy the color to the adress and brigthen the texel on the target lightmap texture. No copybuffer, no readpixelfast etc., the whole thing within the gpu.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah similiar to my thinking, only a couple of issues I hadn't thought of yet heh.<br><br>I've got as far as generating the unique color texture, unwrapping any provided geometry and assigning the tris positions on the texture - having some issues with optimal layout of the triangles as so far its not very efficent leaving massive gaps - even so a 2048x2048 texture should be ample for your average sized indoor level with reasonable shadow resolution.<br><br>Aside from working around color precision I think I've got my head around the other stuff.<br><br>Not sure if I can make anything useful of this or not but gonna have a go. <br><br></td></tr></table><br>
<a name="1063556"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>But as noted, inaccuracies with dithering or as you said antialiasing may cause problems, ..... distant objects will show only a few of the colors that are actually on their surface.<br> <br></div><br>Sorry if I've grossly misunderstood something here, but, isn't that the 'point' of antialising and such? there's no way an object with n pixels could ever be rendered at a distance with the same 'clarity' because, obviously, there'd be less pixels for the distant rendering...<br><br>I'm not trying to be a smartass or anything, I'm sure you're referring to something much more 'complex', I just read that and thought "hang on a minute!" :D <br><br></td></tr></table><br>
<a name="1063638"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah thats the point of anti-aliasing - but it causes issues with doing shadows this way in that you are trying to fill your objects texels so each pixel in the light's viewpoint has a unique color that can be used to mark a certain point as lit or not, anti-aliasing will induce extra color values into the viewpoint that might correspond with a point thats actually occluded from the light's viewpoint and hence allow light on areas that are actually in shadow. However with the way I'm doing it I think it will 90+% of the time merely give a slight softshadowing effect in places without being so inaccurate that its noticeable its wrong.<br><br>With objects at a long distance from the camera view not all pixels will show unless you render very very high resolution, so adjacent pixels might be blended or not even show up, causing mottled shadows where there should be none, etc. however my contention here is that point lights are usually used with a low enough radius for it not to matter and if its possible to get this working people using it would just have to be more careful with their light placement/useage. For directional lights i.e. sunlight we can use tricks to position the light "source" nearer the player to ensure higher accuracy shadows around the player position. Large terrain gets complicated as you'd have to drop down to 1 sample size for quite a large area if you used just 1 global lightmap, however it would be possible to use a quadtree type approach and sub-divide the terrain into smaller sections and only use the shadow technique on the nearest sections and either use a low resolution or static map on the further away terrain. <br><br></td></tr></table><br>
<a name="1063683"></a>

<a name="1063692"></a>

<a name="1063693"></a>

<a name="1063769"></a>

<a name="1063783"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> EDIT: Seems like the built in bi-linear filtering is killing this :( thought I had a work around but so far don't seem to be getting great results from the pixels read from the light camera view.<br><br>Not sure my color encoding/decoding is working properly either will have to test that too.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063923"></a>

<a name="1063930"></a>

<a name="1063932"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe try to turn off dithering in the card settings. Then again, it should work with most default settings to make sense at all.<br><br>The mottled shadows you mentioned: Of course, it would be fast to simply take the found colors, translate it to lightmap texel coords and write the light right into the lightmap. But the true bottleneck is the Readpixelfast action, We can easily do a little bit more math with the data, once read from the light camera render. For this purpose the render should be copied to an array in the first place, using readpixelfast.<br>In the array you can parse the data scanline for scanline.  EG:<br>x1=rgb(x,y) shr 12<br>y1=rgb(x,y) and %111111111111<br>x2=rgb(x+1,y) shr 12<br><br>if abs(x2-x1)&lt;10 then ; I think this would require 10 pixel gaps between the tris on the lightmap to work correctly, and it may still miss some pixels, depending on the distance.<br> for xx=x1 to x2-1 ; filling the missed colors<br>  lightmap(xx,y1)=1<br> next<br>endif<br><br>tho, practicly the for loop may also have to use a negative step value.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1063936"></a>

<a name="1063938"></a>

<a name="1063939"></a>

<a name="1063940"></a>

<a name="1063941"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> yeah readpixelfast straight out the backbuffer is very slow, not tried dumping the backbuffer into a normal buffer and reading from there to see if its any faster.<br><br>Also not sure if:<br><br><div class="quote"> rgb= (x shl 12) or y<br><br>and to read it:<br><br>x= (rgb shr 12)<br>y=rgb and %111111111111 <br></div><br><br>works correctly (with writepixelfast - works fine as raw maths) - will have to test with known values but I didn't seem to be getting anywhere at all until I padded out the full 32bit value including the 8bit alpha.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064029"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have to mask the alpha byte, it will give random values otherwise if I remember right. rgb= readpixelfast(x,y) and $FFFFFF. Unfort. the alpha byte cannot be used, as far as I see. <br><br></td></tr></table><br>
<a name="1064200"></a>

<a name="1064254"></a>

<a name="1064255"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking like the only way to realistically get this working at all is to cover the color "key" texture with large squares of the same color which massively reduces its resolution and how many triangles you can map.<br><br><br>EDIT: FastExtension v1.16.1+ has the ability to disable texture filtering which might produce better results... tho does depend on a 3rd party lib.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064256"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Large squares? Why? <br><br></td></tr></table><br>
<a name="1064326"></a>

<a name="1064327"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> The bilinear filtering is massively screwing with the accuracy - unless you have several pixels together of the same color you can't guarantee you even have the original pixel value present in the rendered view. However FastExt now has a function for disabling texture filtering which might solve this issue.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064383"></a>

<a name="1064384"></a>

<a name="1064390"></a>

<a name="1064391"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> BTW jfk EO-11110 how fast does your shadow code work for you? as copy and pasted it runs about 20fps for me but if I use copyrect to move the backbuffer to a texture (flags 1+512 might be useful, tried +256 but its slightly slower) and readpixelfast from there it runs over 5x faster.<br><br>Not sure if its an issue with my machine or backbuffer reads generally.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064437"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> 5 times faster is always good. Were you talking about the experimantal thing I posted earlier in this thread? The Vertex Color thing? I really got to try that (do I get this right, you are copying to a texturebuffer to be able to ReadPixelFast etc. from there, which is faster than the backbuffer?) One problem with the 256 flag is, it is not always faster, not on every machine and setup. It also depends on if you use Copyrect or single pixel access. In fact we should use a function that determines the fastest texture flags combinations for such operations.<br><br>The blinear Filtering is indeed a problem. I've just tried to implement your idea. It was rather tricky with a Maplet mesh as long as I didn't realize that I cannot simply apply the color map to both texture layers, this might have something to do with the Blendmode of Maplet Mesh Textures, and I also remember that certain properties could not be alteres after loading, probably this was fixed in later Blitz versions.<br><br>The bilinear filtering is much more a problem with 12 Bits and will result in wild flickering artefacts while the camera and/or light is in motion.<br><br>With 8 Bit is much smoother, but it still has artefacts, caused by "linefeeds" within the texture. Most of the texture is now fading smoothly from one corner to the other, with a 256 x 256 Texture you can say Color 0,x,y. With 12 Bit you still get unique colors, but there are much more neighbour diffrences that will result in false detections dur to bilinear filtering, as you already expected. I really have to try that with FastExt asap.<br><br>Here's the code, excuse the globals etc., just a quick test. Note right now the mapsize should be 256, or 512, but with a bitres of 8, the max size for the texture is 256. I've noticed with 512 it is also rather slow.<br><br><pre class=code>
Const mapsize=256
Const bitres=8
Const bitmask=(2^bitres)-1


Graphics3D 800,600,32,2
SetBuffer BackBuffer()

Collisions 1,2,2,2

player=CreatePivot()
PositionEntity player,0,3,0
EntityRadius player,0.75,1.5
EntityType player,1

Global camera=CreateCamera( player )
CameraRange camera,.1,200
TranslateEntity camera,0,1.5,0


;light=CreateLight()
;RotateEntity light,45,45,45

Global world=LoadMesh( "test_room1_"+mapsize+".b3d" )
EntityFX world,1
EntityType world,2

sp#=.5
ey#=EntityY(player)



;testlight=CreatePivot()
testlight=CreateSphere()
ScaleEntity testlight,0.1,0.1,0.1
Global lightcam=CreateCamera()
CameraProjMode lightcam,0
CameraViewport lightcam,0,0,mapsize,mapsize

Dim texwork(mapsize,mapsize)


Global texmap=LoadTexture("oldbric.bmp")
Global white=CreateTexture(16,16)
Color 255,255,255
Rect 0,0,16,16,1
CopyRect 0,0,16,16,0,0,BackBuffer(), TextureBuffer(white)



ClearTextureFilters()
Global colmap=CreateTexture(mapsize,mapsize,256)
Global litmap=CreateTexture(mapsize,mapsize,256)
TextureCoords colmap,1
TextureCoords litmap,1


For y=0 To mapsize-1
 For x=0 To mapsize-1
  rgb=(x Shl bitres) Or y
;:  Color 0,0,rgb
;  Plot x,y ; color tagging
  WritePixel x,y,rgb
 Next 
Next


CopyRect 0,0,mapsize,mapsize,0,0,BackBuffer(),TextureBuffer(colmap)
Flip
Delay 500


While Not KeyHit(1)
	a#=a+1
	If a&gt;=360 Then a=0


	mxs#=-MouseXSpeed()/4.0
	mys#= MouseYSpeed()/4.0
	MoveMouse GraphicsWidth()/2,GraphicsWidth()/2

	If KeyHit(17)
		wire=1-wire
		WireFrame wire
	EndIf

	MoveEntity player,0,-.1,0

	If KeyHit(57) jump#=180
	
	If jump#&gt;0
	 jump#=jump#-10
	 If jump#&lt;0 Then jump#=0
	 MoveEntity player,0,-Cos(jump),0
	EndIf
	
    TurnEntity camera,mys,0,0
    TurnEntity player,0,mxs,0

	If KeyDown(200) MoveEntity player,0,0,sp
	If KeyDown(208) MoveEntity player,0,0,-sp

	If KeyDown(205) MoveEntity player,sp,0,0
	If KeyDown(203) MoveEntity player,-sp,0,0
	
	PositionEntity testlight, EntityX(camera,1), EntityY(camera,1), EntityZ(camera,1),1
	RotateEntity testlight, EntityPitch(camera,1), EntityYaw(camera,1), EntityRoll(camera,1),1
	MoveEntity testlight,Sin(a)*3.0,0,Cos(a)*3.0 ; just to see the shadows at all
	
	UpdateWorld
	
	
	UpdateLightMap(testlight)
	
	
	RenderWorld
	Text 0,0,TrisRendered()
	Flip 0
Wend

End







Function UpdateLightMap(li)
 Local x%,y%
 EntityTexture world, white,0,0
 EntityTexture world, colmap,0,1

 CameraProjMode camera,0
 CameraProjMode lightcam,1
 PositionEntity lightcam,EntityX(li,1),EntityY(li,1),EntityZ(li,1)
 RotateEntity lightcam,EntityPitch(li,1),EntityYaw(li,1),EntityRoll(li,1)

 RenderWorld()

 SetBuffer BackBuffer()
 LockBuffer BackBuffer()
  For y=0 To mapsize-1
  For x=0 To mapsize-1
   texwork(x,y)=ReadPixelFast(x,y) And $FFFFFF
  Next
  Next
 UnlockBuffer BackBuffer()

; Flip 0 ; visually debuggin...

 Color 40,40,40
 Rect 0,0,mapsize,mapsize,1
 CopyRect 0,0,mapsize,mapsize,0,0,BackBuffer(),TextureBuffer(litmap)

 SetBuffer TextureBuffer(litmap)
 LockBuffer TextureBuffer(litmap)
  For y=0 To mapsize-1
  For x=0 To mapsize-1
   xx=texwork(x,y) Sar bitres
   yy=texwork(x,y) And bitmask

   If(xx&gt;=0) And (yy&gt;=0) And (xx&lt;mapsize) And(yy&lt;mapsize)
    WritePixelFast xx,yy,$FFFFFF
   EndIf

  Next
  Next
 UnlockBuffer TextureBuffer(litmap)
 SetBuffer BackBuffer()

 EntityTexture world, texmap,0,0
 EntityTexture world, litmap,0,1
 CameraProjMode camera,1
 CameraProjMode lightcam,0
End Function
</pre><br><br>The Media used in this test can be found here:<br><a href="http://www.melog.ch/dl/icu_mapping_test.zip" target="_blank">http://www.melog.ch/dl/icu_mapping_test.zip</a><br><br>Btw this line:<br>   yy=texwork(x,y) And (2^bitres)-1<br><br>should be optimized in the sourcecode that comes with the zipfile, it can be a const, as seen here.<br><br>Instead of writing directly to the lightmap for a certain color that was found, you may also add a value to an Array and repeat this with multiple lights, finally write the array to the lightmap. But at the moment I still have no idea how you could reduce the light by distance. This might be ok for sunlight, but pointlights for indoor situations really need this. So we're back at the need for depth buffer access :) .<br>A further optimation would be to WritePIxelFast only if you did not already writepixelfast to that texel, using a further array to store that information. <br><br></td></tr></table><br>
<a name="1064442"></a>

<a name="1064443"></a>

<a name="1064444"></a>

<a name="1064445"></a>

<a name="1064446"></a>

<a name="1064447"></a>

<a name="1064448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah was talking about your vertex coloring code... not sure if its my PCs (all recent nVidia cards with 260+ drivers) but directly reading the backbuffer is insanely slow - but by copyrect the backbuffer to a texture and then doing readpixelfast from that texture I get over 5x faster performance. Could just be an issue with newer nVidia setups that are more focused on DX9+ than DX7 tho.<br><br>I'm using this to unwrap arbitary geometry to test stuff - the unwrapping function is hugely inefficent but it works for testing purposes:<br><br><pre class=code>

Global LMU# = 0; x position to place next tris
Global LMV# = 0; 

Global LMSCALE# = 1.0/16.0 ; based on using quake 3 scale where 32 units = 1 metre.

Const LMRES = 512
Const LMCLAMP# = 16 ; should be a multiple of LMRES

Const LMAMBR = 64
Const LMAMBG = 64
Const LMAMBB = 64

Const LMCAMRES = 128

Function LMadd(mesh) ; adds a mesh to be lit
	Local x0#, y0#, z0#
	Local x1#, y1#, z1#
	Local x2#, y2#, z2#
	
	Local u1#
	Local v1#
	
	Local dist#
	
	Local surf
	Local surfcount
	Local tris
	Local triscount
	Local vert1
	Local vert2
	Local vert3
	
	Local scale# = 1.0/LMRES
	Local blocksize# = LMCLAMP# * scale#
	
	Local oldbuffer
	
	mesh = LMunweld(mesh)
	
	Color 255,255,255

	oldbuffer = GraphicsBuffer()
	SetBuffer ImageBuffer(timg)

	For surfcount = 1 To CountSurfaces(mesh)
		surf = GetSurface(mesh,surfcount)
		triscount = CountTriangles(surf)
		For tris = 0 To triscount-1
			vert1 = TriangleVertex(surf,tris,0)
			x0# = VertexX#(surf,vert1)
			y0# = VertexY#(surf,vert1)
			z0# = VertexZ#(surf,vert1)
			
			vert2 = TriangleVertex(surf,tris,1)
			x1# = VertexX#(surf,vert2)
			y1# = VertexY#(surf,vert2)
			z1# = VertexZ#(surf,vert2)

			vert3 = TriangleVertex(surf,tris,2)
			x2# = VertexX#(surf,vert3)
			y2# = VertexY#(surf,vert3)
			z2# = VertexZ#(surf,vert3)

			u1# = Sqr#(((x1#-x0#)^2)+((y1#-y0#)^2)+((z1#-z0#)^2))
			v1# = Sqr#(((x2#-x0#)^2)+((y2#-y0#)^2)+((z2#-z0#)^2))
			
			u1# = u1# * LMSCALE#
			v1# = v1# * LMSCALE#
			
			If (u1# &gt; LMCLAMP#) Then ; this isn't ideal but we don't want large polygons screwing it up
				u1# = LMCLAMP#
			EndIf
			
			If (v1# &gt; LMCLAMP#) Then
				v1# = LMCLAMP#
			EndIf
			
			u1# = u1# * scale#
			v1# = v1# * scale#
			
			VertexTexCoords surf,vert1,LMU#,LMV#,0,1
			VertexTexCoords surf,vert2,LMU#+u1#,LMV#,0,1
			VertexTexCoords surf,vert3,LMU#,LMV#+v1#,0,1
			
			Line LMU#*LMRES,LMV#*LMRES,(LMU#+u1#)*LMRES,LMV#*LMRES
			Line LMU#*LMRES,LMV#*LMRES,LMU#*LMRES,(LMV#+v1#)*LMRES
			Line LMU#*LMRES,(LMV#+v1#)*LMRES,(LMU#+u1#)*LMRES,LMV#*LMRES
			
			LMU# = LMU# + blocksize#
			
			If (LMU# &gt;= 1.0) Then
				LMU# = 0
				LMV# = LMV# + blocksize#
				If (LMV# &gt;= 1.0) Then
					RuntimeError "Ooops ran out of space on the lightmap!"
				EndIf
			EndIf

		Next
	Next
	
	SetBuffer oldbuffer
	
	EntityTexture mesh,LMmap,0,0
	EntityTexture mesh,LMkey,0,7
End Function

Function LMunweld(mesh) ; *** This function is the work of David Dawkins(Starfox) ***
;Unweld a mesh, retaining all of its textures coords and textures
	For surfcount = 1 To CountSurfaces(mesh)
		surf = GetSurface(mesh,surfcount)

		count = CountTriangles(surf)
		bank = CreateBank((15*count)*4)
		For tricount = 0 To count-1
			off = (tricount*15)*4
			in = TriangleVertex(surf,tricount,0)
			x# = VertexX(surf,in):y#=VertexY(surf,in):z#=VertexZ(surf,in)
			u# = VertexU(surf,in):v#=VertexV(surf,in)
			PokeFloat(bank,off,x)
			PokeFloat(bank,off+4,y)
			PokeFloat(bank,off+8,z)
			PokeFloat(bank,off+12,u)
			PokeFloat(bank,off+16,v)

			in = TriangleVertex(surf,tricount,1)
			x# = VertexX(surf,in):y#=VertexY(surf,in):z#=VertexZ(surf,in)
			u# = VertexU(surf,in):v#=VertexV(surf,in)
			PokeFloat(bank,off+20,x)
			PokeFloat(bank,off+24,y)
			PokeFloat(bank,off+28,z)
			PokeFloat(bank,off+32,u)
			PokeFloat(bank,off+36,v)

			in = TriangleVertex(surf,tricount,2)
			x# = VertexX(surf,in):y#=VertexY(surf,in):z#=VertexZ(surf,in)
			u# = VertexU(surf,in):v#=VertexV(surf,in)
			PokeFloat(bank,off+40,x)
			PokeFloat(bank,off+44,y)
			PokeFloat(bank,off+48,z)
			PokeFloat(bank,off+52,u)
			PokeFloat(bank,off+56,v)

		Next

		ClearSurface(surf,True,True)

		For tricount = 0 To count-1
			off = (tricount*15)*4
			x# = PeekFloat(bank,off)
			y# = PeekFloat(bank,off+4)
			z# = PeekFloat(bank,off+8)
			u# = PeekFloat(bank,off+12)
			v# = PeekFloat(bank,off+16)
			a = AddVertex(surf,x,y,z,u,v)
			x# = PeekFloat(bank,off+20)
			y# = PeekFloat(bank,off+24)
			z# = PeekFloat(bank,off+28)
			u# = PeekFloat(bank,off+32)
			v# = PeekFloat(bank,off+36)
			b = AddVertex(surf,x,y,z,u,v)
			x# = PeekFloat(bank,off+40)
			y# = PeekFloat(bank,off+44)
			z# = PeekFloat(bank,off+48)
			u# = PeekFloat(bank,off+52)
			v# = PeekFloat(bank,off+56)
			c = AddVertex(surf,x,y,z,u,v)
			AddTriangle(surf,a,b,c)
		Next
		FreeBank bank
	Next

	UpdateNormals mesh
	Return mesh
End Function
</pre><br><br>the unweld function isn't my work (the LMadd one is), theres also some code in there from where I was building an image of the UV unwrapping for debugging purposes hence the line code. Excuse the habit of localing every variable I use its a habit I find useful for keeping track of stuff.<br><br>EDIT: Also finding the TextureAnisotropy 0/-2 command from fastext hugely useful I don't think its possible with native b3d to get great results without it.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064450"></a>

<a name="1064451"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's a handy, compact function, thanks. BTW I was trying to find the FastExt function to turn off bilinear filtering, but I could only find a sample about Anisotropy and LODBias - did you mean this? (edit, seems like that, but it doesn't make a diffrence for some reason, guess I am doing something wrong there).<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064454"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm using TextureAnisotropy -2 before rendering the light camera(s) and TextureAnisotropy 0 again to reset it before rendering the scene, seems to help preserve the integrity of color values in the light camera.<br><br>My plan if I got it anything like useable was to cap point lights to a range thats acceptable precision wise - indoor with good map design and light useage it should be possible to keep point light radius low enough and maybe try and find a way to only update distant lights to the player at a less regular rate. With sunlight moving the light "source" position along a vector from the player so that you get good precision around the player position. <br><br></td></tr></table><br>
<a name="1064687"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> FastExt wasn't useful to fight the problems caused by Bilinear Filtering, but it comes in handy for rendering to a texture, that might make sense at a certain point.<br><br>But I have found an other way to turn off bilinear mapping: you can use DevisChild Shadow System, it contains a DX7 extension DLL with many useful commands, including SetTextureStageState, that allows to turn off the biliniear filter.<br><br>As a preventive Anti-404 Approach I uploaded the complete DCs Shadow Lib and added a sample for the Biliniear FIlter thing here (DC, hope you don't mind, otherwise let me know):<br>www.melog.ch/dl/bb_bilinear_off.zip<br><br>I've also made a test with it, trying the bespoken Realtime Lightmapping, and it works nicely, at least much better than with bilin.filters. There is still the speed problem with a 512 Texture. I tried to use a texturebuffer as you suggested, but it didn't help on my machine. I still hope somebody is going to hack a bridge in between DX7 and a parallel DX8 mini-surface that acts only as a programmable shader. Meanwhile I'll try to make it faster "somehow" :) <br><br></td></tr></table><br>
<a name="1064757"></a>

<a name="1064758"></a>

<a name="1064759"></a>

<a name="1064760"></a>

<a name="1064777"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
Include "include\FastExt.bb"

Graphics3D 800,600,32,2

InitExt
SetBuffer BackBuffer()


;light=CreateLight()
;RotateEntity light,45,45,0
AmbientLight 255,255,255 ; preserve color data
cube=CreateCube()


w=256
tex1=CreateTexture(w,w)
For i=0 To 100000
 Color Rand(255),Rand(255),Rand(255)
 Plot Rand(0,255),Rand(0,255)
Next
EntityTexture cube,tex1


CopyRect 0,0,256,256,0,0,BackBuffer(), TextureBuffer(tex1)


camera=CreateCamera()
CameraRange camera,0.001,50
TranslateEntity camera,0,0,-1.5

; FastExt filtering

TextureAnisotropy -2


While KeyHit(1)=0
 TurnEntity cube,0,.1,0
 RenderWorld()
 Flip
 Delay 10
Wend

End
</pre><br><br>Does exactly the same thing for me using fastext which is much nicer than using DSS.<br><br>I was intending to try and use the lightmap as a mask (for shadowing) eventually using the normal lights to light stuff rather than purely using the lightmap for lighting as otherwise you need to also render the z-buffer to do light falloff, etc.<br><br>I'll try and get some code up and working with the method I use for reading from the backbuffer as on my PC it makes the difference between &lt;20fps and &gt;70fps which makes a world of difference in useability.<br><br>EDIT: Updated to include AmbientLight 255,255,255 so as to preserve the integrity of color samples.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Note TextureAnisotropy -2 didn't turn off bilinear filtering on a Ati radeon, that<br>'s a fact. Anisotropy is an other feature that you can access seperately in DCs DX7 dll. Are you really sure we're talking about the same thing? There is LOD Bias and Anisotropy in FastExt, but no SetTextureStageState%(0,D3DTSS_MAGFILTER, D3DTFG_POINT).<br><br>While I was happy to get it turned of at all, I realized that there is one problem that I cannot solve, even after hours of hacking: Whenever I want to access a rendered Pixel it must be downloaded from VRam to Ram somehow, and no matter what Method I try, they are all horribly slow. Some of the methods I tried:<br><br>-Copy from backbuffer to imagebuffer, readpixel there<br>-copy from 256-texture (where the scene was rendered to, using Fastext) to 0-texture<br>-copy from backbuffer to 0-texture<br>-using external copybuffer from DX7 dll to copy from 256-tex to 0-tex<br>-copy from backbuffer to image, then use RTLMoveMEmory to move en bloc to a bank, completely skipping readpixel, using ReadInt on the bank.<br><br>No matter what, as soon as the rendered Pixels are read, there is a massive slowdown: on backbuffer, on a texturebuffer with flag 256, on an image, and even with RtlMoveMemory from an image to Ram. Sample: Readpixelfast on a 256-texture is 36 times slower than Readpixelfast on a texture with no 256-flag. But I can render only to a texture when the 256 flag is set. With copyrect it's even worse, copying a 256-tex to a 0-tex is 75 times slower than copying 0-tex to 0-tex.<br>(note 0-tex means a texture with flags 0...).<br>Using texture flags 512+1 and copyrect the backbuffer to it is lightning fast, 20 times faster than anything else, there's only one little problem: noting is copied at all (one more of those "I MADE IT!... not" moments).<br><br>So, for now I seem to be blocked by the hardware. Kinda frustrating. Now, just imagine: the same thing could be done with shaders easily, but then everything would happen within the GPU, not only the CPU would not have to do the calculations, there would also be no need to download anything:<br><br>-Do a color-tagged render in Blitz to a texture buffer<br>-Run a pixel shader that takes the color render and sets the lumels in the lightmap <br>-if possible it may use the depthbuffer for light fallof, not sure if this is supported<br>by the blitz render (maybe when it's rendered to a texture with FastExt, DCs lib however seems to allow to apply a Depthbuffer to a Texturebuffer). <br><br></td></tr></table><br>
<a name="1064785"></a>

<a name="1064786"></a>

<a name="1064787"></a>

<a name="1064799"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh didn't know TextureAnisotropy -2 didn't work on ATI - running all nVidia hardware here :S it definitely does exactly the same thing here - disables filtering as the code using DC's dll.<br><br>Looks like theres some issues on different types of hardware - doing something like:<br><br><pre class=code>
	tempbuffer = CreateTexture(512,512,1+512)
	
	CopyRect 0,0,512,512,0,0,BackBuffer(),TextureBuffer(tempbuffer)
	
	SaveBuffer TextureBuffer(tempbuffer),"c:\buffer.bmp"
</pre><br><br>is extremely fast on all my PCs - using savebuffer I can see its copying data - and I can read pixels from that tempbuffer as fast as normal reads.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064804"></a>

<a name="1064806"></a>

<a name="1064808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is the modified version of your ICU code as I run it on my setup - does ~100fps on an E6600 w/ GTX260 and well over 100 on my gaming PC (Q9550 @ 4gig w/ GTX470 SLI) - SLI not used in b3d tho.<br><br>(I also dropped the light range to simulate a smaller point light, it works fine albiet poor shadow resolution/precision on my nVidia hardware - latest version of fastext is needed for the filtering stuff but runs fine with that commented out)<br><br><pre class=code>
Include "include\FastExt.bb"

Const mapsize=256
Const bitres=8
Const bitmask=(2^bitres)-1

Global scratch


Graphics3D 800,600,32,2
InitExt
SetBuffer BackBuffer()

Collisions 1,2,2,2

player=CreatePivot()
PositionEntity player,0,3,0
EntityRadius player,0.75,1.5
EntityType player,1

Global camera=CreateCamera( player )
CameraRange camera,.1,200
TranslateEntity camera,0,1.5,0


;light=CreateLight()
;RotateEntity light,45,45,45

Global world=LoadMesh( "test_room1_"+mapsize+".b3d" )
EntityFX world,1
EntityType world,2

sp#=.5
ey#=EntityY(player)



;testlight=CreatePivot()
testlight=CreateSphere()
ScaleEntity testlight,0.1,0.1,0.1
Global lightcam=CreateCamera()
CameraProjMode lightcam,0
CameraViewport lightcam,0,0,mapsize,mapsize

Dim texwork(mapsize,mapsize)


Global texmap=LoadTexture("oldbric.bmp")
Global white=CreateTexture(16,16)
Color 255,255,255
Rect 0,0,16,16,1
CopyRect 0,0,16,16,0,0,BackBuffer(), TextureBuffer(white)



ClearTextureFilters()
Global colmap=CreateTexture(mapsize,mapsize,256)
Global litmap=CreateTexture(mapsize,mapsize,256)
TextureCoords colmap,1
TextureCoords litmap,1


For y=0 To mapsize-1
 For x=0 To mapsize-1
  rgb=(x Shl bitres) Or y
;:  Color 0,0,rgb
;  Plot x,y ; color tagging
  WritePixel x,y,rgb
 Next 
Next


CopyRect 0,0,mapsize,mapsize,0,0,BackBuffer(),TextureBuffer(colmap)
Flip
Delay 500

scratch = CreateTexture(mapsize,mapsize,1+512)


While Not KeyHit(1)
	a#=a+1
	If a&gt;=360 Then a=0


	mxs#=-MouseXSpeed()/4.0
	mys#= MouseYSpeed()/4.0
	MoveMouse GraphicsWidth()/2,GraphicsWidth()/2

	If KeyHit(17)
		wire=1-wire
		WireFrame wire
	EndIf

	MoveEntity player,0,-.1,0

	If KeyHit(57) jump#=180
	
	If jump#&gt;0
	 jump#=jump#-10
	 If jump#&lt;0 Then jump#=0
	 MoveEntity player,0,-Cos(jump),0
	EndIf
	
    TurnEntity camera,mys,0,0
    TurnEntity player,0,mxs,0

	If KeyDown(200) MoveEntity player,0,0,sp
	If KeyDown(208) MoveEntity player,0,0,-sp

	If KeyDown(205) MoveEntity player,sp,0,0
	If KeyDown(203) MoveEntity player,-sp,0,0
	
	PositionEntity testlight, EntityX(camera,1), EntityY(camera,1), EntityZ(camera,1),1
	RotateEntity testlight, EntityPitch(camera,1), EntityYaw(camera,1), EntityRoll(camera,1),1
	MoveEntity testlight,Sin(a)*3.0,0,Cos(a)*3.0 ; just to see the shadows at all
	
	UpdateWorld
	
	
	UpdateLightMap(testlight)
	
	TextureAnisotropy 0
	
	RenderWorld()
	Text 0,0,TrisRendered()
	Flip 0
Wend

End







Function UpdateLightMap(li)
 Local x%,y%
Local oldbuffer = GraphicsBuffer()
 EntityTexture world, white,0,0
 EntityTexture world, colmap,0,1

 CameraProjMode camera,0
 CameraProjMode lightcam,1
 PositionEntity lightcam,EntityX(li,1),EntityY(li,1),EntityZ(li,1)
 RotateEntity lightcam,EntityPitch(li,1),EntityYaw(li,1),EntityRoll(li,1)
 CameraRange lightcam,1,8

TextureAnisotropy -2

 RenderWorld()

 CopyRect 0,0,mapsize,mapsize,0,0,BackBuffer(),TextureBuffer(scratch)


 SetBuffer TextureBuffer(scratch) ;BackBuffer()
 LockBuffer TextureBuffer(scratch) ;BackBuffer()
  For y=0 To mapsize-1
  For x=0 To mapsize-1
   texwork(x,y)=ReadPixelFast(x,y) And $FFFFFF
  Next
  Next
 UnlockBuffer TextureBuffer(scratch); BackBuffer()

SetBuffer oldbuffer ; backbuffer?

 ;Flip 0 ; visually debuggin...

 Color 40,40,40
 Rect 0,0,mapsize,mapsize,1
 CopyRect 0,0,mapsize,mapsize,0,0,BackBuffer(),TextureBuffer(litmap)

 SetBuffer TextureBuffer(litmap)
 LockBuffer TextureBuffer(litmap)
  For y=0 To mapsize-1
  For x=0 To mapsize-1
   xx=texwork(x,y) Sar bitres
   yy=texwork(x,y) And bitmask

   If(xx&gt;=0) And (yy&gt;=0) And (xx&lt;mapsize) And(yy&lt;mapsize)
    WritePixelFast xx,yy,$FFFFFF
   EndIf

  Next
  Next
 UnlockBuffer TextureBuffer(litmap)
 SetBuffer BackBuffer()

 EntityTexture world, texmap,0,0
 EntityTexture world, litmap,0,1
 CameraProjMode camera,1
 CameraProjMode lightcam,0
End Function
</pre><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064903"></a>

<a name="1064929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> If this runs with 100 fps, you should try:<br><br>Const mapsize=512<br>Const bitres=12<br><br>This looks not so blocky. If bilinear filtering is really turned off, then it should look ok. There is still the sampling problem of distant locations (player/light angle problem), but the rest is looking nice. If this system is used with a small mesh, eg. a single room in a big building, then the texels may be really small and fine. So it isn't entirely unpractical. With an additional 8 Bit depthmap (created with one of the methods mentioned earlier) you could even realize the light falloff. Unfortunately Renderworld has a little overhead, so it wont be an option to render the depth in slices to gather Depth information.<br><br>Using an animated NPC in this scene may also be less complicated than I guessed in the first place: Simply take the lightmap of the room (let us assume it uses the texture like Maplet, leaving the bottom right corner free, depending on how much of the texture is used), and UVmap the NPCs 2nd texture layer on this free corner. Atually you will have to simply scale it down to the corner in a Tool like UU3D or so.<br><br>Then, when your player is walking trough the level and a portal system is used that switches the lightmaps for the realtime lights, simply switch the NPC(s) lightmap as well. Again, if speed in't an issue then you can use up to a 4kx4k Texture with 12 Bit encoding. I think you can do a lot with a texture like that, for a single portal cell only. Any UVmapping is static, does not consume CPU power, even for animated Meshes.<br><br>Too bad speed IS an issue :/ . Good to hear it works better on NVidia. Mabye it is rather the AGP Bus that I still have. I think these things work diffrent with PCIe.<br><br>While copyrect from backbuffer (or a 256 texture) to a 1+512 texture is not copying anything and savebuffer saves a black, empty rect, (and we may discuss of this should be considered a feature or a bug), it seems I do have some asymetric Bus capabilities: upload works nicely, that's also what is required normally by a game, fast upload, resulting in liquid graphic changes. But as soon as something must be copied from Vram back to Ram, there is a strong brake (in the best case 35 times slower than the upload). I guess it has something to do with muliplexing data.<br><br>AGP Vram is addressed in the logical Ram adress space, somewhere at the top of the 4 gigas. Now this is only for AGP (I guess) and it might be not very interesting, I however was thinking about the usage of the "AGP Aperture" to speed thing up. AGP Aperture (Size can be set in the BIOS) is the amount of RAM the system will provide to the graphics card if it is running out of true VRAM. So this wil be Vram that lies within the conventional Ram. Shure, it wouldn't be a good idea to fill up VRam with unused textures, just to be able to have something in the Aperture Vram, but maybe there's a way to use it directly, maybe with some wrapped DX7 calls, probably something for a new FastExt version.<br><br>In theory reading from a texture Buffer that lies within the "Aperture Vram" should be much faster than reading from true Vram. Especially when a hack would be used, eg. with RtlMoveMemory. Too bad this Aperture Vram <br><br><i>"is spread in a non-contiguous form throughout the physical memory. Accessing these pages directly would hinder performance because of scattering/gathering requiring extra logic. To get around this limitation the GART (Graphics Address Remapping Table) which is implemented in hardware in the Northbridge's Memory Controller Hub provides an automatic physical-to-physical mapping between the scattered pages and the AGP Aperture. ... The actual usable amount of this 'virtual' AGP memory is less than half the AGP Aperture size set in the BIOS. This is because the Aperture is divided into two areas. One uncached half and another write-combined area."</i><br><br>Well, thats AGP. Maybe better placed in the museum. Hacking the impossible is still fun for some reason.<br><br>EDIT: I just tried to wipe out all Vram and create the lightmap texture in the Aperture Ram. Using CreateImage to use all the Vram works nicely, and the program proceeds, but in the render the textures created after there was nomore Vram will remain black, additionally, the speed isn't any higher.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064910"></a>

<a name="1064912"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats one of the things I tried - unfortunatly brings it down to 20-30fps tho the shadows do start to look much more like shadows.<br><br>I'm assuming the issue with copyrect to a 1+512 texture is a bug - possibly related to AGP - try the code with just flags 1?<br><br>My function (with some adaption especially for efficency) can map any mesh into the lightmap, tho not sure how well it would turn out unwelding an NPC - by using a dynamic scale you could map higher resolution meshes into a smaller space which should still provide decent enough detail for an NPC model.<br><br>I can see some potential applications for this system tho i.e. realtime shadowing astroid fields with only the one distant light source (moved along a vector for precision around the player), etc.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064915"></a>

<a name="1064918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oooh just disabled debug mode and its doing 86fps with 512/12 :D and actually looks quite good the odd speckle/incorrect pixel aside.<br><br><a href="http://www.youtube.com/watch?v=ydJCmXEHLrY" target="_blank">http://www.youtube.com/watch?v=ydJCmXEHLrY</a> - was doing ~86fps on an E6600 w/ GTX260.<br><br>Baring in mind that the lightmap can easily be 2048x2048 without any affect on performance if you use my system of clsing the texture with ambient color and only writepixel based on the decoded x/y value and 4096x4096 on high end hardware it would be possible to get fairly decent res shadows assuming precision with a 512x512 or less light cam is possible, tho for point lights you'd really need to render twice with high field of view back to back :S<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried 1 alone and in combination with other flags. As soon as it works, it also becomes as slow as described (eg. 1+2). Yes, 512 may be 25 fps, since it is 4x bigger than 256. I think even on PCIe boards, download from Vram is still not really fast. Since modern shaders are more and more used to calculate non-graphical data as well (doing the work of the CPU using the GPU), we maybe can expect the hardware development will support a better Download in the future.<br><br>Not only asteroid fields, but basicly any sunlight sytem. Note: you can have an almost orthogonal camera (without to use the true Ortho Cam of Blitz, that suffers of Z-Sorting problems, at least here) when you set the Zoom to 100, then move the camera back 100 units and set the range to 100 to 200 (or so). So this render will provide a directional light source, like the sun. <br><br></td></tr></table><br>
<a name="1064919"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> See my updated post above, atleast on newer nVidia hardware its possible to get it working very fast. Unfortunatly I don't have anything else to test it on other than core 2 CPUs and GTX260 or newer. <br><br></td></tr></table><br>
<a name="1064928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> 256/8 with debug disabled and fullscreen does over 300fps! need to get someone on a 4xxx or higher ATI card to try with newer drivers too. Bit of a let down if it only works on recent PCI-e cards decently tho. <br><br></td></tr></table><br>
<a name="1064930"></a>

<a name="1064935"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, 300 fps is more than I ever expected. Well, most things work only on PCI-e these days :) I think you should try a 1024 lightmap now :) this should still be about 70 fps. you may simply scale the texture up, the UVs remain the same.<br><br>EDIT oh, a misunderstanding, thought 256/8 refers to the flags. Well, still pretty fast. How much do you get with 512 texels ? (this coder language is really confusing, are we alking about 256 or about 256... actualy when it comes to binary  there are "10" types of people: those who understand it and those who don't.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064937"></a>

<a name="1064939"></a>

<a name="1064942"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> For clarity - with debug disabled, fullscreen and using 1+512 flags on the texture I'm dumping the back buffer in:<br><br>800x600 with 256x light cam/map 8bit precision = 315fps<br>800x600 with 512x light cam/map 12bit precision = 120fps<br>1280x1024 with 1024x light cam/map 12bit precision = 25fps<br>1280x1024 with 512x light cam, 1024x map with 12bit precision = 100fps<br><br>1024x1024 is a little slow if I use that for light cam size and redrawing the whole texture (25fps). But if I keep the light cam size to 512 and only draw to the lightmap texture based on the x/y coords its still a good 100fps.<br><br>EDIT: With 1+256 (don't really need 512 just using it to make sure precision is always as high as possible incase of driver opptimisations, etc.) I can get to 335fps at 800x600 w/ 256 sized texture tho it seems a bit slower with the 256 texture flag versus just 1 or 1+512 at higher texture resolutions.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064943"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's really fast. When you think about the lot of indoor games that are using an individual lightmap vor every room or even for every light (so you can EG. turn the lights on and off (swapping two lightmap variations), using a light switch item in the game), then this is really promising. I still wonder if there's an easy way to gather depth information for light falloff. <br><br></td></tr></table><br>
<a name="1064947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> It would be better if possible to try and use the lightmap texture as a mask somehow (to shadow areas) and use the standard dx lights for actually lighting. <br><br></td></tr></table><br>
<a name="1064981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> As a mask? Not sure if I understand what you mean. Isn't it the same with a mask except for the sharp edges? You could set the alpha byte instead of $FFFFFF in the lightmap, and use the flag 4 (does 4 work together with flag 256 at all?) <br><br></td></tr></table><br>
<a name="1064986"></a>

<a name="1064988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure quite how to do it off the top of my head without playing (the first method that comes to mind would mean some parts were darker than they should be)<br><br>Essentially apply the lightmap texture with a blend so that the "lit" pixels in the lightmap texture allow the original DX lights to light the geometry, rather themselves lighting it, and the dark parts of the lightmap texture are shadows, cancelling out the DX lights where applicable.<br><br>Don't think I'm doing a great job of explaining it lol.<br><br><br>EDIT: So rather than a traditional lightmap that has both light and shadow info its more like a shadow map.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064989"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wouldn't cancelling out DX light mean the masked parts must be fully opaque? <br><br></td></tr></table><br>
<a name="1065389"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just tried it on an other machine with PCI-e Bus. Although still a low end onboard chip, it's really fast now and the Flags 1+512 also worked. The sooner or later i can plug in a fullfledged PCIe Card there.  I also used to write my first pixel shader, in GLSL, I love it... AFK to do some more tests. <br><br></td></tr></table><br>
<a name="1067726"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> I haven't forgotten about this btw, just been busy with work with the new year and everything, should have a couple of weeks off coming up when I'm planning to put some more effort into it. <br><br></td></tr></table><br>
<a name="1067951"></a>

<a name="1067952"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MikhailV</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excuse me if not in a theme, but...<br><br><div class="quote"> <br>jfk EO-11110:<br>Note TextureAnisotropy -2 didn't turn off bilinear filtering on a Ati radeon, that<br>'s a fact.<br> <br></div><br><br>Fact? Whence you it took? I have checked up - it works perfectly, fullscreen mode too. See below:<br><br><a href="http://fastlibs.com/temp/no_filter.jpg" target="_blank"><img src="http://fastlibs.com/temp/no_filter_th.jpg"><br><u>click for zoom</u></a><br><br>And...<br><div class="quote"> <br>... There is LOD Bias and Anisotropy in FastExt, but no SetTextureStageState%(0,D3DTSS_MAGFILTER, D3DTFG_POINT).<br> <br></div><br><br>Filtration switch-off is implemented more correctly in FastExtension library, I am assured. See a part of source code of TextureAnisotropy function from FastExt.dll:<br><pre class=code>
...
*Ext_D3DDev7\SetTextureStageState(layer, #D3DTSS_MAGFILTER, #D3DTFG_POINT)
*Ext_D3DDev7\SetTextureStageState(layer, #D3DTSS_MINFILTER, #D3DTFN_POINT)
*Ext_D3DDev7\SetTextureStageState(layer, #D3DTSS_MIPFILTER, mode)		; mode = -2 (#D3DTFP_NONE), -1 (#D3DTFP_POINT)
...
</pre><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1068032"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, sorry MikhailV, it didn't work for some reason here, but maybe I was only too silly. It think It was because I checked the include file with the "new blitz3d functions", but not the decls.<br><br> BTW what happened to the other (extremly fast) shadow system that was beta-implemented and then was removed from FastExt?  Any chance to see this continued in a seperate project?<br><br>Hey Rroff, I decided to try it with pixel shaders, the sooner or later. But no matter what, Vram isn't really designed to be read, while writing to it is highly optimized in any way. That's why eg. perspective rendered shadows are rather quick, because you never need to examine a rendered pixel with the cpu. Pixel shaders seem to be the solution because they are designed to read and write from/to textures (and direct rendering to texture is used for sampling). Furthermore there is the nonlinear WBuffer (contrary to Zbuffer that is linear) that may help to reduce the named sampling problems. <br><br></td></tr></table><br>
<a name="1068238"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MikhailV</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>BTW what happened to the other (extremly fast) shadow system that was beta-implemented and then was removed from FastExt? Any chance to see this continued in a seperate project?<br> <br></div><br>There are problems which is actually unreal to solve:<br> Low quality of shadows, low accuracy + artefacts (access denied to a dx7 depth buffer)<br> High complexity of integration of such shadows in real projects. :( <br><br></td></tr></table><br>
<a name="1068315"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> Was that the fake PSSM version? shame its not feasible. <br><br></td></tr></table><br>
<a name="1068407"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> :-( Thanks for the info. <br><br></td></tr></table><br>
<a name="1077787"></a>

<a name="1077789"></a>

<a name="1077815"></a>

<a name="1077817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I've been working on various approaches to ICU dynamic lightmapping over the last few week and unfortunatly so far not been able to find anything that gives a good blend of quality shadows and performance :( good performance versions have way too many artifacts in the shadow map to be useable and the filtering systems/sample resolution, etc. needed to get clean accurate shadows produce sub-realtime speeds.<br><br>Unfortunatly as JFK said it seems the only real approach to getting this to work would be via pixelshaders and theres better ways to do shadows if you have that capability.<br><br>EDIT: Thinking out loud somewhat but I wonder if its possible to use a combination of ICU with the approach with the way fastext does shadows - using a system where each polygon is mapped to a unique color (similiar to the lightmap key system) and when the results of the light cam is projected from the player eye perspective the color differences between the key map and the projected texture can cancel out areas that are lit (same color from each) and provide a map of the areas in shade (different colors)?<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1078089"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uh, I kind of don't get that. Maybe I got to read it again later :) <br><br></td></tr></table><br>
<a name="1078297"></a>

<a name="1078298"></a>

<a name="1078299"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I might be talking rubbish as I'm not entirely sure how fastext works tho I understand the basics.<br><br>Unwrap mesh and give each tris unique coords in a "lightmap" texture but instead of different colors for each texel use a different color for each polygon (also means we don't need to give each polygon much space in the texture).<br><br>Render from the light view like fastext does but with each polygon showing a unique color.<br><br>Project the light cam view back over the geometry still in unique polygon color mode so that where the colors are the same in each area thats "lit" but where the colors are different between the 2 camera it would be "unlit" with clever blending it should be possible to use this to generate a shadow mask.<br><br>Rerender with proper textures and the shadow mask.<br><br>Depending on how the shadow map is projected in fastext it might or might not work - this should work around the artifact issues of per texel mapping, performance issues of manually comparing each pixel and allow self shadowing and z correct shadows, tho it would need some kinda AND or OR blend mode.<br><br>EDIT: Or it might not be possible with the projection method to do self shadowing or z correct shadows in which case it would just be a more complicated way to do shadows the same way fastext works lol.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1078300"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Project the light cam view back over the geometry <br></div><br><br>What does this mean? (I'm assuming you mean render one camera as light position, then apply a perspective-mapped texture to the scene but somehow actually render it from the perspective of the <i>other</i>, normal camera?)<br><br>If so, I think you're on to something. But can that move be done? (Answer: probably not in the current version of FastExt, but that doesn't necessarily rule it out as a future addition if we ask Mikhail nicely.) <br><br></td></tr></table><br>
<a name="1078306"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure how fastext projects its shadow map, probably not in a method thats applicable to this use tho :S (would still have issues with the Z coord). <br><br></td></tr></table><br>
<a name="1078312"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wasn't referring to the shadow system, only to the ability to use a vertex's screen coordinates as the UV coordinates for perspective texturing. Somehow I had the idea this was important to your suggestion... now I'm not sure. I think I misunderstood. <br><br></td></tr></table><br>
<a name="1078313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh thats a different application to what I was meaning, could also have potential tho very complex. <br><br></td></tr></table><br>
<a name="1079652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried hard, still no luck +_+. I am esp. having problems with "Project the light cam view back over the geometry". <br><br></td></tr></table><br>
<a name="1079671"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I'm probably overestimating the method fastext uses for shadows.<br><br>Not easy to explain will have to get some code up and running if its at all possible which will take a bit. <br><br></td></tr></table><br>
<a name="1082252"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I had a go at my idea with fastext - a bit complicated to explain - the long and short of it tho due to the difference in camera/perspective resolution between the player camera and light cam there are unfixable artifacts along the edges of polygons... so back to square one.<br><br><br>The only avenue I've now not explored is using the original lightmap idea but tagging the original points in realtime 3D space (probably a bit slow) so as to get visibility information from a sparse octree in terms of which point on the LM is in shadow. <br><br></td></tr></table><br>
<a name="1082254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> tagging the original points in realtime 3D space (probably a bit slow) so as to get visibility information from a sparse octree in terms of which point on the LM is in shadow <br></div><br><br>As used by Quake and Quake 2 (sadly I can't find the link at the moment).<br><br>The basic idea, as I understand it, is that the lightmap is made without any overlap; each pixel is also linked to a reference to its (only) 3D position, and light sources pick against nearby pixel points then update the render copy of the lightmap as appropriate.<br><br>It can definitely be made very fast (Quake 2 gives hundreds of FPS even in software rendering mode), but the resolution isn't that high unless you have a lot of separate lightmaps (obviously increased resolution will reduce performance). Also won't be usable for animated or movable objects of any sort.<br><br>Definitely a good choice for games with a retro aesthetic though. Quake 2 is one of the best-looking games <i>ever</i>. <br><br></td></tr></table><br>
<a name="1082263"></a>

<a name="1082264"></a>

<a name="1082265"></a>

<a name="1082266"></a>

<a name="1082267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> Quake/Quake 2 only uses a static baked lightmap (non-overlap) for lighting. The game does build a light grid from this - but this is used to test a position to get the light level in realtime rather than to update the lightmap*. The light grid is used to correctly shade moving entities like players but only in a course manner (no shadow projection) - its also used in the AI - a player thats position is in a darker area in the light grid is harder for the AI to detect and react to than someone in the middle of a brightly lit area.<br><br>I'm talking about extending it beyond a static light grid so as to use a voxel style method to update the non-overalp light map in real time.<br><br>Another advantage of using this if its possible to do fast enough would be realtime global illumination which would be perfectly possible from this method.<br><br>* It is used for switchable lights to update the lightmap i.e. lights turning on/off, changing colors or flickering patterns, etc. to simulate say candle light, but it doesn't update the shadow projection only the brightness of a spot on the lightmap with no additional spot occlusion testing against light sources.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
