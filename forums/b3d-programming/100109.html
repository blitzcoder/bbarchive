<!DOCTYPE html><html lang="en" ><head ><title >Intercept/Look-ahead question</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Intercept/Look-ahead question</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Intercept/Look-ahead question</a><br><br>
<a name="1179446"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've got some spaceships shooting at each other, but they need to aim a bit better than they do; they always shoot directly at the target rather than where the target is going to be.  Here's the ideas I have for intercepting:<br><br>1. Put a pivot at the target and move it according to it's speed divided by my bullet's speed (or something like that) and hope the result is good enough.<br><br>2. Use Neraj's code as described here:<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=69777" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=69777</a><br><br>3. Adapt one of the "lines intersect" functions in the code archives, some of which may return an angle, but I think mostly they just tell you if two lines intersect.<br><br>Option 2 is the leader at the moment, but it's costly in cycles, so I would probably only run it once per second per ship, and just remember the distance in front of the target for the rest of that second, if you know what I mean.<br><br>Any other ideas?  Thanks in advance. <br><br></td></tr></table><br>
<a name="1179462"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would position a pivot at a distance, equal to the velocity of the target ship + a random value, in front of the target ship, so that sometimes the ship will shoot a missile which will hit the target ship, and sometimes no. <br><br></td></tr></table><br>
<a name="1179468"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the reply.<br><br>That was my first thought (before I found Neraj's function).<br><br>Basically, the two factors are the speed of the target and the time it will take the attacker to get there.  If we ignore the change in distance caused by the target's movement (moving away or approaching) then it hopefully becomes straightforward, and probably doesn't lose much accuracy since a target approaching or moving away will move less laterally anyway, so is easier to hit.<br><br>Of course if the target is actually turning, well I'm prepared to ignore that for now at least :-)<br><br>Thanks again. <br><br></td></tr></table><br>
<a name="1179476"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I use a function similar to below which converges on the answer, rather than giving exact precision.  The more iterations, the more accurate.  This allows you to make the AI almost perfect or total shite!<br><br>v.vehicle is the source vehicle which is shooting<br>t.vehicle is the target vehicle<br>WeaponSpeed is the bullet speed of v.vehicle<br>Relative should always be true so that target vehicle speed is considered<br>v\Model is the entity for that vehicle<br>v\AimPivot is a pivot which the vehicle v should be aiming at after calling this function.<br><br><pre class=code>
Function AItarget( v.Vehicle , t.Vehicle, WeaponSpeed#, Relative = True )
	
	;relative = false if vehicle doesn't have a weapon
	
	Local Iterations, x#, y#, z#
	Local vx#, vy#, vz#, Frames#, l
	
	Select v\AIskill
		Case 1	;gallus
			Iterations = 6
		Case 2  ;average
			Iterations = 3
		Case 3 	;donkey
			Iterations = 1
	End Select
	
	;target position
	x# = EntityX( t\Model, 1 )
	y# = EntityY( t\Model, 1 )
	z# = EntityZ( t\Model, 1 )
	;target velocity
	vx# = t\VelocityX - v\VelocityX * Relative
	vy# = t\VelocityY - v\VelocityY * Relative	
	vz# = t\VelocityZ - v\VelocityZ * Relative
	;target position
	PositionEntity v\AimPivot, x + vx , y + vy , z + vz					
	
	;converge to best result									
	For l = 1 To Iterations
		Frames# = EntityDistance( v\Model, v\AimPivot ) / WeaponSpeed
		PositionEntity v\AimPivot, x + vx * Frames, y + vy * Frames , z + vz * Frames
	Next
	
End Function
</pre> <br><br></td></tr></table><br>
<a name="1179519"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's awesome Stevie, thanks.  It looks like the same idea, but the multiple iterations makes sense.  Also, I don't currently keep track of velocity x, y and z for each ship, just MoveEntity(ship,0,0,speed) but I can get that info, so this should work.  <br><br>I still like the idea of only running the function once per ship per second (or so), and keeping track of the distance in front of the target.  The rest of the time, just positioning the pivot in that relative location and pointing the gun/ship should be pretty good.  After all, humans can't adjust their aim sixty times a second, but they can follow a target.<br><br>Oh, and I had to look up "gallus", because I are a Merican.  Wikipedia has it near the end of a long list of Roman orators and such.  After Gaius Cornelius Gallus, and of course the noted 19th century female bouncer Gallus Mag.  <br><br>It's a Scottish expression, apparently.  Gallus Mag was particularly gallus.  She used to bite the earlobes off guys who refused to leave the bar.  And kept the ears in a jar of alcohol behind the bar.  I've learned something today.  I've grown as a person.  :-) <br><br></td></tr></table><br>
<a name="1179537"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>It's a Scottish expression, apparently. Gallus Mag was particularly gallus. She used to bite the earlobes off guys who refused to leave the bar. And kept the ears in a jar of alcohol behind the bar. I've learned something today. I've grown as a person. :-) <br> <br></div><br><br>Me too :)  I always associated 'Gallus' with brilliant or someone who loves themself etc. <br><br></td></tr></table><br>
<a name="1179541"></a>

<a name="1179581"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> It started with a maths tutorial to explain "how to" calculate this stuff ...<br>Then ... Don't know why, I started to add a ship that goes from point A to Point B, and finally, randoms ships with a missile launcher :)<br><br>Hit mouse(1) on a ship to shoot it !<br><br><br>Whatever, this method is similar to the others except, it calculates without iteration, the future "collision" point (so it is pretty accurate for what you need)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TV3 Field x#,y#,z# End Type
Function NewV3.TV3(x#=0.0,y#=0.0,z#=0.0):Local v.TV3=New TV3:v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3Assign.TV3(v.TV3,src.TV3):v\x=src\x:v\y=src\y:v\z=src\z:Return v:End Function
Function V3Copy.TV3(src.TV3):Return V3Assign(NewV3(),src):End Function
Function V3set.TV3(v.TV3,x#,y#,z#):v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3normalize.TV3(v.TV3):Local n#=Float(1.0)/Sqr(v\x*v\x+v\y*v\y+v\z*v\z):v\x=v\x*n:v\y=v\y*n:v\z=v\z*n:Return v:End Function
Function V3Add.TV3(v1.TV3,v2.TV3):v1\x=v1\x+v2\x:v1\y=v1\y+v2\y:v1\z=v1\z+v2\z:Return v1:End Function
Function V3Sub.TV3(v1.TV3,v2.TV3):v1\x=v1\x-v2\x:v1\y=v1\y-v2\y:v1\z=v1\z-v2\z:Return v1:End Function
Function V3Negate.TV3(v.TV3):v\x=-v\x:v\y=-v\y:v\z=-v\z:Return v:End Function
Function V3mulScalar.TV3(v.TV3,s#):v\x=v\x*s:v\y=v\y*s:v\z=v\z*s:Return v:End Function
Function V3Norm#(v.TV3):Return Sqr(v\x*v\x+v\y*v\y+v\z*v\z):End Function
Function V3Norm2#(v.TV3):Return v\x*v\x+v\y*v\y+v\z*v\z:End Function
Function V3Mul.TV3(a.TV3,b.TV3):a\x=a\x*b\x:a\y=a\y*b\y:a\z=a\z*b\z:Return a:End Function
Function V3cross.TV3(a.TV3,b.TV3):Return NewV3(a\y*b\z-a\z*b\y, a\z*b\x-a\x*b\z, a\x*b\y-a\y*b\x):End Function
Function V3Dot#(a.TV3,b.TV3):Return a\x*b\x+a\y*b\y+a\z*b\z:End Function


; stores the EmitterDirection vector in @Result vector
; returns the time (as float) of the predicted collision
Function ExtrapolatedInTime#(Result.TV3, E.TV3,E_Velocity#, T.TV3,T_Dir.TV3,T_Velocity#)
	
	; ------------------------------------------------------------
	; from practice to theory then practice !
	; -&gt; also known as "the OMG Maths Theory"
	; ("OMG, I finally used a maths lesson for something real ?!")
	; ------------------------------------------------------------
	;
	; Ok, let's start with simple words to explain what the problem is 
	; and why it looks like a pain in the ass :
	; * We have a Target Origin point and its Velocity (Norm and direction)
	; * We have an Emitter Origin point and only the norm of the velocity
	; -&gt; we're looking for its direction, wich one is given in a relation along the time !
	;
	; to find it, we'll have to find the extrapolated "collision" point in time
	; where PositionT + velocityT*time = PositionE + velocityE*time
	; 
	; so we're actually searching the time "t" when the collision occure
	; if we find t, we find the collision point, and so we have a direction :)
	;
	;   ------------------------------------
	;   * We're looking for the value of t *
	;   ------------------------------------
	;    in linear algebra, we'll have two segment with simple equation (Start + t.Direction)
	;    such as they meet at the collision point.
	;    So : StartE + t.DirectionE = StartT + t.DirectionT
	;      if we use the variables available, what we have is :
	;      - StartE, StartT, DirectionT and only Norm Of DirectionE
	;      in a 3D space coordinate system, a direction means :
	;      a vector of 3 dimension + the norm (ie : the length of the vector)
	;      in term of equation, we have 4 variables per vector, and 3 variables for point
	;      now, let's assume our equation :
	;      StartE(3 var) + t(1var).DirE(4var) = StartT(3var) + t.DirT(4 var)
	;      we know StartE, StartT, DirT and 1 var of DirE
	;      that means we have already 11 variables on the 15
	;      the big deal is Here ! we miss 4 variables, and we only have 3 equations
	;      (one for each axis x,y,z)
	;      Then, this is mathematically not possible to solve the problem.
	;      
	;      BUT !
	;      If we look deeper in the expected behavior, we can see that the collision point
	;      is the intersection of the segment T+DirT.t and the Sphere wich has Emitter coordinates for center
	;      and a radius of EmitterVelocity*t
	;      This is what we will use to solve the problem !
	;      
	;   ---------------
	;   * 2 equations *
	;   ---------------
	;      Let's call : 
	;       C {Cx,Cy,Cz} the intersection point
	;       T {Tx,Ty,Tz} the Target point
	;       I {Ix,Iy,Iz} the Target vector * target velocity
	;       E {Ex,Ey,Ez} the Emitter point
	;       J {Jx,Jy,Jz} the Emitter vector * emitter velocity (so it is not a normalized vector !!!)
	;       Ev the Velocity Norm of the emitter
	;       -
	;       t the Time variable
	;      -&gt; the linear part
	;        (1) : Cx = Tx + t.Ix
	;        (2) : Cy = Ty + t.Iy
	;        (3) : Cz = Tz + t.Iz
	;        (4) : Cx = Ex + t.Jx
	;        (5) : Cy = Ey + t.Jy
	;        (6) : Cz = Ez + t.Jz
	;      -&gt; the sphere equation (formula : X²+Y²+Z²=R²)
	;        (7) : (t.Jx)²+(t.Jy)²+(t.Jz)² = (t.Ev)²
	;        
	;      easy to conclude :
	;        (1) = (4), (2) = (5), (3) = (6)
	;      then try some permutation (I demonstrate for X axis, Y and Z work the same)
	;        t.Jx = (Ex + t.Jx) - Ex
	;        t.Jx = Cx - Ex
	;        t.Jx = (Tx + t.Ix) - Ex
	;        t.Jx = (Tx-Ex + t.Ix)
	;        (t.Jx)² = (Tx-Ex + t.Ix)²
	;      Now, we use our (t.Jx)², (t.Jy)² etc ... in the sphere equation
	;        (Tx-Ex + t.Ix)² + (Ty-Ey + t.Iy)² + (Tz-Ez + t.Iz)² = (t.Ev)²
	;      
	;      let's develop the first argument
	;         (Tx-Ex + t.Ix) * (Tx-Ex + t.Ix)
	;         Tx² - Tx.Ex + t.Tx.Ix - Tx.Ex + Ex² -t.Ex.Ix + t.Tx.Ix - t.Ex.Ix + t².Ix²
	;         Tx²+Ex² - 2.Tx.Ex + t.2.(Tx.Ix-Ex.Ix) + t².Ix²
	;      doing the same for y and Z part will give a loooong development that can be simplified like this :
	;         (Tx²+Ty²+Tz² + Ex²+Ey²+Ez²) - 2.(Tx.Ex+Ty.Ey+Tz.Ez) + t.2.( Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz) + t².(Ix²+Iy²+Iz²) = t².Ev²
	;         
	;      we order the equation by degree (t².A + t.B + C = 0)
	;         t².(Ix²+Iy²+Iz²-Ev²) + t.2.( Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz) + ((Tx²+Ty²+Tz² + Ex²+Ey²+Ez²) - 2.(Tx.Ex+Ty.Ey+Tz.Ez)) = 0
	;      Ok, now, what do we have here ?
	;      Let's call :
	;         a# = Ix²+Iy²+Iz²-Ev²
	;         b# = 2*(Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz)
	;         c# = Tx²+Ty²+Tz² - 2.(Tx.Ex+Ty.Ey+Tz.Ez) + Ex²+Ey²+Ez²
	;         now, if you have a loof at c, you 'll notice the A² + B² - 2.A.B
	;       &gt; c# = (Tx-Ex)² + (Ty-Ey)² + (Tz-Ez)²
	;          
	;      We can finally write our equation easier :
	;         a.t² + b.t + c = 0
	;         and that is a canonical expression for a polynomial degree 2 equation
	;         that can be solved using the Discriminant method !
	;         
	; ---------------------------------------
	; * Then it's time for us to solve this *
	; ---------------------------------------
	; 
	;    to solve the problem, we use the discriminant method
	;         Delta = b²-4.a.c
	;    and according to Delta, we'll deal with the results
	;    
	;************************************************
	;      
	;    If Delta&gt;0 then 2 results :
	;         
	;              - b - sqr(Delta)
	;         x1 = ________________
	;                     2.a
	;    
	;              - b + sqr(Delta)
	;         x2 = ________________
	;                     2.a
	;         
	;         but, as we only need one answer, just remember that "t" is a time factor
	;         and we are not trying to find what "happened" but what "will happen" :)
	;         Sooooo, t&gt;0 !
	;         --&gt;  t = x1 : if t&lt;=0 then t=x2
	;         
	;    if Delta=0 then 
	; 
	;                  b
	;         t   = - ___
	;                 2.a
	;
	;    if Delta&lt;0 then : No result !
	;    
	;************************************************
	;    
	; ----------------------------------------
	; * And finally, back to the pratice !!! *
	; ----------------------------------------
	;    
	;    we'll use the values found to calculate the collision point
	;    Cx = Targetx + t.velocityX.velocity
	;    Cy = Targety + t.velocityY.velocity
	;    Cz = Targetz + t.velocityZ.velocity
	;    
	;    now, we can find the vector from emitter to collision point
	;    Evx = Cx - Ex
	;    Evy = Cy - Ey
	;    Evz = Cz - Ez
	;    and remember, a direction is Normalized !
	;    |Ev| = sqr(Evx*Evx + Evy*Evy + Evz*Evz)
	;    Evx = Evx / |Ev|
	;    Evy = Evy / |Ev|
	;    Evz = Evz / |Ev|
	;    
	;************************************************
	; 
	;                  **************
	;                  * Tadaaaaa ! *
	;                  **************
	;
	;************************************************
	
	Local In# = T_Velocity/Sqr(T_Dir\x*T_Dir\x+T_Dir\y*T_Dir\y+T_Dir\z*T_Dir\z)
	Local Ix# = T_Dir\x*In, Iy# = T_Dir\y*In, Iz# = T_Dir\z*In
	Local a# = Ix*Ix+Iy*Iy+Iz*Iz - E_Velocity*E_Velocity
	Local b# = + Float(2.0)*( (T\x-E\x)*Ix + (T\y-E\y)*Iy + (T\z-E\z)*Iz )
	Local c# = ((T\x-E\x)*(T\x-E\x)+(T\y-E\y)*(T\y-E\y)+(T\z-E\z)*(T\z-E\z))
	
	Local Det# = b*b-4.0*a*c
	Local time#=0.0
	; Delta &lt;0 probably means the occlusion has already occured and the target move too fast for the emitter
	If Det&lt;0 Then Return -1
	If Det&gt;0
		Det=Sqr(Det)
		time = -0.5*(b-Det)/a
		If time&lt;0 Then time=-0.5*(b+Det)/a
	Else
		time = -0.5*b/a
	EndIf
	
	Result\x = T\x + time * Ix - E\x
	Result\y = T\y + time * Iy - E\y
	Result\z = T\z + time * Iz - E\z
	
	; normalize the result
	Local n# = 1.0/Sqr(Result\x*Result\x+Result\y*Result\y+Result\z*Result\z)
	Result\x = Result\x * n
	Result\y = Result\y * n
	Result\z = Result\z * n
	
	; return the time of the future collision
	Return time
	
End Function








Type TShip
	Field p.TV3
	Field d.TV3
	Field v#
End Type

Function NewShip.TShip(x#,y#,vx#,vy#,v#)
	Local s.TShip = New TShip
	s\p = NewV3(x,y,0)
	s\d = V3normalize(NewV3(vx,vy,0))
	s\v = v
	Return s
End Function

Function FreeShip(s.TShip)
	Delete s\p
	Delete s\d
	Delete s
End Function

Function MouseOverShip.TShip()
	Local x=MouseX(),y=MouseY(), s.TShip
	For s = Each TShip
		If RectsOverlap(x,y,1,1,s\p\x-7,s\p\y-7,15,15) Then Return s
	Next
	Return Null
End Function

Function UpdateShips()
	Local s.TShip, nc
	Local temp.TV3 = NewV3(0,0,0)
	For s=Each TShip
		V3Add(s\p,V3mulScalar(V3Assign(temp,s\d),s\v))
		If s\p\x&lt;=0 Then s\p\x=GraphicsWidth()-Ceil(s\v)
		If s\p\y&lt;=0 Then s\p\y=GraphicsHeight()-Ceil(s\v)
		If s\p\x&gt;=GraphicsWidth() Then s\p\x=Ceil(s\v)
		If s\p\y&gt;=GraphicsHeight() Then s\p\y=Ceil(s\v)
		nc=nc+1
	Next
	If nc&lt;5 Then NewShip(Rand(5,GraphicsWidth()),Rand(5,GraphicsHeight()),Rnd(-2,2),Rnd(-2,2), Rnd(1.5,3.0))
	Delete temp
End Function

Function DrawShips()
	Local s.TShip
	For s = Each TShip
		Color 0,255,100
		Oval s\p\x-6,s\p\y-6,13,13,1
		Color 0,255,255
		Line s\p\x,s\p\y, s\p\x+s\d\x*s\v, s\p\y+s\d\y*s\v
		Oval s\p\x+s\d\x*s\v*8-2, s\p\y+s\d\y*s\v*8-2,5,5,0
	Next
End Function



Type TMissile
	Field p.TV3
	Field d.TV3
	Field v#
	Field t.TShip
End Type

Function NewMissile.TMissile(pos.TV3,v#=1.0)
	Local m.TMissile = New TMissile
	m\p=V3Copy(pos)
	m\d=NewV3(0,1,0)
	m\v=v
	Return m
End Function

Function FreeMissile(m.TMissile)
	Delete m\p
	Delete m\d
	Delete m
End Function

Function SetMissileTarget(m.TMissile, t.TShip)
	m\t=t : ExtrapolatedInTime(m\d,m\p,m\v,t\p,t\d,t\v)
End Function

Function UpdateMissiles()
	Local m.TMissile
	Local temp.TV3 = NewV3(0,0,0)
	For m=Each TMissile
		V3Add(m\p,V3mulScalar(V3Assign(temp,m\d),m\v))
		If m\t&lt;&gt;Null
			; target reached
			If V3Norm(V3Sub(V3Assign(temp,m\t\p),m\p))&lt;=m\v
				FreeShip(m\t)
				FreeMissile(m)
				;m=Null
			Else
				If Not(RectsOverlap(0,0,GraphicsWidth(),GraphicsHeight(),m\p\x,m\p\y,1,1))
					; may happen if a ship as been repositionned while touching the screen borders
					FreeMissile(m)
					;m=Null
				EndIf
			EndIf
		Else
		; no target ? no reason to live ... whatever, it will Die when touching the border screen ^.^ !
		EndIf
	Next
	Delete temp
End Function

Function DrawMissiles()
	Local m.TMissile
	For m=Each TMissile
		Color 255,000,000
		Oval m\p\x-1,m\p\y-1,3,3,1
		Line m\p\x,m\p\y,m\p\x-m\d\x*m\v,m\p\y-m\d\y*m\v
	Next
End Function



Graphics 800,600,0,2
SetBuffer BackBuffer()

; Missile Emitter
Local Ep.TV3 = NewV3(400,590,0)

Local missile.TMissile = Null

Repeat
	Delay 20
	Cls
	
	; launch a missile on mousehit (with random velocity)
	If MouseHit(1)
		Local ship.TShip=MouseOverShip()
		If ship&lt;&gt;Null
			; start missile at emitter pos and last computed direction
			missile = NewMissile(Ep,Rnd(6.0,15.0))
			SetMissileTarget(missile,ship)
		EndIf
	EndIf
	
	UpdateShips()
	UpdateMissiles()
	
	DrawShips()
	DrawMissiles()
	
	; draw emitter 
	Color 000,128,255:Rect Ep\x-2,Ep\y-2,5,5,1
	
	Delay 16
	Flip True
	
Until KeyDown(1)
WaitKey
End
</textarea><br><br><br>I just hope the maths tutorial is explicit enough. <br><br></td></tr></table><br>
<a name="1179623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bobysait&gt;&gt;Nice example, this can probably be useful for others things. Thanks. <br><br></td></tr></table><br>
<a name="1179634"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bobysait:<br><br>Definitely one for the code archives.  Both yours and Stevie's.  If you do, you might want to put a quick comment line on each of those functions at the top; they are clearly very useful general game functions that people should know about.<br><br>I've, um, modified it a bit to create a simple game; I hope you don't mind.  Here the player is the ship, and tries to avoid the random missiles.  The missile might target the ship's eventual position (as we've been discussing) or a 50% chance of picking anywhere between that point and the current point, so slowing down won't necessarily help.  I've lasted 58 seconds so far; can you do better?<br><br>It starts slow but it ramps up a bit!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TV3 Field x#,y#,z# End Type
Function NewV3.TV3(x#=0.0,y#=0.0,z#=0.0):Local v.TV3=New TV3:v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3Assign.TV3(v.TV3,src.TV3):v\x=src\x:v\y=src\y:v\z=src\z:Return v:End Function
Function V3Copy.TV3(src.TV3):Return V3Assign(NewV3(),src):End Function
Function V3set.TV3(v.TV3,x#,y#,z#):v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3normalize.TV3(v.TV3):Local n#=Float(1.0)/Sqr(v\x*v\x+v\y*v\y+v\z*v\z):v\x=v\x*n:v\y=v\y*n:v\z=v\z*n:Return v:End Function
Function V3Add.TV3(v1.TV3,v2.TV3):v1\x=v1\x+v2\x:v1\y=v1\y+v2\y:v1\z=v1\z+v2\z:Return v1:End Function
Function V3Sub.TV3(v1.TV3,v2.TV3):v1\x=v1\x-v2\x:v1\y=v1\y-v2\y:v1\z=v1\z-v2\z:Return v1:End Function
Function V3Negate.TV3(v.TV3):v\x=-v\x:v\y=-v\y:v\z=-v\z:Return v:End Function
Function V3mulScalar.TV3(v.TV3,s#):v\x=v\x*s:v\y=v\y*s:v\z=v\z*s:Return v:End Function
Function V3Norm#(v.TV3):Return Sqr(v\x*v\x+v\y*v\y+v\z*v\z):End Function
Function V3Norm2#(v.TV3):Return v\x*v\x+v\y*v\y+v\z*v\z:End Function
Function V3Mul.TV3(a.TV3,b.TV3):a\x=a\x*b\x:a\y=a\y*b\y:a\z=a\z*b\z:Return a:End Function
Function V3cross.TV3(a.TV3,b.TV3):Return NewV3(a\y*b\z-a\z*b\y, a\z*b\x-a\x*b\z, a\x*b\y-a\y*b\x):End Function
Function V3Dot#(a.TV3,b.TV3):Return a\x*b\x+a\y*b\y+a\z*b\z:End Function
	
	
; stores the EmitterDirection vector in @Result vector
; returns the time (as float) of the predicted collision
Function ExtrapolatedInTime#(Result.TV3, E.TV3,E_Velocity#, T.TV3,T_Dir.TV3,T_Velocity#)
	
	; ------------------------------------------------------------
	; from practice to theory then practice !
	; -&gt; also known as "the OMG Maths Theory"
	; ("OMG, I finally used a maths lesson for something real ?!")
	; ------------------------------------------------------------
	;
	; Ok, let's start with simple words to explain what the problem is 
	; and why it looks like a pain in the ass :
	; * We have a Target Origin point and its Velocity (Norm and direction)
	; * We have an Emitter Origin point and only the norm of the velocity
	; -&gt; we're looking for its direction, wich one is given in a relation along the time !
	;
	; to find it, we'll have to find the extrapolated "collision" point in time
	; where PositionT + velocityT*time = PositionE + velocityE*time
	; 
	; so we're actually searching the time "t" when the collision occure
	; if we find t, we find the collision point, and so we have a direction :)
	;
	;   ------------------------------------
	;   * We're looking for the value of t *
	;   ------------------------------------
	;    in linear algebra, we'll have two segment with simple equation (Start + t.Direction)
	;    such as they meet at the collision point.
	;    So : StartE + t.DirectionE = StartT + t.DirectionT
	;      if we use the variables available, what we have is :
	;      - StartE, StartT, DirectionT and only Norm Of DirectionE
	;      in a 3D space coordinate system, a direction means :
	;      a vector of 3 dimension + the norm (ie : the length of the vector)
	;      in term of equation, we have 4 variables per vector, and 3 variables for point
	;      now, let's assume our equation :
	;      StartE(3 var) + t(1var).DirE(4var) = StartT(3var) + t.DirT(4 var)
	;      we know StartE, StartT, DirT and 1 var of DirE
	;      that means we have already 11 variables on the 15
	;      the big deal is Here ! we miss 4 variables, and we only have 3 equations
	;      (one for each axis x,y,z)
	;      Then, this is mathematically not possible to solve the problem.
	;      
	;      BUT !
	;      If we look deeper in the expected behavior, we can see that the collision point
	;      is the intersection of the segment T+DirT.t and the Sphere wich has Emitter coordinates for center
	;      and a radius of EmitterVelocity*t
	;      This is what we will use to solve the problem !
	;      
	;   ---------------
	;   * 2 equations *
	;   ---------------
	;      Let's call : 
	;       C {Cx,Cy,Cz} the intersection point
	;       T {Tx,Ty,Tz} the Target point
	;       I {Ix,Iy,Iz} the Target vector * target velocity
	;       E {Ex,Ey,Ez} the Emitter point
	;       J {Jx,Jy,Jz} the Emitter vector * emitter velocity (so it is not a normalized vector !!!)
	;       Ev the Velocity Norm of the emitter
	;       -
	;       t the Time variable
	;      -&gt; the linear part
	;        (1) : Cx = Tx + t.Ix
	;        (2) : Cy = Ty + t.Iy
	;        (3) : Cz = Tz + t.Iz
	;        (4) : Cx = Ex + t.Jx
	;        (5) : Cy = Ey + t.Jy
	;        (6) : Cz = Ez + t.Jz
	;      -&gt; the sphere equation (formula : X²+Y²+Z²=R²)
	;        (7) : (t.Jx)²+(t.Jy)²+(t.Jz)² = (t.Ev)²
	;        
	;      easy to conclude :
	;        (1) = (4), (2) = (5), (3) = (6)
	;      then try some permutation (I demonstrate for X axis, Y and Z work the same)
	;        t.Jx = (Ex + t.Jx) - Ex
	;        t.Jx = Cx - Ex
	;        t.Jx = (Tx + t.Ix) - Ex
	;        t.Jx = (Tx-Ex + t.Ix)
	;        (t.Jx)² = (Tx-Ex + t.Ix)²
	;      Now, we use our (t.Jx)², (t.Jy)² etc ... in the sphere equation
	;        (Tx-Ex + t.Ix)² + (Ty-Ey + t.Iy)² + (Tz-Ez + t.Iz)² = (t.Ev)²
	;      
	;      let's develop the first argument
	;         (Tx-Ex + t.Ix) * (Tx-Ex + t.Ix)
	;         Tx² - Tx.Ex + t.Tx.Ix - Tx.Ex + Ex² -t.Ex.Ix + t.Tx.Ix - t.Ex.Ix + t².Ix²
	;         Tx²+Ex² - 2.Tx.Ex + t.2.(Tx.Ix-Ex.Ix) + t².Ix²
	;      doing the same for y and Z part will give a loooong development that can be simplified like this :
	;         (Tx²+Ty²+Tz² + Ex²+Ey²+Ez²) - 2.(Tx.Ex+Ty.Ey+Tz.Ez) + t.2.( Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz) + t².(Ix²+Iy²+Iz²) = t².Ev²
	;         
	;      we order the equation by degree (t².A + t.B + C = 0)
	;         t².(Ix²+Iy²+Iz²-Ev²) + t.2.( Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz) + ((Tx²+Ty²+Tz² + Ex²+Ey²+Ez²) - 2.(Tx.Ex+Ty.Ey+Tz.Ez)) = 0
	;      Ok, now, what do we have here ?
	;      Let's call :
	;         a# = Ix²+Iy²+Iz²-Ev²
	;         b# = 2*(Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz)
	;         c# = Tx²+Ty²+Tz² - 2.(Tx.Ex+Ty.Ey+Tz.Ez) + Ex²+Ey²+Ez²
	;         now, if you have a loof at c, you 'll notice the A² + B² - 2.A.B
	;       &gt; c# = (Tx-Ex)² + (Ty-Ey)² + (Tz-Ez)²
	;          
	;      We can finally write our equation easier :
	;         a.t² + b.t + c = 0
	;         and that is a canonical expression for a polynomial degree 2 equation
	;         that can be solved using the Discriminant method !
	;         
	; ---------------------------------------
	; * Then it's time for us to solve this *
	; ---------------------------------------
	; 
	;    to solve the problem, we use the discriminant method
	;         Delta = b²-4.a.c
	;    and according to Delta, we'll deal with the results
	;    
	;************************************************
	;      
	;    If Delta&gt;0 then 2 results :
	;         
	;              - b - sqr(Delta)
	;         x1 = ________________
	;                     2.a
	;    
	;              - b + sqr(Delta)
	;         x2 = ________________
	;                     2.a
	;         
	;         but, as we only need one answer, just remember that "t" is a time factor
	;         and we are not trying to find what "happened" but what "will happen" :)
	;         Sooooo, t&gt;0 !
	;         --&gt;  t = x1 : if t&lt;=0 then t=x2
	;         
	;    if Delta=0 then 
	; 
	;                  b
	;         t   = - ___
	;                 2.a
	;
	;    if Delta&lt;0 then : No result !
	;    
	;************************************************
	;    
	; ----------------------------------------
	; * And finally, back to the pratice !!! *
	; ----------------------------------------
	;    
	;    we'll use the values found to calculate the collision point
	;    Cx = Targetx + t.velocityX.velocity
	;    Cy = Targety + t.velocityY.velocity
	;    Cz = Targetz + t.velocityZ.velocity
	;    
	;    now, we can find the vector from emitter to collision point
	;    Evx = Cx - Ex
	;    Evy = Cy - Ey
	;    Evz = Cz - Ez
	;    and remember, a direction is Normalized !
	;    |Ev| = sqr(Evx*Evx + Evy*Evy + Evz*Evz)
	;    Evx = Evx / |Ev|
	;    Evy = Evy / |Ev|
	;    Evz = Evz / |Ev|
	;    
	;************************************************
	; 
	;                  **************
	;                  * Tadaaaaa ! *
	;                  **************
	;
	;************************************************
	
	Local In# = T_Velocity/Sqr(T_Dir\x*T_Dir\x+T_Dir\y*T_Dir\y+T_Dir\z*T_Dir\z)
	Local Ix# = T_Dir\x*In, Iy# = T_Dir\y*In, Iz# = T_Dir\z*In
	Local a# = Ix*Ix+Iy*Iy+Iz*Iz - E_Velocity*E_Velocity
	Local b# = + Float(2.0)*( (T\x-E\x)*Ix + (T\y-E\y)*Iy + (T\z-E\z)*Iz )
	Local c# = ((T\x-E\x)*(T\x-E\x)+(T\y-E\y)*(T\y-E\y)+(T\z-E\z)*(T\z-E\z))
	
	Local Det# = b*b-4.0*a*c
	Local time#=0.0
	; Delta &lt;0 probably means the occlusion has already occured and the target move too fast for the emitter
	If Det&lt;0 Then Return -1
	If Det&gt;0
		Det=Sqr(Det)
		time = -0.5*(b-Det)/a
		If time&lt;0 Then time=-0.5*(b+Det)/a
	Else
		time = -0.5*b/a
	EndIf
	
	Result\x = T\x + time * Ix - E\x
	Result\y = T\y + time * Iy - E\y
	Result\z = T\z + time * Iz - E\z
	
	; normalize the result
	Local n# = 1.0/Sqr(Result\x*Result\x+Result\y*Result\y+Result\z*Result\z)
	Result\x = Result\x * n
	Result\y = Result\y * n
	Result\z = Result\z * n
	
	; return the time of the future collision
	Return time
	
End Function





Function UpdatePlayer()
	Local ts.TShip=First TShip
	Local nv3.TV3
	Local mx#,my#
	
	If ts&lt;&gt;Null
		Delete(ts\d) ; Get rid of the old ship direction vector
		mx=MouseX()-ts\p\x ; Relative mouse x
		my=MouseY()-ts\p\y ; Relative mouse y
		
		ts\d=V3normalize(NewV3(mx,my,0)) ; Create a new direction vector based on the mouse angle to the ship
		ts\v=Sqr(mx*mx+my*my)/10.0 ; Speed based on distance of mouse from ship
		If ts\v&gt;6 Then ts\v=6 ; Max speed
		
	EndIf
End Function


Type TShip
	Field p.TV3
	Field d.TV3
	Field v#
End Type

Function NewShip.TShip(x#,y#,vx#,vy#,v#)
	Local s.TShip = New TShip
	s\p = NewV3(x,y,0)
	s\d = V3normalize(NewV3(vx,vy,0))
	s\v = v
	Return s
End Function

Function FreeShip(s.TShip)
	Delete s\p
	Delete s\d
	Delete s
End Function

Function MouseOverShip.TShip()
	Local x=MouseX(),y=MouseY(), s.TShip
	For s = Each TShip
		If RectsOverlap(x,y,1,1,s\p\x-7,s\p\y-7,15,15) Then Return s
	Next
	Return Null
End Function

Function UpdateShips()
	Local s.TShip, nc
	Local temp.TV3 = NewV3(0,0,0)
	For s=Each TShip
		V3Add(s\p,V3mulScalar(V3Assign(temp,s\d),s\v))
		If s\p\x&lt;=0 Then s\p\x=GraphicsWidth()-Ceil(s\v)
		If s\p\y&lt;=0 Then s\p\y=GraphicsHeight()-Ceil(s\v)
		If s\p\x&gt;=GraphicsWidth() Then s\p\x=Ceil(s\v)
		If s\p\y&gt;=GraphicsHeight() Then s\p\y=Ceil(s\v)
		nc=nc+1
	Next
	If nc&lt;1 Then NewShip(Rand(5,GraphicsWidth()),Rand(5,GraphicsHeight()),Rnd(-2,2),Rnd(-2,2), 3);Rnd(1.5,3.0))
	Delete temp
End Function

Function DrawShips()
	Local s.TShip
	For s = Each TShip
		Color 0,255,100
		Oval s\p\x-6,s\p\y-6,13,13,1
		Color 0,255,255
		Line s\p\x,s\p\y, s\p\x+s\d\x*s\v, s\p\y+s\d\y*s\v
		Oval s\p\x+s\d\x*s\v*8-2, s\p\y+s\d\y*s\v*8-2,5,5,0
	Next
End Function



Type TMissile
	Field p.TV3
	Field d.TV3
	Field v#
	Field t.TShip
End Type

Function NewMissile.TMissile(pos.TV3,v#=1.0)
	Local m.TMissile = New TMissile
	m\p=V3Copy(pos)
	m\d=NewV3(0,1,0)
	m\v=v
	Return m
End Function

Function FreeMissile(m.TMissile)
	Delete m\p
	Delete m\d
	Delete m
End Function

Function SetMissileTarget(m.TMissile, t.TShip)
	m\t=t 
	If Rnd(1)&lt;.5
		ExtrapolatedInTime(m\d,m\p,m\v,t\p,t\d,Rnd(t\v));t\v)
	Else
		ExtrapolatedInTime(m\d,m\p,m\v,t\p,t\d,t\v)
	EndIf
End Function

Function UpdateMissiles()
	Local m.TMissile
	Local temp.TV3 = NewV3(0,0,0)
	For m=Each TMissile
		V3Add(m\p,V3mulScalar(V3Assign(temp,m\d),m\v))
		If m\t&lt;&gt;Null
			; target reached
			If V3Norm(V3Sub(V3Assign(temp,m\t\p),m\p))&lt;=m\v
				FreeShip(m\t)
				FreeMissile(m)
				Local endTime=MilliSecs()
				
				While Not KeyHit(1)
					Text(0,0,Float(endTime-startTime)/1000.0)
					Text(0,50,"Bang.  Press Esc to exit.")
					Flip()	
				Wend
				
				
				;m=Null
			Else
				If Not(RectsOverlap(0,0,GraphicsWidth(),GraphicsHeight(),m\p\x,m\p\y,1,1))
					; may happen if a ship as been repositionned while touching the screen borders
					FreeMissile(m)
					;m=Null
				EndIf
			EndIf
		Else
		; no target ? no reason to live ... whatever, it will Die when touching the border screen ^.^ !
		EndIf
	Next
	Delete temp
End Function

Function DrawMissiles()
	Local m.TMissile
	For m=Each TMissile
		Color 255,000,000
		Oval m\p\x-1,m\p\y-1,3,3,1
		Line m\p\x,m\p\y,m\p\x-m\d\x*m\v,m\p\y-m\d\y*m\v
	Next
End Function



Graphics 800,600,0,2
SetBuffer BackBuffer()

; Missile Emitter
Local Ep.TV3 = NewV3(400,590,0)

Local missile.TMissile = Null

Local myFont=LoadFont("Arial",30)
SetFont(myFont)
;FreeFont(myFont)
Global startTime=MilliSecs() ; Game score
Global frameTime=16 ; ms per frame
Global lastFrame=MilliSecs() ; time of previous frame
Global thisFrame ; set to millisecs at end of frame

Repeat
	;Delay 20
	Cls
	
	; launch a missile on mousehit (with random velocity)
;	If MouseHit(1)
;		Local ship.TShip=MouseOverShip()
;		If ship&lt;&gt;Null
;			; start missile at emitter pos and last computed direction
;			missile = NewMissile(Ep,Rnd(6.0,15.0))
;			SetMissileTarget(missile,ship)
;		EndIf
;	EndIf
	
	UpdatePlayer()
	fireProb#=fireProb#+.0001
	If Rnd(1)&lt;fireProb#
		ship.TShip=First TShip
		If ship&lt;&gt;Null
			missile=NewMissile(Ep,Rnd(3.0,9.0));Rnd(6.0,15.0))
			SetMissileTarget(missile,ship)
		EndIf
	EndIf
	
	
	UpdateShips()
	UpdateMissiles()
	
	DrawShips()
	DrawMissiles()
	
	; draw emitter 
	Color 000,128,255:Rect Ep\x-2,Ep\y-2,5,5,1
	Text(0,0,Float(MilliSecs()-startTime)/1000.0)
	
	Flip True
	
Until KeyDown(1)
WaitKey
End
</textarea> <br><br></td></tr></table><br>
<a name="1179635"></a>

<a name="1179645"></a>

<a name="1179646"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I probably will post it on code-archive section when I'll have time to do it "well"<br><br>Nice try with your mini-game, glad my code has already found its place in this poor world ;)<br><br><br><br><br><br>[edit]<br><br>I modified the "demo". have Fun<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type TV3 Field x#,y#,z# End Type
Function NewV3.TV3(x#=0.0,y#=0.0,z#=0.0):Local v.TV3=New TV3:v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3Assign.TV3(v.TV3,src.TV3):v\x=src\x:v\y=src\y:v\z=src\z:Return v:End Function
Function V3Copy.TV3(src.TV3):Return V3Assign(NewV3(),src):End Function
Function V3set.TV3(v.TV3,x#,y#,z#):v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3normalize.TV3(v.TV3):Local n#=Float(1.0)/Sqr(v\x*v\x+v\y*v\y+v\z*v\z):v\x=v\x*n:v\y=v\y*n:v\z=v\z*n:Return v:End Function
Function V3Add.TV3(v1.TV3,v2.TV3):v1\x=v1\x+v2\x:v1\y=v1\y+v2\y:v1\z=v1\z+v2\z:Return v1:End Function
Function V3Sub.TV3(v1.TV3,v2.TV3):v1\x=v1\x-v2\x:v1\y=v1\y-v2\y:v1\z=v1\z-v2\z:Return v1:End Function
Function V3Negate.TV3(v.TV3):v\x=-v\x:v\y=-v\y:v\z=-v\z:Return v:End Function
Function V3mulScalar.TV3(v.TV3,s#):v\x=v\x*s:v\y=v\y*s:v\z=v\z*s:Return v:End Function
Function V3Norm#(v.TV3):Return Sqr(v\x*v\x+v\y*v\y+v\z*v\z):End Function
Function V3Norm2#(v.TV3):Return v\x*v\x+v\y*v\y+v\z*v\z:End Function
Function V3Mul.TV3(a.TV3,b.TV3):a\x=a\x*b\x:a\y=a\y*b\y:a\z=a\z*b\z:Return a:End Function
Function V3cross.TV3(a.TV3,b.TV3):Return NewV3(a\y*b\z-a\z*b\y, a\z*b\x-a\x*b\z, a\x*b\y-a\y*b\x):End Function
Function V3Dot#(a.TV3,b.TV3):Return a\x*b\x+a\y*b\y+a\z*b\z:End Function


; stores the EmitterDirection vector in @Result vector
; returns the time (as float) of the predicted collision
Function ExtrapolatedInTime#(Result.TV3, E.TV3,E_Velocity#, T.TV3,T_Dir.TV3,T_Velocity#)
	
	; ------------------------------------------------------------
	; from practice to theory then practice !
	; -&gt; also known as "the OMG Maths Theory"
	; ("OMG, I finally used a maths lesson for something real ?!")
	; ------------------------------------------------------------
	;
	; Ok, let's start with simple words to explain what the problem is 
	; and why it looks like a pain in the ass :
	; * We have a Target Origin point and its Velocity (Norm and direction)
	; * We have an Emitter Origin point and only the norm of the velocity
	; -&gt; we're looking for its direction, wich one is given in a relation along the time !
	;
	; to find it, we'll have to find the extrapolated "collision" point in time
	; where PositionT + velocityT*time = PositionE + velocityE*time
	; 
	; so we're actually searching the time "t" when the collision occure
	; if we find t, we find the collision point, and so we have a direction :)
	;
	;   ------------------------------------
	;   * We're looking for the value of t *
	;   ------------------------------------
	;    in linear algebra, we'll have two segment with simple equation (Start + t.Direction)
	;    such as they meet at the collision point.
	;    So : StartE + t.DirectionE = StartT + t.DirectionT
	;      if we use the variables available, what we have is :
	;      - StartE, StartT, DirectionT and only Norm Of DirectionE
	;      in a 3D space coordinate system, a direction means :
	;      a vector of 3 dimension + the norm (ie : the length of the vector)
	;      in term of equation, we have 4 variables per vector, and 3 variables for point
	;      now, let's assume our equation :
	;      StartE(3 var) + t(1var).DirE(4var) = StartT(3var) + t.DirT(4 var)
	;      we know StartE, StartT, DirT and 1 var of DirE
	;      that means we have already 11 variables on the 15
	;      the big deal is Here ! we miss 4 variables, and we only have 3 equations
	;      (one for each axis x,y,z)
	;      Then, this is mathematically not possible to solve the problem.
	;      
	;      BUT !
	;      If we look deeper in the expected behavior, we can see that the collision point
	;      is the intersection of the segment T+DirT.t and the Sphere wich has Emitter coordinates for center
	;      and a radius of EmitterVelocity*t
	;      This is what we will use to solve the problem !
	;      
	;   ---------------
	;   * 2 equations *
	;   ---------------
	;      Let's call : 
	;       C {Cx,Cy,Cz} the intersection point
	;       T {Tx,Ty,Tz} the Target point
	;       I {Ix,Iy,Iz} the Target vector * target velocity
	;       E {Ex,Ey,Ez} the Emitter point
	;       J {Jx,Jy,Jz} the Emitter vector * emitter velocity (so it is not a normalized vector !!!)
	;       Ev the Velocity Norm of the emitter
	;       -
	;       t the Time variable
	;      -&gt; the linear part
	;        (1) : Cx = Tx + t.Ix
	;        (2) : Cy = Ty + t.Iy
	;        (3) : Cz = Tz + t.Iz
	;        (4) : Cx = Ex + t.Jx
	;        (5) : Cy = Ey + t.Jy
	;        (6) : Cz = Ez + t.Jz
	;      -&gt; the sphere equation (formula : X²+Y²+Z²=R²)
	;        (7) : (t.Jx)²+(t.Jy)²+(t.Jz)² = (t.Ev)²
	;        
	;      easy to conclude :
	;        (1) = (4), (2) = (5), (3) = (6)
	;      then try some permutation (I demonstrate for X axis, Y and Z work the same)
	;        t.Jx = (Ex + t.Jx) - Ex
	;        t.Jx = Cx - Ex
	;        t.Jx = (Tx + t.Ix) - Ex
	;        t.Jx = (Tx-Ex + t.Ix)
	;        (t.Jx)² = (Tx-Ex + t.Ix)²
	;      Now, we use our (t.Jx)², (t.Jy)² etc ... in the sphere equation
	;        (Tx-Ex + t.Ix)² + (Ty-Ey + t.Iy)² + (Tz-Ez + t.Iz)² = (t.Ev)²
	;      
	;      let's develop the first argument
	;         (Tx-Ex + t.Ix) * (Tx-Ex + t.Ix)
	;         Tx² - Tx.Ex + t.Tx.Ix - Tx.Ex + Ex² -t.Ex.Ix + t.Tx.Ix - t.Ex.Ix + t².Ix²
	;         Tx²+Ex² - 2.Tx.Ex + t.2.(Tx.Ix-Ex.Ix) + t².Ix²
	;      doing the same for y and Z part will give a loooong development that can be simplified like this :
	;         (Tx²+Ty²+Tz² + Ex²+Ey²+Ez²) - 2.(Tx.Ex+Ty.Ey+Tz.Ez) + t.2.( Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz) + t².(Ix²+Iy²+Iz²) = t².Ev²
	;         
	;      we order the equation by degree (t².A + t.B + C = 0)
	;         t².(Ix²+Iy²+Iz²-Ev²) + t.2.( Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz) + ((Tx²+Ty²+Tz² + Ex²+Ey²+Ez²) - 2.(Tx.Ex+Ty.Ey+Tz.Ez)) = 0
	;      Ok, now, what do we have here ?
	;      Let's call :
	;         a# = Ix²+Iy²+Iz²-Ev²
	;         b# = 2*(Tx.Ix - Ex.Ix + Ty.Iy - Ey.Iy + Tz.Iz - Ez.Iz)
	;         c# = Tx²+Ty²+Tz² - 2.(Tx.Ex+Ty.Ey+Tz.Ez) + Ex²+Ey²+Ez²
	;         now, if you have a loof at c, you 'll notice the A² + B² - 2.A.B
	;       &gt; c# = (Tx-Ex)² + (Ty-Ey)² + (Tz-Ez)²
	;          
	;      We can finally write our equation easier :
	;         a.t² + b.t + c = 0
	;         and that is a canonical expression for a polynomial degree 2 equation
	;         that can be solved using the Discriminant method !
	;         
	; ---------------------------------------
	; * Then it's time for us to solve this *
	; ---------------------------------------
	; 
	;    to solve the problem, we use the discriminant method
	;         Delta = b²-4.a.c
	;    and according to Delta, we'll deal with the results
	;    
	;************************************************
	;      
	;    If Delta&gt;0 then 2 results :
	;         
	;              - b - sqr(Delta)
	;         x1 = ________________
	;                     2.a
	;    
	;              - b + sqr(Delta)
	;         x2 = ________________
	;                     2.a
	;         
	;         but, as we only need one answer, just remember that "t" is a time factor
	;         and we are not trying to find what "happened" but what "will happen" :)
	;         Sooooo, t&gt;0 !
	;         --&gt;  t = x1 : if t&lt;=0 then t=x2
	;         
	;    if Delta=0 then 
	; 
	;                  b
	;         t   = - ___
	;                 2.a
	;
	;    if Delta&lt;0 then : No result !
	;    
	;************************************************
	;    
	; ----------------------------------------
	; * And finally, back to the pratice !!! *
	; ----------------------------------------
	;    
	;    we'll use the values found to calculate the collision point
	;    Cx = Targetx + t.velocityX.velocity
	;    Cy = Targety + t.velocityY.velocity
	;    Cz = Targetz + t.velocityZ.velocity
	;    
	;    now, we can find the vector from emitter to collision point
	;    Evx = Cx - Ex
	;    Evy = Cy - Ey
	;    Evz = Cz - Ez
	;    and remember, a direction is Normalized !
	;    |Ev| = sqr(Evx*Evx + Evy*Evy + Evz*Evz)
	;    Evx = Evx / |Ev|
	;    Evy = Evy / |Ev|
	;    Evz = Evz / |Ev|
	;    
	;************************************************
	; 
	;                  **************
	;                  * Tadaaaaa ! *
	;                  **************
	;
	;************************************************
	
	Local In# = T_Velocity/Sqr(T_Dir\x*T_Dir\x+T_Dir\y*T_Dir\y+T_Dir\z*T_Dir\z)
	Local Ix# = T_Dir\x*In, Iy# = T_Dir\y*In, Iz# = T_Dir\z*In
	Local a# = Ix*Ix+Iy*Iy+Iz*Iz - E_Velocity*E_Velocity
	Local b# = + Float(2.0)*( (T\x-E\x)*Ix + (T\y-E\y)*Iy + (T\z-E\z)*Iz )
	Local c# = ((T\x-E\x)*(T\x-E\x)+(T\y-E\y)*(T\y-E\y)+(T\z-E\z)*(T\z-E\z))
	
	Local Det# = b*b-4.0*a*c
	Local time#=0.0
	; Delta &lt;0 probably means the occlusion has already occured and the target move too fast for the emitter
	If Det&lt;0 Then Return -1
	If Det&gt;0
		Det=Sqr(Det)
		time = -0.5*(b-Det)/a
		If time&lt;0 Then time=-0.5*(b+Det)/a
	Else
		time = -0.5*b/a
	EndIf
	
	Result\x = T\x + time * Ix - E\x
	Result\y = T\y + time * Iy - E\y
	Result\z = T\z + time * Iz - E\z
	
	DebugLog Result\z
	
	; normalize the result
	Local n# = 1.0/Sqr(Result\x*Result\x+Result\y*Result\y+Result\z*Result\z)
	Result\x = Result\x * n
	Result\y = Result\y * n
	Result\z = Result\z * n
	
	; return the time of the future collision
	Return time
	
End Function







Const GW# = 1280
Const GW2# = GW/2
Const GH# = 768
Const GH2# = GH/2


Type TShip
	Field ent
	Field p.TV3
	Field d.TV3
	Field v#
	Field Size#
End Type

Global gSHIP_MODEL = 0
Function InitShip()
	If gSHIP_MODEL&lt;&gt;0 Then Return
	gSHIP_MODEL = CreateSphere(7)
	Local s=GetSurface(gSHIP_MODEL,1), nv=CountVertices(s)-1,v
	Local x#=0.0,y#=0.0,z#=0.0
	Local Noise#=.3
	For v=0 To nv
		x=VertexX(s,v)
		y=VertexY(s,v)
		z=VertexZ(s,v)
		If Abs(y)&lt;.99
			y=y+VertexNX(s,v)*Rnd(-1,1)*Noise
			z=z+VertexNX(s,v)*Rnd(-1,1)*Noise
			If x&lt;&gt;0 Then x=x+VertexNX(s,v)*Rnd(-1,1)*Noise
		EndIf
		VertexCoords(s,v,x,y,z)
	Next
	ScaleMesh gSHIP_MODEL,1.8,1.9,2.0
	EntityColor gSHIP_MODEL,050,030,010
	HideEntity gSHIP_MODEL
End Function

Function NewShip.TShip(x#,y#,z#,vx#,vy#,vz#,v#)
	InitShip()
	Local s.TShip = New TShip
	s\ent = CopyEntity(gSHIP_MODEL)
	EntityColor s\ent,Rand(045,065),Rand(020,028),Rand(005,010)
	ShowEntity s\ent
	s\p = NewV3(x,y,z)
	s\d = V3normalize(NewV3(vx,vy,vz))
	s\v = v
	s\Size = Rnd(1.0,3.0)
	RotateEntity s\ent, Rand(180), Rand(180), Rand(180)
	ScaleEntity s\ent, s\Size*Rnd(.7,2.0), s\Size*Rnd(.7,2.0), s\Size*Rnd(.7,2.0)
	Return s
End Function

Function FreeShip(s.TShip)
	Delete s\p
	Delete s\d
	FreeEntity s\ent
	Delete s
End Function

Function MouseOverShip.TShip(Radius#=0)
	Local mx=CursorX,my=CursorY, s.TShip
	If Radius=0 Then Radius=2
	For s = Each TShip
		Local d# = 15*(GW-s\p\z)/GW:If d&lt;Radius Then d=Radius
		d=d*s\Size
		Local x# = GW2*(1.0+s\p\x/s\p\z)
		Local y# = GH2-GW2*s\p\y/s\p\z
		If RectsOverlap(x-d,y-d,d*2,d*2,mx,my,1,1) Then Return s
	Next
	Return Null
End Function

Function UpdateShips(speed#=1.0)
	Local s.TShip, nc
	; temp vector for fast calculation
	Local temp.TV3 = NewV3(0,0,0)
	For s=Each TShip
		; translate position -&gt; Pos = Pos + Dir * V [* ApplicationCoef=1.0]
		V3Add(s\p,V3mulScalar(V3Assign(temp,s\d),s\v*speed))
		; 3D -&gt; 2D conversion
		Local d#=s\p\z/GW2 ; depth coef
		; ships always on screen (wrap screen borders)
		Local x# = GW2+GW2*s\p\x/s\p\z
		Local y# = GH2-GW2*s\p\y/s\p\z
		
		If x&lt; 00 Then s\p\x=(GW2-20)*d:s\d\x=Rnd(-1,-.3)
		If x&gt;=GW Then s\p\x=(20-GW2)*d:s\d\x=Rnd(.3,+1)
		If y&lt; 00 Then s\p\y=(20-GH2)*d:s\d\y=Rnd(.3,+1)
		If y&gt;=GH Then s\p\y=(GH2-20)*d:s\d\y=Rnd(-1,-.3)
		V3normalize(s\d)
		; Not too far, not too near !
		If s\p\z&lt;100 Then s\p\z=100:s\d\z=+Abs(s\d\z) ; force forward
		If s\p\z&gt;GW2 Then s\p\z=GW2:s\d\z=-Abs(s\d\z) ; force backward
		nc=nc+1
		; position the 3D entity at the vector coordinates
		PositionEntity s\ent, s\p\x,s\p\y,s\p\z
	Next
	; preserve amount of ships on screen (actually, they are "asteroids" ...)
	If nc&lt;25
		Local z# = Rnd(GW2*.75,GW2*.99)
		Local v# = 1.0
		NewShip(Rnd(-.8,.8)*z,Rnd(-.6,.6)*z,z,Rnd(-2,2), Rnd(-2,2),Rnd(-2,2), Rnd(.5,1.0)*v)
	EndIf
	; release the temp vector
	Delete temp
End Function

Function DrawShips()
	Local s.TShip
	For s = Each TShip
		Color 000,255,100
		Local d# = 15*(GW-s\p\z)/GW * s\Size
		If d&lt;9
			If d&lt;3 Then d=3
			Local x# = GW2*(1.0+s\p\x/s\p\z)
			Local y# = GH2-GW2*s\p\y/s\p\z
			Rect x-1+0, y-d-2, 3,4,0
			Rect x-1+0, y+d+0, 3,4,0
			Rect x-d-2, y-1+0, 4,3,0
			Rect x+d-2, y-1+0, 4,3,0
		EndIf
	Next
End Function

Function DrawShipLocked(s.TShip,r=255,g=255,b=255)
	Local d# = s\Size*15*(GW-s\p\z)/GW:If d&lt;10 Then d=10
	Local x# = GW2*(1.0+s\p\x/s\p\z)
	Local y# = GH2-GW2*s\p\y/s\p\z
	Local w#=d
	Color w*r,w*g,w*b
	Local a1#=1.3*w
	Local a2#=1.1*w
	Local u
	For u=0 To 1
		Line x-a1,y-a1+u, x-a2,y-a1+u
		Line x+a2,y-a1+u, x+a1,y-a1+u
		Line x-a1,y+a1-u, x-a2,y+a1-u
		Line x+a2,y+a1-u, x+a1,y+a1-u
		
		Line x-a1+u,y-a1, x-a1+u,y-a2
		Line x-a1+u,y+a2, x-a1+u,y+a1
		Line x+a1-u,y-a1, x+a1-u,y-a2
		Line x+a1-u,y+a2, x+a1-u,y+a1
	Next
	Line x+d+2,y+d+5,x+d+15,y+d+10
	Line x+d+15,y+d+10,x+d+45,y+d+10
	Text x+d+20,y+d-5, s\p\z
End Function

Type TMissile
	Field ent
	Field p.TV3
	Field d.TV3
	Field v#
	Field t.TShip
End Type
Global gMISSILE_MODEL% = 0
Function InitMissile()
	If gMISSILE_MODEL&lt;&gt;0 Then Return
	gMISSILE_MODEL	=	CreateCylinder( 8, 1 )
						ScaleMesh	( gMISSILE_MODEL, .1,8,.1 )
						PositionMesh( gMISSILE_MODEL, 0,-.5,0 )
						RotateMesh	( gMISSILE_MODEL, 90,0,0 )
	Local BrushM	=	CreateBrush	( 255,040,010 )
						BrushFX		( BrushM, 1 )
						PaintMesh	( gMISSILE_MODEL, BrushM )
	Local BrushA	=	CreateBrush	( 255,50,0 )
						BrushAlpha	( BrushA, .25 )
						BrushFX		( BrushA, 0 )
						BrushBlend	( BrushA, 3 )
	For a = 1 To 3
		Local i# = Float(a)/3
		Local alpha	=	CopyMesh	( gMISSILE_MODEL )
						ScaleMesh	( alpha, 1.1+i*.5,1.1+i*.5,1.1+i*.5 )
						FlipMesh	( alpha )
						PaintMesh	( alpha, BrushA )
						AddMesh		( alpha, gMISSILE_MODEL )
						FreeEntity	( alpha )
	Next
	FreeBrush		( BrushA )
	FreeBrush		( BrushM )
	HideEntity		( gMISSILE_MODEL )
End Function

Function NewMissile.TMissile(pos.TV3,v#=1.0)
	InitMissile()
	Local m.TMissile = New TMissile
	m\ent=CopyEntity(gMISSILE_MODEL)
	ShowEntity m\ent
	m\p=V3Copy(pos)
	m\d=NewV3(0,1,0)
	AlignToVector m\ent, m\d\x,m\d\y,m\d\z,3,1
	m\v=v
	Return m
End Function

Function FreeMissile(m.TMissile)
	Delete m\p
	Delete m\d
	FreeEntity m\ent
	Delete m
End Function

Function SetMissileTarget(m.TMissile, t.TShip)
	m\t=t : ExtrapolatedInTime(m\d,m\p,m\v,t\p,t\d,t\v)
	AlignToVector m\ent, m\d\x,m\d\y,m\d\z,3,1
End Function

Function UpdateMissiles(speed#=1.0)
	Local m.TMissile
	Local temp.TV3 = NewV3(0,0,0)
	For m=Each TMissile
		
		; Remove missile not on screen or too far
		Local x# = GW2*(1.0+m\p\x/m\p\z)
		Local y# = GH2-GW2*m\p\y/m\p\z
		
		If (m\p\z&gt;GW2) Or (Not(RectsOverlap(0,0,GW,GH,x,y,1,1)))
			
			FreeMissile(m)
			
		Else
			
			V3Add(m\p,V3mulScalar(V3Assign(temp,m\d),m\v*VCoef))
			PositionEntity m\ent, m\p\x,m\p\y,m\p\z
			If m\t&lt;&gt;Null
				; target reached
				If V3Norm(V3Sub(V3Assign(temp,m\t\p),m\p))&lt;=(m\v+m\t\v)*speed
					FreeShip(m\t)
					FreeMissile(m)
				EndIf
			Else
			; may happen if a ship as been repositionned while touching the screen borders or already destroyed
			; no target = no reason to live ... whatever, it will Die when touching the border screen ^.^ !
			EndIf
			
		EndIf
		
	Next
	Delete temp
End Function

Function DrawMissiles()
	Local m.TMissile
	Local ScaleV0# = 100.0
	Local ScaleV1# = 3000.0
	Local ScaleT#  = 3000.0
	Local w#=1.0
	Local i#, a#
	For m=Each TMissile
		If m\t&lt;&gt;Null Then DrawShipLocked(m\t,255,150,000)
		If m\p\z&gt;100
			Local d# = m\p\z/GW2
			Local x# = GW2*(1.0+m\p\x/m\p\z)
			Local y# = GH2-GW2*m\p\y/m\p\z
			; show a circle if missile too small to be visible
			If m\p\z&gt;150 Then Color 255,200-d*200,000 : Oval x-4,y-4,1+8,1+8,0
			If m\t&lt;&gt;Null
				Line x+5,y+5,x+15,y+10
				Line x+15,y+10,x+45,y+10
				Text x+20,y-5,m\p\z
			Else
				Color 60,50-d,000
				Line x+5,y+5,x+15,y+10
				Line x+15,y+10,x+85,y+10
				Text x+20,y-5,"- TARGET LOST -"
			EndIf
		EndIf
	Next
End Function

Function CreateNebulaTex()
	Local w = 511
	Local h = 511
	Local NT = 50
	Local w0 = Float(w)/10
	Local w1 = Float(w)/3
	Local h0 = Float(h)/10
	Local h1 = Float(h)/3
	Local img = CreateTexture(w,h)
	Local cbuf = GraphicsBuffer()
	Local f#=10, noise=5
	SetBuffer TextureBuffer(img)
	LockBuffer()
		Local x = Rand(0,w)
		Local y = Rand(0,h)
		For n = 1 To NT
			x=(x+Rand(w/8,w/2))Mod(w)
			y=(y+Rand(w/8,w/3))Mod(h)
			Local sx = Rand(w0,w1)
			Local sy = Rand(h0,h1)
			Local x0 = x-sx:If x0&lt;0 Then x0=0
			Local x1 = x+sx:If x1&gt;w Then x1=w
			Local y0 = y-sy:If y0&lt;0 Then y0=0
			Local y1 = y+sy:If y1&gt;h Then y1=h
			Local s#
			Local i,j
			For j=y0 To y1
				For i=x0 To x1
					s=Sqr(Float((i-x)*(i-x))/(sx*sx)+Float((j-y)*(j-y))/(sy*sy))
					s=(1.0-s)*(1.0-s)
					If s&gt;0
						s=s*4
						p=ReadPixelFast(i,j)
						r=(p Shr(16) And $ff)+f*s+Rand(-noise,noise):If r&lt;0 Then r=0
						g=(p Shr(8) And $ff)+f*s+Rand(-noise,noise):If g&lt;0 Then g=0
						b=(p And $ff)+f*s+Rand(-noise,noise):If b&lt;0 Then b=0
					EndIf
					WritePixelFast i,j,r Shl(16)+g Shl(8)+b
				Next
			Next
		Next
	UnlockBuffer()
	SetBuffer cbuf
	Return img
End Function

Global gStellarMS%=0
Function DrawStellar()
	Local seed=RndSeed()
	SeedRnd(1)
	If gStellarMS=0 Then gStellarMS = MilliSecs()
	Local ms = ((MilliSecs()-gStellarMS) Mod(100000))/60
	Local w = GW
	Local h = GH
	Local px#=(Rand(w/8,w/2))Mod(w)
	Local py#=(Rand(w/8,w/3))Mod(h)
	For nstart= 1 To 400
		Local d#=Rnd(.2,.5)*3
		Color ((500*d)Mod(255))*d,((450*d)Mod(255))*d,((400*d)Mod(255))*d
		px=(px+Rand(w/30,w/5))Mod(w)
		py=(py+Rand(w/30,w/4))Mod(h)
		;Local px#=(Rnd(-.5,.5)*d*ms)
		;Local py#=(Rnd(-.5,.5)*d*ms)
		Plot px+Rnd(-.5,.5)*d*ms,py+Rnd(-.5,.5)*d*ms
		;Plot px+Rand(0,GraphicsWidth()),py+Rand(0,GraphicsHeight())
	Next
	SeedRnd(seed)
End Function



Global VCoef# = 1.0

Graphics3D GW,GH,0,2
SetBuffer BackBuffer()

Local fontS = LoadFont("tahoma", 14,1)
Local fontM = LoadFont("tahoma", 20,1)
Local fontB = LoadFont("tahoma", 35,1)

Local cam=CreateCamera	( )
		CameraFogRange	( cam, GW2*.25,GW2*.9 )
		CameraFogColor	( cam, 1,2,30 )
		CameraFogMode	( cam, 1 )
Local tex1=CreateNebulaTex()
Local tex2=CreateNebulaTex():TextureBlend(tex2,2)
Local back1 = CreateSprite(cam)
		MoveEntity		( back1, 0,0,2 )
		ScaleSprite		( back1, 3,3 )
		EntityFX		( back1, 1+8 )
		EntityAlpha		( back1, .4 )
		EntityOrder		( back1, 999 )
		EntityTexture	( back1, tex1 )
		EntityTexture	( back1, tex2,0,1 )
Local back2 = CreateSprite(cam)
		MoveEntity		( back2, 0,0,2 )
		ScaleSprite		( back2, 3,3 )
		EntityFX		( back2, 1+8 )
		EntityAlpha		( back2, .3 )
		EntityOrder		( back2, 998 )
		EntityTexture	( back2, tex1 )
		EntityTexture	( back2, tex2,0,1 )
		EntityColor		( back2, 120,140,255 )
		EntityBlend		( back2, 3 )
		
Local light = CreateLight(2)
	LightRange light, GW2*1.1
;CameraClsMode cam, 1,0

; Missile Emitter
Local EpL.TV3 = NewV3(-17,-3,20)
Local EpR.TV3 = NewV3(+17,-3,20)
Local Ep.TV3 = EpL
Local EpS = 0

Local missile.TMissile = Null
Local ship.TShip = Null

Local  Starttime = MilliSecs()
Local time = 0, dt# = 17, ltime = -17
Local ShootTime = time
Local ShootDelay = 200
Local Shooting% = False
HidePointer()
Global CursorX#=MouseX(), CursorY#=MouseY()
Local CursorVelX#=0.0, CursorVelY#=0.0
Local TargetLocked=False
MouseXSpeed():MouseYSpeed()

For NbAsteroid = 1 To 50
	Local z# = Rnd(GW2*.95,GW2*.99)
	Local v# = 1.0
	NewShip(Rnd(-.8,.8)*z,Rnd(-.6,.6)*z,z,Rnd(-2,2), Rnd(-2,2),Rnd(-2,2), Rnd(.5,1.0)*v)
Next

Repeat
	
	; time based
		
		time = MilliSecs() - Starttime
		dt = time - ltime
		ltime = time
		VCoef = (60.0*dt)/1000.0
		
		RotateSprite(back1,Float(time)/247)
		RotateSprite(back2,-Float(time)/313)
		
	; Update Pointer
		Local mx = MouseX()
		Local my = MouseY()
		
		CursorVelX = CursorVelX + (MouseXSpeed()-CursorVelX)*.15
		CursorVelY = CursorVelY + (MouseYSpeed()-CursorVelY)*.15
		MoveMouse GW2,GH2
		CursorX = CursorX + CursorVelX
		CursorY = CursorY + CursorVelY
		If CursorX&gt;GW Then CursorX = GW
		If CursorY&gt;GH Then CursorY = GH
		If CursorX&lt;00 Then CursorX = 00
		If CursorY&lt;00 Then CursorY = 00
		
	; update ships
		UpdateShips		( VCoef )
		
	; launch missile ?
		; launch a missile on mousehit (with random velocity)
		If MouseDown(1)
			If ShootTime&lt;time + ShootDelay
				ShootTime = ShootTime + ShootDelay
				ship=MouseOverShip()
				If ship&lt;&gt;Null
					Shooting = True
					; start missile at emitter pos and last computed direction
					EpS=Not(EpS)
					Ep=EpL : If EpS Then Ep=EpR
					missile = NewMissile(Ep,Rnd(5.0,7.0))
					SetMissileTarget(missile,ship)
				EndIf
			EndIf
		Else
			Shooting = False
		EndIf
		
	; update missiles
		UpdateMissiles	( VCoef )
		
	Cls
	RenderWorld
		
		SetFont(fontS)
		DrawStellar	( )
		DrawMissiles( )
		DrawShips	( )
		
		ship=MouseOverShip(TargetLocked*30)
		
		TargetLocked = False
		Local CursorX_# = CursorX
		Local CursorY_# = CursorY
		
		If ship&lt;&gt;Null
			DrawShipLocked(ship,000,200,255)
			TargetLocked=True
			CursorX_ = GW2+GW2*ship\p\x/ship\p\z
			CursorY_ = GH2-GW2*ship\p\y/ship\p\z
		EndIf
		
		; Draw color
		Color 000,075,130
		Local ScopeSizeX = GW/6
		Local ScopeSizeY = ScopeSizeX*GH/GW
		Line 00,00,CursorX_-ScopeSizeX,CursorY_-ScopeSizeY
		Line GW,00,CursorX_+ScopeSizeX,CursorY_-ScopeSizeY
		Line GW,GH,CursorX_+ScopeSizeX,CursorY_+ScopeSizeY
		Line 00,GH,CursorX_-ScopeSizeX,CursorY_+ScopeSizeY
		
		Color 000,100,140
		;Rect CursorX-ScopeSize,CursorY-ScopeSize,ScopeSize*2+1,ScopeSize*2+1,0
		Oval CursorX_-ScopeSizeX*1.404,CursorY_-ScopeSizeY*1.404,ScopeSizeX*1.404*2+1,ScopeSizeY*1.404*2+1,0
		
		Color 000,128,255
		Local CursorSize = 8, CursorRadius=24
		If TargetLocked
			Color 255,100,000
			CursorSize=16;4
			CursorRadius=40;10
		EndIf
		Local c1 = - CursorRadius
		Local c2 = CursorRadius-CursorSize
		
		Local cw#=2
		Rect CursorX_-cw , CursorY_+c1 , 1+cw*2, CursorSize,1
		Rect CursorX_-cw , CursorY_+c2 , 1+cw*2, CursorSize,1
		Rect CursorX_+c1 , CursorY_-cw , CursorSize, 1+cw*2,1
		Rect CursorX_+c2 , CursorY_-cw , CursorSize, 1+cw*2,1
		
		SetFont(fontM)
		If TargetLocked
			
			Color 245,240,050
			Rect CursorX-cw-1 , CursorY+c1-1 , 3+cw*2, CursorSize,0
			Rect CursorX-cw-1 , CursorY+c2-1 , 3+cw*2, CursorSize,0
			Rect CursorX+c1-1 , CursorY-cw-1 , CursorSize, 3+cw*2,0
			Rect CursorX+c2-1 , CursorY-cw-1 , CursorSize, 3+cw*2,0
			
			; clear Text Area
				;Color 0,0,0
				;Rect 15,5,300,50,1
				;Rect GW-310,10,300,50,1
			
			Color 0,255,0
			SetFont(fontM)
			Rect 15,5,300,30,0
			Text 165,20,"- Ennemy Enagged -",1,1
			
			SetFont(fontB)
			If Shooting
				Color 255,100,000
				Rect GW-310,10,300,50,0
				Text GW-160,35,"FIRE",1,1
			Else
				Color 255,180,020
				Rect GW-310,10,300,50,0
				Text GW-160,35,"ENGAGED",1,1
			EndIf
		EndIf
		
	Delay 5
	
	Flip False
	
Until KeyDown(1)

ShowPointer()

End
</textarea> <br><br></td></tr></table><br>
<a name="1179651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've found that in most of these space ship fleet action games, the ones I've designed at least, the ships usually get into some kind of patterned movement eventually that means they follow each other which makes targeting less of a headache....just aim the bullets at the ship's current position plus a random vector weighted in the direction of the target's velocity vector and hope for the best...usually works fine. <br><br></td></tr></table><br>
<a name="1179653"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sure, but I'm not using vectors.  Since Blitz takes care of that stuff with MoveEntity, I just rely on that.  I would only be using the vector code (adding two vectors and such) for this targeting purpose.  In other words, I'll have to translate pitch and yaw to vectors just to aim the gun, which carries a small cycle cost.  <br><br>I figure, if I'm going to do that, I might as well use Bobysait's code since it can provide pinpoint accuracy if desired.  (aces vs. donkeys, etc.).  Anyway, your suggestion is another option I hadn't considered. <br><br></td></tr></table><br>
<a name="1179827"></a>

<a name="1179828"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Matty : you look sarcastic in most of your comment (or it's maybe just me who does not get it right)<br><br>Well, The matter is not "how to &lt;not&gt; do it"<br>We try to give an objective answer to a problem, we're not trying to justify the reason he wanted this stuff to give him an other way to do something different. <br><br></td></tr></table><br>
<a name="1179832"></a>

<a name="1179837"></a>

<a name="1179838"></a>

<a name="1179839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think Matty was referring to the fact that you can simulate target prediction with estimative methods and have the players perceiving them as precise methods.<br><br>In any case, there are other places with discussions on this: <a href="http://www.gamedev.net/topic/401165-target-prediction-system--target-leading/?p=3663387" target="_blank">http://www.gamedev.net/topic/401165-target-prediction-system--target-leading/?p=3663387</a> <br><br></td></tr></table><br>
<a name="1179840"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Or you can cheat and use a seconds count down system that randomly chooses between x to y seconds and shoots while your enemy constantly is using PointEntity() to point the enemy at the player. Once shot, snap him out of that function if far away enough, and make him go back to his waypoint :) <br><br></td></tr></table><br>
<a name="1179844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bobysait:<br><br>I just tried the "updated" demo.  Wow!  That was quick!  Very cool.  Try it out folks (post# 10).  It's completely different.<br><br>Kryzon:<br><br>Useful link.  Thanks.<br><br>Thundros:<br><br>Not sure what you mean exactly.  But anyway some good methods described here. <br><br></td></tr></table><br>
<a name="1179892"></a>

<a name="1179893"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well basically what I mean is.. You have a timer that randomly chooses between 2 &amp; 5 seconds. Or x &amp; y seconds, whichever suits you. Then, during that time frame, point the enemy towards the player, and when it finishes the timer, automatically make the enemy shoot the player. Then rinse &amp; repeat til' your enemy is out of bullets. Then play the "click" sound once to show that he is out of bullets, then make him go back to his waypoint, or before that, look for bullets, then go back to firing at the player after having selected the correct gun for the enemy. :P Also, speed is a not needed with this type of setup as the speed is already defined by the enemy's movement speed.<br><br>It's a cheap way to do it, I know, but I follow the K.I.S.S. rule. Keep it simple, stupid. ;) <br><br></td></tr></table><br>
<a name="1179908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I understand what you mean, but<br><div class="quote"> I've got some spaceships shooting at each other, but they need to aim a bit better than they do; they always shoot directly at the target rather than where the target is going to be <br></div><br><br>you're talking about the spaceship behavior : when it shoots / when it is shot (i.e : the IA involved)<br>Axel talked about estimating a position for better aiming.<br><br>So it's another subject I think, whatever it is a good subject too <br><br></td></tr></table><br>
<a name="1180090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I get it.  So I have fields for Ship and ShipType, with ShipType storing all the information common to all ships of that type, including a firingRate integer, which is the number of frames between firings.  Each Ship then has a timeToFire integer that is set to ShipType\firingRate whenever it fires, which is whenever timeToFire drops to 0 (it decrements each frame, of course.)  That seems to work for me so far, as far as timing.<br><br>Steering is a matter of pointing a pivot at the target and approaching at a certain rate per frame (based on distance from the targeting ship), then pointing the ship at the pivot.  This basic method works for cruising as well (i.e. non-hunting).  The only problem is that while the turning is smooth, the changes in angle are too abrupt, so I'm thinking of putting a second guide pivot in the train, so to speak.  Then that pivot would make the sudden angle changes and the actual ship would appear to smoothly change angles.  I hope that made sense.<br><br>For now I've stuck in a quick and dirty solution for aiming, which is as follows:<br><br>- Calculate how many frames it will take a bullet to reach the target<br>- Actually move the target ahead by those frames x it's speed<br>- Aim at that location and fire<br>- Move the target back where it was!<br><br>Well, I said it was dirty... :-)  I suspect it's may be slower than Bobysait's method, but I need to time to benchmark both ways (and Stevie G's as well).  <br><br>It is surprisingly accurate, tho.  I expected it to be off when the target is approaching or receding at say, 45 degrees, but so far it's pretty much right on.  The ships are chubby enough to still get hit.<br><br>You guys have been amazingly helpful, as always!  I'll publish an updated demo soon. <br><br></td></tr></table><br>
<a name="1180130"></a>

<a name="1180131"></a>

<a name="1180170"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can also use a Lerp (or Slerp) function<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TV3 Field x#,y#,z# End Type
Function NewV3.TV3(x#=0.0,y#=0.0,z#=0.0):Local v.TV3=New TV3:v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3Assign.TV3(v.TV3,src.TV3):v\x=src\x:v\y=src\y:v\z=src\z:Return v:End Function
Function V3Copy.TV3(src.TV3):Return V3Assign(NewV3(),src):End Function
Function V3set.TV3(v.TV3,x#,y#,z#):v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3normalize.TV3(v.TV3):Return V3mulScalar(v,Float(1.0)/V3Norm(v)):End Function
Function V3normalized.TV3(v.TV3):Return V3normalize(V3Copy(v)):End Function
Function V3Add.TV3(v1.TV3,v2.TV3):v1\x=v1\x+v2\x:v1\y=v1\y+v2\y:v1\z=v1\z+v2\z:Return v1:End Function
Function V3AddScalars.TV3(v.TV3,x#,y#,z#):Return V3set(v,v\x+x,v\y+y,v\z+z):End Function
Function V3Sub.TV3(v1.TV3,v2.TV3):v1\x=v1\x-v2\x:v1\y=v1\y-v2\y:v1\z=v1\z-v2\z:Return v1:End Function
Function V3Negate.TV3(v.TV3):v\x=-v\x:v\y=-v\y:v\z=-v\z:Return v:End Function
Function V3mulScalar.TV3(v.TV3,s#):v\x=v\x*s:v\y=v\y*s:v\z=v\z*s:Return v:End Function
Function V3Dot#(a.TV3,b.TV3):Return a\x*b\x+a\y*b\y+a\z*b\z:End Function
Function V3Norm2#(v.TV3):Return V3Dot(v,v):End Function
Function V3Norm#(v.TV3):Return Sqr(V3Norm2(v)):End Function
Function V3Mul.TV3(a.TV3,b.TV3):a\x=a\x*b\x:a\y=a\y*b\y:a\z=a\z*b\z:Return a:End Function
Function V3cross.TV3(a.TV3,b.TV3):Return NewV3(a\y*b\z-a\z*b\y, a\z*b\x-a\x*b\z, a\x*b\y-a\y*b\x):End Function
Function V3Lerp.TV3(v.TV3,dest.TV3,rate#):Local t.TV3=V3mulScalar(V3Sub(V3Copy(dest),v),rate):V3Add(v,t):Delete t:Return V3normalize(v):End Function
Function V3Slerp.TV3(v.TV3, dest.TV3, rate#)
	Local dot# = V3Dot(v,dest):If dot&lt;-1:dot=-1:ElseIf dot&gt;1:dot=1:EndIf
	Local theta# = ACos(dot)*rate
	Local t.TV3=V3mulScalar(V3normalize(V3Add(V3mulScalar(V3Copy(v),-dot),dest)),Sin(theta))
	V3Add(V3mulScalar(v,Cos(theta)), t):Delete t
	Return v
End Function

; stores the EmitterDirection vector in @Result vector
; returns the time (as float) of the predicted collision
Function ExtrapolatedInTime#(Result.TV3, E.TV3,E_Velocity#, T.TV3,T_Dir.TV3,T_Velocity#)
	Local In# = T_Velocity/Sqr(T_Dir\x*T_Dir\x+T_Dir\y*T_Dir\y+T_Dir\z*T_Dir\z)
	Local Ix# = T_Dir\x*In, Iy# = T_Dir\y*In, Iz# = T_Dir\z*In
	Local a# = Ix*Ix+Iy*Iy+Iz*Iz - E_Velocity*E_Velocity
	Local b# = + Float(2.0)*( (T\x-E\x)*Ix + (T\y-E\y)*Iy + (T\z-E\z)*Iz )
	Local c# = ((T\x-E\x)*(T\x-E\x)+(T\y-E\y)*(T\y-E\y)+(T\z-E\z)*(T\z-E\z))
	Local Det# = b*b-4.0*a*c
	Local time#=0.0
	If Det&lt;0 Then Return -1
	If Det&gt;0:Det=Sqr(Det):time = -0.5*(b-Det)/a:If time&lt;0 Then time=-0.5*(b+Det)/a
	Else:time = -0.5*b/a
	EndIf
	Result = V3normalize(V3Sub(V3AddScalars(V3Assign(Result,T),time*Ix,time*Iy,time*Iz),E))
	Return time
	
End Function


Type TRay
	Field p.TV3, d.TV3, n# ; position/direction/norm#
End Type
Function NewRay.TRay(p.TV3, d.TV3, vel#=1.0)
	Local r.TRay = New TRay
	If p=Null:r\p=NewV3():Else:r\p=V3Copy(p):EndIf
	If d=Null:r\d=NewV3(0,1,0):Else:r\d=V3normalized(d):EndIf
	r\n = vel
	Return r
End Function
Function CopyRay.TRay(source.TRay)
	Return NewRay(source\p,source\d,source\n)
End Function

Function FreeRay(r.TRay)
	Delete r\p
	Delete r\d
	Delete r
End Function

Type TPart
	Field r.TRay
	Field life#,mlife
	Field size#
	Field cr,cg,cb
End Type
Const MIN_PART_LIFE = 30, MAX_PART_LIFE=50
Function NewPart.TPart(emitter.TRay, life#=-1,vel#=10.0,size#=5.0,r=255,g=128,b=0)
	Local p.TPart = New TPart
	p\r = CopyRay(emitter)
	p\r\n=vel
	p\size=size
	p\life=life : If p\life&lt;1 Then p\life=Rand(MIN_PART_LIFE,MAX_PART_LIFE)
	p\mlife=p\life
	p\cr=r
	p\cg=g
	p\cb=b
	Return p
End Function
Function FreePart(p.TPart)
	FreeRay(p\r)
	Delete p
End Function
Function UpdateParts(speed#)
	Local t.TV3 = NewV3()
	Local p.TPart
	For p = Each TPart
		p\life=p\life-speed
		If p\life&lt;=0
			FreePart(p)
		Else
			p\r\n=p\r\n-speed*.005
			V3Add(p\r\p, V3mulScalar(V3Assign(t,p\r\d),speed*p\r\n))
		EndIf
	Next
	Delete t
End Function
Function DrawParts()
	Local p.TPart,c#
	For p = Each TPart
		c=p\life/p\mlife
		Color p\cr*c,p\cg*c,p\cb*c
		Oval p\r\p\x-p\size*c,p\r\p\y-p\size*c,p\size*2*c,p\size*2*c,1
	Next
End Function

Function Template_EmitCirclePart(emitter.TRay, life#=-1,rndlife#=0, nb%=20,size#=1.0,rndsize#=1,vel#=1.0,rndvel#=.5,r=255,g=128,b=0,rndr=0,rndg=0,rndb=0)
	Local n
	For n = 1 To nb
		Local p.TPart = NewPart(emitter, life+Rnd(-rndlife,rndlife),vel+Rnd(-rndvel,rndvel), size+Rnd(-rndsize,rndsize),r+Rnd(-rndr,rndr),g+Rnd(-rndg,rndg),b+Rnd(-rndb,rndb))
		V3normalize(V3set(p\r\d,Rnd(-1,1),Rnd(-1,1),0))
	Next
End Function

Const TRG_MAX_LIFE#	=	8.0		; number of collisions/points
Const MSL_MAX_LIFE#	=	200.0	; time to die/explose

Type TTourel
	; the emitter
	Field r.TRay
	Field Aim.TV3
	Field Engaged.TTarget
	Field Radius#
	Field CoefRotation#
	Field Accurate#					; the less = the more the emitter will launch prematured missiles (so "target missed missile")
									; @EmitterAccurate = .9 &gt; very low risk to miss anything
									; @EmitterAccurate = .3 &gt; will loose lots of missiles
	Field MaxRotationSpeed#
	
	; shoot variable (define the rate to launch missiles)
	Field FireTime#
	Field FireDelay#
End Type

Function NewTourel.TTourel(x#,y#,z#,vel#=5.0,radius#=25.0, MaxRotationSpeed#=.2,accurate#=.6, FireDelay#=15.0)
	Local t.TTourel		=	New TTourel
	t\r					=	NewRay(NewV3(x,y,z),NewV3(0,1,0),vel)
	t\Aim				=	NewV3()
	t\Radius			=	radius
	t\Engaged			=	Null
	t\MaxRotationSpeed	=	MaxRotationSpeed
	t\Accurate			=	accurate
	t\CoefRotation		=	0.2
	t\FireTime			=	0
	t\FireDelay			=	FireDelay
	Return t
End Function
Function FreeTourel(t.TTourel)
	FreeRay(t\r)
	Delete t\Aim
	Delete t
End Function

Function UpdateTourels(speed#=1.0)
	Local a.TTourel, t.TTarget
	Local tmp.TV3 = NewV3()
	For a = Each TTourel
		a\FireTime=a\FireTime-speed : If a\FireTime&lt;=0 Then a\FireTime=0 ; missile ready to launch.
		; if no taget "engaged" then select the next target
		If a\Engaged=Null
			Local nearest.TTarget = Null, nearl#=0.0
			
			For t.TTarget = Each TTarget
				If nearest = Null
					nearest = t
					nearl = V3Norm2(V3Sub(V3Assign(tmp,a\r\p),t\r\p))
				Else
					Local nl#=V3Norm2(V3Sub(V3Assign(tmp,a\r\p),t\r\p))
					If nl&lt;nearl
						nearl=nl
						nearest = t
					EndIf
				EndIf
			Next
			a\Engaged = nearest
			a\CoefRotation = 0.0
		; else try to aim and shoot
		Else
			; find collision point
			If ExtrapolatedInTime ( a\Aim, a\r\p, a\r\n, a\Engaged\r\p,a\Engaged\r\d, a\Engaged\r\n )
				; interpolate current direction with the collision point direction
				; check if angular between the two directions is too rough
				If Abs(V3Dot(a\r\d,a\Aim))&lt;.4
					a\CoefRotation = .005
				Else
					a\CoefRotation=a\CoefRotation+speed*.001 : If a\CoefRotation&gt;a\MaxRotationSpeed Then a\CoefRotation=a\MaxRotationSpeed
				EndIf
				V3Slerp ( a\r\d, a\Aim, speed*a\CoefRotation )
			EndIf
			; shoot (if alignment is accurate)
			If a\CoefRotation&gt;a\MaxRotationSpeed*a\Accurate
				If a\FireTime&lt;=0
					; launch a missile
					NewMissile(a\r)
					Template_EmitCirclePart(a\r,-1,0,Rand(3,5),1,0,1,.25,225,175,140,30,10,30)
					; update the "shoot time" for the next missile
					a\FireTime=a\FireTime+a\FireDelay
				EndIf
			EndIf
		EndIf
	Next
	Delete tmp
End Function

Function DrawTourels()
	Local a.TTourel
	For a = Each TTourel
		; the emitter
		; ray that indicates the emitter direction
			Color 030,004,000 : Line a\r\p\x,a\r\p\y,a\r\p\x+a\r\d\x*1000,a\r\p\y+a\r\d\y*1000
			
		; kind of outline
			Color 060,010,150
			Oval a\r\p\x-a\Radius-1,a\r\p\y-a\Radius-1,a\Radius*2+2,a\Radius*2+2,1
			Oval a\r\p\x+a\r\d\x*a\Radius-6,a\r\p\y+a\r\d\y*a\Radius-6,13,13,1
			
		; the canon
			Color 100,020,000 : If a\CoefRotation&gt;a\MaxRotationSpeed*a\Accurate Then Color 255,070,000
			Oval a\r\p\x+a\r\d\x*a\Radius-5,a\r\p\y+a\r\d\y*a\Radius-5,11,11,1
			
		; the body of the tourel
			Color 180,110,000 : Oval a\r\p\x-a\Radius,a\r\p\y-a\Radius,a\Radius*2,a\Radius*2,1
			
		; an indicator for the current target and the current emitter direction
		If a\Engaged&lt;&gt;Null
			; highlight engagde target
			Color 000,255,255 : Oval a\Engaged\r\p\x-5,a\Engaged\r\p\y-5,11,11,0
			; small ray to show target direction
			Color 015,015,018:Line a\Engaged\r\p\x,a\Engaged\r\p\y,a\Engaged\r\p\x+a\Engaged\r\d\x*250,a\Engaged\r\p\y+a\Engaged\r\d\y*250
		EndIf
	Next
End Function

Type TTarget
	Field r.TRay
	Field life#
	Field NextDir.TV3
	Field DirTime
End Type
Function NewTarget.TTarget(pos.TV3,dir.TV3, vel#)
	Local t.TTarget = New TTarget
	t\r = NewRay(pos,dir,vel)
	t\life = TRG_MAX_LIFE
	t\NextDir = NewV3(Rnd(-1,1),Rnd(-1,1),0)
	t\DirTime = 0
	Return t
End Function
Function FreeTarget(a.TTarget)
	FreeRay a\r
	Delete a
End Function
Function UpdateTargets(speed#=1.0)
	Local a.TTarget
	Local t.TV3 = NewV3()
	Local gw=GraphicsWidth()
	Local gh=GraphicsHeight()
	For a = Each TTarget
		a\DirTime = a\DirTime - speed
		If a\DirTime&lt;=0
			a\DirTime = Rand(20,50)
			V3normalize(V3set(a\NextDir,Rnd(-1,1),Rnd(-1,1),0))
		EndIf
		V3Slerp(a\r\d,a\NextDir,speed*.05)
		V3Add(a\r\p,V3mulScalar(V3Assign(t,a\r\d),a\r\n*speed))
		If a\r\p\x&lt;00 Then a\r\p\x=gw-1
		If a\r\p\y&lt;00 Then a\r\p\y=gh-1
		If a\r\p\x&gt;gw Then a\r\p\x=1
		If a\r\p\y&gt;gh Then a\r\p\y=1
		If a\life&lt;=0
			Template_EmitCirclePart(a\r,80,20,Rand(40,80),25,10,2.5,1, 200,195,185,05,05,10)
			Template_EmitCirclePart(a\r,25,10,Rand(20,30),40,15,1.0,.5, 220,120,020, 35,080,19)
			FreeTarget(a)
		EndIf
	Next
	Delete t
End Function
Function DrawTargets()
	Local a.TTarget
	For a = Each TTarget
		Color 255-a\life*255.0/TRG_MAX_LIFE,255.0-a\life*128.0/TRG_MAX_LIFE,a\life*255.0/TRG_MAX_LIFE
		Rect a\r\p\x-2,a\r\p\y-2,5,5,0
	Next
End Function

Type TMissile
	Field r.TRay
	Field life#
End Type

Function NewMissile.TMissile(emitter.TRay)
	Local m.TMissile = New TMissile
	m\r = CopyRay(emitter)
	m\life = MSL_MAX_LIFE
	Return m
End Function
Function FreeMissile(m.TMissile)
	FreeRay m\r
	Delete m
End Function
Function UpdateMissiles(speed#=1.0)
	Local m.TMissile
	Local t.TV3 = NewV3()
	Local a.TTarget
	Local gw=GraphicsWidth()
	Local gh=GraphicsHeight()
	For m = Each TMissile
		m\life = m\life-speed
		If m\life&lt;=0
			FreeMissile(m)
		Else
			V3Add(m\r\p,V3mulScalar(V3Assign(t,m\r\d),m\r\n*speed))
			If m\r\p\x&lt;00 Then m\r\p\x=gw-1
			If m\r\p\x&gt;gw Then m\r\p\x=1
			For a=Each TTarget
				If V3Norm(V3Sub(V3Assign(t,a\r\p),m\r\p))&lt;speed*(a\r\n+m\r\n)*.9
					a\life=a\life-1
					Template_EmitCirclePart(m\r,-1,0,Rand(8,15),1,0,1.5,1, 150,040,000,80,35,0)
					FreeMissile(m)
					Exit
				EndIf
			Next
		EndIf
	Next
	Delete t
End Function
Function DrawMissiles()
	Local m.TMissile
	For m = Each TMissile
		Color 255,m\life*255/MSL_MAX_LIFE,000
		Oval m\r\p\x-1,m\r\p\y-1,3,3,0
		Color 080,m\life*080/MSL_MAX_LIFE,000
		Line m\r\p\x,m\r\p\y,m\r\p\x-m\r\d\x*25,m\r\p\y-m\r\d\y*25
	Next
End Function




Graphics3D 1024,768,0,2
SetBuffer BackBuffer()

; ------------------------
; - Time Based variables -
; ------------------------
	
	; this is the basic FPS with the one the variables have been calculated
	; it does not mean that if the fps is above or below there will noticeable artifacts
	; it is just a time factor to calibrate the "gameplay"
	Local TARGET_FPS#		=	60.0
	
	Local st				=	MilliSecs()-17
	Local mt				=	0
	Local dt#				=	17.0
	Local lt				=	st
	Local coef#				=	1.0
	Local gw				=	GraphicsWidth()
	Local gh				=	GraphicsHeight()
	; 4 tourels on top and bottom (shoot prematurately)
	NewTourel					(gw*0.3, gh*0.0, 0, 05, 15, .1, .5, 30)
	NewTourel					(gw*0.7, gh*0.0, 0, 05, 15, .1, .5, 30)
	NewTourel					(gw*0.8, gh*1.0, 0, 05, 15, .1, .5, 30)
	NewTourel					(gw*0.2, gh*1.0, 0, 05, 15, .1, .5, 30)
	; 2 "super" tourel &gt; fast and accurate on the border of the screen
	NewTourel					(gw*1.0, gh*0.5, 0, 15, 25, .3, .8, 5)
	NewTourel					(gw*0.0, gh*0.3, 0, 15, 25, .3, .8, 5)
	
	Local MaxTargets%		=	30
	
; temporary vectors used for internal calculs
	Local TempTargetP.TV3	=	NewV3()
	Local TempTargetD.TV3	=	NewV3()
	
Repeat
	
	; update time based
		
		mt=MilliSecs()-st
		dt=mt-lt
		lt=mt
		
		; time coeficient
		coef = dt*TARGET_FPS/1000.0
		If Abs(coef)&gt;5 Then coef=5
		
	; auto generate targets
		Local a.TTarget, acount%=0
		For a = Each TTarget : acount = acount + 1 : Next
		If acount&lt;MaxTargets
			NewTarget(V3set(TempTargetP,Rand(gw),Rand(gh),0),V3set(TempTargetD,Rnd(-1,1),Rnd(-1,1),0),Rnd(1,1.4))
		EndIf
		
	; update targets first
		UpdateTargets(coef)
	; update the tourels (with new target positions) -&gt; emit missiles
		UpdateTourels(coef)
	; then update the missiles.
		UpdateMissiles(coef)
		
	; particles
		UpdateParts(coef)
	; draw everything
		Cls
		
		; the missiles
		DrawMissiles()
		; the targets
		DrawTargets()
		; draw the effects
		DrawParts()
		; the emitters
		DrawTourels()
	; prevent CPU heat
		Delay 17
		
	; flip ^^
		Flip False
		
Until KeyDown(1)

Delete TempTargetD
Delete TempTargetP

End
</textarea><br><br><br>here is an online version (html5 compiled with monkey's demo)<br><a href="http://bobysait.free.fr/minigames/html5/Tourel/MonkeyGame.html" target="_blank">http://bobysait.free.fr/minigames/html5/Tourel/MonkeyGame.html</a> <br><br></td></tr></table><br>
<a name="1180137"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have a talent sir! Amazing stuff. <br><br></td></tr></table><br>
<a name="1180239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excellent work Bobsait. <br><br></td></tr></table><br>
<a name="1180274"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Bobysait - I wasn't trying to be sarcastic...maybe that's just how it came across...I was simply giving my own method for how I do these sorts of things...admittedly I don't know the exact type of game the Axel is trying to create (is it a fleet combat game (in which case my method is fine) or is it a simple shooter...) - I was just giving my opinion as to a method that should do the trick. <br><br></td></tr></table><br>
<a name="1180288"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, no problem, so it's just me who misunderstood (sorry for this, I 'm french, I might bad understand things sometimes, don't worry for this)<br><br>@Stevie G and Axel Wheeler : thanks :) <br><br></td></tr></table><br>
<a name="1180356"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so I've updated the <a href="http://www.lumpcat.com/files/ShipDemo.zip" target="_blank">demo</a> that I had originally talked about on <a href="/posts.php?topic=99805" target="_blank">this thread.</a>  Everything you see is procedurally generated using the randomizer.<br><br>It now features:<br><br>- A nebula in the sky (or parts of the sky)<br>- A planet (with a huge black gash along the meridian.  You'll see it when it rolls around.  Gotta fix that texture generator.)<br>- Battleships with independent turrets.  Sometimes they're accurate, often not.  But they're a lot more accurate than they were before this thread!<br><br>You'll notice that when a ship explodes, the light reflects off the planet!  Just think of it as a very bright explosion.<br><br>There are many other improvements that it needs, such as flames and smoke for the explosions, and just better 'explosion management'.  Oh, and sounds.  I'm not going to try to generate those! (at least not immediately.)  But hopefully those will be the only loaded media. <br><br></td></tr></table><br>
<a name="1180385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> MAV on "setting up the planet". <br><br></td></tr></table><br>
<a name="1180430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting.  Doesn't do that for me, although it takes awhile.  The texture generator needs optimization, and I guess it has a bug too.  I'll check tomorrow.  Thanks for trying... <br><br></td></tr></table><br>
<a name="1180434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Same - I get the same MAV running on my work machine - integrated graphics card.  <br><br>If it doesn't do it on yours and yours has a dedicated graphics card make sure the texture flags are supported...often with integrated cards you can't leave off the color flag when combined with alpha in a texture flag....although I'm sure it could be something else as well...this is just from my own experience.<br><br>Ie createtexture(width,height,1+2) will work on an integrated card but createtexture(width,height,2) will not work. <br><br></td></tr></table><br>
<a name="1180449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have no chipset (real decent graphics card) and I get the MAV, it's probably something else.<br><br>BTW : Windows 7 64 bits. If it may be relevant to the error produced.<br><br>(else, you can check if you enabled the debugger, some mistakes does not crach with or without debugguer, like peek/poke to a bank outside the banksize) <br><br></td></tr></table><br>
<a name="1180463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Matty:<br><br>You may have found it.  My CreateTexture for the planet was:<br><br>Local pTex=CreateTexture(2045,1024,2)<br><br>I changed it to 3.  I've updated the <a href="http://www.lumpcat.com/files/ShipDemo.zip" target="_blank">demo.</a><br><br>In case that does not work, I've also put up <a href="http://www.lumpcat.com/files/ShipDemoNoPlanet.zip" target="_blank">a version </a>without the planet, since we are primarily interested in the targeting anyway, and the planet is still pretty basic.  And, like I said, it has a massive black line to be fixed.<br><br>Bobysait:<br><br>As it happens I do use banks, but those functions are also used before the planet part, so I suspect that wasn't the problem.  <br><br>Thanks again! <br><br></td></tr></table><br>
<a name="1180480"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whoa... Ok, two more possible issues: <br><br>1. I just noticed the "2045" instead of "2048" fat finger problem.  Still, doesn't Blitz round that off to the nearest power of two? (anyway, fixed and uploaded)<br><br>2. I just read that some graphics cards can't do textures bigger than 1024.  I have an old Dell Dimension E510, so I tend to assume that if my pc can run it, your's probably can too.<br><br>Either may be the issue.  I've created yet another <a href="http://www.lumpcat.com/files/ShipDemoSmallPlanet.zip" target="_blank">download</a> with a smaller planet texture (1024x512). <br><br></td></tr></table><br>
<a name="1180487"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Seems to run, I saw the ships<br><br>- the "help" says we can move our ship : it does work, I can rotate the camera (really too fast BTW) zoom and pause. but no moves.<br><br>- it crashes (MAV) if I hit "Space" button :)<br><br>ps : the ships are procedural too ? if so, congrats they looks really nice ^^ <br><br></td></tr></table><br>
<a name="1180554"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, it's all procedural.   They are actually standard Blitz spheres, with verts modified according to a random numbers smoothly interpolated, along with a few other extrusion-type modifications.<br><br>The acceleration works for me, but it's a bit slow at first.  The right mouse button is the accelerator.  <br><br>As far as rotation speed, it may be that my system is so slow, so it looks perfect for me.  I may need to slow it down a bit. <br><br></td></tr></table><br>
<a name="1180555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> it should not be different with different systems. You should think about implementing a "time-based" algorithm. <br><br></td></tr></table><br>
<a name="1180614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> My understanding of delta timing may be wrong, but isn't it the case that if you are happy with 60 fps, then Blitz essentially handles timing quite well by delaying the rest of the proper frame time, as long as your cpu and video card processing take less than that.   But I see a lot of code on here where people are essentially replicating the Blitz functionality.  In other words, using a delay statement to use up the time that the Flip statement would have used up anyway.<br><br>Also, simply writing more efficient code should be the first approach to improving frame rate.<br><br>Also, rarely is it pointed out (or done, that I can see) that for delta timing to work you have to multiply the movement of every entity by a calculated amount.  And while this does cause movement to be smooth across frames of differing lengths, the resulting change in ai behavior can be a significant trade-off.  I've played racing games where if a lag occurs the cars go straight off the track.  Essentially false extrapolation errors. <br> <br>Is the above valid?  I don't actually know that much about it, which may be clear at this point :-)<br><br>Having said all that, you're absolutely right that it would clearly be appropriate in cases like this where I intend a lot of stuff to be happening per frame.  Maybe that'll be next.  (But I wanna make space stations!  Waa!) <br><br></td></tr></table><br>
<a name="1180632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> After all that I actually checked the framerate, and it's right about 16 fps, with some frames going above that.  But I'm guessing the reason the camera rotation is so fast is that I'm using it to check things out so I'm looking for speed.  For players it needs to be slower.<br><br>So I've now updated the <a href="http://www.lumpcat.com/files/ShipDemo.zip" target="_blank">demo</a> with a slower camera pan.  And I'll look into delta timing when I can... <br><br></td></tr></table><br>
<a name="1180633"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JeeyD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Agree improving code should be very possible and top priority, bc 60fps is a special limit for the game experience. Amazing looking procedural objects btw. Well done !! <br><br></td></tr></table><br>
<a name="1180634"></a>

<a name="1180635"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RGR</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi AxelWheeler<br>I think your FPS Count is wrong! Try external benchmarking i.e. Fraps which shows that the Framerate is constant at 60 FPS<br>What you show is 16.666 Millisecs each Frame ... which is equivalent to 60 FPS<br><br>16 FPS does not look that smooth as the action in your demo ;-)<br>Demo looks very good btw.<br><br>. <br><br></td></tr></table><br>
<a name="1180641"></a>

<a name="1180642"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right you are!  I was showing ms/frame.  It's now corrected to show fps, which drops to around 40 on my old machine although is usually near 60.  Two main things cause this to happen:  One, when a ship explodes and Big10p's <a href="/codearcs.php?code=1143" target="_blank">mesh clipping function</a> kicks in.  The other occurs when the last ship of a fleet is destroyed and a new fleet is created (the actual generation of a ship design).  This is ok for the demo since in a game all the ship types will be created on initialization.  <br><br>Still, the splitting has to be sped up somehow.  Maybe I can do that on initialization as well...<br><br>Edit: Forgot to say, Thanks for the props! <br><br></td></tr></table><br>
<a name="1180693"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think that you haven't understood in deep why the use of Delta timing.<br>It does not just prevent from computer runing too fast, it calibrates everything, so it also prevent computer runing too slow.<br><br>Just imagine an online game, where a player have a Hell machine<br>All good, the Delay will keep it to 60 fps, so he won't go 10 times faster than you :)<br>But ... if you have a crapy machine ... that even not runs 15 fps ... he 'll still be 4 times faster than you are.<br><br>With Delta timing, the speed of the objects is calibrate so that it runs to an amount of units "per second", and not "per loop", then it does not depend on CPU anymore, whatever the machine runs slow or fast.<br><br><br>BTW : the Delay function does not work for all computers, some just doesn't care about it.<br>(I have a computer which does care about Delay and run applications and game at max, I had to installed CrystalCPU to reduice the FSB [which was at the standard rate] manually to prevent Overheating ... else, on almost recent game, it runs like a charm, but not longer than 20 seconds ... then it reboots &gt; probably a problem with the CPU fan wich is undersized I think) <br><br></td></tr></table><br>
<a name="1180699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, that's pretty consistent with my thoughts about dt.  But notice that your examples are pretty advanced, where one is syncing multiple computers.  In such cases clearly dt is justified.  And in general I would think anytime a game is to be published that has enough stuff running each frame to risk going longer than 15.667 ms on target machines.<br><br>But I would still think that for systems that easily handle the frame in 15.667 ms, dt is no advantage over default Blitz Flip() behavior.<br><br>Good luck with the CrystalCPU! <br><br></td></tr></table><br>
<a name="1180700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> you'll have to take care about the Flip "True"<br>In almost cases it should work to prevent application running up to the sync rate.<br>But :<br>1/ it depends on the refresh rate of the screen. (there are lots of screen "standardised" on 100 or 120 fps)<br>2/ it also depends on the graphics card configuration, if the VSync is disabled (and forced disabled) then the game will not be limited at all.<br><br>Take care of this, probably with both Delay + Flip true (or VWait) you can cover almost all the machines, but for sure only delay or only Flip true is just not enough.<br><br>(And of course all this is only required for publications, if you intend to run something only for you, I imagine you have already set up your machine) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
