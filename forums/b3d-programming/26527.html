<!DOCTYPE html><html lang="en" ><head ><title >Using Normals for backface-culling...</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Using Normals for backface-culling...</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Using Normals for backface-culling...</a><br><br>
<a name="276437"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am using normals for backface culling on b+.<br>I am experiencing with 3d, as opposet to most of you guys, who know everything about it.<br>Well, my backface-culling algorythm seems to be working... as long as I don´t rotate around the X-axis.<br>Here is the code.<br>Please let me know what is wrong.<br>And, please, don´t pay too much attention to code correctness or ellegance... I am learning 3d, so I probably made more mistakes than one would explect.<br>Now, I would like someone to explain to me what I am doing wrong...<br>Thanks a lot,<br><br>Rui Barbosa Jr.<br><br>&lt;CODE&gt;<br>Dim x#(16, 9)<br>Dim y#(16, 9)<br>Dim z#(16, 9)<br>;<br>Dim rx#(16, 9)<br>Dim ry#(16, 9)<br>Dim rz#(16, 9)<br>;<br>Dim nx#(16, 9)<br>Dim ny#(16, 9)<br>Dim nz#(16, 9)<br>;<br>Dim rnx#(16, 9)<br>Dim rny#(16, 9)<br>Dim rnz#(16, 9)<br>;<br>Global a# = 0.00<br>Global b# = 0.00<br>Global g# = 0.00<br><br><br><br>Graphics 1024, 768, 16, 0<br><br><br><br>For i% = 0 To 15<br>	For	j% = 0 To 8<br>		r# = Sin#(22.50 * j%)<br>		x#(i%, j%) = Cos#(22.50 * i%) * r#<br>		y#(i%, j%) = Cos#(22.50 * j%)<br>		z#(i%, j%) = -Sin#(22.50 * i%) * r#<br>	Next<br>Next<br><br><br><br>For i% = 0 To 15<br>	For j% = 0 To 8<br>		x0# = +x#(i%, j%)<br>		y0# = -y#(i%, j%)<br>		z0# = +z#(i%, j%)<br>		x1# = +x#((i% + 1) Mod 16, j%)<br>		y1# = -y#((i% + 1) Mod 16, j%)<br>		z1# = +z#((i% + 1) Mod 16, j%)<br>		x2# = +x#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		y2# = -y#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		z2# = +z#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		x3# = +x#(i%, (j% + 1) Mod 9)<br>		y3# = -y#(i%, (j% + 1) Mod 9)<br>		z3# = +z#(i%, (j% + 1) Mod 9)<br>		If Abs(x2# - x3#) &lt; 0.001 Then<br>			dx1# = x2# - x0#<br>			dy1# = y2# - y0#<br>			dz1# = z2# - z0#<br>			dx2# = x2# - x1#<br>			dy2# = y2# - y1#<br>			dz2# = z2# - z1#<br>		Else<br>			dx1# = x3# - x1#<br>			dy1# = y3# - y1#<br>			dz1# = z3# - z1#<br>			dx2# = x3# - x2#<br>			dy2# = y3# - y2#<br>			dz2# = z3# - z2#<br>		EndIf<br>		nx#(i%, j%) = (dy1# * dz2#) - (dz1# * dy2#)<br>		ny#(i%, j%) = (dz1# * dx2#) - (dx1# * dz2#)<br>		nz#(i%, j%) = (dx1# * dy2#) - (dy1# * dx2#)<br>		l# = Sqr#((nx#(i%, j%) * nx#(i%, j%)) + (ny#(i%, j%) * ny#(i%, j%)) + (nz#(i%, j%) * nz#(i%, j%)))<br>		nx#(i%, j%) = nx#(i%, j%) / l#<br>		ny#(i%, j%) = ny#(i%, j%) / l#<br>		nz#(i%, j%) = nz#(i%, j%) / l#<br>	Next<br>Next<br><br><br><br>Repeat<br>	Cls()<br>	rotateVertices(a#, b#, g#)<br>	rotateNormals(a#, b#, g#)<br>	drawSphere()<br>	Flip()<br>	If KeyDown(30) Then<br>		a# = a# + 1.00<br>		While a# &gt; 360.00<br>			a# = a# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(44) Then<br>		a# = a# - 1.00<br>		While a# &lt; 0.00<br>			a# = a# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(31) Then<br>		b# = b# + 1.00<br>		While b# &gt; 360.00<br>			b# = b# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(45) Then<br>		b# = b# - 1.00<br>		While b# &lt; 0.00<br>			b# = b# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(32) Then<br>		g# = g# + 1.00<br>		While g# &gt; 360.00<br>			g# = g# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(46) Then<br>		g# = g# - 1.00<br>		While g# &lt; 0.00<br>			g# = g# + 360.00<br>		Wend<br>	EndIf<br>Until KeyHit(1)<br>End<br><br><br><br>Function rotateVertices(alpha#, betha#, gamma#)<br>	For i% = 0 To 15<br>		For j% = 0 To 8<br>			xl0# = x#(i%, j%)<br>			yl0# = y#(i%, j%)<br>			zl0# = z#(i%, j%)<br>			xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#)<br>			yl1# = yl0#<br>			zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#)<br>			xl2# = xl1#<br>			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#)<br>			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#)<br>   			rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#)<br>			ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#)<br>			rz#(i%, j%) = zl2#<br>		Next<br>	Next<br>End Function<br><br><br><br>Function rotateNormals(alpha#, betha#, gamma#)<br>	For i% = 0 To 15<br>		For j% = 0 To 8<br>			xl0# = nx#(i%, j%)<br>			yl0# = ny#(i%, j%)<br>			zl0# = nz#(i%, j%)<br>			xl1# = zl0# * Sin#(betha#) + xl0# * Cos#(betha#)<br>			yl1# = yl0#<br>			zl1# = zl0# * Cos#(betha#) - xl0# * Sin#(betha#)<br>			xl2# = xl1#<br>			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#)<br>			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#)<br>   			rnx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#)<br>			rny#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#)<br>			rnz#(i%, j%) = zl2#<br>			Color 255, 255, 255<br>			Text 100 + 100 * j%, 100 + 20 * i%, rnz#(i%, j%)<br>		Next<br>	Next<br>End Function<br><br><br><br>Function drawSphere()<br>	For i% = 0 To 15<br>		For j% = 0 To 7<br>				x0# = +rx#(i%, j%) * 100.00 + 512.00<br>				y0# = -ry#(i%, j%) * 100.00 + 384.00<br>				x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + 512.00<br>				y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + 384.00<br>				x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + 512.00<br>				y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + 384.00<br>				x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + 512.00<br>				y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + 384.00<br>;			If Abs(x2# - x3#) &lt; 0.01 Then<br>;				dx1# = x2# - x0#<br>;				dy1# = y2# - y0#<br>;				dx2# = x2# - x1#<br>;				dy2# = y2# - y1#<br>;			Else<br>;				dx1# = x3# - x1#<br>;				dy1# = y3# - y1#<br>;				dx2# = x3# - x2#<br>;				dy2# = y3# - y2#<br>;			EndIf<br>;			bf# = (dx1# * (dy2# - dy1#)) - ((dx2# - dx1#) * dy1#)<br>;			If bf# &gt; 0.00 Then<br>			If rnz#(i%, j%) &gt; 0.00 Then<br>				If (j And 1)  Then<br>					Color 255, 0, 0<br>				Else<br>					Color 0, 255, 0<br>				EndIf<br>				Line x0#, y0#, x1#, y1#<br>				Line x1#, y1#, x2#, y2#<br>				Line x2#, y2#, x3#, y3#<br>				Line x3#, y3#, x0#, y0#<br>			EndIf<br>		Next<br>	Next<br>End Function<br>&lt;ENDCODE&gt; <br><br></td></tr></table><br>
<a name="276439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> BTW.:<br>If I Do this, instead, it works perfectly...<br><br>Function drawSphere() <br>For i% = 0 To 15 <br>For j% = 0 To 7 <br>x0# = +rx#(i%, j%) * 100.00 + 512.00 <br>y0# = -ry#(i%, j%) * 100.00 + 384.00 <br>x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + 512.00 <br>y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + 384.00 <br>x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + 512.00 <br>y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + 384.00 <br>x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + 512.00 <br>y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + 384.00 <br>If Abs(x2# - x3#) &lt; 0.01 Then <br>dx1# = x2# - x0# <br>dy1# = y2# - y0# <br>dx2# = x2# - x1# <br>dy2# = y2# - y1# <br>Else <br>dx1# = x3# - x1# <br>dy1# = y3# - y1# <br>dx2# = x3# - x2# <br>dy2# = y3# - y2# <br>EndIf <br>bf# = (dx1# * (dy2# - dy1#)) - ((dx2# - dx1#) * dy1#) <br>If bf# &gt; 0.00 Then <br>;If rnz#(i%, j%) &gt; 0.00 Then <br>If (j And 1) Then <br>Color 255, 0, 0 <br>Else <br>Color 0, 255, 0 <br>EndIf <br>Line x0#, y0#, x1#, y1# <br>Line x1#, y1#, x2#, y2# <br>Line x2#, y2#, x3#, y3# <br>Line x3#, y3#, x0#, y0# <br>EndIf <br>Next <br>Next <br>End Function <br><br>Why is that?<br>I hope it is just some programming error of mine, as opposed to a flaw in the algorythm itself.<br>(In other words, I am dtrying to use the rotated normals for lighting the polygons properly, as well as performing backface-culling.<br>But, as far as I can tell, and if there is no "programming error" or typo in the code, I must assume that the rotated normals are not accurate enough for performing back-face culling.<br>If that is the case, what kind of algorythm should I employe?)<br>Thanks a lot,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="276591"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doesn't the hardware do this anyway? <br><br></td></tr></table><br>
<a name="276593"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, hardware already does this much faster than any software ( even C++ ) can do it.<br><br>Unless you are not talking about rendering, maybe you are making something else e.g. dynamic lightmapping. <br><br></td></tr></table><br>
<a name="276610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think its a blitzplus app the guy is talking about. <br><br></td></tr></table><br>
<a name="276651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi.<br>I am trying to learn how 3d engines work.<br>Yes, it is written in Blitz Plus.<br>I am trying to learn how to do backface culling in software, instead of using the hardware.<br>It may sound stupid, specialy with all the 3d hardware available today, but it is a matter of learning how it works, instead of finding the best way to do it.<br>So far, I thought that the rotated normals would be good enough in order to perform the task, but my proggy didn´t work well.<br>Actualy, the problem only happens when I rotate around the X axis.<br>Can you help me find out what is wrong in the code?<br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="276736"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, i'm not too good on this kinda stuff. If i were doing this, i'd check to see if the normal of the triangle or vertex was facing away from the camera. Am i right in assuming that? And that the camera had it's own normal? <br><br></td></tr></table><br>
<a name="276814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> You need lots of resource info. 3D math is an art in itself. A better way is a dedicated book. I've bought 2 books on 3D graphics, the first one I bought a while ago is 3D Computer Graphics by Watt. The second is Trick of 3D programming Gurus. The second is worth its weight in gold.<br><br>You should be using polygon normals for back face culling, not vertex normals. Vertex normals are for lighting algos ( unless you want flat shaded polys ).<br><br>ps. I advise you to use matrix math. If you don't then you can end up with some seriously long equations :)<br>Anyway in your code you are updating the vertices and normals seperately, I changed your 'RotateVertices' code to this and commented out the call to 'RotateNormals':<br><br>Function rotateVertices(alpha#, betha#, gamma#) <br>For i% = 0 To 15 <br>For j% = 0 To 8 <br>xl0# = x#(i%, j%) <br>yl0# = y#(i%, j%) <br>zl0# = z#(i%, j%) <br>xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#) <br>yl1# = yl0# <br>zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#) <br>xl2# = xl1# <br>yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#) <br>zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#) <br>rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) <br>ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) <br>rz#(i%, j%) = zl2#<br><br>************ START OF MOD<br>rnx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) <br>rny#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) <br>rnz#(i%, j%) = zl2# <br>************ END OF MOD<br>Next <br>Next <br>End Function<br><br>There are still a few errors in there but hey, 2 mins work :) <br><br></td></tr></table><br>
<a name="276838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Col!<br>Thanks for the help.<br>Bellow, I have a new implementation, with some simple flat-shaded polygons, but now using your modifications/unification of rotateVertices/rotateNormals.<br>It works real good.<br>You may see that the polygons are all lit correctly, despite backface culling is not 100% correct yet...<br>But it doesn´t have to be. I mean, I do not need a 100% perfect backface culling algorythm.<br>It is ok if it does not drop a backface polygon, as long as it does not drop the ones that are facing the user.<br>Can you give me some more help ?<br>Please, take the code bellow and try it for yourself.<br>I know it is no fancy 3d engine or anything like that.<br>But all that I need is to get the lighting in place, as well as removing as many backfaces as possible, without dropping the visible ones --- even if this means drawing back-faces over front-faces.<br><br>I am doing all this because I have actualy written a very nice 3d engine, but was not able to handle lights properly.<br>Backface culling is something very cool that I want to add, but I already use a 32 bit Z-Buffer, which takes care of removing undesirable pixels (the ones that may pass the backface removal because of a flaw in the algorythm and/or lack of precision in the calculations).<br><br>I can tell you that the engine I have created is very cool, and includes a character creation tool, as well.<br>It currently runs on the PS2, without proper lighting.<br>As I do ALL of my researching wit Blitz Plus, I tryied to do it myself.<br><br>Please do me a BIG favor...<br>Just paste the code bellow into your BlitzPlus IDE and give it a try.<br>Just let me know if the lighting feels right, ok?<br><br>Thank you **so much** for your help!<br><br>Rui Barbosa Jr.<br><br>[CODE]<br>Dim polyhedre%(256, 256)<br>Dim paintArray%(256, 2)<br>;<br>Dim x#(16, 9)<br>Dim y#(16, 9)<br>Dim z#(16, 9)<br>;<br>Dim rx#(16, 9)<br>Dim ry#(16, 9)<br>Dim rz#(16, 9)<br>;<br>Dim nx#(16, 9)<br>Dim ny#(16, 9)<br>Dim nz#(16, 9)<br>;<br>Dim rnx#(16, 9)<br>Dim rny#(16, 9)<br>Dim rnz#(16, 9)<br>;<br>Global a# = 0.00<br>Global b# = 0.00<br>Global g# = 0.00<br>;<br>Global lx# = 1.00<br>Global ly# = 1.00<br>Global lz# = 1.00<br><br><br><br>Graphics 1024, 768, 16, 0<br>ClsColor 255, 128, 64<br><br><br><br>For i% = 0 To 15<br>	For	j% = 0 To 8<br>		r# = Sin#(22.50 * j%)<br>		x#(i%, j%) = Cos#(22.50 * i%) * r#<br>		y#(i%, j%) = Cos#(22.50 * j%)<br>		z#(i%, j%) = Sin#(22.50 * i%) * r#<br>	Next<br>Next<br><br><br><br>For i% = 0 To 15<br>	For j% = 0 To 8<br>		x0# = +x#(i%, j%)<br>		y0# = -y#(i%, j%)<br>		z0# = +z#(i%, j%)<br>		x1# = +x#((i% + 1) Mod 16, j%)<br>		y1# = -y#((i% + 1) Mod 16, j%)<br>		z1# = +z#((i% + 1) Mod 16, j%)<br>		x2# = +x#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		y2# = -y#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		z2# = +z#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		x3# = +x#(i%, (j% + 1) Mod 9)<br>		y3# = -y#(i%, (j% + 1) Mod 9)<br>		z3# = +z#(i%, (j% + 1) Mod 9)<br>		If Abs(x2# - x3#) &lt; 0.001 Then<br>			dx1# = x2# - x0#<br>			dy1# = y2# - y0#<br>			dz1# = z2# - z0#<br>			dx2# = x2# - x1#<br>			dy2# = y2# - y1#<br>			dz2# = z2# - z1#<br>		Else<br>			dx1# = x3# - x1#<br>			dy1# = y3# - y1#<br>			dz1# = z3# - z1#<br>			dx2# = x3# - x2#<br>			dy2# = y3# - y2#<br>			dz2# = z3# - z2#<br>		EndIf<br>		nx#(i%, j%) = (dy1# * dz2#) - (dz1# * dy2#)<br>		ny#(i%, j%) = (dz1# * dx2#) - (dx1# * dz2#)<br>		nz#(i%, j%) = (dx1# * dy2#) - (dy1# * dx2#)<br>		l# = Sqr#((nx#(i%, j%) * nx#(i%, j%)) + (ny#(i%, j%) * ny#(i%, j%)) + (nz#(i%, j%) * nz#(i%, j%)))<br>		nx#(i%, j%) = nx#(i%, j%) / l#<br>		ny#(i%, j%) = ny#(i%, j%) / l#<br>		nz#(i%, j%) = nz#(i%, j%) / l#<br>	Next<br>Next<br><br><br><br>Repeat<br>	Cls()<br>	rotateVertices(a#, b#, g#)<br>	drawSphere()<br>	Flip()<br>	If KeyDown(30) Then<br>		a# = a# + 1.00<br>		While a# &gt; 360.00<br>			a# = a# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(44) Then<br>		a# = a# - 1.00<br>		While a# &lt; 0.00<br>			a# = a# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(31) Then<br>		b# = b# + 1.00<br>		While b# &gt; 360.00<br>			b# = b# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(45) Then<br>		b# = b# - 1.00<br>		While b# &lt; 0.00<br>			b# = b# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(32) Then<br>		g# = g# + 1.00<br>		While g# &gt; 360.00<br>			g# = g# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(46) Then<br>		g# = g# - 1.00<br>		While g# &lt; 0.00<br>			g# = g# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(33) Then<br>		lx# = lx# - 0.03125<br>		While lx# &lt; 0.00<br>			lx# = lx# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(47) Then<br>		lx# = lx# + 0.03125<br>		While lx# &gt; 1.00<br>			lx# = lx# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(34) Then<br>		ly# = ly# - 0.03125<br>		While ly# &lt; 0.00<br>			ly# = ly# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(48) Then<br>		ly# = ly# + 0.03125<br>		While ly# &gt; 1.00<br>			ly# = ly# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(35) Then<br>		lz# = lz# - 0.03125<br>		While lz# &lt; 0.00<br>			lz# = lz# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(49) Then<br>		lz# = lz# + 0.03125<br>		While lz# &gt; 1.00<br>			lz# = lz# - 1.00<br>		Wend<br>	EndIf<br>Until KeyHit(1)<br>End<br><br><br><br>Function rotateVertices(alpha#, betha#, gamma#) <br>	For i% = 0 To 15 <br>		For j% = 0 To 8 <br>			xl0# = x#(i%, j%) <br>			yl0# = y#(i%, j%) <br>			zl0# = z#(i%, j%) <br>			xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#) <br>			yl1# = yl0# <br>			zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#) <br>			xl2# = xl1# <br>			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#) <br>			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#) <br>			rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) <br>			ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) <br>			rz#(i%, j%) = zl2#<br>			rnx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) <br>			rny#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) <br>			rnz#(i%, j%) = zl2# <br>		Next<br>	Next<br>End Function <br><br><br><br>Function drawSphere()<br>	For i% = 0 To 15<br>		For j% = 0 To 7<br>			x0# = +rx#(i%, j%) * 100.00 + 512.00<br>			y0# = -ry#(i%, j%) * 100.00 + 384.00<br>			x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + 512.00<br>			y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + 384.00<br>			x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + 512.00<br>			y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + 384.00<br>			x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + 512.00<br>			y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + 384.00<br>			If rnz#(i%, j%) &gt; 0.00 Then<br>				c% = (((rnx#(i%, j%) * lx#) + (rny#(i%, j%) * ly#) + (rnz#(i%, j%) * lz#)) / 1.00) * 255<br>				If c% &gt; 255 Then<br>					c% = 255<br>				Else<br>					If c% &lt; 15 Then<br>						c% = 15<br>					EndIf<br>				EndIf<br>				c% = (c% Shl 16)<br>				paintTriangle(x0#, y0#, x1#, y1#, x3#, y3#, c%)<br>				paintTriangle(x1#, y1#, x2#, y2#, x3#, y3#, c%)<br>			EndIf<br>		Next<br>	Next<br>End Function<br><br><br><br>Function paintTriangle(x0#, y0#, x1#, y1#, x2#, y2#, c%)<br>    minx# = 9999<br>    maxx# = 0<br>    miny# = 9999<br>    maxy# = 0<br>	;<br>	If x0# &lt; minx# Then minx# = x0#<br>	If x0# &gt; maxx# Then maxx# = x0#<br>	If x1# &lt; minx# Then minx# = x1#<br>	If x1# &gt; maxx# Then maxx# = x1#<br>	If x2# &lt; minx# Then minx# = x2#<br>	If x2# &gt; maxx# Then maxx# = x2#<br>	If y0# &lt; miny# Then miny# = y0#<br>	If y0# &gt; maxy# Then maxy# = y0#<br>	If y1# &lt; miny# Then miny# = y1#<br>	If y1# &gt; maxy# Then maxy# = y1#<br>	If y2# &lt; miny# Then miny# = y2#<br>	If y2# &gt; maxy# Then maxy# = y2#<br>	;<br>	xsize# = maxx# - minx#<br>	ysize# = maxy# - miny#<br>	;<br>	x0# = x0# - minx#<br>	x1# = x1# - minx#<br>	x2# = x2# - minx#<br>	y0# = y0# - miny#<br>	y1# = y1# - miny#<br>	y2# = y2# - miny#<br>	;<br>	For i% = 0 To xsize#<br>		For j% = 0 To ysize#<br>			polyhedre%(i%, j%) = 0<br>		Next<br>	Next<br>	;<br>	drawBresenhamLine(x0#, y0#, x1#, y1#)<br>	drawBresenhamLine(x1#, y1#, x2#, y2#)<br>	drawBresenhamLine(x2#, y2#, x0#, y0#)<br>	;<br>	For j% = 0 To ysize#<br>		For i% = 0 To xsize#<br>			If polyhedre%(i%, j%) Then<br>				paintArray%(j%, 0) = i%<br>				Exit<br>			EndIf<br>		Next<br>		For i% = xsize# To 0 Step -1<br>			If polyhedre%(i%, j%) Then<br>				paintArray%(j%, 1) = i%<br>				Exit<br>			EndIf<br>		Next<br>	Next<br>	;<br>	Color (c% Shr 16), (c% Shr 8) And 255, c% And 255<br>	;<br>	For i% = 0 To ySize#<br>		Line minx# + paintArray%(i%, 0), miny# + i%, minx# + paintArray%(i%, 1), miny# + i%<br>	Next<br>End Function<br><br><br><br>Function drawBresenhamLine(x0%, y0%, x1%, y1%)<br>	If x0% = x1% Then<br>		If y0% = y1% Then<br>			polyhedre%(x0%, y0%) = 1<br>			Return<br>		EndIf<br>		If y0% &lt; y1% Then<br>			For i% = y0% To y1%<br>				polyhedre%(x0%, i%) = 1<br>			Next<br>			Return<br>		EndIf<br>		For i% = y1% To y0%<br>			polyhedre%(x0%, i%) = 1<br>		Next<br>		Return<br>	EndIf<br>	If y0% = y1% Then<br>		If x0% &lt; x1% Then<br>			For i% = x0% To x1%<br>				polyhedre%(i%, y0%) = 1<br>			Next<br>			Return<br>		EndIf<br>		For i% = x1% To x0%<br>			polyhedre%(i%, y0%) = 1<br>		Next<br>		Return<br>	EndIf<br>	If y1% &lt; y0% Then<br>		temp% = y0%<br>		y0% = y1%<br>		y1% = temp%<br>		temp% = x0%<br>		x0% = x1%<br>		x1% = temp%<br>	EndIf<br>	dx% = x1% - x0%<br>	If dx% &lt; 0 Then<br>		dx% = -dx%<br>		xinc% = -1<br>	Else<br>		xinc% = 1<br>	EndIf<br>	dy% = y1% - y0%<br>	If dy% &lt; 0 Then<br>		dy% = -dy%<br>		yinc% = -1<br>	Else<br>		yinc% = 1<br>	EndIf<br>	two_dx% = dx% + dx%<br>	two_dy% = dy% + dy%<br>	xx% = x0%<br>	yy% = y0%<br>	If dx% &gt; dy% Then<br>		error% = 0<br>		For i% = 0 To dx%<br>			polyhedre%(xx%, yy%) = 1<br>			xx% = xx% + xinc%<br>			error% = error% + two_dy%<br>			If error% &gt; dx% Then<br>				error% = error% - two_dx%<br>				yy% = yy% + yinc%<br>			EndIf<br>		Next<br>	Else<br>		error% = 0<br>		For i% = 0 To dy%<br>			polyhedre%(xx%, yy%) = 1<br>			yy% = yy% + yinc%<br>			error% = error% + two_dx%<br>			If error% &gt; dy% Then<br>				error% = error% - two_dy%<br>				xx% = xx% + xinc%<br>			EndIf<br>		Next<br>	EndIf<br>End Function<br>[/CODE] <br><br></td></tr></table><br>
<a name="276841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> BTW: use the following keys to control rotations of the sphere and the light:<br><br>Sphere:<br>+  -  Axis<br>==========<br>A, Z  x<br>S, X  y<br>D, C  z<br><br>Light Source:<br>+  -  Axis<br>==========<br>F, V  x<br>G, B  y<br>H, N  z <br><br></td></tr></table><br>
<a name="276859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Col.<br><br>Here´s one thing that I need some help with:<br>In the code above, if I change the line<br><br>If rnz#(i%, j%) &gt; 0.00 Then<br><br>to<br><br>If rnz#(i%, j%) &gt; -0.25 Then<br><br>I get a perfect result.<br>Why is that?<br>If it is due to some lack of precision in the Blitz Plus compiler, then it is fine. If not, then that is a big worry to me...<br>... because I do not understand the reason why I had to change it.<br><br>As I told before, it drops less polys than it should, but that is fine, because I am using a z-buffer in the real engine.<br>The z-buffering takes care of those unwanted polygons.<br><br>But, again... why such a big difference?<br>I would be prepared to accept -0.01 or even -0.05 without asking, but -0.25... that´s almost 14.50 degrees off.<br><br>(I hope it is just a matter of math precision).<br><br>Thanks for your help,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="276889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> It also worked with <br><br>If rnz#(i%, j%) &gt; -0.21875 Then<br><br>That´s just about 12.5 degrees off, which is 56% of the precision I need (22.50 degrees or 1/16th of 360 degrees), so this should suffice.<br>If you can help me understand why this happens...<br>I do not even have to find a fix... just would like to know the reason why.<br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="276904"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> One more question...<br>I got the normals working --- actualy Col got them working.<br>(I just have to figure out the reason for the 12.5 degrees error, but that can be done later).<br><br>Now, the next step would be assigning indices to the normals, instead of applying rotations to the normals, I would like to be able to add the angles, then after that, find out which normal index to use, which would ultimately give me the normal itself (pre-stored, in a table).<br><br>There will be 144 unique normal indices, despite only 114 of them will actualy have unique normals assigned to them, but that is another story :^).<br><br>From those 114 diferent shades, only (up to) half of them can be seen at any given time.<br>That´s 57 different light gradients.<br>But, again, remember that those will be represented by (up to) 72 (= half of 144) unique normal indices.<br><br>Now, I am not *that smart*, so I am sure someone did that before.<br><br>Why do I want to do that?<br><br>Because I am working with hierarchyc models.<br>And, as you guys know, when you rotate a component, you must apply that rotation to all of its child components.<br>And you must do that recursively, untill you get to the bottom component;<br><br>For instance:<br><br>When move the shoulder, you must rotate it.<br>Then, you must rotate the elbow by the same angles.<br>Then you must go down piece by piece in the hierarchy.<br><br>Things get worse, when you get to the hand.<br>That´s because you will have to apply that same rotation to the first bone of each finger.<br>Then, apply it to every second bone, and the third bone (except for the thumb, of course).<br><br>The question is:<br>If instead of using the normals, I use the normal indices, which could be expressed as (alpha, betha), wouldn´t it be just a matter of adding the angles and, once you do that, get the correct normal index ?<br><br>You guys following me?<br>Is this totally wrong?<br><br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="276907"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> The lighting is incorrect. My fault 8( You have to make a decision whether you light by the polygon face or by the vertex. Currently you set the normals up as the polygon face normal, then with my mod we have changed to 'the vertex normal is now the vertex position'!! This is completely wrong! Oops.<br><br>I'm working a rewrite of your calculations....... <br><br></td></tr></table><br>
<a name="277003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Col.<br>Sorry for the delay.<br>Yes, I have to make a decision about what kind of normal I need.<br>I need the normals to be the polygon face normal.<br>As it is right now, "the vertex normal is now the vertex position" works fine for me.<br>And is a very good solution for my engine, trust me.<br>It is just fine, the way it is... except for the 12.5 degress offset.<br>(I have to compare against -0.21875 instead of 0.0)<br>If that can be fixed, then it will be perfect.<br>It would be great if you could help me with the 3d maths of it.<br>Trust me, the 3d engine for the PS2 is real good and I got a **good** use for it, already.<br>One more thing: it is a voxel based character engine.<br>So, you will find out why the "vertex normal is now the vertex position" is just fine.<br>(All that I need is a "normal ID" to assign to each vertex" and the normal is the vertex position itself, could be different, but works fine for me).<br><br>If you don´t get it, imagine a voxel ( A REAL VOXEL, that is... a real cube), imagine that the sphere is inside of it and touches each face of the voxel cube at the face´s exact center point.<br>If I rotate the cube (voxel), around its center, each face will still touch one single (different) point of the sphere.<br><br>I am planning on using a very limmited set of pre-computed normals... 144.<br>If you check the source-code again, you will see that I have set the sphere to exectly 144 polygons.<br><br>So, based on this, I guess you can help me find the best way to do it, right?<br>But, as far as my common-sense tells me, the vertex position is the normal itself, in this very specific voxel based engine.<br><br>Thanks again for your help, Col.<br><br>Hope to hear from you soon.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its is working fine already, Col...<br>But, if you could help me get rid of the 12.5 degrees difference, well... that would be just perfect.<br>I hope I am not bothering you...<br><br>Thanks again,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277070"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andy</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt;As I told before, it drops less polys than it should, but <br>&gt;that is fine, because I am using a z-buffer in the real <br>&gt;engine. <br><br>Have a look at this, it may be useful.<br><br><a href="http://www.cstone.net/~kyoung/sbuf_faq.html" target="_blank">http://www.cstone.net/~kyoung/sbuf_faq.html</a><br><br>Andy <br><br></td></tr></table><br>
<a name="277090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice one Andy.<br><br>Rui, to get your engine perfect maybe you should think about representing your data in a different format, at least until its working right, then change the format to what ever you wish. By format I mean you have a bunch of vetices in 3d space, then a bunch of polygons which will have each corner of the polygon point to the vertex. This way you can seperate polygon normal from vertex normal data. I did a quick example but using a simple cube although I'm sure this is not 100% technically correct ( I haven't tested it thoroughly ) it is only to show an outline of what I mean by means of representing your data.<br><br>[CODE]<br>Graphics 800,600,32,1<br><br>Dim Vertex#(8,3)	;Vertex Position BEFORE any transformation or rotation<br>Dim RVertex#(8,3)	;Vertex Position AFTER any transformation or rotation<br><br>Dim VNormal#(8,3)	;Vertex Normal BEFORE any transformation or rotation<br>Dim RVNormal#(8,3)	;Vertex Normal AFTER any transformation or rotation<br><br>Dim PNormal#(6,3)	;Polygon Normal BEFORE any transformation or rotation<br>Dim RPNormal#(6,3)  ;Polygon Normal AFTER any transformation or rotation<br><br>Dim polygon(6,4)	;1 quad per face * 6 faces, 4 vertices per quad<br><br>CreateObject<br><br>While Not KeyDown(1)<br>	<br>	Cls<br>	<br>	alpha=alpha+1<br>	beta=beta+1<br>	gamma=gamma+1<br>	<br>	RotateObject(alpha,beta,gamma)<br>	<br>	TransformObject(0,0,0)<br>		<br>	DrawObjectSolid<br>	;DrawObjectWireFrame<br>		<br>	Flip<br><br>Wend<br>End<br><br>Function CreateObject()<br>	;Setup cube vertices<br>	;            X                 Y                  Z<br>	Vertex(1,1)=-1.0  Vertex(1,2)=1.0   Vertex(1,3)=-1.0<br>	Vertex(2,1)=1.0   Vertex(2,2)=1.0   Vertex(2,3)=-1.0<br>	Vertex(3,1)=1.0   Vertex(3,2)=-1.0  Vertex(3,3)=-1.0<br>	Vertex(4,1)=-1.0  Vertex(4,2)=-1.0  Vertex(4,3)=-1.0<br>	Vertex(5,1)=-1.0  Vertex(5,2)=1.0   Vertex(5,3)=1.0<br>	Vertex(6,1)=1.0   Vertex(6,2)=1.0   Vertex(6,3)=1.0<br>	Vertex(7,1)=1.0   Vertex(7,2)=-1.0  Vertex(7,3)=1.0<br>	Vertex(8,1)=-1.0  Vertex(8,2)=-1.0  Vertex(8,3)=1.0<br><br>	;Define the polygon vertices<br>	polygon(1,1)=1   polygon(1,2)=2   polygon(1,3)=3   polygon(1,4)=4<br>	polygon(2,1)=2   polygon(2,2)=6   polygon(2,3)=7   polygon(2,4)=3<br>	polygon(3,1)=6   polygon(3,2)=5   polygon(3,3)=8   polygon(3,4)=7<br>	polygon(4,1)=5   polygon(4,2)=1   polygon(4,3)=4   polygon(4,4)=8<br>	polygon(5,1)=5   polygon(5,2)=6   polygon(5,3)=2   polygon(5,4)=1<br>	polygon(6,1)=4   polygon(6,2)=3   polygon(6,3)=7   polygon(6,4)=8<br><br>	;Scale the object solely for this demo<br>	ScaleObject(100)<br><br>	CreatePolygonNormals<br>End Function<br><br>Function CreatePolygonNormals()<br>	For poly=1 To 6<br>		;Get three vertices from each poly<br>		v1=polygon(poly,1)<br>		v2=polygon(poly,2)<br>		v3=polygon(poly,3)<br>		<br>		;now we the x,y,z position of each vertice<br>		vx1#=Vertex(v1,1)<br>		vy1#=Vertex(v1,2)<br>		vz1#=Vertex(v1,3)<br>		<br>		vx2#=Vertex(v2,1)<br>		vy2#=Vertex(v2,2)<br>		vz2#=Vertex(v2,3)<br><br>		vx3#=Vertex(v3,1)<br>		vy3#=Vertex(v3,2)<br>		vz3#=Vertex(v3,3)<br>		<br>		;Find v1-v2 and v1-v3 then place into u and v:<br>		ux#=vx1-vx2<br>		uy#=vy1-vy2<br>		uz#=vz1-vz2<br>		<br>		vx#=vx1-vx3<br>		vy#=vy1-vy3<br>		vz#=vz1-vz3<br>		<br>		;Create the Normal by finding the cross product<br>		Cx# = uy*vz - uz*vy 		<br>		Cy# = uz*vx - ux*vz <br>		Cz# = ux*vy - uy*vx <br>		<br>		;Normalize the normal<br>		If Cx&lt;&gt;0.0 Cx=Cx/Sqr(cx*cx)<br>		If Cy&lt;&gt;0.0 Cy=Cy/Sqr(cy*cy)<br>		If Cz&lt;&gt;0.0 Cz=Cz/Sqr(cz*cz)<br>		<br>		PNormal(poly,1)=Cx<br>		PNormal(poly,2)=Cy<br>		PNormal(poly,3)=Cz<br>	Next<br>End Function<br><br>Function ScaleObject(scale#)<br>	For vert=1 To 8<br>		Vertex(vert,1)=Vertex(vert,1)*Scale<br>		Vertex(vert,2)=Vertex(vert,2)*Scale<br>		Vertex(vert,3)=Vertex(vert,3)*Scale<br>	Next<br>End Function<br><br>Function RotateObject(alpha#,beta#,gamma#)<br>	;Rotate the Vertices<br>	For vert=1 To 8<br>		x0#=Vertex(vert,1)<br>		y0#=Vertex(vert,2)<br>		z0#=Vertex(vert,3)<br>		<br>		;Rotate around Y axis<br>		x1#=(Cos(beta) * z0) + (Sin(beta) * x0)<br>		y1#=y0<br>		z1#=-(Sin(beta) * z0) + (Cos(beta) * x0)<br>		<br>		;Rotate around X axis<br>		x2#=x1<br>		y2#=(y1 * Cos(alpha)) - (z1 * Sin(alpha))<br>		z2#=(y1 * Sin(alpha)) + (z1 * Cos(alpha))<br>		<br>		;Rotate around Z axis<br>		x3#=(x2 * Cos(gamma)) - (y2 * Sin(gamma))<br>		y3#=(x2 * Sin(gamma)) + (y2 * Cos(gamma))<br>		z3#=z2<br>		<br>		;Store in Rotated Vertex array<br>		RVertex(vert,1)=x3<br>		RVertex(vert,2)=y3<br>		RVertex(vert,3)=z3<br>	Next<br>	<br>	;Rotate the Normals<br>	For poly=1 To 6<br>		nx#=PNormal(poly,1)<br>		ny#=PNormal(poly,2)<br>		nz#=PNormal(poly,3)<br>		<br>		;Rotate around Y axis<br>		nx1#=(Cos(beta) * nz) + (Sin(beta) * nx)<br>		ny1#=ny<br>		nz1#=-(Sin(beta) * nz) + (Cos(beta) * nx)<br>		<br>		;Rotate around X axis<br>		nx2#=nx1<br>		ny2#=(ny1 * Cos(alpha)) - (nz1 * Sin(alpha))<br>		nz2#=(ny1 * Sin(alpha)) + (nz1 * Cos(alpha))<br>		<br>		;Rotate around Z axis<br>		nx3#=(nx2 * Cos(gamma)) - (ny2 * Sin(gamma))<br>		ny3#=(nx2 * Sin(gamma)) + (ny2 * Cos(gamma))<br>		nz3#=nz2<br><br>		RPNormal(poly,1)=nx3<br>		RPNormal(poly,2)=ny3<br>		RPNormal(poly,3)=nz3<br>	Next<br>End Function<br><br>Function TransformObject(Tx#,Ty#,Tz#)<br>	For vert=1 To 8<br>		x#=RVertex(vert,1)<br>		y#=RVertex(vert,2)<br>		z#=RVertex(vert,3)<br>				<br>		RVertex(vert,1)=x+Tx<br>		RVertex(vert,2)=y+Ty<br>		RVertex(vert,3)=z+Tz<br>	Next<br>End Function<br><br>Function DrawObjectSolid()<br>	;For back face removal we test the dot product<br>	;between our view vector and the polygon normal<br>	<br>	;Our View vector<br>	ViewX#=0.0<br>	ViewY#=0.0<br>	ViewZ#=1.0<br>	<br>	For poly=1 To 6<br>		Nx#=RPNormal(poly,1)<br>		Ny#=RPNormal(poly,2)<br>		Nz#=RPNormal(poly,3)<br>		<br>		;If View.Normal &gt; 0 then render ( ignore back facing polys )<br>		If ViewX*NX + ViewY*Ny + ViewZ*Nz &gt; 0.0<br>			RenderPolygon(poly)<br>		EndIf<br>	Next<br>	<br>End Function<br><br>Function DrawObjectWireFrame()<br>	For poly=1 To 6<br>		RenderPolygon(poly)<br>	Next<br>End Function<br><br>Function RenderPolygon(poly)<br>	v1=polygon(poly,1)<br>	v2=polygon(poly,2)<br>	v3=polygon(poly,3)<br>	v4=polygon(poly,4)<br>	<br>	vx1#=RVertex(v1,1)	vy1#=RVertex(v1,2)    vz1#=RVertex(v1,3)<br>	vx2#=RVertex(v2,1)	vy2#=RVertex(v2,2)    vz2#=RVertex(v2,3)<br>	vx3#=RVertex(v3,1)	vy3#=RVertex(v3,2)    vz3#=RVertex(v3,3)<br>	vx4#=RVertex(v4,1)	vy4#=RVertex(v4,2)    vz4#=RVertex(v4,3)<br>	<br>	sx1#=400+vx1<br>	sy1#=300+vy1<br>	sx2#=400+vx2<br>	sy2#=300+vy2<br>	sx3#=400+vx3<br>	sy3#=300+vy3<br>	sx4#=400+vx4<br>	sy4#=300+vy4<br>	<br>	Line sx1,sy1,sx2,sy2<br>	Line sx2,sy2,sx3,sy3<br>	Line sx3,sy3,sx4,sy4<br>	Line sx4,sy4,sx1,sy1<br>End Function<br>[/CODE]<br><br>I feel this is a step in the right direction, simply because we need to eliminate as many errors as early as possible, especially before they introduce new errors that are nearly impossible to find. The only reason the previous code seems to work is because the object in at world origin ( 0,0,0 ) as soon as your move away from that position, the algo will fail badly along with all the lighting. <br><br></td></tr></table><br>
<a name="277184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ho Andy.<br>I was aware of s-buffers before I started working on the voxel engine.<br>S-BUFFER´s are cool, but in a voxel-space, dealing with z-buffer makes much more sense, because uualy, objects are seen from a distance at which voxels are almost 1 pixel x 1 pixel big.<br>The actualy are cubes, math-wise, and they actualy look like cubes, when you take a VERY close look at them.<br>But *usualy* they are at most 4 pixels big, which doesn´t allow for efficient use of S-BUFFERS.<br>Thanks for the tip, thou.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277198"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Col.<br><br>I have checked the rotating cube.<br>And it works perfectly.<br>Now, don´t worry about having it centered at the world coordinates.<br>The voxel engine works just the same.<br>When I rotate a voxel object around its picot, I just have to do this:<br><br>x# = x# - pivotX#<br>y# = y# - pivotY#<br>z# = z# - pivotZ#<br>;<br>;Rotate the voxel object here<br>;<br>x# = x# + pivtoX#<br>y# = y# + pivotY#<br>z# = z# + pivotY#<br><br>And tht is all it takes in order to take the pivot coordinates out of the way.<br><br>I would like to try your method with the voxel engine.<br>But, first, I would like to experiment with a sphere, instead of a cube.<br>If it works properly, no doubt I will use it.<br>An I thank you you for the great help.<br><br>I will have to get rid of floating point variables, and find a more compact way for representing the normals thou.<br>The spiderman head, for instance, employes 9800 voxels, and is equivalent to a 2000 polygons head model, in terms of graphics quality.<br>So, you see, storing 9800 normals is very memory consumming, specialy when you need photo-realistic models on the screen.<br>Spiderman, alone, uses 45 objects.<br>Some are small, like the fingers, but some are pretty big - his chest.<br>The average size is the shoulder.<br>BTW: If you want to have a better idea of how I cut spiderman in order to model it, take a look at Marvel´s fully poseable action figures. I actually have bought two spidermans.<br>One of them is right in front of me, and I use it to check the screen output against the real toy.<br>The other one... went through a surgic procedure hehe...  got all of its parts, disassembled, in order to make it easier for me to model them.<br>Hierarchy is fine, too.<br>But here´s another thing... the final version of the engine will have to deal with normal indices, instead of the normals itself.<br>Because each time I draw the model, I have to recalculate the lighting for EACH voxel, which is very ime consumming.<br><br>I have already implemmented the normal indices, that does make it practical, because instead of computing the rotated normals for all 9800 voxels of spideys head, for instance, I only have to rotate 144 normals, no matter how far or how big it is.<br><br>This is even more critical when you add hierarchy to it.<br>Take spideys butt, for instance (sorry for the name, bu that was the word that came to my mind when I wrote the hierarchy part of the code).<br>Every time a change the butt´s rotation, I have to recalculate ALL normal tables for each and every piece of the model.<br>That is a total of 345 normal tables, each consisting of 144 normals = almost 50.000 normals!<br>Now, add to that, the fact that no 3d engine would be usable if you can have only one character at the screen, at any given time.<br>Double it, if you want to write a fighting game, and you end-up with almost 100.000 normals to rotate.<br><br>That´s why I have to use normal tables.<br>Handling individual voxel normals would make it absolutely impossible to achieve.<br><br>After implementing the lighting, no matter how slow it will run, I will have o find a way to use normal indices, no matter what... or else, I will have to forget about real-time lighting.<br><br>I have put all this info here, because I would like you to have a very clear understanding of why the backface-culling and normal rotation is so critical to the voxel engine.<br>The previous version of backface culling works fine, believe me... the number of drawn voxels dropped from 9800 5300 - the perfect solution would give us a count of 4900 voxels actualy drawn, but that is close enough - the engine is spending only 9.2% more time than it should.<br>I am prepared to accept that performance loss, for now.<br>But I truly agree with you that, if it can be done right from the start, then it is better to spend more time on that now than trying to find errors later.<br><br>I am glad you are helping me.<br>Thank you so much.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277215"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I took a closer look at your cube code.<br>That´s exactly what I am looking for.<br>Bacface culling based on the rotated normals!<br>I just have to try it with the sphere now, to make sure it will work for all 144 possible angles.<br>If it works, then that´s how I am going to do it.<br><br>Just a few more words on why this code is so crytical to the voxel engine...<br><br>1. Take the terminal bone of the pointing finger.<br>Every time I draw it, I have to apply its own x, y and z rotations to it, right?<br>But, before that, I have to apply its parents rotations to it.<br>And, before that, I have to apply its parents´parent´s rotations to it.<br>And this goes recursively, untill I reach the topmost object (in this case, the "butt").<br>So, after all the recursive path is taken, I end up applying 11 rotations to that small part of the model.<br>The part immediately above it, needs 10 rotations, and the one above it, 9 rotations, etc...<br>That´s why I end up with 345 rotations for each character per each frame.<br>(Actualy, it´s 115 rotations, but I am considering the rotation of each independent component of the normal here, i.e., 3 components per normal = 345 rotations).<br><br>So, all that I actualy need, is ONE single polygon model, which has to be a sphere.<br>This same sphere, with radius = 1.00, will be used to generate all normal rotations, and will be used to rebuild each normals table.<br><br>This is important to understand... rotations to normals won´t be applied to the character or any of its components.<br>They will be applied to the same sphere, every time.<br>This will allow for some level of optimization.<br><br>Thanks again,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Paradox7</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> weeeee, alright, check it, does it work ok now? the change was in the rotateVertices, i made other little modifications, only because i love modding stuff :D You can spin the sphere with the Mouse! Try it, move mouse slow, also Press Q to make it bounce around the screen, press it again to stop it. You also forgot to put Setbuffer Backbuffer() so i added that, it smooth now, and doesn't flicker, I also made it screen res independent, so you can change the res to anything you want, and it will work just as perfectly, try it, 640, 480 :D<br><br>Before you start pressing Q and moving with the mouse and screen res changes, just give it a normal spin, hold Z X together, and you will see that it culls alot better, its not all blockly and ODD looking as before, How Did I Do It?<br><br>I have no freakin clue, i'm just a master of messing with stuff till it works, or i give up :P I know nothing of 3D programming, and have no clue to wtf is going on, although I wish I did, this is awesome. Great work, i noticed that your light source is Fixed to the sphere.<br><br><br><br><pre class=code>
Dim polyhedre%(256, 256)
Dim paintArray%(256, 2)
;
Dim x#(16, 9)
Dim y#(16, 9)
Dim z#(16, 9)
;
Dim rx#(16, 9)
Dim ry#(16, 9)
Dim rz#(16, 9)
;
Dim nx#(16, 9)
Dim ny#(16, 9)
Dim nz#(16, 9)
;
Dim rnx#(16, 9)
Dim rny#(16, 9)
Dim rnz#(16, 9)
;
Global a# = 0.00
Global b# = 0.00
Global g# = 0.00
;
Global lx# = 1.00
Global ly# = 1.00
Global lz# = 1.00



Graphics 1024, 768, 16, 1
SetBuffer BackBuffer()
ClsColor 255, 128, 64



For i% = 0 To 15
	For	j% = 0 To 8
		r# = Sin#(22.50 * j%)
		x#(i%, j%) = Cos#(22.50 * i%) * r#
		y#(i%, j%) = Cos#(22.50 * j%)
		z#(i%, j%) = Sin#(22.50 * i%) * r#
	Next
Next



For i% = 0 To 15
	For j% = 0 To 8
		x0# = +x#(i%, j%)
		y0# = -y#(i%, j%)
		z0# = +z#(i%, j%)
		x1# = +x#((i% + 1) Mod 16, j%)
		y1# = -y#((i% + 1) Mod 16, j%)
		z1# = +z#((i% + 1) Mod 16, j%)
		x2# = +x#((i% + 1) Mod 16, (j% + 1) Mod 9)
		y2# = -y#((i% + 1) Mod 16, (j% + 1) Mod 9)
		z2# = +z#((i% + 1) Mod 16, (j% + 1) Mod 9)
		x3# = +x#(i%, (j% + 1) Mod 9)
		y3# = -y#(i%, (j% + 1) Mod 9)
		z3# = +z#(i%, (j% + 1) Mod 9)
		If Abs(x2# - x3#) &lt; 0.001 Then
			dx1# = x2# - x0#
			dy1# = y2# - y0#
			dz1# = z2# - z0#
			dx2# = x2# - x1#
			dy2# = y2# - y1#
			dz2# = z2# - z1#
		Else
			dx1# = x3# - x1#
			dy1# = y3# - y1#
			dz1# = z3# - z1#
			dx2# = x3# - x2#
			dy2# = y3# - y2#
			dz2# = z3# - z2#
		EndIf
		nx#(i%, j%) = (dy1# * dz2#) - (dz1# * dy2#)
		ny#(i%, j%) = (dz1# * dx2#) - (dx1# * dz2#)
		nz#(i%, j%) = (dx1# * dy2#) - (dy1# * dx2#)
		l# = Sqr#((nx#(i%, j%) * nx#(i%, j%)) + (ny#(i%, j%) * ny#(i%, j%)) + (nz#(i%, j%) * nz#(i%, j%)))
		nx#(i%, j%) = nx#(i%, j%) / l#
		ny#(i%, j%) = ny#(i%, j%) / l#
		nz#(i%, j%) = nz#(i%, j%) / l#
	Next
Next


	xdir = 5
	ydir = 5
	xres = GraphicsWidth()
	yres = GraphicsHeight()
	BounceX = xres/2
	BounceY = yres/2
	
Repeat
	Cls()
	rotateVertices(a#, b#, g#)
	drawSphere(bounceX,bounceY)
	Flip()

	;Mouse Control WOOHOO :D
	b# = b#-MouseXSpeed() Mod 360
	a# = a#-MouseYSpeed() Mod 360
	MoveMouse 512, 384

	;Make it Move! press Q
	If KeyHit(16) move = 1 - move
	If move Then
		bounceX = bounceX + xdir
		bounceY = bounceY + ydir
		If bounceX &gt; xres Then xdir = -5
		If bounceX &lt; 0 Then xdir = 5
		If bounceY &gt; yres Then ydir = -5
		If bounceY &lt; 0 Then ydir = 5
	End If

	
	If KeyDown(30) Then
		a# = a# + 1.00
		While a# &gt; 360.00
			a# = a# - 360.00
		Wend
	EndIf
	If KeyDown(44) Then
		a# = a# - 1.00
		While a# &lt; 0.00
			a# = a# + 360.00
		Wend
	EndIf
	If KeyDown(31) Then
		b# = b# + 1.00
		While b# &gt; 360.00
			b# = b# - 360.00
		Wend
	EndIf
	If KeyDown(45) Then
		b# = b# - 1.00
		While b# &lt; 0.00
			b# = b# + 360.00
		Wend
	EndIf
	If KeyDown(32) Then
		g# = g# + 1.00
		While g# &gt; 360.00
			g# = g# - 360.00
		Wend
	EndIf
	If KeyDown(46) Then
		g# = g# - 1.00
		While g# &lt; 0.00
			g# = g# + 360.00
		Wend
	EndIf
	If KeyDown(33) Then
		lx# = lx# - 0.03125
		While lx# &lt; 0.00
			lx# = lx# + 1.00
		Wend
	EndIf
	If KeyDown(47) Then
		lx# = lx# + 0.03125
		While lx# &gt; 1.00
			lx# = lx# - 1.00
		Wend
	EndIf
	If KeyDown(34) Then
		ly# = ly# - 0.03125
		While ly# &lt; 0.00
			ly# = ly# + 1.00
		Wend
	EndIf
	If KeyDown(48) Then
		ly# = ly# + 0.03125
		While ly# &gt; 1.00
			ly# = ly# - 1.00
		Wend
	EndIf
	If KeyDown(35) Then
		lz# = lz# - 0.03125
		While lz# &lt; 0.00
			lz# = lz# + 1.00
		Wend
	EndIf
	If KeyDown(49) Then
		lz# = lz# + 0.03125
		While lz# &gt; 1.00
			lz# = lz# - 1.00
		Wend
	EndIf
Until KeyHit(1)
End





Function rotateVertices(alpha#, betha#, gamma#) 
	For i% = 0 To 15 
		For j% = 0 To 8
		
			;Vertices
			xl0# = x#(i%, j%) 
			yl0# = y#(i%, j%) 
			zl0# = z#(i%, j%) 
			xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#) 
			yl1# = yl0# 
			zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#) 
			xl2# = xl1# 
			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#) 
			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#) 
			rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) 
			ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) 
			rz#(i%, j%) = zl2#

			;Normals
			xl0# = nx#(i%, j%) 
			yl0# = ny#(i%, j%) 
			zl0# = nz#(i%, j%) 
			xl1# = zl0# * Sin#(betha#) + xl0# * Cos#(betha#) 
			yl1# = yl0# 
			zl1# = zl0# * Cos#(betha#) - xl0# * Sin#(betha#) 
			xl2# = xl1#

			;+ - is Oppisite of the Vertices - +, looks like it doesn't matter which is set with + - just as long as the other is oppisite of it - +
			; Its this oppisite sign change that actually makes it work, put it back to the same as the other one
			; - + and see how its messed up :P
			yl2# = yl1# * Cos#(alpha#) + zl1# * Sin#(alpha#) 
			zl2# = yl1# * Sin#(alpha#) - zl1# * Cos#(alpha#)
			;Main Change, Sign Change

				
			rnx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) 
			rny#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) 
			rnz#(i%, j%) = zl2#
		Next
	Next
End Function 



Function drawSphere(xloc, yloc)
	For i% = 0 To 15
		For j% = 0 To 7
			x0# = +rx#(i%, j%) * 100.00 + xloc ;512.00
			y0# = -ry#(i%, j%) * 100.00 + yloc ;384.00
			x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + xloc ;512.00
			y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + yloc ;384.00
			x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + xloc ;512.00
			y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + yloc ;384.00
			x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + xloc ;512.00
			y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + yloc ;384.00
			If rnz#(i%, j%) &gt; 0.00 Then
				c% = (((rnx#(i%, j%) * lx#) + (rny#(i%, j%) * ly#) + (rnz#(i%, j%) * lz#)) / 1.00) * 255
				If c% &gt; 255 Then
					c% = 255
				Else
					If c% &lt; 15 Then
						c% = 15
					EndIf
				EndIf
				c% = (c% Shl 16)
				paintTriangle(x0#, y0#, x1#, y1#, x3#, y3#, c%)
				paintTriangle(x1#, y1#, x2#, y2#, x3#, y3#, c%)
			EndIf
		Next
	Next
End Function



Function paintTriangle(x0#, y0#, x1#, y1#, x2#, y2#, c%)
    minx# = 9999
    maxx# = 0
    miny# = 9999
    maxy# = 0
	;
	If x0# &lt; minx# Then minx# = x0#
	If x0# &gt; maxx# Then maxx# = x0#
	If x1# &lt; minx# Then minx# = x1#
	If x1# &gt; maxx# Then maxx# = x1#
	If x2# &lt; minx# Then minx# = x2#
	If x2# &gt; maxx# Then maxx# = x2#
	If y0# &lt; miny# Then miny# = y0#
	If y0# &gt; maxy# Then maxy# = y0#
	If y1# &lt; miny# Then miny# = y1#
	If y1# &gt; maxy# Then maxy# = y1#
	If y2# &lt; miny# Then miny# = y2#
	If y2# &gt; maxy# Then maxy# = y2#
	;
	xsize# = maxx# - minx#
	ysize# = maxy# - miny#
	;
	x0# = x0# - minx#
	x1# = x1# - minx#
	x2# = x2# - minx#
	y0# = y0# - miny#
	y1# = y1# - miny#
	y2# = y2# - miny#
	;
	For i% = 0 To xsize#
		For j% = 0 To ysize#
			polyhedre%(i%, j%) = 0
		Next
	Next
	;
	drawBresenhamLine(x0#, y0#, x1#, y1#)
	drawBresenhamLine(x1#, y1#, x2#, y2#)
	drawBresenhamLine(x2#, y2#, x0#, y0#)
	;
	For j% = 0 To ysize#
		For i% = 0 To xsize#
			If polyhedre%(i%, j%) Then
				paintArray%(j%, 0) = i%
				Exit
			EndIf
		Next
		For i% = xsize# To 0 Step -1
			If polyhedre%(i%, j%) Then
				paintArray%(j%, 1) = i%
				Exit
			EndIf
		Next
	Next
	;
	Color (c% Shr 16), (c% Shr 8) And 255, c% And 255
	;
	For i% = 0 To ySize#
		Line minx# + paintArray%(i%, 0), miny# + i%, minx# + paintArray%(i%, 1), miny# + i%
	Next
End Function



Function drawBresenhamLine(x0%, y0%, x1%, y1%)
	If x0% = x1% Then
		If y0% = y1% Then
			polyhedre%(x0%, y0%) = 1
			Return
		EndIf
		If y0% &lt; y1% Then
			For i% = y0% To y1%
				polyhedre%(x0%, i%) = 1
			Next
			Return
		EndIf
		For i% = y1% To y0%
			polyhedre%(x0%, i%) = 1
		Next
		Return
	EndIf
	If y0% = y1% Then
		If x0% &lt; x1% Then
			For i% = x0% To x1%
				polyhedre%(i%, y0%) = 1
			Next
			Return
		EndIf
		For i% = x1% To x0%
			polyhedre%(i%, y0%) = 1
		Next
		Return
	EndIf
	If y1% &lt; y0% Then
		temp% = y0%
		y0% = y1%
		y1% = temp%
		temp% = x0%
		x0% = x1%
		x1% = temp%
	EndIf
	dx% = x1% - x0%
	If dx% &lt; 0 Then
		dx% = -dx%
		xinc% = -1
	Else
		xinc% = 1
	EndIf
	dy% = y1% - y0%
	If dy% &lt; 0 Then
		dy% = -dy%
		yinc% = -1
	Else
		yinc% = 1
	EndIf
	two_dx% = dx% + dx%
	two_dy% = dy% + dy%
	xx% = x0%
	yy% = y0%
	If dx% &gt; dy% Then
		error% = 0
		For i% = 0 To dx%
			polyhedre%(xx%, yy%) = 1
			xx% = xx% + xinc%
			error% = error% + two_dy%
			If error% &gt; dx% Then
				error% = error% - two_dx%
				yy% = yy% + yinc%
			EndIf
		Next
	Else
		error% = 0
		For i% = 0 To dy%
			polyhedre%(xx%, yy%) = 1
			yy% = yy% + yinc%
			error% = error% + two_dx%
			If error% &gt; dy% Then
				error% = error% - two_dy%
				xx% = xx% + xinc%
			EndIf
		Next
	EndIf
End Function
</pre> <br><br></td></tr></table><br>
<a name="277244"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Paradox7</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, just to note, i never come into this forum, why would I, i'm not even a newbie to 3d programming, i'm below that :P so why come into the Advance 3D, anyways, I first saw your little program in the <br><a href="http://www.blitzbasic.com/bbs/posts.php?topic=26491" target="_blank">http://www.blitzbasic.com/bbs/posts.php?topic=26491</a><br><br>post, where you complimenting halo, I had first fixed it there, just by that simple, change sign on Only one or the other, and it worked. So I went looking for your post in here, as you said you posted in here, so I can see if you found a solution yet, and so I found your updated version. I applied the changes, including it seems you need both vertices and normals, not combined, and other little modifications. Hope it helps ya :)<br><br>P.S. I have no clue wtf a normal or vertice is :P <br><br></td></tr></table><br>
<a name="277253"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here´s a list of all simplifications that can be applyied to the algorythm:<br><br>1. There is only ONE polygon object, the normal´s sphere.<br>2. Its radius is 1.00.<br>3. Its center point is always located at the world origin, (0.00, 0.00, 0.00).<br>4. The sphere has a total of 144 polygons.<br>Of those, 32 are triangles and 112 are quadrangles.<br>6. If it allows for more optimization, all faces can be handled as triangles, so the sphere is actualy a collection of 144 triangles.<br>7. The sphere is only drawn in order to check the correctness of the backface culling and lighting. But, in the voxel engine, it is never actualy drawn.<br>8. The viewing vector is always (0.00, 0.00, 1.00).<br>There is no camera vector at all. Al changes in the camera position and/or rotation are achieved by moving/scalling/rotating the voxel objects, not the cammera.<br>9. A voxel original normal is stored as an 8 bit value, holding only two angles, Alpha and betha.<br>This 8 bits value indexes a table, which has 144 entries, and returns the 3 components of the normal (nx#, ny#, nz#).<br><br>a% = int(floor#(Alpha# / 22.50)<br>b% = int(floor#(Betha# / 22.50)<br>If (a% &gt; 4) And (a% &lt; 12) Then<br>	a% = (8 - al%) And $0f<br>	b% = be% Xor $08<br>EndIf<br><br>The gamma# is not needed, because these are just the ORIGINAL normals, meaning that no rotation has been applied to them.<br>I chose to use alpha# and betha# as the indice, just because it is easier to remember, but the normal indices are not required to be related to any angle at all.<br>(i just did it this way because it makes it easy to find the angle I want in that big orange I have, with the needles stuck in it).<br><br>I hope this inromation helps.<br>Hey, Col... I don´t mean to bother you, but you know 3d maths and I appreciate your help.<br><br>I, on the other hand, am not comfortable with normals, dot products, etc...<br>So, if you can help me get any further...<br>Thanks a lot,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Paradox7</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow, you posted at the same time I did, this only a bump, incase you don't look above your last post, thinking nobody posted before your last post, and you just scroll all the way down and past my post, looking for new replys. <br><br></td></tr></table><br>
<a name="277281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here´s another thing I´d like to share about the vboxel character engine...<br><br>I have created a cirtual machine, from the ground up, which allows for creating scripts that allow the user to create the AI for NPC´s.<br>I have also created a compiler and a debugger.<br><br>Alright, voxels don´t seem to be a nice technology anylonger, right?<br>I mean, with all those fancy 3d cards, capable of drawing millions of polyfgons per second...<br>But hey, voxels still can play a part in 3d games, as long as some people keep trying to get things done with voxels.<br><br>So, any help is welcome.<br>Thank you guys,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277292"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> The voxel engine has its own scripting language.<br>I have written the IDE, the compiler and the debugger in BlitzPlus, which by the way, I like a lot.<br><br>The cirtual machine was written in gcc, because I needed to port it to PS2 ans Linux.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Paradox7</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> you see the perfect culling on the sphere? <br><br></td></tr></table><br>
<a name="277298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am orry, paradox.<br>But I did not find your code.<br>I will try it immediately.<br>Please let me know wher I can find it.<br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277299"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ho... I got it.<br>Sorry...<br>It really happened that way...<br>You did post at the same time as I did...  and I did not check the posts prior to my last post.<br>One mustake I wll try not to make again.<br>Thanks.<br>I will run your version now.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277328"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi.<br>Just tryied it.<br>It works very well!<br><br>There is still a minor problem: when I rotate around the Z axis, the lighting doesn´t show properly.<br>Backface culling is 100% fine, now.<br><br>Now, if we get the the rotation around the Z axis working, then everything is gonna be perfect!<br><br>So, as I do not know wxactly what´s going on in the code, please help me get this one last thing out of the way. Please? oh, pleeeeeeease!<br><br>Thanks a lot,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277398"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys.<br>Col, did you try the last version?<br>Do you think you can figure out what is wrong with the rotation around the Z axis?<br>I tryied myself, but I just don´t understand it well enough in order to find out.<br>Paradox7?<br>Andy?<br>Anyone?<br><br>Cheers,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277410"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys.<br>I took a closer look at the code.<br>Have re-checked my sketches.<br>Its is now working fine.<br>Once again, it was just a matter of wrong signs.<br>Now, backface culling is 100% correct, as well as lighting.<br>It all failed in the first version, bacause I have defined the polygons using clock-wise order.<br>But all calculations were taking place based on counter-clock wise order of vertices - which is the most used standard.<br>So, my normals where all pointing inwads, instead of outwards.<br>I have done as paradox7, have changed the signs and it all works fine now.<br><br>Well, at least that is what I think.<br>Please, correct me if I am wrong.<br><br>Btw: Here is the latest code:<br><br>[CODE]<br>Dim polyhedre%(256, 256)<br>Dim paintArray%(256, 2)<br>;<br>Dim x#(16, 9)<br>Dim y#(16, 9)<br>Dim z#(16, 9)<br>;<br>Dim rx#(16, 9)<br>Dim ry#(16, 9)<br>Dim rz#(16, 9)<br>;<br>Dim nx#(16, 9)<br>Dim ny#(16, 9)<br>Dim nz#(16, 9)<br>;<br>Dim rnx#(16, 9)<br>Dim rny#(16, 9)<br>Dim rnz#(16, 9)<br>;<br>Global a# = 0.00<br>Global b# = 0.00<br>Global g# = 0.00<br>;<br>Global lx# = 1.00<br>Global ly# = 1.00<br>Global lz# = 1.00<br><br><br><br>Graphics 1024, 768, 16, 1<br>SetBuffer BackBuffer()<br>ClsColor 255, 128, 64<br><br><br><br>For i% = 0 To 15<br>	For	j% = 0 To 8<br>		r# = Sin#(22.50 * j%)<br>		x#(i%, j%) = Cos#(22.50 * i%) * r#<br>		y#(i%, j%) = Cos#(22.50 * j%)<br>		z#(i%, j%) = Sin#(22.50 * i%) * r#<br>	Next<br>Next<br><br><br><br>For i% = 0 To 15<br>	For j% = 0 To 8<br>		x0# = +x#(i%, j%)<br>		y0# = -y#(i%, j%)<br>		z0# = +z#(i%, j%)<br>		x1# = +x#((i% + 1) Mod 16, j%)<br>		y1# = -y#((i% + 1) Mod 16, j%)<br>		z1# = +z#((i% + 1) Mod 16, j%)<br>		x2# = +x#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		y2# = -y#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		z2# = +z#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		x3# = +x#(i%, (j% + 1) Mod 9)<br>		y3# = -y#(i%, (j% + 1) Mod 9)<br>		z3# = +z#(i%, (j% + 1) Mod 9)<br>		If Abs(x2# - x3#) &lt; 0.001 Then<br>			dx1# = x2# - x0#<br>			dy1# = y2# - y0#<br>			dz1# = z2# - z0#<br>			dx2# = x2# - x1#<br>			dy2# = y2# - y1#<br>			dz2# = z2# - z1#<br>		Else<br>			dx1# = x3# - x1#<br>			dy1# = y3# - y1#<br>			dz1# = z3# - z1#<br>			dx2# = x3# - x2#<br>			dy2# = y3# - y2#<br>			dz2# = z3# - z2#<br>		EndIf<br>		nx#(i%, j%) = (dy1# * dz2#) - (dz1# * dy2#)<br>		ny#(i%, j%) = (dz1# * dx2#) - (dx1# * dz2#)<br>		nz#(i%, j%) = (dx1# * dy2#) - (dy1# * dx2#)<br>		l# = Sqr#((nx#(i%, j%) * nx#(i%, j%)) + (ny#(i%, j%) * ny#(i%, j%)) + (nz#(i%, j%) * nz#(i%, j%)))<br>		nx#(i%, j%) = nx#(i%, j%) / l#<br>		ny#(i%, j%) = ny#(i%, j%) / l#<br>		nz#(i%, j%) = nz#(i%, j%) / l#<br>	Next<br>Next<br><br><br><br>	xdir = 5<br>	ydir = 5<br>	xres = GraphicsWidth()<br>	yres = GraphicsHeight()<br>	BounceX = xres/2<br>	BounceY = yres/2<br>	<br><br><br>Repeat<br>	Cls()<br>	rotateVertices(a#, b#, g#)<br>	drawSphere(bounceX,bounceY)<br>	Flip()<br>	;Mouse Control WOOHOO :D<br>	b# = b#-MouseXSpeed() Mod 360<br>	a# = a#-MouseYSpeed() Mod 360<br>	MoveMouse 512, 384<br>	;Make it Move! press Q<br>	If KeyHit(16) move = 1 - move<br>	If move Then<br>		bounceX = bounceX + xdir<br>		bounceY = bounceY + ydir<br>		If bounceX &gt; xres Then xdir = -5<br>		If bounceX &lt; 0 Then xdir = 5<br>		If bounceY &gt; yres Then ydir = -5<br>		If bounceY &lt; 0 Then ydir = 5<br>	End If<br><br>	<br><br>	If KeyDown(30) Then<br>		a# = a# + 1.00<br>		While a# &gt; 360.00<br>			a# = a# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(44) Then<br>		a# = a# - 1.00<br>		While a# &lt; 0.00<br>			a# = a# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(31) Then<br>		b# = b# + 1.00<br>		While b# &gt; 360.00<br>			b# = b# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(45) Then<br>		b# = b# - 1.00<br>		While b# &lt; 0.00<br>			b# = b# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(32) Then<br>		g# = g# + 1.00<br>		While g# &gt; 360.00<br>			g# = g# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(46) Then<br>		g# = g# - 1.00<br>		While g# &lt; 0.00<br>			g# = g# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(33) Then<br>		lx# = lx# - 0.03125<br>		While lx# &lt; 0.00<br>			lx# = lx# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(47) Then<br>		lx# = lx# + 0.03125<br>		While lx# &gt; 1.00<br>			lx# = lx# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(34) Then<br>		ly# = ly# - 0.03125<br>		While ly# &lt; 0.00<br>			ly# = ly# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(48) Then<br>		ly# = ly# + 0.03125<br>		While ly# &gt; 1.00<br>			ly# = ly# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(35) Then<br>		lz# = lz# - 0.03125<br>		While lz# &lt; 0.00<br>			lz# = lz# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(49) Then<br>		lz# = lz# + 0.03125<br>		While lz# &gt; 1.00<br>			lz# = lz# - 1.00<br>		Wend<br>	EndIf<br>Until KeyHit(1)<br>End<br><br><br><br>Function rotateVertices(alpha#, betha#, gamma#) <br>	For i% = 0 To 15 <br>		For j% = 0 To 8<br>		<br>			;Vertices<br>			xl0# = x#(i%, j%) <br>			yl0# = y#(i%, j%) <br>			zl0# = z#(i%, j%) <br>			xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#) <br>			yl1# = yl0# <br>			zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#) <br>			xl2# = xl1# <br>			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#) <br>			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#) <br>			rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) <br>			ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) <br>			rz#(i%, j%) = zl2#<br><br>			;Normals<br>			xl0# = nx#(i%, j%) <br>			yl0# = ny#(i%, j%) <br>			zl0# = nz#(i%, j%) <br>			xl1# = zl0# * Sin#(betha#) + xl0# * Cos#(betha#) <br>			yl1# = yl0# <br>			zl1# = zl0# * Cos#(betha#) - xl0# * Sin#(betha#) <br>			xl2# = xl1#<br><br>			;+ - is Oppisite of the Vertices - +, looks like it doesn't matter which is set with + - just as long as the other is oppisite of it - +<br>			; Its this oppisite sign change that actually makes it work, put it back to the same as the other one<br>			; - + and see how its messed up :P<br>			yl2# = yl1# * Cos#(alpha#) + zl1# * Sin#(alpha#) <br>			zl2# = yl1# * Sin#(alpha#) - zl1# * Cos#(alpha#)<br>			;Main Change, Sign Change<br>			rnx#(i%, j%) = yl2# * Sin#(gamma#) - xl2# * Cos#(gamma#) <br>			rny#(i%, j%) = yl2# * Cos#(gamma#) + xl2# * Sin#(gamma#) <br>			rnz#(i%, j%) = zl2#<br>		Next<br>	Next<br>End Function <br><br><br><br>Function drawSphere(xloc, yloc)<br>	For i% = 0 To 15<br>		For j% = 0 To 7<br>			x0# = +rx#(i%, j%) * 100.00 + xloc ;512.00<br>			y0# = -ry#(i%, j%) * 100.00 + yloc ;384.00<br>			x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + xloc ;512.00<br>			y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + yloc ;384.00<br>			x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + xloc ;512.00<br>			y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + yloc ;384.00<br>			x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + xloc ;512.00<br>			y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + yloc ;384.00<br>			If rnz#(i%, j%) &gt; 0.00 Then<br>				c% = (((rnx#(i%, j%) * lx#) + (rny#(i%, j%) * ly#) + (rnz#(i%, j%) * lz#)) / 1.00) * 255<br>				If c% &gt; 255 Then<br>					c% = 255<br>				Else<br>					If c% &lt; 15 Then<br>						c% = 15<br>					EndIf<br>				EndIf<br>				c% = (c% Shl 16)<br>				paintTriangle(x0#, y0#, x1#, y1#, x3#, y3#, c%)<br>				paintTriangle(x1#, y1#, x2#, y2#, x3#, y3#, c%)<br>			EndIf<br>		Next<br>	Next<br>End Function<br><br><br><br>Function paintTriangle(x0#, y0#, x1#, y1#, x2#, y2#, c%)<br>;	Color (c% Shr 16), (c% Shr 8) And 255, c% And 255<br>;	Line x0#, y0#, x1#, y1#<br>;	Line x1#, y1#, x2#, y2#<br>;	Line x2#, y2#, x0#, y0#<br>;	Return<br><br>    minx# = 9999<br>    maxx# = 0<br>    miny# = 9999<br>    maxy# = 0<br>	;<br>	If x0# &lt; minx# Then minx# = x0#<br>	If x0# &gt; maxx# Then maxx# = x0#<br>	If x1# &lt; minx# Then minx# = x1#<br>	If x1# &gt; maxx# Then maxx# = x1#<br>	If x2# &lt; minx# Then minx# = x2#<br>	If x2# &gt; maxx# Then maxx# = x2#<br>	If y0# &lt; miny# Then miny# = y0#<br>	If y0# &gt; maxy# Then maxy# = y0#<br>	If y1# &lt; miny# Then miny# = y1#<br>	If y1# &gt; maxy# Then maxy# = y1#<br>	If y2# &lt; miny# Then miny# = y2#<br>	If y2# &gt; maxy# Then maxy# = y2#<br>	;<br>	xsize# = maxx# - minx#<br>	ysize# = maxy# - miny#<br>	;<br>	x0# = x0# - minx#<br>	x1# = x1# - minx#<br>	x2# = x2# - minx#<br>	y0# = y0# - miny#<br>	y1# = y1# - miny#<br>	y2# = y2# - miny#<br>	;<br>	For i% = 0 To xsize#<br>		For j% = 0 To ysize#<br>			polyhedre%(i%, j%) = 0<br>		Next<br>	Next<br>	;<br>	drawBresenhamLine(x0#, y0#, x1#, y1#)<br>	drawBresenhamLine(x1#, y1#, x2#, y2#)<br>	drawBresenhamLine(x2#, y2#, x0#, y0#)<br>	;<br>	For j% = 0 To ysize#<br>		For i% = 0 To xsize#<br>			If polyhedre%(i%, j%) Then<br>				paintArray%(j%, 0) = i%<br>				Exit<br>			EndIf<br>		Next<br>		For i% = xsize# To 0 Step -1<br>			If polyhedre%(i%, j%) Then<br>				paintArray%(j%, 1) = i%<br>				Exit<br>			EndIf<br>		Next<br>	Next<br>	;<br>	Color (c% Shr 16), (c% Shr 8) And 255, c% And 255<br>	;<br>	For i% = 0 To ySize#<br>		Line minx# + paintArray%(i%, 0), miny# + i%, minx# + paintArray%(i%, 1), miny# + i%<br>	Next<br>End Function<br><br><br><br>Function drawBresenhamLine(x0%, y0%, x1%, y1%)<br>	If x0% = x1% Then<br>		If y0% = y1% Then<br>			polyhedre%(x0%, y0%) = 1<br>			Return<br>		EndIf<br>		If y0% &lt; y1% Then<br>			For i% = y0% To y1%<br>				polyhedre%(x0%, i%) = 1<br>			Next<br>			Return<br>		EndIf<br>		For i% = y1% To y0%<br>			polyhedre%(x0%, i%) = 1<br>		Next<br>		Return<br>	EndIf<br>	If y0% = y1% Then<br>		If x0% &lt; x1% Then<br>			For i% = x0% To x1%<br>				polyhedre%(i%, y0%) = 1<br>			Next<br>			Return<br>		EndIf<br>		For i% = x1% To x0%<br>			polyhedre%(i%, y0%) = 1<br>		Next<br>		Return<br>	EndIf<br>	If y1% &lt; y0% Then<br>		temp% = y0%<br>		y0% = y1%<br>		y1% = temp%<br>		temp% = x0%<br>		x0% = x1%<br>		x1% = temp%<br>	EndIf<br>	dx% = x1% - x0%<br>	If dx% &lt; 0 Then<br>		dx% = -dx%<br>		xinc% = -1<br>	Else<br>		xinc% = 1<br>	EndIf<br>	dy% = y1% - y0%<br>	If dy% &lt; 0 Then<br>		dy% = -dy%<br>		yinc% = -1<br>	Else<br>		yinc% = 1<br>	EndIf<br>	two_dx% = dx% + dx%<br>	two_dy% = dy% + dy%<br>	xx% = x0%<br>	yy% = y0%<br>	If dx% &gt; dy% Then<br>		error% = 0<br>		For i% = 0 To dx%<br>			polyhedre%(xx%, yy%) = 1<br>			xx% = xx% + xinc%<br>			error% = error% + two_dy%<br>			If error% &gt; dx% Then<br>				error% = error% - two_dx%<br>				yy% = yy% + yinc%<br>			EndIf<br>		Next<br>	Else<br>		error% = 0<br>		For i% = 0 To dy%<br>			polyhedre%(xx%, yy%) = 1<br>			yy% = yy% + yinc%<br>			error% = error% + two_dx%<br>			If error% &gt; dy% Then<br>				error% = error% - two_dy%<br>				xx% = xx% + xinc%<br>			EndIf<br>		Next<br>	EndIf<br>End Function<br>[/CODE]<br><br>Thanks a lot, guys.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277421"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here is the next big challenge:<br><br>Now, I need to find a way to rotate the normals without using floats or multiplies, etc...<br><br>Here´s how I am planning on doing that:<br><br>Create a (big) table, which, based on the three rotation angles, and the thre original rotation angles, will give me the final rotation angles.<br>This table might become huge.<br>It is targetted at the PS2, and I do not have much RAM available, so this may not be easy to do... and may not be doable, in the worst case.<br><br>It would be like having all possible rotations in a pre-computed table.<br><br>So, <br>(Alpha0, Betha0, Gamma0, DeltaAlpha, DeltaBetha, DeltaGamma)<br>would index a table, which would return<br>(finalAlpha, finalBetha, finalGamma)<br><br>Of corse, it is not that easy.<br>Such a table would not be just big... it would be enormous.<br>(A few billion Megs of spare RAM hehehe).<br><br>Fortunately, this can be broken down into three tables:<br><br>a)Indexed by:<br>(Alpha, Betha, Gamma, DeltaAlpha)<br>And Returns:<br>(FinalAlpha, FinalBetha, FinalGamma)<br><br>b)Indexed by:<br>(Alpha, Betha, Gamma, DeltaBetha)<br>And Returns:<br>(FinalAlpha, FinalBetha, FinalGamma)<br><br>c)Indexed by:<br>(Alpha, Betha, Gamma, DeltaGamma)<br>And Returns:<br>(FinalAlpha, FnalBetha, FinalGamma)<br><br>Each one would be no more than 16 thousand megabytes long, for 1 degree precision heheheh<br><br>Now, some smart trickery will ome into play.<br>First, there´s no need to store the complete sphere, but just 1/8th of it.<br>So, that would be just 2 thousand Megabytes for each table.<br>For a total of 6 Gigabytes!<br><br>Hehe... too bad I only have 32Mbytes on the PS2... only 10Mb of which is still available.<br><br>I will have to come up with some real smart technique, because I may not use more than 8 mbytes.<br>But, on the other hand, some sort of pre-computed table will be needed, for rotating the normals is a very costly operation.<br><br>Now, I will have to start think about that...<br><br>Any ideas?<br><br>Thanks,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277423"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Much better. You have a made a vast improvement. Well done.<br><br>Where can I find you other work? website maybe?<br><br>I'm beginning to have an interest in ps2 code. <br><br></td></tr></table><br>
<a name="277429"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Col.<br>I have a linux for playstation kit.<br>That´s pretty much all that you need in order to get the thingy going.<br>The best thing is that it is competely open and official.<br>It is sold by Sony Entertainement, itself.<br>All of the manuals are original, from Sony.<br>If you are in the U.S., you can buy the kit for US$ 200.00.<br><br>Here is the OFFICIAL url:<br><br><a href="http://playstation2-linux.com" target="_blank">http://playstation2-linux.com</a> <br><br></td></tr></table><br>
<a name="277432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Before writting code for the PS2 itself, I test all of my algorythms in Blitz Plus.<br>I can´t find words to tell you how much I appreciate Blitz Plus.<br><br>I wish there was a blitz plus compiler for the PS2.<br>(Sigh...)<br><br>For the PS2, I use gcc, as I told before.<br>Also, there´s PS2SDL, which is much like SDL, but specifically targetted at the PS2.<br>There´s also a very nice assembler, but I try to stay away from coding directly to the Emotion Engine CPU.<br><br>All of the voxel code is written in pure C.<br>Lighting will probably require some hand-crafted assembly routines, if I don´t find a way to express rotations as simple the summation of the rotation angles, thou.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277445"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here is a much better version.<br>It is much faster than the previous one.<br>Actualy, what I did here was to convert the polygon painting code I have written in gcc to its equivalent Blitz Plus code.<br>And I am glad I dd that.<br>It is actualy fater than I thougt it would be in B+.<br><br>[CODE]<br>Dim polyhedre%(256, 256)<br>Dim paintArray%(256, 2)<br>;<br>Dim x#(16, 9)<br>Dim y#(16, 9)<br>Dim z#(16, 9)<br>;<br>Dim rx#(16, 9)<br>Dim ry#(16, 9)<br>Dim rz#(16, 9)<br>;<br>Dim nx#(16, 9)<br>Dim ny#(16, 9)<br>Dim nz#(16, 9)<br>;<br>Dim rnx#(16, 9)<br>Dim rny#(16, 9)<br>Dim rnz#(16, 9)<br>;<br>Global a# = 0.00<br>Global b# = 0.00<br>Global g# = 0.00<br>;<br>Global lx# = 1.00<br>Global ly# = 1.00<br>Global lz# = 1.00<br>;<br>Global wireFrame = False<br><br><br><br>Graphics 1024, 768, 32, 0<br>SetBuffer BackBuffer()<br>ClsColor 255, 128, 64<br><br><br><br>For i% = 0 To 15<br>	For	j% = 0 To 8<br>		r# = Sin#(22.50 * j%)<br>		x#(i%, j%) = Cos#(22.50 * i%) * r#<br>		y#(i%, j%) = Cos#(22.50 * j%)<br>		z#(i%, j%) = Sin#(22.50 * i%) * r#<br>	Next<br>Next<br><br><br><br>For i% = 0 To 15<br>	For j% = 0 To 8<br>		x0# = +x#(i%, j%)<br>		y0# = -y#(i%, j%)<br>		z0# = +z#(i%, j%)<br>		x1# = +x#((i% + 1) Mod 16, j%)<br>		y1# = -y#((i% + 1) Mod 16, j%)<br>		z1# = +z#((i% + 1) Mod 16, j%)<br>		x2# = +x#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		y2# = -y#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		z2# = +z#((i% + 1) Mod 16, (j% + 1) Mod 9)<br>		x3# = +x#(i%, (j% + 1) Mod 9)<br>		y3# = -y#(i%, (j% + 1) Mod 9)<br>		z3# = +z#(i%, (j% + 1) Mod 9)<br>		If Abs(x2# - x3#) &lt; 0.001 Then<br>			dx1# = x2# - x0#<br>			dy1# = y2# - y0#<br>			dz1# = z2# - z0#<br>			dx2# = x2# - x1#<br>			dy2# = y2# - y1#<br>			dz2# = z2# - z1#<br>		Else<br>			dx1# = x3# - x1#<br>			dy1# = y3# - y1#<br>			dz1# = z3# - z1#<br>			dx2# = x3# - x2#<br>			dy2# = y3# - y2#<br>			dz2# = z3# - z2#<br>		EndIf<br>		nx#(i%, j%) = (dy1# * dz2#) - (dz1# * dy2#)<br>		ny#(i%, j%) = (dz1# * dx2#) - (dx1# * dz2#)<br>		nz#(i%, j%) = (dx1# * dy2#) - (dy1# * dx2#)<br>		l# = Sqr#((nx#(i%, j%) * nx#(i%, j%)) + (ny#(i%, j%) * ny#(i%, j%)) + (nz#(i%, j%) * nz#(i%, j%)))<br>		nx#(i%, j%) = nx#(i%, j%) / l#<br>		ny#(i%, j%) = ny#(i%, j%) / l#<br>		nz#(i%, j%) = nz#(i%, j%) / l#<br>	Next<br>Next<br><br><br><br>	xdir = 5<br>	ydir = 5<br>	xres = GraphicsWidth()<br>	yres = GraphicsHeight()<br>	BounceX = xres/2<br>	BounceY = yres/2<br>	<br><br><br>Repeat<br>	Cls()<br>	rotateVertices(a#, b#, g#)<br>	drawSphere(bounceX,bounceY)<br>	Flip()<br>	;Mouse Control WOOHOO :D<br>	b# = b#-MouseXSpeed() Mod 360<br>	a# = a#-MouseYSpeed() Mod 360<br>	MoveMouse 512, 384<br>	;Make it Move! press Q<br>	If KeyHit(16) move = 1 - move<br>	If move Then<br>		bounceX = bounceX + xdir<br>		bounceY = bounceY + ydir<br>		If bounceX &gt; xres Then xdir = -5<br>		If bounceX &lt; 0 Then xdir = 5<br>		If bounceY &gt; yres Then ydir = -5<br>		If bounceY &lt; 0 Then ydir = 5<br>	End If<br><br>	<br><br>	If KeyDown(30) Then<br>		a# = a# + 1.00<br>		While a# &gt; 360.00<br>			a# = a# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(44) Then<br>		a# = a# - 1.00<br>		While a# &lt; 0.00<br>			a# = a# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(31) Then<br>		b# = b# + 1.00<br>		While b# &gt; 360.00<br>			b# = b# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(45) Then<br>		b# = b# - 1.00<br>		While b# &lt; 0.00<br>			b# = b# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(32) Then<br>		g# = g# + 1.00<br>		While g# &gt; 360.00<br>			g# = g# - 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(46) Then<br>		g# = g# - 1.00<br>		While g# &lt; 0.00<br>			g# = g# + 360.00<br>		Wend<br>	EndIf<br>	If KeyDown(33) Then<br>		lx# = lx# - 0.03125<br>		While lx# &lt; 0.00<br>			lx# = lx# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(47) Then<br>		lx# = lx# + 0.03125<br>		While lx# &gt; 1.00<br>			lx# = lx# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(34) Then<br>		ly# = ly# - 0.03125<br>		While ly# &lt; 0.00<br>			ly# = ly# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(48) Then<br>		ly# = ly# + 0.03125<br>		While ly# &gt; 1.00<br>			ly# = ly# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(35) Then<br>		lz# = lz# - 0.03125<br>		While lz# &lt; 0.00<br>			lz# = lz# + 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(49) Then<br>		lz# = lz# + 0.03125<br>		While lz# &gt; 1.00<br>			lz# = lz# - 1.00<br>		Wend<br>	EndIf<br>	If KeyDown(36) Then<br>		wireFrame = True<br>	EndIf<br>	If KeyDown(50) Then<br>		wireFrame = False<br>	EndIf<br>Until KeyHit(1)<br>End<br><br><br><br>Function rotateVertices(alpha#, betha#, gamma#) <br>	For i% = 0 To 15 <br>		For j% = 0 To 8<br>		<br>			;Vertices<br>			xl0# = x#(i%, j%) <br>			yl0# = y#(i%, j%) <br>			zl0# = z#(i%, j%) <br>			xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#) <br>			yl1# = yl0# <br>			zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#) <br>			xl2# = xl1# <br>			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#) <br>			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#) <br>			rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) <br>			ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) <br>			rz#(i%, j%) = zl2#<br><br>			;Normals<br>			xl0# = nx#(i%, j%) <br>			yl0# = ny#(i%, j%) <br>			zl0# = nz#(i%, j%) <br>			xl1# = zl0# * Sin#(betha#) + xl0# * Cos#(betha#) <br>			yl1# = yl0# <br>			zl1# = zl0# * Cos#(betha#) - xl0# * Sin#(betha#) <br>			xl2# = xl1#<br><br>			;+ - is Oppisite of the Vertices - +, looks like it doesn't matter which is set with + - just as long as the other is oppisite of it - +<br>			; Its this oppisite sign change that actually makes it work, put it back to the same as the other one<br>			; - + and see how its messed up :P<br>			yl2# = yl1# * Cos#(alpha#) + zl1# * Sin#(alpha#) <br>			zl2# = yl1# * Sin#(alpha#) - zl1# * Cos#(alpha#)<br>			;Main Change, Sign Change<br>			rnx#(i%, j%) = yl2# * Sin#(gamma#) - xl2# * Cos#(gamma#) <br>			rny#(i%, j%) = yl2# * Cos#(gamma#) + xl2# * Sin#(gamma#) <br>			rnz#(i%, j%) = zl2#<br>		Next<br>	Next<br>End Function <br><br><br><br>Function drawSphere(xloc, yloc)<br>	For i% = 0 To 15<br>		For j% = 0 To 7<br>			x0# = +rx#(i%, j%) * 100.00 + xloc ;512.00<br>			y0# = -ry#(i%, j%) * 100.00 + yloc ;384.00<br>			x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + xloc ;512.00<br>			y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + yloc ;384.00<br>			x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + xloc ;512.00<br>			y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + yloc ;384.00<br>			x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + xloc ;512.00<br>			y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + yloc ;384.00<br>			If rnz#(i%, j%) &gt; 0.00 Then<br>				c% = (((rnx#(i%, j%) * lx#) + (rny#(i%, j%) * ly#) + (rnz#(i%, j%) * lz#)) / 1.00) * 255<br>				If c% &gt; 255 Then<br>					c% = 255<br>				Else<br>					If c% &lt; 15 Then<br>						c% = 15<br>					EndIf<br>				EndIf<br>				c% = (c% Shl 16)<br>				paintTriangle(x0#, y0#, x1#, y1#, x3#, y3#, c%)<br>				paintTriangle(x1#, y1#, x2#, y2#, x3#, y3#, c%)<br>			EndIf<br>		Next<br>	Next<br>End Function<br><br><br><br>Function paintTriangle(x0#, y0#, x1#, y1#, x2#, y2#, c%)<br>	If wireFrame Then<br>		Color (c% Shr 16), (c% Shr 8) And 255, c% And 255<br>		Line x0#, y0#, x1#, y1#<br>		Line x1#, y1#, x2#, y2#<br>		Line x2#, y2#, x0#, y0#<br>		Return<br>	EndIf<br><br>    minx# = 9999<br>    maxx# = 0<br>    miny# = 9999<br>    maxy# = 0<br>	;<br>	If x0# &lt; minx# Then minx# = x0#<br>	If x0# &gt; maxx# Then maxx# = x0#<br>	If x1# &lt; minx# Then minx# = x1#<br>	If x1# &gt; maxx# Then maxx# = x1#<br>	If x2# &lt; minx# Then minx# = x2#<br>	If x2# &gt; maxx# Then maxx# = x2#<br>	If y0# &lt; miny# Then miny# = y0#<br>	If y0# &gt; maxy# Then maxy# = y0#<br>	If y1# &lt; miny# Then miny# = y1#<br>	If y1# &gt; maxy# Then maxy# = y1#<br>	If y2# &lt; miny# Then miny# = y2#<br>	If y2# &gt; maxy# Then maxy# = y2#<br>	;<br>	xsize# = maxx# - minx#<br>	ysize# = maxy# - miny#<br>	;<br>	x0# = x0# - minx#<br>	x1# = x1# - minx#<br>	x2# = x2# - minx#<br>	y0# = y0# - miny#<br>	y1# = y1# - miny#<br>	y2# = y2# - miny#<br>	;<br>	For i% = 0 To xsize#<br>		For j% = 0 To ysize#<br>			polyhedre%(i%, j%) = 0<br>		Next<br>	Next<br>	;<br>	drawBresenhamLine(x0#, y0#, x1#, y1#)<br>	drawBresenhamLine(x1#, y1#, x2#, y2#)<br>	drawBresenhamLine(x2#, y2#, x0#, y0#)<br>	;<br>	For j% = 0 To ysize#<br>		For i% = 0 To xsize#<br>			If polyhedre%(i%, j%) Then<br>				paintArray%(j%, 0) = i%<br>				Exit<br>			EndIf<br>		Next<br>		For i% = xsize# To 0 Step -1<br>			If polyhedre%(i%, j%) Then<br>				paintArray%(j%, 1) = i%<br>				Exit<br>			EndIf<br>		Next<br>	Next<br>	;<br>	LockBuffer<br>	py% = miny#<br>	For i% = 0 To ySize#<br>		px% = paintArray%(i%, 0)<br>		pl% = paintArray%(i%, 1) - px%<br>		px% = px% + minx#<br>		For j% = 0 To pl%<br>			WritePixelFast px%, py%, c%<br>			px% = px% + 1<br>		Next<br>		py% = py% + 1<br>	Next<br>	UnlockBuffer<br>End Function<br><br><br><br>Function drawBresenhamLine(x0%, y0%, x1%, y1%)<br>	If x0% = x1% Then<br>		If y0% = y1% Then<br>			polyhedre%(x0%, y0%) = 1<br>			Return<br>		EndIf<br>		If y0% &lt; y1% Then<br>			For i% = y0% To y1%<br>				polyhedre%(x0%, i%) = 1<br>			Next<br>			Return<br>		EndIf<br>		For i% = y1% To y0%<br>			polyhedre%(x0%, i%) = 1<br>		Next<br>		Return<br>	EndIf<br>	If y0% = y1% Then<br>		If x0% &lt; x1% Then<br>			For i% = x0% To x1%<br>				polyhedre%(i%, y0%) = 1<br>			Next<br>			Return<br>		EndIf<br>		For i% = x1% To x0%<br>			polyhedre%(i%, y0%) = 1<br>		Next<br>		Return<br>	EndIf<br>	If y1% &lt; y0% Then<br>		temp% = y0%<br>		y0% = y1%<br>		y1% = temp%<br>		temp% = x0%<br>		x0% = x1%<br>		x1% = temp%<br>	EndIf<br>	dx% = x1% - x0%<br>	If dx% &lt; 0 Then<br>		dx% = -dx%<br>		xinc% = -1<br>	Else<br>		xinc% = 1<br>	EndIf<br>	dy% = y1% - y0%<br>	If dy% &lt; 0 Then<br>		dy% = -dy%<br>		yinc% = -1<br>	Else<br>		yinc% = 1<br>	EndIf<br>	two_dx% = dx% + dx%<br>	two_dy% = dy% + dy%<br>	xx% = x0%<br>	yy% = y0%<br>	If dx% &gt; dy% Then<br>		error% = 0<br>		For i% = 0 To dx%<br>			polyhedre%(xx%, yy%) = 1<br>			xx% = xx% + xinc%<br>			error% = error% + two_dy%<br>			If error% &gt; dx% Then<br>				error% = error% - two_dx%<br>				yy% = yy% + yinc%<br>			EndIf<br>		Next<br>	Else<br>		error% = 0<br>		For i% = 0 To dy%<br>			polyhedre%(xx%, yy%) = 1<br>			yy% = yy% + yinc%<br>			error% = error% + two_dx%<br>			If error% &gt; dy% Then<br>				error% = error% - two_dy%<br>				xx% = xx% + xinc%<br>			EndIf<br>		Next<br>	EndIf<br>End Function[/CODE]<br><br>BTW: Try pressing J to display the wireframe model and M to display it as a flat-shaded sphere.<br><br>I know it seems to be no use, ´cause Blitz3D can do that much better.<br>But it is the algorythms that we are interested in, here, right?<br><br>Well, I hope this is useful.<br><br>Let me just add the real-time light to the PS2 voxel engine and I will port it to Blitz Plus.<br>I am not sure wheter it is or isn´t going to be fast enough, but it realy is worth a try.<br><br>Besides, I was impressed with the writepixelfast performance. I really was not expecting it...<br><br>Cheers,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="277529"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Paradox7</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm glad I could help in getting the 100% culling down, I just found it funny that I was able to fix the problem with no 3D knowledge and others couldn't :P<br><br>The Lighting looks great now also.<br>Don't forgets about me, a shout out, hehe<br><br>I'm just a 2D programmer, I love 2D, and no, not 3D in 2D mind you, just 2D. Bought BlitzBasic when it first came out, Blitz2D, can't even afford BlitzPlus :( ah well, Blitz2D is fun. :D<br><br>I ripped out ball movement, as now you're using writepixelfast, and there was no checks to make sure writing was inside screen area, although a easy and quick fix, its just best to take it out, its not needed anyways. So use below code.<br><br>Good Luck with your project. And keep us updated.<br><br><pre class=code>
Dim polyhedre%(256, 256)
Dim paintArray%(256, 2)
;
Dim x#(16, 9)
Dim y#(16, 9)
Dim z#(16, 9)
;
Dim rx#(16, 9)
Dim ry#(16, 9)
Dim rz#(16, 9)
;
Dim nx#(16, 9)
Dim ny#(16, 9)
Dim nz#(16, 9)
;
Dim rnx#(16, 9)
Dim rny#(16, 9)
Dim rnz#(16, 9)
;
Global a# = 0.00
Global b# = 0.00
Global g# = 0.00
;
Global lx# = 1.00
Global ly# = 1.00
Global lz# = 1.00
;
Global wireFrame = False



Graphics 1024, 768, 32, 0
SetBuffer BackBuffer()
ClsColor 255, 128, 64



For i% = 0 To 15
	For	j% = 0 To 8
		r# = Sin#(22.50 * j%)
		x#(i%, j%) = Cos#(22.50 * i%) * r#
		y#(i%, j%) = Cos#(22.50 * j%)
		z#(i%, j%) = Sin#(22.50 * i%) * r#
	Next
Next



For i% = 0 To 15
	For j% = 0 To 8
		x0# = +x#(i%, j%)
		y0# = -y#(i%, j%)
		z0# = +z#(i%, j%)
		x1# = +x#((i% + 1) Mod 16, j%)
		y1# = -y#((i% + 1) Mod 16, j%)
		z1# = +z#((i% + 1) Mod 16, j%)
		x2# = +x#((i% + 1) Mod 16, (j% + 1) Mod 9)
		y2# = -y#((i% + 1) Mod 16, (j% + 1) Mod 9)
		z2# = +z#((i% + 1) Mod 16, (j% + 1) Mod 9)
		x3# = +x#(i%, (j% + 1) Mod 9)
		y3# = -y#(i%, (j% + 1) Mod 9)
		z3# = +z#(i%, (j% + 1) Mod 9)
		If Abs(x2# - x3#) &lt; 0.001 Then
			dx1# = x2# - x0#
			dy1# = y2# - y0#
			dz1# = z2# - z0#
			dx2# = x2# - x1#
			dy2# = y2# - y1#
			dz2# = z2# - z1#
		Else
			dx1# = x3# - x1#
			dy1# = y3# - y1#
			dz1# = z3# - z1#
			dx2# = x3# - x2#
			dy2# = y3# - y2#
			dz2# = z3# - z2#
		EndIf
		nx#(i%, j%) = (dy1# * dz2#) - (dz1# * dy2#)
		ny#(i%, j%) = (dz1# * dx2#) - (dx1# * dz2#)
		nz#(i%, j%) = (dx1# * dy2#) - (dy1# * dx2#)
		l# = Sqr#((nx#(i%, j%) * nx#(i%, j%)) + (ny#(i%, j%) * ny#(i%, j%)) + (nz#(i%, j%) * nz#(i%, j%)))
		nx#(i%, j%) = nx#(i%, j%) / l#
		ny#(i%, j%) = ny#(i%, j%) / l#
		nz#(i%, j%) = nz#(i%, j%) / l#
	Next
Next


	xres = GraphicsWidth()
	yres = GraphicsHeight()
	xhalf = xres/2
	yhalf = yres/2
	


Repeat
	Cls()
	rotateVertices(a#, b#, g#)
	drawSphere(xhalf,yhalf)
	Flip()
	;Mouse Control WOOHOO :D
	b# = b#-MouseXSpeed() Mod 360
	a# = a#-MouseYSpeed() Mod 360
	MoveMouse xhalf, yhalf

	

	If KeyDown(30) Then
		a# = a# + 1.00
		While a# &gt; 360.00
			a# = a# - 360.00
		Wend
	EndIf
	If KeyDown(44) Then
		a# = a# - 1.00
		While a# &lt; 0.00
			a# = a# + 360.00
		Wend
	EndIf
	If KeyDown(31) Then
		b# = b# + 1.00
		While b# &gt; 360.00
			b# = b# - 360.00
		Wend
	EndIf
	If KeyDown(45) Then
		b# = b# - 1.00
		While b# &lt; 0.00
			b# = b# + 360.00
		Wend
	EndIf
	If KeyDown(32) Then
		g# = g# + 1.00
		While g# &gt; 360.00
			g# = g# - 360.00
		Wend
	EndIf
	If KeyDown(46) Then
		g# = g# - 1.00
		While g# &lt; 0.00
			g# = g# + 360.00
		Wend
	EndIf
	If KeyDown(33) Then
		lx# = lx# - 0.03125
		While lx# &lt; 0.00
			lx# = lx# + 1.00
		Wend
	EndIf
	If KeyDown(47) Then
		lx# = lx# + 0.03125
		While lx# &gt; 1.00
			lx# = lx# - 1.00
		Wend
	EndIf
	If KeyDown(34) Then
		ly# = ly# - 0.03125
		While ly# &lt; 0.00
			ly# = ly# + 1.00
		Wend
	EndIf
	If KeyDown(48) Then
		ly# = ly# + 0.03125
		While ly# &gt; 1.00
			ly# = ly# - 1.00
		Wend
	EndIf
	If KeyDown(35) Then
		lz# = lz# - 0.03125
		While lz# &lt; 0.00
			lz# = lz# + 1.00
		Wend
	EndIf
	If KeyDown(49) Then
		lz# = lz# + 0.03125
		While lz# &gt; 1.00
			lz# = lz# - 1.00
		Wend
	EndIf
	If KeyDown(36) Then
		wireFrame = True
	EndIf
	If KeyDown(50) Then
		wireFrame = False
	EndIf
Until KeyHit(1)
End



Function rotateVertices(alpha#, betha#, gamma#) 
	For i% = 0 To 15 
		For j% = 0 To 8
		
			;Vertices
			xl0# = x#(i%, j%) 
			yl0# = y#(i%, j%) 
			zl0# = z#(i%, j%) 
			xl1# = (Sin#(betha#) * zl0#) + (Cos#(betha#) * xl0#) 
			yl1# = yl0# 
			zl1# = (Cos#(betha#) * zl0#) - (Sin#(betha#) * xl0#) 
			xl2# = xl1# 
			yl2# = yl1# * Cos#(alpha#) - zl1# * Sin#(alpha#) 
			zl2# = yl1# * Sin#(alpha#) + zl1# * Cos#(alpha#) 
			rx#(i%, j%) = yl2# * Sin#(gamma#) + xl2# * Cos#(gamma#) 
			ry#(i%, j%) = yl2# * Cos#(gamma#) - xl2# * Sin#(gamma#) 
			rz#(i%, j%) = zl2#

			;Normals
			xl0# = nx#(i%, j%) 
			yl0# = ny#(i%, j%) 
			zl0# = nz#(i%, j%) 
			xl1# = zl0# * Sin#(betha#) + xl0# * Cos#(betha#) 
			yl1# = yl0# 
			zl1# = zl0# * Cos#(betha#) - xl0# * Sin#(betha#) 
			xl2# = xl1#

			;+ - is Oppisite of the Vertices - +, looks like it doesn't matter which is set with + - just as long as the other is oppisite of it - +
			; Its this oppisite sign change that actually makes it work, put it back to the same as the other one
			; - + and see how its messed up :P
			; 100% Culling Fixed By Paradox7 :D
			yl2# = yl1# * Cos#(alpha#) + zl1# * Sin#(alpha#) 
			zl2# = yl1# * Sin#(alpha#) - zl1# * Cos#(alpha#)
			;Main Change, Sign Change
			rnx#(i%, j%) = yl2# * Sin#(gamma#) - xl2# * Cos#(gamma#) 
			rny#(i%, j%) = yl2# * Cos#(gamma#) + xl2# * Sin#(gamma#) 
			rnz#(i%, j%) = zl2#
		Next
	Next
End Function 



Function drawSphere(xloc, yloc)
	For i% = 0 To 15
		For j% = 0 To 7
			x0# = +rx#(i%, j%) * 100.00 + xloc ;512.00
			y0# = -ry#(i%, j%) * 100.00 + yloc ;384.00
			x1# = +rx#((i% + 1) Mod 16, j%) * 100.00 + xloc ;512.00
			y1# = -ry#((i% + 1) Mod 16, j%) * 100.00 + yloc ;384.00
			x2# = +rx#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + xloc ;512.00
			y2# = -ry#((i% + 1) Mod 16, (j% + 1) Mod 9) * 100.00 + yloc ;384.00
			x3# = +rx#(i%, (j% + 1) Mod 9) * 100.00 + xloc ;512.00
			y3# = -ry#(i%, (j% + 1) Mod 9) * 100.00 + yloc ;384.00
			If rnz#(i%, j%) &gt; 0.00 Then
				c% = (((rnx#(i%, j%) * lx#) + (rny#(i%, j%) * ly#) + (rnz#(i%, j%) * lz#)) / 1.00) * 255
				If c% &gt; 255 Then
					c% = 255
				Else
					If c% &lt; 15 Then
						c% = 15
					EndIf
				EndIf
				c% = (c% Shl 16)
				paintTriangle(x0#, y0#, x1#, y1#, x3#, y3#, c%)
				paintTriangle(x1#, y1#, x2#, y2#, x3#, y3#, c%)
			EndIf
		Next
	Next
End Function



Function paintTriangle(x0#, y0#, x1#, y1#, x2#, y2#, c%)
	If wireFrame Then
		Color (c% Shr 16), (c% Shr 8) And 255, c% And 255
		Line x0#, y0#, x1#, y1#
		Line x1#, y1#, x2#, y2#
		Line x2#, y2#, x0#, y0#
		Return
	EndIf

    minx# = 9999
    maxx# = 0
    miny# = 9999
    maxy# = 0
	;
	If x0# &lt; minx# Then minx# = x0#
	If x0# &gt; maxx# Then maxx# = x0#
	If x1# &lt; minx# Then minx# = x1#
	If x1# &gt; maxx# Then maxx# = x1#
	If x2# &lt; minx# Then minx# = x2#
	If x2# &gt; maxx# Then maxx# = x2#
	If y0# &lt; miny# Then miny# = y0#
	If y0# &gt; maxy# Then maxy# = y0#
	If y1# &lt; miny# Then miny# = y1#
	If y1# &gt; maxy# Then maxy# = y1#
	If y2# &lt; miny# Then miny# = y2#
	If y2# &gt; maxy# Then maxy# = y2#
	;
	xsize# = maxx# - minx#
	ysize# = maxy# - miny#
	;
	x0# = x0# - minx#
	x1# = x1# - minx#
	x2# = x2# - minx#
	y0# = y0# - miny#
	y1# = y1# - miny#
	y2# = y2# - miny#
	;
	For i% = 0 To xsize#
		For j% = 0 To ysize#
			polyhedre%(i%, j%) = 0
		Next
	Next
	;
	drawBresenhamLine(x0#, y0#, x1#, y1#)
	drawBresenhamLine(x1#, y1#, x2#, y2#)
	drawBresenhamLine(x2#, y2#, x0#, y0#)
	;
	For j% = 0 To ysize#
		For i% = 0 To xsize#
			If polyhedre%(i%, j%) Then
				paintArray%(j%, 0) = i%
				Exit
			EndIf
		Next
		For i% = xsize# To 0 Step -1
			If polyhedre%(i%, j%) Then
				paintArray%(j%, 1) = i%
				Exit
			EndIf
		Next
	Next
	;
	LockBuffer
	py% = miny#
	For i% = 0 To ySize#
		px% = paintArray%(i%, 0)
		pl% = paintArray%(i%, 1) - px%
		px% = px% + minx#
		For j% = 0 To pl%
			WritePixelFast px%, py%, c%
			px% = px% + 1
		Next
		py% = py% + 1
	Next
	UnlockBuffer
End Function



Function drawBresenhamLine(x0%, y0%, x1%, y1%)
	If x0% = x1% Then
		If y0% = y1% Then
			polyhedre%(x0%, y0%) = 1
			Return
		EndIf
		If y0% &lt; y1% Then
			For i% = y0% To y1%
				polyhedre%(x0%, i%) = 1
			Next
			Return
		EndIf
		For i% = y1% To y0%
			polyhedre%(x0%, i%) = 1
		Next
		Return
	EndIf
	If y0% = y1% Then
		If x0% &lt; x1% Then
			For i% = x0% To x1%
				polyhedre%(i%, y0%) = 1
			Next
			Return
		EndIf
		For i% = x1% To x0%
			polyhedre%(i%, y0%) = 1
		Next
		Return
	EndIf
	If y1% &lt; y0% Then
		temp% = y0%
		y0% = y1%
		y1% = temp%
		temp% = x0%
		x0% = x1%
		x1% = temp%
	EndIf
	dx% = x1% - x0%
	If dx% &lt; 0 Then
		dx% = -dx%
		xinc% = -1
	Else
		xinc% = 1
	EndIf
	dy% = y1% - y0%
	If dy% &lt; 0 Then
		dy% = -dy%
		yinc% = -1
	Else
		yinc% = 1
	EndIf
	two_dx% = dx% + dx%
	two_dy% = dy% + dy%
	xx% = x0%
	yy% = y0%
	If dx% &gt; dy% Then
		error% = 0
		For i% = 0 To dx%
			polyhedre%(xx%, yy%) = 1
			xx% = xx% + xinc%
			error% = error% + two_dy%
			If error% &gt; dx% Then
				error% = error% - two_dx%
				yy% = yy% + yinc%
			EndIf
		Next
	Else
		error% = 0
		For i% = 0 To dy%
			polyhedre%(xx%, yy%) = 1
			yy% = yy% + yinc%
			error% = error% + two_dx%
			If error% &gt; dy% Then
				error% = error% - two_dy%
				xx% = xx% + xinc%
			EndIf
		Next
	EndIf
End Function
</pre> <br><br></td></tr></table><br>
<a name="277533"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see what you mean by the sign of the rotations. It does matter a great deal what way you do the math as you are doing is rotating using standard trig with a standard polar system. That is you rotate the vertices around poles (axis).<br><br>Keep us informed of your project :)<br><br>Nice one Paradox7. A great feeling eh :) <br><br></td></tr></table><br>
<a name="277617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Guys.<br><br>Col, Paradox7, Andy...<br><br>Paradox: of course I am very gratefull to you, for pointing me the path of the swapped signs :^).<br>I am not sure if you really don´t know anything about 3d. If you really don´t, maybe this can help you understand how you helped us: there are two standards employed when writting 3d code: the right-hand rule and the left-hand rule.<br>Well, I was creating vertices using one standard, and was doing the normals math using the other one.<br>Vertex math really is not *that* succeptible to that kind of mistake, for wire-frame, or flat-shaded polygons, because we are using a sphere here.<br>So, what we were looking at, prior to the changes, was the inside of the sphere, not its outside, actualy.<br>But, as it is a sphere, we were not able to tell the difference.<br>But with normals, it makes a lot of difference.<br>Normals are VERY sensitive to signals.<br>Why is that?<br>Take a look at how normals are calculated.<br>You are going to find a sqr() inside of its code.<br>Well, sqr() for positive numbers have TWO possible answers.<br>One is positive, and the other one is negative.<br>But the compiler always returns the positive root.<br>So, you have to pick the correct signs or, otherwise, you are going to end up pointing your normal to the opposite direction.<br>Normals should always point outwards, but they were doing the other way around.<br>Actualy, at some point in time, some of the normal components were correct, whist others were wrong. That may be the reason why I was getting that 12.5 degrees offset, remember?<br><br>Now, everything is working fine.<br>Thanks to you guys.<br><br>Well, things are looking good in voxel realm :^).<br>Let me just finish adding real-time lights to the voxel engine and I will release the source-code.<br><br>Initialy, I will release the gcc source-code.<br>Then, I plan on porting it to BlitzPlus.<br>I am not promissing that the B+ version will be lightning fast.<br>It´s not that B+ os not fast enough.<br>It´s just that the engine was written with C in mind.<br>I took advantage of many special constructs of the C language.<br>For one thing, pointers are used all over the place.<br>I believe that using memory blocks will allow for a speed that will be very close to what I get with C pointers, but am not sure about how they are implemented.<br>I am sure they are slower, but they may be much faster than my best estimates (but will never be as fast as a plain C pointer).<br>As it is heavily based on the use of pointers, performance will depend almost exclusively on how fast peekint and pokeint perform their tasks.<br><br>Well, I have to go to sleep now...<br>I will keep you guys updated.<br><br>Just keep one thing in mind: the voxel engine is targetted at the PS2, which has a very powerfull floating point unit (actualy, a couple of them) and a processor which allows for 128 bit instructions.<br>So, I don´t think a P IV will have a chance against it.<br><br>Also, voxel engines don´t rely on hardware acceleration, so no matter what kind of video-card you have, it is not going to change the performance of the engine at all.<br><br>Fast RAM is desirable, thou...<br><br>Talk to you guys tomorrow,<br><br>Rui Barbosa Jr.<br><br>P.S.: I live in Brazil. It´s 01:21AM.<br>It would be good if you guys could tell me where you live, so I can have an approximate idea of time-zone differences among us.<br>P.P.S.: To know my local time, check Rio de Janeiro time or Brasilia time (they are both on the same time zone as mine, in Brazil). I live in Rio de Janeiro. I have to go.. take a warm shower and go to sleep... See you... <br><br></td></tr></table><br>
<a name="277683"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Paradox7</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Texas here, 2:18am right now, and now its time for me To Sleep :D going to take a quick shower, and sleep, man am i tired. <br><br>I would love to see a good Voxel engine in Blitz, can't wait. I really should get BlitzPlus :/<br><br>I remember seeing voxel demos, with little voxel people in QBasic, long time ago :D was pretty awesome.<br><br>So what is your voxel engine mainly able to create? an entire world? landscape? objects? <br><br></td></tr></table><br>
<a name="277850"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi.<br>The voxel engine for the PS2 deals with characters only.<br>It is not capable of renderind landscapes or rooms.<br>After the engine is complete, I will try to contact someone who has a nice polygon 3d engine for the PS2, in order to make both engines compatible.<br>As long as that polygon engine uses a 32 bit Z-buffer, it will work without any problem.<br><br>Due the the extremely CPU intensive nature of a voxel engine, it is not going to be very good a tool for creating real games, or applications which deal with more than 2 characters simulateneously.<br>It will be a nice tool for one-on-one combats, as well as fighting games.<br><br>I´ll post some source-code real soon.<br><br>Cheers,<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="278724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >3DBuzzFan</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys.<br>I have finished implementing the backfac-culling and lighting on the voxel character engine for the PS2.<br>I am not using tables yet and, still, I get a nice framerate on the PS2, using TV resolution (NTSC output), with a complete spiderman model.<br>Lighting is a little meesed up, due to some bug in the hierarchy´s chain of rotations.<br>But, as long as I only move and/or rotate the topmost element (the butt), all pieces are adjusted accordingly, and are drawn using the proper lighting.<br>I will fix this probably tomorrow, and will get back to you.<br>As soon as it all works fine, I will write a B+ version of it and post it here.<br>Thanks for your help, again.<br><br>Rui Barbosa Jr. <br><br></td></tr></table><br>
<a name="278752"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't have anything useful to add except "cool!"... I love seeing 3D engines written in 2D for some reason. <br><br></td></tr></table><br>
<a name="278957"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm in Essex, just outside London UK. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
