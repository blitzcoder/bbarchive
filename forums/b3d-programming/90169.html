<!DOCTYPE html><html lang="en" ><head ><title >cars ai</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >cars ai</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >cars ai</a><br><br>
<a name="1024861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi<br><br>I have been playing with beziers, jv-ode, cars, tracks and some basic ai for them.<br><br><a href="http://sites.google.com/site/odriozolajuanignacio/carsAI.zip" target="_blank">http://sites.google.com/site/odriozolajuanignacio/carsAI.zip</a><br><br>there are 2 executables, one for race and other for edit the tracks to play with.<br><br>some screen shoots:<br><br><img src="http://sites.google.com/site/odriozolajuanignacio/juanodriozola/blitz3d/editTrack.jpg"><br><br><img src="http://sites.google.com/site/odriozolajuanignacio/juanodriozola/blitz3d/carsAI.jpg"><br><br>the tracks definition file:<br><a href="http://sites.google.com/site/odriozolajuanignacio/tracks.dat" target="_blank">http://sites.google.com/site/odriozolajuanignacio/tracks.dat</a><br><br>the race.bb source:<br><a href="http://sites.google.com/site/odriozolajuanignacio/autos_v_08.bb" target="_blank">http://sites.google.com/site/odriozolajuanignacio/autos_v_08.bb</a><br><br>the EditTrack source:<br><a href="http://sites.google.com/site/odriozolajuanignacio/EditTrack2.bb" target="_blank">http://sites.google.com/site/odriozolajuanignacio/EditTrack2.bb</a><br><br>i'm not an expert on this subjects but my intention is to start a thread to talk about race ai, cars ai and the like.<br><br>best regards<br><br>Juan <br><br></td></tr></table><br>
<a name="1024875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I 'm certainly no expert either, and forgive me for not yet looking over your code, but jsut as a general approach, I would make use of some form of waypoints along the track which the AI cars would aim for, with perhaps some preventative code which ensures they don't cut across the corners bt try to stay on the track.<br><br>What's more 'interesting', perhaps, is dealing with more specific AI instances with regards to how the cars deal with racing. For example, how do they deal with overtaking, or when needing to decelerate for turns etc.<br>I don't have any specific suggestions for this, but definitely worth consideration.<br><br>Lastly, with all that taken into account, the general 'problem' would be that all the AI cars behave in a very similar way. This is something that I personally feel is a little 'outdated' when it comes to racing games, and that AI cars (drivers) ought to have more distinct 'personalities'.<br>Some of this distinctiveness may come from the car itself, i.e. different specs. But it's nice to see, say, one particular car (driver) will race more aggressively or something. <br><br></td></tr></table><br>
<a name="1024885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> i agree with all you say.<br><br>at this stage, the ai inplemented shoul be called a (with out i)<br>cars all behave equal trying to stay on the road at a rasonable speed, and trying to detect each other to race with out hundreds of collisions between them.<br><br>my intention is not to talk about the code, but, with suggestions could be grow time to time.<br><br>there are lots of different aproaches:<br>how to define the track is as i think the firs one. How much info should we must know in advance about the specific shape of the track?. All that we know in advance isn't needed to calculate at run time..<br><br>i started with this and i'm trying to get a code for the one i choose, probably in the middle, i discard this track for a better one.<br><br>does any one has yet a better aproach?<br><br>thank's<br><br>Juan <br><br></td></tr></table><br>
<a name="1025376"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am trying this out now, will let you know what I think soon ish, wow it even has multiple camera mode!<br><br>I hope you do not mind, I am threading in joypad support, however it may take a little time, I really need to code for my University studies - which is no way near as much fun as doing this! <br><br></td></tr></table><br>
<a name="1025776"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here you go, joypad support - please note you need to generate a separate joypad.cfg file for this code to detect a typical joypad - the code for the joypad.cfg file is available at the bottom of the code listing. I auto generated my .cfg file from a utility a long while back from the Blitz forums, I cannot seem to locate it now..<br><br>Regards, BP.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

;********************************************************************************************************************
;********************************************************************************************************************
;
;			C A R S   A I
;	
;********************************************************************************************************************
;********************************************************************************************************************
;
;	Autor : Juan Ignacio Odriozola
;	e-mail: jio@...
;									Charrua
;
;********************************************************************************************************************
;********************************************************************************************************************
;
;	many parts/values are in trial stage
;
;********************************************************************************************************************
;********************************************************************************************************************
;
;	About the track:
;
;		Is defined by a series of WayPoints and it's corresponding control points (2 for each)
;		With this 3 points a bezier interpolation is done to calculate intermediate steps
;
;	File Format
;
;	the "tracks.dat" file is strightforward: has 5 tracks defined
;	each track start with an integer: NumberOfPoints
;
;	and folloging is the definition for each point: 15 values are used
;
;	3 floats for x,y,z of the WayPoint
;	3 floats for x,y,z of the first control point (cp1)
;	3 floats for x,y,z of the second control point (cp2)
;	1 integer for the number of interpolated steps desired from the current point to the next
;	1 integer signaling the DriveLine: 0 center, -1 left, +1 right
;	4 floats not used, but reserved at design time, so for the moment: future use.
;
;
;	The Idea:
;
;	Initialization
;
;		Select one track, read it from disk file.
;		Construct the track based on the way points and their corresponding control points
;		Create black boxes to act as the track it self (not so good, but a more intelligent aproach is delegated to you)
;		Create some cars
;		Place them on the track and indicate for each one, a step on the road to follow
;
;	In each loop:
;
;		Evaluate the next 15 steps, looking for the sharpest curve ahead and with this information limit the Force applied
;		Say accelerate as much as possible depending on the dificultity level of the road: delta yaw from one step to the next
;
;		Evaluate the delta yaw between the car and the target step in the road and correct steer
;
;		If the car is near enough to the target step in the road, then, make the next one the target.
;
;		The car, like the rabbits, always is running to reach the carrot in fron of their noses.
;
;
;	The DriveLine is suggested at track design time: how to aproach a curve, left, center or right from the
;	center of the track.
;
;	the AI based on the near cars may chose to acelerate/brake, steer and to change to another lane.
;
;	Cars by default tend to use the DriveLine, but there are 2 more lanes posibles, one at the left and one at the
;	right of the drive line. 
;
;	The body of the car is painted acordingly to the lane it's using: green: DriveLine, Blue: left lane, Cyan: Right lane.
;
;	The sides of the car are painted with red when the ai chooses to reduce the Force aplied.
;	Say, if the car reduces its velocity and is not painted of red, then is for physics constraints, not for the ai
;	to choose to decelerate the car.
;

;   ### Joypad support incorporated by Blitzplotter.  Please note, for the joypad to function
;   ### you will need a joypad.cfg file which can be gnerated on your computer using the following
;   ### Post, could not find the original post that I got this from however if you scroll to the
;   ### bottom of this code you will see the contents of my joypad.cfg file



;
Graphics3D 1024,768,0,2
;Graphics3D 1920,1200,0,2


;Include "..\incluir\JV-ODE.bb"

Include "JV-ODE.bb"


Type tTrackPoints
	Field Point
	Field Interpolated
	Field cp1
	Field cp2
	Field nSteps
	Field DriveLine
	Field Distance#
	Field Number
End Type

Type tSteps
	Field x#,y#,z#
	Field dDist#
	Field dYaw#
	Field Number
	Field Entity
	Field Sector
	Field SectorNumber
End Type

Type ODEGeom
	Field Body
	Field Geom
	Field Mesh
	Field joint
End Type

;----------------------------------------------
; Blitzplotter joypad support

;JOYPAD GLOBALS
Type joypad
	Field x1id
	Field y1id
	Field x2id
	Field y2id
	Field x1invert
	Field y1invert
	Field x2invert
	Field y2invert
End Type 

Dim j.joypad(3)

For port = 0 To 3
	j(port) = New joypad
	j(port)\x1id = 0
	j(port)\y1id = 0
	j(port)\x2id = 0
	j(port)\y2id = 0
	j(port)\x1invert = 1 ;toggles between 1 and -1 
	j(port)\y1invert = 1
	j(port)\x2invert = 1
	j(port)\y2invert = 1
Next 

readconfig()  ; please note this function requires a joypad.cfg file

; END JOYPAD GLOBALS
;--------------------------------------------------



;some translations spanish =&gt; english
;
;	Auto 		= car
;	Autito 		= little car
;	Cuerpo		= body
;	Costados	= sides
;	Rueda		= wheel
;	Situacion	= Situation
;	Carril		= lane
;	Volver		= return
;	Estabilizar = stabilize
;	SigPuntoCamino = Next Point in the path
;
Type Autito		
	Field Numero
	Field Force#, Steer#	;the ones that drives the car
	Field Cuerpo.ODEGeom
	Field Costados.ODEGeom	;siply something between the wheels to prevent coupling each other when collide side by side
	Field Rueda.ODEGeom[3]
	
	Field vel#   	;velocity
	Field pivot  	;pivot used to calculate velocity: distance from one frame to the other kwnowing we are at 50 
					;game updates a second and 1 blitz unit = 1 metre (3 foots aprox)
					
	Field x#,y#,z#	;initial position
	Field Pitch#, Yaw#, Roll#
	
	Field Situacion	;flags set/clear by Radar to reflect Situation properties: OnTheTrack, no one ahead, blocked the left side and the like
	Field Carril	;0=DriveLine, 1=right, -1=left	There are 3 posible paths on the track: 0 is the defaul
					;usign Situation Flags CarsAI choose wich is the best path at each moment.
	Field Volver	;al salir del central, se amrca un temporizador para regresar.
	Field tCambiarCarril
	Field Estabilizar	;when the car is upside down (you drive so badly)
	Field tEstabilizar	;timer to stabilize the car some ms after detected the upside down situation

	Field SigPuntoCamino	;handle to the next step ahead in the track, the one we are facing to and trying to reach
	Field dYaw#		;delta yaw from the car orientation to the target position (depends on the lane choosen)
	Field dDist#	;distance to the next point in the track
End Type

;more translations
; Camara   = Camera	
; Numero   = Number
; Asignada = Assigned
Type Cams
	Field Camara	;entity
	Field Numero	;1 for the main full screen camera, 2, 3, 4, 5 for the first 4 cars
	Field Asignada	;true/false
End Type


Global CarAmount=Input("Number of cars (1..12) :")
If CarAmount &lt; 1 Or CarAmount &gt; 12 Then CarAmount=4	;defecto

Global TrackNumber=Input("Select Track (1..5): ")
If TrackNumber &lt; 1 Or TrackNumber &gt; 6 Then TrackNumber = 1

Global keypad = 0

Global UserControl=Input("Select control (0 - keyboard, 1 - joypad): ")
If UserControl &gt;=1
	keypad = 0
Else
	keypad = 1
EndIf


Global TrackWidth#=18

Global MaxSpeed# = 40.0
Global IncSpeed# = .15
Global DecSpeed# = -.3

Global MaxSteer# = 1
Global MaxNegSteer# = -1
Global IncSteer# = .05
								;SwitchDistance
Global DistCambio# = 50			; less than that, set target to the next step in the track

;this 4 controls via F1..F4 som visualizations preferences
Global ShowMap = True
Global MultipesCamaras = False	;MultipleCameras
Global ShowHelp = True
Global ShowLanes = True
Global MostrarNros=True

;next 2, are implemented in code, but not modifyed by keyboard
;i used them just for testing some tiem ago and think that is good to keep them as is.
Global AceleracionAutomatica = False	;let CarsAI manage the Acelerator of my car: only press UpArrow

Global DirFric = True			;controls if Dir1, Mu, Mu2, Slip1 and Slip2 are adjusted each frame
								;to reflect wheel orientation and spin... see UpdateCars function
								
Global CMass#=300			; ### Car Mass
Global WMass#=50			; ### Wheel Mass

Global WorldERP# = 0.5			; ### World Error Correction	Default=0.2 typ: 0.1 .. 0.8
Global WorldCFM# = 0.0001		; .0001 Constraint force mixing Default= 10-5: 0.00001
Global WorldFriction# = 200.0	; ### World Friction

Global WorldIteractions = 100

Global VelTorque#=1000		; ### Joint Torque	o fmax aplicable en el joint que hace girar la rueda!
Global SteerTorque#=10000	; same for steer

Global SuspensionHS#=0.0001	; ### Suspension Hardness/Softness (Higher=Softer - Lower=Harder)
Global SuspensionERP# = 0.5

Global CarStartY=2

Global Spin#, MaxSpinVel#, MaxSpin#	;used to test how much spin a wheel: my tests: 40 RPS aprox at max speed

; ###################################################################################################
; ### Setup ODE

dInitODE()

Global World=dWorldCreate()
Global Space=dHashSpaceCreate(0)
Global ContactGroup=dJointGroupCreate(0)

dWorldSetQuickStepNumIterations (World, WorldIteractions)

dWorldSetERP(World,WorldERP)
dWorldSetCFM(World, WorldCFM)

dWorldSetGravity(World,0,-0.98,0)

dWorldSetAutoDisableFlag(World,1)

dContactSetMode(dContactFDir1+dContactSlip1+dContactSlip2+dContactMu2)
dContactSetMu(WorldFriction*2)
dContactSetFDir1(1,1,1)
dContactSetSlip1(0.001)
dContactSetSlip2(0.001)
dContactSetMu2(WorldFriction*2)


; ### Create light
Global Light=CreateLight()
PositionEntity Light,500,500,500
temp = CreatePivot()
PointEntity Light,temp
FreeEntity temp
LightColor Light,255,255,255

AmbientLight 64,64,64

; ### Create camera
Global Camera=CreateCamera()
Local RangoCamara = 2000
CameraRange Camera,1,RangoCamara
PositionEntity Camera,0,10,-20
CameraClsColor Camera,40,40,200

Local c.Cams
c.Cams = New Cams
c\Camara = Camera
c\Numero = 0
c\Asignada=True

.Views
Data   0,  0,512,384
Data 512,  0,512,384
Data   0,384,512,384
Data 512,384,512,384

Restore Views
Local x, y, width, height
nCams = 4
If CarAmount &lt; 4 Then nCams = CarAmount
For i=1 To nCams	;set view port for each camera
	c.Cams = New Cams
	c\Numero = i
	If i&lt;=CarAmount Then
		c\Camara = CreateCamera()
		CameraRange c\Camara,1,RangoCamara
		Read x
		Read y
		Read width
		Read height
		CameraViewport c\Camara,x,y,width,height
		CameraProjMode c\Camara,0
		c\Asignada = True
	End If
Next

Global MapCamera = CreateCamera()
CameraRange MapCamera,500,2500
PositionEntity MapCamera,0,1200,0
piv=CreatePivot()
PointEntity MapCamera,piv
RotateEntity MapCamera,EntityPitch(MapCamera),EntityYaw(MapCamera),90
FreeEntity piv

CameraViewport MapCamera,1024-160,0,160,120

ShowMap=True

If Not ShowMap Then
	CameraProjMode MapCamera,0
Else
	CameraProjMode MapCamera,1
End If



; ### Create plane
Global FloorGeom = dCreatePlane(Space,0,1,0,0)
Global Plane=CreatePlane()
EntityAlpha Plane,0.8
PlaneTexture=CreateTexture(128,128,9)

ClsColor 128,128,128
Cls
Color 192,192,192
Rect 0,0,64,64,1
Rect 64,64,64,64,1

CopyRect 0,0,128,128,0,0,BackBuffer(),TextureBuffer(PlaneTexture)
ScaleTexture PlaneTexture,20,20
EntityTexture Plane,PlaneTexture,0,0



; ###################################################################################################

Local  tTemp, frameElapsed, frameTween#, frameTicks, frameLimit
Global gameFPS = 50
Global framePeriod = 1000 / gameFPS
Global frameTime = MilliSecs () - framePeriod

Global fps_=0, fps=0	;number of RenderWorld's per second
Global ups_=0, ups=0	;number of update games per second
Global tug_=0, tug=0	;accumulated time of update games in 1 second
Global trw_=0, trw=0	;accumulated time of render world in 1 second
Global tuw_=0, tuw=0	;accumulated time of update world in 1 second
Global NextSecond = MilliSecs()
Global TrisGranularity = 1000

Local Auto.Autito

Global TrackLenght#

LoadTrack(TrackNumber)	;loads a track from disk file and creates a series of waypoints
CreateTrack()	;based on waypoints created

CreateCars()



Repeat
	
	Repeat
		frameElapsed = MilliSecs () - frameTime
	Until frameElapsed
	
	frameTicks = frameElapsed / framePeriod
	
	frameTween# = Float (frameElapsed Mod framePeriod) / Float (framePeriod)
	
	For frameLimit = 1 To frameTicks
		
		If frameLimit = frameTicks Then CaptureWorld
		frameTime = frameTime + framePeriod
		
		tTemp = MilliSecs()
		UpdateGame ()
		
		tug_ = tug_ + MilliSecs() - tTemp
		
		ups_ = ups_ + 1
		
		tTemp = MilliSecs()
		UpdateWorld
		tuw_ = tuw_ + MilliSecs() - tTemp
		
	Next
	
	tTemp = MilliSecs()
	RenderWorld frameTween
	trw_ = trw_ + MilliSecs() - tTemp
	fps_=fps_+1
	
	UpdateInfo()
	
		
	Flip True
	
Until KeyHit (1)

dJointGroupDestroy(ContactGroup)
dSpaceDestroy(Space)
dWorldDestroy(World)
dCloseODE()

End


Function CreateCars()
	
	Local CarID, mass, count
	Local Auto.Autito
	Local n, p.tSteps
	
	p = First tSteps
	
	For CarID=1 To CarAmount
		
	; ### Create car body
		
		Auto.Autito = New Autito

		Auto\Cuerpo.ODEGeom = New ODEGeom
		Auto\Numero = CarID
		Auto\pivot = CreatePivot()
		
		Auto\x = p\x
		Auto\y = p\y
		Auto\z = p\z
		
		Auto\dYaw = 0
		
		Auto\Pitch = 0
		Auto\Roll = 0
		Auto\Yaw = EntityYaw(p\Entity)
		
		p = After p
		Auto\SigPuntoCamino = Handle(p)
		
		Auto\Cuerpo\Body=dBodyCreate(World)
		dBodySetRotation(Auto\Cuerpo\Body,0,0,0)
		dBodySetPosition(Auto\Cuerpo\Body, Auto\x, Auto\y+CarStartY, Auto\z)
		
		mass=dMassCreate()
		dMassSetBoxTotal(mass,CMass,1.0,.5,3.0)
		dBodySetMass(Auto\Cuerpo\Body,mass)
		dMassDestroy(mass)
		
		Auto\Cuerpo\Geom=dCreateBox(Space,1.0,.5,3.0)
		dGeomSetBody(Auto\Cuerpo\Geom,Auto\Cuerpo\Body)
		
		Auto\Cuerpo\Mesh=CreateCube()
		NameEntity Auto\Cuerpo\Mesh,Handle(Auto)
		
		ScaleMesh Auto\Cuerpo\Mesh,.5,.25,1.5		;body: 3 x 1 metres, 0.5 height
		RotateMesh Auto\Cuerpo\Mesh,0,0,0
		PositionMesh Auto\Cuerpo\Mesh,0,0,0
		
		EntityAlpha Auto\Cuerpo\Mesh,1
		
		Local OffsetBody
		OffsetBody=Auto\Cuerpo\Body
		
		Auto\Costados = New ODEGeom
		Auto\Costados\Geom=dCreateBox(Space,3,.36,1)
		dGeomSetBody(Auto\Costados\Geom,OffsetBody)
		dGeomSetOffsetPosition(Auto\Costados\Geom,0,-.1,-.3)
		Auto\Costados\Mesh=CreateCube()
		ScaleMesh Auto\Costados\Mesh,1.5,.18,.5
		PositionEntity Auto\Costados\Mesh,0,0,0
		
		If CarID=1
			;my car is red
			EntityColor Auto\Cuerpo\Mesh,192,32,32
			EntityColor Auto\Costados\Mesh,192,32,32
		Else
			;others green
			EntityColor Auto\Cuerpo\Mesh,16,192,32
			EntityColor Auto\Costados\Mesh,16,192,32
		End If
		
		; ### Create wheels	
		
		For count=1 To 4
		
			Auto\Rueda.ODEGeom[count-1] = New ODEGeom
			Auto\Rueda[count-1]\Body=dBodyCreate(World)
			
			dBodySetRotation(Auto\Rueda[count-1]\Body,0,0,0)
			dBodySetPosition(Auto\Rueda[count-1]\Body,0,0,0)
			
			mass=dMassCreate()
			If count&lt;2 Then
				dMassSetSphereTotal(mass,WMass,0.4)
			Else
				dMassSetSphereTotal(mass,WMass,0.4)
			End If
			
			dBodySetMass(Auto\Rueda[count-1]\Body,mass)
			dMassDestroy(mass)
			
			Auto\Rueda[count-1]\Geom=dCreateSphere(Space,0.4)
						
			dGeomSetBody(Auto\Rueda[count-1]\Geom,Auto\Rueda[count-1]\Body)
			
			Auto\Rueda[count-1]\Mesh = CreateCylinder(8)

			ScaleMesh Auto\Rueda[count-1]\Mesh,0.4,0.25,0.4
			
			RotateMesh Auto\Rueda[count-1]\Mesh,0,0,90
			PositionMesh Auto\Rueda[count-1]\Mesh,0,0,0
			EntityColor Auto\Rueda[count-1]\Mesh,32,32,32
			
		Next

		dBodySetPosition(Auto\Rueda[0]\Body,Auto\x-1.0,Auto\y+CarStartY-0.2,Auto\z+1.2)
		dBodySetPosition(Auto\Rueda[1]\Body,Auto\x+1.0,Auto\y+CarStartY-0.2,Auto\z+1.2)
		
		dBodySetPosition(Auto\Rueda[2]\Body,Auto\x-1.4,Auto\y+CarStartY-0.2,Auto\z-1.5)
		dBodySetPosition(Auto\Rueda[3]\Body,Auto\x+1.4,Auto\y+CarStartY-0.2,Auto\z-1.5)
		
		For count = 0 To 3
			Auto\Rueda[count]\joint = dJointCreateHinge2(World,0)
			dJointAttach(Auto\Rueda[count]\joint,Auto\Cuerpo\Body,Auto\Rueda[count]\Body)
			dJointSetHinge2Anchor(Auto\Rueda[count]\joint,dBodyGetPositionX(Auto\Rueda[count]\Body),dBodyGetPositionY(Auto\Rueda[count]\Body),dBodyGetPositionZ(Auto\Rueda[count]\Body))
			dJointSetHinge2Axis1(Auto\Rueda[count]\joint,0,1,0)
			dJointSetHinge2Axis2(Auto\Rueda[count]\joint,-1,0,0)
			dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamSuspensionERP,SuspensionERP)
			dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamSuspensionCFM,SuspensionHS)
			If count&gt;1
				dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamLoStop,0)
				dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamHiStop,0)
			End If
		Next
		
		dBodySetForce(Auto\Cuerpo\Body,0,0,0)
		dBodySetTorque(Auto\Cuerpo\Body,0,0,0)
		dBodySetAngularVel(Auto\Cuerpo\Body,0,0,0)
		dBodySetLinearVel(Auto\Cuerpo\Body,0,0,0)
		For count = 0 To 3
			dBodySetForce(Auto\Rueda[count]\Body,0,0,0)
			dBodySetTorque(Auto\Rueda[count]\Body,0,0,0)
			dBodySetAngularVel(Auto\Rueda[count]\Body,0,0,0)
			dBodySetLinearVel(Auto\Rueda[count]\Body,0,0,0)
		Next
		dBodySetRotation(Auto\Cuerpo\Body,Auto\Pitch,Auto\Yaw,Auto\Roll)
		
	Next
	
End Function



Function BarGraph(yPos)
	
	Local i
	
	;shows a graph with 
	;	FPS in red from 0 To 60
	;	game updates in white from 0 to 60
	;	ammount of RenderWorld in green plus game updates in blue plus update world in yelow
	;	concatenated and calculated as a percent of 1 second
	;
	;the graph has as a background a rectangle in black that covers just 5/6
	;signaling 100% for UpdateGame+UpdateWorld+RenderWorld
	;the vertical lines signal 5, 10, 15 and so on for fps and 10, 20, 30, etc
	;for percentages.
	;least: TrisRendered() from 0 to TrisGranularity*100 in grey
	;each vertical line signal for TrisRendered the ammount defined previously by TrisGranularity
	
	
	If MilliSecs()&gt;NextSecond Then
		fps = fps_
		fps_ = 0
		ups = ups_
		ups_ = 0
		tug = tug_
		tug_ = 0
		trw = trw_
		trw_ = 0
		tuw = tuw_
		tuw_ = 0
		NextSecond=MilliSecs()+1000
	End If
	
	Color 0,0,0
	Rect 10,yPos+8,100,42
	For i=1 To 12		;from 0 to 60 whatever per second or 0 to 100%
		If i Mod 2 Then
			Color 0,128,128
		Else
			Color 0,192,192
		End If
		Line 10+i*10, yPos+8,  10+i*10,yPos+50
	Next
	Color 255,0,0		;en rojo world renders 
	Rect 10,yPos+10,fps*2,6
	Color 255,255,255	;en blanco game updates
	Rect 10,yPos+20,ups*2,6
	Color 0,255,0		;como porcentaje en verde Trender
	Rect 10,yPos+30,100*trw/1000,6
	Color 0,0,255		;en azul T update game
	Rect 10+100*trw/1000,yPos+30,100*tug/1000,6
	Color 255,255,0		;en amarillo T update world
	Rect 10+100*trw/1000+100*tug/1000,yPos+30,100*tuw/1000,6
	Color 192,192,192
	Rect 10,yPos+40,TrisRendered()/TrisGranularity ,6	;en gris TrisRendered()
	
End Function

Function ControlarAuto(Auto.Autito)
	
	;controlar por teclado
	
	If AceleracionAutomatica Then
		;ai para aceleracion del auto, yo solo controlo 2 teclas acelerador y freno
		;yo decido si acelerar o no, si acelero, lo hace automático segun el camino
		;si no acelero, disminuye la velocidad ademas de lo que el camino le diga
		;si freno frena.
		If KeyDown(200)=1 Then
			;ai para el acelerador/freno
			CarsAI(Auto,False, True, 10, 0.1)	;acelera segun le diga el camino
			If (Auto\Force &lt; 3) Then Auto\Force=Auto\Force + .5
		Else
			Auto\Force=Auto\Force*0.995
		End If
	Else
		If KeyDown(200)=1
			Auto\Force=Auto\Force+IncSpeed*1.1
			If Auto\Force&gt;MaxSpeed Then Auto\Force=MaxSpeed
		End If
		If KeyDown(200)=0 And KeyDown(208)=0 Then Auto\Force=Auto\Force*0.99
	End If
	
	If KeyDown(208)=1	;el freno funciona siempre ademas de lo que ai decida
		Auto\Force=Auto\Force+DecSpeed
		If Auto\Force&lt;0 Then Auto\Force=0
		If Auto\Force&gt;0 Then Auto\Force=Auto\Force*0.99
	End If
	
	If KeyDown(203)=1 Or KeyDown(205)=1
		If KeyDown(203)=1
			Auto\Steer =  Auto\Steer + IncSteer
			If Auto\Steer &gt; MaxSteer Then Auto\Steer = MaxSteer
		Else
			Auto\Steer =  Auto\Steer - IncSteer
			If Auto\Steer &lt; MaxNegSteer Then Auto\Steer = MaxNegSteer
		End If
	Else
		Auto\Steer = Auto\Steer*0.7	;decrease steer smoothly to 0 if no left or right arrow key
	End If
		
End Function

Function ControlarAutoJoypad(Auto.Autito)   ;Note this function slighlt modified by Blitzplotter 
											;for joypad support
	
	;controlar por teclado
	
		;read in joypad status	
	X1_axis=MapAxis(j(Controller_port)\x1id,j(Controller_port)\x1invert)
	Y1_axis=MapAxis(j(Controller_port)\y1id,j(Controller_port)\y1invert)
	X2_axis=MapAxis(j(Controller_port)\x2id,j(Controller_port)\x2invert)
	Y2_axis=MapAxis(j(Controller_port)\y2id,j(Controller_port)\y2invert)
	
	
	
	
	If AceleracionAutomatica Then
		;ai para aceleracion del auto, yo solo controlo 2 teclas acelerador y freno
		;yo decido si acelerar o no, si acelero, lo hace automático segun el camino
		;si no acelero, disminuye la velocidad ademas de lo que el camino le diga
		;si freno frena.
		If KeyDown(200)=1 Then
			;ai para el acelerador/freno
			CarsAI(Auto,False, True, 10, 0.1)	;acelera segun le diga el camino
			If (Auto\Force &lt; 3) Then Auto\Force=Auto\Force + .5
		Else
			Auto\Force=Auto\Force*0.995
		End If
	Else
		;If KeyDown(200)=1
		If Y1_Axis = -1
			Auto\Force=Auto\Force+IncSpeed*1.1
			If Auto\Force&gt;MaxSpeed Then Auto\Force=MaxSpeed
		End If
		;If KeyDown(200)=0 And KeyDown(208)=0 Then Auto\Force=Auto\Force*0.99
		If Y1_Axis = 0 Then Auto\Force=Auto\Force*0.99 
	End If
	
	;If KeyDown(208)=1	;el freno funciona siempre ademas de lo que ai decida
	If Y1_Axis = 1
		Auto\Force=Auto\Force+DecSpeed
		If Auto\Force&lt;0 Then Auto\Force=0
		If Auto\Force&gt;0 Then Auto\Force=Auto\Force*0.99
	End If
	
	;If KeyDown(203)=1 Or KeyDown(205)=1
	If X2_Axis  = -1 Or X2_Axis = 1
		;If KeyDown(203)=1
		If X2_Axis=-1
			
			Auto\Steer =  Auto\Steer + IncSteer
			If Auto\Steer &gt; MaxSteer Then Auto\Steer = MaxSteer
		Else
			Auto\Steer =  Auto\Steer - IncSteer
			If Auto\Steer &lt; MaxNegSteer Then Auto\Steer = MaxNegSteer
		End If
	Else
		Auto\Steer = Auto\Steer*0.7	;decrease steer smoothly to 0 if no left or right arrow key
	End If
	
End Function



Function SigPunto(Auto.Autito)

	;find next point
	
	Local Punto.tSteps
	Local Distancia#
	
	Punto = Object.tSteps(Auto\SigPuntoCamino)	;get current target point
	
	Distancia = Distance2D(EntityX(Auto\Cuerpo\Mesh,True),EntityZ(Auto\Cuerpo\Mesh,True),Punto\x,Punto\z)
	Auto\dDist = Distancia
	
	If Distancia &lt; DistCambio+(DistCambio/2)*Auto\vel Then	;DistCambio puede o deberia variar con la velocidad...
	
		EntityColor(Punto\Entity,128,0,0)		;vuelvo a rojo al punto del camino que dejo de ser mi objetivo
												;paint red again the point that's no more my target
		
		Punto = After Punto
		If Punto=Null Then Punto = First tSteps	;get next point ahead
		
		Auto\SigPuntoCamino = Handle(Punto)
		
		If Auto\Numero=1
			;this code where simply to get for my car the SpeedFactor used for debug
			;
			Curva# = ClampValue(MaximoHaciaAdelante(Handle(Punto),15), 0.0, 10.0)
			SpeedFactor# = 1.0 - Float(Curva/12.0)
			;globalVariable = SpeedFactor	;then in the main loop i show that globalVariable
			;in this way i test seen it when driving, just to see if the value calculated is rasonably good
			
		End If
		
		EntityColor(Punto\Entity,255,255,0)	;pinto el siguiente punto del camino de amarillo
											;paint yellow the new target point
		
	End If
	
End Function


Function MaximoHaciaAdelante#(punto,Cuantos=10)

	;find the Max dYaw ahead in the track (Cuantos=how many)
	;based on this info, we know (CarsAI see the curve ahead) how much to acelerate/decelerate the car
	temp.tSteps = Object.tSteps(punto)
	Max# = Abs(temp\dYaw)
	For i=1 To 5
		temp=Before temp
		If temp=Null Then temp = Last tSteps
	Next
	For i=1 To Cuantos
		If Max&lt;Abs(Temp\dYaw) Then Max=Abs(temp\dYaw)
		temp=After temp
		If temp=Null Then temp=First tSteps
	Next
	Return Max

End Function


Function CarsAI(Auto.Autito,VolanteAutomatico, AceleradorAtuomatico, PuntosHaciaAdelante, Correccion#)
	
	;Auto : car to drive
	;VolanteAutomatico: AutomaticSteer : AI for Steer
	;AceleradorAutomatico: AutomaticForce : AI for Force
	;PuntosHaciaAdelante: PointsAhead : how many points to see in advance for worst dYaw, how far AI see problems ahead
	;Correccion : Strenght of correction aplied to steer when out of the way. Big values cause over steer, small ones
	;cause late reaching of target, in a sharp curve the car goes out side of the track. Over steer cases overtturn at high
	;speed
	
	Local Punto.tSteps
		
	Punto = Object.tSteps(Auto\SigPuntoCamino)
	
	ForceAlEntrar# = Auto\Force
	
	Caminos(Auto)
	
	Curva# = ClampValue( MaximoHaciaAdelante(Handle(Punto),PuntosHaciaAdelante), 0.0, 10.0)
	SpeedFactor# = 1.0 - Float(Curva/12.0)
	
	;curva is in the range 0..10
	;10 degrees of dYaw in points separated 50 metres is a sharp curve!
	;SpeedFactor# gives a series of values from 1 to 0.167
	;thats the serie of values for angles from 0 to 10
	; 1.0, 0.916667, 0.833333, 0.75, 0.666667, 0.583333, 0.5, 0.416667, 0.333333, 0.25, 0.166667
	;
		
	If (Auto\Situacion And 256) = 256 Then	;if car is on the track
	
		If (Auto\Situacion And 512) = 512 Then 	;Danger, ahead are cars slowly (very slowly than me)
			Auto\Force = Auto\Force*0.98		;brake
			Auto\Steer = 0						;if braking leave the direction stright
			;Auto\Steer = Auto\Steer*0.7
		Else
			If (Auto\Situacion And 7) = 7 Then 
				Auto\Force = Auto\Force*0.99	;there are cars NW, N and NE slightly slowly than me
				Auto\Steer = 0
				;Auto\Steer = Auto\Steer*0.7		;if braking leave the direction stright
			Else
				;si no estoy frenando bruscamente por bloqueo adelante ni peligro
				;controlo el volante
				;if there is a clean track ahead then drive the car: Volante = Steer
				If VolanteAutomatico Then Volante(Auto,Correccion)
			End If
		End If
		
		
		If AceleradorAtuomatico Then
				
			Force# = ClampValue(Auto\Force+IncSpeed,0,MaxSpeed*SpeedFactor)
			;MaxForce to apply considering the track dificultity
			;but this calculated value is a sugestion. If the car is slowly, then the car acelerate
			;if the car is rasonably at the same speed as sugested, i take this value
			;but if the car is at high speed, reduce it abruptly is not recomended, so Brake until rasonably.
			
			If Auto\Force*0.9 &lt; Force Then
				Auto\Force = Force				;if less increment speed
			Else
				;if not, reduce the velocity, 	if they aren't comparable, change the Force say from 1 to 0.3 causes too much brakes!
				Auto\Force = Auto\Force*0.98	;frena o acelera en fn de si el auto va mas o menos que lo calculado
			End If
					
		End If
			
	Else
		;si fuera de la pista ademas de frenar, luego hay que intentar volver a la pista
		;pero no cuando recien me voy... hay que evitar que no solo frene sino un viraje exagerado
	
		;if OutOfTheTrack deceleration is aplied to all cars (even the red one)
		;i reduce Correction trying to reduce over steer, because if i'm out side the track, surely dYaw to the
		;target point should be big.
	
		If VolanteAutomatico Then
			Volante(Auto,Correccion/2)	;si me fui corrijo menos, para evitar volantazos...
		End If
		Auto\Carril=0
		Auto\Volver = MilliSecs()+5000
		Auto\tCambiarCarril = MilliSecs()+5000
		
	End If
		
	If Auto\Force &lt; forceAlEntrar Then
		;paint red if force where reduced
		EntityColor Auto\Costados\Mesh,128,0,0
	Else
		EntityColor Auto\Costados\Mesh,0,128,0
	End If

End Function


Function Volante(Auto.Autito, Ajuste#=0.05)

	Local Punto.tSteps
	Local Angulo#, Target

	Punto = Object.tSteps(Auto\SigPuntoCamino)
	
	Select Auto\Carril
		Case 0
			Target = Punto\Entity
		Case -1
			Target = GetChild(Punto\Entity,1)
		Case +1
			Target = GetChild(Punto\Entity,2)
	End Select
	
	;Target define the lane in which we are driving
	
	Angulo = DeltaYaw(Auto\Cuerpo\Mesh,Target)	;calculo el angulo entre el auto y el siguiente punto
	
	;as a function of delta yaw an scaled steer is aplied: 0.05 is a good value for this simulation
	
	Steer# = (Angulo + Punto\dYaw) * Ajuste
	Steer = ClampValue(Steer, MaxNegSteer, MaxSteer)
	Auto\Steer = Steer
	
	Auto\dYaw = Angulo

End Function

Function Caminos(Auto.Autito)	;paths

	;this routine manage the return to the lane 0 if current situation makes it posible (DriveLine)
	;when choosing to take the left or right lane, the body of the car is painted blue or cyan
	;returning to green when on lane 0 again.

	If MilliSecs() &gt; Auto\Volver Then
		;si puedo vuelvo al carril 0
		If Auto\Carril &lt;&gt; 0 Then
			Reintento = Rand( 5000, 10000 )
			If Auto\Carril = -1 Then	;voy por carril izquierdo, vuelvo si no tengo bloqueo a derecha bit 1
				If (Auto\Situacion And 1)&lt;&gt;0 Then
					Auto\Volver = Auto\Volver + Reintento	;veo el siguiente segundo que hago
				Else
					Auto\Carril = 0
					EntityColor Auto\Cuerpo\Mesh,0,255,0
				End If
			Else
				If (Auto\Situacion And 4)&lt;&gt;0 Then	;voy por carril derecho vuelvo si no tengo bloqueo a iz bit 2
					Auto\Volver = Auto\Volver + Reintento	;veo el siguiente segundo que hago
				Else
					Auto\Carril = 0
					EntityColor Auto\Cuerpo\Mesh,0,255,0
				End If
			End If
		End If
	End If
	
	
	If MilliSecs() &gt; Auto\tCambiarCarril Then
		;timer to let the lane switch to occurr
		
		Volver = Rand(5000,10000)
		
		tCambiar = 1000
	
		Select (Auto\Situacion And 7)
			;ok the numbers from 0 to 7 written in binary: 3 flags: left, centre, right
			;that signals ocupied lanes
			
			Case 0,1,4,5	;x0x	(x=don't care) : left or right occupied but nothing in front
							;libre hacia adelante acelere mijo!	(mijo is a contraction of mi hijo : my son, what a translator say about "mijo"?)
							;no one in front, acelerate 
					;acelerate: CarsAi takes it into account
					
			Case 2	; 010 elijo iz der	;something in front, chosse lane -1 or +1
				If Auto\Carril=0 Then
					If Rand(0,1)=1 Then	;could be some thing more interesting as say 80% right for a car and 30% for another
										;or, taking to account the curve to take from inside or outside...
						Auto\Carril = 1
					Else
						Auto\Carril = -1
					End If
					Auto\Volver = MilliSecs()+Volver	;set timers to return to lane 0 if posible
					Auto\tCambiarCarril = MilliSecs()+tCambiar	;do not take other decision before 1 second has elapsed
					If Auto\Carril = 1 Then
						EntityColor Auto\Cuerpo\Mesh,0,255,255
					Else
						EntityColor Auto\Cuerpo\Mesh,0,0,255
					End If
				End If
			
			Case 3	; 011 libre a izq
				Auto\Carril = -1
				EntityColor Auto\Cuerpo\Mesh,0,0,255
				Auto\Volver = MilliSecs()+Vover
				Auto\tCambiarCarril = MilliSecs()+tCambiar
				
			Case 6	; 110 libre a derecha
				Auto\Carril = +1
				EntityColor Auto\Cuerpo\Mesh,0,255,255
				Auto\Volver = MilliSecs()+Volver
				Auto\tCambiarCarril = MilliSecs()+tCambiar
			
			Case 7	; 111 frenar
				;aply brakes (CarsAi takes it into account)
			
		End Select
		
	End If

End Function

Function Radar(Auto.Autito)

	;Flags that signal diferent situations or an acumulated situation

	;informacion recabada por Radar:
	; 10 bits: p _\|/_ i c d 
	;
	; bit nombre
	; 9		F	: brakes : ahead are a car slowly, 0.3 or less than my velocity
	; 8		p	: out of the track
	;
	; 2		i	: izquierda : left occupied
	; 1		c	: centro	: center occupied
	; 0		d	: derecha	: right occupied
	;
	;bits in each direction are set only if the velocity of the ahead cars are less than mine
	
	Local a.Autito
	
	Auto\Situacion=0
	
	;is the car on the track?
	LinePick EntityX(Auto\Cuerpo\Mesh),EntityY(Auto\Cuerpo\Mesh),EntityZ(Auto\Cuerpo\Mesh),  0, -5,  0	;pista?
	If PickedEntity() Then Auto\Situacion=Auto\Situacion Or 256

	
	;if i'm on the left or right lane, then they are ocupied, say, not to choose to go to lane -1 if already on that lane...
	If Auto\Carril=-1 Then Auto\Situacion = Auto\Situacion Or 4	;si voy por la iz, no puedo ir mas hacia la iz
	If Auto\Carril=+1 Then Auto\Situacion = Auto\Situacion Or 1	;si voy por la derecha, no puedo ir mas hacia la derecha

	For a = Each Autito
	
		If a\Numero&lt;&gt;Auto\Numero Then
		
			If (a\Situacion And 256)=256 Then	;auto en pista
				;evaluate cars that are on the track only
		
				d#=Distance2D( EntityX(a\Cuerpo\Mesh,True), EntityZ(a\Cuerpo\Mesh,True), EntityX(Auto\Cuerpo\Mesh,True), EntityZ(Auto\Cuerpo\Mesh,True) )			
				Desvio# = DeltaYaw(Auto\Cuerpo\Mesh, a\Cuerpo\Mesh)
				Offset# = Auto\vel*20	;a 100Km/h agrega 20 metros de distancia	vel = 1.0 = 100 km/h
				
				;the radar reaches a distance variable acordingly to the car velocity
				;scans in steps of 44 degrees from -110 to + 110 dividing this angle in 5 zones:
				;W, NW, N, NE, E basically that's the idea
				;if it finds a car with less velocity than mine set's the corresponding bit
				;if the velocity is too slow from mine signals to Break
				;
				
				vel# = a\vel
				
				If d &lt; (20+Offset) Then
					;avaluate cars in range, say near me
				
					If Desvio&gt;-110 And Desvio&lt;110 Then
						;and not the ones behind
		
						
						For i=0 To 4
							;scan 5 zones: W, NW, N, NE, E
							
							;why 44? and not 45?, just because i say 44!, and i'm the boss!
							
							;rule number one, gold standard: The boss always has reason
							;rule number two, in case the boss didn't has reason.... rule one is applied!
							
							
							If Desvio&gt;(-110+i*44) And Desvio&lt;(-110+(i+1)*44) Then
								Select i
											;-110 .. -66
									Case 0	; -90 .. -54	esto es derecha!
										Auto\Situacion=Auto\Situacion Or 8
										Auto\Situacion=Auto\Situacion Or 1
									
											; -66 .. -22
									Case 1	; -54 ..-18	;esto es adelante derecha
									
										;If auto\vel*0.90 &gt; vel Then
											Auto\Situacion=Auto\Situacion Or 16
											Auto\Situacion=Auto\Situacion Or 1
										;End If
										If Auto\vel*0.2 &gt; vel Then
											Auto\Situacion=Auto\Situacion Or 512
										End If
											; -22 .. 22
									Case 2	; -18 .. 18	;sigue siendo adelante
										;If auto\vel*0.95 &gt; vel  Then
											;to force Caminos to chose other lane if a car is in front
											;mo matter their velocity
											Auto\Situacion=Auto\Situacion Or 32
											Auto\Situacion=Auto\Situacion Or  2
										;End If
										If Auto\vel*0.3 &gt; vel Then
											Auto\Situacion=Auto\Situacion Or 512
										End If
										
									Case 3	;
										;If auto\vel*0.90 &gt; vel  Then
											Auto\Situacion=Auto\Situacion Or 4
											Auto\Situacion=Auto\Situacion Or 64
										;End If
										If Auto\vel*0.2 &gt; vel Then
											Auto\Situacion=Auto\Situacion Or 512
										End If
										
									Case 4
										Auto\Situacion=Auto\Situacion Or 4
										Auto\Situacion=Auto\Situacion Or 128
											
								End Select
			
							End If
						Next
						
					End If	;auto iz, der o adelante, que los de atras se preocupen por mi...
					
				End If	;auto en distancia
				
			End If	;auto en pista
			
		End If	;no es auto 1
		
	Next
	
End Function

Function UpdateKeys()
	
	Local Auto.Autito, C.Cams
		
	If KeyHit(59) Then MostrarNros=Not(MostrarNros)	;F1
	
	If KeyHit(60) Then	;F2
	
		MultipesCamaras = Not MultipesCamaras
		
		For C.Cams = Each Cams
			If MultipesCamaras Then
				If C\Numero = 1 Then Camera=C\Camara
				Cls
				If C\Numero=0 Then
					CameraProjMode C\Camara,0	;apago principal
				Else
					CameraProjMode C\Camara,1	;prendo restantes
				End If
			Else
				Cls
				If C\Numero = 0 Then Camera=C\Camara
				If C\Numero=0 Then
					CameraProjMode C\Camara,1	;prendo principal
				Else
					CameraProjMode C\Camara,0	;apago restantes
				End If
			End If
		Next
		
	End If
	
	If KeyHit(61) Then 							;F3
		ShowMap = Not ShowMap
		If ShowMap Then
			CameraProjMode MapCamera,1
		Else
			CameraProjMode MapCamera,0
		End If
	End If
	
	If KeyHit(62) Then ShowHelp=Not(ShowHelp)	;F4
	
	If KeyHit(63) Then 							;F5
		ShowLanes = Not ShowLanes
		If ShowLanes Then
			For p.tSteps = Each tSteps
				ShowEntity p\Entity
			Next
			For tp.tTrackPoints = Each tTrackPoints
				ShowEntity tp\Point
			Next
		Else
			For p.tSteps = Each tSteps
				HideEntity p\Entity
			Next
			For tp.tTrackPoints = Each tTrackPoints
				HideEntity tp\Point
			Next
		End If
	End If
	
	
End Function

Function UpdateJoypad()
	
	Local Auto.Autito, C.Cams
	
	If KeyHit(59) Then MostrarNros=Not(MostrarNros)	;F1
	
	If KeyHit(60) Then	;F2
		
		MultipesCamaras = Not MultipesCamaras
		
		For C.Cams = Each Cams
			If MultipesCamaras Then
				If C\Numero = 1 Then Camera=C\Camara
				Cls
				If C\Numero=0 Then
					CameraProjMode C\Camara,0	;apago principal
				Else
					CameraProjMode C\Camara,1	;prendo restantes
				End If
			Else
				Cls
				If C\Numero = 0 Then Camera=C\Camara
				If C\Numero=0 Then
					CameraProjMode C\Camara,1	;prendo principal
				Else
					CameraProjMode C\Camara,0	;apago restantes
				End If
			End If
		Next
		
	End If
	
	If KeyHit(61) Then 							;F3
		ShowMap = Not ShowMap
		If ShowMap Then
			CameraProjMode MapCamera,1
		Else
			CameraProjMode MapCamera,0
		End If
	End If
	
	If KeyHit(62) Then ShowHelp=Not(ShowHelp)	;F4
	
	If KeyHit(63) Then 							;F5
		ShowLanes = Not ShowLanes
		If ShowLanes Then
			For p.tSteps = Each tSteps
				ShowEntity p\Entity
			Next
			For tp.tTrackPoints = Each tTrackPoints
				ShowEntity tp\Point
			Next
		Else
			For p.tSteps = Each tSteps
				HideEntity p\Entity
			Next
			For tp.tTrackPoints = Each tTrackPoints
				HideEntity tp\Point
			Next
		End If
	End If
	
	
End Function

Function ManejarAutos()

	For Auto.Autito = Each Autito
		
		;calculo velocidad del auto, velocidad instantanea: cuanto recorrio en el ultimo frame
		Auto\vel=EntityDistance(Auto\Cuerpo\Mesh,Auto\pivot)
		PositionEntity Auto\pivot,EntityX(Auto\Cuerpo\Mesh),EntityY(Auto\Cuerpo\Mesh),EntityZ(Auto\Cuerpo\Mesh)

		
		If Auto\Estabilizar Then
			;if car is upside down
			If MilliSecs() &gt; Auto\tEstabilizar Then
				Auto\Estabilizar = False
				Auto\Force=0
				dBodySetRotation(Auto\Cuerpo\Body,dGeomGetPitch#(Auto\Cuerpo\Geom),dGeomGetYaw#(Auto\Cuerpo\Geom),0)
			End If
		Else
			;check to see roll magnitude to see if it isn't horizontally
			If Abs(EntityRoll(Auto\Cuerpo\Mesh)) &gt; 45 Then
				If Auto\Vel &lt; 0.2 Then
					Auto\Estabilizar = True
					Auto\tEstabilizar = MilliSecs() + 5000
					Auto\Carril=0
					Auto\Volver = MilliSecs()+10000
					Auto\tCambiarCarril = MilliSecs()+10000
				End If
				
			Else
			
				;running check other cars in the way
				Radar(Auto)
				
				If (Auto\Situacion And 256)=0 Then
					;si fuera de la pista (out of the track)
					Auto\Force = Auto\Force * 0.98
					;brakes but do not stop
					If Auto\Force &lt; MaxSpeed/10 Then Auto\Force = MaxSpeed/10
				End If
				
				If Auto\Numero = 1 Then
					;the red one is controlled by keyboard/joypad
					If	keypad=1 Then
						ControlarAuto(Auto)	;manual
					Else
						ControlarAutoJoypad(Auto)
					EndIf
					
										;note switch required here to allow for joypad input
					
					
					
					
					
				Else	;si no es el auto 1
					;the rest will be handled by AI
					CarsAI(Auto,True, True, 10+auto\Vel*5 , 0.05)	;automático
				End If
			
			End If
			
		End If			
		
		SigPunto(Auto)	;evaluates if a car travel enough to route to the next step in the track
		
	Next

End Function


Function UpdateCars()
	
	;ask vip3r !!!
	
	
	Local Auto.Autito
	Local count, angle#, wheel_angle#, spin#
	
	For Auto.Autito = Each Autito
	
		For count=0 To 3
			
			dBodyEnable(Auto\Rueda[count]\Body)
			
			dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamVel2,Auto\Force)
			dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamFMax2,VelTorque)
			
			If count&lt;2 Then
				angle#=Auto\Steer - dJointGetHinge2Angle1(Auto\Rueda[count]\joint)
				dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamVel,angle)
				dJointSetHinge2Param(Auto\Rueda[count]\joint,dParamFMax,SteerTorque)
			End If
			
			If DirFric Then
				Local x_component#
				Local y_component#
				Local z_component#
								
				wheel_angle#=dGeomGetYaw(Auto\Rueda[count]\Geom)
				
				x_component#=Sin(wheel_angle#)*-1.0 
				y_component#=0.0
				z_component#=Sin(wheel_angle#+90.0)
				
				dGeomContactSetMu(Auto\Rueda[count]\Geom,100)		;tested from 50 to 2000
				dGeomContactSetMu2(Auto\Rueda[count]\Geom,10000)
								
				dGeomContactSetFDir1(Auto\Rueda[count]\Geom,x_component#,y_component#,z_component#)
				dGeomContactSetSlip1(Auto\Rueda[count]\Geom,0.001)
				
				spin#=dJointGetHinge2Angle2Rate(Auto\Rueda[count]\joint)
				
				;If Auto\Numero = 1 Then
				;	If count=1 Then
				;		If Spin &gt; MaxSpin Then
				;			MaxSpin = Spin
				;			MaxSpinVel = Auto\Vel	;just to know max spin: 40 RPS!
				;		End If
				;	End If
				;End If

				;knowing that spin may reach 40: 40/20,000 = 0.002 so Slip2 goes from 0.001 to 0.003 as a fn of spin
				dGeomContactSetSlip2(Auto\Rueda[count]\Geom,0.001+(Abs(spin#)/20000))
				
			End If
			
		Next
		
		dBodyEnable(Auto\Cuerpo\Body)
				
	Next
	
End Function


Function UpdateGeoms()
	Local ode.ODEGeom
	For ode.ODEGeom=Each ODEGeom
		RotateEntity ode\Mesh,dGeomGetPitch#(ode\Geom),dGeomGetYaw#(ode\Geom),dGeomGetRoll#(ode\Geom)
		PositionEntity ode\Mesh,dGeomGetPositionX#(ode\Geom),dGeomGetPositionY#(ode\Geom),dGeomGetPositionZ#(ode\Geom)
	Next
End Function

Function UpdateODE()
	dSpaceCollide(Space,World,ContactGroup)
	dWorldQuickStep(World,0.1)
	dJointGroupEmpty(ContactGroup)
End Function


Function Vistas()
	
	Local Auto.Autito, C.Cams
	Local dct#,cam_alt_max
	Local Ultima,Primera
	
	Auto.Autito = First Autito
	
	If MultipesCamaras Then
		Primera = 1
		Ultima = CarAmount
	Else
		Primera = 0
		Ultima = 0
	End If
	
	For C.Cams = Each Cams
	
		If (C\Numero&gt;=Primera) And (C\Numero &lt;= Ultima) Then
			
			PointEntity C\Camara,Auto\Cuerpo\Mesh
			
			dct# = EntityDistance(Auto\pivot,C\Camara)
			
			If dct# &gt; 1 Then
				MoveEntity C\Camara,-Auto\Steer*.01,Auto\vel*(.45-.01),Auto\vel*.85
			End If
			
			If dct# &gt; 15 Then
				MoveEntity C\Camara,0,0,dct-8	;15
			End If
			
			If dct# &lt; 11 Then
				MoveEntity C\Camara,0,0,dct-8	;11
			End If
			
			TurnEntity C\Camara,-15,0,-Auto\Steer
			
			cam_alt_max = 6
			
			If EntityY(C\Camara) &gt; EntityY(Auto\Cuerpo\Mesh)+cam_alt_max Then PositionEntity Camera,EntityX(C\Camara),EntityY(Auto\Cuerpo\Mesh)+cam_alt_max,EntityZ(C\Camara)
			
			If C\Numero &lt; Ultima Then Auto = After Auto
			
		End If
	Next
	
End Function


Function UpdateGame()	;50 times a second

	UpdateODE()
	
	UpdateGeoms()
	
	UpdateCars()
	
	ManejarAutos()
	
	UpdateKeys()

	Vistas()
	
End Function

Function UpdateInfo()	;as much as posible a second: same as render world

	If ShowHelp Then
	
		BarGraph(600)
		Color 255,255,255
		Text 10,660,"Arrows to drive red car"
		Text 10,680,"F1 Show car numbers on/off"
		Text 10,700,"F2 multiple cameras on/off, F3 Show map on/off"
		Text 10,720,"F4 this help on/off, F5 show DriveLine and lanes on/off"
		Text 10,740,"Track:"+TrackNumber+", Lenght: "+TrackLenght
	
	End If
	
	For Auto.Autito = Each Autito
	
		If Auto\Numero = 1 Then
			Color 255,0,0
		Else
			Color 255,255,255
		End If
		Rect 30,12+Auto\Numero*15,auto\vel*50,5,True
		Rect 30,10+Auto\Numero*15,100,9,False
		Text  5,10+Auto\Numero*15,Auto\Numero
		
		If MostrarNros Then
			If Not(MultipesCamaras) Then
				If Auto\Numero &gt; 1 Then
					CameraProject(Camera,EntityX(Auto\Cuerpo\Mesh),EntityY(Auto\Cuerpo\Mesh),EntityZ(Auto\Cuerpo\Mesh))
					Texto$ = Auto\Numero
					If ProjectedX()&gt;20 And ProjectedY()&gt;20 Then Text ProjectedX(),ProjectedY(),texto
				End If
			End If			
		End If
		
		If ShowMap Then
			CameraProject(MapCamera,EntityX(Auto\Cuerpo\Mesh),EntityY(Auto\Cuerpo\Mesh),EntityZ(Auto\Cuerpo\Mesh))
			If auto\numero&lt;5 Then
				;only show the numbers of the cars that has cameras
				Text ProjectedX()+GraphicsWidth()-160,ProjectedY(),Auto\Numero,True,True
			Else
				Text ProjectedX()+GraphicsWidth()-160,ProjectedY(),"*",True,True
			End If
		End If
		
	Next
End Function

Function CalculatedYaw()

	pNext.tSteps = First tSteps
	pNext = After PNext
	p.tSteps = First tSteps
	n=0
	dMax#=-90
	dMin#=+90
	Repeat
		p\dYaw = DeltaYaw(p\Entity,pNext\Entity)
		p\Number = n
		n=n+1
		If p\dYaw&lt;dMin Then dMin=p\dYaw
		If p\dYaw&gt;dMax Then dMax=p\dYaw
		p = After p
		pNext = After pNext
		If pNext = Null Then pNext = First tSteps
	Until p=Null
	DebugLog "Track  : "+TrackNumber
	DebugLog "Lenght : "+TrackLenght
	DebugLog "dYaw Max: "+dMax+", Min:"+dMin
	strTemp$=""
	For i=0 To 10
		 strTemp = strTemp + ", " + Str((1.0 - Float(i/12.0)))
	Next
	DebugLog "SpeedFactor for angles 0..10 : "+strTemp
	DebugLog ""
	
End Function


Function ClampValue#(value#, lo#, hi#)
	If value&lt;lo Then value=lo
	If value&gt;hi Then value=hi
	Return value
End Function

Function Distance3D#(obj1, obj2, g=True)
	Local x#, y#, z#
	x# = EntityX(obj1,g) - EntityX(obj2,g)
	y# = EntityY(obj1,g) - EntityY(obj2,g)
	z# = EntityZ(obj1,g) - EntityZ(obj2,g)
	Return Sqr(x*x + y*y + z*z)
End Function

Function Distance2D#(x1#, z1#, x2#, z2#)
	Local d#
	d = Sqr( (x1-x2)*(x1-x2) + (z1-z2)*(z1-z2) )
	Return d
End Function

Function Interpolate#(t#, v1#, v2#)	;t 0..1 entre v1 y v2
	Return v1 + (v2-v1)*t
End Function

Function InterpolatePos( t#, p1, p2, p3, p4, Dest)
	
	Local x1#, y1#, z1#, x2#, y2#, z2#, x3#, y3#, z3#, x4#, y4#, z4#, x#, y#, z#

	x1# = EntityX(p1,True)
	y1# = EntityY(p1,True)
	z1# = EntityZ(p1,True)
	
	x2# = EntityX(p2,True)
	y2# = EntityY(p2,True)
	z2# = EntityZ(p2,True)

	x3# = EntityX(p3,True)
	y3# = EntityY(p3,True)
	z3# = EntityZ(p3,True)
	
	x4# = EntityX(p4,True)
	y4# = EntityY(p4,True)
	z4# = EntityZ(p4,True)
	
	x# = x1 * (1-t)^3 + 3 * x2 * (1-t)^2 * t + 3 * x3 * (1-t) * t^2 + x4 * t^3 
	y# = y1 * (1-t)^3 + 3 * y2 * (1-t)^2 * t + 3 * y3 * (1-t) * t^2 + y4 * t^3 
	z# = z1 * (1-t)^3 + 3 * z2 * (1-t)^2 * t + 3 * z3 * (1-t) * t^2 + z4 * t^3 
	
	PositionEntity Dest, x, y, z, True

End Function



Function FreeStepsResources()
	Local p.tSteps
	For p = Each tSteps
		FreeEntity p\Entity
		FreeEntity p\Sector
	Next
	Delete Each tSteps
End Function

Function CreateSteps(tp.tTrackPoints, FirstNumber)
	
	Local k, nStep	;, Fraction#
	Local tpNext.tTrackPoints, p.tSteps

	k=0
	
	For nStep=1 To tp\nSteps
		
		tpNext.tTrackPoints = After tp
		If tpNext = Null Then tpNext = First tTrackPoints
	
		p.tSteps = New tSteps
		p\SectorNumber = tp\Number
		p\Entity = CreateCube()
		ScaleEntity p\Entity,.1,.3,.1
		EntityColor p\Entity,255,0,0	;little red dot that signals the drive line and who turn yelow when
										;a car is going to it.
		p\Number = FirstNumber + k
		
		p\Sector = CreateCube()
		EntityPickMode p\Sector,2		;i do a line pick to know if the car is on the track
		EntityColor(p\Sector,60,60,60)
		
		k=k+1
			
	Next
	
End Function


Function RelocateSteps()
	
	Local tp.tTrackPoints, tpNext.tTrackPoints
	Local p.tSteps, pNext.tSteps
	Local Fraction#, nStep
	
	tp.tTrackPoints = First tTrackPoints
	tpNext.tTrackPoints = After tp	;to interpolate we need 2 points and the 2 control points between them
									;: tp\Point, tp\cp1, tp\cp2 and tpNext\Point
	p.tSteps = First tSteps
	
	nStep = 0
	
	For p.tSteps = Each tSteps
		
		nStep = nStep + 1
		Fraction# = (1.0*(Float(nStep))) / (Float(tp\nSteps))
		InterpolatePos( Fraction, tp\Point, tp\cp1, tp\cp2, tpNext\Point, p\Entity)
				
		p\x = EntityX(p\Entity)
		p\y = EntityY(p\Entity)
		p\z = EntityZ(p\Entity)
		
		If nStep=tp\nSteps Then
			nStep = 0
			tp = After tp
			tpNext = After tpNext
			If tpNext = Null Then tpNext = First tTrackPoints
		End If
		
	Next
	
End Function


Function RedrawTrack()
	
	Local tp.tTrackPoints, tpNext.tTrackPoints
	Local p.tSteps, pNext.tSteps
	Local temp, Distance#, Fraction#, nStep
	Local xScale#, yScale#, zScale#

	tp.tTrackPoints = First tTrackPoints
	tpNext.tTrackPoints = After tp
	tp\Distance = 0
	
	p.tSteps = First tSteps
	pNext.tSteps = After p

	temp = CreatePivot()
	EntityParent temp,p\Entity,False	;temp stores the position of the first Step before repositioning
	EntityParent temp,0					;I use the original Interpolated (midle of the track) to calculate Distance
										;and to point to the next step on the track, but, I move the entity to
										;reflect the position of the DriveLine. The black track mus follow the original
										;positions.
	
	TrackLenght = 0
	nStep = 0

	For p.tSteps = Each tSteps
	
		;for each step in the track
		;Point to the next, calculate the inter steps distance
		nStep = nStep + 1
		
		If pNext=Null Then
			;if this is the last step, point to the saved step in Temp
			PointEntity p\Entity,temp
			Distance# = Distance2D(EntityX(p\Entity), EntityZ(p\Entity),EntityX(temp), EntityZ(temp))
		Else
			PointEntity p\Entity,pNext\Entity	;paso al siguiente, hago apuntar el punto del centro del tramo hacia el siguiente
			Distance# = Distance2D(EntityX(p\Entity), EntityZ(p\Entity),EntityX(pNext\Entity), EntityZ(pNext\Entity))
		End If
		
		;at this time the black track is made of Cubes scaled and oriented following the steps on the track
		;also, 3 points are of interest: one on the Suggested DriveLine, and 2 more one at each side of it.
		;so in the track there are 3 posible paths.
		;the default path is the drive line, the other 2 are used by the CarsAI that chooses to swithc path upon
		;the situation given. Whenever posible, the car will return to the drive line.
	
		p\dDist = Distance
		tp\Distance = tp\Distance + Distance	;acumulate sector lenght
		TrackLenght = TrackLenght + Distance	;acumulate track lenght
		
		xScale# = TrackWidth*1.4
		yScale# = .05
		zScale# = p\dDist/2
		
		ScaleEntity(p\Sector,xScale,yScale,zScale*1.4)
		PositionEntity(p\Sector,p\x,p\y,p\z)
		RotateEntity(p\Sector,0,EntityYaw(p\Entity),0)
		MoveEntity(p\Sector,0,0,zScale)
		
		;Drive Line
		Fraction# = Float(nStep)/Float(tp\nSteps)
		Desvio# = Interpolate(Fraction, tp\DriveLine, tpNext\DriveLine)*TrackWidth*0.8
		MoveEntity p\Entity, Desvio ,0,0
		
		
		;MaxNegDesvio#=TrackWidth
		;MaxPosDesvio#=TrackWidth

		MaxNegDesvio#=TrackWidth+Desvio	;left and right lanes must not be outside the track
		MaxPosDesvio#=TrackWidth-Desvio
		

		;left of the drive line
		;Piv1 = CreatePivot()
		Piv1 = CreateCube()
		EntityColor piv1,0,0,255
		EntityParent Piv1,p\Entity,False
		MoveEntity Piv1,ClampValue(-TrackWidth*8,-MaxNegDesvio*10,0),0,0	;take into account that the parent is scaled 0.1!

		;right of the drive line
		;Piv2 = CreatePivot()
		Piv2 = CreateCube()
		EntityColor piv2,0,255,255
		EntityParent Piv2,p\Entity,False
		MoveEntity Piv2,ClampValue(+TrackWidth*8,0,+MaxPosDesvio*10),0,0	;take into account that the parent is scaled 0.1!

		If nStep=tp\nSteps Then
			nStep = 0
			tp = After tp
			If tp&lt;&gt;Null Then tp\Distance=0
			tpNext = After tpNext
			If tpNext = Null Then tpNext = First tTrackPoints
		End If
		
		If pNext&lt;&gt;Null Then pNext = After pNext
	
	Next
		
	FreeEntity temp

End Function


Function CreateTrack()
	
	Local i, tp.tTrackPoints
		
	i=0
	
	For tp = Each tTrackPoints
		CreateSteps(tp,i)	;only creates the entities and objects
		i=i+tp\nSteps
	Next
	
	RelocateSteps()	;place each step entity
	RedrawTrack()	;orient and scale each entity, calculates distance between each step and track lenght
	
	CalculatedYaw()
	
End Function

Function CreateWP.tTrackPoints(piv, piv1, piv2, nSteps, DriveLine, Number)
	
	Local TrackPoint.tTrackPoints

	TrackPoint = New tTrackPoints
	TrackPoint\Number = Number
		
	TrackPoint\Point = CreateCylinder()
	EntityParent TrackPoint\Point,piv,False
	EntityParent TrackPoint\Point,0

	TrackPoint\cp1 = CreateCylinder()
	EntityParent TrackPoint\cp1,piv1,False
	EntityParent TrackPoint\cp1,0
	
	TrackPoint\cp2 = CreateCylinder()
	EntityParent TrackPoint\cp2,piv2,False
	EntityParent TrackPoint\cp2,0
		
	TrackPoint\nSteps = nSteps
	TrackPoint\DriveLine = DriveLine
	
	ScaleEntity TrackPoint\Point,.5,.2,.5
	EntityColor TrackPoint\Point,0,0,255
	
	EntityParent TrackPoint\cp1,TrackPoint\Point
	EntityParent TrackPoint\cp2,TrackPoint\Point
	
	HideEntity TrackPoint\cp1
	HideEntity TrackPoint\cp2
	
	Return  TrackPoint

End Function

Function CopyInt(Source,Destination,Count=1,Wr=True)
	Local i, temp
	For i=1 To Count
		temp = ReadInt(Source)
		If Wr Then WriteInt(Destination,temp)
	Next
End Function

Function CopyFloat(Source,Destination,Count=1,Wr=True)
	Local i, temp#
	For i=1 To Count
		temp# = ReadFloat(Source)
		If Wr Then WriteFloat(Destination,temp)
	Next
End Function

Function CopyPoint(Source,Destination,Wr=True)
	Local n,j
	n=ReadInt(Source)
	If Wr Then WriteInt(Destination,n)
	For j=0 To n-1
		CopyFloat(Source,Destination,9,Wr)
		CopyInt(Source,Destination,2,Wr)
		CopyFloat(Source,Destination,4,Wr)
	Next
End Function


Function LoadTrack(TrackNumber)
	
	Local TracksFile, piv, piv1, piv2, i
	Local x#, y#, z#, DriveLine, nSteps
	
	TracksFile = OpenFile("tracks.dat")
	
	If TrackNumber &gt; 1 Then
		For i=1 To TrackNumber-1
			CopyPoint(TracksFile,0,False)
		Next
	End If
		
	PointsCount = ReadInt(TracksFile)
	
	piv  = CreatePivot()
	piv1 = CreatePivot()
	piv2 = CreatePivot()
	
	For i = 0 To PointsCount-1
	
		
		x#=ReadFloat(TracksFile)
		y#=ReadFloat(TracksFile)
		z#=ReadFloat(TracksFile)
		PositionEntity piv,x,y,z
		
		x#=ReadFloat(TracksFile)
		y#=ReadFloat(TracksFile)
		z#=ReadFloat(TracksFile)
		PositionEntity piv1,x,y,z
		
		x#=ReadFloat(TracksFile)
		y#=ReadFloat(TracksFile)
		z#=ReadFloat(TracksFile)
		PositionEntity piv2,x,y,z
		
		nSteps = ReadInt(TracksFile)
		DriveLine = ReadInt(TracksFile)
		
		CreateWP(piv, piv1, piv2, nSteps, DriveLine, i)
	
		CopyFloat(TracksFile,0,4,False)
						
	Next
	
	FreeEntity piv
	FreeEntity piv1
	FreeEntity piv2
	
	CloseFile(TracksFile)
	
End Function

;FUNCTIONS TO READ JOYPAD

Function readconfig()
	filename = ReadFile ("joypad.cfg")
	If filename &lt;&gt; 0
		For port = 0 To 3
			tmp = ReadLine (filename) ; skip this line in the file
			j(port)\x1id = ReadLine (filename)
			j(port)\y1id = ReadLine (filename)
			j(port)\x2id  = ReadLine (filename)
			j(port)\y2id = ReadLine (filename)
			j(port)\x1invert = ReadLine (filename)
			j(port)\y1invert = ReadLine (filename)
			j(port)\x2invert = ReadLine (filename)
			j(port)\y2invert = ReadLine (filename)
		Next 
		CloseFile (filename)
		info$ = "config file opened"
	Else
		info$ = "load failed, or no .cfg file present"
	EndIf 
End Function

Function MapAxis#( axis, invert )
	Select axis
		Case 1
			joy#=JoyX(Controller_port)
		Case 2
			joy#=JoyY(Controller_port)
		Case 3
			joy#=JoyZ(Controller_port)
		Case 4
			joy#=JoyPitch(Controller_port)/180
		Case 5
			joy#=JoyRoll(Controller_port)/180
		Case 6
			joy#=JoyYaw(Controller_port)/180
		Case 7
			joy#=JoyU(Controller_port)
		Case 8
			joy#=JoyV(Controller_port)
	End Select
	Return (joy# * invert)
End Function

;END FUNCTIONS TO READ JOYPAD

;typical joypad.cfg file contenst, remove 1st column of semi colons:-
;
;; Joypad port 0
;1
;2
;3
;5
;1
;1
;1
;1
;; Joypad port 1
;0
;0
;0
;0
;1
;1
;1
;1
;; Joypad port 2
;0
;0
;0
;0
;1
;1
;1
;1
;; Joypad port 3
;0
;0
;0
;0
;1
;1
;1
;1

;;; end typical joypad.cfg file

</textarea> <br><br></td></tr></table><br>
<a name="1025809"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> thx for the update, i haven't one, but, when i grow probably buy one!<br><br>Juan<br><br>(there is still to much to do with the cars ai source... it has some goods and some bads) <br><br></td></tr></table><br>
<a name="1025942"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>but, when i grow probably buy one!<br> <br></div><br><br>What are you, a tomato! :D<br><br>Seriously though, nice work, and a very generous share for the community me thinks! ;)<br><br>Dabz <br><br></td></tr></table><br>
<a name="1026452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Charrua, would you mind telling me which version of B3D you are using ? The only reason is I could not compile your track source code until I commented out ParentEntity:<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=90321#1026451" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=90321#1026451</a><br><br>Regards - BP. <br><br></td></tr></table><br>
<a name="1026494"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi, i'm using 1.98<br><br>as yasha said is part of FastExtension, and i didn't know it!<br><br>the idea is that if you Picked a ControlPoint you have it's entitys handle via PickedEntity(), then, as control points has as parent the tTrackPoint\Entity then using ParentEntity we have the parent handle and look for the tTrackObject where control point belongs, any way GetTrackPoint do a search so, modify GetTrackPoint to search either for a match either Entity or cp1. GetTrackPoint must return the tTrackPoint object that the WayPoint or ControlPoint belongs:<br><br><pre class=code>
Function GetTrackPoint.tTrackPoints(Entity)
	Local tp.tTrackPoints
	For tp.tTrackPoints = Each tTrackPoints
		If (tp\Entity = entity) or (tp\cp1 = entity) Then Return tp
	Next
	Return Null
End Function
</pre><br><br>change the line that uses ParentEntity to:<br><br><pre class=code>
If GetTrackPointNumber(Picked)&lt;&gt;-1 Then
	AdjustNeighborsCp(GetTrackPoint(Picked))
Else
	;AdjustCP(GetTrackPoint(ParentEntity(Picked)))
	AdjustCP(GetTrackPoint(Picked))
End If
</pre><br><br><br>Juan <br><br></td></tr></table><br>
<a name="1026548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Juan, I appreciate the description of why as well.<br><br>I am considering the possibility of super imposing the track editor on top of some 3D scenery, I'll confess and admit I have not analysed the code enough to know if this is possible, but I'll let you know how I fair. <br><br></td></tr></table><br>
<a name="1026567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> the waypoints are 3D but only 2d in my app. <br><br>The bezier interpolate is 3d too, but the Grey Cubes (tSteps\Sector) are only rotated in the Y axis.<br><br>See the RedrawTrack, the sentence: RotateEntity(p\Sector,0,EntityYaw(p\Entity),0) do only Y alignement, probably but not tested, if you introduce EntityPitch and EntityRoll the Sectors follow the 3d bezier interpolation.<br><br>i have no idea on how you will match your scenary with a series of waypoints that folow certain interpolation, say, if you scenary didn't follow the same interpolation they will be missplaced. Hope you understand what is in my mind. My english is very poor to express my self. sorry<br><br>Juan <br><br></td></tr></table><br>
<a name="1142591"></a>

<a name="1142592"></a>

<a name="1142593"></a>

<a name="1142594"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Charrua, have managed to get back to this (wow, its been 2 years already) - having some fun with your bezier interpolate code - the 'jist' of it is creating waypoints for some 'runners' to follow - the speed of the runners between each waypoint will be modified on a waypoint by waypoint basis.<br><br>The data for the waypoints &amp; the speed will be gathered by a Global Positioning Satellite training device, the goal being a runner can compare his runs in 'realtime' after the events seeing where and how far appart he managed to perform in different training runs.<br><br>[Edit] - I have FastEntity now as well....<br><br>Cheers - BP.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1142621"></a>

<a name="1142623"></a>

<a name="1142624"></a>

<a name="1142628"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting demo :)<br><br><br><br><div class="quote"> <br>What's more 'interesting', perhaps, is dealing with more specific AI instances with regards to how the cars deal with racing. For example, how do they deal with overtaking, or when needing to decelerate for turns etc.<br>I don't have any specific suggestions for this, but definitely worth consideration.<br><br>Lastly, with all that taken into account, the general 'problem' would be that all the AI cars behave in a very similar way. This is something that I personally feel is a little 'outdated' when it comes to racing games, and that AI cars (drivers) ought to have more distinct 'personalities'.<br> <br></div><br><br>I have thought about that and i have found a possible solution.<br>It uses a mix of AI and pre recorded path with waypoints.<br><br>Let me explain the theory : <br>first, i play on the track several times, and my program records the waypoints and my time.<br>In each replay data there are waypoints data, and time data.<br><br>With this, when i play with others vehicles, the program selects some of the replays datas and use it to create the others vehicles pre recorded paths.<br><br>When a vehicle is in collision with an other vehicle, the vehicle goes into AI mode and behave in certain ways in order to avoid the others vehicles, then it goes towards the nearest waypoint there is and follows  the precalculated path.<br><br>The advantages of such a system is that the AI will always appear random and will sometimes be smart and sometimes do errors. And they will have a human behavior.<br><br>Also the combination of different precalculated paths can provoke interesting behaviors when 2 vehicles come into collision.<br><br>The hardest part will be to program the AI just after the collision. <br><br>What do you think ?<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1142673"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> @bp<br>yep lot of time, currently i haven't had time to play with blitz and/or ode (too much work :) <br><br>@RemiD<br>isn't a bad idea. but (always a but) i think that ai must be used for cars to evade collisions (normally is one of the goals not to suicide)<br>When you say: prerecorded you mean a car moved by blitz and not by the physics engine?<br><br><br>There are many aproaches (as always) one could be that cars could be managed by blitz most of the time and in case of collisions then jv_ode do it's job to reach a more realistic behavior. Say not a 100% physics simulaton (like the code i posted), instead a balance between physics simulation  and some mixture of blitz managed, physics when needed, pre recorded paths and AI.<br><br><br>Juan <br><br></td></tr></table><br>
<a name="1142682"></a>

<a name="1142684"></a>

<a name="1142685"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Charrua&gt;&gt;<br>Yes there are 2 modes :<br>When there is no collision, the first mode is used, a kind of replay of a prerecorded path without physics and without ai.<br>After a collision, the second mode is used and the ai tries to recover from the collision or tries to damage the other vehicle.<br>Then after a while, the vehicle searches and goes towards the nearest waypoint of the pre recorded path and follows the path again.<br><br>Also what is good with this system is that you can record each path of a user when he plays and add it to the pre recorded paths for this specific circuit.<br><br>I would keep only the paths where the user does not leave the road and a mix of bad times and good times so that there are bad npcs and good npcs.<br><br>Depending on the kind of gameplay you want, you can use the same concepts to trigger a specific behavior of a npc.<br><br>For example let's say you do a racing game where the vehicles want to avoid collisions, then you can check the distance between each vehicle and each others vehicle and if a vehicle is too close, then you can trigger a behavior to avoid the collision by making the vehicle turn at the oposite of the other vehicle during the time the other vehicle is far enough. Then the vehicle can follow its path again.<br><br>At the contrary if you do a racing game where the vehicles want to provoke collisions, if a vehicle is too close, you can make the vehicle brake or turn right or turn left so that it annoys the other vehicle, then when the other vehicle is far enough, the vehicle can follow its path again.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1142720"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Charrua, yeah my time is somewhat tight as well, i aim to get there in the end! <br><br></td></tr></table><br>
<a name="1142898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Slomas</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Juan,<br><br>I wrestled with racecar AI a while ago and ended up giving up on waypoints for something which worked better- for me anyway<br><br>That is to approach it as a driver would- 'looking' at the actual track ahead.<br>Two 'feelers' or 'eyes' are parented to the car- sent ahead a distance relative to the car's speed- and left &amp; right to find the track edge (using LinePick from the eye/cube objects in the air in this pic)<br><br>This returns upcoming direction &amp; rate of turn, track tilt, rise/fall, width etc..  i.e. the track edges themselves represent continuous waypoints -<br>the nice thing is- there doesn't have to be any standard width etc to conform to- the AI will work with whatever it sees. <br><br>Allowing the AI car to experiment with its own parameters for controlling and responding to it's 'eyes' for the fasted time- lets it find the best technique for the track<br><br>I think Vorderman made a more complete version of this stunt car game-<br>he'd be a good person to ask?<br><br><br><img src="http://www.planillustrator.com/shot1.jpg"> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
