<!DOCTYPE html><html lang="en" ><head ><title >Cel-shading - Best Method For Outlines?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Cel-shading - Best Method For Outlines?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Cel-shading - Best Method For Outlines?</a><br><br>
<a name="572186"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, so I'm really new to cel-shading and I'd like some opinions.<br><br>I pretty much understand the 'inverted mesh' technique that people seem to have been using in blitz. It's neat and simple, but isn't there a danger of running up huge triangle counts?<br><br>Anyway, doing a bit of research, I've noticed that it's more traditional to use a line drawing technique that draws lines along edges that have a front facing and back facing triangle. <br><br>I realise that this technique would be more complex in terms of the code required (I'd have to collect and store all the edge-triangle information for a start, plus use a function to figure out which way a triangle is facing, vector math etc...) and also I am cautious that there may be limitations involved with doing this in Blitz. (E.g because you have draw the lines after all other rendering, you need to work out when not to draw them - if for example the object is behind something else)<br><br>So, basically my main question: <br><br>Is there anyone out there that would argue in favour of the traditional line-drawing method, and can give some tips for overcoming potential barriers such as the example mentioned, or should I just stick to the inverted mesh method?<br><br><br>Please no discussion on cel-shaded lighting for the moment, as I'm not quite ready to get into all that yet!  :O) <br><br></td></tr></table><br>
<a name="572193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Personally I like the sphere map method. Very fast, very simple. You just need a sphere map which has a black hollow circle filling the texture. I guess shade the inner circle with three or four shades of white and that would be a nice effect. It's not perfect but without pixel shaders nothing is.<br><br>IIRC, the best cel-shaded effect I ever saw was done by Mearrin, but I haven't seen him around in ages, and Blitzcoder, where he posted the pics, is gone now. <br><br></td></tr></table><br>
<a name="572201"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> How do you apply the sphere map? Is it a lighting effect where you use a vector with the vertex normals to work out all the vertex UVs?  That's just the sort of thing I didn't want to get into at this stage. <br><br></td></tr></table><br>
<a name="572232"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Raitsun</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> with thexture-flag 64 :] <br><br></td></tr></table><br>
<a name="572233"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, you literally just apply a texture with flag 64. The second texture channel should do it. ( Channel one, if zero is the first. ) <br><br></td></tr></table><br>
<a name="572236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, now I understand. . .   it's a simple texture mapping (well, simple from the blitz code end, probably complex in the underlying way it's actually applied)    <br><br>It sounds cool and simple, and I might use it for the directional light shading, but. . .  it has nothing to do with creating outlines!<br><br>Now, can we have some discussion on the topic I initially <b>outlined</b> please? :O) <br><br></td></tr></table><br>
<a name="572245"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Now, can we have some discussion on the topic I initially outlined please? :O)  <br></div><br><br>Well if you're gonna get snotty, I won't tell you that what I just suggested takes care of the outline as well as the directional light shading ;o) <br><br></td></tr></table><br>
<a name="572275"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sybix:<br>An edge outline created with a sphere map can get stretched out quite a bit and won't really look very good.<br><br>Also a sphere map is only good for very limited uses.  Unless the light is directly overhead you can never move the camera, and if it is directly overhead you can't tilt the camera only rotate around the object.  Otherwise the light appears to move.  You need to make a cube map so the light stays in a fixed location regardless of how the camera is moved.<br><br>As for outlines, forget trying to make a mesh to represent 2D lines in realtime as the mesh changes.  Drawing lines in 2d though... can't really say if that would be fast enough.  Probably depends on the resolution and how many objects with lines there are in the scene.  I can almost guarantee you though that for complicated scenes the inverted mesh will work best in the general case, and particularly on high end cards in high resolutions. <br><br></td></tr></table><br>
<a name="572285"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no way that drawing lines would be quick enough.  Trust me.  Stick with inverted-black-mesh method. <br><br></td></tr></table><br>
<a name="572313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've just been playing around with the idea of drawing lines. . .    <br><br>So far I've just been drawing all edges on front facing triangles and so haven't needed to compile the list of edges etc.   There does seem to be a perfomance hit, but only when you start drawing more than a few hundred lines.  <br><br>It seems that the number of lines actually drawn is the main factor on performance, not the size of the mesh you perform the operation to (commenting out the Line statements proves this)<br><br>Here's the code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800, 600


Global mshSphere% = CreateSphere(12)
UpdateNormals mshSphere
EntityFX mshSphere, 4


Global GlobalLight% = CreateLight()
RotateEntity GlobalLight, 45, 45, 45
Global GlobalCamera% = CreateCamera()

PositionEntity GlobalCamera, 4, 2, 4
PointEntity GlobalCamera, mshSphere

CameraClsColor GlobalCamera, 180,180,180

Local fps%
Local fpscount%
Local millistop%
Local millis%

While Not KeyHit(1)
	Navigate_World_With_MouseAndKeys(0.5, 0.1)
	
	TurnEntity mshSphere, 0, 0.5, 0
	SetBuffer BackBuffer()
	Cls
	
	RenderWorld()
	DrawFrontFacingLines(mshSphere, GlobalCamera, 0, 0)
	Color 255, 0, 0
	Text 1, 1, "FPS=" + fps	
	Text 1, 12, "TrisRendered=" + TrisRendered()	
	
	Flip
	
	fpscount = fpscount + 1
	millis% = MilliSecs()
	If millistop &lt; millis - 1000 Then
		millistop = millis
		fps = fpscount
		fpscount = 0
	End If
Wend
End


Function DrawFrontFacingLines(m%, cam, thick%, sketchy#)
	Color 30, 30, 50
	
	Local v3X = CreateVector(3)
	Local v3Y = CreateVector(3)		
	For is% = 1 To CountSurfaces(m)
		s% = GetSurface(m, is)
		For it% = 0 To CountTriangles(s) - 1
			If FrontFacing(cam, s, it, m) Then
				For i% = 0 To 2
					vx# = VertexX(s, TriangleVertex(s, it, i))
					vy# = VertexY(s, TriangleVertex(s, it, i))
					vz# = VertexZ(s, TriangleVertex(s, it, i))
					TFormPoint vx, vy, vz, m, 0
					vx = TFormedX()
					vy = TFormedY()
					vz = TFormedZ()
											
					CameraProject(cam, vx, vy, vz)
					VctPut v3X, i, ProjectedX()
					VctPut v3Y, i, ProjectedY()
				Next
				
				c0 = (VctGet(v3X,0)=0) And (VctGet(v3Y,0)=0)
				c1 = (VctGet(v3X,1)=0) And (VctGet(v3Y,1)=0)
				c2 = (VctGet(v3X,2)=0) And (VctGet(v3Y,2)=0)
				For n% = -thick To thick
					r# = sketchy
					If Not (c0 Or c1) Then Line VctGet(v3X,0)+n+Rnd(-r, r), VctGet(v3Y,0)+Rnd(-r, r), VctGet(v3X,1)+Rnd(-r, r), VctGet(v3Y,1)+Rnd(-r, r)
					If Not (c1 Or c2) Then Line VctGet(v3X,1)+n+Rnd(-r, r), VctGet(v3Y,1)+Rnd(-r, r), VctGet(v3X,2)+n+Rnd(-r, r), VctGet(v3Y,2)+Rnd(-r, r)
					If Not (c0 Or c2) Then Line VctGet(v3X,0)+n+Rnd(-r, r), VctGet(v3Y,0)+Rnd(-r, r), VctGet(v3X,2)+n+Rnd(-r, r), VctGet(v3Y,2)+Rnd(-r, r)
				Next

			End If
		Next
	Next
	DeleteVector v3X
	DeleteVector v3Y
End Function



Function Navigate_World_With_MouseAndKeys(turnSpeed#=1, moveSpeed#=1)
	Local dY# = EntityPitch(GlobalCamera)+MouseYSpeed()/2*turnSpeed
	If dY &gt; 89 Then dY = 89
	If dY &lt; -89 Then dY = -89
	
	Local dz# = (KeyDown(200)-KeyDown(208)) * moveSpeed
	Local dx# = (KeyDown(205)-KeyDown(203)) * moveSpeed
	If dz &lt;&gt; 0 And dx &lt;&gt; 0 Then 
		dx=dx * 0.707
		dz=dz * 0.707
	End If
	RotateEntity GlobalCamera, dY, EntityYaw(GlobalCamera)-(MouseXSpeed()/2)*turnSpeed, 0
	MoveEntity GlobalCamera, dx, 0, dz
	MoveMouse GraphicsWidth()/2, GraphicsHeight()/2
	
	If KeyHit(4) Then 
		CameraZoom GlobalCamera, 4.0
	End If
	If KeyHit(5) Then
		CameraZoom GlobalCamera, 1.0
	End If
End Function



Function FrontFacing%(cam%, s%, t%, m%)	
	Local v1 = CreateVector(3)
	Local v2 = CreateVector(3)
	Local v3 = CreateVector(3)
	
	
	x# = VertexX(s, TriangleVertex(s, t, 0))
	y# = VertexY(s, TriangleVertex(s, t, 0))
	z# = VertexZ(s, TriangleVertex(s, t, 0))
	TFormPoint x, y, z, m, cam
	VctPut v1, 0, TFormedX()
	VctPut v1, 1, TFormedY()
	VctPut v1, 2, TFormedZ()
	
	x# = VertexX(s, TriangleVertex(s, t, 1))
	y# = VertexY(s, TriangleVertex(s, t, 1))
	z# = VertexZ(s, TriangleVertex(s, t, 1))
	TFormPoint x, y, z, m, cam
	VctPut v2, 0, TFormedX()
	VctPut v2, 1, TFormedY()
	VctPut v2, 2, TFormedZ()
	
	x# = VertexX(s, TriangleVertex(s, t, 2))
	y# = VertexY(s, TriangleVertex(s, t, 2))
	z# = VertexZ(s, TriangleVertex(s, t, 2))
	TFormPoint x, y, z, m, cam
	VctPut v3, 0, TFormedX()
	VctPut v3, 1, TFormedY()
	VctPut v3, 2, TFormedZ()
	
	
	Local vEdge1 = V3dSubtract(v3, v1)
	Local vEdge2 = V3dSubtract(v3, v2)
	
	Local vFNormal = V3dCross(vEdge1, vEdge2)
	
	Local bFrontFacing% = (V3dDot(v1, vFNormal) &lt; 0)
	
	DeleteVector v1
	DeleteVector v2
	DeleteVector v3
	DeleteVector vEdge1
	DeleteVector vEdge2
	DeleteVector vFNormal
	
	Return bFrontFacing
End Function



Function V3dAdd(v1, v2)
	Local v3 = CreateVector(3)
	
	VctPut v3, 0, VctGet(v1,0) + VctGet(v2,0)
	VctPut v3, 1, VctGet(v1,1) + VctGet(v2,1)
	VctPut v3, 2, VctGet(v1,2) + VctGet(v2,2)
	
	Return v3
End Function


Function V3dSubtract(v1, v2)
	Local v3 = CreateVector(3)
	
	VctPut v3, 0, VctGet(v1,0) - VctGet(v2,0)
	VctPut v3, 1, VctGet(v1,1) - VctGet(v2,1)
	VctPut v3, 2, VctGet(v1,2) - VctGet(v2,2)
	
	Return v3
End Function


Function V3dCross(v1, v2)
	Local v3 = CreateVector(3)
	
	VctPut v3, 0, VctGet(v1,1)*VctGet(v2,2) - VctGet(v1,2)*VctGet(v2,1)
	VctPut v3, 1, VctGet(v1,2)*VctGet(v2,0) - VctGet(v1,0)*VctGet(v2,2)
	VctPut v3, 2, VctGet(v1,0)*VctGet(v2,1) - VctGet(v1,1)*VctGet(v2,0)
	
	Return v3
End Function


Function V3dDot#(v1, v2)
	Return VctGet(v1,0)*VctGet(v2,0) + VctGet(v1,1)*VctGet(v2,1) + VctGet(v1,2)*VctGet(v2,2)
End Function



Function VctGet#(v, i%)
	Return PeekFloat(v, i Shl 2)
End Function




Function VctPut(v, i%, val#)
	PokeFloat v, i Shl 2, val
End Function


Function CreateVector(nDim%)
	v% = CreateBank(nDim Shl 2)
	Return v
End Function


Function DeleteVector(v)
	FreeBank v
End Function

</textarea><br><br><br><div class="quote"> <br> There is no way that drawing lines would be quick enough.  <br></div><br><br>Yup, I think after experimenting I'm inclined to agree. However, I think that some more interesting effects might be achievable with line drawing. . .  for example, try modifying the code above to pass in a value of 1 or 2 to the sketchy parameter in the DrawFrontFacingLines function to see what I mean. . .<br><br><br>So far I'm still not sure which way is best, but I'm starting to see the pros and cons of each.  Also, I still have no idea how to solve the problem of deciding whether or not to draw lines based on whether an edge is hidden behind something or not.<br><br>Thanks people. . .   keep the ideas coming :O) <br><br></td></tr></table><br>
<a name="572321"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ooh. I just noticed that my FPS sometimes keeps going up and down in a cycle as the sphere turns.    I am clueless as to why this happens. . .  does this happen for anyone else with the above code?<br><br>Anyone got any idea why this would happen??? <br><br></td></tr></table><br>
<a name="572323"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also, just noticed that the length of the lines has a major effect on performance (move closer and the FPS goes down)<br><br> I guess that means that it's just down to the number of pixels that have to be written to the screen that causes the performance limit. . . <br><br></td></tr></table><br>
<a name="572324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  I just noticed that my FPS sometimes keeps going up and down in a cycle as the sphere turns. I am clueless as to why this happens  <br></div><br><div class="quote"> length of the lines has a major effect on performance<br> <br></div><br><br>I think I just answered my own question! :O) <br><br></td></tr></table><br>
<a name="572417"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> The major performance is the drawing the with your example above.  This is because, a) you are drawing lots of lines :D and b) you aren't doing much calculation.<br><br>If this were a true algorithm for edge detection it would be very slow (probably slower) but mostly cos of the maths involved. <br><br></td></tr></table><br>
<a name="572432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> true algorithm for edge detection  <br></div><br>Yes, I wouldn't be doing a full-edge detection because that would be silly . .  it normally takes at least couple of seconds to apply such a filter to a desktop sized image, because it's a raster effect and has to be applied to ALL pixels on screen. I'm dealing with vectors and line drawing, not raster filters here. . .<br><br>I don't think that I'll be doing much more calculation when I add the part that checks for edges with a front facing + back facing triangle next to it, at least not enough more for it to have a major perfomance hit.<br><br>I do however think that any attempt to 'cull' the line drawing based on whether a line is behind an object or not might be heavy on the calculations.<br><br>Hmmm.  Here's a thought - perhaps I could combine a raster-edge detection with the line drawing method: Use the line technique to decide where on screen to apply the edge detection.   That way the edge-detection is only applied to a small portion of the screen...  it would solve the lines behind an object problem completely!<br><br>I bet it would be really slow, but I think its probably going to be a fun experiment. . . :O) <br><br></td></tr></table><br>
<a name="572434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would leave the Line command well alone as it's very slow, relatively speaking.<br><br>However, if you're determined to use real lines, you could try using 3D lines. Here's a function for 3D lines:<br><pre class=code>
;
; Adds a 3D line to the specified mesh.
; Note: 3D lines are only properly visible when rendered in wireframe mode!
; 
; Params:
; mesh     - Mesh to add 3D line to. If 0, a new mesh is created.
; x0,y0,z0 - Start point of line.
; x1,y2,z1 - End point of line.
; r,g,b    - Line colour.
;
; Returns:
; Handle of mesh the 3D line was added to.
;
Function create_3D_line(mesh,x0#,y0#,z0#,x1#,y1#,z1#,r%=255,g%=255,b%=255) 

	If mesh = 0 
		mesh = CreateMesh() 
		surf = CreateSurface(mesh) 
		EntityFX mesh,1+2+16
	Else 
		last_surf = CountSurfaces(mesh)
		surf = GetSurface(mesh,last_surf)
		If CountVertices(surf) &gt; 30000 Then surf = CreateSurface(mesh)
	End If 

	v0 = AddVertex(surf,x0,y0,z0) 
	v1 = AddVertex(surf,x1,y1,z1)  
	v2 = AddVertex(surf,x0,y0,z0)  
	AddTriangle surf,v0,v1,v2
	
	VertexColor surf,v0,r,g,b
	VertexColor surf,v1,r,g,b
	VertexColor surf,v2,r,g,b

	Return mesh 

End Function
</pre><br><br>Using this method you have to do 2 renders: one normal render then one render in WireFrame mode to display the 3D line mesh. I've used this technique in the past and it's pretty fast. <br><br></td></tr></table><br>
<a name="572436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> you could try using 3D lines <br></div><br><br>Yep, this would be ideal.<br>The only problem is, as you say I have to do 2 renders, and there would be no easy way to 'choose' which lines to draw (eg don't draw ones behind objects and only ones that are along front+back facing triangles).<br><br>This sort of thing is fine in C++ or whatever because we have access to the directx functions and can render whatever, whenever we chose.  But we only get limited options with this kind of thing in Blitz because it's all done for us. . .<br><br>Please, someone -  tell me I'm wrong because I would love to make this as easy and fast as possible :O) <br><br></td></tr></table><br>
<a name="572443"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> This sort of thing is fine in C++ or whatever because we have access to the directx functions and can render whatever, whenever we chose. But we only get limited options with this kind of thing in Blitz because it's all done for us. . . <br></div>Not sure what you mean by that - can you explain a bit more?<br><br>We can render what we want, when we want in Blitz3D too, can't we?<br><br>Don't be put off by doing multiple renders. Many people use this technique for various effects. By only showing stuff you want in a particular render, and hiding everything else, it's not going to be much (if any) slower than rendering everything in one go.<br><br>As for determining which lines need drawing, I think this is going to involve some pretty heavy math whichever way you look at it. That's why the folks above have been advocating the spheremap method. :) <br><br></td></tr></table><br>
<a name="572448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Isn't it possible with directx to choose to only draw specific triangles, or edges?  I've hardly used c++ with directx before, but that was the kind of impression I was getting when I was reading up on these cel shading techniques. . .<br><br>Also, hiding and showing entities, is pretty tedious code wise. . .   I wish I could just have the option of Render this, or render that :O) <br><br></td></tr></table><br>
<a name="572491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> You misunderstand me.  I wasn't talking about raster edge detection.<br><br>Actually I think I misunderstood your code, I didn't actually look to see if it were doing some edge detection, and thinking about it you can draw millions of lines with little slowdown in Blitz.  So, the biggest bottleneck is already the maths. <br><br></td></tr></table><br>
<a name="572494"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's not what I'm finding. . .  the maths is fast. It's the Line function that's using up all the time. . .<br><br>Is there a faster way of drawing 2d lines that I'm unaware of? <br><br>Perhaps I could lock the buffer and draw all of the lines using fast pixel writing before unlocking it again.  Would this be faster than repeatingly calling the Line function? <br><br></td></tr></table><br>
<a name="572508"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can try cacheing the line data. And then drawing them all inside a Locked/UnLockBuffer() setup.<br><br>Not sure if that will help cos of the extra overhead of cacheing the data.<br><br>I also noticed you are drawing too many lines.  Change this function below (notice I commented out one line):<br><pre class=code>Function DrawFrontFacingLines(m%, cam, thick%, sketchy#)
	Color 30, 30, 50
	
	Local v3X = CreateVector(3)
	Local v3Y = CreateVector(3)		
	For is% = 1 To CountSurfaces(m)
		s% = GetSurface(m, is)
		For it% = 0 To CountTriangles(s) - 1
			If FrontFacing(cam, s, it, m) Then
				For i% = 0 To 2
					vx# = VertexX(s, TriangleVertex(s, it, i))
					vy# = VertexY(s, TriangleVertex(s, it, i))
					vz# = VertexZ(s, TriangleVertex(s, it, i))
					TFormPoint vx, vy, vz, m, 0
					vx = TFormedX()
					vy = TFormedY()
					vz = TFormedZ()
											
					CameraProject(cam, vx, vy, vz)
					VctPut v3X, i, ProjectedX()
					VctPut v3Y, i, ProjectedY()
				Next
				
				c0 = (VctGet(v3X,0)=0) And (VctGet(v3Y,0)=0)
				c1 = (VctGet(v3X,1)=0) And (VctGet(v3Y,1)=0)
				c2 = (VctGet(v3X,2)=0) And (VctGet(v3Y,2)=0)
				For n% = -thick To thick
					r# = sketchy
					If Not (c0 Or c1) Then Line VctGet(v3X,0)+n+Rnd(-r, r), VctGet(v3Y,0)+Rnd(-r, r), VctGet(v3X,1)+Rnd(-r, r), VctGet(v3Y,1)+Rnd(-r, r)
					If Not (c1 Or c2) Then Line VctGet(v3X,1)+n+Rnd(-r, r), VctGet(v3Y,1)+Rnd(-r, r), VctGet(v3X,2)+n+Rnd(-r, r), VctGet(v3Y,2)+Rnd(-r, r)
;					If Not (c0 Or c2) Then Line VctGet(v3X,0)+n+Rnd(-r, r), VctGet(v3Y,0)+Rnd(-r, r), VctGet(v3X,2)+n+Rnd(-r, r), VctGet(v3Y,2)+Rnd(-r, r)
				Next

			End If
		Next
	Next
	DeleteVector v3X
	DeleteVector v3Y
End Function</pre> <br><br></td></tr></table><br>
<a name="572515"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why did you remove that line?  I have to draw 3 lines - a triangle has 3 lines. . . <i>doesn't it?</i><br><br>I'm confused??? :O)<br><br><br>Also, remember that when I add the filtering part that only draws lines on edges that have a front facing and back facing triangle, there will be only a fraction of the lines drawn.<br><br><div class="quote"> You can try cacheing the line data <br></div><br><br>I wouldn't have to - I could lock the buffer at the start of the whole function and not unlock until the end.  The lines would still be drawn on the fly. . .<br><br>. . .  or wait, does locking the buffer mean you can't use any Blitz3d commands such as CameraProject etc?  <br>I thought it was just rendering commands (i.e ones that write or read pixel values to graphics buffers) that are affected. I think I'll ask this in a new post actually. . . <br><br></td></tr></table><br>
<a name="572544"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I removed a line cos if you draw 3 lines for every triangle, you will be drawing each line twice.  Think about it, or even better just try it. <br><br></td></tr></table><br>
<a name="572549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> No, I still don't get you. . .<br>Unfortunately I can't try it until tonight, cos I don't have access to Blitz Basic right now.<br><br>I still think you are wrong though - when I draw a triangle on paper there are most definitely 3 lines to draw.  And logically, if you have 3 vertices v0, v1 and v2 then you have these 3 different lines to draw:<br>1) v0 to v1<br>2) v1 to v2<br>3) v0 to v2<br><br>The line you removed was v0-v2, for some reason. . .? <br><br></td></tr></table><br>
<a name="572550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, now wait a second. . .   I see what you mean. duh!<br>I wasn't thinking of triangles joined together. . .<br><br>You win! :O)<br><br>Actually, this will all be taken in to control when I build in the edge data - I will make sure each edge is listed once and only once, with the 2 triangles linked by reference.  I'll probably use some kind of array:<br>   edgeTriangle(v1, v2, triangle)<br>where triangle can be 0 or 1, and the size of dimensions v1 and v2 total the number of vertices in the mesh.<br><br>Actually this might be dumb because most of the array won't be used and I certainly won't want to loop through all of it. . .  I'll figure something out, perhaps another Bank :O) <br><br></td></tr></table><br>
<a name="572665"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Is there anyone out there that would argue in favour of the traditional line-drawing method, and can give some tips for overcoming potential barriers such as the example mentioned, or should I just stick to the inverted mesh method?<br> <br></div><br><br>Stick to the inverted mesh method with spherical mapping of a gradient texture... much faster , easy to implement etc...  The method you're attempting is going to be far too slow to be practical in a game ( especially the occlusion part ) .... but I guess you're realising this now? <br><br></td></tr></table><br>
<a name="572713"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep. I'm realising this, but I'm still going to try out my outline-limited edge detection idea, just because it would be fun and might look cool - even if it only renders 3 frames per second :O) <br><br></td></tr></table><br>
<a name="572781"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> This has been researched to death in Blitz. For outlines, you want the inverted mesh approach. <br><br></td></tr></table><br>
<a name="572786"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JustLuke</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Trouble is, the inverted mesh approach looks horrible. <br><br></td></tr></table><br>
<a name="572808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree that the inverted mesh method doesn't always look good but alot of that depends on how the mesh is created in the first place.  Convex shapes with no overlapping polys will give you good results.  <br><br>If the method you're going to use involved drawing lines over the top of the mesh ... surely they'll need to be a decent thickness to have the desired effect? <br><br></td></tr></table><br>
<a name="572816"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no reason why the inverted mesh method shouldn't look good, as long as you aren't just inverting the mesh and scaling it. <br><br></td></tr></table><br>
<a name="572830"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> There is no reason why the inverted mesh method shouldn't look good <br></div><br><br>Well, it will look okay, most of the time. . . but:<br><br>1) there's the problem of consistency in the thickness / visibility of the lines (something far away will have lines that are really thin and disappearing)<br><br>2) you can't decide exactly where you want to draw the lines, even though most of the time they appear in the right place. But what if you wanted to always outline certain edges, and not others?<br><br>3) There's the problem getting nice smooth lines, that are antialiased. . . (You can do this with line drawing, although it would take a lot of processing time)<br><br>I do admit, that if I'm going to be working in a real time game with lots of cel shading going on, I'll probably use the flip mesh.  But I still want to experiment with other ways and see what kind of cool alternative effects I can create for quickly rendering a video sequence.  <br><br>I think that line drawing will prove to be a much more flexible and artistically useful technique, even if it's too slow for real time.  It's still going to be hundreds of times faster than doing full-blown edge detections on the whole screen! :O) <br><br></td></tr></table><br>
<a name="572831"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1.  You can rescale the outline mesh based on it's distance to the camera if you want a consistent thickness. Very easy.<br><br>2.  You could use Vertex colours to always outline certain edges or even include this in the texture itself ... may not look too good though.<br><br>Don't get me wrong I'm not trying to be negative here .. good luck to you .. I'm sure we'd all be interested in your results. <br><br></td></tr></table><br>
<a name="572835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Scaling the outline mesh would have to be done vertex by vertex, and that wouldn't be acceptable for realtime.  Though if you wanted to waste the video ram you could preprepare a few widths, each half the size of the previous and switch as objects move into the distance.  But that would only work if you used two seperate meshes.  Unless maybe you had multiple surfaces and used alpha...  Hopefully you wouldn't get a surface hit for surfaces with alpha 0.<br><br>As for antialised lines, they'll be antialiased if you have full screen antialiasing on.  Otherwise, you're out of luck.  Why would you want the lines to be antialised if your polygon edges aren't though?  It would look weird.<br><br>If you want to make a cel shaded game which doesn't just use the mesh outline method, what you really need is pixel shaders.  So maybe you'll have to wait for Max3D to come along.  Then you'll be able to get exactly the effect you want. <br><br></td></tr></table><br>
<a name="572844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mr Snidesmin</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Roll on Max3d then. . . :O)<br><br><div class="quote"> As for antialised lines, they'll be antialiased if you have full screen antialiasing on <br></div><br><br>I think I'd have to do it manually because I'm starting to use fast pixel writing to draw the lines all in one go.  Also, I'm thinking of doing localised edge-detection, which if I make sophisticated enough, should antialias automatically anyway.  This is the experiment I'm working on. I do expect to be really slow - so you don't have to warn me :O)<br><br><br>thanks! <br><br></td></tr></table><br>
<a name="572995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bouncer</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why don't you just draw the lines using single-surface quads. You can make really good soft edged lines using this aproach and it's fast. Just use small gradient texsturemap with the quads and stretch/resize one to make a line. This way you can't blame the line drawing when your algo is too slow :) <br><br></td></tr></table><br>
<a name="573172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >aab</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> thats what i was going to say after only reading the first post. <br><br></td></tr></table><br>
<a name="573185"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Drawing the lines isn't really the bottleneck - it's calculating where to draw them that is. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
