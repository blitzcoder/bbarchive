<!DOCTYPE html><html lang="en" ><head ><title >Real time Strategy?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Real time Strategy?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Real time Strategy?</a><br><br>
<a name="1204718"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hotshot2005</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think for basic start would be<br><br>Plane with Grass textures<br>Cube<br>Mouse pointing 1 cube and put where unit I want<br> <br>Advance<br><br>Mouse Pointing 5 Cubes and put where units I want<br><br>How easy is to make?<br><br>Would I have deal with Path Finding AI? <br><br></td></tr></table><br>
<a name="1204729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, unless you want to have all your units go in a straight line from point A to B at all times, you'll have to use some form of pathfinding.<br><br>As to "how easy" it would be to make, it greatly depends on your programming skills. The individual steps aren't that hard, but you really need to do some thinking on how to break down the entire process and all its requirements into their coponent steps.<br><br>RTS games can become pretty complex after a while since there can be a lot of things influencing other things.<br><br>(The hardest thing to do with an RTS game is probably the most boring part as well: balancing your units with strenghts/weaknesses, hitpoints, etc. It's fairly easy to come up with the mechanics, but hard to come up with a good balance where the game is both interesting &amp; challenging, without devolving into a "rush the enemy with a million unit 'X' and he doesn't stand a chance" thing. <br><br></td></tr></table><br>
<a name="1204732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure how true it still is on modern hardware, but back in "the day" path finding was the single big issue for games like the original-gen C&amp;C. Plotting a route for dozens or hundreds of units across a field full of constantly-changing obstructions was actually well beyond the capabilities of hardware at the time. Units would guess rather than accurately plot paths, and only within a small radius, leading to the bizarre behaviour C&amp;C players may remember like suddenly reversing direction when they got close enough to realise the path was blocked.<br><br>Coming up with a decent strategic AI is also a problem. The same old games described above simply didn't have one; behaviour was just baked into the map via invisible waypoints and scripts. Made for easy campaign design but once a player gets used to the one thing the computer knows how to do, trivial skirmishes. <br><br></td></tr></table><br>
<a name="1204816"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> A lot of the difficulty depends on the specifications for your game.  <br><br>How complex are the environments? How many units do you wish to cater for?  <br><br>As some basic questions to ask yourself. <br><br></td></tr></table><br>
<a name="1204827"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hotshot2005</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks guys as it is interesting reading :)<br><br>How complex are the environments? It have been small Map for starter<br><br>How many units do you wish to cater for? 25 Units then if goes well and may increase it depend on framerates :) <br><br></td></tr></table><br>
<a name="1204831"></a>

<a name="1204832"></a>

<a name="1204834"></a>

<a name="1204839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Omnicode</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Depending on what you're looking for the basis is basically trying to the run the pathfinding AI as little as possible to create the same effect.<br><br>Let's say you have 25 units and you're trying to get them all through the gap, surely making them all use a different AI pass would cause GREAT slowdown. By simply making all units around a single unit that provided the AI to get through the gap follow that prior unit, it saves computing time and slowdown is GREATLY reduced. The unit picked to do that computation on should surely be the closest and in the event of the loss of that 'leader' unit the next in line should inherit it's path.<br><br>I'd still prefer 'baked' map data for pathing. However, it makes it more difficult to make more dynamic maps.<br><br>Concept really, i haven't put anything together sides this:<br>-no media required-<br>Just demonstrates typical pathfinding AI.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,32,2
SetBuffer BackBuffer()

Type Character
	Field Entity,X,Y,Z,Node[999],AI_METHOD
	Field Target,Status$,Destination,CurrentNode,CurrentNodesNeeded
End Type

Type Obstacle
	Field Entity,x,y,z
End Type

Global Plane=CreatePlane()
EntityPickMode Plane,2
EntityColor Plane,80,128,80
MoveEntity Plane,0,-1,0

Global Light=CreateLight()
RotateEntity Light ,45,45,0

Global Camera=CreateCamera()
MoveEntity Camera,0,50,0

Global MainCharacter=Create_Character(0,0)
RotateEntity Camera,90,0,0

For obx=1 To 30
	For oby=1 To 30
		Obs.Obstacle=New Obstacle
		obs\entity=CreateCube()
		EntityColor obs\entity,Rand(255),Rand(255),Rand(255)
		ScaleMesh obs\entity,1,5,1
		RotateEntity obs\entity,0,Rand(-180,180),0
		PositionEntity obs\entity,-100+obx*8-(27.5)+(Sin(obx*oby)*5),0,-130+oby*8+(Cos(obx*oby)*5)
		Obs\x=EntityX#(Obs\entity)
		Obs\y=EntityY#(Obs\entity)
		Obs\z=EntityZ#(Obs\Entity)
		EntityPickMode Obs\Entity,1
		EntityRadius Obs\Entity,2
		EntityType Obs\Entity,2
	Next
Next

Collisions 1,2,2,2
UpdateWorld

While Not KeyDown(1)
	Cls
	TranslateEntity Camera,0,-MouseZSpeed()*2,0
	PositionEntity Camera,EntityX(MainCharacter),EntityY(Camera),EntityZ(MainCharacter)
	If MouseDown(1)=True
		If CameraPick(Camera,MouseX(),MouseY())=Plane
			For C.Character=Each Character
				If C\Entity=MainCharacter
					ShowEntity C\Target
					PositionEntity C\Target,Ceil(PickedX()),EntityY(C\Entity),Ceil(PickedZ())
					C\Destination=C\Target
					EntityPickMode C\Target,0
					C\CurrentNode=1
					C\CurrentNodesNeeded=0
					EntityPickMode Plane,0
					Set_Waypoint(MainCharacter)
				EndIf
			Next
			EntityPickMode Plane,2
		EndIf
	Else
		For C.Character=Each Character
			If C\Entity&lt;&gt;MainCharacter
				If C\Destination=0
					PositionEntity C\Target,Rand(-25,100),0,Rand(-25,100)
					C\Destination=C\Target
					EntityPickMode C\Target,0
					C\CurrentNode=1
					C\CurrentNodesNeeded=0
					EntityPickMode Plane,0
					Set_Waypoint(C\Entity)
				EndIf
			EndIf
		Next
	EndIf
	
	If KeyHit(200)=True Then Create_Character(EntityX(MainCharacter)-Rand(-50,50),EntityZ(MainCharacter)-Rand(-50,50))
	
	
	For C.Character=Each Character
		If C\Destination&lt;&gt;0
			Select C\AI_METHOD
				Case 1
					If EntityDistance(C\Destination,C\Entity)&gt;2
						PointEntity C\Entity,C\Destination
						RotateEntity C\Entity,0,EntityYaw(C\Entity),0
						MoveEntity C\Entity,0,0,.2
					Else
						RotateEntity C\Entity,0,EntityYaw(C\Entity),0
						C\Destination=0
					EndIf
				Case 2
					If EntityDistance(C\Destination,C\Entity)&gt;2
						If C\CurrentNode&lt;1 Then C\CurrentNode=1
						If C\CurrentNode&lt;=999
							If EntityDistance(C\Entity,C\Node[C\CurrentNode])&lt;1
								C\CurrentNode=NextNode(C.Character,C\CurrentNode)
								If C\CurrentNode&gt;C\CurrentNodesNeeded+1 Then C\CurrentNode=C\CurrentNodesNeeded+1
							Else
								PointEntity C\Entity,C\Node[C\CurrentNode]
								TurnEntity C\Entity,0,DeltaYaw#(C\Entity,C\Node[C\CurrentNode]),0
								MoveEntity C\Entity,0,0,.3
							EndIf
						EndIf
					Else
						RotateEntity C\Entity,0,EntityYaw(C\Entity),0
						C\Destination=0
					EndIf
			End Select
		EndIf
	Next
	UpdateWorld
	RenderWorld
	Color 0,0,0
	CameraProject Camera,EntityX(MainCharacter),EntityY(MainCharacter),EntityZ(MainCharacter)
	Text ProjectedX(),ProjectedY(),"Player"
	
    For C.Character=Each Character
		For Nodes=1 To C\CurrentNodesNeeded
			If nodes&gt;=C\CurrentNode-1
				If PositionUnique(C.Character,nodes)=1
					ShowEntity C\Node[nodes]
					CameraProject Camera,EntityX(C\Node[nodes]),EntityY(C\Node[nodes]),EntityZ(C\Node[nodes])
					Local X1#=ProjectedX() : Local Y1#=ProjectedY()
					CameraProject Camera,EntityX(C\Node[nodes+1]),EntityY(C\Node[nodes+1]),EntityZ(C\Node[nodes+1])
					Local X2#=ProjectedX() : Local Y2#=ProjectedY()
					Line X1#,Y1#,X2#,Y2#
				EndIf
			Else
				HideEntity C\Node[nodes]
			EndIf
		Next
	Next
	
	Text 0,0,"Hit the Up Arrow Key to add additional units"
	Text 0,12,"Note: This isnt a very fast method, but it works about 90% of the time."
	Text 0,24,"AI Sometimes switches to 'basic' where it simply guides to the target location, not a bug."
	Text 0,48,"Feel free to mod and do whatever with this code."
	ActuralNodes=0
	Flip 0
Wend
End

Function Create_Character(x,z)
	C.Character=New Character
	C\Entity=CreateCube()
	C\Target=CreateSphere()
	C\CurrentNode=1
	ScaleEntity C\Target,.5,.5,.5
	EntityColor C\Target,10,10,10
	EntityColor C\Entity,255,0,0
	ScaleEntity C\Entity,1,2,1
	MoveEntity C\Entity,x,1,z
	EntityType C\Entity,1
	
	For nodes=1 To 999
		C\Node[nodes]=CreateCube()
		EntityColor C\Node[nodes],0,128,255
		ScaleEntity C\Node[nodes],.5,.5,.5
		HideEntity C\Node[nodes]
	Next
	
	Return C\Entity
End Function

Function Set_Waypoint(ent)
	For C.Character=Each Character
		If C\Entity=ent
			Local OBSTACLE=LinePick(EntityX(C\Entity),EntityY(C\Entity),EntityZ(C\Entity),EntityX(C\Target)-EntityX(C\Entity),EntityY(C\Entity),EntityZ(C\Target)-EntityZ(C\Entity),1)
			If OBSTACLE&lt;&gt;0 And OBSTACLE&lt;&gt;C\Destination
				C\AI_METHOD=2
				C\CurrentNodesNeeded=NodesNeeded(C\Entity,C\Target,C)
				For Nodes=C\CurrentNodesNeeded+1 To 999
					HideEntity C\Node[nodes]
				Next
				For Nodes=1 To C\CurrentNodesNeeded-1
					Local DX1#=EntityX#(C\Node[nodes]):Local DX2#=EntityX#(C\Node[nodes+1])
					Local DZ1#=EntityZ#(C\Node[nodes]):Local DZ2#=EntityZ#(C\Node[nodes+1])
					Local DDX#=Abs(DX2#-DX1#)
					Local DDZ#=Abs(DZ2#-DZ1#)
					;Merge Excessive Noding.
					If DDX#&lt;2 And DDZ#&gt;=2 Then PositionEntity C\Node[nodes+1],EntityX#(C\Node[nodes]),EntityY#(C\Node[nodes+1]),EntityZ#(C\Node[nodes+1])
					If DDZ#&lt;2 And DDX#&gt;=2 Then PositionEntity C\Node[nodes+1],EntityX#(C\Node[nodes+1]),EntityY#(C\Node[nodes+1]),EntityZ#(C\Node[nodes])
					If DDX#&lt;2 Then PositionEntity C\Node[nodes+1],EntityX#(C\Node[nodes]),EntityY#(C\Node[nodes+1]),EntityZ#(C\Node[nodes+1])
					If DDZ#&lt;2 Then PositionEntity C\Node[nodes+1],EntityX#(C\Node[nodes+1]),EntityY#(C\Node[nodes+1]),EntityZ#(C\Node[nodes])
				Next
				PositionEntity C\Node[1],EntityX(C\Entity),EntityY(C\Entity),EntityZ(C\Entity)
				PositionEntity C\Node[C\CurrentNodesNeeded+1],EntityX(C\Target),EntityY(C\Entity),EntityZ(C\Target)
			Else
				C\AI_METHOD=1
			EndIf
		EndIf
	Next
End Function


Function PositionUnique(C.Character,n)
	Local DX1#=EntityX#(C\Node[n])
	Local DX2#=EntityX#(C\Node[n+1])
	Local DZ1#=EntityZ#(C\Node[n])
	Local DZ2#=EntityZ#(C\Node[n+1])
	Local DDX#=Abs(DX2#-DX1#)
	Local DDZ#=Abs(DZ2#-DZ1#)
	If DDX#=0 And DDZ#=0 Then Return 0
	Return 1
End Function

Function NextNode(C.Character,n)
	Repeat
		n=n+1
    Until PositionUnique(C.Character,n)
	Return n
End Function


Function NodesNeeded(obs,dest,C.Character)
	Local NodeUsed=2,NodePick
	EntityPickMode Plane,0
	PositionEntity C\Node[NodeUsed],PickedX(),EntityY(C\Entity),PickedZ()
	MoveEntity C\Node[NodeUsed],PickedNX()*4,0,PickedNZ()*4
	Repeat
		NodePick=LinePick(EntityX(C\Node[NodeUsed]),EntityY(C\Node[NodeUsed]),EntityZ(C\Node[NodeUsed]),EntityX(dest)-EntityX(C\Node[NodeUsed]),EntityY(dest),EntityZ(dest)-EntityZ(C\Node[NodeUsed]),1)
		If NodePick
			If NodeUsed+1&lt;1000
				PositionEntity C\Node[NodeUsed+1],Ceil(EntityX(NodePick)),EntityY(C\Entity),Ceil(EntityZ(NodePick))
				MoveEntity C\Node[NodeUsed+1],PickedNX()*4,0,PickedNZ()*4
				UpdateNormals C\Node[NodeUsed+1]
				NodeUsed=NodeUsed+1
			EndIf
		Else
			EntityPickMode Plane,2
			Return NodeUsed
		EndIf
	Until NodeUsed&gt;=999
	EntityPickMode Plane,2
	DebugLog "Couldnt resolve it... :c"
	Return 0 ;Can't resolve it.
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1325802"></a>

<a name="1325841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Plotting a route for dozens or hundreds of units across a field full of constantly-changing obstructions was actually well beyond the capabilities of hardware at the time<br> <br></div><br>yes, that's what i am thinking too, in a RTS game with many entities which need to calculate a path to a target but at the same time, several others turning moving entities which are dynamic obstacles (like big vehicles) this requires a regular recalculation of each path considering the new areas blocked by the turning moving obstacles.<br><br>For nodes positioned on a grid (like one node each 1x,1z unit), i have an idea on how to quickly change the state of each node blocked by a turning moving obstacle, in order to consider only the accessible nodes, but for nodes positioned around obstacles, this would be difficult/impossible...<br><br>An easy optimization would be to calculate the path for a group of entities with the same start area and the same target and not for each entity... <br><br></td></tr></table><br>
<a name="1326072"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br><br><br>yes, that's what i am thinking too, in a RTS game with many entities which need to calculate a path to a target but at the same time, several others turning moving entities which are dynamic obstacles (like big vehicles) this requires a regular recalculation of each path considering the new areas blocked by the turning moving obstacles.<br> <br></div><br>for large vehicles that need a turning circle, just use a larger minimum "step" size for the pathing checks- This means they will 'detec t' obstacles that are a little way further and take alternative action early.<br><br>If they only can turn x degrees per 'TICK', then the pathfinding only needs to consider a smaller range of "Possible  moves" representing a cone within that angle. <br><br></td></tr></table><br>
<a name="1326079"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think that a good approach is to have a way to identify a turning moving obstacle (vehicle) and a static obstacle (building, wall, big container, big furniture, big machine, big rock, big plant) and to consider a turning moving obstacle as a temporary block.<br>And only recalculate a path when near enough and really blocked by the turning moving obstacle (which can turn move at any time)<br><br>I have replayed command &amp; conquer recently and i have noticed that the pathfinding is not always the best and sometimes an entity simply stops to turn move, so it does not seem to recalculate a new path often.<br><br>Also, another good optimization is to separate the map in zones with passages (from one zone to another zone), and to have nodes childs of each zone, and when an entity try to find a path, first calculate a passages path which leads to the target zone, and then depending on which zone the entity is in, calculate a nodes path which leads to the target passage, considering only the nodes in the zone.<br>This greatly decreases the amount of nodes to consider, and thus the calculation to do... <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
