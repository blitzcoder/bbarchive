<!DOCTYPE html><html lang="en" ><head ><title >Help with ball physics (2/1-2-D)?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Help with ball physics (2/1-2-D)?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Help with ball physics (2/1-2-D)?</a><br><br>
<a name="1221063"></a>

<a name="1221066"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all. As you know, I've been working on my 3D game in a 2D view (top-down view) for a while now. I've recently run into a little snag. What I've tried to do is make it so that if you hold down the left or right arrow, the ball will roll to the left or the right on the X-Axis in 3D, depending on its' changed velocity. Now the problem is when I go to let go of the left or the right arrow key, the friction that stops the ball is incorrect. It goes to Infinity / NaN when letting go of the left arrow key and it gets very close to 0 when letting go of the right arrow key, but it's supposed to no matter what, either count up to 0 from a maximum negative velocity, or count down from a maximum positive velocity, both down to 0.<br><br>I need to use the "CurveValue#()" function, in order to make the positive or negative velocity "slingshot" back to 0.00, slowly or fast depending on the speed of the current velocity.<br><br>Without further delay, here is the code:<br><br>Ball_Physics.bb: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Const gravity#=-0.02 ;gravity constant

Graphics3D 800,600,16,2

Const ball_col=1
Const world_col=2

Collisions ball_col,world_col,2,2

Global texture

texture=CreateTexture(16,16)

SetBuffer TextureBuffer(texture)

Color 255,0,64
Rect 0,0,16,16,1

Color 255,0,0
Rect 0,0,8,8,1
Rect 8,8,8,8,1

ScaleTexture texture,0.1,0.1

;Global groundtexture=CreateTexture(32,32,1+8)

;SetBuffer TextureBuffer(groundtexture)

;Color 0,0,0
;Rect 0,0,32,32,1

;Color 0,0,255
;Rect 0,0,32,32,0

;ScaleTexture groundtexture,2,2

SetBuffer BackBuffer()
Color 255,255,255

;plane=CreatePlane()
;EntityTexture plane,groundtexture
;EntityType plane,world_col
;EntityAlpha plane,0.5

;mirror=CreateMirror()

light=CreateLight(1)
RotateEntity light,30,20,0

obj=CreateCube()

EntityType obj,world_col
PositionEntity obj,0,25,0
ScaleEntity obj,10,10,10
TurnEntity obj,90,0,0

camera=CreateCamera()
CameraClsColor camera,0,0,255

ball.ball=ballnew(0,4,-120,2,0.0)

api_ShowWindow(SystemProperty$("AppHWND"), 1)

PositionEntity camera, 0, 180, 0
RotateEntity camera, 90, 0, 0

Repeat

ballcontrol()
ballupdate()

RenderWorld()

Text 10,10,"Arrow keys to control ball"
Text 10,30,"Scroll on mouse to zoom"

For c.ball = Each ball

	Text 10,50,"c\vx#: "+c\vx#
	Text 10,70,"c\vy#: "+c\vy#
	Text 10,90,"c\vz#: "+c\vz#
	
Next

Flip

Until KeyDown(1)
End


Type ball

Field e ;entity

Field sphere

Field pivot

Field x#,y#,z# ; position in 3d-space

Field vx#,vy#,vz# ; velocity

Field ax#,ay#,az# ; acceleration

Field size#

Field bounce# ; bounce factor

Field vel#

Field vx2#,vy2#,vz2# ; temp velocity

End Type


Function ballnew.ball(x#,y#,z#,size#=1,bounce#=0.9)
	
	c.ball=New ball
	
	c\x#=x#
	c\y#=y#
	c\z#=z#
	
	c\size=size
	
	c\bounce#=bounce#
	
	c\e=CreatePivot()
		
	c\sphere=CreateSphere(64)
	
	c\pivot=CreatePivot()
	
	EntityType c\e,ball_col
	EntityRadius c\e,c\size
	
	PositionEntity c\e,c\x,c\y,c\z
	ScaleEntity c\sphere,c\size,c\size,c\size
	
	EntityTexture c\sphere,texture
	
	Return c
	
End Function

Function ballupdate()
	
	For c.ball=Each ball
				
		;c\vy#=c\vy#+gravity#
		
		c\vx#=c\vx#+c\ax#
		c\vy#=c\vy#+c\ay#
		c\vz#=c\vz#+c\az#
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		TranslateEntity c\e,c\vx,c\vy,c\vz	
	
	Next
	
	UpdateWorld()
		
	For c.ball=Each ball
	
		;correct velocity if collided
		c\vx2=(EntityX(c\e)-c\x)
		c\vy2=(EntityY(c\e)-c\y)
		c\vz2=(EntityZ(c\e)-c\z)
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		PositionEntity c\sphere,c\x,c\y,c\z
		PositionEntity c\pivot,c\x,c\y,c\z
		
		If EntityCollided(c\e,world_col)
				
			For i = 1 To CountCollisions(c\e)
				; Get the normal of the surface which the entity collided with. 
				Nx# = CollisionNX(c\e, i) 
				Ny# = CollisionNY(c\e, i) 
				Nz# = CollisionNZ(c\e, i) 
				
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
				VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
				
				; Calculate the normal force. 
				NFx# = -2.0 * Nx# * VdotN# 
				NFy# = -2.0 * Ny# * VdotN# 
				NFz# = -2.0 * Nz# * VdotN# 
				
				; Add the normal force to the direction vector. 
				c\vx# = c\vx# + NFx# * c\bounce#
				c\vy# = c\vy# + NFy# * c\bounce#
				c\vz# = c\vz# + NFz# * c\bounce#

				avx#=EntityPitch(c\sphere)
				avy#=EntityYaw(c\sphere)
				avz#=EntityRoll(c\sphere)

				;Rotate stuff
				;Get vector from center to collision
				dx1#=(CollisionX(c\e,i)-c\x)
				dy1#=(CollisionY(c\e,i)-c\y)
				dz1#=(CollisionZ(c\e,i)-c\z)
				
				dx2#=c\vx
				dy2#=c\vy
				dz2#=c\vz
				
				;Cross product
				cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
				cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
				cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
															
				AlignToVector c\pivot,cx,cy,cz,1
																									
			Next
			
			Nx# = CollisionNX(c\e, 1) 
			Ny# = CollisionNY(c\e, 1) 
			Nz# = CollisionNZ(c\e, 1) 				
					
			AlignToVector c\e,Nx#,Ny#,Nz#,2,0.5
			
			c\vel#=Sqr(c\vx2*c\vx2+c\vy2*c\vy2+c\vz2*c\vz2)
						
			;slow down due to friction
			c\vx#=c\vx*0.98
			c\vy#=c\vy*0.98
			c\vz#=c\vz*0.98
					

		EndIf

			
		EntityParent c\sphere,c\pivot
								
		TurnEntity c\pivot,-c\vel#*(180/Pi)/c\size#,0,0

		EntityParent c\sphere,0

		c\ax#=0
		c\ay#=0
		c\az#=0	
		
	Next
	
End Function

Function ballcontrol()

	For c.ball=Each ball
	
		If c\vx# &gt; 0.0 Then c\vx# = c\vx# - 0.01
		If c\vx# &lt; -0.01 Then c\vx# = c\vx# + 0.01

		If KeyDown(203)

			c\ax#=TFormedX()
			c\ay#=TFormedY()
			c\az#=TFormedZ()

			c\vx#=c\vx#*0.94
			c\vy#=c\vy#*0.94
			c\vz#=c\vz#*0.94
			
			ballspeed# = CurveValue#(-0.03, -0.03, 1.0)

			TFormVector ballspeed#,0,0,c\e,0
			
		EndIf
		
		If KeyDown(205)
			
			TFormVector 0.03,0,0,c\e,0
			
			c\ax#=TFormedX()
			c\ay#=TFormedY()
			c\az#=TFormedZ()
			
		EndIf
		
		;If KeyDown(208)
			
		;	c\vx=c\vx*0.94
		;	c\vy=c\vy*0.94
		;	c\vz=c\vz*0.94
			
		;EndIf
		
		;If KeyDown(57)
			
			;TFormVector 0,0.05,0,c\e,0
			
			;TFormVector 0,0,0.05,c\e,0
			
		;	c\ax#=c\ax+TFormedX()
		;	c\ay#=c\ay+TFormedY()
		;	c\az#=c\az+TFormedZ()
			
									
		;EndIf
		
		;If KeyDown(203)
			
		;	TurnEntity c\e,0,2,0
			
		;EndIf
		
		;If KeyDown(205)
			
		;	TurnEntity c\e,0,-2,0
			
		;EndIf
		
		
	Next
	
	
	
End Function

Function ballcamera(camera,b.ball,camx#,camy#,camz#,aimx#=0,aimy#=0,aimz#=0,smoothcam#=0.1,roll#=0)

	TFormPoint camx#,camy#,camz#,b\e,0
	
	dx#=(TFormedX()-EntityX(camera))*smoothcam#
	dy#=(TFormedY()-EntityY(camera))*smoothcam#
	dz#=(TFormedZ()-EntityZ(camera))*smoothcam#
	
	TranslateEntity camera,dx,dy,dz
	
	TFormPoint aimx#,aimy#,aimz#,b\e,0
	
	dx# = EntityX(camera)-TFormedX()
	dy# = EntityY(camera)-TFormedY()
	dz# = EntityZ(camera)-TFormedZ()
	dist#=Sqr#((dx#*dx#)+(dz#*dz#))
	pitch#=ATan2(dy#,dist#)
	yaw#=ATan2(dx#,-dz#)
	
	RotateEntity camera,pitch#,yaw#,roll#
	
End Function

Function CurveValue#(current#,destination#,curve)
	current#=current#+((destination#-current#)/curve)
	Return current#
End Function</textarea><br><br>Any assistance is GREATLY appreciated!<br><br>Thanks, and have a wonderful afternoon / evening! =)<br><br>~GF <br><br></td></tr></table><br>
<a name="1221094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Something like this?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,16,2

Const ball_col=1
Const world_col=2

Const FRICTION# = .99
Const ACCELERATION# = 0.03
;MAX SPEED = ACCELERATION / ( 1.0 - FRICTION )

Collisions ball_col,world_col,2,2

Global texture

texture=CreateTexture(16,16)

SetBuffer TextureBuffer(texture)

Color 255,0,64
Rect 0,0,16,16,1

Color 255,0,0
Rect 0,0,8,8,1
Rect 8,8,8,8,1

ScaleTexture texture,0.1,0.1

;Global groundtexture=CreateTexture(32,32,1+8)

;SetBuffer TextureBuffer(groundtexture)

;Color 0,0,0
;Rect 0,0,32,32,1

;Color 0,0,255
;Rect 0,0,32,32,0

;ScaleTexture groundtexture,2,2

SetBuffer BackBuffer()
Color 255,255,255

;plane=CreatePlane()
;EntityTexture plane,groundtexture
;EntityType plane,world_col
;EntityAlpha plane,0.5

;mirror=CreateMirror()

light=CreateLight(1)
RotateEntity light,30,20,0

obj=CreateCube()

EntityType obj,world_col
PositionEntity obj,0,25,0
ScaleEntity obj,10,10,10
TurnEntity obj,90,0,0

camera=CreateCamera()
CameraClsColor camera,0,0,255

ball.ball=ballnew(0,4,-120,2,0.0)

;api_ShowWindow(SystemProperty$("AppHWND"), 1)

PositionEntity camera, 0, 180, 0
RotateEntity camera, 90, 0, 0

Repeat

ballcontrol()
ballupdate()

RenderWorld()

Text 10,10,"Arrow keys to control ball"
Text 10,30,"Scroll on mouse to zoom"

For c.ball = Each ball

	Text 10,50,"c\vx#: "+c\vx#
	Text 10,70,"c\vy#: "+c\vy#
	Text 10,90,"c\vz#: "+c\vz#
	
Next

Flip

Until KeyDown(1)
End


Type ball

Field e ;entity

Field sphere

Field pivot

Field x#,y#,z# ; position in 3d-space

Field vx#,vy#,vz# ; velocity

Field ax#,ay#,az# ; acceleration

Field size#

Field bounce# ; bounce factor

Field vel#

Field vx2#,vy2#,vz2# ; temp velocity

End Type


Function ballnew.ball(x#,y#,z#,size#=1,bounce#=0.9)
	
	c.ball=New ball
	
	c\x#=x#
	c\y#=y#
	c\z#=z#
	
	c\size=size
	
	c\bounce#=bounce#
	
	c\e=CreatePivot()
		
	c\sphere=CreateSphere(64)
	
	c\pivot=CreatePivot()
	
	EntityType c\e,ball_col
	EntityRadius c\e,c\size
	
	PositionEntity c\e,c\x,c\y,c\z
	ScaleEntity c\sphere,c\size,c\size,c\size
	
	EntityTexture c\sphere,texture
	
	Return c
	
End Function

Function ballupdate()
	
	For c.ball=Each ball
				
		;c\vy#=c\vy#+gravity#
		
		c\vx#=c\vx# * FRICTION + c\ax#
		c\vy#=c\vy# * FRICTION + c\ay#
		c\vz#=c\vz# * FRICTION + c\az#
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		TranslateEntity c\e,c\vx,c\vy,c\vz	
	
	Next
	
	UpdateWorld()
		
	For c.ball=Each ball
	
		;correct velocity if collided
		c\vx2=(EntityX(c\e)-c\x)
		c\vy2=(EntityY(c\e)-c\y)
		c\vz2=(EntityZ(c\e)-c\z)
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		PositionEntity c\sphere,c\x,c\y,c\z
		PositionEntity c\pivot,c\x,c\y,c\z
		
		If EntityCollided(c\e,world_col)
				
			For i = 1 To CountCollisions(c\e)
				; Get the normal of the surface which the entity collided with. 
				Nx# = CollisionNX(c\e, i) 
				Ny# = CollisionNY(c\e, i) 
				Nz# = CollisionNZ(c\e, i) 
				
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
				VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
				
				; Calculate the normal force. 
				NFx# = -2.0 * Nx# * VdotN# 
				NFy# = -2.0 * Ny# * VdotN# 
				NFz# = -2.0 * Nz# * VdotN# 
				
				; Add the normal force to the direction vector. 
				c\vx# = c\vx# + NFx# * c\bounce#
				c\vy# = c\vy# + NFy# * c\bounce#
				c\vz# = c\vz# + NFz# * c\bounce#

				avx#=EntityPitch(c\sphere)
				avy#=EntityYaw(c\sphere)
				avz#=EntityRoll(c\sphere)

				;Rotate stuff
				;Get vector from center to collision
				dx1#=(CollisionX(c\e,i)-c\x)
				dy1#=(CollisionY(c\e,i)-c\y)
				dz1#=(CollisionZ(c\e,i)-c\z)
				
				dx2#=c\vx
				dy2#=c\vy
				dz2#=c\vz
				
				;Cross product
				cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
				cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
				cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
															
				AlignToVector c\pivot,cx,cy,cz,1
																									
			Next
			
			Nx# = CollisionNX(c\e, 1) 
			Ny# = CollisionNY(c\e, 1) 
			Nz# = CollisionNZ(c\e, 1) 				
					
			AlignToVector c\e,Nx#,Ny#,Nz#,2,0.5
			
			c\vel#=Sqr(c\vx2*c\vx2+c\vy2*c\vy2+c\vz2*c\vz2)
						
			;slow down due to friction
			c\vx#=c\vx*0.98
			c\vy#=c\vy*0.98
			c\vz#=c\vz*0.98
					

		EndIf

			
		EntityParent c\sphere,c\pivot
								
		TurnEntity c\pivot,-c\vel#*(180/Pi)/c\size#,0,0

		EntityParent c\sphere,0

		c\ax#=0
		c\ay#=0
		c\az#=0	
		
	Next
	
End Function

Function ballcontrol()

	For c.ball=Each ball
	
		;reset acceleration
		c\ax = 0
		c\ay = 0
		c\az = 0

		If KeyDown(203)
			TFormVector -ACCELERATION, 0,0, c\e, 0
			c\ax# = TFormedX()
			c\ay# = TFormedY()
			c\az# = TFormedZ()
		EndIf
		
		If KeyDown(205)
			TFormVector ACCELERATION,0,0,c\e,0
			c\ax#=TFormedX()
			c\ay#=TFormedY()
			c\az#=TFormedZ()
		EndIf
		
		;If KeyDown(208)
			
		;	c\vx=c\vx*0.94
		;	c\vy=c\vy*0.94
		;	c\vz=c\vz*0.94
			
		;EndIf
		
		;If KeyDown(57)
			
			;TFormVector 0,0.05,0,c\e,0
			
			;TFormVector 0,0,0.05,c\e,0
			
		;	c\ax#=c\ax+TFormedX()
		;	c\ay#=c\ay+TFormedY()
		;	c\az#=c\az+TFormedZ()
			
									
		;EndIf
		
		;If KeyDown(203)
			
		;	TurnEntity c\e,0,2,0
			
		;EndIf
		
		;If KeyDown(205)
			
		;	TurnEntity c\e,0,-2,0
			
		;EndIf
		
		
	Next
	
	
	
End Function

Function ballcamera(camera,b.ball,camx#,camy#,camz#,aimx#=0,aimy#=0,aimz#=0,smoothcam#=0.1,roll#=0)

	TFormPoint camx#,camy#,camz#,b\e,0
	
	dx#=(TFormedX()-EntityX(camera))*smoothcam#
	dy#=(TFormedY()-EntityY(camera))*smoothcam#
	dz#=(TFormedZ()-EntityZ(camera))*smoothcam#
	
	TranslateEntity camera,dx,dy,dz
	
	TFormPoint aimx#,aimy#,aimz#,b\e,0
	
	dx# = EntityX(camera)-TFormedX()
	dy# = EntityY(camera)-TFormedY()
	dz# = EntityZ(camera)-TFormedZ()
	dist#=Sqr#((dx#*dx#)+(dz#*dz#))
	pitch#=ATan2(dy#,dist#)
	yaw#=ATan2(dx#,-dz#)
	
	RotateEntity camera,pitch#,yaw#,roll#
	
End Function

Function CurveValue#(current#,destination#,curve)
	current#=current#+((destination#-current#)/curve)
	Return current#
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1221183"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes Stevie. EXACTLY like that! Thanks alot, man! :D <br><br></td></tr></table><br>
<a name="1221243"></a>

<a name="1221268"></a>

<a name="1221269"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all. Ok, for some reason I can't get my ball to jump on the Z axis. (I'm using a top-down view so that the 3D graphics appear in 2D), and for some reason when I hit space, the ball is not "jumping" like it should. What am I doing wrong here? I'm about to pull my hair out! O_O<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 800,600,16,2

Const ball_col=1
Const world_col=2

Const FRICTION# = .99
Const ACCELERATION# = 0.03
Const MAX_SPEED = ACCELERATION / ( 1.0 - FRICTION )

Collisions ball_col,world_col,2,2

Global texture

texture=CreateTexture(16,16)

SetBuffer TextureBuffer(texture)

Color 255,64,64
Rect 0,0,32,32,1

Color 255,0,0
Rect 0,0,8,8,1
Rect 8,8,8,8,1

ScaleTexture texture,0.1,0.1

;Global groundtexture=CreateTexture(32,32,1+8)

;SetBuffer TextureBuffer(groundtexture)

;Color 0,0,0
;Rect 0,0,32,32,1

;Color 0,0,255
;Rect 0,0,32,32,0

;ScaleTexture groundtexture,2,2

SetBuffer BackBuffer()
Color 255,255,255

;plane=CreatePlane()
;EntityTexture plane,groundtexture
;EntityType plane,world_col
;EntityAlpha plane,0.5

;mirror=CreateMirror()

light=CreateLight(1)
RotateEntity light,30,20,0

obj=CreateCube()

EntityType obj,world_col
PositionEntity obj,0,25,0
ScaleEntity obj,10,10,10
TurnEntity obj,90,0,0

Global camera=CreateCamera()
CameraClsColor camera,0,0,255

ball.ball=ballnew(0,4,-120,2,10.0)

;api_ShowWindow(SystemProperty$("AppHWND"), 1)

;PositionEntity camera, 0, 180, 0
;RotateEntity camera, 90, 0, 0
PositionEntity camera, 0, 1, -150

Global player = CreateCube()
PositionEntity player, 0, 0, 1

Global OnGround

;slow down the jump acceleration to get a moon like jumping:
Const JumpAcceleration# = 0.5

;Gravitiy lokks realistic, when it is 10% of Jump acceleraion
Const Gravity# = .005

; has to be FLOAT not INT:
Player_velocityY# =0

api_ShowWindow(SystemProperty$("AppHWND"), 1)

Repeat

ballcontrol()
ballupdate()

RenderWorld()

Text 10,10,"Arrow keys to control ball"
Text 10,30,"Scroll on mouse to zoom"
Text 10,50, "ACCELERATION: "+ACCELERATION

For c.ball = Each ball
	Text 10,70, "c\vx#: "+c\vx#
	Text 10,90, "c\vy#: "+c\vy#
	Text 10,110, "c\vz#: "+c\vz#
Next

Flip

Until KeyDown(1)
End


Type ball

Field e ;entity

Field sphere

Field pivot

Field x#,y#,z# ; position in 3d-space

Field vx#,vy#,vz# ; velocity

Field ax#,ay#,az# ; acceleration

Field size#

Field bounce# ; bounce factor

Field vel#

Field vx2#,vy2#,vz2# ; temp velocity

End Type


Function ballnew.ball(x#,y#,z#,size#=1,bounce#=0.9)
	
	c.ball=New ball
	
	c\x#=x#
	c\y#=y#
	c\z#=z#
	
	c\size=size
	
	c\bounce#=bounce#
	
	c\e=CreatePivot()
		
	c\sphere=CreateSphere(64)
	
	c\pivot=CreatePivot()
	
	EntityType c\e,ball_col
	EntityRadius c\e,c\size
	
	PositionEntity c\e,c\x,c\y,c\z
	ScaleEntity c\sphere,c\size,c\size,c\size
	
	EntityTexture c\sphere,texture

	PointEntity camera, c\sphere
	
	Return c
	
End Function

Function ballupdate()
	
	For c.ball=Each ball
				
		c\vx#=c\vx# * FRICTION + c\ax#
		c\vy#=c\vy# * FRICTION + c\ay#
		c\vz#=c\vz# * FRICTION + c\az#
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		TranslateEntity c\e,c\vx,c\vy,c\vz	
	
	Next
	
	UpdateWorld()
		
	For c.ball=Each ball
	
		;correct velocity if collided
		c\vx2=(EntityX(c\e)-c\x)
		c\vy2=(EntityY(c\e)-c\y)
		c\vz2=(EntityZ(c\e)-c\z)
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		PositionEntity c\sphere,c\x,c\y,c\z
		PositionEntity c\pivot,c\x,c\y,c\z
		
		If EntityCollided(c\e,world_col)
				
			For i = 1 To CountCollisions(c\e)
				; Get the normal of the surface which the entity collided with. 
				Nx# = CollisionNX(c\e, i) 
				Ny# = CollisionNY(c\e, i) 
				Nz# = CollisionNZ(c\e, i) 
				
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
				VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
				
				; Calculate the normal force. 
				NFx# = -2.0 * Nx# * VdotN# 
				NFy# = -2.0 * Ny# * VdotN# 
				NFz# = -2.0 * Nz# * VdotN# 
				
				; Add the normal force to the direction vector. 
				c\vx# = c\vx# + NFx# * c\bounce#
				c\vy# = c\vy# + NFy# * c\bounce#
				c\vz# = c\vz# + NFz# * c\bounce#

				avx#=EntityPitch(c\sphere)
				avy#=EntityYaw(c\sphere)
				avz#=EntityRoll(c\sphere)

				;Rotate stuff
				;Get vector from center to collision
				dx1#=(CollisionX(c\e,i)-c\x)
				dy1#=(CollisionY(c\e,i)-c\y)
				dz1#=(CollisionZ(c\e,i)-c\z)
				
				dx2#=c\vx
				dy2#=c\vy
				dz2#=c\vz
				
				;Cross product
				cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
				cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
				cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
															
				AlignToVector c\pivot,cx,cy,cz,1
																									
			Next
			
			Nx# = CollisionNX(c\e, 1) 
			Ny# = CollisionNY(c\e, 1) 
			Nz# = CollisionNZ(c\e, 1) 				
					
			AlignToVector c\e,Nx#,Ny#,Nz#,2,0.5
			
			c\vel#=Sqr(c\vx2*c\vx2+c\vy2*c\vy2+c\vz2*c\vz2)
						
			;slow down due to friction
			c\vx#=c\vx*0.99
			c\vy#=c\vy*0.99
			c\vz#=c\vz*0.99
					

		EndIf

			
		EntityParent c\sphere,c\pivot
								
		TurnEntity c\pivot,-c\vel#*(180/Pi)/c\size#,0,0

		EntityParent c\sphere,0

		c\ax#=0
		c\ay#=0
		c\az#=0	
		
	Next
	
End Function

Function ballcontrol()

	For c.ball=Each ball
	
		;reset acceleration
		c\ax = 0
		c\ay = 0
		c\az = 0
		
		If KeyDown(30) Or KeyDown(203)
			TFormVector -ACCELERATION,0,0,c\e,0
			c\ax# = TFormedX()
			c\ay# = TFormedY()
			c\az# = TFormedZ()
		EndIf
		
		If KeyDown(32) Or KeyDown(205)
			TFormVector ACCELERATION,0,0,c\e,0
			c\ax# = TFormedX()
			c\ay# = TFormedY()
			c\az# = TFormedZ()
		EndIf
		
		If KeyHit(57) Then jump = 1

		If jump Then Player_velocityY = JumpAcceleration
		Player_velocityY = Player_velocityY - Gravity

		TranslateEntity player, 0, Player_velocityY, 0

		If (EntityY(c\sphere)&lt;1.01) And Player_velocityY&lt;0 Then
			OnGround = True
			PositionEntity c\sphere, 0, 1, 0
			Player_velocityY=0
		Else
			OnGround = False
		EndIf

	Next

End Function

Function ballcamera(camera,b.ball,camx#,camy#,camz#,aimx#=0,aimy#=0,aimz#=0,smoothcam#=0.1,roll#=0)

	TFormPoint camx#,camy#,camz#,b\e,0
	
	dx#=(TFormedX()-EntityX(camera))*smoothcam#
	dy#=(TFormedY()-EntityY(camera))*smoothcam#
	dz#=(TFormedZ()-EntityZ(camera))*smoothcam#
	
	TranslateEntity camera,dx,dy,dz
	
	TFormPoint aimx#,aimy#,aimz#,b\e,0
	
	dx# = EntityX(camera)-TFormedX()
	dy# = EntityY(camera)-TFormedY()
	dz# = EntityZ(camera)-TFormedZ()
	dist#=Sqr#((dx#*dx#)+(dz#*dz#))
	pitch#=ATan2(dy#,dist#)
	yaw#=ATan2(dx#,-dz#)
	
	RotateEntity camera,pitch#,yaw#,roll#
	
End Function</textarea><br><br>Thank You again for the help as usual everyone! =)<br><br>Have a GREAT afternoon!<br><br>~GW<br><br>EDIT:<br><br>Bounce has been fixed, but I'm still having trouble with making the ball realistically jump. O_O; <br><br></td></tr></table><br>
<a name="1221287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> When you are jumping you should set the acceleration c\ay to the jump acceleration, not c\vy.  The accelerations are effectively the forces being applied to the ball which influence the velocity - you should not directly change the velocity.  Obviously, only allow jump acceleration to be applied if the ball is touching the ground.<br><br>For gravity, create a constant GRAVITY# to be 0.01 or whatever feels right and in the section below, deduct the gravity from the velocity at all times even when the ball is on the ground.<br><br>c\vx#=c\vx# * FRICTION + c\ax#<br>c\vy#=c\vy# * FRICTION + c\ay# - GRAVITY<br>c\vz#=c\vz# * FRICTION + c\az# <br><br></td></tr></table><br>
<a name="1221329"></a>

<a name="1221330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why not use a physics wrapper? I was trying to do my own physics once too, til someone told me about dlls. <br><br></td></tr></table><br>
<a name="1221355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good idea, @Fox. Which Physics wrapper is easiest, and where can I download it from? Thanks alot, @Fox! =) <br><br></td></tr></table><br>
<a name="1221371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> A physics wrapper to do a moving and bouncing ball?  Really?  Acht well, to each their own :) <br><br></td></tr></table><br>
<a name="1221375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, if there's ONE thing I've learned the hard way, it's to "keep it simple, stupid" =D <br><br></td></tr></table><br>
<a name="1221376"></a>

<a name="1221377"></a>

<a name="1221378"></a>

<a name="1221379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I could tell, since you're using Blitz3d. I always tell people, if you're starting programming at age 30 instead of age 3, use Blitz3d. Anyway, I spent quite a while checking out all the physics wrappers some time ago, and eventually did decide on a best one. Look at post 9 on the following thread. <br><br><a href="http://blitzbasic.com/Community/posts.php?topic=86991" target="_blank">http://blitzbasic.com/Community/posts.php?topic=86991</a> <br><br></td></tr></table><br>
<a name="1221502"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LineOf7s</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Hey, if there's ONE thing I've learned the hard way, it's to "keep it simple, stupid" =D <br></div><br>...which is the opposite of using a physics wrapper to (just) bounce a ball. <br><br></td></tr></table><br>
<a name="1221524"></a>

<a name="1221525"></a>

<a name="1221551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about trying to do a search on the forum ?<br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=856" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=856</a> <br><br></td></tr></table><br>
<a name="1221541"></a>

<a name="1221542"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya know, Lineof7s. I feel sorry for you. Sorry that you have to pick on everybody else just to feel good about yourself. So you know what, I'm no longer talking to you or reading your rude comments. I'm done. <br><br></td></tr></table><br>
<a name="1221552"></a>

<a name="1221553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Calm down, to show you how cool we are on blitzbasic.com i have even removed my provocative comment. <br>What do you think about the example by Jeppe Nielsen, it is good enough for what you want to do isn't it ? <br><br></td></tr></table><br>
<a name="1221566"></a>

<a name="1221570"></a>

<a name="1221571"></a>

<a name="1221573"></a>

<a name="1221575"></a>

<a name="1221576"></a>

<a name="1221629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's okay Guy, it's just some kind of mania us programmers have, probably from lack of sunlight or something. My rule of thumb: whenever you're tempted to retaliate to a post, just think of it as a baited hook. Nothing against you by the way Line of 7s. I myself am currently tempted to comment venomously on a Youtube video I recently saw. <br><br></td></tr></table><br>
<a name="1221598"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jeppe's code is very familiar, now where did I see that again? <br><br></td></tr></table><br>
<a name="1221635"></a>

<a name="1221639"></a>

<a name="1221640"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, Remi. And thanks guys for being understanding. As for the code, the only thing I need it to do other than what it already does is jump realistically. I got it to jump. But the problem is I can't control the jump speed when going up.<br><br>Here's what I have so far (I edited the tformvector line &amp; made it keyhit(57) instead of keydown(57)): <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;Ball rolling physics example by Jeppe Nielsen 2003

Const gravity#=-0.04;-0.02 ;gravity constant

Graphics3D 800,600,0,2

Const ball_col=1
Const world_col=2

Collisions ball_col,world_col,2,2

Global texture

texture=CreateTexture(16,16)

SetBuffer TextureBuffer(texture)

Color 255,255,255
Rect 0,0,16,16,1

Color 255,0,0
Rect 0,0,8,8,1
Rect 8,8,8,8,1

ScaleTexture texture,0.1,0.1


Global groundtexture=CreateTexture(32,32,1+8)

SetBuffer TextureBuffer(groundtexture)

Color 0,0,0
Rect 0,0,32,32,1

Color 0,0,255
Rect 0,0,32,32,0

ScaleTexture groundtexture,2,2

SetBuffer BackBuffer()
Color 255,255,255

plane=CreatePlane()
EntityTexture plane,groundtexture
EntityType plane,world_col
EntityAlpha plane,0.5

mirror=CreateMirror()




light=CreateLight(1)
RotateEntity light,30,20,0


obj=CreateCube()

EntityType obj,world_col
PositionEntity obj,0,0,0
ScaleEntity obj,10,10,10
RotateEntity obj,45,0,0



camera=CreateCamera()
CameraClsColor camera,0,0,255


ball.ball=ballnew(0,4,-120,2,0.8)


zoom#=14

api_ShowWindow(SystemProperty$("AppHWND"), 1)

Repeat

zoom#=zoom#-MouseZSpeed()
ballcamera(camera,ball,0,zoom#,-zoom#,0,5,0)


ballcontrol()
ballupdate()

RenderWorld()

Text 10,10,"Arrow keys to control ball"
Text 10,30,"Scroll on mouse to zoom"


Flip


Until KeyDown(1)
End


Type ball

Field e ;entity

Field sphere

Field pivot

Field x#,y#,z# ; position in 3d-space

Field vx#,vy#,vz# ; velocity

Field ax#,ay#,az# ; acceleration

Field size#

Field bounce# ; bounce factor

Field vel#

Field vx2#,vy2#,vz2# ; temp velocity

End Type


Function ballnew.ball(x#,y#,z#,size#=1,bounce#=0.9)
	
	c.ball=New ball
	
	c\x#=x#
	c\y#=y#
	c\z#=z#
	
	c\size=size
	
	c\bounce#=bounce#
	
	c\e=CreatePivot()
		
	c\sphere=CreateSphere(64)
	
	c\pivot=CreatePivot()
	
	EntityType c\e,ball_col
	EntityRadius c\e,c\size
	
	PositionEntity c\e,c\x,c\y,c\z
	ScaleEntity c\sphere,c\size,c\size,c\size
	
	EntityTexture c\sphere,texture
	
	Return c
	
End Function

Function ballupdate()
	
	For c.ball=Each ball
	
			
		c\vy#=c\vy#+gravity#
		
		c\vx#=c\vx#+c\ax#
		c\vy#=c\vy#+c\ay#
		c\vz#=c\vz#+c\az#
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		TranslateEntity c\e,c\vx,c\vy,c\vz	
	
	Next
	
	UpdateWorld()
		
	For c.ball=Each ball
	
		;correct velocity if collided
		c\vx2=(EntityX(c\e)-c\x)
		c\vy2=(EntityY(c\e)-c\y)
		c\vz2=(EntityZ(c\e)-c\z)
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		PositionEntity c\sphere,c\x,c\y,c\z
		PositionEntity c\pivot,c\x,c\y,c\z
		
		If EntityCollided(c\e,world_col)
				
			For i = 1 To CountCollisions(c\e)
				; Get the normal of the surface which the entity collided with. 
				Nx# = CollisionNX(c\e, i) 
				Ny# = CollisionNY(c\e, i) 
				Nz# = CollisionNZ(c\e, i) 
				
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
				VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
				
				; Calculate the normal force. 
				NFx# = -2.0 * Nx# * VdotN# 
				NFy# = -2.0 * Ny# * VdotN# 
				NFz# = -2.0 * Nz# * VdotN# 
				
				; Add the normal force to the direction vector. 
				c\vx# = c\vx# + NFx# * c\bounce#
				c\vy# = c\vy# + NFy# * c\bounce#
				c\vz# = c\vz# + NFz# * c\bounce#

				avx#=EntityPitch(c\sphere)
				avy#=EntityYaw(c\sphere)
				avz#=EntityRoll(c\sphere)

				;Rotate stuff
				;Get vector from center to collision
				dx1#=(CollisionX(c\e,i)-c\x)
				dy1#=(CollisionY(c\e,i)-c\y)
				dz1#=(CollisionZ(c\e,i)-c\z)
				
				dx2#=c\vx
				dy2#=c\vy
				dz2#=c\vz
				
				;Cross product
				cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
				cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
				cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
															
				AlignToVector c\pivot,cx,cy,cz,1
																									
			Next
			
			Nx# = CollisionNX(c\e, 1) 
			Ny# = CollisionNY(c\e, 1) 
			Nz# = CollisionNZ(c\e, 1) 				
					
			AlignToVector c\e,Nx#,Ny#,Nz#,2,0.5
			
			c\vel#=Sqr(c\vx2*c\vx2+c\vy2*c\vy2+c\vz2*c\vz2)
						
			;slow down due to friction
			c\vx#=c\vx*0.98
			c\vy#=c\vy*0.98
			c\vz#=c\vz*0.98
					

		EndIf

			
		EntityParent c\sphere,c\pivot
								
		TurnEntity c\pivot,-c\vel#*(180/Pi)/c\size#,0,0

		EntityParent c\sphere,0

		c\ax#=0
		c\ay#=0
		c\az#=0	
		
	Next
	
End Function


Function ballcontrol()
	
	For c.ball=Each ball
		
		If KeyDown(200)
			
			TFormVector 0,0,0.03,c\e,0
			
			c\ax#=TFormedX()
			c\ay#=TFormedY()
			c\az#=TFormedZ()
			
		EndIf
		
		If KeyDown(208)
			
			c\vx=c\vx*0.94
			c\vy=c\vy*0.94
			c\vz=c\vz*0.94
			
		EndIf
		
		If KeyHit(57)
			
			TFormVector 0,5,0,c\e,0
			
			c\ax#=c\ax+TFormedX()
			c\ay#=c\ay+TFormedY()
			c\az#=c\az+TFormedZ()
			
									
		EndIf
		
		If KeyDown(203)
			
			TurnEntity c\e,0,2,0
			
		EndIf
		
		If KeyDown(205)
			
			TurnEntity c\e,0,-2,0
			
		EndIf
		
		
	Next
	
	
	
End Function

Function ballcamera(camera,b.ball,camx#,camy#,camz#,aimx#=0,aimy#=0,aimz#=0,smoothcam#=0.1,roll#=0)
	
	TFormPoint camx#,camy#,camz#,b\e,0
	
	dx#=(TFormedX()-EntityX(camera))*smoothcam#
	dy#=(TFormedY()-EntityY(camera))*smoothcam#
	dz#=(TFormedZ()-EntityZ(camera))*smoothcam#
	
	TranslateEntity camera,dx,dy,dz
	
	TFormPoint aimx#,aimy#,aimz#,b\e,0
	
	dx# = EntityX(camera)-TFormedX()
	dy# = EntityY(camera)-TFormedY()
	dz# = EntityZ(camera)-TFormedZ()
	dist#=Sqr#((dx#*dx#)+(dz#*dz#))
	pitch#=ATan2(dy#,dist#)
	yaw#=ATan2(dx#,-dz#)
	
	RotateEntity camera,pitch#,yaw#,roll#
	
End Function</textarea><br><br>That's pretty much it.<br><br>Thanks again, guys! =) <br><br></td></tr></table><br>
<a name="1221648"></a>

<a name="1221649"></a>

<a name="1221706"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Jeppe's code is very familiar, now where did I see that again? <br></div><br>Rez was even kind enough to remove the header line that mentioned the author, in the original example.<br><br><div class="quote"> [...] The only thing I need it to do other than what it already does is jump realistically. [...] But the problem is I can't control the jump speed when going up. <br></div><br>A realistic jump is a combination of both a sensible jump force and a realistic gravity force. This will require that you test different values until you find a combination that is convincing.<br><br>- The gravity value is easy to modify: it's the "gravity" constant at the beginning of the code. You can change it to a more negative value so it's more realistic.<br><br>- In that program, the jump force does not have a variable assigned to it - it's a "hard-coded" value.<br>You need to identify the part in the program code that adds the jump vector [0, Y, 0] to the acceleration vector.<br>You know that the SPACE key makes the ball jump, so you can infer that whatever part of the code uses the SPACE key will involve the jump force or at least give you some clue of where it is used.<br>The part is this:<br><pre class=code>		If KeyHit(57)
			
			TFormVector 0,5,0,c\e,0
			
			c\ax#=c\ax+TFormedX()
			c\ay#=c\ay+TFormedY()
			c\az#=c\az+TFormedZ()			
									
		EndIf</pre><br>That TFormVector line is forming a 3D vector [0, 5, 0], a strictly vertical vector. This is the jump vector that is added to the motion of the ball.<br>The "5" value is then the magnitude (the "strength") of the vector.<br>Therefore, in place of the "5" you can write the name of a constant such as "JUMP_FORCE," and at the beginning of the program write something like...<br><br><b>Const JUMP_FORCE# = 1.0</b><br><br>...so it is easier to modify and make more realistic.<br>The TFormVector line will become "TFormVector( 0, JUMP_FORCE, 0, c\e, 0 )." <br><br></td></tr></table><br>
<a name="1221703"></a>

<a name="1221704"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Kryzon. Ok, guys. Gravity / jumping works now. The problem I have run into now is that I cannot seem to "accurately" do a linepick to the floor in order to detect whether or not the player is "onground". The linepick code I created sorta' works, but when I start to move the ball for some reason it doesn't let me jump even though "onground" = 1... Here's what I have so far for the jump / collision functions: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global gravity#=-0.010
Global JUMP_FORCE# = 0.8

Global lp

Global lp_x#
Global lp_y#
Global lp_z#

Global onground = 1

Function ballnew.ball(x#,y#,z#,size#=1,bounce#=0.9)
	
	c.ball=New ball
	
	c\x#=x#
	c\y#=y#
	c\z#=z#
	
	c\size=size
	
	c\bounce#=bounce#
	
	c\e=CreatePivot()
		
	c\sphere=CreateSphere(32)
	
	c\pivot=CreatePivot()
	
	EntityType c\e,ball_col
	EntityPickMode c\e, 2, 1
	EntityRadius c\e,c\size
	
	PositionEntity c\e,c\x,c\y,c\z
	ScaleEntity c\sphere,c\size,c\size,c\size
	
	EntityTexture c\sphere,texture
	
	Return c
	
End Function

Function ballupdate()
	
	For c.ball=Each ball
	
			
		c\vy#=c\vy#+gravity#
		
		c\vx#=c\vx#+c\ax#
		c\vy#=c\vy#+c\ay#
		c\vz#=c\vz#+c\az#
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		TranslateEntity c\e,c\vx,c\vy,c\vz	
	
	Next
	
	UpdateWorld()
		
	For c.ball=Each ball
	
		;c\bounce# = 0.0
	
		;correct velocity if collided
		c\vx2=(EntityX(c\e)-c\x)
		c\vy2=(EntityY(c\e)-c\y)
		c\vz2=(EntityZ(c\e)-c\z)
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		PositionEntity c\sphere,c\x,c\y,c\z
		PositionEntity c\pivot,c\x,c\y,c\z
		
		;Stop infinite jumping / jumping in air (this does not include ramps which make you fly into the air)
		;If you're on a ramp and happen to fly in the air, you still can't jump in the air, but onground does = 0 anyway

			lp = LinePick(0, EntityY#(c\e, 1), 0, 0, -3, 0)
					
			lp_x# = PickedX#()
			lp_y# = PickedY#()
			lp_z# = PickedZ#()
				
			If lp And EntityCollided(c\e, world_col) Then onground = True: Else: onground = False
		
		;End Infinite Jumping
		
		;Allow the ball to bounce / roll and allow for collision(s) with object(s)
		;Also slow the ball down due to friction
		If EntityCollided(c\e,world_col)
				
			For i = 1 To CountCollisions(c\e)
				; Get the normal of the surface which the entity collided with. 
				Nx# = CollisionNX(c\e, i) 
				Ny# = CollisionNY(c\e, i) 
				Nz# = CollisionNZ(c\e, i) 
				
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
				VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
				
				; Calculate the normal force. 
				NFx# = -2.0 * Nx# * VdotN# 
				NFy# = -2.0 * Ny# * VdotN# 
				NFz# = -2.0 * Nz# * VdotN# 
				
				; Add the normal force to the direction vector. 
				c\vx# = c\vx# + NFx# * c\bounce#
				c\vy# = c\vy# + NFy# * c\bounce#
				c\vz# = c\vz# + NFz# * c\bounce#

				avx#=EntityPitch(c\sphere)
				avy#=EntityYaw(c\sphere)
				avz#=EntityRoll(c\sphere)

				;Rotate stuff
				;Get vector from center to collision
				dx1#=(CollisionX(c\e,i)-c\x)
				dy1#=(CollisionY(c\e,i)-c\y)
				dz1#=(CollisionZ(c\e,i)-c\z)
				
				dx2#=c\vx
				dy2#=c\vy
				dz2#=c\vz
				
				;Cross product
				cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
				cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
				cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
															
				AlignToVector c\pivot,cx,cy,cz,1
																									
			Next
			
			Nx# = CollisionNX(c\e, 1) 
			Ny# = CollisionNY(c\e, 1) 
			Nz# = CollisionNZ(c\e, 1) 				
					
			AlignToVector c\e,Nx#,Ny#,Nz#,2,0.5
			
			c\vel#=Sqr(c\vx2*c\vx2+c\vy2*c\vy2+c\vz2*c\vz2)
						
			;slow down due to friction
			c\vx#=c\vx*0.98
			c\vy#=c\vy*0.98
			c\vz#=c\vz*0.98

		EndIf

		EntityParent c\sphere,c\pivot
								
			TurnEntity c\pivot,-c\vel#*(180/Pi)/c\size#,0,0
		
		EntityParent c\sphere,0

		c\ax#=0
		c\ay#=0
		c\az#=0	
		
	Next
	
End Function</textarea><br><br>Also, when you jump, wait til' you hit the floor, then quickly move towards an object you can collide with, the ball slowly "climbs up the object" and into the air. How do I fix this?<br><br>Thanks alot for all your help guys! :)<br><br>~GW <br><br></td></tr></table><br>
<a name="1221717"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can anyone help please?<br><br>Thank You all! <br><br></td></tr></table><br>
<a name="1221742"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> The code you've posted doesn't include anything relating to a jump?!<br><br>Remove the linepick - it's unecessary as you already gather collision information later in the code.  An entity is on the ground if the collision normal y components is positive.<br><br>Add OnGround as a field within ball type.<br><br>Within the collision code just add the parts which refer to Onground below:<br><br><pre class=code>
c\OnGround = False

If EntityCollided(c\e,world_col)
				
	For i = 1 To CountCollisions(c\e)
		; Get the normal of the surface which the entity collided with. 
		Nx# = CollisionNX(c\e, i) 
		Ny# = CollisionNY(c\e, i) 
		Nz# = CollisionNZ(c\e, i) 
		
		;is the entity on the ground
		If Ny &gt; 0 c\OnGround = True
				
		; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
		VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
		
		; Calculate the normal force. 
		NFx# = -2.0 * Nx# * VdotN# 
		NFy# = -2.0 * Ny# * VdotN# 
		NFz# = -2.0 * Nz# * VdotN# 
				
		; Add the normal force to the direction vector. 
		c\vx# = c\vx# + NFx# * c\bounce#
		c\vy# = c\vy# + NFy# * c\bounce#
		c\vz# = c\vz# + NFz# * c\bounce#

		avx#=EntityPitch(c\sphere)
		avy#=EntityYaw(c\sphere)
		avz#=EntityRoll(c\sphere)

		;Rotate stuff
		;Get vector from center to collision
		dx1#=(CollisionX(c\e,i)-c\x)
		dy1#=(CollisionY(c\e,i)-c\y)
		dz1#=(CollisionZ(c\e,i)-c\z)
				
		dx2#=c\vx
		dy2#=c\vy
		dz2#=c\vz
				
		;Cross product
		cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
		cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
		cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
															
		AlignToVector c\pivot,cx,cy,cz,1
																									
	Next
</pre><br><br>Then just use the c\Onground to determine whether a jump is possible.<br><br>Stevie <br><br></td></tr></table><br>
<a name="1221880"></a>

<a name="1221881"></a>

<a name="1221882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Stevie! It works GREAT! Thanks ALOT! I do have one small quarrel though. Why won't the code let me jump when my ball is rolling on the ground, but only lets me jump when the ball is not moving at all?<br><br>ballcontrol() &amp; ballupdate() functions: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type ball

	Field e ;entity
	
	Field sphere
	
	Field pivot
	
	Field x#,y#,z# ; position in 3d-space
	
	Field vx#,vy#,vz# ; velocity
	
	Field ax#,ay#,az# ; acceleration
	
	Field size#
	
	Field bounce# ; bounce factor
	
	Field vel#
	
	Field vx2#,vy2#,vz2# ; temp velocity
	
	Field OnGround

End Type

Function ballupdate()
	
	For c.ball=Each ball
	
			
		c\vy#=c\vy#+gravity#
		
		c\vx#=c\vx#+c\ax#
		c\vy#=c\vy#+c\ay#
		c\vz#=c\vz#+c\az#
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		TranslateEntity c\e,c\vx,c\vy,c\vz	
	
	Next
	
	UpdateWorld()
		
	For c.ball=Each ball
	
		;c\bounce# = 0.0
	
		;correct velocity if collided
		c\vx2=(EntityX(c\e)-c\x)
		c\vy2=(EntityY(c\e)-c\y)
		c\vz2=(EntityZ(c\e)-c\z)
		
		c\x#=EntityX(c\e)
		c\y#=EntityY(c\e)
		c\z#=EntityZ(c\e)
		
		PositionEntity c\sphere,c\x,c\y,c\z
		PositionEntity c\pivot,c\x,c\y,c\z

		c\OnGround = False

		;Allow the ball to bounce / roll and allow for collision(s) with object(s)
		;Also slow the ball down due to friction
		If EntityCollided(c\e,world_col)
					
			For i = 1 To CountCollisions(c\e)
					
				; Get the normal of the surface which the entity collided with. 
				Nx# = CollisionNX(c\e, i) 
				Ny# = CollisionNY(c\e, i) 
				Nz# = CollisionNZ(c\e, i) 
						
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with. 
				VdotN# = c\vx#*Nx# + c\vy#*Ny# + c\vz#*Nz# 
						
				; Calculate the normal force. 
				NFx# = -2.0 * Nx# * VdotN# 
				NFy# = -2.0 * Ny# * VdotN# 
				NFz# = -2.0 * Nz# * VdotN# 
						
				; Add the normal force to the direction vector. 
				c\vx# = c\vx# + NFx# * c\bounce#
				c\vy# = c\vy# + NFy# * c\bounce#
				c\vz# = c\vz# + NFz# * c\bounce#
		
				avx#=EntityPitch(c\sphere)
				avy#=EntityYaw(c\sphere)
				avz#=EntityRoll(c\sphere)
		
				;Rotate stuff
				;Get vector from center to collision
				dx1#=(CollisionX(c\e,i)-c\x)
				dy1#=(CollisionY(c\e,i)-c\y)
				dz1#=(CollisionZ(c\e,i)-c\z)
						
				dx2#=c\vx
				dy2#=c\vy
				dz2#=c\vz
						
				;Cross product
				cx# = ( dy1 * dz2 ) - ( dz1 * dy2 ) 
				cy# = ( dz1 * dx2 ) - ( dx1 * dz2 ) 
				cz# = ( dx1 * dy2 ) - ( dy1 * dx2 ) 				
																	
				AlignToVector c\pivot,cx,cy,cz,1
																											
			Next
					
			Nx# = CollisionNX(c\e, 1) 
			Ny# = CollisionNY(c\e, 1) 
			Nz# = CollisionNZ(c\e, 1) 				
							
			AlignToVector c\e,Nx#,Ny#,Nz#,2,0.5

			;Is the entity on the ground
			If Ny# &gt; 0.0 c\OnGround = True
					
			c\vel#=Sqr(c\vx2*c\vx2+c\vy2*c\vy2+c\vz2*c\vz2)
								
			;slow down due to friction
			c\vx#=c\vx*0.98
			c\vy#=c\vy*0.98
			c\vz#=c\vz*0.98
	
		EndIf

		EntityParent c\sphere,c\pivot
								
		TurnEntity c\pivot,-c\vel#*(180/Pi)/c\size#,0,0
		
		EntityParent c\sphere,0

		c\ax#=0
		c\ay#=0
		c\az#=0	
		
	Next
	
End Function

Function ballcontrol()
	
	For c.ball=Each ball

		If KeyHit(57)
		
			If c\OnGround = True
		
				TFormVector 0,0.75,0,c\e,0
		
				;c\ax#=c\ax+TFormedX()
				;c\ay#=c\ay+TFormedY()
				;c\az#=c\az+TFormedZ()

				c\ax#=TFormedX()
				c\ay#=TFormedY()
				c\az#=TFormedZ()
						
			EndIf
		
		EndIf
		
		If KeyDown(200)

			If c\OnGround = True
			
				TFormVector 0,0,0.03,c\e,0
				
				c\ax#=TFormedX()
				c\ay#=TFormedY()
				c\az#=TFormedZ()
				
			Else
			
				TFormVector 0,0,0.003,c\e,0
				
				c\ax#=TFormedX()
				c\ay#=TFormedY()
				c\az#=TFormedZ()
				
			EndIf
			
		EndIf
		
		If KeyDown(208)
			
			c\vx=c\vx*0.94
			c\vy=c\vy*0.94
			c\vz=c\vz*0.94
			
		EndIf

		If KeyDown(203)

			TurnEntity c\e,0,2,0

		EndIf

		If KeyDown(205)

			TurnEntity c\e,0,-2,0

		EndIf

	Next

End Function</textarea><br><br>Thanks alot to ALL of you for your help! I really appreciate it! :)<br><br>~GF <br><br></td></tr></table><br>
<a name="1221885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> You are overwriting the acceleration each time you move.  You need to make it accumulative within the ballcontrol function:<br><br><pre class=code>
Function ballcontrol()

	For c.ball=Each ball
	
		If KeyHit(57)
		
			If c\OnGround = True

				TFormVector 0,0.75,0,c\e,0
				c\ax = c\ax + TFormedX()
				c\ay = c\ay + TFormedY()
				c\az = c\az + TFormedZ()

			EndIf
		
		EndIf
		
		If KeyDown(200)

			If c\OnGround = True
			
				TFormVector 0,0,0.03,c\e,0
				c\ax = c\ax + TFormedX()
				c\ay = c\ay + TFormedY()
				c\az = c\az + TFormedZ()
				
			Else
			
				TFormVector 0,0,0.003,c\e,0
				c\ax = c\ax + TFormedX()
				c\ay = c\ay + TFormedY()
				c\az = c\az + TFormedZ()
				
			EndIf
			
		EndIf
		
		If KeyDown(208)
			
			c\vx=c\vx*0.94
			c\vy=c\vy*0.94
			c\vz=c\vz*0.94
			
		EndIf

		If KeyDown(203)

			TurnEntity c\e,0,2,0

		EndIf

		If KeyDown(205)

			TurnEntity c\e,0,-2,0

		EndIf

	Next

End Function
</pre> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
