<!DOCTYPE html><html lang="en" ><head ><title >View/Rewrite LoadTexture's Code</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >View/Rewrite LoadTexture's Code</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >View/Rewrite LoadTexture's Code</a><br><br>
<a name="1026555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Doktor Zeus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I've been hammering away at code for several days now, and I've come to the conclusion that there is no way to use Blitz's standard internal commands to create the results I want. The sad thing is the alteration I want to make is actually pretty small and simple. I want to rewrite Blitz's "LoadTexture" command so that it can do so directly from a filestream instead of needing to receive a single, standard encoded file. Using Blitz's internal commands is far too slow for the job.<br><br>See, the problem I'm getting is this. I can save a texture to a stream by reading each pixel's RGBA value and saving it as an integer, but this suffers from two problems. Firstly, it is very slow when compared to LoadTexture. The fastest routine I've found that performs the function is three times slower, and my specialised routine that does everything I need is nine times slower (which doesn't even make sense seeing as it's actually a much simpler version). Either way, both methods are unsuitable, and both methods also result in very large files. Ideally what I'd like to do is chain a series of PNG format images together into one big file with a simple index file header, then load each image individually from its index.<br><br>I know I could use an animtexture, but the point is I'm trying to reduce memory overheads and loading time for the operation by only loading and holding in memory the data I need, besides which it'd still be a PNG file which anyone could open and view.<br><br>Now, is there any way I can view and directly alter or ammend the LoadTexture command in its natural state so that it can take its data from specific parts of the file? Maybe using DLLs? Any resources on creating DLLs for Blitz would also be useful. <br><br></td></tr></table><br>
<a name="1026572"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no easy way to do this.<br><br>Firstly, no, there is no way to view or amend the LoadTexture function. It's precompiled, and built into the Blitz3D compiler, so no source exists in the commercial distribution for you to modify.<br><br>I can think of two possible solutions:<br><br><br>1) Write a completely independent LoadTexture function that creates a functioning Blitz3D texture object, or at any rate a DirectDrawSurface that can then be copied using Direct3D drawing functions onto a "real" Blitz3D texture. Personally I would call this <i>ridiculously</i> hard, but not impossible (MikhailV seems to have written his own loaders for FastExtension, so it can clearly be done).<br><br>There's also room for an intermediate solution here where you just create the DDS and then copy it to a native B3D texture, rather than recreating all of Blitz3D's existing functionality... maybe similar to <a href="/posts.php?topic=30480#1025547" target="_blank">this</a>?<br><br><br>2) Load the data as you would a data file, into a bank. Create a new texture; lock the buffer. Now with some clever application of Windows API functions (RTLMoveMemory) you ought to be able to copy the data from bank to buffer in a single go. Unlock buffer, free bank.<br><br>Writing directly to buffers is no faster than WritePixelFast when done pixel-by-pixel, but you might see a big speed boost if you do it in a block.<br><br><br>2) is a much easier solution - but it might not provide much of a speed boost.<br><br>EDIT: Based on the data given in the other thread, the real speed hit comes from the ReadBytes function, as RtlMoveMemory is too quick to measure, and WritePixelFast is also pretty quick. No idea why simply loading data is so much slower than using the builtin load command, but that's where the slowdown is. <br><br></td></tr></table><br>
<a name="1026688"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> 1) Write a completely independent LoadTexture function that creates a functioning Blitz3D texture object, or at any rate a DirectDrawSurface that can then be copied using Direct3D drawing functions onto a "real" Blitz3D texture. Personally I would call this ridiculously hard, but not impossible (MikhailV seems to have written his own loaders for FastExtension, so it can clearly be done). <br></div><br>Yeah, if you can interface with the texture's data buffer, that should be possible.<br><br>Here are the blitz elements structure (check the Texture): <a href="http://blitz.pp.ru/forum/showthread.php?s=&amp;threadid=203" target="_blank">Структуры блица в памяти 2</a>.<br><br>Courtesy of MikhailV. <br><br></td></tr></table><br>
<a name="1026929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Serpent</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yasha's option 2 is clearly the best.  RTLMoveMemory will copy everything over incredibly fast.  If you can get the data into a data bank the code will look like this:<br><br><pre class=code>LocBnk = CreateBank(76)  ;Bank used to get location of data in memory
MoveMemoryObjInt(LocBnk,TextureBuff,76)
Loc = PeekInt(LocBnk,72)
FreeBank LocBnk
LockBuffer TextureBuff
MoveMemoryIntObj(Loc, ImgData, BankSize(ImgData))
UnlockBuffer TextureBuff</pre><br>Where ImgData is the bank and TextureBuff is the texture buffer.<br><br>Userlibs:<br><pre class=code>.lib "Kernel32.dll"
MoveMemoryIntObj(Destination%,Source*,Length%) : "RtlMoveMemory"
MoveMemoryObjInt(Destination*,Source%,Length%) : "RtlMoveMemory"</pre> <br><br></td></tr></table><br>
<a name="1030173"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You forget one thing: writing to Videoram is much slower than writing to ordinary ram. In fact some sort of upload is peformed. Some time ago I hacked Blitz to use a Bank as an Image. Using a normal Bank is fast, but as soon as the bank pointed to Videoram, it became as slow as Writepixelfast. Still fast, but not really fast compared to moving Bulks of Memory.<br><br>What you can do is: use the Texture Flag 256 and Copyrect from Backbuffer or so to it, this is really fast. I've posted a Speed test for the Flag 256 with various Sources and Destinations some time ago, please use the search link.<br><br>No Idea on how to copy a Stream to eg. the Backbuffer. I guess writing Pixels to the Backbuffer ist faster than to a Texturebuffer, is it? <br><br></td></tr></table><br>
<a name="1030250"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Serpent</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry - my code above should be changed so that the LockBuffer is at the start of the code:<br><br><pre class=code>LockBuffer TextureBuff
LocBnk = CreateBank(76)  ;Bank used to get location of data in memory
MoveMemoryObjInt(LocBnk,TextureBuff,76)
Loc = PeekInt(LocBnk,72)
FreeBank LocBnk
MoveMemoryIntObj(Loc, ImgData, BankSize(ImgData))
UnlockBuffer TextureBuff</pre><br><br>The code I posted above actually wouldn't have worked unless the LockBuffer is moved before the memory location of the buffer is found.<br><br><div class="quote"> You forget one thing: writing to Videoram is much slower than writing to ordinary ram. <br></div><br><br>LockBuffer moves the buffer information from V-RAM to normal RAM, right?  And UnlockBuffer does the opposite.  Please let me know if I'm wrong.  This eliminates the slow V-RAM issues:<br><br>This operation is actually incredibly fast.  The upload/download from video RAM is performed quickly in LockBuffer and UnlockBuffer - in my 1024x768x32 tests a Lock/UnlockBuffer pair was less than 1ms.  The RTLMoveMemory is also incredibly fast because it is moving normal RAM to normal RAM.  In fact, I think the entire operation comes out to under 1ms.<br><br><br><div class="quote"> No Idea on how to copy a Stream to eg. the Backbuffer. I guess writing Pixels to the Backbuffer ist faster than to a Texturebuffer, is it? <br></div><br><br>Because LockBuffer moves the buffer info from V-RAM to RAM, it doesn't matter which buffer you use - they should all take just as long.  Writing the image to the BackBuffer then using CopyRect would only slow down the operation.<br><br><br><br>Either way, I'd say the code executing in under 1ms is an added bonus - either way it allows you to copy data directly from a bank into an image :).  You should be able to modify this to copy the data from streams rather than banks, but I'm not sure if a pointer to a stream is simply a pointer to a null-terminated string or whatever... <br><br></td></tr></table><br>
<a name="1030334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> LockBuffer moves the buffer information from V-RAM to normal RAM <br></div><br>What do you mean by "buffer information"? As far as I know, a texture must be uploaded to VRam by DirectX, if you want to alter parts of it, the entire Texture needs to be re-uploaded. At least as long as the Flag 256 isn't set.<br><br>I don't think Locking a buffer makes access to it faster, just more save. Correct me if I'm wrong. <br><br></td></tr></table><br>
<a name="1030341"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> the entire Texture needs to be re-uploaded <br></div><br><br>Locking the buffer creates a copy of the texture in memory that you can alter; unlocking it re-uploads that to VRAM. So you get some advantage our of using a locked buffer and Read/WritePixelFast because it doesn't have to re-upload the whole texture after each individual pixel operation the way it does with Read/WritePixel (which is why you're not allowed to draw with a locked buffer; the changes haven't been applied to the actual texture yet).<br><br>Thus, creating a buffer in normal memory with LockBuffer, and copying the data in a single memory copy operation with RtlMoveMemory, then re-uploading it with UnlockBuffer, should be faster as it also cuts out the individual data poking operations.<br><br>I think that's the idea. At any rate it works pretty well. <br><br></td></tr></table><br>
<a name="1030385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Should? :) Why did noone try this yet? Can't be that hard. Ehrm, my excuse it I haven't got admin rights right now, and I'm afraid I have to add it to a decls first. Maybe later. The idea is good, of course. <br><br></td></tr></table><br>
<a name="1030426"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Serpent</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> What do you mean by "buffer information"? <br></div><br><br>Yeah I wasn't too clear about this sry - simply the 4-byte values for the colours of the pixels.<br><br><div class="quote"> Why did noone try this yet? <br></div><br><br>I have already used a very similar approach to copy images of the screen into blitz buffers (i.e. take screenshots).  As a part of my testing, I was copying image data to banks and then into buffers, so unless I've mistyped the above code, I'm certain that it works.<br><br>One thing that I neglected to mention above though was that in order for the copy to work, the destination buffer needs to have a width that is a multiple of 16.  That is, for an image buffer or the backbuffer/frontbuffer of a 2D graphics mode.  If it is a TextureBuffer or the backbuffer/frontbuffer of a 3D graphics mode, the width needs to be a power of 2.<br><br>The simple way around the above problem (which I used) is, if the destination buffer doesn't fit the criteria I listed, simply create a new image (with a width that is a multiple of 16), copy the data to that, and then copyrect the pixels from that image to the buffer you want it to end up in.  This can be seen in my screenshot functions in the code archives.  However, I think I did something wrong regarding 3D buffers in the code (which I've neglected to update so far).<br><br><br>I think the issues with buffer widths results from some sort of interlacing at irregular widths, but I've just taken the easy way out.<br><br><br>Edit:  @jfk  you mentioned your store in V-RAM (256 flag) tests above.  As a matter of fact, that is very useful for minimising the time taken by the copyrect that you might need to use. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
