<!DOCTYPE html><html lang="en" ><head ><title >The Occlusion challenge</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >The Occlusion challenge</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >The Occlusion challenge</a><br><br>
<a name="273882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> The last real frontier in Blitz is still occlusion/vis schemes. Get cracking lads! this is something we all need so suggestions and discussion welcome! :) <br><br></td></tr></table><br>
<a name="273889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Al Mackey</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Um..  hold on.  Let me go check m-w.com.<br><br><div class="quote"> Main Entry: oc·clu·sion<br>Pronunciation: &amp;-'klü-zh&amp;n<br>Function: noun<br>Etymology: Latin occludere<br>Date: circa 1645<br>1 : the act of occluding : the state of being occluded <br></div><br><br>Wow.  That helped.  What do you mean by occlusion? <br><br></td></tr></table><br>
<a name="273895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiding Entities or triangles that are not in the camera's viewport. Can provide a great speed up and allow more detail on-screen if done correctly.<br><br>My attempt was basically to hide any entity that returned false for EntityVisible. Pretty primitive and i'm sure there are alot of drawbacks to it, but it works for what i need it. Won't really know how to go about anything more detailed :)<br><br>Another point slightly OT. When a triangle has 3 vertexs with an alpha of 0, i assume it isn't even considered for being drawn on screen? (IE. the same as using hideentity) <br><br></td></tr></table><br>
<a name="273900"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Al Mackey</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm pretty sure Blitz does this automatically to a certain degree.  I had an app where a model had all its vertices controlled by child pivots (bones in LightWave terminology).  In the first version the child pivots were unparented from the object itself and allowed to be moved independantly..  if they got too far from the object -- that is, if the original bounding box of the object was completely off screen -- the children would all disappear.  Once the parent object was moving along with its children, the disappearing bug went away.<br><br>This suggests strongly to me that Blitz does its own occlusion based on the origin and bounding box of an object. <br><br></td></tr></table><br>
<a name="273911"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats not useful. Blitz CULLS*, it doesn't occlude. This means massive overdraw on levels. For example, you go inside one of 100 buildings, walk into a room and look at the furniture.<br><br>Right now, at least half of all that will be drawn. With occlusion, you cut down on overdraw. It really is important.<br><br>* culling is a simpler removal based on what isn't immediately within the camera view. <br><br></td></tr></table><br>
<a name="273916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whats the best way to go about doing this? Obviously bounding boxes are a very good way to do it, especially if an entity is a pillar shape and is rotated 45 deg.<br><br>Can you actually cull triangles in a surface? I'd imagine there has got to be some sort of balance needed. You don't want a routine that's too processor intensive as the speed you would gain from culling would be taken up by the time it takes to calculate the culling. <br><br></td></tr></table><br>
<a name="273928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Al Mackey</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, I see...<br><br>Well, one way to do that sort of thing is to have a good typing system in place, where each room has a type entry, and each object has one too that associates it with a room..  then, keep track of which room the player is in, which rooms are visible from what other rooms, and hide any rooms (and their dependant objects) that aren't visible from the player's room.<br><br>I'm doing something like that in a game I'm working on, except the doors between rooms are always solid, so only one room has to have its objects visible at once, unless the player is moving from room to room.<br><br>I know that's not as nice as smart occlusion, but it's a quick and efficient way of making players believe that the world they're in is large and detailed. <br><br></td></tr></table><br>
<a name="273935"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sounds like a good idea, but my world is open and you can usually see most of it at the one time. <br><br></td></tr></table><br>
<a name="273945"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark did have a plan with maplet 2: he wanted maplet to be able to cull entities and polygons inside the maplet level: so maplet would actually control whats visible.<br><br>However he hasn't had time for this so I am seeking other methods. Halo and I both did a version which coloured entities and checked but it was too slow to precalculate.<br><br>Note that all useful occlusion routines will require precalculation to be effective... <br><br></td></tr></table><br>
<a name="273947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got another portal engine design in the works. It will be made public if it turns out to be at least good enough to use as I am counting on it to be faster than any of my previous attempts. I hope it turns out good because I really want to see something like this to be free for blitz community use.<br><br>The only main problem I see with using a "portal only" engine is that it's best to place portals manually in which that doesn't really bother me. I just have to build a "portal editor" for it( And there are differents ways to go about that). It should even work with Quil3D's portal stuff, hopefully, as long as it uses standard like portals(defined as 2d convex/concave shaped mesh in 3D space). Also, It should even work with Maplet if it evers gets the portal update that Mark talked about a while back.<br><br>Obviously, every portal engine is different but one thing that usually remains constant between them is the standard defined portal that a portal engine acts upon( ie: as in how it uses that manually placed portal). My current engine design takes the route of if the current room's portal is in view then render it's room ( cell or sections, whatever you want to call it ) on the other side of it. The next step it takes is if any portals in that other room is in the camera's viewing frustum and can be seen through the portal in your current room then the engine will render it's room. Ofcoarse, this is done in a recursive fashion. Actaully, one could simply skip the second step all togethor to make the engine very simple and crazly fast at the cost of level design limitations.<br><br>It follows the same principles of the first portal engine that I made in Blitz3D as seen in my link below and also with what I was doing for the Community OpenSource: Project Plasma FPS. The difference is that this time I won't be using any sort of LinePick algorithm. I just need to get my test level done( using gameSpace :P ) so I can hurry up and finish my engine. <br><br></td></tr></table><br>
<a name="273948"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >IPete2</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob,<br><br>What about the demo of Portals in the Quill package?<br><br>Do you think there is a fast way to achieve this through programming in Blitz?  Or will it be a combination of a map/level editor and Blitz?<br><br>As I understand it the BSP route requires a 'no-license required' editor and complier so unless there's a free unlicensed BSP editor/compiler available to us...  <br><br>Is there a route through Halos' format CSM and CShop?<br><br>The way Virtools does it, I believe, is to have a list for what is to be rendered, this list is culled before the final list for rendering is produced, this is all that is rendered - every frame though!?!<br><br>If this was to happen in Blitz, do you think Mark may have to 'attack the problem' from his end for the sake of speed of calculation?<br><br>IPete2. <br><br></td></tr></table><br>
<a name="273961"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Physt</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> As far as I can tell, the BSP support in Blitz renders the potentially visible set.  Normally, the potentially visiable set used as the first step in determining what is actually visible and thus rendered.  So Blitz BSP support is out...<br><br>Rob - I assume you are refering to some sort of general purpose occlusion system like that used by Renderware.<br><a href="http://www.renderware.com/partner_products.htm" target="_blank">http://www.renderware.com/partner_products.htm</a><br><br><br><br><br><div class="quote"> <br>RenderWare VisionFX <br><br>RenderWare VisionFX is an advanced visibility technology plugin that's essential if you're developing games with large and dynamic worlds. Genres that specifically benefit from VisionFX are Role-playing games, Action-adventure games, First-person combat games, Massively multi-player online games and Urban / city-based games. RenderWare VisionFX works by identifying the visible objects in a world as quickly as possible. <br><br>RenderWare VisionFX is available as a plugin or standalone product for PC, Xbox and Nintendo GameCube.<br><br>RenderWare VisionFX Features &amp; Benefits<br><br>Faster Rendering Times<br>Once RenderWare VisionFX has done its work, you continue by only drawing the visible objects. This can lead into immense savings in rendering time of up to 400%.<br><br>Faster Development Cycle <br>Development cycles become more efficient as RenderWare VisionFX calculates visibility in reducing the time required for static visibility calculation, using PVS for example. The artists creative restrictions are reduced and export processes can also become simpler and faster. <br><br>Increased Scene Richness <br>RenderWare VisionFX enables more characters and objects, with greater richness in scenes. It removes visibility-based creativity constraints so that you can make your world truly alive with interaction (e.g. deformable environments). New levels of realism can therefore be realistically achieved and larger worlds are handled with much less effort.<br><br>Increased Freedom in MMO Game Worlds <br>As RenderWare VisionFX is a real-time visibility solution, developers concerns over initial world size are greatly reduced. Developers can also allow players to introduce their own scenery (for example players homes and businesses) into the persistent world. And because RenderWare VisionFX reduces the pre-processing required for level design, expansion packs can be introduced easier and with a greater focus on the content.<br><br>Cutting Edge and Feature Rich Technology <br>RenderWare VisionFX effectively blends a number of cutting edge visibility technologies including hierarchical view culling frustum, occlusion culling, portal culling and contribution culling. RenderWare VisionFX also supports on-demand loading of scene data using the object visibility information, enabling the application to effectively stream in visibility optimized content. Other techniques such as LODs, multi-resolution geometry and image-based rendering can be used with RenderWare VisionFX for further enhancing performance and content scalability.<br><br>About RenderWare VisionFX Technology<br>RenderWare VisionFX is the first efficient general-purpose visibility optimizer that requires no scene pre-processing and works with massive dynamic environments of any topological structure. The visibility queries are output-sensitive, so the amount of time RenderWare VisionFX spends in finding the solution is dependent on the number of visible objects rather than the number of objects in the scene. RenderWare VisionFX calculates visibility in reducing the time required for static visibility calculation.<br>RenderWare VisionFX is powered by Umbra from Hybrid Graphics - The leaders in advanced solutions for real-time computer graphics.<br><br><br>Powered by Hybrid Graphics Umbra technology, VisionFX is available for PC, Xbox and NINTENDO GAMECUBE, as a plugin for RenderWare Graphics or as a standalone library.<br><br><br> <br></div> <br><br></td></tr></table><br>
<a name="273966"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a wee VERY simple demo for some vis stuff.<br><br>Press keys 1 and 2 to switch between the over head cam and the normal one. Arrow keys to move.<br><br>Doesn't take into account objects that are behind other objects.<br><br><pre class=code>
Graphics3D 800,600
SetBuffer BackBuffer()


camera=CreateCamera()

camera_overhead=CreateCamera()

PositionEntity camera_overhead,0,60,0
HideEntity camera_overhead

sphere=CreateCone()
ScaleEntity sphere,1,1,3
EntityParent camera,sphere
PositionEntity camera,0,1,0


PointEntity camera_overhead,sphere

light=CreateLight()

Type cube
	Field ent
	Field x#,y#,z#
	Field hidden
End Type


For loop=0 To 20
	c.cube=New cube
	c\ent=CreateCube()
	c\x=Rnd(-20,20)
	c\y=0
	c\z=Rnd(-20,20)
	PositionEntity c\ent,c\x,c\y,c\z
	c\hidden=0
Next


While Not KeyHit(1)



	If KeyDown(200) Then MoveEntity sphere,0,0,0.2
	If KeyDown(208) Then MoveEntity sphere,0,0,-0.2
	If KeyDown(203) Then TurnEntity sphere,0,1,0
	If KeyDown(205) Then TurnEntity sphere,0,-1,0
	
	If KeyHit(2) Then
		ShowEntity camera
		HideEntity camera_overhead
	End If
	If KeyHit(3) Then
		ShowEntity camera_overhead
		HideEntity camera
	End If
	
	Gosub checkvis
	UpdateWorld
	RenderWorld
	Flip
Wend
End

.checkvis
	For c.cube=Each cube
		If EntityInView(c\ent,camera) Then
			If c\hidden=1 Then
				ShowEntity c\ent
				c\hidden=0
			End If
		Else
			If c\hidden=0 Then
				HideEntity c\ent
				c\hidden=1
			End If
		End If
	Next
Return
</pre> <br><br></td></tr></table><br>
<a name="273967"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does EntityAlpha 0 have the same effect as hideentity? I mean except for collision dection, are they just the same? <br><br></td></tr></table><br>
<a name="273973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, the entity's polys are not passed to the render with hideentity and EntityAlpha 0. <br><br></td></tr></table><br>
<a name="273977"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good stuff! <br><br></td></tr></table><br>
<a name="273983"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Ross C: you know that blitz already does this, right? Rob is talking about occlusion, what you showed is only a clipping against the viewing frustum. <br><br></td></tr></table><br>
<a name="273985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >IPete2</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ross, <br><br>Easy when you know how eh?<br><br>btw I tried to globalise the cameras and put it into a function, works fine there too.<br><br>IPete2. <br><br></td></tr></table><br>
<a name="273987"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ross has a good step in a occlusion process. It's basically how I do it with the "rooms" of my level. Lets take these cubes for an example. Imagine those cubes connected to each other and the part on the sides that cubes touch each other are eleminated where you can run around inside them. Well, we want the cubes that are in the viewing frustum but are totatlly hidden behind other cubes not to be rendered. Thus, I would use EntityAlpha 0 on those specific cubes to keep collision data so any entities in them effected by gravity/moving around wont wonder into the void.<br><br>The EntityInView used in this case isn't just used to do what Blitz already does, but to make sure the rooms(cells, sections, or whatever) that come into camera view but not visible to your eyes to not to be rendered. That's what I see in Ross's program above. <br><br></td></tr></table><br>
<a name="273993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see what your saying Koriolis :) This is a bit of learning for me here.<br><br>@Todd<br><br>Thanks :o) Well, i think that would be the first step if i were to do occlusion, get rid of all the stuff that wasn't needed. I don't really know where to go from there. Maybe entity in view would be better, again tho it wouldn't be a very fullproof idea, as i think that everything has to be pickable and it doesn't work too well:<br><br><pre class=code>
Graphics3D 800,600
SetBuffer BackBuffer()


camera=CreateCamera()

camera_overhead=CreateCamera()

PositionEntity camera_overhead,0,60,0
HideEntity camera_overhead

sphere=CreateCone()
PositionEntity sphere,0,-1,0
ScaleEntity sphere,1,1,3
EntityParent camera,sphere
PositionEntity camera,0,1,0


PointEntity camera_overhead,sphere

light=CreateLight()

Type cube
	Field ent
	Field x#,y#,z#
	Field hidden
End Type


For loop=0 To 20
	c.cube=New cube
	c\ent=CreateCube()
	c\x=Rnd(-20,20)
	c\y=0
	c\z=Rnd(-20,20)
	PositionEntity c\ent,c\x,c\y,c\z
	c\hidden=0
	EntityPickMode c\ent,2
Next


While Not KeyHit(1)



	If KeyDown(200) Then MoveEntity sphere,0,0,0.2
	If KeyDown(208) Then MoveEntity sphere,0,0,-0.2
	If KeyDown(203) Then TurnEntity sphere,0,1,0
	If KeyDown(205) Then TurnEntity sphere,0,-1,0
	
	If KeyHit(2) Then
		ShowEntity camera
		HideEntity camera_overhead
	End If
	If KeyHit(3) Then
		ShowEntity camera_overhead
		HideEntity camera
	End If
	
	Gosub checkvis
	UpdateWorld
	RenderWorld
	Flip
Wend
End

.checkvis
	For c.cube=Each cube
		If EntityInView(c\ent,camera) Then
			If EntityVisible(camera,c\ent) Then
				If c\hidden=1 Then
					ShowEntity c\ent
					c\hidden=0
				End If
			Else
				If c\hidden=0 Then
					HideEntity c\ent
					c\hidden=1
				End If
			End If
		Else
			If c\hidden=0 Then
				HideEntity c\ent
				c\hidden=1
			End If
		End If
	Next
Return
</pre><br><br>Entities disappear even tho they can still be seen. <br><br></td></tr></table><br>
<a name="273999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about using a grid system? Placing each level item in a grid and using some 2d maths to figure out if it should be viewed or not.<br><br><pre class=code>
...t.......
.######....
.#.........
.#..p......
...........
</pre><br><br>Find out if p can see t. You would need unhide the entity one grid square before they are actually seen tho, so it doesn't pop into view. <br><br></td></tr></table><br>
<a name="274002"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I wouldn't use entity visible since it only operates on the center point of an entity. That's where portals come in handy here. Using cubes as an example, I perfect example would be how that game Descent ( 1 &amp; 2 ) used portals. Imagine two cubes next to each other where the sides that the two cubes touch share the same vertices. Instead of having polygon sides there, use that vertice data for portal data. You can imagine those sides as a portal where it's now invisible. Say we are standing in one cube and the side that is now a portal is in our camera's viewing frustum. So with preconfigured portal data, the engine would take the portal data from that portal we see in view and display the cube that is next to the cube we are standing in.<br><br>Edit: didn't see above post. But, what you said above with your grid stuff can be done with a "trigger box". You can select all rooms that can be seen from one room manually or find some complex pre-calculation to do it for you. Then have a "box" or something in the doorways of each cube ( or room ) and set states to AlphaEntity 0 or 1 other rooms when you walk/run through them. But that wouldn't be precise as portals are. And ofcoarse you can go the BSP route as stated below. <br><br></td></tr></table><br>
<a name="274003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> The Singularity engine now splits the world up into single faces, each with a mesh and a plane equation.  Compiling the BSP isn't that hard, you just check which side of the plane a wall is on, then go to that wall and repeat with another unassigned wall.  There are a couple of things I have to do before it's really functional. <br><br></td></tr></table><br>
<a name="274007"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think this stuff maybe a wee bit too advanced for me right now. But i'll give some of the suggestions a try. Thanks for your help ppl! <br><br></td></tr></table><br>
<a name="274012"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> np ... ofcoarse this is not just about portal's and bsp's, if you find another solution, the community would be grateful if you decided to share the knowledge. Good luck! :) <br><br></td></tr></table><br>
<a name="274016"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> cheers :) <br><br></td></tr></table><br>
<a name="274020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RockStar: wouldn't having each face as a single mesh compltetly defeat the purpose? Todays card are a lot more comforable drawing 1,000,000 polygons in a shot than 1000 series of 1000 polygons, not to say 1,000,000 serie of one single polygon. Gfx card really don't like frequent state changes.<br>That's why blitz doesn't handle a lot of surfaces very well, and is also the reason why in Quake 3 (or is it Doom3?) the BSPs are not used any more for rendering, but only for collisions purpose.<br><br>I *think* for todays cards the best is to use some lazy occlusion system with octrees or something similar. BSPs are just not very well suited for high poly count levels (they generate a lot of additional faces due to splitting, and in addition the PVS size increases very fast with the poly count increase).<br>Any thougts on this? <br><br></td></tr></table><br>
<a name="274058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Blackledge</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> "I wouldn't use entity visible since it only operates on the center point of an entity" - ?<br>Pardon?<br>I have implemented the previously suggested 'If Not EntityVisible then HideEntity' type code.<br>I have huts which as I turn appear at the side of the screen, as you would expect, but the centre point of the entity is still offscreen.... <br><br></td></tr></table><br>
<a name="274082"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Strange, the docs say that with a mesh EntityInView checks the bounding box of the entity for visibility.<br><br>I don't see this happening, it only appears to use a point, maybe we have to set up EntityBox but the example in the online docs doesn't.<br><br>I'll have to try this at home since I'm at work atm. <br><br></td></tr></table><br>
<a name="274087"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> EntityVisible ( src_entity,dest_entity )<br><br>When the last time I played around with it, it uses the center point of an entity to see if they can "see" each other or not if another entity is obscuring the view between them. In this case, I'm referring to being inside cubes( image their faces inverted inwards as if you are walking around inside of an indoor level) that are connected to each other as where the sides that touch each other are gone. If I use EntityVisible to see if another cube is visible, you can easliy be in a positon where you can see another part of a paticular cube, but the center of it could be behind another cube. That second piece of code RossC shared with us showed by using the EntityVisible command that his cubes where showing and dissappearing only when the center of those cubes where being obscured from another cube.<br><br>Sorry if I didn't make myself clear. <br><br></td></tr></table><br>
<a name="274180"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> EntityVisible uses the centerpivot of a mesh. EntityInView uses the bounding box. <br><br></td></tr></table><br>
<a name="274342"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bradford6</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> the point is...<br><br>an octree/bsp style occlusion scheme is necessary for most 3d game levels. <br><br></td></tr></table><br>
<a name="274362"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep. I agree, occlusion will also allow some massive polygon game worlds to be present but because of the occlusion you will only need to render a small part of that game world, hence a small number of polys ( or entities ).<br><br>A technique I'm working on at the moment which is suitable for indoor game worlds is doing all the occlusion in a pre-processed fashion using manually placed portals. You can store all the vis data in a list ( adjacency list ). Each element of the list could be a seperate entity ( room for eg. ) that stores adjacency info ( that is other entities that are visible from this one ). Then, in game, look at what entity the player is in and refer to the adjacency list to render the other potential visible rooms. Blitz will cull entities out of camera shot for you. It would be quicker to access a memory data than doing all those EntityInView/EntityVisible ( internal matrix bashing ) checks.<br><br>Food for thought :) <br><br></td></tr></table><br>
<a name="274368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Physt</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Isn't occlusion somewhat seperated from culling using octrees and bsp's?<br><br>One could use an occlusion step afer getting the potentially visiable set from the octree or bsp. then It would figure out what needs to be drawn and what is behind something else and therefore doesn't need to be drawn.<br><br>A good general purpose occlusion system would allow you throw abritray geometry at it and it would only draw what was visible.  I know it sounds like the holy grail but such systems exist. <br><br></td></tr></table><br>
<a name="274392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, occlusion is done AFTER octree/bsp culling.<br><br>You do your culling then you end up with a list of entities which are visible/partially visible or occluded by other entities in the scene.<br><br>In Blitz we don't really go down to the triangle level when rendering so I think what we are after is an occlusion technique which is just for whole entitities/meshes.<br><br>I've yet to actually need an occlusion system like this though, since graphics cards are so fast these days the octree/bsp/portal culling is enough to get the polycount down to a reasonable level.<br><br>I don't think most of us actually need it...that doesn't make it any less interesting to talk about though =) <br><br></td></tr></table><br>
<a name="274414"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Physt</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://www.gamasutra.com/features/19991109/moller_haines_01.htm" target="_blank">http://www.gamasutra.com/features/19991109/moller_haines_01.htm</a> <br><br></td></tr></table><br>
<a name="274491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have got to be kidding shambler. You're basically saying that I can't be allowed to put 10x the detail into my levels so it runs well on anything like my sys specs! <br><br></td></tr></table><br>
<a name="274497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> So for us to have occlusion at the triangle level it really does need to be built into the Blitz rendering pipeline. Correct me if I'm wrong, but it looks like blitz just throws the entities ( not Terrains or BSPs ) into the render engine which only culls away complete entities outside the view frustum, I'm sure that Blitz leaves Direct3D to hide the back facing polys ( hence you dont get a true TrisRendered() ).<br><br>Another thing to mention is that say for example we go for an 'entity culled occlusion' which most are getting to work, we mustn't forget that the game still goes on in 'culled sections' of the game so if we are using HideEntity then that entity is no longer involved in the collision engine - EntityAlpha will still be involved in collisions. <br><br></td></tr></table><br>
<a name="274506"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >IPete2</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> So how many vertices is 117,800+ triangles?<br><br>Because that's how many I've got rendering currently with a camera range of about 15,500.<br><br>I know occlusion would help us keep the frame rate up (it's about 20 fps at the moment on an Athlon 2200, with a 64 MB nVidia GeForce 4), but I think Blitz does pretty well to handle this size of a level!<br><br>IPete2. <br><br></td></tr></table><br>
<a name="274510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> No one is knocking blitz at its rendering speed. I'm sure most would agree that Blitz does do a great job. But with some sort of occlusion, 60fps wouldn't be impossible - instead of your 20fps. Great visuals moving smooth and great visuals moving jerky can/will make or break a title. <br><br></td></tr></table><br>
<a name="274515"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm pretty sure my hardware wouldn't even be able to play ipete's game :) <br><br></td></tr></table><br>
<a name="274531"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> One major performance bottleneck with Blitz is that it uses the old DirectX Retained mode.<br><br>This means where I could be getting 40 million triangles per second with certain geometry, I only get 5-10 million, thats a huge performance hit.<br><br>I used the same mode when I started programming with C++ but soon found that to get really fast rendering you had to use immediate mode, alot harder to program but giving you more control and speed at the same time.<br><br>Other than the occlusion commands currently available in Blitz I don't see us gaining much more performance with more complex methods of occlusion.<br><br>The overhead of going down to triangle level and calculating occlusion will be greater than just throwing the mesh at the graphics card to render.<br><br>On a similar note,one thing you could do to gain some performance is render entities from closest to farthest away so you get a performance gain from the Z buffer by reducing overdraw...not sure if Blitz already does that, would need a test =) <br><br></td></tr></table><br>
<a name="274537"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just a side note: Mark Sibly himself corrected me when I said something about blitz3d was using DX7's Retained Mode. He said he is using immediate mode with his own retain mode design. <br><br></td></tr></table><br>
<a name="274706"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Funny how people assume :) <br><br></td></tr></table><br>
<a name="274715"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, assuming always comes back and bites me in the arse. <br><br></td></tr></table><br>
<a name="274762"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Not Available</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry for the cross post - but this is more relevant here:<br><br>I remember doing some stuff with this a while ago, no for culling, but to see whether I had to animate/procedural texture an object only when it was in view - I checked first EntityVisible for the object and then EntityInview for the object if they were both true then we were in business otherwise it didn't matter. How I got decent performance was to run the visibility check every 66 millisecs (why that magic number I can't remember... not documented in the source)... <br><br>But onto triangle level stuff...<br><br>The Ray_Intersect_Triangle, and Ray_Intersect_Mesh functions in the code archives could be useful for doing triangle level occulsion (coded in C++ in a DLL would be the way to go), again - I'd limit just how much removal the occulsion it could do in it's time (ie. a limit of say 30 ms per occulsion run) in addition to making it force the occusional full run. I'd also make a copy of the original object before I started removing triangles and add some velocity to camera rotates &amp; movement so I could predict whether an object was going to be coming back into full view and use the original copy. Also, depending on how complex the scene was - I'd probably think about storing copies of the occluded mesh at various stages so that they could be re-used without re-occulsion if that makes sense.<br><br>eg. just off the top of my head:<br><br>Complex mesh in middle of screen<br>do<br>    cursor left adds velocity to camera rotation<br>    predict worst case scenario (ie. if you took your finger off the key now, what is the x,y,z,rx,ry,rz of the camera - project a box from the camera out to the viewdistance (this is used for a boolean)<br><br>    trace ray from center camera to four corners of object (or more)<br>    if none are visible then hide object<br> <br>   on next removal call (ie. every N millisecs)<br>    remove triangles based on worst case scenario<br>    via a boolean subtraction of the object - inverse of the box<br>    (the inverse box is like a big cube with a hole in the middle that the camera looks through, everything outside of the hole is subtracted at a triangle level)<br> <br>loop<br><br>I would use a similar method to cull objects partially obscured by other objects - by doing an extrude from the backfaces of an object in a direction paralell to the cameras vector, extrude object to viewdistance, subtract it from any objects it intersects.<br><br>We all know about how to do this stuff with trees etc, however I'd be interested to code the boolean subtraction stuff and see how it performs... again it would need to be in a .DLL for speed I think, but a prototype in B3d would be the way to go initially.<br><br>Just some ideas; I don't really have a need for this sort of thing at the moment; however I will in the next 6 months - if I crack the code I'll share...<br><br>-R<br><br>p.s. be forgiving - i'm just banging this out quickly to seed some ideas - and i'm exhausted ;) <br><br></td></tr></table><br>
<a name="274768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, moving back a bit in the post. I think blitz is doing something with those entities that aren't on screen. Hiding them is pretty important i think, cause i get a fair speed up if there hidden. This code only hides entities that aren't in the viewport.<br><br>Again, key 1 for the normal camera, key 2 for the overhead, arrow keys to move. This time, key 3 for none hiding mode and key 4 for hiding mode.<br><br>If you move to the end of the cubes, then turn and don't face them, try each mode. You'll see you get a fair increase. Try about 400 - 2000 cubes.<br><br><pre class=code>
num_cubes=Input("How many cubes?")

Graphics3D 800,600
SetBuffer BackBuffer()



camera=CreateCamera()

camera_overhead=CreateCamera()

PositionEntity camera_overhead,0,60,0
HideEntity camera_overhead

sphere=CreateCone()
PositionEntity sphere,0,-1,0
ScaleEntity sphere,1,1,3
EntityParent camera,sphere
PositionEntity camera,0,1,0


PointEntity camera_overhead,sphere

light=CreateLight()

Type cube
	Field ent
	Field x#,y#,z#
	Field hidden
End Type


For loop=0 To num_cubes
	c.cube=New cube
	c\ent=CreateCube()
	c\x=Rnd(-80,80)
	c\y=0
	c\z=Rnd(-80,80)
	PositionEntity c\ent,c\x,c\y,c\z
	c\hidden=0
	EntityPickMode c\ent,2
	EntityColor c\ent,100,100,255
Next

mode=0;0 for none vis,  1 for vis

While Not KeyHit(1)



	If KeyDown(200) Then MoveEntity sphere,0,0,0.2
	If KeyDown(208) Then MoveEntity sphere,0,0,-0.2
	If KeyDown(203) Then TurnEntity sphere,0,1,0
	If KeyDown(205) Then TurnEntity sphere,0,-1,0
	
	If KeyHit(2) Then
		ShowEntity camera
		HideEntity camera_overhead
	End If
	
	If KeyHit(3) Then
		ShowEntity camera_overhead
		HideEntity camera
	End If
	
	If MilliSecs()&lt;timer+1000 Then
		frame=frame+1
	Else
		fps=frame
		frame=0
		timer=MilliSecs()
	End If
	
	If KeyHit(4) Then mode=0:Gosub showall
	If KeyHit(5) Then mode=1
	
	If mode=1 Then
		Gosub checkvis
	End If
	UpdateWorld
	RenderWorld
	Text 0,0,"fps="+fps+" mode="+mode
	Text 0,10,"Key(3) mode 0= no hiding of entities that aren't in the cameras viewport
	Text 0,20,"Key(4) mode 1= hide all entities that aren't in the camera viewport
        Text 0,30,"Polys="+TrisRendered()
	Flip 0
Wend
End

.checkvis
	For c.cube=Each cube
		If EntityInView(c\ent,camera) Then
				If c\hidden=1 Then
					ShowEntity c\ent
					c\hidden=0
				End If
		Else
			If c\hidden=0 Then
				HideEntity c\ent
				c\hidden=1
			End If
		End If
	Next
Return

.showall
	For c.cube=Each cube
		ShowEntity c\ent
		c\hidden=0
	Next
Return
</pre> <br><br></td></tr></table><br>
<a name="274789"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Physt</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://www.realtimerendering.com/" target="_blank">http://www.realtimerendering.com/</a><br><br>Manual has a large section on dynamic occlusion culling<br><a href="http://www.hybrid.fi/dpvs_download.html" target="_blank">http://www.hybrid.fi/dpvs_download.html</a> <br><br></td></tr></table><br>
<a name="274795"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ross, I agree 100% with you without even having to look at your new code there. I used that fact with my previous portal systems. I don't know why some people don't get that. Hopefully with your code above, they will now.<br><br>Edit: Yup, thats a good example. <br><br></td></tr></table><br>
<a name="275021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mustang</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I think blitz is doing something with those entities that aren't on screen. Hiding them is pretty important i think, cause i get a fair speed up if there hidden. <br></div><br><br>Hiding entities is important at least if you have collisions set up:<br><br><a href="http://www.blitzbasic.co.nz/b3ddocs/command.php?name=HideEntity&amp;ref=3d_cat" target="_blank">http://www.blitzbasic.co.nz/b3ddocs/command.php?name=HideEntity&amp;ref=3d_cat</a><br><br>...So even just for this purpose you should hide stuff that's not on the screen preferably?<br><br>For my own game I will try room node occlusion, ie have one "root null" which will act as a base for EVERY static object in the room (wall parts, doors, chairs, pipes, boxes, dead monsters etc) and then construct somekind of list of node visibility (node-to-node). <br><br>Hiding the "root null" will automatically hide every child object too, and I can also add objects to that group (null) easily runtime. Hardest part is to make the visibilty list, so far I have no idea how to make it automatic. I'm NOT aiming polygon perfect occlusion, is useless... object based occlusion is enough for me. <br><br></td></tr></table><br>
<a name="275027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Occlusion is *hard*!<br><br>Some observations from experiments I've done:<br><br>(1) Hardware evolution shifts the goalposts. I have seen many occlusion demos (including, I think, some from the system  renderware uses) where the demos were faster with occlusion turned off! I imagine that when they were written they were pretty quick, but hardware T&amp;L has changed the situation quite a bit. Hardware likes to be given a decent chunk of polys at once, which tends to conflict with...<br><br>(2) Occlusion must be done accurately or not at all - close enough is not good enough. As soon as you get a bit too 'generous' with an occlusion algorithm, the effect ripples and you get an exponential slowdown.<br><br>(3) There is no one solution. Most modern occlusion algorithms work based on the assumption the geometry is 'highly occluded indoor scenery', but take things outdoors and such algorithms die. Doesn't matter to Carmack as he obviously doesn't go outdoors much, but for a generic game creation package it sucks a bit. Its probably a necessary evil though...<br><br>(4) Portals are tricky. The idea is neat - create a temporary 'frustum volume' using the viewpoint and a portal poly and clip further portals to it recursively - but the complexity is exponential. For example, if an average sector has just 3 portals, then each time you traverse another sector you are cubing the amount of work required.It doesn't take many sectors for this to blow up. It then becomes tempting to increase the size of sectors, but again, you start running into problems with (2) above!<br><br>(5) Should we even be bothering? While I was writing Maplet, I was unable to come up with a level that slowed down my hunble GeForce2. Hardware is hugely faster now and will continue to improve. Sure, there will always be a scene complex enough where occlusion is a 'win', but how much effort will be required to generate such a scene?<br><br>So...perhaps we should be thinking LOD instead of occlusion? <br><br></td></tr></table><br>
<a name="275030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOD in indoor scenes? Ok, what about if you are at one end of a large indoor level and an AI Bot is at the other end of the large level. If you try to use LOD on the polys furthest away from you in an indoor level, I can only imagine the nightmares on trying to keep animated moving entities effected by collisions and gravity inside the level.<br><br>Portals, yes it adds up when there are more portals in each room to check on. But, it's how quick the method of working with portals which is key here. Portals used with sections( rooms, cells, whateva... ) of a level doesn't need to be 100% accurate. If I can get over my programmer's block thing I'm going through at the moment, I'll have a demo with source to show what I mean out here, hopefully, soon. <br><br></td></tr></table><br>
<a name="275031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I'm talking purely rendering here...physics is another problem altogether!<br><br>As for portals, the method had better be damned quick, because you are likely to be processing hundreds of portals in even a moderate scene. No matter how you look at it, the complexity of 'the classic' portal algorithm is great, which is not to say there aren't more efficient variations... <br><br></td></tr></table><br>
<a name="275032"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark, no offense, but the Maplet levels I have seen aren't exactly UT2003.  Some of us ARE pushing that many polys.  I have maps that will make my GEForce4 crawl without occlusion.  I think this is one instance when it would be good to commit to one method and lay down some rules, instead of trying to make Blitz3D completely nonspecific.<br><br>Incidentally, there isn't even an efficient way of implmenting BSP into the rendering, since the speed gained by the BSP occlusion would be fighting the speed lost by having every face a separate surface. <br><br></td></tr></table><br>
<a name="275034"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>No problems, Mr Rockstar!<br><br>But...where are these levels? Can you post a .X model?<br><br>[edit]<br>When I was writing the original occlusion engine, I put a call out for level models to test it with.<br><br>There were 2 problems with the stuff people sent me:<br><br>1) They had terrible geometry - flipped polys, coplanar polys etc etc. This made them hard to process.<br><br>2) None of them slowed down my card! I dutifully spent time trying to algorithmically clean up the models, and learned a lot in the process, but I was always nagged by the 'why am I doing this, they run OK as-is?' thing!<br><br>Point 1 lead me to write Maplet - which ONLY generates 'correct' geometry. Point 2 lead me to make Maplet as simple as it is.<br><br>This is not a 'Blitz is so great we don't need occlusion' rant - its more a 'brute force is getting pretty brutal' thing.<br>[/edit] <br><br></td></tr></table><br>
<a name="275036"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with Halo - the expectations for level complexity are rising indeed.  I have personally worked on levels in the one million poly range and higher!!<br><br>If portals are only placed at connections between rooms, the number of them isn't that high.  I am referring to a system that requires hand placement, which some may feel is an imposition on the artist.  I would argue, however, that it is insignificant compared to building Lods for everything - inside and out! <br><br></td></tr></table><br>
<a name="275044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with these level complexity and portal placement statements. With portal placement, it's needs to be a manual placement job over an automated one... then you wont even come close to processing hundreds of portals at one time. IMHO, manual portal placement will always lead to the best optimized situations. As LT basically said, it's an extra step in building levels but not a big one. Someone else besides that actaul level creator can actaully get in with a custom editor or an option of an editor to place portals on an already built level if needed be. <br><br></td></tr></table><br>
<a name="275049"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>With portal placement, it's needs to be a manual placement job over an automated one<br> <br></div><br><br>I disagree. Manual placement will break my rule (2) above.<br><br>Yet I agree - I think the answer to a descent occlusion algorithm does lie in manual placement of portals, as this allows rule (1) above to work.<br><br>Portals may well be the answer, but the current portal algorithm is not 'right'. I've tried it. <br><br></td></tr></table><br>
<a name="275050"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> My thoughts<br><div class="quote"> <br>Incidentally, there isn't even an efficient way of implmenting BSP into the rendering, since the speed gained by the BSP occlusion would be fighting the speed lost by having every face a separate surface. <br> <br></div><br>Absolutely true when you have a single Mesh Level as a Maplet Mesh.<br><br>You might remember my afforts to use some kind of occlusion System. First I worked with a House Model that included tons of Child Meshes. I used a precalculated Visibility List for each Cluster (about some "Meters") to hide or show the Children. This gave me about 40% more Speed, but even then some people with faster Cards said the Occlusion System didn't make it faster on their Machines.<br><br>However, here is a Realtime Calculation System that is based on my Identification de Colour Unique (ICU) or unique color indentification system. It is an Adaption by Shadowturtle, Author of the Scream3D Editor. I have no idea how fast it is, but I found it pretty clever:<br><br>First all Object must be in a List. Every Loop they are colored using a unique color. It's possible to use right the List index as a Color, but this works only in 32 Bit Mode. Probably it works in 16Bit too when $F-Steps are used.<br>All Objects EntityFX are set to fullbright and Color instead of Texure Rendering. <br><br>Now the Cameraviewport is set to something very tiny, maybe 160*120 or even less.<br><br>A Renderworld is performed. Now all Objects in the List will be compared with the Pixels of the Rendered Picture. If their Color is visible, they will be shown, if not then they will be hidden.<br><br>After hiding everything neccessary the cameraviewport is set to original Size, EntityFX is reset to Texturing and Lightning and whatever.<br><br>Now it continues as usual, a fullsize Renderworld, Flip etc.<br><br>As I said, I don't know how efficient this Method is, but I think for Levels with lots of seperate Objects, combined with a relative reasonably short CameraRange it could boost the Speed quiet a bit.<br><br>EDIT: Tested - too slow. Precalculation seems to be the only way - combined with halos Idea to split up a Mesh in Surfaces.<br><br><br>But with all those "Render only what's visible" Solutions you have to UpdateWorld _before_ the Occlusion, because when you hide things behind the camera before the UpdateWorld and then walk back, you'll fall through the ground. <br><br></td></tr></table><br>
<a name="275051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> How accurate do you want portals? Where they are clipped by polygons in front of them to determine if other portals behind them can be seen through them?<br><br>Aight, let me see if I can break me old PSP out and draw some illistrations. <br><br></td></tr></table><br>
<a name="275052"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't understand what you mean in rule #2, or how this would conflict with manual placement.  A portal placed at every doorway is very accurate, no?<br><br>Btw, I've tried it also...seemed to work pretty well. <br><br></td></tr></table><br>
<a name="275057"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I don't understand what you mean in rule #2<br> <br></div><br><br>The problem is, if you allow people to create, say, 200 poly sectors (which may be optimal for the hardware) and use the 'classic' portal algorithm, none of those 200 polygons will obscure portals. If you can think of a way they *can*, I think you've cracked it.<br><br>If you reduce the number of polys per sector, you'll get both exponential blowout of the portal algorithm, and hardware thrashing.<br><br><div class="quote"> <br>Btw, I've tried it also...seemed to work pretty well.<br> <br></div><br><br>Again, show me the demo, give me the data...<br><br>My P3666/GeForce256 could chew through 20,000 poly levels at 85FPS. God knows what my current setup could do! <br><br></td></tr></table><br>
<a name="275058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> A friend of mine wrote <a href="http://www.mjolner.dk/~thomasg/portals.pdf" target="_blank">this thesis</a> on the use of portals in games. There is also some stuff about auto generating the portals, but I havent read it :) Maybe it can be of help somehow! <br><br></td></tr></table><br>
<a name="275059"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, ok.  That's completely different from the system I am referring to.<br><br>What I'm talking about is a scheme similar to what Mr. Riggins had suggested in previous posts.  If a level interior can be broken down into spaces that represent rooms, and they are connected with portals, then the visibility of the portals determines the visibility of the rooms.<br><br>A "room" would be more like 5,000 polys.  I'm not at all convinced that it could not be done algorithmically, but hand-placed is a hell of a lot easier and allows the level designer the flexibility to make those decisions about what can and cannot be seen. <br><br></td></tr></table><br>
<a name="275067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Exactly, LT. Btw, does setting an Entity with AlphaEntity 0 or 1 all the time thrash the hardware?<br><br>Thanks for sharing the nice looking thesis, Fredborg. :) I skimmed through it, but didn't see anything about using portals with concave cells. Mat have missed it. Just like to point out that with Blitz3D, it doesn't matter if the cell (section, room, whatever...) is concaved or convexed if a portal algorithm is used like what me and LT are talking about. <br><br></td></tr></table><br>
<a name="275070"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> The problem with an algo to determine visibility data is that it has to account for "bad" geometry! open spaces, non-welded gaps and double faces are just part of the problem.<br><br>With bsp based vis'ing, you don't have this problem as the levels are watertight. This is why something like maplet is such a good idea. Maplet designed areas would be overlaid by the geometry of any old imported level, yet clip what lied within... <br><br></td></tr></table><br>
<a name="275071"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>it doesn't matter if the cell (section, room, whatever...) is concaved or convexed<br> <br></div><br><br>It *totally* matters! See rule (2) above...with a convex space nothing can obscure a portal, by definition.<br><br>Have you got an occlusion demo I can check out? <br><br></td></tr></table><br>
<a name="275076"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> "It *totally* matters!"<br><br>Nope! :P hehe<br><br>I think you are thinking BSP convex stuff.<br><br>I'm working on my occlusion demo at this very moment.<br>-----------------------------------------------------<br><br>edit: image deleted<br>- Red Letters = Room ( yellow lines )<br>- Green Letters = Portal (Blue Lines)<br>- Purple Numbers = Camera Positions<br><br>In room A at position 1 where the camera is facing straight up towards room D, a simplified portal algorithm can just render/show rooms A,B and D. From position 1, you can only see portal A and you can see portal C through portal A.<br><br>If you went down to polygon level where polys could clip portals to help in more detail occlusion, then at position 2 we would not be able to see portal B through portal A because the room B's walls would be in the way.<br><br>But, at position 2 with a simplified portal algoritm, portal B can be seen through portal A when the room's wall are not taken into consideration. So room C would get rendered/shown because portal B can be seen through portal A in the viewing frustum. That's a side effect for a simplified portal algorithm, but an ok one to deal with providing we know that for careful manual portal placements.<br><br>My demo will only cater for portals that can be seen from your cuurent room that you are in and the portals that you can see through portals with your eye. I'm working on it! :) <br><br></td></tr></table><br>
<a name="275081"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> Surely this means you need to set everything up your way, making it useless for the majority of users? <br><br></td></tr></table><br>
<a name="275082"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The problem with an algo to determine visibility data is that it has to account for "bad" geometry! <br></div><br>If the portals are placed by hand, then bad geometry is not an issue.<br><br><div class="quote"> ...with a convex space nothing can obscure a portal, by definition <br></div><br>The idea is not to obscure portals, but rather to test portal visibility THROUGH other portals in recursive fashion.  e.g. If camera is inside room A and can see portal AB, then test room B's portals to see if they can be seen THROUGH portal AB, render those that can, etc.<br><br>Portal occlusion is another possibility, with some additional steps, but what we're talking about is a gross method that is a bit more granular than octree world division.<br><br>[EDIT]<br>Rob, not necessarily.  It should be possible to create an editor that would allow for just about any kind of interior level.  This is certainly not for the outdoors though!!<br>[/EDIT] <br><br></td></tr></table><br>
<a name="275083"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob, If manual portal placement is useless for the majority of users, then a Quake3 BSP is the only way to go for the simple 1-click-compile-a-bsp-map-to-use thing that everybody can use. It's just an idea that's being presented. If anybody has ideas to make this better or comes up with an ever more clever way... share the idea. <br><br></td></tr></table><br>
<a name="275087"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> Todd,<br><br>a) Your algorithm is currently limited to 20 polygons.<br><br>b) Whether you like it or not, it works *because* the sectors are convex.<br><br>Which is not to say your not necessarily onto something here - keep hacking! <br><br></td></tr></table><br>
<a name="275089"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> No no no ... you are missing the point.<br><br>That was just a simple illistration. If that was my design of my level, I could have around a 1000 polys in each room.<br><br>Grrr... let me draw up another illistration.<br><br><br>PS: Please, Kick the BSP stuff out the door on it's arse! I think I know what you are thinking with the 20 polygon thing. It's not that. &lt;shivers&gt;<br><br>PS: Gonna draw me room illistrations in circles this time... <br><br></td></tr></table><br>
<a name="275090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> What !!? <br><br></td></tr></table><br>
<a name="275094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know manual portal placement is not what this thread is really about, but surely each portal would be put in a type collection, and would have a list of all other portals it can see, again, entered by the user. I could be pre-calculated, or entered manually. Then when rendering the scene, you only render the room, which portals are on the 'can see list'.<br><br>Only thing is, you'd probably need two portals for every bit, as you would be going thru passageways bothways. <br><br></td></tr></table><br>
<a name="275100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ross, yes you could use 2 seperate portals at the same place defined with the same 2d convex/concave shape in 3d space. But, what you are suggesting then is to use portals as objects predefined to show other portals that they could possibly see from their position, not the camera position. It's a great idea and is what a trigger box solution is like, but it's no longer a portal because you are not looking through it in realtime to check to see if you can see other portals in a more accurate way. <br><br></td></tr></table><br>
<a name="275101"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> So why not use a trigger box solution. Then an entities which pass into a room that cannot be seen by the portal(or trigger box) carry a variable which holds the thier current room. They then get hidden if it is decided they are not in view, if you get what i mean. <br><br></td></tr></table><br>
<a name="275107"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not saying a trigger box solution is bad at all. Me, I'm just portal crazy at the moment. :) <br><br></td></tr></table><br>
<a name="275110"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> hehe <br><br></td></tr></table><br>
<a name="275113"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://www.exodev.com/images1/PortalDesc2.gif"><br>- Red Letters = Room ( yellow lines ) <br>- Green Letters = Portal (Blue Lines) <br><br>Here rooms B,C &amp; E are convexed because all sides face each other. Rooms A &amp; D are concaved because all sided do not face each other. With the portal system I'm talking about is:<br><br>- the level is sectioned out into seperate sections( entities of themselfs ) depending on where you want the portals to be in the level.<br>- portals either hides or shows each section (with EntityAlpha to keep collision) depending if you can see the portal in your camera view or not.<br>- No BSP alogrithm required.<br><br>Curently with maplet or gameSpace, I can create a single level. But I need to have it sectioned. So I CSG the sections of the level out. The doorway/window that leads into another section of the level is now replaced with a  textured wall. I use this texture with a specific name to act as a portal. The specific name tells me what section the portal wil show or hide when I load the seperate .b3d sections of the level into my engine. My current demo will load levels like this.<br><br>What I'm working on is an editor to place portals manually without a bounding box thing to make overlaps a portal. The portal is created via vertices of the level geometry. This will allow me to create all different types of shapely portals at different angles then what you get with a bounding box overlap portal creation thingy.<br><br>How one get's a portal to see other portals or not is the creative part. The very basic portal shape itself that you place in a level editor should be the one thing thats common to all portal engines. The engine itself will figure how to work with these 2d shapes in 3D space themselfs.<br><br>My agorithm seems like a simple algorithm and should be fast enough to use. Thats what I'm doing now is implementing it. I'll will release the code and demo asap if it doesn't turn out to be bad. I have faith in it so far. <br><br></td></tr></table><br>
<a name="275117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, another thing is how this can work with the .b3d format. Hopefully I will be able to have all sections of a level in one .b3d including the portals.<br><br>in the .b3d format, I would have:<br>-node<br>|...- Section Mesh #1<br>|.....- node (child)<br>|.....- Portal Mesh<br>|.....- [plus more child nodes for more portal that see other sections of the level]<br>-node<br>|...- Section Mesh #2<br>|.....- node (child)<br>|.....- Portal Mesh<br>|.....- [plus more child nodes for more portal that see other sections of the level]<br>-node<br>|...- [ more section meshs here]<br><br>The node name can specify the mesh as a section of the level or it can specify it as a portal which will then also specify the section that portal shows or hides.<br><br>Hopefully I can EntityAlpha setions and use child entities as portals like this. I think Birdie with Quil3D is doing something like this.<br><br>note: Ofcoarse, we use the portal mesh also to see if we pass through it to see if we go into another section. <br><br></td></tr></table><br>
<a name="275120"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="275121"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, I've just seen my radeon 9200 for 65 Dollars renders 390 Thousand Tris with 23 FPS... <br><br></td></tr></table><br>
<a name="275122"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="275123"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool, can't wait to see it. I'm gonna put a bit of work into my own idea. Well hardly my OWN idea but i'll give it a go anyway.<br><br>@Todd<br><br>The problem i can see you having, is if you have, say a corridor, which leads to another one. If you are looking into the corridor, the corridor further down from that should also be visiable. But i wanna see the dmeo :) <br><br></td></tr></table><br>
<a name="275126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="275128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="275133"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, now, something strange going on. Why does entities that are not in the camera viewport, but are hidden, give me a fps boost, whilst the entityalpha method, gives me no boost!<br><br>stange<br>any ideas? <br><br></td></tr></table><br>
<a name="275138"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> The Portal Master: That may be a sweet method for indoor FPS style environments. But let's face it, they are no fun compared to huge mixed indoor/outdoor scenarios.<br><br>Ross C: I think Blitz still needs to process 0 alpha entities, to check if they are in view. And if you have collisions going on, they are checked, while hidden entities are not. <br><br></td></tr></table><br>
<a name="275152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, cool. I've got no collisions going on and i'm manually checking to see if there in the camera viewport. Got it working better now. Missed out a command. :) thanks fredborg! <br><br></td></tr></table><br>
<a name="275171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fredborg, I can still use a portal on each side of a large sqaurish section of a terrain. I plan on making my outside terrain similuar to like the UT2003 demo's outdoor map.<br><br>My indoor/outdoor method will be smooth. <br><br></td></tr></table><br>
<a name="275185"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sweet :) <br><br></td></tr></table><br>
<a name="275187"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mustang</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Ok, now, something strange going on. Why does entities that are not in the camera viewport, but are hidden, give me a fps boost, whilst the entityalpha method, gives me no boost! <br></div><br><br>Do you have collisions?<br><br><div class="quote"> If you wish to hide an entity so that it is no longer visible but still involved in collisions, then use EntityAlpha 0 instead. This will make an entity completely transparent. <br></div><br><br><a href="http://www.blitzbasic.co.nz/b3ddocs/command.php?name=HideEntity&amp;ref=3d_cat" target="_blank">http://www.blitzbasic.co.nz/b3ddocs/command.php?name=HideEntity&amp;ref=3d_cat</a> <br><br></td></tr></table><br>
<a name="275244"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ruz</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> 'the occlusion challenge'. is that anyhting like the Daz doorstep challenge .<br><br>Actually occlusion is a good name for washing powder.<br><br>'occludes the stains that other non bios leave visible' <br><br></td></tr></table><br>
<a name="275245"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://www.leadwerks.com/map.zip" target="_blank">This map</a> is 23,000 polys and 41,000 vertices.<br><br>It does contain geometry which your compiler will probably not like.  However, Cartography Shop makes a distinction between "brush" type geometry, (convex and coplanar surfaces, with each face a separate surface), and arbitrary polygons, which is what all the pipes and details are.  This distinction is lost upon export to .x format.<br><br>My BSP "compiler" (too soon to really call it that) just works with the brush geometry, and will use that to hide the detail meshes.  I could provide you with code to actually check if a mesh follows the rules of geometry you need.  If it does, include it in the BSP, if not, treat it like any other moving item in the map and just hide and show it based on the BSP walls.<br><br>This would allow your compiler to work with any mesh put out by any program.  Bad geometry would only result in an object getting dismissed from the BSP tree.<br><br><img src="http://www.leadwerks.com/map2.jpg"><br><br><a href="http://www.leadwerks.com/brushesonly.zip" target="_blank">Here</a> is the same map, only without detail meshes.  I can guarantee you that all geometry in this copy of the map will work with your compiler.  Without detail meshes, the map is a mere 1600 polygons.<br><br><img src="http://www.leadwerks.com/brushes.jpg"><br><br><br>These super-high polygon maps would benefit greatly from BSP compilation.  They could be compiled using only the "good" brush geometry, so that compiling a BSP wouldn't be any more comp[licated now than it would have been in the days of Half-Life.  You just use the brush geometry to build the BSP tree, and hide and show the detail meshes depending on where they are relative to the BSP walls. <br><br></td></tr></table><br>
<a name="275248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> @mustang i posted my post that i thought i posted before. :S<br>lol.<br><br>I didn't have any collisions. Very cool map there! <br><br></td></tr></table><br>
<a name="275249"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br><br>You don't want a routine that's too processor intensive as the speed you would gain from culling would be taken up by the time it takes to calculate the culling. <br><br> <br></div><br><br>This is the main point. As really, occlusion is only about saving time, speed.<br><br>Another problem I envisage is 'cataloguing' all the objects so that yu can refer to them to know which one's are to be occluded or not.<br><br>I am still very much in favour of portals, even though they are a little out-dated now (ah dont kill me for saying that!) But they are a good balance (as per quoted statement). <br><br></td></tr></table><br>
<a name="275260"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#98">[#98]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm a bit out of touch here.  Someone care to explain the terms used here: convex, coplanar, "brush geometry" etc.:).<br><br>&lt;- dunce. <br><br></td></tr></table><br>
<a name="275263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#99">[#99]</a></td></tr></table></td></tr><tr ><td class="posttext"> www.google.com :) <br><br></td></tr></table><br>
<a name="275274"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#100">[#100]</a></td></tr></table></td></tr><tr ><td class="posttext"> yeah, I looked ;).  Looks like I'll be helping you lot now as well since I'll be needing this soon :). <br><br></td></tr></table><br>
<a name="275279"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#101">[#101]</a></td></tr></table></td></tr><tr ><td class="posttext"> RockStar, I would like to see that code.   Can you post it please? <br><br></td></tr></table><br>
<a name="275282"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#102">[#102]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob - sounds like you don't know it. Well, I don't know it - and I don't wonder! :P Well, convex is the opposite of concave, like when you say createcube() it's concave, and after a FlipMesh it's convex - or the other way :) <br><br></td></tr></table><br>
<a name="275286"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#103">[#103]</a></td></tr></table></td></tr><tr ><td class="posttext"> A convex set of polygons is one in which the polygons are both in front of one another(considering their normals) as far as I've read.  Still havnt found a definition for brush geometry. <br><br></td></tr></table><br>
<a name="275289"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#104">[#104]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any occlusion algorithm for today's 3D cards should probably work at the entity level, rather than the polygon level.<br><br>In other words, forget culling individual polygons.  If any part of an entity is visible, all of it is visible.<br><br>This being the case, the primary problem of occlusion can be broken down into a simplified initital test for each entity.  <br><br>Ie: <br>If it's bounding box is visible, then the entity may be visible.  But if it is not visible, then the entity is definitely hidden.<br><br>If you did no other test, then this alone would provide a large speed increease.  <br><br>So you need a fast way to determine if a bounding box is hidden behind arbitrary polygons in an arbitrary number of entities.<br><br>Which is not easy, but at least we have a clear idea of what needs to be done.<br><br><br>Another step one can take from here is to give all entities bounding boxes, and determine which boxes are visible based on these other bounding boxes.  Of course this will not work if one's level is one large entity, but as I already said, you don't want to do polygon culling at the polygon level.  So you want to split your level up into a bunch of entities for easier culling.<br><br><br>Of course testing if a box is hidden by other boxes is still not easy.  But at least it will be a fast test.<br><br><br>Once you do this first test, you know which boxes are definitely visible, and thus which entities are definitely visible.  So you can avoid doing more detailed checks on all those entities, but you still need to consider them when checking to see if they occlude other entities.<br><br>With this test you can also determine which SPECIFIC entities may be occluding a particular entitiy.  So you only need to do the polygon perfect test on a known small set of entities.<br><br>And that's all that I have to say about this for now.  I don't know what the best polygon perfect method to use would be, though "beam trees" looks interesting.  May work well with this early-out test I described.  It does NOT work well with large numbers of polygons though.  So it's a matrer of how many polygons are too many and how many you have in each entitiy.  I guess testing would have to be done.<br><br>type "beam tree" "abrash" and "quake" into google to get an article on Quake 1's rendering system whic describes beam trees and two optimizations for them which make the math fast. <br><br></td></tr></table><br>
<a name="275294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#105">[#105]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could also have a flag for each entity, stating whether or not it is an occluder, if it isn't, it won't be considered in the tests. <br><br></td></tr></table><br>
<a name="275296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#106">[#106]</a></td></tr></table></td></tr><tr ><td class="posttext"> To answer Dev's terminology question...<br><br>A mesh is convex if all of its faces point outward and none of them, when extended to form infinite planes, intersect with any other faces in the mesh.  Here's the test:  if a 3d line can intersect the object in more than two places, it's not convex.<br><br>Of course, concave is the same thing but with all of the faces pointing inward.<br><br>Brush geometry refers to mesh details added on top of the occlusion geometry and usually parented to it as part of the visibility scheme.  Think of it as furniture inside the room. <br><br></td></tr></table><br>
<a name="275309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#107">[#107]</a></td></tr></table></td></tr><tr ><td class="posttext"> -Convex does mean all the faces point outward.<br><br>-Concave is if any of the faces point inward, it doesn't have to be all of them, just one or more.<br><br>-Coplanar means that all vertices on a surface lie on the same plane.<br><br>-Brush geometry means that an object is convex, and is separated into coplanar faces.<br><br>Ross C, that is exactly how I do it, but I figured Mark was interested in compiling any mesh, not just output from CShop.<br><br>Dev, it would take me some time to put the functions into a useful routine, and I would only do it if Mark needed it. <br><br></td></tr></table><br>
<a name="275318"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LT</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#108">[#108]</a></td></tr></table></td></tr><tr ><td class="posttext"> Semantics...<br><br>Yes, I suppose that is the standard definition for concave.  My definition was in reference to objects that would be considered 100% concave - often used to define bounding volumes.<br><br>The requirement for brush geometry to be convex is specific to the technique used - no? <br><br></td></tr></table><br>
<a name="275320"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#109">[#109]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm going to be using both BSP, and manually placed bounding boxes/nodes(things that need polygonal detection within bounding boxes) to do culling I think.  I don't see any reason to over complicate things.  Most of it will be automatic anyhow.  It might be a pain to have to manually place bounding boxes, but it only takes as long as you want it too.  With a decent tool(Like the one I'm making for plasma atm), it wouldnt take long at all. <br><br></td></tr></table><br>
<a name="275326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#110">[#110]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why manually place them?  Just calculate the bounds of the mesh. <br><br></td></tr></table><br>
<a name="275403"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#111">[#111]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br><div class="quote"> <br>A friend of mine wrote this thesis on the use of portals in games<br> <br></div><br><br>Very cool doc, Fredborg.<br><br>I like how he/she's taken such a different approach to cell/portal generation - a nice change from reading yet again how Quake was done!<br><br>Off to read up on 'Delauney Triangulation'... <br><br></td></tr></table><br>
<a name="275431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#112">[#112]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yo, Rockstar!<br><br>Have you got B3D versions of those 2 models?<br><br>Also, any textures (just makes them more fun to play with)? <br><br></td></tr></table><br>
<a name="275434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#113">[#113]</a></td></tr></table></td></tr><tr ><td class="posttext"> that's the level in singularity 3.02, but I assume you already know that :) . My definition of convex(right out of a geometry textbook) is a shape in which no diagnols (lines between unconnected vertices) go outside the polygon.  Of course, you still have to deffine what is inside and what's out. <br><br></td></tr></table><br>
<a name="275435"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#114">[#114]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://www.leadwerks.com/mark.zip" target="_blank">Here</a> it is.  (1.62 mb)<br><br>I don't have the original textures I used, but lightmaps are included.<br><br>"Brushes and meshes.b3d" contains the whole map.  "Brushes only.b3d" only contains the brush geometry.<br><br>As a general rule, you might consider not including any named objects in the BSP, since they are probably special entities that will be moved, disappear, or are otherwise subject to change. <br><br></td></tr></table><br>
<a name="275699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#115">[#115]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I like how he/she's taken such a different approach to cell/portal generation - a nice change from reading yet again how Quake was done! <br></div><br>HE will be glad to hear :) <br><br></td></tr></table><br>
<a name="276178"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Boiled Sweets</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#116">[#116]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe I'm missing the point here but...<br><br>it seems to me that creating a 'world' from cubes is madness as for each cube you have 32 triangles.  Wouldn't it be far quicker to use a surface/mesh comprising of just 2 triangles for a wall.  <br><br>In other words instead of creating a 3d maze with say 10 * 10 * 10 cubes removing the cubes you want to be able to move through you create the walls using a 2 triangle mesh.<br><br>Am I making sense?  Obviously that would cut down massively on the number of triangles poor Blitz would have to handle. <br><br></td></tr></table><br>
<a name="276224"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#117">[#117]</a></td></tr></table></td></tr><tr ><td class="posttext"> 12 tri's a cube? :P Apparently the number of poly doens't mater that much, it' the number of surfaces taht kills things and the number of different textures on screen. <br><br></td></tr></table><br>
<a name="276234"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Boiled Sweets</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#118">[#118]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I figured its 4 tris per surface.  Is it not?  2 tris for the front of side 1 and 2 fro the back of side 1.  thats 4, then there are 6 sides to a cube so its 4 * 6 = 24 tris per cube (ok its not 32 but its not 12 either...)?<br><br>So lookkng at this thread it appears that Blitz3d is not really designed for 3d maze type games unless you can do some HEAVY DUTY occlusion/culling algorithms quickly.<br><br>Maybe I'll wait for BlitzMax to attempt my 3d maze.<br><br>What I would also like to know is if I had a cube and placed another cube beside it, how could I remove the 'walls'/surface joining the 2 cubes? <br><br></td></tr></table><br>
<a name="276239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#119">[#119]</a></td></tr></table></td></tr><tr ><td class="posttext"> 12 tri's per cube, 2 for each face. The front of side 1 is the same tri's as the back of side 1.<br><br>You could figure out which cubes are beside each other and just strectch a cube for long walls. I think there is stuff in the code archives for that sort of stuff tho :) <br><br></td></tr></table><br>
<a name="276240"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#120">[#120]</a></td></tr></table></td></tr><tr ><td class="posttext"> "it seems to me that creating a 'world' from cubes is madness as for each cube you have 32 triangles. Wouldn't it be far quicker to use a surface/mesh comprising of just 2 triangles for a wall."<br><br>I don't know what CSHOP does with the cubes you create in it, but if it's not culling the hidden surfaces then NO THANKS. :-)<br><br>Btw, cubes only have 12 tris, not 32.  6 sides x 2.<br><br>Yes, ideally one would create a level which only has those tris that would actually be visible to the player.  And all professional games that I know of construct levels in this manner.<br><br>In Angry Tanks, my own game, I have a level construction tool which allows you to place down 3d "tiles".  Each tile is a 3D model, and all similar tiles are added to the same surface.  Then you can push a button in the level editor to optimize the level, and it goes through and finds all triangles which have three vertices touching and deletes said triangles from the final mesh.<br><br>I posted this optimiztion function to the code archives a while back.<br><br>The trick though is that the function will only work if the triangles overlap.  That means you have to specifically create the 3D models so that when they abut up against one another, the triangles match up.  The cubes Blitz creates with the CreateCube comman on the other hand, (and probably the cylynders as well) do not have the triangles set up properly to do this.  If you place two cubes end to end, and then look through from one side to the other, you'll see the diagonals cross instead of aligning.  Ie, the front side diagonal goes top left to bottom right, and the back side goes top right to bottom left.<br><br>Solving this issue for just cubes with just two polygons per side would slow the algorithm down quite a bit, but solving for the general case...  Well...  I suppose if you created an algorithm which finds all coplanar tris and then makes a set of "faces" and then only compares one face to another then maybe you could handle less strictly constructed geometry, but you're still gonna have cases where you could say, place two cubes in a T contiguration over a third cube's front side and have a case where the third cube's front side is completely contained and should be deleted but is not detected.  Such cases are hard to detect.<br><br>Optimization is already slow enough, taking about a second to complete for a small level which is just fast enough to use for doing it when the game is actually running when the level loads or possibly even when geometry changes if it's optimized more.  But coming up with somethign that can handle any case would only be useful for precalculaton and saving the optimized level out, and that's not what I wanted for my game. :-)  And it would be hard to accomplish.  I don't recall ever seeing a tutorial on how to do that.  <br><br>I basically just wanted a realtime optimization I could do when a level loads, which would remove the faces between cubes and floor tiles because those were creating tons of cracking artifacts.  In my case, the number of polygons was so low that the speed of extra polygons in the level was not really an issue. <br><br></td></tr></table><br>
<a name="276289"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#121">[#121]</a></td></tr></table></td></tr><tr ><td class="posttext"> The editor im working on for plasma will have the option of contructing walls and such from said two triangle poly's.  I guess I'll just call it "Strip" modelling.  Har har har ;). <br><br></td></tr></table><br>
<a name="276898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#122">[#122]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Off to read up on 'Delauney Triangulation'... <br> <br></div>Mark: Did you find anything? And if you did, can you give me a hint, I need it for this: <a href="http://www.blitzbasic.co.nz/bbs/posts.php?topic=26539" target="_blank">ac3d to b3d converter topic thingy...</a> <br><br></td></tr></table><br>
<a name="277032"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#123">[#123]</a></td></tr></table></td></tr><tr ><td class="posttext"> I toyed with a precalculated occlusion technique similar to jfk's colour id system for 3DS levels. The system was fairly slow in processing vis data, however, the ultimate benefit to the system was that vis data collection was automated. <br><br>Using this technique I also realized that other processes could be precalculated during the VIS processing to include pathfinding tables and mesh swapping LOD. Obviously, these additional processes would impact VIS collection speed. <br><br>My "planned" solution to the speed issue was to developed a Networked Managment System that would distribute levels across a network of agent pcs for compilation. The NMS collecting the compiled data when complete. Many time consuming technologies use this form processing to speed up work.<br><br>No. 1, I'm not that excited about writting a game level editor when there are so many other tools that can do job. No. 2, manual placing portals does not sound like fun. No. 3, It is better to have it and not need it, then to need it and not have it. <br><br></td></tr></table><br>
<a name="277375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#124">[#124]</a></td></tr></table></td></tr><tr ><td class="posttext"> First, I want to define some terms.<br><br>Brush - The Quake geometry we are all familiar with, convex, coplanar, and capable of fast CSG operations.<br><br>Static mesh - High-poly meshes that are used to give insane detail to a map.  These probably shouldn't be used to calculate occlusion!<br><br>Mark, you were right about no maps being complex enough to slow Blitz down, sort of.  The polycount for the map I posted, without detail meshes, is 1900.  That's without caulking (removal of any face that has a "caulk" texture).  In my experience, caulking reduces a map's brush polycount by about 75%.  So let's estimate the caulked map above to be about 500 polys.  How big is a map going to get?  A map ten times that size would be a meager 5000 polys to render, for the whole map.  This is not even worth occluding.  Just merge the whole thing into a single mesh and draw it.  If a couple of Stroggs walk by, it's going to cost more polygons than that!<br><br>The static meshes, however, will kill performance.  A map ten times the size of the one above would have a 350,000 static mesh polycount.  So now we can come to a general rule:  Brushes occlude static meshes.  And that's it.  Brushes never get hidden, and static meshes never occlude anything.  Let's just use the bounding boxes of the static meshes to test occlusion.  If anything, doing that will err on the side of caution, and never result in any visible mistakes.  Suddenly our job just got really easy.  We have a bunch of boxes to hide, and a bunch of flat walls to hide them with.<br><br>Mark, you saw my CSG occlusion demo last Spring, where I calculated occlusion by performing CSG on the outlines of objects, relative to the camera.  If the same thing were done, using brush walls as the occluding object, and just using a bounding box to test occlusion of a static mesh, large levels with insane detail would work.<br><br>I'll have a large UT2003-detail map running in a week.  The map might be kind of repetitive, but will show the technique. <br><br></td></tr></table><br>
<a name="277462"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#125">[#125]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark is clearly *wrong* because he hasn't taken into account what we might achieve.<br><br>Consider a node<br>500 polys of high detail.<br>x2 or 3 when you multitexture enough times.<br>Add cubemaps.<br>Add bumpmaps.<br><br>only occlusion will save the day. Especially if the level has 300 such chunks. <br><br></td></tr></table><br>
<a name="277575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#126">[#126]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't think he ever literally meant that we couldn't slow it down.  I think he just meant the maps he was testing with.  I shouldn't have said it like that. <br><br></td></tr></table><br>
<a name="278082"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#127">[#127]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I didn't think either - just suprised he'd say that, thats all.<br><br>When it comes to it, HW occlusion is probably gonna be the the all-round solution to preventing overdraw. <br><br></td></tr></table><br>
<a name="279024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Isaac P</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#128">[#128]</a></td></tr></table></td></tr><tr ><td class="posttext"> *bump* <br><br></td></tr></table><br>
<a name="349782"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AbbaRue</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#129">[#129]</a></td></tr></table></td></tr><tr ><td class="posttext"> I finally know what Occlusion means, and what it intails. <br>Quit the subject. <br>I'm glad I dug up this old post from last year. <br>A little dusty though. <br>Any new thoughts on the subject? <br>I think LOD is really the best way to go, at this time. <br>And that is were I am at now. <br><br></td></tr></table><br>
<a name="349824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#130">[#130]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Quit the subject. <br></div><br>Erm... says the person dragging the post up?<br><br><div class="quote"> I think LOD is really the best way to go, at this time. <br></div><br>LOD is suited to models and occlusion is suited to indoor environments, they are two vastyl different things. <br><br></td></tr></table><br>
<a name="349829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#131">[#131]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I finally know what Occlusion means, and what it intails. <br>Quit the subject. <br>I'm glad I dug up this old post from last year. <br>A little dusty though. <br>Any new thoughts on the subject? <br></div><br>You are kidding, right? <br><br></td></tr></table><br>
<a name="349844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#132">[#132]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its still a very important topic!<br><br>Ideas?!?!? <br><br></td></tr></table><br>
<a name="349852"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#133">[#133]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Its still a very important topic! <br></div><br>It is, but he posted:<br><br><div class="quote"> I finally know what Occlusion means, and what it intails. <br>Quit the subject.<br>I think LOD is really the best way to go, at this time.<br> <br></div><br><br>In a dead topic months old, then edited it at my response.<br><br>As far as occlusion goes I think the request I posted <a href="/posts.php?topic=32617" target="_blank">here</a> could really help with instances where one object occludes another (though it would be entirely useless for self-occluding objects), wouldn't it be worth implementing as it is essentially 'free'? <br><br></td></tr></table><br>
<a name="349889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AbbaRue</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#134">[#134]</a></td></tr></table></td></tr><tr ><td class="posttext"> From what I can figure, the time needed to check which objects in a scene Occlude others, <br>the scene can be rendered as is. The clock cycles used to check a 3D object are the same <br>clock Cycles needed to render the object. <br>Todays GPU's are faster working with 3D objects then CPU's. <br>That is why I mentioned LOD as a better method of doing things. <br>I wasn't refering to indoor scenes. <br>I asked a question earlier today, concerning an outdoor scene, and was pointed towards Occlusion. <br>That is why I looked it up in the first place. <br>When I walked up to a hill in my world, I noticed that the tris. value remained the same. <br>So I asked if there was a way to tell blitz not to render past the hill. <br>That was when I was told about Occlusion. <br>I think for outdoor scenes LOD is still the best way to go, because of the distance and complexity. <br><br>For indoor areas, I could see Occlusion or something simular as priceless, <br>and it should be quite easy to implament. I can see some means of doing it already. <br>But that is not were I'm at right now.<br>When I get to the indoor part of my game I will be giving it alot of thought. <br>But right now I am working on the outdoor part of my game. <br><br></td></tr></table><br>
<a name="349899"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#135">[#135]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, I see. This whole debate, though, (as I remember it) is about occlusion indoors. You can't simply LOD indoor environments (though you can LOD the objects in them).<br><br>You are dead right about GPUs being very fast nowdays and that occlusion isn't necessary for many scenes. What can be done, though, is to create a very 'loose' occlusion algorithm that occludes huge chunks and sacrifices quality for speed (but it *always* renders when in doubt), which won't use much CPU time but will help a hell of a lot on the GPU (though the GPU will still be under significantly more strain than it would be with a Quake 1,2 &amp; 3 style occlusion system) in huge indoor worlds, and I think that's the way forward.<br><br>It's easy to say that, but coding it (especially when setting it up in an automated fashion) is another thing! :) <br><br></td></tr></table><br>
<a name="349926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#136">[#136]</a></td></tr></table></td></tr><tr ><td class="posttext"> I still got this Idea for an Occlusion on a very low machine level:<br><br>Render from near to far, and as soon as all Pixels of the Screen are drawn (Count Pixels), skip Rendering. I have no idea if this is possible with DirectX, and it might need to use non-intersecting Polygons. But it would be pretty fast.<br><br>I wanted to use this for a software 3d engine some time ago, but never finished it. <br><br></td></tr></table><br>
<a name="349964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#137">[#137]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can *kind of* do that, but you can't tell the 3D card to skip rendering when all the pixels are drawn.<br><br>My request for EntityOrder with ZBuffer was to do something like this - it's faster to render an object in front then an object behind than it is to render an object behind then an object that is in front. It will still require some CPU time to order them, though - and it's no replacement for a 'real' occlusion system. <br><br></td></tr></table><br>
<a name="349970"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#138">[#138]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Its still a very important topic! <br><br>Ideas?!?!? <br> <br></div><br><br>Depends on whether you mean from within Blitz3D, or within the engine it's self.<br><br>From within Blitz3D, there's a method I developed, though slow, so the actual mesh compiler is best wrote in C++,<br><br>compile stage,<br>go through each poly in the scene, and from it's centre, cast a linepick to the centre of every other poly in the scene. If it can 'see' the poly, add it to it's seen.poly pool, if not, add it to it's unseen poly pool. <br>One way to speed this up is to create a 3rd universal list, that each poly is added to as it's check, that way when you check a poly, check if it's cross-checked in this universal list, if so, you can safely assume if it can see or not, the ones that references, and so on, end up with 50% less linepicks.<br><br>Anyway, you have this list of every poly visible(For memory reasons, it would probably make sense to make it every 4 or 10 polys, or better still polyInc#=numPolys/maxNumberTotal (maxNumberTotal being worked out at runtime depending on quality settings etc.) now, due to blitz3d's limited access to internal rendering, we have to create meshes with overlap,<br>firstly, group every poly that can each other in unique meshes, so say poly a can see poly b and poly d. that means b can a, but whatever, at any point on this section it's worth assuming they can all see each other. This becomes a surface.A long corridor for example would become one mesh.<br>For accuracy, a further check could be to use a threashold for max amount of non-visible pairs before it's disqualified and is apart of the next surface created.But it's still added to the current mesh, because it can be seen from some points, but also the next mesh, so this is the overlap, so we can safely changes visible meshes.<br><br>Now when we create the next mesh, we link it the previous, and link the previous to the next, do this by generating a bounding box.<br><br><br>Then, you have a bunch of meshes totally independent of scale/size, and again totally oblivious to the shape of the 3d world.<br><br>Save these meshes, out, along with list of links, and the bounding boxes.(The meshes are linked to the bounding boxes too)<br>Then in game, we just check what bounding boxes we're in, remembering they can overlap safely, and turn the alpha up on those meshes, turn it off those we arn't in.<br><br>ultra fast, just ultra expensive to compile the meshes..but i'm sure it can be improved further. <br><br>The biggest drawback of this is down to way you handle surfaces now. It appears you bind the textures of every surface, even if the surface shares the same texture combos.<br>Imo you should group off each surface in memory that share the same texture combo. that way it surface limit problems would disappear, and it would be the much better(if it a little harder to understand for newbs) limited by unique texture combos/blend modes.<br>-<br><br>if on the other hand you're talking internal, I think streaming is the way to go for huge worlds. just look at gta3 on the xbox and then compare it to Deus ex 2 on the xbox, which uses occlusion etc. One has huge open worlds, the other has claustophobic levels riddled in a load fest of a mess.<br><br>i.e build up a mesh from a set point of origin, and then as it transforms away from the current camera, stream in a certain set of polys and stream out just as many. order it in memory in terms of Z, so you can quickly throw out a bunch of polys without any expensive maths, and check for the closet x or the first ones to fall within a radius, and throw those out. Do the same for streaming in, but save them in order of Z. <br><br></td></tr></table><br>
<a name="350190"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#139">[#139]</a></td></tr></table></td></tr><tr ><td class="posttext"> Count pixels doesn't work due to alpha pixels. Overdraw is a necessary evil. <br><br></td></tr></table><br>
<a name="350296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zmatrix</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#140">[#140]</a></td></tr></table></td></tr><tr ><td class="posttext"> doesnt Bsp /vis create alot of surfaces? <br>3dgs for example(maybe the engine is just broken)..i had a small 3000 poly level made in Cshop and exported to .map , in 3dgs it was over 8000 surfaces after compile.<br>in b3d it was 6.<br>3dgs ran about 30fps<br>while in b3d about 225fps<br><br><br>No doubt b3d is fast,not just in 3d but also in code execution. <br><a href="http://www.glbasic.com/files/mandelbrot.zip" target="_blank">http://www.glbasic.com/files/mandelbrot.zip</a><br>A fractal drawing test/compare for blitz3d,db,dbpro,glbasic,Vb6,Vc++6<br>on this crappy system, 950 duron,256megs radeon7200 32(horribly slow pci version) heh<br><br>vc++ : 260 kpix/sec<br>blitz3d 1.64 : 225 kpix/sec<br>vb6: 200 kpix/sec <br>glbasic 180 kpix/sec<br>db: started drawing but woulda taken about 10 min to finish the first screen.<br>dbpro : never even saw it start,,said 0 kpix/sec<br>mayeb someone with B+ can port it?...i would like to see the score.<br>.............<br><br>Blitz3d using Retained mode?? I dont think so..heh<br>Alpha doesnt work in retained mode,you cant multitexture  and theres no hardwaret&amp;l support..best youll get even out of even a geforcefx or radeon9800 in retained mode is about 5 million tris per second.(give or take with Cpu speed)<br>3drad is retained mode and ive seen 4million tris per second (single surface) with my radeon 8500.<br><br><br><br>Zmatrix <br><br></td></tr></table><br>
<a name="350314"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#141">[#141]</a></td></tr></table></td></tr><tr ><td class="posttext"> No need to count pixels, rendering objects in near to far order will give a good performance increase as is.<br><br>Plus if you count pixels this won't work if your meshes are concave or overlap.<br><br>Bsp splits polygons if they straddle the current partitioning plane so creating an extra poly each time.<br><br>There's no holy grail of culling methods because they are so reliant upon the type of geometry you have.<br><br>That doesn't mean that there isn't a general solution, just there is no 'best' solution.<br><br>One general way that would work for indoor and outdoor scenery would be to maintain your own z-buffer in software, draw near to far and use this to decide what needs drawing.<br><br>On the other hand you may find that the gpu on the graphics card does a faster job for free! =) <br><br></td></tr></table><br>
<a name="350716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AbbaRue</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#142">[#142]</a></td></tr></table></td></tr><tr ><td class="posttext"> I could see using a 2D map of an indoor scene, to seperate rooms and then just render the present room you are in as a seperate mesh object.  Then use more then one camera to do Windows and doors, before you enter the other rooms. Kind of like a mirror idea, only it's a window or door, not a mirror.  <br>Then you don't need to worry about Occlusions. <br>I don't understand why this wouldn't work for any indoor scene.  Any examples of were it wouldn't, before I write code and then find it falls short. <br><br></td></tr></table><br>
<a name="350755"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#143">[#143]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excuse my ignorance, but what information does a BSP hold? I know that it is a list of what triangles are visible, but how is that held. As a spatial grid with a list of tris attached to each area?<br><br>I have a method for determining what triangles are visible that I developed for the Projection Painting in Tattoo, and I was wondering if it would work for visibility compling? <br><br></td></tr></table><br>
<a name="350756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#144">[#144]</a></td></tr></table></td></tr><tr ><td class="posttext"> Part of the problem isn't actually how the data is held, but getting the data in the first place. Even a lose tree of data will do us.<br><br>But how to compute visibility from where you are?<br><br>IMHO the best occlusion would be on a per-entity basis. This would work as Hiding/showing large batches of polys is beneficial in todays hardware.<br><br>The problem is scanning the scene and building a list of visible objects for each x,y,z map grid position. I have done something like this with linepick, but compilation is painfully slow.<br><br>Optionally, the engine could manage and split the level into chunks. <br><br></td></tr></table><br>
<a name="350765"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#145">[#145]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The problem is scanning the scene and building a list of visible objects for each x,y,z map grid position. I have done something like this with linepick, but compilation is painfully slow. <br></div><br><br>I see. How slow is slow? And what resolution is the vis data held at. i.e. 'at each blitz unit?' or some other arbitraty resolution?<br><br>The method I mentioned would give you a list of triangles and surfaces visible from any arbitrary point. It's fast, but not instant. Should be much faster than vanilla blitz linepicks though. Do you have an blitz code example? <br><br></td></tr></table><br>
<a name="350818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#146">[#146]</a></td></tr></table></td></tr><tr ><td class="posttext"> Two problems arise: Illegal Geometry and Compilation time. You have to define a resolution for the grid of points you'll use to check for visibility. The more points it has, the longer the VIS calculation and the longer the ingame hiding/showing. Depending on this Resolution there is a certain kind of ILLEGAL GEOMETRY, which could be visible from one footstep byside the checked point, but remains invisible from the point. So you cannot simply use any beloved Map or Model. An object must be bigger than the distance between two points, watched FROM ALL SIDES.<br><br>Checking a level with say 50*50*50 Positions can easily take up to several hours using Linepicks. So slow is slow. ALthough it is a precalculation, it's uselessy painful.<br><br>Some time ago I have released an other method that is indeed much faster. It is using a "Identify Color by Uniqueness" Method (ICU). Basicly every Surface is using plain Color and no texture. Every Surface will have it's own, unique Color.<br><br>Now a camera is positioned at every point, take 6 Renders like in cubic enviroment mapping. Now use readpixelfast to check for the colors on the rendered images. It's even possible to use the color right as the index of a blitzarray that acts as flags for visibility. For 16 Bit color Resolution the values might have to be shifted some way to work correctly, but in 24 or 32 Bit it's really simple.<br><br>A working example can be found here:<br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=341" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=341</a><br>(note: use it to see the ICU method in action, other parts might be spaghetti to useless)<br><br>There is a further problem: if the initial Map has let's say 20 surfaces, you will need to fragment the Map Mesh into clusters to be able to hide the occluded parts. Therefore each cluster will contain its own copies of the surfaces it uses. This means you will now have about ten times more surfaces in the videoram, depending on the leveldesign. <br><br></td></tr></table><br>
<a name="350874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#147">[#147]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi jfk,<br><br>Thanks for the source. I ran a compile on my machine and it took 6 minutes to complete.<br><br>After some messing around, I managed to get it down to 16 seconds (22.5 x faster). That's about as fast as I can see it going with either system. The lockedpixels stuff of Blitzplus would help here I think!<br><br>[edit] got it down to 12 secs. :) <br><br></td></tr></table><br>
<a name="350939"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#148">[#148]</a></td></tr></table></td></tr><tr ><td class="posttext"> So is that all that is required, or does it need to be done on a Triangle by Triangle basis? <br><br>How would you go about hiding and showing quickly the tris that are hidden / visible. <br><br></td></tr></table><br>
<a name="350946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#149">[#149]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd keep an array containing flags which show if a surface is hidden or not. Then I would only hide/unhide those which have to be altered. That's fast.<br><br>I have no idea for a By-Triangle solution. I think it would be pretty slow to assemble a meshs visible Tris each loop.<br>I also think you would end up with a too high number of surfaces if you would make each Triangle a hideable Surface or child mesh.<br><br>And whatever you do, a map must be designed for occlusion, otherwise it will not be much faster. (no big rooms with high detail)<br><br>BTW, Lee, how did you reduce the time to 12 secs?!? <br><br></td></tr></table><br>
<a name="350973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#150">[#150]</a></td></tr></table></td></tr><tr ><td class="posttext"> In this case, looking at what was taking the time, I set up multiple cameras looking around in four directions. You can then set their viewports at different on screen positions. That way you have one renderworld with four faces. (you can get a better verticle field of view with a lower camerazoom which eliminates much of the look up and down)<br><br>It was also taking a long time to lock and unlock the buffer, so having to do it less often by having 4 in 1 renders sped thing up a bit.<br><br>Locking and reading the backbuffer/frontbuffer seems to be very time consuming, so I copyrected the composite four faces to a created texture which has the +256 flag to lock it in VRAM.<br><br>From that created texture reading is much faster (really much faster). But it would be better still with locked pixel stuff.<br><br>My plan ultimately would be to render two positions in one frame by using up the remainder of the texture space in a 1024x1024 frame with another camera set. That would lower the overhead on the copyrect to about half. So about 9 seconds would be about right.<br><br>I could get it down to between 5-7 secs if I could render directly to a texture! <br><br></td></tr></table><br>
<a name="350988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#151">[#151]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks! pretty sly. well, i think when I wrote it there was no 256 flag :) . Honestly I had no idea reading the backbuffer is slower than reading from a texture. <br><br></td></tr></table><br>
<a name="351024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#152">[#152]</a></td></tr></table></td></tr><tr ><td class="posttext"> I devised a color id VIS compilation system similar to jfk's. In fact, our algorithms are practically identical:<br><br><pre class=code>;frankie t's identify color by uniqueness (icu) algorithm
array vis(n,n,n)
global worldscale#=.1

loadanimmesh levelmap.b3d

for each childmesh within mesh
	apply unique color equal to childmesh index
	set childmesh attributes to fullbright, flat shading, disable fog, disable backface culling, no texture
next

repeat 
	increment camera through level map geometry on x,y,z planes
	cameraPosition camera,{camera.increment * worldscale#}
	vis(camera.increment.x%,camera.increment.y%,camera.increment.z%)=create bank
	for cameraAngles% = 1 to 6;(up,down,left,right,front,behind)
		cameraAngle camera
		snapshot=cameraSnapshot(camera)
		for each snapshot
			for x = 0 to snapshotWidth
				for y = 0 to snapshotHeight
					color%=readpixel(snapshot,x,y)
					if color&gt;0 and not on vis(camera.increment.x%,camera.increment.y%,camera.increment.z%)
						poke(vis(camera.increment.x%,camera.increment.y%,camera.increment.z%),++,color)
					endif					
				next
			next	
		next
	next
until camera completes level
</pre><br><br><br>I have found "Identify Color by Uniqueness" method to be very flexible, easy to implement, and faster than most. It works for convex/concave geometry. You can also precalcuate mesh-switching LOD with it.<br><br>The process is extremly slow on older machines. To solve this problem, I was rewriting the compiler to split the compilation task among multiple agent PCs. This multi-processing approach is commonly taken with other task that have long compilation times such as cgi.<br><br>However, I could live with TeraBit's compilation times. So I guess all I need to do is get a faster machine. <br><br></td></tr></table><br>
<a name="351042"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#153">[#153]</a></td></tr></table></td></tr><tr ><td class="posttext"> Terabit's optimisation has allowed a far greater degree of accuracy, so perhaps this technique is feasible after all.<br><br>Nice work lee!<br><br>Mark, do you still think render to texture is out of the question? If so, why? <br><br></td></tr></table><br>
<a name="351047"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#154">[#154]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interestingly. I too use multi-viewport technique parented to a pivot. But I only render to the backbuffer (no flip to the frontbuffer). I also increment the read pixel x,y by 2. Hmm, the copyrect texture VRAM method sounds very good.<br><br>Overall, the ICU Algorithm is my VIS method of choice. It could very well, become a standard. <br><br></td></tr></table><br>
<a name="351116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#155">[#155]</a></td></tr></table></td></tr><tr ><td class="posttext"> Manual Portal placement will become the standard... no doubt! :P<br><br>Really though, I'm getting there and I will show all the greatness of Portals!<br><br>I thought Rob might like some hype there... :D <br><br></td></tr></table><br>
<a name="351149"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#156">[#156]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I also increment the read pixel x,y by 2 <br></div>pointless optimisation. Instead, render smaller!<br><br>Hype? even the matrix couldn't touch wells for that.<br>Anyway, I like hype, just not antony wells hype.<br><br>I believe I will use Lee's method. I did this form of occlusion a long time ago, probably around same time as jfk.<br><br>An optimisation I did further was to replace all entities with bounding boxes. This sped up the render portion significantly for further speed gains. The loss in accuracy was minimal. The slowest part isn't rendering, it's scanning. <br><br></td></tr></table><br>
<a name="351177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#157">[#157]</a></td></tr></table></td></tr><tr ><td class="posttext"> The copyrect to the texture is really slowing things down (although not as much are reading from the backbuffer!)<br><br>You can use the same method for Triangles too. Simply unweld the geometry and use vertex colours to colour the individual triangles the colour ID. <br><br></td></tr></table><br>
<a name="351179"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#158">[#158]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do you honestly consider this to be a good method? <br><br></td></tr></table><br>
<a name="351181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#159">[#159]</a></td></tr></table></td></tr><tr ><td class="posttext"> You mean for triangles? Well I've been using it in Tattoo since it got projection painting (otherwise reprojection would take about four minutes instead of a few seconds). <br><br>You can tell exactly what triangles are visible at any location even if they are partially occluded. It's never given me any problems and vertex colours render very quickly.<br><br>I tried to post my generic function to do the job, but my work net connection won't let me post anything over about six lines long. <br><br></td></tr></table><br>
<a name="351260"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#160">[#160]</a></td></tr></table></td></tr><tr ><td class="posttext"> On the other hand, if you mean do I think that culling individual triangles is a good method, then I would say no. Not worth the effort. I don't believe that it makes sense to only render a few hundred polys over a few thousand considering the processing overhead involved.<br><br>Basing the occlusion on entities is a much neater, more controlled solution, so jfk's CSP stuff does the job nicely for most things. <br><br>That said, some changes to the entity system would make this kind of system easier. Perhaps some kind of grouping. So you could define a list of polygons as belonging to a group (although with less overhead than a separate entity, since they would not have rotation, scale and other entity stuff to worry about.)<br><br>Grp = CreateGroup()<br>AddGroupTriangle Grp,Surface,Tri<br><br>HideGroup grp  ; removes from rendering pipeline <br>ShowGroup grp  ; shows in rendering<br><br>Thoughts? <br><br></td></tr></table><br>
<a name="351528"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#161">[#161]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  if you mean do I think that culling individual triangles is a good method, <br></div><br><br>I think someone really should make a benchmark test. I suggest to try the following: Based on Triangle Visibility Information a prototype Mesh that contains visible Triangles  only is constructed each frame. It may take too long to assemble it, then again it's only a few hundred tris. As far as I know, MasterBeakers Z_Sorting Algorithm for alphaed meshes used to reconstruct the mesh each frame too.<br><br>Maybe it would work this way: keep a hidden copy of the entire Map in memory and clone the visible trianlges only, just to render and remove them again.<br><br>I see more reasons to use VIS data: Currently I use Linepicks to determine if a Lightbulb is visible and needs a flare. Those picks are real slow, my app would profit a lot if it could use VIS information to show/hide flares.<br><br>Somebody should find a clever way to save the VIS Data in a Ram-saving way. Even if it only contains the visible Tris for each point, its size will easily be 20 Megs. So maybe some kind of compression is required. <br><br></td></tr></table><br>
<a name="351568"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#162">[#162]</a></td></tr></table></td></tr><tr ><td class="posttext"> To a certain extent, that was the idea behind groups. That way, you could simply list the groups that were visible from each point.<br><br>Reconstructing a large mesh in real time in blitz would very likely be time consuming. A built in system would fare better, but may be overkill in the current GFX climate. Pehaps since the way forward is bigger and heavier graphics cards, a simple group based occlusion would do what we need. There may be some dynamic way of setting up optimal groups in code using a similar system to the CSP. <br><br></td></tr></table><br>
<a name="351722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#163">[#163]</a></td></tr></table></td></tr><tr ><td class="posttext"> Everyone lost interest in this then? <br><br></td></tr></table><br>
<a name="351754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#164">[#164]</a></td></tr></table></td></tr><tr ><td class="posttext"> no, not at all. I think that render to texture needs to be put into blitz. It's foolish to leave it out. Put it in and we will simply benchmark it's performance and choose to use it or not.<br><br>As programmers give us the choice, I say.<br><br>Lee, why not put your point across to Mark about render to texture? so many effects and techniques use it now it seems foolish not impliment it at speed.<br><br>Render to texture could also preserve masking. <br><br></td></tr></table><br>
<a name="351770"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#165">[#165]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I'm gonna try to reconstruct the mesh using the visible tris only. Since this isn't a large mesh, especially if a lowpoly map design is used. Maybe it's gonna be 300 tris or something. I think it's worth a try.<br><br>For this i'd check all surfaces of the hidden original map. If anyone of the tris of a surface is visible, I'd add that brush/surface to the visible mesh. So I'd probably have only 5 surfaces to render, while the whole level uses hundreds of surfaces. In the same time the whole map can be real big. I just need to find a way to ship around the 64k Vertices limit. How exactly does this limit work, is it possible to use 64k Vertices per Surface/child, or does it count for the entire top level entity?<br><br>However, if I can make it compile it 12 secs instead of 6 minutes, it's much easier to develop. <br><br></td></tr></table><br>
<a name="379791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#166">[#166]</a></td></tr></table></td></tr><tr ><td class="posttext"> This was very good discussion on VIS and occlusion. Could not resist reviving. <br><br></td></tr></table><br>
<a name="380126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pepsi</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#167">[#167]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="380276"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#168">[#168]</a></td></tr></table></td></tr><tr ><td class="posttext"> heres a VERY simple way to do highly efficient culling.  <br><br>All ya do, is break the map up into 1 x 1 grids.  Check every triangle in the map for visiblity, using normals, and a visibility routine.  Store all visible tris for each cube in the 3d grid.  At runtime, clear all tris, and only build the visible ones. <br><br></td></tr></table><br>
<a name="380290"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#169">[#169]</a></td></tr></table></td></tr><tr ><td class="posttext"> IMHO destroying and building the tris at a runtime could prove to be very inefficient. <br><br></td></tr></table><br>
<a name="1294482"></a>

<a name="1294483"></a>

<a name="1294484"></a>

<a name="1294485"></a>

<a name="1294497"></a>

<a name="1294498"></a>

<a name="1294499"></a>

<a name="1294501"></a>

<a name="1294503"></a>

<a name="1294576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#170">[#170]</a></td></tr></table></td></tr><tr ><td class="posttext"> &lt;-!necro post!-&gt;<br><br>I have thought of an easy to implement system to determine the non visible surfaces and the visible surfaces and show only the visible surfaces before rendering :<br><br>-when you create your map, make sure the static entities are divided in different meshes (or copies of a mesh) depending on their position and proximity with others static surfaces and shared or notshared materials with others near static surfaces. (of course it is better to combine surfaces which are near and which share the same material (you can also combine different textures which have the same material into one and then combine the corresponding surfaces into one))<br><br>-make sure the turningmoving entities have each one mesh (or copy of a mesh)<br><br>-for each static entity, and for each turningmoving entity, create one very low details mesh (the less tris possible, just to have an approximate shape) and one high details mesh (as much tris as necessary)<br><br>-for each static entity, and for each turningmonving entity, create a root and a very low details mesh (to determine the visible/notvisible surfaces) and a high details mesh (to display the result to player)<br>Color each very low detail mesh with a different color between 0,0,0 and 255,255,255 (you must use 32bits graphics) and set it to fullbright.<br><br>-before rendering the scene with the high details meshes, hide all high details meshes, show all very low details meshes, set the cameraviewport to 10% of its normal size (for example 102*76 for 1024*768), render the scene, analyze the pixels of the image, and depending on the colors found, you know which entities are not visible and must stay hidden and which entities are visible and must be shown.<br><br>-hide all very low details meshes<br><br>-show the necessary high details meshes<br><br>-render the scene<br><br>That's all, it can be very useful for an outdoor map with big obstacles like buildings or deeps hills or mountains which can sometimes mask others smaller shapes...<br>But for an indoor map, it is probably better to use a portals system (one room connected to one or several others rooms by one or several passages, before rendering hide all rooms (and the statics in each room) and depending on in which room player is, and depending on the passages from this room to the others room, show the appropriate rooms (and statics in these rooms))... <br><br></td></tr></table><br>
<a name="1294567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#171">[#171]</a></td></tr></table></td></tr><tr ><td class="posttext"> Take a look at this:<br><a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch29.html" target="_blank">http://http.developer.nvidia.com/GPUGems/gpugems_ch29.html</a> <br><br></td></tr></table><br>
<a name="1294568"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#172">[#172]</a></td></tr></table></td></tr><tr ><td class="posttext"> Much like a particle system for grass and stuff? <br><br></td></tr></table><br>
<a name="1294574"></a>

<a name="1294575"></a>

<a name="1294578"></a>

<a name="1294579"></a>

<a name="1294611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#173">[#173]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Much like a particle system for grass and stuff? <br> <br></div><br>No ! :P<br><br>You may know what the camera fov (field of view) is, all meshes in the camera fov will be considered for the rendering, all meshes outside the camera fov will not be considered for the rendering.<br>However sometimes some meshes considered for the rendering are not visible to the player because there are big meshes in front of the camera (so a big mesh masks one or several smaller meshes behind it). <br>So the "visible/notvisible surfaces determination" is the process to determine which surfaces are visible and which surface are not visible (because a big surface may be in front of the camera and some smaller surfaces are not visible). This process is usually done with bounding boxes or very low details meshes.<br>Then only the necessary high details meshes are shown and rendered.<br>This decreases the time it takes to render a scene. But it is useful only with some kinds of scenes (outdoor more than indoor) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
