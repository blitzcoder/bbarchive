<!DOCTYPE html><html lang="en" ><head ><title >Tweening... Again... Just shoot me now.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Tweening... Again... Just shoot me now.</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Tweening... Again... Just shoot me now.</a><br><br>
<a name="1071295"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all,<br><br>So, I've run into trouble YET AGAIN with tweening in Blitz 3D. A reminder for those who may need to be brought up to speed on my project: the game is, in essence, a 2D shooter rendered in 3D, using tile-based level maps. This means that there will sometimes be a metric LOT OF ENEMIES about - quite possibly in excess of 100 at once - all colliding with each other AND the map by use of <b>Collisions()</b>.<br><br>This means, of course, that there is every chance for the LOGIC to take more than 16 milliseconds, and of course anything over 16 2/3 ms is too long for a game to render at 60 FPS. Mark Sibly's tweening code works purely on the RENDERING; if a frame takes two frame's worth of time to render, the game performs the logic TWICE on the next loop to make up for it. Render goes too long, logic increases to catch up.<br><br>This presents a problem, however. If the logic takes, say, 10ms for a single frame, then it's run twice to catch up with a long render, the result is 20ms, meaning the logic has ALREADY taken too long, before the render has even started. This eventually results in cumulative errors that take longer to catch up the longer the frame delays persist.<br><br>So, bottom line is this. I need my game to be able to update 100+ enemies, all colliding with each other AND the map, along with rendering about 500~2000 non-colliding frags and bullets, in as few milliseconds as possible, without needing the power of an MIT supercomputer behind it. What should I do? Should I try a different tweening method? Is it unrealistic to hope for 200+ entity collisions, which indeed seem to be Blitz3D's most CPU-intensive process, and should I rethink said collisions? I'm at my wit's end with this; shooters are all about impressive masses of frags, bullets and enemies, yet it seems like I'm just overreaching things somehow.<br><br>All help is appreciated, and "dumb" ideas won't be flamed. Thanks. :p <br><br></td></tr></table><br>
<a name="1071298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> In games where I have lots of enemies/units that can collide I don't use the blitz collision command usually.<br><br>Instead I have a bank (or an array will do) which represents a grid of locations in the game world, at each index is a handle to another bank which contains a list of units within that grid cell.  Then, when a unit moves it simply needs to update its grid cell position and check the current grid cell and neighbouring ones iterating through the units in those grid cells to perform distance checks for purpose of collisions.<br><br>Pseudo code:<br><br>if unit moves<br>  check if still in current grid cell<br>   if in current grid cell check collisions with other units in current grid cell and neigbouring ones.<br><br>  if moved to different grid cell, remove from current grid cell (adjust bank's accordingly), add to new grid cell bank and check collisions as for above.<br><br>This is extremely fast as when a unit (bullet/enemy etc) moves it only needs to check against its nearest neighbours..rather than iterating through an entire list.<br><br>Use of the handle/object commands is of great benefit here too.<br><br>Hope this helps, from matt. <br><br></td></tr></table><br>
<a name="1071299"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> That WOULD work, except I neglected to mention that although the MAPS are tile-based, the movement within the maps is completely free-range.<br><br>Anyway, first tip of the day in less than an hour, thanks Matt! :D <br><br></td></tr></table><br>
<a name="1071316"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Even so - it would still work for unit to unit collisions, the grid overlaid does not have to be the same size as the tiles/maps. <br><br></td></tr></table><br>
<a name="1071355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Except that the entities use sphere-to-sphere collisions, and since the maps are 100x100 with tiles of 64x64px, we're looking at a 6400x6400 grid is subdivided... Bruteforcing that would be even slower than intercollisions. <br><br></td></tr></table><br>
<a name="1071369"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> The grid would solely function as a way to cut down the number of collisions. You should look at them as "area's", rather than tiles. Limiting collisionchecks to only those entities that are in the same area will cut down the number of checks quite a bit.<br>This example just shows/hides entities. Imagine there is an object where the mouse is at. The visible entities are then the ones that should be involved in collisions. The invisible ones should not be checked.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

;-----------------------------------------------------
;				define grid
;-----------------------------------------------------
Const sizex = 20
Const sizey = 15
Dim area_(sizex-1, sizey-1)

;-----------------------------------------------------
;				setup camera
;-----------------------------------------------------
cam = CreateCamera()
PositionEntity cam, sizex/2, 15, sizey/2
RotateEntity cam, 90, 0, 0

;-----------------------------------------------------
;				create grid
;-----------------------------------------------------
SetupGrid()

;-----------------------------------------------------
;				create floor
;-----------------------------------------------------
plane = CreatePlane()
EntityColor plane, 0, 128, 0
EntityPickMode plane, 2

;-----------------------------------------------------
;				create objects
;-----------------------------------------------------
For i = 0 To 3600

	sphere = CreateSphere()
	ScaleEntity sphere, 0.125, 0.125, 0.125
	PositionEntity sphere, Rnd(sizex), 0, Rnd(sizey)	
	EntityColor sphere, Rand(255), Rand(255), Rand(255)
	AddToGrid(sphere)
	
Next

Repeat

	;camera pick
	CameraPick cam, MouseX(), MouseY()
	;if picked floor
	If PickedEntity() Then
		;get pick coords
		mx = PickedX()
		my = PickedZ()
		
		;determine which area these coords are
		area = GetArea(mx, my)
		If area &lt;&gt; 0 Then
			;show this area, and hide previous one
			If lastarea &lt;&gt; 0 HideEntity lastarea
			ShowEntity area
			lastarea = area
		End If
			
	End If
	
	RenderWorld
	Flip
	
Until KeyHit(1)

End


;create grid
Function SetupGrid()

	For x = 0 To sizex-1
	For y = 0 To sizey-1
		area_(x, y) = CreatePivot() ;pivots are used to hold a list of entities
		PositionEntity area_(x, y), x, 0, y ;place pivot at grid position
		HideEntity area_(x, y) ;hide pivot
	Next
	Next
	
End Function

;add entity to grid
Function AddToGrid(ent)

	;get position of entity
	x = EntityX(ent)
	z = EntityZ(ent)
	
	;check if it is a valid position within grid
	If x &lt; 0 x = 0
	If z &lt; 0 z = 0
	If x &gt; sizex-1 x = sizex-1
	If z &gt; sizey-1 z = sizey-1

	;add entity to grid	
	EntityParent ent, area_(x, z)
	
End Function

;get grid pivot
Function GetArea(x, z)

	If x &lt; 0 Return 0
	If z &lt; 0 Return 0
	If x &gt; sizex-1 Return 0
	If z &gt; sizey-1 Return 0
	
	Return area_(x, z)
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1071374"></a>

<a name="1071375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I've done some research online, apparently the term I've been looking for all this time is "Delta Time." I also learned about the "spiral of death," which I had thought was an inadequacy in my + Sibly's tweening code but apparently is just an inherent problem in programs experiencing extreme load for prolonged periods of time. So, bottom line is I just have to tear through my code and mercilessly strip and trim things to lessen the logic time as much as possible.<br><br>I'll do things like hiding or at least de-colliding enemies when more than a certain distance offscreen, replacing <b>EntityDistance()</b> with my 2-dimensional <b>Distance()</b> function (remember, this is all arranged in 2D), etc. Looks like there's nothing else for it. This has also taught me a lesson, namely the reason why large-scale commercial companies like Valve don't use higher-end languages like B3D; there's really more overhead than first meets the eye. Well, at least I know where I'm going now; after <i>Midnight Hacker</i>, I guess it's time to finally learn C++. ;D<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1071399"></a>

<a name="1071400"></a>

<a name="1071401"></a>

<a name="1071402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SLotman</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> C++ won't improve your rendering speed, you know? <br><br>Again: divide enemies by areas. If your hole map is 6400x6400 then divide it in 4 chunks (each 3200x3200) and only test coliisions on the area the player is. You'll probably have to divide it further, but that's the idea.<br><br>If still slow, just do rect-rect collisions on bullets/enemies, can't get any faster than that. Even EntityDistance may have an "Sqr" hidden in there, so it will be much slower then a simple position+width and height comparison.<br><br>Make sure your problems are really from the code area. Maybe your models have too much polygons for your video card, and it's slowing it down having too many of them on screen at once - try disabling collisions at all and see if the speed improves drastically, or remains the same.<br><br>How are you creating thos 100s ships? I hope you're using copyentity...<br><br>Also, avoid using sprites. They slows down things a lot. Create QUADs facing the camera, and update them manually if needed.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1071448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Adam I don't think you understood what either I or Warner are suggesting.<br><br>You don't have to have a grid of size 1 pixel per grid square.  You simply allocate 'zones' or 'areas' - perhaps if your map is 6400 pixels by 6400 pixels then split into areas of size say 200x200 giving you an array size of 32x32 - and store the units that are within each 'area' in their own bank and do collision checks between those within their own and neighbouring cells.<br><br>Trust me, it works well and is extremely fast - blitz is more than capable of having a game with hundreds (or even thousands) of units moving around.. <br><br></td></tr></table><br>
<a name="1071478"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now that I properly understand the zone concept, that's actually what I said I'd do in the end:<br><br><div class="quote"> de-colliding enemies when more than a certain distance offscreen <br></div><br>Only difference here is that it's just one zone that moves with the player rather than dividing the map into static ones.<br><br>As far as C++, I know it won't improve render time; that's why I kept stating LOGIC time. Blitz3D's rendering goes as fast as any DX7 renderer, of this I'm aware, however its logic just has too much overhead, being such a high-end language; hell, it can't even power through a 75KB peek/poke bank without taking at least 11ms.<br><br>For <b>Distance()</b> versus <b>EntityDistance</b>, yes they both use <b>Sqr()</b>, but theoretically <b>EntityDistance</b> needs extras to accommodate the third dimension. I might end up cutting my losses and using simple rect collision on smaller, less complex enemies.<br><br>As far as quads versus sprites, I was unaware of that distinction; I've had little trouble with sprites in excess of 2,500, but if quads can be even faster then hell I'll rip it out and change it anyway; thanks for the tip.<br><br>Collisions, yes I am sure about those; I've done tests that confirm for me the fact that while 400 sprites can move and update quite easily for me, 400 sprites with sphere-to-sphere intercollision cannot; they quickly instigate the spiral of death, as the LOGIC (!=rendering) takes too long. My computers are a pretty good example of mid-market machines, which is more or less my target audience, so if the program doesn't run on my machines it needs work. I should probably test sphere-to-box collisions, however, those would theoretically be much faster; with 400 enemies on sphere-to-sphere there's bound to be 160,000 MULTIPLE calls of <b>Sqr()</b>, whereas with sphere-to-box it should theoretically only be 400 calls of <b>Sqr()</b>. I'll see what I can do there.<br><br>Oh, one final thing, the ships are being created from scratch with <b>CreateSprite()</b> - which will be replaced with <b>CreateQuad()</b>, using <b>CreateMesh()</b> - but they're all being textured from a single source. I'm not loading 100 sprites with their own individual yet identical textures, if that's what you're worrying. ;D <br><br></td></tr></table><br>
<a name="1071485"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SLotman</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> You shouldn't use CreateSprite() for each ship! This creates a brush for every and each one of them, instead of using the same brush for all.<br><br>Create juse 1 sprite, then use copyentity to create the others. Just that should give you a speed boost. <br><br></td></tr></table><br>
<a name="1071530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would disadvise using sprites. They're seem to be somewhat unreliable due to compatibility issues. <br><br></td></tr></table><br>
<a name="1071534"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Some of my users reported problems with my game engine as well, until I replaced the sprites by quads (see archives). Tho, I have to say I probalby cloned the sprites by accident, I used copyentity for some lamps, but then added a sprite while there was already one due to copyentity. Such clones at the same position will however couse extreme slowdowns.<br><br>So you say you're using sphere to sphere collision? If you don't need the collision response then you could also use EntityDistance instead. And as you said, 2D-Distance can be calculated using Pytagoras: <br><br>dist2d#=sqr((xdist#*xdist#)+(ydist#*ydist#))<br>then simply ask is dist2fd is smaller than radius of sprite*2.<br><br>Tweening. I am not a fan of it. It really doesn't make sense to call Updateworld() twice only because a frame took longer than 16.667ms. As you already suggested, I would also use Delta here. Just use<br><br>delta#=(frametime#/16.667)<br>Now you can use it as a multiplication factor for any movement. And best of all, if you for some reason have animated meshes in your game, use Updateworld(delta#) and the animation will be adjusted to the framerate. <br><br></td></tr></table><br>
<a name="1071568"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, delta time definitely avoids the whole spiral-of-death problem. My only two quibbles with it are that it can't poll additional user inputs, and Blitz floats aren't exactly accurate, but I think in the end I'll just use it. Blitz' tweening capability is a great idea, but in execution it just doesn't always work out too well. :p <br><br></td></tr></table><br>
<a name="1071891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't get the thing about the two quibbles. Why would you want to poll additional user input, is the framerate that low so a user could write some text between two frames? AFAIS usually controls are "pressed or not", kind of "walk pressed*delta". In my Opinion a framerate of 20+ is high enough for most controls (no?), although for the eyes there should be 60. The other thing, floats are not accurate. That's true for some situations. But for delta timing it never seemed to be a problem to me. There is the system timer with its millisecsonds resolution. This may be considered inaccurate. And with delta there  is also this paradoxon: you measured the last frametime for delta and then use it for the current frame, this is also a source for inaccuracy.<br><br>If you need additional input polling, just add some additional keys and button handlers in you gameloop. You could also read the keys at many points in your code, and add the pressed Char to a string, then examine the string at a dedicated, single input handler. (btw. isn't inkey$ doing that automaticly? ) <br><br></td></tr></table><br>
<a name="1072008"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Which is faster?<br><br><b> sqr(X) </b><br>or<br><b> (X)^.5</b><br><br>Just a thought.I agree on sprites, theyr'e painful and outdated and I've been wanting to replace them for a long time, still haven't finished. <br><br></td></tr></table><br>
<a name="1072060"></a>

<a name="1072063"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you use the code I've posted in the archives then it's rather painless. It will override the original commands. (Maybe still needs a final cut, codewise, but the idea is there)<br><br>(BTW: There is A limitation: when you "FreeEntity" a Sprite, you will also have to "ReleaseSprite" it. Usually it's simple to find all places in your code where Sprites are freed, and add the command there. And such a quadbased Sprite will also be of EntityClass$ "Mesh" and not "Sprite", this may cause further problems. Well, just read the comments in the archive entry.<br><br>BTW2:<br><br><pre class=code>
b=16
Delay 500

t=MilliSecs()
For i=0 To 1000000
 a=b^0.5
Next
Print MilliSecs()-t

t=MilliSecs()
For i=0 To 1000000
 a=Sqr(b)
Next
Print MilliSecs()-t



WaitKey()
End



</pre><br>result:<br><br>887<br>55<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1072094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you put your two quibbles in a warm box and feed them lemons and sweetmeats they should be fine.<br><br>Here's a thought that avoids the hassle of creating a zone-based collision system, and should speed things up a bit.<br><br>Instead of running square roots on every permutation of objects, why not start with a recursive culling of the clearly-out-of-range objects:<br><br><pre class=code>
If abs(Thing1\x-thing2\x) &gt; 10 ; Or whatever your minimum collision distance would be
   If abs(Thing1\y-thing2\y)&gt; 10
      ;Run your distance check here
   EndIf
EndIf
</pre><br><br>I know it looks like it's repeating itself, but only for those few objects that are actually close enough to bother with.  For the great majority of objects the first If statement culls them quickly.<br><br>I've never done this, so I don't know, but it seems like it should work.<br><br>Come to think of it, for the collisions that don't include the player, the initial checks may be good enough; you could skip the square roots altogether. <br><br></td></tr></table><br>
<a name="1072100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, here's the proof.  I got a speed increase using my method of nearly a factor of 10.  Three methods are compared on collosions of 1000 objects (1,000,000 permutations):<br><br>1. Pythagoras on every one (takes ~490 ms)<br><br>2. First cull on x, then on y, then Pythagoras on those left over (takes ~86 ms)<br><br>3. Cull on x, cull on y, then we're done (settle for a rectangular collusion area)  (takes ~62 ms)<br><br>Methods 1 and 2 produce idential results, but 2 is much faster.  Method 3 is just a bit faster but less accurate.  I'd go with method 2.<br><br>Of course, varying the size of the overall area relative to the collision area will change the results, but probably not the fact that method 2 is more effiecient than method 1.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics(800,600,32,2)
SeedRnd(MilliSecs())

Type thing
	Field x#
	Field y#
End Type

Local i,t.thing,o.thing,distance#,count,start

For i=1 To 1000
	t.thing=New thing
	t\x=Rnd(100)
	t\y=Rnd(100)
Next

;Method 1

Print("Method 1 - Running Pythagoras on each pair")
start=MilliSecs()
For t.thing=Each thing
	For o.thing=Each thing
		If t.thing&lt;&gt;o.thing 
			If Sqr((t\x-o\x)^2+(t\y-o\y)^2)&lt;10.0 Then count=count+1
		EndIf
	Next
Next
Write("Collisions detected=")
Print(count)
Write("Time taken=")
Print(MilliSecs()-start)
Print

count=0

;Method 2

Print ("Method 2 - Culling first based on one dimension at a time")
start=MilliSecs()
For t.thing=Each thing
	For o.thing=Each thing
		If t.thing&lt;&gt;o.thing
			If Abs(t\x-o\x)&lt;10.0 ; These four lines are the only difference
				If Abs(t\y-o\y)&lt;10.0 ;These four lines are the only difference
					If Sqr((t\x-o\x)^2+(t\y-o\y)^2)&lt;10.0 Then count=count+1
				EndIf ;These four lines are the only difference
			EndIf ; These four lines are the only difference
		EndIf
	Next
Next
Write("Collisions detected=")
Print(count)
Write("Time taken=")
Print (MilliSecs()-start)
Print

count=0

;Method 3

Print ("Method 3 - If rectangular collisions are good enough to skip Pythagoras altogether")
start=MilliSecs()
For t.thing=Each thing
	For o.thing=Each thing
		If t.thing&lt;&gt;o.thing
			If Abs(t\x-o\x)&lt;10.0 ; Same here as before
				If Abs(t\y-o\y)&lt;10.0 ;Same here as before
					count=count+1 ;Skip Pythagoras; we're done
				EndIf ;Same here as before
			EndIf ; Same here as before
		EndIf
	Next
Next
Write("Collisions detected=")
Print(count)
Write("Time taken=")
Print (MilliSecs()-start)

WaitKey()
</textarea> <br><br></td></tr></table><br>
<a name="1072134"></a>

<a name="1072135"></a>

<a name="1072136"></a>

<a name="1072137"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SLotman</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's why I suggested first doing RECT collisions:<br><br><pre class=code>
function Collision%(x1%,y1%,w1%,h1%,x2%,y2%,w2%,h2%)       
  if (x1&lt;x2+w2) and (x1+w1&gt;x2) and (y1&lt;y2+h2) and (y1+h1&gt;y2) then return true
  return false
end function
</pre><br><br>This is fast as it can be - then you check for sphere collisions, or even use the built-in collisions commands. The function can be optimized a little more if using something like this:<br><br><pre class=code>
if (x1&lt;x2+w2) then if (x1+w1&gt;x2) then ...
</pre><br><br>So if any condition isn't met, it won't test all the other options.<br><br>Even on an old 486, I could test lots of objects with this code, without any slowdown.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1072152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It really doesn't make sense to call Updateworld() twice only because a frame took longer than 16.667ms. <br></div><br>It's actually essential, and the fact that delta-timing lets you do it just shows you how many mistakes delta-timing lets you get away with ;)<br><br>You're setting the target frame rate, so if your game doesn't reach it, whose fault is that? Either lower the target frame rate or speed up your game logic. It's pretty rare that a game needs to run its logic at 60 frames per second. It's usually a setting which ends up being left over when people convert from delta time because you can't get smooth updates with less than 60 fps with delta timing. Virtually all games could manage very nicely at 30 update cycles per second and you'd be amazed how many games could actually run perfectly well at just ten. If you can't optimize (or can't be bothered to try) your game logic then you can buy yourself so much more time be decreasing the target frame rate. <br><br></td></tr></table><br>
<a name="1072157"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> From my old Atari days I've learnt to use the Vsync, so the frame update will not interfere with the physical sync. That's what I still do. This way the target rate is the rate the user has set for his VSync, usually 60 Hz in Fullscreen. Users may turn off VSync and run the game with as many fps as they can, but basicly 60 is the desired rate. But on many older machines it won't reach 60. So it wil run (still vsynched) with 30, 20, 15, 12 or 10. Some users probably even play it with 2 fps or so. With delta I get the exact time factor, I don't understand why you say "because you can't get smooth updates with less than 60 fps with delta timing", Gabriel. Why not? <br><br></td></tr></table><br>
<a name="1072177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>That's why I suggested first doing RECT collisions:<br> <br></div><br><br><div class="quote"> <br>If still slow, just do rect-rect collisions on bullets/enemies<br> <br></div><br><br>Oh, I get it.  I thought by rect-rect you meant something like RectsOverlap().  So that means I basically fleshed out the method you mentioned and provided the evidence for Adam.  It should basically solve his collisions problem with minimum fuss.<br><br>Out of curiousity I ran a test on RectsOverlap() and it was about the same speed as method 3 and usually slightly faster, although I couldn't get the counts to match for some reason.  It should be a 20x20 square against a 0x0 point, which produces far more collisions than method 3.  Even a 5x5 against 0x0 produces slightly more.  Anyway, here it is.<br><br><pre class=code>
;Method 4

Print ("Method 4 - RectsOverLap")
start=MilliSecs()
For t.thing=Each thing
	For o.thing=Each thing
		If t.thing&lt;&gt;o.thing
			If RectsOverlap(t\x-2.5,t\y-2.5,5,5,o\x,o\y,0,0)
				count=count+1 ;Skip Pythagoras; we're done
			EndIf
		EndIf
	Next
Next
Write("Collisions detected=")
Print(count)
Write("Time taken=")
Print (MilliSecs()-start)
</pre> <br><br></td></tr></table><br>
<a name="1072179"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> With delta I get the exact time factor, I don't understand why you say "because you can't get smooth updates with less than 60 fps with delta timing", Gabriel. Why not?  <br></div><br>It's a rather complex issue, and not really the discussion I was trying to make. One big reason would be that there is no VSync in Windowed mode. So while you *might* get good results in a window, you also might not. It's entirely dependant upon what the OS wants to do. <br><br></td></tr></table><br>
<a name="1073079"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam Novagen</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, sorry to revive this thread after a couple of days' inactivity, but I only just remembered to check it again and I didn't want you all to think I was just ignoring you, after all the help you've given out.<br><br>So, for the time being I've actually REMOVED enemy intercollisions altogether, not as a copout so much as a design choice. When I started thinking about the various shmups I've played - Touhou, Geometry Wars and so forth - I honestly couldn't think of a single one where the enemies collided with each other, or needed to for that matter. All they really need to collide with, as I see it right now, are the map walls, and so far it's working out great.<br><br>I'm in the MASSIVE process of replacing every occurrence of sprites in my code with my quads, and have been surprised to see a distinct increase in rendering efficiency. This interests me, what exactly is it about the nature of B3D sprites that makes them more expensive to render than a quad?<br><br>By the by, K &amp; jfk, where exactly do exponents enter into this? I'm a bit confused as to why they'd be used instead of <b>Sqr()</b> in the first place. &gt;.&gt; <br><br></td></tr></table><br>
<a name="1073125"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Foppy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Only difference here is that it's just one zone that moves with the player rather than dividing the map into static ones. <br></div>Well, the difference is that if you do a distance check to all enemies and bullets, that means you are still computing 500 distances every fraction of a second if you have 500 enemies and bullets. The same is true by the way for collisions between your bullets and enemies. So if you have 100 bullets on screen, and 100 enemies, you would have 10.000 distance checks...<br><br>Using a grid-system where enemies and bullets are in separate linked-lists of objects for separate grid zones, you can have direct access to only those objects that are in grid areas adjacent to the area the player or one of his bullets is in, which in general means massive savings.<br><br>That being said if the game runs fine without a grid I guess it runs fine. :) <br><br></td></tr></table><br>
<a name="1073142"></a>

<a name="1073143"></a>

<a name="1073884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> For <b> X^Y=Z </b>:<br><br>If Y is a whole number (ie 2) Z is a Y to the power of X.<br>If Y is a float/fraction, Z is the X root of Y{EDIT: DENOMINATOR OF Y}<br>If Y is negative, Z is the reciprical of X^(abs(Y))<br><br>But as JFK pointed out, sqr() would be WAY faster for hypotenous distance checks. BTW JFK, thanks for testing that, my whole next project was gonnna rest on pythagoreas, never bothered to test it, figured they'd be about the same.<br><br>On sprites, as was said, using copyentity() instead of Create is always better. But, good man to eliminate sprites, their compatibility is attrocious and having more than ~250 in one locale pushines your FPS down by maybe half.<br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1073249"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I'm in the MASSIVE process of replacing every occurrence of sprites in my code with my quads,<br> <br></div><br><br>Of course, you should use CopyEntity() with your quads too whenever possible.  It should boost efficiency a lot; at least it does for other meshes, and quads are just meshes. <br><br></td></tr></table><br>
<a name="1073294"></a>

<a name="1073295"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Foppy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another thing, pointed out to me by GfK once if I am not mistaken, is that if you check for collisions or something else between 4 objects, you don't always need 4*4 checks because that would mean checks between the same objects are done twice.<br><br><pre class=code>
For object1.OBJECT = each OBJECT
   For object2.OBJECT = each OBJECT
      ; ...
   Next
Next
</pre><br>would result in 16 checks:<br><pre class=code>
a: a,b,c,d
b: a,b,c,d
c: a,b,c,d
d: a,b,c,d
</pre><br><br>A is checked against B, but later on B is checked against A. You can avoid that by not looking at all objects in the inner loop, but only at those following object1:<br><pre class=code>
For object1.OBJECT = each OBJECT
   object2.OBJECT = After object1
   While object2 &lt;&gt; null
      ; ...
      object2 = After object2
   Wend
Next
</pre><br>would result in 6 checks:<br><pre class=code>
a: b,c,d
b: c,d
c: d
d:
</pre><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1074407"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why not make custom functions named Createsprite(), etc. that would override Blitz Native Functions, as opposed to replacing "every occurence"? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
