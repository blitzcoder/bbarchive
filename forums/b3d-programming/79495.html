<!DOCTYPE html><html lang="en" ><head ><title >bisectmesh() function?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >bisectmesh() function?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >bisectmesh() function?</a><br><br>
<a name="892613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> To blow stuff up real good, it would be interesting to have a function that bisects a mesh along some random plane, leaving you with two meshes.  Then you can do it again on each half, etc.  In conjunction with particles this could enliven those explosions with unique chunks of stuff flying around.<br><br>Is there a function out there already?  I couldn't find one.<br><br>an example in partial pseudocode:<br><br><pre class=code>
function bisectmesh(oldmesh)
  origpitch#=entitypitch(oldmesh)
  origyaw#=entityyaw(oldmesh)
  origroll#=entityroll(oldmesh)
  ;The above is so we can move it back when we're done

  my#=entityy(oldmesh);  
 
  rotateentity(oldmesh,rnd(360),rnd(360),rnd(360))
  
  newmesh=CreateMesh()

  for each vertex:
    if VertexY(...) &lt; my# then move this vertex to the new mesh
  next

  ...

end function
</pre><br><br>Of course triangles have to by moved as well.<br><br>The problem is the exposed area of both meshes; if the object is hollow (like a car or tank, for example) then a copymesh()/flipmesh() could be the easiest solution.  If it is a rock, however, you have to create new triangles between assorted existing vertices, which I don't want to do if it's been done already.<br><br>Hence my question here today.<br><br>Thanks in advance. <br><br></td></tr></table><br>
<a name="892621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_33</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wanted to do a function like this but didn't have the skills.  There is something similar in the code archive made by big10p, only the "in-between" triangles are missing.  But otherwise, it truncates a model by a given plane. <br><br></td></tr></table><br>
<a name="892627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >srcoder</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sounds like a fun project. <br>BSP maps slice geometry exactly across a plane and creates two triangles from any triangle that bisects the plane (it creates the additional vertex from a edge/plane intersect calculation) That would give a very clean cut and would make it slightly easier to calculate the vertices/faces to make up the "hole".<br>Anyone know of code to do that? <br><br></td></tr></table><br>
<a name="892633"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> _33:  Wow.  That's pretty close to what I was looking for, and better written than mine would have been.  I've been browsing his code archive articles; there are several good ones in there.<br><br>He does calculate the missing vertices, just doesn't close them with triangles (his purpose was to create a smooth edge).  It should be pretty simple to close the gap.<br><br>srcoder:  Thanks for the tip.  I'll check that out too. <br><br></td></tr></table><br>
<a name="892646"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>It should be pretty simple to close the gap.<br> <br></div><br><br>It isn't really.  You should look at some of the triangulation routines in the archives.  Basically, you would need to create a list of the vertices which lie on the intersection plane, in clockwise order IIRC and pass them to the triangulate function.  <br><br>Getting them in the correct order is probably the most difficult part. Thinking about it, you could find the center of all the vertices which sit on the plane and store each vertex angle to the center point.  Then sort this  list based on it's angle.  This would probably only work with simple convex shapes.<br><br>Stevie <br><br></td></tr></table><br>
<a name="892678"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Clever idea.  I was assuming (hoping, really) two things: <br><br>1. It would be possible to grab the new vertices into a list as they are created; then I don't have to find them. <br><br>2. That the vertices are created in order around the gap, thus making it easy to link adjacent pairs to a central vertex (or to a selected one of the new vertixes - that's how cylinder caps are done).<br><br>Even if 2 is not true, it should be possible to iterate through the triangles looking for those with exactly two of the new vertices; these would be adjacent.  From that you could get the order.  Wait - you no longer need the order; each set of new vertices in an triangle...<br><br>Wait, make it simpler, for each new triangle created it creates another one linking the two new vertices to the center vertex (yes it must be convex). <br><br></td></tr></table><br>
<a name="892682"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ricky Smith</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Depending on the complexity of the models, the routines to calculate this on the fly would probably cause too much slowdown in a real time situation. Especially if you have a large amount of explosions. You would also have to recalculate the uv coordinates and vertex normals etc.<br>It would be much more efficient to create and texture the mesh pieces in a modeller and then use these as particles. <br><br></td></tr></table><br>
<a name="892686"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> big10p's function is quite fast; and we're talking exploding rocks here so they're probably not that complex except for maybe the original one.<br><br>The problem with the loaded media approach is they cause a big problem; players abandon games when they start looking too samey.  When each explosion has the same identical chunks as the previous ones, something is wrong.<br><br>You're right that time management would be important.  You could create a list of pending breaks and do only one per frame.<br><br>But just think about it; RoadWar; you blast the car in front of you and a chunk of its fender flies back and hits your car.  And, the chunks (completely unique) are still lying there for you to hit each lap.  Awesome! <br><br></td></tr></table><br>
<a name="892728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> A thought on concave meshes (u-shaped, bowl shaped, etc.) in which separate sections are cut apart.  The following method should solve part of it:<br><br>- Collect the new vertices<br>- Identify adjacencies by examining triangles<br>- Follow adjacencies around the loop<br>- If there are any vertices left over, then you have another section in a concave mesh, so continue until all the vertices are accounted for.<br><br>This also allows you to place your central vertex within each loop correctly.  Granted, if the loop itself is concave you still need to detect that (using your method of angle checking perhaps) and try to find an acceptable point.  This is a difficult problem that would need to be solved for any serious applications such as a modeller.<br><br>Do any modellers have a "knife" function like this?<br><br>Some game ideas:<br><br>A rather gruesome Samurai game concept comes to mind ...  make your own gibs!<br><br>Or how about... Sandwich Maker Pro!  Slice the bread, the ham, the cheese, and position it all together.  Sounds like a big seller... :D<br><br>Maybe you have to slice up monsters and make sandwiches out of them!!!  (Of course they keep attacking with whatever remaining body parts they have)  Eat the sandwich to restore health. The sliced areas chould have the stylized internal bone organ structure textured in.<br><br>I never knew I was such a sicko! <br><br></td></tr></table><br>
<a name="892737"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>The problem with the loaded media approach is they cause a big problem; players abandon games when they start looking too samey. When each explosion has the same identical chunks as the previous ones, something is wrong.<br> <br></div><br><br>I think you're better sticking to this approach.  There is no reason you can't make several versions of the same object with different breakable parts for some variation.  For realtime use, the method you're suggesting will be slower than a week in the jail unless your meshes are very simple. <br><br></td></tr></table><br>
<a name="892750"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_33</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Axel Wheeler, if you manage to program that routine, I'm interested in the source :P <br><br></td></tr></table><br>
<a name="892812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Naughty Alien</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> in Crysis, every breakable tree is actually already cut inside modeling program in to bunch of smaller pieces..there is no on the fly cut off things.. <br><br></td></tr></table><br>
<a name="892819"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> _33: Ok, I'll let you know if I get it together.<br><br>Thanks for the advice, everyone! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
