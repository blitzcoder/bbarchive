<!DOCTYPE html><html lang="en" ><head ><title >Raycasting Evenly in Arbitrary Hemisphere?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Raycasting Evenly in Arbitrary Hemisphere?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Raycasting Evenly in Arbitrary Hemisphere?</a><br><br>
<a name="805350"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I decided to put this in B3D Programmming because it's very 3D and probably makes more sense here than in General.<br><br>I'm trying to work out a method of raycasting a hemisphere which has to be aligned to the normal of a surface. EG: if the surface normal is -1,0,0 then the hemisphere would extend to 0,1,0 and 0,-1,0 in a complete 360 arc on the x axis but only 180 degrees on the z axis. Ah heck, a picture's worth 1000 words, so here's a pic.<br><br><img src="http://www.shadersforgames.com/Ray.jpg"><br><br>The red arrows point *at* the vertex, in the *direction* of the normal.<br><br>I want to cast rays out, only through that hemisphere and with a configurable, even distribution. In other words, I want to be able to specify the density of the raycasts so that I can do lots or few, depending on how accurate I want to be.<br><br>I'm just struggling with the maths to get the vector to cast, because it has to be relative to an arbitrary normal and then evenly within that hemisphere.<br><br>My gut tells me I should be using some kind of points on a sphere algorithm and then discaring half of the points by comparing to the surface normal somehow, but I'm not 100% sure if that's right or how go to about it. <br><br></td></tr></table><br>
<a name="805359"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Basically, I guess you're going to need some code to rotate a 3D vector, which will probably require some matrix math. Then, you can rotate the vector around the base of the hemisphere, rotate the vector 'up' by x amount, and repeat until the entire hemisphere is scanned. Gah, does that make sense?<br><br>[edit] Actually, I'm informed it is possible to do 3d vector rotation without the use of matrices. <br><br></td></tr></table><br>
<a name="805397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I have a function which will rotate a vector to any given quaternion orientation. Your description of covering the hemisphere line by line, rotating up a little at each stage does make sense. That only leaves me with the question of orienting all that to the surface. However, I guess the best way to do that would be afterward. Precalculate a set of vectors for a 0,1,0 normal oriented hemisphere and then rotate them all wholesale to the orientation of each normal as I go.<br><br>Yeah, it sounds ok in theory. I'll have a go at coding it up. Thanks for the idea. <br><br></td></tr></table><br>
<a name="805441"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here are some notes I made a while back which should be of some help.  The idea here was to be able to specify a point on a sphere, and then find random points around that point that had a uniform distribution.  One's first instinct would be to just use polar coordinates to calculate these points, but doing so results in pole clustering.  <br><br>What's pole clustering?<br><br>If you imagine a camera pointing 45 degree up, and you turn, taking a photo every 45 degrees, and then point it straight up and do the same thing, you'll understand that the center of all the images on the second set are actually the same point.  That's pole clustering.  If you use polar coordinates with the center point being one of the poles, then you'll get a lot more points around the central point than out a ways from it.<br><br><br>Anyway here's the algorithm which avoids the pole clustering issue:<br><br><br>Finding uniform random points around a point on a sphere:<br>---------------------------------------------------------<br><br>Find a point on the unit sphere:<br>P = (a,b,c)  <br><br>The first step is to find a point N on the unit sphere which is 90 degrees (arc length) away.<br><br>N = (a/sqrt(a^2+b^2) ,  -b/sqrt(a^2+b^2), 0)    <br>will work unless a=b=0.<br><br>now let T = PxN. so P,N,T are at right angles to each other<br><br>now let's see. we want to parameterize the circle of radius r centered at P<br><br>R = P*cos(r) + N*sin(r)*cos(t) + T*sin(r)*sin(t) should work<br><br>pick a random angle t between 0 and 360 and you have a random point in the circle<br><br>So in sphere space using P(0,0,1) N(0,1,0) T(1,0,0):<br><br>r = radius from point at 0,0,1<br>t = random number between 0 and 360<br><br>Rx = sin(r)*sin(t) <br>Ry = sin(r)*cos(t)<br>Rz = cos(r)<br><br><br>So "point on the unit sphere" = Your surface normal.<br>Radius = Random number from 0 to 180, for a hemisphere centered on the tip of your normal.<br>T = Random number from 0 to 360.<br><br>You'll have to figure out how that works into the stuff above cause I have to go eat dinner and I wrote this so long ago I forget how you calculate it but it's all there in the notes. :-) <br><br></td></tr></table><br>
<a name="805443"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> This may be of some help too:<br><br><br><br>Finding UNFORM random points on a sphere:  (Ie: no pole clustering)<br>----------------------------------<br>choose a random angle t and a random number z between -1 and 1, then let r=sqrt(1-z^2), x=r*cos(t), y=r*sin(t).<br>then (x,y,z) is a random point on the sphere<br>(of radius 1, centered at the origin)<br><br><br>OR:<br><br>To generate a random point on the sphere, it is necessary only to generate two random numbers, <br>z between -R and R, <br><br>phi between 0 and 2 pi, each with a uniform distribution<br><br>To find the latitude (theta) of this point, note that z=Rsin(theta), so: <br><br>theta=sin-1(z/R)<br><br>its longitude is phi.<br><br>In rectilinear coordinates:<br><br>x=R*cos(theta)*cos(phi)<br>y=R*cos(theta)*sin(phi)<br>z=R*sin(theta)=z<br><br>Note that in both methods points will appear to be  clustered if you attempt to step through it.  The lattitude lines become more sparse as the longitude lines become <br><br>more dense, so random points will be evenly distributed, but if you plot even lonigtude lines it will look wrong.<br><br><br><br>if you enclose a sphere in a cylinder (with no top or bottom) then the sphere and the cylinder have the same surface area.<br><br>moreover,if you project from the cylinder to the sphere, towards the axis of the cylinder, then this projection preserves area.<br><br>so, to choose random points on a sphere, you can just choose random points on a vertical cylinder, then project the points horizontally to the sphere.<br><br>The height of the cylinder is the diameter of the sphere. <br><br></td></tr></table><br>
<a name="805447"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, this 'pole clustering' effect of the method I described did occur to me. However, I figured as this is for raycasting maybe taking more samples nearer to the pole would be a good thing? <br><br></td></tr></table><br>
<a name="805451"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks a lot for all the reading material, SSwift. I think I'm generating some spheres with nicely distributed points now. I'm discarding all the vectors with Y&lt;0 to get my hemisphere, so all that's left is to find the angle ( as a quaternion ) between any two given normals. It's probably simple, but I can't for the life of me remember how. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
