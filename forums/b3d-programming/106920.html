<!DOCTYPE html><html lang="en" ><head ><title >Simulating Simple Rigid Body Physics, Few Bounces</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Simulating Simple Rigid Body Physics, Few Bounces</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Simulating Simple Rigid Body Physics, Few Bounces</a><br><br>
<a name="1319970"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I saw old examples but still looking for some basic ones like a box that bounces a bit then just sit stationary.<br><br>I can't use 3rd party libs here just avoiding to mix physics engine and b3d collisions already in place. <br><br></td></tr></table><br>
<a name="1319974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> search for "reflection vector" "billard physics" "marble physics", there are a few examples in the forums/codearchives <br><br></td></tr></table><br>
<a name="1319997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks RemiD. I found one though I need something simple just can detect and bounce walls and a few on the ground. probably like cannonball physics with a very few bounces. <br><br></td></tr></table><br>
<a name="1320019"></a>

<a name="1320020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> "reflection vector" is what you are looking for.<br><br>an old example by Bobysait :<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Const COL_WALL% = 1 
Const COL_BALL% = 2 
 
Graphics3D 800,600,0,2 
SetBuffer BackBuffer() 
 
 
; - j'applique les collisions - 
	Collisions COL_BALL,COL_WALL,2,1 ; Sphere/poly -&gt; Stop ! 
 
 
; - coordonnées de ma balle - 
	Local Ballx#,Bally#,Ballz#, BallRadius# = 4.0 
	Local BallSpeed#=Rnd(1,2) ; vitesse/Norme du déplacement 
	Local Ball%	=	CreateSphere	( 16 ) 
					ScaleEntity		( Ball, BallRadius,BallRadius,BallRadius ) 
					EntityColor		( Ball, 255,050,050 ) 
					EntityShininess	( Ball, .6 ) 
					EntityRadius	( Ball, BallRadius ) ; /!\ le radius doit faire le rayon de ma sphere !!! 
					EntityType		( Ball, COL_BALL ) 
 
	; vecteur déplacement de la balle 
	Local BallVx#=Rnd(-1,1), BallVy#=Rnd(-1,1), BallVz#=Rnd(-1,1) 
	; je normalise mon vecteur ( comme il est en random, sa taille ne fait pas "1", donc, je le normalise ) 
	Local n# = Sqr(BallVx*BallVx + BallVy*BallVy + BallVz*BallVz) ; pythagore -&gt; diagonale² = somme des carrés des cotés 
	BallVx=BallVx/n : BallVy=BallVy/n : BallVz=BallVz/n 
 
 
; - le "mur" - 
	Local Wall1	=	CreateCube		( ) 
					ScaleMesh		( Wall1, 50,40,30 ) 
					FlipMesh		( Wall1 ) 
					EntityType		( Wall1, COL_WALL ) 
	 
	; - deuxième demo -&gt; la balle rebondis dans une "cage" sphérique - [touche F2] 
	; une sphere, pleine de poly, pleine de surfaces de contact avec des normales différentes, trop cool ^^ 
	Local Wall2	=	CreateSphere	( 6 ) 
					ScaleMesh		( Wall2, 50,40,30 ) 
					FlipMesh		( Wall2 ) 
					EntityType		( Wall2, COL_WALL ) 
					HideEntity		( Wall2 ) 
 
; - visu - 
	Local piv=CreatePivot() 
	Local pit=CreatePivot(piv) 
	Local cam=CreateCamera(pit) 
	MoveEntity cam,0,0,-70 
	TurnEntity pit,45,0,0 
 
; - tu vas où sans lumière ?! - 
	Local Light1	=	CreateLight(2):PositionEntity Light1,+0500,+0300,+0200:LightRange Light1,0500:LightColor Light1, 200,100,255 
	Local Light2	=	CreateLight(3):PositionEntity Light2,+0000,+1000,+1000:LightRange Light2,2500:LightColor Light2, 128,100,100 
						AlignToVector Light2,0,-.6,-.3,3,1 
 
 
Local wire%=False 
Local demo%=0 
 
Repeat 
	 
	; ------------------------------------------------------------ / Inputs 
	; touche [F1] -&gt; wireframe 
	If KeyHit(59) Then wire=1-wire:Wireframe wire 
	 
	; touche [F2] -&gt; switch demos 
	If KeyHit(60) 
		demo=1-demo 
		If demo=1 
			ShowEntity Wall2 
			HideEntity Wall1 
		Else 
			ShowEntity Wall1 
			HideEntity Wall2 
		EndIf 
		 
		; reset la baballe -&gt; sinon, entre le cube et la sphere, y a des zones de vide 
		; si la balle se trouve dedans, elle partira peut être à l'infini ^^ 
		PositionEntity Ball , 0,0,0 
		ResetEntity Ball 
		 
	EndIf 
	 
	; touche  [Space] -&gt; random le vecteur 
		If KeyHit(57) 
			BallVx=Rnd(-1,1): BallVy=Rnd(-1,1): BallVz#=Rnd(-1,1) 
			n=Sqr(BallVx*BallVx+BallVy*BallVy+BallVz*BallVz) 
			BallVx=BallVx/n : BallVy=BallVy/n : BallVz=BallVz/n 
			BallSpeed#=Rnd(0.1,3.0)
		EndIf 
	 
	; ------------------------------------------------------------ / Update 
	; - Update de ma Balle - 
		; j'enregistre les coordonnées avant déplacement 
		Ballx# = EntityX(Ball,1) 
		Bally# = EntityY(Ball,1) 
		Ballz# = EntityZ(Ball,1) 
		; je déplace 
		TranslateEntity Ball, BallVx*BallSpeed, BallVy*BallSpeed, BallVz*BallSpeed 
	 
	; ------------------------------------------------------------ / Update post-Collisions 
	; update des collisions 
		UpdateWorld() 
		 
		; si collisions : 
		Local nc= CountCollisions(Ball), i% 
		 
		If nc&gt;0 
			; nouvelles coordonnées de la balle après impact 
			Local NewX# = EntityX(Ball,1) 
			Local NewY# = EntityY(Ball,1) 
			Local NewZ# = EntityZ(Ball,1) 
			 
			; trajet effectué avant impact 
			Local dx# = NewX - Ballx 
			Local dy# = NewY - Bally 
			Local dz# = NewZ - Ballz 
			 
			For i= 1 To nc 
				 
				; normale de collision 
				Local nx# = CollisionNX(Ball,i) 
				Local ny# = CollisionNY(Ball,i) 
				Local nz# = CollisionNZ(Ball,i) 
				 
				; réflexion du vecteur 
				Local dot# = nx*BallVx+ny*BallVy+nz*BallVz  ; dot product -&gt; donne l'angle entre 2 vecteurs tel que : dot = Cos(ang) &lt;-&gt; ang = ACos(dot) 
				; à noter que dans mes calculs, mes vecteurs sont NORMALISES ! 
				 
				BallVx = BallVx - 2* nx * dot 
				BallVy = BallVy - 2* ny * dot 
				BallVz = BallVz - 2* nz * dot 
				 
				; je déplace maintenant ma balle le long de ce vecteur pour terminer le trajet 
				Local d# = Sqr(dx*dx+dy*dy+dz*dz) ; distance déjà parcourue 
				Local d2# = BallSpeed - d 
				 
				TranslateEntity Ball, BallVx*d2, BallVy*d2, BallVz*d2 
				 
			Next 
			 
		EndIf 
		 
	; ------------------------------------------------------------ / render 
	; maintenant on peux rendre la scène . 
		; - j'update ma camera - 
		Local msx=MouseXSpeed() 
		Local msy=MouseYSpeed() 
		If MouseDown(1) 
			TurnEntity piv,0,-msx,0 
			TurnEntity pit,msy,0,0 
		EndIf 
		 
		RenderWorld() 
		 
	; ------------------------------------------------------------ / flip 
	Flip() 
	 
Until KeyHit(1) 
End() 
</textarea> <br><br></td></tr></table><br>
<a name="1320021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome! This is just what I need :D so simulating force, momentum or whatever, how do I make it stop? Like throwing a rock normally or off the wall.<br><br>Examples like this should be in the code archives, good one. <br><br></td></tr></table><br>
<a name="1321459"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> another example with basic physics :<br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=2029" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=2029</a> <br><br></td></tr></table><br>
<a name="1321465"></a>

<a name="1321466"></a>

<a name="1321467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's a very old sample from Blitz3DFr, Isn't it ?<br><br>Maybe a small update could be fine (so here it is)<br><br>it contains a small vector library and the "body" for a rigidbody library<br>(the rigid box is not implemented yet, but I think it could be composed from 8 small spheres, and updated with a verlet stuff, so it could implement torque and stuff ...)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; ----------------------------------------------------------------
; small vector3 sdk
; ----------------------------------------------------------------
Type Vec3
	Field X#,Y#,Z#
	End Type
	
	; constructor
	Function NewVec3.Vec3(x#=0,y#=0,z#=0) : Local v.Vec3 = New Vec3 : v\X=x : v\Y=y : v\Z=z : Return v : End Function
	; Copy
	Function Vec3Copy.Vec3(src.Vec3) : Return NewVec3(src\X,src\Y,src\Z) : End Function
	; destructor
	Function FreeVec3.Vec3(v.Vec3) : If (v&lt;&gt;Null) : Delete v : EndIf : Return Null: End Function
	; Set
	Function Vec3Set.Vec3(v.Vec3,x#,y#,z#) : v\X=x : v\Y=y : v\Z=z : Return v : End Function
	Function Vec3SetX.Vec3(v.Vec3,x#) : v\X=x : Return v: End Function
	Function Vec3SetY.Vec3(v.Vec3,y#) : v\Y=y : Return v: End Function
	Function Vec3SetZ.Vec3(v.Vec3,z#) : v\Z=z : Return v: End Function
	Function Vec3Assign.Vec3(v.Vec3, src.Vec3) : Return Vec3Set(v,src\X,src\Y,src\Z) : End Function
	; Get
	Function Vec3X#(v.Vec3) : Return v\X : End Function
	Function Vec3Y#(v.Vec3) : Return v\Y : End Function
	Function Vec3Z#(v.Vec3) : Return v\Z : End Function
	; transform
	Function Vec3Add		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X+q\X,v\Y+q\Y,v\Z+q\Z) : End Function
	Function Vec3SelfAdd	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X+q\X,v\Y+q\Y,v\Z+q\Z) : End Function
	Function Vec3Sub		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X-q\X,v\Y-q\Y,v\Z-q\Z) : End Function
	Function Vec3SelfSub	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X-q\X,v\Y-q\Y,v\Z-q\Z) : End Function
	Function Vec3Mul		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X*q\X,v\Y*q\Y,v\Z*q\Z) : End Function
	Function Vec3SelfMul	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X*q\X,v\Y*q\Y,v\Z*q\Z) : End Function
	Function Vec3Div		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X/q\X,v\Y/q\Y,v\Z/q\Z) : End Function
	Function Vec3SelfDiv	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X/q\X,v\Y/q\Y,v\Z/q\Z) : End Function
	Function Vec3Scale		.Vec3(v.Vec3,s#)	: Return NewVec3	(  v\X*s,v\Y*s,v\Z*s)		: End Function
	Function Vec3SelfScale	.Vec3(v.Vec3,s#)	: Return Vec3Set	(v,v\X*s,v\Y*s,v\Z*s)		: End Function
	Function Vec3Normalize	.Vec3(v.Vec3)		: Return Vec3Scale	(v, 1.0/Sqr(Vec3Dot(v,v)))	: End Function
	Function Vec3SelfNormalize.Vec3(v.Vec3)		: Return Vec3SelfScale(v, 1.0/Sqr(Vec3Dot(v,v))): End Function
	Function Vec3Cross		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\Y*q\Z-v\Z*q\Y, v\Z*q\X-v\X*q\Z, v\X*q\Y-v\Y*q\X) : End Function
	Function Vec3SelfCross	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v, v\Y*q\Z-v\Z*q\Y, v\Z*q\X-v\X*q\Z, v\X*q\Y-v\Y*q\X) : End Function
	; dot, length etc ...
	Function Vec3Dot#(a.Vec3,b.Vec3) : Return a\X*b\X+a\Y*b\Y+a\Z*b\Z : End Function
	Function Vec3Length#(v.Vec3) : Return Sqr(Vec3Dot(v,v)) : End Function
	Function Vec3SqLength#(v.Vec3) : Return Vec3Dot(v,v) : End Function
	
; not yet used -&gt; should be required for torque (unless I update it using quaternions)
Type Mat3
	Field I.Vec3
	Field J.Vec3
	Field K.Vec3
	End Type
	
	Function NewMat3.Mat3()
		Local m.Mat3 = New Mat3
		m\I = NewVec3(1,0,0)
		m\J = NewVec3(0,1,0)
		m\K = NewVec3(0,0,1)
		Return m
	End Function
	
; so as a transform class that holds the rotation and position for an entity (probably useless ...)
Type Transform
	Field M.Mat3
	Field V.Vec3
	End Type
	
	Function NewTransform.Transform()
		Local t.Transform = New Transform
		t\M = NewMat3()
		t\V = NewVec3()
		Return t
	End Function
	
	
; Physic body (rigid body)
Type RigidBody
	Field Style%; sphere(1) or box(3)
	Field Sub; handle from extended type
	Field Entity; the blitz entity this physic body is attached to.
	Field Position.Vec3; center of mass
	Field Velocity.Vec3; velocity
	Field Speed#
	Field Friction#
End Type
	
	;(private) rigid body constructor -&gt; called by extended rigidbody class
	Function NewRigidBody.RigidBody(Entity, style, SubHandle%)
		Local body.RigidBody = New RigidBody
		body\Sub = SubHandle
		body\Position = NewVec3()
		body\Velocity = NewVec3()
		body\Speed = 0.0
		body\Entity = Entity
		body\Style = style
		body\Friction = 1; by default : perfect body -&gt; no friction in collisions.
		Return body
	End Function
	
	;(public) rigidbody constructors
	; - extends rigid sphere
	Type RigidSphere
		Field Body.RigidBody
		Field Radius#
	End Type
	
	Function NewRigidSphere.RigidBody(entity, radius#)
		Local sphere.RigidSphere = New RigidSphere
		sphere\Body = NewRigidBody(entity, 1, Handle(sphere))
		sphere\Radius = radius
		Return sphere\Body
	End Function
	
	; - extends rigid box (not yet available)
	Type RigidBox
		Field Body.RigidBody
		Field box#[6]
	End Type
	
	Function NewRigidBox.RigidBody(entity, x#=-1,y#=-1,z#=-1,w#=2,h#=2,d#=2)
		Local box.RigidBox = New RigidBox
		box\Body = NewRigidBody(entity, 1, Handle(box))
		box\Box[0] = x
		box\Box[1] = y
		box\Box[2] = z
		box\Box[3] = w
		box\Box[4] = h
		box\Box[5] = d
		Return box\Body
	End Function
	
	; update bodies moves (only process the initial moves)
	Function MoveRigidBodies(AppCoef#=1.0)
		
		; temporary vectors
		Local l_Gravity.Vec3=	Vec3Scale(GRAVITY, AppCoef)
		Local l_Wind.Vec3	=	Vec3Scale(WIND, AppCoef)
		Local l_V.Vec3		=	NewVec3()
		
		; iterate through rigid bodies and add force
		Local l_Body.RigidBody
		For l_Body = Each RigidBody
			; compute velocity to apply to position
			; v = body\vel * body\Speed * AppCoef + GRAVITY + WIND
			Vec3Assign		( l_V, l_Body\Velocity ); v = body\velocity
			Vec3SelfScale	( l_V, l_Body\Speed*AppCoef ); v = v * speed (*AppCoef)
			Vec3SelfAdd		( l_V, l_Gravity ); v = v + l_Gravity
			Vec3SelfAdd		( l_V, l_Wind ); v = v + l_Wind
			
			; add velocity to current position
			Vec3SelfAdd		( l_Body\Position, l_V )
			
			; process blitz moves
			PositionEntity	( l_Body\Entity, l_Body\Position\X, l_Body\Position\Y, l_Body\Position\Z, 1)
		Next
		
		; free temp vectors
		FreeVec3(l_V)
		FreeVec3(l_Gravity)
		FreeVec3(l_Wind)
		
	End Function
	
	; process post collisions-detection (collisions responses)
	Function UpdateRigidBodies%(AppCoef#, MaxColLoop% = 3)
		
		; update moves for all rigid bodies
		MoveRigidBodies(AppCoef)
		
		; temp vectors
		Local l_V.Vec3		=	NewVec3()
		Local l_ColP.Vec3	=	NewVec3()
		Local l_ColN.Vec3	=	NewVec3()
		
		; while collisions happened, bodies must be updated
		While (MaxColLoop&gt;0)
			
			MaxColLoop = MaxColLoop - 1
			
			; update blitz collisions
			UpdateWorld()
			
			Local l_CountCollisions% = 0
			
			Local l_Body.RigidBody
			For l_Body = Each RigidBody
				
				; get entity from the rigid body
				Local l_Ent = l_Body\Entity
				
				; new coords after collisions
				Vec3Set					( l_ColP, EntityX(l_Ent, 1), EntityY(l_Ent, 1), EntityZ(l_Ent, 1))
				
				; if collision occured
				If (CountCollisions(l_Ent)&gt;0)
					
					; wanted position - collision position
					Vec3Assign			( l_V, l_Body\Position ); l_V = position
					Vec3SelfSub			( l_V, l_ColP ); l_V = l_V - Collision
					; Remaining length (remaining energy after collision)
					Local d#		=	Vec3Length(l_V) * l_Body\Friction ; remaining = |l_V| * Friction
					
					; update velocity vector
					; -&gt; as the collision response is set to "Stop", there should be, at most, only one collision per entity
					; so we only test the collision for index "1"
					
					; collision normal
					Vec3Set				( l_ColN, CollisionNX(l_Ent,1), CollisionNY(l_Ent,1), CollisionNZ(l_Ent,1) )
					
					; reflect velocity by the collision normal =&gt; V' = V - N*2(V.N)
					Vec3SelfSub			( l_Body\Velocity, Vec3SelfScale	( l_ColN, 2.0*Vec3Dot(l_Body\Velocity, l_ColN) ) )
					Vec3SelfNormalize	( l_Body\Velocity )
					
					; moves the ball along the new velocity (l_V) times the remaining energy
					Vec3Assign			( l_V, l_Body\Velocity )
					Vec3SelfScale		( l_V, d )
					
					; new position + remaining energy
					Vec3SelfAdd			( l_ColP, l_V )
					PositionEntity		( l_Ent, l_ColP\X, l_ColP\Y,l_ColP\Z, 1)
					
					l_CountCollisions = l_CountCollisions+1
				EndIf
				
				; update new position
				Vec3Assign			( l_Body\Position, l_ColP )
			Next
			
			; no collisions on this loop -&gt; we can quit the update loop
			If (l_CountCollisions&lt;1) Then Exit
		Wend
		
		; release temp vectors
		FreeVec3(l_V)
		FreeVec3(l_ColP)
		FreeVec3(l_ColN)
	End Function






Graphics3D	( 800,600,0,2 )
SetBuffer	( BackBuffer() );

; Init blitz collisions
	Const COL_WALL%		=	1
	Const COL_BALL%		=	2
	
	Collisions COL_BALL,COL_WALL,2,1 ; Sphere/poly -&gt; Stop !
	Collisions COL_BALL,COL_BALL,1,1 ; Sphere/sphere -&gt; Stop !
	
	; Gravity Vector
	Global GRAVITY.Vec3	=	NewVec3			( 0,-.197,0 );
	; Wind Vector
	Global WIND.Vec3	=	NewVec3			( -.02,0,.05 );
	
; Lights
	Local Light1		=	CreateLight		( 2 )
							PositionEntity	( Light1, +0500,+0300,+0200 )
							LightRange		( Light1,  500 )
							LightColor		( Light1, 200,100,255 )
	Local Light2		=	CreateLight		( 3 )
							PositionEntity	( Light2, +0000,+1000,+1000 )
							LightRange		( Light2, 2500 )
							LightColor		( Light2, 128,100,100 )
							AlignToVector	( Light2, 0,-.6,-.3, 3, 1 )
							
; Camera
	Local piv			=	CreatePivot		( )
	Local pit			=	CreatePivot		( piv )
	Local cam			=	CreateCamera	( pit)
							MoveEntity		( cam, 0,0,-70 )
							TurnEntity		( pit, 45,0,0 )
							
; - Collision scene -
	Local Wall1			=	CreateCube		( )
							EntityColor		( Wall1, 150,255,100 )
							EntityShininess	( Wall1, .2 )
							ScaleMesh		( Wall1, 50,40,30 )
							FlipMesh		( Wall1 )
							EntityType		( Wall1, COL_WALL )
							
	; - for second demo -&gt; the ball bounds inside a spherical scene (F2 to switch between demos)
	Local Wall2			=	CreateSphere	( 16 )
							EntityColor		( Wall2, 100,150,255 )
							EntityShininess	( Wall1, .3 )
							ScaleMesh		( Wall2, 50,40,30 )
							FlipMesh		( Wall2 )
							EntityType		( Wall2, COL_WALL )
							HideEntity		( Wall2 )
							
; Create some balls
	Local l_Body.RigidBody
	
	Local NBalls		=	25
	Local b
	Local Model			=	CreateSphere	( 16 )
							ScaleEntity		( Model, 1,1,1 )
							EntityShininess	( Model, .4 )
							EntityColor		( Model, 200, 080, 020 )
							EntityType		( Model, COL_BALL )
							EntityRadius	( Model, 1 )
							HideEntity		( Model )
	For b = 1 To NBalls
		Local l_radius#	=	Rnd(3,6)
		l_Body			=	NewRigidSphere	( CopyEntity(Model), l_radius )
							ScaleEntity		( l_Body\Entity, l_radius,l_radius,l_radius )
							EntityRadius	( l_Body\Entity, l_radius )
							Vec3Set			( l_Body\Position, Rnd(-5,5), Rnd(-5,5), Rnd(-5,5) )
							Vec3Set			( l_Body\Velocity, Rnd(-1,1),Rnd(-1,1),Rnd(-1,1) )
		l_Body\Speed		=	Rnd(1,2)
	Next
	
; switches
	Local wire%=False
	Local demo%=0

; time based movement
	Local st = MilliSecs()-17
	Local mt = -17
	Local lt = 0
	Local AppCoef# = 1.0;

; reset mouse speed
MouseXSpeed() : MouseYSpeed()


Repeat
	
	lt = mt
	mt = MilliSecs()-st
	dt = mt - lt
	AppCoef = 60.0*dt / 1000
	
	; ------------------------------------------------------------ / Inputs
		; Key [F1] -&gt; wireframe
		If KeyHit(59) Then wire=1-wire:Wireframe wire
		 
		; Key [F2] -&gt; switch demo Mode
		If KeyHit(60)
			demo=1-demo
			If (demo=1)
				ShowEntity Wall2
				HideEntity Wall1
			Else 
				ShowEntity Wall1
				HideEntity Wall2
			EndIf
			
			; reset rigid bodies
			
			For l_Body = Each RigidBody
				; randomize position ( but keep the body inside the walls )
				PositionEntity l_Body\Entity, Rnd(-5,5), Rnd(-5,5), Rnd(-5,5), 1
				; reset collisions (if any)
				ResetEntity l_Body\Entity
			Next
		EndIf
		
		; Key  [Space] -&gt; randomize ball velocity
			If KeyHit(57)
				For l_Body = Each RigidBody
					; Randomize velocity ( and normalize it !)
					Vec3SelfNormalize ( Vec3Set ( l_Body\Velocity, Rnd(-1,1), Rnd(-1,1), Rnd(-1,1) ) )
					; randomise speed
					l_Body\Speed = Rnd(0.1,3.0)
				Next
			EndIf
		
	; - Update Camera -
		Local msx# = MouseXSpeed()
		Local msy# = MouseYSpeed()
		If MouseDown(1)
			TurnEntity piv,0,-msx,0
			TurnEntity pit,msy,0,0
		EndIf
		
	; - Update Collisions -
		UpdateRigidBodies(AppCoef)
		
	RenderWorld()
		
		
	Flip True
	
Until KeyDown(1)

End
</textarea> <br><br></td></tr></table><br>
<a name="1321492"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks RemiD and awesome demo Bobysait! definitely looks up to date :) <br><br></td></tr></table><br>
<a name="1321493"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was thinking more of a simple throwing a single object example and do not infinitely bounce but can bounce through walls. Maybe you can simplify it?<br><br>I already found a cannonball physics but it does not bounce and not through walls. Yes the rigid body like box is what I'm looking for. <br><br></td></tr></table><br>
<a name="1321524"></a>

<a name="1321525"></a>

<a name="1321526"></a>

<a name="1321527"></a>

<a name="1321528"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've not yet implemented neither boxes nor torque (nor contraints), but the "Sphere engine" is a bit more complete<br>-&gt; Right Click to launch a ball from the camera<br>-&gt; F1 to switch Wireframe (useless ... but here it is)<br>-&gt; F2 to switch the scene (cube/sphere)<br>-&gt; Space to randomize force for the last ball<br><br><iframe width="560" height="345" src="http://www.youtube.com/embed/8l83qAGlLGY" frameborder="0" allowfullscreen></iframe><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; ----------------------------------------------------------------
; small vector3 sdk
; ----------------------------------------------------------------
Type Vec3
	Field X#,Y#,Z#
	End Type
	
	; constructor
	Function NewVec3.Vec3(x#=0,y#=0,z#=0) : Local v.Vec3 = New Vec3 : v\X=x : v\Y=y : v\Z=z : Return v : End Function
	; Copy
	Function Vec3Copy.Vec3(src.Vec3) : Return NewVec3(src\X,src\Y,src\Z) : End Function
	; destructor
	Function FreeVec3.Vec3(v.Vec3) : If (v&lt;&gt;Null) : Delete v : EndIf : Return Null: End Function
	; Set
	Function Vec3Set.Vec3(v.Vec3,x#,y#,z#) : v\X=x : v\Y=y : v\Z=z : Return v : End Function
	Function Vec3SetX.Vec3(v.Vec3,x#) : v\X=x : Return v: End Function
	Function Vec3SetY.Vec3(v.Vec3,y#) : v\Y=y : Return v: End Function
	Function Vec3SetZ.Vec3(v.Vec3,z#) : v\Z=z : Return v: End Function
	Function Vec3Assign.Vec3(v.Vec3, src.Vec3) : Return Vec3Set(v,src\X,src\Y,src\Z) : End Function
	; Get
	Function Vec3X#(v.Vec3) : Return v\X : End Function
	Function Vec3Y#(v.Vec3) : Return v\Y : End Function
	Function Vec3Z#(v.Vec3) : Return v\Z : End Function
	; transform
	Function Vec3Add		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X+q\X,v\Y+q\Y,v\Z+q\Z) : End Function
	Function Vec3SelfAdd	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X+q\X,v\Y+q\Y,v\Z+q\Z) : End Function
	Function Vec3Sub		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X-q\X,v\Y-q\Y,v\Z-q\Z) : End Function
	Function Vec3SelfSub	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X-q\X,v\Y-q\Y,v\Z-q\Z) : End Function
	Function Vec3Mul		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X*q\X,v\Y*q\Y,v\Z*q\Z) : End Function
	Function Vec3SelfMul	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X*q\X,v\Y*q\Y,v\Z*q\Z) : End Function
	Function Vec3Div		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\X/q\X,v\Y/q\Y,v\Z/q\Z) : End Function
	Function Vec3SelfDiv	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v,v\X/q\X,v\Y/q\Y,v\Z/q\Z) : End Function
	Function Vec3Scale		.Vec3(v.Vec3,s#)	: Return NewVec3	(  v\X*s,v\Y*s,v\Z*s)		: End Function
	Function Vec3SelfScale	.Vec3(v.Vec3,s#)	: Return Vec3Set	(v,v\X*s,v\Y*s,v\Z*s)		: End Function
	Function Vec3Normalize	.Vec3(v.Vec3)		: Return Vec3Scale	(v, 1.0/Sqr(Vec3Dot(v,v)))	: End Function
	Function Vec3SelfNormalize.Vec3(v.Vec3)		: Return Vec3SelfScale(v, 1.0/Sqr(Vec3Dot(v,v))): End Function
	Function Vec3Cross		.Vec3(v.Vec3,q.Vec3): Return NewVec3	(  v\Y*q\Z-v\Z*q\Y, v\Z*q\X-v\X*q\Z, v\X*q\Y-v\Y*q\X) : End Function
	Function Vec3SelfCross	.Vec3(v.Vec3,q.Vec3): Return Vec3Set	(v, v\Y*q\Z-v\Z*q\Y, v\Z*q\X-v\X*q\Z, v\X*q\Y-v\Y*q\X) : End Function
	; dot, length etc ...
	Function Vec3Dot#(a.Vec3,b.Vec3) : Return a\X*b\X+a\Y*b\Y+a\Z*b\Z : End Function
	Function Vec3Length#(v.Vec3) : Return Sqr(Vec3Dot(v,v)) : End Function
	Function Vec3SqLength#(v.Vec3) : Return Vec3Dot(v,v) : End Function
	
	Function Vec3ToString$(v.Vec3) : Return v\X+" "+v\Y+" "+v\Z : End Function
	
; not yet used -&gt; should be required for torque (unless I update it using quaternions)
Type Mat3
	Field I.Vec3
	Field J.Vec3
	Field K.Vec3
	End Type
	
	Function NewMat3.Mat3()
		Local m.Mat3 = New Mat3
		m\I = NewVec3(1,0,0)
		m\J = NewVec3(0,1,0)
		m\K = NewVec3(0,0,1)
		Return m
	End Function
	
; so as a transform class that holds the rotation and position for an entity (probably useless ...)
Type Transform
	Field M.Mat3
	Field V.Vec3
	End Type
	
	Function NewTransform.Transform()
		Local t.Transform = New Transform
		t\M = NewMat3()
		t\V = NewVec3()
		Return t
	End Function
	

; Gravity Vector
Global GRAVITY.Vec3	=	NewVec3			( 0, -9.81 * .25, 0 );

; Wind Vector
Global WIND.Vec3	=	NewVec3			( 0, 0, 0 );

Global RHO_AIR#		=	1.2
Global RHO_WATER#	=	1000.0

; Physic body (rigid body)
Type RigidBody
	; -------------------
	; Not yet implemented -&gt; rigid body style (sphere/box/...)
	Field Style%		; sphere(1) or box(3)
	Field Sub			; handle from extended type
	; -------------------
	Field Entity		; the blitz entity this physic body is attached to.
	; -------------------
	; Object properties
	Field Volume#		; volume ^^
	Field Density#		; Material density -&gt; amount of kilo per m3
	Field Mass#			; computed weight -&gt; Volume * Density
	Field Bounciness#	; between 0 and 1 (the factor of absorption of velocity on collision)
	Field Friction#		; attenuation of force
	Field Drag#			; don't ask me ... I have no idea -_-
	; -------------------
	; Used controled params
	Field Force.Vec3	; Initiates Force on the body (in Newton "N")
	Field Torque.Mat3	; Initiates "rotation" (in ... probably something  like rad/sec -&gt; not implemented yet)
	; -------------------
	; Internal update
	Field Position.Vec3	; center of mass
	Field Velocity.Vec3	; velocity
	Field Acceleration.Vec3
End Type
	
	;(private) rigid body constructor -&gt; called by extended rigidbody class
	Function NewRigidBody.RigidBody(Entity, style, SubHandle%, Volume#, Density#)
		Local body.RigidBody=	New RigidBody
		body\Sub			=	SubHandle
		body\Position		=	NewVec3()
		body\Velocity		=	NewVec3()
		body\Force			=	NewVec3()
		body\Torque			=	NewMat3()
		body\Acceleration	=	NewVec3()
		body\Entity			=	Entity
		body\Style			=	style
		body\Friction		=	1; by default : perfect body -&gt; no friction in collisions.
		body\Bounciness		=	-0.5
		body\Drag			=	0.47
		body\Volume			=	Volume
		body\Density		=	Density
		body\Mass			=	Volume * Density
		NameEntity(body\Entity, Handle(body))
		Return body
	End Function
	
	;(public) rigidbody constructors
	; - extends rigid sphere
	Type RigidSphere
		Field Body.RigidBody
		Field Radius#
	End Type
	
	Function NewRigidSphere.RigidBody(entity, radius#, ColType%=-1, Density# = 10)
		Local sphere.RigidSphere = New RigidSphere
		sphere\Body = NewRigidBody(entity, 1, Handle(sphere), Radius*Radius*Radius*4.1, Density)
		sphere\Radius = radius
		; Sphere volume : (4 * r*r*r * Pi)/3 =&gt; rounded to 4.1*r*r*r
		EntityRadius(entity, radius)
		If (ColType&gt;-1) Then EntityType(entity, ColType)
		Return sphere\Body
	End Function
	
	; - extends rigid box (not yet available)
	Type RigidBox
		Field Body.RigidBody
		Field Sphere.RigidBody[8]
		Field box#[6]
	End Type
	
	Function NewRigidBox.RigidBody(entity, x#=-1,y#=-1,z#=-1,w#=2,h#=2,d#=2, ColType%=-1, Density#=1)
		Local box.RigidBox = New RigidBox
		box\Body = NewRigidBody(entity, 1, Handle(box), w*h*d, Density)
		box\Box[0] = x
		box\Box[1] = y
		box\Box[2] = z
		box\Box[3] = w
		box\Box[4] = h
		box\Box[5] = d
		
		Local r# = w/10
		If h&lt;w Then r = h/10
		If d&lt;w And d&lt;h Then r = d/10
		Local f
		For f = 0 To 7
			box\Sphere[f] = NewRigidSphere(CreatePivot(), r)
			If (ColType&gt;-1) Then EntityType(box\Sphere[f]\entity, ColType)
		Next
		PositionEntity	( box\Sphere[0]\Entity, x+r  , y+r  , z+r  , 0 )
		PositionEntity	( box\Sphere[1]\Entity, x+w-r, y+r  , z+r  , 0 )
		PositionEntity	( box\Sphere[2]\Entity, x+r  , y+h-r, z+r  , 0 )
		PositionEntity	( box\Sphere[3]\Entity, x+w-r, y+h-r, z+r  , 0 )
		PositionEntity	( box\Sphere[4]\Entity, x+r  , y+r  , z+d-r, 0 )
		PositionEntity	( box\Sphere[5]\Entity, x+w-r, y+r  , z+d-r, 0 )
		PositionEntity	( box\Sphere[6]\Entity, x+r  , y+h-r, z+d-r, 0 )
		PositionEntity	( box\Sphere[7]\Entity, x+w-r, y+h-r, z+d-r, 0 )
		
		Return box\Body
	End Function
	
	Global G_VEC_TMP_0.Vec3 = NewVec3()
	Global G_VEC_TMP_1.Vec3 = NewVec3()
	Global G_VEC_TMP_2.Vec3 = NewVec3()
	Global G_VEC_TMP_3.Vec3 = NewVec3()
	Global G_VEC_TMP_4.Vec3 = NewVec3()
	Global G_VEC_TMP_5.Vec3 = NewVec3()
	Global G_VEC_TMP_6.Vec3 = NewVec3()
	
	Global F_Y# = 0.0
	Global LAST_RIGIDBODIES_UPDATE% = MilliSecs()
	Function MoveRigidBodies(AppCoef#=1.0)
		
		Local time_step#			=	AppCoef;
		Local time_step2#			=	0.5 * time_step*time_step;
		
		Local l_Pos.Vec3			=	G_VEC_TMP_0
		Local l_G.Vec3				=	G_VEC_TMP_1
		Local last_acceleration.Vec3=	G_VEC_TMP_2
		Local new_acceleration.Vec3	=	G_VEC_TMP_3
		Local l_Acc.Vec3			=	G_VEC_TMP_4
		Local l_Tmp.Vec3			=	G_VEC_TMP_5
		Local l_F.Vec3				=	G_VEC_TMP_6
		
		Vec3Assign			( l_G, GRAVITY )
		Vec3SelfScale		( l_G, time_step )
		
		Local l_Body.RigidBody
		For l_Body = Each RigidBody
			
			;last_acceleration = acceleration
			;position += velocity * time_step + ( 0.5 * last_acceleration * time_step^2 )
			;new_acceleration = force / mass 
			;avg_acceleration = ( last_acceleration + new_acceleration ) / 2
			;velocity += avg_acceleration * time_step
			
			; Forces sum = Gravity + body Force
				; gravity*mass
				Vec3Assign		( l_F, GRAVITY )
				Vec3SelfScale	( l_F, l_Body\Mass )
				; body Force
				Vec3SelfAdd		( l_F, l_Body\Force )
				; air friction against gravity
				Vec3Assign		( l_Tmp, l_Body\Velocity )
				Vec3SelfMul		( l_Tmp, l_Tmp )
				Vec3SelfScale	( l_Tmp, 0.5 * RHO_AIR * l_Body\Drag * (l_Body\Volume*0.5) )
				Vec3SelfSub		( l_F, l_Tmp )
			
			Vec3Assign		( last_acceleration, l_Body\Acceleration )
			Vec3SelfScale	( Vec3Assign( l_Tmp, last_acceleration ), time_step2 )
			Vec3SelfScale	( Vec3Assign( l_Acc, l_Body\Velocity ), time_step )
			Vec3SelfAdd		( l_Acc, l_Tmp )
			Vec3Assign		( l_Pos, l_Body\Position )
			Vec3SelfAdd		( l_Pos, l_Acc )
			
			Vec3SelfScale	( Vec3Assign( new_acceleration, l_F ), 1.0 / l_Body\Mass )
			Vec3Assign		( l_Body\Acceleration, new_acceleration )
			Vec3SelfAdd		( new_acceleration, last_acceleration )
			Vec3SelfScale	( new_acceleration, 0.5 * AppCoef )
			Vec3SelfAdd		( l_Body\Velocity, new_acceleration )
			
			PositionEntity	( l_Body\Entity, l_Pos\X, l_Pos\Y, l_Pos\Z, 1)
			
			Vec3SelfScale	( l_Body\Force, l_Body\Friction )
		Next
	End Function
	
	Function UpdateRigidBody(Body.RigidBody)
		Local l_Ent = Body\Entity
		
		Local l_V.Vec3	=	G_VEC_TMP_0
		Local l_V2.Vec3	=	G_VEC_TMP_1
		Local l_ColP.Vec3=	G_VEC_TMP_2
		Local l_ColN.Vec3=	G_VEC_TMP_3
		
		Local l_NPos.Vec3=	G_VEC_TMP_4
		Local l_Pos.Vec3=	Body\Position
		
		Local l_VelLength#=	Vec3Length(Body\Velocity)
		
		Vec3Set				( l_NPos, EntityX(l_Ent, 1), EntityY(l_Ent, 1), EntityZ(l_Ent, 1))
		Vec3Set				( l_ColP, CollisionX(l_Ent, 1), CollisionY(l_Ent, 1), CollisionZ(l_Ent, 1))
		
		Vec3Assign			( l_V, l_ColP )
		Vec3SelfSub			( l_V, l_Pos )
		Vec3SelfNormalize	( l_V )
		
		Vec3Assign			( l_Pos, l_V )
		Vec3SelfScale		( l_Pos, -.001 )
		Vec3SelfAdd			( l_Pos, l_NPos )
		
		PositionEntity		( Body\Entity, l_Pos\X, l_Pos\Y, l_Pos\Z, 1 )
		ResetEntity			( Body\Entity )
		
		Vec3Set				( l_ColN, CollisionNX(l_Ent,1), CollisionNY(l_Ent,1), CollisionNZ(l_Ent,1) )
		Local l_Dot#	=	Vec3Dot( l_V, l_ColN )
		Vec3Assign			( l_V2, l_ColN )
		Vec3SelfScale		( l_V2, -l_Dot * 2.0 )
		Vec3SelfAdd			( l_V2, l_V )
		Vec3SelfNormalize	( l_V2 )
		Vec3Assign			( Body\Velocity, l_V2 )
		Vec3SelfScale		( Body\Velocity, Abs(Body\Bounciness) * l_VelLength )
		
		; update force
		Body\Force\X	=	Abs(Body\Force\X*Body\Bounciness) * Sgn(Body\Velocity\X)
		Body\Force\Y	=	Abs(Body\Force\Y*Body\Bounciness) * Sgn(Body\Velocity\Y)
		Body\Force\Z	=	Abs(Body\Force\Z*Body\Bounciness) * Sgn(Body\Velocity\Z)
	End Function
	
	; process post collisions-detection (collisions responses)
	Function UpdateRigidBodies%(AppCoef#, MaxColLoop% = 1)
		
		Local Elapsed#			=	MilliSecs() - LAST_RIGIDBODIES_UPDATE
		If (Elapsed&lt;5)				Then Return
		LAST_RIGIDBODIES_UPDATE	=	LAST_RIGIDBODIES_UPDATE + Elapsed
		
		AppCoef					=	AppCoef * Elapsed / 60.0
		
		; update moves for all rigid bodies
		MoveRigidBodies				( AppCoef )
		
		; temp vectors
		Local l_V.Vec3		=	NewVec3()
		Local l_ColP.Vec3	=	NewVec3()
		Local l_ColN.Vec3	=	NewVec3()
		
		; while collisions happened, bodies must be updated
		While (MaxColLoop&gt;0)
			
			MaxColLoop = MaxColLoop - 1
			
			; update blitz collisions
			UpdateWorld()
			
			Local l_CountCollisions% = 0
			
			Local l_Body.RigidBody
			For l_Body = Each RigidBody
				
				; get entity from the rigid body
				Local l_Ent = l_Body\Entity
				
				; if collision occured
				If (CountCollisions(l_Ent)&gt;0)
					UpdateRigidBody (l_Body)
					l_CountCollisions = l_CountCollisions+1
				Else
					Vec3Set			( l_Body\Position, EntityX(l_Ent, 1), EntityY(l_Ent, 1), EntityZ(l_Ent, 1) )
				EndIf
			Next
			
			; no collisions on this loop -&gt; we can quit the update loop
			If (l_CountCollisions&lt;1) Then Exit
		Wend
		
		; release temp vectors
		FreeVec3(l_V)
		FreeVec3(l_ColP)
		FreeVec3(l_ColN)
	End Function
	




Graphics3D	( 800,600,0,2 )
SetBuffer	( BackBuffer() );

; Init blitz collisions
	Const COL_WALL%		=	1
	Const COL_BALL%		=	2
	
	Collisions COL_BALL,COL_WALL,2,1 ; Sphere/poly -&gt; Stop !
	Collisions COL_BALL,COL_BALL,1,1 ; Sphere/sphere -&gt; Stop !
	
; Lights
	Local Light1		=	CreateLight		( 2 )
							PositionEntity	( Light1, +0500,+0300,+0200 )
							LightRange		( Light1,  500 )
							LightColor		( Light1, 200,100,255 )
	Local Light2		=	CreateLight		( 3 )
							PositionEntity	( Light2, +0000,+1000,+1000 )
							LightRange		( Light2, 2500 )
							LightColor		( Light2, 128,100,100 )
							AlignToVector	( Light2, 0,-.6,-.3, 3, 1 )
							
; Camera
	Local piv			=	CreatePivot		( )
	Local pit			=	CreatePivot		( piv )
	Local cam			=	CreateCamera	( pit)
							MoveEntity		( cam, 0,0,-180 )
							TurnEntity		( pit, 45,0,0 )
							
; - Collision scene -
	Local Wall1			=	CreateCube		( )
							EntityColor		( Wall1, 150,255,100 )
							EntityShininess	( Wall1, .2 )
							ScaleMesh		( Wall1, 100,80,100 )
							FlipMesh		( Wall1 )
							EntityType		( Wall1, COL_WALL )
							
	; - for second demo -&gt; the ball bounds inside a spherical scene (F2 to switch between demos)
	Local Wall2			=	CreateSphere	( 16 )
							EntityColor		( Wall2, 100,150,255 )
							EntityShininess	( Wall1, .3 )
							ScaleMesh		( Wall2, 100,130,100 )
							FlipMesh		( Wall2 )
							EntityType		( Wall2, COL_WALL )
							HideEntity		( Wall2 )
							
; Create some balls
	Local l_Body.RigidBody
	
	Local l_radius#
	Local Model			=	CreateSphere	( 16 )
							ScaleEntity		( Model, 1,1,1 )
							EntityShininess	( Model, .4 )
							EntityColor		( Model, 200, 080, 020 )
							EntityType		( Model, COL_BALL )
							EntityRadius	( Model, 1 )
							HideEntity		( Model )
	
	Local NBalls		=	50
	Local b
	For b = 1 To NBalls
		RandomSphere(Model)
	Next
	
; switches
	Local wire%=False
	Local demo%=0

; time based movement
	Local st = MilliSecs()-17
	Local mt = -17
	Local lt = 0
	Local AppCoef# = 1.0;
	Local AppFPS# = 60.0;
	
; reset mouse speed
MouseXSpeed() : MouseYSpeed()


Repeat
	
	lt = mt
	mt = MilliSecs()-st
	dt = mt - lt
	AppCoef = AppFPS*dt / 1000
	
	; ------------------------------------------------------------ / Inputs
		; Key [F1] -&gt; wireframe
		If KeyHit(59) Then wire=Not(wire):Wireframe wire
		 
		; Key [F2] -&gt; switch demo Mode
		If KeyHit(60)
			demo=1-demo
			If (demo=1)
				ShowEntity Wall2
				HideEntity Wall1
			Else 
				ShowEntity Wall1
				HideEntity Wall2
			EndIf
			
			; reset rigid bodies
			
			For l_Body = Each RigidBody
				; randomize position ( but keep the body inside the walls )
				PositionEntity l_Body\Entity, Rnd(-40,40), Rnd(10,50), Rnd(-40,40), 1
				; reset collisions (if any)
				ResetEntity l_Body\Entity
			Next
		EndIf
		
		; Key  [Space] -&gt; randomize ball velocity
			If KeyHit(57)
				For l_Body = Each RigidBody
					; Randomize velocity ( and normalize it !)
					Vec3SelfScale( Vec3SelfNormalize ( Vec3Set ( l_Body\Force, Rnd(-1,1), Rnd(-1,1), Rnd(-1,1) ) ), Rnd(5000,40000) )
				Next
			EndIf
			
		; launch new ball
		If MouseHit(2)
			Local l_Mz# =	120.0
			Local l_Mx#	=	( -1.0 + 2.0 * Float(MouseX() ) / GraphicsWidth() )*l_Mz
			Local l_My#	=	( Float(GraphicsHeight() - 2*MouseY() ) / GraphicsWidth() )*l_Mz
			
			l_radius	=	Rnd(3,6)
			l_Body		=	RandomSphere(Model)
							TFormPoint		( l_Mx,l_My,l_Mz, cam, 0 )
							Vec3Set			( l_Body\Position, TFormedX(), TFormedY(), TFormedZ() )
							TFormNormal		( l_Mx,l_My,l_Mz, cam, 0 )
							Vec3Set			( l_Body\Force, TFormedX(), TFormedY(), TFormedZ() )
							Vec3SelfScale	( l_Body\Force, 20000 )
			l_Body\Friction=Rnd(.999,.9999)
		EndIf
		
	; - Update Camera -
		Local msx# = MouseXSpeed()
		Local msy# = MouseYSpeed()
		If MouseDown(1)
			TurnEntity piv,0,-msx,0
			TurnEntity pit,msy,0,0
		EndIf
		
	; - Update Collisions -
		UpdateRigidBodies(1);AppCoef)
		
	RenderWorld()
		
	Flip True
	
Until KeyDown(1)

End


Function RandomSphere.RigidBody(Model)
	Local l_Body.RigidBody
	l_radius	=	Rnd(4,10)
	l_Body		=	NewRigidSphere	( CopyEntity(Model), l_radius )
					ScaleEntity		( l_Body\Entity, l_radius,l_radius,l_radius )
					EntityColor		( l_Body\Entity, Rand(120,255), Rand(0,120), Rand(0,120) )
					Vec3Set			( l_Body\Position, Rnd(-60,60), Rnd(10,70), Rnd(-60,60) )
					Vec3Set			( l_Body\Force, Rnd(-1,1), Rnd(-1,1), Rnd(-1,1) )
					Vec3SelfNormalize( l_Body\Force )
					Vec3SelfScale	( l_Body\Force, Rnd(5000,40000) )
	l_Body\Friction=Rnd(.999,.9999)
	l_Body\Bounciness=0.4
	Return l_Body
End Function
</textarea> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
