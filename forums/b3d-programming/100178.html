<!DOCTYPE html><html lang="en" ><head ><title >Intercepting a moving target easily - Vectors</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Intercepting a moving target easily - Vectors</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Intercepting a moving target easily - Vectors</a><br><br>
<a name="1180819"></a>

<a name="1180820"></a>

<a name="1180821"></a>

<a name="1180822"></a>

<a name="1180823"></a>

<a name="1180824"></a>

<a name="1180825"></a>

<a name="1180826"></a>

<a name="1180827"></a>

<a name="1180828"></a>

<a name="1180829"></a>

<a name="1180917"></a>

<a name="1180953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi. It's one of those common problems in games with AI turrets and AI shooting: shooting 'ahead' of a moving target so when the projectile gets there the target is also there and gets hit.<br><br>I was looking for solutions to this problem. Most deal with quadratic equations, and that can be a bit daunting if your math is rusty - they do, at least, provide the fastest way to compute the solution.<br>In a Stackoverflow thread on this subject a guy suggested a different approach, using vectors. Here's his post: <a href="http://stackoverflow.com/a/2248934" target="_blank">http://stackoverflow.com/a/2248934</a><br><br>After digesting it for a while it made a whole lot of sense to me, so I thought I'd take the time to explain how it works, as it can benefit other people. It avoids quadratic equations, discriminants etc., dealing instead with vectors and coordinate contexts. It works for 2D and 3D with minimal differences.<br>It can be used for other things as well, not just interception-prediction.<br><br>• <b>The problem:</b><br><img src="http://i47.tinypic.com/10d8e1u.jpg"><br><font class="tiny">We're at the top, looking down at a 3D scene. We have a moving target (A) with known speed and direction, and we want to shoot 'ahead' of it so our shot certainly hits it. <br>We don't know which direction to shoot at, however. We only know the place we're shooting from (B) and the speed of its projectiles.</font><br><br>• <b>Changing the point-of-view:</b><br><img src="http://i50.tinypic.com/282lxyd.jpg"><br><font class="tiny">We 'spin' this scene so the segment that goes from object A to object B (in other words, the distance between them) gets aligned to one of the axes of this new space. In this case, it's the Z axis (their distance is aligned to the new space's Z axis).</font><br><br>• <b>Decomposing the target's vector:</b><br><img src="http://i47.tinypic.com/nbdy0g.jpg"><br><font class="tiny">We can then decompose the target object's movement vector into its components WITHIN this new coordinate space. <br>In this specific coordinate space, the X (sideways) and Y (pointing up) axes don't do much, but movements in the Z axis can <i>bring the objects together or distance them</i>.</font><br><br>• <b>Copying X and Y components:</b><br><img src="http://i45.tinypic.com/28ahybs.jpg"><br><font class="tiny">We then create a vector and make its X and Y components be the same as the X and Y components of the target object's movement vector. This keeps the projectile and target object <i>aligned</i> while they move.<br>The Z component of this new vector is derived from the predefined projectile's speed\length\magnitude: Z = Sqr(speed^2 - x^2 - y^2)</font>.<br><br>• <b>The interception:</b><br><img src="http://i49.tinypic.com/1oaio8.jpg"><br><font class="tiny">This new vector is going to be our "projectile vector". Having its X and Y components the same as the target's keeps it aligned to it, but the Z axis will draw it closer to the target until it hits. <br>We can use a simple space equation (X = Xo + V * t) to calculate the time taken for the projectile to hit the target in the future.</font><br><br>• <b>Restoring the old view:</b><br><img src="http://i50.tinypic.com/34ywl1z.jpg"><br><font class="tiny">We then transform the "projectile vector" we computed back to the original coordinate space of the scene. We now have the projectile vector, the time it'll take for the projectile to hit the target and we can also find out the interception point.</font><br><br><br>But is this method fast? you tell me. <br><br>For the following demo...<br>- Move the Mouse to aim, and shoot with the Left Mouse Button.<br>- Hold Space while shooting so you use the "auto-aim".<br>- Press Enter so you change the movement speed for the target object.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;==============================================
;Intercepting a moving target easily - Vectors
;
;     Kryzon, 2013. Public Domain.
;
;     Based on information by Aryabhatta.
;   
;==============================================

;***** 
;Important parts of the interception logic are marked with "*****" tags.
;*****

AppTitle "Shoot the moving object!"
Graphics3D 800,600,0,2
HidePointer()
MoveMouse 600,400

Const CAMERA_DISTANCE# = 20
Const TARGET_RADIUS# = 28
Const SHIP_COL_TYPE = 1
Const BULLET_COL_TYPE = 2

Global SPIN_DELAY = 2700

;*****
;If the target object's speed is too high there might be some situations where the interception point can't be calculated.
Global TARGET_SPEED# = 0.4
Const PROJECTILE_SPEED# = 1
;*****


;*****
;Pivot used by the interception logic.
Global contextPivot = CreatePivot()

;Generic movement vector class used by the interception logic.
Type TVector
	Field x#
	Field y#
	Field z#
End Type
;*****

Type TBullet
	Field mesh
	Field vector.TVector
End Type

Type TShip
	Field mesh
	Field vector.TVector
End Type

;Scene
camera = CreateCamera()
CameraClsColor camera,0,0,10
PositionEntity camera,0,CAMERA_DISTANCE,-CAMERA_DISTANCE
TurnEntity camera,30,0,0

target = CreateCone()
temp = CreateCylinder()
PositionMesh temp,0,-2,0
AddMesh temp,target
FreeEntity temp
PositionMesh target,0,1,0
RotateMesh target,90,0,0
EntityColor target,255,0,0
PositionEntity target,30,0,40
RotateEntity target,0,90,0
EntityType target, SHIP_COL_TYPE

shot = CreateSphere(4)
ScaleMesh shot,0.25,0.25,0.25
HideEntity shot

Collisions BULLET_COL_TYPE, SHIP_COL_TYPE, 2, 1

light = CreateLight(1)
TurnEntity light,30,60,0

AmbientLight 80,80,80

;Creating a "ship" to represent the player. In this case, the camera.
;In your game this would be the player ship for instance.
sourceShip.TShip = New TShip
sourceShip\vector = New TVector
sourceShip\mesh = CreatePivot()
PositionEntity sourceShip\mesh,EntityX(camera,True),EntityY(camera,True),EntityZ(camera,True),True

;Creating a ship to represent the autonomous NPC.
;In your game this would be enemies, asteroids etc. Targettable objects.
targetShip.TShip = New TShip
targetShip\vector = New TVector
targetShip\mesh = target

fpsTimer = CreateTimer(60)
Local spinTimer = MilliSecs()
timeTaken# = 0
autoAim = False
crazyMode = False
ClsColor 80,80,0

;Used to temporarily store the results calculated by the interception function.
shootVector.TVector = New TVector

While Not KeyHit(1)
	WaitTimer fpsTimer
	
	;Update scene.
	
		autoAim = KeyDown(57)	
		If KeyHit(28) Then 
			If crazyMode Then
				SPIN_DELAY = 4000
				TARGET_SPEED = 0.4
			Else
				SPIN_DELAY = 2000
				TARGET_SPEED = 0.7
			EndIf
			crazyMode = Not crazyMode
		EndIf
		
		;The right way to move objects in your game: first orient the object (rotation), then move or translate the object (position).
		
		;With this mindset...
		;1) Orient my target ship in whatever way I want (AI, user control etc.). In this case, I'm using a timer.
		If MilliSecs() &gt; spinTimer+SPIN_DELAY Then 
			spinTimer = MilliSecs()
			TurnEntity targetShip\mesh,0,120,0,True
		EndIf 
	
		;*****
		;Obtain the target ship's movement vector in world space (necessary for interception).	
		TFormVector 0, 0, TARGET_SPEED, targetShip\mesh, 0 
		targetShip\vector\x = TFormedX()
		targetShip\vector\y = TFormedY()
		targetShip\vector\z = TFormedZ()
		;*****
		
		;2) Move the target ship by its current orientation and speed.
		TranslateEntity targetShip\mesh, targetShip\vector\x, targetShip\vector\y, targetShip\vector\z, True
		
		;*****
		;We have a shooter object (1) and target object (2).
		;We also have a defined projectile speed (3) for the player, and a motion vector (4) for the target object.
		;These 4 items are all that's necessary to calculate the closest interception point.
		
		;This function returns the "time" in game logic cycles that would take for the shot to reach the target.
		;If this value is "-1" it means that potential shots can never reach the enemy (the enemy may be faster than 
		;the predefined projectile speed etc.).
		;This function also calculates and stores in TFormedX(), TFormedY() and TFormedZ() the components of the motion vector 
		;that the projectile needs to be translated by in order to comply with the calculated interception point.
		
		timeTaken = GetInterceptVector(sourceShip, PROJECTILE_SPEED, targetShip)
		shootVector\x = TFormedX()
		shootVector\y = TFormedY()
		shootVector\z = TFormedZ()
		;*****
			
		;Logic to fire shots.
		If MouseHit(1) Or MouseHit(2) Then
			b.TBullet = New TBullet
			b\vector = New TVector
		
			;Projectile's motion vector.
			If autoAim Then
				;If the user is holding "auto-aim" then use the calculated motion vector for interception: the shots should
				;always hit the target. This is what you'd use for automatic turrets etc.
				
				;It's actually easy to miss shots, even when their calculated: a shot will only hit if the target object moves 
				;in a straight line enough for the interception to occur. If it's erratic, making zig-zags, waves etc. then 
				;the shots will most likely miss.
				b\vector\x = shootVector\x 
				b\vector\y = shootVector\y
				b\vector\z = shootVector\z
			Else
				;Else, use manual aiming, building each projectile's movement vector based on the mouse's screen coordinates.
				;In case of your game, you could use the player's ship's orientation, a turret's cannon's orientation etc.
				TFormNormal (4.0 * (MouseX()-400)) / 800.0, (3.0 * -(MouseY()-300)) / 600.0, 2, camera, 0 
				b\vector\x = TFormedX() * PROJECTILE_SPEED
				b\vector\y = TFormedY() * PROJECTILE_SPEED
				b\vector\z = TFormedZ() * PROJECTILE_SPEED
			EndIf 
			
			b\mesh = CopyMesh(shot)
			EntityType b\mesh, BULLET_COL_TYPE
			EntityRadius b\mesh,0.25
			PositionEntity b\mesh, EntityX(camera), EntityY(camera), EntityZ(camera)
			AlignToVector b\mesh, b\vector\x, b\vector\y, b\vector\z, 3
		EndIf 
	
		;Update each projectile that's already been shot.
		For b.TBullet = Each TBullet
			TranslateEntity b\mesh, b\vector\x, b\vector\y, b\vector\z, True
			
			If EntityCollided(b\mesh, SHIP_COL_TYPE) Then
				Cls
				Flip
				Delay 10
				Flip
				FreeEntity b\mesh
				Delete b
			Else
				If EntityZ(b\mesh) &gt; 75 Then 
					FreeEntity b\mesh
					Delete b\vector
					Delete b
				EndIf
			EndIf  
		Next
	
		UpdateWorld()
	;Update end.
	
	
	;Render scene.
		RenderWorld()
	
		Color 150,230,255
		Oval MouseX()-30,MouseY()-30,60,60,False
		Oval MouseX()-2,MouseY()-2,4,4,True
		
		If timeTaken &gt; -1 Then
			Text 10,10,"Use LEFT MOUSE to shoot."
			Text 574,10,"Hold SPACE to use Auto-Aim."
			Text 10,578,"Press ENTER to toggle crazy mode (only auto-aim can hit...)."
			If crazyMode Then Text 10,540,"[Crazy mode]"
			If autoAim Then Text 574,40,"[Auto-Aim activated]"
			
		Else
			Color 255,90,90
			Text 10,10,"Shots can't intercept the target."
		EndIf
	
		;*****
		;Displaying\finding the position of the interception point.
		;You can find the world position of the interception point by selecting either the computed projectile vector or the target
		;object's vector.
		;You then multiply each component of the selected vector by 'timeTaken' (that was calculated by the interception function)
		;and add the results to each of the coordinates of the object whose vector was selected. 
		
		;As an example, for the X coordinate you'd do (EntityX() + (vectorX * timeTaken)). The same for the other coordinates.
		;I'm doing this using the target object:
		CameraProject camera, EntityX(targetShip\mesh,True)+targetShip\vector\x*timeTaken, EntityY(targetShip\mesh,True)+targetShip\vector\y*timeTaken, EntityZ(targetShip\mesh,True)+targetShip\vector\z*timeTaken 
		Oval ProjectedX()-3,ProjectedY()-3,6,6,1
		;*****
	
		Flip
	;Render end.
	
Wend

End


Function GetInterceptVector#(sourceShip.TShip, projectileSpeed#, targetShip.TShip)
	
	;This function finds the movement vector that a projectile fired from location "sourceShip" needs to 
	;be translated by in order to intercept the moving target object "targetShip".
	;The result will be a world-space movement vector stored in the TFormedX(), TFormedY() and TFormedZ() values.
	
	Local sVecX#,sVecY#,sVecZ# ;Projectile's movement vector in the coordinate context of the aligned distance.
	Local tVecX#,tVecY#,tVecZ# ;Target ship's movement vector in the coordinate context of the aligned distance.
	Local squaredVecZ#
	Local timeTaken# ;Time estimated for the projectile to intercept the target ship.
	Local targetDistance#
		
	;Setup the "context" pivot that will transform the distance segment between source ~ target so it's aligned with the 
	;pivot's Z axis.
	PositionEntity contextPivot, EntityX(sourceShip\mesh,True), EntityY(sourceShip\mesh,True), EntityZ(sourceShip\mesh,True), True
	PointEntity contextPivot, targetShip\mesh
	
	;Transform the target ship's movement vector from world space to the context pivot's space.
	TFormVector targetShip\vector\x, targetShip\vector\y, targetShip\vector\z, 0, contextPivot
	tVecX = TFormedX() ;Vector used for alignment between projectile and target.
	tVecY = TFormedY() ;Vector used for alignment between projectile and target.
	tVecZ = TFormedZ()
	
	sVecX = tVecX ;Projectile's alignment with target is guaranteed by 
	sVecY = tVecY ;making its X and Y components the same as the target object's.
	squaredVecZ = (projectileSpeed*projectileSpeed - sVecX*sVecX - sVecY*sVecY)
	
	If squaredVecZ &gt; 0 Then
		;The projectile's Z component, however, is derived from the desired projectile's speed.
		sVecZ = Sqr(squaredVecZ)
		
		;Calculate the time taken for the projectile to intercept the target ship.
		;The Z axis, in the context pivot's space, represents the approximation axis. The projectile and target object can only
		;get closer if they move in the Z axis.
		
		TFormPoint EntityX(targetShip\mesh,True),EntityY(targetShip\mesh,True),EntityZ(targetShip\mesh,True),0,contextPivot
		targetDistance# = TFormedZ() ;Get the distance from source object to target object.
		
		If sVecZ &gt; tVecZ Then
			timeTaken = targetDistance / (sVecZ - tVecZ) ;Calculate the time taken to intercept.
		Else
			TFormVector 0,0,0,0,0
			Return -1
		EndIf 			
	Else
		TFormVector 0,0,0,0,0
		Return -1
	EndIf
	
	;Transform the calculated movement vector from this context pivot space back to world space so we can use it in the game.
	TFormVector sVecX, sVecY, sVecZ, contextPivot, 0 ;Components will be stored in TFormedX\Y\Z.
	
	Return timeTaken
End Function</textarea><br><br>PS: Since the target object has volume, some shots will still hit even if they're aimed a bit off. <br><br></td></tr></table><br>
<a name="1180836"></a>

<a name="1180837"></a>

<a name="1180838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok ....<br>So to avoid quadratic equations, you have :<br>- A positionEntity (which involve a 4*4 multiplication matrix)<br>- A pointEntity (I don't even know how Blitz handle such a function ... probably some matrix multiplied and such things)<br>- At least 2 TFormXXXX (that involve 2 matrix multiplication)<br><br>sorry but, it 's ... much much much complicated and slow than the "quadratic" solution where all you need is that :<br><br><br><pre class=code>
; Normalize the Target Direction + multiply the Target_Velocity
Local In# = Target_Velocity/Sqr(TargetDir_x*TargetDir_x+TargetDir_y*TargetDir_y+TargetDir_z*TargetDir_z)
Local Ix# = TargetDir_x*In, Iy# = TargetDir_y*In, Iz# = TargetDir_z*In

; square target velocity substract square bullet velocity
Local a# = Ix*Ix+Iy*Iy+Iz*Iz - Bullet_Velocity*Bullet_Velocity

; distance Bullet-&gt; target
Local Dx# = Targetx-Bulletx
Local Dy# = Targety-Bullety
Local Dz# = Targetz-Bulletz

; a not really complicated equation : no big deal (2.0* dot product of Distance and Target Velocity)
Local b# = + Float(2.0)*( Dx*Ix + Dy*Iy + Dz*Iz )

; the Square distance
Local c# = (Dx*Dx+Dy*Dy+Dz*Dz)

; then the famous Discriminant, which is really simple
Local Det# = b*b-4.0*a*c
Local time#=0.0

; And deal with 2 solutions
If Det&lt;0 Then Return -1 ; no solution

If Det&gt;0
	Det=Sqr(Det)
	time = -0.5*(b-Det)/a
	If time&lt;0 Then time=-0.5*(b+Det)/a
Else
	time = -0.5*b/a
EndIf

; And Here we are.
ResultX = Dx + time * Ix
ResultY = Dy + time * Iy
ResultZ = Dz + time * Iz
	
; Eventually, normalize the result
Local n# = 1.0/Sqr(Resultx*Resultx+Resulty*Resulty+Resultz*Resultz)
Resultx = Resultx * n
Resulty = Resulty * n
Resultz = Resultz * n

</pre><br><br>So, there is only small maths involved, and really less operations <br><br></td></tr></table><br>
<a name="1180906"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I disagree that it is "much much complicated"; vector manipulation is more intuitive to me, I feel like a kid playing with sticks.<br><br>I agree that it can be slower, I said that in that post already.<br>Do you know <i>how</i> slower it is in comparison, however? please benchmark both methods, because you'd be surprised of the fact that making use of internal Blitz3D functions is many times faster than doing the same but with Blitz3D code.<br><br>For example, make a simple 3D euclidean distance function with Sqr(x*x + y*y + z*z). It's slower than using EntityDistance(). <br><br></td></tr></table><br>
<a name="1180921"></a>

<a name="1180922"></a>

<a name="1180927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> For sure the internal function runs pretty fast, but not "that" fast.<br><br>This can explain easily<br>My code only use some simple multiplications and 2 squareroots<br>happy internal function are not faster, else it would not mean "internal stuff is really fast" but "blitz code is reaaally slow" :)<br><br>A Tform call is made internally with 2 matrix multiplications<br><br>you have a point x,y,z, you transform it in the local matrix (Source)<br>let's say sxx,sxy,sxz, syx,syy,syz, szx,szy,szz the source matrix<br>newx = x * Sxx + y * Syx + z * Szx  +  SourceX (absolute coords of source)<br>newy = x * Sxy + y * Syy + z * Szy  +  SourceY<br>newz = x * Sxz + y * syz + z * Szz  +  SourceZ<br>then you have to get the coords in the Destination matrix<br>x = newx - DestX : y = newy - DesyY : z = newz - DestZ<br>resx = x*dxx + y*dxy + z*dxz<br>resy = x*dyx + y*dyy + z*dyz<br>resz = x*dzx + y*dzy + z*dzz<br><br>And here we don't even care of the "If / Else" if you set Source or Dest (or both) to "0"<br><br><br>Then, I think the slowest function in your code is the pointentity<br>it's a process that require to inverse the matrix to estimate it to the destination matrix<br>the transform matrix is a 4*4 matrix (not just a rotation)<br><br>And as it also performs a "Roll" effect (the last optional parameters) I suppose it involves some kind of Lerp interpolation<br><br>At last but not least :<br>The "PositionEntity" function<br>It requires a multiplication of the Root matrix * entity matrix, then update the entity<br>(if you ever tracked the memory offsets of an entity, you would see something not really elegant but it's still here : the entity matrix is stored in many locations, and each time to modify with a PositionEntity/Move/Translate etc ... you manipulate all the matrix to update the entity)<br><br><br>It's probably where my code is much ( much much much :) ) faster is :<br>I don't update anything.<br>You can also make it with a c++ dll, it will be probably 2 or 3 time faster.<br><br>Actually, on the bench I processed, my function runs 3 times faster than yours.<br>- 30 ms for 100000 tests vs 100ms or above for your function<br>- 100-120 ms in debug vs &gt;500ms for your function.<br><br><br><br>Then I suppose " vector manipulation is more intuitive to me" is just a matter of point of view. I'm easy with maths and vectors, so I can manipulate them in a more "low level", then making the stuff of the function here is not really difficult, and whatever you think about it, it's still some vectors stuff, it's just that it is more theorical than the PositionEntity/TFormVector etc ...)<br>And for someone who better not deal with "low level" codes, of course, using the blitz stuff is surely easier in some way<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;==============================================
;Intercepting a moving target easily - Vectors
;
;     Kryzon, 2013. Public Domain.
;
;     Based on information by Aryabhatta.
;   
;==============================================

;***** 
;Important parts of the interception logic are marked with "*****" tags.
;*****

AppTitle "Shoot the moving object!"
Graphics3D 800,600,0,2
HidePointer()
MoveMouse 600,400

Const CAMERA_DISTANCE# = 20
Const TARGET_RADIUS# = 28
Const SHIP_COL_TYPE = 1
Const BULLET_COL_TYPE = 2

Global SPIN_DELAY = 2700

;*****
;If the target object's speed is too high there might be some situations where the interception point can't be calculated.
Global TARGET_SPEED# =  0.4
Const PROJECTILE_SPEED# = 1.0
;*****

Collisions BULLET_COL_TYPE, SHIP_COL_TYPE, 2, 1

;*****
;Pivot used by the interception logic.
Global contextPivot = CreatePivot()

;Generic movement vector class used by the interception logic.
Type TVector
	Field x#
	Field y#
	Field z#
End Type
;*****

Type TBullet
	Field mesh
	Field vector.TVector
End Type

Type TShip
	Field mesh
	Field vector.TVector
End Type

;Scene
Local camera		=	CreateCamera()
						CameraClsColor	( camera, 0,0,10 )
						PositionEntity	( camera, 0,CAMERA_DISTANCE,-CAMERA_DISTANCE )
						TurnEntity		( camera, 30,0,0 )

Local target		=	CreateCone		( )
Local temp			=	CreateCylinder	( )
						PositionMesh	( temp, 0,-2,0 )
						AddMesh			( temp, target )
						FreeEntity		( temp )
						PositionMesh	( target, 0,1,0 )
						RotateMesh		( target, 90,0,0 )
						EntityColor		( target, 255,0,0 )
						PositionEntity	( target, 30,0,40 )
						RotateEntity	( target, 0,90,0 )
						EntityType		( target, SHIP_COL_TYPE )
	
Local shot			=	CreateSphere	( 4 )
						ScaleMesh		( shot, 0.25,0.25,0.25 )
						HideEntity		( shot )


AmbientLight 80,80,80

Local light			=	CreateLight		( 1 )
						TurnEntity		( light, 30,60,0 )


;Creating a "ship" to represent the player. In this case, the camera.
;In your game this would be the player ship for instance.
Local sourceShip.TShip=	New TShip
	sourceShip\vector=	New TVector
	sourceShip\mesh	=	CreatePivot()
						PositionEntity	( sourceShip\mesh, EntityX(camera,True),EntityY(camera,True),EntityZ(camera,True),True )

;Creating a ship to represent the autonomous NPC.
;In your game this would be enemies, asteroids etc. Targettable objects.
Local targetShip.TShip=	New TShip
	targetShip\vector=	New TVector
	targetShip\mesh	=	target

Local fpsTimer		=	CreateTimer		( 60 )
Local spinTimer		=	MilliSecs		( )
Local timeTaken#	=	0
Local autoAim		=	False
Local crazyMode		=	False

ClsColor 80,80,0

;Used to temporarily store the results calculated by the interception function.
Local shootVector.TVector=New TVector

Local BenchTime1	=	0
Local BenchTime2	=	0

Local method = 0

While Not KeyHit(1)
	WaitTimer fpsTimer
	
	;Update scene.
		
		If KeyHit(60) Then method = Not(method)
		
		autoAim = KeyDown(57)	
		If KeyHit(28) Then 
			If crazyMode Then
				SPIN_DELAY = 4000
				TARGET_SPEED = 0.4
			Else
				SPIN_DELAY = 2000
				TARGET_SPEED = 0.7
			EndIf
			crazyMode = Not crazyMode
		EndIf
		
		;The right way to move objects in your game: first orient the object (rotation), then move or translate the object (position).
		
		;With this mindset...
		;1) Orient my target ship in whatever way I want (AI, user control etc.). In this case, I'm using a timer.
		If MilliSecs() &gt; spinTimer+SPIN_DELAY Then 
			spinTimer = MilliSecs()
			TurnEntity targetShip\mesh,0,120,0,True
		EndIf
		
		;*****
		;Obtain the target ship's movement vector in world space (necessary for interception).	
		TFormVector 0, 0, TARGET_SPEED, targetShip\mesh, 0 
		targetShip\vector\x = TFormedX()
		targetShip\vector\y = TFormedY()
		targetShip\vector\z = TFormedZ()
		;*****
		
		;2) Move the target ship by its current orientation and speed.
		TranslateEntity targetShip\mesh, targetShip\vector\x, targetShip\vector\y, targetShip\vector\z, True
		
		;*****
		;We have a shooter object (1) and target object (2).
		;We also have a defined projectile speed (3) for the player, and a motion vector (4) for the target object.
		;These 4 items are all that's necessary to calculate the closest interception point.
		
		;This function returns the "time" in game logic cycles that would take for the shot to reach the target.
		;If this value is "-1" it means that potential shots can never reach the enemy (the enemy may be faster than 
		;the predefined projectile speed etc.).
		;This function also calculates and stores in TFormedX(), TFormedY() and TFormedZ() the components of the motion vector 
		;that the projectile needs to be translated by in order to comply with the calculated interception point.
		
		Select method
			Case 0
				timeTaken = GetInterceptVector(sourceShip, PROJECTILE_SPEED, targetShip)
			Case 1
				timeTaken = GetInterceptVector2(sourceShip, PROJECTILE_SPEED, targetShip)
		End Select
		shootVector\x = TFormedX()
		shootVector\y = TFormedY()
		shootVector\z = TFormedZ()
		;*****
		
		;Logic to fire shots.
		If MouseHit(1) Or MouseHit(2) Then
			Local b.TBullet	=	New TBullet
				b\vector	=	New TVector
			
			;Projectile's motion vector.
			If autoAim Then
				;If the user is holding "auto-aim" then use the calculated motion vector for interception: the shots should
				;always hit the target. This is what you'd use for automatic turrets etc.
				
				;It's actually easy to miss shots, even when their calculated: a shot will only hit if the target object moves 
				;in a straight line enough for the interception to occur. If it's erratic, making zig-zags, waves etc. then 
				;the shots will most likely miss.
				b\vector\x	=	shootVector\x 
				b\vector\y	=	shootVector\y
				b\vector\z	=	shootVector\z
			Else
				;Else, use manual aiming, building each projectile's movement vector based on the mouse's screen coordinates.
				;In case of your game, you could use the player's ship's orientation, a turret's cannon's orientation etc.
				TFormNormal		(4.0 * (MouseX()-400)) / 800.0, (3.0 * -(MouseY()-300)) / 600.0, 2, camera, 0 
				b\vector\x	=	TFormedX() * PROJECTILE_SPEED
				b\vector\y	=	TFormedY() * PROJECTILE_SPEED
				b\vector\z	=	TFormedZ() * PROJECTILE_SPEED
			EndIf 
			
			b\mesh			=	CopyMesh		( shot )
								EntityType		( b\mesh, BULLET_COL_TYPE )
								EntityRadius	( b\mesh, 0.25 )
								PositionEntity	( b\mesh, EntityX(camera), EntityY(camera), EntityZ(camera) )
								AlignToVector	( b\mesh, b\vector\x, b\vector\y, b\vector\z, 3 )
		EndIf 
		
		;Update each projectile that's already been shot.
		For b.TBullet = Each TBullet
			TranslateEntity b\mesh, b\vector\x, b\vector\y, b\vector\z, True
			
			If EntityCollided(b\mesh, SHIP_COL_TYPE) Then
				Cls
				Flip
				Delay 10
				Flip
				FreeEntity b\mesh
				Delete b
			Else
				If EntityZ(b\mesh) &gt; 75 Then 
					FreeEntity b\mesh
					Delete b
				EndIf
			EndIf  
		Next
		
		
		; Benchmark
		If KeyHit(59)
			Local NbSamples = 100000
			Local sample
			Local t0 = MilliSecs()
			For sample = 1 To NbSamples
				GetInterceptVector(sourceShip, PROJECTILE_SPEED, targetShip)
			Next
			Local t1 = MilliSecs()
			For sample = 1 To NbSamples
				GetInterceptVector2(sourceShip, PROJECTILE_SPEED, targetShip)
			Next
			Local t2 = MilliSecs()
			BenchTime1 = t1-t0
			BenchTime2 = t2-t1
		EndIf
		
		UpdateWorld()
	;Update end.
	
	
	;Render scene.
		RenderWorld()
	
		Color 150,230,255
		Oval MouseX()-30,MouseY()-30,60,60,False
		Oval MouseX()-2,MouseY()-2,4,4,True
		
		If timeTaken &gt; -1 Then
			Text 10,10,"Use LEFT MOUSE to shoot."
			Text 574,10,"Hold SPACE to use Auto-Aim."
			Text 10,578,"Press ENTER to toggle crazy mode (only auto-aim can hit...)."
			If crazyMode Then Text 10,540,"[Crazy mode]"
			If autoAim Then Text 574,40,"[Auto-Aim activated]"
			
		Else
			Color 255,90,90
			Text 10,10,"Shots can't intercept the target."
		EndIf
	
		;*****
		;Displaying\finding the position of the interception point.
		;You can find the world position of the interception point by selecting either the computed projectile vector or the target
		;object's vector.
		;You then multiply each component of the selected vector by 'timeTaken' (that was calculated by the interception function)
		;and add the results to each of the coordinates of the object whose vector was selected. 
		
		;As an example, for the X coordinate you'd do (EntityX() + (vectorX * timeTaken)). The same for the other coordinates.
		;I'm doing this using the target object:
		CameraProject camera, EntityX(targetShip\mesh,True)+targetShip\vector\x*timeTaken, EntityY(targetShip\mesh,True)+targetShip\vector\y*timeTaken, EntityZ(targetShip\mesh,True)+targetShip\vector\z*timeTaken 
		Oval ProjectedX()-3,ProjectedY()-3,6,6,1
		;*****
		
		If BenchTime1&gt;0 Or BenchTime2&gt;0
			Text 10,400, "Bench 1 :"+BenchTime1+" .ms"
			Text 10,415, "Bench 2 :"+BenchTime2+" .ms"
		EndIf
		
		Flip
	;Render end.
	
Wend

End


Function GetInterceptVector#(sourceShip.TShip, projectileSpeed#, targetShip.TShip)
	
	;This function finds the movement vector that a projectile fired from location "sourceShip" needs to 
	;be translated by in order to intercept the moving target object "targetShip".
	;The result will be a world-space movement vector stored in the TFormedX(), TFormedY() and TFormedZ() values.
	
	Local sVecX#,sVecY#,sVecZ# ;Projectile's movement vector in the coordinate context of the aligned distance.
	Local tVecX#,tVecY#,tVecZ# ;Target ship's movement vector in the coordinate context of the aligned distance.
	Local squaredVecZ#
	Local timeTaken# ;Time estimated for the projectile to intercept the target ship.
	Local targetDistance#
		
	;Setup the "context" pivot that will transform the distance segment between source ~ target so it's aligned with the 
	;pivot's Z axis.
	PositionEntity contextPivot, EntityX(sourceShip\mesh,True), EntityY(sourceShip\mesh,True), EntityZ(sourceShip\mesh,True), True
	PointEntity contextPivot, targetShip\mesh
	
	;Transform the target ship's movement vector from world space to the context pivot's space.
	TFormVector targetShip\vector\x, targetShip\vector\y, targetShip\vector\z, 0, contextPivot
	tVecX = TFormedX() ;Vector used for alignment between projectile and target.
	tVecY = TFormedY() ;Vector used for alignment between projectile and target.
	tVecZ = TFormedZ()
	
	sVecX = tVecX ;Projectile's alignment with target is guaranteed by 
	sVecY = tVecY ;making its X and Y components the same as the target object's.
	squaredVecZ = (projectileSpeed*projectileSpeed - sVecX*sVecX - sVecY*sVecY)
	
	If squaredVecZ &gt; 0 Then
		;The projectile's Z component, however, is derived from the desired projectile's speed.
		sVecZ = Sqr(squaredVecZ)
		
		;Calculate the time taken for the projectile to intercept the target ship.
		;The Z axis, in the context pivot's space, represents the approximation axis. The projectile and target object can only
		;get closer if they move in the Z axis.
		
		TFormPoint EntityX(targetShip\mesh,True),EntityY(targetShip\mesh,True),EntityZ(targetShip\mesh,True),0,contextPivot
		targetDistance# = TFormedZ() ;Get the distance from source object to target object.
		
		If sVecZ &gt; tVecZ Then
			timeTaken = targetDistance / (sVecZ - tVecZ) ;Calculate the time taken to intercept.
		Else
			TFormVector 0,0,0,0,0
			Return -1
		EndIf 			
	Else
		TFormVector 0,0,0,0,0
		Return -1
	EndIf
	
	;Transform the calculated movement vector from this context pivot space back to world space so we can use it in the game.
	TFormVector sVecX, sVecY, sVecZ, contextPivot, 0 ;Components will be stored in TFormedX\Y\Z.
	
	Return timeTaken
End Function

Function GetInterceptVector2#(sourceShip.TShip, projectileSpeed#, targetShip.TShip)
	
	; distance emitter-&gt;target
	Local i# = EntityX(targetShip\mesh,1)-EntityX(sourceShip\mesh,1)
	Local j# = EntityY(targetShip\mesh,1)-EntityY(sourceShip\mesh,1)
	Local k# = EntityZ(targetShip\mesh,1)-EntityZ(sourceShip\mesh,1)
	
	; Target Dir
	Local x# = targetShip\vector\x
	Local y# = targetShip\vector\y
	Local z# = targetShip\vector\z
	
	; Calculate Discriminant and solutions
	Local a# = x*x+y*y+z*z - projectileSpeed*projectileSpeed
	Local b# = 2.0*(i*x+j*y+k*z)
	Local c# = i*i+j*j+k*k
	Local Det# = b*b-4.0*a*c
	Local time#=0.0
	; Det &lt;0 : no solution (target move probably too fast)
	If Det&lt;0 Then Return -1
	; else, check the smaller time
	If Det&gt;0
		Det=Sqr(Det)
		time = -0.5*(b-Det)/a
		If time&lt;0 Then time=-0.5*(b+Det)/a
	Else
		time = -0.5*b/a
	EndIf
	
	; reuse the local variables to store the result intercept direction
	i = i+x*time
	j = j+y*time
	k = k+z*time
	
	; normalize (*projectile speed at the same time)
	a = projectileSpeed/Sqr(i*i+j*j+k*k)
	; store result in the TFormed()
	TFormVector(i*a,j*a,k*a, 0,0)
	Return time
	
End Function
</textarea><br><br><br><br><br><br><br><br><br><br>[edit]<br>BTW, I just found a small memory leak in your code :<br>You never use "Delete" on the TVector objects when you release the bullets<br><pre class=code>
			If EntityCollided(b\mesh, SHIP_COL_TYPE) Then
				Cls
				Flip
				Delay 10
				Flip
				FreeEntity b\mesh
				Delete b\vector ; insert here
				Delete b
			Else
				If EntityZ(b\mesh) &gt; 75 Then 
					FreeEntity b\mesh
					Delete b\vector ; insert here
					Delete b
				EndIf
			EndIf  
</pre> <br><br></td></tr></table><br>
<a name="1180931"></a>

<a name="1180932"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi. Thanks for the explanations. <br>I like your tabbed indentation, it makes working on an entity's settings (color, position etc.) much more organized.<br><br>I was skeptic at first, but then realized you are right on PointEntity: it's abusive. <br>I replaced it with AlignToVector() (among other optimizations, taking away redundancy) and now the benchmarks are much less apart. Take a look:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Optimized "vector" interception function.

Function GetInterceptVector#(sourceShip.TShip, projectileSpeed#, targetShip.TShip)
	Local sVecZ#,tVecZ#
	Local squaredVecZ#

	PositionEntity contextPivot, EntityX(sourceShip\mesh,True), EntityY(sourceShip\mesh,True), EntityZ(sourceShip\mesh,True), True
	AlignToVector contextPivot, EntityX(targetShip\mesh,True)-EntityX(sourceShip\mesh,True), EntityY(targetShip\mesh,True)-EntityY(sourceShip\mesh,True), EntityZ(targetShip\mesh,True)-EntityZ(sourceShip\mesh,True), 3

	TFormVector targetShip\vector\x, targetShip\vector\y, targetShip\vector\z, 0, contextPivot
	tVecZ = TFormedZ()
	squaredVecZ = (projectileSpeed*projectileSpeed - TFormedX()*TFormedX() - TFormedY()*TFormedY())
	
	If squaredVecZ &gt; 0 Then
		sVecZ = Sqr(squaredVecZ)
		
		If sVecZ &gt; tVecZ Then
			TFormVector TFormedX(), TFormedY(), sVecZ, contextPivot, 0
			Return EntityDistance(sourceShip\mesh,targetShip\mesh) / (sVecZ - tVecZ)
		EndIf 			
	EndIf
	
	TFormVector 0,0,0,0,0
	Return -1
End Function</textarea> <br><br></td></tr></table><br>
<a name="1180934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MCP</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is one of those rare occasions when a bit of rivalry actually benefits everyone :)<br>I was wondering though do both algorithms assume both source and target objects are travelling at the same speed or can they be independent of one another? Thanks to both of you for your submissions. <br><br></td></tr></table><br>
<a name="1180939"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, the AlignTovector thing is really a fast method to PointAt Position :)<br>(actually, it divide by 2 the times to perform the check, still not as fast as pure maths but, already quite performant enough)<br><br><br>@MCP :<br>Actually the bench code works with target and emitter with different velocities, and both Kryzon's code and mine work, so I think you've got your answer :)<br><br>ps : I always indent this way, I'm a bit ... obsessive with order IRL :)<br><br>ps2 : i've made a "pure maths" method involving the Kryzon's code (converting the Position/PointEntity/TForm stuff with matrix)<br>it runs at almost the same speed than mine (a bit slower, but I'm sure it can be optimized)<br>So the theory involved is not that bad actually, it's even well thought...<br>I wouldn't expect it be that robust <br><br></td></tr></table><br>
<a name="1180950"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> For fun, I tested with the bullet library (I mean : the physics libraryr, not the "tBullet type")<br>So here is a c++ code to compile to dll (if you have the bullet library)<br><br><pre class=code>
/*
   @result = a bullet vector to store the final direction vector (normalized)
   @em = emitter
   @tg = target
   @td = target direction (velocity include)
   @v  = emitter velocity
   returns : the time to intercept the target at their respectives velocities (as float)
   
   small note :
   take care to check if time is &gt;=0 before using the result
   as for performance, the function use the result as a temporary vector to store some vector operations.
   so if the function returns '-1' the @result will contain some fake datas.
   BTW, I probably would better set it to {0,0,0} before returning '-1' ...
*/

extern "C" _declspec(dllexport) const float _stdcall Extrapolate(btVector3&amp; result,btVector3&amp; em,btVector3&amp; tg,btVector3&amp; td, float v)
{
	result = tg-em;
	float a =  td.length2() - v*v;
	float b = 2.0f*result.dot(td);
	float d = b*b-4.0f*a*result.length2();
	float t = 0.0f;
	if (d&lt;0.0f)return -1.0f;
	if (d&gt;0.0f){d=sqrtf(d);t=-0.5f*(b-d)/a;if(t&lt;0.0f){t=-0.5f*(b+d)/a;};}
	else{t=-0.5f*b/a;};
	result+=td*t;result*=(v/result.length());return t;
};
</pre><br><br>you'll need some tweaking to set/create the vectors, but not a big deal if you know how to wrap some c++ class<br><br>it's a bit faster than my blitz3d function<br>for 100 000 test :<br>- 20-30 ms with the dll<br>- 30-35 ms with blitz native maths <br><br></td></tr></table><br>
<a name="1180954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MCP</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the code Bobysait I'll look at that when I get some free time :) <br><br></td></tr></table><br>
<a name="1180957"></a>

<a name="1180961"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I was wondering though do both algorithms assume both source and target objects are travelling at the same speed or can they be independent of one another? <br></div><br>The only elements necessary to use these methods in 2D or 3D contexts are: <br>- Start position of the shot;<br>- Speed of the shot;<br>- Current position of the target;<br>- Movement\translation vector of the target used in the current frame;<br>So you get in return the ideal movement\translation vector for the shot.<br><br>This method of target-prediction (or "extrapolation", as it was better put) is ideal for space games. <br>I have Microsoft's Freelancer in mind: when battling in space, you would "lock" in an enemy and the interface would show <a href="http://media.moddb.com/images/games/1/1/81/up7.PNG" target="_blank">a little red cross that represented the extrapolated interception point</a>. You'd then aim at this cross so your shots would hit the enemy.<br><br>It's quite easy to dodge shots like these. The object being targetted has to simply change orientation\direction.<br>These methods assume the targetted object will <i>remain</i> under its current orientation while the projectile gets there.<br><br><div class="quote"> For fun, I tested with the bullet library (I mean : the physics libraryr, not the "tBullet type")<br>So here is a c++ code to compile to dll (if you have the bullet library) <br></div><br>Thanks for sharing. <br><br></td></tr></table><br>
<a name="1181116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just discovered this.  (I work on weekends).  Excellent discussion that I can't but think I might have inspired with my question on this topic!<br><br>As to the debate about intuitiveness vs efficiency, I think it depends on how much time you have to devote.  For this and many other issues, learning the maths way provides a consistent approach to deal with many issues, but requires much more time to learn.  It's not really about whether the maths way is faster, it's about whether one can do what Bobysait did, or feel confident applying something they don't understand.  That's the advantage of Kryzon's approach, which I have also generally followed.<br><br>I mean, clearly we want to create our game at a reasonable pace of development, not spend several days trying to wrap our heads around concepts like the discriminant. <br><br>However, I have to admit that in the long run, those few days of study would accelerate not only the pace of development of all our games, but the games themselves as well, in terms of more efficient code.<br><br>Part of the problem is that it's hard to find a tutorial on these concepts that doesn't presume significant prior knowledge (accidentally or intentionally) in the given area of math.  <a href="http://en.wikipedia.org/wiki/Discriminant" target="_blank">Here's an example.</a>  These tend to be written by experts, not surprisingly, and they tend not to think about which terms their audience already know and don't know.<br><br>On the other hand, I just found a site on Essential Math for Games Programmers:<br><br><a href="http://www.essentialmath.com/tutorial.htm" target="_blank">http://www.essentialmath.com/tutorial.htm</a><br><br>Everything is in powerpoint for some reason.  But the point is that there are probably some good "entry-level" tutorials on these topics if we really look.<br><br>Anyway, great discussion! <br><br></td></tr></table><br>
<a name="1181141"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would also add that nobody has compared either of these methods to less accurate methods, like Stevie G.'s method in the other thread.<br><br>What I'm doing in the meantime is just:<br><br>A. Calculating the time for a bullet to reach the target where it is now<br><br>B. Moving the target forward it's speed x that time.<br><br>C. Aim &amp; fire<br><br>D. Move the target back where it was.  No one is the wiser!<br><br>Of course there is still a pointentity and two moveentity's, but it has the advantage of simplicity.  And, where it's implemented correctly at the moment, it works reasonably well.<br><br>Still, if you want truly accurate results, the Kryzon's and Bobysait's methods are da bomb. <br><br></td></tr></table><br>
<a name="1181144"></a>

<a name="1181146"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> When you come to 3D stuff, It's always a matter of maths anyway, even when you do a "simple" MoveEntity, you have to understand some standard at some maths level, like "what is a vector" (even if you don't know the "words" you have to understand how it works)<br>Else you can't deal with 3D without the logic of what you're doing.<br><br>By the way, the Kryzon's method is a maths approach (he used the blitz-commands to get it working, but it still remains some maths)<br>And that's the part that makes me a bit laugh, its method is probably more complicate (and mostly more mathematical on the logic) than mine on the basis, because it relies on vector projections to simplfy the problem in a 2D coords space -&gt; which is not a natural human behavior. (when I only used a physic approach, and it is by the way, the same approach than the one involved in the actual physic engines to compute collision detection, for ex: they use the same kind of stuff in the bullet physic engine)<br>But the real difference I think is important in our methods, is not how we deal with it in blitz, (maths algorythm or bblitz-stuff) but the way we come to a solution before using a single operator.<br><br>To simplify every thing, let's come back in -2500 AD, where physicians did already exist and build house, but maths hadn't been writen yet, so they had to compensate their lack of knowledge and they did.<br>The only matter was to understand the global thing to do what they needed.<br>Nowadays, In programmation, the matter remains the same. We just have more tools to come to solutions. And maybe where the hard part relie, is to have enough logical mind to even start thinking of a way to do things, and that, no matter the tools we have to do them, because, efficient or not, the maths remains a hammer, and only the brain can draw is the planes of the house.<br><br>Then it 's not a maths question anymore to be an "expert". It only requires to be curious on the way to do things, else, we just have to use what has already been done. (and that's here where <i>&lt;it's about whether one can do what Bobysait did, or feel confident applying something they don't understand&gt;</i> is the most relevant in my opinion)<br><br>It's just like being a geak or not. You're obsessed to solve solutions like you're obsessed to learn everything about something. Or you're not, and you just want something to be done, no matter how it is done.<br>So I'm probably a geak in some way, where most "blitzers" are not (it's probably the main reason "blitzers" are "blitzers" by the way ... they prefer not having to deal with the manner, they just want things to be done "easily" or "basically")<br>(and Kryzon is probably a geak too ... in evidence, he made is own stuff, wether or not he used some "already made functions", it still made is own method)<br><br><br><i>ps : the "discriminant" is not a complicate thing, actually, we learn at it school (don't know away, but in France it is) at 12-14 years old. (Generally children does not really understand when we could apply it in real life, but the maths thing is pretty simple. Maybe teachers could or should learn maths in a different manner... like involving more concrete exemples than some triangles on a sheet of paper ...)</i> <br><br></td></tr></table><br>
<a name="1181195"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good points all around.<br><br>It makes me wonder, did Michelangelo make his own paints?  How thoroughly did he need to understand the properties of the various ingredients in order to optimize a formula for the particular requirements of the Sistine Chapel ceiling?<br><br>I could see that going both ways; some artists might prefer to spend their time mostly on the form and detail of their technique and artistic vision, or they might prefer a more thorough grounding in all the chemistry first.<br><br>I bet most artists could benefit hugely from a better understanding of the chemistry, in the same way that most Blitzers would benefit from better understanding of the maths.<br><br>Anyway, you've motivated me to do more training in maths, so thanks! <br><br></td></tr></table><br>
<a name="1181201"></a>

<a name="1181203"></a>

<a name="1181204"></a>

<a name="1181205"></a>

<a name="1181206"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> A. Calculating the time for a bullet to reach the target where it is now<br><br>B. Moving the target forward it's speed x that time.<br><br>C. Aim &amp; fire<br><br>D. Move the target back where it was. No one is the wiser! <br></div><br>About this that you're using. You can change step B to a TFormPoint so you don't need step D.<br><br>You see, with TFormPoint you can see a 3D point from an entity's point of view - for instance, having the target as origin [0,0,0] - and you can make this point offset relatively to the target by [vectorX*time, vectorY*time, vectorZ*time]. <br>Then this function takes this same point that is relative to the target and sees it from the world's origin point of view: instead of being relative to the target, it'll be relative to the world origin, giving you the "actual" position you need to aim at.<br><pre class=code>;A) Get the time.
timeTaken# = EntityDistance(playerShip\mesh, enemyShip\mesh) / bulletSpeed

;B) Find the target point in world space (the vector you're using here has to be a local vector, the values you'd be using in a MoveEntity).
TFormPoint enemyShip\vectorX*timeTaken, enemyShip\vectorY*timeTaken, enemyShip\vectorZ*timeTaken, enemyShip\mesh, 0

;C) Aim the player\cannon\etc.
AlignToVector playerShip\mesh, TFormedX()-EntityX(playerShip\mesh,True), TFormedY()-EntityY(playerShip\mesh,True), TFormedZ()-EntityZ(playerShip\mesh,True), 3
</pre>As you said, the method isn't exactly precise but should give that vibe of correctness.<br><br>PS: If one needs to pick one of these, then go straight to the quadratic solution presented by Bobysait. <br>It's faster and works seamlessly with 2D by simply removing the Z axis from all vectors\normals being used. And it's conveniently interfaced in that benchmark code, you just have to copy-paste. <br><br></td></tr></table><br>
<a name="1181319"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon,<br><br>Thanks for this.  Yes, clearly Bobysait's code is much more accurate, and probably faster than either my method or your version above (although maybe not, because it's doing more; it's taking into account the actual time to reach the target where it will be, not just where is now.  And that takes more time.)  <br><br>But I do enjoy knowing why a function works, which is the advantage of the other solutions (for me).  If someone asks "How does that work" I can explain it.  Of course, everything is based on lower level code that might be impenetrable to me, but if the code I see in my program is understandable to me, it gives me a feeling of authority over it.  (Including the fact that I can fix it if there's a bug).<br><br>That said, my Catmull-Rom interpolation function is ported from the web and is pretty much indecipherable to anyone but a mathematician.  But in that case there really was no other option.<br><br>Your method above does pass the test, so I'll probably go with either that or Bobysait's anyway eventually.  Depends how much speed I need! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
