<!DOCTYPE html><html lang="en" ><head ><title >U/V positions</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >U/V positions</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >U/V positions</a><br><br>
<a name="1322002"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Spike314</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Im trying to add U V positions to a geosphere with no luck and wondering if someone can help.<br><br>Here is the code I'm using:<br><br><pre class=code>
Function GEOcreate( Parent , Detail )

	Mesh = CreateMesh( Parent )
	S = CreateSurface( Mesh )
	a#=2.0/(1.0+Sqr(5.0))					
	b#=1.0/Sqr((3.0+Sqr(5.0)) / (1.0+Sqr(5.0)))
	
	v01=AddVertex(S,  0,  a,  b)
	v02=AddVertex(S,  0,  a, -b)
	v03=AddVertex(S,  0, -a,  b)
	v04=AddVertex(S,  0, -a, -b)
	v05=AddVertex(S,  a,  b,  0)
	v06=AddVertex(S,  a, -b,  0)
	v07=AddVertex(S, -a,  b,  0)
	v08=AddVertex(S, -a, -b,  0)
	v09=AddVertex(S,  b,  0,  a)
	v10=AddVertex(S,  b,  0, -a)
	v11=AddVertex(S, -b,  0,  a)
	v12=AddVertex(S, -b,  0, -a)
	GEOsub( S, v02,v05,v07,Detail )
	GEOsub( S, v01,v07,v05,Detail )
	GEOsub( S, v01,v03,v11,Detail )
	GEOsub( S, v01,v09,v03,Detail )
	GEOsub( S, v02,v04,v10,Detail )
	GEOsub( S, v02,v12,v04,Detail )
	GEOsub( S, v03,v06,v08,Detail )
	GEOsub( S, v04,v08,v06,Detail )
	GEOsub( S, v07,v11,v12,Detail )
	GEOsub( S, v08,v12,v11,Detail )
	GEOsub( S, v05,v10,v09,Detail )
	GEOsub( S, v06,v09,v10,Detail )
	GEOsub( S, v01,v11,v07,Detail )
	GEOsub( S, v01,v05,v09,Detail )
	GEOsub( S, v02,v07,v12,Detail )
	GEOsub( S, v02,v10,v05,Detail )
	GEOsub( S, v04,v12,v08,Detail )
	GEOsub( S, v04,v06,v10,Detail )
	GEOsub( S, v03,v08,v11,Detail )
	GEOsub( S, v03,v09,v06,Detail )

	Return mesh

End Function

;======================================
;======================================
;======================================

Function GEOsub( S, v1 , v2 , v3 , Detail )
	
	If Detail &gt; 0 
		nx#=(VertexX(S,v1)+VertexX(S,v2))/2
		ny#=(VertexY(S,v1)+VertexY(S,v2))/2
		nz#=(VertexZ(S,v1)+VertexZ(S,v2))/2
		l#=Sqr(nx#*nx#+ny#*ny#+nz#*nz#)
		n1=AddVertex(S,nx#/l,ny#/l,nz#/l)
		nx#=(VertexX(S,v2)+VertexX(S,v3))/2
		ny#=(VertexY(S,v2)+VertexY(S,v3))/2
		nz#=(VertexZ(S,v2)+VertexZ(S,v3))/2
		l#=Sqr(nx#*nx#+ny#*ny#+nz#*nz#)
		n2=AddVertex(S,nx#/l,ny#/l,nz#/l)
		nx#=(VertexX(S,v3)+VertexX(S,v1))/2
		ny#=(VertexY(S,v3)+VertexY(S,v1))/2
		nz#=(VertexZ(S,v3)+VertexZ(S,v1))/2
		l#=Sqr(nx#*nx#+ny#*ny#+nz#*nz#)
		n3=AddVertex(S,nx#/l,ny#/l,nz#/l)
		GEOsub( S, v1,n3,n1,Detail-1)
		GEOsub( S, v2,n1,n2,Detail-1)
		GEOsub( S, v3,n2,n3,Detail-1)
		GEOsub( S, n3,n2,n1,Detail-1)
	Else
		AddTriangle(S,v2,v1,v3)
	End If

End Function
</pre> <br><br></td></tr></table><br>
<a name="1322004"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> it depends on how you want to uvmap the shape (we can't decide for you)<br><br>to calculate the u,v coords of a vertex it works like this :<br>let's say that a texture is 128width*128height<br>let's say that you want to uvmap a triangle so that the vertices positions on the texture are :<br>AX% = 0<br>AY% = 128-1<br>BX% = 64<br>BY% = 0<br>CX% = 128-1<br>CY% = 128-1<br><br>vertexA will have these u,v coordinates : float(0)/128,float(128-1)/128<br>vertexB will have these u,v coordinates : float(64)/128,float(0)/128<br>vertexC will have these u,v coordinates : float(128-1)/128,float(128-1)/128<br><br>to set the u,v coords you can use<br>vertextexcoords(surface,vertexindex%,u#,v#)<br><br>this may give you some ideas... <br><br></td></tr></table><br>
<a name="1322041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RemiD : There is no reason to be always that condescendant you know ^^<br>By the way, did you read what he's looking for ? Computing UVs for a geo sphere is not easy at all, and this one use a recursive algorithm ...<br>All you give as help is "this is how generic UV works"<br><br>LOL, good luck with that :D<br><br><br>@Spike314 :<br>The problem with the geosphere is that it's a recursive algorithm that create vertices that are not aligned with a UV map, so, you can eventually rotate the UV to fit the sphere but it's hard<br>Also, as the vertices are welded, the seams will be visible and UVs will be stretch.<br><br>ps : your geosphere seems to be reversed, am I wrong ? v2,v1,v3 -&gt; that's not the good sens for triangle (should be v1,v2,v3 according to the coords you pass)<br><br>I'm going to look at your algo and see what can be done, but I won't spend too much time on it, so don't expect a result :) <br><br></td></tr></table><br>
<a name="1322046"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Function SphereUV(x#,y#,z#, uv#[2])
	uv[0] = ((360+ATan2(z,x))Mod(360))/360
	uv[1] = (90-ASin(y))/180
End Function

Function GEOcreate( Detail=2, Parent=0 )
	
	Local sens = Detail Mod(2)
	
	Local uv#[2]
	Mesh = CreateMesh( Parent )
	S = CreateSurface( Mesh )
	a#=2.0/(1.0+Sqr(5.0))					
	b#=1.0/Sqr((3.0+Sqr(5.0)) / (1.0+Sqr(5.0)))
	
	; Planes Corners
	; Plane YZ
	v01=AddVertex(S,  0,  a,  b)
	v02=AddVertex(S,  0,  a, -b)
	v03=AddVertex(S,  0, -a,  b)
	v04=AddVertex(S,  0, -a, -b)
	; Plane XY 
	v05=AddVertex(S,  a,  b,  0)
	v06=AddVertex(S,  a, -b,  0)
	v07=AddVertex(S, -a,  b,  0)
	v08=AddVertex(S, -a, -b,  0)
	; Plane XZ
	v09=AddVertex(S,  b,  0,  a)
	v10=AddVertex(S,  b,  0, -a)
	v11=AddVertex(S, -b,  0,  a)
	v12=AddVertex(S, -b,  0, -a)
	
	GEOsub( S, v02,v05,v07, Detail, sens )
	GEOsub( S, v01,v07,v05, Detail, sens )
	GEOsub( S, v01,v03,v11, Detail, sens )
	GEOsub( S, v01,v09,v03, Detail, sens )
	GEOsub( S, v02,v04,v10, Detail, sens )
	GEOsub( S, v02,v12,v04, Detail, sens )
	GEOsub( S, v03,v06,v08, Detail, sens )
	GEOsub( S, v04,v08,v06, Detail, sens )
	GEOsub( S, v07,v11,v12, Detail, sens )
	GEOsub( S, v08,v12,v11, Detail, sens )
	GEOsub( S, v05,v10,v09, Detail, sens )
	GEOsub( S, v06,v09,v10, Detail, sens )
	GEOsub( S, v01,v11,v07, Detail, sens )
	GEOsub( S, v01,v05,v09, Detail, sens )
	GEOsub( S, v02,v07,v12, Detail, sens )
	GEOsub( S, v02,v10,v05, Detail, sens )
	GEOsub( S, v04,v12,v08, Detail, sens )
	GEOsub( S, v04,v06,v10, Detail, sens )
	GEOsub( S, v03,v08,v11, Detail, sens )
	GEOsub( S, v03,v09,v06, Detail, sens )
	
	For v = 0 To CountVertices(S)-1
		SphereUV(VertexX(S,v),VertexY(S,v),VertexZ(S,v),uv)
		VertexTexCoords(S,v, uv[0],uv[1])
	Next
	
	Return mesh
	
End Function

;======================================
;======================================
;======================================

Function GEOsub( S, v1 , v2 , v3 , Detail, sens% )
	
	Local u#,v#, nx#, ny#,nz#, l#
	Local va%, vb%
	If ( Detail &gt; 0 )
		va = v1 : vb = v2
		nx=(VertexX(S,va)+VertexX(S,vb)) * .5
		ny=(VertexY(S,va)+VertexY(S,vb)) * .5
		nz=(VertexZ(S,va)+VertexZ(S,vb)) * .5
		l=1.0/Sqr(nx*nx+ny*ny+nz*nz)
		n1=AddVertex(S,nx*l,ny*l,nz*l)
		
		va = v2 : vb = v3
		nx=(VertexX(S,va)+VertexX(S,vb)) * .5
		ny=(VertexY(S,va)+VertexY(S,vb)) * .5
		nz=(VertexZ(S,va)+VertexZ(S,vb)) * .5
		l=1.0/Sqr(nx*nx+ny*ny+nz*nz)
		n2=AddVertex(S,nx*l,ny*l,nz*l)
		
		va = v3 : vb = v1
		nx=(VertexX(S,va)+VertexX(S,vb)) * .5
		ny=(VertexY(S,va)+VertexY(S,vb)) * .5
		nz=(VertexZ(S,va)+VertexZ(S,vb)) * .5
		l=1.0/Sqr(nx*nx+ny*ny+nz*nz)
		n3=AddVertex(S,nx*l,ny*l,nz*l)
		
		GEOsub( S, v1,n3,n1, Detail-1, sens)
		GEOsub( S, v2,n1,n2, Detail-1, sens)
		GEOsub( S, v3,n2,n3, Detail-1, sens)
		GEOsub( S, n3,n2,n1, Detail-1, sens)
	Else
		If sens
			AddTriangle(S,v1,v2,v3)
		Else
			AddTriangle(S,v2,v1,v3)
		EndIf
	End If
	
End Function
</textarea><br><br><br>That's the best I can do (but it won't fix the UV on the seams)<br><br>ps : fixed the triangle, it was fliped depending on the detail count.<br>Now, it's always counterclockwise.<br>Also, take care of the aguments of the function, I've swaped parent and details (because, blitz primitives always put the parent in last position -&gt; so, it's consistant with blitz stuff) <br><br></td></tr></table><br>
<a name="1322047"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Bobysait&gt;&gt;my post was informative about the basics (since i did not see any u,v in his/her code), not "condescending", i don't know the level of the guy/gal asking the question... Please focus on answering your way instead of teaching me life... Thanks <br><br></td></tr></table><br>
<a name="1322049"></a>

<a name="1322050"></a>

<a name="1322051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1 - If this guy just wanted to know how UVs work, he'd post in the beginner section<br>2 - Have you ever seen a recursive function that creates vertex ? knowing what UV is will not help at all, it's mostyle a matter of understanding the algorithm and what a geo sphere is ... but if you had read the code, you'll understand that<br>3 - geo spheres are very specific shapes which are supposed to use specific UV sets, and if you use basic spherical UVs (like I did in previous post) it's horrible because there are seams that are not aligned with the triangles because it's not the way it's supposed to be unwraped ... you would understand that if you had compiled the code<br>4 - most of the time, you can't keep on emitting things like "we can't decide for you" or other stuff like this ... is it really that relevant to say it ?<br>Seriously, anytime you post, I just feel like you hate almost everybody ... you maybe don't realize it but yes, you're "condescending" very often, and it becomes very hard to noticed if you're or not.<br><br>And i don't f****g care about teaching you life, but I care to see some respect to anyone, just because we're here to help or get helped. Not for being bashed. <br><br></td></tr></table><br>
<a name="1322062"></a>

<a name="1322063"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Seriously, anytime you post, I just feel like you hate almost everybody ... you maybe don't realize it but yes, you're "condescending" very often, <br> <br></div><br>that's your perception, not my intent, wait until you meet RGR, i am sure that you will like him :)<br><br><div class="quote"> <br> Not for being bashed.<br> <br></div><br>where in my post do you see that ? My post was neutral... <br><br></td></tr></table><br>
<a name="1322093"></a>

<a name="1322094"></a>

<a name="1322096"></a>

<a name="1322097"></a>

<a name="1322100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RemiD : Everything is already said, I have no time to loose explaining trivial things like behaviors and we both know you won't accept it or you'll think I'm wrong, so let's skip this and go on for real stuff ^^.<br><br><br>Here is what I got for now :<br>- I replaced the GeoSphere function (lot of tweaking using a type to split the main vertices, so they are no more welded)<br>- the function create a pivot with some meshes attached to it (it allows to get more triangles than using a single mesh that seems to crash even with lots of surfaces)<br>- the demo will show you a random planet generator with export of the heightmap and colormap.<br><br>It can make Spore-like planet which are not that bad to be true.<br>(I had to use quaternion to update the normals ... sorry for that, but dealing with heightmap on a planet is never an easy task)<br><br>The UVs works pretty well, but are not generic, so it can be hard to find resources if you don't create them by yourself.<br>This sheet, shows how UVs are dispatched on the texture (the texture is not a square, it's composed of 4*2 frames).<br><br><img src="http://mdt.bigbang.free.fr/blitz/geosphere/UV_GEO_SPHERE.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; *****************************************************************************************
; * GEO SPHERE *
; *****************************************************************************************
	; temp vertex for geo sphere
	Type TGeoVertex
		Field x#,y#,z#, u#,v#
	End Type
	Function NewGeoVertex.TGeoVertex(x#,y#,z#)
		Local gv.TGeoVertex = New TGeoVertex
		gv\x = x : gv\y = y : gv\z = z
		Return gv
	End Function
	Function BuildGeoV%(S, g.TGeoVertex, u#=0,v#=0)
		Local i = AddVertex(S, g\x,g\y,g\z, u,v)
		VertexNormal S,i, g\x,g\y,g\z
		Return i
	End Function
	
	; constructor
	Function GEOcreate( Detail=2, Parent=0 )
		
		Delete Each TGeoVertex
		
		Local sens = Detail Mod(2)
		Local pivot = CreatePivot(Parent)
		
		a# = 1.0/Sqr(2)
		b# = a
		;a#=2.0/(1.0+Sqr(5.0))					
		;b#=1.0/Sqr((3.0+Sqr(5.0)) / (1.0+Sqr(5.0)))
		
		Local vNP.TGeoVertex=NewGeoVertex( 0,  1,  0)
		Local vSP.TGeoVertex=NewGeoVertex( 0, -1,  0)
		; Planes Corners
		; Plane YZ
		Local v00.TGeoVertex=NewGeoVertex( 0,  a,  b)
		Local v01.TGeoVertex=NewGeoVertex( 0,  a, -b)
		Local v02.TGeoVertex=NewGeoVertex( 0, -a,  b)
		Local v03.TGeoVertex=NewGeoVertex( 0, -a, -b)
		; Plane XY 
		Local v04.TGeoVertex=NewGeoVertex( a,  b,  0)
		Local v05.TGeoVertex=NewGeoVertex( a, -b,  0)
		Local v06.TGeoVertex=NewGeoVertex(-a,  b,  0)
		Local v07.TGeoVertex=NewGeoVertex(-a, -b,  0)
		; Plane XZ
		Local v08.TGeoVertex=NewGeoVertex( b,  0,  a)
		Local v09.TGeoVertex=NewGeoVertex( b,  0, -a)
		Local v10.TGeoVertex=NewGeoVertex(-b,  0,  a)
		Local v11.TGeoVertex=NewGeoVertex(-b,  0, -a)
		
		Local Mesh
		; North plane (Top)
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vNP, 0.625,0.000),BuildGeoV(s,v01, 0.500,0.250),BuildGeoV(s,v04, 0.750,0.250), Detail, sens )
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vNP, 0.875,0.000),BuildGeoV(s,v04, 0.750,0.250),BuildGeoV(s,v00, 1.000,0.250), Detail, sens )
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vNP, 0.125,0.000),BuildGeoV(s,v00, 0.000,0.250),BuildGeoV(s,v06, 0.250,0.250), Detail, sens )
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vNP, 0.375,0.000),BuildGeoV(s,v06, 0.250,0.250),BuildGeoV(s,v01, 0.500,0.250), Detail, sens )
		
		; south plane (Bottom)
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vSP, 0.125,1.000),BuildGeoV(s,v07, 0.250,0.750),BuildGeoV(s,v02, 0.000,0.750), Detail, sens )
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vSP, 0.375,1.000),BuildGeoV(s,v03, 0.500,0.750),BuildGeoV(s,v07, 0.250,0.750), Detail, sens )
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vSP, 0.625,1.000),BuildGeoV(s,v05, 0.750,0.750),BuildGeoV(s,v03, 0.500,0.750), Detail, sens )
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,vSP, 0.875,1.000),BuildGeoV(s,v02, 1.000,0.750),BuildGeoV(s,v05, 0.750,0.750), Detail, sens )
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v08, 0.875,0.500),BuildGeoV(s,v02, 1.000,0.750),BuildGeoV(s,v00, 1.000,0.250), Detail, sens ) ; Back
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v10, 0.125,0.500),BuildGeoV(s,v00, 0.000,0.250),BuildGeoV(s,v02, 0.000,0.750), Detail, sens )
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v09, 0.625,0.500),BuildGeoV(s,v01, 0.500,0.250),BuildGeoV(s,v03, 0.500,0.750), Detail, sens ) ; Front
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v11, 0.375,0.500),BuildGeoV(s,v03, 0.500,0.750),BuildGeoV(s,v01, 0.500,0.250), Detail, sens )
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v06, 0.250,0.250),BuildGeoV(s,v10, 0.125,0.500),BuildGeoV(s,v11, 0.375,0.500), Detail, sens ) ; Left
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v07, 0.250,0.750),BuildGeoV(s,v11, 0.375,0.500),BuildGeoV(s,v10, 0.125,0.500), Detail, sens )
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v04, 0.750,0.250),BuildGeoV(s,v09, 0.625,0.500),BuildGeoV(s,v08, 0.875,0.500), Detail, sens ) ; Right
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v05, 0.750,0.750),BuildGeoV(s,v08, 0.875,0.500),BuildGeoV(s,v09, 0.625,0.500), Detail, sens )
		
		; Joints
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v00, 0.000,0.250),BuildGeoV(s,v10, 0.125,0.500),BuildGeoV(s,v06, 0.250,0.250), Detail, sens ); Top-Left-Back
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v00 ,1.000,0.250),BuildGeoV(s,v04, 0.750,0.250),BuildGeoV(s,v08, 0.875,0.500), Detail, sens ); Top-Right-Back
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v01, 0.500,0.250),BuildGeoV(s,v06, 0.250,0.250),BuildGeoV(s,v11, 0.375,0.500), Detail, sens ); Top-Left-Front
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v01, 0.500,0.250),BuildGeoV(s,v09, 0.625,0.500),BuildGeoV(s,v04, 0.750,0.250), Detail, sens ); Right-Left-Front
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v03, 0.500,0.750),BuildGeoV(s,v11, 0.375,0.500),BuildGeoV(s,v07, 0.250,0.750), Detail, sens ); Bottom-Left-Front
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v03, 0.500,0.750),BuildGeoV(s,v05, 0.750,0.750),BuildGeoV(s,v09, 0.625,0.500), Detail, sens ); Bottom-Right-Front
		
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v02, 0.000,0.750),BuildGeoV(s,v07, 0.250,0.750),BuildGeoV(s,v10, 0.125,0.500), Detail, sens ); Bottom-Left-Back
		Mesh = CreateMesh( pivot ) : S = CreateSurface( Mesh )
		GEOsub( S, BuildGeoV(s,v02, 1.000,0.750),BuildGeoV(s,v08, 0.875,0.500),BuildGeoV(s,v05, 0.750,0.750), Detail, sens ); Bottom-Right-Back
		
		Delete Each TGeoVertex
		
		Return pivot
		
	End Function
	
	Function GEOsub( S, v1 , v2 , v3 , Detail, sens% )
		
		Local u#,v#, nx#, ny#,nz#, l#
		Local va%, vb%
		If ( Detail &gt; 0 )
			; cut segment in half
			va = v1 : vb = v2
			; half coords
			nx=(VertexX(S,va)+VertexX(S,vb)) * .5
			ny=(VertexY(S,va)+VertexY(S,vb)) * .5
			nz=(VertexZ(S,va)+VertexZ(S,vb)) * .5
			l=1.0/Sqr(nx*nx+ny*ny+nz*nz) ; inverse normal
			nx = nx*l: ny=ny*l: nz=nz*l
			; half UVs
			u=(VertexU(S,va)+VertexU(S,vb)) * .5
			v=(VertexV(S,va)+VertexV(S,vb)) * .5
			; create vertex with UVs
			n1=AddVertex(S,nx,ny,nz,u,v)
			; set normal (for a normalized sphere -&gt; normal = coords)
			VertexNormal S, n1, nx,ny,nz
			
			va = v2 : vb = v3
			nx=(VertexX(S,va)+VertexX(S,vb)) * .5
			ny=(VertexY(S,va)+VertexY(S,vb)) * .5
			nz=(VertexZ(S,va)+VertexZ(S,vb)) * .5
			l=1.0/Sqr(nx*nx+ny*ny+nz*nz)
			nx = nx*l: ny=ny*l: nz=nz*l
			u=(VertexU(S,va)+VertexU(S,vb)) * .5
			v=(VertexV(S,va)+VertexV(S,vb)) * .5
			n2=AddVertex(S,nx,ny,nz,u,v)
			VertexNormal S, n2, nx,ny,nz
			
			va = v3 : vb = v1
			nx=(VertexX(S,va)+VertexX(S,vb)) * .5
			ny=(VertexY(S,va)+VertexY(S,vb)) * .5
			nz=(VertexZ(S,va)+VertexZ(S,vb)) * .5
			l=1.0/Sqr(nx*nx+ny*ny+nz*nz)
			nx = nx*l: ny=ny*l: nz=nz*l
			u=(VertexU(S,va)+VertexU(S,vb)) * .5
			v=(VertexV(S,va)+VertexV(S,vb)) * .5
			n3=AddVertex(S,nx,ny,nz,u,v)
			VertexNormal S, n3, nx,ny,nz
			
			; cut again (or create a triangle at lower detail)
			GEOsub( S, v1,n3,n1, Detail-1, sens )
			GEOsub( S, v2,n1,n2, Detail-1, sens )
			GEOsub( S, v3,n2,n3, Detail-1, sens )
			GEOsub( S, n3,n2,n1, Detail-1, sens )
		Else
			If sens
				AddTriangle(S,v1,v2,v3)
			Else
				AddTriangle(S,v2,v1,v3)
			EndIf
		End If
		
	End Function
	

; *****************************************************************************************
; * SOME TEXTURE STUFF *
; *****************************************************************************************
	; clear all pixels
	Function ClearTexture(tex%, c%)
		Local curbuf = GraphicsBuffer()
		Local TexW% = TextureWidth(tex)
		Local TexH% = TextureHeight(tex)
		Local i%,j%
		SetBuffer TextureBuffer (tex)
			LockBuffer()
				For j = 0 To TexH-1
					For i = 0 To TexW-1
						WritePixelFast (i,j, c)
					Next
				Next
			UnLockBuffer()
		SetBuffer curbuf
	End Function
	
	; for the geo sphere texture, fill the pink holes
	Function ExpandSeams(tex, Mask%=$FF00FF)
		Local curbuf = GraphicsBuffer()
		Local TexW% = TextureWidth(tex)
		Local TexH% = TextureHeight(tex)
		Local i%,j%
		SetBuffer TextureBuffer(tex)
			LockBuffer()
				Local j1
				Local p%
				; Expand pixels right
				For j = 0 To TexH-1
					Local pL = Mask
					For i = 1 To TexW-1
						p = ReadPixelFast(i,j) And $FFFFFF
						If (p=Mask)
							If (pL&lt;&gt;Mask) Then WritePixelFast (i,j, pL)
						Else
							pL = p
						EndIf
					Next
				Next
				; Expand one pixel left
				For j = 0 To TexH-1
					Local LeftIsPink = False
					For i = TexW-2 To 0 Step -1
						p = ReadPixelFast(i,j) And $FFFFFF
						If (p=Mask)
							If (pL&lt;&gt;Mask) Then WritePixelFast (i,j, pL)
						Else
							pL = p
						EndIf
					Next
				Next
			UnlockBuffer()
		SetBuffer curbuf
	End Function


Graphics3D 1920,1024,0,2
SetBuffer BackBuffer()


; *****************************************************************************************
; * RANDOM GEO-PLANET *
; *****************************************************************************************
	
	Local FrameSize = 512
	Local TexW = FrameSize * 4
	Local TexH = FrameSize * 2
	
	Local heightmap = CreateTexture(TexW,TexH, 1) : ClearTexture (heightmap, $FFFF00FF)
	Local bufH = TextureBuffer(heightmap)
	Local tex = CreateTexture(TexW,TexH, 1) : ClearTexture (tex, $FFFF00FF)

	Local geosphere= GEOcreate(5)
	
	Function DrawProgress(percent#, title$="")
		Cls
		Color 255,255,000
		Rect 7,7,786,22, 1
		Color 000,000,100
		Rect 10,10, 780,16,1
		Color 000,128,255
		Rect 10,10, 780*percent, 16
		If (title&lt;&gt;"")
			Color 255,128,000
			Text 10,50, title
		EndIf
		Flip True
	End Function
	
	; ************************
	; * Create random points *
	; ************************
		
		Local surf, child, v%
		Local i%,j%
		
		; simple random heights with radius (act like smoothed spheres that deforms vertices in their range)
			Type RandHeight
				Field X#,Y#,Z#, H#, N#
			End Type
			Local rh.RandHeight
			For t=0 to 250
				rh = New RandHeight
				rh\X = Rnd(-1,1) : rh\Y = Rnd(-1,1) : rh\Z = Rnd(-1,1); position of the deformation
				Local rn# = 1.0/Sqr(rh\X*rh\X+rh\Y*rh\Y+rh\Z*rh\Z) ; normalize the position
				rh\X=rh\X*rn : rh\Y=rh\Y*rn : rh\Z=rh\Z*rn
				rh\H = 1.15*(-0.002+0.015*Rnd(-.9,1.15)); deformation factor
				rh\N = Rnd(0.1,0.4)*1.25; range
				rh\N = rh\N * rh\N ; square it
			Next
		
	; *************************
	; * Create Color Template *
	; *************************
		
		; color template depending on height
		Local MinH# = 0.950
		Local MaxH# = 1.190
		Local sumH#
		
		Local ColorH_R#[7], ColorH_G#[7], ColorH_B#[7], ColorH_H#[7]
			ColorH_R[0] = 000 : ColorH_G[0] = 010 : ColorH_B[0] = 080 : ColorH_H[0] = MinH
			ColorH_R[1] = 010 : ColorH_G[1] = 080 : ColorH_B[1] = 170 : ColorH_H[1] = 0.990 ; water
			ColorH_R[2] = 255 : ColorH_G[2] = 200 : ColorH_B[2] = 080 : ColorH_H[2] = 0.999 ; sand
			ColorH_R[3] = 050 : ColorH_G[3] = 120 : ColorH_B[3] = 020 : ColorH_H[3] = 1.050 ; grass
			ColorH_R[4] = 130 : ColorH_G[4] = 100 : ColorH_B[4] = 020 : ColorH_H[4] = 1.125 ; rocks
			ColorH_R[5] = 200 : ColorH_G[5] = 050 : ColorH_B[5] = 000 : ColorH_H[5] = 1.170 ; reddish ...
			ColorH_R[6] = 255 : ColorH_G[6] = 255 : ColorH_B[6] = 255 : ColorH_H[6] = MaxH; heigh mountains (snow)
		
	; *********************
	; * Randomize heights *
	; *********************
		
		For nc = 1 To CountChildren(geosphere)
			; debug progress
			DrawProgress(Float(nc-1)/(CountChildren(geosphere)-1), "Generate Heights")
			
			; get child mesh and its surfaces
			child = GetChild(geosphere,nc)
				; set the "material"
				EntityShininess child,.05
				EntityTexture child, tex
				
			For is = 1 To CountSurfaces(child)
				surf	=	GetSurface (child,is)
				
				For v = 0 To CountVertices(surf)-1
					Local x#=VertexX(surf, v), y#=VertexY(surf, v),z#=VertexZ(surf, v)
					; initialize height to 1.0 (for a normalized sphere, radius is "1" for any vertex)
					sumH = 1.0
					For rh = Each RandHeight
						Local dx# = (x-rh\X)
						Local dy# = (y-rh\Y)
						Local dz# = (z-rh\Z)
						; distance from the vertex to the random sphere
						Local d# = (dx*dx+dy*dy+dz*dz)
						; vertex in range : sum up the interpolated height
						If (d&lt;rh\N) Then sumH = sumH + rh\H*(rh\N-d)/rh\N
					Next
					
					; [optional : exponential height]
					; (remove this line for smoother results)
					sumH = sumH * sumH * sumH * sumH
					
					; clamp height
					If (sumH&lt;MinH)
						sumH = MinH
					ElseIf (sumH&gt;MaxH)
						sumH=MaxH
					EndIf
					
					; set new coordinates (push the vertex along the normal)
					VertexCoords(surf, v, x*sumH, y*sumH, z*sumH)
					
				Next
			Next
		Next
		
	; *********************
	; * Extract heightmap *
	; *********************
		
		; -------------------------------------------------------------
		; &gt; Unfold the scene then convert heights to color
		; -------------------------------------------------------------
			; create a temporary scene with copies of the surfaces
			; flatten the coordinates using the UVs as projection
			; render the scene to a camera with viewport sized to the
			; heightmap resolution
			; /!\ The CameraCls 255,000,255 is required to expand
			; the seams so that the pixels of the lines at the top and
			; bottom are not visible
		
		Local UVCam = CreateCamera()
			MoveEntity UVCam,32000,-32000,32000
			CameraViewPort(UVCam, 0,0, FrameSize*2,FrameSize*2)
			CameraClsColor(UVCam, 255,000,255)
			CameraProjMode(UVCam, 2)
			CameraRange(UVCam, 1,2)
			CameraZoom(UVCam, 1)
			
			; create a new mesh to happen the flattened surfaces
			Local sub = CreateMesh(UVCam)
				; fx fullbright + vertex color + 2 sided
				EntityFx sub, 1+2+16
				Local surfUV = CreateSurface(sub)
			
		For nc = 1 To CountChildren(geosphere)
			; progress bar
			DrawProgress(Float(nc-1)/(CountChildren(geosphere)-1), "Extract HeightMap")
			
			child = GetChild(geosphere,nc)
			
			Local Min_I# = 2000
			Local Min_J# = 2000
			Local DestI = TexW+1, DestJ = TexH+1
			Local UV_I%, UV_J%
			
			Local MinU# = 10
			Local MinV# = 10
			Local curU#, curV#
			
			For is = 1 To CountSurfaces(child)
				
				ClearSurface (surfUV,1,1)
				
				Local CellI = 10
				Local CellJ = 10
				Local OffsetU# = 0.0
				Local OffsetV# = 0.0
				
				surf = GetSurface(child,is)
				For v = 0 To CountVertices(surf)-1
					Local c_i = Floor(VertexU(surf,v)*8)
					Local c_j = Floor(VertexV(surf,v)*4)
					If (c_i&lt;CellI) Then CellI = c_i
					If (c_j&lt;CellJ) Then CellJ = c_j
				Next
				
				OffsetU = 0.125 * CellI
				OffsetV = 0.25 * CellJ
				
				Select CellJ
					Case 0 : DestJ=0 : OffsetV = 0
					Case 1,2 : DestJ = FrameSize/2 : OffsetV = 0.25
					Case 3 : DestJ = FrameSize+FrameSize/2 : OffsetV = 0.75
				End Select
				
				DestI = CellI * FrameSize / 2
				
				surf = GetSurface(child,is)
				For v = 0 To CountVertices(surf)-1
					; convert vertex uv to screen coordinates
					Local uv_v = AddVertex (surfUV, -1+4.0*(VertexU(surf,v)-OffsetU), 1.0-2.0*(VertexV(surf,v)-OffsetV), 1)
					; convert distance from center to height
					sumH = Sqr(VertexX(surf,v)^2+VertexY(surf,v)^2+VertexZ(surf,v)^2)
					; convert height to color
					Local h_c% = Int( Floor( 255.0*(sumH-MinH)/(MaxH-MinH)))
					; color the vertex
					VertexColor(surfUV,uv_v, h_c,h_c,h_c, 1.5)
				Next
				
				; build the triangles ^^
				For t = 0 To CountTriangles(surf)-1
					AddTriangle(surfUV, TriangleVertex(surf,t,0),TriangleVertex(surf,t,1),TriangleVertex(surf,t,2))
				Next
				
				; copy the screen to the heightmap texture
				RenderWorld()
				
				LockBuffer()
					LockBuffer BufH
						For j = 0 To FrameSize-1
							For i = 0 To FrameSize-1
								Local pixel = ReadPixelFast(i,j)
								If (pixel&lt;&gt;$FFFF00FF And pixel&lt;&gt;$FF00FF)
									Local i_= i+DestI
									If i_&gt;=0 And i_ &lt;TexW
										Local j_= j+DestJ
										If j_&gt;=0 And j_&lt;TexH
											WritePixelFast(i_,j_, pixel, bufH)
										EndIf
									EndIf
								EndIf
							Next
						Next
					UnLockBuffer(BufH)
				UnLockBuffer()
				
			Next
			
		Next
		
		; free the scene (the camera and all its hierarchy)
		FreeEntity UVCam
		
		
		
		; fill the pink holes
		ExpandSeams(heightmap)
		
		; set height color
		LockBuffer bufH
			SetBuffer TextureBuffer (tex)
			LockBuffer()
				Local h_Coef# = (MaxH-MinH) / 255.0
				For j = 0 To TexH-1
				For i = 0 To TexW-1
					; convert [0-255] height to [Min-Max] height
					sumH = MinH + (Float(ReadPixelFast(i,j, bufH) And $FF)) * h_Coef
					
					; initialize with default color (= default color for deepest height)
					Local v_r% = ColorH_R[0], v_g%=ColorH_G[0], v_b%=ColorH_B[0]
					
					; get color depending on height
					For n = 6 To 0 Step -1
						If (sumH&gt;=ColorH_H[n])
							Local h_# = (sumH - ColorH_H[n])/(ColorH_H[n+1]-ColorH_H[n])
							v_r = ColorH_R[n] + (ColorH_R[n+1]-ColorH_R[n]) * h_
							v_g = ColorH_G[n] + (ColorH_G[n+1]-ColorH_G[n]) * h_
							v_b = ColorH_B[n] + (ColorH_B[n+1]-ColorH_B[n]) * h_
							found=1
							Exit
						EndIf
					Next
					
					; write the pixel color.
					WritePixelFast i,j, $FF000000 + v_r Shl(16) + v_g Shl(8) + v_b
				Next
			Next
			UnlockBuffer()
			SetBuffer BackBuffer()
		UnlockBuffer(bufH)
		
		; export height and diffuse to bmp
		SaveBuffer bufH, "geo_hmap.bmp"
		SaveBuffer TextureBuffer(tex), "geo_tex.bmp"
		
	; ******************
	; * Update Normals *
	; ******************
		
		Function CrossF3(r#[3], a#[3],b#[3])
			r[0] = a[1]*b[2]-a[2]*b[1]
			r[1] = a[2]*b[0]-a[0]*b[2]
			r[2] = a[0]*b[1]-a[1]*b[0]
		End Function
		Function TFormF3(R#[3], V#[3], X#[3],Y#[3],Z#[3])
			R[0] = v[0] * X[0] + V[1] * Y[0] + V[2] * Z[0]
			R[1] = v[0] * X[1] + V[1] * Y[1] + V[2] * Z[1]
			R[2] = v[0] * X[2] + V[1] * Y[2] + V[2] * Z[2]
		End Function
		Function MagF3(N#[3])
			Local l# = 1.0/Sqr(N[0]*N[0]+N[1]*N[1]+N[2]*N[2])
			N[0]=N[0]*l : N[1]=N[1]*l : N[2]=N[2]*l
		End Function
		
		Function QSetM3(q#[4], X#[3],Y#[3],Z#[3])
			Local t# = X[0]+Y[1]+Z[2]
			If( t&gt;0.00000001 )
				t = Sqr( t+1.0 )*2.0;
				q[1] = (Z[1]-Y[2])/t;
				q[2] = (X[2]-Z[0])/t;
				q[3] = (Y[0]-X[1])/t;
				q[0] = t*.25;
			ElseIf( X[0]&gt;Y[1] And X[0]&gt;Z[2] )
				t=Sqr( X[0]-Y[1]-Z[2]+1.0 )*2.0;
				q[1]=t*.25;
				q[2]=(Y[0]+X[1])/t;
				q[3]=(X[1]+Z[0])/t;
				q[0]=(Z[2]-Y[2])/t;
			ElseIf( Y[1]&gt;Z[2] )
				t=Sqr( Y[1]-Z[2]-X[0]+1.0 )*2;
				q[1]=(Y[0]+X[1])/t;
				q[2]=t*.25;
				q[3]=(Z[1]+Y[2])/t;
				q[0]=(X[2]-Z[0])/t;
			Else
				t=Sqr( Z[2]-Y[1]-X[0]+1.0 )*2.0;
				q[1]=(X[2]+Z[0])/t;
				q[2]=(Z[1]+Y[1])/t;
				q[3]=t*.25;
				q[0]=(Y[0]-X[1])/t;
			EndIf;
		End Function
		Function QMulV(r#[3], q#[4],v#[3])
			Local qw# = 			- q[1]*v[0]	- q[2]*v[1]	- q[3]*v[2];
			Local qx# = + q[0]*v[0] 			- q[2]*v[2]	+ q[3]*v[1];
			Local qy# = + q[0]*v[1]	+ q[1]*v[2]				- q[3]*v[0];
			Local qz# = + q[0]*v[2]	- q[1]*v[1]	+ q[2]*v[0];
			r[0] = - qw*q[1] + qx*q[0] + qy*q[3] - qz*q[2];
			r[1] = - qw*q[2] - qx*q[3] + qy*q[0] + qz*q[1];
			r[2] = - qw*q[3] + qx*q[2] - qy*q[1] + qz*q[0];
		End Function
		
		Local q#[4]
		
		; finally : use the heightmap to update the vertex normals
		For nc = 1 To CountChildren(geosphere)
			; progress bar
			DrawProgress(Float(nc-1)/(CountChildren(geosphere)-1), "Update Normals")
			
			SetBuffer bufH
			LockBuffer()
			child = GetChild(geosphere,nc)
			For is = 1 To CountSurfaces(child)
				surf = GetSurface(child,is)
				Local X_#[3], Y_#[3], Z_#[3], N_#[3], T_#[3]
				For v = 0 To CountVertices(surf)-1
					Y_[0]=VertexNX(surf, v)
					Y_[1]=VertexNY(surf, v)
					Y_[2]=VertexNZ(surf, v)
					
					MagF3(Y_)
					X_[0]=1:X_[1]=0:X_[2]=0
					If Abs(Y_[1])&lt;1
						X_[0] = -Y_[2]
						X_[2] = Y_[0]
						MagF3(X_)
					EndIf
					CrossF3(Z_,X_,Y_)
					MagF3(Z_)
					QSetM3(q, X_,Y_,Z_)
					
					Local ti = Float(TexW-1) * VertexU(surf,v)
					Local tj = Float(TexH-1) * VertexV(surf,v)
					Local hT# = Float((ReadPixelFast(ti,tj) And $FF))/255
					Local hl# = 0, hr# = 0, hu# = 0, hd# = 0
					If (ti&gt;0)
						hl = Float((ReadPixelFast(ti-1,tj) And $FF))/255-hT
					Else
						hl = Float((ReadPixelFast(TexW-1,tj) And $FF))/255-hT
					EndIf
					If (ti&lt;TexW-1)
						hr = Float((ReadPixelFast(ti+1,tj) And $FF))/255-hT
					Else
						hr = Float((ReadPixelFast(0,tj) And $FF))/255-hT
					EndIf
					If (tj&gt;0) Then hd = Float((ReadPixelFast(ti,tj-1) And $FF))/255-hT
					If (tj&lt;TexH-1) Then hu = Float((ReadPixelFast(ti,tj+1) And $FF))/255-hT
					
					N_[0] = (hl-hr)
					N_[1] = Float(1)/128
					N_[2] = -(hd-hu)
					MagF3(N_)
					QMulV(T_,q,N_)
					
					VertexNormal surf, v, T_[0],T_[1],T_[2]
					VertexColor surf, v, 128+127*T_[0],128+127*T_[1],128+127*T_[2]
				Next
			Next
			
			UnLockBuffer()
			SetBuffer BackBuffer()
		Next
		
		
		; Weld normals
		For nc = 1 To 8
			; progress bar
			DrawProgress(Float(nc-1)/7, "Weld Normals")
			
			Local c1 = 1 + (nc&gt;4) * 4, c2 = 4 + (nc&gt;4) * 4
			SetBuffer bufH
			LockBuffer()
			child = GetChild(geosphere,nc)
			For is = 1 To CountSurfaces(child)
				surf = GetSurface(child,is)
				For v = 0 To CountVertices(surf)-1
					
					Local vx# = VertexX(surf,v)
					Local vy# = VertexY(surf,v)
					Local vz# = VertexZ(surf,v)
					Local vnx# = VertexNx(surf,v)
					Local vny# = VertexNy(surf,v)
					Local vnz# = VertexNz(surf,v)
					Local vnn#
					
					found = False
					; parse again
					For nc2 = nc+1 To c2
						if (nc &lt;&gt; nc2)
							Local child2=GetChild(geosphere, nc2)
							Local is2%, surf2, v2
							For is2 = 1 To CountSurfaces(child2)
								surf2 = GetSurface(child2,is2)
								For v2 = 0 To CountVertices(surf2)-1
									If (v&lt;&gt;v2)
										If (VertexX(surf2, v2)=vx) And (VertexY(surf2, v2)=vy) And (VertexZ(surf2, v2)=vz)
											vnx = (VertexNx(surf2,v2) + vnx)*0.5
											vny = (VertexNy(surf2,v2) + vny)*0.5
											vnz = (VertexNz(surf2,v2) + vnz)*0.5
											VertexNormal surf, v, vnx,vny,vnz
											VertexNormal surf2, v2, vnx,vny,vnz
											Exit
										EndIf
									EndIf
								Next
								If found Then Exit
							Next
							If found Then Exit
						EndIf
					Next
				Next
			Next
			UnLockBuffer()
			SetBuffer backBuffer()
		Next
		
		
; *****************************************************************************************
; * SAMPLE *
; *****************************************************************************************
	
	AmbientLight 0,0,0
	
	Local light1=	CreateLight		( 3 )
					PositionEntity	( light1, 200,100,-200 )
					PointEntity		( light1, geosphere )
					LightRange		( light1, 600 )
					LightColor		( light1, 255,180,100 )
					
	Local light2=	CreateLight		( 1 )
					PositionEntity	( light2, -500,-1000,500 )
					PointEntity		( light2, geosphere )
					LightRange		( light2, 10000 )
					LightColor		( light2, 000,030,100 )
					
	Local piv	=	CreatePivot		( )
	Local pit	=	CreatePivot		( piv )
	Local cam	=	CreateCamera	( pit )
					CameraRange		( cam, .1,1000 )
					MoveEntity		( cam, 0,0,-10 )
					CameraClsColor	( cam, 10,15,30 )
					
	Local Water	=	CreateSphere	( 64 )
					EntityColor		( Water, 000,100,255 )
					EntityAlpha		( Water, .5 )
					EntityShininess	( Water, .6 )
					EntityBlend		( Water, 3 )
					
	FlushMouse()
	
	Repeat
		
		; switch wireframe on keyhit F2
			If KeyHit(60) Then Wire = Not(Wire) : WireFrame Wire
			
		; Rotate Orbital Camera
			Msx# = MouseXSpeed()
			Msy# = MouseYSpeed()
			If MouseDown(2)
				TurnEntity piv, 0,-msx,0
				TurnEntity pit, +msy,0,0
			EndIf
			
		; Zoom
			PositionEntity cam, 0,0,EntityZ(cam, 0) * (1-0.05*Float(MouseZSpeed())),0
		
		RenderWorld()
			
			Color 255,128,000
			Text 10,10, "triangles : "+TrisRendered()
			Text 10,25, "&lt; Right Mouse Down to rotate the orbital camera &gt;"
			Text 10,40, "&lt; Mouse wheel to zoom +/- &gt;"
			Text 10,55, "&lt; F2 - WireFrame &gt;"
			
			Color 000,128,255
		Flip True
		
	Until KeyDown(1)
End
</textarea><br><br><br><iframe width="560" height="345" src="http://www.youtube.com/embed/QbjQ3b8RObQ" frameborder="0" allowfullscreen></iframe><br><br>* I've add the code to the code archive, so it 'll be a bit more accurate to find it. <br><br></td></tr></table><br>
<a name="1322099"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>so let's skip this and go on for real stuff<br> <br></div><br>i agree, let's focus on what we are here for : discuss about programming with blitzplus/blitz3d/blitzmax !!!<br><br><br>nice demo <br><br></td></tr></table><br>
<a name="1322101"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I forgot to mention, the pixels of the edges (for the top and bottom parts) are stretched to meet their neighboors on the texture (so there is no hole, every pixels are filled)<br>It allows to remove some artifacts on the edges so we don't see aliasing of the texture.<br>it also allows to compute normals easily, but I still had to make a (bad) check to "weld" the normals on, the edge (it's the slowest part of the creation and would need some optimization) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
