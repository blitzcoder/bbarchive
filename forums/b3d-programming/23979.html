<!DOCTYPE html><html lang="en" ><head ><title >Verlet rope/snake sim</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Verlet rope/snake sim</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Verlet rope/snake sim</a><br><br>
<a name="248452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's an early version of my physics engine. Pre collisions-friction. The rope looks like a cylinder, but it is really just alot of sphere particles. Use F1 to pause and start, arrow keys as well as PgUp and PgDown for movement.<br><br>here it is:<br><br>[CODE]<br>Graphics3D 640,480,0,2<br><br>Global T.Vector=Vector()									<br>Global T1.Vector = Vector()<br>Global T2.Vector = Vector()<br>Global dest_xang#,dest_yang#<br><br>Global Ntime,Otime,Ntsq,Lmilli,NdivO#<br><br>Const reps=4<br><br>Type structure<br> Field name$<br> Field Frst.entity,Lst.entity<br> Field FirstC.constraint,LastC.constraint<br> Field Nxt.structure<br> Field fric#<br>End Type<br><br>Global LastS.structure=Null<br><br>Type entity<br> Field name$,mesh<br> Field Nxt.entity,FirstP.verlet,LastP.verlet,FirstC.constraint,LastC.constraint,s.structure<br> Field center.verlet,x.verlet,y.verlet<br>End Type<br><br>Type verlet<br> Field Old.Vector,Current.Vector,Force.vector<br> Field ID,Nxt.verlet,e.entity<br> Field Anchor,Mass#,collidable<br> Field rep															;Del<br>End Type <br><br>Type constraint <br> Field ID,s.structure,e.entity,Nxt.constraint<br> Field p1.verlet,p2.verlet,Desired_Dist#<br> Field springiness#,collidable<br> Field rep<br>End Type<br><br>Type Vector<br> Field x#<br> Field y#<br> Field z#<br>End Type<br><br>ti=MilliSecs()<br>;ti=188221425<br>SeedRnd ti<br>DebugLog ti<br><br>Dim RetV.verlet(1000)<br><br>st.structure=Object.structure(VString(100,1))<br><br>l1=CreateLight(1)<br>RotateEntity l1,20,45,0<br>LightColor l1,255,255,255<br><br>Global cam=CreateCamera()<br>CameraRange cam,10,20000<br><br>PositionEntity cam,0,-50,-200<br><br>cube=CreateCube()<br>FlipMesh cube<br>ScaleEntity cube,200,200,200<br>rn=1<br>Global in =CreateBank(60)<br>While Not KeyHit(1)<br> l=MilliSecs()<br> If rn Then  <br>  update<br>  dostructure st<br>  positionreps  <br> EndIf<br><br> If KeyDown(200) Then RetV(0)\Old\z#=RetV(0)\Old\z#+1 ElseIf KeyDown(208) Then RetV(0)\Old\z#=RetV(0)\Old\z#-1<br> If KeyDown(203) Then RetV(0)\Old\x#=RetV(0)\Old\x#-1 ElseIf KeyDown(205) Then RetV(0)\Old\x#=RetV(0)\Old\x#+1<br> If KeyDown(201) Then RetV(0)\Old\y#=RetV(0)\Old\y#+1 ElseIf KeyDown(209) Then RetV(0)\Old\y#=RetV(0)\Old\y#-1<br><br> If KeyHit(59) Then rn=Not rn<br> If Not MouseDown(3) Then <br>  movecam<br>  MoveEntity cam,0,0,MouseZSpeed()*2+MouseDown(1)*5+MouseDown(2)*-5 <br> Else <br>  MoveEntity cam,0,0,-MouseYSpeed()*2<br>  MoveMouse GraphicsWidth()/2,GraphicsHeight()/2<br> EndIf<br><br> RenderWorld<br> Flip<br> ttl#=ttl+(MilliSecs()-l)<br> c#=c#+1<br> DebugLog 1000/(ttl#/c#);1000/(MilliSecs()-l)<br>Wend<br><br>Function VString(num,Stp#)<br> st.structure=Object.structure(cst("String"))<br> e1.entity=Object.entity(ce("STE",st))<br> For a=0 To num<br>  If a=0 Then <br>   RetV.verlet (0)=Object.verlet(crv(e1,0,0,0,0,0,0,1))<br>  Else<br>   RetV.verlet (a)=Object.verlet(crv(e1,0,a*-Stp#,0,Rnd(-1,1),a*-stp#+Rnd(-1,1),Rnd(-1,1),0))<br>   c1.constraint=Object.constraint(cce(e1,RetV(a),RetV(a-1),1))<br>   If a&gt;1 Then c2.constraint=Object.constraint(cce(e1,RetV(a),RetV(a-2),1))<br>  EndIf<br> Next<br> Return Handle(st.structure)<br>End Function<br><br>Function cube()<br> st.structure=Object.structure(cst("Box"))<br><br> e1.entity=Object.entity(ce("Box entity",st))<br> v1.verlet=Object.verlet(crv(e1,-10,-10,-10,-10+Rnd(-1,1),-10+Rnd(-1,1),-10+Rnd(-1,1)))<br> v2.verlet=Object.verlet(crv(e1,10,-10,-10,10+Rnd(-1,1),-10+Rnd(-1,1),-10+Rnd(-1,1)))<br> v3.verlet=Object.verlet(crv(e1,-10,10,-10,-10+Rnd(-1,1),10+Rnd(-1,1),-10+Rnd(-1,1)))<br> v4.verlet=Object.verlet(crv(e1,10,10,-10,10+Rnd(-1,1),10+Rnd(-1,1),-10+Rnd(-1,1)))<br> v5.verlet=Object.verlet(crv(e1,-10,-10,10,-10+Rnd(-1,1),-10+Rnd(-1,1),10+Rnd(-1,1)))<br> v6.verlet=Object.verlet(crv(e1,10,-10,10,10+Rnd(-1,1),-10+Rnd(-1,1),10+Rnd(-1,1)))<br> v7.verlet=Object.verlet(crv(e1,-10,10,10,-10+Rnd(-1,1),10+Rnd(-1,1),10+Rnd(-1,1)))<br> v8.verlet=Object.verlet(crv(e1,10,10,10,10+Rnd(-1,1),10+Rnd(-1,1),10+Rnd(-1,1)))<br> cv.verlet=Object.verlet(csrv(e1,0,0,0,Rnd(-1,1),Rnd(-1,1),Rnd(-1,1),1))<br> xv.verlet=Object.verlet(csrv(e1,-10,0,0,-10+Rnd(-1,1),Rnd(-1,1),Rnd(-1,1),2))<br> yv.verlet=Object.verlet(csrv(e1,0,10,0,Rnd(-1,1),10+Rnd(-1,1),Rnd(-1,1),3,1))<br><br> c1a.constraint=Object.constraint(cce(e1,v1,v2,1))<br> c2a.constraint=Object.constraint(cce(e1,v2,v4,1))<br> c3a.constraint=Object.constraint(cce(e1,v3,v4,1))<br> c4a.constraint=Object.constraint(cce(e1,v1,v3,1))<br> c5a.constraint=Object.constraint(cce(e1,v2,v3,1))<br><br> c1b.constraint=Object.constraint(cce(e1,v5,v6,1))<br> c2b.constraint=Object.constraint(cce(e1,v6,v8,1))<br> c3b.constraint=Object.constraint(cce(e1,v7,v8,1))<br> c4b.constraint=Object.constraint(cce(e1,v5,v7,1))<br> c5b.constraint=Object.constraint(cce(e1,v6,v7,1))<br><br> c1c.constraint=Object.constraint(cce(e1,v1,v5,1))<br> c2c.constraint=Object.constraint(cce(e1,v2,v6,1))<br> c3c.constraint=Object.constraint(cce(e1,v3,v7,1))<br> c4c.constraint=Object.constraint(cce(e1,v4,v8,1))<br><br> c1d.constraint=Object.constraint(cce(e1,v1,v6,1))<br> c2d.constraint=Object.constraint(cce(e1,v2,v8,1))<br> c3d.constraint=Object.constraint(cce(e1,v3,v5,1))<br> c4d.constraint=Object.constraint(cce(e1,v4,v7,1))<br><br> c1e.constraint=Object.constraint(cce(e1,v1,cv,1))<br> c2e.constraint=Object.constraint(cce(e1,v5,cv,1))<br> c3e.constraint=Object.constraint(cce(e1,v2,cv,1))<br><br><br> c1f.constraint=Object.constraint(cce(e1,cv,xv,1))<br> c2f.constraint=Object.constraint(cce(e1,v4,xv,1))<br> c4f.constraint=Object.constraint(cce(e1,v7,xv,1)) <br><br> c1g.constraint=Object.constraint(cce(e1,cv,yv,1))<br> c2g.constraint=Object.constraint(cce(e1,v3,yv,1))<br> c4g.constraint=Object.constraint(cce(e1,v7,yv,1))<br><br> e1\mesh=CreateCube()<br> ScaleEntity e1\mesh,10,10,10<br> EntityColor e1\mesh,255,0,0<br><br> Return Handle(st.structure)<br>End Function<br><br>Function update()<br> If Lmilli=0 Then <br>  Ntime=10<br>  Otime=10<br>  NdivO=1<br> Else<br>  Otime=Ntime<br>  Ntime=MilliSecs()-LMilli<br>  NdivO#=Float(Ntime)/Otime<br> EndIf<br> lmilli=MilliSecs()<br> Ntsq=Ntime*Ntime<br>End Function<br><br>Function positionreps()<br> For a.verlet=Each verlet<br>  PositionEntity a\rep,a\Current\x#,a\Current\y#,a\Current\z#<br> Next<br> For b.entity=Each entity<br>  If b\mesh&lt;&gt;0 Then<br>   PositionEntity b\mesh,b\center\Current\x#,b\center\Current\y#,b\center\Current\z#<br>   AlignToVector b\mesh,b\x\Current\x#-b\center\Current\x#,b\x\Current\y#-b\center\Current\y#,b\x\Current\z#-b\center\Current\z#,1<br>   AlignToVector b\mesh,b\y\Current\x#-b\center\Current\x#,b\y\Current\y#-b\center\Current\y#,b\y\Current\z#-b\center\Current\z#,2      <br>  EndIf<br> Next<br>End Function<br><br>Function cce(ent.entity,tp1.verlet,tp2.verlet,sp#)<br> c.constraint=New constraint<br> c\e.entity=ent.entity<br> c\p1.verlet=tp1.verlet<br> c\p2.verlet=tp2.verlet<br> c\springiness#=sp#<br> c\desired_dist#=Sqr((tp1\current\x#-tp2\current\x#)^2+(tp1\current\y#-tp2\current\y#)^2+(tp1\current\z#-tp2\current\z#)^2)<br> If ent\firstC.constraint=Null Then ent\firstC.constraint=c.constraint<br> If ent\LastC.constraint&lt;&gt;Null Then ent\LastC\Nxt.constraint=c.constraint<br> ent\LastC.constraint=c.constraint<br> Return Handle c.constraint<br>End Function<br><br>Function ccs(st.structure,tp1.verlet,tp2.verlet,sp#)<br> c.constraint=New constraint<br> c\s.structure=st.structure<br> c\p1.verlet=tp1.verlet<br> c\p2.verlet=tp2.verlet<br> c\springiness#=sp#<br> c\desired_dist#=Sqr((tp1\current\x#-tp2\current\x#)^2+(tp1\current\y#-tp2\current\y#)^2+(tp1\current\z#-tp2\current\z#)^2)<br> If st\firstC.constraint=Null Then st\firstC.constraint=c.constraint<br> If st\LastC.constraint&lt;&gt;Null Then st\LastC\Nxt.constraint=c.constraint<br> st\LastC.constraint=c.constraint<br> Return Handle c.constraint<br>End Function<br><br>Function cst(Name$)<br> news.structure=New Structure<br> news\name$=name$<br> news\fric#=.99<br> If LastS.structure&lt;&gt;Null Then LastS\Nxt.structure=news.structure<br> LastS.structure=news.structure<br> Return Handle news.structure<br>End Function<br> <br>Function ce(Name$,struct.structure)<br> newe.entity=New entity<br> newe\name$=name$<br> newe\s.structure=struct.structure<br> If struct\Frst.entity=Null Then struct\Frst.entity=newe.entity<br> If struct\Lst.entity&lt;&gt;Null Then struct\Lst\NXt.entity=newe.entity<br> struct\Lst.entity=newe.entity<br> Return Handle newe.entity<br>End Function<br><br>Function crv(ent.entity,CX#,CY#,CZ#,OX#,OY#,OZ#,Anch=0)<br> v.verlet=New verlet <br> v\current.vector=New vector<br> v\current\x#=CX#<br> v\current\y#=CY#<br> v\current\z#=CZ#<br> v\Old.Vector=New Vector <br> v\Old\x#=OX#<br> v\Old\y#=OY#<br> v\Old\z#=OZ#<br> v\mass#=1<br> v\Anchor=Anch<br> v\rep=CreateSphere()<br> ScaleEntity v\rep,5,5,5<br> EntityColor v\rep,255,0,0<br> PositionEntity v\rep,CX#,CY#,CZ#<br> EntityAlpha v\rep,1<br> v\force.vector=New vector<br> v\force\y#=-.0001<br> v\e.entity=ent.entity<br> If ent\FirstP.verlet=Null Then ent\FirstP.verlet=v.verlet<br> If ent\LastP.verlet&lt;&gt;Null Then ent\LastP\NXt.verlet=v.verlet<br> ent\LastP.verlet=v.verlet<br> Return Handle(v.verlet)<br>End Function<br><br>Function csrv(ent.entity,CX#,CY#,CZ#,OX#,OY#,OZ#,SP,Anch=0)<br> v.verlet=New verlet <br> v\current.vector=New vector<br> v\current\x#=CX#<br> v\current\y#=CY#<br> v\current\z#=CZ#<br> v\Old.Vector=New Vector <br> v\Old\x#=OX#<br> v\Old\y#=OY#<br> v\Old\z#=OZ#<br> v\mass#=1<br> v\Anchor=Anch<br> v\rep=CreateSphere()<br> ScaleEntity v\rep,5,5,5<br> EntityAlpha v\rep,1<br> If SP=3 Then EntityColor v\rep,0,0,255 Else EntityColor v\rep,255,0,0<br> PositionEntity v\rep,CX#,CY#,CZ#<br> v\force.vector=New vector<br> v\force\y#=-.0001<br> v\e.entity=ent.entity<br> Select sp<br> Case 1:<br>  ent\center.verlet=v.verlet<br> Case 2:<br>  ent\x.verlet=v.verlet<br> Case 3:<br>  ent\y.verlet=v.verlet<br> End Select<br> Return Handle(v.verlet)<br>End Function<br><br>Function dostructure(st.structure)<br> e.entity=st\Frst.entity<br> If e.entity&lt;&gt;Null Then<br>  Repeat <br>   doverlets e<br>   If e.entity=st\lst.entity Then Exit Else e.entity=e\Nxt.entity<br>  Forever<br>  For r=1 To reps<br>   c.constraint=st\firstC.constraint<br>   e.entity=st\Frst.entity<br>   If c.constraint&lt;&gt;Null Then<br>    Repeat<br>     Setdistance c\p1.verlet,c\p2.verlet,c\desired_dist#,c\springiness<br>     If c.constraint=st\LastC.constraint Then Exit Else c.constraint=c\Nxt.constraint<br>    Forever<br>   EndIf<br>   Repeat <br>    doconstraints e<br>    If e.entity=st\Lst.entity Then Exit Else e.entity=e\Nxt.entity<br>   Forever<br>  Next<br> EndIf<br>End Function<br><br>Function doentity(e.entity)<br> If e.entity&lt;&gt;Null Then<br>  doverlets e<br>  doconstraints e<br> EndIf<br>End Function<br><br>Function doverlets(e.entity)<br> v.verlet=e\firstP.verlet<br> If v.verlet&lt;&gt;Null Then<br>  Repeat<br>   indivVerlet v.verlet<br>   If v.verlet=e\LastP.verlet Then Exit Else v.verlet=v\Nxt.verlet<br>  Forever<br> EndIf<br> If e\center.verlet&lt;&gt;Null Then indivVerlet e\center.verlet<br> If e\x.verlet&lt;&gt;Null Then indivVerlet e\x.verlet<br> If e\y.verlet&lt;&gt;Null Then indivVerlet e\y.verlet<br>End Function<br><br>Function doconstraints(e.entity)<br> c.constraint=e\firstC.constraint<br> If c.constraint&lt;&gt;Null Then <br>  Repeat<br>   Setdistance c\p1.verlet,c\p2.verlet,c\desired_dist#,c\springiness#<br>   If c.constraint=e\LastC.constraint Then Exit Else c.constraint=c\Nxt.constraint<br>  Forever<br> EndIf<br>End Function<br><br>Function indivVerlet(v.verlet)<br> If v.verlet&lt;&gt;Null Then<br>  If v\Anchor=0 Then<br>   CloneVector(T,v\current)<br>   MulVecScalar(T2,v\Force,Ntsq)					; a*timestep*timestep           				(Acceleration offset)<br>   Addvector(T1,v\current,T2)						; N+a*timestep*timestep							(Acceleration with Current Position)<br>   Subvector(T2,v\Current,v\Old)					; N-O											(Uncorrected Velocity)						 	     <br>   MulvecScalar2(T2,NdivO#*v\e\s\fric#)            ; (Newtime/Oldtime)(N-O)						(Time Corrected Velocity)<br>   Addvector(v\current,T1,T2)						; N+Newtime/Oldtime(N-O)+a*Newtime*Oldtime		(Complete, time corrected physics)<br>   CloneVector(v\old,T)<br>  Else<br>   clonevector(v\current,v\old)<br>  EndIf<br> EndIf<br>End Function<br><br>Function SetDistance(p1.verlet,p2.verlet,dist#,sp#)	<br>		SubVector(T1,p1\current,p2\current)<br>		deltalength# = Sqr((T1\x * T1\x) + (T1\y * T1\y) + (T1\z * T1\z))<br>		If deltalength# &lt;= 0.0 deltalength# = 0.0001<br>		diff# = (deltalength# - dist#) / deltalength#<br>		tmass# = p1\mass + p2\mass<br>		MulVecScalar(T2,T1,diff# * (p2\mass / tmass)*sp#)<br>		SubVector2(p1\current,T2)<br>		MulVecScalar(T2,T1,diff# * (p1\mass / tmass)*sp#)<br>		AddVector2(p2\current,T2)<br>End Function<br><br>Function Vector.Vector(x#=0.0,y#=0.0,z#=0.0)<br>	v.Vector = New Vector<br>	v\x=x<br>	v\y=y<br>	v\z=z<br>	Return v<br>End Function <br><br>;// Vector 1 is set to Vector 2<br>Function CloneVector(v1.Vector,v2.Vector)<br>	v1\x = v2\x<br>	v1\y = v2\y<br>	v1\z = v2\z<br>End Function<br><br>;// Vector Scalar Multiplication<br>;// Form of Vector1 = Vector2 * Scalar<br>Function MulVecScalar(v1.Vector,v2.Vector,s#)<br>	v1\x = v2\x * s<br>	v1\y = v2\y * s<br>	v1\z = v2\z * s<br>End Function<br><br>;// Form of Vector1 = Vector1 + Vector2<br>Function AddVector2(v1.Vector,v2.Vector)<br>	v1\x = v1\x + v2\x<br>	v1\y = v1\y + v2\y<br>	v1\z = v1\z + v2\z<br>End Function<br><br>;// Form of Vector1 = Vector1 - Vector2<br>Function SubVector2(v1.Vector,v2.Vector)<br>	v1\x = v1\x - v2\x<br>	v1\y = v1\y - v2\y<br>	v1\z = v1\z - v2\z<br>End Function<br><br>;// Form of Vector1 = Vector1 + Vector2<br>Function AddVector(v1.Vector,v2.Vector,v3.vector)<br>	v1\x = v2\x + v3\x<br>	v1\y = v2\y + v3\y<br>	v1\z = v2\z + v3\z<br>End Function<br><br>;// Vector Subtraction<br>;// Form of Vector1 = Vector2 - Vector3<br>Function SubVector(v1.Vector,v2.Vector,v3.Vector)<br>	v1\x = v2\x - v3\x<br>	v1\y = v2\y - v3\y<br>	v1\z = v2\z - v3\z<br>End Function<br><br>;// Form of Vector1 = Vector1 * Scalar<br>Function MulVecScalar2(v1.Vector,s#)<br>	v1\x = v1\x * s<br>	v1\y = v1\y * s<br>	v1\z = v1\z * s<br>End Function<br><br>; the rest is from Rob hutchison<br>Function movecam()<br> mxs=MouseXSpeed()/2<br> mys=MouseYSpeed()/2<br>		<br> ; Update destination camera angle x and y values<br> dest_xang#=dest_xang#+mys<br> dest_yang#=dest_yang#-mxs<br>	<br> ; Curve camera angle values towards destination values<br> xang#=CurveValue#(xang#,dest_xang#,5)<br> yang#=CurveValue#(yang#,dest_yang#,5)<br>	<br> RotateEntity cam,xang#,yang#,0<br> MoveMouse GraphicsWidth()/2,GraphicsHeight()/2<br>End Function<br><br>Function CurveValue#(current#,destination#,curve)<br>	current#=current#+((destination#-current#)/curve)<br>	Return current#<br>End Function<br>[/CODE]<br><br>If you use it, please credit bot builder(myself).<br><br>[CODE]<br>;Change <br><br>st.structure=Object.structure(VString(100,1)) <br><br>;to <br><br>st.structure=Object.structure(cube()) <br><br>;and take out <br>If KeyDown(200) Then RetV(0)\Old\z#=RetV(0)\Old\z#+1 ElseIf KeyDown(208) Then RetV(0)\Old\z#=RetV(0)\Old\z#-1<br>If KeyDown(203) Then RetV(0)\Old\x#=RetV(0)\Old\x#-1 ElseIf KeyDown(205) Then RetV(0)\Old\x#=RetV(0)\Old\x#+1<br>If KeyDown(201) Then RetV(0)\Old\y#=RetV(0)\Old\y#+1 ElseIf KeyDown(209) Then RetV(0)\Old\y#=RetV(0)\Old\y#-1<br>[/CODE]<br><br>Also, to change accuracy, increase or decrease reps. <br><br></td></tr></table><br>
<a name="248644"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fantastic stuff!!!!<br><br>This is an option to the actual ODE wrapper indeed :)<br><br>BTW, where are collisions ? <br><br></td></tr></table><br>
<a name="248871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you. Heh. Collisions aren't here yet. that's why I said pre collisions-friction. I could use blitze's built in collision detection, but they don't have line to poly collisions :( . I guess I could do with a long cylinder but blitz doesn't have that either. linepicks to slow. I need somthing that runs in less that 1 tenth of a millisecond, as I expect to run it hundreds of times per-loop, yet the physics should run at 60-100 fps, allowing the game some proccessing time to. I also plan to run diffferent objects at different rates. So far away objects have less physics detail. I also plan on having the far away objects update less accuratly. Working on the collisions now...... <br><br></td></tr></table><br>
<a name="249017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmc</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> thats pretty cool stuff. good work. look forward to seeing it evlolve. <br><br></td></tr></table><br>
<a name="249353"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Heh. Thanks. Right now my main focus is on collisions, as I said. I've come up with a giant system<br>that should hopefully run pretty fast. It will basically be a whole custom collision system that<br>sadly won't be very user-friendly unless I create a custom editer. basically, it will be a large<br>hierchy of collision checks, all box checks, that contain quad checks, triangle checks, more <br>box checks, cylinder checks, and sphere checks. The hierarchy of collision checks is<br>similar to a portal system(I think). It checks whether or not an entity could be in an area,<br>and if it is then it goes on to another check that involves a smaller area, until it has such <br>few colision possibilities that they run quickly. I've also decided to specialize the collision<br>system to deal not only with triangles, but with quads, as it is fast to check if a quad is <br>being collided with. Especially in the case that the quad is horizontal or vertical. In fact,<br>I have seperate type structures to deal with quads aligned to the different axis. I haven't <br>done any work with the other collision checks yet, as they are quite a bit harder.<br><br>Once I get collisions and friction sorted out, evolving constraints are in, then <br>possibly evolving Verlets, then several editers to edit the collision structures, <br>verlet positions, etc. So basically, I have my work cut out :) . <br><br></td></tr></table><br>
<a name="249371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmc</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> my god man... you do have your work cut out for you. im especially interested in what you come up with for collision detection AND response. i havent had much luck trying to make my own. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
