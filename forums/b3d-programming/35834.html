<!DOCTYPE html><html lang="en" ><head ><title >Help with Swift Shadow system</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Help with Swift Shadow system</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Help with Swift Shadow system</a><br><br>
<a name="391103"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >banky</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all<br><br>I recently bought the swift shadow system and I have a problem with animated characters.<br><br>I tried to run the demo using the Mario animated mesh (from the castle demo of blitz). If I use LoadMesh the shadow works perfectly, buy if I use LoadAnimMesh the shadow doesn't appear...<br><br>Help, please... :)<br><br>Thank you in advance<br>-Banky <br><br></td></tr></table><br>
<a name="391119"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> LoadAnimMesh attaches a structure to the model, and the first level of that structure is a null pivot, not your model. Find the name of the main model in your modeller ( or there is a B3d hierarchy viewer in the code archives ) and then get the handle of that with the FindChild() command. You can then set *this* as the shadowcaster. <br><br></td></tr></table><br>
<a name="392392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >banky</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the answer Sybixsus,<br>but my problem is that I can't use the name of the main model. To make the shadows work I have to set as a shadowcaster every part of the model (for example, right arm, left arm, left leg...) and this way the system is sooooo slow. (19 frames in a Athlon XP+ 2600 with a Geforce FX 5600)<br><br>Is this the only way to make it work with animated meshes?<br><br>Help, please... :) <br><br>Thank you in advance <br>-Banky <br><br></td></tr></table><br>
<a name="392432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Generally you would use a single model which was animated with skeletal animation, thus only needing one shadow casting object. You could probably get around this problem by creating a cube which is just big enough to envelop the entire character, then parent the character to the cube and set the cube as the shadow casting object. If you need the player to be parented for something else, just parent it to the cube directly before calling Update_Shadows() and then immediately afer, parent it back to whatever else you want it parented to. <br><br></td></tr></table><br>
<a name="392569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Banky:<br><br>Your post convinced me to take another look at the possiblity of adding the ability to cast shadows from compound objects made of multiple entities.  I think I can do it in a manner which would work well enough for animated characters, but I need a demo to test with.<br><br>If you could send me a simple program with your segmented model animating onscreen with a lightsource and something set for it to cast shadows on, then that would be helpful.  Set the shadow to cast from it's head or something and I will change it to the pivot myself.  That way you can tell it's set up right before you send it. <br><br></td></tr></table><br>
<a name="392604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I've fixed the problem... jsut need a demo from you to test with. :-) <br><br></td></tr></table><br>
<a name="392867"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Isaac P</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> sswift use the markio demo from the blitz3d folder and substitute the terrain for a mesh terrain, i think that is the model he is using anyways <br><br></td></tr></table><br>
<a name="392929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >puki</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mmm, I just bought "sswifty's" shadow system.  Hope I get an updated one. <br><br></td></tr></table><br>
<a name="393463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >banky</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, Sswift<br><br>This is my piece of code... Just a modification of the demo code with an animated character and a gile[s] level.<br><br>I hope it will be useful to you...<br><br>Thanks for the answers, <br>- Banky<br><br>---<br><br><br>Type emitter<br>	Field parent,rate#,time#<br>	Field texture,blend<br>	Field speed#,spread#,life#,size#,growth#,gravity#<br>End Type<br><br>Type particle<br>	Field sprite<br>	Field x#,y#,z#<br>	Field sx#,sy#,sz#<br>	Field life#,lifespan#,size#,growth#,gravity#<br>End Type<br><br>Type flare<br>	Field sprite<br>	Field texture<br>	Field alpha#,talpha#<br>End Type<br><br>;#Region Program Setup<br><br><br>Global Terminate = False   ; Set this to True anywhere to terminate the program.<br><br>; Setup the screen dimensions<br>Global ScreenWidth  = 1024<br>Global ScreenHeight = 768<br>Global ScreenDepth  = 16<br>Global ScreenMode   = 2<br><br>; Create the screen.<br>Graphics3D ScreenWidth,ScreenHeight,ScreenDepth,ScreenMode <br>SetBuffer BackBuffer()     ; Switch to Back Buffer for Double Buffered drawing.<br><br>; Setup the lighting...<br>AmbientLight 200,200,200<br><br>;#End Region<br><br>;#Region Declarations<br><br>; Setup the camera.<br>;Global MainCamera = CreateCamera()<br><br><br>;#End Region<br><br>Include "Swift Shadow System - 097.bb"<br>Include "ParseB3D.bb"<br><br>Global info1$="Swift Shadow System Demo"<br>Global info2$="Please note that this is a STRESS TEST!"<br>Global info3$="There are 48 pairs of casting/receiving objects in this scene."<br>Global info4$="And double that number when you add a second light!"<br>Include "start.bb"<br><br>; Stuff for the normal calculation function:<br>Dim Face_NX#(32768)<br>Dim Face_NY#(32768)<br>Dim Face_NZ#(32768)<br>		<br>Dim Vertex_ConnectedTris(32768)<br>Dim Vertex_TriList(32768, 16)<br><br>; Stuff for the HSV to RGB function.<br>Global HSV_R<br>Global HSV_G<br>Global HSV_B<br><br><br>.Main<br><br>	; Removes all the default flags when you load a texture.<br>	; Required because shadow maps cannot be mipmapped or the UV clamping will cause artifacts, <br>	; and blitz by default has mipmapping enabled for all textures loaded.<br>	ClearTextureFilters  <br><br>	<br>	; Load a texture for our fake shadows.<br>	; Note the flags:<br>	; Texture must have UV clamping enabled, and no mipmapping!<br>	Global TEX_Fake_Shadow = LoadTexture("TEX-003.jpg", 16+32)<br><br>	<br>	; Create a camera and move it back from 0,0,0<br>	Camera = CreateCamera()<br>	CameraRange Camera, 0.1, 65536<br>	;PositionEntity Camera, 0, 200, -800<br><br>	Camera_Pivot = CreatePivot()<br>	<br>	EntityParent Camera, Camera_Pivot, True<br><br>	; Set up the lights.<br>	Gosub Setup_Lights<br><br>	Gosub Create_Objects<br><br>	Shadow_Resolution = 256<br><br>	; Set the amount to nudge the shadows by to combat z fighting.<br>	Shadow_Nudge# = 0.75<br><br>	Animated_Casters(caster_2)<br><br>	; Remember that we're drawing rendered shadows by default.<br>	Cast_Rendered_Shadows = True<br>	<br>	; Specify what objects should receive shadows.<br>	; It's not a good idea to have too many objects receiving shadows.<br>	Receive_Shadow(Receiver_1)<br>		<br>	; Specify the lights which cast shadows, and set their range.<br>	Cast_Light(Light_1, 2000)<br><br>	Time_Old = MilliSecs()<br>	Time_Of_Next_Event = Time_Old + 2000<br><br>	<br><br>	While Not KeyDown(1)<br><br>		Time_New		= MilliSecs()<br>		Time_Delta      = Time_New - Time_Old				<br>		Time_Delta_Sec# = Float(Time_Delta)/1000.0<br>		Time_Old		= Time_New<br><br>		If KeyHit(88) Then SaveScreenshot()<br>	<br>	<br>		If KeyHit(2)<br><br>			; Stop the objects from casting shadows.			<br>			; Note:<br>			; You only need to call this once per object casting shadows, <br>			; even if it casts shadows onto more than one reciever.<br>			Delete_Shadow_Caster(Caster_2)		; Fighter<br>			<br>			; If we're currenty casting rendered shadows...<br>			If Cast_Rendered_Shadows = True<br><br>				; Make the objects cast fake shadows.<br>				; The value of the resolution parameter doesn't matter because you created the texture.<br><br>				Cast_Textured_Shadow(caster_2, TEX_Fake_Shadow) 	; Fighter<br>				<br>				<br>				Cast_Rendered_Shadows = False<br>							<br>			Else<br>			<br>				; Make the objects cast rendered shadows.<br>				; We don't need a texture parameter because the function will create a unique texture<br>				; for each shadow itself.<br><br>				Cast_Shadow(caster_2,   Shadow_Resolution)		; Fighter<br><br>				Cast_Rendered_Shadows = True<br>				<br>			EndIf<br>		<br>		EndIf		<br>	<br>		<br>		If KeyHit(3)<br>		<br>			If Shadow_Resolution = 128<br>				Shadow_Resolution = 256<br>			Else<br>				If Shadow_Resolution = 256<br>					Shadow_Resolution = 512<br>				Else<br>					If Shadow_Resolution = 512<br>						Shadow_Resolution = 128	<br>					EndIf<br>				EndIf<br>			EndIf<br><br><br>			; If we're currenty casting rendered shadows...<br>			If Cast_Rendered_Shadows = True<br>	<br>				; Stop the objects from casting shadows.			<br>				; Note:<br>				; You only need to call this once per object casting shadows, <br>				; even if it casts shadows onto more than one reciever.<br>				Delete_Shadow_Caster(caster_2)		; Fighter<br>			<br>				; Make the objects cast rendered shadows.<br>				; We don't need a texture parameter because the function will create a unique texture<br>				; for each shadow itself.<br>				Cast_Shadow(caster_2, Shadow_Resolution)		; Fighter<br>;				<br>			EndIf<br><br><br>		EndIf<br>	<br>			<br>		If KeyHit(4)<br>	<br>			Delay 5000<br>											<br>		EndIf<br>	<br>		<br>		If KeyHit(5)<br>	<br>			FormatC = Not FormatC<br>												<br>		EndIf<br>			<br><br>		If KeyHit(6)<br>	<br>			Second_Light = Not Second_Light<br>			<br>			If Second_Light = True<br><br>				Cast_Light(Light_2, 2000)<br>				ShowEntity Light_2<br>				<br>			Else<br><br>				Delete_Light_Caster(Light_2)					<br>				HideEntity Light_2<br>				<br>			EndIf									<br>												<br>		EndIf<br><br>		<br>		If KeyHit(57)<br>			Show_Shadow_Map = Not Show_Shadow_Map<br>		EndIf<br>				<br>		;TurnEntity Caster_1, 1, 1, 1<br>		TurnEntity Caster_2, 1, 0.5, 0<br>		;TurnEntity Caster_3, 0, 1, 0.5<br><br>		TurnEntity Light_Pivot, 0.25, 0.5, 1		<br>				<br>		Update_Shadows(camera) <br><br>		UpdateWorld<br>		If Show_Shadow_Map = False Then RenderWorld<br><br>		Select Event <br>		<br>			Case 0 <br>		<br>				Info$ = "-- Swift Shadow System - Created by Shawm C. Swift --"<br>		<br>			Case 1<br>						<br>				Info$ = "-- Press 1 to toggle rendered/fake shadows! --"<br>				<br>			Case 2<br><br>				Info$ = "-- Press 2 to toggle shadow resolution between 128, 256, and 512! --"<br>				<br>			Case 3<br>			<br>				Info$ = "-- Press 3 to crash your pc! --"<br>				<br>			Case 4<br>			<br>				Info$ = "-- Press 4 to FORMAT C: drive! ---"<br>		<br>			Case 5<br>			<br>				Info$ = "-- Press 5 to kill your framerate... I mean add a second light to the scene. --"<br>				<br>		End Select <br>				<br>		Text GraphicsWidth()/2, 16*1, Info$, True, False<br><br>		If (Time_Delta &gt; 0)<br>			Frames_Per_Second = Int(Floor(1000.0/Float(Time_Delta)))<br>			Text GraphicsWidth()/2, 16*2, "FPS: " + Str$(Frames_Per_Second), True, False<br>		EndIf	<br><br>		Select (Event Mod 3)<br>		<br>			Case 0<br>		<br>				Text GraphicsWidth()/2, 16*3, "Shadow Resolution: " + Str$(Shadow_Resolution), True, False<br>				<br>			Case 1<br>					<br>				Text GraphicsWidth()/2, 16*3, "Shadow Polys: " + Str$(Shadow_Poly_Count), True, False<br>				<br>			Case 2<br>					<br>				Text GraphicsWidth()/2, 16*3, "Scene Polys: " + Str$(TrisRendered()), True, False<br><br>		End Select<br>		<br>		<br>		If FormatC = True<br>			Text GraphicsWidth()/2, GraphicsHeight()/2, "Formatting C:\ ... Please wait.", True, True		<br>		EndIf<br><br>		Flip False<br><br>	Wend<br><br>End<br><br>; -------------------------------------------------------------------------------------------------------------------<br>.Setup_Lights<br><br>	; Tell the shadow system what the ambient light level is.  (Blitz doesn't have a command to retreive that info.)<br>	Shadow_Ambient_Light_R = 80<br>	Shadow_Ambient_Light_G = 80<br>	Shadow_Ambient_Light_B = 128<br><br>	AmbientLight Shadow_Ambient_Light_R, Shadow_Ambient_Light_G, Shadow_Ambient_Light_B<br><br>	; Create three point light sources.<br>	Light_1 = CreateLight(2)<br>	Light_2 = CreateLight(2)<br>	<br>	; Set the color of the lights.<br>	LightColor Light_1, 255, 255, 240<br>	LightColor Light_2, 255, 255, 240<br>	<br>	; Set the radius of the lights.<br>	LightRange Light_1, 2000<br>	LightRange Light_2, 2000<br><br>	; Create a pivot to rotate the light sources around.<br>	Light_Pivot = CreatePivot()<br>	PositionEntity Light_Pivot, 0, 800, 0<br>	<br>	; Attach the light sources to the pivot.<br>	EntityParent Light_1, Light_Pivot<br>	EntityParent Light_2, Light_Pivot<br>	<br>	; Position the light sources around the pivot.<br>	PositionEntity Light_1, 400, 0, 0<br>	PositionEntity Light_2, 0, 0, 400<br>	<br>	; Create entities to show the positions of the light sources in the world.<br>	TEX_04 = LoadTexture("TEX-004.bmp", 8)<br>	Light_Sprite_1 = CreateSprite(Light_1) <br>	ScaleSprite Light_Sprite_1, 100, 100<br>	EntityFX Light_Sprite_1, 1<br>	EntityBlend Light_Sprite_1, 3<br>	EntityTexture Light_Sprite_1, TEX_04<br><br>	Light_Sprite_2 = CopyEntity(Light_1, Light_2) <br>	HideEntity Light_2<br><br>Return<br><br><br>; -------------------------------------------------------------------------------------------------------------------<br>; This subroutine creates and textures the meshes we will use to cast and recieve the shadows.<br>; -------------------------------------------------------------------------------------------------------------------<br>.Create_Objects<br><br>	; We have to set the mipmap flag manually because we turned that off so we could create <br>	; shadow textures without mipmapping.	<br>	TEX_01 = LoadTexture("TEX-001.jpg", 8) <br>	TEX_02 = LoadTexture("TEX-002.jpg", 8)<br>	TEX_05 = LoadTexture("TEX-005.jpg", 8)<br>		<br>	Receiver_1 = LoadMesh("level\romanbath.b3d")<br>	ParseB3D(receiver_1)<br>	Calculate_Normals(Receiver_1)<br><br>	; Make pillars	<br>	Temp1 = CreateCylinder(12, False)<br>	ScaleMesh Temp1, 40, 100, 40<br>	UpdateNormals(Temp1)<br><br>	Temp2 = CreateCube()<br>	ScaleMesh Temp2, 50, 10, 50<br>	Calculate_Normals(Temp2)<br>	PositionMesh Temp2, 0, 100, 0<br><br>	Temp3 = CreateSphere(8)<br>	ScaleMesh Temp3, 40, 40, 40<br>	UpdateNormals(Temp3)	<br>	PositionMesh Temp3, 0, 150, 0<br>	<br>	Caster_2 = LoadAnimMesh("mario.3ds")<br><br>	Animate CASTER_2, 1, 1<br>	PositionEntity Caster_2, 0, 7, 50, True	<br>	<br>Return<br><br><br><br>; -------------------------------------------------------------------------------------------------------------------<br>; This function adds a bit of noise to a mesh so that it's more interesting.<br>; -------------------------------------------------------------------------------------------------------------------<br>Function Randomize_Mesh(ThisMesh)<br><br>	Offset = 25<br>	<br>	; Loop through all surfaces of the mesh.<br>	Surfaces = CountSurfaces(ThisMesh)<br>	For LOOP_Surface = 1 To Surfaces<br><br>		Surface_Handle = GetSurface(ThisMesh, LOOP_Surface)<br>	<br>		; Loop through all triangles in this surface of the mesh.<br>		Verts = CountVertices(Surface_Handle)<br>		For LOOP_Verts = 0 To Verts-1<br>	<br>			Vx# = VertexX#(Surface_Handle, LOOP_Verts)<br>			Vy# = VertexY#(Surface_Handle, LOOP_Verts)<br>			Vz# = VertexZ#(Surface_Handle, LOOP_Verts)<br>						<br>			VertexCoords Surface_Handle, LOOP_Verts, Vx#, Vy#+Rnd(-Offset,Offset), Vz#<br><br>		Next<br><br>	Next<br><br>End Function<br><br><br>; -------------------------------------------------------------------------------------------------------------------<br>; This function takes a screenshot of whatever is on the screen and saves it in the current directory.<br>; -------------------------------------------------------------------------------------------------------------------<br>Function SaveScreenshot()<br><br>    iFileNumber% = 0<br>    Repeat<br>        iFileNumber = iFileNumber + 1<br>        sFileName$ = "Screenshot" + String$("0", 3 - Len(Str$(iFileNumber))) + iFileNumber + ".bmp"<br>    Until Not(FileType(sFileName$))<br>    <br>    SaveBuffer FrontBuffer(), sFileName$<br><br>End Function<br><br><br>; -------------------------------------------------------------------------------------------------------------------<br>; This function calculates and sets the normals for a mesh.<br>;<br>; This is diffrent from Blitz's function in that it does not smooth across edges which do not share vertices.  <br>; In my opinion, that is the best way to calculate the normals for a mesh.  Blitz on the other hand assumes that<br>; vertices which lie at the same point in space should be smoothed across.  This works well for <br>;<br>; Should probably update this so that it can recursively loop through all of an entities children as well.<br>; -------------------------------------------------------------------------------------------------------------------<br>Function Calculate_Normals(ThisMesh)<br>	<br>	; Loop through all surfaces of the mesh.<br>	Surfaces = CountSurfaces(ThisMesh)<br>	For LOOP_Surface = 1 To Surfaces<br><br>		Surface_Handle = GetSurface(ThisMesh, LOOP_Surface)<br><br>		; Reset the number of connected polygons for each vertex.<br>		For LoopV = 0 To 32767	<br>			Vertex_ConnectedTris(LoopV) = 0<br>		Next	<br>	<br>		; Loop through all triangles in this surface of the mesh.<br>		Tris = CountTriangles(Surface_Handle)<br>		For LOOP_Tris = 0 To Tris-1<br><br>			; Get the vertices that make up this triangle.<br>				Vertex_0 = TriangleVertex(Surface_Handle, LOOP_Tris, 0)<br>				Vertex_1 = TriangleVertex(Surface_Handle, LOOP_Tris, 1)<br>				Vertex_2 = TriangleVertex(Surface_Handle, LOOP_Tris, 2)<br>	<br>			; Adjust the number of triangles each vertex is connected to and<br>			; store this triangle in each vertex's list of triangles it is connected to.<br>				ConnectedTris = Vertex_ConnectedTris(Vertex_0)<br>				Vertex_TriList(Vertex_0, ConnectedTris) = LOOP_Tris<br>				Vertex_ConnectedTris(Vertex_0) = ConnectedTris + 1<br><br>				ConnectedTris = Vertex_ConnectedTris(Vertex_1)<br>				Vertex_TriList(Vertex_1, ConnectedTris) = LOOP_Tris<br>				Vertex_ConnectedTris(Vertex_1) = ConnectedTris + 1<br><br>				ConnectedTris = Vertex_ConnectedTris(Vertex_2)<br>				Vertex_TriList(Vertex_2, ConnectedTris) = LOOP_Tris<br>				Vertex_ConnectedTris(Vertex_2) = ConnectedTris + 1<br><br>			; Calculate the normal for this face.<br><br>				; Get the corners of this face:<br>				Ax# = VertexX#(Surface_Handle, Vertex_0)<br>				Ay# = VertexY#(Surface_Handle, Vertex_0)<br>				Az# = VertexZ#(Surface_Handle, Vertex_0)<br><br>				Bx# = VertexX#(Surface_Handle, Vertex_1)<br>				By# = VertexY#(Surface_Handle, Vertex_1)<br>				Bz# = VertexZ#(Surface_Handle, Vertex_1)<br><br>				Cx# = VertexX#(Surface_Handle, Vertex_2)<br>				Cy# = VertexY#(Surface_Handle, Vertex_2)<br>				Cz# = VertexZ#(Surface_Handle, Vertex_2)<br><br>				; Triangle 1<br>				; Get the vectors for two edges of the triangle.<br>				Px# = Ax#-Bx#<br>				Py# = Ay#-By#<br>				Pz# = Az#-Bz#<br><br>				Qx# = Bx#-Cx#<br>				Qy# = By#-Cy#<br>				Qz# = Bz#-Cz#<br><br>				; Compute their cross product.<br>				Nx# = Py#*Qz# - Pz#*Qy#<br>				Ny# = Pz#*Qx# - Px#*Qz#<br>				Nz# = Px#*Qy# - Py#*Qx#<br><br>				; Store the face normal.<br>				Face_NX#(LOOP_Tris) = Nx#<br>				Face_NY#(LOOP_Tris) = Ny#<br>				Face_NZ#(LOOP_Tris) = Nz#<br><br>		Next<br><br>		; Now that all the face normals for this surface have been calculated, calculate the vertex normals.<br>		Vertices = CountVertices(Surface_Handle)<br>		For LOOP_Vertices = 0 To Vertices-1<br><br>			; Reset this normal.<br>			Nx# = 0<br>			Ny# = 0<br>			Nz# = 0<br><br>			; Add the normals of all polygons which are connected to this vertex.<br>			Polys = Vertex_ConnectedTris(LOOP_Vertices)<br>				<br>			For LOOP_Polys = 0 To Polys-1<br><br>				ThisPoly = Vertex_TriList(LOOP_Vertices, LOOP_Polys)<br><br>				Nx# = Nx# + Face_NX#(ThisPoly)<br>				Ny# = Ny# + Face_NY#(ThisPoly)<br>				Nz# = Nz# + Face_NZ#(ThisPoly)			<br>				<br>			Next	<br>				<br>			; Normalize the new vertex normal.<br>			; (Normalizing is scaling the vertex normal down so that it's length = 1)<br><br>				Nl# = Sqr(Nx#^2 + Ny#^2 + Nz#^2)<br><br>				; Avoid a divide by zero error if by some freak accident, the vectors add up to 0.<br>				; If Nl# = 0 Then Nl# = 0.1<br><br>				Nx# = Nx# / Nl#<br>				Ny# = Ny# / Nl#<br>				Nz# = Nz# / Nl#<br><br>			; Set the vertex normal.<br>			<br>				VertexNormal Surface_Handle, LOOP_Vertices, Nx#, Ny#, Nz#<br>				;VertexColor Surface_Handle, LOOP_Vertices, polys*127, polys*127, polys*127<br>		<br>		Next<br><br>	Next<br><br>End Function<br><br><br>; -------------------------------------------------------------------------------------------------------------------<br>; This function takes a color in HSV format and returns a color in RGB format.<br>; -------------------------------------------------------------------------------------------------------------------<br>Function HSV_to_RGB(h#, s#, v#)<br><br>	If s = 0 Then<br><br>		r# = g# = b# = v		;grey<br><br>	Else<br><br>		h = h / 60<br>		i = Floor(h)<br>		f# = h - i<br>		p# = v * (1 - s)<br>		q# = v * (1 - s * f)<br>		t# = v * (1 - s * (1 - f))<br><br>		Select i<br><br>			Case 0<br>				r# = v<br>				g# = t<br>				b# = p<br><br>			Case 1<br>				r# = q<br>				g# = v<br>				b# = p<br>	<br>			Case 2<br>				r# = p<br>				g# = v<br>				b# = t<br><br>			Case 3<br>				r# = p<br>				g# = q<br>				b# = v<br>	<br>			Case 4<br>				r# = t<br>				g# = p<br>				b# = v<br><br>			Default<br>				r# = v<br>				g# = p<br>				b# = q<br><br>		End Select		<br><br>	EndIf<br><br>	HSV_R = r# * 255<br>	HSV_G = g# * 255<br>	HSV_B = b# * 255<br><br>End Function <br><br>Function Animated_Casters(caster_2)<br>	<br>	Shadow_Resolution = 256<br>	<br>	If CountChildren(Caster_2) &gt; 0 <br>		For childcount = 1 To CountChildren(Caster_2) <br>			child = GetChild(caster_2, childcount) <br><br>			Animated_Casters(child)<br>		Next <br>	Else<br>		Cast_Shadow(caster_2, Shadow_Resolution)	; Fighter<br><br>	EndIf  <br>	<br><br>End Function <br><br></td></tr></table><br>
<a name="393464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I need the level and the character.  I think the character is markio?  Email them to me.  My email address is in my profile. <br><br></td></tr></table><br>
<a name="393835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just so those following the thread know, <br><br>The problem with casting shadows from groups of entities parented to one another is now fixed.  You can now load an animated mesh comprised of a group of entities that are connected to one another, and have them cast a single shadow. <br><br></td></tr></table><br>
<a name="1039240"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MoonShadow</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you post a PICTURE to see how it looks? <br><br></td></tr></table><br>
<a name="1039248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LineOf7s</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> 6 year old thread, dude. <br><br></td></tr></table><br>
<a name="1039361"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Heh my thoughts exactly LineOf7s....<br><br>PS: that "dude" was priceless. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
