<!DOCTYPE html><html lang="en" ><head ><title >Planet atmosphere glow</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Planet atmosphere glow</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Planet atmosphere glow</a><br><br>
<a name="916744"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am experimenting with a simple planet atmosphere FX without textures. I have a sphere and a ring of triangles surrounding the sphere, the ring always points to the cam. It looks nice when you're far away from the planet but doesn't work when you get closer. I am looking for some kind of formula which resizes/repositions the ring according to the viewer's perspective along the sphere. I tried some experiments with SQR,EXP and so on but wasn't successful. And even if I got close to an acceptable result it didn't worked anymore when I resized the sphere from 1.0 to 2.0 or other values.<br><br>Here is a demo code to visualize the problem:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 1024,768,32,2

; Variables
mousespeed#=0.1
cameraspeed#=0.05
camerasmoothness#=10
scale#=1.0

; Camera
cam=CreateCamera()
PositionEntity cam,0,0,-5
CameraRange cam,0.1,100

; Planet
planet=CreateSphere(32)
ScaleEntity planet,scale,scale,scale
EntityColor planet,0,255,0
EntityFX planet,1

; Glow
ring=CreateRing(1*scale,1.5*scale,30,1,255,255,255,32,32,32,0)
EntityFX ring,1+2+32

; Timer
timer=CreateTimer(60)

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

While Not KeyHit(1)
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; Mousecam
	mx#=CurveValue(MouseXSpeed()*mousespeed,mx,camerasmoothness)
	my#=CurveValue(MouseYSpeed()*mousespeed,my,camerasmoothness)
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	pitch#=EntityPitch(cam)
	yaw#=EntityYaw(cam)
	pitch=pitch+my
	yaw=yaw-mx
	If pitch&gt;89 Then pitch=89
	If pitch&lt;-89 Then pitch=-89
	RotateEntity cam,0,yaw,0
	TurnEntity cam,pitch,0,0
	
	; Movement
	cx#=(KeyDown(205)-KeyDown(203))*cameraspeed
	cz#=(KeyDown(200)-KeyDown(208))*cameraspeed
	MoveEntity cam,cx,0,cz
	
	; Ring points always to camera
	PointEntity ring,cam
	TurnEntity ring,-90,0,0
	
	RenderWorld
	
	WaitTimer timer
	
	Flip
	
Wend

End

; Smoothcam
Function CurveValue#(newvalue#,oldvalue#,increments )
	If increments&gt;1 oldvalue#=oldvalue#-(oldvalue#-newvalue#)/increments
		If increments&lt;=1 oldvalue=newvalue
			Return oldvalue#
End Function

; Create Single Surface Ring
Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,r1%=255,g1%=255,b1%=255,r2%=0,g2%=0,b2%=0,a#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),0,radius1*Sin(a1),0,0)
		v1=AddVertex(surf,radius1*Cos(a2),0,radius1*Sin(a2),0,0)
		v2=AddVertex(surf,radius2*Cos(a3),0,radius2*Sin(a3),1,1)
		v3=AddVertex(surf,radius2*Cos(a4),0,radius2*Sin(a4),1,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,1
		VertexColor surf,v1,r1,g1,b1,1
		VertexColor surf,v2,r2,g2,b2,a
		VertexColor surf,v3,r2,g2,b2,a
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	
	Return mesh
	
End Function</textarea><br><br>Any suggestions? <br><br></td></tr></table><br>
<a name="916808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pongo</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think what you have is pretty good to start with.<br><br>The thing that is screwing you up is the perspective of the sphere when you get close. If you change your camerazoom to a higher value (I used 4) things work a lot better. <br><br></td></tr></table><br>
<a name="916854"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Blackledge</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's not bad - simple and practical. <br><br></td></tr></table><br>
<a name="916883"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think this is doable. You basically want to position the ring on the horizon of the sphere/planet. Google 'calculating distance to horizon' to get started. <br><br></td></tr></table><br>
<a name="916916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I think this is doable. You basically want to position the ring on the horizon of the sphere/planet. Google 'calculating distance to horizon' to get started<br> <br></div><br>Wouldn't that get complicated and involve a re-scaling of the ring then? <br>As the horizon shrinks at higher 'latitudes' ('latitude' here is assuming an invariance where any point on the sphere's surface can be considered a pole)<br><br>Once you get close enough for the 'distortioon' to set in, might be niece to just switch to a sprite overlay instead. ?<br><br>I think it's acvtually a lot more complicated than it first appears... <br><br></td></tr></table><br>
<a name="916917"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, it will require re-scaling the ring, but I dont see that as a problem. <br><br></td></tr></table><br>
<a name="916922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hehe well I had problems trying to work it..<br> <br>I am in agreement wit the cameraoom comment though, because the fisheye distortion plays havoc with objects up close which I don't think is easily reslveable. <br><br></td></tr></table><br>
<a name="916934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I am in agreement wit the cameraoom comment though, because the fisheye distortion plays havoc with objects up close which I don't think is easily reslveable. <br></div>You could always re-size the ring slightly smaller than the calculations say, to get over the perspective problem, I think. <br><br></td></tr></table><br>
<a name="916938"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pongo</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's not only the perspective that is causing the problem.<br><br>The glow is using a look at constraint to the camera. When the camera gets really close and is not looking at the center of the glow, then the glow will actually tip away from the camera view. (I don't know if I explained this very good)<br><br>Anyways, the larger camerazoom also helps this because the camera stays farther away from the glow, so you do not get this effect as bad. <br><br></td></tr></table><br>
<a name="916947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I started a quick'n'dirty test to check out if it is really possible, and it IS - but with my solution not in realtime. Here is my testbed (with a improved Createring function, there was an error in the UV coordinates and we don't need to turn it 90° all the time anymore):<br><br>1. the dummy pivot always points to cam<br>2. do a linepick from cam to spherecenter<br>3. check if it hits the planet or the dummy<br>4. if it hits the planet move the dummy a little bit to the cam<br>5. if it hits the dummy move the dummy a little bit from the cam away<br>6. the ring scale is (the distance between dummy and sphere) / 2<br>7. scale the ring and point it to the cam<br><br>The process is due accuracy very slow so be patient if you get too far away from the planet (this is a testbed for a close orbit). You can speed this up by changing the 0.001 value to 0.01 or 0.1, which will result in precision lost.<br><br>big10p: I don't get the "calculate distance to horizon" function to work. To be precise: I can calc the distance between the cam and the horizon, but how shall I calculate the actual scale of the ring out of it? Can you post a small BB-Example?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 1024,768,32,2

; Variables
mousespeed#=0.1
cameraspeed#=0.1
camerasmoothness#=10
scale#=2.0

timer=CreateTimer(60)

; Camera
cam=CreateCamera()
PositionEntity cam,0,0,-scale*1.1
CameraRange cam,0.1,1000

; Planet
ppiv=CreatePivot()
PointEntity ppiv,cam
planet=CreateSphere(60)
ScaleEntity planet,scale,scale,scale
EntityPickMode planet,1
EntityRadius planet,scale
NameEntity planet,"Planet"
EntityColor planet,0,255,0

; Dummy
dummy=CreateSphere(8,ppiv)
PositionEntity dummy,scale*2.5,0,0
EntityPickMode dummy,1
EntityRadius dummy,0.1
ScaleEntity dummy,0.1*scale,0.1*scale,0.1*scale
NameEntity dummy,"Dummy"

ring=CreateRing(1*scale,1.1*scale,120,1+2+32,3,192,224,255,64,128,255,0,scale)

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

PointEntity cam,dummy


While Not KeyHit(1)
	
	cx#=EntityX(cam)
	cy#=EntityY(cam)
	cz#=EntityZ(cam)
	
	dx#=EntityX(dummy,1)
	dy#=EntityY(dummy,1)
	dz#=EntityZ(dummy,1)
	
	entity=LinePick(cx,cy,cz,dx-cx,dy-cy,dz-cz,0.001)
	If entity=planet Then MoveEntity dummy,0.001,0,0
	If entity=dummy Then MoveEntity dummy,-0.001,0,0
	
	diff#=EntityDistance(ppiv,dummy)/scale
	
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; Mousecam
	mx#=CurveValue(MouseXSpeed()*mousespeed,mx,camerasmoothness)
	my#=CurveValue(MouseYSpeed()*mousespeed,my,camerasmoothness)
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	pitch#=EntityPitch(cam)
	yaw#=EntityYaw(cam)
	pitch=pitch+my
	yaw=yaw-mx
	If pitch&gt;89 Then pitch=89
	If pitch&lt;-89 Then pitch=-89
	RotateEntity cam,0,yaw,0
	TurnEntity cam,pitch,0,0
	
	; Movement
	cx#=(KeyDown(205)-KeyDown(203))*cameraspeed
	cz#=(KeyDown(200)-KeyDown(208))*cameraspeed
	MoveEntity cam,cx,0,cz
	
	PointEntity ppiv,cam
	PointEntity ring,cam
	
	ScaleEntity ring,diff,diff,diff
	
	RenderWorld
	
	WaitTimer timer
	
	Flip 0
	
Wend

End

; Smoothcam
Function CurveValue#(newvalue#,oldvalue#,increments )
	If increments&gt;1 oldvalue#=oldvalue#-(oldvalue#-newvalue#)/increments
		If increments&lt;=1 oldvalue=newvalue
			Return oldvalue#
End Function

; Ring
Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,r2%=0,g2%=0,b2%=0,a#=1.0,scale#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0.01*scale,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0.01*scale,0,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,1
		VertexColor surf,v1,r1,g1,b1,1
		VertexColor surf,v2,r2,g2,b2,a
		VertexColor surf,v3,r2,g2,b2,a
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend

	
	Return mesh
	
End Function</textarea><br><br>Edit: it could look like this image if it is working:<br><img src="http://www.christianhart.de/bb/planet/planet004.jpg"> <br><br></td></tr></table><br>
<a name="916958"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> big10p: I don't get the "calculate distance to horizon" function to work. To be precise: I can calc the distance between the cam and the horizon, but how shall I calculate the actual scale of the ring out of it? Can you post a small BB-Example? <br></div>Erm, I'd have to have a think about that, TBH. I just figured the 'distance to horizon' calc was along the right lines.<br><br>Actually, looking at that screenie, I'm thinking using a separate sphere for the atmosphere may be a better way to go. That pic doesn't look quite right - kinda looks like theres a light behind the planet. <br><br></td></tr></table><br>
<a name="916959"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; That pic doesn't look quite right - kinda looks like theres a light behind the planet. <br><br>I know. But that is priority 5 at the moment. Its only the testbed with textures and stars. <br><br></td></tr></table><br>
<a name="916964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think that you should loop through each vertex of the planet, and project it. Then, determine min/max x/y/z values. If the ring was a 2D object, that would be enough. However, because the ring is 3D, you'll need to find a way to project the 2D coords back into the 3D world. CameraPick on a plane should usually work, but I had trouble getting it to work with this.<br>Anyway, here is code that projects the 2D size of the planet onto the screen:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 1024,768,32,2

; Variables
mousespeed#=0.1
cameraspeed#=0.05
camerasmoothness#=10
scale#=1.0

; Camera
cam=CreateCamera()
PositionEntity cam,0,0,-5
CameraRange cam,0.1,100

; Planet
planet=CreateSphere(32)
ScaleEntity planet,scale,scale,scale
EntityColor planet,0,255,0
EntityFX planet,1

; Glow
ring=CreateRing(1*scale,1.5*scale,30,1,255,255,255,32,32,32,0)
EntityFX ring,1+2+32

; Timer
timer=CreateTimer(60)

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

While Not KeyHit(1)
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; Mousecam
	mx#=CurveValue(MouseXSpeed()*mousespeed,mx,camerasmoothness)
	my#=CurveValue(MouseYSpeed()*mousespeed,my,camerasmoothness)
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	pitch#=EntityPitch(cam)
	yaw#=EntityYaw(cam)
	pitch=pitch+my
	yaw=yaw-mx
	If pitch&gt;89 Then pitch=89
	If pitch&lt;-89 Then pitch=-89
	RotateEntity cam,0,yaw,0
	TurnEntity cam,pitch,0,0
	
	; Movement
	cx#=(KeyDown(205)-KeyDown(203))*cameraspeed
	cz#=(KeyDown(200)-KeyDown(208))*cameraspeed
	MoveEntity cam,cx,0,cz

	RenderWorld
	
	; Ring points always to camera
	ScaleRing(cam, planet)
	PointEntity ring,cam
	TurnEntity ring,-90,0,0
			
	WaitTimer timer
		
	Flip
	
Wend

End

; Smoothcam
Function CurveValue#(newvalue#,oldvalue#,increments )
	If increments&gt;1 oldvalue#=oldvalue#-(oldvalue#-newvalue#)/increments
		If increments&lt;=1 oldvalue=newvalue
			Return oldvalue#
End Function

; Create Single Surface Ring
Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,r1%=255,g1%=255,b1%=255,r2%=0,g2%=0,b2%=0,a#=1.0)

	Local a1#,a2#,a3#,a4#,angle%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),0,radius1*Sin(a1),0,0)
		v1=AddVertex(surf,radius1*Cos(a2),0,radius1*Sin(a2),0,0)
		v2=AddVertex(surf,radius2*Cos(a3),0,radius2*Sin(a3),1,1)
		v3=AddVertex(surf,radius2*Cos(a4),0,radius2*Sin(a4),1,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,1
		VertexColor surf,v1,r1,g1,b1,1
		VertexColor surf,v2,r2,g2,b2,a
		VertexColor surf,v3,r2,g2,b2,a
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	;If fx&gt;0 Then EntityFX mesh,fx
	
	Return mesh
	
End Function


Function ScaleRing(cam, planet)
	
	;get size of rendered planet
	surf = GetSurface(planet, 1)
	minx# =  10000
	maxx# =  -10000
	miny# =  10000
	maxy# =  -10000
	For i = 1 To CountVertices(surf) - 1
		TFormPoint VertexX(surf, i), VertexY(surf, i), VertexZ(surf, i), planet, 0
		CameraProject cam, TFormedX(), TFormedY(), TFormedZ()
		If ProjectedX() &lt; minx# Then minx# = ProjectedX()
		If ProjectedX() &gt; maxx# Then maxx# = ProjectedX()
		If ProjectedY() &lt; miny# Then miny# = ProjectedY()
		If ProjectedY() &gt; maxy# Then maxy# = ProjectedY()
	Next

	Rect minx, miny, maxx-minx, maxy-miny, 0
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="917086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woo-hoo! Finally I found the exact mathematical solution (with some help <a href="http://www.arndt-bruenner.de/mathe/scripts/dreiecksberechnungrw.htm" target="_blank">from this homepage</a> - it is in german but you don't need to understand german to understand the solution :-)<br><br>We only need two right-angled triangles and some trigonometry knowledge to solve it. The ring scale is identical with the c2 hypotenuse we need to calc. I named the variables like they would appear in the two triangles. And we only need to know the scale (Radius of the planet) and the distance between the camera and the planet, it is very simple if you understand how ;-)<br><br>Here is a simple sketch of the two triangles, the red dot at the top is the cam, the red line at the left the distance, the black line the radius and the violet line at the bottom is the c2 hypotenuse we are looking for:<br><img src="http://www.christianhart.de/bb/planet/triangles.png"><br><br><b>radius#=scale<br>distance#=EntityDistance(cam,planet)<br><br>; First triangle<br>c1#=distance<br>a1#=radius<br>q1#=a1^2/c1<br>p1#=c1-q1<br>h1#=Sqr(p1*q1)<br>gamma1#=90<br>alpha1#=ATan(h1/p1)<br>beta1#=gamma1-alpha1<br>	<br>; Second Triangle<br>alpha2# = 90-(90-beta1)<br>b2# = a1/Tan(alpha2)<br>c2# = (Sqr(a1^2 + b2^2))/radius<br>	<br>ScaleEntity ring,c2,c2,c2</b><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 1024,768,32,2

; Variables
mousespeed#=0.1
cameraspeed#=0.01
camerasmoothness#=10
scale#=1.0

timer=CreateTimer(60)

; Camera
cam=CreateCamera()
PositionEntity cam,0,0,-scale*2
CameraRange cam,0.01,1000

; Planet
planet=CreateSphere(60)
ScaleEntity planet,scale,scale,scale
EntityColor planet,0,255,0

ring=CreateRing(1*scale,1.5*scale,120,1+2+32,3,192,224,255,64,128,255,0,scale)

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2


While Not KeyHit(1)
	
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; Mousecam
	mx#=CurveValue(MouseXSpeed()*mousespeed,mx,camerasmoothness)
	my#=CurveValue(MouseYSpeed()*mousespeed,my,camerasmoothness)
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	pitch#=EntityPitch(cam)
	yaw#=EntityYaw(cam)
	pitch=pitch+my
	yaw=yaw-mx
	If pitch&gt;89 Then pitch=89
	If pitch&lt;-89 Then pitch=-89
	RotateEntity cam,0,yaw,0
	TurnEntity cam,pitch,0,0
	
	; Movement
	cx#=(KeyDown(205)-KeyDown(203))*cameraspeed
	cz#=(KeyDown(200)-KeyDown(208))*cameraspeed
	MoveEntity cam,cx,0,cz
	
	PointEntity ring,cam
	
	radius#=scale
	distance#=EntityDistance(cam,planet)
	
	; First triangle
	c1#=distance
	a1#=radius
	q1#=a1^2/c1
	p1#=c1-q1
	h1#=Sqr(p1*q1)
	gamma1#=90
	alpha1#=ATan(h1/p1)
	beta1#=gamma1-alpha1
	
	; Second Triangle
	alpha2# = 90-(90-beta1)
	b2# = a1/Tan(alpha2)
	c2# = (Sqr(a1^2 + b2^2))/radius
	
	ScaleEntity ring,c2,c2,c2
	
	RenderWorld
	
	WaitTimer timer
	
	Flip 0
	
Wend

End

; Smoothcam
Function CurveValue#(newvalue#,oldvalue#,increments )
	If increments&gt;1 oldvalue#=oldvalue#-(oldvalue#-newvalue#)/increments
		If increments&lt;=1 oldvalue=newvalue
			Return oldvalue#
End Function

; Ring
Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,r2%=0,g2%=0,b2%=0,a#=1.0,scale#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,1
		VertexColor surf,v1,r1,g1,b1,1
		VertexColor surf,v2,r2,g2,b2,a
		VertexColor surf,v3,r2,g2,b2,a
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	
	Return mesh
	
End Function</textarea> <br><br></td></tr></table><br>
<a name="917149"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warner</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Perfect! Nice work. <br><br></td></tr></table><br>
<a name="917522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>The glow is using a look at constraint to the camera. When the camera gets really close and is not looking at the center of the glow, then the glow will actually tip away from the camera view. (I don't know if I explained this very good)<br> <br></div><br><br>Yeah I did erealise this tioo, just didn't mention it. The same problem occurs when you get within CameraNear Range etc. and objects seem to 'flip' over or around.<br><br>Still nice to see a solution works there. I gave up way too early because trig gives me a headache (why do I punish myself tryiong to work in 3D &gt;? :D :D :D)<br><br><br><div class="quote"> <br> I'm thinking using a separate sphere for the atmosphere may be a better way to go<br><br>That pic doesn't look quite right - kinda looks like theres a light behind the planet.<br> <br></div><br>I'm sure just alpha-ing it down a little (if that makes sense) will be fine.<br>Using a whole sphere is gonna be a lot more intensive than a smaller bunch of tri's at least. <br><br></td></tr></table><br>
<a name="917550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am not sure If I understood this correct, but after my post I had the problem that when I got closer to the planet the glow "shrinked" instead of expanding like an atmosphere would do. I solved the problem by using some kind of "flipped" ring and bending the outer vertices towards and away from the cam that a "glow cone" exists. Now I can even "land" on the planet and see the stars shining through my atmosphere without changing anything, just rescaling the ring!<br><br>Sorry, I have no time for a small demo (perhaps later) but here is the function call and the main function parts (scale is here 1.0, 10.0... must match the planet size):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Function call
glow1=CreateRing(1*scale,0.5*scale,60,1+2+32,1,224,240,255,0.5, 64,128,255,0.0,scale*1)
glow2=CreateRing(0.8*scale,0.1*scale,60,1+2+32,1,255,255,255,1.0,  0,128,255,0.0,scale*1)
EntityOrder glow1,10
EntityOrder glow2,10

; put this in the main loop
radius#=scale
distance#=EntityDistance(cam,planet)
c1#=distance
a1#=scale
q1#=a1^2/c1
p1#=c1-q1
h1#=Sqr(p1*q1)
gamma1#=90
alpha1#=ATan(h1/p1)
beta1#=gamma1-alpha1
alpha2# = 90-(90-beta1)
b2# = a1/Tan(alpha2)
c2# = (Sqr(a1^2 + b2^2))/radius
PointEntity glow1,cam
PointEntity glow2,cam
ScaleEntity glow1,c2,c2,c2
ScaleEntity glow2,c2,c2,c2

; The functions that creates the ring
Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,alpha1#=1.0,r2%=0,g2%=0,b2%=0,alpha2#=1.0,scale#=0.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	Local v0%,v1%,v2%,v3%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),scale,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),scale,1,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,alpha1
		VertexColor surf,v1,r1,g1,b1,alpha1
		VertexColor surf,v2,r2,g2,b2,alpha2
		VertexColor surf,v3,r2,g2,b2,alpha2
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	Return mesh
	
End Function</textarea><br><br>As you can see, the ring starts now at the size of the planet and moves inwards, I don't know how to explain. Just stop the glow rings pointing to the cam, set FX 16 and move around the planet and you will see what happens. And here three eye-candy shots using this technique (still room for improvement, e.g. fading the stars and matching the Cameraclscolor while inside the atmosphere):<br><br>Nice view from a geostationary orbit - lets land at the far left side<br><img src="http://www.christianhart.de/bb/planet/planet005.jpg"><br><br>Entering the atmosphere<br><img src="http://www.christianhart.de/bb/planet/planet006.jpg"><br><br>We reached the cruising altitude<br><img src="http://www.christianhart.de/bb/planet/planet007.jpg"><br><br>Oh and yes I know - planets don't glow at the dark side. If anybody has a nice solution how to setup the ring normals according to the light angle - POST IT! <br><br></td></tr></table><br>
<a name="917556"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >stayne</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work Krischan and cheers for the math lesson (with diagram even!).  I have enjoyed this thread :). <br><br></td></tr></table><br>
<a name="917696"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Blackledge</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> When can we see a demo of this? <br><br></td></tr></table><br>
<a name="917743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well here is a little tech demo, I added some basic light functionality, not finished yet - but this is a good point to start from. Just copy'n'paste - it doesn't need any media but uses the same technique which I used to make the screenshots above. Additional, I tried to measure the angles between the cam, the planet and the sun. The variable <b>alpha#</b> holds a value from 0.0 to 1.0 where 1.0 is in a direct line between sun and the planet and 0.0 is behind the planet to check if the ring glow has full or some alpha.<br><br>To enjoy the effect just try to land at the far right side of the planet (the sunny side) and when you're close to the surface press the right arrow key to start in a 90° angle from the surface into space.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 1024,768,32,2

; Variables
mousespeed#=0.1
camerasmoothness#=10
scale#=10.0
cameraspeed#=scale/10.0

timer=CreateTimer(60)

; Camera
cam=CreateCamera()
PositionEntity cam,-scale*3,0,scale*2
CameraRange cam,0.01,1000

; Planet
planet=CreateSphere(60)
ScaleEntity planet,scale,scale,scale
EntityColor planet,64,128,255

; Directional Sunlight
light=CreateLight(1)
PositionEntity light,0,0,-scale*10
LightRange light,10*scale
AmbientLight 32,32,32

; Sunsprite
sun=CreateSprite()
ScaleSprite sun,scale,scale
EntityFX sun,1+16
EntityColor sun,255,255,0
EntityParent sun,light
PositionEntity sun,0,0,0
EntityBlend sun,3

; Glow
glow1=CreateRing(1.0*scale,0.5*scale,120,2+16+32,1,224,240,255,0.5, 64,128,255,0.0,scale*1)
glow2=CreateRing(0.8*scale,0.1*scale,120,2+16+32,1,255,255,255,1.0,  0,128,255,0.0,scale*1)

; Hide glow behind the planet
EntityOrder glow1,10
EntityOrder glow2,10

; Cam points to planet first
PointEntity cam,planet

; Center mouse
MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

While Not KeyHit(1)
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf : WireFrame wf
	
	; Mousecam
	mx#=CurveValue(MouseXSpeed()*mousespeed,mx,camerasmoothness)
	my#=CurveValue(MouseYSpeed()*mousespeed,my,camerasmoothness)
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	pitch#=EntityPitch(cam)
	yaw#=EntityYaw(cam)
	pitch=pitch+my
	yaw=yaw-mx
	If pitch&gt;89 Then pitch=89
	If pitch&lt;-89 Then pitch=-89
	RotateEntity cam,0,yaw,0
	TurnEntity cam,pitch,0,0
	
	; Calculate ring scale
	radius#=scale
	distance#=EntityDistance(cam,planet)
	c1#=distance
	a1#=scale
	q1#=a1^2/c1
	p1#=c1-q1
	h1#=Sqr(p1*q1)
	gamma1#=90
	alpha1#=ATan(h1/p1)
	beta1#=gamma1-alpha1
	alpha2# = 90-(90-beta1)
	b2# = a1/Tan(alpha2)
	c2# = (Sqr(a1^2 + b2^2))/radius
	
	; Calculcate the sun light angle (1 = between sun and planet, 0 = behind the planet)
	aa#=EntityDistance(cam,planet)
	bb#=EntityDistance(planet,light)
	cc#=EntityDistance(cam,light)
	alpha#=ACos((aa^2+cc^2-bb^2)/(2*aa*cc))/180.0
	If alpha&lt;0 Or alpha&gt;1 Then alpha=1
	If alpha&lt;0.25 Then alpha=0.25
	
	; Glow always points to cam
	PointEntity glow1,cam
	PointEntity glow2,cam
	
	; Scale the rings
	ScaleEntity glow1,c2,c2,c2
	ScaleEntity glow2,c2,c2,c2
	
	; Update the rings
	UpdateRing(glow1,1*scale,0.5*scale,120,224,240,255,0.5*alpha,64,128,255,0.0,scale*1) : UpdateNormals glow1 : FlipMesh glow1
	UpdateRing(glow2,0.8*scale,0.1*scale,120,255,255,255,1.0*alpha,0,128,255,0.0,scale*1) : UpdateNormals glow2 : FlipMesh glow2
	
	; Movement with speed limit closer to the planet surface
	cx#=(KeyDown(205)-KeyDown(203))*cameraspeed
	cz#=(KeyDown(200)-KeyDown(208))*cameraspeed
	moz#=cz*1.0/(c2)^3
	mox#=cx*1.0/(c2)^3
	MoveEntity cam,mox,0,moz
	
	; simple background color change in atmosphere
	bg#=1-(1.0/c2)
	If bg&lt;0 Then bg=0
	If bg&gt;1 Then bg=1
	CameraClsColor cam,160*bg,192*bg,255*bg
	
	RenderWorld
	
	WaitTimer timer
	
	Flip 0
	
Wend

End

; Smoothcam
Function CurveValue#(newvalue#,oldvalue#,increments )
	If increments&gt;1 oldvalue#=oldvalue#-(oldvalue#-newvalue#)/increments
		If increments&lt;=1 oldvalue=newvalue
			Return oldvalue#
End Function

; The functions that creates the ring
Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,alpha1#=1.0,r2%=0,g2%=0,b2%=0,alpha2#=1.0,scale#=0.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	Local v0%,v1%,v2%,v3%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),scale,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),scale,1,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,alpha1
		VertexColor surf,v1,r1,g1,b1,alpha1
		VertexColor surf,v2,r2,g2,b2,alpha2
		VertexColor surf,v3,r2,g2,b2,alpha2
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	Return mesh
	
End Function

; Re-creates the ring vertices and triangles with different values
Function UpdateRing(mesh%,radius1#=1.0,radius2#=2.0,segments%=360,r1%=255,g1%=255,b1%=255,alpha1#=1.0,r2%=0,g2%=0,b2%=0,alpha2#=1.0,scale#=0.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	Local v0%,v1%,v2%,v3%
	
	Local surf=GetSurface(mesh,1)
	ClearSurface surf,1,1
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),scale,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),scale,1,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,alpha1
		VertexColor surf,v1,r1,g1,b1,alpha1
		VertexColor surf,v2,r2,g2,b2,alpha2
		VertexColor surf,v3,r2,g2,b2,alpha2
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	Return mesh
	
End Function</textarea> <br><br></td></tr></table><br>
<a name="917827"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Beautiful. Great work, Krischan! Very impressive.<br><br>Of course what you have shown is purely a demo, and maybe you have considered this already, but I was wondering if it's worth using HideEntity when the 'atmosphere' is not visible? I guess this really depends on how many planets and what other stuff is going on at the time, either way, I really like what you have done here! <br><br></td></tr></table><br>
<a name="917856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is only a tech demo. Do whatever you want with it, improve it and let us share if you think it is usable for others. I was only disappointed that I didn't found a nice and elegant solution for my atmosphere problem - so i coded my own. My solution is not the best or even physically correct, but my planet looks much nicer now and if I ever consider to implement some kind of "landing on the planet" feature this is the way I can go now.<br><br>I really enjoyed the game <b><a href="http://en.wikipedia.org/wiki/Starflight" target="_blank">Starflight</a></b> years ago where you could land on a planet and drive around to collect things from the surface. The GFX is a big laugher today but the gameplay and the imagination balanced everything. Later - <b><a href="http://en.wikipedia.org/wiki/Frontier%3a_Elite_II" target="_blank">Frontier</a></b> was THE procedural game (until today?) but it was boring and too exact. <b><a href="http://www.infinity-universe.com/" target="_blank">Infinity</a></b> looks very promising and i hope that it won't be a blown up Frontier without a challenging gameplay (if we'll ever see it).<br><br>It has to make fun, fun and fun again. Who cares about lit nightsides? We had a lot of fun with 64K/16 color games only a few years ago, and often even more fun than in some games today.<br><br>And if you never played Starflight go and get an Amiga Emulator, the ADF and play it. You really missed something -&gt; <b><a href="http://www.lemonamiga.com/?mainurl=http%3A//www.lemonamiga.com/games/details.php%3Fid%3D1635" target="_blank">Screenshots</a></b> <br><br></td></tr></table><br>
<a name="917951"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm old enough (and ugly enough) to fondly remember Elite. Yeah, Frontier was a nice change moving from the speccy to the Amiga and getting all those colours, but just... too much overkill on the physics ;)<br><br>I don't recall Starflight, though, but I'm sure it was grand!<br><br>I was working on something similar to Elite with beng able to land on planets and including various land-based 'factories' etc. but as my coding improved I have scrapped a lot of previous attempts, and am now concentrating more on planning other aspects before I hit it again. However, I'm sure stuff like this will be a great addition. It's an open-source plan, so hopefully I'll have some useful routines in return especially seeing as the two projects appear to have some similarities. <br><br></td></tr></table><br>
<a name="1068795"></a>

<a name="1068800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Filax</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi<br><br>The same with a type class <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type tPlanet
	
	Field x#
	Field y#
	Field z#
	
	Field scale#
	
	Field entity%
	Field glow%
	
End Type


Function CreatePlanet(x#,y#,z#,scale#)
	
	Local p.tPlanet=New tPlanet
	
	p\x#=x#
	p\y#=y#
	p\z#=z#
	
	p\scale#=scale#
	
	p\entity%=LoadMesh("World.b3d")
	ScaleEntity p\entity%,p\scale#,p\scale#,p\scale#
	PositionEntity p\entity%,p\x#,p\y#,p\z#
	
	p\glow%=CreateRing(1*p\scale#,1.1*p\scale#,120,1+2+32,3,192,224,255,64,128,255,0,p\scale#)
		
	PositionEntity p\glow%,p\x#,p\y#,p\z#
	
End Function

Function RefreshPlanet(cam%)
	
	Local q1#,p1#,b2#,c2#
	Local alpha#,beta#
	
	For p.tPlanet=Each tPlanet
		
		distance#=EntityDistance(cam%,p\entity%)
		
		q1#=p\scale#^2/distance#
		p1#=distance#-q1
		
		alpha#=ATan(Sqr(p1#*q1#)/p1#)
		beta#=90-alpha#
		
		b2# = p\scale#/Tan(90-(90-beta#))
		c2# = (Sqr(p\scale#^2 + b2#^2))/p\scale#
		
		ScaleEntity p\glow%,c2#,c2#,c2#
		PointEntity p\glow%,cam%
		
	Next
	
End Function

Function CreateRing(radius1#=1.0,radius2#=2.0,segments%=360,fx%=0,blend%=0,r1%=255,g1%=255,b1%=255,r2%=0,g2%=0,b2%=0,a#=1.0,scale#=1.0)
	
	Local a1#,a2#,a3#,a4#,angle%
	
	Local mesh=CreateMesh()
	Local surf=CreateSurface(mesh)
	
	; Limit segments
	If segments&gt;360 Then segments=360
	
	; Create ring
	For angle=1 To segments
		
		a1=angle*360.0/segments
		a2=angle*360.0/segments +360.0/segments
		a3=angle*360.0/segments +180.0/segments
		a4=angle*360.0/segments -180.0/segments
		
		; Calc vertex points
		v0=AddVertex(surf,radius1*Cos(a1),radius1*Sin(a1),0,0,0)
		v1=AddVertex(surf,radius1*Cos(a2),radius1*Sin(a2),0,0,0)
		v2=AddVertex(surf,radius2*Cos(a3),radius2*Sin(a3),0,1,1)
		v3=AddVertex(surf,radius2*Cos(a4),radius2*Sin(a4),0,0,1)
		
		; Color
		VertexColor surf,v0,r1,g1,b1,1
		VertexColor surf,v1,r1,g1,b1,1
		VertexColor surf,v2,r2,g2,b2,a
		VertexColor surf,v3,r2,g2,b2,a
		
		; Create Triangles
		AddTriangle surf,v2,v1,v0
		AddTriangle surf,v0,v3,v2
		
	Next
	
	If fx&gt;0 Then EntityFX mesh,fx
	If blend&gt;0 Then EntityBlend mesh,blend
	
	Return mesh
	
End Function
</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
