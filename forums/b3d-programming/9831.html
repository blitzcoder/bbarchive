<!DOCTYPE html><html lang="en" ><head ><title >Shadows</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Shadows</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Shadows</a><br><br>
<a name="98905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> How do I do them in Blitz... I'm hoping to have both Lo-Detail and Hi-Detail shadows in there.<br><br>Lo-D will be the &quot;circle on the ground&quot;. Hi-D will be proper shadows. How would I go about doing both of these? <br><br>The Lo-D I understand would just follow the model, but how would I create the shadow? The Hi-D version will have to change as the anim frames change. I don't want it all to be hard-coded (that would be poor coding technique), but I want them to dynamically change.<br><br>So how would I go about creating both the aforementioned Lo-D and Hi-D shadows? <br><br></td></tr></table><br>
<a name="98908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://www.blitzbasic.co.nz/cgi-bin/codearc.pl?opt=4&amp;code=214" target="_blank">Here's</a> my shadow code. It is a &quot;towel&quot; that means it can handle any sort of level and floor surface.<br><br>If you want Hi-D you will need to render a small view of the character onto a texture with a really dark entitycolor, or blend mode, then texture the result each frame (or every second frame) onto the towel.<br><br>So in this manner you've both shadow techniques. A lot of code needs to change to make it effective. <br><br></td></tr></table><br>
<a name="98921"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excuse me Rob, but I don't quite get this. I'm a bit of a nwebie to programming and Blitz and everything else, and don't really know what is going on in your example.<br><br>Could you maybe comment it a bit better, like tell why you've done something, and what it does? <br><br></td></tr></table><br>
<a name="98925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sure... here's what it does.<br><br>1. Make a towel. This is a quad mesh. That is, a mesh that has rows and columns. David Bird's code was used for this in the CreateQuad function. It's given these rows and columns so that it may deform effectively.<br><br>2. Imagine a towel? you can throw it over anything and it should lie on the surface flat pretty well. This is how the shadow routines work.<br><br>We position the flat mesh high above where it is due to land, then throw it onto the floor by using a linepick at each vertex. Then we use PickedY() to get the height of the floor where that vert will go.<br><br>3. And thats it. Basically, the idea is to deform a detailed square blanket, or towel so it fits on any floor. And repeat this procedure every loop.<br><br>There are other ways of doing it I suppose... <br><br></td></tr></table><br>
<a name="98963"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> huh ! arf! I'm gonna try it gain...<br><br>I've tried about 3 kind of these things, and no one worked....even FLEX yeah, I'v tried it with no success in DDK :(<br><br>It was slowing it at about 2 FPS...<br><br>Is maybe that with big levels, I have to sort, and use only the piece of level (child) on which the character is walking ?<br><br>Then I tried something like what you are explaining here, with an helicopter on a terrain, and it worked pretty well (some clipping problem with terrain dynamic LOD) though.<br><br><br>I really need one who works on .3ds based levels. <br><br></td></tr></table><br>
<a name="98966"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's what I need.<br><br>All my levels are BSP-style indoor levels in 3DS files. <br><br></td></tr></table><br>
<a name="98969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> My flex code works on 3ds levels. You guys just need to learn how to code :) after all it's just a small mesh that deforms. Tiny code.<br><br>Best bet will be if Mark ever codes shadow volumes... :) <br><br></td></tr></table><br>
<a name="98994"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DougUK</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> &quot;My flex code works on 3ds levels. You guys just need to learn how to code :)&quot;<br><br>man thats a little harsh lol  <br><br></td></tr></table><br>
<a name="98999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> lol... I know :) People can call me names if it makes them feel better! <br><br></td></tr></table><br>
<a name="99000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DougUK</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> hehe, flura'sdj'jffjjfja, that feels better :) <br><br></td></tr></table><br>
<a name="99002"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't care. Harsh comments or not, I'm here to learn. And I'm gonna put shadows in my game even if it drives me to the brink of death! <br><br>After all, you stop learning only when you're dead... <br><br></td></tr></table><br>
<a name="99005"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DougUK</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wish i could help BlackHawk but i dont know either, ignore Rob, he dosn't know either, he's just like us hoping someone will have the answer :) <br><br></td></tr></table><br>
<a name="99030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> &gt;&gt;I don't care. Harsh comments or not, I'm here to learn. And I'm gonna put shadows in my game even if it drives me to the brink of death! <br><br>After all, you stop learning only when you're dead...&lt;&lt; <br></div><br><br>THat's THe SpiriT!<br><br><div class="quote"> &gt;&gt;I wish i could help BlackHawk but i dont know either, ignore Rob, he dosn't know either, he's just like us hoping someone will have the answer :)&lt;&lt; <br></div><br><br>LoL !<br><br>I guess is that one I gave bymself, because if I ask the pretty mesh to deform on the basis of my level.3ds it goes mad, and run at 2 fps.<br><br>Fine in a simple room.<br><br>I'm now trying the NORC shadows routine, via lightmapping, but the part where I walk on, get all black, so wrong UV for the second layer I guess...anybody ? <br><br></td></tr></table><br>
<a name="99037"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tracer</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob,<br><br>FLEX is pretty cool, but the main problem is that the shadow 'floats' .. it's not ON the mesh, it's ABOVE it.<br><br>Also, on large levels, the entitypicking slows things down a LOT.<br><br>We will not be able to do good shadowing until we get access to stencil buffers.<br><br>Tracer <br><br></td></tr></table><br>
<a name="99061"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I'm now trying the NORC shadows routine, via lightmapping, but the part where I walk on, get all black, so wrong UV for the second layer I guess...anybody ? <br></div><br><br>I reckon I'm gonna work on Hi-D shadows first, since that's the one I'm presuming will be hardest and most time consuming.<br><br>I downloaded Norc's demo too (the one with the speed hack by Peter Scheutz), from the Code Archives. The only problem with that is that it's not at all newbie-friendly! The code is not commented at all well for newbies like myself. I don't know what does what, so I don't know how to adapt it to my own program!! Aargh.<br><br>As a general point (to anyone, but especially to people who want to make examples for others to follow), I'd like the code examples I get to be commented with why and how you did something, so that it is easier for newbies to follow, as well as easy to adapt, as you will then know what bits are useful to you and what they do. <br><br></td></tr></table><br>
<a name="99063"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Neochrome</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did it!!!<br><br>looks funny, but i still did it!! <br><br></td></tr></table><br>
<a name="99067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> neo, the tags are &quot;[img]&quot; and &quot;[/img]&quot;. No &quot;[url]&quot; is needed. The tag should be &quot;[img=&lt;image url goes here&gt;]&quot;. The Image URL should *not* be in quotes, either. <br><br></td></tr></table><br>
<a name="99083"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://www.neomancer.co.uk/ccam.jpg"><br><br>So thats what he's up to... <br><br></td></tr></table><br>
<a name="99084"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Neochrome</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> [img=http://www.neomancer.co.uk/images/boogerman.jpg[/img]<br>this works? <br><br></td></tr></table><br>
<a name="99122"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> This code will project shadows straight down.  <br><br>It was designed for circular shadows.  However, since you can use any texture you want you can generate a new texture each frame.  So write a little code that makes an appropriate shadow texture from the specified mesh and voila, nice shadows which actually represent the shapes of stuff.<br><br>The shadows will wrap around the speficied reciver mesh.  The caster is the object which determines the location of the shadow in space.<br><br>The shadows will taper off in brightness as the angle of the surface they are relative to gets steeper, so shadows will never be seen on perfectly vertical walls.<br><br>It shouldn't be too hard to change the code to allow the shadows to be projected in any direction.   What would be required is finding out where the vertcies of the model are in space after being rotated in such a way that their location relative to the shadow is below it.  Well that's not a great explanation... basically you need to rotate the world so that the line of sight of the &quot;light&quot; casting the shadow points downward.  That way you can use the cheap equations to find what polygons are inside the shadow volume.<br><br>Oh, and right now the code is set up so that the object shadows ar ebeing cast onto can't be rotated in any way, and it must be at 0,0,0 so the locations of the vertices within it are correct relative to the shadow.  But fixing that is also trivial.  At least the movement bit.  The rotation is a little more costly to fix.  Basicically this is good for casting shadows onto levels.<br><br>Oh and if you want to use this in a commercial game, send $10 via paypal, to sswift@....  I need the money.  You can use it in shareware for free.<br><br><pre class=code>
; -------------------------------------------------------------------------------------------------------------------
; Swift Shadow System 1.0 - Copyright 2002 Shawn C. Swift
; -------------------------------------------------------------------------------------------------------------------

	
Type Shadow_Caster
	Field Caster
	Field Receiver
	Field Texture
	Field Radius#
End Type
	
		
Type Shadow
	Field Mesh
End Type	


; -------------------------------------------------------------------------------------------------------------------
; This function sets up a new shadow caster/receiver pair.
;
; Caster   = Mesh to cast shadows.
; Receiver = Mesh to receive shadows.
; Texture  = Texture to use for shadow.  (Must have UV clamping enabled for proper operation!)
; Radius#  = Radius of the shadow.
; -------------------------------------------------------------------------------------------------------------------
Function Cast_Shadow(Caster, Receiver, Texture, Radius#)

	ThisCaster.Shadow_Caster = New Shadow_Caster	
	
	ThisCaster\Caster   = Caster
	ThisCaster\Receiver = Receiver
	ThisCaster\Texture  = Texture
	ThisCaster\Radius#  = Radius#

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all old shadows and creates a shadow mesh for each shadow casting object.
;
; Note:
; Shadows only need to be repositioned and recreated each time the scene is rendered, 
; not every time the physics are updated.
; -------------------------------------------------------------------------------------------------------------------
Function Update_Shadows()

	Delete_Shadows()

	For ThisCaster.Shadow_Caster = Each Shadow_Caster
		 
		Shadow_Center_X# = EntityX#(ThisCaster\Caster, True)
		Shadow_Center_Y# = EntityY#(ThisCaster\Caster, True)
		Shadow_Center_Z# = EntityZ#(ThisCaster\Caster, True)
		Shadow_Radius#   = ThisCaster\Radius#		
		
		ThisShadow.Shadow = New Shadow
		ThisShadow\Mesh = Create_Shadow(ThisCaster\Receiver, Shadow_Center_X#-Radius#, Shadow_Center_Z#+Radius#, Shadow_Center_X#+Radius#, Shadow_Center_Z#-Radius#, Shadow_Center_Y#)
	
		EntityFX ThisShadow\Mesh, 1+2+8
		EntityBlend ThisShadow\Mesh, 2
		EntityTexture ThisShadow\Mesh, ThisCaster\Texture
		
	Next	
		
End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all active shadows.
; -------------------------------------------------------------------------------------------------------------------
Function Delete_Shadows()

	For ThisShadow.Shadow = Each Shadow
		FreeEntity ThisShadow\Mesh
	Next	

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all shadow casters/recievers which reference the specified entity.
;
; When you delete an entity which is casting or receiving a shadow, you must call this function so that the game
; does not crash from trying to reference an entity which does not exist.
; -------------------------------------------------------------------------------------------------------------------
Function Delete_Shadow_Caster(Entity)

	For ThisCaster.Shadow_Caster = Each Shadow_Caster

		If (ThisCaster\Caster = Entity) Or (ThisCaster\Receiver = Entity) 
			Delete ThisCaster
		EndIf	

	Next	

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function creates a shadow mesh and returns it's handle.
;
; Reciever = The entity to recieve the shadow.
; -------------------------------------------------------------------------------------------------------------------
Function Create_Shadow(Receiver, Shadow_X1#, Shadow_Z1#, Shadow_X2#, Shadow_Z2#, Shadow_Y#)

	; Get the cordinates of the lower left hand corner of the shadow.
	Shadow_Corner_X# = Shadow_X1#
	Shadow_Corner_Z# = Shadow_Z2# 

	Shadow_Scale# = Sqr(Shadow_X1#^2 - Shadow_X2#^2)

	ShadowTris = 0

	; Create the mesh for the shadow, and give it a surface to add polygons to.
	MESH_Shadow = CreateMesh()
	SURFACE_Shadow = CreateSurface(MESH_Shadow)

	; Loop through all triangles in all surfaces of the reciever.
	Surfaces = CountSurfaces(Receiver)
	For LOOP_Surface = 1 To Surfaces

		Surface_Handle = GetSurface(Receiver, LOOP_Surface)

		Tris = CountTriangles(Surface_Handle)
		For LOOP_Tris = 0 To Tris-1

			Vertex_0 = TriangleVertex(Surface_Handle, LOOP_Tris, 0)
			Vertex_1 = TriangleVertex(Surface_Handle, LOOP_Tris, 1)
			Vertex_2 = TriangleVertex(Surface_Handle, LOOP_Tris, 2)
									
			; Check to see if the triangle is inside the shadow's bounding rectangle.
			;
			; This test works by seeing if all of a triangle's points are on a specific side of each side of the
			; rectangle.  The test is not 100% accurate... a very few triangles will pass the test but actually be
			; outside the region.  But we are concerned only with making sure we find all the triangles which ARE
			; in the region and cull the vast majority outside the region, so a little sloppiness in the test is
			; okay if that means it's really fast.
			Shadow = True

			Z0# = VertexZ#(Surface_Handle, Vertex_0)
			Z1# = VertexZ#(Surface_Handle, Vertex_1)
			Z2# = VertexZ#(Surface_Handle, Vertex_2)

			; Is polygon to north of shadow's bounding rectangle?
			If (Z0# &gt; Shadow_Z1#) And (Z1# &gt; Shadow_Z1#) And (Z2# &gt; Shadow_Z1#) 
				Shadow = False 
			Else	

				; Is polygon to south of shadow's bounding rectangle?
				If (Z0# &lt; Shadow_Z2#) And (Z1# &lt; Shadow_Z2#) And (Z2# &lt; Shadow_Z2#) 
					Shadow = False	
				Else
					
					X0# = VertexX#(Surface_Handle, Vertex_0)
					X1# = VertexX#(Surface_Handle, Vertex_1)
					X2# = VertexX#(Surface_Handle, Vertex_2)

					; Is polygon to west of shadow's bounding rectangle?
					If (X0# &lt; Shadow_X1#) And (X1# &lt; Shadow_X1#) And (X2# &lt; Shadow_X1#) 
						Shadow = False 
					Else

						; Is polygon to east of shadow's bounding rectangle?
						If (X0# &gt; Shadow_X2#) And (X1# &gt; Shadow_X2#) And (X2# &gt; Shadow_X2#) 
							Shadow = False 
						Else

							Y0# = VertexY#(Surface_Handle, Vertex_0)
							Y1# = VertexY#(Surface_Handle, Vertex_1)
							Y2# = VertexY#(Surface_Handle, Vertex_2)

							; Is shadow below the polygon?
							If (Shadow_Y# &lt; Y0#) And (Shadow_Y# &lt; Y1#) And (Shadow_Y# &lt; Y2#)
								Shadow = False
							Else
								
								NY0# = VertexNY#(Surface_Handle, Vertex_0) 
								NY1# = VertexNY#(Surface_Handle, Vertex_1) 
								NY2# = VertexNY#(Surface_Handle, Vertex_2)

								FaceNY# = NY0# + NY1# + NY2#								

								; Is polygon facing downwards?
								If (FaceNY# &lt; 0) Then
									Shadow = False
								Else
								
									If (FaceNY# = 0)
										Shadow = False
									EndIf	
									
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf	
			
			; If the triangle is inside the bounding box then add it to the mesh.
			; Note that shadow texture will be flipped top to bottom because of how UV coordinates are assigned to the vertices from the world coordinates.
			If Shadow = True

				Shadow_Vertex_0 = AddVertex(SURFACE_Shadow, X0#, Y0#, Z0#, (X0#-Shadow_Corner_X#)/Shadow_Scale#, (Z0#-Shadow_Corner_Z#)/Shadow_Scale#)
				Shadow_Vertex_1 = AddVertex(SURFACE_Shadow, X1#, Y1#, Z1#, (X1#-Shadow_Corner_X#)/Shadow_Scale#, (Z1#-Shadow_Corner_Z#)/Shadow_Scale#)
				Shadow_Vertex_2 = AddVertex(SURFACE_Shadow, X2#, Y2#, Z2#, (X2#-Shadow_Corner_X#)/Shadow_Scale#, (Z2#-Shadow_Corner_Z#)/Shadow_Scale#)

				; Adjust shadow brightness at each vertex according to vertex normal.				
					VC = (1.0-NY0#)^3*255.0
					If (VC &gt; 0) Then VertexColor SURFACE_Shadow, Shadow_Vertex_0, VC, VC, VC
	
					VC = (1.0-NY1#)^3*255.0
					If (VC &gt; 0) Then VertexColor SURFACE_Shadow, Shadow_Vertex_1, VC, VC, VC
				
					VC = (1.0-NY2#)^3*255.0
					If (VC &gt; 0) Then VertexColor SURFACE_Shadow, Shadow_Vertex_2, VC, VC, VC

				; Add the triangle to the shadow mesh.
					AddTriangle(SURFACE_Shadow, Shadow_Vertex_0, Shadow_Vertex_1, Shadow_Vertex_2)

				ShadowTris = ShadowTris + 1

			EndIf
			
		Next			
	
	Next

	Return MESH_Shadow

End Function
</pre> <br><br></td></tr></table><br>
<a name="99135"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> personally i like the direct way, the fast way. My Renderworld-Shadow-projector optimized by Peter Scheutz is pretty fast and an ideal choice for tekken-like stuff. For large Terrains and Buildings etc. you can combine this with the FLEX Method Rob mentioned. That's really easy. If you have probs with the FLEX-Mesh then have a look at the Flag Demo in the 3D Code Archives, it uses a Mesh with realtime modificated Vertex Heights.<br><br>So this technic uses two parts:<br><br>1)<br>temporary position camera at the lights position, point it to the Character, color the character grey and the ground black/hidden (entityFX 1 of course) and make a Renderworld (which is in fact the shadow viewed from above). transfer this Render to the Texturebuffer of the FLEX-Mesh.<br><br>2)<br>Position the FLEX-Mesh right above the Character, x/z-centered. get each Vertex X and Z position and use Linepick to determine the Ground Y.(Make shure the Character is not pickable for his own shadow) Now set the Vertex-Y of the FLEX-Mesh to Ground-Y +0.1 or something.<br><br>then reset camera and entityfx etc, continue as usual. <br><br></td></tr></table><br>
<a name="99161"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, Norc, that's exactly what I tried yesterday,<br>But the point is: it doesnt work!!!! :(<br><br>I got to have my lightmap (yourcode) rendered on the &quot;towel&quot; (the flex mesh),I have set all my level children pickmode to 2 (polies), <br>but If I apply the UpdateFlex() function before the updateworld() it blocks down at 0.001 fps..<br><br>What's wrong ?<br><br>Also, I noticed the rendered lightmap, is not only the character model, but has some more pixel, I dont know where are they coming from, so now a questioN:<br><br>To pre render the lightmap, I saw in your code you used entityalpha flo,0<br>then back for rendering entityalpha flo,1.0<br><br>I have many more than &quot;flo&quot;, so I used EntityHide on all stuff: skybox, groundplane, level, <br>but still something more than the character is &quot;grabbed&quot; by the temp camera.<br><br>Now what you think, if instead of hiding everything, we go toward this: create a white flipped faces box, big let's say the triple of the character, around the character, then do the lightmap, then hide the whitebox, then render scene.<br><br>Do you think will work ? <br><br></td></tr></table><br>
<a name="99178"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> not on a terrain, because you'll have hills and sometimes you'll standing between 2 hills which would intersect with the box. I think ti isn't very hard to set up an array which stores all EntityHandles of the &quot;ground-objects&quot;. <br><br></td></tr></table><br>
<a name="99184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> But you'd hide the terrain while rendering the shadow...<br><br>Ok you mean an array which stores all the Ground surfaces, not the children...<br><br>because is that (the surface) that I need most of the time (really also the walls should be lightmapped if the light is not on the top of the character.<br><br>What I'm trying to do, is to retrieve each frame, the surface (triangle or quad) where the player is walking on, so to be able to texture it with a real time shadow lightmap.<br><br>I have at the mo' the handle of the mesh, the player is &quot;touching/walking&quot;,<br>but now I need to know <br><br>EG: which surface of the room/corridor, is the one to be textured( I don't know if is possible in blitz, to assing a second texture layer just for a &quot;face&quot; of a cube/room, but I hope so).<br>Which one is below the player's foot ?<br><br>Infact at the moment, when I walk in a room, the real time animated shadow, is texturing all the parts of the room with itself, it seems is using the 1st channel of UVmapping, instead of using the whole mesh....<br><br>...stucked there<br><br>P.S. Tell me if you need screenshot <br><br></td></tr></table><br>
<a name="99190"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> here it is NORC code, trying to be applied to a complete .3ds level...<br><br><img src="http://www.nofrontier.it/snap3.jpg"><br><br>Impossibile ? not for my buffalo head :P<br><br>I'm keep trying and testing...it also appears that lightmap get coloured...mmm <br><br></td></tr></table><br>
<a name="99261"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> My Opinion is it's too much trouble to apply the shadow to the current tris. Only in rare cases you will need to shade only one triangel, most times you'll have to use2 or more Tris for the shadow. The NORC-Code :) (Sounds like a standard - hey! i'm still using 'goto'!) is using the second UV-Coordds Set to blend the shadows as seen in the Demo.<br><br>Robs FLEX Method is much better casue you won't have to care about the whole stuff, just render it to a texture, align the texture to the flexmesh and align the flexmesh to the ground.<br><br>I've just finished a fist Demo that combines both. I had some troubles with the Vertex Coords, but now it works. It's pretty fast, even on my crap Machine. It would be perfect for a third person camera.<br><br>I'll send you the source for 'Realtime Shadows for large Scenes' per mail, cheers! <br><br></td></tr></table><br>
<a name="99288"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Litobyte</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Humm that is for a terrain only ?<br><br>Or for a 3ds based as well ? <br><br></td></tr></table><br>
<a name="99581"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's what I got so far:<br><br><img src="http://melog.ch/dl/shadow1.jpg"> <img src="http://melog.ch/dl/shadow2.jpg"> <br><br></td></tr></table><br>
<a name="99583"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chevron</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> that looks like a great shadow norc, is their a demo? with source :-) <br><br></td></tr></table><br>
<a name="99379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> it is for everything that is pickable. Just take a minute and read trough the Source and you'lle see a Remark : &quot;Any pickable Geometry&quot; :/ [EDIT] :) <br><br></td></tr></table><br>
<a name="99587"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes there's a demo - but it's not for release to the public - only for co-producers.<br><br>I've released a lot of source, but whenever I have a Question or need some help then most ppl ignore me here. Seems I have to slightly adjust my philosophy. <br><br></td></tr></table><br>
<a name="99589"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chevron</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok norc, no problem, I will allways try to help if possible but tend to refrain from posting unless i'm totally sure that I know what I'm on about as I dont like to look like a arse.<br>I can assure you that the majority of the blitz comunity DO appreiate your contribution. <br><br></td></tr></table><br>
<a name="99597"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> of course - don't take this personal. <br><br></td></tr></table><br>
<a name="99663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> [img=http://www.neomancer.co.uk/images/boogerman.jpg[/img]<br>this works?<br> <br></div><br><br>No, Neomancer. It doesn't work because you forgot to close the first image tag before starting the last one. Put a &quot;]&quot; before the &quot;[/&quot;. Your image will then show correctly. <br><br></td></tr></table><br>
<a name="99676"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> do it this way:<br>{img http://www.server.com/piccy.jpg}<br><br>(Replace the {} by []) There ain't no = or / or a closing tag. Or did you see a closing tag in html? <br><br></td></tr></table><br>
<a name="99837"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >necky</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi All,<br>Heres my shadow code. realtime, dynamic specular shadows. If you use the cursors the shadows dynaically change to the direction the light is pointing. If you want to use it, you'll have to fill in the missing files yourself, or send me a mail and I'll forward them on to you to get you started. :) Looks very nice when it's up and running :)<br><br>cu,<br>    Mike<br><br>;******************<br>;*                *<br>;* Shadow Casting *<br>;*                *<br>;*       by       *<br>;*                *<br>;*  Mike Oakley   *<br>;*                *<br>;******************<br><br><br>Global screenx=320<br>Global screeny=240<br><br>Graphics3D screenx,screeny,16<br>SetBuffer BackBuffer()<br><br>AmbientLight 128,128,128<br><br>Global light=CreateLight()<br>MoveEntity light,0,5,-10<br><br>Global shadsizex=128<br>Global shadsizey=128<br><br>Global shadowcamera=CreateCamera()<br>PositionEntity shadowcamera,0,5,-10	;x,y,z<br><br>RotateEntity shadowcamera,20,0,0<br><br>Global sphere=LoadMesh(&quot;spotlight.3ds&quot;)<br>Global shadowfloor=LoadMesh(&quot;shadowmodel.3ds&quot;)<br>Global softshadow=LoadMesh(&quot;soft-shadow.3ds&quot;,shadowcamera)<br>Global stepsFloor=LoadMesh(&quot;stepsfloor.3ds&quot;)<br>Global player=LoadMesh(&quot;horse.3ds&quot;)<br><br>Global black=LoadTexture(&quot;black.bmp&quot;)<br>Global white=LoadTexture(&quot;white.bmp&quot;)<br>Global tex=LoadTexture(&quot;texture.bmp&quot;)<br>Global objtexture=LoadTexture(&quot;T-PageHead.bmp&quot;)<br>Global Floortexture=LoadTexture(&quot;floor2.bmp&quot;)<br><br>Global shadtexture=CreateTexture(shadsizex,shadsizey)<br>Global softtexture=CreateTexture(shadsizex,shadsizey)<br><br>Global lightring=LoadTexture(&quot;lightring.bmp&quot;)<br>Global lightringsprite=CreateSprite(shadowcamera)  <br>SpriteViewMode lightringsprite,1<br>EntityTexture lightringsprite,lightring<br><br>EntityBlend softshadow,2<br>EntityFX softshadow,1<br>MoveEntity softshadow,0,0,15<br>ScaleEntity softshadow,0.15,0.15,0.15<br>EntityTexture softshadow,shadtexture<br><br>MoveEntity lightringsprite,-0.15,0,50<br>ScaleSprite lightringsprite,50,50<br><br>EntityBlend shadowfloor,2<br>EntityFX shadowfloor,1<br><br>EntityFX sphere,1<br><br>MoveEntity player,0,-3.3,0<br>MoveEntity stepsfloor,0,-1,-2<br>MoveEntity shadowfloor,0,-1,-2<br><br>EntityTexture player,tex<br><br>EntityTexture stepsfloor,floortexture<br><br>;EntityTexture shadowfloor,black<br>EntityTexture shadowfloor,shadtexture<br><br>Global r#<br><br>Global pp#<br>pp#=6<br><br>Global gg#<br>gg#=10<br><br>Global ff#<br>ff#=-8<br><br>Global rot#<br>rot#=20<br><br>Global rotb#<br>rotb#=30<br><br>;********<br>;********<br>;* Main *<br>;********<br>;********<br><br>While Not KeyDown(1)<br><br>SetBuffer BackBuffer()	<br>	<br>yyy#=0<br>xxx#=0	<br><br>If KeyDown(205)=1 Then pp#=pp#+0.1<br>If KeyDown(203)=1 Then pp#=pp#-0.1<br><br>If KeyDown(30)=1 Then ff#=ff#+0.1<br>If KeyDown(44)=1 Then ff#=ff#-0.1<br><br>If KeyDown(200)=1 Then gg#=gg#+0.1<br>If KeyDown(208)=1 Then gg#=gg#-0.1<br><br>If KeyDown(2)=1 Then rot#=rot#+1<br>If KeyDown(3)=1 Then rot#=rot#-1<br><br>If KeyDown(4)=1 Then rotb#=rotb#+1<br>If KeyDown(5)=1 Then rotb#=rotb#-1<br><br>If KeyDown(19)=1 Then pp#=0:gg#=5:ff#=-8:rot#=20:rotb#=0<br>	<br>PositionEntity sphere,pp#,gg#,ff#<br>RotateEntity sphere,20,0,0<br>RotateEntity sphere,rot#,rotb#,0<br><br>r#=r#+1<br>RotateEntity player,0,r#,0	<br>MoveEntity player,xxx#,yyy#,0<br><br>MoveEntity light,pp#,gg#,ff#<br>RotateEntity light,rot#,rotb#,0<br><br>makeshadow()<br>	<br>		Flip<br>	<br>Wend<br><br>;***************************<br>;* Camera Mapping Function *<br>;***************************<br><br>Function cameramap(mesh)<br><br>Local xx#<br>Local yy#<br><br>	For b=1 To CountSurfaces(mesh)<br>		surf=GetSurface(mesh,b)<br>		<br>		For a=0 To CountVertices(surf)-1<br>				<br>		x#=VertexX(surf,a)<br>		y#=VertexY(surf,a)<br>		z#=VertexZ(surf,a)<br><br>		TFormPoint x#,y#,z#,mesh,0<br>				<br>		x=TFormedX()<br>		y=TFormedY()<br>		z=TFormedZ()<br>				<br>		CameraProject shadowcamera,x#,y#,z#<br>				<br>		xx#=ProjectedX()<br>		yy#=ProjectedY()<br>				<br>		u#=(xx#/shadsizex)<br>		v#=(yy#/shadsizey)<br>		<br>		If u#&gt;1 Then u#=1<br>		If v#&gt;1 Then v#=1<br>		<br>		If u#&lt;0 Then u#=0<br>		If v#&lt;0 Then v#=0<br>			<br>;		VertexTexCoords surf,a,VertexU(surf,a),VertexV(surf,a),0			<br>	    VertexTexCoords surf,a,u#,v#<br>				Next<br>	Next<br>End Function<br><br>;*******************<br>;* Make the shadow *<br>;*******************<br><br>Function makeshadow()<br><br>ShowEntity player<br>	<br>CameraClsColor shadowcamera,255,255,255<br>	<br>CameraViewport shadowcamera,0,0,shadsizex,shadsizey 		<br>PositionEntity shadowcamera,pp#,gg#,ff#<br>RotateEntity shadowcamera,rot#,rotb#,0<br><br>AmbientLight 255,255,255<br><br>ShowEntity lightringsprite<br>HideEntity softshadow<br>HideEntity stepsfloor<br>HideEntity shadowfloor<br>EntityTexture player,black<br><br>UpdateWorld				<br>RenderWorld<br>	<br>	CameraClsColor shadowcamera,255,255,255<br>	<br>	SetBuffer TextureBuffer(softtexture)		<br>	CopyRect 0,0,shadsizex,shadsizey,0,0,BackBuffer(),TextureBuffer(softtexture)<br>	EntityTexture player,objtexture<br><br>HideEntity lightringsprite<br>HideEntity player<br>EntityTexture softshadow,softtexture<br>ShowEntity softshadow<br>UpdateWorld				<br>RenderWorld<br><br>SetBuffer TextureBuffer(shadtexture)<br>CopyRect 0,0,shadsizex,shadsizey,0,0,BackBuffer(),TextureBuffer(shadtexture)<br><br>cameramap(shadowfloor)<br><br>	AmbientLight 30,30,30<br><br>SetBuffer BackBuffer()<br><br>	CameraClsColor shadowcamera,0,0,0<br>	HideEntity softshadow<br>	HideEntity lightringsprite<br>	ShowEntity stepsfloor<br>	ShowEntity shadowfloor	<br>	ShowEntity player<br>	CameraViewport shadowcamera,0,0,screenx,screeny		<br>	PositionEntity shadowcamera,5,10,-17<br>	RotateEntity shadowcamera,30,20,0<br>;	HideEntity player<br>			<br>	RenderWorld<br><br>End Function <br><br></td></tr></table><br>
<a name="100029"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> *cries*<br><br>I don't understand!! I try, I really do, but I can't understand it...<br><br>I need someone to talk me through everything line by line. No holds barred, nice and slow - I'm thick when it comes to programming, so I need to have it spelled out to me. I can't really get my head around general points because I don't know how to turn the general stuff into specifics. I just can't take it all in at once...<br><br>...and I *really* think that gratuitous commenting is sorely lacking in the examples shown here. Shadows (for me, at least) aren't exactly the easiest thing in the world to do.<br><br>I feel a bit lame having said all of this, but this really is what it looks like - a pathetic, desperate plea for a lengthy, line-by-line explanation of how to implement shadows. -norc-'s example is what I'd rather have the explanation on. But that's because it is (for me) the fastest example of shadowing I've seen.<br><br>So does anyone care to help a complete dunce? <br><br></td></tr></table><br>
<a name="100031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now now... its easy enough. I suspect you're becoming stuck only because you're not up on the background info.<br><br>Lets concentrate on that and hopefully things will click into place.<br><br>A shadow in real life will usually be the same shape as you. When you walk around, your shadow is a filled in outline of you.<br><br>To make this, a camera is placed at the light source and pointed at you. The resulting render is placed on a texture. This is the shadow texture. More often than not it will be enough to convince you that it is a shadow for real. A few more tricks such as entitycolour or entityfx are used to color the render. <br><br>The scene is then rendered again, this time with the shadow texture already in place. This is usually going to be on a terrain or flat floor for this kind of trick.<br><br>points to note:<br><br>1. color objects dark grey<br>2. render these objects from above<br>3. copy the renderworld to a texture<br>4. apply this new &quot;shadow&quot; texture to the ground<br>5. restore the original objects<br>6. render the game<br>7 goto 1<br><br>This is the basic cycle of creating a realtime shadow map norc's way. Its really quite effective when done carefully.<br><br>As for typical shadows, such as a blob under the player's feet it may well be better to use a single sprite. if the ground is basically flat this is all you need. SpriteViewMode will prevent the sprite from turning.<br><br>If the ground has hills or it's a level - then my flex code does the same thing, except the shadow bends to fit the floor's bumps and hills.<br><br>I hope this is a little bit clearer... :) <br><br></td></tr></table><br>
<a name="100080"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> @BlackHawk <br><a href="/cgi-bin/showposts.pl?topic=7466" target="_blank">Here</a> is my original post about this metod. It also contains some links. <br><br></td></tr></table><br>
<a name="100115"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for all your help guys. Well, I've managed to do something... it's not quite right yet, but I believe I may have forgotten something somewhere along the line.<br><br>The shot below shows it all.<br><br><img src="http://riptide.gxstudios.net/images/games/demonsrage/problem02.jpg"><br><br>I'm sure you can all see the problem, but as I said, have I forgotten something here? How do I stop the terrain from tiling, and how do I get the terrain to stick to the model? (The ground texture has been removed to help you see the problem more clearly.) <br><br></td></tr></table><br>
<a name="100138"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK. I've fixed the tiling issue by using the Clamp U and Clamp V flags.<br><br>However, the shadow still stays in a fixed place. How do I get the shadow to move with the model? I've textured the ground with the shadow texture (as Rob said), but the shadow won't move with the model? How do I get it to do this? <br><br></td></tr></table><br>
<a name="100139"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> there's two methods:<br><br>a) you want the shadow map to work for lots of objects (in which case you just want to position the camera for rendering a shadow where the light is)<br><br>b) you want the shadow map for only the character<br><br>(b) is harder. You will need to use flex or move a large flat sprite under the character's feet every frame<br><br>See peter's notes about that... <br><br></td></tr></table><br>
<a name="100154"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ashley - I sent you the FLEX Combination - what's wrong with it? <br><br>Maybe one general word about shadows: If you're relatively new to game dev then shadows might be the wrong thing to start with, cause they are difficult even for advanced Programmers. If you once know what each Command is doing then it's easy to read through the Source and understand what happens when you have a logical description such as &quot;position camera above scene and ENtityFX  1 the Character in a Grey-Tone&quot;. (Btw. I had some troubles with textured Models, so I just use a grey Texture and ENtityFX 1 for the Shadow Rendering.)<br><br>Your last Screenshot is looking good so far. But you have the wrong Scaling on the texture. The Problem is you should use a Texture which covers the whole Building without repetition. That means  your Building Floor Texture can have max. screensize. not a good idea<br><br>A second method would be to Render the Shadow to the backbuffer and copy that rectangle to the xz location inside a huge Shadow/Floor texture. (thanks the new bit256 this is an option)<br><br>And there's the FLEX Method which is my favorite. It's a bit tricky to handle all kinds of slopes and I'm working on a solution for Stairways etc. but it's the fastest and the most flexible. You can put the shadow on multiple objects without to waste a single second to think about howto do that. <br><br></td></tr></table><br>
<a name="100165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doesn't anyone like the code I posted? :-) <br><br></td></tr></table><br>
<a name="100177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> sswift - sorry, I didn't test you functions yet, the source is looking promising, but I was too lazy to figure out how to use them. Could you post a little Example that can be started? (just omit the functions) <br><br>cheers! <br><br></td></tr></table><br>
<a name="100213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> A second method would be to Render the Shadow to the backbuffer and copy that rectangle to the xz location inside a huge Shadow/Floor texture. (thanks the new bit256 this is an option) <br></div><br><br>Hmmm... my floor texture is tiled. I don't suppose this would work with a 128x128 texture that is tiled to cover the whole floor?<br><br>I'm trying to go Rob's way of having a flat sprite that is underneath the character and moves with the character. However, the sprite is not being textured properly. In fact, it is not being textured at all. All I'm getting is a totally white sprite under the character.<br><br>I have the media and full source if anyone would like to have a peek at it and tell me what is wrong. Obviously, you will get full credit for the fix. <br><br></td></tr></table><br>
<a name="100821"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess that sprite is not visible because the Shadow Texture as in the Example from the code archive is a second blend-texture. but it should be the first one.<br>try <br>entitytexture sprite,limap,0,0<br>instead of<br>entitytexture sprite,limap,0,1 <br><br></td></tr></table><br>
<a name="101105"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Norc:<br>The code is really simple if you look at it.  <br><br>All you have to do is call one function to define an object as casting a shadow, and another object as reciving the shadow from that object, and the texture to use for the shadow, and then each time you render the world call the function which regenerates all the shadows.<br><br>That's it!<br><br>The code casts shadows straight down only currently.  But in theory it should be possible to modify it to cast shadows in any directon.<br><br>Also, the shadow textures right now are intended to be circular shadows.  So you just make a circular black texture.  Then that will wrap around the obejct the shadow is being cast down upon.<br><br>However, you should be able to generate a new shadow texture each frame from the actual object's geometry, and then you could have shaped shadows which cast downward.<br><br>In theory you could do this by rendering the world from a camera view to a small viewport offscreen.  Just point the camera down towards the object making sure the object is black and the background is white.  Then you just grab that for your texture.<br><br>I don't have a small sample program for it, but like I said, it's only 2 function calls.  One to create the shadow generator shadow caster link, and one each renderworld to create the actual shadows.  Doesn't get any simpler than that.<br><br>Oh nad with my system it doesn't matter how your world is textured.  The system creates new geometry specifically for the shadows. <br><br></td></tr></table><br>
<a name="101108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chevron</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do your shadow functions work on single hieghtmapped terrains SSwift? <br><br></td></tr></table><br>
<a name="101238"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> sswift - I tried it hard :( here's what I tried:<br><br><pre class=code>

Graphics3D 640,480,16,2
SetBuffer BackBuffer()
   
Type Shadow_Caster
    Field Caster
    Field Receiver
    Field Texture
    Field Radius#
End Type
   
       
Type Shadow
    Field Mesh
End Type   


camera=CreateCamera()
PositionEntity camera,0,50,-200

light=CreateLight(2)
PositionEntity light,0,200,0
AmbientLight 100,100,100

ground=CreateSphere()
ScaleEntity ground,100,10,100
PositionEntity ground,0,-30,0

cube = CreateCube()
ScaleEntity cube,20,20,20
RotateEntity cube,30,50,70
PositionEntity cube,0,50,0

PointEntity camera,cube

shd=CreateTexture(256,256,48)
SetBuffer TextureBuffer(shd)
Color 127,127,127
Rect 0,0,256,256,1
SetBuffer BackBuffer()

;----------------
Create_Shadow(ground, -30, -30, 30, 30, 0)
; Cast_Shadow(cube, ground, shd, 10.0) ; ?????
;----------------

While KeyDown(1)=0
 Cast_Shadow(cube, ground, shd, 10.0)
 ; Update_Shadows()  ; ??????????
 UpdateWorld()
 RenderWorld()
 Flip
Wend


End

... the Functions ...

</pre><br><br>I tried to read through the source and I understood as follows:<br><br>A mesh is created every Renderworld? why don't you reuse the mesh? The Vertex Alignement Part is pretty good. The whole thing isn't far away from the one I'm working on. Stuying your Source just gave an idea how to fix one of my mesh-alignement-problems. THX! <br><br></td></tr></table><br>
<a name="101267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right. I've almost got shadows as-near-as-damnit nailed.<br><br>Only one niggling problem remains. How do I make the white parts of a textured sprite transparent? The solution to the problem, easy as it may be, eludes me completely. Here is a shot, just in case you may need it:<br><br><img src="http://riptide.gxstudios.net/images/games/demonsrage/problem03.jpg"><br><br>I dunno, maybe I can't think straight because my brain is on supreme downtime after exams. <br><br></td></tr></table><br>
<a name="101358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >semar</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> You should load the texture with the flag 4, that is, masked; in this way, all the black color that are present on the texture, will not be drawn on the screen.<br><br>See the LoadTexture command, and the related parameters.<br><br>Hope this helps,<br>Sergio. <br><br></td></tr></table><br>
<a name="101413"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> blackhawk - congrats, lookin good so far!<br><br>try this for the white background (which is ok):<br><br>; mesh is the Sprite or whatever and limat the Shadow Texture.<br>EntityTexture mesh,limat,0,0<br>EntityBlend mesh,2<br>EntityFX mesh,8<br><br>this makes the background transparent and the shadow semitransparent if it's grey. <br><br></td></tr></table><br>
<a name="101429"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uh...how do you do shadows?  Now I want to know. :) <br><br></td></tr></table><br>
<a name="101464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK... now this is getting weird.<br><br>Normally, I have the texture flag set at 256, for speed. This is what I get following norc's above method:<br><br><img src="http://riptide.gxstudios.net/images/games/demonsrage/problem04_1.jpg"><br><br>After this, (since it didn't work correctly) I adapted semar's suggestion, and used a flag value of 260 (256+4 - fast textures+alpha). However, doing that gave me this:<br><br><img src="http://riptide.gxstudios.net/images/games/demonsrage/problem04_2.jpg"><br><br>Since that didn't work either, I removed the 256 flag and just left the 4 (alpha) flag. This is what I got for trying that:<br><br><img src="http://riptide.gxstudios.net/images/games/demonsrage/problem04_3.jpg"><br><br>All of these problems I think are very strange, and I don't know why they happen. What exactly is going wrong here?<br><br>I have an nVidia GeForce 2 MX (32MB) with the latest nVidia official drivers (29.42). <br><br></td></tr></table><br>
<a name="101508"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Blackhawk,<br><br>It looks like the same problem I had. Make sure you use EntityBlend ... ,2 on the shadowmesh, and make sure the texture is white with a black shadow. <br><br></td></tr></table><br>
<a name="101608"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just like I said Grrrrrrr! :) <br><br></td></tr></table><br>
<a name="101627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yup, but it looks similar to what I experienced, so I just wanted to be sure. <br><br></td></tr></table><br>
<a name="101641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt;&gt;Normally, I have the texture flag set at 256, for speed. This is what I get following norc's above method:&lt;&lt;<br><br>Did you try that with 256 off as well? I can't believe this, here it works. Hmm maybe because its a sprite? you could test this with a cube (scale it to 10,0.1,10) instead of a sprite. Don't forget to hide the Shadow Sprite as well when you RenderWorld the Shadow Texture. <br><br></td></tr></table><br>
<a name="101843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ash</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using the cube still doesn't work.<br><br>However, the really awesome news is that it *finally* does work for me (using the sprite, as before). Here's what I did:<br><br>I took norc's above code:<br><div class="quote"> <br>EntityTexture mesh,limat,0,0<br>EntityBlend mesh,2<br>EntityFX mesh,8<br> <br></div><br><br>Removed the &quot;,0,0&quot; from the EntityTexture line, removed the EntityFX line, and set the EntityBlend for the shadow (&quot;mesh&quot;) to 3 instead of 2. I now get a lovely real-time shadow in my game and it still pumps out 50-60 FPS!!<br><br><img src="http://riptide.gxstudios.net/images/games/demonsrage/yippee01.jpg"><br><br>AWESOME!! =^__^= <br><br></td></tr></table><br>
<a name="102099"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> Chevron:<br>&quot;Do your shadow functions work on single hieghtmapped terrains SSwift?&quot;<br><br>Not unless those terrains are a mesh.  My system will not work with LOD based terrains because Mark does not give you access to the vertex data for the mesh each time it is rebuilt.  If he did, then it would.<br><br>You could of course make a mesh that represents the terrain at some level of detail and use that to generate the shadows from, but then the shadows would not lie flush with the actual terrain because the terrain changes shape as it changes LOD.<br><br><br><br><br>Norc:<br>&quot;A mesh is created every Renderworld? why don't you reuse the mesh? The Vertex Alignement Part is pretty good. The whole thing isn't far away from the one I'm working on. Stuying your Source just gave an idea how to fix one of my mesh-alignement-problems. THX!&quot;<br><br><br>Why don't I reuse the mesh?  Because the mesh has to change every time it moves.  The mesh I create is just large enough to cover the area the shadows lies on precisely.  The polygons in it mirror the polygons the shadow overlaps precisely.  <br><br>In other words, if you have a teapot, and the shadow covers that whole teapot, the shadow mesh while over the teapot will be constructed of all the polygons in that teapot which face upwards.<br><br>Unlike towel shadows, my shadows lie almost perfectly flush with the surface, so there are no rendering errors, EVER.  You'll never see a bit of shadow overhanging the ege of a stair for example.  <br><br>With towel shadow techniques, the polygons do not match the polygons the shaodw lies over exactly, so you have to tesselate your towel a lot to minimize error when your player is near the edge of something or over a complex object.<br><br>With my system only the exact number of polygons needed to render the shadow are created and they're exactly the same as the polygons which are being shadowed so there's never any polygons hanging over edges.<br><br>So.... when your player walks over a floor, the code will make maybe one or two polygons and run really fast.  If they walk over a teapot, then the code will create hundreds of polygons if the teapot is made of hundreds of polygons and be somewhat slower.  But you'll still get still pretty good framerates and that is a worst case scenario.<br><br>The only issue with my code right now is that if your levels have rooms over rooms, my code has no way to tell that the shadow has been blocked by something.  So if a player is in a room above, and another player is in a room below, the second player would see the shadow of the first player on the floor, and the first player would also see their shadow on the floor below them.  So the shadow from the first player would be cast onto two surfaces.  Backfacing surfaces do not recieve shadows though so there would not be a shadow on the ceiling.<br><br>I'm sure there's a way to work around that problem, but I haven't bothered because I don't need to worry about it in my game. <br><br></td></tr></table><br>
<a name="102102"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob </td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> If your floor is always flat in-game and shadow will always be cast from light above, then you can gain a massive speed boost by just using a copy of the main character with Y scale being around 0.5 and placed at the feet...<br><br>no rendering needed. <br><br></td></tr></table><br>
<a name="102145"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay norc... I fixed your code.  It took me three hours, but I fixed it.<br><br><br>There were a number of problems with it, some wiht your code, some with mine.  I won't list them all but here are a few.<br><br>First, the object you were casting shadows did not have it's vertices in the right places.  The coordinates of the vertices in the object must match their locations in the world.  My code assumes you're casting shadows onto a static level so this isn't a problem.  You can of course change this by modifying my code to sutract the vertex positions by the object's offset in the real world when doing the calculations.<br><br>Second, the blending mode for the texture was not set up right.  The texture blend mode has to be additive.  That's my fault for not informing you of that.  I'd forgotten it myself.  It has to be add because the colors are added to the vertex colors in order to create the effect of the shadow fading out when the surface's angle is too steep relative to the imaginary overhad light source.  To do this the vertex colors start out black and go to white as the surface angle increases, and the texture of the shadow is ADDED to this, so that the areas not in shadow become white anyhow, and the areas in shadow stay whatever color the vertex colors say they should be.<br><br>Third you were scaling the entity that you wanted to cast shadows onto rather than the MESH.  This whole system relies on the mesh data being set up a certain way.  You can of course change this behavior by adding more math to the alogirthm, but I did not do that myself because to do so would slow the alogorithm down some.<br><br>Fourth, you were using a SOLID BLACK shadow texture.  For the shadow code to work the areas outside the shadow must be white.  And for them to be white yhou have to clamp the texture... but for the clmaping to make the areas outside the shadow white, ALL the edge pixels of the shadow must be white, otherwise the UV clmaping will copy the blackness everywhere outside the shadow and you don't want that.<br><br>You'll notice that the shadow is square, but not aligned properly with the cube.  As I said, you have to generate an appropriate shadow each frame for the object in it's current position for the shadow to be shaped properly.   Rendering a camera view from above the object to be shadowed while it is black and against a white background and then using that as the texture is one way of doing this. <br><br>Anyhow the code now works.  Hope this helps you out!<br><br><br><pre class=code>

Graphics3D 640,480,16,2
SetBuffer BackBuffer()

Type Shadow_Caster
	Field Caster
	Field Receiver
	Field Texture
	Field Radius#
End Type


Type Shadow
	Field Mesh
End Type


	camera=CreateCamera()
	PositionEntity camera,50,100,-200
	
	light=CreateLight(2)
	PositionEntity light,0,200,0
	AmbientLight 100,100,100

	ground=CreateSphere()
	ScaleMesh ground,100,25,100
	; Position the mesh so that the lower bottom left hand corner of it lies at 0,0,0
	PositionMesh ground,50,12.5,50
	; Update the normals because we scaled the mesh (newest versions of Blitz should not require this)
	UpdateNormals ground
	;PositionEntity ground,50,25,50
	

	cube = CreateCube()
	ScaleEntity cube,20,20,20
	RotateEntity cube,30,50,70
	PositionEntity cube,50,150,50

	PointEntity camera,cube
		
	; Create texture of black square in white background
	shd=CreateTexture(256,256,48)  ; Flags = ClampU, ClampV
	TextureBlend shd, 3
	SetBuffer TextureBuffer(shd)
	ClsColor 255, 255, 255
	Cls
	Color 0,0,0
	; Must leave border of white around shadow!
	Rect 1,1,254,254,1
	SetBuffer BackBuffer()

	Cast_Shadow(cube, ground, shd, 20.0) 

	While KeyDown(1)=0
	
		Update_Shadows() 
		UpdateWorld()
		RenderWorld()
		Flip

	Wend


End


; -------------------------------------------------------------------------------------------------------------------
; This function sets up a new shadow caster/receiver pair.
;
; Caster   = Mesh to cast shadows.
; Receiver = Mesh to receive shadows.
; Texture  = Texture to use for shadow.  (Must have UV clamping enabled for proper operation!)
; Radius#  = Radius of the shadow.
; -------------------------------------------------------------------------------------------------------------------
Function Cast_Shadow(Caster, Receiver, Texture, Radius#)

	ThisCaster.Shadow_Caster = New Shadow_Caster	
	
	ThisCaster\Caster   = Caster
	ThisCaster\Receiver = Receiver
	ThisCaster\Texture  = Texture
	ThisCaster\Radius#  = Radius#

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all old shadows and creates a shadow mesh for each shadow casting object.
;
; Note:
; Shadows only need to be repositioned and recreated each time the scene is rendered, 
; not every time the physics are updated.
; -------------------------------------------------------------------------------------------------------------------
Function Update_Shadows()

	Delete_Shadows()

	For ThisCaster.Shadow_Caster = Each Shadow_Caster
		 
		Shadow_Center_X# = EntityX#(ThisCaster\Caster, True)
		Shadow_Center_Y# = EntityY#(ThisCaster\Caster, True)
		Shadow_Center_Z# = EntityZ#(ThisCaster\Caster, True)
		Shadow_Radius#   = ThisCaster\Radius#		
						
		ThisShadow.Shadow = New Shadow
		ThisShadow\Mesh = Create_Shadow(ThisCaster\Receiver, Shadow_Center_X#-Shadow_Radius#, Shadow_Center_Z#+Shadow_Radius#, Shadow_Center_X#+Shadow_Radius#, Shadow_Center_Z#-Shadow_Radius#, Shadow_Center_Y#)
	
		; full bright, use vertex colors, no fog.
		EntityFX ThisShadow\Mesh, 1+2+8

		; multiply blend mesh.
		EntityBlend ThisShadow\Mesh, 2 

		EntityTexture ThisShadow\Mesh, ThisCaster\Texture
				
	Next	
		
End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all active shadows.
; -------------------------------------------------------------------------------------------------------------------
Function Delete_Shadows()

	For ThisShadow.Shadow = Each Shadow
		FreeEntity ThisShadow\Mesh
		Delete ThisShadow.Shadow
	Next	

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all shadow casters/recievers which reference the specified entity.
;
; When you delete an entity which is casting or receiving a shadow, you must call this function so that the game
; does not crash from trying to reference an entity which does not exist.
; -------------------------------------------------------------------------------------------------------------------
Function Delete_Shadow_Caster(Entity)

	For ThisCaster.Shadow_Caster = Each Shadow_Caster

		If (ThisCaster\Caster = Entity) Or (ThisCaster\Receiver = Entity) 
			Delete ThisCaster
		EndIf	

	Next	

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function creates a shadow mesh and returns it's handle.
;
; Reciever = The entity to recieve the shadow.
; -------------------------------------------------------------------------------------------------------------------
Function Create_Shadow(Receiver, Shadow_X1#, Shadow_Z1#, Shadow_X2#, Shadow_Z2#, Shadow_Y#)

	; Get the cordinates of the lower left hand corner of the shadow.
	Shadow_Corner_X# = Shadow_X1#
	Shadow_Corner_Z# = Shadow_Z2# 

	Shadow_Scale# = Sqr((Shadow_X1#-Shadow_X2#)*(Shadow_X1#-Shadow_X2#))

	DebugLog &quot;S: &quot; + Str$(Shadow_Scale#)
	ShadowTris = 0

	; Create the mesh for the shadow, and give it a surface to add polygons to.
	MESH_Shadow = CreateMesh()
	SURFACE_Shadow = CreateSurface(MESH_Shadow)

	; Loop through all triangles in all surfaces of the reciever.
	Surfaces = CountSurfaces(Receiver)
	For LOOP_Surface = 1 To Surfaces

		Surface_Handle = GetSurface(Receiver, LOOP_Surface)

		Tris = CountTriangles(Surface_Handle)
		For LOOP_Tris = 0 To Tris-1

			Vertex_0 = TriangleVertex(Surface_Handle, LOOP_Tris, 0)
			Vertex_1 = TriangleVertex(Surface_Handle, LOOP_Tris, 1)
			Vertex_2 = TriangleVertex(Surface_Handle, LOOP_Tris, 2)
									
			; Check to see if the triangle is inside the shadow's bounding rectangle.
			;
			; This test works by seeing if all of a triangle's points are on a specific side of each side of the
			; rectangle.  The test is not 100% accurate... a very few triangles will pass the test but actually be
			; outside the region.  But we are concerned only with making sure we find all the triangles which ARE
			; in the region and cull the vast majority outside the region, so a little sloppiness in the test is
			; okay if that means it's really fast.
			Shadow = True

			Z0# = VertexZ#(Surface_Handle, Vertex_0)
			Z1# = VertexZ#(Surface_Handle, Vertex_1)
			Z2# = VertexZ#(Surface_Handle, Vertex_2)

			; Is polygon to north of shadow's bounding rectangle?
			If (Z0# &gt; Shadow_Z1#) And (Z1# &gt; Shadow_Z1#) And (Z2# &gt; Shadow_Z1#) 
				Shadow = False 
			Else	

				; Is polygon to south of shadow's bounding rectangle?
				If (Z0# &lt; Shadow_Z2#) And (Z1# &lt; Shadow_Z2#) And (Z2# &lt; Shadow_Z2#) 
					Shadow = False	
				Else
					
					X0# = VertexX#(Surface_Handle, Vertex_0)
					X1# = VertexX#(Surface_Handle, Vertex_1)
					X2# = VertexX#(Surface_Handle, Vertex_2)

					; Is polygon to west of shadow's bounding rectangle?
					If (X0# &lt; Shadow_X1#) And (X1# &lt; Shadow_X1#) And (X2# &lt; Shadow_X1#) 
						Shadow = False 
					Else

						; Is polygon to east of shadow's bounding rectangle?
						If (X0# &gt; Shadow_X2#) And (X1# &gt; Shadow_X2#) And (X2# &gt; Shadow_X2#) 
							Shadow = False 
						Else

							Y0# = VertexY#(Surface_Handle, Vertex_0)
							Y1# = VertexY#(Surface_Handle, Vertex_1)
							Y2# = VertexY#(Surface_Handle, Vertex_2)

							; Is shadow below the polygon?
							If (Shadow_Y# &lt; Y0#) And (Shadow_Y# &lt; Y1#) And (Shadow_Y# &lt; Y2#)
								Shadow = False
							Else
								
								NY0# = VertexNY#(Surface_Handle, Vertex_0) 
								NY1# = VertexNY#(Surface_Handle, Vertex_1) 
								NY2# = VertexNY#(Surface_Handle, Vertex_2)

								FaceNY# = NY0# + NY1# + NY2#								

								; Is polygon facing downwards?
								If (FaceNY# &lt; 0) Then
									Shadow = False
								Else
								
									If (FaceNY# = 0)
										Shadow = False
									EndIf	
									
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf	
			
			; If the triangle is inside the bounding box then add it to the mesh.
			; Note that shadow texture will be flipped top to bottom because of how UV coordinates are assigned to the vertices from the world coordinates.
			If Shadow = True

				Shadow_Vertex_0 = AddVertex(SURFACE_Shadow, X0#, Y0#, Z0#, (X0#-Shadow_Corner_X#)/Shadow_Scale#, (Z0#-Shadow_Corner_Z#)/Shadow_Scale#)
				Shadow_Vertex_1 = AddVertex(SURFACE_Shadow, X1#, Y1#, Z1#, (X1#-Shadow_Corner_X#)/Shadow_Scale#, (Z1#-Shadow_Corner_Z#)/Shadow_Scale#)
				Shadow_Vertex_2 = AddVertex(SURFACE_Shadow, X2#, Y2#, Z2#, (X2#-Shadow_Corner_X#)/Shadow_Scale#, (Z2#-Shadow_Corner_Z#)/Shadow_Scale#)

				; Adjust shadow brightness at each vertex according to vertex normal.				
					VC = (1.0-NY0#)^3*255.0
					If (VC &gt; 0) Then VertexColor SURFACE_Shadow, Shadow_Vertex_0, VC, VC, VC
	
					VC = (1.0-NY1#)^3*255.0
					If (VC &gt; 0) Then VertexColor SURFACE_Shadow, Shadow_Vertex_1, VC, VC, VC
				
					VC = (1.0-NY2#)^3*255.0
					If (VC &gt; 0) Then VertexColor SURFACE_Shadow, Shadow_Vertex_2, VC, VC, VC

				; Add the triangle to the shadow mesh.
					AddTriangle(SURFACE_Shadow, Shadow_Vertex_0, Shadow_Vertex_1, Shadow_Vertex_2)

				ShadowTris = ShadowTris + 1

			EndIf
			
		Next			
	
	Next

	Return MESH_Shadow

End Function
</pre> <br><br></td></tr></table><br>
<a name="102155"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chevron</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> do these functions work on terrains shaun? <br><br></td></tr></table><br>
<a name="102163"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Read a couple posts up, I answewered your question already. :-)<br><br>In short, it depends on what kind of terrain you're talking about. :-) <br><br></td></tr></table><br>
<a name="102165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh and one more thing on that terrain thing...<br><br>If you use an impostor mesh to create shadows for the terrain, then if you make the shadows autofade out at a certain distance then you can limit the error so that it wouldn't be as much of an issue.  The terrain is very detailed up close but not so detailed far off, so as long as you don't have the shaodws too far away they should match the countour of the terrain pretty closely.  And if you have a problem with the shadows dipping below the terrain you can move the impostor mesh's vertices up a little bit so that the shaodws get created higher up. <br><br></td></tr></table><br>
<a name="102179"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chevron</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry, missed that answer, thats as I thought, shame, but thanks for the code you have posted as it is sure to come useful for me in many other instances. I'll look into creating a duplicate mesh to create my effect, I can do it now but seem to be taking a big speed hit using vertex manipulation. <br><br></td></tr></table><br>
<a name="102199"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh you're trying to do a scrolling terrain type of thing and taking a speed hit from doing that?  You should just break your terrain up into chunks and fade the chunks out as they go out of range.  That would work better I think. <br><br></td></tr></table><br>
<a name="102237"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> New code!<br><br>I just made some changes to my code.  I optimized it a little bit more I think, though the addition I made probably slowed it down a bit so I'm not sure if I had a net gain or not.<br><br>The addition I made was to make it so that you can put the reciver ANYHWERE in the world, and you don't have to specially position it's vertices within the mesh to make the shadow code work.<br><br>This means the code is a lot simpler to use.<br><br>Use the arrow keys to move the reciver around.  The cube and the camera are fixed in location, though they could be moved as well.<br><br><pre class=code>

Graphics3D 640,480,16,2

SetBuffer BackBuffer()

Type Shadow_Caster
	Field Caster
	Field Receiver
	Field Texture
	Field Radius#
End Type


Type Shadow
	Field Mesh
End Type


.Main
	camera=CreateCamera()
	PositionEntity camera,0,100,-300
	
	light=CreateLight(2)
	PositionEntity light,0,200,0
	AmbientLight 100,100,100

	ground=CreateSphere()
	; Scale the mesh.  If you want to change the mesh's shape you have to scalemesh, not scaleentity.  
	; The vertices won't represent their position in space if you scaleentity.
	ScaleMesh ground,100,50,100
	; Update the normals because we scaled the mesh (newest versions of Blitz should not require this)
	UpdateNormals ground

	cube = CreateCube()
	ScaleEntity cube,20,20,20
	RotateEntity cube,30,50,70
	PositionEntity cube,0,150,0

	PointEntity camera,cube
		
	; Create texture of black square in white background
	shd=CreateTexture(256,256,48)  ; Flags = ClampU, ClampV
	TextureBlend shd, 3
	SetBuffer TextureBuffer(shd)
	ClsColor 255, 255, 255
	Cls
	Color 0,0,0
	; Must leave border of white around shadow!
	Rect 1,1,254,254,1
	SetBuffer BackBuffer()

	Cast_Shadow(cube, ground, shd, 20.0) 

	While KeyDown(1)=0

		If KeyDown(200) MoveEntity ground, 0, 0, 1
		If KeyDown(208) MoveEntity ground, 0, 0, -1
		If KeyDown(203) MoveEntity ground, -1, 0, 0
		If KeyDown(205) MoveEntity ground, 1, 0, 0

		Update_Shadows() 

		UpdateWorld
		RenderWorld
		Flip

	Wend


End


; -------------------------------------------------------------------------------------------------------------------
; This function sets up a new shadow caster/receiver pair.
;
; Caster   = Mesh to cast shadows.
; Receiver = Mesh to receive shadows.
; Texture  = Texture to use for shadow.  (Must have UV clamping enabled for proper operation!)
; Radius#  = Radius of the shadow.
; -------------------------------------------------------------------------------------------------------------------
Function Cast_Shadow(Caster, Receiver, Texture, Radius#)

	ThisCaster.Shadow_Caster = New Shadow_Caster	
	
	ThisCaster\Caster   = Caster
	ThisCaster\Receiver = Receiver
	ThisCaster\Texture  = Texture
	ThisCaster\Radius#  = Radius#

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all old shadows and creates a shadow mesh for each shadow casting object.
;
; Note:
; Shadows only need to be repositioned and recreated each time the scene is rendered, 
; not every time the physics are updated.
; -------------------------------------------------------------------------------------------------------------------
Function Update_Shadows()

	Delete_Shadows()

	For ThisCaster.Shadow_Caster = Each Shadow_Caster
		 
		Shadow_Center_X# = EntityX#(ThisCaster\Caster, True)
		Shadow_Center_Y# = EntityY#(ThisCaster\Caster, True)
		Shadow_Center_Z# = EntityZ#(ThisCaster\Caster, True)
		Shadow_Radius#   = ThisCaster\Radius#		
						
		ThisShadow.Shadow = New Shadow
		ThisShadow\Mesh = Create_Shadow(ThisCaster\Receiver, Shadow_Center_X#-Shadow_Radius#, Shadow_Center_Z#+Shadow_Radius#, Shadow_Center_X#+Shadow_Radius#, Shadow_Center_Z#-Shadow_Radius#, Shadow_Center_Y#)
	
		; full bright, use vertex colors, no fog.
		EntityFX ThisShadow\Mesh, 1+2+8

		; multiply blend mesh.
		EntityBlend ThisShadow\Mesh, 2 

		EntityTexture ThisShadow\Mesh, ThisCaster\Texture
				
	Next	
		
End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all active shadows.
; -------------------------------------------------------------------------------------------------------------------
Function Delete_Shadows()

	For ThisShadow.Shadow = Each Shadow
		FreeEntity ThisShadow\Mesh
		Delete ThisShadow.Shadow
	Next	

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function deletes all shadow casters/recievers which reference the specified entity.
;
; When you delete an entity which is casting or receiving a shadow, you must call this function so that the game
; does not crash from trying to reference an entity which does not exist.
; -------------------------------------------------------------------------------------------------------------------
Function Delete_Shadow_Caster(Entity)

	For ThisCaster.Shadow_Caster = Each Shadow_Caster

		If (ThisCaster\Caster = Entity) Or (ThisCaster\Receiver = Entity) 
			Delete ThisCaster
		EndIf	

	Next	

End Function


; -------------------------------------------------------------------------------------------------------------------
; This function creates a shadow mesh and returns it's handle.
;
; Reciever = The entity to recieve the shadow.
; -------------------------------------------------------------------------------------------------------------------
Function Create_Shadow(Receiver, Shadow_X1#, Shadow_Z1#, Shadow_X2#, Shadow_Z2#, Shadow_Y#)

	; Get the coordinates of the receiver in world space.
	Receiver_X# = EntityX#(Receiver, True)
	Receiver_Y# = EntityY#(Receiver, True)
	Receiver_Z# = EntityZ#(Receiver, True)

	; Get the coordinates of the lower left hand corner of the shadow in world space.
	Shadow_Corner_X# = Shadow_X1#
	Shadow_Corner_Z# = Shadow_Z2# 

	; Convert the shadow's coordinates into the reciever's vertex space.
	Shadow_X1# = Shadow_X1# - Receiver_X#
	Shadow_X2# = Shadow_X2# - Receiver_X#
	Shadow_Z1# = Shadow_Z1# - Receiver_Z#
	Shadow_Z2# = Shadow_Z2# - Receiver_Z#
	Shadow_Y#  = Shadow_Y#  - Receiver_Y#

	; Determine how large the shadow is.
	Shadow_Scale# = Sqr((Shadow_X1#-Shadow_X2#)*(Shadow_X1#-Shadow_X2#))

	ShadowTris = 0

	; Create the mesh for the shadow, and give it a surface to add polygons to.
	MESH_Shadow = CreateMesh()
	SURFACE_Shadow = CreateSurface(MESH_Shadow)

	; Loop through all triangles in all surfaces of the reciever.
	Surfaces = CountSurfaces(Receiver)
	For LOOP_Surface = 1 To Surfaces

		Surface_Handle = GetSurface(Receiver, LOOP_Surface)

		Tris = CountTriangles(Surface_Handle)
		For LOOP_Tris = 0 To Tris-1

			Vertex_0 = TriangleVertex(Surface_Handle, LOOP_Tris, 0)
			Vertex_1 = TriangleVertex(Surface_Handle, LOOP_Tris, 1)
			Vertex_2 = TriangleVertex(Surface_Handle, LOOP_Tris, 2)
									
			; Check to see if the triangle is inside the shadow's bounding rectangle.
			;
			; This test works by seeing if all of a triangle's points are on a specific side of each side of the
			; rectangle.  The test is not 100% accurate... a very few triangles will pass the test but actually be
			; outside the region.  But we are concerned only with making sure we find all the triangles which ARE
			; in the region and cull the vast majority outside the region, so a little sloppiness in the test is
			; okay if that means it's really fast.
			Shadow = True

			Z0# = VertexZ#(Surface_Handle, Vertex_0)
			Z1# = VertexZ#(Surface_Handle, Vertex_1)
			Z2# = VertexZ#(Surface_Handle, Vertex_2)

			; Is polygon to north of shadow's bounding rectangle?
			If (Z0# &gt; Shadow_Z1#) And (Z1# &gt; Shadow_Z1#) And (Z2# &gt; Shadow_Z1#) 
				Shadow = False 
			Else	

				; Is polygon to south of shadow's bounding rectangle?
				If (Z0# &lt; Shadow_Z2#) And (Z1# &lt; Shadow_Z2#) And (Z2# &lt; Shadow_Z2#) 
					Shadow = False	
				Else
					
					X0# = VertexX#(Surface_Handle, Vertex_0)
					X1# = VertexX#(Surface_Handle, Vertex_1)
					X2# = VertexX#(Surface_Handle, Vertex_2)

					; Is polygon to west of shadow's bounding rectangle?
					If (X0# &lt; Shadow_X1#) And (X1# &lt; Shadow_X1#) And (X2# &lt; Shadow_X1#) 
						Shadow = False 
					Else

						; Is polygon to east of shadow's bounding rectangle?
						If (X0# &gt; Shadow_X2#) And (X1# &gt; Shadow_X2#) And (X2# &gt; Shadow_X2#) 
							Shadow = False 
						Else

							Y0# = VertexY#(Surface_Handle, Vertex_0)
							Y1# = VertexY#(Surface_Handle, Vertex_1)
							Y2# = VertexY#(Surface_Handle, Vertex_2)

							; Is shadow below the polygon?
							If (Shadow_Y# &lt; Y0#) And (Shadow_Y# &lt; Y1#) And (Shadow_Y# &lt; Y2#)
								Shadow = False
							Else
								
								NY0# = VertexNY#(Surface_Handle, Vertex_0) 
								NY1# = VertexNY#(Surface_Handle, Vertex_1) 
								NY2# = VertexNY#(Surface_Handle, Vertex_2)

								FaceNY# = NY0# + NY1# + NY2#								

								; Is polygon facing downwards?
								If (FaceNY# &lt; 0) Then
									Shadow = False
								Else
								
									If (FaceNY# = 0)
										Shadow = False
									EndIf	
									
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf	
			
			; If the triangle is inside the bounding box then add it to the mesh.
			; Note that shadow texture will be flipped top to bottom because of how UV coordinates are assigned to the vertices from the world coordinates.
			If Shadow = True

				; Convert the coordinates of the vertices of the receiver from receiver space to world space.
				X0# = X0# + Receiver_X#
				X1# = X1# + Receiver_X#
				X2# = X2# + Receiver_X#
				Y0# = Y0# + Receiver_Y# + 0.1
				Y1# = Y1# + Receiver_Y#	+ 0.1
				Y2# = Y2# + Receiver_Y# + 0.1
				Z0# = Z0# + Receiver_Z#
				Z1# = Z1# + Receiver_Z#
				Z2# = Z2# + Receiver_Z#
				
				Shadow_Vertex_0 = AddVertex(SURFACE_Shadow, X0#, Y0#, Z0#, (X0#-Shadow_Corner_X#)/Shadow_Scale#, (Z0#-Shadow_Corner_Z#)/Shadow_Scale#)
				Shadow_Vertex_1 = AddVertex(SURFACE_Shadow, X1#, Y1#, Z1#, (X1#-Shadow_Corner_X#)/Shadow_Scale#, (Z1#-Shadow_Corner_Z#)/Shadow_Scale#)
				Shadow_Vertex_2 = AddVertex(SURFACE_Shadow, X2#, Y2#, Z2#, (X2#-Shadow_Corner_X#)/Shadow_Scale#, (Z2#-Shadow_Corner_Z#)/Shadow_Scale#)

				; Adjust shadow brightness at each vertex according to how much the vertex normal points down.
					;VC = (1.0-NY0#)^3*255.0
					VC = (1.0-NY0#)*(1.0-NY0#)*255.0
					VertexColor SURFACE_Shadow, Shadow_Vertex_0, VC, VC, VC
	
					VC = (1.0-NY1#)*(1.0-NY1#)*255.0
					VertexColor SURFACE_Shadow, Shadow_Vertex_1, VC, VC, VC
				
					VC = (1.0-NY2#)*(1.0-NY2#)*255.0
					VertexColor SURFACE_Shadow, Shadow_Vertex_2, VC, VC, VC

				; Add the triangle to the shadow mesh.
					AddTriangle(SURFACE_Shadow, Shadow_Vertex_0, Shadow_Vertex_1, Shadow_Vertex_2)

				ShadowTris = ShadowTris + 1

			EndIf
			
		Next			
	
	Next

	Return MESH_Shadow

End Function
</pre> <br><br></td></tr></table><br>
<a name="103091"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2002)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, thanks sswift! <br><br></td></tr></table><br>
<a name="263054"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Filax</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> IT work with animated objects ? <br><br></td></tr></table><br>
<a name="263061"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >maximo</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ressurrecion ;) <br><br></td></tr></table><br>
<a name="263260"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> "IT work with animated objects ? "<br><br>The one I posted in the Code Archives: yes, but it is a bit slow and it complicates the source. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
