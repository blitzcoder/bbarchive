<!DOCTYPE html><html lang="en" ><head ><title >Shadow volume</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Shadow volume</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Shadow volume</a><br><br>
<a name="653880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This demo is created for simulate the volume shadow<br><br>shipment the code in order to test it and hoping that you can help me to improve it<br>hello<br><br>excuse for the my english<br><br><a href="http://digilander.libero.it/enzo_light/shw.zip" target="_blank">http://digilander.libero.it/enzo_light/shw.zip</a><br><br><img src="http://digilander.libero.it/enzo_light/Image2.jpg"> <br><br></td></tr></table><br>
<a name="653885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Where to start....<br><br>1. You're referencing several include files which the rest of us don't have. [edit] I found one of them hidden in the above 'mess'.  See point 3 below.<br><br>2. You're loading models and textures that the rest of us don't have.<br><br>3. Your code is not indented and is nigh on impossible to read.  At LEAST put it in code tags.<br><br>People simply cannot be bothered messing about getting your code to run.  Post a downloadable demo with EXE/ZIP file, and possibly a screenshot as well, and you might get people interested. <br><br></td></tr></table><br>
<a name="653893"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> or better still codebox tags. <br><br></td></tr></table><br>
<a name="653900"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >IPete2</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vincenzo,<br><br>Use "[code] ...your code goes here... [\code]" to show your code - Oh but ignore the "  ".<br><br>IPete2. <br><br></td></tr></table><br>
<a name="653916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> or codebox, it's much better for lots of long code. <br><br></td></tr></table><br>
<a name="654262"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok!!!<br><br>Bye <br><br></td></tr></table><br>
<a name="654288"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ran the EXE - Memory Access Violation.<br><br>Your code gives the same error at "WritePixelFast X,Y,0", in Function ShadowVolumeCreateImage() <br><br></td></tr></table><br>
<a name="654401"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> ? <br><br></td></tr></table><br>
<a name="654514"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> you have got the same problem as i have...did u read my thread about stencil shadow volumes?<br>if not, this would be helpful at all :) <br><br></td></tr></table><br>
<a name="654768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> i ha a simulate stencil buffer :D<br>this is a very slow speed :(<br>help me for speed up<br><br>bye <br><br></td></tr></table><br>
<a name="654853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes, i will check the code out when i come back from my holiday trip in a few days... <br><br></td></tr></table><br>
<a name="654903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have changed the code function ShadowVolumeCreate3$ for speed up, imcrements 16 milliseconds<br><br>bye<br><br>post a new code<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;=======================
; Creazione volume
; forse si può fare ancora qualcosina!!
Function ShadowVolumeCreate3$( model, Normalize)
	;===&gt; 
	Local Result$=""
	Local Norm.Point3D=New Point3D 
	Local MidPoint.Point3D=New Point3D 
	Local NormLight.Point3D=New Point3D
	Local CNTFront=0
	Local CNTBack=0
	Local surf=0
	Local check1 = False
	Local check2 = False
	;===&gt; 
	; Cerchiamoci i vertici faccia vista verso la luce
	For n=1 To CountSurfaces(model) 
		;DebugLog "Testing surface "+n 
		surf = GetSurface(model,n) 
		dwNumFaces = CountTriangles(surf)-1 
		;dwNumVertex = CountVertices(surf)-1 
		;DebugLog "Limb "+EntityName(model)+", surface "+n+" contains "+dwNumVertex+" vertices." 
		For v=0 To dwNumFaces
			;Stop
			;===&gt; 
			vert0 = TriangleVertex(surf,v,0) : vert1 = TriangleVertex(surf,v,1) : vert2 = TriangleVertex(surf,v,2)
			;===&gt;
			;associamo le trasformazioni ai vertici
			TFormPoint VertexX( surf, vert0), VertexY( surf, vert0) , VertexZ( surf, vert0 ), model, 0
			sh_v1\x = TFormedX() : sh_v1\y = TFormedY() : sh_v1\z = TFormedZ()
			;===&gt; 
			;associamo le trasformazioni ai vertici
			TFormPoint VertexX( surf, vert1), VertexY( surf, vert1) , VertexZ( surf, vert1 ), model, 0
			sh_v2\x = TFormedX() : sh_v2\y = TFormedY() : sh_v2\z = TFormedZ() 
			;===&gt; 
			;associamo le trasformazioni ai vertici
			TFormPoint VertexX( surf, vert2), VertexY( surf, vert2) , VertexZ( surf, vert2 ), model, 0
			sh_v3\x = TFormedX() : sh_v3\y = TFormedY() : sh_v3\z = TFormedZ() 
			;===&gt; 
			Norm= CalcNormal(sh_v1,sh_v2,sh_v3)
			MidPoint=V_3Mid(sh_v1,sh_v2,sh_v3) 
			NormLight= V_3Dec(MidPoint,sh_light) 
			V_3Normalize(Norm) 
			V_3Normalize(NormLight) 
			Dot#=V_3Dot(Norm,NormLight) 
			;===&gt;
			; Ricerchiamo i vertici rivolti verso la luce e non e li memoriziamo
			If Dot#=&gt;0.1 And Dot#&lt;=1 Then
				;Stop
				;VertexColor surf,vert0,255,0,0
				;VertexColor surf,vert1,255,0,0
				;VertexColor surf,vert2,255,0,0
				;===&gt;
				; Edge 1
				;===&gt;
				ID_EdgeF.EdgeF = edgeFront(CNTFront)
				ID_EdgeF\Surf = surf
				ID_EdgeF\Triangle = v
				V_3Copy(ID_EdgeF\Point0,sh_v1)
				V_3Copy(ID_EdgeF\Point1,sh_v2)
				CNTFront=CNTFront+1
				;===&gt;
				; Edge 2
				;===&gt;
				ID_EdgeF.EdgeF = edgeFront(CNTFront)
				ID_EdgeF\Surf = surf
				ID_EdgeF\Triangle = v
				V_3Copy(ID_EdgeF\Point0,sh_v2)
				V_3Copy(ID_EdgeF\Point1,sh_v3)
				CNTFront=CNTFront+1
				;===&gt;
				; Edge 3Result$
				;===&gt;
				ID_EdgeF.EdgeF = edgeFront(CNTFront)
				ID_EdgeF\Surf = surf
				ID_EdgeF\Triangle = v
				V_3Copy(ID_EdgeF\Point0,sh_v3)
				V_3Copy(ID_EdgeF\Point1,sh_v1)
				CNTFront=CNTFront+1
				;===&gt; 
			EndIf
			;===&gt; 
		Next 
	Next
	Result$=Result$+" ==&gt; Facce Front : "+CNTFront+"  Facce Back : "+CNTBack
	;===&gt; 
	cntUguali=0
	cntDiverse=0

	;CNTFront=CNTFront-1 ;serve solo per eliminare x sottrazioni nel ciclo Più interno
	For a=0 To CNTFront
		;===&gt; 
		If (EdgeFront(a)\surf&gt;0) Then
			;===&gt;
			Diverso=True
			MemB=0
			;===&gt;
			; Inizializziamo i puntatori
			ID_EdgeFA.EdgeF = edgeFront(a) ; funziona come i puntatori del c++
			ID_P0.Point3d = ID_EdgeFA\Point0
			ID_P1.Point3d = ID_EdgeFA\Point1	; Puntiamo a Point - funziona come i puntatori del c++
			;===&gt;
			For b=a+1 To CNTFront	; Ottimizzazione 2°
				;===&gt;
				ID_EdgeFB.EdgeF = edgeFront(b)
				;===&gt;
				If (EdgeFront(b)\surf&gt;0) Then
					;non conviene quì fare il puntatore perche il tempo di acquisizione del puntatore.
					;ID_PB0.Point3d = ID_EdgeFB\Point0
					;ID_PB1.Point3d = ID_EdgeFB\Point1	; Puntiamo a Point - funziona come i puntatori del c++
					;===&gt;
					; verifichiamo che i vertici che stiamo visionando non appartengano allo stesso triangolo
					;===&gt;
					;Ulteriore verifica di diversità
					check1 = CheckVertex( ID_P0, ID_EdgeFB\Point0 )
					check2 = CheckVertex( ID_P1, ID_EdgeFB\Point1 )
						;===&gt;
					If  (check1 And check2)  Then
						;===&gt;
						MemB=b
						;===&gt;
						cntUguali = cntUguali + 1
						ID_EdgeFA\surf = 0
						ID_EdgeFB\surf = 0
						Diverso = False
						Exit
						;===&gt;
					Else
						;===&gt;
						check1 = CheckVertex(ID_P0,ID_EdgeFB\Point1)
						check2 = CheckVertex(ID_P1,ID_EdgeFB\Point0)
						;===&gt;
						If (check1 And check2) Then
							;===&gt;
							MemB=b
							;===&gt;
							cntUguali=cntUguali+1
							ID_EdgeFA\surf=0
							ID_EdgeFB\surf=0
							Diverso=False
							Exit
							;===&gt;
						EndIf
						;===&gt;
					EndIf
					;===&gt;
				EndIf
				;===&gt; 
			Next
			;===&gt;
			If  (Diverso=True) Then
				cntDiverse=cntDiverse+1
				;===&gt;
				; per debug
				;VertexColor EdgeFront(a)\surf,EdgeFront(a)\Vert0,255,0,255
				;VertexColor EdgeFront(a)\surf,EdgeFront(a)\Vert1,255,0,255
				;===&gt;
				ID_EdgeFA\Ray0 = V_3Dec( ID_P0, sh_light ) 
				V_3Normalize(ID_EdgeFA\Ray0 ) 
				ID_EdgeFA\Ray0 = V_3Inc( V_3Mul(ID_EdgeFA\Ray0, sh_lenght ), ID_P0 )
				;===&gt;
				ID_EdgeFA\Ray1 = V_3Dec( ID_P1,sh_light ) 
				V_3Normalize( ID_EdgeFA\Ray1 ) 
				ID_EdgeFA\Ray1 = V_3Inc( V_3Mul( ID_EdgeFA\Ray1, sh_lenght ), ID_P1 ) 
				;===&gt;
				va = AddVertex(SurfaceFront,  ID_P0\x, ID_P0\y, ID_P0\z ); 
				vb = AddVertex(SurfaceFront,  ID_EdgeFA\Ray0\x,   ID_EdgeFA\Ray0\y,   ID_EdgeFA\Ray0\z ); 
				vc = AddVertex(SurfaceFront,  ID_EdgeFA\Ray1\x,   ID_EdgeFA\Ray1\y,   ID_EdgeFA\Ray1\z); 
				vd = AddVertex(SurfaceFront,  ID_P1\x, ID_P1\y, ID_P1\z ); 
				;===&gt;
				AddTriangle(SurfaceFront, va, vb, vc); faccia 1/3 a 
				AddTriangle(SurfaceFront, va, vc, vd); faccia 1/3 b
				ID_EdgeFA\surf=0
				EdgeFront(MemB)\surf=0
				;===&gt;
			EndIf
		;===&gt;
		EndIf
		;===&gt;
	Next
	Result$=Result$+" Edges : "+cntDiverse
	;===&gt;
	.jump
	;UpdateNormals model
	For e=1 To CountChildren(Model) 
		limb = GetChild(model,e) 
		ShadowVolumeCreate3(limb, Normalize) 
	Next 
;	;===&gt;
	;Stop
	Return Result$
End Function 

</textarea> <br><br></td></tr></table><br>
<a name="656933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, i can help you(i have got the same problem as you!)<br><br>if you help me to find the function in that code which creates the volume and isolate it, i can help you to create a good stencil shadow system!<br><br>so where is the function which creates the volume?<br><br>edit: i found some things about the volume, but it is to slow for a real shadow system, and i can't really isolate the function from the rest(from the rubbish) <br><br></td></tr></table><br>
<a name="657160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> the function for create volume is the last function posted ShadowVolumeCreate3$(...)<br><br>this function is composed the 2 section<br><br>1° section:<br><br>acquire vertex transformed, selected vertex front side light, and defined edge triangle<br><br><br>2° section:<br><br>discard edge equal and create volume object other adge<br><br>the funtion is indipendent to the system<br><br>i have a idea.... InitShadow this function acquire vertex object first and precessed vertex(in the memory) post for volume, this system increment speed 2 - 10%<br><br>the very problem is generate ShadowVolumeCreateImage this funcion create slow speed for 2 read pixel(back and front face object volume) and 1 write pixel, this function simulate stencil<br><br>congratulation!! the your system render is very good speed<br><br>excuse  for the my english<br><br>Thank's for all bye <br><br></td></tr></table><br>
<a name="657170"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> but why is this thingy so slowly?<br>i think it is thew volume create function which is so slowly... so i cannot use it for my system sry :( <br><br></td></tr></table><br>
<a name="657233"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> ?<br><br>test the your system disabled the creation volume or system simulate stencil <br><br></td></tr></table><br>
<a name="657295"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, i found the function which lames all down, now i'm making a system out of this... if it works(IF IT WORKS) i will send it to u :)<br><br>edit: your source is 1200 lines large. i'm modifying it, and now it's only 250 lines long, how could this be?? - half of ypur code is rubish! <br><br></td></tr></table><br>
<a name="657300"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> i send a link new version simplex<br><br>;)<br><br>i have divide common and shadow<br><br>digilander.libero.it/enzo_light/shw01.zip <br><br></td></tr></table><br>
<a name="657309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> there is nothing changed, but i'll try to make the best of both :) <br><br></td></tr></table><br>
<a name="657323"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> i search the new alghoritm for generate silhouette bye <br><br></td></tr></table><br>
<a name="657439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have modifyed you one up to this:<br><br><pre class=code>Graphics3D 1024, 768, 32, 2
SetBuffer BackBuffer()

;Globs
Global sh_v1.Point3D, sh_v2.Point3D, sh_v3.Point3D, sh_nv1.Point3D, sh_nv2.Point3D, sh_nv3.Point3D, sh_vect1.Point3D, sh_vect2.Point3D, sh_vect3.Point3D, sh_light.Point3D, sh_lenght.Point3D, sh_normal.Point3D, sh_NCamera.Point3D
Global VolumeMesh, VolumeSurface
Dim Edge.Edge(65000)

;Camera
Cam = CreateCamera()

;Shadows
InitShadows()

;Floor
c = CreateCube()
ScaleEntity c, 10, 1, 10
PositionEntity c, 0, -5, 10
EntityColor c, 0, 255, 0

;Caster
Cube = CreateSphere()
PositionEntity Cube, -1.5, 0, 10
Cube2 = CreateCube()
PositionEntity Cube2, 1.5, 0, 10

;Light
Light = CreateLight()
PositionEntity Light, 0, 5, 10

While Not KeyHit(1)
	ms = ms + 1
	PointEntity Light, Cube
	TurnEntity Cube, 1, .5, 1.5
	TurnEntity Cube2, 1, .5, 1.5
	ResetShadowVolume()
	ShadowVolume(Cube, Light)
	ShadowVolume(Cube2, Light)
	RenderWorld
	Flip
Wend
FreeShadows()
End








;Types
Type Point3D
	Field x#, y#, z#
End Type
Type Edge
	Field Surf, Triangle
	Field Point0.Point3D, Point1.Point3D, Ray0.Point3D, Ray1.Point3D
End Type

Function InitShadows()
;Volume mesh
VolumeMesh = CreateMesh()
VolumeSurface = CreateSurface(VolumeMesh)
EntityAlpha VolumeMesh, .5
EntityColor VolumeMesh, 255, 0, 0
EntityFX VolumeMesh, 17
;Edges
For a = 0 To 65000
	Edge.Edge(a) = New Edge
	Edge(a)\Point0.Point3D = New Point3D
	Edge(a)\Point1.Point3D = New Point3D
	Edge(a)\Ray0.Point3D = New Point3D
	Edge(a)\Ray1.Point3D = New Point3D
Next
;Points
sh_v1.Point3D = New Point3D
sh_v2.Point3D = New Point3D
sh_v3.Point3D = New Point3D
sh_nv1.Point3D = New Point3D
sh_nv2.Point3D = New Point3D
sh_nv3.Point3D = New Point3D
sh_vect1.Point3D = New Point3D
sh_vect2.Point3D = New Point3D
sh_vect3.Point3D = New Point3D
sh_light.Point3D = New Point3D
sh_lenght.Point3D = New Point3D
sh_normal.Point3D = New Point3D
sh_NCamera.Point3D = New Point3D
End Function

Function FreeShadows()
If VolumeMesh Then FreeEntity VolumeMesh
Delete Each Point3D
Delete Each Edge
End Function

Function V3_Inc.Point3D(val1.Point3D, val2.Point3D)
val1\x = val1\x + val2\x
val1\y = val1\y + val2\y
val1\z = val1\z + val2\z
Return val1
End Function

Function V3_Dec.Point3D(val1.Point3D, val2.Point3D, val3.Point3D)
val3\x = val1\x - val2\x
val3\y = val1\y - val2\y
val3\z = val1\z - val2\z
End Function

Function V3_Mul.Point3D(val1.Point3D, val2.Point3D)
val1\x = val1\x * val2\x
val1\y = val1\y * val2\y
val1\z = val1\z * val2\z
Return val1
End Function

Function V3_Copy(a.Point3D, b.Point3D)
a\x# = b\x#
a\y# = b\y#
a\z# = b\z#
End Function

Function V3_Normalize(val.Point3D)
do# = 1.0 / Float(Sqr(val\x ^ 2 + val\y ^ 2 + val\z ^ 2))
val\x = val\x * do
val\y = val\y * do
val\z = val\z * do
End Function

Function V3_CheckVertex(a.Point3D, b.Point3D)
If a\x = b\x And a\y = b\y And a\z = b\z Then Return True Else Return False
End Function

Function ResetShadowVolume()
ClearSurface VolumeSurface
End Function

Function ShadowVolume(model, Light)
sh_light\x = EntityX(Light)
sh_light\y = EntityY(Light)
sh_light\z = EntityZ(Light)
sh_lenght\x = 1000
sh_lenght\y = 1000
sh_lenght\z = 1000
Norm.Point3D = New Point3D
MidPoint.Point3D = New Point3D
NormLight.Point3D = New Point3D
For n = 1 To CountSurfaces(model)
	surf = GetSurface(model, n)
	dwNumFaces = CountTriangles(surf) - 1
	For v = 0 To dwNumFaces
		vert0 = TriangleVertex(surf, v, 0)
		vert1 = TriangleVertex(surf, v, 1)
		vert2 = TriangleVertex(surf, v, 2)
		TFormPoint VertexX(surf, vert0), VertexY(surf, vert0), VertexZ(surf, vert0), model, 0
		sh_v1\x = TFormedX()
		sh_v1\y = TFormedY()
		sh_v1\z = TFormedZ()
		TFormPoint VertexX(surf, vert1), VertexY(surf, vert1), VertexZ(surf, vert1), model, 0
		sh_v2\x = TFormedX()
		sh_v2\y = TFormedY()
		sh_v2\z = TFormedZ()
		TFormPoint VertexX(surf, vert2), VertexY(surf, vert2), VertexZ(surf, vert2), model, 0
		sh_v3\x = TFormedX()
		sh_v3\y = TFormedY()
		sh_v3\z = TFormedZ()
		aa.Point3D = New Point3D
		bb.Point3D = New Point3D
		V3_Dec(sh_v3, sh_v2, aa.Point3D)
		V3_Dec(sh_v2, sh_v1, bb.Point3D)
		ax# = aa\y# * bb\z# - aa\z# * bb\y#
		ay# = aa\z# * bb\x# - aa\x# * bb\z#
		az# = aa\x# * bb\y# - aa\y# * bb\x#
		Norm\x# = ax#
		Norm\y# = ay#
		Norm\z# = az#
		Delete aa
		Delete bb
		MidPoint\x = (sh_v1\x# + sh_v2\x# + sh_v3\x) / 3
		MidPoint\y = (sh_v1\y# + sh_v2\y# + sh_v3\y) / 3
		MidPoint\z = (sh_v1\z# + sh_v2\z# + sh_v3\z) / 3
		V3_Dec(MidPoint, sh_light, NormLight)
		V3_Normalize(Norm)
		V3_Normalize(NormLight)
		Dot# = Norm\x# * NormLight\x# + Norm\y# * NormLight\y# + Norm\z# * NormLight\z#
		If Dot# =&gt; 0 And Dot# &lt;= 1 Then
			ID_EdgeF.Edge = Edge(CNTFront)
			ID_EdgeF\Surf = surf
			ID_EdgeF\Triangle = v
			V3_Copy(ID_EdgeF\Point0, sh_v1)
			V3_Copy(ID_EdgeF\Point1, sh_v2)
			CNTFront = CNTFront + 1
			ID_EdgeF.Edge = Edge(CNTFront)
			ID_EdgeF\Surf = surf
			ID_EdgeF\Triangle = v
			V3_Copy(ID_EdgeF\Point0, sh_v2)
			V3_Copy(ID_EdgeF\Point1, sh_v3)
			CNTFront = CNTFront + 1
			ID_EdgeF.Edge = Edge(CNTFront)
			ID_EdgeF\Surf = surf
			ID_EdgeF\Triangle = v
			V3_Copy(ID_EdgeF\Point0, sh_v3)
			V3_Copy(ID_EdgeF\Point1, sh_v1)
			CNTFront = CNTFront + 1
		EndIf
	Next
Next
cntUguali = 0
cntDiverse = 0
For a = 0 To CNTFront
	If Edge(a)\surf &gt; 0 Then
		Diverso = True
		MemB = 0
		ID_EdgeFA.Edge = Edge(a)
		ID_P0.Point3d = ID_EdgeFA\Point0
		ID_P1.Point3d = ID_EdgeFA\Point1
		For b = a + 1 To CNTFront
			ID_EdgeFB.Edge = Edge(b)
			If Edge(b)\surf &gt; 0 Then
				check1 = V3_CheckVertex(ID_P0, ID_EdgeFB\Point0)
				check2 = V3_CheckVertex(ID_P1, ID_EdgeFB\Point1)
				If check1 And check2 Then
					MemB = b
					cntUguali = cntUguali + 1
					ID_EdgeFA\surf = 0
					ID_EdgeFB\surf = 0
					Diverso = False
					Exit
				Else
					check1 = V3_CheckVertex(ID_P0, ID_EdgeFB\Point1)
					check2 = V3_CheckVertex(ID_P1, ID_EdgeFB\Point0)
					If check1 And check2 Then
						MemB = b
						cntUguali = cntUguali + 1
						ID_EdgeFA\surf = 0
						ID_EdgeFB\surf = 0
						Diverso = False
						Exit
					EndIf
				EndIf
			EndIf
		Next
		If Diverso Then
			cntDiverse = cntDiverse + 1
			V3_Dec(ID_P0, sh_light, ID_EdgeFA\Ray0)
			V3_Normalize(ID_EdgeFA\Ray0)
			ID_EdgeFA\Ray0 = V3_Inc(V3_Mul(ID_EdgeFA\Ray0, sh_lenght), ID_P0)
			V3_Dec(ID_P1, sh_light, ID_EdgeFA\Ray1)
			V3_Normalize(ID_EdgeFA\Ray1)
			ID_EdgeFA\Ray1 = V3_Inc(V3_Mul(ID_EdgeFA\Ray1, sh_lenght), ID_P1)
			va = AddVertex(VolumeSurface, ID_P0\x, ID_P0\y, ID_P0\z)
			vb = AddVertex(VolumeSurface, ID_EdgeFA\Ray1\x, ID_EdgeFA\Ray1\y, ID_EdgeFA\Ray1\z)
			AddTriangle(VolumeSurface, va, AddVertex(VolumeSurface, ID_EdgeFA\Ray0\x, ID_EdgeFA\Ray0\y, ID_EdgeFA\Ray0\z), vb)
			AddTriangle(VolumeSurface, va, vb, AddVertex(VolumeSurface, ID_P1\x, ID_P1\y, ID_P1\z))
			ID_EdgeFA\surf = 0
			Edge(MemB)\surf = 0
		EndIf
	EndIf
Next
Delete Norm.Point3D
Delete MidPoint.Point3D
Delete NormLight.Point3D
End Function</pre> <br><br></td></tr></table><br>
<a name="657546"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Devils Child .. now that looks like it's supposed to ..  Nice work :)  You could get more raw speed by not calling your vector functions in the shadowvolume routine.  Also, you create and delete Norm / MidPoint/ NormLight many times - just make them global and don't delete them so that they can be reused.  Also in the normalize routine .. it's quicker to use x*x than using x^2.<br><br>I may have a play around and see if I can be speeded up.<br><br>So what's the next step?<br><br>Stevie <br><br></td></tr></table><br>
<a name="657784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I Devils Child <br><br>the your system not have change result, the problem is  generate silhouette, i have a solution,  have a studi the system for fast silhouette this methods is based for adjacent triangle and a 1 for next (not nested)for generate sil..  I am creating this <br><br><br>bye <br><br></td></tr></table><br>
<a name="658460"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I all<br>this is a link for new systems generate silouette for blitz,<br>is not complete and optimized for my time is little, in order to complete servants the management fines object in sketched part<br><br>the new optimize are "simulate stencil buffer" is very slow<br><br>test this software <br><br><a href="http://digilander.libero.it/enzo_light/shw03.zip" target="_blank">http://digilander.libero.it/enzo_light/shw03.zip</a><br><br>bye <br><br></td></tr></table><br>
<a name="658465"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> is the createvolume function of shw03.zip faster than the old one? <br><br></td></tr></table><br>
<a name="658472"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> very very fast!!!<br><br>i have create a new system for blitz Edge to edge remember?<br><br>if disable simulate stencil buffer and verify the difference<br><br>the include is changed<br><br>:) <br><br></td></tr></table><br>
<a name="658547"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> there is a little bug... if i create a cylinder or a cone, the program crashes... <br><br></td></tr></table><br>
<a name="658607"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok lock the program thanks <br>bye <br><br></td></tr></table><br>
<a name="659017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> The Bug is resolved<br><br>post the code<br>Bye :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">v
;======================================= 
;--------------------------------------- 
; 
;   Name file: Shadow_Include
; 
;   Programmatore: 
;      Caldarulo Vincenzo (Eye &amp; Light) 
;   Descrizione: 
;			Creazione dei volumi d'ombra
; 
;--------------------------------------- 
;======================================= 
Include"commontype.bb"
;======================================= 
;--------------------------------------- 
; Variabili ShadowVolume 
;--------------------------------------- 
;======================================= 
;===&gt;
Type EdgeToEdge
	Field IdModel
	Field Surfaces.ETE_Surface
End Type
;===&gt;
Type ETE_Surface
	Field IdSurface
	Field cntTriangle
	Field IdTriangle.ETE_Triangle[ETE_MaxTriang]
End Type
;===&gt;
Type ETE_Triangle
	Field Normal.Point3D
	Field a.Point3D
	Field b.Point3D
	Field c.Point3D
	Field Triangle
	Field ATriangle
	Field BTriangle
	Field CTriangle
End Type
;===&gt;
;======================================= 
;===&gt;
Const SHWTexSize = 128; Parametro di regolazione Ombra
Const sh_level# = 0.1
Const ETE_MaxTriang=15000
Const SHWL3D = 20000
;===&gt;
;======================================= 
;===&gt;
Dim BG1(SHWTexSize,SHWTexSize)
Dim BG2(SHWTexSize,SHWTexSize)
Dim  TriangleClone.ETE_Triangle(ETE_MaxTriang)
;===&gt;
;======================================= 
;===&gt;
Global Scena = CreatePivot(); CreateSphere(5)
Global MeshFront = CreateMesh(); 
Global SurfaceFront = CreateSurface(MeshFront); 
EntityAlpha MeshFront, sh_level 
EntityColor MeshFront, 255,0,0 
EntityFX MeshFront,1;4
EntityBlend MeshFront,3

Global cntLine3D=0
Dim Line3DAX#(SHWL3D)
Dim Line3DAY#(SHWL3D)
Dim Line3DAZ#(SHWL3D)
Dim Line3DBX#(SHWL3D)
Dim Line3DBY#(SHWL3D)
Dim Line3DBZ#(SHWL3D)
;===&gt;
;Creiamo il piano che proietterà l'ombra
;===&gt;
Global SHWSpriteFront=CreateSprite()
SpriteViewMode SHWSpriteFront,1
Global ShwTex1=CreateTexture(SHWTexSize,SHWTexSize,1+2+8+256+512)
EntityTexture SHWSpriteFront,ShwTex1
EntityFX SHWSpriteFront,1
EntityParent SHWSpriteFront,Camera
HideEntity SHWSpriteFront
;===&gt;
Global sh_v1.Point3D			= New Point3D 
Global sh_v2.Point3D			= New Point3D 
Global sh_v3.Point3D			= New Point3D 
Global sh_light.Point3D		= New Point3D 
Global sh_lenght.Point3D	= New Point3D 
;===&gt;
Global SHW_ETE_Object.EdgeToEdge
;===&gt;
;======================================= 
;===&gt;
;=======================
; 
Function CheckVertex%(a.Point3D,b.Point3D)
	If (a\x=b\x)And(a\y=b\y)And(a\z=b\z) Then
		Return True 
	Else
		Return False 
	EndIf 
End Function 

;======================================================================= 
;======================================================================= 
; Shadow Volume For silhouette Method Edge to Edge
;======================================================================= 
;======================================================================= 
;======================= 
; Inizialize Object Shadow
Function SHW_Init()

	;===&gt;
	; Search surface and triangle object
	For n=0 To ETE_MaxTriang
	
		TriangleClone.ETE_Triangle(n) = New ETE_Triangle
		
		TriangleClone(n)\Normal.Point3D = New Point3D
		TriangleClone(n)\a.Point3D = New Point3D
		TriangleClone(n)\b.Point3D = New Point3D
		TriangleClone(n)\c.Point3D = New Point3D
	Next
End Function 

;=======================
; Inizialize Object Shadow
Function SHW_InitObject(model)

	Norm.Point3D = New Point3D
	
	SHW_ETE_Object.EdgeToEdge = New EdgeToEdge
	SHW_ETE_Object\IdModel = model
	;===&gt;
	; Search surface and triangle object
	For n=1 To CountSurfaces(model)
		;===&gt;
		surf = GetSurface(model,n)
		NumFaces = CountTriangles(surf)-1
		;===&gt;
		SHW_ETE_Object\Surfaces.ETE_Surface = New  ETE_Surface
		IdSurface.ETE_Surface = SHW_ETE_Object\Surfaces
		;===&gt;
		IdSurface\IdSurface = surf
		IdSurface\cntTriangle = NumFaces
		For v=0 To NumFaces
			;===&gt;
			IdSurface\IdTriangle.ETE_Triangle[v] = New ETE_Triangle
			IdTriang.ETE_Triangle = IdSurface\IdTriangle[v]
			;===&gt;
			IdTriang\normal.Point3D = New Point3D
			IdTriang\a.Point3D = New Point3D
			IdTriang\b.Point3D = New Point3D
			IdTriang\c.Point3D = New Point3D
			;===&gt; 
			vert0 = TriangleVertex(surf,v,0)
			vert1 = TriangleVertex(surf,v,1)
			vert2 = TriangleVertex(surf,v,2)
			;===&gt;
			IdTriang\a\x = VertexX( surf, vert0) : IdTriang\a\y = VertexY( surf, vert0) : IdTriang\a\z = VertexZ( surf, vert0)
			;===&gt; 
			IdTriang\b\x = VertexX( surf, vert1) : IdTriang\b\y = VertexY( surf, vert1) : IdTriang\b\z = VertexZ( surf, vert1)
			;===&gt; 
			IdTriang\c\x = VertexX( surf, vert2) : IdTriang\c\y = VertexY( surf, vert2) : IdTriang\c\z = VertexZ( surf, vert2)
			;===&gt;
			IdTriang\Normal= CalcNormal( IdTriang\a, IdTriang\b, IdTriang\c)
			IdTriang\Normal = V_3Normalize(IdTriang\Normal) 
			;===&gt;
			IdTriang\Triangle = v
			IdTriang\ATriangle = -1
			IdTriang\BTriangle = -1
			IdTriang\CTriangle = -1
			;===&gt;
		Next 
		;===&gt;
		; Search adjacent triangle
		For a=0 To IdSurface\cntTriangle
			;===&gt;
			ATriang.ETE_Triangle = IdSurface\IdTriangle[a]
			;===&gt;
			For b=a+1 To IdSurface\cntTriangle
				If a=b Then Goto jump
				;===&gt;
				BTriang.ETE_Triangle = IdSurface\IdTriangle[b]
				;*********************************************************************
				; SIDE " A "
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato A del 2° Triangolo)
				check1 = CheckVertex( ATriang\a, BTriang\a )
				check2 = CheckVertex( ATriang\b, BTriang\b )
				check3 = CheckVertex( ATriang\a, BTriang\b )
				check4 = CheckVertex( ATriang\b, BTriang\a )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\ATriangle = b
					BTriang\ATriangle = a
					Goto SIDEA
					;Stop
				EndIf 
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato B del 2° Triangolo)
				check1 = CheckVertex( ATriang\a, BTriang\b )
				check2 = CheckVertex( ATriang\b, BTriang\c )
				check3 = CheckVertex( ATriang\a, BTriang\c )
				check4 = CheckVertex( ATriang\b, BTriang\b )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\ATriangle = b
					BTriang\BTriangle = a
					Goto SIDEA
					;Stop
				EndIf
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato C del 2° Triangolo)
				check1 = CheckVertex( ATriang\a, BTriang\c )
				check2 = CheckVertex( ATriang\b, BTriang\a )
				check3 = CheckVertex( ATriang\a, BTriang\a )
				check4 = CheckVertex( ATriang\b, BTriang\c )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\ATriangle = b
					BTriang\CTriangle = a
					;Stop
				EndIf
				.SIDEA
				;===&gt;
				;*********************************************************************
				; SIDE " B "
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato A del 2° Triangolo)
				check1 = CheckVertex( ATriang\b, BTriang\a )
				check2 = CheckVertex( ATriang\c, BTriang\b )
				check3 = CheckVertex( ATriang\b, BTriang\b )
				check4 = CheckVertex( ATriang\c, BTriang\a )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\BTriangle = b
					BTriang\ATriangle = a
					Goto SIDEB
					;Stop
				EndIf 
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato B del 2° Triangolo)
				check1 = CheckVertex( ATriang\b, BTriang\b )
				check2 = CheckVertex( ATriang\c, BTriang\c )
				check3 = CheckVertex( ATriang\b, BTriang\c )
				check4 = CheckVertex( ATriang\c, BTriang\b )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\BTriangle = b
					BTriang\BTriangle = a
					Goto SIDEB
					;Stop
				EndIf
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato C del 2° Triangolo)
				check1 = CheckVertex( ATriang\b, BTriang\c )
				check2 = CheckVertex( ATriang\c, BTriang\a )
				check3 = CheckVertex( ATriang\b, BTriang\a )
				check4 = CheckVertex( ATriang\c, BTriang\c )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\BTriangle = b
					BTriang\CTriangle = a
					;Stop
				EndIf
				.SIDEB
			;===&gt;
				;*********************************************************************
				; SIDE " C "
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato A del 2° Triangolo)
				check1 = CheckVertex( ATriang\c, BTriang\a )
				check2 = CheckVertex( ATriang\a, BTriang\b )
				check3 = CheckVertex( ATriang\c, BTriang\b )
				check4 = CheckVertex( ATriang\a, BTriang\a )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\CTriangle = b
					BTriang\ATriangle = a
					Goto SIDEC
					;Stop
				EndIf 
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato B del 2° Triangolo)
				check1 = CheckVertex( ATriang\c, BTriang\b )
				check2 = CheckVertex( ATriang\a, BTriang\c )
				check3 = CheckVertex( ATriang\c, BTriang\c )
				check4 = CheckVertex( ATriang\a, BTriang\b )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\CTriangle = b
					BTriang\BTriangle = a
					Goto SIDEC
					;Stop
				EndIf
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato C del 2° Triangolo)
				check1 = CheckVertex( ATriang\c, BTriang\c )
				check2 = CheckVertex( ATriang\a, BTriang\a )
				check3 = CheckVertex( ATriang\c, BTriang\a )
				check4 = CheckVertex( ATriang\a, BTriang\c )
				;===&gt;
				If  (check1 And check2) Or (check3 And check4) Then
					ATriang\CTriangle = b
					BTriang\CTriangle = a
					;Stop
				EndIf
				.SIDEC
				;===&gt;
				.jump
				;===&gt;
			Next
			;===&gt;
		Next 
		;===&gt;
	Next
	;===&gt;
	Delete Norm
	;===&gt;
End Function 

;=======================
; Inizialize Object Shadow
Function CloneListTriangle(dst.ETE_Triangle,src.ETE_Triangle)
	;===&gt;
	V_3Copy( dst\Normal, src\Normal)
	V_3Copy( dst\a, src\a)
	V_3Copy( dst\b, src\b)
	V_3Copy( dst\c, src\c)
	dst\Triangle = src\Triangle
	dst\ATriangle = src\ATriangle
	dst\BTriangle = src\BTriangle
	dst\CTriangle = src\CTriangle
	;===&gt;
End Function 
;=======================
Function ResetShadowVolume() 
   ClearSurface SurfaceFront; 
End Function 
;======================= 
; Shadows Volume start 
Function ShadowVolume$( Light, LightLenght )
	ResetShadowVolume()
	;===&gt;
	sh_light\x = EntityX(Light) : sh_light\y = EntityY(Light) : sh_light\z = EntityZ(Light) 
	sh_lenght\x = LightLenght 
	sh_lenght\y = LightLenght 
	sh_lenght\z = LightLenght 
	;===&gt;
	cntLine3D=0
	;===&gt;
	result$=ShadowVolumeCreate3()
	;===&gt;
	ShadowVolumeCreateImage()
	;===&gt;
	Return result$
	;===&gt;
End Function 
;=======================
; Creazione immagine ombra
; ottimizzazione completata 
Function ShadowVolumeCreateImage()
	;===&gt;
	; Fase 1
	;===&gt;
	Local CaptureX = TextureWidth(ShwTex1)
	Local CaptureY = TextureHeight(ShwTex1)
	CameraViewport Camera,0,0,CaptureX, CaptureY
	;===&gt;
	HideEntity SHWSpriteFront 
	;===&gt;
	HideEntity MeshFront 
	ShowEntity Scena
	RenderWorld
	CameraClsMode camera,True,False
	;===&gt;
	HideEntity Scena
	;per ottimizzare renderizzo prima il back
	ShowEntity MeshFront
	FlipMesh MeshFront ;Visualizzo il back face
	;preparo in back face
	EntityColor MeshFront,10,10,10
	RenderWorld
	;===&gt;
	; Front Ground 1
	LockBuffer()
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			bg2(x,y)=ReadPixelFast(x,y)
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;proparo in front face
	FlipMesh MeshFront
	RenderWorld
	;===&gt;
	; Back Ground 2
	LockBuffer()
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			bg1(x,y)=ReadPixelFast(x,y)
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;===&gt;
	HideEntity MeshFront
	;===&gt;
	;Ripristiniamo tutto prima di riprendere le normali attività
	;===&gt;
	; Filter
	SetBuffer TextureBuffer(ShwTex1)
	LockBuffer()
	ShadowColor=(128 Shl 24)
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			Val=(Bg1(x,y)-Bg2(x,y))
			;Val=Abs(Bg1(x,y)-Bg2(x,y))
			If (Val)&gt;0 Then
				WritePixelFast x,y,ShadowColor
			Else
				WritePixelFast x,y,0
			EndIf
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;===&gt;
	CameraViewport Camera,0,0,GraphicsWidth(), GraphicsHeight()
	CameraClsMode camera,True,True
	;===&gt;
	ShowEntity SHWSpriteFront 
	ShowEntity Scena
	;===&gt;
	SetBuffer BackBuffer()
	Cls

	PositionEntity SHWSpriteFront,EntityX(Camera),EntityY(Camera),EntityZ(Camera)+1.001
	;===&gt;
End Function 
;=======================
; Creazione volume
; forse si può fare ancora qualcosina!!
Function ShadowVolumeCreate3$()
	;===&gt; 
	Local Result$ = ""
	Local Norm.Point3D = New Point3D 
	Local MidPoint.Point3D = New Point3D 
	Local NormLight.Point3D = New Point3D
	Local RayA.Point3D = New Point3D 
	Local RayB.Point3D = New Point3D 
	Local RayC.Point3D = New Point3D 
	;===&gt; 
	Local CNTFront=0
	Local CNTBack=0
	Local surf=0
	Local check1 = -1
	Local check2 = -1
	Local check3 = -1
	;===&gt; 
	t0=MilliSecs()
	;===&gt;
	; Cerchiamoci i vertici faccia vista verso la luce
	For SHW_ETE_Object\surfaces.ETE_Surface = Each ETE_Surface
		;===&gt;
		surf = SHW_ETE_Object\surfaces\IdSurface
		dwNumFaces = SHW_ETE_Object\surfaces\cntTriangle 
		;===&gt;
		For v=0 To dwNumFaces
			;===&gt;
			IdTriang.ETE_Triangle = SHW_ETE_Object\Surfaces\IdTriangle[v]
			CloneListTriangle(TriangleClone(v),IdTriang)
			IdCLT.ETE_Triangle = TriangleClone(v)
			;===&gt;
			;associamo le trasformazioni ai vertici
			TFormPoint IdCLT\a\x, IdCLT\a\y , IdCLT\a\z, SHW_ETE_Object\IdModel, 0
			sh_v1\x = TFormedX() : sh_v1\y = TFormedY() : sh_v1\z = TFormedZ()
			;===&gt; 
			TFormPoint IdCLT\b\x, IdCLT\b\y , IdCLT\b\z, SHW_ETE_Object\IdModel, 0
			sh_v2\x = TFormedX() : sh_v2\y = TFormedY() : sh_v2\z = TFormedZ() 
			;===&gt; 
			TFormPoint IdCLT\c\x, IdCLT\c\y , IdCLT\c\z, SHW_ETE_Object\IdModel, 0
			sh_v3\x = TFormedX() : sh_v3\y = TFormedY() : sh_v3\z = TFormedZ() 
			;===&gt;
			TFormNormal  IdCLT\Normal\x, IdCLT\Normal\y , IdCLT\Normal\z, SHW_ETE_Object\IdModel, 0
			Norm\x = TFormedX() : Norm\y = TFormedY() : Norm\z = TFormedZ() 
			MidPoint = V_3Mid(sh_v1,sh_v2,sh_v3) 
			NormLight = V_3Dec(MidPoint,sh_light) 
			NormLight  = V_3Normalize(NormLight) 
			Dot# = V_3Dot( Norm, NormLight ) 
			;===&gt;
			; Marchiamo i vertici non rivolti verso la luce
			If Dot#=&gt;0.1 Then
				;===&gt;
				V_3Copy( IdCLT\a, sh_v1 )
				V_3Copy( IdCLT\b, sh_v2 )
				V_3Copy( IdCLT\c, sh_v3 )
				CNTFront=CNTFront+1
				;===&gt;
			Else
				;===&gt;
				IdCLT\Triangle  = -1
				CNTBack=CNTBack+1
				;===&gt;
			EndIf
			;===&gt; 
		Next
		;===&gt;
		; Ora creiamo il volume
		;Stop
		For v=0 To dwNumFaces
			;===&gt;
			IdCLT.ETE_Triangle = TriangleClone(v)
			;===&gt;
			; Saltiamo il triangolo se è a -1
			If IdCLT\Triangle&lt;0 Then Goto continue
			;===&gt;
			If IdCLT\ATriangle&gt;=0 Then check1 = TriangleClone(IdCLT\ATriangle)\Triangle Else check1 = -1
			If IdCLT\BTriangle&gt;=0 Then check2 = TriangleClone(IdCLT\BTriangle)\Triangle Else check2 = -1
			If IdCLT\CTriangle&gt;=0 Then check3 = TriangleClone(IdCLT\CTriangle)\Triangle Else check3 = -1
			;===&gt;
			If check1&gt;0 And check2&gt;0 And check3&gt;0  Then Goto continue
			;===&gt;
			;Edge A
			If check1&lt;0 Then
				;===&gt;
				RayA = V_3Dec( IdCLT\a, sh_light ) 
				V_3Normalize(RayA ) 
				RayA = V_3Inc( V_3Mul(RayA, sh_lenght ), IdCLT\a )
				;===&gt;
				RayB = V_3Dec( IdCLT\b,sh_light ) 
				V_3Normalize( RayB ) 
				RayB = V_3Inc( V_3Mul( RayB, sh_lenght ), IdCLT\b ) 
				;===&gt;
				va = AddVertex(SurfaceFront,  IdCLT\a\x, 				IdCLT\a\y, 					IdCLT\a\z ); 
				vb = AddVertex(SurfaceFront,  RayA\x,						RayA\y,							RayA\z ); 
				vc = AddVertex(SurfaceFront,  RayB\x,						RayB\y,							RayB\z ); 
				vd = AddVertex(SurfaceFront,  IdCLT\b\x, 				IdCLT\b\y, 					IdCLT\b\z ); 
				;===&gt;
				AddTriangle(SurfaceFront, va, vb, vc); faccia 1/3 a 
				AddTriangle(SurfaceFront, va, vc, vd); faccia 1/3 b
				;===&gt;
				Line3DAX(cntLine3D) = IdCLT\a\x : Line3DAY(cntLine3D) = IdCLT\a\y : Line3DAZ(cntLine3D) = IdCLT\a\z
				Line3DBX(cntLine3D) = IdCLT\b\x : Line3DBY(cntLine3D) = IdCLT\b\y : Line3DBZ(cntLine3D) = IdCLT\b\z
				cntLine3D=cntLine3D+1
				;===&gt;
			EndIf
			;===&gt;
			;Edge B
			If check2&lt;0 Then
				;===&gt;
				RayB = V_3Dec( IdCLT\b,sh_light ) 
				V_3Normalize( RayB ) 
				RayB = V_3Inc( V_3Mul( RayB, sh_lenght ), IdCLT\b ) 
				;===&gt;
				RayC = V_3Dec( IdCLT\c,sh_light ) 
				V_3Normalize( RayC ) 
				RayC = V_3Inc( V_3Mul( RayC, sh_lenght ), IdCLT\c ) 
				;===&gt;
				va = AddVertex(SurfaceFront,  IdCLT\b\x, 				IdCLT\b\y, 					IdCLT\b\z ); 
				vb = AddVertex(SurfaceFront,  RayB\x,						RayB\y,							RayB\z ); 
				vc = AddVertex(SurfaceFront,  RayC\x,						RayC\y,							RayC\z ); 
				vd = AddVertex(SurfaceFront,  IdCLT\c\x, 				IdCLT\c\y, 					IdCLT\c\z ); 
				;===&gt;
				AddTriangle(SurfaceFront, va, vb, vc); faccia 2/3 a 
				AddTriangle(SurfaceFront, va, vc, vd); faccia 2/3 b
				;===&gt;
				Line3DAX(cntLine3D) = IdCLT\b\x : Line3DAY(cntLine3D) = IdCLT\b\y : Line3DAZ(cntLine3D) = IdCLT\b\z
				Line3DBX(cntLine3D) = IdCLT\c\x : Line3DBY(cntLine3D) = IdCLT\c\y : Line3DBZ(cntLine3D) = IdCLT\c\z
				cntLine3D=cntLine3D+1
				;===&gt;
			EndIf 
			;===&gt;
			;Edge C
			If check3&lt;0 Then
				;===&gt;
				RayA = V_3Dec( IdCLT\a, sh_light ) 
				V_3Normalize(RayA ) 
				RayA = V_3Inc( V_3Mul(RayA, sh_lenght ), IdCLT\a )
				;===&gt;
				RayC = V_3Dec( IdCLT\c,sh_light ) 
				V_3Normalize( RayC ) 
				RayC = V_3Inc( V_3Mul( RayC, sh_lenght ), IdCLT\c ) 
				;===&gt;
				va = AddVertex(SurfaceFront,  IdCLT\c\x, 				IdCLT\c\y, 					IdCLT\c\z ); 
				vb = AddVertex(SurfaceFront,  RayC\x,						RayC\y,							RayC\z ); 
				vc = AddVertex(SurfaceFront,  RayA\x,						RayA\y,							RayA\z ); 
				vd = AddVertex(SurfaceFront,  IdCLT\a\x, 				IdCLT\a\y, 					IdCLT\a\z ); 
				;===&gt;
				AddTriangle(SurfaceFront, va, vb, vc); faccia 3/3 a 
				AddTriangle(SurfaceFront, va, vc, vd); faccia 3/3 b
				;===&gt;
				Line3DAX(cntLine3D) = IdCLT\c\x : Line3DAY(cntLine3D) = IdCLT\c\y : Line3DAZ(cntLine3D) = IdCLT\c\z
				Line3DBX(cntLine3D) = IdCLT\a\x : Line3DBY(cntLine3D) = IdCLT\a\y : Line3DBZ(cntLine3D) = IdCLT\a\z
				cntLine3D=cntLine3D+1
				;===&gt;
			EndIf 
			;===&gt;
			.continue
			;===&gt;
		Next 
		;===&gt;
	Next
	;===&gt;
	t1=MilliSecs()
	t2=t1-t0
	Result$=Result$+"==&gt; Facce Front : "+CNTFront+"  Facce Back : "+CNTBack + " Tim-Vert: " + t2
	;===&gt; 
	Delete RayA
	Delete RayB
	Delete RayC
	Delete Norm
	Delete MidPoint
	Delete NormLight
	;===&gt; 
	Return Result$
	;===&gt; 
End Function 
;=======================
;
Function SHWLine3D()
	;===&gt;
	Color 255,0,0
	;===&gt;
	For a=0 To cntLine3D-1
		Line3D( Line3DAX(a), Line3DAY(a), Line3DAZ(a), Line3DBX(a), Line3DBY(a), Line3DBZ(a))
	Next
	cntLine3D=0
	;===&gt;
	Color 255,255,255
	;===&gt;
End Function
</textarea> <br><br></td></tr></table><br>
<a name="659050"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> the volume of the cylinder looks a little bit strange... <br><br></td></tr></table><br>
<a name="659054"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd imagine that cylinders and cones may look strange as they use 2 surfaces unlike spheres and cubes.  For shadow volume creation you need to combine these surfaces into one.  I have a simple function which does this if you want it?<br><br>Stevie <br><br></td></tr></table><br>
<a name="659058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes, please :) <br><br></td></tr></table><br>
<a name="659067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
Function MESHsingle( Mesh )

	Copy = CreateMesh()
	ns = CreateSurface( Copy )
	For su = 1 To CountSurfaces( Mesh )
		s = GetSurface( Mesh , su )
		For t = 0 To CountTriangles( s ) - 1
			v0 = TriangleVertex( s, t, 0 )
			v1 = TriangleVertex( s, t, 1 )
			v2 = TriangleVertex( s, t, 2 )
			Nv0 = AddVertex( ns , VertexX( s , v0 ) , VertexY( s, v0 ) , VertexZ( s, v0 ) )
			Nv1 = AddVertex( ns , VertexX( s , v1 ) , VertexY( s, v1 ) , VertexZ( s, v1 ) )
			Nv2 = AddVertex( ns , VertexX( s , v2 ) , VertexY( s, v2 ) , VertexZ( s, v2 ) )
			AddTriangle ns , Nv0 , Nv1 , Nv2
		Next
	Next
	FreeEntity mesh
	Return Copy

End Function	
</pre><br><br>Useage ....<br><br>MyCylinder = MESHsingle( createcylinder() )<br><br>You may need to retain the normals but this should be easy to implement.  <br><br>Stevie <br><br></td></tr></table><br>
<a name="659115"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> I *think* CopyMesh attemps to combine surfaces. <br><br></td></tr></table><br>
<a name="659129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doh .. so it does ... Copymesh combines surfaces which share the same brush so logically this works just fine .... why I never thought of that is beyond me ;)<br><br>So function becomes ..<br><br><pre class=code>

Function MESHsingle( Mesh )

 copy = copymesh( Mesh )
 freeentity Mesh
 return copy

end function

</pre> <br><br></td></tr></table><br>
<a name="659165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> dare devil:<br>with the code of you i cannot make 2 entitys casting a volume!!! there is a bug...<br><br>edit: ok, but another issue is, that if i take a sphere with 32 segments, the initobject() takes half a minute!? what's about that? can we make it work without long initialization times? <br><br></td></tr></table><br>
<a name="660239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have write a new update for the software, <br>1° optimize pre load mesh<br>2° resolved problem object multi surface<br>3° i ha create a new function simulate stencil 2 fast speed<br><br>and ...... <br><br>the inizialize mesh required 5 seconds in released version.<br><br>The new link a version is:<br><br><a href="http://digilander.libero.it/enzo_light/shw06.zip" target="_blank">http://digilander.libero.it/enzo_light/shw06.zip</a><br><br>for multi object i not have write "for Obj=each..." for test this software.<br><br>bye <br><br></td></tr></table><br>
<a name="660276"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, i will check it out:<br><br>ps: look what i have made out of your libary:<br><a href="http://www.blitzbasic.com/gallery/view_pic.php?id=1336&amp;gallery=&amp;page=1" target="_blank">http://www.blitzbasic.com/gallery/view_pic.php?id=1336&amp;gallery=&amp;page=1</a><br><br>when it's ready it will be FREE* <br><br></td></tr></table><br>
<a name="660684"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have look program the different speed is very lot<br>8 millisecs in the my new systems, and 100 millisecs in the old method from used you.<br><br>bye <br><br></td></tr></table><br>
<a name="660685"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> well, i see...<br>but...can we make the initobject() time fast AND the shadowvolume() time fast? when we could do this, this would be the best... <br><br></td></tr></table><br>
<a name="660696"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> the init object pre elaborate mesh, not function in real time the IntObject is a system the elaborate edge.<br><br>the phase 1 is complete ( the bug for 2 object is not resolved generate over face 2 cube )<br><br>the Phase 2 is Multi Light Zone, is the system based the lenght light ray all object present in the ray generate volume shadow ;)<br><br>PS:<br>(in the new demo the system is settings a 256 size texture and not 128)<br><br><br>ok bye <br><br></td></tr></table><br>
<a name="661148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all<br><br>post the new update file shadow, i have finished face 1 and start the new section OPTIMIZE InitObject <br><br>bye<br><br>size texture 512<br><br><img src="http://digilander.libero.it/enzo_light/Image3.jpg"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;======================================= 
;--------------------------------------- 
; 
;   Name file: Shadow_Include
; 
;   Programmatore: 
;      Caldarulo Vincenzo (Eye &amp; Light) 
;   Descrizione: 
;			Creazione dei volumi d'ombra
; 
;--------------------------------------- 
;======================================= 
Include"commontype.bb"
;======================================= 
;--------------------------------------- 
; Variabili ShadowVolume 
;--------------------------------------- 
;======================================= 
;===&gt;
Type EdgeToEdge
	Field IdModel
	Field cntSurface
	Field Surfaces.ETE_Surface
End Type
;===&gt;
Type ETE_Surface
	Field IdSurface
	Field cntTriangle
	Field IdTriangle.ETE_Triangle[ETE_MaxTriang]
End Type
;===&gt;
Type ETE_Triangle
	Field Normal.Point3D
	Field a.Point3D
	Field b.Point3D
	Field c.Point3D
	Field Triangle
	Field ATriangle
	Field BTriangle
	Field CTriangle
End Type
;===&gt;
;======================================= 
;===&gt;
Const SHWTexSize = 128; Parametro di regolazione Ombra
Const sh_level# = 0.1
Const ETE_MaxTriang=65000
Const SHWL3D = 65000
;===&gt;
;======================================= 
;===&gt;
Dim BG1(SHWTexSize,SHWTexSize)
Dim BG2(SHWTexSize,SHWTexSize)
Dim  TriangleClone.ETE_Triangle(ETE_MaxTriang)
Dim AD(65000,2)
;===&gt;
;======================================= 
;===&gt;
Global Scena = CreatePivot(); CreateSphere(5)
;===&gt;
Global MeshFront = CreateMesh(); 
Global SurfaceFront = CreateSurface(MeshFront); 
EntityAlpha MeshFront, sh_level 
EntityFX MeshFront,1;4
EntityBlend MeshFront,3
;===&gt;
Global cntLine3D=0
Dim Line3DAX#(SHWL3D)
Dim Line3DAY#(SHWL3D)
Dim Line3DAZ#(SHWL3D)
Dim Line3DBX#(SHWL3D)
Dim Line3DBY#(SHWL3D)
Dim Line3DBZ#(SHWL3D)
;===&gt;
;Creiamo il piano che proietterà l'ombra
;===&gt;
Global SHWScreenImage = CreateImage(SHWTexSize,SHWTexSize)
Global SHWSpriteFront=CreateSprite()
SpriteViewMode SHWSpriteFront,1
Global ShwTex1=CreateTexture(SHWTexSize,SHWTexSize,1+2+8+256+512)
EntityTexture SHWSpriteFront,ShwTex1
EntityFX SHWSpriteFront,1
HideEntity SHWSpriteFront

;===&gt;
Global sh_v1.Point3D			= New Point3D 
Global sh_v2.Point3D			= New Point3D 
Global sh_v3.Point3D			= New Point3D 
Global sh_light.Point3D		= New Point3D 
Global sh_lenght.Point3D	= New Point3D 
;===&gt;
Global SHW_ETE_Object.EdgeToEdge
;===&gt;
;======================================= 
;===&gt;
;=======================
; 
Function CheckVertex%(a.Point3D,b.Point3D)
	If (a\x=b\x)And(a\y=b\y)And(a\z=b\z) Then
		Return True 
	Else
		Return False 
	EndIf 
End Function 

;======================================================================= 
;======================================================================= 
; Shadow Volume For silhouette Method Edge to Edge
;======================================================================= 
;======================================================================= 
;======================= 
; Inizialize Object Shadow
Function SHW_Init()

	;===&gt;
	; Search surface and triangle object
	For n=0 To ETE_MaxTriang
	
		TriangleClone.ETE_Triangle(n) = New ETE_Triangle
		
		TriangleClone(n)\Normal.Point3D = New Point3D
		TriangleClone(n)\a.Point3D = New Point3D
		TriangleClone(n)\b.Point3D = New Point3D
		TriangleClone(n)\c.Point3D = New Point3D
	Next
	ShwInitDisplay()

End Function 

Function ShwInitDisplay()
	;===&gt;
	EntityParent(SHWSpriteFront,Camera) 
	PositionEntity SHWSpriteFront,-0.005,+0.005,1.001 
	;===&gt;
End Function 
;=======================
; Inizialize Object Shadow
Function SHW_InitObject$(model)
	Time$=""
	Tim1=MilliSecs()
	Norm.Point3D = New Point3D
	
	SHW_ETE_Object.EdgeToEdge = New EdgeToEdge
	SHW_ETE_Object\IdModel = model
	;===&gt;
	; Search surface and triangle object
	SHW_ETE_Object\cntSurface = CountSurfaces(model)-1
	For n=0 To SHW_ETE_Object\cntSurface
		;===&gt;
		surf = GetSurface(model,n+1)
		NumFaces = CountTriangles(surf)-1
		;===&gt;
		SHW_ETE_Object\Surfaces.ETE_Surface = New  ETE_Surface
		IdSurface.ETE_Surface = SHW_ETE_Object\Surfaces
		;===&gt;
		IdSurface\IdSurface = surf
		IdSurface\cntTriangle = NumFaces
		For v=0 To NumFaces
			;===&gt;
			IdSurface\IdTriangle.ETE_Triangle[v] = New ETE_Triangle
			IdTriang.ETE_Triangle = IdSurface\IdTriangle[v]
			;===&gt;
			IdTriang\normal.Point3D = New Point3D
			IdTriang\a.Point3D = New Point3D
			IdTriang\b.Point3D = New Point3D
			IdTriang\c.Point3D = New Point3D
			;===&gt; 
			vert0 = TriangleVertex(surf,v,0)
			vert1 = TriangleVertex(surf,v,1)
			vert2 = TriangleVertex(surf,v,2)
			;===&gt;
			IdTriang\a\x = VertexX( surf, vert0) : IdTriang\a\y = VertexY( surf, vert0) : IdTriang\a\z = VertexZ( surf, vert0)
			;===&gt; 
			IdTriang\b\x = VertexX( surf, vert1) : IdTriang\b\y = VertexY( surf, vert1) : IdTriang\b\z = VertexZ( surf, vert1)
			;===&gt; 
			IdTriang\c\x = VertexX( surf, vert2) : IdTriang\c\y = VertexY( surf, vert2) : IdTriang\c\z = VertexZ( surf, vert2)
			;===&gt;
			IdTriang\Normal= CalcNormal( IdTriang\a, IdTriang\b, IdTriang\c)
			IdTriang\Normal = V_3Normalize(IdTriang\Normal) 
			;===&gt;
			IdTriang\Triangle = v
			IdTriang\ATriangle = -1
			IdTriang\BTriangle = -1
			IdTriang\CTriangle = -1
			;===&gt;
		Next 
		;===&gt;
		; Search adjacent triangle
		;===&gt;
		; ottimizzazione precalcolo
		For a=0 To IdSurface\cntTriangle
			AD(a,0)=1 : AD(a,1) = 1 : AD(a,2) = 1
		Next
		;===&gt;
		For a=0 To IdSurface\cntTriangle
			;===&gt;
			ATriang.ETE_Triangle = IdSurface\IdTriangle[a]
			;===&gt;
			For b=a+1 To IdSurface\cntTriangle
				If a=b Or (AD(b,0)=0 And AD(b,1)=0 And AD(b,2)=0)Then Goto jump
				;===&gt;
				BTriang.ETE_Triangle = IdSurface\IdTriangle[b]
				;*********************************************************************
				; SIDE " A "
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato A del 2° Triangolo)
				If (AD(b,0)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\a, BTriang\a )
					check2 = CheckVertex( ATriang\b, BTriang\b )
					check3 = CheckVertex( ATriang\a, BTriang\b )
					check4 = CheckVertex( ATriang\b, BTriang\a )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\ATriangle = b
						BTriang\ATriangle = a
						AD(b,0)=0
						Goto SIDEA
						;Stop
					EndIf
					;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato B del 2° Triangolo)
				If (AD(b,1)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\a, BTriang\b )
					check2 = CheckVertex( ATriang\b, BTriang\c )
					check3 = CheckVertex( ATriang\a, BTriang\c )
					check4 = CheckVertex( ATriang\b, BTriang\b )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\ATriangle = b
						BTriang\BTriangle = a
						AD(b,1)=0
						Goto SIDEA
						;Stop
					EndIf
					;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato C del 2° Triangolo)
				If (AD(b,2)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\a, BTriang\c )
					check2 = CheckVertex( ATriang\b, BTriang\a )
					check3 = CheckVertex( ATriang\a, BTriang\a )
					check4 = CheckVertex( ATriang\b, BTriang\c )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\ATriangle = b
						BTriang\CTriangle = a
						AD(b,2)=0
						;Stop
					EndIf
					;===&gt;
				EndIf
				.SIDEA
				;===&gt;
				;*********************************************************************
				; SIDE " B "
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato A del 2° Triangolo)
				If (AD(b,0)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\b, BTriang\a )
					check2 = CheckVertex( ATriang\c, BTriang\b )
					check3 = CheckVertex( ATriang\b, BTriang\b )
					check4 = CheckVertex( ATriang\c, BTriang\a )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\BTriangle = b
						BTriang\ATriangle = a
						AD(b,0)=0
						Goto SIDEB
						;Stop
					EndIf 
					;===&gt;
				EndIf 
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato B del 2° Triangolo)
				If (AD(b,1)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\b, BTriang\b )
					check2 = CheckVertex( ATriang\c, BTriang\c )
					check3 = CheckVertex( ATriang\b, BTriang\c )
					check4 = CheckVertex( ATriang\c, BTriang\b )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\BTriangle = b
						BTriang\BTriangle = a
						AD(b,1)=0
						Goto SIDEB
						;Stop
					EndIf
					;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato C del 2° Triangolo)
				If (AD(b,2)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\b, BTriang\c )
					check2 = CheckVertex( ATriang\c, BTriang\a )
					check3 = CheckVertex( ATriang\b, BTriang\a )
					check4 = CheckVertex( ATriang\c, BTriang\c )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\BTriangle = b
						BTriang\CTriangle = a
						AD(b,2)=0
						;Stop
					EndIf
					;===&gt;
				EndIf
				.SIDEB
			;===&gt;
				;*********************************************************************
				; SIDE " C "
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato A del 2° Triangolo)
				If (AD(b,0)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\c, BTriang\a )
					check2 = CheckVertex( ATriang\a, BTriang\b )
					check3 = CheckVertex( ATriang\c, BTriang\b )
					check4 = CheckVertex( ATriang\a, BTriang\a )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\CTriangle = b
						BTriang\ATriangle = a
						AD(b,0)=0
						Goto SIDEC
						;Stop
					EndIf
				;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato B del 2° Triangolo)
				If (AD(b,1)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\c, BTriang\b )
					check2 = CheckVertex( ATriang\a, BTriang\c )
					check3 = CheckVertex( ATriang\c, BTriang\c )
					check4 = CheckVertex( ATriang\a, BTriang\b )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\CTriangle = b
						BTriang\BTriangle = a
						AD(b,1)=0
						Goto SIDEC
						;Stop
					EndIf
					;===&gt;
				EndIf 
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato C del 2° Triangolo)
				If (AD(b,2)=1)Then
					;===&gt;
					check1 = CheckVertex( ATriang\c, BTriang\c )
					check2 = CheckVertex( ATriang\a, BTriang\a )
					check3 = CheckVertex( ATriang\c, BTriang\a )
					check4 = CheckVertex( ATriang\a, BTriang\c )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\CTriangle = b
						BTriang\CTriangle = a
						AD(b,2)=0
						;Stop
					EndIf
					;===&gt;
				EndIf
				.SIDEC
				;===&gt;
				.jump
				;===&gt;
			Next
			;===&gt;
		Next 
		;===&gt;
	Next
	;===&gt;
	Delete Norm
	;===&gt;
	Tim2=MilliSecs()
	Time$="Time Precalcolo: "+(Tim2-Tim1)
	Return Time$
	;===&gt;
End Function 

;=======================
; Inizialize Object Shadow
Function CloneListTriangle(dst.ETE_Triangle,src.ETE_Triangle)
	;===&gt;
	V_3Copy( dst\Normal, src\Normal)
	V_3Copy( dst\a, src\a)
	V_3Copy( dst\b, src\b)
	V_3Copy( dst\c, src\c)
	dst\Triangle = src\Triangle
	dst\ATriangle = src\ATriangle
	dst\BTriangle = src\BTriangle
	dst\CTriangle = src\CTriangle
	;===&gt;
End Function 
;=======================
Function ResetShadowVolume()
   ClearSurface SurfaceFront; 
End Function 
;======================= 
; Shadows Volume start 
Function ShadowVolume$( Light, LightLenght )
	ResetShadowVolume()
	;===&gt;
	sh_light\x = EntityX(Light) : sh_light\y = EntityY(Light) : sh_light\z = EntityZ(Light) 
	sh_lenght\x = LightLenght 
	sh_lenght\y = LightLenght 
	sh_lenght\z = LightLenght 
	;===&gt;
	cntLine3D=0
	;===&gt;
	result$=ShadowVolumeCreate3()
	;===&gt;
	;ShadowVolumeSimulateStencil()
	ShadowVolumeSimulateStencilNew() ; è un pò più veloce della New1
	;ShadowVolumeSimulateStencilNew1()
	;===&gt;
	;PositionEntity SHWSpriteFront,EntityX(Camera),EntityY(Camera),EntityZ(Camera)+1.001
	;RotateEntity SHWSpriteFront,-EntityPitch(Camera),EntityYaw(Camera),0
	;===&gt;
	Return result$
	;===&gt;
End Function 
;=======================
; Creazione volume
; forse si può fare ancora qualcosina!!
Function ShadowVolumeCreate3$()
	;===&gt; 
	Local Result$ = ""
	Local Norm.Point3D = New Point3D 
	Local MidPoint.Point3D = New Point3D 
	Local NormLight.Point3D = New Point3D
	Local RayA.Point3D = New Point3D 
	Local RayB.Point3D = New Point3D 
	Local RayC.Point3D = New Point3D 
	;===&gt; 
	Local CNTFront=0
	Local CNTBack=0
	Local surf=0
	Local check1 = -1
	Local check2 = -1
	Local check3 = -1
	;===&gt; 
	t0=MilliSecs()


	For SHW_ETE_Object.EdgeToEdge = Each EdgeToEdge
		;===&gt;
		; Cerchiamoci i vertici faccia vista verso la luce
		Surfaces.ETE_Surface = SHW_ETE_Object\Surfaces
		For aSurf = 0 To SHW_ETE_Object\cntSurface
			;===&gt;
			surf = Surfaces\IdSurface
			dwNumFaces = Surfaces\cntTriangle 
			;===&gt;
			For v=0 To dwNumFaces
				;===&gt;
				IdTriang.ETE_Triangle = SHW_ETE_Object\Surfaces\IdTriangle[v]
				CloneListTriangle(TriangleClone(v),IdTriang)
				IdCLT.ETE_Triangle = TriangleClone(v)
				;===&gt;
				;associamo le trasformazioni ai vertici
				TFormPoint IdCLT\a\x, IdCLT\a\y , IdCLT\a\z, SHW_ETE_Object\IdModel, 0
				sh_v1\x = TFormedX() : sh_v1\y = TFormedY() : sh_v1\z = TFormedZ()
				;===&gt; 
				TFormPoint IdCLT\b\x, IdCLT\b\y , IdCLT\b\z, SHW_ETE_Object\IdModel, 0
				sh_v2\x = TFormedX() : sh_v2\y = TFormedY() : sh_v2\z = TFormedZ() 
				;===&gt; 
				TFormPoint IdCLT\c\x, IdCLT\c\y , IdCLT\c\z, SHW_ETE_Object\IdModel, 0
				sh_v3\x = TFormedX() : sh_v3\y = TFormedY() : sh_v3\z = TFormedZ() 
				;===&gt;
				TFormNormal  IdCLT\Normal\x, IdCLT\Normal\y , IdCLT\Normal\z, SHW_ETE_Object\IdModel, 0
				Norm\x = TFormedX() : Norm\y = TFormedY() : Norm\z = TFormedZ() 
				MidPoint = V_3Mid(sh_v1,sh_v2,sh_v3) 
				NormLight = V_3Dec(MidPoint,sh_light) 
				NormLight  = V_3Normalize(NormLight) 
				Dot# = V_3Dot( Norm, NormLight ) 
				;===&gt;
				; Marchiamo i vertici non rivolti verso la luce
				If Dot#=&gt;0.0 Then
					;===&gt;
					V_3Copy( IdCLT\a, sh_v1 )
					V_3Copy( IdCLT\b, sh_v2 )
					V_3Copy( IdCLT\c, sh_v3 )
					CNTFront=CNTFront+1
					;===&gt;
				Else
					;===&gt;
					IdCLT\Triangle  = -1
					CNTBack=CNTBack+1
					;===&gt;
				EndIf
				;===&gt; 
			Next
			;===&gt;
			; Ora creiamo il volume
			For v=0 To dwNumFaces
				;===&gt;
				IdCLT.ETE_Triangle = TriangleClone(v)
				;===&gt;
				; Saltiamo il triangolo se è a -1
				If IdCLT\Triangle&lt;0 Then Goto continue
				;===&gt;
				If IdCLT\ATriangle&gt;=0 Then check1 = TriangleClone(IdCLT\ATriangle)\Triangle Else check1 = -1
				If IdCLT\BTriangle&gt;=0 Then check2 = TriangleClone(IdCLT\BTriangle)\Triangle Else check2 = -1
				If IdCLT\CTriangle&gt;=0 Then check3 = TriangleClone(IdCLT\CTriangle)\Triangle Else check3 = -1
				;===&gt;
				If check1&gt;0 And check2&gt;0 And check3&gt;0  Then Goto continue
				;===&gt;
				;Edge A
				If check1&lt;0 Then
					;===&gt;
					RayA = V_3Dec( IdCLT\a, sh_light ) 
					V_3Normalize(RayA ) 
					RayA = V_3Inc( V_3Mul(RayA, sh_lenght ), IdCLT\a )
					;===&gt;
					RayB = V_3Dec( IdCLT\b,sh_light ) 
					V_3Normalize( RayB ) 
					RayB = V_3Inc( V_3Mul( RayB, sh_lenght ), IdCLT\b ) 
					;===&gt;
					va = AddVertex(SurfaceFront,  IdCLT\a\x,		IdCLT\a\y, 			IdCLT\a\z ); 
					vb = AddVertex(SurfaceFront,  RayA\x,				RayA\y,					RayA\z ); 
					vc = AddVertex(SurfaceFront,  RayB\x,				RayB\y,					RayB\z ); 
					vd = AddVertex(SurfaceFront,  IdCLT\b\x,		IdCLT\b\y, 			IdCLT\b\z ); 
					;===&gt;
					AddTriangle(SurfaceFront, va, vb, vc); faccia 1/3 a 
					AddTriangle(SurfaceFront, va, vc, vd); faccia 1/3 b
					;===&gt;
					Line3DAX(cntLine3D) = IdCLT\a\x : Line3DAY(cntLine3D) = IdCLT\a\y : Line3DAZ(cntLine3D) = IdCLT\a\z
					Line3DBX(cntLine3D) = IdCLT\b\x : Line3DBY(cntLine3D) = IdCLT\b\y : Line3DBZ(cntLine3D) = IdCLT\b\z
					cntLine3D=cntLine3D+1
					;===&gt;
				EndIf
				;===&gt;
				;Edge B
				If check2&lt;0 Then
					;===&gt;
					RayB = V_3Dec( IdCLT\b,sh_light ) 
					V_3Normalize( RayB ) 
					RayB = V_3Inc( V_3Mul( RayB, sh_lenght ), IdCLT\b ) 
					;===&gt;
					RayC = V_3Dec( IdCLT\c,sh_light ) 
					V_3Normalize( RayC ) 
					RayC = V_3Inc( V_3Mul( RayC, sh_lenght ), IdCLT\c ) 
					;===&gt;
					va = AddVertex(SurfaceFront,  IdCLT\b\x, 		IdCLT\b\y, 			IdCLT\b\z ); 
					vb = AddVertex(SurfaceFront,  RayB\x,				RayB\y,					RayB\z ); 
					vc = AddVertex(SurfaceFront,  RayC\x,				RayC\y,					RayC\z ); 
					vd = AddVertex(SurfaceFront,  IdCLT\c\x, 		IdCLT\c\y, 			IdCLT\c\z ); 
					;===&gt;
					AddTriangle(SurfaceFront, va, vb, vc); faccia 2/3 a 
					AddTriangle(SurfaceFront, va, vc, vd); faccia 2/3 b
					;===&gt;
					Line3DAX(cntLine3D) = IdCLT\b\x : Line3DAY(cntLine3D) = IdCLT\b\y : Line3DAZ(cntLine3D) = IdCLT\b\z
					Line3DBX(cntLine3D) = IdCLT\c\x : Line3DBY(cntLine3D) = IdCLT\c\y : Line3DBZ(cntLine3D) = IdCLT\c\z
					cntLine3D=cntLine3D+1
					;===&gt;
				EndIf 
				;===&gt;
				;Edge C
				If check3&lt;0 Then
					;===&gt;
					RayA = V_3Dec( IdCLT\a, sh_light ) 
					V_3Normalize(RayA ) 
					RayA = V_3Inc( V_3Mul(RayA, sh_lenght ), IdCLT\a )
					;===&gt;
					RayC = V_3Dec( IdCLT\c,sh_light ) 
					V_3Normalize( RayC ) 
					RayC = V_3Inc( V_3Mul( RayC, sh_lenght ), IdCLT\c ) 
					;===&gt;
					va = AddVertex(SurfaceFront,  IdCLT\c\x, 		IdCLT\c\y, 			IdCLT\c\z ); 
					vb = AddVertex(SurfaceFront,  RayC\x,				RayC\y,					RayC\z ); 
					vc = AddVertex(SurfaceFront,  RayA\x,				RayA\y,					RayA\z ); 
					vd = AddVertex(SurfaceFront,  IdCLT\a\x, 		IdCLT\a\y, 			IdCLT\a\z ); 
					;===&gt;
					AddTriangle(SurfaceFront, va, vb, vc); faccia 3/3 a 
					AddTriangle(SurfaceFront, va, vc, vd); faccia 3/3 b
					;===&gt;
					;===&gt;
					Line3DAX(cntLine3D) = IdCLT\c\x : Line3DAY(cntLine3D) = IdCLT\c\y : Line3DAZ(cntLine3D) = IdCLT\c\z
					Line3DBX(cntLine3D) = IdCLT\a\x : Line3DBY(cntLine3D) = IdCLT\a\y : Line3DBZ(cntLine3D) = IdCLT\a\z
					cntLine3D=cntLine3D+1
					;===&gt;
				EndIf 
				;===&gt;
				.continue
				;===&gt;
			Next 
			;===&gt;
			Surfaces = After Surfaces
			;===&gt;
		Next
		;===&gt;
	Next
	;===&gt;
	t1=MilliSecs()
	t2=t1-t0
	Result$=Result$+"==&gt; Facce Front : "+CNTFront+"  Facce Back : "+CNTBack + " Tim-Vert: " + t2
	;===&gt; 
	Delete RayA
	Delete RayB
	Delete RayC
	Delete Norm
	Delete MidPoint
	Delete NormLight
	;===&gt; 
	Return Result$
	;===&gt; 
End Function 
;=======================
;
Function SHWLine3D()
	;===&gt;
	Color 255,0,0
	;===&gt;
	For a=0 To cntLine3D-1
		Line3D( Line3DAX(a), Line3DAY(a), Line3DAZ(a), Line3DBX(a), Line3DBY(a), Line3DBZ(a))
	Next
	cntLine3D=0
	;===&gt;
	Color 255,255,255
	;===&gt;
End Function
;=======================
; Creazione immagine ombra
; ottimizzazione completata 
Function ShadowVolumeSimulateStencil()
	;===&gt;
	; Fase 1
	;===&gt;
	Local CaptureX = TextureWidth(ShwTex1)
	Local CaptureY = TextureHeight(ShwTex1)
	CameraViewport Camera,0,0,CaptureX, CaptureY
	;===&gt;
	HideEntity SHWSpriteFront 
	;===&gt;
	HideEntity MeshFront 
	ShowEntity Scena
	RenderWorld
	CameraClsMode camera,True,False
	;===&gt;
	HideEntity Scena
	;per ottimizzare renderizzo prima il back
	ShowEntity MeshFront
	FlipMesh MeshFront ;Visualizzo il back face
	;preparo in back face
	EntityColor MeshFront,10,10,10
	EntityFX MeshFront,1;4

	RenderWorld
	;===&gt;
	; Front Ground 1
	LockBuffer()
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			bg2(x,y)=ReadPixelFast(x,y)
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;proparo in front face
	FlipMesh MeshFront
	EntityColor MeshFront,10,10,10
	RenderWorld
	;===&gt;
	; Back Ground 2
	LockBuffer()
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			bg1(x,y)=ReadPixelFast(x,y)
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;===&gt;
	HideEntity MeshFront
	;===&gt;
	;Ripristiniamo tutto prima di riprendere le normali attività
	;===&gt;
	; Filter
	SetBuffer TextureBuffer(ShwTex1)
	LockBuffer()
	ShadowColor=(128 Shl 24)
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			Val=(Bg1(x,y)-Bg2(x,y))
			;Val=Abs(Bg1(x,y)-Bg2(x,y))
			If (Val)&gt;0 Then
				WritePixelFast x,y,ShadowColor
			Else
				WritePixelFast x,y,0
			EndIf
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;===&gt;
	CameraViewport Camera,0,0,GraphicsWidth(), GraphicsHeight()
	CameraClsMode camera,True,True
	;===&gt;
	ShowEntity SHWSpriteFront 
	ShowEntity Scena
	;===&gt;
	SetBuffer BackBuffer()
	Cls
	;===&gt;
End Function 
;=======================
; Creazione immagine ombra
; Fast1
Function ShadowVolumeSimulateStencilNew()
	;===&gt;
	Local MeshBack = CopyMesh(MeshFront)
	EntityAlpha MeshBack, sh_level 
	EntityBlend MeshBack,3
	;===&gt;
	; Fase 1
	;===&gt;
	Local CaptureX = TextureWidth(ShwTex1)
	Local CaptureY = TextureHeight(ShwTex1)
	CameraViewport Camera,0,0,CaptureX, CaptureY
	SetBuffer BackBuffer()
	;===&gt;
	HideEntity SHWSpriteFront 
	;===&gt;
	HideEntity MeshFront 
	HideEntity MeshBack 
	ShowEntity Scena
	RenderWorld
	CameraClsMode camera,True,False
	;===&gt;
	HideEntity Scena
	;preparo il back face
	ShowEntity MeshBack
	EntityColor MeshBack,0,0,100
	EntityFX MeshBack,1;4
	FlipMesh MeshBack ;Visualizzo il back face
	;preparo il front face
	ShowEntity MeshFront
	EntityColor MeshFront,100,0,0
	EntityFX MeshFront,1;4
	RenderWorld

	;CopyRect 0, 0, CaptureX, CaptureY, 0, 0, BackBuffer(), ImageBuffer(ShwScreenImage)
	;===&gt;
	; Front Ground 1
	LockBuffer BackBuffer()
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			pix=ReadPixelFast(x,y)
			bg1(x,y) = ((pix And $00FF0000) Shr 16)-(pix And $000000FF)
			;===&gt;
		Next
	Next
	UnlockBuffer BackBuffer()
	;CopyRect 0, 0, CaptureX, CaptureY, 0, 0, BackBuffer(), ImageBuffer(ShwScreenImage)
;Goto Jump
	;===&gt;
	HideEntity MeshFront
	HideEntity MeshBack
	;===&gt;
	; Filter
	SetBuffer TextureBuffer(ShwTex1)
	LockBuffer()
	ShadowColor=(128 Shl 24)
	ShadowColor2=(64 Shl 24)

	If KeyHit(63) Then Stop
	
	For y=1 To 	CaptureY-1
		For x=1 To 	CaptureX-1
			;===&gt;
			If bg1(x,y)&lt;&gt;0 Then
				;Blur image
;				If bg1( x-1, y-1 )=0 Or bg1( x, y-1 )=0 Or bg1( x+1, y-1 )=0 Or bg1( x-1, y )=0 Or bg1( x+1, y )=0 Or bg1( x-1, y+1 )=0 Or bg1( x, y+1 )=0 Or bg1( x+1, y+1 )=0  Then 
				If bg1( x, y-1 )=0 Or bg1( x-1, y )=0 Or bg1( x+1, y )=0 Or bg1( x, y+1 )=0  Then 
					WritePixelFast x,y,ShadowColor2
				Else
					WritePixelFast x,y,ShadowColor
				EndIf
			Else
				WritePixelFast x,y,0
			EndIf
			;===&gt;
		Next
	Next
	UnlockBuffer()
	;===&gt;
.Jump
	;===&gt;
	;Ripristiniamo tutto prima di riprendere le normali attività
	FreeEntity MeshBack
	CameraViewport Camera,0,0,GraphicsWidth(), GraphicsHeight()
	CameraClsMode camera,True,True
	;===&gt;
	ShowEntity SHWSpriteFront 
	ShowEntity Scena
	;===&gt;
	SetBuffer BackBuffer()
	Cls
	;===&gt;
End Function 
;=======================
; Creazione immagine ombra
; Fast2
Function ShadowVolumeSimulateStencilNew1()
	;===&gt;
	Local MeshBack = CopyMesh(MeshFront)
	EntityAlpha MeshBack, sh_level 
	EntityBlend MeshBack,3
	;===&gt;
	; Fase 1
	;===&gt;
	Local CaptureX = TextureWidth(ShwTex1)
	Local CaptureY = TextureHeight(ShwTex1)
	CameraViewport Camera,0,0,CaptureX, CaptureY
	;===&gt;
	HideEntity SHWSpriteFront 
	;===&gt;
	HideEntity MeshFront 
	HideEntity MeshBack 
	ShowEntity Scena
	RenderWorld
	CameraClsMode camera,True,False
	;===&gt;
	HideEntity Scena
	;preparo il back face
	ShowEntity MeshBack
	EntityColor MeshBack,0,0,100
	EntityFX MeshBack,1;4
	FlipMesh MeshBack ;Visualizzo il back face
	;preparo il front face
	ShowEntity MeshFront
	EntityColor MeshFront,100,0,0
	EntityFX MeshFront,1;4
	RenderWorld
	;===&gt;
;Goto Jump
	;===&gt;
	; Front Ground 1
	ShadowColor=(128 Shl 24)
	LockBuffer BackBuffer()
	LockBuffer TextureBuffer(ShwTex1)
	For y=0 To 	CaptureY
		For x=0 To 	CaptureX
			;===&gt;
			pix=ReadPixelFast(x,y)
			Front = (pix And $00FF0000) Shr 16 ; Filtro il rosso
			Back  = (pix And $000000FF) ; Filtro il blu
			Val=Front-Back
			If Val&gt;0 Then
				WritePixelFast x,y,ShadowColor,TextureBuffer(ShwTex1)
			Else
				WritePixelFast x,y,0,TextureBuffer(ShwTex1)
			EndIf
			;===&gt;
		Next
	Next
	UnlockBuffer TextureBuffer(ShwTex1)
	UnlockBuffer BackBuffer()
	;===&gt;
.Jump
	;===&gt;
	;Ripristiniamo tutto prima di riprendere le normali attività
	FreeEntity MeshBack
	CameraViewport Camera,0,0,GraphicsWidth(), GraphicsHeight()
	CameraClsMode camera,True,True
	;===&gt;
	ShowEntity SHWSpriteFront 
	ShowEntity Scena
	;===&gt;
	SetBuffer BackBuffer()
	Cls
	;===&gt;
End Function 

</textarea> <br><br></td></tr></table><br>
<a name="661172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, when the initobject() works fast, i will intergrate this code into my stencil shadow system and you'll be the first who will know it :)<br><br>cya <br><br></td></tr></table><br>
<a name="661239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> look what i have done with your shadow code:<br><a href="http://patrick-sch.de/bleibdafuerimmer/StencilShadowSystem.zip" target="_blank">http://patrick-sch.de/bleibdafuerimmer/StencilShadowSystem.zip</a> <br><br></td></tr></table><br>
<a name="661256"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good !! the system is good :)<br><br>bye <br><br></td></tr></table><br>
<a name="661289"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >t3K|Mac</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> hm, i get a "too many parameters" error at SetRenderState() <br><br></td></tr></table><br>
<a name="661353"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> t3kMac ..I take it your using at least v1.88?<br><br>It works fine here ... a few clitches and some slowdown on demo 4.  I still don't think it's fast enough for in-game use though :(   Max FPS I got on the swwift demo was 60fps but that's without game logic / physics etc.. Your beethoven mesh is nowhere near the same polys as he was pushing. <br><br>Nice work none the less!!<br><br>It seems that the shadowvolume creation is still the bottleneck ... if only some smart guy could create a .dll for the volume building then you'd be cooking on gas :)<br><br>Stevie <br><br></td></tr></table><br>
<a name="661371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes, a volume dll would be revolutionary, because everybody could create his own shadow system, then remember: 90% of the work of a stencil shadow system is the shadow volume! the rest is as easy as clean up his ass :) <br><br></td></tr></table><br>
<a name="661383"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >t3K|Mac</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> @stevieg: t3kMac ..I take it your using at least v1.88?<br><br>i am using blitz 1.96 and hmm don't know the version of dx7test.dll (mine is 77.824 Bytes) maybe i have an old one or old decals... can you send me yours please? <br><br></td></tr></table><br>
<a name="661394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ t3kMac ... <br><br>I just used the ones which came with the zip download and popped them into the uselibs directory and it worked fine.<br><br>Stevie <br><br></td></tr></table><br>
<a name="661402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now, get cracking on self shadowing :P Good work guys :o) <br><br></td></tr></table><br>
<a name="661474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> self shadowing should be simple. You only have to add the caster mesh to the list of the receiver surfaces.<br><br>One thing that is surely more a candidate for headache is the animated vertices problem. And after all we want to use shadows with characters, right?<br>Adding a pivot to every vertex is also very slow. Additionally there are weighted vertices, so this wouldn't work.<br><br>Somebody was working on a DLL that was capable of determinating the true vertex coords of animated meshes. Not sure what's going on there.<br><br>Anyway, good work! <br><br></td></tr></table><br>
<a name="661556"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >t3K|Mac</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> @stevie: this dx7 dll looks way older than mine. now i have 3 different dx7.dlls. which one is the best?<br><br>dx7test.dll<br>DirectX7.dll<br>vardx7.dll<br><br>little chaos is coming up... <br><br></td></tr></table><br>
<a name="661564"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> directx7.dll is the same as dx7test.dll<br>the name has just changed and i deleted the not-needed functions...<br><br>ps: daredevil, how is your progress? <br><br></td></tr></table><br>
<a name="661573"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> the my proces is good i have found a litle bug in the initobject, this bug have effect in the load object that contain object null.<br><br>aptend a new version, what completed this you join the my system your.<br><br>ok!! bye ;) <br><br></td></tr></table><br>
<a name="661974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >t3K|Mac</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks for the clear up. <br><br></td></tr></table><br>
<a name="661979"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have integred your stencil buffer in the my systems is fast !!!<br><br>:) <br><br></td></tr></table><br>
<a name="661986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> GOOD!<br>a software stencil buffer is not very useful in games... <br><br></td></tr></table><br>
<a name="662027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> this is a link<br><br><a href="http://digilander.libero.it/enzo_light/shw08.zip" target="_blank">http://digilander.libero.it/enzo_light/shw08.zip</a><br><br>lock software, the time systems is not correct o stencil buffer hardware has a slow speed<br><br>is fast the software simulate end not hardware?<br><br><br>bye <br><br></td></tr></table><br>
<a name="662046"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> hey, thats not bad...man thats good! :)<br>yes, sure the hardware stencil buffer is faster... but there is a little bug...don't mid, i'll fix it soon!<br>the initobject() takes half a minute in the first sample, and there are &gt;only&lt; 2 spehres with 32 segments... quite to slowly for a real stencil shadow system ;)<br><br>have you got any idea what we could do?<br><br>edit: i noticed that you are better in creating volumes, and i am better in making it work with hardware, multilights and so on..<br><br>what about, that we could make s shadow system together? then we would be a team for this system! ok?<br>if you have icq or msn, you could give me your icq/msn number and we could chat a lil bit... <br><br></td></tr></table><br>
<a name="662096"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> i'm not use icq :(<br><br>i have create the system silouette for permit a the new programmers the use software complet and simple that blitzbasic3d.<br><br>i'm ex programmer professional i have programmed wing commander prophecy for GBA and one part R-Type III by www.raylight.it studios Naples Italy.<br><br><a href="http://www.mobygames.com/developer/sheet/view/developerId,166785/" target="_blank">http://www.mobygames.com/developer/sheet/view/developerId,166785/</a><br><br>The team for shadow? yes!!!<br><br>the my old team hobby is Eye&amp;Light the link:<br><br><a href="http://digilander.libero.it/eyeandlight/index.htm" target="_blank">http://digilander.libero.it/eyeandlight/index.htm</a><br><br>bye <br><br></td></tr></table><br>
<a name="662148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> well, on www.icq.com you can download icq, then you must create an account and in my signature is my icq number, so you can easily find me :)<br><br>edit: here is OUR worklog :)<br><a href="http://www.blitzbasic.com/logs/userlog.php?user=8270&amp;log=660" target="_blank">http://www.blitzbasic.com/logs/userlog.php?user=8270&amp;log=660</a> <br><br></td></tr></table><br>
<a name="662652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have played arround with shw08 for a few hours and i heve noticed that if you set the m4 mesh as a shadow caster, the shadow of that mesh looks anyhow...strange... <br><br></td></tr></table><br>
<a name="662791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good !!<br><br>i programmed the silouette in c++ for fast result and return the all<br><br><br>?????<br><br>bye <br><br></td></tr></table><br>
<a name="662812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> in c++? well... you may can make a volume dll for blitz, that would be the best :) <br><br></td></tr></table><br>
<a name="663101"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have test the limits blitz, is view no screen the problem slow stencil, i have correct common type for max speed, and abjust your stencil sistem, lock gemedev site.<br><br>The new update:<br><br>digilander.libero.it/enzo_light/shw09.zip <br><br></td></tr></table><br>
<a name="663116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> You've got a major memory leak somewhere ...  my system ran out of virtual memory after about 5 mins of running the shw example.  Was a bugger to close it down.<br><br>Looks nice though .. assume the low res version is software stencils?<br><br>Stevie <br><br></td></tr></table><br>
<a name="663958"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> how about making a solution in c++, and making a blitz dll? this would be the fastest solution EVER! <br><br></td></tr></table><br>
<a name="664308"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok new update:D silhouette fast speed up 10% resolved bug in common and general optimizzation .<br><br>Test this version <br><br>bye all<br><br><a href="http://digilander.libero.it/enzo_light/shw10.zip" target="_blank">http://digilander.libero.it/enzo_light/shw10.zip</a> <br><br></td></tr></table><br>
<a name="664507"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have checked out the shw10 and there is a critical bug:<br><br><img src="http://patrick-sch.de/screens/Screen24.jpg"><br><br>i don't know how this strip accures...the object has got only one surface. with the m4 model you see those strips, too! <br><br></td></tr></table><br>
<a name="664660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know this bug, but it has not been never resolved!!<br>perhaps the error is caused gives of connected the well faces not caused from the export<br>this bug I have an idea of like resolving it, I will insert a<br>tolerance on you concern to us<br>I have increased of an other 10% the performances of the silouette but it I have not still Posted perhaps why I succeed in 1/2 the speed <br><br></td></tr></table><br>
<a name="665586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> news: i have checked out the tfp libary from marksibly for tformpoint() commands on animated b3d meshes.<br>but there are too much bugs, so i cannot use it...<br><br>how is your progress? <br><br></td></tr></table><br>
<a name="665627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got those strips when my quad faces were oriented backwards.<br><br>Test a third vertex along either of the triangles that make up the edge.  Use the orientation of that vertex relative to the plane equation created by the quad to test which direction the quad should face. <br><br></td></tr></table><br>
<a name="665664"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tom</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> Geometry is at fault here, not your code!<br><br>The strip is because the mesh is not a closed mesh. Shadow volumes must be completely closed, or consist of groups of closed meshes.<br><br>See...<br><img src="http://www.tomspeed.com/impmouth.jpg"><br><br>The red and green lines show where an edge is exposed. Idealy, the 'top lip' red edge and the 'mouth cavity' blue edge should be spanned with polys. similarly, the green line should be joint to the lower mouth cavity inside :) <br><br></td></tr></table><br>
<a name="665685"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another tip:<br><br>When you are building the mesh edges, do NOT look for triangles that share vertices.  You may have two different vertices in the same position, because of normals or texture mapping.  Instead, look for triangles that share vertices that have an identical position.  Compare the absolute value of the difference between each component of the vertex positions, and consider them the same if they less than a very small precision value, like 0.001:<br><br>Function VerticesMatch(surf,a,b)<br>If Abs(VertexX(surf,a)-VertexX(surf,b))&lt;0.001<br>If Abs(VertexY(surf,a)-VertexY(surf,b))&lt;0.001<br>If Abs(VertexZ(surf,a)-VertexZ(surf,b))&lt;0.001<br>Return True<br>Endif<br>Endif<br>Endif<br>End Function <br><br></td></tr></table><br>
<a name="665800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok!! for you the new update :D<br><br>the bug face is not resolved is the problem is object :(<br><br>ok pleace test the new version and check with others object<br><br><br>the new step is carmak sistem and multi light range<br><br>digilander.libero.it/enzo_light/shw11.zip <br><br>equation plane intersect rect?<br><br>bye <br><br></td></tr></table><br>
<a name="665881"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> here is the new dll for the stencil buffer:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=59699" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=59699</a><br><br>use this instead of mine, because this one is better^^ <br><br></td></tr></table><br>
<a name="666243"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> the new version "shadowinclude", i have a problem for procedure tom for robust shadow pleace help me!!! :(<br>i have optmized other than for fast silhouette<br><br>the time render is very slow <br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;======================================= 
;--------------------------------------- 
; 
;   Name file: Shadow_Include
; 
;   Programmatore: 
;      Caldarulo Vincenzo (Eye &amp; Light) 
;   Descrizione: 
;			Creazione dei volumi d'ombra
; 
;--------------------------------------- 
;======================================= 
Include"commontype.bb"
;Include"cost.bb"
;======================================= 
;--------------------------------------- 
; Variabili ShadowVolume 
;--------------------------------------- 
;=======================================
;
;D3DCULL
Const D3DCULL_NONE				= 1
Const D3DCULL_CW					= 2
Const D3DCULL_CCW					= 3
		
;D3DSHADE_MODE
Const D3DSHADE_FLAT			= 1
Const D3DSHADE_GOURAUD	= 2
Const D3DSHADE_PHONG		= 3

;D3DFILL_MODE
Const D3DFILL_POINT			= 1
Const D3DFILL_WIREFRAME	= 2
Const D3DFILL_SOLID			= 3

;D3DSTENCILOP
Const D3DSTENCILOP_KEEP           = 1
Const D3DSTENCILOP_ZERO           = 2
Const D3DSTENCILOP_REPLACE        = 3
Const D3DSTENCILOP_INCRSAT        = 4
Const D3DSTENCILOP_DECRSAT        = 5
Const D3DSTENCILOP_INVERT         = 6
Const D3DSTENCILOP_INCR           = 7
Const D3DSTENCILOP_DECR           = 8
Const D3DSTENCILOP_FORCE_DWORD    = $7fffffff	;force 32-bit size enum

;D3DCMPFUNC
Const D3DCMP_NEVER               = 1
Const D3DCMP_LESS                = 2
Const D3DCMP_EQUAL               = 3
Const D3DCMP_LESSEQUAL           = 4
Const D3DCMP_GREATER             = 5
Const D3DCMP_NOTEQUAL            = 6
Const D3DCMP_GREATEREQUAL        = 7
Const D3DCMP_ALWAYS              = 8
Const D3DCMP_FORCE_DWORD         = $7fffffff	;force 32-bit size enum

;D3DBLEND
Const D3DBLEND_ZERO              = 1
Const D3DBLEND_ONE               = 2
Const D3DBLEND_SRCCOLOR          = 3
Const D3DBLEND_INVSRCCOLOR       = 4
Const D3DBLEND_SRCALPHA          = 5
Const D3DBLEND_INVSRCALPHA       = 6
Const D3DBLEND_DESTALPHA         = 7
Const D3DBLEND_INVDESTALPHA      = 8
Const D3DBLEND_DESTCOLOR         = 9
Const D3DBLEND_INVDESTCOLOR      = 10
Const D3DBLEND_SRCALPHASAT       = 11
Const D3DBLEND_BOTHSRCALPHA      = 12
Const D3DBLEND_BOTHINVSRCALPHA   = 13
Const D3DBLEND_FORCE_DWORD       = $7fffffff	;force 32-bit size enum
;===&gt;
Const D3DRS_ANTIALIAS          = 2    ; D3DANTIALIASMODE */
Const D3DRS_TEXTUREPERSPECTIVE = 4    ; True For perspective correction */
Const D3DRS_ZENABLE            = 7    ; D3DZBUFFERTYPE (Or True/False For legacy) */
Const D3DRS_FILLMODE           = 8    ; D3DFILL_MODE        */
Const D3DRS_SHADEMODE          = 9    ; D3DFILL_MODE */
Const D3DRS_LINEPATTERN        = 10   ; D3DLINEPATTERN */
Const D3DRS_ZWRITEENABLE       = 14   ; True To enable z writes */
Const D3DRS_ALPHATESTENABLE    = 15   ; True To enable alpha tests */
Const D3DRS_LASTPIXEL          = 16   ; True For Last-pixel on lines */
Const D3DRS_SRCBLEND           = 19   ; D3DBLEND */
Const D3DRS_DESTBLEND          = 20   ; D3DBLEND */
Const D3DRS_CULLMODE           = 22   ; D3DCULL */
Const D3DRS_ZFUNC              = 23   ; D3DCMPFUNC */
Const D3DRS_ALPHAREF           = 24   ; D3DFIXED (long) */
Const D3DRS_ALPHAFUNC          = 25   ; D3DCMPFUNC */
Const D3DRS_DITHERENABLE       = 26   ; True To enable dithering */
Const D3DRS_ALPHABLENDENABLE   = 27   ; True To enable alpha blending */
Const D3DRS_FOGENABLE          = 28   ; True To enable fog blending */
Const D3DRS_SPECULARENABLE     = 29   ; True To enable specular */
Const D3DRS_ZVISIBLE           = 30   ; True To enable z checking */
Const D3DRS_STIPPLEDALPHA      = 33   ; True To enable stippled alpha (RGB device only) */
Const D3DRS_FOGCOLOR           = 34   ; D3DCOLOR */  INT (((a) &lt;&lt; 24) Or ((r) &lt;&lt; 16) Or ((g) &lt;&lt; 8) Or (b)))
Const D3DRS_FOGTABLEMODE       = 35   ; D3DFOGMODE */
Const D3DRS_FOGSTART           = 36   ; Float Fog start (For both vertex And pixel fog) 
Const D3DRS_FOGEND             = 37   ; Float Fog End      */
Const D3DRS_FOGDENSITY         = 38   ; Fog density  */
Const D3DRS_EDGEANTIALIAS      = 40   ; True To enable edge antialiasing */
Const D3DRS_COLORKEYENABLE     = 41   ; True To enable source colorkeyed textures */
Const D3DRS_ZBIAS              = 47   ; LONG Z bias */
Const D3DRS_RANGEFOGENABLE     = 48   ; Enables range-based fog */
; *** STENCIL OPS ***
Const D3DRS_STENCILENABLE      = 52   ; BOOL enable/disable stenciling
Const D3DRS_STENCILFAIL        = 53   ; D3DSTENCILOP To do If stencil test fails
Const D3DRS_STENCILZFAIL       = 54   ; D3DSTENCILOP To do If stencil test passes And Z test fails
Const D3DRS_STENCILPASS        = 55   ; D3DSTENCILOP To do If both stencil And Z tests pass */
Const D3DRS_STENCILFUNC        = 56   ; D3DCMPFUNC fn.  Stencil Test passes If ((ref &amp; mask) stencilfn (stencil &amp; mask)) is True */
Const D3DRS_STENCILREF         = 57   ; INT Reference value used in stencil test */
Const D3DRS_STENCILMASK        = 58   ; Mask value used in stencil test  e.g (0xffffffff)
Const D3DRS_STENCILWRITEMASK   = 59   ; Write mask applied To values written To stencil buffer e.g (0xffffffff)
Const D3DRS_TEXTUREFACTOR      = 60   ; D3DCOLOR used For multi-texture blend */
Const D3DCLEAR_TARGET					= $00000001	;Clear target surface
Const D3DCLEAR_ZBUFFER				= $00000002	;Clear target z buffer
Const D3DCLEAR_STENCIL				= $00000004	;Clear Stencil
;ERRORS
Const D3DERR_ZBUFFER_NOTPRESENT					= 2070
Const D3DERR_STENCILBUFFER_NOTPRESENT		= 2071
Const D3DERR_VIEWPORTHASNODEVICE				= 774
Const DDERR_INVALIDOBJECT								= 130
Const DDERR_INVALIDPARAMS								= $80070057

;===&gt;
Global Direct3DDevice7 = SystemProperty$("Direct3DDevice7")
Global Direct3D7 = SystemProperty$("Direct3D7")
Global DirectDraw7 = SystemProperty$("DirectDraw7")
Global DirectInput7 = SystemProperty$("DirectInput7")
Global AppHWND = SystemProperty$("AppHWND")
Global AppHINSTANCE = SystemProperty$("AppHINSTANCE")

;===&gt;
Type EdgeToEdge
	Field IdModel
	Field cntSurface
	Field Surfaces.ETE_Surface
End Type
;===&gt;
Type ETE_Surface
	Field IdSurface
	Field cntTriangle
	Field IdTriangle.ETE_Triangle[ETE_MaxTriang]
End Type
;===&gt;
Type ETE_Triangle
	Field Normal.Point3D
	Field a.Point3D
	Field b.Point3D
	Field c.Point3D
	Field Triangle
	Field ATriangle
	Field BTriangle
	Field CTriangle
End Type
;===&gt;
;=======================================
;===&gt;
Const SHWTexSize = 128; Parametro di regolazione Ombra
Const sh_level# = 0.1
Const ETE_MaxTriang=65000
Const SHWL3D = 65000
Const Tolerance#=0.01
Const MaxEdgeCamera=1000
;===&gt;
;======================================= 
;===&gt;
Dim TriangleClone.ETE_Triangle(ETE_MaxTriang)
Dim EdgeCamera.Point3D(MaxEdgeCamera)
Dim AD(65000,2)
;===&gt;
;======================================= 
;===&gt;
Global CNTEdgeCamera = 0
;===&gt;
Global Scena = CreatePivot(); CreateSphere(5)
Global result$=""
;===&gt;
Global MeshFront = CreateMesh(); 
Global SurfaceFront = CreateSurface(MeshFront); 
EntityAlpha MeshFront, sh_level 
EntityFX MeshFront,1;4
EntityBlend MeshFront,3
;===&gt;
Global cntLine3D=0
Dim Line3DAX#(SHWL3D)
Dim Line3DAY#(SHWL3D)
Dim Line3DAZ#(SHWL3D)
Dim Line3DBX#(SHWL3D)
Dim Line3DBY#(SHWL3D)
Dim Line3DBZ#(SHWL3D)
;===&gt;
;Creiamo il piano che proietterà l'ombra
;===&gt;
Global SHWScreenImage = CreateImage(SHWTexSize,SHWTexSize)
Global SHWSpriteFront=CreateSprite()
SpriteViewMode SHWSpriteFront,1
EntityFX SHWSpriteFront,1
;===&gt;
Global sh_light.Point3D = New Point3D 
;===&gt;
Global SHW_ETE_Object.EdgeToEdge
;===&gt;
Global sh_lenght# = 0
Global CRValX# = 0
Global CRValY# = 0
Global CRValZ# = 0
;===&gt;
; Equazione del piano e intersezione della retta
Global PickX# = 0
Global PickY# = 0
Global PickZ# = 0
Global PickD# = 0
Global Zfail#=0.0 

;======================================= 
;===&gt;
;=======================
; 
Function CheckVertex_orig%(a.Point3D,b.Point3D)
	If (a\x=b\x)And(a\y=b\y)And(a\z=b\z) Then
		Return True 
	Else
		Return False 
	EndIf 
End Function 

Function CheckVertex%(a.Point3D,b.Point3D)
	If Abs(a\x-b\x) &lt; Tolerance
		If Abs(a\y-b\y) &lt; Tolerance
			If Abs(a\z-b\z) &lt; Tolerance
				Return True 
			Else
				Return False 
			EndIf
		Else
			Return False 
		EndIf
	Else
		Return False 
	EndIf

End Function 
;======================================================================= 
;======================================================================= 
; Shadow Volume For silhouette Method Edge to Edge
;======================================================================= 
;======================================================================= 
;======================= 
; Inizialize Object Shadow
Function SHW_Init()
;	DX_D3D=SystemProperty$("Direct3D7")
;	DX_DEV7=SystemProperty$("Direct3DDevice7")
;	DX_DRAW7=SystemProperty$("DirectDraw7")
;	DX_HWND=SystemProperty$("AppHWND")
;	DX_INSTANCE=SystemProperty$("AppHINSTANCE")
;
;	Direct3DDevice7 = SystemProperty$("Direct3DDevice7")
	;===&gt;
	; Search surface and triangle object
	For n=0 To ETE_MaxTriang
		;===&gt;
		TriangleClone.ETE_Triangle(n) = New ETE_Triangle
		;===&gt;
		TriangleClone(n)\Normal.Point3D = New Point3D
		TriangleClone(n)\a.Point3D = New Point3D
		TriangleClone(n)\b.Point3D = New Point3D
		TriangleClone(n)\c.Point3D = New Point3D
	Next
	;===&gt;
	For n=0 To MaxEdgeCamera
		EdgeCamera.Point3D(n) = New Point3D
	Next
	;===&gt;

	ShwInitDisplay()

End Function 
;======================= 
;
Function ShwInitDisplay()
	;===&gt;
	EntityParent(SHWSpriteFront,Camera) 
;	PositionEntity SHWSpriteFront,-0.005,+0.005,1.001 
	PositionEntity SHWSpriteFront,0,0,1.001 
	;===&gt;
End Function 
;=======================
; Inizialize Object Shadow
Function SHW_InitObject$(model)
	Time$=""
	Tim1=MilliSecs()

	Local Norm.Point3D = New Point3D
	Local IdSurface.ETE_Surface
	Local IdTriang.ETE_Triangle
	Local BTriang.ETE_Triangle
	Local IdN.Point3D
	Local IdA.Point3D
	Local IdB.Point3D
	Local IdC.Point3D
	Local IdBA.Point3D
	Local IdBB.Point3D
	Local IdBC.Point3D
	Local a%
	Local b%
	Local check1%
	Local check2%
	Local check3%
	Local check4%
	Local state1%
	Local state2
	Local state3%
	;===&gt;
	SHW_ETE_Object.EdgeToEdge = New EdgeToEdge
	SHW_ETE_Object\IdModel = model
	;===&gt;
	; Search surface and triangle object
	SHW_ETE_Object\cntSurface = CountSurfaces(model)-1
	For n=0 To SHW_ETE_Object\cntSurface
		;===&gt;
		surf = GetSurface(model,n+1)
		NumFaces = CountTriangles(surf)-1
		;===&gt;
		SHW_ETE_Object\Surfaces.ETE_Surface = New  ETE_Surface
		IdSurface.ETE_Surface = SHW_ETE_Object\Surfaces
		;===&gt;
		IdSurface\IdSurface = surf
		IdSurface\cntTriangle = NumFaces
		For v=0 To NumFaces
			;===&gt;
			IdSurface\IdTriangle.ETE_Triangle[v] = New ETE_Triangle
			IdTriang.ETE_Triangle = IdSurface\IdTriangle[v]
			;===&gt;
			IdTriang\normal.Point3D = New Point3D
			IdTriang\a.Point3D = New Point3D
			IdTriang\b.Point3D = New Point3D
			IdTriang\c.Point3D = New Point3D
			IdN.Point3D = IdTriang\normal
			IdA.Point3D = IdTriang\a
			IdB.Point3D = IdTriang\b
			IdC.Point3D = IdTriang\c
			;===&gt; 
			vert0 = TriangleVertex(surf,v,0)
			vert1 = TriangleVertex(surf,v,1)
			vert2 = TriangleVertex(surf,v,2)
			;===&gt;
			IdA\x = VertexX( surf, vert0) : IdA\y = VertexY( surf, vert0) : IdA\z = VertexZ( surf, vert0)
			;===&gt; 
			IdB\x = VertexX( surf, vert1) : IdB\y = VertexY( surf, vert1) : IdB\z = VertexZ( surf, vert1)
			;===&gt; 
			IdC\x = VertexX( surf, vert2) : IdC\y = VertexY( surf, vert2) : IdC\z = VertexZ( surf, vert2)
			;===&gt;
			;IdN\x= (VertexNX( surf, vert0) + VertexNX( surf, vert1) + VertexNX( surf, vert2))/3
			;IdN\y= (VertexNY( surf, vert0) + VertexNY( surf, vert1) + VertexNY( surf, vert2))/3
			;IdN\z= (VertexNZ( surf, vert0) + VertexNZ( surf, vert1) + VertexNZ( surf, vert2))/3
			CalcNormal( IdN, IdA, IdB, IdC)
			V_3Normalize( IdN, IdN) 
			;===&gt;
			IdTriang\Triangle = v
			IdTriang\ATriangle = -1
			IdTriang\BTriangle = -1
			IdTriang\CTriangle = -1
			;===&gt;
		Next 
		;===&gt;
		; Search adjacent triangle
		;===&gt;
		; ottimizzazione precalcolo
		For a=0 To IdSurface\cntTriangle
			AD(a,0)=1 : AD(a,1) = 1 : AD(a,2) = 1
		Next
		;===&gt;
		For a=0 To IdSurface\cntTriangle
			;===&gt;
			ATriang.ETE_Triangle = IdSurface\IdTriangle[a]
			IdA.Point3D = ATriang\a
			IdB.Point3D = ATriang\b
			IdC.Point3D = ATriang\c
			;===&gt;
			For b=a+1 To IdSurface\cntTriangle
				;===&gt;
				state1=AD(b,0) : state2=AD(b,1) : state3=AD(b,2)
				If a=b Or ( state1=0 And state2=0 And state3=0 ) Then Goto SIDEC
				;===&gt;
				BTriang.ETE_Triangle = IdSurface\IdTriangle[b]
				IdBA.Point3D = BTriang\a
				IdBB.Point3D = BTriang\b
				IdBC.Point3D = BTriang\c
				;*********************************************************************
				; SIDE " A "
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato A del 2° Triangolo)
				If (state1=1)Then
					;===&gt;
					check1 = CheckVertex( IdA, IdBA )
					check2 = CheckVertex( IdB, IdBB )
					check3 = CheckVertex( IdA, IdBB )
					check4 = CheckVertex( IdB, IdBA )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\ATriangle = b
						BTriang\ATriangle = a
						AD(b,0)=0
						Goto SIDEA
						;Stop
					EndIf
					;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato B del 2° Triangolo)
				If (state2=1)Then
					;===&gt;
					check1 = CheckVertex( IdA, IdBB )
					check2 = CheckVertex( IdB, IdBC )
					check3 = CheckVertex( IdA, IdBC )
					check4 = CheckVertex( IdB, IdBB )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\ATriangle = b
						BTriang\BTriangle = a
						AD(b,1)=0
						Goto SIDEA
						;Stop
					EndIf
					;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato A del 1° triangolo confina con lato C del 2° Triangolo)
				If (state3=1)Then
					;===&gt;
					check1 = CheckVertex( IdA, IdBC )
					check2 = CheckVertex( IdB, IdBA )
					check3 = CheckVertex( IdA, IdBA )
					check4 = CheckVertex( IdB, IdBC )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\ATriangle = b
						BTriang\CTriangle = a
						AD(b,2)=0
						;Stop
					EndIf
					;===&gt;
				EndIf
				.SIDEA
				;===&gt;
				;*********************************************************************
				; SIDE " B "
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato A del 2° Triangolo)
				If (state1=1)Then
					;===&gt;
					check1 = CheckVertex( IdB, IdBA )
					check2 = CheckVertex( IdC, IdBB )
					check3 = CheckVertex( IdB, IdBB )
					check4 = CheckVertex( IdC, IdBA )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\BTriangle = b
						BTriang\ATriangle = a
						AD(b,0)=0
						Goto SIDEB
						;Stop
					EndIf 
					;===&gt;
				EndIf 
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato B del 2° Triangolo)
				If (state2=1)Then
					;===&gt;
					check1 = CheckVertex( IdB, IdBB )
					check2 = CheckVertex( IdC, IdBC )
					check3 = CheckVertex( IdB, IdBC )
					check4 = CheckVertex( IdC, IdBB )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\BTriangle = b
						BTriang\BTriangle = a
						AD(b,1)=0
						Goto SIDEB
						;Stop
					EndIf
					;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato B del 1° triangolo confina con lato C del 2° Triangolo)
				If (state3=1)Then
					;===&gt;
					check1 = CheckVertex( IdB, IdBC )
					check2 = CheckVertex( IdC, IdBA )
					check3 = CheckVertex( IdB, IdBA )
					check4 = CheckVertex( IdC, IdBC )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\BTriangle = b
						BTriang\CTriangle = a
						AD(b,2)=0
						;Stop
					EndIf
					;===&gt;
				EndIf
				.SIDEB
			;===&gt;
				;*********************************************************************
				; SIDE " C "
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato A del 2° Triangolo)
				If (state1=1)Then
					;===&gt;
					check1 = CheckVertex( IdC, IdBA )
					check2 = CheckVertex( IdA, IdBB )
					check3 = CheckVertex( IdC, IdBB )
					check4 = CheckVertex( IdA, IdBA )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\CTriangle = b
						BTriang\ATriangle = a
						AD(b,0)=0
						Goto SIDEC
						;Stop
					EndIf
				;===&gt;
				EndIf
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato B del 2° Triangolo)
				If (state2=1)Then
					;===&gt;
					check1 = CheckVertex( IdC, IdBB )
					check2 = CheckVertex( IdA, IdBC )
					check3 = CheckVertex( IdC, IdBC )
					check4 = CheckVertex( IdA, IdBB )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\CTriangle = b
						BTriang\BTriangle = a
						AD(b,1)=0
						Goto SIDEC
						;Stop
					EndIf
					;===&gt;
				EndIf 
				;===&gt;
				; Adjacent side A (il lato C del 1° triangolo confina con lato C del 2° Triangolo)
				If (state3=1)Then
					;===&gt;
					check1 = CheckVertex( IdC, IdBC )
					check2 = CheckVertex( IdA, IdBA )
					check3 = CheckVertex( IdC, IdBA )
					check4 = CheckVertex( IdA, IdBC )
					;===&gt;
					If  (check1 And check2) Or (check3 And check4) Then
						ATriang\CTriangle = b
						BTriang\CTriangle = a
						AD(b,2)=0
						;Stop
					EndIf
					;===&gt;
				EndIf
				.SIDEC
				;===&gt;
			Next
			;===&gt;
		Next 
		;===&gt;
	Next
	;===&gt;
	Delete Norm
	;===&gt;
	Tim2=MilliSecs()
	Time$="Time Precalcolo: "+(Tim2-Tim1)
	Return Time$
	;===&gt;
End Function 
;=======================
; Inizialize Object Shadow
Function CloneListTriangle(dst.ETE_Triangle,src.ETE_Triangle)
	;===&gt;
	V_3Copy( dst\Normal, src\Normal)
	V_3Copy( dst\a, src\a)
	V_3Copy( dst\b, src\b)
	V_3Copy( dst\c, src\c)
	dst\Triangle = src\Triangle
	dst\ATriangle = src\ATriangle
	dst\BTriangle = src\BTriangle
	dst\CTriangle = src\CTriangle
	;===&gt;
End Function 
;=======================
Function ResetShadowVolume()
	ClearSurface SurfaceFront;
	CNTEdgeCamera = 0

End Function 
;======================= 
; Shadows Volume start 
Function ShadowVolume$( Light, LightLenght, ShowVol=False, SBHardware=False )
	;===&gt;
	ResetShadowVolume()
	;===&gt;
	sh_light\x = EntityX(Light) : sh_light\y = EntityY(Light) : sh_light\z = EntityZ(Light) 
	sh_lenght = LightLenght 
	;===&gt;
	cntLine3D=0
	;===&gt;
	UpdateWorld()
	;===&gt;
	result$ = ShadowVolumeCreate3()
	;===&gt;
	ShadowVolumeStenciBuffer( ShowVol ) ; gestione hardware
	;===&gt;
	Return result$
	;===&gt;
End Function 
;=======================
; Calcolo del raggio
; 
Function CalcRay(Rtn.Point3D,val1.Point3D, val2.Point3D, Leght#)
	;----&gt; 
	CRValX# = val1\x - val2\x; 
	CRValY# = val1\y - val2\y; 
	CRValZ# = val1\z - val2\z;
	;----&gt; 
	do# = (1.0 / Sqr( ( CRValX * CRValX ) + ( CRValY * CRValY ) + ( CRValZ * CRValZ ) ) ) * Leght
	;----&gt;
	Rtn\x = val1\x + ( CRValX * do ); 
	Rtn\y = val1\y + ( CRValY * do ); 
	Rtn\z = val1\z + ( CRValZ * do );
	;----&gt; 
End Function 

;=======================
; Intersezione piano - retta
; questa fuzione verrà divisa in equazione del piano e intersezione della retta  per ottimizzazione maggiore 
Function Pick_GetCoordinate( Retta.Point3D, RettaVect.Point3D, P1.Point3D, P2.Point3D, P3.Point3D )
	;===&gt;
	Local DirCam.Point3D = New Point3D
	; fattori Equazione piano
	Local a#
	Local b#
	Local c#
	Local d#
	;===&gt;
	Local k#
	;===&gt;
	; Equazione del piano
	; a = (y2-y1)*(z3-z1) - (z2-z1)*(y3-y1)
	; b = (z2-z1)*(x3-x1) - (x2-x1)*(z3-z1);
	; c = (x2-x1)*(y3-y1) - (y2-y1)*(x3-x1);

	; d =((z2-z1)*(y3-y1) - (y2-y1)*(z3-z1))*x1 + 
	;		((x2-x1)*(z3-z1) - (z2-z1)*(x3-x1))*y1 + 
	;		((y2-y1)*(x3-x1) - (x2-x1)*(y3-y1))*z1;
	;===&gt;
	a = ((P2\y-P1\y)*(P3\z-P1\z)) - ((P2\z-P1\z)*(P3\y-P1\y));
	b = ((P2\z-P1\z)*(P3\x-P1\x)) - ((P2\x-P1\x)*(P3\z-P1\z));
	c = ((P2\x-P1\x)*(P3\y-P1\y)) - ((P2\y-P1\y)*(P3\x-P1\x));

	d =	((P2\z-P1\z)*(P3\y-P1\y) - (P2\y-P1\y)*(P3\z-P1\z))*P1\x + ((P2\x-P1\x)*(P3\z-P1\z) - (P2\z-P1\z)*(P3\x-P1\x))*P1\y + ((P2\y-P1\y)*(P3\x-P1\x) - (P2\x-P1\x)*(P3\y-P1\y))*P1\z;

;	a =  (P1\y*P2\z)+(P2\y*P3\z)+(P1\z*P3\y)-(P3\y*P2\z)-(P3\z*P1\y)-(P2\y*P1\z);
;	b = -(P1\x*P2\z)-(P1\z*P3\x)-(P2\x*P3\z)+(P3\x*P2\z)+(P1\x*P3\z)+(P2\x*P1\z);
;	c =  (P1\x*P2\y)+(P1\y*P3\x)+(P2\x*P3\y)-(P2\y*P3\x)-(P1\x*P3\y)-(P2\x*P1\y);
;	d = -(P1\x*P2\y*P3\z)-(P1\y*P2\z*P3\x)-(P2\x*P3\y*P1\z)+(P3\x*P2\y*P1\z)+(P3\y*P2\z*P1\x)+(P2\x*P1\y*P3\z);

	; ax+by+cz+d=0   =&gt;  a*x+b*y+c*z+d=0

	;===&gt;
	; Assegnazione termini noti
	; Retta - Retta vettore ( l m n )
	;===&gt;
	;k =   (( a*x0 + b*y0 + c*z0 + d ) 
	;		- ---------------------------
	;					( a*l + b*m + c*n));

	k = -(( a*Retta\x + b*Retta\y + c*Retta\z + d ) / ( a*RettaVect\x + b*RettaVect\y + c*RettaVect\z));

	;===&gt;
	; Intersezione
	PickX = Retta\x + ( RettaVect\x*k );
	PickY= Retta\y + ( RettaVect\y*k );
	PickZ = Retta\z + ( RettaVect\z*k );
	;===&gt;
	PickD = ( a*Retta\x + b*Retta\y + c*Retta\z + d )/Sqr( a*a + b*b + c*c );

End Function 

;=======================
; 
Function CreatePolygon( IdA.Point3D, RayA.Point3D, RayB.Point3D, IdB.Point3D)
	Local va=0
	Local vb=0
	Local vc=0
	Local vd=0
	;===&gt;
	va = AddVertex(SurfaceFront,  IdA\x,			IdA\y, 			IdA\z ); 
	vb = AddVertex(SurfaceFront,  RayA\x,	RayA\y,		RayA\z ); 
	vc = AddVertex(SurfaceFront,  RayB\x,	RayB\y,		RayB\z ); 
	vd = AddVertex(SurfaceFront,  IdB\x,			IdB\y, 			IdB\z ); 
	;===&gt;
	AddTriangle(SurfaceFront, va, vb, vc); faccia 1/3 a 
	AddTriangle(SurfaceFront, va, vc, vd); faccia 1/3 b
	;===&gt;
	Line3DAX(cntLine3D) = IdA\x : Line3DAY(cntLine3D) = IdA\y : Line3DAZ(cntLine3D) = IdA\z
	Line3DBX(cntLine3D) = IdB\x : Line3DBY(cntLine3D) = IdB\y : Line3DBZ(cntLine3D) = IdB\z
	cntLine3D=cntLine3D+1
;	;===================================================
;	;===&gt;
;	;TEST
;	Local Rrt.Point3D = New Point3D
;	Local P1.Point3D = New Point3D
;	Local P2.Point3D = New Point3D
;	Local P3.Point3D = New Point3D
;	Local PNormal.Point3D = New Point3D
;	;===&gt;
;	TFormPoint 0, 0 , Zfail , SHWSpriteFront, 0
;	P1\x = TFormedX() : P1\y = TFormedY() : P1\z = TFormedZ()
;	TFormPoint 0, 1 , Zfail , SHWSpriteFront, 0
;	P2\x = TFormedX() : P2\y = TFormedY() : P2\z = TFormedZ()
;	TFormPoint 1, 0 , Zfail , SHWSpriteFront, 0
;	P3\x = TFormedX() : P3\y = TFormedY() : P3\z = TFormedZ()
;	CalcNormal(PNormal,P1,P2,P3)
;	V_3Normalize( PNormal, PNormal )
;	;coordinate di test 
;	P1\x = -5 : P1\y = -5 : P1\z = Zfail
;	P2\x = -5 : P2\y = 5 : P2\z = Zfail
;	P3\x = 5 : P3\y = -5 : P3\z = Zfail
;	V_3Dec(RayA,RayA,IdA)
;	V_3Normalize( RayA, RayA )
;	Dot# = V_3Dot( PNormal, RayA ) 
;	If Dot&lt;0 Then 
;			;===&gt;
;			V_3Dec(RayB,RayB,IdB)
;			V_3Normalize( RayB, RayB )
;			;===&gt;
;			Pick_GetCoordinate( IdA, RayA, P1, P2, P3 )
;			Line3DAX(cntLine3D) = PickX : Line3DAY(cntLine3D) = PickY : Line3DAZ(cntLine3D) = PickZ
;			
;			EdgeCamera(CNTEdgeCamera)\x = PickX : EdgeCamera(CNTEdgeCamera)\y = PickY : EdgeCamera(CNTEdgeCamera)\z = PickZ
;			CNTEdgeCamera=CNTEdgeCamera+1
;			;===&gt;
;			Pick_GetCoordinate(  IdB, RayB, P1, P2, P3 )
;			Line3DBX(cntLine3D) = PickX : Line3DBY(cntLine3D) = PickY : Line3DBZ(cntLine3D) = PickZ
;		
;			EdgeCamera(CNTEdgeCamera)\x = PickX : EdgeCamera(CNTEdgeCamera)\y = PickY : EdgeCamera(CNTEdgeCamera)\z = PickZ
;			CNTEdgeCamera=CNTEdgeCamera+1
;			;===&gt;
;			cntLine3D=cntLine3D+1
;			;===&gt;
;	EndIf 
;	;===&gt;
;	Delete PNormal
;	Delete Rrt
;	Delete P1
;	Delete P2
;	Delete P3
;
End Function
;=======================
; Creazione volume
; forse si può fare ancora qualcosina!!
Function ShadowVolumeCreate3$()
	;===&gt; 
	t0=MilliSecs()
	;===&gt; 
	Local Result$ = ""
	;===&gt; 
	Local RayA.Point3D = New Point3D 
	Local RayB.Point3D = New Point3D 
	Local RayC.Point3D = New Point3D
	Local Norm.Point3D = New Point3D
	Local MidPoint.Point3D = New Point3D
	Local NormLight.Point3D = New Point3D
	;===&gt; 
	Local IdA.Point3D
	Local IdB.Point3D
	Local IdC.Point3D
	Local IdN.Point3D
	Local IdCLT.ETE_Triangle
	Local Surfaces.ETE_Surface
	;===&gt; 
	Local CNTFront=0
	Local CNTBack=0
	Local surf=0
	Local Dot#=0
	Local check1 = -1
	Local check2 = -1
	Local check3 = -1

	Local TriangA = 0
	Local TriangB = 0
	Local TriangC = 0
	;===&gt;
	Local v=0
	Local v1=0
	Local aSurf=0
	;===&gt;
	
	For SHW_ETE_Object.EdgeToEdge = Each EdgeToEdge
		;===&gt;
		; Cerchiamoci i vertici faccia vista verso la luce
		Surfaces = SHW_ETE_Object\Surfaces
		For aSurf = 0 To SHW_ETE_Object\cntSurface
			;===&gt;
			If Surfaces=Null Then Goto ErrorSurf
			surf = Surfaces\IdSurface
			dwNumFaces = Surfaces\cntTriangle
			v1=0
			;===&gt;
			For v=0 To dwNumFaces
				;===&gt;
				IdCLT = TriangleClone(v)
				CloneListTriangle( IdCLT,Surfaces\IdTriangle[v] )
				IdA = IdCLT\a
				IdB = IdCLT\b
				IdC = IdCLT\c
				IdN = IdCLT\Normal
				;===&gt;
				;associamo le trasformazioni ai vertici
				TFormPoint IdA\x, IdA\y , IdA\z, SHW_ETE_Object\IdModel, 0
				IdA\x = TFormedX() : IdA\y = TFormedY() : IdA\z = TFormedZ()
				;===&gt; 
				TFormPoint IdB\x, IdB\y , IdB\z, SHW_ETE_Object\IdModel, 0
				IdB\x = TFormedX() : IdB\y = TFormedY() : IdB\z = TFormedZ() 
				;===&gt; 
				TFormPoint IdC\x, IdC\y , IdC\z, SHW_ETE_Object\IdModel, 0
				IdC\x = TFormedX() : IdC\y = TFormedY() : IdC\z = TFormedZ() 
				;===&gt;
				TFormNormal  IdN\x, IdN\y , IdN\z, SHW_ETE_Object\IdModel, 0
				Norm\x = TFormedX() : Norm\y = TFormedY() : Norm\z = TFormedZ()
				;Stop
				V_3Mid(MidPoint, IdA, IdB, IdC) 
				V_3Dec(NormLight, MidPoint, sh_light)
				V_3Normalize( NormLight, NormLight )
				Dot# = V_3Dot( Norm, NormLight ) 
				;===&gt;
				; Marchiamo i vertici non rivolti verso la luce
				If Dot#=&gt;0.0 Then
					;===&gt;
					CNTFront=CNTFront+1
					v1=v1+1
					;===&gt;
				Else
					;===&gt;
					IdCLT\Triangle  = -1
					CNTBack=CNTBack+1
					;===&gt;
				EndIf
				;===&gt; 
			Next
			;===&gt;
			; Ora creiamo il volume
			TriangA = 0
			TriangB = 0
			TriangC = 0
			For v=0 To dwNumFaces
				;===&gt;
				IdCLT = TriangleClone(v)
				;===&gt;
				; Saltiamo il triangolo se è a -1
				If IdCLT\Triangle&lt;0 Then Goto continue
				;===&gt;
				TriangA = IdCLT\ATriangle
				TriangB = IdCLT\BTriangle
				TriangC = IdCLT\CTriangle
				If TriangA&gt;-1 Then check1 = TriangleClone(TriangA)\Triangle Else check1 = -1
				If TriangB&gt;-1 Then check2 = TriangleClone(TriangB)\Triangle Else check2 = -1
				If TriangC&gt;-1 Then check3 = TriangleClone(TriangC)\Triangle Else check3 = -1
				;===&gt;
				If check1&gt;-1 And check2&gt;-1 And check3&gt;-1  Then Goto continue
				;===&gt;
				;Stop
				IdA =  IdCLT\a
				IdB =  IdCLT\b
				IdC =  IdCLT\c
				;===&gt;
				;Edge A
				If check1&lt;0 Then

					;===&gt;
					;Calcolo raggio A
					CalcRay( RayA, IdA, sh_light, sh_lenght)
					;===&gt;
					;Calcolo raggio B
					CalcRay( RayB, IdB, sh_light, sh_lenght)
					;===&gt;
					CreatePolygon(IdA,RayA,RayB,IdB)
					;===&gt;
				EndIf
				;===&gt;
				;Edge B
				If check2&lt;0 Then
					;===&gt;
					;Calcolo raggio B
					CalcRay( RayB, IdB, sh_light, sh_lenght)
					;===&gt;
					;Calcolo raggio C
					CalcRay( RayC, IdC, sh_light, sh_lenght)
					;===&gt;
					CreatePolygon(IdB,RayB,RayC,IdC)
					;===&gt;
				EndIf 
				;===&gt;
				;Edge C
				If check3&lt;0 Then
					;===&gt;
					;Calcolo raggio A
					CalcRay( RayA, IdA, sh_light, sh_lenght)
					;===&gt;
					;Calcolo raggio C
					CalcRay( RayC, IdC, sh_light, sh_lenght)
					;===&gt;
					CreatePolygon(IdC,RayC,RayA,IdA)
					;===&gt;
				EndIf 
				;===&gt;
				.continue
				;===&gt;
			Next 
			;===&gt;
			Surfaces = After Surfaces
			.ErrorSurf
			;===&gt;
		Next
		;===&gt;
	Next
	;===&gt; 
	For v=0 To CNTEdgeCamera-1 Step 2
		;===&gt; 
		va = AddVertex(SurfaceFront,  EdgeCamera(v+0)\x, EdgeCamera(v+0)\y, EdgeCamera(v+0)\z ); 
		vc = AddVertex(SurfaceFront,  EdgeCamera(v+1)\x, EdgeCamera(v+1)\y, EdgeCamera(v+0)\z ); 
		vb = AddVertex(SurfaceFront,  EdgeCamera(v+2)\x, EdgeCamera(v+2)\y, EdgeCamera(v+0)\z ); 
		;===&gt;
		AddTriangle(SurfaceFront, va, vb, vc); faccia 1/3 a 
		;===&gt; 
	Next
	;===&gt;
	Delete MidPoint
	Delete NormLight
	Delete Norm
	Delete RayA
	Delete RayB
	Delete RayC
	;===&gt;
	t1=MilliSecs()
	t2=t1-t0
	Result$=Result$+"==&gt; Face Front: "+CNTFront+"  Face Back: "+CNTBack+"  Edge: "+cntLine3D + " Tim-Vert: " + t2 
	;===&gt; 
	Return Result$
	;===&gt; 
End Function 
;=======================
;
Function SHWLine3D()
	;===&gt;
	Color 0,255,0
	;===&gt;
	For a=0 To cntLine3D-1
		Line3D( Line3DAX(a), Line3DAY(a), Line3DAZ(a), Line3DBX(a), Line3DBY(a), Line3DBZ(a))
	Next
	cntLine3D=0
	;===&gt;
	Color 255,255,255
	;===&gt;
End Function
;=======================
; Creazione immagine ombra
; Fast2 ?
Function ShadowVolumeStenciBuffer_orig(ShowVol)
	EntityColor SHWSpriteFront, 5, 5, 5
	EntityAlpha SHWSpriteFront, 0.3
	;===&gt;
	;SetBuffer  TextureBuffer(ShwTex1)
	;Cls 
	SetBuffer BackBuffer()
	;======================================================================
	;PASS 1
	;===&gt;
	;Render object modal standard
	;===&gt;
	HideEntity SHWSpriteFront
	;colour buffer OFF
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CCW)
	SetRenderState( Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True );
	SetRenderState( Direct3DDevice7, D3DRS_SRCBLEND, D3DBLEND_ONE );
	SetRenderState( Direct3DDevice7, D3DRS_DESTBLEND, D3DBLEND_ONE );
	;lighting ON
	SetRenderState( Direct3DDevice7, D3DRS_AMBIENT, AMB_LIGHT );
	SetRenderState( Direct3DDevice7, D3DRS_LIGHTING, True );
	;depth buffer ON (Write+test)
	SetRenderState( Direct3DDevice7, D3DRS_ZENABLE, True );
	SetRenderState( Direct3DDevice7, D3DRS_ZWRITEENABLE, True );
	;stencil buffer OFF
	SetRenderState( Direct3DDevice7, D3DRS_STENCILENABLE, False );
	DeviceClear(Direct3DDevice7, 7, $00008080, 1, 0)
	CameraClsMode Camera, True, True
	;===&gt;
	If ShowVol Then
		ShowEntity MeshFront
		EntityColor MeshFront, 255, 0,0
		EntityFX MeshFront,1;+16
	Else
		HideEntity MeshFront
	EndIf
	;===&gt;
	ShowEntity scena
	;===&gt;
	RenderWorld
	;===&gt;
	EntityColor MeshFront,10,0,0
	EntityFX MeshFront,1
	;===&gt;
	;======================================================================
	;PASS 2
	;===&gt;
	CameraClsMode Camera, False, False
	HideEntity scena
	ShowEntity MeshFront
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE, True)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILFUNC, D3DCMP_ALWAYS)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILREF, 1)
	SetRenderState(Direct3DDevice7, D3DRS_SRCBLEND, D3DBLEND_ZERO)
	SetRenderState(Direct3DDevice7, D3DRS_DESTBLEND, D3DBLEND_ONE)
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CW)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILPASS, D3DSTENCILOP_INCR)
	RenderWorld
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_STENCILPASS, D3DSTENCILOP_DECR)
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CCW)
	RenderWorld
	;===&gt;
	HideEntity MeshFront
	SetRenderState(Direct3DDevice7, D3DRS_STENCILFUNC, D3DCMP_LESSEQUAL)
	SetRenderState(Direct3DDevice7, D3DRS_SRCBLEND, D3DBLEND_ONE )
	SetRenderState(Direct3DDevice7, D3DRS_DESTBLEND, D3DBLEND_ONE )
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE, True)
	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True)
	ShowEntity SHWSpriteFront
	;===&gt;
	RenderWorld
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE, False)
	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True)
	HideEntity SHWSpriteFront

End Function

Function ShadowVolumeStenciBuffer(ShowVol)
	EntityColor SHWSpriteFront, 5, 5, 5
	EntityAlpha SHWSpriteFront, 0.3
	;===&gt;
	SetBuffer BackBuffer()
	;===&gt;
	HideEntity SHWSpriteFront
	;======================================================================
	;PASS 1
	;===&gt;
	;Render object modal standard
	;===&gt;
	;colour buffer OFF
	SetRenderState(Direct3DDevice7, D3DRS_ZWRITEENABLE, True) 
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE, False)
	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, False)
	DeviceClear(Direct3DDevice7, 7,$00008080,1,0)
	CameraClsMode Camera, True, True
	;===&gt;
	If ShowVol Then
		ShowEntity MeshFront
		EntityColor MeshFront, 255, 0,0
		EntityFX MeshFront,1;+16
	Else
		HideEntity MeshFront
	EndIf
	;===&gt;
	ShowEntity scena
	;===&gt;
	RenderWorld
	;===&gt;
	HideEntity scena
	EntityColor MeshFront,10,0,0
	EntityFX MeshFront,1
	;===&gt;
	;======================================================================
	;PASS 2
	;===&gt;
	CameraClsMode Camera, False, False
	ShowEntity MeshFront
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_ZWRITEENABLE,False)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE,True)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILFUNC, D3DCMP_ALWAYS)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILPASS, D3DSTENCILOP_KEEP)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILREF, 1)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILMASK,$ffffffff)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILWRITEMASK,$ffffffff)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILZFAIL, D3DSTENCILOP_INCR)
	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True)
	SetRenderState(Direct3DDevice7, D3DRS_SRCBLEND, D3DBLEND_ZERO)
	SetRenderState(Direct3DDevice7, D3DRS_DESTBLEND, D3DBLEND_ONE)
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CCW)
	RenderWorld
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CW)
	RenderWorld
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CCW)
	SetRenderState(Direct3DDevice7, D3DRS_STENCILZFAIL, D3DSTENCILOP_DECR)
	RenderWorld
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_ZWRITEENABLE,     True )
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE,    False )
	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, False )			
	;===&gt;
	;HideEntity MeshFront
	SetRenderState(Direct3DDevice7, D3DRS_ZENABLE,       False )
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE, True )
	SetRenderState(Direct3DDevice7, D3DRS_FOGENABLE, False)	

	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True )
	SetRenderState(Direct3DDevice7, D3DRS_SRCBLEND, D3DBLEND_SRCALPHA )
	SetRenderState(Direct3DDevice7, D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA )

	SetRenderState(Direct3DDevice7, D3DRS_STENCILREF,  1 )
	SetRenderState(Direct3DDevice7, D3DRS_STENCILFUNC, D3DCMP_LESSEQUAL )
	SetRenderState(Direct3DDevice7, D3DRS_STENCILPASS, D3DSTENCILOP_KEEP )
	;===&gt;
	ShowEntity SHWSpriteFront
	RenderWorld
	;===&gt;
	SetRenderState(Direct3DDevice7, D3DRS_STENCILENABLE, False)
	SetRenderState(Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True)
	HideEntity SHWSpriteFront
	RenderWorld

End Function
</textarea> <br><br></td></tr></table><br>
<a name="666278"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tom</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> Please use forum tags for pasting code! :)<br><br>Look for code/codebox<br><a href="http://www.blitzbasic.com/faq/faq_entry.php?id=2" target="_blank">http://www.blitzbasic.com/faq/faq_entry.php?id=2</a> <br><br></td></tr></table><br>
<a name="666291"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok thanks for link<br><br>you help me!! <br><br></td></tr></table><br>
<a name="668036"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> progress?? <br><br></td></tr></table><br>
<a name="668314"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes in the old code posted i have insert multy light system :)<br><br>this is a progress!!<br><br>no speed up addizional :( stencil buffer in not very speed for 5 render execute<br><br>if you have a idea for speed software or new alghoritm this is your house :D<br><br><br>new update for code stencil:<br><br><pre class=code>
;=======================
; Creazione immagine ombra
; Fast2 ?
Function ShadowVolumeStenciBuffer_orig(ShowVol)
	EntityColor SHWSpriteFront, 5, 5, 5
	EntityAlpha SHWSpriteFront, 0.3
	;===&gt;
	;SetBuffer  TextureBuffer(ShwTex1)
	;Cls 
	SetBuffer BackBuffer()
	;======================================================================
	;PASS 1
	;===&gt;
	;Render object modal standard
	;===&gt;
	HideEntity SHWSpriteFront
	;colour buffer OFF
	SetRenderState(Direct3DDevice7, D3DRS_CULLMODE, D3DCULL_CCW)
	;SetRenderState( Direct3DDevice7, D3DRS_ALPHABLENDENABLE, True );
	;SetRenderState( Direct3DDevice7, D3DRS_SRCBLEND, D3DBLEND_ONE );
	;SetRenderState( Direct3DDevice7, D3DRS_DESTBLEND, D3DBLEND_ONE );
	;lighting ON
	SetRenderState( Direct3DDevice7, D3DRS_AMBIENT, AMB_LIGHT );
</pre> <br><br></td></tr></table><br>
<a name="668719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> this is a last update :( i not have orther idea<br><br>link:<br><br><a href="http://digilander.libero.it/enzo_light/shw13.zip" target="_blank">http://digilander.libero.it/enzo_light/shw13.zip</a><br><br><br>bye :( <br><br></td></tr></table><br>
<a name="668721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> i will check it out when i get back from school...<br>cya <br><br></td></tr></table><br>
<a name="668723"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> you is a student?<br><br>i have 29 years<br><br>what old are you? <br><br></td></tr></table><br>
<a name="668743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> i am 14 years old, but a good coder... <br><br></td></tr></table><br>
<a name="668784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have seen your work, but the bug with the faces isn't resolved yet :(...<br><br>some of the edge faces are casting wrong...<br><img src="http://patrick-sch.de/screens/Screen24.jpg"><br>so they should be flipped... <br><br></td></tr></table><br>
<a name="668794"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> this bug is in the init object, if you change in the sphere 32 o over "The bug show" ;)<br><br>the check vertex have a bug ?!?! <br><br>what is a bug? <br><br>what are I?<br><br>what sale live?<br><br>pleace help me for resolved bug! <br><br>all for one!! one for all :D <br><br></td></tr></table><br>
<a name="668824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd like to thank you guys again, I think you pushed stencil shadows to its limits for Blitz3D on an open source base.<br><br>Maybe the sooner or later somebody will add a fast volume creation. <br><br>Thanks! <br><br></td></tr></table><br>
<a name="668860"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, well done guys ... great work and alot of effort which is much appreciated.  A damn shame it's not fast enough to use on a grander scale.  <br><br>Hopefully if BRL can respond to Tom's renderworld() feature request and we'll all have super fast shadows soon!!<br><br>Stevie <br><br></td></tr></table><br>
<a name="669101"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have search the bug for create object the time for resolved and is ok!! <br><br></td></tr></table><br>
<a name="669122"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> sry, i do NOT understand your english...<br>please come to icq, download icq and post your icq numbere here!<br>´cya <br><br></td></tr></table><br>
<a name="669164"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok the my number icq is 249548841 <br><br></td></tr></table><br>
<a name="669231"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bytecode77</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, thx :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
