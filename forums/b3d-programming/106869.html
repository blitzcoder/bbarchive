<!DOCTYPE html><html lang="en" ><head ><title >[Solved] Per Object Glow</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >[Solved] Per Object Glow</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >[Solved] Per Object Glow</a><br><br>
<a name="1318328"></a>

<a name="1318459"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm trying to do a per object glow. I found some code that does the whole scene but I just needed per object to focus on it. Is there a workaround or somebody already done this, w/o the use of userlibs? <br><br></td></tr></table><br>
<a name="1318329"></a>

<a name="1318330"></a>

<a name="1318331"></a>

<a name="1318332"></a>

<a name="1318365"></a>

<a name="1318428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, <br><br>either with several meshes with each one being scaled up a little more and alpha a little less (=more transparent) (tried, looks ok)<br><br>or<br><br>with a textured quad and several textures, each one for a different view angle (8 or 16 depending on the shape), the texture being a render of the shape in fullbright, and blurred. (never tried, but i have seen it in Rune)<br><br>or<br><br>with several flat rectangle mesh which go outside the shape (along its major edges) and the near vertices are of the same color of the thing color and alpha 1.0 and the far vertices are of the same color of the thing color and alpha 0.0 (tried, looks ok, i have seen it in Tecno the base)<br><br>Full screen glow is really slow if you want a pixel precise glow with an offset around each shape (not like the blur using 8quads with an offset around the screen...) <br><br></td></tr></table><br>
<a name="1318333"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks RemiD. Can you post some simple examples? I find the first method to be quite easy  btw, great idea! <br><br></td></tr></table><br>
<a name="1318334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok tried the first one and there's a blurring issue if you got more details on your texture. It will do but would like to try other methods. <br><br></td></tr></table><br>
<a name="1318352"></a>

<a name="1318355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Use a full screen glow method with a small trick :<br><br>- create a fullbright black material (Fx=1+8 -&gt; fullbright + fog disabled)<br><br>On your render loop :<br><br>- apply the black material to all objects except the one you want to be glow<br>- make your glow pass<br>- re-apply materials to the objects<br>- Renderworld<br>- draw your glow pass on top of the renderworld<br><br>It can be achieved by a simple "Type"<br><br><pre class=code>
Type TNonGlowingMeshes
   Field Entity
   Field Material
End Type
</pre><br>use the type to register entities that glow wont affect<br><br><br>And that's a small sample of how you can do it<br>Unoptimized, and it's just a prototype (so, it's not really good to integrate -&gt; should be like a library with small function calls etc ...)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TNonGlowMesh
	Field Mesh
	Field Material
End Type

; easier function to set a new "non-glow" mesh
Function NewNonGlowMesh(entity)
	; only meshes based entity (mesh, terrain, plane, sprite)
	Select EntityClass(entity)
		Case "Mesh", "Terrain", "Sprite", "Plane"
		Default : Return
	End Select
	
	Local ngm.TNonGlowMesh = New TNonGlowMesh
	ngm\Mesh = entity
	ngm\Material = GetEntityBrush(entity)
End Function






Graphics3D 800,600,0,2
SetBuffer BackBuffer()

; sunset lighting

	AmbientLight 0,0,0
	Local light1	=	CreateLight		(2) ; blue sky light
						MoveEntity 		(light1, 0,20000,0)
						LightColor 		(light1, 050,140,255)
						LightRange 		(light1, 30000)
					
	Local light2	=	CreateLight		(2) ; yellow sunset light
						MoveEntity		(light2, -20000,500,2000)
						LightColor		(light2, 255,140,050)
						LightRange		(light2, 40000)
					
	; backlighting (light from above -&gt; simulate fake sky refraction from the ground)
	Local light3	=	CreateLight		(2) ; blueish backlight
						MoveEntity		(light3, 0,-30000,0)
						LightColor		(light3, 000,040,050)
						LightRange		(light3, 50000)

; small fps system ( player-&gt;head-&gt;camera )
	Local player	=	CreatePivot		()
	Local head		=	CreatePivot		(player)
	Local cam		=	CreateCamera	(head)
						PositionEntity	(player, 0,2,0)
						CameraClsColor	(cam, 230,150,145)


; scene
	; a plane for the floor
	Local ground	=	CreatePlane		(6)
						EntityColor		(ground, 30,80,10)
						; the ground does not glow
						NewNonGlowMesh	(ground)
	
	; some entities to show
	Local mesh
	For n = 1 To 50
		; random primitive
		Select Rand(1,3)
			Case 1 : mesh = CreateCube()
			Case 2 : mesh = CreateSphere(Rand(10,20))
			Case 3 : mesh = CreateCylinder(Rand(12,24), 1)
		End Select
		
		; randomize position, size and color
		MoveEntity	mesh, Rnd(-50,50), Rnd(1,2), Rnd(-50,50)
		TurnEntity	mesh, Rnd(-15,15), Rnd(360), Rnd(-15,15)
		ScaleEntity	mesh, Rnd(1,2), Rnd(1,2), Rnd(1,2)
		EntityColor	mesh, Rnd(160,255),Rnd(160,255),Rnd(160,255)
		EntityShininess mesh, 0.4
		
		; approximate one other 3 meshes is glowing
		Select Rand(1,10)
			Case 1,2,3 ; glowing meshes -&gt; do nothing
			
			Default ; else non-glowing mesh -&gt; register them
				NewNonGlowMesh mesh
		End Select
	Next
	
; A black material
	Local BLACK = CreateBrush(0,0,0)
	BrushFX BLACK, 1+8 ; you can also set the fx to "0" To enable glowing specularity
	
; the glow texture
	Local GLOW_Tex_L = CreateTexture(GraphicsWidth(), GraphicsHeight())
	; real size (texture are power of 2 size)
	Local Glow_W = TextureWidth(GLOW_Tex_L)
	Local Glow_H = TextureHeight(GLOW_Tex_L)
	; ratio of the texture vs graphics size
	Local du# = Float(GraphicsWidth())/Glow_W
	Local dv# = Float(GraphicsHeight())/Glow_H
	
	; quads to render the texture
	; -&gt; all quads are attached to a single pivot (for easier Hide/Show and transformations)
	Local FX_Quad_L		=	CreatePivot		(cam)
							PositionEntity	(FX_Quad_L, 0,0,2) ; position at Z=2 -&gt; no need to set a specific camera near range
							; scale the pivot so the quads will preserve the graphics ratio
							ScaleEntity		(FX_Quad_L, 2, 2.0*Float(GraphicsHeight())/GraphicsWidth(), 2)
							HideEntity		(FX_Quad_L)
	
	Local FX_Surf
						
	; you can create more quads to get a smoother result (here I used 49 quads with low alpha)
	; all the stuff below can be replaced by a single surface will all triangles on it.
	; this is just for demonstration, so I used quads, faster to code (lazzy me ? maybe)
	For i = -3 To 3
	For j = -3 To 3
		
		Local FX_Quad	=	CreateMesh		(FX_Quad_L)
							; offset the quads
							PositionEntity	(FX_Quad, Float(i)*0.01, Float(j)*0.01, 0, 0)
							; set as transparent mesh (the farther from center, the less visible)
							EntityAlpha		(FX_Quad, 0.08*( 1-Sqr(i*i+j*j) / Sqr(18) ))	; Sqr(18) -&gt; Sqr(3*3 + 3*3) -&gt; if you use more quads, adjust this value ^^
																							; also, more quads = more cumulated alpha, so the 0.05 must be adjusted too
							EntityOrder		(FX_Quad, -1000)			; render the quad on top of any meshes rendered
							EntityFX		(FX_Quad, 1+8)				; disable lighting and fog on the quads
							EntityTexture	(FX_Quad, GLOW_Tex_L)
							EntityBlend		(FX_Quad, 3)				; LIGHT Blend -&gt; mandatory if you want glowing highlights (else it will just make some blur)
							; the glow surface
		FX_Surf			=	CreateSurface	(FX_Quad)
							AddVertex		(FX_Surf, -1, 1,0, 0,0)
							AddVertex		(FX_Surf,  1, 1,0, du,0) ; UVs are offseted to fit the real part of the texture rendered
							AddVertex		(FX_Surf,  1,-1,0, du,dv)
							AddVertex		(FX_Surf, -1,-1,0, 0,dv)
							AddTriangle		(FX_Surf, 0,1,2)
							AddTriangle		(FX_Surf, 0,2,3)
	Next
	Next


; reset mouse speeds just before the loop to prevent random rotation on first loop if you press the mouse button.
	MouseXSpeed()
	MouseYSpeed()


Repeat
	
	Local msx# = MouseXSpeed()
	Local msy# = MouseYSpeed()
	
	; ZQSD or Arrows -&gt; Replce the Key_L "30" by the QWERTY value, it's set on an AZERTY keyboard
		Local Key_L = (KeyDown(203) Or KeyDown(30))&gt;0
		Local Key_R = (KeyDown(205) Or KeyDown(32))&gt;0
		Local Key_U = (KeyDown(200) Or KeyDown(17))&gt;0
		Local Key_D = (KeyDown(208) Or KeyDown(31))&gt;0
	
	; on left mouse down -&gt; rotate the player
		If MouseDown(1)
			TurnEntity player, 0, -msx,0
			TurnEntity head, msy,0,0
		EndIf
		
		; move the player with ZQSD/Arrows
		MoveEntity player, Float(Key_R-Key_L)*0.1, 0, Float(Key_U-Key_D)*0.15
	
	; -------------------------------------------------
	; - The Glow part -
	; -------------------------------------------------
		; use the black material to mask non glowing meshes
			Local ent.TNonGlowMesh
			For ent = Each TNonGlowMesh
				PaintEntity ent\Mesh,BLACK
			Next
			; remove the background color (so it's full black -&gt; for this demo, we don't want the background to be glowing)
			CameraClsColor cam, 0,0,0
			
		; hide the glow quad
			HideEntity FX_Quad_L
			
		; render the scene and copy the result to the glow texture
			RenderWorld()
			CopyRect 0,0,GraphicsWidth(), GraphicsHeight(), 0,0, BackBuffer(), TextureBuffer(GLOW_Tex_L)
			
		; restore materials and reset background
			For ent = Each TNonGlowMesh
				PaintEntity ent\Mesh,ent\Material
			Next
			CameraClsColor cam, 230,150,145
			
		; show the glow quads
			ShowEntity FX_Quad_L
	; -------------------------------------------------
	
	; finally render the scene.
		; it will mix the "normal" with the glow quads
		RenderWorld()
		
	Flip True
	
Until KeyDown(1)
End
</textarea><br><br>it requires 2 renderworld and 1 copyrect <br><br></td></tr></table><br>
<a name="1318353"></a>

<a name="1318360"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> ps : as mentionned in the comment (in the code), you can remove the Fullbright FX and use some shininess<br><br><pre class=code>
; A black material
	Local BLACK = CreateBrush(0,0,0)
	BrushFX BLACK, 0 ; you can also set the fx to "0" To enable glowing specularity
	BrushShininess BLACK, 1
</pre><br>It will make glow from specularity on the non glowing meshes.<br><br><br><br>(code updated with single surface, but curiously, more quads makes the demo slower, while more quad meshes doesn't)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TNonGlowMesh
	Field Mesh
	Field Material
End Type

; easier function to set a new "non-glow" mesh
Function NewNonGlowMesh(entity)
	; only meshes based entity (mesh, terrain, plane, sprite)
	Select EntityClass(entity)
		Case "Mesh", "Terrain", "Sprite", "Plane"
		Default : Return
	End Select
	
	Local ngm.TNonGlowMesh = New TNonGlowMesh
	ngm\Mesh = entity
	ngm\Material = GetEntityBrush(entity)
End Function






Graphics3D 800,600,0,2
SetBuffer BackBuffer()

; sunset lighting

	AmbientLight 0,0,0
	Local light1	=	CreateLight		(2) ; blue sky light
						MoveEntity 		(light1, 0,20000,0)
						LightColor 		(light1, 050,140,255)
						LightRange 		(light1, 30000)
					
	Local light2	=	CreateLight		(2) ; yellow sunset light
						MoveEntity		(light2, -20000,500,2000)
						LightColor		(light2, 255,140,050)
						LightRange		(light2, 40000)
					
	; backlighting (light from above -&gt; simulate fake sky refraction from the ground)
	Local light3	=	CreateLight		(2) ; blueish backlight
						MoveEntity		(light3, 0,-30000,0)
						LightColor		(light3, 000,040,050)
						LightRange		(light3, 50000)

; small fps system ( player-&gt;head-&gt;camera )
	Local player	=	CreatePivot		()
	Local head		=	CreatePivot		(player)
	Local cam		=	CreateCamera	(head)
						PositionEntity	(player, 0,2,0)
						CameraClsColor	(cam, 230,150,145)


; scene
	; a plane for the floor
	Local ground	=	CreatePlane		(6)
						EntityColor		(ground, 30,80,10)
						; the ground does not glow
						NewNonGlowMesh	(ground)
	
	; some entities to show
	Local mesh
	For n = 1 To 50
		; random primitive
		Select Rand(1,3)
			Case 1 : mesh = CreateCube()
			Case 2 : mesh = CreateSphere(Rand(10,20))
			Case 3 : mesh = CreateCylinder(Rand(12,24), 1)
		End Select
		
		; randomize position, size and color
		MoveEntity	mesh, Rnd(-50,50), Rnd(1,2), Rnd(-50,50)
		TurnEntity	mesh, Rnd(-15,15), Rnd(360), Rnd(-15,15)
		ScaleEntity	mesh, Rnd(1,2), Rnd(1,2), Rnd(1,2)
		EntityColor	mesh, Rnd(160,255),Rnd(160,255),Rnd(160,255)
		EntityShininess mesh, 0.4
		
		; approximate one other 3 meshes is glowing
		Select Rand(1,10)
			Case 1,2,3 ; glowing meshes -&gt; do nothing
				EntityColor	mesh, Rnd(160,255)*.4,Rnd(160,255)*.4,500
			
			Default ; else non-glowing mesh -&gt; register them
				NewNonGlowMesh mesh
		End Select
	Next
	
; A black material
	Local BLACK = CreateBrush(0,0,0)
	BrushFX BLACK, 8 ; you can also set the fx to "0" To enable glowing specularity
	BrushShininess BLACK, .5
	
; the glow texture
	Local GLOW_Tex_L	=	CreateTexture(GraphicsWidth(), GraphicsHeight())
	; real size (texture are power of 2 size)
	Local Glow_W		=	TextureWidth(GLOW_Tex_L)
	Local Glow_H		=	TextureHeight(GLOW_Tex_L)
	Local FX_Screen_Ratio#=	Float(GraphicsHeight())/GraphicsWidth()
	
	; ratio of the texture vs graphics size
	Local FX_Quad_du#	=	Float(GraphicsWidth())/Glow_W
	Local FX_Quad_dv#	=	Float(GraphicsHeight())/Glow_H
	
	; quads to render the texture
	Local FX_GLOW_POWER#=	0.2
	Local FX_GLOW_COUNT%=	5
	
	Local FX_Quad_A#	=	FX_GLOW_POWER / Sqr(FX_GLOW_COUNT*FX_GLOW_COUNT*2);
	Local FX_Quad_Div#	=	1.0 / Sqr(FX_GLOW_COUNT*FX_GLOW_COUNT*2)
	Local FX_Quad_Offset#=	6.0/GraphicsWidth()
	Local FX_Quad_si#	=	2.0
	Local FX_Quad_sj#	=	2.0*FX_Screen_Ratio
	
	; -&gt; all quads are attached to a single pivot (for easier Hide/Show and transformations)
	Local FX_Quad		=	CreateMesh		(cam)
							PositionEntity	(FX_Quad, 0,0,2) ; position at Z=2 -&gt; no need to set a specific camera near range
							; scale the pivot so the quads will preserve the graphics ratio
							HideEntity		(FX_Quad)
							EntityOrder		(FX_Quad, -1000)			; render the quad on top of any meshes rendered
							EntityFX		(FX_Quad, 1+2+8+32)				; disable lighting and fog on the quads
							EntityTexture	(FX_Quad, GLOW_Tex_L)
							EntityBlend		(FX_Quad, 3)				; LIGHT Blend -&gt; mandatory if you want glowing highlights (else it will just make some blur)
	
	Local FX_Surf		=	CreateSurface	(FX_Quad)
							
	; you can create more quads to get a smoother result (here I used 49 quads with low alpha)
	; all the stuff below can be replaced by a single surface will all triangles on it.
	; this is just for demonstration, so I used quads, faster to code (lazzy me ? maybe)
	For j = -FX_GLOW_COUNT To FX_GLOW_COUNT
	For i = -FX_GLOW_COUNT To FX_GLOW_COUNT
		; offset the quads
		Local qi#		=	Float(i)*FX_Quad_Offset/FX_Quad_du
		Local qj#		=	Float(j)*FX_Quad_Offset/FX_Quad_dv
							; set as transparent mesh (the farther from center, the less visible)
							; the glow surface
		Local qa#		=	FX_Quad_A * (1.0 - Sqr(i*i+j*j) * FX_Quad_Div)
		If qa&gt;0.01
			Local v0	=	AddVertex		(FX_Surf, -FX_Quad_si+qi, FX_Quad_sj+qj, 0, 0,0)
							AddVertex		(FX_Surf,  FX_Quad_si+qi, FX_Quad_sj+qj, 0, FX_Quad_du,0) ; UVs are offseted to fit the real part of the texture rendered
							AddVertex		(FX_Surf,  FX_Quad_si+qi,-FX_Quad_sj+qj, 0, FX_Quad_du,FX_Quad_dv)
							AddVertex		(FX_Surf, -FX_Quad_si+qi,-FX_Quad_sj+qj, 0, 0,FX_Quad_dv)
							VertexColor		(FX_Surf, v0  , 255,255,255, qa)
							VertexColor		(FX_Surf, v0+1, 255,255,255, qa)
							VertexColor		(FX_Surf, v0+2, 255,255,255, qa)
							VertexColor		(FX_Surf, v0+3, 255,255,255, qa)
							AddTriangle		(FX_Surf, v0,v0+1,v0+2)
							AddTriangle		(FX_Surf, v0,v0+2,v0+3)
		EndIf
	Next
	Next
	
; reset mouse speeds just before the loop to prevent random rotation on first loop if you press the mouse button.
	MouseXSpeed()
	MouseYSpeed()


Repeat
	
	Local msx# = MouseXSpeed()
	Local msy# = MouseYSpeed()
	
	; ZQSD or Arrows -&gt; Replce the Key_L "30" by the QWERTY value, it's set on an AZERTY keyboard
		Local Key_L = (KeyDown(203) Or KeyDown(30))&gt;0
		Local Key_R = (KeyDown(205) Or KeyDown(32))&gt;0
		Local Key_U = (KeyDown(200) Or KeyDown(17))&gt;0
		Local Key_D = (KeyDown(208) Or KeyDown(31))&gt;0
	
	; on left mouse down -&gt; rotate the player
		If MouseDown(1)
			TurnEntity player, 0, -msx,0
			TurnEntity head, msy,0,0
		EndIf
		
		; move the player with ZQSD/Arrows
		MoveEntity player, Float(Key_R-Key_L)*0.1, 0, Float(Key_U-Key_D)*0.15
	
	; -------------------------------------------------
	; - The Glow part -
	; -------------------------------------------------
		; use the black material to mask non glowing meshes
			Local ent.TNonGlowMesh
			For ent = Each TNonGlowMesh
				PaintEntity ent\Mesh,BLACK
			Next
			; remove the background color (so it's full black -&gt; for this demo, we don't want the background to be glowing)
			CameraClsColor cam, 0,0,0
			
		; hide the glow quad
			HideEntity FX_Quad
			
		; render the scene and copy the result to the glow texture
			RenderWorld()
			CopyRect 0,0,GraphicsWidth(), GraphicsHeight(), 0,0, BackBuffer(), TextureBuffer(GLOW_Tex_L)
			
		; restore materials and reset background
			For ent = Each TNonGlowMesh
				PaintEntity ent\Mesh,ent\Material
			Next
			CameraClsColor cam, 230,150,145
			
		; show the glow quads
			ShowEntity FX_Quad
	; -------------------------------------------------
	
	; finally render the scene.
		; it will mix the "normal" with the glow quads
		RenderWorld()
		
	Flip True
	
Until KeyDown(1)
End
</textarea> <br><br></td></tr></table><br>
<a name="1318364"></a>

<a name="1318366"></a>

<a name="1318368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RustyKristi&gt;&gt;for method1 there is an example in the code archives, see : <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=391" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=391</a><br><br><br>@Bobysait&gt;&gt;the problem wih fullscreen glow (do a small render of fulldbright colored shapes (and the others shapes colored in black), then blur this render, then display it on a screen mesh over the scene) is that the glow is not precise and i have found that it produces flickering of the glow when a shape is too small... And if you do a bigger render, it is slower... And a glow on a big texture (1024*1024) is too slow anyway... <br><br></td></tr></table><br>
<a name="1318369"></a>

<a name="1318370"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>(do a small render of fulldbright colored shapes (and the others shapes colored in black), then blur this render, then display it on a screen mesh over the scene)<br> <br></div><br><br>mmm ... maybe you should just try the code above then.<br>What I mentioned as "Glow pass" is not a "bad glow pass", it's just a "nice real glow pass".<br>While what you describe is a ugly way to make glow.<br><br>- On my routine, there is no real blur applied because there is no need for it, and no artifact or fickering with smaller or farther objects.<br>The bluring effect doesn't stretch the pixels (like what gaussian or other standard algorithm would do)<br>It's more accurate and looks way much nicer.<br>- The render is not a "small render", it actually renders at the full resolution.<br>- The glowing objetcs are not rendered fullbright, they are just rendered normally.<br><br>------------------<br><br>The principle is not to render in a special way the glowing objects, but to disable the "not-glowing" objects.<br>So, all objects are rendered black and glowing objects are rendered with their standard brushes. Then, render the scene again with all objects painted with their original brushes<br>Once you apply the blend in light mode, what it does is "Add" the pixel to the screen.<br>So, a black pixel just does not add any light, while a "normal" pixel will highlight the pixel above.<br><br>As the mesh that receives the blended texture is composed of several quads with alpha, all offseted (by one or two pixels), it adds smaller amount of light around each pixels that was not black.<br><br>So, the final render is just like a fullscreen per pixel effect, neat and accurate. <br><br></td></tr></table><br>
<a name="1318371"></a>

<a name="1318372"></a>

<a name="1318373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes what i described is what sswift suggested (i have a demo somewhere...) and i have not found that it produces a precise glow and there is some flickering when the glowing shapes are too small (those which are far away.<br><br><br><div class="quote"> <br>As the mesh that receives the blended texture is composed of several quads with alpha, all offseted (by one or two pixels), it adds smaller amount of light around each pixels that was not black.<br> <br></div><br>that's a good idea, i will take a look at your code. Thanks<br><br>You also posted this example a while ago : <a href="http://www.blitzbasic.com/Community/posts.php?topic=105815" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=105815</a> (#4)<br>maybe RustyKristi wants to take a look... <br><br></td></tr></table><br>
<a name="1318375"></a>

<a name="1318376"></a>

<a name="1318377"></a>

<a name="1318378"></a>

<a name="1318380"></a>

<a name="1318381"></a>

<a name="1318410"></a>

<a name="1318411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Bobysait&gt;&gt;i am still trying to understand what you are doing in your code but this just gave me another idea for a per shape glow effect, but i am not sure if this is doable (fast enough)<br><br>The idea would be to render the scene with normal width height (for example 1024*768), with the non glowing shapes colored in black (or with no light and ambientlight 0,0,0) and the glowing shapes colored in their color and fullbright, and then analyze the resulting image, and for each colored pixel (which corresponds to a part of a glowing shape) create a small quad with a size slightly bigger than the pixel (so this would be the glow radius)<br>All quads would be merged to one mesh one surface which would then be drawn (blendmode add) on top of the screen mesh + screen texture (with the image of the render with the shapes with their normal colors)<br>The slow step would be to analyze the pixels of the image of the render (1024*768=786432pixels!!!) <br><br></td></tr></table><br>
<a name="1318382"></a>

<a name="1318384"></a>

<a name="1318385"></a>

<a name="1318389"></a>

<a name="1318394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Bobysait&gt;&gt;i think i understand your code now, but it is still not pixel precise glow... since when you scale up a screen mesh + screen texture (or in your example play with the uv to stretch the texture), the glow will not be uniform around the shape... one or two sides will glow more depending on where it is rendered on the screen...<br><br>But nice example anyway. <br><br></td></tr></table><br>
<a name="1318391"></a>

<a name="1318392"></a>

<a name="1318395"></a>

<a name="1318407"></a>

<a name="1318420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> simpified version of your code (replaced the nonglowmesh customtype by entityfx 0 or 1 + hideentity(light) + ambientlight(0,0,0))<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,32,2
SetBuffer BackBuffer()

 dlight = CreateLight(1)
 LightColor(dlight,255,255,255)
 PositionEntity(dlight,-1000,1000,-1000,True)
 RotateEntity(dlight,45,-45,0,True)

 AmbientLight 064,064,064
	
; small fps system ( player-&gt;head-&gt;camera )
	Local player	=	CreatePivot		()
	Local head		=	CreatePivot		(player)
	Local cam		=	CreateCamera	(head)
						PositionEntity	(player, 0,1.65,0)
						CameraRange(cam,0.1,100)
						CameraClsColor	(cam, 128,128,255)
  

; scene
	; a plane for the floor
	Local ground	=	CreateCube()
	   					ScaleMesh(ground,1000.0,0.1/2,1000.0)
	   					PositionMesh(ground,0,-0.1/2,0)
						EntityColor		(ground, 000,096,000)
						EntityFX(ground,0)
	
	; some entities to show
	Local mesh
	For n = 1 To 100
		; random primitive
		Select Rand(1,3)
			Case 1 : mesh = CreateCube()
			Case 2 : mesh = CreateSphere(16)
			Case 3 : mesh = CreateCylinder(16)
		End Select
		
		; randomize position, size and color
		Scale# = Rnd(0.1,1.0)
		ScaleMesh	mesh, Scale/2, Scale/2, Scale/2
		EntityColor	mesh, Rnd(025,255),Rnd(025,255),Rnd(025,255)
		MoveEntity	mesh, Rnd(-50,50), Scale/2, Rnd(-50,50)
		TurnEntity	mesh, Rnd(-15,15), Rnd(-180,180), Rnd(-15,15)
		
		;EntityShininess mesh, 0.4
		
		; approximate one other 3 meshes is glowing
		Select Rand(1,2)
			Case 1 ; glowing meshes -&gt; do nothing
				;EntityColor	mesh, Rand(025,255),Rand(025,255),Rand(025,255)
			    EntityFX(mesh,1)
			Case 2
			 	EntityFX(mesh,0)
		End Select
	Next
	
; the glow texture
	Local GLOW_Tex_L	=	CreateTexture(GraphicsWidth(), GraphicsHeight())
	; real size (texture are power of 2 size)
	Local Glow_W		=	TextureWidth(GLOW_Tex_L)
	Local Glow_H		=	TextureHeight(GLOW_Tex_L)
	Local FX_Screen_Ratio#=	Float(GraphicsHeight())/GraphicsWidth()
	
	; ratio of the texture vs graphics size
	Local FX_Quad_du#	=	Float(GraphicsWidth())/Glow_W
	Local FX_Quad_dv#	=	Float(GraphicsHeight())/Glow_H
	
	; quads to render the texture
	Local FX_GLOW_POWER#=	0.5
	Local FX_GLOW_COUNT%=	3
	
	Local FX_Quad_A#	=	FX_GLOW_POWER / Sqr(FX_GLOW_COUNT*FX_GLOW_COUNT*2);
	Local FX_Quad_Div#	=	1.0 / Sqr(FX_GLOW_COUNT*FX_GLOW_COUNT*2)
	Local FX_Quad_Offset#=	6.0/GraphicsWidth()
	Local FX_Quad_si#	=	2.0
	Local FX_Quad_sj#	=	2.0*FX_Screen_Ratio
	
	; -&gt; all quads are attached to a single pivot (for easier Hide/Show and transformations)
	Local FX_Quad		=	CreateMesh		(cam)
							PositionEntity	(FX_Quad, 0,0,2) ; position at Z=2 -&gt; no need to set a specific camera near range
							; scale the pivot so the quads will preserve the graphics ratio
							HideEntity		(FX_Quad)
							EntityOrder		(FX_Quad, -1000)			; render the quad on top of any meshes rendered
							EntityFX		(FX_Quad, 1+2+8+32)				; disable lighting and fog on the quads
							EntityTexture	(FX_Quad, GLOW_Tex_L)
							EntityBlend		(FX_Quad, 3)				; LIGHT Blend -&gt; mandatory if you want glowing highlights (else it will just make some blur)
	
	Local FX_Surf		=	CreateSurface	(FX_Quad)
							
	; you can create more quads to get a smoother result (here I used 49 quads with low alpha)
	; all the stuff below can be replaced by a single surface will all triangles on it.
	; this is just for demonstration, so I used quads, faster to code (lazzy me ? maybe)
	For j = -FX_GLOW_COUNT To FX_GLOW_COUNT
	 For i = -FX_GLOW_COUNT To FX_GLOW_COUNT
		; offset the quads
		Local qi#		=	Float(i)*FX_Quad_Offset/FX_Quad_du
		Local qj#		=	Float(j)*FX_Quad_Offset/FX_Quad_dv
							; set as transparent mesh (the farther from center, the less visible)
							; the glow surface
		Local qa#		=	FX_Quad_A * (1.0 - Sqr(i*i+j*j) * FX_Quad_Div)
		If qa&gt;0.01
			Local v0	=	AddVertex		(FX_Surf, -FX_Quad_si+qi, FX_Quad_sj+qj, 0, 0,0)
							AddVertex		(FX_Surf,  FX_Quad_si+qi, FX_Quad_sj+qj, 0, FX_Quad_du,0) ; UVs are offseted to fit the real part of the texture rendered
							AddVertex		(FX_Surf,  FX_Quad_si+qi,-FX_Quad_sj+qj, 0, FX_Quad_du,FX_Quad_dv)
							AddVertex		(FX_Surf, -FX_Quad_si+qi,-FX_Quad_sj+qj, 0, 0,FX_Quad_dv)
							VertexColor		(FX_Surf, v0  , 255,255,255, qa)
							VertexColor		(FX_Surf, v0+1, 255,255,255, qa)
							VertexColor		(FX_Surf, v0+2, 255,255,255, qa)
							VertexColor		(FX_Surf, v0+3, 255,255,255, qa)
							AddTriangle		(FX_Surf, v0,v0+1,v0+2)
							AddTriangle		(FX_Surf, v0,v0+2,v0+3)
		EndIf
	 Next
	Next
	
; reset mouse speeds just before the loop to prevent random rotation on first loop if you press the mouse button.
	MouseXSpeed()
	MouseYSpeed()


Repeat
	
	Local msx# = MouseXSpeed()
	Local msy# = MouseYSpeed()
	MoveMouse(GraphicsWidth()/2,GraphicsHeight()/2)
	; ZQSD or Arrows -&gt; Replce the Key_L "30" by the QWERTY value, it's set on an AZERTY keyboard
		Local Key_L = (KeyDown(203) Or KeyDown(30))&gt;0
		Local Key_R = (KeyDown(205) Or KeyDown(32))&gt;0
		Local Key_U = (KeyDown(200) Or KeyDown(17))&gt;0
		Local Key_D = (KeyDown(208) Or KeyDown(31))&gt;0
	
	; on left mouse down -&gt; rotate the player
	
			TurnEntity player, 0, -msx,0
			TurnEntity head, msy,0,0
		If MouseDown(1)=1
			MoveEntity(player,0,0,0.15)
		Else If MouseDown(2)=1
		 MoveEntity(player,0,0,-0.15)
		EndIf
		
		; move the player with ZQSD/Arrows

	; -------------------------------------------------
	; - The Glow part -
	; -------------------------------------------------

            HideEntity(dlight)
            AmbientLight(0,0,0)
			CameraClsColor cam, 0,0,0
			
		; hide the glow quad
			HideEntity FX_Quad
			
		; render the scene and copy the result to the glow texture
			RenderWorld()
			CopyRect 0,0,GraphicsWidth(), GraphicsHeight(), 0,0, BackBuffer(), TextureBuffer(GLOW_Tex_L)
			
		; restore materials and reset background
            ShowEntity(dlight)
            AmbientLight(064,064,064)
			CameraClsColor	(cam, 128,128,255)
			
		; show the glow quads
			ShowEntity FX_Quad
	; -------------------------------------------------
	
	; finally render the scene.
		; it will mix the "normal" with the glow quads
		RenderWorld()
		
	Flip True
	
Until KeyDown(1)
End
</textarea> <br><br></td></tr></table><br>
<a name="1318393"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>but it is still not pixel precise glow... since [...]<br> <br></div><br><br>It is.<br>It just need to be set with the optimal values ( -&gt; 1.0/GraphicsWidth() for the offset)<br>Thoose two variables :<br>Local qi# = Float(i)/GraphicsWidth()<br>Local qj# = Float(j)/GraphicsHeight()<br>This will use an offset of one pixel.<br><br>Then, I don't know what you're looking for, but maybe it's not glow.<br><br>Finally, I don't play with the UV (in the sample, I just used du and dv on qi and qj just for convenience because it was a good factor for good result and good perfs)<br>Then, where I use the UVs, it's just that I set them to fit the texture area that contains the viewport of the camera rendered : <br>-&gt; because a texture is power of 2 size, a 800*600 will create a 1024*1024 texture, but the camera rendered will export on the 800*600 area, so it does not cover the whole texture.<br>-&gt; So I set the UV to fit the {800/1024, 600/1024} texture coords<br>Once done, I don't need to touch it anymore.<br><br>The only tweaking is about the offset and the alpha (to modify the power of the glow, and the dispersion)<br><br>More dispersion will create "glares" and at this moment it won't be pixel precise, but if you use "1.0/GraphicsWidth()" as offset, you'll have quads that are offseted by one pixel.<br>More quads = more glow radius = more smooth = more resources (lower fps)<br>or you can just use the dispersion to cover a larger radius (but you'll see the quads)<br><br>If you need very accurate and large radius, there is a cost.<br>But, as mentionned, I really doubt you'll find a better way to acheive this effect without a drastic fps cost. <br><br></td></tr></table><br>
<a name="1318396"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes i know, there is nothing ideal in this world :) <br><br></td></tr></table><br>
<a name="1318398"></a>

<a name="1318400"></a>

<a name="1318401"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another problem with the blendmode "add" is that sometimes the resulting glow is not of the same color than the shape color (because, as i understand it, too many "added" pixels become white pixels) <br><br></td></tr></table><br>
<a name="1318402"></a>

<a name="1318403"></a>

<a name="1318405"></a>

<a name="1318406"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your method is quite good compared to the sswift method. There is no flickering even with far away small shapes. Good. <br><br></td></tr></table><br>
<a name="1318404"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Another problem with the blendmode "add" is that sometimes the resulting glow is not of the same color than the shape color (because, as i understand it, too many "added" pixels become white pixels) <br> <br></div><br>At the same time, this is what glow is supposed to do.<br>So, seriously, I don't know what you're looking for, but maybe it's not glow, but just something like an highlighted outline ? <br><br></td></tr></table><br>
<a name="1318412"></a>

<a name="1318413"></a>

<a name="1318414"></a>

<a name="1318415"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Since you probably know how directx manages stuff behind the scene, what happens if several meshes have the same entityorder, (for example quads) how is the final color of a pixel calculated since the shapes have the same zorder ?<br>For example, let's say 2quads with the same entityorder and with blendmode "add" <br><br></td></tr></table><br>
<a name="1318416"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> if entityorder is set, it disables the depth test, so all faces are drawn the first to the last, no matter what.<br><br>Then, if you have two quads with same order, they are rendered the last on top of the first (render the first, then render the last = the last appear front of the previous one. exactly Like 2D drawing)<br><br>It depends on the creation time. <br><br></td></tr></table><br>
<a name="1318417"></a>

<a name="1318418"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh so the creation order of meshes is considered ? Like the creation order of surfaces in a mesh ? I remember some discussions to prevent zorder artifacts was to create a surface before another depending on if it is more inside or outside a mesh (related to the camera). <br><br></td></tr></table><br>
<a name="1318423"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, but there are cases where it doesn't matter.<br>(like the code I posted above)<br><br>For entities with blending modes, they are mixed with special equation<br>-&gt; blend add adds the pixels, so no matter the order 0+1+2+3 = 0+3+1+2 = 2+1+3+0<br>-&gt; blend shade is a multiplication -&gt; 1*2*3 = 2*1*3 etc ...<br><br>it only matters for solid or alpha blend. (actually, it's essentially with alpha that the problem occures, with or without entityorder, the alpha meshes disable the z buffer (because the z buffer only store a single value, it's a choice to make when you program the rendering, and blitz3d choose to disable it -&gt; which is not a bad choise, because others methods are actually worse)) <br><br></td></tr></table><br>
<a name="1318426"></a>

<a name="1318427"></a>

<a name="1320102"></a>

<a name="1320103"></a>

<a name="1320641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> removed because of an error in this old ugly code <br><br></td></tr></table><br>
<a name="1318429"></a>

<a name="1318430"></a>

<a name="1318431"></a>

<a name="1318432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> ... (nothing interesting, i was just confused :P) <br><br></td></tr></table><br>
<a name="1318433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> nope, it's a static offset between two layers.<br>it's the offset that quantify the dispersion.<br>-&gt; set it to 1.0/GraphicsWidth() to get a "pixel perfect" effect and lower glow radius. <br><br></td></tr></table><br>
<a name="1318434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh ok, thanks for the clarification. <br><br></td></tr></table><br>
<a name="1318439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://i65.tinypic.com/2v0jt5w.png"> <br><br></td></tr></table><br>
<a name="1318441"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, I did not know it will end up this long of a discussion! Anyway, thanks RemiD and Bobysait.<br><br>I will try all posted methods here. awesome. <br><br></td></tr></table><br>
<a name="1318447"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is the old glow demo with the sswift blur method :<br><a href="http://expirebox.com/download/34503ac9e9bf6d7a971e99866858462d.html" target="_blank">http://expirebox.com/download/34503ac9e9bf6d7a971e99866858462d.html</a> <br><br></td></tr></table><br>
<a name="1318449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why not use a combination of geometric glow and a screen mesh + blurred screen texture with blendmode add ?<br><br>It would allow to have a precise glow around the shape but also to have a blured glow.<br><br>This can be done by using the example Rob (or I) posted and FastExt blur, however the FastExt lib does not work well with the last version of Blitz3d... <br><br></td></tr></table><br>
<a name="1318458"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I should go for the one that is easiest and won't affect much performance, but looks like it's all good for here. appreciate the help, thanks again. <br><br></td></tr></table><br>
<a name="1318464"></a>

<a name="1318465"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh ! I just had another idea :<br>Similar to the geometric glow, but instead of using several scaled up shapes with decreasing alpha, use several flipped scaled up shapes with decreasing alpha.<br>Also don't use the blendmode "add" but use the blendmode "alpha/default"<br>Also set all geometric glow shapes to fullbright.<br>Also you need a screen mesh + a screen texture with blendmode "alpha/default"<br><br>In the mainloop :<br>hide the light(s)<br>set ambientlight to 0,0,0<br>set camera cls color to 0,0,0<br>hide the screen mesh<br>render the scene (all "normal" shapes will be black, all fullbright shapes (the geometric glow shapes) will be colored and fullbright<br>copyrect the result to the screen texture<br>fast blur the texture (with fastext blur ?)<br>show the light(s)<br>set the ambientlight to its initial color<br>set the camera cls color to its initial color<br>hide the geometric glow shapes (facultative)<br>show the screen mesh<br>render the scene<br><br>This should produce a glow which is of the color of the shape (from opaque color to transparent color) instead of the white saturation produced by the blendmode "add" <br><br></td></tr></table><br>
<a name="1318467"></a>

<a name="1318468"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1 - If it worked it would only produce some darkish blur (not glow)<br>2 - It won't work at all.<br><br>Add blend removes the black parts because it doesn't add the color.<br>alpha will mixe the black color with the scene.<br>The result will be darkened and probably dirty blured.<br><br>But !<br>Anyway, whatever I can think or anticipate, if you have an idea, don't expose it, try it then post the result<br>You already have the requested structur to make the minor changes on this topic <br><br></td></tr></table><br>
<a name="1318469"></a>

<a name="1318470"></a>

<a name="1318471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Bobysait&gt;&gt;sometimes i appreciate when others post their methods (in words, not necessarily in code), if the method is senseful and will most likely work, why not, so here was my post.<br><br>But i understand your concern about the blending of colored pixels and black pixels so maybe a workaround would be to have a progressive decrease of the alpha of each bigger shape but between 1.0 and 0.5 so that the resulting pixels stay colored enough ? I don't know and i don't want to try now... <br><br></td></tr></table><br>
<a name="1318494"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> 2 ways to reduce the brightness (white pixels of the blendmode "add") in the example (#22) is to color the shape with a color between 0 and 128 (instead of 0 and 255)<br> and also to set the alpha of each between 0.5 and 0 instead of 1.0 and 0. <br><br></td></tr></table><br>
<a name="1320280"></a>

<a name="1320281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is an attempt to use the 3rd method described in post#2<br><img src="http://rd-stuff.fr/glow-with-flat-rectangles-on-important-edges-with-decreasing-alpha-201609262159.jpg"><br>the glowing shape is a square (2 triangles) <br><br></td></tr></table><br>
<a name="1320302"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> This would serve nicely as a button on an elevator or something. <br><br></td></tr></table><br>
<a name="1320303"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes this looks nice RemiD! Can you post the actual code? <br><br></td></tr></table><br>
<a name="1320304"></a>

<a name="1320305"></a>

<a name="1320306"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Rick Nasher : For a button, you'd probably better use an alpha texture with the glowing effect on it (on a fixed sprite or something similar), as it's a simple purpose it would not require several copies of the polygons and it would prevent the counter-part : there is a big chance your alpha polygons will be intersecting with the wall the button will be on.<br><br>But I must admit it's a very nice blue. <br><br></td></tr></table><br>
<a name="1320321"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doom 3 uses something similar, a dynamic mesh that is changed based on the camera position:<br><a href="https://simonschreibt.de/gat/doom-3-volumetric-glow/" target="_blank">https://simonschreibt.de/gat/doom-3-volumetric-glow/</a> <br><br></td></tr></table><br>
<a name="1320343"></a>

<a name="1320344"></a>

<a name="1320345"></a>

<a name="1320346"></a>

<a name="1320347"></a>

<a name="1320348"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>there is a big chance your alpha polygons will be intersecting with the wall the button will be on<br> <br></div><br>@Bobysait&gt;&gt;i made sure to have each "glow part" not intersecting with each other or with the square mesh (with an offset of 0.001 between each near vertices) (it is also easier to set the alpha value if the vertices have a precise position, in this case, the vertices at the bottom near the edges of the square are alpha 1.0 and all others vertices far from the edges of the square are alpha 0)<br><br>If you play the game TECNO the base (made with Blitz3d) you will see this method used on almost all lightsources/luminous things, this method and the method of scaling up the shape and decreasing its alpha are really fast compared to having to render the whole scene twice. Even if it looks slightly different... <br><br></td></tr></table><br>
<a name="1320359"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Kryzon&gt;&gt;very nice method, similar to what i have done, but my example is not "dynamic". Thanks for the link! <br><br></td></tr></table><br>
<a name="1320362"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Even if it looks slightly different<br> <br></div><br>"slightly"<br>I would say, "even if it does not look the same at all"<br><br>Well, if it's just for single buttons, and limited geometries, I guess this trick can do the job.<br>But depending on how many object need to be "glowed", this trick could easily be lower than rendering twice, as you multiply geometries to get the result. <br><br></td></tr></table><br>
<a name="1320371"></a>

<a name="1320372"></a>

<a name="1320373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> The doom3 method is way better because the glow is uniform around the flat shape and there are less triangles and consequently less alpha, i have to think about how to reproduce this effect, it should be doable... <br><br></td></tr></table><br>
<a name="1320379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow nice. I hope we can see some example code and demo :D<br><br>I have seen a lot of awesome B3D stuff digging the archives and thread that has some shader equivalent so I think this is possible. <br><br></td></tr></table><br>
<a name="1320383"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> The doom3 method probably uses a lots of picking to generate the mesh on the fly. What you'd win in polygon rendering (GPU) would probably be lost in CPU time. But if there is not too many objects to "project" and the pickable scene is not too complex, maybe it can be fast enough. <br><br></td></tr></table><br>
<a name="1320392"></a>

<a name="1320393"></a>

<a name="1320394"></a>

<a name="1320395"></a>

<a name="1320396"></a>

<a name="1320397"></a>

<a name="1320449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Test with another flat shape (a symbol) with only an "outglow" :<br><img src="http://rd-stuff.fr/glow-with-flat-rectangles-on-important-edges-with-decreasing-alpha-201609272007.jpg"><br><br>imo it looks better with an "outglow" + an "outlineglow" (like with the square shape)<br><br>also the cool thing is that if you model the "outglow" in a certain way, you can then scale it up/down along the "outaxis" (in this case upward) and it will look as if the intensity is increased/decreased. <br><br></td></tr></table><br>
<a name="1320400"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting. You seem  to become the glow/illuminated objects expert here. <br><br></td></tr></table><br>
<a name="1320421"></a>

<a name="1320443"></a>

<a name="1320535"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Rick&gt;&gt;thanks but i don't like the term "expert", i would prefer the term experimenter if you don't mind ;) <br><br></td></tr></table><br>
<a name="1320642"></a>

<a name="1320643"></a>

<a name="1320644"></a>

<a name="1320645"></a>

<a name="1320646"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> new experiment/result inspired by the volumetric glow by Rob with some improvements to have the glow shape with only one surface and some tweaks with the colors/alpha to make it looks less white/more colored :<br><img src="http://rd-stuff.fr/glow-with-scaledup-shapes-with-decreasing-alpha-201610011359.jpg"><br><br>there is still one improvement that i want to add :<br>instead of scalingup each glow shape, i want to push the vertices (using the vertices normals) so that there is the same offset all around the shape. Not sure if this doable without producing deformations of the shape, i will see... <br><br></td></tr></table><br>
<a name="1320649"></a>

<a name="1320650"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> no... it only works if the shape is shaped in a way that the scaled up bigger shape will have all its edges outside of the smaller shape. Hence the superiority of per pixel glow... <br><br></td></tr></table><br>
<a name="1320651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't scale using the normal but using the vector relative to the center of the object.<br><pre class=code>
V.Vector = Vertex-Center
L# = V.Length() + Extend#
NewVertexPosition = Vertex +  V.Normalized() * L
</pre><br><br>It won't be homogenous but it will work for any convex shapes <br><br></td></tr></table><br>
<a name="1320652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think that's what scalemesh already does but from the origine of the shape, so if i set the origine at the center of the shape, then scalemesh probably repositions the vertices using a similar formula. <br><br></td></tr></table><br>
<a name="1320654"></a>

<a name="1320655"></a>

<a name="1320656"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> ScaleMesh resizes from the 0,0,0 coordinates. (it's not always the center, it's only the "bouding center" for blitz primitive, but for ex, a cube that you PositionMesh 0,1,0 will have a center at 0,1,0, while ScaleMesh will still use the 0,0,0 point (local to the entity, of course, it's not a global position) )<br><br>The job behind  scalemesh :<br>- Create a transformation matrix (that is just an identity matrix multiplied by a vector which holds the 3 scale factors)<br>- applies the matrix to each vertex.<br>(and finally, recomputes the internal mesh stuff like bounding box/sphere)<br><br>So, in the end, it looks almost the same, except the center is not always the one that fit better for a scaling.<br>But anyway, the goal of my previous post is just to say :<br>- Don't use the vertex normals, they won't do the job for unweld meshes (and will only work for meshes with normals "polyshed" like using UpdateNormals), while an expand along the distance of the vertex to an arbitrary point will work better (for convex meshes !) <br><br></td></tr></table><br>
<a name="1320659"></a>

<a name="1320660"></a>

<a name="1320661"></a>

<a name="1320662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Don't use the vertex normals, they won't do the job for unweld meshes<br> <br></div><br>yes i understand what you mean, but in my previous procedures, i first determined which vertices were at the same position before calculating the new position and repositionning them, and the new position was calculated by adding the n vectors from the n vertices sharing the same position, so it did not matter, there were no offset. But ok ! <br><br></td></tr></table><br>
<a name="1321188"></a>

<a name="1321230"></a>

<a name="1321231"></a>

<a name="1321233"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> Experiment/result with the procedure to push vertices around the shape using the normals (instead of scalingup the shape) :<br><img src="http://rd-stuff.fr/glow-with-pushedvertices-shapes-with-decreasing-alpha-201610061055.jpg"><br>(the glow offset is bigger around some parts than around others parts and i think this is because the surface uses a smoothinggroup which adds more vertices to the surface so that the lighting/shading looks a certain way. And this procedure adds an offset for each vertex and the others vertices at the same position, so if several vertices are at the same position the offset is added multiple times...) <br><br></td></tr></table><br>
<a name="1321192"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> cool RemiD! any code to actually try? <br><br></td></tr></table><br>
<a name="1321193"></a>

<a name="1321195"></a>

<a name="1321205"></a>

<a name="1321232"></a>

<a name="1321234"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> By exporting the mesh/surface without taking into account the smoothinggroups,  the mesh is welded (it has only one vertex at each position), then the glow is more uniform, with the same offset all around the shape :<br><img src="http://rd-stuff.fr/glow-with-pushedvertices-shapes-with-decreasing-alpha-201610061136.jpg"><br><br>and since a fullbright mesh/surface is not lighted/shaded, it can be welded without problems (it also has the advantage to have less vertices per shape/glow)<br><br>Great ! :D <br><br></td></tr></table><br>
<a name="1321194"></a>

<a name="1321204"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>any code to actually try? <br> <br></div><br>I have just explained what i have done, so if you try, i am sure that you can reproduce it ;)<br><br>Maybe later, i want to finish a demo with my own special graphics effects... <br><br></td></tr></table><br>
<a name="1321272"></a>

<a name="1321273"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Final version (tweaked the color of the shape and of the color of the glow layers so that they blend well) :<br><img src="http://rd-stuff.fr/glow-with-pushedvertices-shapes-with-decreasing-alpha-201610071046.jpg"><br>this is what a nice glow should look like imo.<br><br>i have to admit that the render in post #57 looks nice too, but this is not really glow since the shape must be of a brighter color than the glow... <br><br></td></tr></table><br>
<a name="1321274"></a>

<a name="1321275"></a>

<a name="1321276"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was wondering if my "pushverticesofsurface" procedure would work if the shape has its origine not at its center, in theory, yes, in practice, yes :<br><img src="http://rd-stuff.fr/glow-with-pushedvertices-shapes-with-decreasing-alpha-201610071138.jpg"><br>the offset between each glow layer is uniform all around the shape, good ! :)<br>i will try with others weird shapes and if it works well, i will share it.<br>in any case, the shape needs to be welded (only one vertex at each position, and so not take into account smoothinggroups, Fragmotion can help you to export this way (when you export in b3d, tick the "exclude normals" option)) <br><br></td></tr></table><br>
<a name="1321283"></a>

<a name="1321285"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wonder if there is a way to have only some parts of the shape glow...<br>For example, color some vertices of the shape in the material (non glowing) color and some vertices in the glowing color <br>like this : <br><img src="http://rd-stuff.fr/shape-colored-with-material-color-glow-color-201610071250.jpg"><br>and use the alpha property of each vertex of the glow layers to be able to have a glow coming out only from some parts of the shape.<br>Tricky but may work... <br><br></td></tr></table><br>
<a name="1321289"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks nice. <br><br></td></tr></table><br>
<a name="1321291"></a>

<a name="1321292"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> Before i post the procedure, i would appreciate if you can share a few weird 3d shapes (with less than 32000/9 tris), so that i can debug/improve it if necessary. Thanks <br><br></td></tr></table><br>
<a name="1321293"></a>

<a name="1321294"></a>

<a name="1321295"></a>

<a name="1321296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> sure, I found a couple on github <br><br><a href="https://github.com/OpenGLInsights/OpenGLInsightsCode/raw/master/Chapter%2026%20Indexing%20Multiple%20Vertex%20Arrays/article/suzanne.obj" target="_blank">https://github.com/OpenGLInsights/OpenGLInsightsCode/raw/master/Chapter%2026%20Indexing%20Multiple%20Vertex%20Arrays/article/suzanne.obj</a><br><br><a href="https://github.com/OpenGLInsights/OpenGLInsightsCode/blob/master/Chapter%2026%20Indexing%20Multiple%20Vertex%20Arrays/article/bunny.obj" target="_blank">https://github.com/OpenGLInsights/OpenGLInsightsCode/blob/master/Chapter%2026%20Indexing%20Multiple%20Vertex%20Arrays/article/bunny.obj</a><br><br>Just click download on the right side button <br><br></td></tr></table><br>
<a name="1321298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, i also found some in the Blitz3d samples folders (good to keep in mind!) <br><br></td></tr></table><br>
<a name="1321326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RustyKristi</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> nice <br><br></td></tr></table><br>
<a name="1321330"></a>

<a name="1321331"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> This 2003 demo uses shaders and HDR rendering to get some impressive effects:<br><br>http://web.archive.org/web/20090223060038/http://www.daionet.gr.jp/~masa/rthdribl<br><br>Linked to web archive because the actual website seems broken. <br><br></td></tr></table><br>
<a name="1321339"></a>

<a name="1321340"></a>

<a name="1321341"></a>

<a name="1321342"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> With a complex shape (like a humanoid), we can really see the difference between using a welded surface and a notwelded surface :<br>with a welded surface (=no smoothing groups, only one vertex at each position) <br><img src="http://rd-stuff.fr/glow-with-pushedvertices-shapes-with-decreasing-alpha-surfacewelded-201610081046.jpg"><br><br>with a notwelded surface (=smoothing groups, several vertices may be at the same position to improve lighting/shading)<br><img src="http://rd-stuff.fr/glow-with-pushedvertices-shapes-with-decreasing-alpha-surfacenotwelded-201610081046.jpg"><br><br>with a well modeled welded surface, it seems to work well even if the shape is complex. Good ! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
