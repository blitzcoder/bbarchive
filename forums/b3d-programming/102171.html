<!DOCTYPE html><html lang="en" ><head ><title >Controlled Deceleration</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Controlled Deceleration</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Controlled Deceleration</a><br><br>
<a name="1218663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Working on a program and have run into a snag. In a nutshell I want a ship to Run from Star A to Star B with smooth acceleration and deceleration. I use 3 values. <br><br>Speed# which is the Maximum Speed<br>Acceleration# which is how much speed is increased.<br>Thrust# which is how much Acceleration increases or decreases.<br><br>Take off works fine. With Acceleration starting at 0 I just increase its value with Thrust until it reaches Speed. My ship takes off smoothly then cruises along until it reaches the Destination. But of course then its going from max speed to 0 ... don't want that.<br><br>I tried setting up a halfway point where acceleration increases until half the distance and then acceleration starts to decrease. This works fine if the distance between stars is less than how long it takes for the ship to reach maximum acceleration. Longer journeys leaves me with a ship that slows down too soon and reaches 0 acceleration before reaching the star.<br><br>I could go the easy route and just pick some arbitrary distance and then decrease the speed by %, but this would sometimes mean the ship's deceleration is higher than its acceleration. Thinking realistically, ship captains would just fly their ships backward so they would start out faster.<br><br>So I guess I'm wondering if anyone would know a way that I could figure out the point in which I would start slowing the ship down so that it arrived at the destination coordinates with 0 speed? <br><br></td></tr></table><br>
<a name="1218668"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did solve this in a round about way, however I would still be interested if anyone had any kind of formula that would work.<br><br>My solution was to add another Field to my ship Type called MaxAccelDist#. When a ship's acceleration matched the maximum speed the ship could go it would check to see if MaxAccelDist = 0. If it does then it would store the distance the ship had gone into it. If it doesn't = 0 then we would know it was already set and not update it. Then it would only begin slowing the ship down if its distance to the target was equal to or less than the MaxAccelDist. Since it is decelerating at the same rate it accelerated it end up at the destination coordinates by the time its acceleration reaches 0. Once it arrived at the destination it would reset the value of MaxAccelDist to 0 for the next leg of its journey. <br><br></td></tr></table><br>
<a name="1218674"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> There was  the same question some weeks ago on the german forum and I answered with this sample code:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 800,600
SetBuffer BackBuffer()
FPS=CreateTimer(60)
SeedRnd MilliSecs()
Global X#, TargetX#, Speed#, Thrust#

	X=Rnd(10,50)
	TargetX=Rnd(750,790)
	Speed=Rnd(1 , 3.5)
	Thrust= 0.005
	
	t$="Braking Distance = " + BrakingDistance(Speed)
 
	Repeat
		Cls
		Text 100,300,t
		Rect X-2,100-2,5,5
		Rect TargetX,0,1,600
		X= X+ Speed	
		Automatik X, TargetX
		Flip 0
		WaitTimer FPS	
	Until KeyHit(1)



Function Automatik (Pos#, Target#)
    Local Distance#
    Distance = BrakingDistance(Speed)
    If Distance &gt;(Target-Pos)*1.01
		DebugLog "much to close"

        Speed=Speed - 2*Thrust
    ElseIf Distance &gt;(TargetX-Pos)
		DebugLog "to close"
        Speed = Speed - Thrust
    EndIf
	If Speed&lt;0.01
		Speed=0
	EndIf
End Function 


Function BrakingDistance#(TestSpeed#)
     Local Way#=0
     Repeat
         TestSpeed=TestSpeed - Thrust
         Way=Way+TestSpeed
     Until TestSpeed&lt;0
     Return Way
End Function</textarea><br><br>It bases on the fact, that a spaceship can only fire thrust or not. It has two rocket nozzles and uses one to slow down, if the distance is ok and both if the ship is too fast for the target. It stops the nozzles if the spaceship is to far away.<br><br>Now after every nozzle thrust the "only one nozzle distance" is calculated  and compared with the real distance to the star. This causes ON/OFF for the nozzles next thrust. <br><br></td></tr></table><br>
<a name="1218801"></a>

<a name="1218815"></a>

<a name="1218816"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think you should remove the 'thrust' (or "jerk") element from your original concept.<br>You only need the (fixed) 'acceleration' and the (dynamic) 'velocity,' as they can still provide you with a smooth movement.<br><br>You need to use the kinematic equations for this, which are studied under physics.<br>I think the best one for your situation is this, the "Time Independent Equation:"<br><br><b>v</b><font class="tiny">f</font> = <b>v</b><font class="tiny">o</font> + <b>2</b> * <b>a</b> * <b>d</b><br><br>The equation above calculates the final velocity '<b>v</b><font class="tiny">f</font>' of a body based on the velocity '<b>v</b><font class="tiny">o</font>' that it has at the moment that you calculate the equation, its acceleration '<b>a</b>' which is always the same and the displacement that the body will travel '<b>d</b>'.<br>You can see other equations <a href="http://zonalandeducation.com/mstm/physics/mechanics/kinematics/EquationsForAcceleratedMotion/EquationsForAcceleratedMotion.htm" target="_blank"><u>here</u></a>.<br><br>We want the final velocity to be zero (the ship comes to a halt), we know our original velocity (the current one that the ship has), we know the acceleration (it's always the same), and we <i>want</i> to know the displacement that the ship will have (the distance between the target and source positions) so that it can slow down to zero under these conditions.<br>This "want to know" term means that we have to isolate the variable that represents the value that we want to know.<br><br>Isolating 'd,' with a desired final velocity 'v<font class="tiny">f</font>' of zero.<br><br><b>v</b><font class="tiny">f</font> = <b>v</b><font class="tiny">o</font> + <b>2</b>*<b>a</b>*<b>d</b><br><br><b>0</b> = <b>v</b><font class="tiny">o</font> + <b>2</b>*<b>a</b>*<b>d</b><br><br>-<b>2</b>*<b>a</b>*<b>d</b> = <b>v</b><font class="tiny">o</font><br><br><b>d</b> = <b>v</b><font class="tiny">o</font> / -<b>2</b>*<b>a</b><br><br>Replacing the variables with the appropriate names:<br><br><b>minimumDistance</b> = <b>currentSpeed</b> / -<b>2</b>*<b>acceleration</b><br><br>Therefore,<br><div class="quote"> the point in which I would start slowing the ship down so that it arrived at the destination coordinates with 0 speed? <br></div><br>When the ship is close to the target such that the distance between them is less than or equal to 'minimumDistance,' start decelerating the ship: Flip the sign of the acceleration.<br><br>Note that it's easier to do all this if you're keeping separate the direction and magnitude of the vectors involved. This means, you have the direction represented by an angle and the magnitudes represented by floating point variables that you later decompose into 'x' and 'y' components based on the sine and cosine of the angle.<br>If you are doing this, then you can probably insert the magnitudes already in the equation and it should work.<br><br>If you are keeping the vectors decomposed as 'x' and 'y' components, then you would need to retrieve their magnitudes by using the pythagorean theorem: <br><b>magnitude = Sqr( x + y )</b> <br><br></td></tr></table><br>
<a name="1218809"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the response Kryzon! This will most likely still come in handy for me and I'm still digesting it for understanding. I ran your example code and followed it through and I understood what it was doing quite easily. <br><br>The reason I have the thrust variable is to be able to alter it with technology advances. It is a % of the max Speed. I will most likely do away with it later when I clean up the code and just use acc = acc + speed * % because I don't anticipate the thrust value not being tied into the percentage of the max speed.<br><br>I had actually looked into the kinematic equation for velocity (although I wasn't aware it was called that) but the conversion into blitz language was causing me problems. So it is well appreciated that I can now see how that was done.<br><br>Thank you very much! <br><br></td></tr></table><br>
<a name="1218851"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello. I forgot to add this point.<br>Since you have a positive original speed and you are going to get a null final speed, the acceleration value that you input in that formula has to be negative. <br><br></td></tr></table><br>
<a name="1222009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ack. I made a particularly bad assumption that I am just now realizing. I owe an apology to MidiMaster as I overlooked his contribution and for some reason (lack of sleep? degenerating mind from age?) and read the code he presented as if it was from Kryzon.<br><br>I am very sorry for doing that MidiMaster. <br><br></td></tr></table><br>
<a name="1222041"></a>

<a name="1222043"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Originally I stuck in a sloppy movement code in my own program so that I could just get things working and allow me to continue coding other portions. It suffered in accuracy and often left ships stopping early and then slowly finishing the final distance. Upon revising how I handed Star/Planet coordiantes (to cut down on rounding errors) I was forced to revisit how I handled movement and MidiMaster's example proved invaluable. <br><br>I had to adapt it for 2d coordinate moving. Did some other modifications to allow changing the ShipMaxSpeed on the fly, and it now loops to continually go toward new target points once it reaches a target.<br><br>Thanks again to MidiMaster and Kryzon for helping me figure this out!<br><br>There is one small quirk in this in that the value of the ShipThrust *MUST* be smaller than whatever distance you are using to determine if the ship is close enough to the target to consider it arrived. Otherwise the ship moves farther than the level of detection and gets stuck endlessly trying to get there.<br><br>I set the measurement value to be the same as the ShipThrust value - as such, there can still be a small "hiccup" where it actually passes the target, turns around, and then arrives. That can be completely cured by just increasing the distance detection value to the ShipThrust Value + half the shipthrust value.<br><br>EDIT : Added in that the ShipThrust value is a percentile of the ShipMaxThrust Value. The Faster the ship can go the faster it accelerates and decelerates.<br><br><pre class=code>
Graphics 800,600,16,2
SetBuffer BackBuffer()
FPS=CreateTimer(60)
SeedRnd MilliSecs()
Global ShipX#,ShipY#, TargetX#,TargetY#,ShipSpeed#,ShipThrust#
Global ShipHeading#,ShipTurnSpeed#,ShipMaxSpeed#
Global done

done = False

	ShipX=Rnd(10,GraphicsWidth()-10)
	ShipY=Rnd(10,GraphicsHeight()-100)
	TargetX=Rnd(10,GraphicsWidth()-10);Rnd(750,790)
	TargetY=Rnd(10,GraphicsHeight()-100);Rnd(20,500)
	ShipSpeed= 0
	ShipMaxSpeed = 5
	;WARNING : If the value of ShipThrust is higher than the value to determine
	;if the ship is close enough to the target then ship may never "reach" target.
	;As such, Just set the detection distance to the value of ShipThrust.
	ShipThrust= ShipMaxSpeed / 100
	ShipHeading = Rnd(0,360)
	ShipTurnSpeed = 5
	
	t$="Braking Distance = " + BrakingDistance(ShipSpeed,ShipThrust)
 
	Repeat
		If KeyHit(1) Then done = True
		Cls
		Text 100,500,t
		Text 100,520,"Speed :"+ShipSpeed
		Text 100,560,"Thrust : "+ShipThrust
		
		Text 400,500,"Left/Right Arrows Increase/Decrease MaxSpeed"
		If KeyHit(205) Then ShipMaxSpeed = ShipMaxSpeed + 1
		If KeyHit(203) Then ShipMaxSpeed = ShipMaxSpeed - 1
		Text 400,520,"Max Speed : "+ShipMaxSpeed
		
		If ShipMaxSpeed &lt; 1 Then ShipMaxSpeed = 1
		;Draw Target
		Rect TargetX-3,TargetY-3,6,6
		;Draw Ship
		Oval ShipX-2,ShipY-2,5,5
		Line ShipX,ShipY,Cos(ShipHeading) * 10 + ShipX,(Sin(ShipHeading) * 10) * -1 + ShipY
		;If ship not pointed at Target
		TargetAngle = DistAng(ShipX,ShipY,TargetX,TargetY,"ang")
		ShipHeading = TurnToTarget(ShipX,ShipY,TargetX,TargetY,ShipHeading,ShipTurnSpeed)
		Text 100,540,"Left to Turn :"+Abs(ShipHeading - targetangle)
		If Abs(ShipHeading - TargetAngle) &lt; 1 Then
		;If ship pointed at target
			ShipX = Cos(ShipHeading) * ShipSpeed + ShipX
			ShipY = (Sin(ShipHeading) * ShipSpeed) * -1 + ShipY
			ShipSpeed = Automatik (ShipX,ShipY,TargetX,TargetY, ShipSpeed, ShipThrust)
		EndIf
		;Once Ship arrives set new Target coordinates
		If DistAng(ShipX,ShipY,TargetX,TargetY) &lt; ShipThrust + ShipThrust/2 Then
			TargetX=Rnd(10,GraphicsWidth()-10)
			TargetY=Rnd(10,GraphicsHeight()-100)
			DebugLog "Resetting Target and ShipSpeed"
			ShipSpeed = 0
			ShipThrust= ShipMaxSpeed / 100
		EndIf
		Flip 0
		WaitTimer FPS	
	Until done = True
End

Function Automatik# (X#,Y#,TargX#,TargY#,Speed#,Thrust#)
    ;StopDistance - Distance Required to end at full stop
	;Distance - Distance between Ship and Target
	Local StopDistance#,Distance#
    StopDistance = BrakingDistance(Speed,Thrust)
	Distance = DistAng(X,Y,TargX,TargY)
    If StopDistance &gt; Distance*1.01 Then
		DebugLog "much to close"
		Speed=Speed - 2*Thrust
    ElseIf StopDistance &gt; Distance Then
		DebugLog "to close"
        Speed = Speed - Thrust
	Else
		dl$ = "Thrust"
		Speed = Speed + Thrust
		If Speed &gt; ShipMaxSpeed Then 
			Speed = ShipMaxSpeed
			dl$ = "Coasting at MaxSpeed"
		EndIf
		DebugLog dl$
	EndIf
	If Speed &lt; 0.01 And StopDistance &gt;= Distance Then
		If Speed &lt;&gt; -0.01 Then 
			DebugLog "Stopped when speed was "+Speed
			Speed = 0
		EndIf
	EndIf
	Return Speed
End Function 


Function BrakingDistance#(TestSpeed#,Thrust#)
     Local Way#=0
     Repeat
         TestSpeed=TestSpeed - Thrust
         Way=Way+TestSpeed
     Until TestSpeed&lt;0
     Return Way
End Function


Function DistAng#(x1#,y1#,x2#,y2#,job$="")
	dx# = Abs(x1 - x2)
	dy# = Abs(y1 - y2)
	Dist# = Sqr ((dx * dx)+(dy * dy))
	If job = "ang" Then
		ang# = ACos(dx/dist)
		If (x2 &lt; x1) And (y2 &lt;= y1) Then		;91-180 degrees
			ang = 180 - ang
		ElseIf (x2 &lt; x1) And (y2 &gt; y1) Then		;181-269 degrees
			ang = 180 + ang
		ElseIf (x2 &gt;= x1 And (y2 &gt; y1)) Then	;270-360 degrees
			ang = 360 - ang
		EndIf
		Return ang#
	Else
		Return Dist#
	EndIf
End Function


Function TurnToTarget#(ShipX#,ShipY#,TargetX#,TargetY#,Heading#,TurnSpeed#)
	Local Ang#,Turn#
	Ang# =  DistAng(ShipX,ShipY,TargetX,TargetY,"ang")
;If the turnspeed turns us farther than the remaining angle then just point at target
	If Abs(Heading - Ang) &lt; TurnSpeed Then
		Return Ang
	EndIf
;Determine how far to turn
	If Heading &gt; Ang Then
		Turn# = Abs(Heading - Ang)
	Else
		Turn# = Abs(Ang - Heading)
	EndIf
	If Turn &lt;&gt; 0 Then 
		If Turn &lt;= 180 Then
			If Heading &lt;= Ang Then Heading = Heading + TurnSpeed
			If Heading &gt;  Ang Then Heading = Heading - TurnSpeed
		Else
			If Heading &lt;= Ang Then Heading = Heading - TurnSpeed
			If Heading &gt;  Ang Then Heading = Heading + TurnSpeed
		EndIf
	EndIf
	While Heading &gt; 360
		Heading = Heading - 360
	Wend
	While Heading &lt; 0 
		Heading = Heading + 360
	Wend
	Return Heading#	
End Function
</pre> <br><br></td></tr></table><br>
<a name="1222086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think the BreakdingDistance function is turning out to be a bit of a resource hog. I'm still trying to successfully implement this movement method into my program but am having some difficulties. I think that's more of an issue of how I've implemented showing various zoom views than the above code itself, but even with working with only 1 ship I notice a significant drop in FPS once the ship begins its move order.<br><br>My computer is a bit older and slower, but my fps rating drops from the set 60 fps range down to the 40 to 50 range (the further the distance the worse it seems to be). I'm thinking it will get much worse once I implement it for all of the various ships that will be in the game.<br><br>Going to have to focus on finding a single formula to determine breaking distance rather then counting down every update call. <br><br></td></tr></table><br>
<a name="1222202"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> As a fisrt step I would test, how much time the Function BrakingDistance() needs!<br><br><pre class=code>
Function BrakingDistance#(TestSpeed#,Thrust#)
     Local Time%=Millisecs() 
     Local Way#=0
     Repeat
         TestSpeed=TestSpeed - Thrust
         Way=Way+TestSpeed
     Until TestSpeed&lt;0
     Print "Time=" + (Millisecs() -Time)
     Return Way
End Function
</pre><br><br>Please report the results here!<br><br>If it is below 2, it is not responsible for your problems.<br><br>If it is more than 5 you have to do something. Some solutions:<br><br>- You could replace it by a complex function instead of a iteration. <br><br>- You could stop calling the function as long as the target is far away. As you use a "maximum speed", you know its maximum braking distance and as long as this is smaller than the distance to the target, there is no need of testing anything.<br><br>- You could use a "table of speeds&lt;-&gt;distances" for estimate, whether a testing is necessary anyway.<br><br><br>- You could use a 10 times faster approximation if speed is high<br><br><pre class=code>Function EstimateBrakingDistance#(TestSpeed#,Thrust#)
     ShipMaxBrakeDistance=123456
     If TestSpeed&gt;=ShipMaxSpeed Then Return ShipMaxBrakeDistance
     Local Way#=0
     Repeat
         If TestSpeed&gt;MaxSpeed*0.2
              TestSpeed=TestSpeed - 10*Thrust
              Way=Way+10*TestSpeed
         Else
             TestSpeed=TestSpeed - Thrust
              Way=Way+TestSpeed
         Endif
     Until TestSpeed&lt;0
     Return Way
End Function</pre> <br><br></td></tr></table><br>
<a name="1222267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good point and thanks for the response. Should have checked that beforehand.<br><br>Put in a millisec() counter and the outcome on every single pass was 0. Here's the exact code I used (this is from my main program, not the demo used above)<br><pre class=code>
test3 = MilliSecs()
	StopDistance = 0
	BrakeSpeed = Speed
	Thrust = ShipMaxSpeed / 1000
	Repeat
		BrakeSpeed = BrakeSpeed - Thrust
		StopDistance = StopDistance + BrakeSpeed
	Until BrakeSpeed &lt; 0
DebugLog MilliSecs() - test3
</pre><br>I find it odd that the millisecs doesn't increment between assigning Test3 the millisec() value and then doing the subtraction later, but I've run into that before, like when using millisec() to generate unique ID's for various type objects I've created. If I don't put in a delay(10) immediately after a read then the next created type in the loop will have the same exact millisecs() value for the UID.<br><br>For example, when I generate my initial Planets without a Delay (10) all the planets come out with the same UID. I use the Unique ID to parse through the planet types at various times to find specific planets. Here's that chunk of code :<br><br><pre class=code>
	While Not complete
		count = Rand(1,10)
		If Rnd(100) &lt; 45 And st\World[count]\ID = 0 Then
		;Identify Planet with Orbit and Parent Star
			st\World[count]\ID = st\ID
		;Generate Unique ID for Planet
			st\World[count]\UID = MilliSecs()
			Delay(10)
			st\World[count]\Orbit = count
		;Position Planet on orbit line in distances of 100
			ang = Rand(-180,180)
			st\World[count]\X = (Cos(ang) * (count * 10) * .0001)
			st\World[count]\Y = (Sin(ang) * (count * 10) * .0001)
			tempx# = st\World[count]\X
			tempy# = st\World[count]\Y 
		;Determine Size and Class
			st\World[count]\Size = Rand(1,10)
			st\World[count]\Class= Rand(1,10)
		;Name Planet
			name$ = st\Name
			Select count
				Case 1 n$ = "I"
				Case 2 n$ = "II"
				Case 3 n$ = "III"
				Case 4 n$ = "IV"
				Case 5 n$ = "V"
				Case 6 n$ = "VI"
				Case 7 n$ = "VII"
				Case 8 n$ = "VIII"
				Case 9 n$ = "IX"
				Case 10 n$ = "X"
			End Select
			st\World[count]\Name = st\Name + " " + n$
		;Assign Resourse Value to Planets and system
			st\World[count]\resources = Rand (1,3)
			rich = False
		;Rare Chance it is a richer planet
			While Not rich
				If Rand(100) &lt; 10 Then 
					st\World[count]\resources = st\World[count]\resources + Rand(3,10)
				Else
					rich = True
				EndIf
			Wend
			st\Resources = st\Resources + st\World[count]\resources
		;Check to see if enough planets were made
			planetcount = planetcount + 1
			If planetcount = numplanets Then
				st\NumPlanets = numplanets
				complete = True
			EndIf
		EndIf
	Wend
</pre><br><br>So, again, it surprised me that the millisec() value remained the same for each planet in the loop.<br><br>I'm thinking I had a false read on the FPS drop because its not doing it now. Most likely I had something else taking resources in memory and it slowed down the program during the compile and run. If I leave firefox open too long in the background I get that sometimes when running a program.<br><br>So in short, it doesn't look like that BreakDistance check is my problem. It most likely has to do with how I'm presenting magnification. I have a "Galaxy" level view where you see all the stars on a map, then a "Zoom View" for when you click on a star and see the planets/ships in that system. I'm getting movement where my ships are jumping pretty large distances (5 pixels or so) between updates. I think thats because in Zoom view I've ended up making each pixel space the relative size of 20 or 20 pixels from the magnification level so will have to figure out a better way of doing that. <br><br></td></tr></table><br>
<a name="1222311"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's  what i expected: The algo is too fast to think about optimisation.<br><br><br>But we did still not think about the sum of calculations. How many different ship-planet distances do you calculate at the same moment in a typical game situation?<br><br>But what is the reason for the lags?... Next performance test now would be to test the time between REPEAT and FLIP. Please send results.... If time is always &lt;15 there is no need for optimisation.<br><br><br>You cannot use Millisecs() to generate unique IDs, because the app is too fast. Normally you can do thousands of things during one millisec step. So better use ID=Rand(100000). Or use a simple incremending counter for first ID=1, second ID=2, ... <br><br></td></tr></table><br>
<a name="1222314"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Between the number of players set for the game (2 to 8) and the number of stars in the game (50 to 150)  the ship count will run between 210 to 310 ships total, plus or minus depending on how many a player can afford to build. Ships get more expensive for each consecutive ship built. There are ships that a player directly controls and gives orders to (the ones they actually build) and ships that are generated automatically and run in the background beyond the players control (ships that gather resources, move colonists around)<br><br>In my own testing I set all the stars as owned by Player 1 in a 150 star game. It automatically generated 149 resource ships (a ship to gather resources at each 'owned' but un-colonized system' and then return them to the closest base) and while I suffered a drastic FPS loss during the creation of all the ships (which was expected), once they were made they all began running their routes with no real noticeable FPS loss.<br><br>I should point out that when I preformed this 'proof of concept' test it was early on with the ships just going to the resources system, visiting each planet, returning to their home base and then repeating the cycle. There was no acceleration/deceleration code in place at that time. And since then I've rewritten my coordinate system because I was experiencing some rather bad rounding errors when the ships began moving around at a solar system scale vs the galaxy wide scale.<br><br>This is why I revisited the acceleration/deceleration part of this. I haven't completed retrofitting the code that handles ships being able to run their patterns yet because I'm still stuck on getting the acceleration/deceleration working and am still experiencing some accuracy problems on the smaller scale of planets. I'm currently just focused on getting a ship to run from its base to its parent star smoothly. I haven't even begun to add in the portion where a ship runs from star to star again. I'm assuming (hoping like crazy!) that once I solve the small movement problems the big ones will work out when I plug in the larger coordinates.<br><br>I misspoke my concerns of the FPS lag problem. It was more of a projected concern based on what appears now to be my own fault in leaving too many programs open while I was coding that effected the FPS rate.<br><br>Also thank you for the heads-up on millisecs(). I was not aware of that and will most definitely keep that in mind in the future. <br><br></td></tr></table><br>
<a name="1222358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> So if you plan to control the distances of 300 ships, you should simulate this with a simple loop in our test code. (Of course remove the loop after testing it):<br><br><pre class=code>Global TEST_MAX%=10 ; test also 30, 100, 300 

Function BrakingDistance#(TestSpeed#,Thrust#)
     Local Time%=Millisecs()
     Local TestTestSpeed#=TestSpeed
     For Local i%= 0 To TESTMAX 
          Local Way#=0
          TestSpeed#=TestTestSpeed
          Repeat
              TestSpeed=TestSpeed - Thrust
              Way=Way+TestSpeed
          Until TestSpeed&lt;0
     Next
     Print "Time=" + (Millisecs() -Time)
     Return Way
End Function</pre><br><br>Test this first with a value of 10, then 30, then 100 then 300 and report the results.... <br><br></td></tr></table><br>
<a name="1222390"></a>

<a name="1222391"></a>

<a name="1222392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> At 400 ships my FPS drops from 60 to 30, the Timer fluctuates between an 8 and a 9.<br><br>At 300 ship FPS drops from 60 to 55, Timer fluctuates between 5 and 6<br><br>At 200 FPS stayed mostly around 57/58 with it occasionally going up to 59 or dropping to 56 for a flicker. Timer fluctuated between 3 and 4<br><br>At 100 ship FPS stayed pretty solid on either 58 or 59 with the timer showing a solid 2 with the occasional blip into 1<br><br>At 30 Ships FPS stayed a solid 59 with the Timer fluctuating between 1 and 0<br><br>At 10 Ships FPS was a solid 59 with the Timer reading mostly 0 with occasional 1's popping up.<br><br>Just for a stress test I put in 2000 ships. FPS dropped to 18-20 and the Timer fluctuated between 37 and 40.<br><br>Here is the loop I used <br><br><pre class=code>
test1 = MilliSecs()
	For count = 1 To 2000
		StopDistance = 0
		BrakeSpeed = Speed
		Repeat
			If BrakeSpeed &gt; 1 Then
				BrakeSpeed = BrakeSpeed - ShipMaxSpeed / 100
			Else
				BrakeSpeed = BrakeSpeed - ShipMaxSpeed / 10000
			EndIf
			StopDistance = StopDistance + BrakeSpeed
		Until BrakeSpeed &lt; 0
	Next
	test1 = MilliSecs() - test1
</pre><br><br>You'll note that I use too instances of ShipMaxSpeed. I found that using a single value didn't work between the star scale and planet scale. If I set things up to move correctly while flying from star to star then they moved far too fast on the planetary scale, and if set things so that ships moved correctly on that scale they would move way slower on the bigger scale. Often a ship wouldn't even reach its max speed even on long journies.<br><br>Just for a little explanation - Star coordinates are generated on a 650 by 700 grid, then multiplied by 1000. Planet coordinates take up the 0 to 1000 range of a stars x/y coordinate. So there is a magnification difference of about 1000 between the 2. So basically a ship moving on the x axis between 0 and 1000 wouldn't even move 1 pixel on the star scale.<br><br>So I have to alter at what value Thrust has depending on whether the ship is trying to just move within a star system or if its moving from star to star. That made figuring out the breakingdistance a little more trickier so I'm still tweaking that. It currently still wants to overshoot the target and then come back. But I think I'm pretty close to figuring that out. <br><br></td></tr></table><br>
<a name="1222412"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> As 300 is realistic number of ships the 5-6msec should be the realistic time consumption of the deceleration function. <br><br>This is to much! But you can do something very:<br><br>So now I would add a first check, whether the ship is closed to its target or not. Depending on your max speed, there is a "max braking distance". Try to find out this value by a test with max speed in BrakingDistance() and use the returned value as  "ShipMaxBrakeDistance". When distance is higher than this, there is no need of checking anything:<br><pre class=code>Global Const ShipMaxBrakeDistance#=300

Function Automatik# (X#,Y#,TargX#,TargY#,Speed#,Thrust#)
      Local StopDistance#,Distance#
      Distance = DistAng(X,Y,TargX,TargY)
      If Distance &gt;ShipMaxBrakeDistance Then Return ShipMaxSpeed

      StopDistance = BrakingDistance(Speed,Thrust)
      If StopDistance &gt; Distance*1.01 Then
            .....
</pre><br><br>This prevents that the ships that are far away from there target will be checked. If we exepect that 20% of the ship are closed to the target and 80% are far away, this reduces the time consumption from 5msec to 1msec<br><br>More? Better? What do you think about a function EstimateBrakingDistance() ?<br><br>This function reduces the iterations, when the speed of the ship is very high, but makes a "fine tuning" if the speed is low:<br><br><pre class=code>Function EstimateBrakingDistance#(TestSpeed#,Thrust#)
     ShipMaxBrakeDistance=123456
     If TestSpeed&gt;=ShipMaxSpeed Then Return ShipMaxBrakeDistance
     Local Way#=0
     Repeat
         If TestSpeed&gt;ShipMaxSpeed*0.2
              TestSpeed=TestSpeed - 10*Thrust
              Way=Way+10*TestSpeed
         Else
             TestSpeed=TestSpeed - Thrust
              Way=Way+TestSpeed
         Endif
     Until TestSpeed&lt;0
     Return Way
End Function</pre> <br><br></td></tr></table><br>
<a name="1222475"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do you mean like the way everything always slows to a stop smoothly in Metal gear games? If so tell me, I have just the thing. <br><br></td></tr></table><br>
<a name="1222541"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> fox, I am not familiar with Metal gear games, so not sure if its the same thing or not.<br><br>Midi, this is becoming a bit problematic. I'm not yet accurately finding a BreakingDistance value where the ship slows to a stop. This is because of the 2 different levels of Thrust I'm using dependent on how far the ship is from the target.<br><br>I recognize where my problem here is and just have to work out how best to know when to slow the ship at the faster value or slower value. Until then I can't really implement what you've suggested.<br><br>However I do think that your suggestion is completely correct. The ship should never have to slow down before it reaches the halfway point, so I can skip making a breakdistance check up to that point. Once it reaches halfway then either it has achieved MaxSpeed or its at the fastest speed it can get so I can do a single check on what the Stopdistance is going to be. If the ship isn't going max speed it will then just start decelerating, else if its coasting at maxspeed the Stopdistance value will tell me when it starts decelerating.<br><br>I just wanted to make sure you know I recognize and understand what you are saying and that I'm not ignoring your suggestion. As soon as I get things smoothed out for the StopDistance I'll implement this and report the results to you.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="1222628"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I mean for slowing things down like this:<br><pre class=code>
.
.
 .
   .
       .
              .        .
</pre><br>The module I made can be used for gradual slowdowns or speedups, and can be stretched across any segment of your ships route. <br><br></td></tr></table><br>
<a name="1222646"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> That sounds like it could be quite helpful for me. One of the problems I'm facing is that I'm using a set acceleration value for increasing/decreasing speed. This works fine if I were using standard distances, but moving between stars and moving between planets requires to very different acceleration ratios. In a nut shell my x/y values for stars are in the 999,000 range while the x/y for planets is in the 999  range. <br><br>Basically, on the star scale, each planetary system is only 1 pixel across. So if my star x value is at 100,000 and my ship moves to 100,001 then its already left the system. So when I calculate my interplanetary movements I have demagnify the scale (if that makes sense). 1 pixel movement on the planetary scale would then become something like 1/1000 on the star scale.<br><br>If I used a set thrust value then accelerating out of the star system to go to another star takes a very long time before the ship achieves enough thrust to be noticeable on the star scale - and the converse of entering the planetary system after arriving from another star has my ship with speeds that are so high that it looks like its just teleporting around on that scale. <br><br>This has caused me to use 2 different values for thrust, but that makes figuring out when and how much to slow down problematic (at least for me). More often than not my ships overshoot their destination, turn around, overshoot again (but be a little closer) and just running back and forth until its close enough to be considered there.<br><br>So yes, a sloped curve like you show above, I think, would help out well because while the initial acceleration may be slow on the star scale, it would quickly increase in power for faster acceleration.<br><br>I'd be very interested to see what you have to see if it would solve some of the problems I'm having. <br><br></td></tr></table><br>
<a name="1222807"></a>

<a name="1222808"></a>

<a name="1222843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 640,480,32,1
blitz=LoadFont("blitz",10,1,0,0)
SetFont blitz:Color 128,128,128
ClsColor 25,25,25



SINETYPE  $= "gradual^"
;SINETYPE  $= "sudden^"
;SINETYPE  $= "gradualv"
;SINETYPE  $= "suddenv"

SINESPEED #= .5 ; .1 ~ 3

sinemultiplier3 #= 0
sinemultiplier2 #= 0
sinemultiplier1 #= 0
sinemultiplier  #= 0 ; final output

degrees2  #= -90
degrees1  #= 0
degrees   #= 0
enddegree #= 0

height2 #= 0
height1 #= 0
height  #= 0

backgroundAposition1 #= 0
backgroundAposition  #= 0
backgroundBposition  #= 0
backgroundCposition  #= 0

image %= LoadImage("sine wave.png")

If sinetype="gradual^":degrees1=180:enddegree=270:EndIf ; 0 ~ 50
If sinetype="sudden^":degrees1=-90:enddegree=0:EndIf ; 50 ~ 100
If sinetype="gradualv":degrees1=0:enddegree=90:EndIf ; 100 ~ 50
If sinetype="suddenv":degrees1=90:enddegree=180:EndIf ; 100 ~ 50



While Not KeyDown(1)
Cls
UpdateWorld
RenderWorld()



If Not degrees1=enddegree
If KeyDown(57) degrees1=degrees1+sinespeed ;  1,  2,  3
EndIf
degrees=degrees2+degrees1                  ; 91, 92, 93

If degrees1&lt;-90 degrees1=270
If degrees1&gt;270 degrees1=-90

height2=Sin(degrees) ; 0, 1, 0, -1, 0 
height1=height2* 107 ; span
height =height1+ 239 ; start

 If sinetype="gradual^"
If degrees1&gt;enddegree degrees1=enddegree
sinemultiplier3=height-346               ; 0 ~  214
sinemultiplier2=sinemultiplier3/1.080808 ; 0 ~ - 99
sinemultiplier1=Abs(sinemultiplier2)     ; 0 ~   99
sinemultiplier=sinemultiplier1+1         ; 1 ~  100
 EndIf

 If sinetype="sudden^"
If degrees1&gt;enddegree degrees1=enddegree
sinemultiplier3=height-239.00001
sinemultiplier2=sinemultiplier3/1.080808
sinemultiplier1=Abs(sinemultiplier2)
sinemultiplier=sinemultiplier1+1
 EndIf

 If sinetype="gradualv" 
If degrees1&gt;enddegree degrees1=enddegree
sinemultiplier3=height-239
sinemultiplier2=sinemultiplier3/1.080808
sinemultiplier1=Abs(sinemultiplier2)
sinemultiplier=sinemultiplier1+1
 EndIf

 If sinetype="suddenv" 
If degrees1&gt;enddegree degrees1=enddegree
sinemultiplier3=height-346
sinemultiplier2=sinemultiplier3/1.080808
sinemultiplier1=Abs(sinemultiplier2)
sinemultiplier=sinemultiplier1+1
 EndIf

backgroundAposition1=-degrees1
backgroundAposition=backgroundAposition1*1.777777
backgroundBposition=backgroundAposition+640
backgroundCposition=backgroundAposition-640

DrawImage image,backgroundAposition,0
DrawImage image,backgroundBposition,0
DrawImage image,backgroundCposition,0

Color 128,128,128
Text 0, 0,"sinemultiplier: "+sinemultiplier

Color 255,255,255
Rect 320,height,1,1



Flip
Wend
End
</textarea><br><br>You'll need this image file:<br><a href="http://kiwi6.com/file/4c1sjmgwi3" target="_blank">http://kiwi6.com/file/4c1sjmgwi3</a> <br><br></td></tr></table><br>
<a name="1222837"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Fox. I'm seeing very good potential here, but my mind just isn't grasping the mechanics of how I would implement it.<br><br>If I understand it correctly, I wouldn't even have to use thrust/acceleration to move an object (ship), I would just have to track the time of the travel and use a sine wave to see how far along the path it had gone. Visually it would appear to be accelerating and decelerating as its x/y would be plotted dependent on how far along the wave it was. <br><br>I'll need to mull this over a bit more to better absorb how I might use it. <br><br></td></tr></table><br>
<a name="1222846"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello.<br>I don't understand why you're not using a kinematic equation as a solver for your system. <br><br></td></tr></table><br>
<a name="1222857"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> To be bluntly honest, its a combination of things at this point ranging from weak math skills to simple inexperience in knowing which path to follow to a bad case of wanting to just get something working so I could continue developing other parts of my program. Midi's initial code looked to do exactly what I needed and my being able to modify it to run and look exactly what I wanted to do left me focused on trying to conform it into my own code. <br><br>However, I have been looking back at what you explained to me earlier and am trying to see if I have a handle on it enough to plug that in. My first attempts when I began this involved trying to implement the kinematic equation, but my source knowledge was from a Texas Instrument Calculator manual (and I didn't even know it was called the kinematic equation then) but what I managed failed miserably. <br><br></td></tr></table><br>
<a name="1222860"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon, one problem I'm seeing right away is the same issue I'm having with Midi's code - I need to manage 2 different thrust values for acceleration/deceleration dependent on whether I'm traveling in system or between stars. These 2 different values mix as a ship enters a system and uses a lower thrust value or exits a star system and starts thrusting at a higher value. <br><br>Whichever thrust value I use for one does not work with the other. The kinematic formula seems dependent on the same value of thrust being used at all times. I'm not sure how I would adapt to this, or even if I can?<br><br>This is why fox's example seemed promising to me. I like the idea of an initial low thrust value that quickly increases as the ship moves. This would allow the relatively short distance in planet to planet movement to use the lower thrust value, but if they continued moving toward another star it would increase with a higher rate of thrust to cover the much larger distances. But I have to admit, that I didn't even know where to start to convert what he posted into something I could use. <br><br>Unless that is what the "magnitude" equation you presented was for? I didn't quite understand how that came into play or how it would be used.<br><br>I'm sorry to be struggling with this so much. <br><br></td></tr></table><br>
<a name="1222861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just as an update, I did successfully plug in the Kinematic formula. I used the same thrust value for the entire trip from 1 star to another. But the problem I ran into was what I explained - that set thrust value made macro movement vs micro movement problematic.<br><br>So obviously the tricky question is can the Kinematic formula still work if using a thrust value that changes? Ideally, if the thrust could start out quite low and then geometrically increase to its max amount. I'm reading over the link you posted, but I'm not sure if something like that is there as it all seems to depend on constant acceleration.<br><br>Here is the function I made for acceleration/deceleration, btw<br><br><pre class=code>
Function Update_Accel#(ShipX#,ShipY#,DestX#,DestY#,ShipMaxSpeed#,Speed#)
	Local Distance#, StopDistance#, Thrust#
	
	Distance = DistAng(ShipX,ShipY,DestX,DestY,"")
	Thrust = ShipMaxSpeed / 10000
	
	StopDistance = Abs((Speed * Speed) / (-2 * Thrust))
	
	If Distance &gt; StopDistance Then Speed = Speed + Thrust
	If Distance &lt;= StopDistance Then Speed = Speed - Thrust
	
	Return Speed
End Function
</pre><br><br>The DistAng call is just a function call that returns the distance between two points, or their angle if 'ang' is put between the quotation marks.<br><br>I also made Stop distance an Abs value because it was coming up negative from that -2. Suppose I could have just taken the - off? <br><br></td></tr></table><br>
<a name="1222862"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> So I went on the search for Kinematic non constant acceleration ... I think I'm suffering some internal brain bleeding now. This subject is quickly destroying what little confidence in mathematics I thought I had ... <br><br></td></tr></table><br>
<a name="1222875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wrote this a while back, it might be useful. It essentially takes an entity and smoothly moves it from point A to point B. I understand that your system is a little more complex, but my thoughts are that you could possibly use two different points for movement: one for the interplanetary system, and one for the star system. The only problem I see is that the entity would appear to stop right as it reaches the boundary of the two systems before accelerating again.<br><br><a href="http://blitzbasic.com/codearcs/codearcs.php?code=3058" target="_blank">http://blitzbasic.com/codearcs/codearcs.php?code=3058</a><br><br>I just want yo let you know that there's a logical bug in the demo in which if you slow the speed of one object, it will keep snapping back to the starting position until the other object finishes. But this is just a bug in the demo, not in the actual function.<br><br>I have to go to my math class (Calculus III) now, but I will be back later. I'm curious if I could provide a modified version which would be a better match for your needs. <br><br></td></tr></table><br>
<a name="1222885"></a>

<a name="1222886"></a>

<a name="1222889"></a>

<a name="1222985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't realize that you were having trouble with implementing the kinematic solution.<br><br>I have written some example code.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;Example of a simple kinematic solver for space travel.
;
; Notes: 
;	- Unit of distance: pixel.
;
;------------------------------------------------------


;CONST.

;Unit of distance: pixel.

;Travel distance beyond which the ship uses its "turbo" mode (higher thrust), for travelling between star 
;systems or at least wildly far away planets (in the case of a large star system with far away planets).

Const DISTANCE_THRESHOLD# = 300.0 ;Pixels.

;Thrusts used when travelling to a planet or star.

Const THRUST_INTERPLANETARY#	= 0.05
Const THRUST_INTERSTELLAR#		= 0.5

Const MAX_SPEED#	= 10.0 ;The maximum speed has to be a common multiple of all the possible thrust 
						   ;values so there's an increase in the precision of movement.

Const SHIP_SIZE#		= 32
Const HALF_SHIP_SIZE#	= 16
Const TEXT_OFFSET		= 3 + HALF_SHIP_SIZE

Const STATE_SELECT_TARGET	= 1
Const STATE_WAIT_TO_START	= 2
Const STATE_ACCELERATING	= 3
Const STATE_CRUISING		= 4
Const STATE_DECELERATING	= 5

Const TRAVEL_MODE_NORMAL	= 1
Const TRAVEL_MODE_TURBO		= 2

;LOCAL.

Local fpsTimer
Local newState

;GLOBAL.

Global shipSpeed#
Global shipThrust#
Global shipAngle#

Global shipX#, shipY#			;Position of the ship.
Global targetX#, targetY#		;Position of the target.
Global slowdownX#, slowdownY#	;Position of the point of slowdown (point beyond which the ship 
								;begins decelerating to reach the target).
Global slowdownDistance#		;Distance that the ship travels until it reaches the slowdown point.								
								
Global travelMode
Global travelDistance#

Global gameState
Global stateMessage$
Global messageR, messageG, messageB


;Program entry.

Graphics( 800, 600, 0, 2 )
SetBuffer( BackBuffer() )

fpsTimer = CreateTimer( 30 )

shipX = 400
shipY = 500

setState( STATE_SELECT_TARGET )


;Main loop.

While Not KeyHit( 1 ) Or ( KeyDown( 56 ) + KeyDown( 62 ) )

	WaitTimer( fpsTimer )
	Cls
	
	Select gameState
	
		Case STATE_SELECT_TARGET
			
			targetX = MouseX()
			targetY = MouseY()
			
			shipAngle = ATan2( targetY - shipY, targetX - shipX )
			
			travelDistance = distance2D( shipX, shipY, targetX, targetY )
			
			If travelDistance &lt; DISTANCE_THRESHOLD Then 
			
				travelMode = TRAVEL_MODE_NORMAL ;Standard thrust.
			
			Else
			
				travelMode = TRAVEL_MODE_TURBO ;Turbo thrust. For travelling between far away bodies.
			
			EndIf 
			
			If MouseHit( 1 ) Then setState( STATE_WAIT_TO_START )
			
			;- - - - -
			
			solveSlowdown()			
			drawGame()
		
		Case STATE_WAIT_TO_START
			
			drawGame()
			Flip
			WaitKey()
			
			solveSlowdown() ;*** Calculate the slowdown point under the set circumstances.
			
			setState( STATE_ACCELERATING )	
			
		Case STATE_ACCELERATING
			
			newState = accelerateShip()
			
			drawGame()
			
			If newState &lt;&gt; gameState Then 
				setState( newState )		
			Else
				moveShip() ;Only move the ship if there's not a state change, otherwise it adds 
						   ;to the imprecision of reaching the target.
			EndIf 
			
		Case STATE_CRUISING
		
			newState = cruiseShip()
		
			drawGame()
			
			If newState &lt;&gt; gameState Then 
				setState( newState )		
			Else
				moveShip()
			EndIf
		
		Case STATE_DECELERATING

			newState = decelerateShip()
			
			drawGame()
			
			If newState &lt;&gt; gameState Then 
				
				Delay 500
				setState( newState )
			
			Else
			
				moveShip()			
			
			EndIf 	
		
	End Select

	Flip

Wend

End


;FUNCTIONS.

Function setState( state% = STATE_SELECT_TARGET )

	gameState = state
	
	Select gameState
	
		Case STATE_SELECT_TARGET
			
			stateMessage	= "Use the mouse to set the target position. Click when ready."
			messageR		= 200
			messageG		= 200
			messageB		= 200 
		
		Case STATE_WAIT_TO_START
		
			stateMessage = "Press any key for the ship to start travelling to the target."
			messageR		= 240
			messageG		= 240
			messageB		= 0 
			
		Case STATE_ACCELERATING
		
			stateMessage = "ACCELERATING."
			messageR		= 0
			messageG		= 240
			messageB		= 0 
		
		Case STATE_CRUISING
		
			stateMessage = "CRUISING (Maximum speed reached)."
			messageR		= 0
			messageG		= 200
			messageB		= 255 
		
		Case STATE_DECELERATING
		
			stateMessage = "DECELERATING."
			messageR		= 240
			messageG		= 0
			messageB		= 0 

	End Select

End Function


Function drawGame()

	;State message.
	
	Color( messageR, messageG, messageB )
	Text( 10, 10, stateMessage )
	
	;Ship.
	
	Select gameState
		
		Case STATE_SELECT_TARGET, STATE_WAIT_TO_START
		
			Color( 255, 128, 64 )
		
		Case STATE_ACCELERATING
		
			Color( 0, 210, 0 )
			
		Case STATE_CRUISING
		
			Color( 0, 210, 220 )
			
		Case STATE_DECELERATING
		
			Color( 190, 0, 0 ) 
		
	End Select
	 
	Oval( shipX - HALF_SHIP_SIZE, shipY - HALF_SHIP_SIZE, SHIP_SIZE, SHIP_SIZE, True )
	
	;Target.
	
	Color( 255, 255, 255 )
	Rect( targetX - HALF_SHIP_SIZE, targetY - HALF_SHIP_SIZE, SHIP_SIZE, SHIP_SIZE, False )
	Rect( targetX - 2, targetY - 2, 4, 4, True )
		
	;Point of slowdown.
	
	Local tempAngle# = shipAngle + 90
	
	Color( 255, 0, 255 )
	Line( slowdownX - Cos( tempAngle ) * 20, slowdownY - Sin( tempAngle ) * 20, slowdownX + Cos( tempAngle ) * 20, slowdownY + Sin( tempAngle ) * 20 )
	
	Color( 220, 220, 220 )
	
	;Ship text.
	
	Text( shipX + TEXT_OFFSET, shipY + TEXT_OFFSET, "Ship" )
	
	;Target text.
	
	Text( targetX + TEXT_OFFSET, targetY + TEXT_OFFSET, "Target" )
		
	;State related graphics.
	
	If gameState = STATE_WAIT_TO_START Or gameState = STATE_SELECT_TARGET Then
	
		;Point of slowdown text.
	
		Color( 220, 220, 220 )
		Text( slowdownX + TEXT_OFFSET, slowdownY + TEXT_OFFSET, "Point of Slowdown" )
	
		;Travel-mode text.
	
		If travelMode = TRAVEL_MODE_NORMAL Then
		
			Color( 0, 200, 0 )
			Text( 10, 50, "Normal travel mode. (" + Int( travelDistance ) + ")" )
	
		Else
	
			Color( 220, 220, 0 )
			Text( 10, 50, "Turbo travel mode. (" + Int( travelDistance)  + ")" )
	
		EndIf		
	
	EndIf
	
	;Trajectory line.
			
	Line( shipX, shipY, targetX, targetY )

End Function


Function solveSlowdown()

	;This function calculates the point of slowdown, which is the point at which the ship needs to start decelerating to a null speed (zero).
	;When the ship reaches the null speed, it has reached its target.
	;The only kinematic equation used in this solver function is the "time independent" equation:
	
	;Vf = Vo + 2 * a * d

	;This function needs to know the following values:
		
		;- Position of the ship.
		;- Position of the target.	
		;- Distance bettwen the ship and the target.
		;- Thrust values for the ship when under normal and turbo mode.
		
	;It assumes the following conditions: 
	;
	;	- The ship always uses the same thrust value during the travel, regardless if its
	;	accelerating, crusing (has reached the maximum speed) or decelerating. The thrust value is
	;	defined before the ship starts travelling, based on the distance between the ship and its destination.
	;
	;	- The ship starts travelling from a still position.
	
	;LOGIC.
	
	;1) Define which thrust (acceleration) value that the ship will use.
	
		Local acceleration#
	
		If travelMode = TRAVEL_MODE_NORMAL Then
		
			acceleration	= THRUST_INTERPLANETARY
			shipThrust		= THRUST_INTERPLANETARY
			
		Else
		
			acceleration	= THRUST_INTERSTELLAR
			shipThrust		= THRUST_INTERSTELLAR
			
		EndIf
	
	;2) Test if the ship can reach its maximum speed before travelling HALF the total distance.
	;Using the kinematic equation, this means that the final speed is 'unknown,' the starting speed is 'zero', the
	;distance is half the total travel distance and the acceleration is the thrust that was decided in the previous step.
	
		Local Vf#
		Local d# = travelDistance / 2.0
	
		;From this...
		
		;Vf = Vo + 2 * a * d
	
		;...to the code form. The square in "Vf" was moved to the other side as a square-root:
		
		Vf = Sqr( 0 + 2 * acceleration * d )
	
		;SLOWDOWN CASE 1:
		;If the calculated final speed when reaching half the distance is equal to or less than the maximum possible speed, 
		;then the ship only has to decelerate past half the distance. It takes half way to accelerate, and half way to decelerate.
		
		If Vf &lt;= MAX_SPEED Then
		
			slowdownX = ( shipX + targetX ) / 2.0
			slowdownY = ( shipY + targetY ) / 2.0
		
		EndIf 
		
		;SLOWDOWN CASE 2:
		;If the calculated final speed when reaching half the distance is greater then the maximum possible speed, then the
		;ship reaches the maximum speed at some point before reaching half the distance.
		;This means that the distance from the slowdown point to the target is the same distance as the starting position
		;of the ship to the point where the ship reaches maximum speed.
		;In this case, the slowdown distance is always the same no matter the distance - it is given by the turbo thrust.
		;The ship will accelerate, travel for a while under maximum speed, then decelerate. 
		
		If Vf &gt; MAX_SPEED Then
	
			;From the kinematic equation, isolating "d" to discover the distance at which the ship reaches the maximum speed.
			;Vf = Vo + 2 * a * d
			
			;d = Vf / 2 * a
			
			d = ( MAX_SPEED * MAX_SPEED ) / ( 2.0 * acceleration ) 
			
			;Moving away from the target point to the starting position of the ship by 'd' amount.
			
			d = d / travelDistance
			
			slowdownX = targetX - ( targetX - shipX ) * d
			slowdownY = targetY - ( targetY - shipY ) * d
		
		EndIf
	
	;*** The point of slowdown was calculated above as the coordinates 'slowdownX' and 'slowdownY.'
	
	;*** The ship will pass the slowdown point when the DOT PRODUCT of the [ship to slowdown point] vector and 
	;the [ship to target] vector results in	a NEGATIVE number.
	;Calculating a dot product is much faster than calculating a distance.
	
End Function


Function distance2D#( x1#, y1#, x2#, y2# )

	Return Sqr( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) )

End Function


Function dotProduct#( x1#, y1#, x2#, y2# )

	;[x1, y1] and [x2, y2] define 2D vectors from the ORIGIN of space.
	
	Return ( x1 * x2 ) + ( y1 * y2 )

End Function


Function accelerateShip()

	;Accelerate the ship.

	shipSpeed = shipSpeed + shipThrust
	
	;Check for passing the slowdown point (for the SLOWDOWN CASE 1). Always check for the slowdown point first.
	
	If dotProduct( ( targetX - shipX ), ( targetY - shipY ), ( slowdownX - shipX ), ( slowdownY - shipY ) ) &lt; 0.0 Then
	
		;If a negative dot product was calculated, then the ship has already passed the slowdown point and needs to decelerate.
		
		Return STATE_DECELERATING
	
	EndIf
	
	;Limit the speed.
	
	If shipSpeed &gt; MAX_SPEED Then 
		
		shipSpeed = MAX_SPEED
		Return STATE_CRUISING ;Switch to the cruise state.
	
	EndIf
	
	Return STATE_ACCELERATING ;Continue with this accelerating state.

End Function


Function cruiseShip()

	;Check for passing the slowdown point (for the SLOWDOWN CASE 2).
	
	If dotProduct( ( targetX - shipX ), ( targetY - shipY ), ( slowdownX - shipX ), ( slowdownY - shipY ) ) &lt; 0.0 Then
	
		;If a negative dot product was calculated, then the ship has already passed the slowdown point and needs to decelerate.
		
		Return STATE_DECELERATING
	
	EndIf
	
	Return STATE_CRUISING ;Continue with this cruising state.

End Function


Function decelerateShip()

	shipSpeed = shipSpeed - shipThrust
	
	If shipSpeed &lt;= 0.0 Then Return STATE_SELECT_TARGET
	
	Return STATE_DECELERATING

End Function


Function moveShip()

	Local velocityX# = Cos( shipAngle ) * shipSpeed
	Local velocityY# = Sin( shipAngle ) * shipSpeed
	
	shipX = shipX + velocityX
	shipY = shipY + velocityY

End Function

;Kryzon, 2014.</textarea> <br><br></td></tr></table><br>
<a name="1222894"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for pointing that out to me Rob. I hadn't thoroughly gone through the 3d Graphics portion of the archives because I'm not currently using 3d spacial movement. However, one thought I am entertaining is that once I have the core code figured out that I would convert some of my GUI to render in 3d for effects and what not. <br><br>Kryzon, that is an amazing example! I'm going to spend some time now in running this and walking through it so that I can get a handle on what its doing. I sometimes have trouble understanding concepts as they are explained, and having a visual representation of what's going on goes quite far in allowing me to absorb and learn. Thank you!<br><br>Thanks to everyone in helping me out with this. I sincerely appreciate the time and effort in the responses! <br><br></td></tr></table><br>
<a name="1222901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm glad. If you have trouble understanding the code, please share. <br><br></td></tr></table><br>
<a name="1222915"></a>

<a name="1222916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not having any trouble understanding the code. the commenting and notes have explained each part of it so that I'm easily able to see what its doing and how its doing it.<br><br>I'm at the point now where I'm digging around in it and tinkering. I admit the format that it follows still throws me off when I'm trying to recall where it goes next or in what order things happen. But each time I follow it through that sticks more readily in my memory.<br><br>I'm trying to change it so that movement always starts and ends in the Standard thrust mode and am trying to use the Distance_Threshold as the marker for that. The reason for this is because if the distance is great enough that MaxSpeed is achieved then it starts out and ends in "Turbo Mode". This is simply an aesthetic quibble on my part. So I'm seeing if I can have those trips where it reaches MaxSpeed and cruises start and end in Standard Mode the same as those distances in which MaxSpeed is not reached.<br><br>So as it looks now, using 'S' for Ship, 'T' for Target 'D' for the point in which slow down starts,'-' for Normal Thrust, '=' for Cruise and '+' for Turbo Thrust it looks like :<br><br>Max Speed Not Achieved -<br><br>S----------D----------T<br><br>Max Speed Achieved - <br><br>S++++++++++==========D++++++++++T<br><br>What I'm shooting for would look like this, where '&gt;' a minimum distance that the Ship would Travel in Normal Thrust before switching to Turbo Thrust and '&lt;' is the minimum remaining distance in which it would change from Turbo Thrust back to Normal Thrust<br><br>S-----&gt;+++++++=========D+++++++&lt;-----T<br><br>The plan is to use the kinematic formula to determine what the ships speed will be in Standard Thrust when it reaches '&gt;'. Then it will determine the deceleration point between &gt; and &lt;, keeping in mind that I don't want to find that point by decelerating all the way down to 0 when it reaches &lt; and that it will be starting out with the speed it reached when it got to &gt;. Then I will switch it to Standard Thrust again and decelerate to 0 between &lt; and T.<br><br>I believe it should be fairly simple and the only trouble I'm having at the moment is adapting the code example you provided. It's more about my own remembering of where things occur and what order they occur in. Most likely I'll start it from scratch so that the format is more familiar to me.<br><br>I'm very excited about this and thank you again for all your help! <br><br></td></tr></table><br>
<a name="1223027"></a>

<a name="1223072"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I got it. I had to fudge a bit at the end because the calculations didn't seem to be coming out precise. Once I calculated how far the ship moved to reach maximum speed I just took that and moved back from the target's position to get where I wanted to start slowing down. More often than not the precision was off so that one cycle of movement between Fast deceleration and slow deceleration was enough that either the ship stopped far short or overshot by a significant amount.<br><br>Basically, when the ship reached the point in which it was suppose to change from Turbo Speed to Normal Speed I force adjusted the speed to match what the speed was when it changed from Normal to Turbo. <br><br>I'm sorry, Kryzon, that I butchered your code up a little bit. But some of the math and techniques you used escaped me and I had to work around my own ignorance.<br><br>Here's what I worked out<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Using Kinematic equations to calculate Acceleration/Decelration

Const THRUST_PLANETARY#	= 0.001 ;(1/1000 of MaxSpeed) - Short Range Travel
Const THRUST_STELLAR#	= 0.1	;(1/10 of Max Speed)  - Long Range Travel
Const CORNERX			= 10	;X pointer for lower graphic
Const CORNERY			= 500	;Y pointer for lower graphic

Type PlotPoint
	Field x,y
End Type

;ship Info
Global Max_Speed# = 2.0			;Maximum Ship Speed
Global ShipSpeed#				;Current Ship Speed
Global ShipThrust#				;Amount of Thrust to alter Ship Speed
Global ShipAngle#				;Ship's Heading
Global Threshold# = 2.0			;Range in which Ship *MUST* travel at Impulse (Interplanetary) speeds
;Stored Positions
Global ShipX#, ShipY#			;Position of the ship.
Global TargetX#, TargetY#		;Position of the target
Global StartX#,StartY#			;Location Ship was at When target was selected
Global ReverseX#, ReverseY#		;Point when ship starts to reverse Thrust
Global ReversePoint#			;Point Ship starts to decelerate
Global ThreshX#,ThreshY			;Point when Ship can use THRUST_STELLAR

Global StellarX#,StellarY#		;Distance when Ship using THRUST_STELLAR changes to THRUST_PLANETARY
Global StellarSpeed#			;Speed Ship is going when reaching the Stellar Marker Point
Global PlanetaryX#,PlanetaryY#	;Distance Remaining Before Ship can engage THRUST_STELLAR

Global TravelDistance#			;Total Distance of Trip from Start to Finish
Global isTraveling				;Boolean if ship is traveling
Global MidPoint#				;Halfway Marker
Global MidX#,MidY#				;Location of Midpoint
Global CoastX#,CoastY#			;Point Ship Reaches Max Thrust and can coast
Global CoastPoint#				;Distance Coast takes effect

Global ThrustMode$				;If Accel/Decel and if Warp/Impulse
Global setdelay					;Boolean to slow down time


Graphics( 800, 600, 0, 2 )
SetBuffer( BackBuffer() )

fpsTimer = CreateTimer( 30 )

ShipX = 10
ShipY = 300
HidePointer()

;Main loop.
While Not KeyHit( 1 )  ; Esc
	WaitTimer( fpsTimer )
	Cls()
;Draw Mouse
	Color 255,255,255
	Oval MouseX()-2, MouseY()-2, 5, 5
;Get Initial Travel Info when Mouse is clicked
	If KeyHit(15) Then setdelay = 1 - setdelay
	If setdelay Then Delay(250)
	;Start Ship Movement
	If MouseHit(1) Then 
		isTraveling = True
		Delete Each PlotPoint
		Find_Marker_Points()
	EndIf
	;Reset the Scene
	If MouseHit(2) Then
		ShipX = 10
		ShipY = 300
		ShipSpeed = 0
		isTraveling = False
		Delete Each PlotPoint
	EndIf
	;Select Target Point
	If (Not isTraveling)
		TargetX = MouseX()
		TargetY = MouseY()
		StartX = ShipX
		StartY = ShipY
		TravelDistance = DistAng(ShipX,ShipY,TargetX,TargetY)
		ShipAngle = DistAng(ShipX,ShipY,TargetX,TargetY,"ang")
	;Increase/Decrease Max Speed
		If KeyHit(200) Then 
			Max_Speed=Max_Speed+1
			If Max_Speed &gt; 10 Then Max_Speed = 10
		EndIf
		If KeyHit(208) Then 
			Max_Speed=Max_Speed-1
			If Max_Speed &lt; 1 Then Max_Speed = 1
		EndIf
	;Increase/Decrease Threshold Amount
		If KeyDown(205) Then Threshold = Threshold + 1
		If KeyDown(203) Then Threshold = Threshold - 1
		If Threshold &lt; 0 Then Threshold = 0
	;Find Marker Points for travel
		Find_Marker_Points()
	Else
		ShipSpeed = Get_Acceleration()
		ShipX = Cos(ShipAngle) * ShipSpeed + ShipX
		ShipY = Sin(ShipAngle) * ShipSpeed * -1 + ShipY
		If ShipSpeed = 0 Then
		;Wait for Mouseclick before accepting next target location
			While Not MouseHit(1)
				Delay(5)
			Wend
			isTraveling = False
		EndIf
	EndIf

;Speed Grid
	Color 100,100,100
	For count = CORNERY To GraphicsHeight() Step 10
		Line CORNERX,count,CORNERX+TravelDistance,count
	Next
	;Plot Ship Speed
	dist# = DistAng(ShipX,ShipY,StartX,StartY)
	Oval CORNERX+dist-2,CORNERY-2+ShipSpeed*10,5,5
	If dist Mod 1 Then
		pp.PlotPoint = New PlotPoint
		pp\x = CORNERX+dist
		pp\y = CORNERY+ShipSpeed*10+1
	EndIf
	Color 0,255,255
	px=CORNERX
	py=CORNERY
	For pp.PlotPoint = Each PlotPoint
		Line px,py,pp\x,pp\y
		px = pp\x
		py = pp\y
	Next
;Ship
	Color 255,255,0
	Oval ShipX-2,ShipY-2,5,5
	Line ShipX,ShipY,Cos(ShipAngle) * 10.0 + ShipX,Sin(ShipAngle) * 10.0 * -1 + ShipY
	Text 10,10, "ShipX : "+ShipX
	Text 10,25, "ShipY : "+ShipY
	Text 400,10,"Max Speed : "+Max_Speed
	Text 600,10,"Ship Speed : "+ShipSpeed
	Oval CORNERX-2, CORNERY-22,5,5
	Line CORNERX,CORNERY-22,CORNERX,CORNERY
	Line ShipX,ShipY,ShipX,ShipY-30
	Text ShipX,ShipY-40,"Ship "+ThrustMode,0,1
	Text ShipX,ShipY-60,"Speed "+ShipSpeed,0,1
	If markerx &lt;&gt; 0 And markery &lt;&gt; 0 Then
		Oval markerx-1,markery-10,3,3
	EndIf
;Target
	Color 255,100,255
	Oval TargetX-3,TargetY-3,7,7
	Text 10,40,"TargetX : "+TargetX
	Text 10,55,"TargetY : "+TargetY
	Oval CORNERX+TravelDistance-3,CORNERY-23,7,7
	Line CORNERX+TravelDistance,CORNERY-23,CORNERX+TravelDistance,CORNERY
;Travel Path
	Color 255,255,255
	Line StartX,StartY,TargetX,TargetY
	Text 150,10,"Travel Distance : "+TravelDistance
;Stellar Threshold Position
	If MidPoint &gt; Threshold Then
		Color 0,255,255
		Line StellarX+Cos(ShipAngle+90)*20,StellarY-Sin(ShipAngle+90)*20,StellarX-Cos(ShipAngle+90)*20,StellarY+Sin(ShipAngle+90)*20
		Text 150,25,"Planetary Drive Range : "+Threshold
		Text 400,25,"Threshold Speed : "+StellarSpeed
		Line CORNERX,CORNERY,CORNERX+Threshold,CORNERY
		Line CORNERX+Threshold,CORNERY-60,CORNERX+Threshold,CORNERY
		Text CORNERX+Threshold,CORNERY-70,"Stellar Acceleration",0,1
	EndIf
;Midpoint
	Color 255,255,255
	Line MidX+Cos(ShipAngle+90)*20,MidY-Sin(ShipAngle+90)*20,MidX-Cos(ShipAngle+90)*20,MidY+Sin(ShipAngle+90)*20
	Text 150,40,"Mid Range : "+TravelDistance/2
	temp# = DistAng(StartX,StartY,ReverseX,ReverseY)
	Line CORNERX+Threshold,CORNERY,TargetX,CORNERY
	Line CORNERX+MidPoint,CORNERY-50,CORNERX+MidPoint,CORNERY
	Line CORNERX+MidPoint,CORNERY,CORNERX+ReversePoint,CORNERY
	Text CORNERX+MidPoint,CORNERY-60,"Mid Point",1,1
;Coast Point
	If CoastPoint &lt;= MidPoint And CoastPoint &lt;&gt; 0 Then
		Color 100,255,100
		Line CoastX+Cos(ShipAngle+90)*20,CoastY-Sin(ShipAngle+90)*20,CoastX-Cos(ShipAngle+90)*20,CoastY+Sin(ShipAngle+90)*20
		Line CORNERX+Threshold,CORNERY,CORNERX+CoastPoint,CORNERY
		Line CORNERX+CoastPoint,CORNERY-20,CORNERX+CoastPoint,CORNERY
		Text CORNERX+CoastPoint-75,CORNERY-30,"Max Speed",0,1
	EndIf
;Planetary THRESHOLD position
	If MidPoint &gt; Threshold Then
		Color 0,255,255
		Line PlanetaryX+Cos(ShipAngle+90)*20,PlanetaryY-Sin(ShipAngle+90)*20,PlanetaryX-Cos(ShipAngle+90)*20,PlanetaryY+Sin(ShipAngle+90)*20
		Text 400,40,"Force Slowdown : "+(TravelDistance - Threshold)
		Text 10,70,"SlowDownX : "+PlanetaryX
		Text 10,85,"SlowDownY : "+PlanetaryY
		Line CORNERX+TravelDistance-Threshold,CORNERY,CORNERX+TravelDistance,CORNERY
		Line CORNERX+TravelDistance-Threshold,CORNERY-20,CORNERX+TravelDistance-Threshold,CORNERY
		Text CORNERX+TravelDistance-Threshold,CORNERY-30,"Planetary Deceleration",0,1
	EndIf
;Reverse Thrust
	If ReversePoint &gt; MidPoint  And ReversePoint &gt; Threshold Then
		Color 255,50,50
		Line ReverseX+Cos(ShipAngle+90)*20,ReverseY-Sin(ShipAngle+90)*20,ReverseX-Cos(ShipAngle+90)*20,ReverseY+Sin(ShipAngle+90)*20
		temp# = DistAng(StartX,StartY,ReverseX,ReverseY)
		Text 150,55,"Point of Reverse : "+ ReversePoint
		Line CORNERX+ReversePoint,CORNERY,CORNERX+TravelDistance-Threshold,CORNERY
		Line CORNERX+ReversePoint,CORNERY-40,CORNERX+ReversePoint,CORNERY
		Text CORNERX+ReversePoint,CORNERY-50,"Stellar Decelerate",0,1
	EndIf
;On Screen Instructions
	Color 200,200,200
	Text 200,80,"Left Mouse Button Initiates Flight"
	Text 200,95,"Right Mouse Button Resets Scene"
	Text 500,80,"Up/Down Arrows Set Max Speed"
	Text 500,95,"Right/Left Arrow Sets Threshold"
	Text 200,110,"Tab Slows Processing Speed"
	Flip()
Wend
End

Function Get_Acceleration#()
	Local Dist#,Thrust#, ThrustPoint#, slowpoint#
	
	Dist# = DistAng(ShipX,ShipY,StartX,StartY)
;First Leg and Last Leg
	If Dist &lt; Threshold Or Dist &gt; (TravelDistance - Threshold) Then
		Thrust = THRUST_PLANETARY
		ThrustMode = "Impulse"
;Full Thrust
	Else
		Thrust = THRUST_STELLAR
		ThrustMode = "Warp"
	EndIf
;What is our stop thrust point?
	If CoastPoint &lt;&gt; 0 Then 
		ThrustPoint = CoastPoint
	Else
		ThrustPoint = MidPoint
	EndIf
;Where to start slowing down
	If ReversePoint &lt;= MidPoint Then
		slowpoint = MidPoint
	Else
		slowpoint = ReversePoint
	EndIf
;Increase Ship Speed
	If Dist &lt; ThrustPoint Then
		ShipSpeed = ShipSpeed + Thrust
		If ShipSpeed &lt; Max_Speed Then
			ThrustMode = ThrustMode + " Acceleration"
		Else
			ShipSpeed = Max_Speed
		EndIf
;Decrease Ship Speed
	ElseIf Dist &gt; slowpoint Then 
		ShipSpeed = ShipSpeed - Thrust
		If Dist &lt; TravelDistance - Threshold And ShipSpeed &lt; StellarSpeed Then
			ShipSpeed = StellarSpeed
			ThrustMode = ThrustMode + " Deceleration"
		ElseIf Dist &gt;= TravelDistance - Threshold And ShipSpeed &gt; StellarSpeed Then
			ShipSpeed = StellarSpeed
			ThrustMode = ThrustMode + " Deceleration"
		Else
			ThrustMode = ThrustMode + " Deceleration"
			If ShipSpeed &lt; 0 Then ShipSpeed = 0
		EndIf
;Coast
	Else
		ThrustMode = ThrustMode + " Coasting"
		ShipSpeed = Max_Speed
	EndIf
	Return ShipSpeed
End Function

Function Find_Marker_Points#()

Local d#, Vf#

;Midway Point
	MidPoint = TravelDistance / 2.0
	MidX = Cos(ShipAngle) * MidPoint + StartX
	MidY = Sin(ShipAngle) * MidPoint * -1.0 + StartY
;Stellar Position - Point in which ship can engage Warp Drive
	StellarX = Cos(ShipAngle) * Threshold + StartX
	StellarY = (Sin(ShipAngle) * Threshold * -1.0) + StartY
;Stellar Speed - Find speed of ship when it hits Threshold
	StellarSpeed = Sqr( 0 + 2 * THRUST_PLANETARY * Threshold )
;Planetary Position - Point in which a ship *must* reduce to THRUST_PLANETARY
	PlanetaryX = Cos(ShipAngle) * (TravelDistance - Threshold) + StartX
	PlanetaryY = (Sin(ShipAngle) * (TravelDistance - Threshold) * -1.0) + StartY
;Find out if Ship will attain MaxSpeed before reaching the midpoint
;Vf = Vo + 2 * a * d
; Vo - Speed in which calculation is made
; a   - is Acceleration it is traveling at
; d   - is Distance it travels
	If MidPoint &gt; Threshold Then
		d = MidPoint - Threshold 	;The Threshold part of this distance has already been
									;calculated when StellarSpeed was Determined.
	Else
		d = MidPoint
	EndIf
	Vf = Sqr( StellarSpeed + 2 * THRUST_STELLAR * d )
	Text 400,55,"Mid Point Travel Speed : "+Vf
;If Vf hasn't achieved max speed then our point of slowdown is the midpoint
	If Vf &lt;= Max_Speed Then
		ReverseX = Cos(ShipAngle) * (MidPoint) + StartX
		ReverseY = Sin(ShipAngle) * (MidPoint) * -1.0 + StartY
		ReversePoint = MidPoint
		CoastPoint = 0
	Else
;Need to isolate the distance at which our ship hits max speed. Using the equation
;Vf = Vo + 2 * a * d
;d = Vf - Vo / 2a
	d = ((Max_Speed * Max_Speed) - (StellarSpeed * StellarSpeed)) / (2.0 * THRUST_STELLAR)
;This is the point in which ship reaches MaxSpeed and can coast from here until slowdown point
	CoastPoint = d + Threshold
	CoastX = Cos(ShipAngle) * CoastPoint + StartX
	CoastY = Sin(ShipAngle) * CoastPoint * -1.0 + StartY
;Finding the Reverse point is just a matter of using the point in which the ship hit Max speed
;and measure the same distance back from the target location
		ReversePoint = TravelDistance - CoastPoint
		ReverseX = Cos(ShipAngle) * ReversePoint + StartX
		ReverseY = Sin(ShipAngle) * ReversePoint * -1 + StartY
	EndIf
End Function

;Simple function to find distance and angle
Function DistAng#(x1#,y1#,x2#,y2#,job$="")
	dx# = Abs(x1 - x2)
	dy# = Abs(y1 - y2)
	Dist# = Sqr ((dx * dx)+(dy * dy))
	If job = "ang" Then
		ang# = ACos(dx/dist)
		If (x2 &lt; x1) And (y2 &lt;= y1) Then		;91-180 degrees
			ang = 180 - ang
		ElseIf (x2 &lt; x1) And (y2 &gt; y1) Then		;181-269 degrees
			ang = 180 + ang
		ElseIf (x2 &gt;= x1 And (y2 &gt; y1)) Then	;270-360 degrees
			ang = 360 - ang
		EndIf
		Return ang#
	Else
		Return Dist#
	EndIf
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1223071"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've edited my above code to include plotting the speed of the ship over the course. Was just curious how it would appear visually. <br><br></td></tr></table><br>
<a name="1223415"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm glad that you're making progress.<br>One thing that I've been meaning to ask you is this. The starship knows the location of its destination and knows the distance that it will have to travel, so why does it need to travel with impulse thrust for a while, and only later engage the warp speed?<br><br>Considering a context such as Star Trek, for example, if they're travelling from a planet to its moon then they use their impulse (or "sub-light") engine. But if they have to travel to another planet or system, they engage the warp exclusively - they don't use the impulse thrust.<br>I presume that the warp is too costly to use with shorter distances, and that the impulse doesn't contribute that much with longer distances.<br><br>The reason I'm saying this is because deciding which thrust to use based on the total distance to travel and just using that thrust for the whole voyage requires a simpler logic. <br>Also, speaking as a player, seeing the ship travelling with a slower thrust when I know that it will later engage the warp speed because I selected a far away destination will feel a bit frustrating, not to mention spend more time than if it were using the warp thrust from the beginning.<br>Regards. <br><br></td></tr></table><br>
<a name="1223451"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry this got long. I'm terrible at brief, concise statements.<br> <br>It's because of the game scales. To explain the scale, the area I generate the coordinates of my stars in is roughly 750,000 x 640,000. I divide that number by 1000 to display them on my map of 750 x 640.<br><br>Each star system has between 1 to 10 planets. Nothing fancy here, just 10 orbital distances around each star. Each planet's coordinate resides within a 1,000 x 1,000 area around each star. In effect each star system is 1 pixel across regardless if it has 1 planet or 10 planets.<br><br>The problem that arises by using a single thrust value is that what works for one level of scope is either too fast or too slow for the other. If I want my ships to move at a reasonably looking speed on the planet scale then I have to increment the speed by tiny amounts, but that means achieving that full warp speed to go to another star is going to take a long time when incrementing ship speed by such a small value. Most of the trip would be spent in constant acceleration/deceleration. Different warp values actually become inconsequential. At those thrust increment speeds the ship won't even hit max speed between most star movements so having warp 2 or warp 10 makes no difference. <br><br>If I use the larger Thrust value then the opposite happens - the ships zip around on the planetary scale and can't even accurately find their target destinations because their thrust range greatly exceeds any level of accuracy of determining when they've arrived. A ship moving just 1 warp thrust value on the planetary scale is enough to jump it between several planet orbits.<br><br>I felt that using 2 different thrust values dependent on how close the ship was to its stop and start area would give me both the accuracy I need for short distances and the speed I needed for long distances. In doing this I had to come up with an arbitrary point where one or the other kicks in.<br><br>I also need to keep in mind that there is almost yet a 3rd level of scale. What appears as acceptable movement between planets is still a bit too fast for very tiny control, such as to dock at a starbase, or eventually move in combat. That is the reason I prefer a gradual increase of speed on the small scale vs just having an arbitrary speed amount. Again, what works for one doesn't work well for the other.<br><br>However, in thinking this through to respond, the idea of getting rid of the Warp thrust value entirely and just automatically going to full warp between those initial speed up and final slowdown values is probably going to be more sensible. I was just initially turned off by the idea of a ship suddenly jumping to full speed. But since a ship moving on that scale is just moving and not maneuvering then I think you are right having the speed up and slow down to and from full speed just adds needless complication.<br><br>I'd work out some visual image at the point of entering and leaving warp, like a halo, or a blurred smear behind the ship or something like that.<br><br>I think a bulk of the problem I'm having is with float accuracy. I'm just now coming to realize the 6 significant figure level. I had assumed it meant 6 figures on each side of the decimal point when it seems to be 6 or 7 digits in total regardless of the decimal. I found RGR's float doubling code last night and am looking to see if using that might be a solution or if I'm going to have to rethink the scales (again). As it stands, a ship with an x coordinate of something like 305743.0 will not always increment if I increase it by any less than about .1 and .1 is far too large on the planetary scale. At that scale, ships docking at a colony base look like they either are teleporting or move in very blocky manners. Or they won't dock at all because the amount of movement is too small to register so they just sit. <br><br></td></tr></table><br>
<a name="1223519"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> The significant digit thing is really stumping me. Tried using RGR's double functions, but that didn't pan out.  Looks like I'm going to have to rethink my entire coordinate system. I really liked the simplicity of everything residing in the same coordinates but it costs me the accuracy of fine level movement. Guess I'm going to have to store and track macro and micro locations separately and not together. <br><br>Rather than have a star's x location as 725,000 and a planet's x location in that star at 725,144 I'll just break them down to 725 for the star and 144 for the planet. <br><br>The trick will be ships recognizing if they are moving on the star's scale or the planet's scale. Gah .. gonna have to rewrite all the resolution and magnification code. What a pain. <br><br></td></tr></table><br>
<a name="1223521"></a>

<a name="1223522"></a>

<a name="1223523"></a>

<a name="1223524"></a>

<a name="1223525"></a>

<a name="1223526"></a>

<a name="1223527"></a>

<a name="1223528"></a>

<a name="1223530"></a>

<a name="1223531"></a>

<a name="1223532"></a>

<a name="1223533"></a>

<a name="1223535"></a>

<a name="1223536"></a>

<a name="1223538"></a>

<a name="1223539"></a>

<a name="1223540"></a>

<a name="1223555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fox95871</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> You sure you don't want to just use a simple sine wave? If you used gradual increase, sudden increase, gradual decrease, sudden decrease from the code I posted, you could easily simulate believable interstellar travel speed transitions.<br><pre class=code>
                  .     . warp ten
              .
            .
          .               the speed of light
.     .                   five miles an hour
</pre> <br><br></td></tr></table><br>
<a name="1223581"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had orginally wanted exactly that fox, but figuring out the formula to determine when and how much acceleration and deceleration was beyond my abilities. I appreciated your examples but I wasn't quite understanding how it worked or how I could adapt it.<br><br>Since that point I have to agree with Kryzon that a simpler system would probably serve best. I'll still require 2 basic thrust speeds depending on which scale I'm moving, but simplifying it by having Warp move only as a maximum speed and using impulse as a set speed (with a minor accel/decel transition from or to stop) for moving on the smaller scale. <br><br></td></tr></table><br>
<a name="1223740"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a very interesting thread with some great examples of deccelerating entities in 3D space, really appreciated. <br><br></td></tr></table><br>
<a name="1224121"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >-Rick-</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I got the movement figured out now. Discovered a flaw in the way I was moving ships - would only have them thrust if they were pointed at the destination coord, which translated them stopping dead in space no matter what their speed if they passed the destination point, turn around, then fly back at the target at the speed they passed it by. Created a see-saw movement that was quite annoying.<br><br>Also added in a check on the final leg of the journey when they drop to impulse engines. Because of rounding errors the initial calculated distance was usually off by the time the ship got there and it would over shoot (causing the see-saw movement). I just recalculate how far they would move from the target point (starting at 0 speed) to reach their current speed at the checkpoint. If they were overshooting then it just does another thrust subtraction to help trim the speed. Haven't seen an overshoot in a few days now. <br><br>The math isn't pretty, but visually everything works out.<br><br>Just wanted to say thank you again to everyone that helped me out with this through suggestions, code examples, and explanations. I learned things I didn't know before and can now apply that in other similar situations which I wouldn't easily be able to do if I just copy/pasted code I didn't understand. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
