<!DOCTYPE html><html lang="en" ><head ><title >Good Collision\Physics Engine for Blitz3D?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Good Collision\Physics Engine for Blitz3D?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Good Collision\Physics Engine for Blitz3D?</a><br><br>
<a name="1192417"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just recently discovered that Blitz3d collisions can't handle moving on moving collisions without the help of an LIB or DLL or whatever - pretty sad that I didn't know until now, huh?<br><br>Anyway, is there any recommendation for good physics/collision engines compatible with Blitz3d? <br><br></td></tr></table><br>
<a name="1192421"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> well if you updateworld after every entity move then it might be working.<br><br>advanced physics are ode, tokamak and newton. several wrappers were released in the past, such as the one for ode by devils child if i recall correctly. see also userlibs section. <br><br></td></tr></table><br>
<a name="1192422"></a>

<a name="1192423"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I just recently discovered that Blitz3d collisions can't handle moving on moving collisions<br> <br></div><br>From my tests, it can. But you have to use a collider sphere against a collider sphere.<br>And set them as both emitter and receiver.<br><br>This means that you can't set a moving collider as being part of a group of colliders, instead  each moving collider is his own group (has its own constant)<br>Then each moving collider must be set as an emitter against all others moving colliders.<br><br>It is not easy to manage but doable.<br><br><br><br>About physics engines, i recommend Bullet and JVODE. <br><br></td></tr></table><br>
<a name="1192428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you show me your example, RemiD? I can't replicate it from the way you're explaining it. <br><br></td></tr></table><br>
<a name="1192432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've actually created a psuedo moving object collision system using the entitydistance command <br><br></td></tr></table><br>
<a name="1192440"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> ...And it proves to be glitchy and unreliable-_- <br><br></td></tr></table><br>
<a name="1192460"></a>

<a name="1192461"></a>

<a name="1192462"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, there is a dinamic collision lib made by Harrison:<br><br><pre class=code>
; Dynamic collision lib by Simon Harrison (si@...)

; You are free to use this source code how you like, however a credit in any programs that use it would be appreciated.
; Feel free to email me any questions you might have about the code, however please don't necessarily expect a reply.

; Limitations:
; Only works with spheres as source entities
; Only works if the source entity is colliding with one dynamic entity at once
</pre><br><br>here is the lib and a sample code i made long ago for testing it<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Dynamic collision lib by Simon Harrison (si@...)

; You are free to use this source code how you like, however a credit in any programs that use it would be appreciated.
; Feel free to email me any questions you might have about the code, however please don't necessarily expect a reply.

; Limitations:
; Only works with spheres as source entities
; Only works if the source entity is colliding with one dynamic entity at once

; Functions:
; DCO_SetPair(src_ent,des_ent,src_type,des_type,src_rad=1.0)
; DCO_UpdateA()
; DCO_UpdateB()
; DCO_EntityCollided()
; DCO_CollisionNX()
; DCO_CollisionNY()
; DCO_CollisionNZ()

; * See included example for demonstration of system.

Global DCO_pair_pos
Global DCO_ent
Global DCO_nx#
Global DCO_ny#
Global DCO_nz#

Type DCO_pair

	Field src_ent,src_col,src_type,src_rad
	Field des_ent,des_col,des_type
	
End Type

Function DCO_SetPair(src_ent,des_ent,src_type,des_type,src_rad=1.0)

	c.DCO_pair=New DCO_pair
	
	c\src_ent=src_ent
	c\src_type=src_type
	c\src_rad=src_rad
	
	c\des_ent=des_ent
	c\des_type=des_type
	
	c\src_col=CreatePivot() : EntityRadius c\src_col,src_rad
	c\des_col=CopyEntity(des_ent)
	EntityAlpha c\des_col,0
	
	DCO_pair_pos=DCO_pair_pos+(MeshWidth(c\des_col)*2)
	DCO_pair_pos=DCO_pair_pos+1000
	PositionEntity c\des_col,DCO_pair_pos,DCO_pair_pos,0
	
	EntityType c\src_col,src_type
	EntityType c\des_col,des_type
	
	ResetEntity c\src_col
	ResetEntity c\des_col
	
End Function

Function DCO_UpdateA()

	Local dx#,dy#,dz#,pivo,pivv

	For c.DCO_pair=Each DCO_pair

		dx#=EntityX#(c\src_ent)-EntityX#(c\des_ent)
		dy#=EntityY#(c\src_ent)-EntityY#(c\des_ent)
		dz#=EntityZ#(c\src_ent)-EntityZ#(c\des_ent)

		pivo=CreatePivot()
		pivv=CreatePivot(pivo)
		
		PositionEntity pivo,EntityX#(c\des_col),EntityY#(c\des_col),EntityZ#(c\des_col)
		
		RotateEntity pivo,0,0,0
		
		PositionEntity pivv,dx#,dy#,dz#,False

		RotateEntity pivo,-EntityPitch#(c\des_ent),-EntityYaw#(c\des_ent),-EntityRoll#(c\des_ent)

		PositionEntity c\src_col,EntityX#(pivv,True),EntityY#(pivv,True),EntityZ#(pivv,True)
		
		FreeEntity pivo
		
	Next

End Function

Function DCO_UpdateB()

	Local col,dx#,dy#,dz#,dx2#,dy2#,dz2#,ddx#=0,ddy#=0,ddz#=0,pivo,pivv,pivn
	
	DCO_ent=0
	For c.DCO_pair=Each DCO_pair
				
		col=EntityCollided(c\src_col,c\des_type)
		
		If col=c\des_col
	
			DCO_ent=c\des_ent
	
			dx#=EntityX#(c\src_ent)-EntityX#(c\des_ent)
			dy#=EntityY#(c\src_ent)-EntityY#(c\des_ent)
			dz#=EntityZ#(c\src_ent)-EntityZ#(c\des_ent)
		
			dx2#=EntityX#(c\src_col)-EntityX#(c\des_col)
			dy2#=EntityY#(c\src_col)-EntityY#(c\des_col)
			dz2#=EntityZ#(c\src_col)-EntityZ#(c\des_col)
	
			pivo=CreatePivot()
			pivv=CreatePivot(pivo)
			pivn=CreatePivot(pivo) ; piv used to translate collsion normals
			
			PositionEntity pivo,0,0,0
	
			RotateEntity pivo,-EntityPitch#(c\des_ent),-EntityYaw#(c\des_ent),-EntityRoll#(c\des_ent)
			
			PositionEntity pivv,dx2#,dy2#,dz2#,True
			PositionEntity pivn,CollisionNX#(c\src_col,1),CollisionNY#(c\src_col,1),CollisionNZ#(c\src_col,1),True
			
			RotateEntity pivo,0,0,0
			
			; platform normals
			DCO_nx#=EntityX#(pivn)
			DCO_ny#=EntityY#(pivn)
			DCO_nz#=EntityZ#(pivn)
			
			dx2#=EntityX#(pivv)
			dy2#=EntityY#(pivv)
			dz2#=EntityZ#(pivv)
	
			ddx#=dx2#-dx#
			ddy#=dy2#-dy#
			ddz#=dz2#-dz#
							
			FreeEntity pivo
		
			TranslateEntity c\src_ent,ddx#,ddy#,ddz#
		
			;Exit
		
		EndIf
				
	Next

End Function

Function DCO_EntityCollided()

	Return DCO_ent

End Function

Function DCO_CollisionNX#()

	Return DCO_nx#

End Function

Function DCO_CollisionNY#()

	Return DCO_ny#

End Function

Function DCO_CollisionNZ#()

	Return DCO_nz#

End Function
</textarea><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Dynamic Collisions Example
; --------------------------
; based on the test program made by Simon Harrison
; modified by Juan Ignacio Odriozola (Charrua)

Include "dcol_lib.bb" ; must be used at start of program

Graphics3D 640,480,0,2
SetBuffer BackBuffer()

Type platfrm
	Field entidad	;entity
End Type


cam=CreateCamera() : PositionEntity cam,0,15,-10 : RotateEntity cam,25,0,0
light=CreateLight()

; Create source entity
Global PlayerRadius# = 1.0
player=CreateSphere() : EntityColor player,0,0,255 : PositionEntity player,0,5,0
guide=CreateCube(player) : EntityColor guide,0,255,255 : ScaleEntity guide,.1,.1,1 : PositionEntity guide,0,.8,.3


; Give sphere a collision type for collisions with non-dynamic objects, i.e. the ground in this case
EntityType player,1 : EntityRadius player,1

room = CreateCube() : ScaleEntity room, 20,20,20 : PositionEntity room, 0,0,10
FlipMesh room
EntityType room,2

s=32
roomTexture=CreateTexture(s,s)
ClsColor 0,200,80
Cls

Color 255,255,255

Rect 0,0,s/2,s/2,1
Rect s/2,s/2,s,s,1

CopyRect 0,0,s,s,0,0,BackBuffer(),TextureBuffer(roomTexture)
ScaleTexture roomTexture,.1,.1

EntityTexture room,roomTexture,0,0

ground = CreatePlane() : EntityType ground,2 : EntityColor ground,0,0,128: EntityAlpha ground,0.8
Mirror=CreateMirror() 


Body1 = CreateCube() : EntityColor Body1,200,200,0 : ScaleEntity Body1,2,1,10 : PositionEntity Body1,-10,10,20
EntityType Body1,2

Body2 = CreateCube() : EntityColor Body2,200,0,200 : ScaleEntity Body2,4,.1,6 : PositionEntity Body2,10,3,18
RotateEntity Body2,-30,0,0
EntityType Body2,2




; NOW THE DYNAMIC STUFF - *** Important comments highlighted by stars ***

; Create first destination entity - platform 1
platform1=CreateCylinder(16) : ScaleEntity platform1,2,.2,2 : EntityColor platform1,255,255,0
PositionEntity platform1,-10,0,8
EntityPickMode platform1,2
plat.platfrm = New platfrm
plat\entidad = platform1


; Create second destination entity - platform 2
platform2=CreateCube() : ScaleEntity platform2,4,1,4 : EntityColor platform2,255,0,0
PositionEntity platform2,10,1,3
EntityPickMode platform2,2
plat.platfrm = New platfrm
plat\entidad = platform2

;another one
platform3=CreateCube() : ScaleEntity platform3,5,.2,5 : EntityColor platform3,0,0,255
PositionEntity platform3,-4,6,28
EntityPickMode platform3,2
plat.platfrm = New platfrm
plat\entidad = platform3

src_type=3 ; assign a collision type for source collision entity (sphere)
des_type=4 ; assign a collision type for destination collision entity (platforms)

; *** Set dynamic collision pairs ***
DCO_SetPair(player,platform1,src_type,des_type,PlayerRadius#) ; parameters - src_entity,des_entity,src_type,des_type,src_radius=1.0
DCO_SetPair(player,platform2,src_type,des_type,PlayerRadius#)
DCO_SetPair(player,platform3,src_type,des_type,PlayerRadius#)

;parar = False


; Set up normal sliding collisions between sphere and plane
;tipo1 = jugador, tipo 2 = sala, esto es para que el jugador choque contra las paredes y el piso
Collisions 1,2,2,2
; *** Enable collisions for dynamic pairs ***

Collisions src_type,des_type,2,2

Global txt1$,txt2$,txt3$
Global estoy=False
Global pvt=CreatePivot()

While Not KeyDown(1)
 
	sph_z#=0
	dy# = 0
	If KeyDown(203)=True Then dy =2
	If KeyDown(205)=True Then dy =-2
	If KeyDown(208)=True Then sph_z=-.4
	If KeyDown(200)=True Then sph_z=.4

	; Make our platforms dynamic - move them!
	If Not EstoyDebajoPlataforma(player) Then 
		MoveEntity platform1,0,Sin(angle#)*0.1,0
		angle#=angle#+1
	End If

	TurnEntity platform2,0,1,0
	
	TranslateEntity platform2,0,0,Sin(angle#)*0.1
	
	MoveEntity platform3,Sin(angle1#)*0.2,0,0 : angle1#=angle1#+1
	
	
	If EstoySobrePlataforma(player) Then
	;	;esto es un parche y no se por que se acelera...
		sph_z = sph_z/5
	Else
		DCO_UpdateA()
		UpdateWorld 0
		DCO_UpdateB()
		MoveEntity player,0,-.3,0
	EndIf

	MoveEntity player,0,sph_y,sph_z
	TurnEntity player,0,dy,0
	
	; *** Usual UpdateWorld call ***
	UpdateWorld
	
	; *** For best results, try experimenting with the order of the above four function calls ***
	
	RenderWorld
	
	; Output dynamic collision information - the dynamic collision system works best if you use these values to implement
	; proper bouncing physics between source entity and destination entity
	Text 0,  0,"EntityCollided: "+DCO_EntityCollided()
	Text 0, 20,"CollisionNX: "+DCO_CollisionNX#()
	Text 0, 40,"CollisionNY: "+DCO_CollisionNY#()
	Text 0, 60,"CollisionNZ: "+DCO_CollisionNZ#()
	
	Flip True

Wend


Function EstoySobrePlataforma(yo)	; player is over a platform

	algo = LinePick(EntityX(yo,True),EntityY(yo,True),EntityZ(yo,True),0,-PlayerRadius#,0)	;linea hacia abajo
	si = False

	If algo Then
		For plat.platfrm = Each platfrm
			If algo = plat\entidad Then
				EntityParent yo,plat\entidad
				si=True
			End If
		Next
	End If

	If Not si Then EntityParent yo,0
		
	Return si
	
End Function

Function EstoyDebajoPlataforma(yo)	; player is under a platform

	
	algo = LinePick(EntityX(yo,True),EntityY(yo,True),EntityZ(yo,True),0,+PlayerRadius#,0)	;linea hacia arriba
	si = False

	If algo Then
		For plat.platfrm = Each platfrm
			If algo = plat\entidad Then
				si=True
			End If
		Next
	End If

	
	Return si
	
End Function
</textarea><br><br>(no media needed)<br><a href="https://dl.dropboxusercontent.com/u/78894295/dco_demo.exe" target="_blank">https://dl.dropboxusercontent.com/u/78894295/dco_demo.exe</a><br><br><br><br>hope it helps<br><br>Juan <br><br></td></tr></table><br>
<a name="1192491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Incredible! This was all done purely using Blitz3d code? <br><br></td></tr></table><br>
<a name="1192492"></a>

<a name="1192503"></a>

<a name="1192504"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using a physics engine will be good for your project in the long run as they're generally both faster and more robust than collision. Si's code is really cool and definitely usable for simple things though (I have the feeling it may not scale too well if you want thousands of fully dynamic objects with more than two interaction directions, but most games don't actually need that so it's fine).<br><br>A very fast-and-light solution also worth checking out is <a href="/toolbox/toolbox.php?tool=11" target="_blank">ColDet</a>. Technically it's an intersection library rather than a "true" collision library: that is, where Blitz can detect both a) that the line of an entity's movement took it through another collider, and b) adjust its position according to slide parameters if necessary, ColDet merely tests whether two colliders are currently intersecting or not. Essentially it's like MeshesIntersect, except with the advantage that its mesh intersection check is faster than B3D's sphere collision check. In practice intersection combined with some "hard" position checks (i.e. "am I outside the universe? if so, reset") is perfectly adequate for games where objects move at a limited speed, as the linear collision is only truly necessary for situations when objects are moving more than one object-length in one frame, and therefore might skip an intersection check. <br><br></td></tr></table><br>
<a name="1192500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> So basically, Yasha, ColDet won't actually determine "collision" as in stopping the two moving objects, but will still internally recognize when the two moving objects have intersected? <br><br></td></tr></table><br>
<a name="1192502"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Indeed, it won't stop objects from moving - in fact it can't, since it's a DLL and isn't integrated with the B3D movement engine but rather maintains its own internal collision entities. It's not really too hard to write some code around this though (if you do decide to use ColDet, I can post up a simple wrapper I wrote around the commands to make them work like B3D stop-collisions). <br><br></td></tr></table><br>
<a name="1192518"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Then ColDet is exactly what I needed! I downloaded it just a couple minutes ago and I'm still looking over its functions - trying to figure out how it works and all. Do you have any advice or anything of that kind? <br><br></td></tr></table><br>
<a name="1192519"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> ColDet works by creating and maintaining a second logical universe with its own set of entities, which are dedicated colliders. You move these entities in accordance with the entities in your main B3D universe, then check to see what the collision consequences of the movement were, potentially updating the B3D scene as a result. The ColDet universe is completely separated from the B3D one and therefore all of the movement and collision results and so on needs to be explicitly expressed in your code.<br><br>Some of the functions are exposed directly from the DLL, others are wrapped by B3D code in the BB file. It's not important which is which (unless you want to hack on it), so much as it is important to remember which are the "main" API and which are "internal" and generally to avoid in high-level code.<br><br>-- ColDet_Start and ColDet_End create and destroy the separate colliders' world space.<br>-- ColDet_Make creates a collider mesh from a B3D mesh.<br>-- ColDet_Finalize frees a collider entity.<br>-- ColDet_SetMatrix updates the position of a collider to match its B3D counterpart's current world position. You probably want to loop through all of your dynamic entities and call this somewhere in your main loop.<br>-- ColDet_Collision returns true if two ColDet collider entities are currently intersecting.<br>-- Sphere-mesh and ray-mesh collisions are also supported; the former is probably good for optimising low-detail scenes and the latter is good for ray picks.<br>-- The collision-information functions work similarly to their B3D counterparts. Calling ColDet_Colliding_Verts or ColDet_Collision_Point sets up which data will be returned by the information functions themselves.<br><br>Here is a wrapper-wrapper that makes a pathetic attempt at recreating some of the B3D commands (this code is pretty bad, several of the command loop through all entities twice or more - I wrote it for a program with a small number of highly detailed meshes where the loops didn't matter because they were short, don't use it for a large system). It's a drop-in replacement for ColDet.bb:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Slightly modified version of EliasT's wrapper
; - changed the function names to be tidier
; - added new functions to imitate B3D collision system
; - changed ColDet_Start and ColDet_End to create and free collider list

;------------------------------------------------------------------------
;COLLISION POINT BANK
Global col_point=CreateBank(3*4)

;COLLIDING TRIANGLES BANK
Global col_verts1=CreateBank(9*4)
Global col_verts2=CreateBank(9*4)

;COLLIDING TRIANGLES Index BANK
Global col_tri1=CreateBank(1*4)
Global col_tri2=CreateBank(1*4)


;RAY COLLISION BANKS
Global ray_origin=CreateBank(3*4)
Global ray_direction=CreateBank(3*4)

;sphere centers
Global col_center1=CreateBank(3*4)
Global col_center2=CreateBank(3*4)


;matrix
Global col_dummy_pivot
Global col_matrix = CreateBank(16*4)

;arrays for nx,ny,nz calculations
Dim cnrx1#(0),cnry1#(0),cnrz1#(0)
Dim cnrx2#(0),cnry2#(0),cnrz2#(0)
;------------------------------------------------------------------------






;NEW FUNCTIONS-----------------------------------------------------------


Type Collider
	Field b3d_entity
	Field coldet_entity
	Field hasMoved
	Field colType
	Field pickMode
End Type

Function FreeCollider(c.Collider)
	ColDet_Free_Model c\coldet_entity
	Delete c
End Function


Type CollisionTypePair
	Field t1, t2
End Type


;------------------------------------------------------------------------
;EntityType replacement (creates ColDet meshes and adds to list)
;------------------------------------------------------------------------
Function ColDet_ListAdd(entity, colType)
	Local c.Collider = New Collider
	c\b3d_entity = entity
	c\coldet_entity = ColDet_Make(entity, 1)
	c\colType = colType
	
	ColDet_SetMatrix(c\b3d_entity, c\coldet_entity)
End Function


;------------------------------------------------------------------------
;Remove entity from collision list and delete colmesh
;------------------------------------------------------------------------
Function ColDet_ListRemove(entity)
	Local c.Collider
	For c = Each Collider
		If c\b3d_entity = entity
			FreeCollider c
			Exit
		EndIf
	Next
End Function


;------------------------------------------------------------------------
;Create a dedicated (non-rendering) collider entity (convenience)
;------------------------------------------------------------------------
Function ColDet_CreateCollider(entity, colType)
	ColDet_ListAdd entity, colType
	HideEntity entity
End Function


;------------------------------------------------------------------------
;Create a collision pair
;------------------------------------------------------------------------
Function ColDet_SetCollisionPair(t1, t2)
	Local p.CollisionTypePair = New CollisionTypePair
	p\t1 = t1
	p\t2 = t2
End Function


;------------------------------------------------------------------------
;Check if a pair of collision types have a response set
;------------------------------------------------------------------------
Function ColDet_TypesCollide(t1, t2)
	Local p.CollisionTypePair
	For p = Each CollisionTypePair
		If (p\t1 = t1 And p\t2 = t2) Or (p\t1 = t2 And p\t2 = t1) Then Return True
	Next
End Function


;------------------------------------------------------------------------
;Get the ColDet mesh corresponding to a Blitz entity
;------------------------------------------------------------------------
Function ColDet_GetColDetEntity(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	Return c\coldet_entity
End Function


;------------------------------------------------------------------------
;Get the ColDet collision type from a Blitz entity handle
;------------------------------------------------------------------------
Function ColDet_GetColDetType(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	Return c\colType
End Function


;------------------------------------------------------------------------
;Get the ColDet pick mode from a Blitz entity handle
;------------------------------------------------------------------------
Function ColDet_GetColDetPickmode(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	Return c\pickMode
End Function


;------------------------------------------------------------------------
;Set whether an entity is pickable
;------------------------------------------------------------------------
Function ColDet_SetColDetPickMode(entity, mode)
	Local c.Collider = ColDet_GetCollider(entity)
	c\pickMode = mode
End Function


;------------------------------------------------------------------------
;Get the Collider associated with a Blitz entity handle
;------------------------------------------------------------------------
Function ColDet_GetCollider.Collider(entity)
	Local c.Collider
	For c = Each Collider
		If c\b3d_entity = entity Then Return c
	Next
End Function


;------------------------------------------------------------------------
;CameraPick replacement
;------------------------------------------------------------------------
Function ColDet_CameraPick(camera, viewX, viewY, viewW, viewH)
	Local x#, y#, picked, zdiff# = 1000000;, ptr;, entity, cEntity
	
	x = (viewX - viewW / 2)
	y = - (viewY - viewH / 2)
	TFormPoint x, y, viewW / 2, camera, 0
	PokeFloat ray_origin, 0, EntityX(camera, 1)
	PokeFloat ray_origin, 4, EntityY(camera, 1)
	PokeFloat ray_origin, 8, EntityZ(camera, 1)
	PokeFloat ray_direction, 0, TFormedX()
	PokeFloat ray_direction, 4, TFormedY()
	PokeFloat ray_direction, 8, TFormedZ()
	
	Local c.Collider
	For c = Each Collider
		If c\pickMode		;Entity is pickable
			If MemoryFastPeekByte(c\b3d_entity + $18)		;Entity is visible
				ColDet_SetMatrix c\b3d_entity, c\coldet_entity
				If ColDet_Ray_Collision2(c\coldet_entity, ray_origin, ray_direction)
					ColDet_Collision_Point c\coldet_entity, 0
					TFormPoint PeekFloat(col_point, 0), PeekFloat(col_point, 4), PeekFloat(col_point, 8), 0, camera
					If TFormedZ() &lt; zdiff
						zdiff = TFormedZ()
						picked = c\b3d_entity
					EndIf
				EndIf
			EndIf
		EndIf
	Next
	
	Return picked
End Function


;------------------------------------------------------------------------
;Move an entity unless it collided
;------------------------------------------------------------------------
Function ColDet_MoveEntity(entity, x#, y#, z#)
	Local oldX#, oldY#, oldZ#
	
	oldX = EntityX(entity)
	oldY = EntityY(entity)
	oldZ = EntityZ(entity)
	
	MoveEntity entity, x, y, z
	
	ColDet_ResetAll
	If ColDet_EntityCollided(entity)
		PositionEntity entity, oldX, oldY, oldZ
		ColDet_ResetAll
	EndIf
End Function


;------------------------------------------------------------------------
;Turn an entity unless it collided
;------------------------------------------------------------------------
Function ColDet_TurnEntity(entity, pitch#, yaw#, roll#)
	Local oldP#, oldY#, oldR#, cEntity
	
	oldP = EntityPitch(entity)
	oldY = EntityYaw(entity)
	oldR = EntityRoll(entity)
	cEntity = ColDet_GetColDetEntity(entity)
	
	TurnEntity entity, pitch, yaw, roll
	
	ColDet_ResetAll
	If ColDet_EntityCollided(entity)
		RotateEntity entity, oldP, oldY, oldR
		ColDet_ResetAll
	EndIf
End Function


;------------------------------------------------------------------------
;EntityCollided replacement
;------------------------------------------------------------------------
Function ColDet_EntityCollided(entity)
	Local c.Collider = ColDet_GetCollider(entity)
	
	Local comp.Collider
	For comp = Each Collider
		If comp &lt;&gt; c
			If ColDet_TypesCollide(c\colType, comp\colType)
				If ColDet_Collision(c\coldet_entity, comp\coldet_entity) Then Return True
			EndIf
		EndIf
	Next
End Function


;------------------------------------------------------------------------
;Update the transformation matrices for all ColDet meshes
;------------------------------------------------------------------------
Function ColDet_ResetAll()
	Local c.Collider
	For c = Each Collider
		ColDet_SetMatrix c\b3d_entity, c\coldet_entity
	Next
End Function




;COLDET FUNCTIONS--------------------------------------------------------





;------------------------------------------------------------------------
;Start
;------------------------------------------------------------------------
Function ColDet_Start()
	
	col_dummy_pivot = CreatePivot()
	PokeFloat col_matrix, 12,0
	PokeFloat col_matrix, 28,0
	PokeFloat col_matrix, 44,0
	PokeFloat col_matrix, 60,1
	
	Dim cnrx1#(1),cnry1#(1),cnrz1#(1)
	Dim cnrx2#(1),cnry2#(1),cnrz2#(1)
	
End Function


;------------------------------------------------------------------------
;End
;------------------------------------------------------------------------
Function ColDet_End()
	
	FreeEntity col_dummy_pivot
	FreeBank col_point
	FreeBank col_verts1
	FreeBank col_verts2
	FreeBank col_tri1
	FreeBank col_tri2
	FreeBank ray_origin
	FreeBank ray_direction
	FreeBank col_center1
	FreeBank col_center2
	FreeBank col_matrix
	
	Dim cnrx1#(0),cnry1#(0),cnrz1#(0)
	Dim cnrx2#(0),cnry2#(0),cnrz2#(0)
	
	Local c.Collider
	For c = Each Collider
		FreeCollider c
	Next
	
End Function






;------------------------------------------------------------------------
;This function creates a coldet compatible model.
;By this we mean that we use the global vertex positions of the model,
;since coldet does not work with scales.

;dynamic=0 the model is static.
;dynamic=1 the model moves and/or rotates.
;------------------------------------------------------------------------

Function ColDet_Make(entity,dynamic)
	
	Local model
	Local cbank,count%
	Local surf,tris,verts
	Local v0%,v1%,v2%,point%
	Local vx#,vy#,vz#
	Local rx#,ry#,rz#
	Local px#,py#,pz#
	
	
	Local surfs=CountSurfaces(entity)
	If surfs=0 Return 0
		
;We want a 0 rotated and 0 positioned object object
;We will return it to it's original state after the coldet model is created
		rx=EntityPitch(entity,1)
		ry=EntityYaw(entity,1)
		rz=EntityRoll(entity,1)
		RotateEntity entity,0,0,0,1
		px=EntityX(entity,1)
		py=EntityY(entity,1)
		pz=EntityZ(entity,1)
		PositionEntity entity,0,0,0,1
		
		For i=1 To surfs
			surf=GetSurface(entity,i)
			tris=tris+CountTriangles(surf)
		Next
		
		
;make the coldet model with triangles=tris and  dynamic= 0 or 1
		
;NOTE: If you not asign the tris number the coldet model
;      will still be constructed. The tris no. assignment 
;      is for faster construction speed of the coldet model.
		
		If dynamic&gt;1 dynamic=1
			If dynamic&lt;0 dynamic=0
				
				model=ColDet_Make_Model(tris,dynamic)
				
				cbank=CreateBank(tris*9*4)
				
				
				count=0
				
				For i=1 To surfs
					surf=GetSurface(entity,i)
					
					For k=0 To CountTriangles(surf)-1
						
						v0=TriangleVertex(surf,k,0)
						v1=TriangleVertex(surf,k,1)
						v2=TriangleVertex(surf,k,2)
						
						vx=VertexX(surf,v0)
						vy=VertexY(surf,v0)
						vz=VertexZ(surf,v0)
						TFormPoint vx,vy,vz,entity,0
						PokeFloat cbank,count+0,TFormedX()
						PokeFloat cbank,count+4,TFormedY()
						PokeFloat cbank,count+8,TFormedZ()
						
						vx=VertexX(surf,v1)
						vy=VertexY(surf,v1)
						vz=VertexZ(surf,v1)
						TFormPoint vx,vy,vz,entity,0
						PokeFloat cbank,count+12,TFormedX()
						PokeFloat cbank,count+16,TFormedY()
						PokeFloat cbank,count+20,TFormedZ()
						
						vx=VertexX(surf,v2)
						vy=VertexY(surf,v2)
						vz=VertexZ(surf,v2)
						TFormPoint vx,vy,vz,entity,0
						PokeFloat cbank,count+24,TFormedX()
						PokeFloat cbank,count+28,TFormedY()
						PokeFloat cbank,count+32,TFormedZ()
						
						count=count+36
						
					Next
					
				Next
				
				
				ColDet_Add_Model(model,cbank,tris*9)
				
				FreeBank cbank
				
				ColDet_Finalize(model)
				
				
;set it back to it's original rotation and position
				RotateEntity entity,rx,ry,rz,1
				PositionEntity entity,px,py,pz,1
				
				ColDet_SetMatrix(entity,model)
				
				
				
				Return model
				
End Function






;------------------------------------------------------------------------
;USE THIS ONLY IF YOU CREATE A COLDET MODEL MANUALLY
;This function just makes an "empty" coldet model and specifies the number of tris
;Use this function against the "coldet_make" function if you want
;to add manually triangles to a coldet model.

;NOTE: If you not asign the tris number the coldet model
;      will still be constructed. The tris no. assignment 
;      is for faster construction speed of the coldet model.
;------------------------------------------------------------------------

Function ColDet_Model_Start(tris=0,dynamic=0)
	If dynamic&gt;1 dynamic=1
		If dynamic&lt;0 dynamic=0
			Return ColDet_Make_Model(tris,dynamic)
End Function




;------------------------------------------------------------------------
;USE THIS ONLY IF YOU CREATE A COLDET MODEL MANUALLY
;Add manually a triangle to the coldet model.
;We pass here also the blitz model to get the global vertex positions.
;We rotate the blitz model to 0,0,0 and back to it's original rotation
;because it could be already rotated.
;------------------------------------------------------------------------

Function ColDet_Add_Tri(b_ent,c_ent,vx1#,vy1#,vz1#,vx2#,vy2#,vz2#,vx3#,vy3#,vz3#)
	
	Local tvx1#,tvy1#,tvz1#
	Local tvx2#,tvy2#,tvz2#
	Local tvx3#,tvy3#,tvz3#
	Local px#,py#,pz#
	Local rx#,ry#,rz#
	
	
	
	rx=EntityPitch(b_ent,1)
	ry=EntityYaw(b_ent,1)
	rz=EntityRoll(b_ent,1)
	px=EntityX(b_ent,1)
	py=EntityY(b_ent,1)
	pz=EntityZ(b_ent,1)
	
;We want a 0 rotated and 0 positioned object object
;We will return it to it's original state after the coldet tri is created
	RotateEntity b_ent,0,0,0,1
	PositionEntity b_ent,0,0,0,1
	
	TFormPoint vx1,vy1,vz1,b_ent,0
	tvx1=TFormedX()
	tvy1=TFormedY()
	tvz1=TFormedZ()
	TFormPoint vx2,vy2,vz2,b_ent,0
	tvx2=TFormedX()
	tvy2=TFormedY()
	tvz2=TFormedZ()
	TFormPoint vx3,vy3,vz3,b_ent,0
	tvx3=TFormedX()
	tvy3=TFormedY()
	tvz3=TFormedZ()
	
	ColDet_AddTri(c_ent,tvx1,tvy1,tvz1,tvx2,tvy2,tvz2,tvx3,tvy3,tvz3)
	
;set it back to it's original rotation and position
	RotateEntity b_ent,rx,ry,rz,1
	PositionEntity b_ent,px,py,pz,1
End Function 


;------------------------------------------------------------------------
;USE THIS ONLY IF YOU CREATE A COLDET MODEL MANUALLY
;Finalize the coldet model and set it's matrix
;------------------------------------------------------------------------

Function ColDet_Model_End(b_ent,c_ent)
	ColDet_Finalize(c_ent)
	ColDet_SetMatrix(b_ent,c_ent)
End Function






;------------------------------------------------------------------------
;This function sets the transformation matrix of the coldet model.
;It is neccesary to call it only when moving and rotating
;a dynamic object.
;For Static objects you only need to call it once.

;b_ent=the blitz entity
;c_ent=the coldet entity pointer !
;------------------------------------------------------------------------

Function ColDet_SetMatrix(b_ent,c_ent)
	
;we use a dummy pivot to get pitch,yaw,roll because coldet doesn't work with scale values
	RotateEntity col_dummy_pivot,EntityPitch(b_ent,1),EntityYaw(b_ent,1),EntityRoll(b_ent,1)
	
	PokeFloat col_matrix, 0,GetMatElement(col_dummy_pivot,0,0)
	PokeFloat col_matrix, 4,GetMatElement(col_dummy_pivot,0,1)
	PokeFloat col_matrix, 8,GetMatElement(col_dummy_pivot,0,2)
	
	PokeFloat col_matrix, 16,GetMatElement(col_dummy_pivot,1,0)
	PokeFloat col_matrix, 20,GetMatElement(col_dummy_pivot,1,1)
	PokeFloat col_matrix, 24,GetMatElement(col_dummy_pivot,1,2)
	
	PokeFloat col_matrix, 32,GetMatElement(col_dummy_pivot,2,0)
	PokeFloat col_matrix, 36,GetMatElement(col_dummy_pivot,2,1)
	PokeFloat col_matrix, 40,GetMatElement(col_dummy_pivot,2,2)
	
	PokeFloat col_matrix, 48,EntityX(b_ent,1)
	PokeFloat col_matrix, 52,EntityY(b_ent,1)
	PokeFloat col_matrix, 56,EntityZ(b_ent,1)
	
	
	ColDet_Set_Matrix(c_ent,col_matrix)
	
End Function











;------------------------------------------------------------------------
;Get collision point for 'this' model.
;g=0 for global coordinates
;g=1 for model's local coordinates
;------------------------------------------------------------------------

Function ColDet_Collision_Point(model,g)
	ColDet_GetCollision_Point(model,col_point,g)
End Function

;and return the x,y,z values by these functions
Function Collision_Point_X#()
	Return PeekFloat (col_point,0)
End Function

Function Collision_Point_Y#()
	Return PeekFloat (col_point,4)
End Function

Function Collision_Point_Z#()
	Return PeekFloat (col_point,8)
End Function






;-------------------------------------------------------------------------------
;This function is actually used to get the colliding triangle normal.
;if calc1=true make precalculations for the first model's colliding tri normals
;if calc2=true make precalculations for the second model's colliding tri normals
;-------------------------------------------------------------------------------

Function ColDet_Colliding_Verts(model,calc1,calc2)
	
	ColDet_GetColliding_Verts(model,col_verts1,col_verts2)
	
	
;v0x=0   , v0y=4   , v0z=8
;v1x=12  , v1y=16  , v1z=20
;v2x=24  , v2y=28  , v2z=32
	
	If calc1=True
		cnrx1(0)=PeekFloat(col_verts1,12)-PeekFloat(col_verts1,0)
		cnry1(0)=PeekFloat(col_verts1,16)-PeekFloat(col_verts1,4)
		cnrz1(0)=PeekFloat(col_verts1,20)-PeekFloat(col_verts1,8)
		
		cnrx1(1)=PeekFloat(col_verts1,24)-PeekFloat(col_verts1,12)
		cnry1(1)=PeekFloat(col_verts1,28)-PeekFloat(col_verts1,16)
		cnrz1(1)=PeekFloat(col_verts1,32)-PeekFloat(col_verts1,20)
	EndIf
	
	If calc2=True
		cnrx2(0)=PeekFloat(col_verts2,12)-PeekFloat(col_verts2,0)
		cnry2(0)=PeekFloat(col_verts2,16)-PeekFloat(col_verts2,4)
		cnrz2(0)=PeekFloat(col_verts2,20)-PeekFloat(col_verts2,8)
		
		cnrx2(1)=PeekFloat(col_verts2,24)-PeekFloat(col_verts2,12)
		cnry2(1)=PeekFloat(col_verts2,28)-PeekFloat(col_verts2,16)
		cnrz2(1)=PeekFloat(col_verts2,32)-PeekFloat(col_verts2,20)
	EndIf
	
End Function



Function Colliding_NX1#()
	Return (cnry1(0)*cnrz1(1))-(cnrz1(0)*cnry1(1))
End Function

Function Colliding_NY1#()
	Return (cnrz1(0)*cnrx1(1))-(cnrx1(0)*cnrz1(1))
End Function

Function Colliding_NZ1#()
	Return (cnrx1(0)*cnry1(1))-(cnry1(0)*cnrx1(1))
End Function




Function Colliding_NX2#()
	Return (cnry2(0)*cnrz2(1))-(cnrz2(0)*cnry2(1))
End Function

Function Colliding_NY2#()
	Return (cnrz2(0)*cnrx2(1))-(cnrx2(0)*cnrz2(1))
End Function

Function Colliding_NZ2#()
	Return (cnrx2(0)*cnry2(1))-(cnry2(0)*cnrx2(1))
End Function



;-----------------------------------------------------------------------------
;Get colliding triangle for 'this' model.
;If this=1 then the triangle of the 'other' colliding object will be returned.
;-----------------------------------------------------------------------------

Function ColDet_Colliding_Tri(model,this=0)
	ColDet_GetColliding_Tris(model,col_tri1,col_tri2)
	
	If this=0
		Return PeekInt(col_tri1,0)
	Else
		Return PeekInt(col_tri2,0)
	EndIf
	
End Function
</textarea><br><br>My additions are between "New functions" and "Coldet functions". The principle is just to store an object's old position, test if moving it causes an intersection, and if so, stick it back where it was before. This is fine for systems that are a) simple and b) have movement slow enough that the small gap between surfaces that this causes isn't visible. If point b is a problem you might work out some arrangement that progressively moves objects towards the target... (this is getting into the sort of thing that makes B3D collisions slower though - "stop" and "slide" collisions are inherently slower than no-response collisions). I advise against using the Move and Turn functions as they're really loop-heavy; you could work out something much more efficient that only does a lot of the work once.<br><br><br>Also, B3D-style capitalisation for the DLL functions:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">.lib "coldet_wrap.dll"

;wrapper functions
ColDet_Make_Model%(trinum%,static%):"_coldet_make_model@8"
ColDet_Add_Model%(model%,bank*,tris%):"_coldet_addmod@12"
ColDet_Finalize%(model%):"_coldet_finalize@4"
ColDet_Set_Matrix%(model%,bank*):"_coldet_set_matrix@8"
ColDet_AddTri%(model%,vx1#,vy1#,vz1#,vx2#,vy2#,vz2#,vx3#,vy3#,vz3#):"_coldet_addTriangle@40"
ColDet_Free_Model%(model%):"_coldet_free@4"

ColDet_Collision%(model1%,model2%):"_colldet_collision@8"
ColDet_GetCollision_Point%(model%,bank*,global%):"_get_collision_point@12"
ColDet_GetColliding_Verts%(model%,bank1*,bank2*):"_getcolliding_tris1@12"
ColDet_GetColliding_Tris%(model%,bank1*,bank2*):"_getcolliding_tris2@12"
ColDet_Ray_Collision1%(model%,origin*,direction*,closest%,segmin#,segmax#):"_coldet_rayCollision1@24"
ColDet_Ray_Collision2%(model%,origin*,direction*):"_coldet_rayCollision2@12"
ColDet_Sphere_Collision%(model%,bank*,radius#):"_coldet_sphereCollision@12"



;Utility functions
SphereRayCollision%(center*,radius#,origin*,direction*,point*):"_coldet_SphereRayCollision@20"
SphereSphereCollision%(center1*,radius1#,center2*,radius2#,point*):"_coldet_SphereSphereCollision@20"
</textarea><br><br>I don't know about you but I find this much easier on the eye.<br><br><br>Anyway after getting used to the basic subset, take a look at the bundled examples again and they should make more sense, and then you can hopefully use things like ray picking with relative ease. <br><br></td></tr></table><br>
<a name="1192530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know why, but I keep on getting a Memory Access Violation error whenever I follow the steps of the ColDet examples. <br><br></td></tr></table><br>
<a name="1192535"></a>

<a name="1192536"></a>

<a name="1192537"></a>

<a name="1192538"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello. <br>I think we can add a "looks good enough" sliding-response to that library if we can retrieve the normal of the contact between 'object' and 'obstacle' (by looking at those functions, it seems we can).<br><br>You should also add the pure Blitz3D functions to that DECLS. Functions like "Collision_Point_X#()" etc. so that they're also highlighted when typed.<br><br>On the sliding response.<br>You have your 'object' moving with 'old vector', and you want to find out the sliding-response's 'new vector' to move this object with.<br>These vectors are formed by a magnitude (a "strength", or "speed") and a direction (an orientation).<br><br>- To find the magnitude of the 'new vector', you modulate the magnitude of 'old vector' with the normalized Dot product of 'old vector' and the obstacle's collided triangle's normal.<br>Since the normalized dot product is a value with a range [-1, +1], you'd need to map it to the range [0, +1] for it to be easier to modulate with (so it becomes a value you just need to multiply with the magnitude of 'old vector' to find the magnitude for the 'new vector').<br><br>- To find the direction of the 'new vector', you do a cross-product two times in the following way: First store the resulting vector of the cross-product between 'old vector' and the obstacle's collided triangle's normal. Take this resulting vector and cross-product it again with the obstacle's collided triangle's normal.<br>If you normalize the result from this second cross-product, you can multiply each component of it with the new magnitude you obtained in the previous step.<br><br>The resulting vector is the sliding-response you need to translate your object with. <br><br></td></tr></table><br>
<a name="1192584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wait, is it true that ColDet functions don't work with types? <br><br></td></tr></table><br>
<a name="1192592"></a>

<a name="1192593"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Wait, is it true that ColDet functions don't work with types? <br></div><br><br>It is untrue in the sense that this question doesn't actually mean very much.<br><br>The DLL has no knowledge of B3D's types because it is written in C, which is (obviously) a different language with its own types (although B3D's types are designed to perfectly interact with C structs where possible). The code in the .bb file would be a tad more efficient if it used type objects instead of banks internally, but it's not a particularly big deal and not <i>really</i> worth fixing (it works right now...).<br><br>The wrapper functions do not use types, instead exposing int handles for ColDet entities the same way B3D exposes int handles for B3D entities. A user-defined type would be an excellent choice to link the two into render-collider entity pairs.<br><br>ColDet does not use them because it chooses not to use them. The extra commands I showed above actually <i>do</i> use types internally, which shows that this is simply a choice on the part of EliasT and does not impose anything on the end user. <br><br></td></tr></table><br>
<a name="1193004"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> TaGames... about the MAVs... you did turn debugging mode on? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
