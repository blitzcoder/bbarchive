<!DOCTYPE html><html lang="en" ><head ><title >Objective-B3D</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Objective-B3D</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Objective-B3D</a><br><br>
<a name="993815"></a>

<a name="1051580"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>Update 4/6/2010:</b> Completely new (from scratch) version of Objective-B3D! Fixes several of the old version's problems. See post #17 (this first post will remain about the original version).<br><br><br>Warning! This will be a long post (and not very beginner-friendly)! I hope it's worth your time. Skip to the end for source code.<br><br>A couple of days ago, I was looking at the Wikipedia article on the C programming language, and discovered an interesting thing.<br><br><div class="quote"> <br> C++ and Objective-C were two different extensions of C that provided object-oriented capabilities. Both languages were originally implemented as source-to-source compilers -- source code was translated into C, and then compiled with a C compiler.<br> - <a href="http://en.wikipedia.org/wiki/C_(programming_language)#Related_languages" target="_blank">Wikipedia</a><br> <br></div><br><br>Huh. Apparently it's possible to implement OOP in an procedural language. Admittedly not news - assembly is procedural, after all - but not something one's used to thinking about. Perhaps it would be possible to write a preprocessor for an object-oriented dialect of Blitz3D that would output vanilla B3D source code?<br><br>Apparently so. And I have imaginatively named it Objective-B3D.<br><br>Before we continue I would like to point out that <b>yes I do own BlitzMax</b> and that this is, as everything I do seems to be, a largely <b>academic exercise</b> that just happens to also have some considerable practical potential. This was done for fun, intellectual exercise and to gain a better understanding of programming, <i>not</i> because I've never heard of miniB3D; please try to see it in that light.<br><br>To install Objective-B3D, <a href="https://sites.google.com/site/nangdongseng/downloads" target="_blank">download the binaries for the code processor and wrapper</a>, or build them yourself from the source below. First, extract or build the code processor (that's the .bb code) to Blitz3D\bin\ObjB3D.exe . This is the part that translates OOP code into pure procedural code. Next, rename the existing blitzcc.exe to blitzcc_old.exe (it's very important that these are all named correctly, by the way). Finally, extract or build the wrapper exe (that's the .bmx code, or blitzcc_obj.exe in the archive) to Blitz3D\bin\blitzcc.exe (must be compiled as a console app). And you're away! I do recommend making a second Blitz3D installation, both for separate work on projects not requiring any of this stuff, and in case things go wrong.<br><br>The program itself consists of two entirely separate preprocessor stages (there's no requirement to use them together, actually - you might find one or the other more useful by itself): a vaguely C-like directive processor, and the Objective-B3D translator. I was originally going to include a third, to cover some functional programming elements, but decided against (the <a href="/posts.php?topic=87249" target="_blank">extreme popularity</a> of my last attempt to integrate functional ideas leaves me thinking it wouldn't be worth the effort). Input is in the form of the file to process, optionally followed by " -d" to signify that debug mode is on. You can use it separately like this if you don't want to integrate it into the toolchain.<br><br><b>EDIT:</b> Removed the C-like processor section, as it's not the real focus of this article. You can find it <a href="/codearcs.php?code=2656" target="_blank">here</a> if you need it.<br><br>The Blitz "Include" command is also processed in the first pass, in order to get everything at once.<br><br>But there is another, bigger part to this abomination...<br><br>Once the code has been processed once, it can be fed into the Objective-B3D translator. Objective-B3D can be considered an informal superset dialect of Blitz3D - there are a few new features, but all legal Blitz3D code (with a very few exceptions that won't affect most users, detailed below) should come out of this unchanged (except that the formatting will be ruined, but what can you do?). As the name and the previous sentence imply, my inspiration was taken not from C++, Java or BlitzMax (I do not in any way wish to compete with BlitzMax - please do not ban me!) but from Objective-C and SmallTalk, which operate a "purer" (more logical and internally consistent) kind of OOP, that will probably be completely unrecognisable to most people familiar with the dot-syntax used by C++/Java/BlitzMax.<br><br>Types (classes) are the core of object-orientation. Normal type declarations are perfectly valid in Objective-B3D, but you can also add a few things to the declaration:<br><pre class=code>
Type MyType
	Field a
	Field b,charlie
	Private Field d$,e#
	Field g$[10]
	Public Field zz.MyType[10]
	Field d[8]
End Type

Type MyFinalType: MyType
	Private Field j$[10],x.MyType
End Type
</pre><br>The default state of all fields is, as usual in B3D, public. The Public modifier doesn't actually do anything, but you can safely put it there anyway if it makes things clearer. The Private modifier will make fields inaccessible from outside the class's own methods (actually it will just append two underscores in the final version, so if you really need to get at them anyway, you can use that, but consider a redesign). To extend a class, you can use a colon followed by the name of its superclass - this class will now have all of the fields above added to it, at the same access level they were declared at previously.<br><br>Some readers may be wondering where the methods are. As in Objective-C, the class interface (fields) and implementation (methods) are declared separately. Not strictly necessary, but it keeps things tidy.<br><pre class=code>
;Arbitrarily ugly code for the purposes of illustration
Implement MyType
	Method Delete
		Local boogle.MyType
		Delete self
	End Method
	
	Method setA:value%
		a=value
	End Method
	
	Method getB
		Return b
	End Method
End Implement

Implement MyFinalType
	Method setA:value
		a=value+1
	End Method
	
	Method setX:newX.MyType
		x=newX
	End Method
	
	Method getX.MyType
		Return x.MyType
	End Method
End Implement
</pre><br>Methods are declared <i>without</i> parentheses and with a colon separating the name from the arguments, and each argument from the next (no optional arguments/default parameters). There is a reason for this - methods are not directly conceptually connected to functions in this style of OOP; rather, they are messages that request the object to perform an action. Methods are also inherited from the superclass, unless they are overridden by the subclass's own implementation (which must have the same number and type of arguments). It is important to note that there is NO REQUIREMENT for virtual/abstract methods, so don't implement anything you don't intend to use where it is. More on this below. You may make reference to "self" in methods if it makes you more comfortable, but don't attempt to redeclare it ("self" is a pointer to the object doing something, for those unfamiliar with OOP). You can reassign or delete it if you need to (be aware that it is an actual object variable, not an integer, so it is not polymorphic within the method body and is the only way to directly reference non-final objects).<br><br>"Getter" and "setter" methods are automatically generated for every public field (in the case of arrays, they have an "index" parameter as well). A "New" class method is automatically generated, as is a "Delete" method. You can safely override Delete if you want a custom destructor. Don't try to override New, though...<br><br>Class methods are declared the same way as instance methods, but with the extra keyword "Class" before "Method". They differ from instance methods in that their "self" variable actually points to the class object itself, not to an instance of that class. Using a class method is the only safe way to instatiate non-final classes - this is because, to facilitate polymorphism, ALL references to non-final classes are replaced with integer pointers. The only place nonfinal objects can be referenced directly is in their own methods (so implementing a constructor would require a call to class method New to be the recipient of an initialisation message).<br><br>Polymorphism should be a familiar topic in OOP. It behaves relatively as-expected in Objective-B3D, except that fields of non-final classes (ie. any polymorphic variable) may not be accessed directly (because they use integer pointers) - you have to use getter and setter methods. Rather more interesting is inheritance: because the idea of methods as function calls is replaced with messages to objects, there is no need for virtual methods to be declared - if the object in question implements the requested method, it will be found automatically; otherwise, nothing happens. This makes things a little more flexible than in other languages - not only do methods not need to exist, but the "method" part of a message might itself be the result of another function, as might the object (and since classes are also objects, even that can be changed at runtime).<br><br>Now for the part that people won't like: message syntax. To smooth things over, here's a translated version of one of John Judnich's examples in "Object-Oriented Programming in BlitzMax":<br><pre class=code>
Type TRobot
	Field name$
	Field x#,y#
	Field health
End Type

Implement TRobot
	Method Move:newx#:newy#
		x=x+newx
		y=y+newy
	End Method
	
	Method Draw
		Color 255, 255, 255
		Text x - (Len(Name)/2), y - 20,Name
		Color 0, 0, 255
		Rect x - 5, y - 5, 10, 10
		Color 255, 0, 0
		Rect x - 4, y - 4, 8, 8
	End Method
End Implement

Graphics 640, 480,32,6
Local robot.TRobot = New TRobot
[:robot:SetName:"XB-75b"]
While Not KeyHit(1)
	Cls
	[:robot:Move:1:1]
	[:robot:Draw]
	Flip
Wend
End
</pre><br><br>Those who have used Objective-C will recognise the square-brackets, although there are more colons now, as I found the exact style used by Objective-C to be incompatible with the existing BASIC syntax. Square brackets surround a message, and every component of the message is preceded by a colon. The first field is the message recipient - either an object or a class (classes are also objects, but not many people will want to take advantage of this). You can also send a message to Null, but nothing will come of it. The second is the method selector; these two fields are obviously mandatory. Following this is the argument list (remember, no optional arguments - if there are too many or too few I have not bothered to define what will happen). Any field in this list may be a direct name, or it can be the result of a function or another message (yes, even the target <i>and</i> selector of a class method). However, if it is not possible for the type of arguments to be known at compile-time, you'll need to specify them or the runtime will assume they're integers, which may not be what you want. To specify type, simply add the type symbol (#, $, .mytype) at the end of the field, right before the following colon or closing bracket. Arguments are known at compile-time if both the target and selector are knowable, or if the target is a subtype of a polymorphic variable BUT the method was declared in the supertype (this is the only reason you'd need to declare virtual methods). In general, you can treat messages as expressions in the same way as function calls:<br><pre class=code>
[: a : setA : [: b : getB ] ]
[: b : setA : [: a : getB ] ]
Print [: b : getB ]
Print [: a : getB ]
e = [:a:getB]
[: b : setA : d ]

[:PickClassAtRandom():DoSomethingToIt()]
</pre><br><br>Unlike in Objective-C, not all messages are late-bound: if the object and selector are both known at compile-time, the result will be a normal function call, and if one is known but not the other the resulting output code will still statically bind as much as possible, so there's no speed penalty for functionality you don't use.<br><br>I'll leave that there for now - hopefully people will ask questions if they are unclear on any element of this?<br><br>As mentioned above, there are a few areas where Objective-B3D code does not allow every element of Blitz3D code to compile as it otherwise would. As follows:<br><br> - Obviously Objective-B3D creates many helper functions, constants and classes. In general, all of their names end with two underscores, so I think it unlikely many people will have a problem here. If you also use two underscores at the end of any names, look through the source code for any conflicts.<br><br> - "Self" is used by methods to refer to their target (an object in the case of instance methods, or the class in the case of class methods). It's a hidden parameter that is the first in the argument list of the functions that methods are translated into. You cannot therefore declare a global variable named "Self" and expect this to work. It's bad practice to give a global a name like that anyway, so just don't do it.<br><br> - Blitz3D allows you to engage in the cardinal sin of declaring variables with the same name as a type. Objective-B3D will beat you to it - since each class is an object that can receive messages, there is a global object declared with the name of each type already. You really shouldn't be doing this, though ...because I said so.<br><br>EDIT: (this is, strictly speaking, a bug, not a feature) - The current incarnation of Objective-B3D will fail to correctly handle a global variable being declared and initialised on the same line (eg. "Global myGlobal = Something()" ). In the fullness of time this will be changed, but at the moment globals must have their declarations on completely separate lines - ie. "Global myGlobal &lt;newline&gt; myGlobal = Something()". Sorry about that.<br><br>Technically speaking, there are two more stages of preprocessing. The third stage is simply that an extra line is added at the top to Include "standard definitions" (class Type, box Types, box functions to allow strings and floats to be passed by Int pointer) - things that don't change. Nothing remarkable there. Finally, of course, there is compilation with blitzcc.exe.<br><br><br>EDIT: OK the source is waaaay too long for one post, so I'll post each file in its own box. Gimme a moment... sorry about that.<br><br><br>I make no guarantee that this program is bug-free - I lack the imagination to develop proper tests - and in fact there are almost certainly bugs there, so PLEASE report them if you find them and I will try to fix things.<br><br>Please consider this software public-domain. Thank you for your attention, and I hope at least someone finds it helpful or interesting.<br><br>EDIT 2: Just discovered that Noel beat me to this by five years or so... <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1103" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1103</a> . Use that instead, he's a better coder than me.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="993816"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> UPDATED - The main file (call it whatever you like):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">


;=======================================================;
;                                                       ;
;        Objective-B3D - A Blitz3D Pre-processor        ;
;        ---------------------------------------        ;
;                                                       ;
;=======================================================;


Include "PPh.bb"
Include "OO.bb"
Include "Lexer.bb"
Include "StdDef.bb"


Const CODE_COMMENT$ = ";"
Const CODE_MAX_ARGS = 64	;If this isn't enough, rewrite your functions


AppTitle "Objective-B3D"
;Graphics 800,300,0,2


Global cmdLine$ = Trim(CommandLine())
Global inputFilename$
Global inputfilepath$
Global processedInputFilename$ = "objb3d_tmp.bb";GetEnv("blitzpath")+"\tmp\objb3d_tmp.bb"		;Where to dump out the processed file


SetMode()		;Check if debug mode is on, and get the input file name and path

Write "Applying simple pre-processor... "
ProcessDirectives(inputFilename,processedInputFilename)					;Apply basic C-like preprocessor
Print "done!"

Write "Applying objective pre-processor... "
ObjectiveProcess(processedInputFilename,processedInputFilename)			;Apply objective preprocessor
Print "done!"

Write "Including Objective-B3D standard definitions... "
DEF_IncludeStdDefs(processedInputFilename,processedInputFilename)		;Include base classes for FP and OOP
Print "done!"

Print "":Print "Press any key to exit..."
;WaitKey
End



Function SetMode()		;Check if debug mode is on, and get the input file name
	Local i,debug.PP_Macro
	
	debug.PP_Macro=New PP_Macro
	debug\tok=PP_DEBUGMODE
	
	If Right(cmdLine,2)="-d"
		debug\def="True"
		cmdLine=Left(cmdLine,Len(cmdLine)-3)
	Else
		debug\def="False"
	EndIf
	
	inputFilename=cmdLine
	For i=Len(inputFilename) To 1 Step -1
		If Mid(inputFilename,i,1)="\" Or Mid(inputFilename,i,1)="/"
			inputfilepath=Left(inputFilename,i)
			Return
		EndIf
	Next
End Function

Function CodeError(err$,body=True)	;Expand this
	Print ""
	If body
		Print "ERROR in line "+PeekInt(TokenBank,lexCurrentToken*16+12)+": "+err
	Else
		Print "ERROR: "+err
	EndIf
	Print "Compilation halted, press any key to exit."
	
	WaitKey
	End
End Function

Function ProcessDirectives(inFile$,outputFile$)		;Applies basic C-preprocessor-like commands
	Local m.PP_Macro,n.PP_Macro,pos,ptr,i
	Local com,sep,skip,srcline$;,SourceBank
	Local inquote,incomment,cfile,filelist=CreateBank(4)
	
	cfile=ReadFile(inFile)
	PokeInt(filelist,0,cfile)
	SourceBank=CreateBank()
	
	Repeat
		srcline=ReadLine(cfile)
		
		If Left(srcline,1)=PP_COMMAND
			srcline=Replace(srcline,Chr(9)," ")
			
			com=Instr(srcline,CODE_COMMENT)
			If com&gt;0 Then srcline=Trim(Left(srcline,com-1))
			
			Select True
				Case Lower(Left(srcline,7+PP_CMDLEN))=PP_COMMAND+"define "		;Add a macro
					If skip=0
						m=New PP_Macro
						srcline=Trim(Mid(srcline,7+PP_CMDLEN))
						sep=Instr(srcline," ")
						m\tok=Trim(Left(srcline,sep))
						m\def=Trim(Right(srcline,Len(srcline)-sep))
						
						If m\tok=PP_DEBUGMODE Then CodeError("token "+m\tok+" is reserved for debugging",False)
						For n=Each PP_Macro
							If n&lt;&gt;m And m\tok=n\tok
								CodeError("Token "+m\tok+" is already defined")
							EndIf
						Next
					EndIf
					
				Case Lower(Left(srcline,6+PP_CMDLEN))=PP_COMMAND+"undef "		;Remove a macro
					If skip=0
						srcline=Trim(Mid(srcline,6+PP_CMDLEN))
						For m=Each PP_Macro
							If m\tok=srcline Then Delete m
						Next
					EndIf
					
				Case Lower(Left(srcline,3+PP_CMDLEN))=PP_COMMAND+"if "			;Conditional compilation by value
					srcline=Trim(Mid(srcline,3+PP_CMDLEN))
					If skip=0 Then skip=skip+(Not(PP_EvalDirective(srcline))):Else skip=skip+1
					
				Case Lower(Left(srcline,6+PP_CMDLEN))=PP_COMMAND+"ifdef "		;Conditional compilation by definition
					srcline=Trim(Mid(srcline,6+PP_CMDLEN))
					If skip=0
						For m=Each PP_Macro
							If m\tok=srcline Then skip=skip-1:Exit
						Next
					EndIf
					skip=skip+1
					
				Case Lower(Left(srcline,7+PP_CMDLEN))=PP_COMMAND+"ifndef "		;Conditional lack of compilation by definition
					srcline=Trim(Mid(srcline,7+PP_CMDLEN))
					If skip=0
						For m=Each PP_Macro
							If m\tok=srcline Then skip=skip+1:Exit
						Next
					Else
						skip=skip+1
					EndIf
					
				Case Lower(Left(srcline,5+PP_CMDLEN))=PP_COMMAND+"endif"		;End of conditional compilation block
					If skip&gt;0 Then skip=skip-1
					
				Case Lower(Left(srcline,8+PP_CMDLEN))=PP_COMMAND+"include "		;Include files
					If skip=0 And incomment=0
						srcline=Trim(Mid(srcline,8+PP_CMDLEN))
						If Left(srcline,1)=Chr(34) And Right(srcline,1)=Chr(34) Then srcline=Mid(srcline,2,Len(srcline)-2)	;Cut off quote marks
						cfile=ReadFile(PP_AbsoluteFileName(srcline))
						ResizeBank(filelist,BankSize(filelist)+4)
						PokeInt filelist,BankSize(filelist)-4,cfile
					EndIf
					
				Case Lower(Left(srcline,7+PP_CMDLEN))=PP_COMMAND+"option "		;Set other compilation options?
					If skip=0
						srcline=Trim(Mid(srcline,7+PP_CMDLEN))
						;
					EndIf
					
				Case Lower(Left(srcline,6+PP_CMDLEN))=PP_COMMAND+"error "
					If skip=0
						srcline=Trim(Mid(srcline,6+PP_CMDLEN))
						CodeError(srcline)
					EndIf
					
				Case Lower(Left(srcline,3+PP_CMDLEN))=PP_COMMAND+"rem"
					If skip=0 Then incomment=incomment+1
					
				Case Lower(Left(srcline,7+PP_CMDLEN))=PP_COMMAND+"end rem"
					If skip=0 Then incomment=incomment-1
					If incomment&lt;0 Then CodeError("mismatched "+Chr(34)+"#end rem"+Chr(34)+" directive",False)
					
				Default
					CodeError("unrecognised preprocessor command",False)
			End Select
		ElseIf Lower(Left(srcline,7))="include"
			If incomment
				srcline="; "+srcline
			Else
				If Asc(Lower(Mid(srcline,8)))&lt;41
					com=Instr(srcline,CODE_COMMENT)
					If com&gt;0 Then srcline=Trim(Left(srcline,com-1))
					
					srcline=Trim(Right(srcline,Len(srcline)-8))
					If Left(srcline,1)=Chr(34) And Right(srcline,1)=Chr(34) Then srcline=Mid(srcline,2,Len(srcline)-2)	;Cut off quote marks
					cfile=ReadFile(PP_AbsoluteFileName(srcline))
					ResizeBank(filelist,BankSize(filelist)+4)
					PokeInt filelist,BankSize(filelist)-4,cfile
				EndIf
			EndIf
		Else
			If skip=0
				If incomment
					srcline="; "+srcline	;Replace block comments with many one-line comments
				Else
					If First PP_Macro&lt;&gt;Null		;Replace #defined tokens
						inquote=0
						For ptr=1 To Len(srcline)
							If Mid(srcline,ptr,1)=Chr(34) Then inquote=Not inquote
							
							If Mid(srcline,ptr,Len(CODE_COMMENT))=CODE_COMMENT		;Don't replace tokens in comments
								srcline=Left(srcline,ptr-1)+";"+Right(srcline,Len(srcline)-(ptr+(Len(CODE_COMMENT)-1)))
								Exit
							EndIf
							
							If inquote=False
								For m=Each PP_Macro
									If ptr&gt;1 Then i=Asc(Mid(srcline,ptr-1,1)):Else i=0
									If Not((i&gt;47 And i&lt;58) Or (i&gt;64 And i&lt;91) Or i=95 Or (i&gt;96 And i&lt;123))
										i=Asc(Mid(srcline,ptr+Len(m\tok),1))
										If Not((i&gt;47 And i&lt;58) Or (i&gt;64 And i&lt;91) Or i=95 Or (i&gt;96 And i&lt;123))		;Don't replace partial matches
											If Lower(Mid(srcline,ptr,Len(m\tok)))=Lower(m\tok)		;Since B3D is not case-sensitive
												srcline=Left(srcline,ptr-1)+m\def+Right(srcline,Len(srcline)-(ptr-1)-Len(m\tok))
											EndIf
										EndIf
									EndIf
								Next
							EndIf
						Next
					EndIf
				EndIf
				
				ResizeBank SourceBank,BankSize(SourceBank)+Len(srcline)+2
				For ptr=0 To Len(srcline)-1
					PokeByte SourceBank,pos+ptr,Asc(Mid(srcline,ptr+1,1))
				Next
				PokeShort SourceBank,pos+ptr,$A0D		;CR+LF - end of line
				pos=pos+ptr+2
			EndIf
		EndIf
		
		If Eof(cfile)
			CloseFile cfile
			ResizeBank filelist,BankSize(filelist)-4
			If BankSize(filelist)=0 Then Exit:Else cfile=PeekInt(filelist,BankSize(filelist)-4)
		EndIf
	Forever
	
	cfile=WriteFile(outputFile)
	WriteBytes(SourceBank,cfile,0,BankSize(SourceBank))
	CloseFile cfile
	
	FreeBank filelist		;Tidy up
	FreeBank SourceBank
	Delete Each PP_Macro
End Function

Function ObjectiveProcess(inputFile$,outputFile$)		;Applies object-oriented preprocessor
	Local fileIn,fileOut,tempOut
	Local class.ObjClass,super.ObjClass
	Local c,accessLevel,i,outLine$
	
	SourceBank=CreateBank(FileSize(inputFile)+4)
	fileIn=ReadFile(inputFile)
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)-4		;Load the file
	CloseFile fileIn
	PokeInt SourceBank,BankSize(SourceBank)-4,$FFFFFFFF		;Add an obvious EOF tag
	fileOut=WriteFile(outputFile)				;The pre-processed output file
	
	;Constants
	OBJ_ReadConstants(fileOut,outputFile)
	
	;[Block] - Types
	Local cField,var.ObjVariable
	
	ResizeBank SourceBank,FileSize(outputFile+"_tmp")
	fileIn=ReadFile(outputFile+"_tmp")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	tempOut=WriteFile(outputFile+"_tmp")
	
	While lexTokenType&lt;&gt;tt_EOF			;Build a list of all Types
		If LEX_CheckToken("type")
			
			super=Last ObjClass
			class=New ObjClass
			class\name=lexToken:LEX_NextToken
			If super=Null Then class\ID=4:Else class\ID=super\ID+1		;Allow 1-3 for the primitive types
			class\base=True:class\final=True
			
			If Not(lexNewLine)
				LEX_ExpectToken(":")	;Inheritance
				If lexNewLine Then CodeError("expecting base class ID")
				class\superName=lexToken:LEX_NextToken
				class\base=False
			EndIf
			
			While Not(LEX_CheckToken("end"))	;Get a list of fields
				If LEX_CheckToken("private")
					accessLevel=2
				Else
					LEX_CheckToken("public")	;Entirely optional
					accessLevel=0
				EndIf
				LEX_CheckToken("access")	;Add functionality for this later - autogenerates getter&amp;setter methods for this field
				
				LEX_ExpectToken("field")
				Repeat
					class\fieldName[class\noFields]=lexToken:LEX_NextToken
					If LEX_CheckToken("%") Or lexToken="[" Then class\fieldType[class\noFields]=1:class\fieldTypeName[class\noFields]="%"
					If LEX_CheckToken("#") Then class\fieldType[class\noFields]=2:class\fieldTypeName[class\noFields]="#"
					If LEX_CheckToken("$") Then class\fieldType[class\noFields]=3:class\fieldTypeName[class\noFields]="$"
					If LEX_CheckToken(".") Then class\fieldTypeName[class\noFields]="."+lexToken:LEX_NextToken
					
					If LEX_CheckToken("[")		;It's an array
						class\fieldTypeName[class\noFields]=class\fieldTypeName[class\noFields]+"["+lexToken+"]"
						LEX_NextToken
						LEX_ExpectToken("]")
					EndIf
					
					class\fieldAccess[class\noFields]=accessLevel
					class\noFields=class\noFields+1
					If Not(lexNewLine) Then LEX_ExpectToken(",")
				Until lexNewLine
			Wend
			LEX_ExpectToken("type")
			
		Else
			LEX_WriteToken(tempOut)		;Dump lines that don't concern Type definitions, for the time being
		EndIf
	Wend
	LEX_WriteToken(tempOut)
	
	CloseFile tempOut
	FreeBank TokenBank
	
	For class=Each ObjClass
		For i=0 To class\noFields-1
			If class\fieldType[i]=0
				If class\fieldTypeName[i]=""
					class\fieldType[i]=1
					class\fieldTypeName[i]="%"
				Else
					If Instr(class\fieldTypeName[i],"[")=0 Then c=Len(class\fieldTypeName[i])-1:Else c=Instr(class\fieldTypeName[i],"[")-2
					For super=Each ObjClass		;Set type IDs for the remaining fields
						If super\name=Mid(class\fieldTypeName[i],2,c) Then class\fieldType[i]=super\ID:Exit
					Next
				EndIf
			EndIf
		Next
	Next
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,";Type definitions"
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,""
	
	For class=Each ObjClass
		If class\base=False
			For super=Each ObjClass
				If super\name=class\superName
					class\super=super
					super\final=False
					Exit
				EndIf
			Next
			
			While super&lt;&gt;Null	;Copy the fields from superclass
				If super=class Then CodeError("type "+class\name+" attempts to extend itself",False)
				cField=0
				For i=class\noFields To class\noFields+super\noFields-1
					For c=0 To class\noFields-1
						If super\fieldName[i-class\noFields]=class\fieldName[c] Then Exit
					Next
					If c=class\noFields	;Don't copy fields that have been copied once already
						class\fieldName[i]=super\fieldName[i-class\noFields]
						class\fieldType[i]=super\fieldType[i-class\noFields]
						class\fieldTypeName[i]=super\fieldTypeName[i-class\noFields]
						class\fieldAccess[i]=super\fieldAccess[i-class\noFields]
						cField=cField+1
					EndIf
				Next
				class\noFields=class\noFields+cField;super\noFields
				super=super\super
			Wend
		EndIf
		
		var=New ObjVariable
		var\name=class\name
		var\scope=-1
		var\typeRep=class\ID
		If class\final Then var\typeID=var\typeRep:Else var\typeID=1
	Next
	
	For class=Each ObjClass
		For i=0 To class\noFields-1
			If class\fieldType[i]&gt;3
				super=OBJ_GetTypeDef(class\fieldType[i])
				If super\final=False
					class\fieldType[i]=1
					class\fieldTypeName[i]=Replace(class\fieldTypeName[i],"."+super\name,"%")
				EndIf
			EndIf
		Next
		
		If class\base
			WriteLine fileOut,"Type "+class\name
		Else
			WriteLine fileOut,"Type "+class\name+Chr(9)+";Extends "+class\super\name
		EndIf
		
		If class\final=False
			For i=0 To class\noFields-1
				If class\fieldAccess[i]=0 Then class\fieldAccess[i]=1
			Next
		EndIf
		
		For i=0 To class\noFields-1
			outLine=Chr(9)+"Field "+class\fieldName[i]
			If class\fieldAccess[i] Then outLine=outLine+"__"+class\fieldTypeName[i]+Chr(9)+"; Private":Else outLine=outLine+class\fieldTypeName[i]
			WriteLine fileOut,outLine
		Next
		WriteLine fileOut,"End Type"
		WriteLine fileOut,""
	Next
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,"":WriteLine fileOut,""
	;[End block]
	DEF_LoadStdDefs()
	
	;Globals - these need to be processed twice due to possibly including commands
	Local tempOut2=WriteFile(Left(outputFile,Len(outputFile)-3)+"_globals.bb")
	OBJ_ReadGlobals(tempOut2,outputFile$)
	CloseFile tempOut2
	
	;Methods - these need to be processed twice in case they contain references to each other
	tempOut2=WriteFile(Left(outputFile,Len(outputFile)-3)+"_methods.bb")
	OBJ_ReadMethods(tempOut2,outputFile$)
	CloseFile tempOut2
	
	;Methods - second pass
	OBJ_WriteMethods(fileOut,Left(outputFile,Len(outputFile)-3)+"_methods.bb")
	DeleteFile Left(outputFile,Len(outputFile)-3)+"_methods.bb"
	
	;[Block] - Functions
	Local func.ObjFunction,prevToken$
	
	ResizeBank SourceBank,FileSize(outputFile+"_tmp")
	fileIn=ReadFile(outputFile+"_tmp")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn
	tempOut=WriteFile(outputFile+"_tmp")
	tempOut2=WriteFile(Left(outputFile,Len(outputFile)-3)+"_functions.bb")
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,";Function Definitions"
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,""
	
	While lexTokenType&lt;&gt;tt_EOF			;Build a list of user functions
		If LEX_CheckToken("function")
			outLine="Function "
			
			func=Last ObjFunction
			If func=Null Then i=0:Else i=func\ID
			func=New ObjFunction
			func\name=lexToken:outLine=outLine+lexToken:LEX_NextToken
			func\ID=i
			
			While Not LEX_CheckToken(")")
				If lexToken="," Then func\noArgs=func\noArgs+1
				If lexToken="."
					LEX_FetchToken(lexCurrentToken-1)		;Add object arguments to list of local variables
					For var=Each ObjVariable
						If var\name=lexToken Then Exit
					Next
					If var=Null
						var=New ObjVariable
						var\name=lexToken
						var\scope=1
						LEX_NextToken
						For class=Each ObjClass
							If class\name=lexToken Then Exit
						Next
						If class=Null Then CodeError("unrecognised type "+Chr(34)+lexToken+Chr(34))
						var\typeRep=class\ID
						If class\final
							var\typeID=class\ID
							lexToken=". "+lexToken
						Else
							var\typeID=1
							lexToken="%"
							func\argType[func\noArgs]=-1
						EndIf
					Else
						lexToken=OBJ_GetTypeSym(var\typeID)
					EndIf
				EndIf
				outLine=outLine+lexToken+" "
				LEX_NextToken
			Wend
			outLine=outLine+")"+Chr(13)+Chr(10)
			
			outLine=outLine+OBJ_FunctionBody(Null)
			WriteLine tempOut2,outLine+"End Function"+Chr(13)+Chr(10)
			
			For var=Each ObjVariable
				If var\scope=1 Then Delete var		;Delete local var definitions
			Next
		Else
			LEX_WriteToken(tempOut)		;Dump lines that don't contain function definitions
		EndIf
	Wend
	LEX_WriteToken(tempOut)
	WriteLine tempOut2,Chr(255)
	CloseFile tempOut:CloseFile tempOut2
	FreeBank TokenBank
	
	ResizeBank SourceBank,FileSize(Left(outputFile,Len(outputFile)-3)+"_functions.bb")
	fileIn=ReadFile(Left(outputFile,Len(outputFile)-3)+"_functions.bb")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn:DeleteFile Left(outputFile,Len(outputFile)-3)+"_functions.bb"
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	While lexTokenType&lt;&gt;tt_EOF
		If prevToken&lt;&gt;"function"
			For func=Each ObjFunction
				If lexToken=func\name Then Exit
			Next
		EndIf
		If func&lt;&gt;Null
			OBJ_WriteFunctionCall(func,fileOut)
			func=Null
		Else
			prevToken=lexToken
			LEX_WriteToken(fileOut)
		EndIf
	Wend
	WriteLine fileOut,""
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,"":WriteLine fileOut,""
	FreeBank TokenBank
	;[End block]
	
	;Globals - second pass
	OBJ_WriteGlobals(fileOut,Left(outputFile,Len(outputFile)-3)+"_globals.bb")
	DeleteFile Left(outputFile,Len(outputFile)-3)+"_globals.bb"
	
	;Body code
	ResizeBank SourceBank,FileSize(outputFile+"_tmp")
	fileIn=ReadFile(outputFile+"_tmp")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,";Body code"
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,""
	
	tempOut=WriteFile(outputFile+"_tmp")
	WriteLine tempOut,OBJ_FunctionBody(Null)
	WriteLine tempOut,Chr(255)
	CloseFile tempOut:FreeBank TokenBank
	ResizeBank SourceBank,FileSize(outputFile+"_tmp")
	fileIn=ReadFile(outputFile+"_tmp")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)
	CloseFile fileIn:DeleteFile outputFile+"_tmp"
	LEX_Tokenise:lexCurrentToken=0
	LEX_FetchToken(lexCurrentToken)
	While lexTokenType&lt;&gt;tt_EOF
		If prevToken&lt;&gt;"function"
			For func=Each ObjFunction
				If lexToken=func\name Then Exit
			Next
		EndIf
		If func&lt;&gt;Null
			OBJ_WriteFunctionCall(func,fileOut)
			func=Null
		Else
			prevToken=lexToken
			LEX_WriteToken(fileOut)
		EndIf
	Wend
	WriteLine fileOut,""
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,"":WriteLine fileOut,""
	
	FreeBank TokenBank
	CloseFile fileOut
End Function

</textarea> <br><br></td></tr></table><br>
<a name="993817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> - "OO.bb"<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">


Const OBJ_MAX_FIELDS=1024		;These really ought to be enough...
Const OBJ_METHOD_MAX_ARGS=64	;Actually this will be determined dynamically so as not to waste space, but seriously...
Const OBJ_MAX_CLASSES=1024

;Global classList.ObjClass[OBJ_MAX_CLASSES]
Global methodID

Type ObjClass
	Field name$,ID
	Field superName$,super.ObjClass
	Field base,final,private
	Field noFields
	Field fieldName$[OBJ_MAX_FIELDS]
	Field fieldType[OBJ_MAX_FIELDS],fieldTypeName$[OBJ_MAX_FIELDS]
	Field fieldAccess[OBJ_MAX_FIELDS]
	Field noMethods,methodMaxArgs,methodMaxName
	Field method.ObjMethod[OBJ_MAX_FIELDS]
End Type

Type ObjMethod
	Field name$,globalName$,ID
	Field class.ObjClass,cMethod
	Field rType,rTypeName$,rTypeRep
	Field noArgs
	Field argName$[OBJ_METHOD_MAX_ARGS]
	Field argType[OBJ_METHOD_MAX_ARGS]
	Field decl$,body$
End Type

Type ObjFunction
	Field name$,ID
	Field rtype,rTypeRep
	Field noArgs
	Field argName$[CODE_MAX_ARGS]
	Field argType[CODE_MAX_ARGS]
	Field decl$,body$
End Type

Type ObjVariable
	Field name$
	Field typeID,typeRep
	Field scope
End Type

Type ObjSelector
	Field name,selID
End Type


Function OBJ_GetTypeSym$(typeID)	;Return a type's suffix (eg. #, $, .MyType) from its ID
	Local class.ObjClass
	
	Select typeID
		Case 1:Return "%"
		Case 2:Return "#"
		Case 3:Return "$"
		Default
			For class=Each ObjClass
				If class\ID=typeID
					If class\final Then Return ("."+class\name):Else Return "%"
				EndIf
			Next
	End Select
End Function

Function OBJ_GetTypeName$(typeID)	;Return a type's text name (eg. Float, String, MyType) from its ID
	Local class.ObjClass
	
	Select typeID
		Case 1:Return "Int"
		Case 2:Return "Flt"
		Case 3:Return "Str"
		Default
			For class=Each ObjClass
				If class\ID=typeID Then Return (class\name)
			Next
	End Select
End Function

Function OBJ_GetTypeID()			;Return a type's ID from the current token suffix
	Local super.ObjClass
	
	If LEX_CheckToken(".")
		For super=Each ObjClass
			If super\name=lexToken Then Exit
		Next
		LEX_NextToken
		Return super\ID
	ElseIf LEX_CheckToken("#")
		Return 2
	ElseIf LEX_CheckToken("$")
		Return 3
	Else
		LEX_CheckToken("%")
		Return 1
	EndIf
End Function

Function OBJ_GetTypeDef.ObjClass(ID)	;Return a type's definition from its ID
	Local class.ObjClass
	For class=Each ObjClass
		If class\ID=ID Then Return class
	Next
End Function

Function OBJ_CopyMethod.ObjMethod(newClass.ObjClass,method.ObjMethod)
	Local copy.ObjMethod,i
	
	copy=New ObjMethod
	copy\name=method\name
	copy\ID=method\ID
	copy\class=newClass
	copy\cMethod=method\cMethod
	copy\globalName=newClass\name+"_Method_"+copy\name+"__"
	copy\rType=method\rType
	copy\rTypeName=method\rTypeName
	copy\rTypeRep=method\rTypeRep
	copy\noArgs=method\noArgs
	
	For i=0 To copy\noArgs-1
		copy\argName[i]=method\argName[i]
		copy\argType[i]=method\argType[i]
	Next
	copy\argType[0]=newClass\ID
	
	OBJ_SetMethodDecl(newClass,copy)
	copy\body=method\body
	
	Return copy
End Function

Function OBJ_SetMethodID(method.ObjMethod)		;Assign the same ID to all methods with the same name
	Local oldMethod.ObjMethod
	
	For oldMethod=Each ObjMethod
		If oldMethod&lt;&gt;method; And oldMethod\cMethod=False
			If oldMethod\name=method\name Then method\ID=oldMethod\ID:Exit
		EndIf
	Next
	
	If method\ID=0
		methodID=methodID+1
		method\ID=methodID
	EndIf
End Function

Function OBJ_SetMethodDecl(class.ObjClass,m.ObjMethod,auto=False)
	Local outLine$,i
	
	If m\cMethod
		m\decl=Chr(9)+"; Class method "+class\name+"::"+m\name
		outLine="Function "+m\globalName+m\rTypeName+"(self.ObjB3D_Class__"
	Else
		m\decl=Chr(9)+"; Instance method "+class\name+"::"+m\name
		outLine="Function "+m\globalName+m\rTypeName+"(self."+class\name
	EndIf
	
	If auto Then m\decl=m\decl+"  (Automatic)"
	m\decl=m\decl+Chr(13)+Chr(10)
	
	For i=1 To m\noArgs-1
		outLine=outLine+","+m\argName[i]
		If m\argType[i]&lt;4
			outLine=outLine+OBJ_GetTypeSym(m\argType[i])
		Else
			outLine=outLine+OBJ_GetTypeSym(m\argType[i])
		EndIf
	Next
	m\decl=m\decl+Chr(9)+outLine+")"
	If m\rType&lt;&gt;m\rTypeRep
		m\decl=m\decl+Chr(9)+";Return type "+OBJ_GetTypeName(m\rTypeRep)
	EndIf
	m\decl=m\decl+Chr(13)+Chr(10)
End Function

Function OBJ_AutoGetter(class.ObjClass,i)
	Local fieldIsArray,method.ObjMethod,super.ObjClass
	
	method=New ObjMethod
	method\class=class
	method\name=class\fieldName[i]
	method\globalName=class\name+"_Method_"+class\fieldName[i]+"__"
	method\rType=class\fieldType[i]
	If Right(class\fieldTypeName[i],1)="]"
		method\rTypeName=Left(class\fieldTypeName[i],Instr(class\fieldTypeName[i],"[")-1):fieldIsArray=True
	Else
		method\rTypeName=class\fieldTypeName[i]:fieldIsArray=False
	EndIf
	If class\fieldType[i]&gt;3
		super=OBJ_GetTypeDef(class\fieldType[i])
		If super\final Then method\rTypeRep=class\fieldType[i]:Else method\rTypeRep=1
	Else
		method\rTypeRep=method\rType
	EndIf
	method\noArgs=1+fieldIsArray:method\argName[0]="self"
	If fieldIsArray Then method\argName[1]="index":method\argType[1]=1
	OBJ_SetMethodID(method)
	OBJ_SetMethodDecl(class,method,True)
	method\body=Chr(9)+Chr(9)+"Return self \ "+class\fieldName[i]
	If class\fieldAccess[i] Then method\body=method\body+"__"
	If fieldIsArray Then method\body=method\body+" [ index ]"
	method\body=method\body+Chr(13)+Chr(10)+Chr(9)+"End Function"+Chr(13)+Chr(10)
	class\method[class\noMethods]=method
	class\noMethods=class\noMethods+1
End Function

Function OBJ_AutoSetter(class.ObjClass,i)
	Local fieldIsArray,method.ObjMethod,super.ObjClass
	
	method=New ObjMethod
	method\class=class
	method\name="set"+class\fieldName[i]
	method\globalName=class\name+"_Method_set"+class\fieldName[i]+"__"
	method\rType=1:method\rTypeRep=1	;Well, void, but we have no void type here
	If Right(class\fieldTypeName[i],1)="]" Then fieldIsArray=True
	method\noArgs=2+fieldIsArray:method\argName[0]="self"
	method\argName[1]=class\fieldName[i]
	If class\fieldType[i]&gt;3
		super=OBJ_GetTypeDef(class\fieldType[i])
		If super\final Then method\argType[1]=super\ID:Else method\argType[1]=1
	Else
		method\argType[1]=class\fieldType[i]
	EndIf
	If fieldIsArray Then method\argName[2]="index":method\argType[2]=1
	OBJ_SetMethodID(method)
	OBJ_SetMethodDecl(class,method,True)
	method\body=Chr(9)+Chr(9)+" self \ "+class\fieldName[i]
	If class\fieldAccess[i] Then method\body=method\body+"__"
	If fieldIsArray Then method\body=method\body+" [ index ]"
	method\body=method\body+" = "+method\argName[1]+Chr(13)+Chr(10)+Chr(9)+"End Function"+Chr(13)+Chr(10)
	class\method[class\noMethods]=method
	class\noMethods=class\noMethods+1
End Function

Function OBJ_AutoNew(class.ObjClass)
	Local method.ObjMethod
	
	For method=Each ObjMethod
		If method\class=class And method\name="new" Then Exit
	Next
	If method=Null
		method=New ObjMethod
		method\class=class
		method\name="new"
		method\globalName=class\name+"_ClassMethod_new__"
		method\rType=1:method\rTypeRep=1:method\rTypeName="%"
		method\noArgs=1:method\argName[0]="self":method\argType[0]=-1:method\cMethod=True
		OBJ_SetMethodID(method):OBJ_SetMethodDecl(class,method,True)
		method\body=Chr(9)+Chr(9)+"Return Handle( New "+class\name+" )"+Chr(13)+Chr(10)+Chr(9)+"End Function"+Chr(13)+Chr(10)
	EndIf
End Function

Function OBJ_AutoDel(class.ObjClass)
	Local method.ObjMethod
	
	For method=Each ObjMethod
		If method\class=class And method\name="delete" Then Exit
	Next
	If method=Null
		method=New ObjMethod
		method\class=class
		method\name="delete"
		method\globalName=class\name+"_Method_delete__"
		method\rType=1:method\rTypeRep=1:method\rTypeName="%"
		method\noArgs=1:method\argName[0]="self":method\argType[0]=class\ID
		OBJ_SetMethodID(method):OBJ_SetMethodDecl(class,method,True)
		method\body=Chr(9)+Chr(9)+"Delete self"+Chr(13)+Chr(10)+Chr(9)+"End Function"+Chr(13)+Chr(10)
	EndIf
End Function

Function OBJ_FunctionBody$(method.ObjMethod)
	Local outLine$,prevToken$,i
	Local class.ObjClass,var.ObjVariable
	
	While lexTokenType&lt;&gt;tt_EOF
		If lexToken="end"
			LEX_NextToken
			If LEX_CheckToken("function") Then Exit
			lexCurrentToken=lexCurrentToken-1:LEX_FetchToken(lexCurrentToken)
		EndIf
		
		outLine=outLine+Chr(9)
		If method&lt;&gt;Null Then outLine=outLine+Chr(9)
		Repeat
			For class=Each ObjClass
				If class\final=False		;Remove direct references to nonfinal classes
					If lexToken=class\name
						If prevToken="." Then lexToken="":outLine=Left(outLine,Len(outLine)-2)
					EndIf
				EndIf
			Next
			
			If method&lt;&gt;Null
				For i=0 To method\class\noFields-1		;Rename private fields and add references to "self" where relevant
					If lexToken=method\class\fieldName[i]
						If method\class\fieldAccess[i] Then lexToken=lexToken+"__"
						If prevToken&lt;&gt;"\" Then lexToken="self \ "+lexToken:Exit
					EndIf
				Next
			EndIf
			
			If lexToken="." And lexNewLine=False
				LEX_FetchToken(lexCurrentToken+2)
				If lexToken&lt;&gt;"("
					LEX_FetchToken(lexCurrentToken-1)
					For var=Each ObjVariable
						If var\name=lexToken Then Exit
					Next
					If var=Null		;First reference = declaration, for local scope
						var=New ObjVariable
						var\name=prevToken
						var\scope=1
						LEX_NextToken
						For class=Each ObjClass
							If class\name=lexToken Then Exit
						Next
						If class=Null Then CodeError("unrecognised type "+Chr(34)+lexToken+Chr(34))
						var\typeRep=class\ID
						If class\final Then var\typeID=class\ID:Else var\typeID=1
						lexCurrentToken=lexCurrentToken-1:LEX_FetchToken(lexCurrentToken)
					EndIf
					lexToken="."
				Else
					lexToken="."
				EndIf
			EndIf
			
			If LEX_CheckToken("[")
				If LEX_CheckToken(":")		;It's a message
					lexToken=OBJ_ParseMessage(False)
					lexCurrentToken=lexCurrentToken-1	;Back up one because we just overwrote and lost a token
				Else						;It's just an array
					lexCurrentToken=lexCurrentToken-1
					lexToken="["
				EndIf
			EndIf
			
			outLine=outLine+lexToken+" "
			prevToken=lexToken
			LEX_NextToken
		Until lexNewLine
		outLine=outLine+Chr(13)+Chr(10)
	Wend
	
	If method&lt;&gt;Null Then outLine=outLine+Chr(9)+"End Function"+Chr(13)+Chr(10)
	
	Return outLine
End Function

Function OBJ_ParseMessage$(inMessage)
	Local i,receiver$,selector$,outLine$,arg$[OBJ_METHOD_MAX_ARGS],argT[OBJ_METHOD_MAX_ARGS],argC
	Local class.ObjClass,method.ObjMethod,rec.ObjVariable
	Local typeKnown,selKnown,selType,bracketCount,closed
	
	If LEX_CheckToken("[")			;Get the receiver
		LEX_ExpectToken(":")
		receiver=OBJ_ParseMessage(True)
		LEX_ExpectToken(":")
	Else
		For rec=Each ObjVariable
			If lexToken=rec\name Then Exit
		Next
		If rec&lt;&gt;Null
			receiver=rec\name:LEX_NextToken
			While Not LEX_CheckToken(":")
				receiver=receiver+lexToken
			Wend
			If rec\typeID&lt;&gt;1 Then typeKnown=True
		Else
			While Not LEX_CheckToken(":")
				If LEX_CheckToken("[")
					If LEX_CheckToken(":") Then receiver=receiver+OBJ_ParseMessage(False):Else lexCurrentToken=lexCurrentToken-1:lexToken="["
				EndIf
				receiver=receiver+lexToken+" ":LEX_NextToken
			Wend
		EndIf
	EndIf
	
	If LEX_CheckToken("[")			;Get the selector
		LEX_ExpectToken(":")
		selector=OBJ_ParseMessage(True)
		If lexToken="%" Or lexToken="#" Or lexToken="$" Or lexToken="."		;Check for type specifier
			If LEX_CheckToken(".")
				For class=Each ObjClass
					If LEX_CheckToken(class\name)
						If class\final Then selType=class\ID:Else selType=1
						Exit
					EndIf
				Next
			ElseIf LEX_CheckToken("$")
				selType=3
			ElseIf LEX_CheckToken("#")
				selType=2
			Else
				LEX_CheckToken("%")
				selType=1
			EndIf
		EndIf
	Else
		LEX_FetchToken(lexCurrentToken+1)
		If lexToken=":" Or lexToken="]" Or lexToken="%" Or lexToken="#" Or lexToken="$" Or lexToken="."
			LEX_FetchToken(lexCurrentToken)
			selector=lexToken:selType=1
			For method=Each ObjMethod
				If rec&lt;&gt;Null
					If method\name=selector And method\class\ID=rec\typeRep
						selector="Selector_"+selector+"__"		;Replace the method name with the appropriate constant
						selType=method\rType
						selKnown=True:Exit
					EndIf
				EndIf
			Next
			LEX_NextToken
			If lexToken="%" Or lexToken="#" Or lexToken="$" Or lexToken="."		;Check for type specifier
				If LEX_CheckToken(".")
					For class=Each ObjClass
						If LEX_CheckToken(class\name)
							If class\final Then selType=class\ID:Else selType=1
							Exit
						EndIf
					Next
				ElseIf LEX_CheckToken("$")
					selType=3
				ElseIf LEX_CheckToken("#")
					selType=2
				Else
					LEX_CheckToken("%")
					selType=1
				EndIf
			EndIf
		Else
			LEX_FetchToken(lexCurrentToken)
			While Not LEX_CheckToken(":")
				If LEX_CheckToken("[")
					If LEX_CheckToken(":") Then selector=selector+OBJ_ParseMessage(False):Else lexCurrentToken=lexCurrentToken-1:lexToken="[":bracketCount=bracketCount+1
				EndIf
				selector=selector+lexToken+" "
				If LEX_CheckToken("]")
					If bracketCount=0 Then closed=True:Exit
					bracketCount=bracketCount-1
				Else
					LEX_NextToken
				EndIf
			Wend
			LEX_FetchToken(lexCurrentToken-2)
			For class=Each ObjClass
				If LEX_CheckToken(class\name)		;Check for type specifier
					If class\final Then selType=class\ID:Else selType=1
					Exit
				EndIf
			Next
			If class&lt;&gt;Null
				LEX_FetchToken(lexCurrentToken-3)
				LEX_ExpectToken(".")
				selector=Left(selector,Len(selector)-(Len(class\name)+1))
			ElseIf LEX_CheckToken("$")
				selector=Left(selector,Len(selector)-1)
				selType=3
			ElseIf LEX_CheckToken("#")
				selector=Left(selector,Len(selector)-1)
				selType=2
			Else
				If LEX_CheckToken("%") Then selector=Left(selector,Len(selector)-1)
				selType=1
			EndIf
			LEX_FetchToken(lexCurrentToken)
		EndIf
	EndIf
	
	If Not closed
		bracketCount=0
		Repeat
			If LEX_CheckToken(":")
				If LEX_CheckToken("[")
					LEX_ExpectToken(":"):arg[argC]=OBJ_ParseMessage(True)
				Else
					Repeat
						If LEX_CheckToken("[")
							If LEX_CheckToken(":") Then arg[argC]=arg[argC]+OBJ_ParseMessage(False):Else lexCurrentToken=lexCurrentToken-1:lexToken="[":bracketCount=bracketCount+1
						EndIf
						If lexToken="]" And bracketCount&gt;0
							bracketCount=bracketCount-1
						EndIf
						arg[argC]=arg[argC]+lexToken
						LEX_NextToken
					Until lexToken=":" Or (lexToken="]" And bracketCount=0)
					If lexToken="]" Then closed=True
				EndIf
				argC=argC+1
			Else
				LEX_ExpectToken("]")
				lexCurrentToken=lexCurrentToken-1:LEX_FetchToken(lexCurrentToken)
				closed=True
			EndIf
			
			If argC&gt;0
				If selKnown
					argT[argC-1]=method\argType[argC]
				Else
					LEX_FetchToken(lexCurrentToken-1)
					For class=Each ObjClass
						If lexToken=class\name		;Check for argument type specifiers
							If class\final Then argT[argC-1]=class\ID:Else argT[argC-1]=1
							Exit
						EndIf
					Next
					If class&lt;&gt;Null
						LEX_FetchToken(lexCurrentToken-2)
						LEX_ExpectToken("."):lexCurrentToken=lexCurrentToken-1
						arg[argC-1]=Left(arg[argC-1],Len(arg[argC-1])-(Len(class\name)+1))
					ElseIf lexToken="$"
						arg[argC-1]=Left(arg[argC-1],Len(arg[argC-1])-1)
						argT[argC-1]=3
					ElseIf lexToken="#"
						arg[argC-1]=Left(arg[argC-1],Len(arg[argC-1])-1)
						argT[argC-1]=2
					Else
						If lexToken="%" Then arg[argC-1]=Left(arg[argC-1],Len(arg[argC-1])-1)
						argT[argC-1]=1
					EndIf
					LEX_FetchToken(lexCurrentToken)
				EndIf
			EndIf
		Until closed
		LEX_ExpectToken("]")
	EndIf
	
	If typeKnown	;rec&lt;&gt;Null therefore method&lt;&gt;Null
		class=OBJ_GetTypeDef(rec\typeRep)
		If selKnown
			outLine=method\globalName+"( "+receiver
			For i=0 To argC-1
				outLine=outLine+" , "
				outLine=outLine+arg[i]
			Next
		Else
			outLine="Message_"+class\name+"__( "+receiver+" , "+selector
			For i=0 To argC-1
				outLine=outLine+" , "
				If argT[i]&gt;3
					outLine=outLine+"Handle ( "+arg[i]+ ")"
				ElseIf argT[i]&gt;1
					outLine=outLine+"Box"+OBJ_GetTypeName(argT[i])+"__( "+arg[i]+" )"
				Else
					outLine=outLine+arg[i]
				EndIf
			Next
			If selType&gt;1 And inMessage=False
				If selType&gt;3
					outLine="Object"+OBJ_GetTypeSym(selType)+" ( "+outLine+ " )"
				Else
					outLine="Unbox"+OBJ_GetTypeName(selType)+"__( "+outLine+" )"
				EndIf
			EndIf
		EndIf
	Else
		If selKnown		;rec&lt;&gt;Null
			outLine="PassMessage_"+method\class\name+"__( "+receiver+" , "+selector
			selType=method\rType
		Else			;This will come up rarely enough that optimising it should be a low priority
			outLine="PassMessage_Generic__("+receiver+" , Selector_"+selector+"__"
		EndIf
		
		For i=0 To argC-1
			outLine=outLine+" , "
			If argT[i]&gt;3
				outLine=outLine+"Handle ( "+arg[i]+ ")"
			ElseIf argT[i]&gt;1
				outLine=outLine+"Box"+OBJ_GetTypeName(argT[i])+"__( "+arg[i]+" )"
			Else
				outLine=outLine+arg[i]
			EndIf
		Next
		If selType&gt;1 And inMessage=False
			If selType&gt;3
				outLine="Object"+OBJ_GetTypeSym(selType)+" ( "+outLine+ " )"
			Else
				outLine="Unbox"+OBJ_GetTypeName(method\rType)+"__( "+outLine+" )"
			EndIf
		EndIf
	EndIf
	
	outLine=outLine+" )"
	
	Return outLine
End Function

Function OBJ_ReadConstants(fileOut,outputFile$)
	Local tempOut,outLine$
	
	tempOut=WriteFile(outputFile+"_tmp")		;Since the pre-processing is in multiple passes, remaining data needs to be dumped out and reloaded a few times
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	WriteLine fileOut,""
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,";Const definitions"
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,""
	While lexTokenType&lt;&gt;tt_EOF			;First iterate through and build a list of all Consts
		If LEX_CheckToken("const")		;Note that all identifiers are lower-case at this point
			outLine="Const "
			While Not(lexNewLine)
				outLine=outLine+lexToken+" "	;Blitz3D doesn't mind extra spaces between tokens as long as the order is valid
				LEX_NextToken
			Wend
			WriteLine fileOut,outLine
		Else
			LEX_WriteToken(tempOut)		;Dump lines that don't contain Const definitions
		EndIf
	Wend
	LEX_WriteToken(tempOut)
	WriteLine fileOut,""
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,"":WriteLine fileOut,""
	
	CloseFile tempOut
	FreeBank TokenBank
End Function

Function OBJ_WriteFunctionCall(f.ObjFunction,fileOut)
	Local parenCount,cArg,func.ObjFunction,newline
	
	LEX_WriteToken(fileOut)		;Dump the function identifier
	If lexToken="%" Or lexToken="#" Or lexToken="$" Then LEX_WriteToken(fileOut)	;Dump the type specifier if present
	If LEX_CheckToken="." Then lexToken=". "+lexToken:LEX_WriteToken(fileOut)
	If lexToken="(" Then parenCount=1:LEX_WriteToken(fileOut)
	If f\argType[0]=-1 Then lexToken="Handle( "+lexToken
	
	While parenCount&gt;0 And lexToken&lt;&gt;":" And lexNewLine=0
		For func=Each ObjFunction
			If lexToken=func\name Then Exit
		Next
		If func&lt;&gt;Null
			OBJ_WriteFunctionCall(func,fileOut)
		Else
			If lexToken="(" Then parenCount=parenCount+1
			If lexToken=")" Then parenCount=parenCount-1
			If lexToken=","
				If f\argType[cArg]=-1 Then lexToken=lexToken+" )"
				cArg=cArg+1
				If f\argType[cArg]=-1 Then lexToken="Handle( "+lexToken
			EndIf
			LEX_WriteToken(fileOut,Not(f\argType[cArg]=-1))
			newline=lexNewLine
		EndIf
	Wend
	
	If f\argType[cArg]=-1
		lexCurrentToken=lexCurrentToken-1
		lexToken=")"
		LEX_WriteToken(fileOut)
		lexNewLine=newline
	EndIf
	LEX_FetchToken(lexCurrentToken)
End Function

Function OBJ_ReadGlobals(fileOut,outputFile$)
	Local fileIn,tempOut,outLine$,prevToken$
	Local class.ObjClass,var.ObjVariable
	
	ResizeBank SourceBank,FileSize(outputFile+"_tmp")
	fileIn=ReadFile(outputFile+"_tmp")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn
	tempOut=WriteFile(outputFile+"_tmp")
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	While lexTokenType&lt;&gt;tt_EOF		;Build a list of global definitions, and convert any nonfinal type references to integer handles
		prevToken=lexToken
		If LEX_CheckToken("global") Or LEX_CheckToken("dim")
			outLine=prevToken+" "
			While Not(lexNewLine)
				If lexToken="."
					var=New ObjVariable
					var\name=prevToken
					var\scope=0
					LEX_NextToken
					For class=Each ObjClass
						If class\name=lexToken
							var\typeID=class\ID:var\typeRep=class\ID
							If class\final=False Then lexToken="%":var\typeID=1
							Exit
						EndIf
					Next
					If class\final Then lexToken=". "+lexToken
				EndIf
				
				outLine=outLine+lexToken+" "	;Blitz3D doesn't mind extra spaces between tokens as long as the order is valid
				
				prevToken=lexToken
				LEX_NextToken
			Wend
			WriteLine fileOut,outLine
		Else
			LEX_WriteToken(tempOut)		;Dump lines that don't contain Const definitions
		EndIf
	Wend
	
	LEX_WriteToken(tempOut)
	WriteLine fileOut,Chr(255)		;Give it an EOF token so the lexer doesn't complain
	
	CloseFile tempOut
	FreeBank TokenBank
End Function

Function OBJ_WriteGlobals(fileOut,inputFile$)
	Local filein,outLine$,prevToken$,i
	Local class.ObjClass,method.ObjMethod,var.ObjVariable
	
	ResizeBank SourceBank,FileSize(inputFile)
	filein=ReadFile(inputFile)
	ReadBytes SourceBank,filein,0,BankSize(SourceBank)		;Load the file
	CloseFile filein
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,";Global Definitions"
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,""
	
	While lexTokenType&lt;&gt;tt_EOF
		outLine=""
		Repeat
			
			If LEX_CheckToken("[")
				If LEX_CheckToken(":")		;It's a message
					lexToken=OBJ_ParseMessage(False)
					lexCurrentToken=lexCurrentToken-1	;Back up one because we just overwrote and lost a token
				Else						;It's just an array
					lexCurrentToken=lexCurrentToken-1
					lexToken="["
				EndIf
			EndIf
			
			outLine=outLine+lexToken+" "
			prevToken=lexToken
			LEX_NextToken
		Until lexNewLine
		WriteLine fileOut,outLine
	Wend
	
	For var=Each ObjVariable
		If var\scope=1 Then Delete var
	Next
	
	WriteLine fileOut,""
	WriteLine fileOut,"; Class objects"
	WriteLine fileOut,";------------------------------------------"
	WriteLine fileOut,""
	For class=Each ObjClass
		If class\private=False
			WriteLine fileOut,"Global "+class\name+".ObjB3D_Class__ = New ObjB3D_Class__"
			WriteLine fileOut,class\name+" \ name = "+Chr(34)+class\name+Chr(34)
			WriteLine fileOut,class\name+" \ base = "+class\base
			WriteLine fileOut,class\name+" \ final = "+class\final
			WriteLine fileOut,class\name+" \ noFields = "+class\noFields
			WriteLine fileOut,class\name+" \ noMethods = "+class\noMethods
			For i=0 To class\noFields-1
				WriteLine fileOut,class\name+" \ fieldName [ "+i+" ] = "+Chr(34)+class\fieldName[i]+Chr(34)
				WriteLine fileOut,class\name+" \ fieldType [ "+i+" ] = "+class\fieldType[i]
			Next
			WriteLine fileOut,""
		EndIf
	Next
	
	For class=Each ObjClass
		If class\base=0 Then WriteLine fileOut,class\name+" \ super = "+class\super\name
	Next
	
	WriteLine fileOut,""
	WriteLine fileOut,""
	WriteLine fileOut,"; Method objects"
	WriteLine fileOut,";------------------------------------------"
	WriteLine fileOut,""
	WriteLine fileOut,"Local selector.ObjB3D_Selector__"
	WriteLine fileOut,""
	For method=Each ObjMethod
		WriteLine fileOut,"selector__.ObjB3D_Selector__ = New ObjB3D_Selector__"
		WriteLine fileOut,"selector__ \ name = "+Chr(34)+method\name+Chr(34)
		WriteLine fileOut,"selector__ \ selID = "+method\ID
		WriteLine fileOut,"selector__ \ noArgs = "+method\noArgs
		For i=0 To method\noArgs-1
			WriteLine fileOut,"selector__ \ argName [ "+i+" ] = "+Chr(34)+method\argName[i]+Chr(34)
			WriteLine fileOut,"selector__ \ argType [ "+i+" ] = "+method\argType[i]
		Next
		WriteLine fileOut,""
	Next
	WriteLine fileOut,""
	
	For class=Each ObjClass
		If class\private=False And class\noMethods&gt;0
			For i=0 To class\noFields-1
				WriteLine fileOut,class\name+" \ methodName [ "+i+" ] = "+Chr(34)+class\method[i]\name+Chr(34)
				WriteLine fileOut,class\name+" \ methodType [ "+i+" ] = "+class\method[i]\rTypeRep
				WriteLine fileOut,class\name+" \ methodSel [ "+i+" ] = "+class\method[i]\ID
			Next
			WriteLine fileOut,""
		EndIf
	Next
	
	WriteLine fileOut,""
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,"":WriteLine fileOut,""
	
	FreeBank TokenBank
End Function

Function OBJ_ReadMethods(fileOut,outputFile$)
	Local fileIn,tempOut
	Local i,j,c,outLine$,prevToken$,cMethod
	Local class.ObjClass,super.ObjClass,method.ObjMethod
	
	ResizeBank SourceBank,FileSize(outputFile+"_tmp")
	fileIn=ReadFile(outputFile+"_tmp")
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn
	tempOut=WriteFile(outputFile+"_tmp")
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	While lexTokenType&lt;&gt;tt_EOF			;Build a list of Type implementations (methods)
		
		If LEX_CheckToken("implement")
			For class=Each ObjClass
				If LEX_CheckToken(class\name) Then Exit
			Next
			If Not(lexNewLine) Then CodeError("unexpected identifier "+Chr(34)+lexToken+Chr(34))
			
			While Not(LEX_CheckToken("end"))
				
				cMethod=LEX_CheckToken("class")
				LEX_ExpectToken("method")
				
				method=New ObjMethod
				method\class=class
				If cMethod
					method\globalName=class\name+"_ClassMethod_"+lexToken+"__"
					method\cMethod=True
				Else
					method\globalName=class\name+"_Method_"+lexToken+"__"
				EndIf
				
				method\name=lexToken:LEX_NextToken
				method\rType=OBJ_GetTypeID():method\rTypeName=OBJ_GetTypeSym(method\rType):method\rTypeRep=method\rType
				If method\rType&gt;3
					super=OBJ_GetTypeDef(method\rType):If super=Null Then CodeError("unrecognised type")
					If super\final=False Then method\rType=1:method\rTypeName="%"
				EndIf
				
				method\noArgs=1
				method\argName[0]="self"
				If cMethod=False Then method\argType[0]=class\ID:Else method\argType[0]=-1	;Err... come back to this later, but essentially class methods also have a "self", referring to the class itself
				While LEX_CheckToken(":")
					method\argName[method\noArgs]=lexToken:LEX_NextToken
					method\argType[method\noArgs]=OBJ_GetTypeID()
					If method\argType[method\noArgs]&gt;3
						super=OBJ_GetTypeDef(method\argType[method\noArgs]):If super=Null Then CodeError("unrecognised type")
					EndIf
					method\noArgs=method\noArgs+1
				Wend
				
				OBJ_SetMethodID(method)
				OBJ_SetMethodDecl(class,method)
				
				prevToken=lexToken
				Repeat
					If lexToken="end"
						LEX_NextToken
						If LEX_CheckToken("method") Then Exit
						lexCurrentToken=lexCurrentToken-1:LEX_FetchToken(lexCurrentToken)
					EndIf
					
					outLine=""
					Repeat
						If class\final=0
							If method\rTypeRep=class\ID
								If lexToken="self"
									If prevToken="return"
										LEX_FetchToken(lexCurrentToken+1)		;Check that it's not returning a field
										If lexToken&lt;&gt;"\" Then lexToken="Handle(self)"
										lexToken="self"
									EndIf
								EndIf
							EndIf
						EndIf
						
						outLine=outLine+lexToken+" "
						prevToken=lexToken
						LEX_NextToken
					Until lexNewLine
					method\body=method\body+Chr(9)+Chr(9)+outLine+Chr(13)+Chr(10)
				Forever
				
				method\body=method\body+Chr(9)+"End Function"+Chr(13)+Chr(10)
				
				If cMethod=False
					class\method[class\noMethods]=method
					class\noMethods=class\noMethods+1
				EndIf
			Wend
			LEX_ExpectToken("implement")
		Else
			LEX_WriteToken(tempOut)		;Dump lines that don't concern Type implementations
		EndIf
	Wend
	LEX_WriteToken(tempOut)
	
	For class=Each ObjClass
		super=class\super
		While super&lt;&gt;Null	;Copy the methods from superclass
			cMethod=0
			For i=class\noMethods To class\noMethods+super\noMethods-1
				For c=0 To class\noMethods-1
					If super\method[i-class\noMethods]\name=class\method[c]\name Then method=super\method[i-class\noMethods]:Exit
				Next
				If c=class\noMethods	;Don't copy methods that have been overridden
					class\method[class\noMethods+cMethod]=OBJ_CopyMethod(class,super\method[i-class\noMethods])
					cMethod=cMethod+1
				Else
					If method\noArgs&lt;&gt;class\method[c]\noArgs Then CodeError("overriding method "+Chr(34)+method\name+Chr(34)+" in class "+Chr(34)+class\name+Chr(34)+" must have same number of arguments")
					For j=1 To method\noArgs-1		;Not an error - if they compare "self" they'll always think it's different
						If method\argType[j]&lt;&gt;class\method[c]\argType[j] Then CodeError("overriding method "+Chr(34)+method\name+Chr(34)+" in class "+Chr(34)+class\name+Chr(34)+" must have same type of arguments")
					Next
				EndIf
			Next
			class\noMethods=class\noMethods+cMethod
			super=super\super
		Wend
	Next
	
	For method=Each ObjMethod
		WriteLine fileOut,method\decl
		WriteLine fileOut,method\body
	Next
	WriteLine fileOut,Chr(255)
	
	CloseFile tempOut
	FreeBank TokenBank
End Function

Function OBJ_WriteMethods(fileOut,inputFile$)
	Local i,c,outLine$,deriv.ObjClass,fileIn,var.ObjVariable
	Local class.ObjClass,super.ObjClass,cMethod,method.ObjMethod
	
	ResizeBank SourceBank,FileSize(inputFile)
	fileIn=ReadFile(inputFile)
	ReadBytes SourceBank,fileIn,0,BankSize(SourceBank)		;Load the file
	CloseFile fileIn
	
	LEX_Tokenise		;Tokenise it
	lexCurrentToken=0	;Set to start
	LEX_FetchToken(lexCurrentToken)
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,";Type Implementations"
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,""
	
	For class=Each ObjClass
		If class\private=False
			OBJ_AutoNew(class)				;Automatically generate "New" class method, if necessary
			OBJ_AutoDel(class)				;Automatically generate "Delete" method, if necessary
			For i=0 To class\noFields-1		;Automatically generate getters and setters for public fields
				If class\fieldAccess[i]&lt;2
					For c=0 To class\noMethods-1
						If class\method[c]\name=class\fieldName[i] Then Exit		;Check if the default getter name (same as the field name) is taken
					Next
					If c=class\noMethods Then OBJ_AutoGetter(class,i)		;If not, create it
					For c=0 To class\noMethods-1
						If class\method[c]\name="set"+class\fieldName[i] Then Exit		;Check if the default setter name (setFieldName) is taken
					Next
					If c=class\noMethods Then OBJ_AutoSetter(class,i)		;If not, create that
				EndIf
			Next
		EndIf
	Next
	
	WriteLine fileOut,"; Method selectors"
	WriteLine fileOut,";------------------------------------------"
	WriteLine fileOut,""
	For i=1 To methodID
		For method=Each ObjMethod
			If method\ID=i Then WriteLine fileOut,"Const Selector_"+method\name+"__ = "+i:Exit
		Next
	Next
	WriteLine fileOut,""
	WriteLine fileOut,";------------------------------------------"
	WriteLine fileOut,""
	
	cMethod=0
	For class=Each ObjClass
		For i=0 To class\noMethods-1
			If class\method[i]\noArgs&gt;class\methodMaxArgs Then class\methodMaxArgs=class\method[i]\noArgs
			If Len(class\method[i]\name)&gt;class\methodMaxName Then class\methodMaxName=Len(class\method[i]\name)
		Next
		If class\name="objb3d_class__"	;Doesn't have its own methods as such
			For method=Each ObjMethod
				If method\cMethod
					If method\noArgs&gt;class\methodMaxArgs Then class\methodMaxArgs=method\noArgs
				EndIf
			Next
		EndIf
		If class\methodMaxArgs&gt;cMethod Then cMethod=class\methodMaxArgs
	Next
	
	WriteLine fileOut,"; General message handling"
	WriteLine fileOut,";------------------------------------------"
	WriteLine fileOut,""
	outLine="Function PassMessage_Generic__(objIntPtr%,msg%"
	For i=1 To cMethod-1
		outLine=outLine+",arg"+i+"=0"
	Next
	outLine=outLine+")"
	WriteLine fileOut,outLine
	WriteLine fileOut,Chr(9)+"Select True"
	For class=Each ObjClass
		If class\private=False
			WriteLine fileOut,Chr(9)+Chr(9)+"Case Object."+class\name+"(objIntPtr)&lt;&gt;Null"
			outLine="Return Message_"+class\name+"__(Object."+class\name+"(objIntPtr),msg"
			For i=1 To class\methodMaxArgs-1
				outLine=outLine+",arg"+i
			Next
			outLine=outLine+")"
			WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+outLine
		EndIf
	Next
	WriteLine fileOut,Chr(9)+"End Select"
	WriteLine fileOut,"End Function":WriteLine fileOut,""
	WriteLine fileOut,";------------------------------------------"
	WriteLine fileOut,""
	
	While lexTokenType&lt;&gt;tt_EOF
		LEX_ExpectToken("function")
		For method=Each ObjMethod
			If LEX_CheckToken(Lower(method\globalName)) Then Exit		;Get the method
		Next
		While Not lexNewLine	;Skip the rest of the line, we've seen it before
			LEX_NextToken
		Wend
		For i=0 To method\noArgs-1
			If method\argType[i]&gt;3
				var=New ObjVariable
				var\name=method\argName[i]
				var\scope=1
				var\typeRep=method\argType[i]
				class=OBJ_GetTypeDef(method\argType[i])
				If class\final Then var\typeID=var\typeRep:Else var\typeID=1
			EndIf
		Next
		
		method\body=OBJ_FunctionBody(method)
		
		For var=Each ObjVariable
			If var\scope=1 Then Delete var
		Next
	Wend
	
	For class=Each ObjClass
		If class\private=False
			WriteLine fileOut,"; "+class\name
			WriteLine fileOut,";------------------------------------------"
			WriteLine fileOut,""
			
			If Not class\final
				WriteLine fileOut,Chr(9)+"; Dynamic dispatch"
				outLine="Function PassMessage_"+class\name+"__(objIntPtr%,msg%"
				For i=1 To class\methodMaxArgs-1
					outLine=outLine+",arg"+i+"=0"
				Next
				outLine=outLine+")"
				WriteLine fileOut,Chr(9)+outLine
				WriteLine fileOut,Chr(9)+Chr(9)+"Select True"
				
				For deriv=Each ObjClass
					super=deriv\super
					While (super&lt;&gt;Null) And (super&lt;&gt;class)
						super=super\super
					Wend
					If super=class
						WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+"Case Object."+deriv\name+"(objIntPtr)&lt;&gt;Null"
						outLine="Return Message_"+deriv\name+"__(Object."+deriv\name+"(objIntPtr),msg"
						For i=1 To deriv\methodMaxArgs-1
							outLine=outLine+",arg"+i
						Next
						outLine=outLine+")"
						WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+Chr(9)+outLine
					EndIf
				Next
				WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+"Case Object."+class\name+"(objIntPtr)&lt;&gt;Null"
				outLine="Return Message_"+class\name+"__(Object."+class\name+"(objIntPtr),msg"
				For i=1 To class\methodMaxArgs-1
					outLine=outLine+",arg"+i
				Next
				outLine=outLine+")"
				WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+Chr(9)+outLine
				
				WriteLine fileOut,Chr(9)+Chr(9)+"End Select"
				WriteLine fileOut,Chr(9)+"End Function":WriteLine fileOut,""
			EndIf
			
			WriteLine fileOut,Chr(9)+"; Receive messages"
			outLine="Function Message_"+class\name+"__(obj."+class\name+",msg%"
			For i=1 To class\methodMaxArgs-1
				outLine=outLine+",arg"+i+"=0"
			Next
			outLine=outLine+")"
			WriteLine fileOut,Chr(9)+outLine
			
			If class\name&lt;&gt;"objb3d_class__"
				WriteLine fileOut,Chr(9)+Chr(9)+"Select msg"
				For i=0 To class\noMethods-1
					outLine=Chr(9)+Chr(9)+Chr(9)+"Case "+LSet("Selector_"+class\method[i]\name+"__",class\methodMaxName+11)+":Return "
					WriteLine fileOut,OBJ_WriteMethodName(outLine,class\method[i])
				Next
			Else
				WriteLine fileOut,Chr(9)+Chr(9)+"Select True"
				For super=Each ObjClass
					If super\private=False And super&lt;&gt;class
						WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+"Case obj.ObjB3D_Class__ = "+super\name+".ObjB3D_Class__"
						WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+Chr(9)+"Select msg"
						For method=Each ObjMethod
							If method\cMethod And (method\class=super)
								outLine=Chr(9)+Chr(9)+Chr(9)+Chr(9)+Chr(9)+"Case Selector_"+method\name+"__:Return "
								WriteLine fileOut,OBJ_WriteMethodName(outLine,method)
							EndIf
						Next
						WriteLine fileOut,Chr(9)+Chr(9)+Chr(9)+Chr(9)+"End Select"
					EndIf
				Next
			EndIf
			
			WriteLine fileOut,Chr(9)+Chr(9)+"End Select"
			WriteLine fileOut,Chr(9)+"End Function":WriteLine fileOut,""
			
			For method=Each ObjMethod	;Dump class methods
				If method\class=class And method\cMethod=True Then WriteLine fileOut,method\decl+method\body
			Next
			
			For i=0 To class\noMethods-1	;Dump instance methods
				WriteLine fileOut,class\method[i]\decl+class\method[i]\body
			Next
			
			WriteLine fileOut,";------------------------------------------"
			WriteLine fileOut,""
		EndIf
	Next
	
	WriteLine fileOut,";=========================================="
	WriteLine fileOut,"":WriteLine fileOut,""
	
	FreeBank TokenBank
End Function

Function OBJ_WriteMethodName$(outline$,method.ObjMethod)
	Local c,super.ObjClass
	
	If method\rType=1
		outline=outline+method\globalName+"(obj"
	ElseIf method\rType&lt;4
		outline=outline+"Box"+OBJ_GetTypeName(method\rType)+"__( "+method\globalName+"(obj"
	Else
		outline=outline+"Handle ( "+method\globalName+"(obj"
	EndIf
	For c=1 To method\noArgs-1
		If method\argType[c]&gt;3
			super=OBJ_GetTypeDef(method\argType[c])
			If super\final
				outline=outline+",Object."+super\name+"(arg"+c+")"
			Else
				outline=outline+",arg"+c
			EndIf
		Else
			If method\argType[c]&gt;1
				outline=outline+",Unbox"+OBJ_GetTypeName(method\argType[c])+"__(arg"+c+")"
			Else
				outline=outline+",arg"+c
			EndIf
		EndIf
	Next
	outline=outline+")"
	If method\rType&gt;1 Then outline=outline+" )"
	
	Return outline
End Function
</textarea> <br><br></td></tr></table><br>
<a name="993818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> - "Lexer.bb"<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Const src_EOF=$FF

Global SourceBank
Global TokenBank
Global lexToken$,lexTokenType,lexCurrentToken,lexNewLine

Const tt_EOF=1,tt_NAME=2,tt_PUNCT=3,tt_STRINGLITERAL=4,tt_NUMLITERAL=5

Const MAX_SYMBOLS=22
Global codeSymbol$[MAX_SYMBOLS]		;longer symbols must be before a shorter partial match
codeSymbol[0]="&lt;="
codeSymbol[1]="&gt;="
codeSymbol[2]="&lt;&gt;"
codeSymbol[3]="~"
codeSymbol[4]=","
codeSymbol[5]="*"
codeSymbol[6]="/"
codeSymbol[7]="("
codeSymbol[8]=")"
codeSymbol[9]="-"
codeSymbol[10]="+"
codeSymbol[11]="="
codeSymbol[12]="["
codeSymbol[13]="]"
codeSymbol[14]="."
codeSymbol[15]="&lt;"
codeSymbol[16]="&gt;"
codeSymbol[17]="^"
codeSymbol[18]=":"
codeSymbol[19]="%"
codeSymbol[20]="#"
codeSymbol[21]="$"
codeSymbol[22]="\"


Function LEX_Tokenise()					;Pre-scan the source to list and classify all tokens
	Local c,SourcePos,SourceLine
	Local i,ptr,pp$,TBsize,neg
	
	SourceLine=1
	TokenBank=CreateBank()
	
	Repeat
		c=PeekByte(SourceBank,SourcePos)
		;Skip whitespace and comments (but tokenise line breaks, for the sake of the error messages)
		Repeat
			TBsize=BankSize(TokenBank)
			While (c&lt;=32)									;Whitespace
				TBsize=BankSize(TokenBank)
				If c=13 Then SourceLine=SourceLine+1
				If c=0		;End of file... this really shouldn't happen if it loaded properly
					CodeError("unexpected end-of-file!",False)
				EndIf
				SourcePos=SourcePos+1
				c=PeekByte(SourceBank,SourcePos)
			Wend
			
			If c=59											;Skip comments
				While c&lt;&gt;0 And (c&lt;&gt;13)
					SourcePos=SourcePos+1
					c=PeekByte(SourceBank,SourcePos)
				Wend
				If c=13 Then SourceLine=SourceLine+1
				SourcePos=SourcePos+1
				c=PeekByte(SourceBank,SourcePos)
			Else
				Exit
			EndIf
		Forever
		
		;Tokenise text
		TBsize=BankSize(TokenBank)
		Select True
			Case c=src_EOF	;End of file
				ResizeBank(TokenBank,TBsize+16)
				PokeInt TokenBank,TBsize,SourcePos
				PokeInt TokenBank,TBsize+4,1
				PokeInt TokenBank,TBsize+8,tt_EOF
				PokeInt TokenBank,TBsize+12,SourceLine
				Exit;Return
				
			Case c=34		;String literal
				ptr=1
				pp=""
				Repeat
					c=PeekByte(SourceBank,SourcePos+ptr)
					ptr=ptr+1
					If c=0 Then CodeError("unexpected EOF inside quote",False)
					If c=13 Then CodeError("newline inside quote",False)
					If (c&lt;&gt;34) Then pp=pp+Chr(c)
				Until c=34
				ResizeBank(TokenBank,TBsize+16)
				PokeInt TokenBank,TBsize,SourcePos;+1	;Probably we don't want to remove the quotes
				PokeInt TokenBank,TBsize+4,ptr;-2
				PokeInt TokenBank,TBsize+8,tt_STRINGLITERAL
				PokeInt TokenBank,TBsize+12,SourceLine
				SourcePos=SourcePos+ptr
				
			Case (c&gt;=48 And c&lt;=57) Or (c=46 And PeekByte(SourceBank,SourcePos+1)&gt;=48 And PeekByte(SourceBank,SourcePos+1)&lt;=57)	;Decimal numbers
				ptr=0
				pp=""
				
				While ((c&gt;=48 And c&lt;=57) Or c=46)
					pp=pp+Chr(c)
					ptr=ptr+1
					c=PeekByte(SourceBank,SourcePos+ptr)
				Wend
				
				If PeekInt(TokenBank,TBsize-8)=tt_PUNCT
					If PeekByte(SourceBank,PeekInt(TokenBank,TBsize-16))=45		;Previous token is a minus... subtraction or negative?
						If SourceLine&gt;PeekInt(TokenBank,TBsize-4)
							neg=True
						Else
							If Not(PeekInt(TokenBank,TBsize-24)=tt_NAME Or PeekInt(TokenBank,TBsize-24)=tt_NUMLITERAL Or (PeekInt(TokenBank,TBsize-24)=tt_PUNCT And (PeekByte(SourceBank,PeekInt(TokenBank,TBsize-32))=41 Or PeekByte(SourceBank,PeekInt(TokenBank,TBsize-32))=93)))
								neg=True
							EndIf
						EndIf
					EndIf
				EndIf
				
				If neg		;Number is negative - replace previous "-" token with the complete negative number
					PokeInt TokenBank,TBsize-12,(SourcePos+ptr)-PeekInt(TokenBank,TBsize-16)
					PokeInt TokenBank,TBsize-8,tt_NUMLITERAL
					PokeInt TokenBank,TBsize-4,SourceLine
					SourcePos=SourcePos+ptr
					neg=False
				Else		;Number is not negative, new token.
					ResizeBank(TokenBank,TBsize+16)
					PokeInt TokenBank,TBsize,SourcePos
					PokeInt TokenBank,TBsize+4,ptr
					PokeInt TokenBank,TBsize+8,tt_NUMLITERAL
					PokeInt TokenBank,TBsize+12,SourceLine
					SourcePos=SourcePos+ptr
				EndIf
				
			Case (c=36 Or c=37) And ((PeekByte(SourceBank,SourcePos+1)&gt;=48 And PeekByte(SourceBank,SourcePos+1)&lt;=57) Or (PeekByte(SourceBank,SourcePos+1)&gt;=65 And PeekByte(SourceBank,SourcePos+1)&lt;=70) Or (PeekByte(SourceBank,SourcePos+1)&gt;=97 And PeekByte(SourceBank,SourcePos+1)&lt;=102))
				ptr=0
				pp=""
				
				While (c=36 Or c=37 Or (c&gt;=48 And c&lt;=57) Or (c&gt;=65 And c&lt;=70) Or (c&gt;=97 And c&lt;=102))
					pp=pp+Chr(c)
					ptr=ptr+1
					c=PeekByte(SourceBank,SourcePos+ptr)
				Wend
				
				ResizeBank(TokenBank,TBsize+16)
				PokeInt TokenBank,TBsize,SourcePos
				PokeInt TokenBank,TBsize+4,ptr
				PokeInt TokenBank,TBsize+8,tt_NUMLITERAL	;Hex/binary
				PokeInt TokenBank,TBsize+12,SourceLine
				SourcePos=SourcePos+ptr
				
			Case (c&gt;=97 And c&lt;=122) Or (c&gt;=65 And c&lt;=90) Or c=95	;Names
				ptr=0
				While ((c&gt;=97 And c&lt;=122) Or (c&gt;=65 And c&lt;=90) Or c=95 Or (c&gt;=48 And c&lt;=57))
					If (c&gt;=65 And c&lt;=90) Then PokeByte SourceBank,SourcePos+ptr,c+32	;Change names into lower case
					ptr=ptr+1
					c=PeekByte(SourceBank,SourcePos+ptr)
				Wend
				ResizeBank(TokenBank,TBsize+16)
				PokeInt TokenBank,TBsize,SourcePos
				PokeInt TokenBank,TBsize+4,ptr
				PokeInt TokenBank,TBsize+8,tt_NAME
				PokeInt TokenBank,TBsize+12,SourceLine
				SourcePos=SourcePos+ptr
				
			Default		;Other characters
				For i=0 To MAX_SYMBOLS
					pp=""
					For ptr=0 To Len(codeSymbol[i])-1
						pp=pp+Chr(PeekByte(SourceBank,SourcePos+ptr))
					Next
					If pp=codeSymbol[i]
						ResizeBank(TokenBank,TBsize+16)
						PokeInt TokenBank,TBsize,SourcePos
						PokeInt TokenBank,TBsize+4,Len(codeSymbol[i])
						PokeInt TokenBank,TBsize+8,tt_PUNCT
						PokeInt TokenBank,TBsize+12,SourceLine
						Exit
					EndIf
				Next
				If i&gt;MAX_SYMBOLS Then CodeError("unrecognised operator "+Chr(34)+pp+Chr(34),False)
				SourcePos=SourcePos+Len(codeSymbol[i])
		End Select
		
	;	SourcePos=SourcePos+1
	Until SourcePos=BankSize(SourceBank)
;	
;	For i=0 To BankSize(TokenBank)/16-1
;		LEX_FetchToken(i)
;		DebugLog lexToken
;	Next
;	
;	Stop
End Function

Function LEX_FetchToken(index)			;Fetch a specific token by index, from the token list
	Local i,startpos=PeekInt(TokenBank,index*16)
	Local length=PeekInt(TokenBank,(index*16)+4)
	
	lexToken=""
	For i=0 To length-1
		lexToken=lexToken+Chr(PeekByte(SourceBank,startpos+i))
	Next
	lexTokenType=PeekInt(TokenBank,(index*16)+8)
End Function

Function LEX_NextToken()				;Gets the next (valid) token from the token list
	Local oldLineNum,newLineNum
	
	oldLineNum=PeekInt(TokenBank,lexCurrentToken*16+12)
	If lexCurrentToken&lt;BankSize(TokenBank)/16-1 Then lexCurrentToken=lexCurrentToken+1
	LEX_FetchToken(lexCurrentToken)
	newLineNum=PeekInt(TokenBank,lexCurrentToken*16+12)
	
	lexNewLine=Not(oldLineNum=newLineNum)	;True if the new token is also on a new line, otherwise false
End Function

Function LEX_CheckToken(chk$)			;Returns True and gets the next token if the current token equals string
	If chk=lexToken					;Returns False and does nothing otherwise
		LEX_NextToken
		Return True
	Else
		Return False
	EndIf
End Function

Function LEX_ExpectToken(chk$)			;Issues an error if the current token isn't equal to chk$, gets the next token if it is
	If chk&lt;&gt;lexToken
		CodeError("expected "+Chr(34)+chk+Chr(34)+", found "+Chr(34)+lexToken+Chr(34))
	EndIf
	LEX_NextToken
End Function

Function LEX_WriteToken(stream,newLine=True)		;Dump the current token to the specified temp stream and get the next one
	Local i
	
	For i=1 To Len(lexToken)
		WriteByte stream,Asc(Mid(lexToken,i,1))
	Next
	WriteByte stream,32		;Add a space - B3D won't mind if the syntax was valid before
	;WriteShort stream,$A0D
	
	LEX_NextToken
	If lexNewLine
		If newLine Then WriteShort stream,$A0D		;If there's a newline, write that (CRLF) too
	EndIf
End Function
</textarea> <br><br></td></tr></table><br>
<a name="993819"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> - "PPh.bb" (updated)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Type PP_Macro			;As defined with #define. No regular expressions, just cut and paste
	Field tok$			;Constant token to use in source
	Field def$			;Definition
End Type


Const PP_COMMAND$ = "#"
Const PP_CMDLEN = 1		; = Len(PP_COMMAND)
Const PP_DEBUGMODE$ = "_DEBUG"


Function PP_EvalDirective(directive$)		;Evaluate an #if directive
	Local lArg$,op$,rArg$,i,m.PP_Macro
	
	i=Instr(directive," ")
	lArg=Trim(Left(directive,i))
	directive=Trim(Mid(directive,i))
	
	i=Instr(directive," ")
	op=Trim(Left(directive,i))
	rArg=Trim(Mid(directive,i))
	
	For m=Each PP_Macro
		If m\tok=lArg Then lArg=m\def
		If m\tok=rArg Then rArg=m\def
	Next
	
	Select op
		Case "=","=="		;On tests for equality, strings will be compared directly so "6.0" != "6" - must be converted if floats are involved
			If Instr(lArg,".") Or Instr(rArg,".")
				Return (Float(lArg) = Float(rArg))
			Else
				Return Lower(lArg)=Lower(rArg)
			EndIf
			
		Case "&lt;&gt;","!="
			If Instr(lArg,".") Or Instr(rArg,".")
				Return (Float(lArg) &lt;&gt; Float(rArg))
			Else
				Return Lower(lArg) &lt;&gt; Lower(rArg)
			EndIf
			
		Case "&lt;"			;On tests that imply numerical value, strings will be automagically converted!
			Return lArg &lt; rArg
			
		Case "&gt;"
			Return lArg &gt; rArg
			
		Case "&lt;="
			Return lArg &lt;= rArg
			
		Case "&gt;="
			Return lArg &gt;= rArg
			
	End Select
End Function

Function PP_AbsoluteFileName$(filename$)		;If a filename is relative, convert it to an absolute path
	Local temppath$,i
	
	If Mid(filename,2,1)=":"
		Return filename		;If the second character is a colon it's a drive name which means absolute path - no change
	ElseIf Left(filename,2)=".."
		temppath=Left(inputfilepath,Len(inputfilepath)-1)	;Includes are one level up
		For i=Len(temppath) To 1 Step -1
			If Mid(temppath,i,1)="\" Or Mid(temppath,i,1)="/"
				temppath=Left(temppath,i)
				Return temppath+filename
			EndIf
		Next
	Else
		Return inputfilepath+filename	;Attach the local space to the name
	EndIf
End Function
</textarea> <br><br></td></tr></table><br>
<a name="993820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> - "StdDef.bb"<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Function DEF_IncludeStdDefs(inputFile$,outputFile$)
	Local defsFile,defsLine$,bank,file
	
	;If FileType(GetEnv("blitzpath")+"\tmp\objb3d_stddef.bb")=0
	;	defsFile=WriteFile(GetEnv("blitzpath")+"\tmp\objb3d_stddef.bb")
	If FileType("objb3d_stddef.bb")=0
		defsFile=WriteFile("objb3d_stddef.bb")
		Restore StandardDefinitions
		Read defsLine
		While defsLine&lt;&gt;"End of Standard Definitions"
			WriteLine defsFile,Replace(defsLine,"|",Chr(34))	;Due to technical restrictions, chr(34) can never appear in data statements
			Read defsLine
		Wend
		CloseFile defsFile
	EndIf
	
	bank=CreateBank(FileSize(inputFile))		;Add an include to the top of the processed output
	
	file=ReadFile(inputFile)
	ReadBytes bank,file,0,BankSize(bank)
	CloseFile file
	file=WriteFile(outputFile)
	WriteLine file,""
	WriteLine file,"Include "+Chr(34)+"objb3d_stddef.bb"+Chr(34)
	WriteLine file,""
	WriteBytes bank,file,0,BankSize(bank)
	CloseFile file
	
	FreeBank bank
End Function

Function DEF_LoadStdDefs()
	Local class.ObjClass
	
	class=New ObjClass
	class\name="objb3d_boxint__"
	class\ID=-1:class\base=True:class\final=True:class\private=True
	
	class=New ObjClass
	class\name="objb3d_boxflt__"
	class\ID=-1:class\base=True:class\final=True:class\private=True
	
	class=New ObjClass
	class\name="objb3d_boxstr__"
	class\ID=-1:class\base=True:class\final=True:class\private=True
	
	class=New ObjClass
	class\name="objb3d_class__"
	class\ID=-1:class\base=True:class\final=True;:class\private=True
	
	class=New ObjClass
	class\name="objb3d_selector__"
	class\ID=-1:class\base=True:class\final=True:class\private=True
End Function

.StandardDefinitions

Data ""
Data ";=========================================="
Data ";Box classes"
Data ";=========================================="
Data ""
Data ";Float"
Data "Global ObjB3D_FloatBox__"
Data ""
Data "Function BoxFlt__%(fVal__#)"
Data "    PokeFloat ObjB3D_FloatBox__,0,fVal__"
Data "    Return PeekInt(ObjB3D_FloatBox__,0)"
Data "End Function"
Data ""
Data "Function UnboxFlt__#(fBoxH__)"
Data "    PokeInt ObjB3D_FloatBox__,0,fBoxH__"
Data "    Return PeekFloat(ObjB3D_FloatBox__,0)"
Data "End Function"
Data ""
Data ";String"
Data "Type ObjB3D_BoxStr__"
Data "    Field sVal$"
Data "End Type"
Data ""
Data "Function BoxStr__%(sVal__$)"
Data "    Local sBox__.ObjB3D_BoxStr__"
Data "    sBox__=Last ObjB3D_BoxStr__"
Data "    sBox__\sVal=sVal__"
Data "    Insert sBox__ Before First ObjB3D_BoxStr__"
Data "    Return Handle(sBox__)"
Data "End Function"
Data ""
Data "Function UnboxStr__$(sBoxH__)"
Data "    Local sBox__.ObjB3D_BoxStr__,sVal__$"
Data "    sBox__=Object.ObjB3D_BoxStr__(sBoxH__)"
Data "    sVal__=sBox__\sVal"
Data "    sBox__\sVal=||"
Data "    Return sVal__"
Data "End Function"
Data ""
Data ";Setup"
Data "Function ObjB3D_Setup_Box_Classes__()"
Data "    Local i,sBox.ObjB3D_BoxStr__"
Data ""
Data "    ObjB3D_FloatBox__=CreateBank(4)"
Data "    Delete Each ObjB3D_BoxStr__"
Data "    For i=1 To 4096        ;If this isn't enough, you're doing it wrong"
Data "        sBox=New ObjB3D_BoxStr__"
Data "    Next"
Data "End Function"
Data ""
Data "ObjB3D_Setup_Box_Classes__"
Data ""
Data ";=========================================="
Data ""
Data ""
Data ";=========================================="
Data ";Meta-classes"
Data ";=========================================="
Data ""
Data "Const OBJB3D_MAX_FIELDS__=1024"
Data "Const OBJB3D_MAX_ARGS__=64"
Data ""
Data ";Class objects"
Data "Type ObjB3D_Class__"
Data "    Field name$"
Data "    Field super.ObjB3D_Class__"
Data "    Field base,final"
Data "    Field noFields%"
Data "    Field fieldName$[OBJB3D_MAX_FIELDS__]"
Data "    Field fieldType%[OBJB3D_MAX_FIELDS__]"
Data "    Field noMethods%"
Data "    Field methodName$[OBJB3D_MAX_FIELDS__]"
Data "    Field methodType%[OBJB3D_MAX_FIELDS__]"
Data "    Field methodSel%[OBJB3D_MAX_FIELDS__]"
Data "End Type"
Data ""
Data ";Method objects"
Data "Type ObjB3D_Selector__"
Data "    Field name$,selID%"
Data "    Field noArgs%"
Data "    Field argName$[OBJB3D_MAX_ARGS__]"
Data "    Field argType%[OBJB3D_MAX_ARGS__]"
Data "End Type"
Data ""
Data ";=========================================="
Data ""
Data "End of Standard Definitions"		;Stop dumping lines out once this is encountered

</textarea><br><br>Sorry for the spamtastic posting. <br><br></td></tr></table><br>
<a name="993876"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >D4NM4N</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting project, good luck with it. :) <br>(although i do have to ask the point when there is Bmax+b3dsdk/minib3d :/ ) <br><br></td></tr></table><br>
<a name="993882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> The point is that a donkey can mimic a horse<br><br>Wasn't that obvious? <br><br></td></tr></table><br>
<a name="994337"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xtremegamr</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> It sounds cool and all, but I have to agree with D4NM4N: is there really a point when there's Bmax? <br><br></td></tr></table><br>
<a name="994339"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well the point is that I for one find this kind of thing both fun and informative (no really - writing this is my idea of relaxation); I'm more interested in the theoretical aspects of programming than actually producing a game any time soon, so in order to fully understand OOP I decided it would be best to try and implement it myself, rather than just be spoonfed by Mark. Sure, if I want to actually <i>use</i> OO and Blitz together I'll go for BlitzMax over this mess every time, but that really isn't the goal here at all.<br><br>Not the usual point of view for this forum, I know, but different people get different things out of programming. I'm a real live CS student so don't expect anything approaching sanity from me... <br><br></td></tr></table><br>
<a name="994347"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> You should write a scripting language then... add whatever features you want... <br><br></td></tr></table><br>
<a name="994357"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I started on one a while back (<a href="http://sites.google.com/site/quicknoodle/" target="_blank">signature link</a>) - actually about half of the above code (the directive preprocessor and the lexer) is ripped straight out of it with very little change. There are a couple of issues I haven't worked out yet (how to compile a switch/case with fallthrough?), but overall it's gone pretty well as well. Actually if I really needed to use OOP in Blitz3D I'd probably use that, since I imagine the necessary boxing/unboxing to allow native functions to receive different types of argument probably eats up any advantage of compiled over interpreted code (and yeah, extra features like "proper" recursion and a GC are always nice). <br><br></td></tr></table><br>
<a name="994500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CodeGit</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why dont you write a parser that will take BLITZMAX code and create Objective-c code for the MAC. Now that would be extremely interesting. iPhone dev????? <br><br></td></tr></table><br>
<a name="1001043"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> UPDATED! (Not because I think anyone cares, but because I don't like leaving public projects unfinished)<br><br>It's now possible to fully integrate Objective-B3D into the Blitz3D toolchain and use it from the IDE!<br><br>Of course, that's not the same as saying it actually works. The changes seem to have highlighted a few issues with the system as it is. For the time being, don't assign anything to Globals in the same line they're declared... will fix this sometime when I have energy...<br><br>While I'm pretty sure it's possible, using Kernel32.dll commands, to do this completely within Blitz3D, I couldn't be bothered to find out how to use them and instead used BlitzMax to interface with blitzcc.exe, because it passes a lot of information through the console and BlitzMax can do this; Blitz3D can't, without extensions. Do note that none of BlitzMax's features are being used to "cheat" in any way on the OOP side - all the mini-application does is provide a link between blitzcc and the code processor via the console.<br><br>Installation instructions are given above, and in the download (http://sites.google.com/site/quicknoodle/other-stuff). As above, I would strongly recommend you make a second installation of Blitz3D to try this out (and if you keep it, to separate objective and procedural projects). This is easier if you <a href="http://www.fungamesfactory.com" target="_blank">use IDEal</a>, as it lets you choose a compiler on the main toolbar. (EDIT: Actually IDEal is weird, not sure this works with it... oh well.)<br><br>The code above is updated to reflect that it is now a "pure" code processor and not expected to interact with blitzcc.exe by itself in any way. Interacting with blitzcc is now handled by the ridiculously short BlitzMax app given here (must be compiled as a console app):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Framework BRL.retro
Import pub.stdc


';=======================================================;
';                                                       ;
';        Objective-B3D - A Blitz3D Pre-processor        ;
';        ---------------------------------------        ;
';                                                       ;
';=======================================================;


AppTitle = "Objective-B3D"


Local args:String
Local i:Int , debug:Int


If AppArgs.length &gt; 2	'If it's actually doing something to source and not just providing info...
		
	For i = 1 To AppArgs.length - 2	'Knock the last one - the source file - off
		args = args + " " + AppArgs[i]
		If AppArgs[i] = "-d" Then debug = 1
	Next
	
	If debug = 1
		system_("ObjB3D " + AppArgs[AppArgs.length - 1] + " -d")	'Debug is the only flag ObjB3D needs to see
	else
		system_("ObjB3D " + AppArgs[AppArgs.length - 1])
	endif
	
	args = args + " objb3d_tmp.bb"	'And replace it with the preprocessed version
else

	For i = 1 To AppArgs.length - 1
		args = args + " " + AppArgs[i]
	Next
	
endif


system_("cmd /c blitzcc_old" + args + " &gt; blitzcc_tempout.txt")


Local file:TStream = ReadFile("c:\Blitz3D\Bin\blitzcc_tempout.txt")

While Not Eof(file)
	Print ReadLine(file)
wend

CloseFile(file)

End

</textarea><br><br>I was considering rewriting the whole thing in BlitzMax (it needs a complete rewrite anyway... it's a mess) but didn't really see the point (and that'd be too much like work).<br><br>Anyway, I hope this is at least useful to someone; failing that, I hope it's interesting or informative. Enjoy! <br><br></td></tr></table><br>
<a name="1001115"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Well the point is that I for one find this kind of thing both fun and informative (no really - writing this is my idea of relaxation); I'm more interested in the theoretical aspects of programming than actually producing a game any time soon, so in order to fully understand OOP I decided it would be best to try and implement it myself, rather than just be spoonfed by Mark. Sure, if I want to actually use OO and Blitz together I'll go for BlitzMax over this mess every time, but that really isn't the goal here at all.<br><br> <br></div><br><br>An interesting read, though I've dabbled in variations of C++ for scripting etc. I've not really had to deal with OOP and the programming I've done has always been rather procedural, so for me, I agree this is something of an aid to learning more on the OO front. <br><br></td></tr></table><br>
<a name="1001193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>(Not because I think anyone cares, ...)<br> <br></div><br><br>I care!<br><br>I don't have the time to try out your work right now, that is one sad thing, but I highly appreciate your work here and will be delighted to try it out when I get back to my B3D project.<br><br>Do you happen to be INTP (I am)? I often find myself suggesting stuff to people and get an o.O-face back :-) I think what you did here is really cool work and the only thing holding it back from becoming main-stream in the blitz community is BlitzMax and its strong OOP support. That doesn't in any way mean that it's not useful though.<br><br>I was thinking in the preprocessor chains of thought a while back concerning B3D to add some kind of reflection or at least serialization support for types, and maybe that could be added somehow into your OOP preprocessor. I'll look into that when(if..) my commitment at work is lessened later on. (fulltime code- and specification-slave atm.). <br><br></td></tr></table><br>
<a name="1030128"></a>

<a name="1051581"></a>

<a name="1082543"></a>

<a name="1084300"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Time to flog a dead horse!<br><br>Objective-B3D has been completely rewritten from scratch. <a href="https://sites.google.com/site/nangdongseng/downloads/Objective-B3Dv2.rar?attredirects=0&amp;d=1" target="_blank"> Click here to download!</a> (Last updated April 2011)<br><br><br>The old version had three huge problems. Firstly, the message syntax was clunky: many people dislike Objective-C but this was even worse. Secondly, and more importantly, because it completely tore apart the project and reorganised it as a single file, the debugger and any error messages from B3D itself were next to useless and as a result error checking was very, very hard.<br><br>The new version has been designed to preserve line numbering, file structure, indentation and comments. As a result, although the code will of course look different it will still be recognisable in the debugger window! All lines are modified "in place" and saved to a file with a slightly decorated name; the "extra" functions needed to dispatch polymorphic calls etc. are all now outputted to a standard file ("objb3d_tmp.bb") - this file includes your project, so that it doesn't mess up the line numbering.<br><br>Thirdly, the syntax was totally incompatible with any existing Blitz IDEs. I have attempted to solve this by relying on a bare minimum of keywords (at some reduced functionality), so that the default B3D IDE will generally be fooled into accepting the code as legitimate. (IDEal is too clever to fool, sadly). My quick tests indicated that it will still work as part of the toolchain from the default IDE, but not from IDEal anyway.<br><br><br>Changes:<br><br> - Messaging rules: message selectors must now be a constant method name <i>valid for the type receiving the message</i>. This means that for polymorphism to work you <i>will</i> need to create an abstract method to inherit (there is no abstract marker... just create an empty method). Dynamic typing or dynamically selected methods are no longer allowed - this improves performance, and fits better with B3D's static/weak typing (I know it kinda detracts from the point of message passing vs. method calling, but it's more suited to the base language).<br><br> - Message syntax: methods are now called with the same syntax as Objective-C, except that parameters cannot be named. ie.:<br><pre class=code>
[myObject myMessage :a :b :c ]
</pre><br><br> - Type syntax: as before, type blocks only describe instance variables, they can extend types with the colon operator, and fields can be marked as private (equivalent to C++/Java "protected") with Private. Public is no longer a keyword, and "super" is now a reserved field name (don't use it). eg.:<br><pre class=code>
Type Animal
    Field name$
End Type

Type Dog : Animal
    Field waggingTail
    Private Field beenFed, beenWalked
End Type
</pre><br>Autogetters and setters are generated for all non-private fields, unless a method with the default name already exists (getters are just named the same as the field, while setters prepend "set", e.g. "setWaggingTail").<br><br> - Class Implementation syntax: this was a big mess before, especially because the IDE can't handle indented functions. Class implementation blocks are now begun and ended with special tags ";+ Class myClass" and ";+ End Class". <b>These are not comments</b> and if you want a comment on that line, you'll need a second semicolon. The choice to make them look like comments is to make them fit in more naturally with the way you might organise your code in a procedural project. Within each class block, functions are written normally (Function name(args) etc.) and instance variables are in scope (so "self" is reserved, and field names will point to the object field, not a local). Type definition blocks can appear in-or-outside class blocks (put them wherever you like!). eg.:<br><pre class=code>
;+ Class Animal

Function Init(newName$)
    name = newName
End Function

;+ End Class

;+ Class Dog

Function Talk()
	Print name+"Arf! Arf!"
End Function

Class Function Create.Dog(newName$)
	Local d.Dog
	d=New Dog
	[d Init:newName]
	Return d
End Function

;+ End Class
</pre><br><br> - Polymorphism: You may not assign objects from variables of one type to another without an explicit cast - and the cast will fail without warning if it's not valid. This is because I didn't want to write a full B3D parser... you should consider redesigning whatever you're doing to use messages instead if this is a frequent issue. (Message recipients never need to be cast if the method is inherited.) eg.:<br><pre class=code>
Local myAnimal.Animal = (Animal) New Dog
doSomethingToAnimal( (Animal) myDog )
</pre><br><br> - Field access: for the same reason, the only guaranteed place to access fields is within a method. In a function or the main program, trying to use \ to access inherited fields will fail, unfortunately. You should use getter and setter methods instead.<br><br> - The global type lists: A lot goes on behind the scenes; if you;re using inheritance, DO NOT rely on First/Last/Before/After to give you expected results, as they may return hidden instances that you didn't explicitly create (don't worry, New and Delete are overridden to cover this).<br><br>As before, double-underscore is used at the end of private names, so stay away from this and you should be fine. Reserved words are: Self, Super, Private, Class (...think that's all). Oh, and source files need to be in Windows format (CRLF line endings) - Unix or Mac format will break everything (if you don't know what this means, you don't need to do anything).<br><br>I haven't tested it thoroughly, but the supplied examples work correctly and it does successfully integrate into the toolchain using the default IDE.<br><br>Enjoy!<br><br><br><b>Disclaimer:</b> As before, this work was undertaken for my own amusement and that of others only. It is not intended as a serious development solution, or to compete with any BRL products. I consider "addressing usability issues" to be <i>part of the fun of making it</i>, and do not seriously expect anyone to actually use this tool.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1030728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Really impressive, Yasha!<br><br>I've only just gooten back to see this, but will have a proper 'fiddle around' with it over the week :)<br><br>I think I can seriously make some use of this! <br><br></td></tr></table><br>
<a name="1053474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Almo</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just want to say that's really cool! <br><br></td></tr></table><br>
<a name="1114509"></a>

<a name="1114510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice job BUT :<br><br>Are you sure you're allowed to publish original "blitzcc.exe" compiler in your archive ?<br>I'm almost sure it is really forbiden as you can pass it any text file you want to run blitz3d (and you always should have a valid license of blitz3d to do that)<br><br><br>ps : I made about the same to achieve OO in blitz3d and got the same problem with IDeal ... really disturbing<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1114519"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh wow someone looked at this!<br><br><div class="quote"> Are you sure you're allowed to publish original "blitzcc.exe" compiler in your archive ? <br></div><br><br>It's not the original blitzcc.exe - it's just a tiny wrapper program that calls Objective-B3D and regular-B3D in order on the source. You have to supply the original blitzcc yourself (the idea is that if the wrapper program is renamed to blitzcc.exe, programs that originally looked for Blitz3D now get this program).<br><br>The reason there are two exes is because the preprocessor (the larger one) is separate from the wrapper, and is supposed to be able to stand alone.<br><br><br>Anyway, don't pay too much attention to this project. It's still got too many bugs to be usable, sadly (actually I did use a cut-down version of it for some commercial code, because it sped up writing boilerplate... but the method syntax doesn't work properly).<br><br>Its successor will be along soon - a real compiler this time, not a B3D-source-generator. Enhanced version of the object system, as well as an aspect system and some other cool stuff (yay, "subject oriented programming"!). <br><br></td></tr></table><br>
<a name="1114531"></a>

<a name="1114533"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It's not the original blitzcc.exe - it's just a tiny wrapper program that calls Objective-B3D and regular-B3D <br></div><br>Ok, so it's just a mistake from me<br>I just have modified the blitzcc with yours (as mentioned in instructions) and I didn't remember, so I did it once again, then they were both (blitzcc and blitzcc_old) the exact same size, then I thought you released the original blitzcc :)<br>happy I've got a backup from blitzcc in an other folder, cause I've overwriten the one from the bin folder &gt;.&lt;<br><br>whatever<br><div class="quote"> Anyway, don't pay too much attention to this project. It's still got too many bugs to be usable, sadly (actually I did use a cut-down version of it for some commercial code, because it sped up writing boilerplate... but the method syntax doesn't work properly). <br></div><br>Don't worry, I just looked for "Fun", it's always interesting to run other stuff like this<br>I already have made my own blitzlike compiler, I found yours very instructive<br>and it might get me some new ideas ;)<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1115569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I enterame that's the thing, but the google translator sucks, does not help me. <br><br></td></tr></table><br>
<a name="1261416"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eNano</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Yasha as a newbie I find this absolutely awesome!, I'm learning to code graphics really slowly and adding complexity to a language like blitz3d helps me a lot to understand some concepts.<br><br>I have 3 questions:<br><br>Is this code safe to use in standard projects like a simple fps or with userlibs like fastlibs and pointers and that stuffs?<br><br>Should this work in Ideal IDE without problem?<br><br>Do I loose some speed in my projects using this?<br><br>I really thanks you for sharing all this stuffs!! <br><br></td></tr></table><br>
<a name="1261419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> No, this code is not safe to use in practice. As I touched on above, it actually emits buggy generated code. I don't think this can actually be of any practical use to someone who isn't deeply familiar with it and able to hand-patch code as they go (which is what I did on the one project where I used it). It also didn't work with IDEal.<br><br>I wrote this back before I bothered to learn how to write parsers/compilers properly. As a result it's a complete mess and would have to be redesigned (again) from the ground up (even if I hadn't completely forgotten about it or how it works!).<br><br>There is a minor speed hit to the generated code but unless you go completely crazy with objects, it's nothing major (and probably the equivalent of what you;d have to do to get polymorphic behaviour anyway).<br><br>I'm honoured by your interest in the project, but it's really not complete or usable as it is. I wouldn't bother with it if I were you. (If you really want to learn, you might even do better to recreate it yourself without looking at this version.)<br><br><br>If there's genuine interest in using a language like this one I might rewrite it fully sometime in the future (now that B3D is open-source, it could be a complete standalone project). But I think you'd find BlitzMax more appealing. <br><br></td></tr></table><br>
<a name="1261420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eNano</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks a lot for your answer I guess I could try what you suggest. I just found blitz3d an amazing lightweight and simple tool for prototyping 3d applications for people like me who only had time to learn Basic. I still find some concepts really abstract in more powerful programs like blitzmax but I guess I will have to take a deeper look it.<br>If you have time to play with this in the future you will make a lot of newbies really happy :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
