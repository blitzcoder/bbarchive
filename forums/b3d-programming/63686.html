<!DOCTYPE html><html lang="en" ><head ><title >Texture Map Correction for spherical mapping</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Texture Map Correction for spherical mapping</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Texture Map Correction for spherical mapping</a><br><br>
<a name="710827"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I have a generated texture map (planet surface) in mercator-style projection applied to a sphere. The problem is that the texture distorts at the poles. I have seen textures of planets/moons of our solar system where the texture has been modified and there is no more distortion at the poles (like here: <a href="http://www.mmedia.is/bjj/planetary_maps.html" target="_blank">http://www.mmedia.is/bjj/planetary_maps.html</a> ).<br><br>Any Idea how to do this modification in blitzbasic? The idea behind is a procedural universe with random planets / no file-based heightmaps, everything is being generated on the fly.<br><br>Here is a example planet texture:<br><img src="http://www.christianhart.de/bb/planet1.png"><br><br>The algorithm should produce a map like this:<br><img src="http://www.christianhart.de/bb/planet2.png"><br><br>The examples are generated with a DOS tool by Torben Mogensen (grab it here: <a href="http://www.diku.dk/~torbenm/" target="_blank">http://www.diku.dk/~torbenm/</a> ), which can generate a "square projection" map (Example 2) which fits my needs, but unfortunately the planet.exe must be in a path only with DOS compatible 8.3 parent directories :-( But i won't use this tool, I have my own perlin-based algorithm for planet surface generation which is way faster.<br><br>Can anybody read/transform the square projection C-Code from this planet generator into Blitz code? I really don't understand Torbens code and need help. Thanks. <br><br></td></tr></table><br>
<a name="710860"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mustang</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you have Photoshop here's a plug-in that does the same thing:<br><br><div class="quote"> <br>Spherical Mapping Corrector<br><br>This filter produces texture map correction for spherical texture mapping. Special thanks to Paul Bourke for allowing his algorithm to be ported to this plugin. For more information, please visit Mr. Bourke's site at Mr. Bourke'sCurrent Version v1.2<br> <br></div><br><br><a href="http://www.richardrosenman.com/software/downloads/" target="_blank">http://www.richardrosenman.com/software/downloads/</a><br><br><div class="quote"> <br>It stretches the top and bottom of an image horizontally more than the center of the image so that the top and bottom don't create a "pinched" look at the poles. The results are not necessarily mathematically accurate. <br> <br></div> <br><br></td></tr></table><br>
<a name="710874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know this tool, but I won't preprocess the heightmaps, I want to calculate the new maps in BB (imagine 100 stars with approx. 5 planets each = 500 heightmaps, doh!). And if you try to stretch the upper map with this tool and put the new map on  a sphere it won't fit anymore at the sides.<br><br>Torbens planet generator has the solution but I don't understand his source code (the squarep() function). <br><br></td></tr></table><br>
<a name="710875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's some pseudocode from: <a href="http://local.wasp.uwa.edu.au/~pbourke/texture/polargrid/" target="_blank">http://local.wasp.uwa.edu.au/~pbourke/texture/polargrid/</a><br><br><pre class=code>   double theta,phi,phi2;
   int i,i2,j;
   BITMAP *imagein,*imageout;

   Form the input and output image arrays
   Read an input image from a file

   for (j=0;j&lt;image.height;j++) {
      theta = PI * (j - (image.height-1)/2.0) / (double)(image.height-1);
      for (i=0;i&lt;image.width;i++) {
         phi  = TWOPI * (i - image.width/2.0) / (double)image.width;
         phi2 = phi * cos(theta);
         i2  = phi2 * image.width / TWOPI + image.width/2;
         if (i2 &lt; 0 || i2 &gt; image.width-1) {
            newpixel = red;                         /* Should not happen */
         } else {
            newpixel = imagein[j*image.width+i2];
         }
         imageout[j*image.width+i] = image.newpixel;
      }
   }

   Do something with the output image</pre>Share your code when you're done!<br><br>Also, you could combine your map generation and polar correction in the same loop to speed things up.  In other words calculate each map pixel and polar-correct it as you go.<br><br>Mike <br><br></td></tr></table><br>
<a name="710886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Morbius, sorry I forgot to mention that I know this site and tried to write the code in Blitzbasic. But there is something wrong, running my code gives an exact copy of the original image, and I dont know why LOL!<br><br>On the other hand, if I take an image from this site and put it on a sphere, the X axis sides doesn't match anymore.<br><br>Here's my code attempt:<br><br><pre class=code>
Graphics 512,513,32,2 

width=512
height=256
twopi#=2*Pi


;read image to array
Dim col(width,height) 


;load source image
raster=LoadImage("raster.png") 


;get color data from source image
SetBuffer ImageBuffer(raster) 
LockBuffer ImageBuffer(raster) 
For x=0 To width-1 
	For y=0 To height-1 
		col(x,y)=ReadPixelFast(x,y)
	Next 
Next 
UnlockBuffer ImageBuffer(raster) 


;create a new image
test=CreateImage(width,height)


;algorithm
SetBuffer ImageBuffer(test) 
LockBuffer ImageBuffer(test) 
For j=0 To height-1 
	theta#=Pi*(j-(height-1)/2.0)/(height-1) 
	For i=0 To width-1 
		phi#=twopi#*(i-width/2.0)/width 
		phi2#=phi#*Cos(theta#) 
		i2#=phi2#*width/twopi#+width/2 
		rgb=col(i,j) 
		WritePixelFast i2#,j,rgb 
	Next 
Next 
UnlockBuffer ImageBuffer(test) 
SetBuffer FrontBuffer() 


;draw results
DrawImage raster,0,0 
DrawImage test,0,height+1 


;red divider line
Color 255,0,0 
Line 0,256,512,256 


WaitKey 


End
</pre><br><br>The raster image i used is here:<br><br><img src="http://www.christianhart.de/bb/raster.png"> <br><br></td></tr></table><br>
<a name="710894"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >b32</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think the problem itself is the difference between blitz' cos/sin and c++ cos/sin.<br>In Blitz, cos/sin use degrees and in C++, radians.<br>The conversion between them is * pi / 180, but I don't remeber which way around, so you might need to invert it.<br>And I would make all variables float, so that when you use them in a division, the outcome will not become an integer. <br><br></td></tr></table><br>
<a name="710896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jeppe Nielsen</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> You switched two variables, and forgot to convert from radians to degrees.<br><br>Anyway, here you go:<br><pre class=code>
Graphics 512,513,32,2 

imagefile$="raster.png"

;load source image
raster=LoadImage(imagefile$) 

width=ImageWidth(raster)
height=ImageHeight(raster)
twopi#=2*Pi

;read image to array
Dim col(width,height) 

;get color data from source image
SetBuffer ImageBuffer(raster) 
LockBuffer ImageBuffer(raster) 
For x=0 To width-1 
	For y=0 To height-1 
		col(x,y)=ReadPixelFast(x,y)
	Next 
Next 
UnlockBuffer ImageBuffer(raster) 


;create a new image
test=CreateImage(width,height)


;algorithm
SetBuffer ImageBuffer(test) 
LockBuffer ImageBuffer(test) 
For j=0 To height-1 
	theta#=Pi*(j-(height-1)/2.0)/(height-1) 
	For i=0 To width-1 
		phi#=twopi#*(i-width/2.0)/width 
		phi2#=phi#*Cos(theta#*(180.0/Float(Pi))) 
		i2#=phi2#*width/twopi#+width/2 
		rgb=col(i2,j)
		WritePixelFast i,j,rgb 
	Next 
Next 
UnlockBuffer ImageBuffer(test) 
SetBuffer FrontBuffer() 


;draw results
DrawImage raster,0,0 
DrawImage test,0,height+1 


;red divider line
Color 255,0,0 
Line 0,256,512,256 


WaitKey 


End
</pre> <br><br></td></tr></table><br>
<a name="710912"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jeppe, nice one :-) There is still one issue i mentioned before: the X axis sides doesn't match, here is a 3D test for it:<br><br><pre class=code>
Graphics3D 512,513,32,2 

imagefile$="planet1.png"

;load source image
raster=LoadImage(imagefile$) 

width=ImageWidth(raster)
height=ImageHeight(raster)
twopi#=2*Pi

;read image to array
Dim col(width,height) 

;get color data from source image
SetBuffer ImageBuffer(raster) 
LockBuffer ImageBuffer(raster) 
For x=0 To width-1 
	For y=0 To height-1 
		col(x,y)=ReadPixelFast(x,y)
	Next 
Next 
UnlockBuffer ImageBuffer(raster) 


;create a new image
test=CreateImage(width,height)


;algorithm
SetBuffer ImageBuffer(test) 
LockBuffer ImageBuffer(test) 
For j=0 To height-1 
	theta#=Pi*(j-(height-1)/2.0)/(height-1) 
	For i=0 To width-1 
		phi#=twopi#*(i-width/2.0)/width 
		phi2#=phi#*Cos(theta#*(180.0/Float(Pi))) 
		i2#=phi2#*width/twopi#+width/2 
		rgb=col(i2,j)
		WritePixelFast i,j,rgb 
	Next 
Next 
UnlockBuffer ImageBuffer(test) 
SetBuffer FrontBuffer() 


;draw results
;DrawImage raster,0,0
;DrawImage test,0,height+1 


;red divider line
;Color 255,0,0 
;Line 0,256,512,256 

SaveImage test,"planet.bmp"

planet=CreateSphere(32)
tex=LoadTexture("planet.bmp")
;test it with this line
;tex=LoadTexture("planet2.png")
EntityTexture planet,tex

cam=CreateCamera()
PositionEntity cam,0,0,2
MoveMouse 256,256
PointEntity cam,planet

While Not KeyHit(1)

TurnEntity planet,0.5,0.25,0.5

RenderWorld

Flip

Wend


End
</pre><br><br>to see how it should look just remove the comment before entitytexture (you need planet1.png / planet2.png, the two examples from the beginning) <br><br></td></tr></table><br>
<a name="710925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll have a look tonight.  I'm sure you're on the right track. <br><br></td></tr></table><br>
<a name="711036"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, which projection are you using to make the original map?  And the "corrected" map?<br><br>Give me the commandline arguments you are using if you can.<br><br>The original flat map you posted appears to be truncated at the top and bottom.  Entire sections of map are missing that do not appear in the spherical version.  This is what is leading you to conclude that your code is wrong when in fact it is fine.<br><br>Thanks<br><br>Mike <br><br></td></tr></table><br>
<a name="711054"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> this is what i got. it basically lowers the amount of distortion, but results in problems at the poles.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 512,513,32,2 

imagefile$="planet1.png"

;load source image
raster=LoadImage(imagefile$) 

width=ImageWidth(raster)
height=ImageHeight(raster)
twopi#=2*Pi

;read image to array
Dim col(width,height) 

;get color data from source image
SetBuffer ImageBuffer(raster) 
LockBuffer ImageBuffer(raster) 
For x=0 To width-1 
	For y=0 To height-1 
		col(x,y)=ReadPixelFast(x,y)
	Next 
Next 
UnlockBuffer ImageBuffer(raster) 


;create a new image
test=CreateImage(width,height)


;algorithm
SetBuffer ImageBuffer(test) 
LockBuffer ImageBuffer(test) 
For j=0 To height-1 
	theta#=Pi*(j-(height-1)/2.0)/(height-1) 
	For i=0 To width-1 
		chheight#=Cos(j/(height/Float(180))) ;1..0..1
		chwidth#=Sin(i/(width/Float(180))) ;0..1..0
		chd#=180.0*(chheight#*chwidth#) ;change distortion amount
		phi#=twopi#*(i-width/2.0)/width 
		phi2#=phi#*Cos(theta#*(chd#/Float(Pi))) 
		i2#=phi2#*width/twopi#+width/2 
		rgb=col(i2,j)
		WritePixelFast i,j,rgb 
	Next 
Next 
UnlockBuffer ImageBuffer(test) 
SetBuffer FrontBuffer() 


;draw results
;DrawImage raster,0,0
;DrawImage test,0,height+1 


;red divider line
;Color 255,0,0 
;Line 0,256,512,256 

SaveImage test,"planet.bmp"

planet=CreateSphere(32)
tex=LoadTexture("planet.bmp")
;test it with this line
;tex=LoadTexture("planet2.png")
EntityTexture planet,tex

cam=CreateCamera()
PositionEntity cam,0,0,2
MoveMouse 256,256
PointEntity cam,planet

While Not KeyHit(1)

TurnEntity planet,0.3,0.1,0.1

RenderWorld

Flip

Wend


End
</textarea> <br><br></td></tr></table><br>
<a name="711097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Morbius, the commandline for this planet is exactly<br><br>planet.exe -pq -M terra.rgb -i -0.01 -s 0.1 -w 512 -h 256 -o planet.bmp<br><br>the switch -pq calculates the square projection (example 2), changing this to -pm you'll get mercator projection (example 1), oh and terra.rgb is a simple text file:<br><br>#333399<br>#6666cc<br>#009900<br>#E8A45A<br>#F8B45C<br>#A5806C<br>#FFFFFF<br>#000000<br>#000000 <br><br>EDIT: here is an animation of the two maps - Morbius you're right, it seems that the map is cut off slightly at the poles in mercator projection mode. The distortion looks like if it increases from equator to poles in an exponential?!? curve:<br><br><img src="http://www.christianhart.de/bb/planet_torben.gif"><br><br>But even if I take another map it doesn't gets seamless. I've made a small GIF animation to see the difference:<br><br><img src="http://www.christianhart.de/bb/planet_animation.gif"><br><br>markcw, if I take your code and use the same image we can see the difference, the distortion is not strong enough:<br><br><img src="http://www.christianhart.de/bb/planet_markcw.gif"><br><br>I think we should extract the wisdom from Torbens C code because he knew how to do the trick :-|<br><br>My final pseudorandom generated world could look like this (needs more finetuning, first attempt of atmosphere):<br><br><img src="http://www.christianhart.de/bb/planet.png"> <br><br></td></tr></table><br>
<a name="711130"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi Krischan, yes with that algorithm it seems to "push" the data off the map, as can be seen in your gifs. so i guess you're right, it needs the squarep algorithm. i'll have a go at it. what is that algorithm by the way?<br><br>edit: sorry missed the link to that article. <br><br></td></tr></table><br>
<a name="711173"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi markcw,<br><br>the algorithm is this C code (include in Torbens planet generator, see the link in my first post):<br><br>void squarep()<br>{<br>  double y,scale1,theta1,cos2, log_2();<br>  int k,i,j, planet0();<br><br>  k = (int)(lat*Width*scale/PI);<br>  for (j = 0; j &lt; Height; j++) {<br>    if (debug &amp;&amp; ((j % (Height/25)) == 0)) {fprintf (stderr, "%c", view); fflush(stderr);}<br>    y = (2.0*(j-k)-Height)/Width/scale*PI;<br>    if (fabs(y)&gt;=0.5*PI) for (i = 0; i &lt; Width ; i++) {<br>      col[i][j] = BACK;<br>      if (doshade) shades[i][j] = 255;<br>    } else {<br>      cos2 = cos(y);<br>      if (cos2&gt;0.0) {<br>	scale1 = scale*Width/Height/cos2/PI;<br>	Depth = 3*((int)(log_2(scale1*Height)))+3;<br>	for (i = 0; i &lt; Width ; i++) {<br>	  theta1 = longi-0.5*PI+PI*(2.0*i-Width)/Width/scale;<br>	  col[i][j] = planet0(cos(theta1)*cos2,sin(y),-sin(theta1)*cos2);<br>	  if (doshade) shades[i][j] = shade;<br>	}<br>      }<br>    }<br>  }<br>  if (hgrid != 0.0) { /* draw horisontal gridlines */<br>    for (theta1 = 0.0; theta1&gt;-90.0; theta1-=hgrid);<br>    for (theta1 = theta1; theta1&lt;90.0; theta1+=hgrid) {<br>      y = DEG2RAD*theta1;<br>      j = Height/2+(int)(0.5*y*Width*scale/PI)+k;<br>      if (j&gt;=0 &amp;&amp; j&lt;Height) for (i = 0; i &lt; Width ; i++) col[i][j] = BLACK;<br>    }<br>  }<br>  if (vgrid != 0.0) { /* draw vertical gridlines */<br>    for (theta1 = 0.0; theta1&gt;-360.0; theta1-=vgrid);<br>    for (theta1 = theta1; theta1&lt;360.0; theta1+=vgrid) {<br>      i = (int)(0.5*Width*(1.0+scale*(DEG2RAD*theta1-longi)/PI));<br>      if (i&gt;=0 &amp;&amp; i&lt;Width)<br>	for (j = max(0,Height/2-(int)(0.25*PI*Width*scale/PI)+k);<br>	     j &lt; min(Height,Height/2+(int)(0.25*PI*Width*scale/PI)+k); j++)<br>	  col[i][j] = BLACK;<br>    }<br>  }<br>}<br><br>Notes on this code I found out:<br><br>- lat/longi is 0.0 (I guess)<br>- scale is 1.0<br>- log_2 is log(x)/log(2.0)<br>- the "Depth" isn't used and makes no sense<br>- col[x][y] contains the final map data (is being calculated by squarep)<br>- we don't need shades<br>- we don't need grids<br><br>So we can shorten the code to:<br><br>void squarep()<br>{<br>  double y,scale1,theta1,cos2, log_2();<br>  int k,i,j, planet0();<br><br>  k = (int)(lat*Width*scale/PI);<br>  for (j = 0; j &lt; Height; j++) {<br>    y = (2.0*(j-k)-Height)/Width/scale*PI;<br>    if (fabs(y)&gt;=0.5*PI) for (i = 0; i &lt; Width ; i++) {<br>      col[i][j] = BACK;<br>      cos2 = cos(y);<br>      if (cos2&gt;0.0) {<br>	scale1 = scale*Width/Height/cos2/PI;<br>	for (i = 0; i &lt; Width ; i++) {<br>	  theta1 = longi-0.5*PI+PI*(2.0*i-Width)/Width/scale;<br>	  col[i][j] = planet0(cos(theta1)*cos2,sin(y),-sin(theta1)*cos2);<br>      }<br>    }<br>  }<br>}<br><br>What I don't understand is the call of planet0(x,y,z), I think the code calculates somehow the planet surface color for a given x,y,z coordinate and distorts the value from this position to the final image. But this function is very confusing to me. <br><br></td></tr></table><br>
<a name="711193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for posting.  I'll have a look tonight.  Judging by the animated gif, (very helpful!) it appears that it is just squeezing the lattitude as a proportion of the circumference of the circle at some lattitude to the circumference of the equator.<br><br>To find the circumference at a given lattitude:  C = E * Cos(L)<br><br>Where:<br><br>E is the circumference at the equator<br>L is the lattitude (O at the equator, 1 at the poles)<br><br>It's hard to tell exactly what is going on at the poles since they are truncated in the original map.  I'll check out the algorithm above and see if I can get a clue.  It looks like it's squeezing (vertical) as described above, then doing a little stretching (horizontal) (near poles?)<br><br>Thanks<br><br>Mike <br><br></td></tr></table><br>
<a name="711279"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi Krischan, yeah i looked at the planet.c code but i couldn't understand the planet functions either. but i went back to the other algorithm and ended up rewriting it. the theory is you distort according to an arc, but a standard sin arc isn't enough, you need a steep arc. the result of some further tweaking is enough to get what you need i think.<br><br>i have two codes, one for the planet sphere and one for the image to show how the custom sin curve is obtained.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 512,512,0,2

imagefile$="planet1.png"

;load source image
raster=LoadImage(imagefile$) 

width=ImageWidth(raster)
height=ImageHeight(raster)
twopi#=2*Pi

;read image to array
Dim col(width,height) 

;get color data from source image
SetBuffer ImageBuffer(raster) 
LockBuffer ImageBuffer(raster) 
For x=0 To width-1 
	For y=0 To height-1 
		col(x,y)=ReadPixelFast(x,y)
	Next 
Next 
UnlockBuffer ImageBuffer(raster) 

;create a new image
test=CreateImage(width,height)

;algorithm2
SetBuffer ImageBuffer(test) 
LockBuffer ImageBuffer(test)
For j=0 To height-1 
 theta#=Sin(j/(height/Float(180))) ;y_sin 0..1..0
 For i=0 To width-1
  phi#=64 ;level of sin curve distortion
  sin1#=1-((1-theta#)^phi#) ;inverse(inverse_sin^n)
  sin2#=(theta#*((1-theta#)^(phi#/2)))*phi# ;sin*(inverse_sin^n)*n
  i2#=((i-(width/2))*(sin1#-sin2#))+(width/2) ;offset*(sin_product)+mid
  rgb=col(i2,j)
  WritePixelFast i,j,rgb
 Next
Next
UnlockBuffer ImageBuffer(test) 
SetBuffer FrontBuffer() 

;draw results
;DrawImage raster,0,0
;DrawImage test,0,height+1 

;red divider line
;Color 255,0,0 
;Line 0,256,512,256 

SaveImage test,"planet.bmp"

planet=CreateSphere(32)
tex=LoadTexture("planet.bmp")
;test it with this line
;tex=LoadTexture("planet2.png")
EntityTexture planet,tex

cam=CreateCamera()
PositionEntity cam,0,0,2
MoveMouse 256,256
PointEntity cam,planet

While Not KeyHit(1)

 TurnEntity planet,0.2,0.1,0

 RenderWorld

 Flip
Wend
End
</textarea><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 512,512,0,2

imagefile$="raster.png"
imagefile$="planet1.png"

;load source image
raster=LoadImage(imagefile$) 

width=ImageWidth(raster)
height=ImageHeight(raster)
twopi#=2*Pi

;read image to array
Dim col(width,height) 

;get color data from source image
SetBuffer ImageBuffer(raster) 
LockBuffer ImageBuffer(raster) 
For x=0 To width-1 
	For y=0 To height-1 
		col(x,y)=ReadPixelFast(x,y)
	Next 
Next 
UnlockBuffer ImageBuffer(raster) 

;create a new image
test=CreateImage(width,height)

;algorithm2
SetBuffer ImageBuffer(test) 
LockBuffer ImageBuffer(test)

For j=0 To height-1 
 theta#=Sin(j/(height/Float(180))) ;y_sin 0..1..0
 For i=0 To width-1
  phi#=64 ;level of sin curve distortion
  sin1#=1-((1-theta#)^phi#) ;inverse(inverse_sin^n)
  sin2#=(theta#*((1-theta#)^(phi#/2)))*phi# ;sin*(inverse_sin^n)*n
  i2#=((i-(width/2))*(sin1#-sin2#))+(width/2) ;offset*(sin_product)+mid
  rgb=col(i2,j)
  WritePixelFast i,j,rgb
 Next
Next
;draw sin curves
For j=0 To height-1
 theta#=Sin(j/(height/Float(180))) ;y_sin 0..1..0
 phi#=64 ;level of sin curve distortion
 sin1#=1-((1-theta#)^phi#) ;inverse(inverse_sin^n)
 sin2#=(theta#*((1-theta#)^(phi#/2)))*phi# ;sin*(inverse_sin^n)*n
 WritePixelFast theta#*256,j,$00FF00 ;green
 WritePixelFast sin1#*256,j,$0000FF ;blue
 WritePixelFast sin2#*256,j,$FF0000 ;red
 WritePixelFast (sin1#-sin2#)*256,j,$00FFFF ;cyan
Next

UnlockBuffer ImageBuffer(test)
SetBuffer FrontBuffer()

;draw results
DrawImage raster,0,0
DrawImage test,0,height+1

;red divider line
Color 255,0,0
Line 0,256,512,256

WaitKey
End
</textarea> <br><br></td></tr></table><br>
<a name="711283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmmm, seems like a lot of bother... Why not just use a geosphere? That would solve your problems :) <br><br></td></tr></table><br>
<a name="711440"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> markcw, thanks for your nice demonstration, the result is here:<br><br><img src="http://www.christianhart.de/bb/sphere1.png"><br><br>I used a different map (perlin noise with a shaded relief) with more land mass at the north pole, and you can clearly see that the distortion looks strange there. A simple solution would be to have an ocean at the poles, so that the distortion seems to disappear in a single color, but this is only useful for creating Class M planets (think about a pluto-style planet or even jupiter with its clouds).<br><br>Ross C, I already thought about it but the result looks like on a sphere, or do you have another solution or example code/mesh for it? Here is a screenshot with a 32 segment Icosaeder geosphere:<br><br><img src="http://www.christianhart.de/bb/geosphere1.png"><br><br>For both examples I used this new colormap:<br><br><img src="http://www.christianhart.de/bb/colormap.png"><br><br>I think the only useful solution is to translate the *complete* source from Torbens planet generator to Blitzbasic and see if it is working there (without knowing *why* it's working LOL). But I'm afraid that Blitzbasic is not fast enough to calculate the planet in an appropriate time but we'll see (the DOS program is not that fast already).<br><br>Any suggestions / hints concerning known traps if I translate C code to Blitzbasic? Never did that, beside Basic I know PHP and a little bit Java... never coded in C but it looks a little bit like Java syntax. <br><br></td></tr></table><br>
<a name="711546"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, the problem using sphereical mapping, is the mesh's UV co-ords are always going to be squeezed at the top. Have you tried using a cubemap? I'm not sure how you would go about creating a cubemap from this... <br><br></td></tr></table><br>
<a name="711551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi Krischan, i have been translating the planet.c code. thought you might like to see what i have so far. it is now functioning.<br><br>edit: just an update on what i have now.<br>edit2: ok, another update, it now prints the heightmap, i think.<br>edit3: added the mercator function.<br>edit4: added 5 more of the projection functions.<br>edit5: added the last 4 projections.<br>edit6: fixed sinusoid map projection, added ppm output.<br><br>code is now here:<br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1831" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1831</a> <br><br></td></tr></table><br>
<a name="711684"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Amazing!  It would take me a week to get that far.  I've done a little further research and found that what we're looking for is called a geographic lat-lon projection.  It really isn't a projection at all, and the cartographers don't recognize it as such.<br><br>The trick, as I understand it so far, is to treat lats and lons directly as if they were x and y coordinates with lat -90 to 90 and lon -180 to 180.  If I get anywhere, I'll share it.<br><br>Good luck to you both!<br><br>Mike <br><br></td></tr></table><br>
<a name="711725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> markcw, I'm deeply impressed how far you got, I didn't even start my own code! I would love to see the final result and hope that we'll get it to work in BB!<br><br>Ross, I've hade some experiments with geospheres but I don't get it how to put a texture on it. Only a premade UV-mapped geosphere worked, but none of the codes here which create a geosphere in BB. The sphere gets some color from the texture but that's all. <br><br>Morbius, I think the correct name for this is "equidistant cylindrical projection", read this:<br><br>The simplest of all map graticules belongs to the equatorial aspect of the equirrectangular projection, referred to by many names like equidistant cylindrical, plane chart, plain chart and rectangular. It is a cylindrical projection with standard meridians: all have constant scale, equal to the standard parallels's, therefore all parallels are equally spaced. It was credited to Erathostenes (ca. 200 b.c.) and to Marinus of Tyre (ca. 100). Its trivial construction made it widely used, even for navigation, until the Modern Age. <br><br>A special case of the equirrectangular projection is called Plate Carrée, or simple cylindrical: the Equator is a standard parallel, so it is twice as long as all meridians, making the map a 2 : 1 rectangle and the graticule's grid square. <br><br>Fast, trivial equations led to its resurgence in rough computer-drawn maps, with early machines or real-time graphics. It is still commonly used in digitized textures ("skins") of earthly and planetary features. <br><br>From <a href="http://www.progonos.com/furuti/MapProj/Normal/ProjCyl/projCyl.html" target="_blank">http://www.progonos.com/furuti/MapProj/Normal/ProjCyl/projCyl.html</a><br><br>There is a nice overview of projection techniques, too:<br><a href="http://www.progonos.com/furuti/MapProj/Normal/TOC/cartTOC.html" target="_blank">http://www.progonos.com/furuti/MapProj/Normal/TOC/cartTOC.html</a> <br><br></td></tr></table><br>
<a name="711776"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> We're learning more about cartography than we ever imagined, aren't we! <br><br></td></tr></table><br>
<a name="711953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> i'm having problems. i have the mercator function translated and the "commandline" is set to do that function, but i think there is a problem with converting from radians to degrees, as the output is just blank.<br><br>it draws the vertical gridlines ok but not the horizontal ones, there's a commented line on what it was, and then my attempt at converting radians to degrees, but i don't know how to do that, maybe you could fix it Krischan/anyone?<br><br>i'll move on a translate the other ones now. <br><br></td></tr></table><br>
<a name="712021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Degrees = Radians * (Pi / 180) ?<br><br>You're conveting theta1 to radians then back to degrees?<br><br><pre class=code>
y = Sin(DEG2RAD*theta1 * Rad2Deg) ;y = Sin(DEG2RAD*theta1)
</pre> <br><br></td></tr></table><br>
<a name="712026"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Back to cartography for a moment - There's a nice illustration of the geographic projection here:<br><br><a href="http://www.3dsoftware.com/Cartography/USGS/MapProjections/Cylindrical/PlateCarree/" target="_blank">http://www.3dsoftware.com/Cartography/USGS/MapProjections/Cylindrical/PlateCarree/</a><br><br>And here's some fantastic info:<br><br><a href="http://www.lepp.cornell.edu/~seb/celestia/textures.html#2.1" target="_blank">http://www.lepp.cornell.edu/~seb/celestia/textures.html#2.1</a><br><br><img src="http://morbius.blitzforge.com/blitzimages/distort.gif"> <br><br></td></tr></table><br>
<a name="712042"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi Morbius,<br><br>well, while translating the sinusoid projection i found the gridline projections worked when i did sin or cos(value*Rad2Deg) where Rad2Deg = 180/Pi. And when i went back to the mercator function i found i could do: <br>Sin(theta1) or Sin(DEG2RAD*theta1*Rad2Deg)<br>but i still had to edit the original code before it worked.<br><br>i still can't get anything working for the actual map projections though, but i'm thinking it must be something wrong in the planet functions, but it's confusing because they don't have any sin/cos commands.<br><br>i will just ignore it for now and get the rest of the projections translated. <br><br></td></tr></table><br>
<a name="712126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi Krischan,<br><br>that's all the important stuff translated now. the only stuff left is the output to ppm or xpm formats, which i'll do later.<br><br>i have tested all the projections and compared them to identical commandlines in planet.exe, and all the gridlines match now that i converted sin/cos to rad2deg. <br><br>the last 5 projections don't have any lat/longi specifications so they are at 0,0 always. strange how it isn't finished. <br><br>also there's something funny going on in the conical projection one, most of it comes out black. so i've edited it to force blue to see the gridlines.<br><br>so that's the gridlines working but still no actual map data. :/<br><br>edit: ok, found the problem, it was the initial altitude -i or M in the code which needs to be around 0.3 for some reason. it works now, yippee! <br><br></td></tr></table><br>
<a name="712163"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow!  I'm blown away.  Really amazing work there! <br><br></td></tr></table><br>
<a name="712184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> markcw, that are really good news today. I would love to see it running in Blitzbasic, by the way: how fast is it calculating a 1024x512 map in square projection? And did you notice, that when you apply lat/lon data and a magnification level of 10 or 100, the details get finer and finer, shores and small islands appear :-) <br><br></td></tr></table><br>
<a name="712396"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Krischan,<br>i have moved the code to here: <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1831" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1831</a><br>i had to remove a bit so it would fit. i will edit it some more.<br><br>can you not run the code? i haven't tried 1024x512 but it is slow, especially when you increase the -m (magnification) option. <br><br></td></tr></table><br>
<a name="712463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi markcw,<br><br>sorry I didn't see that you've posted the code to the code archive. Huh, you really translated the complete source, respect! It works very good, I played a little bit around but still don't get it how the square projection works, I'm even more confused now. The "planet1" function returns incredible small numbers (smaller than 0.0000xxx) and I think I'm just too stupid to understand the technique behind it. Unfortunately, the planet generation in higher dimensions (1024x512) is way too slow for nearly realtime calculation (for ex. when entering a solar system, screen message: "Scanning system..." for ~ 3-5 seconds)<br><br>Calculating a perlin noise cloud is ~ 100 times faster than Torben's algorithm (ok, Torbens planet looks nicer, so it should take longer). But I don't know how to distort such a perlin noise image with torbens squarep algorithm, because we have X/Y/Z coordinates, and Torbens code calculates the height (=alt) out of these coordinates, but my perlin cloud is only 2D. Huh? Why does it need a Y coordinate?<br><br>So "my" holy grail of planet generation would be a mixture of a fast perlin cloud and its distortion with squarep. <br><br></td></tr></table><br>
<a name="712481"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >b32</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> When you found a method that works, but is to slow, maybe you could precalculate a table. Say, two arrays, containing the projected coordinates ie. newx(x, y) and newy(x, y) <br><br></td></tr></table><br>
<a name="712501"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi Krischan, <br><br>well knowing a bit about calculating stuff i can say there is a rule that usually works, which is: quality is relative to time. so if you want quality AND speed then you'd need to precalculate the maps ie. save out the maps to be loaded into the project later. <br><br>looking at the planet functions i can't see anything you could do to speed them up, they are already optimized. <br><br></td></tr></table><br>
<a name="712676"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Morbius</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Krischan:  Here's a link to a very complete projection system with source <a href="http://www.users.globalnet.co.uk/~arcus/mmps/" target="_blank">http://www.users.globalnet.co.uk/~arcus/mmps/</a><br><br>markcw: There's an interesting projection in this code called a perspective projection, which basically maps the texture around an imaginary sphere, complete with shadow casting.  You could use this to render a small quick billboard imposter of the planet and save the heavy calculation for close ranges. <br><br></td></tr></table><br>
<a name="713676"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have another idea how to distort the texture, maybe it is working. The idea is to convert the cylindrical map into a sinusoid projection, so that the poles get pinched to a singularity and remap this sinusoid back to a cylindrical projection.<br><br>Here is my example code using the planet1.png (first image in this post) which converts the image into a sinusoid-like one. But now there is a problem: I dunno how to convert this image back to a flat image :-(<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 512,512,32,2

;define color field
Dim col(512,256)

;read source image and its colors
image=LoadImage("planet1.png")
SetBuffer ImageBuffer(image)
LockBuffer ImageBuffer(image)
For x=0 To 511
	For y=0 To 255
		col(x,y)=ReadPixelFast(x,y)
	Next
Next
UnlockBuffer ImageBuffer(image)

;create new image
sinusoid=CreateImage(512,256)
SetBuffer ImageBuffer(sinusoid)
LockBuffer ImageBuffer(sinusoid)

;image/sinus factor
factor#=360.0/512.0

;calulate sinusoid
For yy#=0 To 255 Step 1
	For xx#=0 To 511 Step 0.1

		;read current color
		rgb=col(Int(xx),Int(yy))

		;calulate new x
		theta#=Cos((1+xx)/2*factor)*Sin((1+yy)*factor)*256

		;output
		If theta&gt;256 Then xxx=256-theta Else xxx=256+theta
		WritePixelFast 512-xxx,yy,rgb

	Next
Next
UnlockBuffer ImageBuffer(sinusoid)

;output both images
SetBuffer FrontBuffer()
While Not KeyHit(1)
	DrawImage image,0,0
	DrawImage sinusoid,0,256
	Flip
Wend

End</textarea><br><br>source:<br><img src="http://www.christianhart.de/bb/planet1.png"><br><br>output:<br><img src="http://www.christianhart.de/bb/sinusoid.png"> <br><br></td></tr></table><br>
<a name="713739"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ShadowTurtle</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you want more details, do re-calculate the uv coords instead edit the image from texture. <br><br></td></tr></table><br>
<a name="713768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, here is my "solution" but I'm not very happy with it, still pinching at the poles and the code looks messy:<br><br><img src="http://www.christianhart.de/bb/sinusoid2.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 512,768,32,2

;define color field
Dim col(512,256),col2(512,256)

Dim the#(256)

;read source image and its colors
image=LoadImage("planet1.png")
SetBuffer ImageBuffer(image)
LockBuffer ImageBuffer(image)
For x=0 To 511
	For y=0 To 255
		col(x,y)=ReadPixelFast(x,y)
	Next
Next
UnlockBuffer ImageBuffer(image)

;create new image
sinusoid=CreateImage(512,256)
SetBuffer ImageBuffer(sinusoid)
LockBuffer ImageBuffer(sinusoid)

;image/sinus factor
factor#=360.0/512.0

;calulate sinusoid
For yy#=0 To 255 Step 1
	For xx#=0 To 511 Step 0.5

		;read current color
		rgb=col(Int(xx),Int(yy))

		;calulate new x
		theta#=Cos((1+xx)/2*factor)*Sin((yy)*factor)*256
		
		;output
		If theta&gt;256 Then xxx=256-theta Else xxx=256+theta
		WritePixelFast 512-xxx,yy,rgb
		
		col2(512-Int(xxx),Int(yy))=rgb
		
	Next
	
	the#(yy)=Abs(theta)
	
Next
UnlockBuffer ImageBuffer(sinusoid)

;convert sinusoid to rectangular
spherical=CreateImage(512,256)
SetBuffer ImageBuffer(spherical)
LockBuffer ImageBuffer(spherical)

For yy=0 To 255

	;get y distortion
	theta=the(yy)

	;divider
	div#=theta/256.0

	;left side
	For xx=0 To 255
		rgb=col2(256-(xx*div),yy)
		WritePixelFast 255-xx,yy,rgb
	Next
	
	;right side
	For xx=0 To 255
		rgb=col2(256+(xx*div),yy)
		WritePixelFast 256+xx,yy,rgb
	Next
Next
	
UnlockBuffer ImageBuffer(spherical)

;output all images
SetBuffer FrontBuffer()
While Not KeyHit(1)

	Cls

	DrawImage image,0,0
	DrawImage sinusoid,0,256
	DrawImage spherical,0,512
	
	Flip
Wend

End</textarea><br><br>This tech demo shows all three maps in a row <br><br></td></tr></table><br>
<a name="913804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well folks, after two years I found the solution to this, but unfortunately it is written in Dark Basic Pro. It is a custom Perlin3D noise function which produces a smooth and spherecompatible texture. I tried to translate this to BB but wasn't successfully. Is anybody able to locate the error or rewrite my attempt that we get the same results in BB?<br><br>Dark Basic Pro output:<br><img src="http://www.christianhart.de/bb/perlin/dbperlin.png"><br><br>My BB attempt output:<br><img src="http://www.christianhart.de/bb/perlin/bbperlin.png"><br><br>The Dark Basic Code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Rem ***** Main Source File *****
set window on
set window layout 0,0,0
set display mode 512,256,32
hide mouse
sync off
sync rate 0

rem create arrays for perlin generator
dim s#(15,2)
dim r#(63,63,63)

rem prepare the perlin
prepare_perlin(1,0.5)

rem multisampling controller
multi = 1
milti = multi - 1
malt# = multi ^ 2
malt# = 1 / malt#

xsize = 512
ysize = 256

rem get the base sizes
xsize# = xsize * multi
ysize# = ysize * multi

rem get the scalers
xscaler# = 360
yscaler# = 180

xscaler# = xscaler# / xsize#
yscaler# = yscaler# / ysize#

width# = 2

rem piece details
pxs = 511
pys = 255

xof = 0
yof = 0

rem loop the y position
for posx = 0 to pxs step 1

   rem prepare screen for drawing
   lock pixels

   rem loop the x
   for posy = 0 to pys step 1


      rem reset colours
      g = 0
      b = 0

      rem get the scaled sizes
      xp = (posx + xof) * multi
      yp = (posy + yof) * multi

      rem do the multisampling
      for posa = 0 to milti
         rem get the baring around the sphere
         ba# = xp + posa
         ba# = (ba# + 0.5) * xscaler#
         xp# = cos(ba#)
         zp# = sin(ba#)
         for s = 0 to milti
            rem get the pitch around the sphere
            pa# = yp + poss
            pa# = ((pa# + 0.5) * yscaler#)
            po# = sin(pa#) * width#
            rem get the positions in the space
            x# = (xp# * po#) + 5
            y# = (cos(pa#) * width#) + 5
            z# = (zp# * po#) + 5
            rem get the perlin result for that part
            h = int(perl(x#,y#,z#,8) * 255)
            rem cap the value
            if h =&gt; 255 then h = 255
            if h &lt;= 0 then h = 0

            rem add appropriate colour
            if h =&gt; 136
               g=g+h
            else
               b=b+h
            endif

            rem failsafe quit
            if spacekey() then end

         next poss
      next posa

      rem scale down the colours
      g = g * malt#
      b = b * malt#

      rem get the colour
      ink rgb(0,g,b),0

      rem put a dot there
      dot posx,posy

   next posy

   unlock pixels
   sync

next posx

do

 if spacekey() then end

loop

rem end

rem perlin function
function perl(x#,y#,z#,octaves)
   rem make sure the pass value is zerod
   h# = 0
   rem shift octaves down to input works from 1 but system works from 0
   octaves=octaves-1
   rem make sue octaves are an ecceptable value
   if octaves &lt;= 0 then octaves = 0
   if octaves =&gt; 15 then octaves = 15
   rem loop the octaves
   for oct = 0 to octaves
      rem grab the frequency and amplitude for this
      fre# = s#(oct,0)
      amp# = s#(oct,1)
      rem convert the co-ordinates into steps
      x = int(x# * fre#)
      y = int(y# * fre#)
      z = int(z# * fre#)
      rem get the inbetween co-ords
      xb# = sine((x# * fre#) - flo(x))
      yb# = sine((y# * fre#) - flo(y))
      zb# = sine((z# * fre#) - flo(z))
      xa# = 1 - xb#
      ya# = 1 - yb#
      za# = 1 - zb#
      rem get the values for the 8 corners
      v000# = vil(x,y,z) * xa# * ya# * za#
      v100# = vil(x+1,y,z) * xb# * ya# * za#
      v010# = vil(x,y+1,z) * xa# * yb# * za#
      v001# = vil(x,y,z+1) * xa# * ya# * zb#
      v101# = vil(x+1,y,z+1) * xb# * ya# * zb#
      v110# = vil(x+1,y+1,z) * xb# * yb# * za#
      v011# = vil(x,y+1,z+1) * xa# * yb# * zb#
      v111# = vil(x+1,y+1,z+1) * xb# * yb# * zb#
      rem add it on
      h#=h#+(v000# + v100# + v010# + v001# + v101# + v110# + v011# + v111#) * amp#
   next oct
   rem scale it down
   h# = h# * s#(octaves,2)
endfunction h#

rem function to get the random value of a co-ordinate
function vil(x,y,z)
   rem control edges
   if x &lt; 0 then x = x - (int((x / 64) - 1) * 64) else x = x - (int(x/64) * 64)
   if y &lt; 0 then y = y - (int((y / 64) - 1) * 64) else y = y - (int(y/64) * 64)
   if z &lt; 0 then z = z - (int((z / 64) - 1) * 64) else z = z - (int(z/64) * 64)
   rem get the number
   v# = r#(x,y,z)
endfunction v#

rem return an integer as a floating point
function flo(a)
   b# = a
endfunction b#

rem function to turn a straight 0 - 1 into a sine curved 0 - 1
function sine(v#)
   rem perform the change
   v# = (1 - cos(v# * 180)) * 0.5
endfunction v#

rem function to prepare data for perlin noise
function prepare_perlin(seed,persistance#)
   rem set the seed value
   randomize seed
   rem create seed data
   for x = 0 to 63
      for y = 0 to 63
         for z = 0 to 63
            z# = rnd(10000)
            r#(x,y,z) = (z# * 0.0001)
         next z
      next y
   next z
   rem prepare octave data
   for z = 0 to 15
      rem work out the frequence of the octave
      s#(z,0) = 2 ^ z
      rem get the amplitude
      s#(z,1) = persistance# ^ z
      rem work out the maximum amplitude of
      s#(z,2) = 0
      for x = 0 to z
         s#(z,2)=s#(z,2)+s#(x,1)
      next x
      s#(z,2) = 1 / s#(z,2)
   next z
endfunction
</textarea><br><br>My BB attempt Code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 512,256,32,2

; create arrays For perlin generator
	Dim s#(15,2)
	Dim r#(63,63,63)
	
	; prepare the perlin
	prepare_perlin(1,0.5)
	
	; multisampling controller
	multi = 1
	milti = multi - 1
	malt# = multi ^ 2
	malt# = 1.0 / malt#
	
	xsize# = 512
	ysize# = 256
	
	; get the base sizes
	xsize# = xsize * multi
	ysize# = ysize * multi
	
	; get the scalers
	xscaler# = 360
	yscaler# = 180
	
	xscaler# = xscaler# / xsize#
	yscaler# = yscaler# / ysize#
	
	width# = 2
	
	; piece details
	pxs = 511
	pys = 255
	
	xof = 0
	yof = 0
	
	LockBuffer GraphicsBuffer()
	
	; loop the y position
	For posx = 0 to pxs Step 1
		
			; loop the x
			For posy = 0 to pys Step 1
				
				
				; reset colours
				g = 0
				b = 0
				
				; get the scaled sizes
				xp# = (posx + xof) * multi
				yp# = (posy + yof) * multi
				
; do the multisampling
				For posa = 0 to milti
					; get the baring around the sphere
					ba# = xp + posa
					ba# = (ba# + 0.5) * xscaler#
					xp# = Cos(ba#)
					zp# = Sin(ba#)
					For poss = 0 To milti
						; get the pitch around the sphere
						pa# = yp + poss
						pa# = ((pa# + 0.5) * yscaler#)
						po# = Sin(pa#) * width#
						; get the positions in the space
						x# = (xp# * po#) + 5
						y# = (Cos(pa#) * width#) + 5
						z# = (zp# * po#) + 5
						; get the perlin result For that part
						h = Int(perl(x#,y#,z#,8) * 255)
						
						;Print h : WaitKey : End
						
							; cap the value
							If h =&gt; 255 Then h = 255
							If h &lt;= 0 Then h = 0
							
							; add appropriate colour
							If h =&gt; 136
								g=g+h
							Else
								b=b+h
							EndIf
							
							; failsafe quit
							If KeyHit(1) Then End
							
						Next
					Next
					
					; scale down the colours
					g = g * malt#
					b = b * malt#
					
					; get the colour
					rgb=0*$10000+g*$100+b
					WritePixelFast posx,posy,rgb
					; put a dot there
					;Plot posx,posy
					
				Next
				
			Next
			
			UnlockBuffer GraphicsBuffer()
			
			SaveBuffer(GraphicsBuffer(),"bbperlin.bmp")
			
			While Not KeyHit(1)
				
				Flip
				
			Wend
			
			End
			
			; perlin Function
Function perl#(x#,y#,z#,octaves)
	; make sure the pass value is zerod
	h# = 0
	; shift octaves down to Input works from 1 but system works from 0
	octaves=octaves-1
	; make sue octaves are an ecceptable value
	If octaves &lt;= 0 Then octaves = 0
	If octaves =&gt; 15 Then octaves = 15
	; loop the octaves
	For oct = 0 to octaves
		; grab the frequency And amplitude For this
			fre# = s#(oct,0)
			amp# = s#(oct,1)
			; convert the co-ordinates into steps
			x = Int(x# * fre#)
			y = Int(y# * fre#)
			z = Int(z# * fre#)
			; get the inbetween co-ords
			xb# = sine((x# * fre#) - Floor(x))
			yb# = sine((y# * fre#) - Floor(y))
			zb# = sine((z# * fre#) - Floor(z))
			xa# = 1.0 - xb#
			ya# = 1.0 - yb#
			za# = 1.0 - zb#
			; get the values For the 8 corners
				v000# = vil(x,y,z) * xa# * ya# * za#
				v100# = vil(x+1,y,z) * xb# * ya# * za#
				v010# = vil(x,y+1,z) * xa# * yb# * za#
				v001# = vil(x,y,z+1) * xa# * ya# * zb#
				v101# = vil(x+1,y,z+1) * xb# * ya# * zb#
				v110# = vil(x+1,y+1,z) * xb# * yb# * za#
				v011# = vil(x,y+1,z+1) * xa# * yb# * zb#
				v111# = vil(x+1,y+1,z+1) * xb# * yb# * zb#
				; add it on
				h#=h#+(v000# + v100# + v010# + v001# + v101# + v110# + v011# + v111#) * amp#
			Next
			; scale it down
			h# = h# * s#(octaves,2)
			Return h#
End Function

; Function to get the random value of a co-ordinate
Function vil#(x,y,z)
	; control edges
	If x &lt; 0 Then x = x - (Int((x / 64) - 1) * 64) Else x = x - (Int(x/64) * 64)
	If y &lt; 0 Then y = y - (Int((y / 64) - 1) * 64) Else y = y - (Int(y/64) * 64)
	If z &lt; 0 Then z = z - (Int((z / 64) - 1) * 64) Else z = z - (Int(z/64) * 64)
	; get the number
	v# = r#(x,y,z)
	Return v#
End Function

	; Return an integer as a floating point
Function flo#(a)
	b# = a
	Return b#
End Function

; Function to turn a straight 0 - 1 into a sine curved 0 - 1
Function sine#(v#)
	; perform the change
	v# = (1 - Cos(v# * 180)) * 0.5
	
	Return v#
End Function

; Function to prepare Data For perlin noise
Function prepare_perlin(seed,persistance#)
	; set the seed value
	SeedRnd seed
	; create seed Data
	For posx = 0 To 63
		For posy = 0 To 63
			For posz = 0 To 63
				z# = Rnd(0,10000)
				r#(posx,posy,posz) = (z# * 0.0001)
				
			Next
		Next
	Next
	
	; prepare octave Data
	For posz = 0 To 15
		; work out the frequence of the octave
		s#(posz,0) = 2 ^ posz
		; get the amplitude
		s#(posz,1) = persistance# ^ posz
		; work out the maximum amplitude of
		s#(posz,2) = 0
		For posx = 0 To posz
			s#(posz,2)=s#(posz,2)+s#(posx,1)
		Next
		s#(posz,2) = 1.0 / s#(posz,2)
		
		
		
	Next
End Function
	</textarea> <br><br></td></tr></table><br>
<a name="913922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mtnhome3d</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> couldn't you use a sphere with pre-done uv coords and then generate the map and then place it on the spherein the game?<br>also how did you get that atmosphere?? its awesome looking <br><br></td></tr></table><br>
<a name="913955"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> This one is seamless and easy to use. The Atmosphere - dunno - i have to look in my archives. But I worked further and got a different pic now, still not working correct. Looks like something has turned upside down with Sinus and Cosinus coordinates. The main problem was that you can declare in Dark Basic variables twice so I renamed them all that they can't collide in BB. At least I can see some parts of a shoreline now :-)<br><br>But I still need help here:<br><br><img src="http://www.christianhart.de/bb/perlin/bbperlin2.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 512,256,32,2

	; create arrays For perlin generator
	Dim s#(15,2)
	Dim r#(63,63,63)
	
	; prepare the perlin
	prepare_perlin(1,0.5)
	
	; multisampling controller
	multi = 1
	milti = multi - 1
	malt# = multi ^ 2
	malt# = 1 / malt#
	
	xsize1 = 512
	ysize1 = 256
	
	; get the base sizes
	xsize2# = xsize1 * multi
	ysize2# = ysize1 * multi
	
	; get the scalers
	xscaler1# = 360
	yscaler1# = 180
	
	xscaler2# = xscaler1# / xsize2#
	yscaler2# = yscaler1# / ysize2#
	
	width# = 2
	
	; piece details
	pxs = 511
	pys = 255
	
	xof = 0
	yof = 0
	
	; loop the y position
	For posx = 0 To pxs Step 1
		
			; loop the x
			For posy = 0 To pys Step 1
				
				; reset colours
				g = 0
				b = 0
				
				; get the scaled sizes
				xp1 = (posx + xof) * multi
				yp1 = (posy + yof) * multi
				
				; do the multisampling
				For posa = 0 To milti
					
					; get the baring around the sphere
					ba# = xp1 + posa
					ba# = (ba# + 0.5) * xscaler2#
					xp2# = Cos(ba#)
					zp2# = Sin(ba#)
					
					For poss = 0 To milti
						
						; get the pitch around the sphere
						pa# = yp1 + poss
						pa# = ((pa# + 0.5) * yscaler2#)
						po# = Sin(pa#) * width#
						
						; get the positions in the space
						x# = (xp2# * po#) + 5
						y# = (Cos(pa#) * width#) + 5
						z# = (zp2# * po#) + 5
						
						; get the perlin result For that part
						h = Int(perl(x#,y#,z#,8) * 255)
							
						; cap the value
						If h =&gt; 255 Then h = 255
						If h &lt;= 0 Then h = 0
							
						; add appropriate colour
						If h =&gt; 136
							g=g+h
						Else
							b=b+h
						EndIf
							
						; failsafe quit
						If KeyHit(1) Then End
							
					Next
					
				Next	
				
				; scale down the colours
				g = g * malt#
				b = b * malt#
					
				; get the colour
				Color 0,g,b
					
				; put a dot there
				Plot posx,posy
					
			Next
				
		Next
			
		WaitKey
		
		End
		
; perlin Function
Function perl#(x#,y#,z#,octaves)
	
	; make sure the pass value is zerod
	h# = 0
	
	; shift octaves down to Input works from 1 but system works from 0
	octaves=octaves-1
	
	; make sue octaves are an ecceptable value
	If octaves &lt;= 0 Then octaves = 0
	If octaves =&gt; 15 Then octaves = 15
	
	; loop the octaves
	For oct = 0 To octaves
		
		; grab the frequency And amplitude For this
		fre# = s#(oct,0)
		amp# = s#(oct,1)
			
		; convert the co-ordinates into steps
		xx = Int(x# * fre#)
		yy = Int(y# * fre#)
		zz = Int(z# * fre#)
			
		; get the inbetween co-ords
		xb# = sine((x# * fre#) - flo(xx))
		yb# = sine((y# * fre#) - flo(yy))
		zb# = sine((z# * fre#) - flo(zz))
		xa# = 1.0 - xb#
		ya# = 1.0 - yb#
		za# = 1.0 - zb#
			
		; get the values For the 8 corners
		v000# = vil(xx,yy,zz) * xa# * ya# * za#
		v100# = vil(xx+1,yy,zz) * xb# * ya# * za#
		v010# = vil(xx,yy+1,zz) * xa# * yb# * za#
		v001# = vil(xx,yy,zz+1) * xa# * ya# * zb#
		v101# = vil(xx+1,yy,zz+1) * xb# * ya# * zb#
		v110# = vil(xx+1,yy+1,zz) * xb# * yb# * za#
		v011# = vil(xx,yy+1,zz+1) * xa# * yb# * zb#
		v111# = vil(xx+1,yy+1,zz+1) * xb# * yb# * zb#
				
		; add it on
		h#=h#+(v000# + v100# + v010# + v001# + v101# + v110# + v011# + v111#) * amp#
				
	Next
			
	; scale it down
	h# = h# * s#(octaves,2)
			
	Return h#
			
End Function
			
; Function to get the random value of a co-ordinate
Function vil#(x,y,z)
	
	; control edges
	If x &lt; 0 Then x = x - (Int((x / 64) - 1) * 64) Else x = x - (Int(x/64) * 64)
	If y &lt; 0 Then y = y - (Int((y / 64) - 1) * 64) Else y = y - (Int(y/64) * 64)
	If z &lt; 0 Then z = z - (Int((z / 64) - 1) * 64) Else z = z - (Int(z/64) * 64)
	
	; get the number
	v# = r#(x,y,z)
	
	Return v#
	
End Function

	
	; Return an integer as a floating point
Function flo#(a)
	
	b# = a*1.0
	
	Return b#
	
End Function
	
; Function to turn a straight 0 - 1 into a sine curved 0 - 1
Function sine#(v#)
	
	; perform the change
	v# = (1 - Cos(v# * 180)) * 0.5
	
	Return v
	
End Function

	
; Function to prepare Data For perlin noise
Function prepare_perlin(seed,persistance#)
	
	; set the seed value
	SeedRnd seed
	
	; create seed Data
	For x = 0 To 63
		
		For y = 0 To 63
			
			For z = 0 To 63
				
				zz# = Rnd(10000)
				r#(x,y,z) = (zz# * 0.0001)
				
			Next
			
		Next
		
	Next
	
	; prepare octave Data
	For i = 0 To 15
		
		; work out the frequence of the octave
		s#(i,0) = 2 ^ i
		
		; get the amplitude
		s#(i,1) = persistance# ^ i
		
		; work out the maximum amplitude of
		s#(i,2) = 0.0
		
		For j = 0 To i
			
			s#(i,2)=s#(i,2)+s#(j,1)
			
		Next
		
		s#(i,2) = 1.0 / s#(i,2)
		
	Next
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="913971"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think the remaining problem is Int(), which is misnamed in Blitz3D. It should be called Round() since it rounds to the nearest integer. Every other language I know uses Int() to mean "integer part of", i.e. discard the fractional part.<br><br>So here is a quick fix. I did a search and replace to change every Int( to DBInt(, which chops off everything after the decimal point.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function DBInt( x# )
	If x &gt;= 0 
		Return Floor(x)
	Else
		Return Ceil(x)
	End If
End Function

Graphics 512,256,32,2

	; create arrays For perlin generator
	Dim s#(15,2)
	Dim r#(63,63,63)
	
	; prepare the perlin
	prepare_perlin(1,0.5)
	
	; multisampling controller
	multi = 1
	milti = multi - 1
	malt# = multi ^ 2
	malt# = 1 / malt#
	
	xsize1 = 512
	ysize1 = 256
	
	; get the base sizes
	xsize2# = xsize1 * multi
	ysize2# = ysize1 * multi
	
	; get the scalers
	xscaler1# = 360
	yscaler1# = 180
	
	xscaler2# = xscaler1# / xsize2#
	yscaler2# = yscaler1# / ysize2#
	
	width# = 2
	
	; piece details
	pxs = 511
	pys = 255
	
	xof = 0
	yof = 0
	
	; loop the y position
	For posx = 0 To pxs Step 1
		
			; loop the x
			For posy = 0 To pys Step 1
				
				; reset colours
				g = 0
				b = 0
				
				; get the scaled sizes
				xp1 = (posx + xof) * multi
				yp1 = (posy + yof) * multi
				
				; do the multisampling
				For posa = 0 To milti
					
					; get the baring around the sphere
					ba# = xp1 + posa
					ba# = (ba# + 0.5) * xscaler2#
					xp2# = Cos(ba#)
					zp2# = Sin(ba#)
					
					For poss = 0 To milti
						
						; get the pitch around the sphere
						pa# = yp1 + poss
						pa# = ((pa# + 0.5) * yscaler2#)
						po# = Sin(pa#) * width#
						
						; get the positions in the space
						x# = (xp2# * po#) + 5
						y# = (Cos(pa#) * width#) + 5
						z# = (zp2# * po#) + 5
						
						; get the perlin result For that part
						h = DBInt(perl(x#,y#,z#,8) * 255)
							
						; cap the value
						If h =&gt; 255 Then h = 255
						If h &lt;= 0 Then h = 0
							
						; add appropriate colour
						If h =&gt; 136
							g=g+h
						Else
							b=b+h
						EndIf
							
						; failsafe quit
						If KeyHit(1) Then End
							
					Next
					
				Next	
				
				; scale down the colours
				g = g * malt#
				b = b * malt#
					
				; get the colour
				Color 0,g,b
					
				; put a dot there
				Plot posx,posy
					
			Next
				
		Next
			
		WaitKey
		
		End
		
; perlin Function
Function perl#(x#,y#,z#,octaves)
	
	; make sure the pass value is zerod
	h# = 0
	
	; shift octaves down to Input works from 1 but system works from 0
	octaves=octaves-1
	
	; make sue octaves are an ecceptable value
	If octaves &lt;= 0 Then octaves = 0
	If octaves =&gt; 15 Then octaves = 15
	
	; loop the octaves
	For oct = 0 To octaves
		
		; grab the frequency And amplitude For this
		fre# = s#(oct,0)
		amp# = s#(oct,1)
			
		; convert the co-ordinates into steps
		xx = DBInt(x# * fre#)
		yy = DBInt(y# * fre#)
		zz = DBInt(z# * fre#)
			
		; get the inbetween co-ords
		xb# = sine((x# * fre#) - flo(xx))
		yb# = sine((y# * fre#) - flo(yy))
		zb# = sine((z# * fre#) - flo(zz))
		xa# = 1.0 - xb#
		ya# = 1.0 - yb#
		za# = 1.0 - zb#
			
		; get the values For the 8 corners
		v000# = vil(xx,yy,zz) * xa# * ya# * za#
		v100# = vil(xx+1,yy,zz) * xb# * ya# * za#
		v010# = vil(xx,yy+1,zz) * xa# * yb# * za#
		v001# = vil(xx,yy,zz+1) * xa# * ya# * zb#
		v101# = vil(xx+1,yy,zz+1) * xb# * ya# * zb#
		v110# = vil(xx+1,yy+1,zz) * xb# * yb# * za#
		v011# = vil(xx,yy+1,zz+1) * xa# * yb# * zb#
		v111# = vil(xx+1,yy+1,zz+1) * xb# * yb# * zb#
				
		; add it on
		h#=h#+(v000# + v100# + v010# + v001# + v101# + v110# + v011# + v111#) * amp#
				
	Next
			
	; scale it down
	h# = h# * s#(octaves,2)
			
	Return h#
			
End Function
			
; Function to get the random value of a co-ordinate
Function vil#(x,y,z)
	
	; control edges
	If x &lt; 0 Then x = x - (DBInt((x / 64) - 1) * 64) Else x = x - (DBInt(x/64) * 64)
	If y &lt; 0 Then y = y - (DBInt((y / 64) - 1) * 64) Else y = y - (DBInt(y/64) * 64)
	If z &lt; 0 Then z = z - (DBInt((z / 64) - 1) * 64) Else z = z - (DBInt(z/64) * 64)
	
	; get the number
	v# = r#(x,y,z)
	
	Return v#
	
End Function

	
	; Return an integer as a floating point
Function flo#(a)
	
	b# = a*1.0
	
	Return b#
	
End Function
	
; Function to turn a straight 0 - 1 into a sine curved 0 - 1
Function sine#(v#)
	
	; perform the change
	v# = (1 - Cos(v# * 180)) * 0.5
	
	Return v
	
End Function

	
; Function to prepare Data For perlin noise
Function prepare_perlin(seed,persistance#)
	
	; set the seed value
	SeedRnd seed
	
	; create seed Data
	For x = 0 To 63
		
		For y = 0 To 63
			
			For z = 0 To 63
				
				zz# = Rnd(10000)
				r#(x,y,z) = (zz# * 0.0001)
				
			Next
			
		Next
		
	Next
	
	; prepare octave Data
	For i = 0 To 15
		
		; work out the frequence of the octave
		s#(i,0) = 2 ^ i
		
		; get the amplitude
		s#(i,1) = persistance# ^ i
		
		; work out the maximum amplitude of
		s#(i,2) = 0.0
		
		For j = 0 To i
			
			s#(i,2)=s#(i,2)+s#(j,1)
			
		Next
		
		s#(i,2) = 1.0 / s#(i,2)
		
	Next
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="913978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Int() also has this strange behaviour:<br><div class="quote"> <br>Int converts floating point numbers by rounding to the nearest integer.<br>NOTE: This is not the traditional meaning of Int in Basic.<br><br>What about numbers exactly halfway between integers?<br>The rounding is to the nearest even integer:<br><br>Int( 2.5 ) ... produces 2<br>Int( 3.5 ) ... produces 4<br> <br></div> <br><br></td></tr></table><br>
<a name="913986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just use Int( Left( Number,1) ). <br><br></td></tr></table><br>
<a name="913992"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon, that wont work for numbers with more than 1 digit or negative numbers. <br><br></td></tr></table><br>
<a name="914097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> True. Nevermind that.<br><br>To bypass Blitz's rounding system, use strings (since blitz doesn't round strings, it just returns the number until the "."):<br><pre class=code>
Print Int( 2.9 )  ;result is 3
Print Int( Str(2.9) ) ;result is 2, which is what it should be in the first place.
</pre> <br><br></td></tr></table><br>
<a name="914148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks to all, that is the solution! I wonder if I could speed up the whole code since it is a little bit slow for on-the-fly generating a planet. Perhaps pre-calculated sin/cos tables? <br><br></td></tr></table><br>
<a name="914152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> For a decent speed up, lock the buffer and use writepixelfast, instead of plot.<br><br>Also, just use the native float command rather than this ..<br><br><pre class=code>
Function flo#(a)
	
	b# = a*1.0
	
	Return b#
	
End Function
</pre> <br><br></td></tr></table><br>
<a name="914162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just an alternate idea. Have you tried a geosphere, with a cubemapped planet texture? <br><br></td></tr></table><br>
<a name="914177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stevie G - yeah "Plot" was used just for test purposes, sure "Writepixelfast" is faster for output. I was talking about speed up the calculation and my tests results showed that Float is slower than x*1.0.<br><br>Ross C - I only read about this but I am too dumb to realise it, are you talking about a "smoothed cube"? At the moment I am using a geosphere mesh instead of a sphere, but the texture only mapped to it the standard way. My goal is a planet generated by a seed which looks like the planets in "Freelancer" - they were simple but looked fine from a certain distance. And do you remember the game "Starflight"? There were nice but low resolution planets where you could land and drive over the surface (in 2D). I dunno how they did it (both the Freelancer planets and these in Starflight).<br><br>Another thing I was thinking about is creating and coloring a geosphere direct from the 3D Perlin cloud:<br><br>- generate a 3D Perlin Noise cloud<br>- calc the X/Y/Z Coordinates of Geosphere vertices<br>- Vertexcolor these vertices with the "color" from the same position in this cloud<br>- or even apply a texture depending on the "height" of the vertex, e.g. sea/grass/mountain<br>- realtime subdivide the visible patches if you get closer and modify the geosphere by the Perlin cloud data to get more detail<br><br>A very advanced engine using this technique (as far as I understood) is "Infinity":<br><br><a href="http://www.infinity-universe.com/Infinity/index.php?option=com_zoom&amp;Itemid=90&amp;catid=4&amp;PageNo=2" target="_blank">http://www.infinity-universe.com/Infinity/index.php?option=com_zoom&amp;Itemid=90&amp;catid=4&amp;PageNo=2</a><br><a href="http://www.youtube.com/watch?v=DCzDKj3hjOE&amp;feature=related" target="_blank">http://www.youtube.com/watch?v=DCzDKj3hjOE&amp;feature=related</a><br><br>In Darkbasic there is a simple example how they did it, and even untextured it looks awesome!<br><a href="http://forumfiles.thegamecreators.com/download/1527504" target="_blank">http://forumfiles.thegamecreators.com/download/1527504</a> <br><br></td></tr></table><br>
<a name="914195"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah i see what you mean now. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
