<!DOCTYPE html><html lang="en" ><head ><title >3D Spaceship with turret</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >3D Spaceship with turret</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >3D Spaceship with turret</a><br><br>
<a name="1283342"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi everyone,<br><br>I've search forum files for something like this ang got something but i'm failing to understand it.<br><br>i've a Spaceship in a 3d world with full movement and rotation. As a child of that ship i have a TurretBase that can only rotate his Y axis(yaw). As a child of that TurretBase i have a TurretGun that can only rotate in his X axis (pitch).<br><br>How can i point that gun to a target entity using DeltaYaw and DeltaPitch values?<br><br>I getting stuck with that relationship between global and local angles once my Spaceship rotates in the 3D space.<br><br>Need some help. Thanks in advance. <br><br></td></tr></table><br>
<a name="1283362"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not visualizing any difficulties here. Wouldn't this work?<br><br><pre class=code>1. Use DeltaYaw with TurretBase and Target.
2. Turn TurretBase on Y-axis.
3. Use DeltaPitch with TurretGun and Target.
4. Turn TurretGun on X-axis.</pre> <br><br></td></tr></table><br>
<a name="1283365"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have that but it only works when the Spaceship is aligned with axis X and Y, by other words, when Spaceship has no rotation. <br><br></td></tr></table><br>
<a name="1283370"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does it need to be DeltaYaw and Pitch?<br>If you use AlignToVector, which takes in vectors and handles the rotation, it might be slightly faster as it may use more optimised code.<br><br><a href="http://www.blitzbasic.com/b3ddocs/command.php?name=AlignToVector&amp;ref=3d_cat" target="_blank">http://www.blitzbasic.com/b3ddocs/command.php?name=AlignToVector&amp;ref=3d_cat</a><br><br>vectorX = targetX - turretGunX ;Destination minus source.<br>vectorY = targetY - turretGunY<br>vectorZ = targetZ - turretGunZ<br><br>AlignToVector( turretGun, vectorX, vectorY, vectorZ, 3 ) ;With the 'Z' axis used, or whatever axis your turretGun is pointing in, in the model file \ when it's created. <br><br></td></tr></table><br>
<a name="1283379"></a>

<a name="1283381"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> My first attempt was with aligntovector and it does the job but... Always a 'but' :D<br><br>aligntovector has a rate field set to 1 as default and it represents an instant align to target that I don't want. So if I set a value to that rate between 0 and 1 I will get a smooth align but... Another 'but'... That align is not constant and I need a fixed value (previously set by the turret data)...<br><br>...so I created a pivot (1 for base and other for gun with same relationship parent-child) that aligns instantly to target and then I rotate TurretBase and TurretGun at constant angles.<br><br>Recently I found that delta commands and thought it was a better way to achieve same result but got that problem with the align... I have a similar system for missiles so it is a good option to save all those pivots <br><br></td></tr></table><br>
<a name="1283389"></a>

<a name="1283390"></a>

<a name="1283391"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see, you want a fixed rate turning speed. I don't think you can do that with vectors, you really need DeltaYaw and DeltaPitch then.<br><br>What happens when you use the Delta commands and when turning use the 'global' parameter set to 'True'? I think that should work.<br><br>deltaX = DeltaPitch( ... )<br>deltaY = DeltaYaw( ... )<br><br>TurnEntity( turretGun, deltaX, deltaY, 0, True ) ;True to treat the 'delta' values as a global rotation rather than local. <br><br></td></tr></table><br>
<a name="1283397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >angros47</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> The rate of aligntovector is a percentage of the gap: let's say that, to align the turret, you need to turn it by 10 degrees: a rate of .5 will turn it by 50% of it, so 5 degrees; at the next step, it will turn by half of remaining gap, so 2.5... then 1.25, then 0.625, and it will never be aligned (do you know Zeno's paradox , right?)<br><br>The fix is simple: if you want to take 10 steps to align, for the first step use a rate of 1/10 (1/10 of 10 degrees is 1 degree, still 9 to go); for the second step, use a rate of 1/9 (1/9 of 9 is again 1 degree... 8 to go), then 1/8, 1/7... until you have only one degree to align, and you use 1/1, so you complete the alignment.  In other words, use as a rate the value 1/steps remaining. <br><br></td></tr></table><br>
<a name="1283425"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon:<br>TurretBase can only rotate his local Yaxis andTurretGun can only rotate his local Xaxis so i'm using DeltaYaw for Base and DeltaPitch for Gun, can't use both 'pitch' and 'yaw' at the same entity :(<br><br>Using global TurnEntity at TurretBase will make it rotate around all his local axis. same for TurretGun.<br><br>angros47:<br>I see the point and it seems to work although having a Delta command working with local angles would be so nice. <br><br></td></tr></table><br>
<a name="1283430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> well... this does the job:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

		aX#=EntityPitch#(TurretBase)
		aY#=EntityYaw#(TurretBase)
		aZ#=EntityRoll#(TurretBase)
		
		PointEntity TurretBase,Target
		
		DX#=EntityPitch#(TurretBase)-aX#
		DY#=EntityYaw#(TurretBase)-aY#
		DZ#=EntityRoll#(TurretBase)-aZ#
		
		RotateEntity TurretBase,aX#,aY#+DY#,aZ#
		
		
		aX#=EntityPitch#(TurretGun)
		aY#=EntityYaw#(TurretGun)
		aZ#=EntityRoll#(TurretGun)
		
		PointEntity TurretGun,Target
		
		DX#=EntityPitch#(TurretGun)-aX#
		DY#=EntityYaw#(TurretGun)-aY#
		DZ#=EntityRoll#(TurretGun)-aZ#
		
		RotateEntity TurretGun,aX#+DX#,aY#,aZ#

</textarea><br><br>since there is no Roll changes at all we can remove some lines:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

		aX#=EntityPitch#(TurretBase)
		aY#=EntityYaw#(TurretBase)
		
		PointEntity TurretBase,Target
		
		DX#=EntityPitch#(TurretBase)-aX#
		DY#=EntityYaw#(TurretBase)-aY#
		
		RotateEntity TurretBase,aX#,aY#+DY#,0
		
		
		aX#=EntityPitch#(TurretGun)
		aY#=EntityYaw#(TurretGun)
		
		PointEntity TurretGun,Target
		
		DX#=EntityPitch#(TurretGun)-aX#
		DY#=EntityYaw#(TurretGun)-aY#
		
		RotateEntity TurretGun,aX#+DX#,aY#,0

</textarea><br><br>To avoid instant point at target, just need to set a max and min value for DX# and DY# <br><br></td></tr></table><br>
<a name="1283441"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is the final state (i hope)...<br><br><pre class=code>

Function PointTurretTo#(BaseEnt,GunEnt,TargetEnt,rate#=1,maxPitch#=90,minPitch#=-90)
	
	;BaseEnt	- entity used as base for turret
	;GunEnt		- entity used as gun for turret
	;rate		- max ammount of degrees to increment
	;maxPitch	- max Pitch gun can handle
	;minPitch	- min Pitch gun can handle
	
	Local aX#,aY#		;used to store entity pitch and yaw values
	Local DX#,DY#		;used as delta pitch and yaw variables, also used as pitch and yaw rotation
	Local vX#,vY#	;used to store delta pitch and yaw variables
	
	;Rotate Turret Base------------------------------------------------------------------
	
	
	aX=EntityPitch#(BaseEnt)			;store actual Base entity pitch
	aY=EntityYaw#(BaseEnt)				;store actual Base entity yaw
	
	PointEntity BaseEnt,TargetEnt		;points base entity to target entity	(final angle)	
	
	
	DY=EntityYaw#(BaseEnt)-aY			;store angle between initial angle and final angle (it is a deltaYaw)
	
	If DY &lt;= -180 Then DY = DY + 360	;fixes angles limits
	If DY &gt;  +180 Then DY = DY - 360
	
	vX=DY								;stores deltaYaw for future use [optional]
	
	If DY&gt;rate Then DY=rate				;sets a limit for turret rotation rate
	If DY&lt;-rate Then DY=-rate
	
	DY=DY+aY							;transforms deltaYaw in a final angle
	
	RotateEntity BaseEnt,aX,DY,0		;sets Base entity to initial state with Yaw variation
	
	
	;Rotate Turret Gun------------------------------------------------------------------
	aX=EntityPitch#(GunEnt)				;store actual Gun entity pitch
	aY=EntityYaw#(GunEnt)				;store actual Gun entity yaw
	
	PointEntity GunEnt,TargetEnt		;points Gun entity to target entity	(final angle)	
	
	
	DX=EntityPitch#(GunEnt)-aX			;store angle between initial angle and final angle (it is a deltaPitch)
	
	vX=DX								;stores deltaPitch for future use [optional]
	
	If Abs(DX)&gt;=Abs(vX)/2.				;only aligns gun at the near end of base align [optional]
		
		If DX&gt;rate*.5 Then DX=rate*.5	;sets a limit for turret rotation rate note:i set the Gun align to be 50% of the Base align rate [optional]
		If DX&lt;-rate*.5 Then DX=-rate*.5
		
		DX=DX+aX						;transforms deltaPitch in a final angle
		
		If DX&gt;maxPitch Then DX=maxPitch		;sets a limit for Gun max angle
		If DX&lt;minPitch Then DX=minPitch		;sets a limit for Gun min angle
		
		RotateEntity GunEnt,DX,aY,0		;sets Gun entity to initial state with Yaw variation
		
	Else
		
		RotateEntity GunEnt,aX,aY,0		;sets Gun entity to initial state without Yaw variation
		
	EndIf
	
	
	
	Return vX+vY						;returns total amount left to complete the alignment (from 360 to 0) [optional]
	
End Function

</pre><br><br>...feel free to use or update <br><br></td></tr></table><br>
<a name="1283452"></a>

<a name="1283453"></a>

<a name="1283454"></a>

<a name="1283455"></a>

<a name="1283456"></a>

<a name="1283457"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> That looks somewhat convoluted.<br>From previous experience (thanks to user Bobysait) we noticed that PointEntity is about 4x slower than AlignToVector, and both do similar tasks. So I'd at least replace it with AlignToVector.<br><br>But still, I think it might be faster to do this with TFormPoint. Essentially, what you're trying to do is turn the base so its YZ plane contains the target, and turn the gun so its XZ plane contains the target as well.<br><br>The TFormPoint will treat each object as the origin, with the position of the target transformed to this coordinate space.<br>Then you can find the angles using ATan2.<br><br><pre class=code>Local targetX# = EntityX( target, True )
Local targetY# = EntityY( target, True )
Local targetZ# = EntityZ( target, True )

Local turretBaseX# = EntityX( turretBase, True )
Local turretBaseY# = EntityY( turretBase, True )
Local turretBaseZ# = EntityZ( turretBase, True )

;Get the vector from the turret base to the target, in the turret base space.

TFormPoint( targetX - turretBaseX, targetY - turretBaseY, targetZ - turretBaseZ, 0, turretBase ) 

;Use the Y and Z components to find out the delta pitch angle.

Local dtPitch# = -Atan2( TFormedY(), TFormedZ() ) 

;Use the X and Z components to find out the delta yaw angle.

Local dtYaw# = -ATan2( TFormedX(), TFormedZ() )

;Then limit the delta angles in whatever way you want.

;Local finalPitch# = ...
;Local finalYaw# = ...

;Finally, apply the angles to the turret base and the gun.

TurnEntity( turretBase,	0, finalYaw, 0 ) ;Global flag turned off.
RotateEntity( turretGun, finalPitch, 0, 0 ) ;Rotate instead of Turn.

;I haven't tested if all of the above needs to be calculated for the turret gun as well.
;I don't think it does.</pre>EDIT: Changed from TFormNormal to TFormPoint, it wasn't necessary. <br><br></td></tr></table><br>
<a name="1283467"></a>

<a name="1283469"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Volturna</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> As far i can say it works just fine!! Changed TFormPoint to TFormNormal again. With TFormPoint  after ship goes away from position x=0 y=0 z=0 the alignment wont work.<br><br>I really appreciate your help! <br><br></td></tr></table><br>
<a name="1283491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Kryzon:<br><div class="quote"> EDIT: Changed from TFormNormal to TFormPoint, it wasn't necessary.  <br></div><br>Maybe you're looking for TFormVector ? (it should fit better the needs : as you don't need the start position, and it's both faster than TFormPoint AND TformNormal (as far as it's a not normalized TFormNormal))<br><br>BTW, it actually works pretty well using vectorpitch/vectoryaw<br>(ZQSD/WASD to move the camera)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Function CreateTurretModels( pParent%=0 )
	
	Local turret		=	CreatePivot			( pParent								 );
							NameEntity			( turret		, "turret"				 );
	Local base			=	CreateMesh			( turret								 );
							NameEntity			( base			, "turret_base"			 );
	Local canon			=	CreateMesh			( turret								 );
							NameEntity			( canon			, "turret_canon"		 );
							
	Local Turret_M1		=	CreateCylinder		( 32,1									 ); Ground cube
							FitMesh				( Turret_M1		, -2,0,-2, 4,.5,4		 ); 
	Local Turret_M2		=	CreateCube			( 										 ); body
							FitMesh				( Turret_M2		, -1,.2,-1, 2,4.0,2		 );
	Local Turret_M3		=	CreateCylinder		( 32									 ); Left launcher bloc
							ScaleMesh			( Turret_M3		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M3		, 0,0,90				 );
							PositionMesh		( Turret_M3		, +0.7,3.8,0.0			 );
	Local Turret_M4		=	CreateCylinder		( 32									 ); Right launcher bloc
							ScaleMesh			( Turret_M4		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M4		, 0,0,90				 );
							PositionMesh		( Turret_M4		, -0.7,3.8,0.0			 );
							AddMesh				( Turret_M1		, base );
							AddMesh				( Turret_M2		, base );
							AddMesh				( Turret_M3		, base );
							AddMesh				( Turret_M4		, base );
							
	
	Local Turret_C0		=	CreateCylinder		( 6, 1									 ); rotative cylinder
							RotateMesh			( Turret_C0		, 0,0,90				 );
							FitMesh				( Turret_C0		, -0.8,-.5,-.5,1.6,1,1	 );
							
	Local Turret_C1		=	CreateCylinder		( 16, 1									 ); canon base
							RotateMesh			( Turret_C1		, 90,0,0				 );
							FitMesh				( Turret_C1		, -.4,-.4,0,.8,.8,.7	 );
	Local Turret_C2		=	CreateCylinder		( 16, 1									 ); canon extends
							RotateMesh			( Turret_C2		, 90,0,0				 );
							FitMesh				( Turret_C2		, -.2,-.2,.7,.4,.4,3	 );
	Local Turret_C3		=	CreateCylinder		( 16, 1									 ); canon end
							RotateMesh			( Turret_C3		, 90,0,0				 );
							FitMesh				( Turret_C3		, -.3,-.3,3.7,.6,.6,.3	 );
							
							AddMesh				( Turret_C0		, canon);
							AddMesh				( Turret_C1		, canon);
							AddMesh				( Turret_C2		, canon);
							AddMesh				( Turret_C3		, canon);
							
							FreeEntity			( Turret_M1								 );
							FreeEntity			( Turret_M2								 );
							FreeEntity			( Turret_M3								 );
							FreeEntity			( Turret_M4								 );
							FreeEntity			( Turret_C0								 );
							FreeEntity			( Turret_C1								 );
							FreeEntity			( Turret_C2								 );
							FreeEntity			( Turret_C3								 );
	Return turret;
End Function





Type TTurret
	Field piv
	Field head
	Field base
	Field canon
End Type

Function CreateTurret.TTurret(model)
	Local t.TTurret = New TTurret;
	t\piv	=	CreatePivot	( );
	t\head	=	CreatePivot	( t\piv );
				MoveEntity	( t\head, 0,5,0 );
	
	t\base	=	CopyEntity	( FindChild(model, "turret_base"), t\piv);
	t\canon	=	CopyEntity	( FindChild(model, "turret_canon"), t\head );
	Return t;
End Function

Function TurretTarget(t.TTurret, target, rate#=1.0)	
	; vector turret-&gt;target
	Local dx# = EntityX(target,True)-EntityX(t\head,True);
	Local dy# = EntityY(target,True)-EntityY(t\head,True);
	Local dz# = EntityZ(target,True)-EntityZ(t\head,True);
	
	Local pit# = VectorPitch(dx,dy,dz);
	Local yaw# = VectorYaw(dx,dy,dz);
	
	Local curyaw# = EntityYaw(t\piv, True);
	Local curpit# = EntityPitch(t\head,False);
	
	RotateEntity ( t\piv	, 0, curyaw+(yaw-curyaw)*rate, 0, True );
	RotateEntity ( t\head	, curpit+(pit-curpit)*rate, 0, 0, False );
End Function


Graphics3D 800,600,0,2
SetBuffer BackBuffer()

	AmbientLight .2,.2,.2
	
	Local ground		=	CreatePlane			( 5										 );
	
	Local skylight		=	CreateLight			( 2 );
							LightColor			( skylight		, 030,035,033			 );
							LightRange			( skylight		, 1000					 );
							PositionEntity		( skylight		, 150,100,150			 );
							
	Local player		=	CreatePivot			( 										 );
	Local head			=	CreatePivot			( player								 );
	Local camera		=	CreateCamera		( head									 );
							CameraClsColor		( camera		, 100,110,130			 );
							CameraClsMode		( camera		, True, True			 );
							CameraRange			( camera		, .1,2000				 );
							PositionEntity		( head			, 0,1.7,0				 );
							PositionEntity		( player		, 0,0,-10				 );
							
	Local camlight		=	CreateLight			( 2, camera								 );
							LightColor			( camlight		, 040,035,030			 );
							LightRange			( camlight		, 5						 );
							
	Local turret_model	=	CreateTurretModels	( 										 );
							HideEntity			( turret_model							 );
	Local t1.TTurret	=	CreateTurret		( turret_model							 );
	
	
	Local msx#			=	MouseXSpeed			( );
	Local msy#			=	MouseYSpeed			( );


	Local bird			=	CreateSphere		( 16 );
							PositionEntity		( bird			, 50,70,200				 );
	Local bird_target	=	CreateCone			( 16,1									 );
							RotateMesh			( bird_target	, 90,0,0				 );
	
	Local bird_x#	=	Rnd(-250,250);
	Local bird_y#	=	Rnd(1,250);
	Local bird_z#	=	Rnd(-250,250);



Repeat
	
	msx = MouseXSpeed();
	msy = MouseYSpeed();
	
	If Not(MouseDown(2))
		TurnEntity			( player	, 0, -msx, 0 );
		TurnEntity			( head		, +msy, 0, 0 );
	EndIf;
	
	Local vx#, vy#, vz#
		vx	=	Float(KeyDown(32)-KeyDown(30))*0.1;
		vz	=	Float(KeyDown(17)-KeyDown(31))*0.1;
		vy	=	0.0;
	
	MoveEntity				( player	, vx, vy, vz );
	
	
	PositionEntity(bird_target, bird_x, bird_y, bird_z)
	AlignToVector bird, EntityX(bird_target)-EntityX(bird),EntityY(bird_target)-EntityY(bird),EntityZ(bird_target)-EntityZ(bird), 3, .25
	MoveEntity bird, 0,0,2.0
	
	If EntityDistance (bird, bird_target)&lt;10
		bird_x	=	Rnd(-250,250);
		bird_y	=	Rnd(1,250);
		bird_z	=	Rnd(-250,250);
	EndIf;
	
	TurretTarget ( t1, bird, .05 );
	
	RenderWorld();
		Text 10,10,"ZQSD/WASD to move"
		Text 10,25,"Right mouse to freely move the mouse"
	Delay (5);
	Flip (True);
	
Until KeyDown(1);

End;
</textarea> <br><br></td></tr></table><br>
<a name="1283521"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> On an unrelated note, TFormVector and TFormPoint seem confusing to me, since a 3D point is a vector.<br><br>From a quick test, TFormVector seems to ignore the translation of the objects involved. TFormPoint takes the translation into account.<br><br>For example, move a pivot by ( +5, 0, 0 ).<br>If you do TFormPoint( +1, 0, 0, pivot, 0 ), the result is ( +6, 0, 0 ).<br>If you do TFormVector( +1, 0, 0, pivot, 0 ), the result is ( +1, 0, 0 ).<br><br>Both functions take the rotation and scale of the source and destination objects into consideration, but only TFormPoint also uses their position. <br><br></td></tr></table><br>
<a name="1283530"></a>

<a name="1283533"></a>

<a name="1283534"></a>

<a name="1283536"></a>

<a name="1283537"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Actually, the 3 functions do what they say :<br><br>TFormPoint transforms a point (coordinates) seen from the source entity (or world coordinates) then transforms the result relative to the destination entity.<br><br>TFormVector transform a vector (a direction + length)<br>So the result is like a rotation+scale<br><br>TFormNormal is just the same as TFormVector but ends with a normalization of the result vector so its length is 1.0<br><br>For commun use, TFormPoint is required to get "real vertex coordinates"<br>for exemple &gt; TFormPoint(VertexX(surf, v), VertexY(surf, v), VertexZ(surf, v), mesh, camera)<br>will give the vertex coordinates in camera coordinate system (for exemple again, checking TFormedZ()&gt;0 tell you if the vertex is front or back from the camera)<br><br>TFormVector/TFormNormal can be used to retreive a rotation matrix<br>TFormVector(1,0,0, entity, dest) -&gt; vector Xx,Xy,Xz<br>TFormVector(0,1,0, entity, dest) -&gt; vector Yx,Yy,Yz<br>TFormVector(0,0,1, entity, dest) -&gt; vector Zx,Zy,Zz<br><br>for a particle system, its more usefull than TFormPoint<br><br>get vector transformation from the camera for each corner using a transform from camera to mesh like<br>TFormVector (-1,+1,0, camera, Mesh): VULx# = tformedX(): VULy# = tformedY(): VULy# = tformedZ()<br>TFormVector (+1,+1,0, camera, Mesh): VURx# = tformedX(): VURy# = tformedY(): VURy# = tformedZ()<br>TFormVector (+1,-1,0, camera, Mesh): VBRx# = tformedX(): VBRy# = tformedY(): VBRy# = tformedZ()<br>TFormVector (-1,-1,0, camera, Mesh): VBLx# = tformedX(): VBLy# = tformedY(): VBLy# = tformedZ()<br><br>you can now compute easily each particle vertices coordinates.<br>For each particle<br>addvertex ( Surf, particle\X + particle\sx * VULx, particle\Y + particle\sy * VULy, particle\z + VULz ,0.0,0.0 );<br>addvertex ( Surf, particle\X + particle\sx * VURx, particle\Y + particle\sy * VURy, particle\z + VURz ,1.0,0.0 );<br>addvertex ( Surf, particle\X + particle\sx * VBRx, particle\Y + particle\sy * VBRy, particle\z + VBRz ,1.0,1.0 );<br>addvertex ( Surf, particle\X + particle\sx * VBLx, particle\Y + particle\sy * VBLy, particle\z + VBLz ,0.0,1.0 );<br><br>It's fast and more efficient than most particle engines that transform points for each particles ;)<br><br>(and this is the quick and dirty demo you didn't ask)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type Emiter
	Field mesh%
	Field partR.Part ; root
	Field partT.Part ; tail
End Type

Type Part
	Field x#, y#, z#
	Field i0#, j0#, k0#
	Field i1#, j1#, k1#
	Field s#, l#, maxl#
	Field r#, dr#
	Field cr%,cg%,cb%
End Type

Function createEmiter.Emiter(x#,y#,z#)
	Local m.Emiter = New Emiter;
	m\mesh	=	CreateMesh		( );
				CreateSurface	( m\mesh );
				PositionEntity	( m\mesh, x,y,z );
				EntityFX		( m\mesh, 1+2+32 );
	Return m;
End Function

Function emitPart(mtr.Emiter, x#,y#,z#, i0#,j0#,k0#, i1#,j1#,k1#, cr,cg,cb, s#, maxlife#, life#)
	Local p.Part = New Part;
	p\x = x : p\y = y : p\z = z;
	p\i0 = i0 : p\j0 = j0 : p\k0 = k0;
	p\i1 = i1 : p\j1 = j1 : p\k1 = k1;
	p\s = s;
	p\l = life : p\maxl = maxlife;
	p\r = Rand(360);
	p\cr = cr;
	p\cg = cg;
	p\cb = cb;
	p\dr = Rnd(-1,1);
	If mtr\partR = Null
		mtr\partR = p
		Insert p After Last Part
	Else
		Insert p After mtr\partT
	EndIf
	mtr\partT = p
End Function

; release a particle and return the next one
Function freePart.Part(mtr.Emiter, p.Part)
	If p=mtr\partR
		If p=mtr\partT
			Delete p
			mtr\partR = Null;
			mtr\partT = Null;
			Return Null;
		EndIf;
		mtr\partR=After p;
		Delete p;
		Return mtr\partR;
	EndIf;
	
	If p=mtr\partT
		mtr\partT = Before mtr\partT;
		Delete p;
		Return Null;
	EndIf;
	Local p_.Part = After p;
	Delete p;
	Return p_;
End Function

Function updateParts(camera, dt#=16)
	Local coef# = dt * 0.001;
	Local mtr.Emiter
	For mtr = Each Emiter
		
		TFormVector (-1,+1,0, camera, mtr\mesh):Local VULx# = TFormedX(), VULy# = TFormedY(), VULz# = TFormedZ()
		TFormVector (+1,+1,0, camera, mtr\mesh):Local VURx# = TFormedX(), VURy# = TFormedY(), VURz# = TFormedZ()
		TFormVector (+1,-1,0, camera, mtr\mesh):Local VBRx# = TFormedX(), VBRy# = TFormedY(), VBRz# = TFormedZ()
		TFormVector (-1,-1,0, camera, mtr\mesh):Local VBLx# = TFormedX(), VBLy# = TFormedY(), VBLz# = TFormedZ()
		
		Local surf = GetSurface(mtr\mesh,1);
		ClearSurface(surf, True, True)
		Local i_#, j_#, k_#
		
		Local p.Part = mtr\partR;
		While p&lt;&gt;Null
			
			p\l=p\l-dt;
			If p\l&lt;=0
				p = freePart(mtr, p);
				If p=Null Then Exit;
			Else
				Local dl#, idl#
				If p\l&gt;p\maxl/2
					dl  = (p\l-p\maxl/2)/(p\maxl/2);
					idl = 1.0 - dl;
					i_  = p\i0* dl + p\i1*idl;
					j_  = p\j0* dl + p\j1*idl;
					k_  = p\k0* dl + p\k1*idl;
					p\x = p\x + i_*coef;
					p\y = p\y + j_*coef;
					p\z = p\z + k_*coef;
					p\s = p\s + p\s*coef*Cos(90*idl);
				Else
					dl  = (p\l)/(p\maxl/2);
					p\x = p\x + p\i1*coef;
					p\y = p\y + p\j1*coef;
					p\z = p\z + p\k1*coef;
					p\s = p\s - p\s*coef*Cos(90*dl);
				EndIf;
				p\r = p\r + coef*30*p\dr
				Local tu0# = 0.5+0.75*Cos(p\r);
				Local tv0# = 0.5+0.75*Sin(p\r);
				Local tu1# = 0.5+0.75*Cos(p\r+90);
				Local tv1# = 0.5+0.75*Sin(p\r+90);
				Local tu2# = 0.5+0.75*Cos(p\r+180);
				Local tv2# = 0.5+0.75*Sin(p\r+180);
				Local tu3# = 0.5+0.75*Cos(p\r+270);
				Local tv3# = 0.5+0.75*Sin(p\r+270);
				Local v0=	AddVertex	( surf, p\x + p\s * VULx, p\y + p\s * VULy, p\z + p\s * VULz ,tu0,tv0 );
							AddVertex	( surf, p\x + p\s * VURx, p\y + p\s * VURy, p\z + p\s * VURz ,tu1,tv1 );
							AddVertex	( surf, p\x + p\s * VBRx, p\y + p\s * VBRy, p\z + p\s * VBRz ,tu2,tv2 );
							AddVertex	( surf, p\x + p\s * VBLx, p\y + p\s * VBLy, p\z + p\s * VBLz ,tu3,tv3 );
							Local a# = p\l/p\maxl;
							VertexColor	( surf, v0+0, p\cr,p\cg,p\cb, a );
							VertexColor	( surf, v0+1, p\cr,p\cg,p\cb, a );
							VertexColor	( surf, v0+2, p\cr,p\cg,p\cb, a );
							VertexColor	( surf, v0+3, p\cr,p\cg,p\cb, a );
							
							AddTriangle	( surf, v0,v0+1,v0+2 );
							AddTriangle	( surf, v0,v0+2,v0+3 );
							
				If p=mtr\partT Then Exit;
				p = After p;
			EndIf;
			
		Wend;
		
	Next;
End Function

; emiter templates to make smoke and spread a nice Boom effect
Function smoke(mtr.Emiter,turret.TTurret, t#)
	
	TFormPoint (0,0,4, turret\head, mtr\mesh); end of canon is at 4.0 along Z axis
	Local cx#=TFormedX(),cy#=TFormedY(),cz#=TFormedZ();
	Local i=0;
	Local nprt% = Rand(1,2)*(0.5+0.5*t)
	For i=1 To nprt
		TFormVector (Rnd(-.5,.5),Rnd(-.5,.5),2, turret\head, mtr\mesh)
		
		Local dx#=TFormedX(),dy#=TFormedY(),dz#=TFormedZ();
		Local x_#=cx+Rnd(-.25,.25);
		Local y_#=cy+Rnd(-.25,.25);
		Local z_#=cz+Rnd(-.25,.25);
		Local i_#=Rnd(-0.5,0.5);
		Local j_#=Rnd(-0.2,1.0);
		Local k_#=Rnd(-0.5,0.5);
		Local l_#=Rnd(2000,5000);
		Local s_#=Rnd(.2,.5);
		emitPart(mtr, x_,y_,z_, dx*2,dy*2,dz*2, i_*5,j_*5,k_*5, 30,28,25, s_*2+s_*(2.0-t), l_, l_ * t*0.5 )
	Next;

End Function

Function spread(mtr.Emiter,turret.TTurret)
	TFormPoint (0,0,4, turret\head, mtr\mesh); end of canon is at 4.0 along Z axis
	Local cx#=TFormedX(),cy#=TFormedY(),cz#=TFormedZ();
	Local i=0;
	Local nprt% = Rand(100,250)
	For i=1 To nprt
		If i&lt;nprt*3/4
			TFormVector (Rnd(-1,1),Rnd(-1,1),2+Rnd(.5,-.5), turret\head, mtr\mesh)
		Else
			TFormVector (3*Rnd(-.5,.5),3*Rnd(-.5,.5),2+Rnd(3.25,1), turret\head, mtr\mesh)
		EndIf;
		Local dx#=TFormedX(),dy#=TFormedY(),dz#=TFormedZ();
		Local x_#=cx+Rnd(-.25,.25);
		Local y_#=cy+Rnd(-.25,.25);
		Local z_#=cz+Rnd(-.25,.25);
		Local i_#=Rnd(-0.5,0.5)-4;
		Local j_#=Rnd(-0.2,1.0)+.5;
		Local k_#=Rnd(-0.5,0.5);
		Local l_#=Rnd(2000,5000);
		Local s_#=Rnd(.2,.5);
		
		If i&lt;nprt*2/4
			emitPart(mtr, x_,y_,z_, dx*4,dy*4,dz*4, i_,j_,k_, 30,28,25, s_*1.5, l_, l_)
		ElseIf i&lt;nprt*3/4
			emitPart(mtr, x_,y_,z_, dx*5,dy*5,dz*5, i_,j_,k_, 80,75,70, s_*Rnd(1,3), l_, l_)
		Else
			emitPart(mtr, x_,y_,z_, dx*2,dy*2,dz*2, i_*1.2,j_*1.2,k_*1.2, 150,145,130, s_*2, l_, l_)
		EndIf;
	Next;
End Function






; the worst missile library in the world :)
Type Missile
	Field m, l#
End Type

Function launchMissile(turret.TTurret)
	Local m.Missile = New Missile
	m\m = CreateCylinder(6,1)
	m\l = 5000
	ScaleEntity(m\m, turret\canon_radius*0.25, turret\canon_radius*0.25, turret\canon_radius*2)
	PositionEntity m\m, EntityX(turret\head,1), EntityY(turret\head,1), EntityZ(turret\head,1)
	TFormVector (0,0,1, turret\head, 0)
	AlignToVector m\m, TFormedX(), TFormedY(), TFormedZ(), 3, 1
	MoveEntity m\m, 0,0,turret\canon_length
	
End Function

Function updateMissiles(dt#=17)
	Local m.Missile
	Local coef# = dt*0.1
	For m.Missile = Each Missile
		MoveEntity m\m, 0,0,coef
		m\l = m\l-dt
		If m\l&lt;0 Then FreeEntity m\m:Delete m
	Next;
End Function





Type TTurret
	Field piv
	Field head
	Field base
	Field canon
	Field canon_length#
	Field canon_radius#
End Type

Function CreateTurret.TTurret(model, length#, radius#)
	Local t.TTurret = New TTurret;
	t\piv				=	CreatePivot			( );
	t\head				=	CreatePivot			( t\piv );
							MoveEntity			( t\head, 0,5,0 );
	
	t\base				=	CopyEntity			( FindChild(model, "turret_base"), t\piv);
	t\canon				=	CopyEntity			( FindChild(model, "turret_canon"), t\head );
	t\canon_length		=	length;
	t\canon_radius		=	radius;
	Return t;
End Function

Function TurretTarget(t.TTurret, target, rate#=1.0)	
	; vector turret-&gt;target
	Local dx# = EntityX(target,True)-EntityX(t\head,True);
	Local dy# = EntityY(target,True)-EntityY(t\head,True);
	Local dz# = EntityZ(target,True)-EntityZ(t\head,True);
	
	Local pit# = VectorPitch(dx,dy,dz);
	Local yaw# = VectorYaw(dx,dy,dz);
	
	Local curyaw# = EntityYaw(t\piv, True);
	Local curpit# = EntityPitch(t\head,False);
	
	RotateEntity ( t\piv	, 0, curyaw+(yaw-curyaw)*rate, 0, True );
	RotateEntity ( t\head	, curpit+(pit-curpit)*rate, 0, 0, False );
End Function



Function CreateTurretModels( pParent%=0 )
	
	Local turret		=	CreatePivot			( pParent								 );
							NameEntity			( turret		, "turret"				 );
	Local base			=	CreateMesh			( turret								 );
							NameEntity			( base			, "turret_base"			 );
	Local canon			=	CreateMesh			( turret								 );
							NameEntity			( canon			, "turret_canon"		 );
							
	Local Turret_M1		=	CreateCylinder		( 32,1									 ); Ground cube
							FitMesh				( Turret_M1		, -2,0,-2, 4,.5,4		 ); 
	Local Turret_M2		=	CreateCube			( 										 ); body
							FitMesh				( Turret_M2		, -1,.2,-1, 2,4.0,2		 );
	Local Turret_M3		=	CreateCylinder		( 32									 ); Left launcher bloc
							ScaleMesh			( Turret_M3		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M3		, 0,0,90				 );
							PositionMesh		( Turret_M3		, +0.7,3.8,0.0			 );
	Local Turret_M4		=	CreateCylinder		( 32									 ); Right launcher bloc
							ScaleMesh			( Turret_M4		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M4		, 0,0,90				 );
							PositionMesh		( Turret_M4		, -0.7,3.8,0.0			 );
							AddMesh				( Turret_M1		, base );
							AddMesh				( Turret_M2		, base );
							AddMesh				( Turret_M3		, base );
							AddMesh				( Turret_M4		, base );
							
	
	Local Turret_C0		=	CreateCylinder		( 6, 1									 ); rotative cylinder
							RotateMesh			( Turret_C0		, 0,0,90				 );
							FitMesh				( Turret_C0		, -0.8,-.5,-.5,1.6,1,1	 );
							
	Local Turret_C1		=	CreateCylinder		( 16, 1									 ); canon base
							RotateMesh			( Turret_C1		, 90,0,0				 );
							FitMesh				( Turret_C1		, -.4,-.4,0,.8,.8,.7	 );
	Local Turret_C2		=	CreateCylinder		( 16, 1									 ); canon extends
							RotateMesh			( Turret_C2		, 90,0,0				 );
							FitMesh				( Turret_C2		, -.2,-.2,.7,.4,.4,3	 );
	Local Turret_C3		=	CreateCylinder		( 16, 1									 ); canon end
							RotateMesh			( Turret_C3		, 90,0,0				 );
							FitMesh				( Turret_C3		, -.3,-.3,3.7,.6,.6,.3	 );
							
							AddMesh				( Turret_C0		, canon);
							AddMesh				( Turret_C1		, canon);
							AddMesh				( Turret_C2		, canon);
							AddMesh				( Turret_C3		, canon);
							
							FreeEntity			( Turret_M1								 );
							FreeEntity			( Turret_M2								 );
							FreeEntity			( Turret_M3								 );
							FreeEntity			( Turret_M4								 );
							FreeEntity			( Turret_C0								 );
							FreeEntity			( Turret_C1								 );
							FreeEntity			( Turret_C2								 );
							FreeEntity			( Turret_C3								 );
	Return turret;
End Function




Graphics3D 1600,900,0,2
SetBuffer BackBuffer()

	AmbientLight .2,.2,.2
	
	Local ground		=	CreatePlane			( 5										 );
	
	Local skylight		=	CreateLight			( 2 );
							LightColor			( skylight		, 030,035,033			 );
							LightRange			( skylight		, 1000					 );
							PositionEntity		( skylight		, 150,100,150			 );
							
	Local player		=	CreatePivot			( 										 );
	Local head			=	CreatePivot			( player								 );
	Local camera		=	CreateCamera		( head									 );
							CameraClsColor		( camera		, 100,110,130			 );
							CameraClsMode		( camera		, True, True			 );
							CameraRange			( camera		, .1,2000				 );
							PositionEntity		( head			, 0,1.7,0				 );
							PositionEntity		( player		, 0,0,-10				 );
							
	Local camlight		=	CreateLight			( 2, camera								 );
							LightColor			( camlight		, 040,035,030			 );
							LightRange			( camlight		, 5						 );
							
	Local turret_model	=	CreateTurretModels	( 										 );
							HideEntity			( turret_model							 );
	Local t1.TTurret	=	CreateTurret		( turret_model	, 4, .5					 );
	
	
	Local msx#			=	MouseXSpeed			( );
	Local msy#			=	MouseYSpeed			( );


	Local bird			=	CreateSphere		( 16 );
							PositionEntity		( bird			, 50,70,200				 );
	Local bird_target	=	CreateCone			( 16,1									 );
							RotateMesh			( bird_target	, 90,0,0				 );
	
	Local bird_x#		=	Rnd(-250,250);
	Local bird_y#		=	Rnd(1,250);
	Local bird_z#		=	Rnd(-250,250);

	Local mtr.Emiter	=	createEmiter(0,5,0);
	
	Local smokes		=	8
	Local smoketex		=	CreateTexture(smokes,smokes,1+4+16+32+256);
	SetBuffer (TextureBuffer (smoketex))
		LockBuffer()
			Local ti,tj
			For tj = 0 To smokes-1
				For ti = 0 To smokes-1
					Local sm# = 1.0-Sqr((smokes/2-ti)*(smokes/2-ti) + (smokes/2-tj)*(smokes/2-tj))/(smokes/2)
					If sm&lt;=0
						WritePixelFast(ti, tj, $00000000);
					Else
						Local tex_a = (Int(Rand(255*sm)*sm));
						WritePixelFast(ti, tj, $FFFFFF + $01000000*tex_a );
					EndIf
				Next
			Next
		UnlockBuffer()
	SetBuffer BackBuffer()
	EntityTexture mtr\mesh, smoketex
	
	Local emittime%=MilliSecs()
	
Repeat
	
	msx = MouseXSpeed();
	msy = MouseYSpeed();
	
	If Not(MouseDown(2))
		TurnEntity			( player	, 0, -msx, 0 );
		TurnEntity			( head		, +msy, 0, 0 );
	EndIf;
	
	Local vx#, vy#, vz#
		vx	=	Float(KeyDown(32)-KeyDown(30))*0.1;
		vz	=	Float(KeyDown(17)-KeyDown(31))*0.1;
		vy	=	0.0;
	
	MoveEntity				( player	, vx, vy, vz );
	
	PositionEntity(bird_target, bird_x, bird_y, bird_z)
	AlignToVector bird, EntityX(bird_target)-EntityX(bird),EntityY(bird_target)-EntityY(bird),EntityZ(bird_target)-EntityZ(bird), 3, .25
	MoveEntity bird, 0,0,2.0
	
	If EntityDistance (bird, bird_target)&lt;10
		bird_x	=	Rnd(-250,250);
		bird_y	=	Rnd(1,250);
		bird_z	=	Rnd(-250,250);
	EndIf;
	
	TurretTarget ( t1, bird, .05 );
	
	If emittime&gt;MilliSecs()
		smoke (mtr, t1, Float(emittime-MilliSecs())/5000)
	EndIf;
	
	If KeyHit(57)
		
		emittime = MilliSecs()+5000
		
		spread(mtr, t1);
		launchMissile(t1);
		
	EndIf;
	
	updateParts(camera, 17);
	updateMissiles(17)
	
	RenderWorld();
		
		Text 10,10,"ZQSD/WASD to move"
		Text 10,25,"Right mouse to freely move the mouse"
		Text 10,40,"Space to shoot"
		
	Delay (5);
	Flip (True);
	
Until KeyDown(1);

End;</textarea> <br><br></td></tr></table><br>
<a name="1283557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wauw Bobysait, this is a really nice demo and informative too. Can't hit a thing for the target object is moving way to fast, but a very, very pretty demo. Thanks for sharing man. <br><br></td></tr></table><br>
<a name="1283560"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, it's not designed to allow the turret to shoot the target accurately, it's just a "point at target", so it will actually probably never reached it as long as the turret shoots at the current position of the target which is already too late since the bullet can't teleport itself :)<br><br>But, I could implement it using an old code which aims the target relative to its orientation and speed ...<br><br>ps : I didn't sort the particles, so, as it uses alpha (vertex alpha and texture alpha) the Z-sorting should be mandatory.<br>I'll post an update in the afternoon at least whith z-sorting (using a mix of QSort and bubble sort). <br><br></td></tr></table><br>
<a name="1283570"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool! <br><br></td></tr></table><br>
<a name="1283571"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> On an unrelated note, TFormVector and TFormPoint seem confusing to me, since a 3D point is a vector. <br></div><br>The idea is that a point represents a position in space. A vector represents direction and length. A normal is a vector which is perpendicular to something, another vector or vectors or perhaps a surface.<br><br>In traditional mathematics you will see a point depicted as a dot, a vector as an arrow. The direction and length of the arrow are the direction and magnitude of the vector. It often has some physical interpretation such as velocity, which has direction and speed. There are many other uses, such as orientation and strength of a gravitational or electromagnetic field.<br><br>It gets somewhat confusing in programming languages. In 3D space a point or a vector are both represented by an ordered triple of numbers. You can't tell if (1,4,2) is a point or a vector unless I tell you how to interpret it. If it is a vector then it means "one step right, four steps up and two forward".  Starting from point (x,y,z) and applying this vector will give a new point (x+1,y+4,z+2). <br><br>A point is sometimes interpreted as a position vector. In this case we assume the vector (1,4,2) begins at initial point (0,0,0) and ends at point (1,4,2).<br><br>Incidentally, TFormNormal is often misunderstood. The idea is that TFormVector and TFormNormal, when applied to two perpendicular vectors, will preserve perpendicularity. This is trivial if there is no scaling involved, just rigid motions i.e. rotation and movements.<br><br>But scaling changes angles. Imagine a triangle in 2D space. Put a vertex at (-1,0) and another at (1,0). Put the third vertex at (0,1). This has 45 degree angles at the left and right vertices and a right angle at the top.<br><br>Now scale this by multiplying the y-coordinate of all three vertices. The left left and right vertices don't change because y is zero. But the top can become any (0,y). For very large y the triangle is tall and thin. The base angles are almost 90 degrees and the top is close the zero.<br><br>I posted about the TFormNormal issue eight years ago, and gave some code which was old even then. You can tell it's old because my example uses 640x480 full screen graphics. Feel free to change that.<br><br>Here is the post: <a href="http://www.blitzbasic.com/Community/post.php?topic=72322&amp;post=808271" target="_blank">http://www.blitzbasic.com/Community/post.php?topic=72322&amp;post=808271</a> <br><br></td></tr></table><br>
<a name="1283572"></a>

<a name="1283573"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> here it is, Z-sorted particles<br>I put some comments to make the code more understandable<br><br>10 turrets aiming at a single "bird" which they still never will touch (for some reasons previously explained)<br><br>on top, you'll find a TFormPoint function, it is not used at all in the demo, it's just an extra to show the maths behind the scene of this function.<br>Just notice : TFormVector is almost the same function, it just don't use the position of both entities involved.<br><br>And TFormNormal removes the scaling (as mentionned by Floyd)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global g_tformedx#;
Global g_tformedy#;
Global g_tformedz#;
Global g_tfm#[16];


Function TFormPoint_ ( x#, y#, z#, source=0, dest=0 )
	g_tformedx = x : g_tformedy = y : g_tformedz = z;
	
	Local M#[16], MD#[16], scl#[3];
	Local i,j
	
	For j = 0 To 3
		For i = 0 To 3
			If source&lt;&gt;0
				M[i+j*4] = GetMatElement(source, j,i);
			EndIf
			If dest&lt;&gt;0
				MD[i+j*4] = GetMatElement(dest, j,i);
			EndIf
		Next;
	Next;
	
	scl[0] = 1.0 : scl[1] = 1.0 : scl[2] = 1.0;
	
	If (source&lt;&gt;0)
		
		If (dest=0)
			g_tformedx = x * M[0] + y * M[4] + z * M[ 8] + M[12];
			g_tformedy = x * M[1] + y * M[5] + z * M[ 9] + M[13];
			g_tformedz = x * M[2] + y * M[6] + z * M[10] + M[14];
		Else
			Local x_# = x * M[0] + y * M[4] + z * M[ 8] + M[12];
			Local y_# = x * M[1] + y * M[5] + z * M[ 9] + M[13];
			Local z_# = x * M[2] + y * M[6] + z * M[10] + M[14];
			
			m4InvRot2(g_tfm, MD, scl);
			g_tformedx = x_ * g_tfm[0] + y_ * g_tfm[4] + z_ * g_tfm[8] + g_tfm[12];
			g_tformedy = x_ * g_tfm[1] + y_ * g_tfm[5] + z_ * g_tfm[9] + g_tfm[13];
			g_tformedz = x_ * g_tfm[2] + y_ * g_tfm[6] + z_ * g_tfm[10] + g_tfm[14];
		EndIf;
		
	Else
		
		If (dest=0)
			g_tformedx = x : g_tformedy = y : g_tformedz = z;
		Else
			m4InvRot2(g_tfm, MD, scl);
			g_tformedx = x * g_tfm[0] + y * g_tfm[4] + z * g_tfm[8] + g_tfm[12];
			g_tformedy = x * g_tfm[1] + y * g_tfm[5] + z * g_tfm[9] + g_tfm[13];
			g_tformedz = x * g_tfm[2] + y * g_tfm[6] + z * g_tfm[10] + g_tfm[14];
		EndIf;
		
	EndIf;
	
End Function

Function m4InvRot2( dst#[16], src#[16], srcScale#[3] )
	Local tx# = 1.0 / (srcScale[0]*srcScale[0]);
	Local ty# = 1.0 / (srcScale[1]*srcScale[1]);
	Local tz# = 1.0 / (srcScale[2]*srcScale[2]);
	dst[ 0] = src[ 0]*tx;
	dst[ 1] = src[ 4]*ty;
	dst[ 2] = src[ 8]*tz;
	dst[ 3] = 0.0;
	dst[ 4] = src[ 1]*tx;
	dst[ 5] = src[ 5]*ty;
	dst[ 6] = src[ 9]*tz;
	dst[ 7] = 0.0;
	dst[ 8] = src[ 2]*tx;
	dst[ 9] = src[ 6]*ty;
	dst[10] = src[10]*tz;
	dst[11] = 0.0;
	dst[12] = -tx*(src[12]*src[ 0]+src[13]*src[ 1]+src[14]*src[ 2]);
	dst[13] = -ty*(src[12]*src[ 4]+src[13]*src[ 5]+src[14]*src[ 6]);
	dst[14] = -tz*(src[12]*src[ 8]+src[13]*src[ 9]+src[14]*src[10]);
	dst[15] = 1.0;
End Function







Type Emitter
	Field quicksort%
	Field mesh%
	Field partR.Part ; root
	Field partT.Part ; tail
	Field count%;
	Field count_%;
End Type

Type Part
	Field x#, y#, z#
	Field i0#, j0#, k0#
	Field i1#, j1#, k1#
	Field s#, l#, maxl#
	Field r#, dr#
	Field cr%,cg%,cb%
	Field depth#
End Type

Type TZPart
	Field z#
	Field p.Part
End Type

Type TZNPart
	Field z#
	Field p.Part
End Type

Global qSortPart.TZPart[65536]

Function sortPart(mtr.Emitter)
	
	; store parts in an array
	Local zp.TZPart;
	Local zn.TZNPart;
	Local count%=0
	For zp = Each TZPart
		qSortPart[count] = zp;
		count=count+1;
	Next
	
	; sort only if there are at least 2 entries
	If count&gt;1
		fPartSort(0,count-1, count);
		
		; initialize with the first particle
		Insert qSortPart[0] Before First TZPart;
		Local i%
		For i = 1 To count-1
			Insert qSortPart[i] After qSortPart[i-1]
		Next
		
	EndIf;
	
End Function

Function fPartSort(l=-1,r=-1, count)
	
	Local zd.TZPart, i, A=l, B=r, m#;
	
	m = qSortPart[ (l+r)/2 ]\z;
	While True
		
		While m &gt; qSortPart[A]\z
			A = A+1 : If A &gt; r Then Exit;
		Wend;
		
		While  m &lt; qSortPart[B]\z
			B = B - 1 : If B &lt; 0 Then Exit;
		Wend;
		
		If A &gt; B Then Exit;
		
		; swap A and B
		zd = qSortPart[A];
		qSortPart[A] = qSortPart[B];
		qSortPart[B] = zd;
		
		A = A + 1 :  B = B - 1;
		If B &lt; 0 Then Exit;
		
	Wend;
	
	If l &lt; B Then fPartSort( l, B, count );
	If A &lt; r Then fPartSort( A, r, count );
	
End Function

Function bubbleSort(mtr.Emitter, minZ#=0.1)
	
	Local z1.TZPart = First TZPart;
	If z1 = Null Then Return;
	If z1 = Last TZPart Then Return;
	Local z2.TZPart;
	
	; simple pass to switch parts by pair
	; it's not accurate, but it runs on second pass after the QSort which sort efficiently, but slower.
	; Then, as the camera does not move very fast, there is not a lot of particles that really need to be sorted.
	; running bubble sort on several loops will probably be enough.
	While z1&lt;&gt;Null
		z2 = After z1;
		If z2 = Null Then Exit;
		If z1\z&gt;z2\z Then Insert z2 Before z1;
		z1 = After z1;
	Wend;
	
End Function

Function sortEmitter(mtr.Emitter)
	
	Local znR.TZNPart = First TZNPart;
	Local znT.TZNPart = Last TZNPart;
	
	Local zpR.TZPart = First TZPart;
	Local zpT.TZPart = Last TZPart;
	
	Local zn.TZNPart;
	Local zp.TZPart;
	
	If ((znR = Null) And (zpR=Null)) Then Return;
	
	; sort Negative parts first
	If (znR&lt;&gt;Null)
		
		mtr\partR = znR\p;
		zn = znR;
		While zn&lt;&gt;Null
			Insert zn\p After Last Part;
			zn = After zn;
		Wend;
		mtr\partT = Last Part;
		
	Else
		
		mtr\partR = zpR\p;
		
	EndIf;
	
	; add visible parts at last
	If zpR&lt;&gt;Null
		
		zp = zpR;
		While zp&lt;&gt;Null
			Insert zp\p After Last Part;
			zp = After zp;
		Wend;
		mtr\partT = Last Part;
		
	EndIf
	
End Function


Function createEmitter.Emitter(x#,y#,z#)
	Local m.Emitter	=	New Emitter;
	m\mesh			=	CreateMesh		( );
						CreateSurface	( m\mesh );
						PositionEntity	( m\mesh, x,y,z );
						EntityFX		( m\mesh, 1+2+32 );
	m\quicksort		=	False;
	Return m;
End Function

Function emitPart(mtr.Emitter, x#,y#,z#, i0#,j0#,k0#, i1#,j1#,k1#, cr,cg,cb, s#, maxlife#, life#)
	Local p.Part = New Part;
	p\x = x : p\y = y : p\z = z;
	p\i0 = i0 : p\j0 = j0 : p\k0 = k0;
	p\i1 = i1 : p\j1 = j1 : p\k1 = k1;
	p\s = s;
	p\l = life : p\maxl = maxlife;
	p\r = Rand(360);
	p\cr = cr;
	p\cg = cg;
	p\cb = cb;
	p\dr = Rnd(-1,1);
	If mtr\partR = Null
		mtr\partR = p
		Insert p After Last Part
	Else
		Insert p After mtr\partT
	EndIf
	mtr\partT = p
End Function

; release a particle and return the next one
Function freePart.Part(mtr.Emitter, p.Part)
	If p=mtr\partR
		If p=mtr\partT
			mtr\partR = Null;
			mtr\partT = Null;
			Delete p
			Return Null;
		EndIf;
		mtr\partR=After p;
		Delete p;
		Return mtr\partR;
	EndIf;
	
	If p=mtr\partT
		mtr\partT = Before p;
		Delete p;
		Return Null;
	EndIf;
	Local p_.Part = After p;
	Delete p;
	Return p_;
End Function

Function updateParts(camera, rangemin#=.1, dt#=16)
	Local coef# = dt * 0.001;
	Local mtr.Emitter;
	Local zp.TZPart;
	Local zp_.TZPart
	Local zn.TZNPart;
	
	; compute the camera matrix before the loop to improve performances
	TFormVector (1,0,0, camera, 0) : Local cxx# = TFormedX(), cxy# = TFormedY(), cxz# = TFormedZ(); camera X axis
	TFormVector (0,1,0, camera, 0) : Local cyx# = TFormedX(), cyy# = TFormedY(), cyz# = TFormedZ(); camera Y axis
	TFormVector (0,0,1, camera, 0) : Local czx# = TFormedX(), czy# = TFormedY(), czz# = TFormedZ(); camera Z axis
	TFormPoint  (0,0,0, camera, 0) : Local cpx# = TFormedX(), cpy# = TFormedY(), cpz# = TFormedZ(); camera pos
	; invert position of the camera (this is the Z part of the matrix after an invert transform)
	; you can get the same result with a tformpoint but slower as it computes 16 values instead of one.
	Local invcampos# = -(cpx*czx + cpy*czy + cpz*czz);
	
	For mtr = Each Emitter
		
		mtr\count = 0;
		mtr\count_ = 0;
		
		; vector transformation for vertex coords
		TFormVector (-1,+1,0, camera, mtr\mesh):Local VULx# = TFormedX(), VULy# = TFormedY(), VULz# = TFormedZ(); The Top Left vector
		TFormVector (+1,+1,0, camera, mtr\mesh):Local VURx# = TFormedX(), VURy# = TFormedY(), VURz# = TFormedZ(); The Top Right vector
		TFormVector (+1,-1,0, camera, mtr\mesh):Local VBRx# = TFormedX(), VBRy# = TFormedY(), VBRz# = TFormedZ(); The Bottom Right vector
		TFormVector (-1,-1,0, camera, mtr\mesh):Local VBLx# = TFormedX(), VBLy# = TFormedY(), VBLz# = TFormedZ(); The Bottom Left vector
		
		; coords of the Emitter
		Local mx# = EntityX(mtr\mesh,True), my# = EntityY(mtr\mesh,True), mz# = EntityZ(mtr\mesh,True);
		
		; clear the emitter surface
		Local surf = GetSurface(mtr\mesh,1);
		ClearSurface(surf, True, True);
		
		Local i_#, j_#, k_#;
		Local zmin#=0.1, zmax#=0.1;
		Local p.Part = mtr\partR;
		
		While p&lt;&gt;Null
			
			p\l=p\l-dt;
			If p\l&lt;=0
				p = freePart(mtr, p);
				If p=Null Then Exit;
			Else
				
				mtr\count=mtr\count+1
				
				; particle world coords
				Local wx# = p\x + mx;
				Local wy# = p\y + my;
				Local wz# = p\z + mz;
				
				; compute particle depth in camera space
				p\depth = wx * czx + wy * czy + wz * czz + invcampos;
				
				; particle front of the camera
				If p\depth&gt;=rangemin
					
					mtr\count_=mtr\count_+1
					
					; 2 state of spread (allow to make a nicer animation, like wind simulation)
					Local dl#, idl#
					; first state is the spreading velocity
					If p\l&gt;p\maxl/2
						dl  = (p\l-p\maxl/2)/(p\maxl/2);
						idl = 1.0 - dl;
						i_  = p\i0* dl + p\i1*idl;
						j_  = p\j0* dl + p\j1*idl;
						k_  = p\k0* dl + p\k1*idl;
						p\x = p\x + i_*coef;
						p\y = p\y + j_*coef;
						p\z = p\z + k_*coef;
						p\s = p\s + p\s*coef*Cos(90*idl);
						
					; second part is the diffusion (wind or else)
					Else
						dl  = (p\l)/(p\maxl/2);
						p\x = p\x + p\i1*coef;
						p\y = p\y + p\j1*coef;
						p\z = p\z + p\k1*coef;
						p\s = p\s - p\s*coef*Cos(90*dl);
					EndIf;
					
					; rotate the particle ...
					p\r = p\r + coef*30*p\dr
					
					; create an instance of TZPart to sort Z-Depth
					zp = New TZPart;
					zp\z = p\depth;
					zp\p = p;
					
				; particle is not visible
				Else
					
					; create an instance of TZNPart
					zn = New TZNPart;
					zn\z = p\depth;
					zn\p = p;
					
				EndIf;
				
				If p=mtr\partT Then Exit;
				p = After p;
			EndIf;
			
		Wend;
		
		; 2 step to sort particles
		If mtr\quicksort
			; quick sort with a single pass of bubble sort algorithm
			bubbleSort(mtr);
		Else
			; full efficient sort with QSort algorithm (a bit slower but really sort all particles)
			sortPart(mtr);
			; once all particles are sorted, set the Emitter on quicksort, the next frame will sort using the bubble algorithm
			mtr\quicksort = True;
		EndIf;
		
		; recompute the list of particles (the negative one first, the z-sorted last)
		sortEmitter(mtr);
		
		; draw Z-Sorted particles
		zp = Last TZPart
		While zp&lt;&gt;Null
			
			p = zp\p
			Local tu0# = 0.5+0.75*Cos(p\r);
			Local tv0# = 0.5+0.75*Sin(p\r);
			Local tu1# = 0.5+0.75*Cos(p\r+90);
			Local tv1# = 0.5+0.75*Sin(p\r+90);
			Local tu2# = 0.5+0.75*Cos(p\r+180);
			Local tv2# = 0.5+0.75*Sin(p\r+180);
			Local tu3# = 0.5+0.75*Cos(p\r+270);
			Local tv3# = 0.5+0.75*Sin(p\r+270);
			Local v0=	AddVertex	( surf, p\x + p\s * VULx, p\y + p\s * VULy, p\z + p\s * VULz ,tu0,tv0 );
						AddVertex	( surf, p\x + p\s * VURx, p\y + p\s * VURy, p\z + p\s * VURz ,tu1,tv1 );
						AddVertex	( surf, p\x + p\s * VBRx, p\y + p\s * VBRy, p\z + p\s * VBRz ,tu2,tv2 );
						AddVertex	( surf, p\x + p\s * VBLx, p\y + p\s * VBLy, p\z + p\s * VBLz ,tu3,tv3 );
						Local a# = p\l/p\maxl;
						; this can be improved using a single triangle instead of 2 (quad) with better UV coordinates.
						VertexColor	( surf, v0+0, p\cr,p\cg,p\cb, a );
						VertexColor	( surf, v0+1, p\cr,p\cg,p\cb, a );
						VertexColor	( surf, v0+2, p\cr,p\cg,p\cb, a );
						VertexColor	( surf, v0+3, p\cr,p\cg,p\cb, a );
						
						AddTriangle	( surf, v0,v0+1,v0+2 );
						AddTriangle	( surf, v0,v0+2,v0+3 );
						
			zp = Before zp;
			
		Wend
		
		; remove all temporary instances
		Delete Each TZPart;
		Delete Each TZNPart;
		
	Next;
	
End Function


; Emitter templates to make smoke and spread a nice Boom effect
Function smoke(mtr.Emitter,turret.TTurret, t#)
	
	TFormPoint (0,0,4, turret\head, mtr\mesh); end of canon is at 4.0 along Z axis
	Local cx#=TFormedX(),cy#=TFormedY(),cz#=TFormedZ();
	Local i=0;
	Local nprt% = Rand(1,2)*(0.5+0.5*t)
	For i=1 To nprt
		TFormVector (Rnd(-.5,.5),Rnd(-.5,.5),2, turret\head, mtr\mesh)
		
		Local dx#=TFormedX(),dy#=TFormedY(),dz#=TFormedZ();
		Local x_#=cx+Rnd(-.25,.25);
		Local y_#=cy+Rnd(-.25,.25);
		Local z_#=cz+Rnd(-.25,.25);
		Local i_#=Rnd(-0.5,0.5);
		Local j_#=Rnd(-0.2,1.0);
		Local k_#=Rnd(-0.5,0.5);
		Local l_#=Rnd(2000,5000);
		Local s_#=Rnd(.2,.5);
		emitPart(mtr, x_,y_,z_, dx*2,dy*2,dz*2, i_*5,j_*5,k_*5, 30,28,25, s_*2+s_*(2.0-t), l_, l_ * t*0.5 )
	Next;
	
	; disable quicksort for the first pass, so all particles emitted will be sorted
	mtr\quicksort = False;
End Function

Function spread(mtr.Emitter,turret.TTurret)
	TFormPoint (0,0,4, turret\head, mtr\mesh); end of canon is at 4.0 along Z axis
	Local cx#=TFormedX(),cy#=TFormedY(),cz#=TFormedZ();
	Local i=0;
	Local nprt% = Rand(100,250)*.3
	For i=1 To nprt
		If i&lt;nprt*3/4
			TFormVector (Rnd(-1,1),Rnd(-1,1),2+Rnd(.5,-.5), turret\head, mtr\mesh)
		Else
			TFormVector (3*Rnd(-.5,.5),3*Rnd(-.5,.5),2+Rnd(3.25,1), turret\head, mtr\mesh)
		EndIf;
		Local dx#=TFormedX(),dy#=TFormedY(),dz#=TFormedZ();
		Local x_#=cx+Rnd(-.25,.25);
		Local y_#=cy+Rnd(-.25,.25);
		Local z_#=cz+Rnd(-.25,.25);
		Local i_#=Rnd(-0.5,0.5)-4;
		Local j_#=Rnd(-0.2,1.0)+.5;
		Local k_#=Rnd(-0.5,0.5);
		Local l_#=Rnd(2000,5000);
		Local s_#=Rnd(.2,.5);
		
		If i&lt;nprt*2/4
			emitPart(mtr, x_,y_,z_, dx*4,dy*4,dz*4, i_,j_,k_, 30,28,25, s_*1.5, l_*2, l_*1.75)
		ElseIf i&lt;nprt*3/4
			emitPart(mtr, x_,y_,z_, dx*5,dy*5,dz*5, i_,j_,k_, 80,75,70, s_*Rnd(1,3), l_*2, l_*1.75)
		Else
			emitPart(mtr, x_,y_,z_, dx*2,dy*2,dz*2, i_*1.2,j_*1.2,k_*1.2, 170,165,150, s_*2, l_*2, l_*1.75)
			emitPart(mtr, x_,y_,z_, dx*3.5,dy*3.5,dz*3.5, i_*1.5,j_*1.5,k_*1.5, 230,220,215, s_*4, l_*2, l_*1.75)
		EndIf;
		If i&gt;nprt*2/6
			emitPart(mtr, x_,y_,z_, -dx*1.5,-dy*1.5,-dz*1.5, i_,j_,k_, 10,13,20, s_*1.8, l_, l_)
		EndIf
	Next;
	
	; disable quicksort for the first pass, so all particles emitted will be sorted
	mtr\quicksort = False;
End Function






; the worst missile library in the world :)
Type Missile
	Field m, l#
End Type

Function launchMissile(turret.TTurret)
	Local m.Missile = New Missile
	m\m = CreateCylinder(6,1)
	m\l = 5000
	ScaleEntity(m\m, turret\canon_radius*0.25, turret\canon_radius*0.25, turret\canon_radius*2)
	PositionEntity m\m, EntityX(turret\head,1), EntityY(turret\head,1), EntityZ(turret\head,1)
	TFormVector (0,0,1, turret\head, 0)
	AlignToVector m\m, TFormedX(), TFormedY(), TFormedZ(), 3, 1
	MoveEntity m\m, 0,0,turret\canon_length
	
End Function

Function updateMissiles(dt#=17)
	Local m.Missile
	Local coef# = dt*0.1
	For m.Missile = Each Missile
		MoveEntity m\m, 0,0,coef
		m\l = m\l-dt
		If m\l&lt;0 Then FreeEntity m\m:Delete m
	Next;
End Function





Type TTurret
	Field piv, head, base, canon
	Field canon_length#, canon_radius#
	Field shootTime%, shootFreq%
	Field smokeTime%, smokeFreq%
End Type

Function CreateTurret.TTurret(model, length#, radius#)
	Local t.TTurret = New TTurret;
	t\piv				=	CreatePivot			( );
	t\head				=	CreatePivot			( t\piv );
							MoveEntity			( t\head, 0,5,0 );
	
	t\base				=	CopyEntity			( FindChild(model, "turret_base"), t\piv);
	t\canon				=	CopyEntity			( FindChild(model, "turret_canon"), t\head );
	t\canon_length		=	length;
	t\canon_radius		=	radius;
	t\shootFreq			=	Rand(2000,10000);
	t\shootTime			=	MilliSecs()+t\shootFreq;
	t\smokeTime			=	0;
	Return t;
End Function

Function TurretTarget(t.TTurret, target, rate#=1.0)	
	; vector turret-&gt;target
	Local dx# = EntityX(target,True)-EntityX(t\head,True);
	Local dy# = EntityY(target,True)-EntityY(t\head,True);
	Local dz# = EntityZ(target,True)-EntityZ(t\head,True);
	
	Local pit# = VectorPitch(dx,dy,dz);
	Local yaw# = VectorYaw(dx,dy,dz);
	
	Local curyaw# = EntityYaw(t\piv, True);
	Local curpit# = EntityPitch(t\head,False);
	
	RotateEntity ( t\piv	, 0, curyaw+(yaw-curyaw)*rate, 0, True );
	RotateEntity ( t\head	, curpit+(pit-curpit)*rate, 0, 0, False );
End Function



Function CreateTurretModels( pParent%=0 )
	
	Local turret		=	CreatePivot			( pParent								 );
							NameEntity			( turret		, "turret"				 );
	Local base			=	CreateMesh			( turret								 );
							NameEntity			( base			, "turret_base"			 );
	Local canon			=	CreateMesh			( turret								 );
							NameEntity			( canon			, "turret_canon"		 );
							
	Local Turret_M1		=	CreateCylinder		( 32,1									 ); Ground cube
							FitMesh				( Turret_M1		, -2,0,-2, 4,.5,4		 ); 
	Local Turret_M2		=	CreateCube			( 										 ); body
							FitMesh				( Turret_M2		, -1,.2,-1, 2,4.0,2		 );
	Local Turret_M3		=	CreateCylinder		( 32									 ); Left launcher bloc
							ScaleMesh			( Turret_M3		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M3		, 0,0,90				 );
							PositionMesh		( Turret_M3		, +0.7,3.8,0.0			 );
	Local Turret_M4		=	CreateCylinder		( 32									 ); Right launcher bloc
							ScaleMesh			( Turret_M4		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M4		, 0,0,90				 );
							PositionMesh		( Turret_M4		, -0.7,3.8,0.0			 );
							AddMesh				( Turret_M1		, base );
							AddMesh				( Turret_M2		, base );
							AddMesh				( Turret_M3		, base );
							AddMesh				( Turret_M4		, base );
							
	
	Local Turret_C0		=	CreateCylinder		( 6, 1									 ); rotative cylinder
							RotateMesh			( Turret_C0		, 0,0,90				 );
							FitMesh				( Turret_C0		, -0.8,-.5,-.5,1.6,1,1	 );
							
	Local Turret_C1		=	CreateCylinder		( 16, 1									 ); canon base
							RotateMesh			( Turret_C1		, 90,0,0				 );
							FitMesh				( Turret_C1		, -.4,-.4,0,.8,.8,.7	 );
	Local Turret_C2		=	CreateCylinder		( 16, 1									 ); canon extends
							RotateMesh			( Turret_C2		, 90,0,0				 );
							FitMesh				( Turret_C2		, -.2,-.2,.7,.4,.4,3	 );
	Local Turret_C3		=	CreateCylinder		( 16, 1									 ); canon end
							RotateMesh			( Turret_C3		, 90,0,0				 );
							FitMesh				( Turret_C3		, -.3,-.3,3.7,.6,.6,.3	 );
							
							AddMesh				( Turret_C0		, canon);
							AddMesh				( Turret_C1		, canon);
							AddMesh				( Turret_C2		, canon);
							AddMesh				( Turret_C3		, canon);
							
							FreeEntity			( Turret_M1								 );
							FreeEntity			( Turret_M2								 );
							FreeEntity			( Turret_M3								 );
							FreeEntity			( Turret_M4								 );
							FreeEntity			( Turret_C0								 );
							FreeEntity			( Turret_C1								 );
							FreeEntity			( Turret_C2								 );
							FreeEntity			( Turret_C3								 );
	Return turret;
End Function




Graphics3D 1600,900,0,2
SetBuffer BackBuffer()

	AmbientLight .2,.2,.2
	
	Local ground		=	CreatePlane			( 5										 );
	
	Local skylight		=	CreateLight			( 2 );
							LightColor			( skylight		, 030,035,033			 );
							LightRange			( skylight		, 1000					 );
							PositionEntity		( skylight		, 150,100,150			 );
							
	Local player		=	CreatePivot			( 										 );
	Local head			=	CreatePivot			( player								 );
	Local camera		=	CreateCamera		( head									 );
							CameraClsColor		( camera		, 100,110,130			 );
							CameraClsMode		( camera		, True, True			 );
							CameraRange			( camera		, .1,2000				 );
							PositionEntity		( head			, 0,1.7,0				 );
							PositionEntity		( player		, 0,0,-10				 );
							
	Local camlight		=	CreateLight			( 2, camera								 );
							LightColor			( camlight		, 040,035,030			 );
							LightRange			( camlight		, 5						 );
							
	Local turret_model	=	CreateTurretModels	( 										 );
							HideEntity			( turret_model							 );
	
	Local nbTurret = 10, it, turret.TTurret;
	For it = 0 To nbTurret-1
		turret			=	CreateTurret		( turret_model	, 4, .5					 );
							PositionEntity		( turret\piv	, -25+it*5,0,0			 );
	Next;
	
	Local bird			=	CreateSphere		( 16 );
							PositionEntity		( bird			, 50,70,200				 );
	Local bird_target	=	CreateCone			( 16,1									 );
							RotateMesh			( bird_target	, 90,0,0				 );
	
	Local bird_x#		=	Rnd(-250,250);
	Local bird_y#		=	Rnd(1,250);
	Local bird_z#		=	Rnd(-250,250);

	Local mtr.Emitter	=	createEmitter(0,5,0);
	
	Local smokes		=	8
	Local smoketex		=	CreateTexture(smokes,smokes,1+4+16+32+256);
	SetBuffer (TextureBuffer (smoketex))
		LockBuffer()
			Local ti,tj
			For tj = 0 To smokes-1
				For ti = 0 To smokes-1
					Local sm# = 1.0-Sqr((smokes/2-ti)*(smokes/2-ti) + (smokes/2-tj)*(smokes/2-tj))/(smokes/2)
					If sm&lt;=0
						WritePixelFast(ti, tj, $00000000);
					Else
						Local tex_a = (Int(Rand(255*sm)*sm));
						WritePixelFast(ti, tj, $FFFFFF + $01000000*tex_a );
					EndIf
				Next
			Next
		UnlockBuffer()
	SetBuffer BackBuffer()
	EntityTexture mtr\mesh, smoketex
	
	Local emittime%=MilliSecs()
	
	Local freqSpread = 500
	Local spreadtime = MilliSecs()+freqSpread
	
	MouseXSpeed();
	MouseYSpeed();
	
Repeat
	
	Local msx#			=	MouseXSpeed			( );
	Local msy#			=	MouseYSpeed			( );
	
	If Not(MouseDown(2))
		TurnEntity			( player	, 0, -msx, 0 );
		TurnEntity			( head		, +msy, 0, 0 );
	EndIf;
	
	Local vx#, vy#, vz#
		vx	=	Float(KeyDown(32)-KeyDown(30))*0.1;
		vz	=	Float(KeyDown(17)-KeyDown(31))*0.1;
		vy	=	0.0;
	
	MoveEntity				( player	, vx, vy, vz );
	
	PositionEntity(bird_target, bird_x, bird_y, bird_z)
	AlignToVector bird, EntityX(bird_target)-EntityX(bird),EntityY(bird_target)-EntityY(bird),EntityZ(bird_target)-EntityZ(bird), 3, .25
	MoveEntity bird, 0,0,2.0
	
	If EntityDistance (bird, bird_target)&lt;10
		bird_x	=	Rnd(-250,250);
		bird_y	=	Rnd(1,250);
		bird_z	=	Rnd(-250,250);
	EndIf;
	
	For turret = Each TTurret
		; turret aims the bird
		TurretTarget ( turret, bird, .05 );
		
		; if time to shoot ... shoot !
		If (turret\shootTime&lt;MilliSecs())
			
			spread(mtr, turret);
			launchMissile(turret);
			
			turret\shootTime	=	turret\shootTime+turret\shootFreq;
			; update smoke time
			turret\smokeTime=MilliSecs()+turret\smokeFreq
			
		EndIf;
		
		; spread some smoke after a shoot
		
		If turret\smokeTime&gt;MilliSecs()
			smoke (mtr, turret, Float(turret\smokeTime-MilliSecs())/turret\smokeFreq)
		EndIf;
		
	Next;
	
	Local prtt0 = MilliSecs();
	updateParts(camera, .1, 17);
	Local prtt1 = MilliSecs();
	
	updateMissiles(17)
	
	RenderWorld();
		
		Text 10,10,"ZQSD/WASD to move"
		Text 10,25,"Right mouse to freely move the mouse"
		Text 10,40,"Space to shoot"
		
		Text 10, 55,"tris   : "+TrisRendered();
		Text 10, 85,"mtr  Nb: "+mtr\count_+"/"+mtr\count;
		Text 10,130,"part T : "+(prtt1-prtt0)+".ms";
		
	Delay (5);
	Flip (True);
	
Until KeyDown(1);

End;</textarea> <br><br></td></tr></table><br>
<a name="1283578"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Amazing stuff, love the clouds, and that all in code! Great stuff. <br><br></td></tr></table><br>
<a name="1283581"></a>

<a name="1283582"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you want to hit a target which is moving and which takes velocity but not acceleration into account I did a code archives entry earlier in the year......<br><br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=3184" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=3184</a><br><br>Explanation and example (javascript but blitz is much the same)<br><a href="http://mattiesgames.com/webfolder/index.html" target="_blank">http://mattiesgames.com/webfolder/index.html</a> <br><br></td></tr></table><br>
<a name="1283584"></a>

<a name="1283585"></a>

<a name="1283590"></a>

<a name="1283591"></a>

<a name="1283592"></a>

<a name="1283600"></a>

<a name="1283601"></a>

<a name="1283605"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Matty: thanks but I already have a function for that (did it myself long time ago)<br><br><br>A bit messy, but now, the turret shoot (and kill) the birds.<br>nothing to do but watch.<br><br>(ZQSD to move, Right Mouse Down to rotate the camera)<br>F1 - show debug lines (current aiming)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global g_tformedx#;
Global g_tformedy#;
Global g_tformedz#;
Global g_tfm#[16];


Function TFormPoint_ ( x#, y#, z#, source=0, dest=0 )
	g_tformedx = x : g_tformedy = y : g_tformedz = z;
	
	Local M#[16], MD#[16], scl#[3];
	Local i,j
	
	For j = 0 To 3
		For i = 0 To 3
			If source&lt;&gt;0
				M[i+j*4] = GetMatElement(source, j,i);
			EndIf
			If dest&lt;&gt;0
				MD[i+j*4] = GetMatElement(dest, j,i);
			EndIf
		Next;
	Next;
	
	scl[0] = 1.0 : scl[1] = 1.0 : scl[2] = 1.0;
	
	If (source&lt;&gt;0)
		
		If (dest=0)
			g_tformedx = x * M[0] + y * M[4] + z * M[ 8] + M[12];
			g_tformedy = x * M[1] + y * M[5] + z * M[ 9] + M[13];
			g_tformedz = x * M[2] + y * M[6] + z * M[10] + M[14];
		Else
			Local x_# = x * M[0] + y * M[4] + z * M[ 8] + M[12];
			Local y_# = x * M[1] + y * M[5] + z * M[ 9] + M[13];
			Local z_# = x * M[2] + y * M[6] + z * M[10] + M[14];
			
			m4InvRot2(g_tfm, MD, scl);
			g_tformedx = x_ * g_tfm[0] + y_ * g_tfm[4] + z_ * g_tfm[8] + g_tfm[12];
			g_tformedy = x_ * g_tfm[1] + y_ * g_tfm[5] + z_ * g_tfm[9] + g_tfm[13];
			g_tformedz = x_ * g_tfm[2] + y_ * g_tfm[6] + z_ * g_tfm[10] + g_tfm[14];
		EndIf;
		
	Else
		
		If (dest=0)
			g_tformedx = x : g_tformedy = y : g_tformedz = z;
		Else
			m4InvRot2(g_tfm, MD, scl);
			g_tformedx = x * g_tfm[0] + y * g_tfm[4] + z * g_tfm[8] + g_tfm[12];
			g_tformedy = x * g_tfm[1] + y * g_tfm[5] + z * g_tfm[9] + g_tfm[13];
			g_tformedz = x * g_tfm[2] + y * g_tfm[6] + z * g_tfm[10] + g_tfm[14];
		EndIf;
		
	EndIf;
	
End Function

Function m4InvRot2( dst#[16], src#[16], srcScale#[3] )
	Local tx# = 1.0 / (srcScale[0]*srcScale[0]);
	Local ty# = 1.0 / (srcScale[1]*srcScale[1]);
	Local tz# = 1.0 / (srcScale[2]*srcScale[2]);
	dst[ 0] = src[ 0]*tx;
	dst[ 1] = src[ 4]*ty;
	dst[ 2] = src[ 8]*tz;
	dst[ 3] = 0.0;
	dst[ 4] = src[ 1]*tx;
	dst[ 5] = src[ 5]*ty;
	dst[ 6] = src[ 9]*tz;
	dst[ 7] = 0.0;
	dst[ 8] = src[ 2]*tx;
	dst[ 9] = src[ 6]*ty;
	dst[10] = src[10]*tz;
	dst[11] = 0.0;
	dst[12] = -tx*(src[12]*src[ 0]+src[13]*src[ 1]+src[14]*src[ 2]);
	dst[13] = -ty*(src[12]*src[ 4]+src[13]*src[ 5]+src[14]*src[ 6]);
	dst[14] = -tz*(src[12]*src[ 8]+src[13]*src[ 9]+src[14]*src[10]);
	dst[15] = 1.0;
End Function




Type TV3 Field x#,y#,z# End Type
Function NewV3.TV3(x#=0.0,y#=0.0,z#=0.0):Local v.TV3=New TV3:v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3Assign.TV3(v.TV3,src.TV3):v\x=src\x:v\y=src\y:v\z=src\z:Return v:End Function
Function V3Copy.TV3(src.TV3):Return V3Assign(NewV3(),src):End Function
Function V3set.TV3(v.TV3,x#,y#,z#):v\x=x:v\y=y:v\z=z:Return v:End Function
Function V3normalize.TV3(v.TV3):Return V3mulScalar(v,Float(1.0)/V3Norm(v)):End Function
Function V3normalized.TV3(v.TV3):Return V3normalize(V3Copy(v)):End Function
Function V3Add.TV3(v1.TV3,v2.TV3):v1\x=v1\x+v2\x:v1\y=v1\y+v2\y:v1\z=v1\z+v2\z:Return v1:End Function
Function V3AddScalars.TV3(v.TV3,x#,y#,z#):Return V3set(v,v\x+x,v\y+y,v\z+z):End Function
Function V3Sub.TV3(v1.TV3,v2.TV3):v1\x=v1\x-v2\x:v1\y=v1\y-v2\y:v1\z=v1\z-v2\z:Return v1:End Function
Function V3Negate.TV3(v.TV3):v\x=-v\x:v\y=-v\y:v\z=-v\z:Return v:End Function
Function V3mulScalar.TV3(v.TV3,s#):v\x=v\x*s:v\y=v\y*s:v\z=v\z*s:Return v:End Function
Function V3Dot#(a.TV3,b.TV3):Return a\x*b\x+a\y*b\y+a\z*b\z:End Function
Function V3Norm2#(v.TV3):Return V3Dot(v,v):End Function
Function V3Norm#(v.TV3):Return Sqr(V3Norm2(v)):End Function
Function V3Mul.TV3(a.TV3,b.TV3):a\x=a\x*b\x:a\y=a\y*b\y:a\z=a\z*b\z:Return a:End Function
Function V3cross.TV3(a.TV3,b.TV3):Return NewV3(a\y*b\z-a\z*b\y, a\z*b\x-a\x*b\z, a\x*b\y-a\y*b\x):End Function
Function V3Lerp.TV3(v.TV3,dest.TV3,rate#):Local t.TV3=V3mulScalar(V3Sub(V3Copy(dest),v),rate):V3Add(v,t):Delete t:Return V3normalize(v):End Function
Function V3Slerp.TV3(v.TV3, dest.TV3, rate#)
	Local dot# = V3Dot(v,dest):If dot&lt;-1:dot=-1:ElseIf dot&gt;1:dot=1:EndIf
	Local theta# = ACos(dot)*rate
	Local t.TV3=V3mulScalar(V3normalize(V3Add(V3mulScalar(V3Copy(v),-dot),dest)),Sin(theta))
	V3Add(V3mulScalar(v,Cos(theta)), t):Delete t
	Return v
End Function

; stores the EmitterDirection vector in @Result vector
; returns the time (as float) of the predicted collision
Function ExtrapolatedInTime#(Result.TV3, E.TV3, E_Velocity#, T.TV3, T_Dir.TV3, T_Velocity#)
	Local In# = T_Velocity/Sqr(T_Dir\x*T_Dir\x+T_Dir\y*T_Dir\y+T_Dir\z*T_Dir\z);
	Local Ix# = T_Dir\x*In, Iy# = T_Dir\y*In, Iz# = T_Dir\z*In;
	Local a# = Ix*Ix+Iy*Iy+Iz*Iz - E_Velocity*E_Velocity;
	Local dTEx# = (T\x-E\x), dTEy# = (T\y-E\y), dTEz# = (T\z-E\z);
	Local b# = + Float(2.0)*( dTEx*Ix + dTEy*Iy + dTEz*Iz );
	Local c# = (dTEx*dTEx+dTEy*dTEy+dTEz*dTEz);
	Local Det# = b*b-4.0*a*c;
	Local time#=0.0;
	If Det&lt;0 Then Return -1;
	If Det&gt;0:Det=Sqr(Det):time = -0.5*(b-Det)/a:If time&lt;0 Then time=-0.5*(b+Det)/a;
	Else:time = -0.5*b/a;
	EndIf;
	Result = V3normalize(V3Sub(V3AddScalars(V3Assign(Result,T),time*Ix,time*Iy,time*Iz),E));
	Return time;
End Function



Type Emitter
	Field quicksort%
	Field mesh%
	Field partR.Part ; root
	Field partT.Part ; tail
	Field count%;
	Field count_%;
End Type

Type Part
	Field x#, y#, z#
	Field i0#, j0#, k0#
	Field i1#, j1#, k1#
	Field s#, l#, maxl#
	Field r#, dr#
	Field cr%,cg%,cb%
	Field depth#
End Type

Type TZPart
	Field z#
	Field p.Part
End Type

Type TZNPart
	Field z#
	Field p.Part
End Type

Global qSortPart.TZPart[65536]

Function sortPart(mtr.Emitter)
	
	; store parts in an array
	Local zp.TZPart;
	Local zn.TZNPart;
	Local count%=0
	For zp = Each TZPart
		qSortPart[count] = zp;
		count=count+1;
	Next
	
	; sort only if there are at least 2 entries
	If count&gt;1
		fPartSort(0,count-1, count);
		
		; initialize with the first particle
		Insert qSortPart[0] Before First TZPart;
		Local i%
		For i = 1 To count-1
			Insert qSortPart[i] After qSortPart[i-1]
		Next
		
	EndIf;
	
End Function

Function fPartSort(l=-1,r=-1, count)
	
	Local zd.TZPart, i, A=l, B=r, m#;
	
	m = qSortPart[ (l+r)/2 ]\z;
	While True
		
		While m &gt; qSortPart[A]\z
			A = A+1 : If A &gt; r Then Exit;
		Wend;
		
		While  m &lt; qSortPart[B]\z
			B = B - 1 : If B &lt; 0 Then Exit;
		Wend;
		
		If A &gt; B Then Exit;
		
		; swap A and B
		zd = qSortPart[A];
		qSortPart[A] = qSortPart[B];
		qSortPart[B] = zd;
		
		A = A + 1 :  B = B - 1;
		If B &lt; 0 Then Exit;
		
	Wend;
	
	If l &lt; B Then fPartSort( l, B, count );
	If A &lt; r Then fPartSort( A, r, count );
	
End Function

Function bubbleSort(mtr.Emitter, minZ#=0.1)
	
	Local z1.TZPart = First TZPart;
	If z1 = Null Then Return;
	If z1 = Last TZPart Then Return;
	Local z2.TZPart;
	
	; simple pass to switch parts by pair
	; it's not accurate, but it runs on second pass after the QSort which sort efficiently, but slower.
	; Then, as the camera does not move very fast, there is not a lot of particles that really need to be sorted.
	; running bubble sort on several loops will probably be enough.
	While z1&lt;&gt;Null
		z2 = After z1;
		If z2 = Null Then Exit;
		If z1\z&gt;z2\z Then Insert z2 Before z1;
		z1 = After z1;
	Wend;
	
End Function

Function sortEmitter(mtr.Emitter)
	
	Local znR.TZNPart = First TZNPart;
	Local znT.TZNPart = Last TZNPart;
	
	Local zpR.TZPart = First TZPart;
	Local zpT.TZPart = Last TZPart;
	
	Local zn.TZNPart;
	Local zp.TZPart;
	
	If ((znR = Null) And (zpR=Null)) Then Return;
	
	; sort Negative parts first
	If (znR&lt;&gt;Null)
		
		mtr\partR = znR\p;
		zn = znR;
		While zn&lt;&gt;Null
			Insert zn\p After Last Part;
			zn = After zn;
		Wend;
		mtr\partT = Last Part;
		
	Else
		
		mtr\partR = zpR\p;
		
	EndIf;
	
	; add visible parts at last
	If zpR&lt;&gt;Null
		
		zp = zpR;
		While zp&lt;&gt;Null
			Insert zp\p After Last Part;
			zp = After zp;
		Wend;
		mtr\partT = Last Part;
		
	EndIf
	
End Function


Function createEmitter.Emitter(x#,y#,z#)
	Local m.Emitter	=	New Emitter;
	m\mesh			=	CreateMesh		( );
						CreateSurface	( m\mesh );
						PositionEntity	( m\mesh, x,y,z );
						EntityFX		( m\mesh, 1+2+32 );
	m\quicksort		=	False;
	Return m;
End Function

Function emitPart(mtr.Emitter, x#,y#,z#, i0#,j0#,k0#, i1#,j1#,k1#, cr,cg,cb, s#, maxlife#, life#)
	Local p.Part = New Part;
	p\x = x : p\y = y : p\z = z;
	p\i0 = i0 : p\j0 = j0 : p\k0 = k0;
	p\i1 = i1 : p\j1 = j1 : p\k1 = k1;
	p\s = s;
	p\l = life : p\maxl = maxlife;
	p\r = Rand(360);
	p\cr = cr;
	p\cg = cg;
	p\cb = cb;
	p\dr = Rnd(-1,1);
	If mtr\partR = Null
		mtr\partR = p
		Insert p After Last Part
	Else
		Insert p After mtr\partT
	EndIf
	mtr\partT = p
End Function

; release a particle and return the next one
Function freePart.Part(mtr.Emitter, p.Part)
	If p=mtr\partR
		If p=mtr\partT
			mtr\partR = Null;
			mtr\partT = Null;
			Delete p
			Return Null;
		EndIf;
		mtr\partR=After p;
		Delete p;
		Return mtr\partR;
	EndIf;
	
	If p=mtr\partT
		mtr\partT = Before p;
		Delete p;
		Return Null;
	EndIf;
	Local p_.Part = After p;
	Delete p;
	Return p_;
End Function

Function updateParts(camera, rangemin#=.1, dt#=16)
	Local coef# = dt * 0.001;
	Local mtr.Emitter;
	Local zp.TZPart;
	Local zp_.TZPart
	Local zn.TZNPart;
	
	; compute the camera matrix before the loop to improve performances
	TFormVector (1,0,0, camera, 0) : Local cxx# = TFormedX(), cxy# = TFormedY(), cxz# = TFormedZ(); camera X axis
	TFormVector (0,1,0, camera, 0) : Local cyx# = TFormedX(), cyy# = TFormedY(), cyz# = TFormedZ(); camera Y axis
	TFormVector (0,0,1, camera, 0) : Local czx# = TFormedX(), czy# = TFormedY(), czz# = TFormedZ(); camera Z axis
	TFormPoint  (0,0,0, camera, 0) : Local cpx# = TFormedX(), cpy# = TFormedY(), cpz# = TFormedZ(); camera pos
	; invert position of the camera (this is the Z part of the matrix after an invert transform)
	; you can get the same result with a tformpoint but slower as it computes 16 values instead of one.
	Local invcampos# = -(cpx*czx + cpy*czy + cpz*czz);
	
	For mtr = Each Emitter
		
		mtr\count = 0;
		mtr\count_ = 0;
		
		; vector transformation for vertex coords
		TFormVector (-1,+1,0, camera, mtr\mesh):Local VULx# = TFormedX(), VULy# = TFormedY(), VULz# = TFormedZ(); The Top Left vector
		TFormVector (+1,+1,0, camera, mtr\mesh):Local VURx# = TFormedX(), VURy# = TFormedY(), VURz# = TFormedZ(); The Top Right vector
		TFormVector (+1,-1,0, camera, mtr\mesh):Local VBRx# = TFormedX(), VBRy# = TFormedY(), VBRz# = TFormedZ(); The Bottom Right vector
		TFormVector (-1,-1,0, camera, mtr\mesh):Local VBLx# = TFormedX(), VBLy# = TFormedY(), VBLz# = TFormedZ(); The Bottom Left vector
		
		; coords of the Emitter
		Local mx# = EntityX(mtr\mesh,True), my# = EntityY(mtr\mesh,True), mz# = EntityZ(mtr\mesh,True);
		
		; clear the emitter surface
		Local surf = GetSurface(mtr\mesh,1);
		ClearSurface(surf, True, True);
		
		Local i_#, j_#, k_#;
		Local zmin#=0.1, zmax#=0.1;
		Local p.Part = mtr\partR;
		
		While p&lt;&gt;Null
			
			p\l=p\l-dt;
			If p\l&lt;=0
				p = freePart(mtr, p);
				If p=Null Then Exit;
			Else
				
				mtr\count=mtr\count+1
				
				; particle world coords
				Local wx# = p\x + mx;
				Local wy# = p\y + my;
				Local wz# = p\z + mz;
				
				; compute particle depth in camera space
				p\depth = wx * czx + wy * czy + wz * czz + invcampos;
				
				; particle front of the camera
				If p\depth&gt;=rangemin
					
					mtr\count_=mtr\count_+1
					
					; 2 state of spread (allow to make a nicer animation, like wind simulation)
					Local dl#, idl#
					; first state is the spreading velocity
					If p\l&gt;p\maxl/2
						dl  = (p\l-p\maxl/2)/(p\maxl/2);
						idl = 1.0 - dl;
						i_  = p\i0* dl + p\i1*idl;
						j_  = p\j0* dl + p\j1*idl;
						k_  = p\k0* dl + p\k1*idl;
						p\x = p\x + i_*coef;
						p\y = p\y + j_*coef;
						p\z = p\z + k_*coef;
						p\s = p\s + p\s*coef*Cos(90*idl);
						
					; second part is the diffusion (wind or else)
					Else
						dl  = (p\l)/(p\maxl/2);
						p\x = p\x + p\i1*coef;
						p\y = p\y + p\j1*coef;
						p\z = p\z + p\k1*coef;
						p\s = p\s - p\s*coef*Cos(90*dl);
					EndIf;
					
					; rotate the particle ...
					p\r = p\r + coef*30*p\dr
					
					; create an instance of TZPart to sort Z-Depth
					zp = New TZPart;
					zp\z = p\depth;
					zp\p = p;
					
				; particle is not visible
				Else
					
					; create an instance of TZNPart
					zn = New TZNPart;
					zn\z = p\depth;
					zn\p = p;
					
				EndIf;
				
				If p=mtr\partT Then Exit;
				p = After p;
			EndIf;
			
		Wend;
		
		; 2 step to sort particles
		If mtr\quicksort
			; quick sort with a single pass of bubble sort algorithm
			bubbleSort(mtr);
		Else
			; full efficient sort with QSort algorithm (a bit slower but really sort all particles)
			sortPart(mtr);
			; once all particles are sorted, set the Emitter on quicksort, the next frame will sort using the bubble algorithm
			mtr\quicksort = True;
		EndIf;
		
		; recompute the list of particles (the negative one first, the z-sorted last)
		sortEmitter(mtr);
		
		; draw Z-Sorted particles
		zp = Last TZPart
		While zp&lt;&gt;Null
			
			p = zp\p
			Local tu0# = 0.5+0.75*Cos(p\r);
			Local tv0# = 0.5+0.75*Sin(p\r);
			Local tu1# = 0.5+0.75*Cos(p\r+90);
			Local tv1# = 0.5+0.75*Sin(p\r+90);
			Local tu2# = 0.5+0.75*Cos(p\r+180);
			Local tv2# = 0.5+0.75*Sin(p\r+180);
			Local tu3# = 0.5+0.75*Cos(p\r+270);
			Local tv3# = 0.5+0.75*Sin(p\r+270);
			Local v0=	AddVertex	( surf, p\x + p\s * VULx, p\y + p\s * VULy, p\z + p\s * VULz ,tu0,tv0 );
						AddVertex	( surf, p\x + p\s * VURx, p\y + p\s * VURy, p\z + p\s * VURz ,tu1,tv1 );
						AddVertex	( surf, p\x + p\s * VBRx, p\y + p\s * VBRy, p\z + p\s * VBRz ,tu2,tv2 );
						AddVertex	( surf, p\x + p\s * VBLx, p\y + p\s * VBLy, p\z + p\s * VBLz ,tu3,tv3 );
						Local a# = p\l/p\maxl;
						; this can be improved using a single triangle instead of 2 (quad) with better UV coordinates.
						VertexColor	( surf, v0+0, p\cr,p\cg,p\cb, a );
						VertexColor	( surf, v0+1, p\cr,p\cg,p\cb, a );
						VertexColor	( surf, v0+2, p\cr,p\cg,p\cb, a );
						VertexColor	( surf, v0+3, p\cr,p\cg,p\cb, a );
						
						AddTriangle	( surf, v0,v0+1,v0+2 );
						AddTriangle	( surf, v0,v0+2,v0+3 );
						
			zp = Before zp;
			
		Wend
		
		; remove all temporary instances
		Delete Each TZPart;
		Delete Each TZNPart;
		
	Next;
	
End Function


; Emitter templates to make smoke and spread a nice Boom effect
Function smoke(mtr.Emitter,turret.TTurret, t#)
	
	TFormPoint (0,0,4, turret\head, mtr\mesh); end of canon is at 4.0 along Z axis
	Local cx#=TFormedX(),cy#=TFormedY(),cz#=TFormedZ();
	Local i=0;
	Local nprt% = Rand(1,2)*(0.5+0.5*t)
	For i=1 To nprt
		TFormVector (Rnd(-.5,.5),Rnd(-.5,.5),2, turret\head, mtr\mesh)
		
		Local dx#=TFormedX(),dy#=TFormedY(),dz#=TFormedZ();
		Local x_#=cx+Rnd(-.25,.25);
		Local y_#=cy+Rnd(-.25,.25);
		Local z_#=cz+Rnd(-.25,.25);
		Local i_#=Rnd(-0.5,0.5);
		Local j_#=Rnd(-0.2,1.0);
		Local k_#=Rnd(-0.5,0.5);
		Local l_#=Rnd(2000,5000);
		Local s_#=Rnd(.2,.5);
		emitPart(mtr, x_,y_,z_, dx*2,dy*2,dz*2, i_*5,j_*5,k_*5, 30,28,25, s_*2+s_*(2.0-t), l_, l_ * t*0.5 )
	Next;
	
	; disable quicksort for the first pass, so all particles emitted will be sorted
	mtr\quicksort = False;
End Function

Function spread(mtr.Emitter,turret.TTurret)
	TFormPoint (0,0,4, turret\head, mtr\mesh); end of canon is at 4.0 along Z axis
	Local cx#=TFormedX(),cy#=TFormedY(),cz#=TFormedZ();
	Local i=0;
	Local nprt% = Rand(100,250)*.3
	For i=1 To nprt
		If i&lt;nprt*3/4
			TFormVector (Rnd(-1,1),Rnd(-1,1),2+Rnd(.5,-.5), turret\head, mtr\mesh)
		Else
			TFormVector (3*Rnd(-.5,.5),3*Rnd(-.5,.5),2+Rnd(3.25,1), turret\head, mtr\mesh)
		EndIf;
		Local dx#=TFormedX(),dy#=TFormedY(),dz#=TFormedZ();
		Local x_#=cx+Rnd(-.25,.25);
		Local y_#=cy+Rnd(-.25,.25);
		Local z_#=cz+Rnd(-.25,.25);
		Local i_#=Rnd(-0.5,0.5)-4;
		Local j_#=Rnd(-0.2,1.0)+.5;
		Local k_#=Rnd(-0.5,0.5);
		Local l_#=Rnd(2000,5000);
		Local s_#=Rnd(.2,.5);
		
		If i&lt;nprt*2/4
			emitPart(mtr, x_,y_,z_, dx*4,dy*4,dz*4, i_,j_,k_, 30,28,25, s_*1.5, l_*2, l_*1.75)
		ElseIf i&lt;nprt*3/4
			emitPart(mtr, x_,y_,z_, dx*5,dy*5,dz*5, i_,j_,k_, 80,75,70, s_*Rnd(1,3), l_*2, l_*1.75)
		Else
			emitPart(mtr, x_,y_,z_, dx*2,dy*2,dz*2, i_*1.2,j_*1.2,k_*1.2, 170,165,150, s_*2, l_*2, l_*1.75)
			emitPart(mtr, x_,y_,z_, dx*3.5,dy*3.5,dz*3.5, i_*1.5,j_*1.5,k_*1.5, 230,220,215, s_*4, l_*2, l_*1.75)
		EndIf;
		If i&gt;nprt*2/6
			emitPart(mtr, x_,y_,z_, -dx*1.5,-dy*1.5,-dz*1.5, i_,j_,k_, 10,13,20, s_*1.8, l_, l_)
		EndIf
	Next;
	
	; disable quicksort for the first pass, so all particles emitted will be sorted
	mtr\quicksort = False;
End Function

Function spreadBlood(mtr.Emitter, x#,y#,z#, nx#,ny#,nz#)
	Local nprt = Rand(80,150)/2;
	Local i%
	For i = 1 To nprt
		Local x_# = x+Rnd(-.5,.5);
		Local y_# = y+Rnd(-.5,.5);
		Local z_# = z+Rnd(-.5,.5);
		Local dx# = nx*10+Rnd(-1,1)*2;
		Local dy# = ny*10+Rnd(-.2,.2)*2;
		Local dz# = nz*10+Rnd(-1,1)*2;
		Local dy2# = dy*.25-Rnd(5,12);
		Local s# = Rnd(0.1,0.25)*1.5;
		Local ml# = Rnd(4000,7000)*0.7;
		Local l# = Rnd(ml*4/6,ml);
		emitPart(mtr, x_,y_,z_, dx,dy,dz, dx*0.25,dy2,dz*0.25, Rand(20,40),05,02, s, ml, l);
		emitPart(mtr, x_,y_,z_, dx*Rnd(.9,1.1),dy*Rnd(.9,1.1),dz*Rnd(.9,1.1), dx*0.30,dy2*.9,dz*0.30, Rand(40,80),05,02, s*Rnd(.9,1.1), ml, l);
	Next
End Function




; the worst missile library in the world :)
Type Missile
	Field m, l#
	Field v#
End Type

Const MISSILE_VELOCITY# = 0.2;

Function launchMissile(turret.TTurret)
	Local m.Missile = New Missile
	m\m = CreateCylinder(6,1);
	m\l = 5000;
	m\v = MISSILE_VELOCITY;
	ScaleEntity(m\m, turret\canon_radius*0.25, turret\canon_radius*0.25, turret\canon_radius*2);
	PositionEntity m\m, EntityX(turret\head,1), EntityY(turret\head,1), EntityZ(turret\head,1);
	TFormVector (0,0,1, turret\head, 0);
	AlignToVector m\m, TFormedX(), TFormedY(), TFormedZ(), 3, 1;
	MoveEntity m\m, 0,0,turret\canon_length;
End Function

Function updateMissiles(dt#=17)
	Local m.Missile;
	For m.Missile = Each Missile
		MoveEntity m\m, 0,0,dt*m\v
		m\l = m\l-dt
		If m\l&lt;0 Then freeMissile(m);
	Next;
End Function

Function freeMissile(m.Missile)
	FreeEntity m\m;
	Delete m;
End Function



Type TTurret
	Field piv, head, base, canon
	Field canon_length#, canon_radius#
	Field shootTime%, shootFreq%
	Field smokeTime%, smokeFreq%
	Field vec.TV3;
	
	Field aim.TBird;
End Type

Function CreateTurret.TTurret(model, length#, radius#)
	Local t.TTurret = New TTurret;
	t\piv				=	CreatePivot			( );
	t\head				=	CreatePivot			( t\piv );
							MoveEntity			( t\head, 0,5,0 );
	
	t\base				=	CopyEntity			( FindChild(model, "turret_base"), t\piv);
	t\canon				=	CopyEntity			( FindChild(model, "turret_canon"), t\head );
	
	t\canon_length		=	length;
	t\canon_radius		=	radius;
	t\shootFreq			=	Rand(2000,10000);
	t\shootTime			=	MilliSecs()+t\shootFreq;
	t\smokeTime			=	0;
	t\smokeFreq			=	Rand(2500,5000);
	t\vec				=	NewV3();
	Return t;
End Function

Global temp_vec.TV3 = NewV3();
Function TurretTarget(t.TTurret, emitterSpeed#, rate#=1.0)
	
	If t\aim = Null Then t\aim = randomBirdTarget();
	If t\aim = Null Then Return;
	
	Local target		=	t\aim\ent;
	
	Local VEmt.TV3		=	NewV3(EntityX(t\head,1), EntityY(t\head,1), EntityZ(t\head,1));
	Local VTrg.TV3		=	NewV3(EntityX(target,1), EntityY(target,1), EntityZ(target,1));
	TFormNormal(0,0,1,target,0);
	Local VTrgDir.TV3	=	NewV3(TFormedX(),TFormedY(),TFormedZ());
	Local time#			=	ExtrapolatedInTime ( temp_vec, VEmt, emitterSpeed, VTrg, VTrgDir, t\aim\v);
	Delete VEmt;
	Delete VTrg;
	Delete VTrgDir;
	
	If time&lt;.01 Then Return;
	
	V3Assign(t\vec, temp_vec);
	
	; vector turret-&gt;target
	Local dx# = t\vec\x;
	Local dy# = t\vec\y;
	Local dz# = t\vec\z;
	
	Local pit# = VectorPitch(dx,dy,dz);
	Local yaw# = VectorYaw(dx,dy,dz);
	
	Local curyaw# = EntityYaw(t\piv, True);
	Local curpit# = EntityPitch(t\head,False);
	
	RotateEntity ( t\piv	, 0, curyaw+(yaw-curyaw)*rate, 0, True );
	RotateEntity ( t\head	, curpit+(pit-curpit)*rate, 0, 0, False );
	
End Function



Function CreateTurretModels( pParent%=0 )
	
	Local turret		=	CreatePivot			( pParent								 );
							NameEntity			( turret		, "turret"				 );
	Local base			=	CreateMesh			( turret								 );
							NameEntity			( base			, "turret_base"			 );
	Local canon			=	CreateMesh			( turret								 );
							NameEntity			( canon			, "turret_canon"		 );
							
	Local Turret_M1		=	CreateCylinder		( 32,1									 ); Ground cube
							FitMesh				( Turret_M1		, -2,0,-2, 4,.5,4		 ); 
	Local Turret_M2		=	CreateCube			( 										 ); body
							FitMesh				( Turret_M2		, -1,.2,-1, 2,4.0,2		 );
	Local Turret_M3		=	CreateCylinder		( 32									 ); Left launcher bloc
							ScaleMesh			( Turret_M3		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M3		, 0,0,90				 );
							PositionMesh		( Turret_M3		, +0.7,3.8,0.0			 );
	Local Turret_M4		=	CreateCylinder		( 32									 ); Right launcher bloc
							ScaleMesh			( Turret_M4		, 2.0,0.2,0.8			 );
							RotateMesh			( Turret_M4		, 0,0,90				 );
							PositionMesh		( Turret_M4		, -0.7,3.8,0.0			 );
							AddMesh				( Turret_M1		, base );
							AddMesh				( Turret_M2		, base );
							AddMesh				( Turret_M3		, base );
							AddMesh				( Turret_M4		, base );
							
	
	Local Turret_C0		=	CreateCylinder		( 6, 1									 ); rotative cylinder
							RotateMesh			( Turret_C0		, 0,0,90				 );
							FitMesh				( Turret_C0		, -0.8,-.5,-.5,1.6,1,1	 );
							
	Local Turret_C1		=	CreateCylinder		( 16, 1									 ); canon base
							RotateMesh			( Turret_C1		, 90,0,0				 );
							FitMesh				( Turret_C1		, -.4,-.4,0,.8,.8,.7	 );
	Local Turret_C2		=	CreateCylinder		( 16, 1									 ); canon extends
							RotateMesh			( Turret_C2		, 90,0,0				 );
							FitMesh				( Turret_C2		, -.2,-.2,.7,.4,.4,3	 );
	Local Turret_C3		=	CreateCylinder		( 16, 1									 ); canon end
							RotateMesh			( Turret_C3		, 90,0,0				 );
							FitMesh				( Turret_C3		, -.3,-.3,3.7,.6,.6,.3	 );
							
							AddMesh				( Turret_C0		, canon);
							AddMesh				( Turret_C1		, canon);
							AddMesh				( Turret_C2		, canon);
							AddMesh				( Turret_C3		, canon);
							
							FreeEntity			( Turret_M1								 );
							FreeEntity			( Turret_M2								 );
							FreeEntity			( Turret_M3								 );
							FreeEntity			( Turret_M4								 );
							FreeEntity			( Turret_C0								 );
							FreeEntity			( Turret_C1								 );
							FreeEntity			( Turret_C2								 );
							FreeEntity			( Turret_C3								 );
	Return turret;
End Function


Const BIRD_VELOCITY# = 0.02;

Type TBird
	Field ent ; entity
	Field v# ; velocity
	Field tx#, ty#, tz# ; target position
End Type

Function createbird.TBird(v# = -1)
	Local b.TBird = New TBird;
	b\ent				=	CreateSphere		( 4										 );
							ScaleMesh			( b\ent			, .2,.3,1				 );
							PositionEntity		( b\ent			, Rnd(-100,100),0,Rnd(-100,100) );
	b\v					=	v;
	If b\v&lt;0 Then b\v = Rnd(BIRD_VELOCITY*.6,BIRD_VELOCITY*1.2);
	b\tx				=	Rnd(-100,+100);
	b\ty				=	Rnd(+  1,+ 80);
	b\tz				=	Rnd(-100,+100);
	Return b;
End Function

Function updateBirds(mtr.Emitter, dt#=17)
	
	Local b.TBird;
	For b = Each TBird
		
		Repeat
			Local vx# = b\tx-EntityX(b\ent,1);
			Local vy# = b\ty-EntityY(b\ent,1);
			Local vz# = b\tz-EntityZ(b\ent,1);
			
			If vx*vx+vy*vy+vz*vz &gt; (b\v*dt * b\v*dt)*20
				
				AlignToVector (b\ent, vx,vy,vz, 3, .1);
				Exit;
				
			Else
				
				b\tx = Rnd(-100,+100);
				b\ty = Rnd(+  1,+ 80);
				b\tz = Rnd(-100,+100);
				
			EndIf;
			
		Forever;
		
		MoveEntity b\ent, 0,0,b\v*dt
		
		Local m.Missile
		For m = Each Missile
			
			If EntityDistance(m\m, b\ent)&lt;2
				
				Local kx# = EntityX(b\ent,1);
				Local ky# = EntityY(b\ent,1);
				Local kz# = EntityZ(b\ent,1);
				TFormVector (0,0,1,m\m,0);
				Local ki# = TFormedX();
				Local kj# = TFormedY();
				Local kk# = TFormedZ();
				spreadBlood(mtr, kx,ky,kz, ki,kj,kk)
				freeMissile(m);
				killbird(b);
				Exit;
				
			EndIf;
			
		Next;
		
	Next;
	
End Function

Function killbird(b.TBird)
	FreeEntity b\ent;
	Delete b;
End Function

Function randomBirdTarget.TBird()
	Local bCount%=0;
	Local b.TBird;
	For b = Each TBird
		bCount=bCount+1;
	Next;
	
	Local a = Rand(1,bCount);
	Local i=0
	For b = Each TBird
		i=i+1 : If i=a Then Return b;
	Next;
	Return First TBird;
End Function







Graphics3D 1600,900,0,2
SetBuffer BackBuffer()

	AmbientLight .2,.2,.2
	
	Local ground		=	CreatePlane			( 5										 );
	
	Local skylight		=	CreateLight			( 2 );
							LightColor			( skylight		, 030,035,033			 );
							LightRange			( skylight		, 1000					 );
							PositionEntity		( skylight		, 150,100,150			 );
							
	Local player		=	CreatePivot			( 										 );
	Local head			=	CreatePivot			( player								 );
	Local camera		=	CreateCamera		( head									 );
							CameraClsColor		( camera		, 100,110,130			 );
							CameraClsMode		( camera		, True, True			 );
							CameraRange			( camera		, .1,2000				 );
							PositionEntity		( head			, 0,1.7,0				 );
							PositionEntity		( player		, 0,0,-60				 );
							
	Local camlight		=	CreateLight			( 2, camera								 );
							LightColor			( camlight		, 040,035,030			 );
							LightRange			( camlight		, 5						 );
							
	Local turret_model	=	CreateTurretModels	( 										 );
							HideEntity			( turret_model							 );
	
	Local nbTurret = 10, it, turret.TTurret;
	For it = 0 To nbTurret-1
		turret			=	CreateTurret		( turret_model	, 4, .5					 );
							PositionEntity		( turret\piv	, 25*Cos(it*360/nbTurret),0,25*Sin(it*360/nbTurret) );
	Next;
	
	Local ib%, nBirds% = 20, bird.TBird;
	For ib = 0 To nBirds-1
		bird = createbird();
	Next
	
	Local mtr.Emitter	=	createEmitter(0,5,0);
	
	Local smokes		=	8
	Local smoketex		=	CreateTexture(smokes,smokes,1+4+16+32+256);
	SetBuffer (TextureBuffer (smoketex))
		LockBuffer()
			Local ti,tj
			For tj = 0 To smokes-1
				For ti = 0 To smokes-1
					Local sm# = 1.0-Sqr((smokes/2-ti)*(smokes/2-ti) + (smokes/2-tj)*(smokes/2-tj))/(smokes/2)
					If sm&lt;=0
						WritePixelFast(ti, tj, $00000000);
					Else
						Local tex_a = (Int(Rand(255*sm)*sm));
						WritePixelFast(ti, tj, $FFFFFF + $01000000*tex_a );
					EndIf
				Next
			Next
		UnlockBuffer()
	SetBuffer BackBuffer()
	EntityTexture mtr\mesh, smoketex
	
	Local emittime%=MilliSecs()
	
	Local freqSpread = 500
	Local spreadtime = MilliSecs()+freqSpread
	
	MouseXSpeed();
	MouseYSpeed();
	
	Local mt% = 0
	Local st% = MilliSecs()-17;
	Local dt# = 17;
	
	For turret = Each TTurret
		turret\aim = randomBirdTarget();
	Next;
	
	Local debug_draw = False;
	
Repeat
	
	dt = (MilliSecs()-st)-mt;
	mt = (MilliSecs()-st);
	
	If KeyHit(59) Then debug_draw = Not (debug_draw);
	
	Local msx#			=	MouseXSpeed			( );
	Local msy#			=	MouseYSpeed			( );
	
	If MouseDown(2)
		TurnEntity			( player	, 0, -msx, 0 );
		TurnEntity			( head		, +msy, 0, 0 );
	EndIf;
	
	Local vx#, vy#, vz#
		vx	=	Float(KeyDown(32)-KeyDown(30))*0.1;
		vz	=	Float(KeyDown(17)-KeyDown(31))*0.1;
		vy	=	0.0;
	
	MoveEntity				( player	, vx, vy, vz );
	
	For turret = Each TTurret
		
		; turret aims the bird
		TurretTarget ( turret, MISSILE_VELOCITY, .15 );
		
		; if time to shoot ... shoot !
		If (turret\shootTime&lt;MilliSecs())
			
			spread(mtr, turret);
			launchMissile(turret);
			
			turret\shootTime	=	turret\shootTime+turret\shootFreq;
			; update smoke time
			turret\smokeTime=MilliSecs()+turret\smokeFreq
			
		EndIf;
		
		; spread some smoke after a shoot
		
		If turret\smokeTime&gt;MilliSecs()
			smoke (mtr, turret, Float(turret\smokeTime-MilliSecs())/turret\smokeFreq)
		EndIf;
		
	Next;
	
	Local prtt0 = MilliSecs();
	updateParts(camera, .1, dt);
	Local prtt1 = MilliSecs();
	
	updateMissiles(dt);
	updateBirds(mtr, dt)
	
	RenderWorld();
		
		Local countBirds%=0;
		For bird = Each TBird
			countBirds=countBirds+1;
		Next;
		
		If countBirds&lt;50 Then createbird();
		
		If debug_draw
			
			For turret = Each TTurret
				TFormPoint (0,0,0, turret\head, 0);
				CameraProject camera, TFormedX(), TFormedY(), TFormedZ()
				Local thx0 = ProjectedX(), thy0 = ProjectedY()
				Color 0,255,0 : Oval thx0-3,thy0-3,7,7,0
				TFormPoint (5*turret\vec\x+TFormedX(),5*turret\vec\y+TFormedY(),5*turret\vec\z+TFormedZ(), 0, 0);
				CameraProject camera, TFormedX(), TFormedY(), TFormedZ()
				Local thx1 = ProjectedX(), thy1 = ProjectedY()
				If thx1&gt;0 And thy1&gt;0
					Color 255,128,000
					Line thx0,thy0, thx1, thy1
					Rect thx1-2, thy1-2,5,5,1
				EndIf;
				
				If turret\aim&lt;&gt;Null
					CameraProject camera, EntityX(turret\aim\ent,1), EntityY(turret\aim\ent,1), EntityZ(turret\aim\ent,1)
					Local aimx# = ProjectedX(), aimy# = ProjectedY();
					If aimx&gt;0 And aimy&gt;0
						Color 255,000,255
						Line thx0, thy0, aimx, aimy
						Oval aimx-1, aimy-1,3,3,0
					EndIf;
				EndIf;
			Next
			
		EndIf;
		
		Color 001,001,001
		Text 10,10,"ZQSD/WASD to move"
		Text 10,25,"Right mouse to rotate the camera"
		Text 10,40,"[F1] to show debug lines"
		Text 10, 55,"tris   : "+TrisRendered();
		
		Text 10, 85,"mtr  Nb: "+mtr\count_+"/"+mtr\count;
		Text 10,130,"part T : "+(prtt1-prtt0)+".ms";
		Text 10,145,"Birds  : "+countBirds;
		
	Delay (5);
	Flip (True);
	
Until KeyDown(1);

End;
</textarea> <br><br></td></tr></table><br>
<a name="1283586"></a>

<a name="1283587"></a>

<a name="1283588"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> furious bobysait ^^ (tu comptes crer le nouveau "gamemaker" avec des lances missiles et des missiles autoguids en une soire ? :P) <br><br></td></tr></table><br>
<a name="1283589"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ha ha, non, c'est tout pour cette dmo :)<br>Je retourne  mes travaux, c'tait juste ma "pause dj'" on va dire...<br>De temps en temps consacrer une petite soire pour pondre un truc totalement inutile, a fait du bien ^_^ <br><br></td></tr></table><br>
<a name="1283596"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you for the explanation Floyd. <br><br></td></tr></table><br>
<a name="1283659"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, Bobysait, I'm thankful that you did, for it's really a site for sore eyes. It's like watching an Alien Blitz taking place. All that's left to add is an air raid alarm, sound effects and it's a complete demo scene. <br>I changed the colors a bit for bird/missiles so it's easier to see what's what, like this:<br><pre class=code>
Function createbird.TBird(v# = -1)
	Local b.TBird = New TBird;
	b\ent				=	CreateSphere		( 4										 );
							ScaleMesh			( b\ent			, .2,.3,1				 );
							PositionEntity		( b\ent			, Rnd(-100,100),0,Rnd(-100,100) );
							EntityColor 		b\ent,25,25,55 : EntityFX b\ent,1 ;&lt;&lt;&lt;&lt;
</pre><br><pre class=code>
Function launchMissile(turret.TTurret)
	Local m.Missile = New Missile
	m\m = CreateCylinder(6,1);
	EntityColor m\m,255,255,55 : EntityFX m\m,1 ;&lt;&lt;&lt;&lt;

</pre><br><br>I'm jealous you can pull this out of your sleeve just like that. <br>BTW: Dunno why, but the cannons are somehow vaguely making me think of Dr. Who's Daleks ("Exterminate-Exterminate!") lol <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
