<!DOCTYPE html><html lang="en" ><head ><title >Verlet Blob</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Verlet Blob</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Verlet Blob</a><br><br>
<a name="929805"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Firstly, sorry for all of the verlet posts.<br><br>I know that some Blitz users have had success with what appears to be Verlet blobs (Oddball comes to mind), and would appreciate any help.<br><br>After successfully creating Verlet chains, I decided to make a fun little Verlet blob. Following <a href="http://cowboyprogramming.com/2007/01/05/blob-physics/" target="_blank">this</a> article, I have a program that creates a blob of a user-specified number of joints. It has a double-layered skin and a center point in the exact same style as that of the article. And all works well when the number of outer joints is less than around 8 or 9 (that is, 8 outer joints, 8 inner joints, and the single central joint). My problem arises when I try to have bigger (and thus more blob-like) blobs.<br><br>Once I have about 9 outer joints, the blob does well for a few seconds, then begins to shake and ultimately collapses, and the end result is that it folds over on itself. The article mentions folding, but only when the number of joints gets towards 80, which I am obviously nowhere near.<br><br>The article also mentions stability as an issue, and the author said that this was fixed when he divided the verlet integration into two separate loops... one loop to calculate the force of all of the constraints, and a second to move each joint. When implementing this method, however, the points go all over the place. Examining it frame-by-frame, it appears that using this method, the points overcorrect themselves to cause chaos. For example, in one frame, the central point will move a hair upwards. The next frame, it will overcorrect downwards. Then upwards, then downwards, until its Y-value becomes infinity, or NaN.<br><br>If anyone either knows what is happening (if this makes any sense at all) or has ideas for how I could fix this, they would be much appreciated. I can post code if necessary.<br><br>Thanks in advance. <br><br></td></tr></table><br>
<a name="929807"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had a similar problem with my verlet physics engine/experiment thingy.. when I had maybe 50 verlets in a sphere shape they would all vibrate and wiggle but somehow I got around this... not sure how it just happened when I was messing around with it<br><br>good luck<br><br>I may be able to offer more help if you could post some code?<br><br>feel free to take a look :)<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=80075" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=80075</a><br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=80320" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=80320</a> <br><br></td></tr></table><br>
<a name="929835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Buggy, how many relaxation iterations are you using for the contraints?   What timestep size are you using?  Can you show some code for this 2 loop method?<br><br>In my experience, this will always be a problem, particularly with hard collisions.  The only way round it is to have an orientation constraint, from the center of the sphere to one of the outer points.  Store each point's start position relative to the center of the orientation before you start the simulation.  Every time you move a point check to see how much it has deviated from where it should be in relation to this orientation constraint and where it currently is.  If the difference is over a certain threshold then force it towards it's correct position. <br><br></td></tr></table><br>
<a name="929889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stevie, the orientation constraint's a great idea, and I might have to use it. I was trying to steer away from an orientation/angle restraint, at least until I got it to work as-is, because with 10 outer joints, it collapses quite quickly without colliding into anything, which leads me to believe there's a problem with the joint-joint constraint code/implementation.<br><br>As of now, I'm using just one relaxation iteration, and a timestep of 1. But I've tried relaxation iterations of anything from 1 to 100, and nothing helps. In fact, with ridiculously large relaxation iterations, once-stable shapes tend to wobble quite violently.<br><br>I decided to examine the extension values (the difference between the actual distance and the correct distance) in the very first iteration after creating a blob. While no values are suspiciously high, I have some around .2 or .3, which I suspect may be due to discrepancies between floating-point location variables and integer pixel values, though I haven't been able to fix this even by converting everything to floats. Could this be the source of the instability?<br><br>I don't have the code on me right now, but here's the general framework:<br><br><pre class=code>
Go through each joint and:
-Move it according to its last position, current position, and current acceleration.
-Reposition it to keep it onscreen (i.e. with 800x600, if an x value &gt; 800, the x value = 800, etc.)
-Calculate constraints for each joint's first neighbor (adjacent ones), and move joints accordingly.
-Calculate constraints for each joint's second neighbor (diagonal or vertical ones), and move joints accordingly.

Then:
-Move center point according to its last position, current position, and current acceleration.
-For each inner joint, calculate constraint between joint and center point, and move both accordingly.
</pre><br>...and Stevie, with the 2-loop method, each joint has an adjustX# and adjustY# value. Implementation is the same, except when calculating constraints, instead of moving the joint, values are added to its adjustX# and adjustY# values. After everything has been done, it goes through and moves each joint according to these values, and then sets adjustX# and adjustY# back to zero.<br><br>It just occurred to me that the reason this particular 2-loop method isn't working could be that I still move each joint in the moving phase, even though I don't move them during the constraint phase any more. Could that be one of the problems?<br><br>Thanks for all the help. <br><br></td></tr></table><br>
<a name="929916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It just occurred to me that the reason this particular 2-loop method isn't working could be that I still move each joint in the moving phase, even though I don't move them during the constraint phase any more. Could that be one of the problems?<br> <br></div><br><br>as far as I know you arent supposed to move them in the constraint phase<br><br>ummm based on your description of the framework this is a 2-d verlet system? ok that simplifies stuff a little :)<br><br>a simple example of what you are trying to do with your verlet system or what you plan to do would be helpful :) <br><br></td></tr></table><br>
<a name="929922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> By moving them in the constraint phase, I meant moving both points either closer together or farther apart, to satisfy the distance constraints.<br><br>Yes, this is a 2D system... sorry for any confusion.<br><br>As far as what I plan to do, I don't really know, but this something like <a href="/posts.php?topic=67220" target="_blank">this</a> springs to mind at the moment. <br><br></td></tr></table><br>
<a name="929927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmmm from the looks of that game it seems as though they only needed 3 or 4 verlets for the main character... does your character really need 10 outer joints?... if it does that could be and probably will be solved if you mess around with the numbers and equations for a while... it took me a few weeks of messing around with my verlet system after i thought I had "finished" it to get it working properly for car physics :)<br><br>again if you have any code or an exe to download it would help us help you :) <br><br></td></tr></table><br>
<a name="929930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Buggy,<br><br>Never used that method before so can't comment on how well it works.  Have you tried using the standard, accumulate forces, update verlet, update constraints method?<br><br>Can you show a picture of how your verlet body is constructed, including the constraints?  This is important.<br><br>It's not an angular constraint I'm was talking about - more a local space distance constraint.  The angular method will probably work too - your standard dot product or minimum distance constraint.<br><br>Some ideas which should improve stability :<br><br>* Always have the longest constraints processed last.  The bigger the distance the more the error so if it's processed last it more likely to be closer to it's restlength.<br>* Use more constraint relaxation iterations.  I use 3-5 most of the time.<br>* Use a smaller timestep.  I use 0.05 as this seems to work best for me.<br>* Make your central joint/pivot have a radius at least as large as the inner joint distance.<br>* Limit the speed of the joints by a maximum speed.<br>* Add proper drag &amp; friction forces<br>* Post your code, you may be doing something wrong and best to get is sorted now before you start coding workarounds which you don't need.<br><br>Stevie <br><br></td></tr></table><br>
<a name="929933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> heres another thing that I did to stabalize my update constraints function... instead of doing this<br><br><pre class=code>
For i = 1 To 5
	;do the math stuff here
	;move the verlets to the exact place they need to be
Next
</pre><br><br>I did this<br><br><pre class=code>
For i = 1 To 5
	;do the math stuff here
	;move the verlets HALF the distance to their target position unless it is the last loop... if it is the last loop then position them exactly
Next
</pre><br><br>its just a simple /2 but it seems to help me with stability <br><br></td></tr></table><br>
<a name="929949"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pongo</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is very important which verlets are constrained to where. If they are not set properly, then things will collapse no matter how many constraints you use.<br><br>For example, a 2d box shape will need constraints between the four points, but if you do not constrain the diagonals then the whole thing will collapse easily. It would be helpful to see what your shape is and how you are constraining it.<br><br>In my own verlet code I have come up with some very stable 3d configurations that use a minimum number of verlets and constraints. Higher verlet count can slow things down as well, so it's best to keep things as light as possible. <br><br></td></tr></table><br>
<a name="929988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Firstly, thanks for all the help and support. Much appreciated.<br><br>Secondly, sorry for a ridiculously long post. Feel free to skim.<br><br>@ Stevie<br><br>I'm not exactly sure which method you're talking about. I've scrapped (for now) the adjustX#/adjustY# method, but its remains can still be seen in the code. Could you explain what you mean by the "standard" method? I don't appear to have any "accumulate forces" part of my code... perhaps I should? Or is that what I was trying (unsuccessfully) to accomplish with my adjustX#/adjustY# code? I'm a bit confused here...<br><br>My blob is (I believe) set up identically to the one in <a href="http://cowboyprogramming.com/2007/01/05/blob-physics/" target="_blank">this article</a>. Run the code to see.<br><br>I may have to implement angular or distance constraints, but I think there's an underlying problem that needs to get dealt with first.<br><br>Thanks <b>a ton</b> for all of your suggestions! I haven't tried them all, but changing the number of relaxations and time step doesn't seem to help too much. I have drag implemented (just a basic *1.99 sort of thing), but friction wouldn't seem to matter at this point as I have no level!<br><br>@ Nate the Great<br><br>Thanks so much... great idea! I implemented it and it helped the stability somewhat. Blobs with 10 outer joints used to collapse/fold in half. With your trick, they did much better, but blobs would still collapse when I got around 12 outer joints, so clearly there is a deeper problem.<br><br>@ Pongo<br><br>Thanks for the advice. My shape is the same as that of the article I mentioned, and you can always run my code to see. I still could be setting it up incorrectly, because it seems like there is an excess of energy in the system at the start - and this is magnified by the number of joints in the system.<br><br>@ All<br><br>Without any further ado, I present my code! Even though some suggestions (Nate the Great's neat trick, Stevie's - and others' - advice to increase the number of relaxation iterations and decrease the time step, etc.) helped some, none solved the underlying problem, so here is the code <u>as I originally wrote it</u>. I apologize in advance for any unreadability. Ask me if you have any questions.<br><br>Another problem I forgot to mention is every blob's tendency to spin counter-clockwise during its initial freefall. Could this have to do with the problem? I have absolutely no clue why it happens, so maybe...<br><br>Also good to know:<br>-Blobs are created by clicking the mouse.<br>-Blobs can be controlled by the arrow keys and the spacebar.<br>-To change the size of a blob, you must alter the constant <b>NUM_OUTER_BLOB_JOINTS</b> at the top of the code. Because of Blitz arrays, I couldn't implement a way to change the number of blob joints during the running of the program.<br><br>And here it is.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 800, 600, 0, 2

AppTitle "Verlet Demonstration"

SeedRnd MilliSecs()

Const NUM_OUTER_BLOB_JOINTS = 6
Const BLOB_OUTER_DISTANCE = 100, BLOB_INNER_DISTANCE = 80

Type blob
	
	Field joints.joint[NUM_OUTER_BLOB_JOINTS*2]
	Field centerPoint.point
	
End Type

Type joint
	
	Field x#, y#
	Field lastX#, lastY#
	Field adjustX#, adjustY#
	Field ax#, ay#
	Field inverseMass
	Field otherJoint1.joint, otherJoint2.joint
	Field correctDistance1#, correctDistance2#
	
End Type

Type point
	
	Field x#, y#
	Field lastX#, lastY#
	Field adjustX#, adjustY#
	Field ax#, ay#
	Field inverseMass
	Field otherJoints.joint[NUM_OUTER_BLOB_JOINTS]
	Field correctDistance#
	
End Type

Const GRAVITY# = .2
Const TIME_STEP = 1

Global startX, startY, endX, endY
Global timePassed

SetBuffer BackBuffer()

MainLoop()

Function CheckMouse()
	
	If MouseHit(1)
		
		CreateBlob(MouseX(), MouseY())
		
	EndIf
	
End Function

Function CheckKeys()
	
	If KeyDown(205)
		
		For p.point = Each point
			
			p\x# = p\x# + 1
			
		Next
		
	ElseIf KeyDown(203)
		
		For p.point = Each point
			
			p\x# = p\x# - 1
			
		Next
		
	EndIf
	
	If KeyDown(200)
		
		For p.point = Each point
			
			p\y# = p\y# - 10
			
		Next
		
	EndIf
	
	If KeyHit(57)
		
		For p.point = Each point
			
			p\lastY# = p\y# + 100
			
		Next
		
	EndIf
	
End Function

Function CreateBlob(x, y)
	
	b.blob = New blob
	
	;START CREATE OUTER JOINTS
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		b\joints[n] = New joint
		b\joints[n]\x# = Cos#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_OUTER_DISTANCE + x
		b\joints[n]\lastX# = b\joints[n]\x#
		b\joints[n]\y# = Sin#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_OUTER_DISTANCE + y
		b\joints[n]\lastY# = b\joints[n]\y#
		b\joints[n]\inverseMass = 1
		b\joints[n]\ay# = GRAVITY#/b\joints[n]\inverseMass
		
	Next
	
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 2
		
		b\joints[n]\otherJoint1 = b\joints[n + 1]
		
	Next
	
	b\joints[NUM_OUTER_BLOB_JOINTS - 1]\otherJoint1 = b\joints[0]
	;END CREATE OUTER JOINTS
	
	;START CREATE INNER JOINTS
	For n = NUM_OUTER_BLOB_JOINTS To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n] = New joint
		b\joints[n]\x# = Cos#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_INNER_DISTANCE + x
		b\joints[n]\lastX# = b\joints[n]\x#
		b\joints[n]\y# = Sin#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_INNER_DISTANCE + y
		b\joints[n]\lastY# = b\joints[n]\y#
		b\joints[n]\inverseMass = 1
		b\joints[n]\ay# = GRAVITY#/b\joints[n]\inverseMass
		
	Next
	
	For n = NUM_OUTER_BLOB_JOINTS To NUM_OUTER_BLOB_JOINTS*2 - 2
		
		b\joints[n]\otherJoint1 = b\joints[n + 1]
		
	Next
	
	b\joints[NUM_OUTER_BLOB_JOINTS*2 - 1]\otherJoint1 = b\joints[NUM_OUTER_BLOB_JOINTS]
	;END CREATE INNER JOINTS
	
	;set correct joint distances
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n]\correctDistance1# = GetDistance#(b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint1\x#, b\joints[n]\otherJoint1\y#)
		
	Next
	
	;attach outer joints to inner joints
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		;attach outer joint to corresponding inner joint
		b\joints[n]\otherJoint2 = b\joints[n + NUM_OUTER_BLOB_JOINTS]
		
		;attach inner joint to diagonal outer joint
		b\joints[n + NUM_OUTER_BLOB_JOINTS]\otherJoint2 = b\joints[n + 1]
		
	Next
	
	;attach last inner joint to last diagonal outer joint
	b\joints[NUM_OUTER_BLOB_JOINTS*2 - 1]\otherJoint2 = b\joints[0]
	
	;set correct 2-layer distances
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n]\correctDistance2# = GetDistance#(b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint2\x#, b\joints[n]\otherJoint2\y#)
		
	Next
	
	;START CREATE CENTER POINT
	b\centerPoint.point = New point
	b\centerPoint\x# = x
	b\centerPoint\y# = y
	b\centerPoint\lastX# = b\centerPoint\x#
	b\centerPoint\lastY# = b\centerPoint\y#
	b\centerPoint\ax# = 0
	b\centerPoint\inverseMass = 1
	b\centerPoint\ay# = GRAVITY#/b\centerPoint\inverseMass
	;END CREATE CENTER POINT
	
	;attach center point to inner joints
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		b\centerPoint\otherJoints[n] = b\joints[n + NUM_OUTER_BLOB_JOINTS]
		
	Next
	
	b\centerPoint\correctDistance# = GetDistance#(b\centerPoint\x#, b\centerPoint\y#, b\centerPoint\otherJoints[0]\x#, b\centerPoint\otherJoints[0]\y#)
	
End Function

Function DrawBlobs()
	
	Color 255, 0, 0
	
;	For b.blob = Each blob
;		
;		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
;			
;			Line b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint1\x#, b\joints[n]\otherJoint1\y#
;			
;		Next
;		
;	Next
	
	For j.joint = Each joint
		
		Line j\x#, j\y#, j\otherJoint1\x#, j\otherJoint1\y#
		Line j\x#, j\y#, j\otherJoint2\x#, j\otherJoint2\y#
		
	Next
	
	For p.point = Each point
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
			
			Line p\x#, p\y#, p\otherJoints[n]\x#, p\otherJoints[n]\y#
			
		Next
		
	Next
	
	Color 0, 255, 0
	
	For j.joint = Each joint
		
		Oval j\x# - 5, j\y# - 5, 10, 10, 1
		
	Next
	
	;START TEST
	Color 255, 0, 0
	
	For b.blob = Each blob
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			Text b\joints[n]\x#, b\joints[n]\y#, n, True, True
			
		Next
		
	Next
	;END TEST
	
	Color 0, 0, 255
	
	For p.point = Each point
		
		Oval p\x# - 5, p\y# - 5, 10, 10, 1
		
	Next
	
	Color 255, 255, 255
	
End Function

Function GetDistance#(x1#, y1#, x2#, y2#)
	
	Return Sqr#((x1# - x2#)*(x1# - x2#) + (y1# - y2#)*(y1# - y2#))
	
End Function

Function MainLoop()
	
	Local thisTime = MilliSecs(), lastTime = MilliSecs()
	
	Local FPSTimer = MilliSecs()
	Local FPSCounter, FPS
	
	While Not KeyDown(1)
		
		thisTime = MilliSecs()
		
		If thisTime &gt; lastTime
			
			;START FPS CALCULATIONS
			FPSCounter = FPSCounter + 1
			
			If thisTime &gt; FPSTimer + 1000
				
				FPS = FPSCounter
				FPSCounter = 0
				FPSTimer = thisTime
				
			EndIf
			;END FPS CALCULATIONS
			
			timePassed = thisTime - lastTime
			
			lastTime = thisTime
			
			;quickTimer = MilliSecs()
			UpdateBlobs()
			;DebugLog "UpdateChains: " + (MilliSecs() - quickTimer)
			
			;quickTimer = MilliSecs()
			CheckMouse()
			;DebugLog "CheckMouse: " + (MilliSecs() - quickTimer)
			
			;quickTimer = MilliSecs()
			CheckKeys()
			;DebugLog "CheckKeys: " + (MilliSecs() - quickTimer)
			
			Cls
			
			;quickTimer = MilliSecs()
			DrawBlobs()
			;DebugLog "DrawChains: " + (MilliSecs() - quickTimer)
			
			Text 0, 0, "FPS: " + FPS
			Text 0, 10, "Time Passed: " + timePassed
			
			VWait
			Flip False
			
		EndIf
		
	Wend
	
End Function

Function UpdateBlobs()
	
	Local numIterations = 1
	
	For b.blob = Each blob
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			;move joint one timestep
			Local temp# = b\joints[n]\x#
			b\joints[n]\x# = 1.99*(b\joints[n]\x#) - .99*b\joints[n]\lastX# + b\joints[n]\ax#*TIME_STEP*TIME_STEP
			b\joints[n]\lastX# = temp#
			temp# = b\joints[n]\y#
			b\joints[n]\y# = 1.99*(b\joints[n]\y#) - .99*b\joints[n]\lastY# + b\joints[n]\ay#*TIME_STEP*TIME_STEP
			b\joints[n]\lastY# = temp#
			
			For i = 1 To numIterations
				
				;keep joint in bounds
				If b\joints[n]\x# &gt; 799
					
					b\joints[n]\x# = 799
					
				ElseIf b\joints[n]\x# &lt; 0
					
					b\joints[n]\x# = 0
					
				EndIf
				
				If b\joints[n]\y# &gt; 599
					
					b\joints[n]\y# = 599
					
				EndIf
				
				;joint constraints for first pair
				Local dx# = b\joints[n]\otherJoint1\x# - b\joints[n]\x#
				Local dy# = b\joints[n]\otherJoint1\y# - b\joints[n]\y#
				Local separation# = Sqr(dx#*dx# + dy#*dy)
				Local extension# = separation# - b\joints[n]\correctDistance1#
				
				Local springForce# = extension#/(separation#*(b\joints[n]\inverseMass + b\joints[n]\otherJoint1\inverseMass))
				b\joints[n]\x# = b\joints[n]\x# + b\joints[n]\inverseMass*dx#*springForce#
				b\joints[n]\y# = b\joints[n]\y# + b\joints[n]\inverseMass*dy#*springForce#
				b\joints[n]\otherJoint1\x# = b\joints[n]\otherJoint1\x# - b\joints[n]\otherJoint1\inverseMass*dx#*springForce#
				b\joints[n]\otherJoint1\y# = b\joints[n]\otherJoint1\y# - b\joints[n]\otherJoint1\inverseMass*dy#*springForce#
				
				;joint constraints for second pair
				dx# = b\joints[n]\otherJoint2\x# - b\joints[n]\x#
				dy# = b\joints[n]\otherJoint2\y# - b\joints[n]\y#
				separation# = Sqr(dx#*dx# + dy#*dy)
				extension# = separation# - b\joints[n]\correctDistance2#
				
				springForce# = extension#/(separation#*(b\joints[n]\inverseMass + b\joints[n]\otherJoint2\inverseMass))
				b\joints[n]\x# = b\joints[n]\x# + b\joints[n]\inverseMass*dx#*springForce#
				b\joints[n]\y# = b\joints[n]\y# + b\joints[n]\inverseMass*dy#*springForce#
				b\joints[n]\otherJoint2\x# = b\joints[n]\otherJoint2\x# - b\joints[n]\otherJoint2\inverseMass*dx#*springForce#
				b\joints[n]\otherJoint2\y# = b\joints[n]\otherJoint2\y# - b\joints[n]\otherJoint2\inverseMass*dy#*springForce#
				
			Next
			
		Next
		
	Next
	
	;updates center point
	For p.point = Each point
		
		;move center point one timestep
		temp# = p\x#
		p\x# = 1.99*(p\x#) - .99*p\lastX# + p\ax#*TIME_STEP*TIME_STEP
		p\lastX# = temp#
		temp# = p\y#
		p\y# = 1.99*(p\y#) - .99*p\lastY# + p\ay#*TIME_STEP*TIME_STEP
		p\lastY# = temp#
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
			
			For i = 1 To numIterations
				
				;keep center point in bounds - don't need to check?
				If p\x# &gt; 799
					
					p\x# = 799
					
				ElseIf p\x# &lt; 0
					
					p\x# = 0
					
				EndIf
				
				If p\y# &gt; 599
					
					p\y# = 599
					
				EndIf
				
				;constraints for center point and inner joints
				dx# = p\otherJoints[n]\x# - p\x#
				dy# = p\otherJoints[n]\y# - p\y#
				separation# = Sqr(dx#*dx# + dy#*dy)
				extension# = separation# - p\correctDistance#
				
				springForce# = extension#/(separation#*(p\inverseMass + p\otherJoints[n]\inverseMass))
				p\x# = p\x# + p\inverseMass*dx#*springForce#
				p\y# = p\y# + p\inverseMass*dy#*springForce#
				p\otherJoints[n]\x# = p\otherJoints[n]\x# - p\otherJoints[n]\inverseMass*dx#*springForce#
				p\otherJoints[n]\y# = p\otherJoints[n]\y# - p\otherJoints[n]\inverseMass*dy#*springForce#
				
			Next
			
		Next
		
	Next
	
	;START MOVING EVERYTHING - this is currently unused, as all constraint updates directly move joints
	For j.joint = Each joint
		
		j\x# = j\x# + j\adjustX#
		j\y# = j\y# + j\adjustY#
		
		j\adjustX# = 0
		j\adjustY# = 0
		
	Next
	
	For p.point = Each point
		
		p\x# = p\x# + p\adjustX#
		p\y# = p\y# + p\adjustY#
		
		p\adjustX# = 0
		p\adjustY# = 0
		
	Next
	;END MOVING EVERYTHING
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="929995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did this cuz I was bored. It doesnt quite work, but you get the idea. This will stop lag.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 800, 600, 0, 2

AppTitle "Verlet Demonstration"

SeedRnd MilliSecs()

Const NUM_OUTER_BLOB_JOINTS = 6
Const BLOB_OUTER_DISTANCE = 100, BLOB_INNER_DISTANCE = 80

Type blob
	
	Field joints.joint[NUM_OUTER_BLOB_JOINTS*2]
	Field centerPoint.point
	Field min_blobs
	Field max_blobs
	
End Type

Type joint
	
	Field x#, y#
	Field lastX#, lastY#
	Field adjustX#, adjustY#
	Field ax#, ay#
	Field inverseMass
	Field otherJoint1.joint, otherJoint2.joint
	Field correctDistance1#, correctDistance2#
	
End Type

Type point
	
	Field x#, y#
	Field lastX#, lastY#
	Field adjustX#, adjustY#
	Field ax#, ay#
	Field inverseMass
	Field otherJoints.joint[NUM_OUTER_BLOB_JOINTS]
	Field correctDistance#
	
End Type

Const GRAVITY# = .2
Const TIME_STEP = 1

Global startX, startY, endX, endY
Global timePassed

For b.blob = Each blob

b\max_blobs = 10

Next

SetBuffer BackBuffer()

MainLoop()

Function CheckMouse()
	
	If MouseHit(1) = 1 And MouseX() &gt; -1 And MouseX() &lt; GraphicsWidth()+1 And MouseY() &gt; -1 And MouseY() &lt; GraphicsHeight()+1

For b.blob = Each blob

b\min_blobs = b\min_blobs + 1

Next

If b\min_blobs &lt; b\max_blobs
		
		CreateBlob(MouseX(), MouseY())
		
Else

If b\min_blobs &gt; b\max_blobs

RuntimeError "Too many blobs!"

EndIf
				
	EndIf
EndIf
	
End Function

Function CheckKeys()
	
	If KeyDown(205)
		
		For p.point = Each point
			
			p\x# = p\x# + 1
			
		Next
		
	ElseIf KeyDown(203)
		
		For p.point = Each point
			
			p\x# = p\x# - 1
			
		Next
		
	EndIf
	
	If KeyDown(200)
		
		For p.point = Each point
			
			p\y# = p\y# - 10
			
		Next
		
	EndIf
	
	If KeyHit(57)
		
		For p.point = Each point
			
			p\lastY# = p\y# + 100
			
		Next
		
	EndIf
	
End Function

Function CreateBlob(x, y)
	
	b.blob = New blob
		
	;START CREATE OUTER JOINTS
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		b\joints[n] = New joint
		b\joints[n]\x# = Cos#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_OUTER_DISTANCE + x
		b\joints[n]\lastX# = b\joints[n]\x#
		b\joints[n]\y# = Sin#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_OUTER_DISTANCE + y
		b\joints[n]\lastY# = b\joints[n]\y#
		b\joints[n]\inverseMass = 1
		b\joints[n]\ay# = GRAVITY#/b\joints[n]\inverseMass
		
	Next
	
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 2
		
		b\joints[n]\otherJoint1 = b\joints[n + 1]
		
	Next
	
	b\joints[NUM_OUTER_BLOB_JOINTS - 1]\otherJoint1 = b\joints[0]
	;END CREATE OUTER JOINTS
	
	;START CREATE INNER JOINTS
	For n = NUM_OUTER_BLOB_JOINTS To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n] = New joint
		b\joints[n]\x# = Cos#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_INNER_DISTANCE + x
		b\joints[n]\lastX# = b\joints[n]\x#
		b\joints[n]\y# = Sin#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_INNER_DISTANCE + y
		b\joints[n]\lastY# = b\joints[n]\y#
		b\joints[n]\inverseMass = 1
		b\joints[n]\ay# = GRAVITY#/b\joints[n]\inverseMass
		
	Next
	
	For n = NUM_OUTER_BLOB_JOINTS To NUM_OUTER_BLOB_JOINTS*2 - 2
		
		b\joints[n]\otherJoint1 = b\joints[n + 1]
		
	Next
	
	b\joints[NUM_OUTER_BLOB_JOINTS*2 - 1]\otherJoint1 = b\joints[NUM_OUTER_BLOB_JOINTS]
	;END CREATE INNER JOINTS
	
	;set correct joint distances
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n]\correctDistance1# = GetDistance#(b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint1\x#, b\joints[n]\otherJoint1\y#)
		
	Next
	
	;attach outer joints to inner joints
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		;attach outer joint to corresponding inner joint
		b\joints[n]\otherJoint2 = b\joints[n + NUM_OUTER_BLOB_JOINTS]
		
		;attach inner joint to diagonal outer joint
		b\joints[n + NUM_OUTER_BLOB_JOINTS]\otherJoint2 = b\joints[n + 1]
		
	Next
	
	;attach last inner joint to last diagonal outer joint
	b\joints[NUM_OUTER_BLOB_JOINTS*2 - 1]\otherJoint2 = b\joints[0]
	
	;set correct 2-layer distances
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n]\correctDistance2# = GetDistance#(b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint2\x#, b\joints[n]\otherJoint2\y#)
		
	Next
	
	;START CREATE CENTER POINT
	b\centerPoint.point = New point
	b\centerPoint\x# = x
	b\centerPoint\y# = y
	b\centerPoint\lastX# = b\centerPoint\x#
	b\centerPoint\lastY# = b\centerPoint\y#
	b\centerPoint\ax# = 0
	b\centerPoint\inverseMass = 1
	b\centerPoint\ay# = GRAVITY#/b\centerPoint\inverseMass
	;END CREATE CENTER POINT
	
	;attach center point to inner joints
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		b\centerPoint\otherJoints[n] = b\joints[n + NUM_OUTER_BLOB_JOINTS]
		
	Next
	
	b\centerPoint\correctDistance# = GetDistance#(b\centerPoint\x#, b\centerPoint\y#, b\centerPoint\otherJoints[0]\x#, b\centerPoint\otherJoints[0]\y#)
			
End Function

Function DrawBlobs()
	
	Color 255, 0, 0
	
;	For b.blob = Each blob
;		
;		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
;			
;			Line b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint1\x#, b\joints[n]\otherJoint1\y#
;			
;		Next
;		
;	Next
	
	For j.joint = Each joint
		
		Line j\x#, j\y#, j\otherJoint1\x#, j\otherJoint1\y#
		Line j\x#, j\y#, j\otherJoint2\x#, j\otherJoint2\y#
		
	Next
	
	For p.point = Each point
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
			
			Line p\x#, p\y#, p\otherJoints[n]\x#, p\otherJoints[n]\y#
			
		Next
		
	Next
	
	Color 0, 255, 0
	
	For j.joint = Each joint
		
		Oval j\x# - 5, j\y# - 5, 10, 10, 1
		
	Next
	
	;START TEST
	Color 255, 0, 0
	
	For b.blob = Each blob
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			Text b\joints[n]\x#, b\joints[n]\y#, n, True, True
			
		Next
		
	Next
	;END TEST
	
	Color 0, 0, 255
	
	For p.point = Each point
		
		Oval p\x# - 5, p\y# - 5, 10, 10, 1
		
	Next
	
	Color 255, 255, 255
	
End Function

Function GetDistance#(x1#, y1#, x2#, y2#)
	
	Return Sqr#((x1# - x2#)*(x1# - x2#) + (y1# - y2#)*(y1# - y2#))
	
End Function

Function MainLoop()
	
	Local thisTime = MilliSecs(), lastTime = MilliSecs()
	
	Local FPSTimer = MilliSecs()
	Local FPSCounter, FPS
	
	While Not KeyDown(1)
		
		thisTime = MilliSecs()
		
		If thisTime &gt; lastTime
			
			;START FPS CALCULATIONS
			FPSCounter = FPSCounter + 1
			
			If thisTime &gt; FPSTimer + 1000
				
				FPS = FPSCounter
				FPSCounter = 0
				FPSTimer = thisTime
				
			EndIf
			;END FPS CALCULATIONS
			
			timePassed = thisTime - lastTime
			
			lastTime = thisTime
			
			;quickTimer = MilliSecs()
			UpdateBlobs()
			;DebugLog "UpdateChains: " + (MilliSecs() - quickTimer)
			
			;quickTimer = MilliSecs()
			CheckMouse()
			;DebugLog "CheckMouse: " + (MilliSecs() - quickTimer)
			
			;quickTimer = MilliSecs()
			CheckKeys()
			;DebugLog "CheckKeys: " + (MilliSecs() - quickTimer)
			
			Cls
			
			;quickTimer = MilliSecs()
			DrawBlobs()
			;DebugLog "DrawChains: " + (MilliSecs() - quickTimer)
			
			Text 0, 0, "FPS: " + FPS
			Text 0, 10, "Time Passed: " + timePassed
			
			VWait
			Flip False
			
		EndIf
		
	Wend
	
End Function

Function UpdateBlobs()
	
	Local numIterations = 1
	
	For b.blob = Each blob
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			;move joint one timestep
			Local temp# = b\joints[n]\x#
			b\joints[n]\x# = 1.99*(b\joints[n]\x#) - .99*b\joints[n]\lastX# + b\joints[n]\ax#*TIME_STEP*TIME_STEP
			b\joints[n]\lastX# = temp#
			temp# = b\joints[n]\y#
			b\joints[n]\y# = 1.99*(b\joints[n]\y#) - .99*b\joints[n]\lastY# + b\joints[n]\ay#*TIME_STEP*TIME_STEP
			b\joints[n]\lastY# = temp#
			
			For i = 1 To numIterations
				
				;keep joint in bounds
				If b\joints[n]\x# &gt; 799
					
					b\joints[n]\x# = 799
					
				ElseIf b\joints[n]\x# &lt; 0
					
					b\joints[n]\x# = 0
					
				EndIf
				
				If b\joints[n]\y# &gt; 599
					
					b\joints[n]\y# = 599
					
				EndIf
				
				;joint constraints for first pair
				Local dx# = b\joints[n]\otherJoint1\x# - b\joints[n]\x#
				Local dy# = b\joints[n]\otherJoint1\y# - b\joints[n]\y#
				Local separation# = Sqr(dx#*dx# + dy#*dy)
				Local extension# = separation# - b\joints[n]\correctDistance1#
				
				Local springForce# = extension#/(separation#*(b\joints[n]\inverseMass + b\joints[n]\otherJoint1\inverseMass))
				b\joints[n]\x# = b\joints[n]\x# + b\joints[n]\inverseMass*dx#*springForce#
				b\joints[n]\y# = b\joints[n]\y# + b\joints[n]\inverseMass*dy#*springForce#
				b\joints[n]\otherJoint1\x# = b\joints[n]\otherJoint1\x# - b\joints[n]\otherJoint1\inverseMass*dx#*springForce#
				b\joints[n]\otherJoint1\y# = b\joints[n]\otherJoint1\y# - b\joints[n]\otherJoint1\inverseMass*dy#*springForce#
				
				;joint constraints for second pair
				dx# = b\joints[n]\otherJoint2\x# - b\joints[n]\x#
				dy# = b\joints[n]\otherJoint2\y# - b\joints[n]\y#
				separation# = Sqr(dx#*dx# + dy#*dy)
				extension# = separation# - b\joints[n]\correctDistance2#
				
				springForce# = extension#/(separation#*(b\joints[n]\inverseMass + b\joints[n]\otherJoint2\inverseMass))
				b\joints[n]\x# = b\joints[n]\x# + b\joints[n]\inverseMass*dx#*springForce#
				b\joints[n]\y# = b\joints[n]\y# + b\joints[n]\inverseMass*dy#*springForce#
				b\joints[n]\otherJoint2\x# = b\joints[n]\otherJoint2\x# - b\joints[n]\otherJoint2\inverseMass*dx#*springForce#
				b\joints[n]\otherJoint2\y# = b\joints[n]\otherJoint2\y# - b\joints[n]\otherJoint2\inverseMass*dy#*springForce#
				
			Next
			
		Next
		
	Next
	
	;updates center point
	For p.point = Each point
		
		;move center point one timestep
		temp# = p\x#
		p\x# = 1.99*(p\x#) - .99*p\lastX# + p\ax#*TIME_STEP*TIME_STEP
		p\lastX# = temp#
		temp# = p\y#
		p\y# = 1.99*(p\y#) - .99*p\lastY# + p\ay#*TIME_STEP*TIME_STEP
		p\lastY# = temp#
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
			
			For i = 1 To numIterations
				
				;keep center point in bounds - don't need to check?
				If p\x# &gt; 799
					
					p\x# = 799
					
				ElseIf p\x# &lt; 0
					
					p\x# = 0
					
				EndIf
				
				If p\y# &gt; 599
					
					p\y# = 599
					
				EndIf
				
				;constraints for center point and inner joints
				dx# = p\otherJoints[n]\x# - p\x#
				dy# = p\otherJoints[n]\y# - p\y#
				separation# = Sqr(dx#*dx# + dy#*dy)
				extension# = separation# - p\correctDistance#
				
				springForce# = extension#/(separation#*(p\inverseMass + p\otherJoints[n]\inverseMass))
				p\x# = p\x# + p\inverseMass*dx#*springForce#
				p\y# = p\y# + p\inverseMass*dy#*springForce#
				p\otherJoints[n]\x# = p\otherJoints[n]\x# - p\otherJoints[n]\inverseMass*dx#*springForce#
				p\otherJoints[n]\y# = p\otherJoints[n]\y# - p\otherJoints[n]\inverseMass*dy#*springForce#
				
			Next
			
		Next
		
	Next
	
	;START MOVING EVERYTHING - this is currently unused, as all constraint updates directly move joints
	For j.joint = Each joint
		
		j\x# = j\x# + j\adjustX#
		j\y# = j\y# + j\adjustY#
		
		j\adjustX# = 0
		j\adjustY# = 0
		
	Next
	
	For p.point = Each point
		
		p\x# = p\x# + p\adjustX#
		p\y# = p\y# + p\adjustY#
		
		p\adjustX# = 0
		p\adjustY# = 0
		
	Next
	;END MOVING EVERYTHING
	
End Function</textarea> <br><br></td></tr></table><br>
<a name="929997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ DarkShadowWing<br><br>What you want is two global variables, not type fields. And thanks, but that's not really the issue here at all. <br><br></td></tr></table><br>
<a name="929999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ DarkShadowWing - your code doesn't run.<br><br>@ Buggy, I can see immediately that you don't have enough constraints.  You need some more diagonals between the outer and inner joints and also constrain the outer joints to the center of the blob.  <br><br>Your iteration method for constraints isn't coded correctly which is probably why setting it higher than 1 makes no difference.  The iteration loop should be outside the constraint loop, otherwise your just correcting the same constraint a number of times &amp; moving on to the next.  You should be correcting all the constraints each iteration.  Even then something is not right as increasing the iterations now causes it to go haywire.<br><br>Why are you keeping point and joint separate?  They are basically the same thing ( pointmasses ) and should have the same properties.<br><br>Basically, I don't understand why you are doing constraints this way - I think you've over complicated things.   I guess I'm just used to the simple Jacobsen methods. <br><br></td></tr></table><br>
<a name="930012"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know. Thats why I said "it doesnt quite work, but you get the idea". <br><br></td></tr></table><br>
<a name="930020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pongo</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ahh, I see now. I hadn't looked at the link until now. It's a pretty neat concept.<br><br>I agree with Stevie that you may need more constraints, but more importantly, you need to fix the iteration loop. Once you are able to feed a few iterations through, then things will stabilize quite a bit. <br><br></td></tr></table><br>
<a name="930023"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmmm it looks as though you are using a much more complicated method than I originally thought... I will look through it a bit and see what I can figure out <br><br></td></tr></table><br>
<a name="930028"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Stevie<br><br>I changed the joint setup. Now, inner joints are spaced inside and <i>between</i> outer joints, and all joints are connected to the center point. I don't know if this is good or bad, but it allows me to at least see things clearer.<br><br>Thank you, thank you, <b>thank you</b> for noticing the iteration problem. I can't believe I didn't catch that, but it was indeed the source of <i>many</i> (I won't dare say <i>all</i>) of my woes. Now I can do around 12 outer joints without it imploding. More than that, however, and you're right - it goes haywire. The whole thing starts wobbling and spinning (counterclockwise, as always) until it goes nuts. Collisions seem to help it calm down.<br><br>Funny you should say that about Jacobsen - I started this project by thoroughly reading and rereading his paper. I admit I wouldn't like to have "joints" and the "center point" be separate types, but I've become quite attached to using types. From there, it made sense to store the joints in a blitz array within a "blob" type, but blitz arrays are quite finicky. They only accept a constant number of elements, so if I have each joint store the joints it's connected to, then each joint would have two other joints stored, except the center point, which is connected to all of them (used to be half of them). So you see, I really didn't see any other options at the time. I suppose now, if I'm connecting <i>each</i> joint to the center point, I could have the joints each store the center point as well, but then the center point wouldn't store any and would have to be a separate type to keep my memory-conscious impulses appeased. And now I'm rambling, and possibly unintelligible.<br><br>The bottom line is, <u>thank you</u> everyone. While this is still not really <i>fixed</i> per se, I appreciate the support, and I am making progress. Now I just have to figure out why using more than 12-ish outer joints makes it go nuts. Any more ideas? <br><br></td></tr></table><br>
<a name="930031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm... problem solved? Apparently I had forgotten to fix the iteration for the center point. And with a small time step, a few iterations, and not *too* many joints... eet verks! And it even occasionally spins clockwise! Go figure!<br><br>Complete source code below:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Verlet Demo
;Copyright Jacob Evelyn 2009
;Free to use for any/all non-commercial projects

Graphics 800, 600, 0, 2

AppTitle "Verlet Demonstration"

SeedRnd MilliSecs()

Const NUM_OUTER_BLOB_JOINTS = 10
Const BLOB_OUTER_DISTANCE = 100, BLOB_INNER_DISTANCE = 80

Type blob
	
	Field joints.joint[NUM_OUTER_BLOB_JOINTS*2]
	Field centerPoint.point
	
End Type

Type joint
	
	Field x#, y#
	Field lastX#, lastY#
	Field ax#, ay#
	Field inverseMass
	Field otherJoint1.joint, otherJoint2.joint
	Field correctDistance1#, correctDistance2#
	
End Type

Type point
	
	Field x#, y#
	Field lastX#, lastY#
	Field ax#, ay#
	Field inverseMass
	Field otherJoints.joint[NUM_OUTER_BLOB_JOINTS*2]
	Field correctDistance1#, correctDistance2#
	
End Type

Const GRAVITY# = 50
Const TIME_STEP# = .05

Global startX, startY, endX, endY
Global timePassed

SetBuffer BackBuffer()

MainLoop()

Function CheckMouse()
	
	If MouseHit(1)
		
		CreateBlob(MouseX(), MouseY())
		
	EndIf
	
End Function

Function CheckKeys()
	
	If KeyDown(205)
		
		For p.point = Each point
			
			p\x# = p\x# + 1
			
		Next
		
	ElseIf KeyDown(203)
		
		For p.point = Each point
			
			p\x# = p\x# - 1
			
		Next
		
	EndIf
	
	If KeyDown(200)
		
		For p.point = Each point
			
			p\y# = p\y# - 10
			
		Next
		
	EndIf
	
	If KeyHit(57)
		
		For p.point = Each point
			
			p\lastY# = p\y# + 10
			
		Next
		
		For j.joint = Each joint
			
			j\lastY# = j\y# + 10
			
		Next
		
	EndIf
	
End Function

Function CreateBlob(x, y)
	
	b.blob = New blob
	
	;START CREATE OUTER JOINTS
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
		
		b\joints[n] = New joint
		b\joints[n]\x# = Cos#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_OUTER_DISTANCE + x
		b\joints[n]\lastX# = b\joints[n]\x#
		b\joints[n]\y# = Sin#(360.0/NUM_OUTER_BLOB_JOINTS*n)*BLOB_OUTER_DISTANCE + y
		b\joints[n]\lastY# = b\joints[n]\y#
		b\joints[n]\inverseMass = 1
		b\joints[n]\ay# = GRAVITY#/b\joints[n]\inverseMass
		
	Next
	
	For n = 0 To NUM_OUTER_BLOB_JOINTS - 2
		
		b\joints[n]\otherJoint1 = b\joints[n + 1]
		
	Next
	
	b\joints[NUM_OUTER_BLOB_JOINTS - 1]\otherJoint1 = b\joints[0]
	;END CREATE OUTER JOINTS
	
	;START CREATE INNER JOINTS
	For n = NUM_OUTER_BLOB_JOINTS To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n] = New joint
		b\joints[n]\x# = Cos#(360.0/NUM_OUTER_BLOB_JOINTS*n - 180.0/NUM_OUTER_BLOB_JOINTS)*BLOB_INNER_DISTANCE + x
		b\joints[n]\lastX# = b\joints[n]\x#
		b\joints[n]\y# = Sin#(360.0/NUM_OUTER_BLOB_JOINTS*n - 180.0/NUM_OUTER_BLOB_JOINTS)*BLOB_INNER_DISTANCE + y
		b\joints[n]\lastY# = b\joints[n]\y#
		b\joints[n]\inverseMass = 1
		b\joints[n]\ay# = GRAVITY#/b\joints[n]\inverseMass
		
	Next
	
	For n = NUM_OUTER_BLOB_JOINTS To NUM_OUTER_BLOB_JOINTS*2 - 2
		
		b\joints[n]\otherJoint1 = b\joints[n + 1]
		
	Next
	
	b\joints[NUM_OUTER_BLOB_JOINTS*2 - 1]\otherJoint1 = b\joints[NUM_OUTER_BLOB_JOINTS]
	;END CREATE INNER JOINTS
	
	;set correct joint distances
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n]\correctDistance1# = GetDistance#(b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint1\x#, b\joints[n]\otherJoint1\y#)
		
	Next
	
	;attach outer joints to inner joints
	For n = 1 To NUM_OUTER_BLOB_JOINTS - 1
		
		;attach outer joint to diagonal inner joint
		b\joints[n]\otherJoint2 = b\joints[n + NUM_OUTER_BLOB_JOINTS]
		
		;attach inner joint to diagonal outer joint
		b\joints[n + NUM_OUTER_BLOB_JOINTS]\otherJoint2 = b\joints[n - 1]
		
	Next
	
	;attach first outer joint to diagonal inner joint
	b\joints[0]\otherJoint2 = b\joints[NUM_OUTER_BLOB_JOINTS]
	
	;attach last inner joint to last diagonal outer joint
	b\joints[NUM_OUTER_BLOB_JOINTS]\otherJoint2 = b\joints[NUM_OUTER_BLOB_JOINTS - 1]
	
	;set correct 2-layer distances
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\joints[n]\correctDistance2# = GetDistance#(b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint2\x#, b\joints[n]\otherJoint2\y#)
		
	Next
	
	;START CREATE CENTER POINT
	b\centerPoint.point = New point
	b\centerPoint\x# = x
	b\centerPoint\y# = y
	b\centerPoint\lastX# = b\centerPoint\x#
	b\centerPoint\lastY# = b\centerPoint\y#
	b\centerPoint\ax# = 0
	b\centerPoint\inverseMass = 1
	b\centerPoint\ay# = GRAVITY#/b\centerPoint\inverseMass
	;END CREATE CENTER POINT
	
	;attach center point to inner joints
	For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
		
		b\centerPoint\otherJoints[n] = b\joints[n]
		
	Next
	
	b\centerPoint\correctDistance1# = GetDistance#(b\centerPoint\x#, b\centerPoint\y#, b\centerPoint\otherJoints[0]\x#, b\centerPoint\otherJoints[0]\y#)
	b\centerPoint\correctDistance2# = GetDistance#(b\centerPoint\x#, b\centerPoint\y#, b\centerPoint\otherJoints[NUM_OUTER_BLOB_JOINTS]\x#, b\centerPoint\otherJoints[NUM_OUTER_BLOB_JOINTS]\y#)
	
End Function

Function DrawBlobs()
	
	Color 255, 0, 0
	
;	For b.blob = Each blob
;		
;		For n = 0 To NUM_OUTER_BLOB_JOINTS - 1
;			
;			Line b\joints[n]\x#, b\joints[n]\y#, b\joints[n]\otherJoint1\x#, b\joints[n]\otherJoint1\y#
;			
;		Next
;		
;	Next
	
	For j.joint = Each joint
		
		Line j\x#, j\y#, j\otherJoint1\x#, j\otherJoint1\y#
		Line j\x#, j\y#, j\otherJoint2\x#, j\otherJoint2\y#
		
	Next
	
	For p.point = Each point
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			Line p\x#, p\y#, p\otherJoints[n]\x#, p\otherJoints[n]\y#
			
		Next
		
	Next
	
	Color 0, 255, 0
	
	For j.joint = Each joint
		
		Oval j\x# - 5, j\y# - 5, 10, 10, 1
		
	Next
	
	;START TEST
	Color 255, 0, 0
	
	For b.blob = Each blob
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			Text b\joints[n]\x#, b\joints[n]\y#, n, True, True
			
		Next
		
	Next
	;END TEST
	
	Color 0, 0, 255
	
	For p.point = Each point
		
		Oval p\x# - 5, p\y# - 5, 10, 10, 1
		
	Next
	
	Color 255, 255, 255
	
End Function

Function GetDistance#(x1#, y1#, x2#, y2#)
	
	Return Sqr#((x1# - x2#)*(x1# - x2#) + (y1# - y2#)*(y1# - y2#))
	
End Function

Function MainLoop()
	
	Local thisTime = MilliSecs(), lastTime = MilliSecs()
	
	Local FPSTimer = MilliSecs()
	Local FPSCounter, FPS
	
	While Not KeyDown(1)
		
		thisTime = MilliSecs()
		
		If thisTime &gt; lastTime
			
			;START FPS CALCULATIONS
			FPSCounter = FPSCounter + 1
			
			If thisTime &gt; FPSTimer + 1000
				
				FPS = FPSCounter
				FPSCounter = 0
				FPSTimer = thisTime
				
			EndIf
			;END FPS CALCULATIONS
			
			timePassed = thisTime - lastTime
			
			lastTime = thisTime
			
			;quickTimer = MilliSecs()
			UpdateBlobs()
			;DebugLog "UpdateChains: " + (MilliSecs() - quickTimer)
			
			;quickTimer = MilliSecs()
			CheckMouse()
			;DebugLog "CheckMouse: " + (MilliSecs() - quickTimer)
			
			;quickTimer = MilliSecs()
			CheckKeys()
			;DebugLog "CheckKeys: " + (MilliSecs() - quickTimer)
			
			Cls
			
			;quickTimer = MilliSecs()
			DrawBlobs()
			;DebugLog "DrawChains: " + (MilliSecs() - quickTimer)
			
			Text 0, 0, "FPS: " + FPS
			Text 0, 10, "Time Passed: " + timePassed
			
			VWait
			Flip False
			
			;WaitKey
			
		EndIf
		
	Wend
	
End Function

Function UpdateBlobs()
	
	Local numIterations = 5
	
	For b.blob = Each blob
		
		For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
			
			;move joint one timestep
			Local temp# = b\joints[n]\x#
			b\joints[n]\x# = 1.99*(b\joints[n]\x#) - .99*b\joints[n]\lastX# + b\joints[n]\ax#*TIME_STEP#*TIME_STEP#
			b\joints[n]\lastX# = temp#
			temp# = b\joints[n]\y#
			b\joints[n]\y# = 1.99*(b\joints[n]\y#) - .99*b\joints[n]\lastY# + b\joints[n]\ay#*TIME_STEP#*TIME_STEP#
			b\joints[n]\lastY# = temp#
			
		Next
		
	Next
	
	
	For i = 1 To numIterations
		
		For b.blob = Each blob
			
			For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
				
				;keep joint in bounds
				If b\joints[n]\x# &gt; 799
					
					b\joints[n]\x# = 799
					
				ElseIf b\joints[n]\x# &lt; 0
					
					b\joints[n]\x# = 0
					
				EndIf
				
				If b\joints[n]\y# &gt; 599
					
					b\joints[n]\y# = 599
					
				EndIf
				
				;joint constraints for first pair
				Local dx# = b\joints[n]\otherJoint1\x# - b\joints[n]\x#
				Local dy# = b\joints[n]\otherJoint1\y# - b\joints[n]\y#
				Local separation# = Sqr(dx#*dx# + dy#*dy)
				Local extension# = separation# - b\joints[n]\correctDistance1#
				
				Local springForce# = extension#/(separation#*(b\joints[n]\inverseMass + b\joints[n]\otherJoint1\inverseMass))
				b\joints[n]\x# = b\joints[n]\x# + b\joints[n]\inverseMass*dx#*springForce#
				b\joints[n]\y# = b\joints[n]\y# + b\joints[n]\inverseMass*dy#*springForce#
				b\joints[n]\otherJoint1\x# = b\joints[n]\otherJoint1\x# - b\joints[n]\otherJoint1\inverseMass*dx#*springForce#
				b\joints[n]\otherJoint1\y# = b\joints[n]\otherJoint1\y# - b\joints[n]\otherJoint1\inverseMass*dy#*springForce#
				
				;joint constraints for second pair
				dx# = b\joints[n]\otherJoint2\x# - b\joints[n]\x#
				dy# = b\joints[n]\otherJoint2\y# - b\joints[n]\y#
				separation# = Sqr(dx#*dx# + dy#*dy)
				extension# = separation# - b\joints[n]\correctDistance2#
				
				springForce# = extension#/(separation#*(b\joints[n]\inverseMass + b\joints[n]\otherJoint2\inverseMass))
				b\joints[n]\x# = b\joints[n]\x# + b\joints[n]\inverseMass*dx#*springForce#
				b\joints[n]\y# = b\joints[n]\y# + b\joints[n]\inverseMass*dy#*springForce#
				b\joints[n]\otherJoint2\x# = b\joints[n]\otherJoint2\x# - b\joints[n]\otherJoint2\inverseMass*dx#*springForce#
				b\joints[n]\otherJoint2\y# = b\joints[n]\otherJoint2\y# - b\joints[n]\otherJoint2\inverseMass*dy#*springForce#
				
			Next
			
		Next
		
	Next
	
	;updates center point
	For p.point = Each point
		
		;move center point one timestep
		temp# = p\x#
		p\x# = 1.99*(p\x#) - .99*p\lastX# + p\ax#*TIME_STEP#*TIME_STEP#
		p\lastX# = temp#
		temp# = p\y#
		p\y# = 1.99*(p\y#) - .99*p\lastY# + p\ay#*TIME_STEP#*TIME_STEP#
		p\lastY# = temp#
		
		For i = 1 To numIterations
			
			For n = 0 To NUM_OUTER_BLOB_JOINTS*2 - 1
				
				;keep center point in bounds - don't need to check?
				If p\x# &gt; 799
					
					p\x# = 799
					
				ElseIf p\x# &lt; 0
					
					p\x# = 0
					
				EndIf
				
				If p\y# &gt; 599
					
					p\y# = 599
					
				EndIf
				
				;constraints for center point and inner joints
				dx# = p\otherJoints[n]\x# - p\x#
				dy# = p\otherJoints[n]\y# - p\y#
				separation# = Sqr(dx#*dx# + dy#*dy)
				extension# = separation# - p\correctDistance1#*(n &lt; NUM_OUTER_BLOB_JOINTS) - p\correctDistance2#*(n &gt;= NUM_OUTER_BLOB_JOINTS)
				
				springForce# = extension#/(separation#*(p\inverseMass + p\otherJoints[n]\inverseMass))
				p\x# = p\x# + p\inverseMass*dx#*springForce#
				p\y# = p\y# + p\inverseMass*dy#*springForce#
				p\otherJoints[n]\x# = p\otherJoints[n]\x# - p\otherJoints[n]\inverseMass*dx#*springForce#
				p\otherJoints[n]\y# = p\otherJoints[n]\y# - p\otherJoints[n]\inverseMass*dy#*springForce#
				
			Next
			
		Next
		
	Next
	
End Function
</textarea><br><br>Thanks everyone for all the help! <br><br></td></tr></table><br>
<a name="930032"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> now I assume you will have to turn all of the constraints into rubberband-like constraints for a blob effect? <br><br></td></tr></table><br>
<a name="930070"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> To make it more blobbish I'd recommend not using an elasticity value when doing your constraints.  Use the inverse mass proportioning as per the jacobsen article.  If you make the center point have a large mass and the outer and inner points have a smaller mass then it should behave as you want. <br><br></td></tr></table><br>
<a name="930221"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't actually know how I'd go about using rubberband-like constraints, but I've tried Stevie G's advice, and it works somewhat. The best I can get is a circle with sides (well, circles technically <i>don't have</i> sides, but anyway...) that compress upon colliding with the ground or walls. I can't seem to get it to really droop at all on my own. Is there something else I should be doing, or should I just keep fiddling? I've searched online and can't find any answers...<br><br>I suppose I could also have a blob-like shape, instead of a circle, at the start. But it wouldn't really deform like Mick West's (once again, <a href="http://cowboyprogramming.com/2007/01/05/blob-physics/" target="_blank">here</a>) seem to.<br><br>Thanks again for the help. <br><br></td></tr></table><br>
<a name="930226"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> you could give the constraints a length 'range' <br><br></td></tr></table><br>
<a name="930597"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried something like that I think (only perform the constraint correction if abs(extension#) &gt; 5 or some other number), and it didn't really work at all. It just seemed to make everything vibrate. I'll continue to fiddle. And maybe violin a bit as well. ;) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
