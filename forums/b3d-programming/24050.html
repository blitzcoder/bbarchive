<!DOCTYPE html><html lang="en" ><head ><title >please help a poor unfortunate ex-DB user</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >please help a poor unfortunate ex-DB user</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >please help a poor unfortunate ex-DB user</a><br><br>
<a name="249214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> i've been using DBC for about 6 months now (an 'extended time limit' demo version ;) ), but then found out about blitz 3 days ago and bought it today after a bit of playing.<br>from the demos, and playing with meshes, i feel i made the right choice by far (i WAS tossing up whether or not to buy db pro until i found blitz and converted some of my code to it). i wish i'd found about about blitz before db, because i've spent a hell of alot of time on this game, only to find out it will never work quick enough, or have good gfx on darkbasic. if anyone could help me, it would be highly appreciated.<br><br>my problem is with matrices(in db) or terrains(in blitz). my game physics work independant of the terrain/matrix, but the terrain/matrix has to look the same as the array that the physics work from, or the cars will be flying around no-where near the track :)<br><br>this is the darkbasic code (it's a bit messy, but it works, so you can use it in darkbasic classic demo or retail, or possibly db pro (i havent tried) it needs 2 bitmaps, matrixtexture2.bmp, and roadtexture1.bmp (these can be any size or whatever, but a small bitmap will be faster).<br>here it is:<br>[CODE]<br>sync on<br>tracklength# = 1000<br>`roadtexture$ = "roadtexture1.bmp"<br>`groundtexture$ = "matrixtexture1.bmp"<br>trackfilename$ = "testing" + "_road.map"<br>open to write 1,trackfilename$<br>write float 1,tracklength#<br>write float 1,100<br>write float 1,100<br>write float 1,100<br>write float 1,100<br>write string 1,roadtexture$<br>write string 1,roadtexture$<br><br>rem load textures<br>load image "roadtexture1.bmp",1<br>`load image "reflectred.bmp",2<br>`load image "reflectgrey.bmp",3<br>load image "matrixtexture2.bmp",4<br><br>preparematrixs(tracklength#, 100.0, 100.0, 100.0, 100.0, 4.0)<br>cam_z# = 0<br>cam_y# = 0<br>cam_x# = 500<br><br>rem set maximum and current corner and slope variables,<br>maxcorner# = 10<br>maxslope# = 5<br>corner# = 0<br>slope# = 0<br>rem the amount of tiles we've travelled past<br>matrix_z# = 1 : rem hopefully<br>rem check if moving forward to make the track smoother<br>moving# = 0<br>rem when this is 10, a reflector is placed<br>reflectcounter# = 0<br>rem reflector object no. start at 900 to avoid conflict in the game<br>reflectno# = 1000<br>rem set matrix wireframe off 1<br>rem 1st Triangle to create road from<br>roadtri# = 20000<br>backtriy# = 0<br>fronttriy# = 0<br>backtrix# = 500<br>fronttrix# = 500<br>backtriz# = 0<br>fronttriz# = 0<br>moving# = 0<br>frame# = 0<br>section = 1<br><br>while spacekey() = 0 and matrix_z# &lt; tracklength# * 10<br>   if moving# = 1<br>      rem store variables for road triangle polygon creation<br>      backtriy# = cam_y# + 0.5<br>      backtrix# = cam_x#<br>      backtriz# = cam_z#<br><br><br>   endif<br><br>   rem set moving if upkey is pressed, and move to next z joint in matrix.<br>   if upkey()=1<br>      cam_z#=cam_z# + 10<br>      moving# = 1<br>   else<br>      moving# = 0<br>   endif<br><br>   if moving# = 1<br>      if leftkey()=1 and corner# &gt; maxcorner# * -1 then dec corner#<br>      if rightkey()=1 and corner# &lt; maxcorner# then inc corner#<br>      if leftkey() = 0 and rightkey() = 0 and corner# &lt; 0 then corner# = corner# + .5<br>      if leftkey() = 0 and rightkey() = 0 and corner# &gt; 0 then corner# = corner# - .5<br><br>      if shiftkey() = 1 and slope# &lt; maxslope# then inc slope#<br>      if controlkey() = 1 and slope# &gt; maxslope# * -1 then dec slope#<br>      if shiftkey() = 0 and controlkey() = 0 and slope# &lt; 0 then slope# = slope# + .5<br>      if shiftkey() = 0 and controlkey() = 0 and slope# &gt; 0 then slope# = slope# - .5<br><br>      cam_x# = cam_x# + corner#<br>      cam_y# = cam_y# + slope#<br>      inc matrix_z#<br>      section = setheight(matrix_z#, cam_y#, 100.0, 100.0)<br>      write float 1, matrix_z#<br>      write float 1, cam_x#<br>      write float 1, cam_y#<br>      rem set triangle variables for road creation<br>      fronttriy# = cam_y# + 0.5<br>      fronttrix# = cam_x#<br>      fronttriz# = cam_z#<br>      backleft# = backtrix# - 25<br>      backright# = backtrix# + 25<br>      frontleft# = fronttrix# - 25<br>      frontright# = fronttrix# + 25<br>      rem create triangle polygons for road, texture them, and make them static<br>      rem                               |  POINT ONE                      |        POINT TWO                   |             POINT THREE        |<br>      MAKE OBJECT TRIANGLE roadtri#, frontright#, fronttriy#, fronttriz#, backleft#, backtriy#, backtriz#, frontleft#, fronttriy#, fronttriz#<br>      make static object roadtri#,1<br>      texture object roadtri#, 1<br>  rem    delete object roadtri#<br>      inc roadtri#<br>      MAKE OBJECT TRIANGLE roadtri#, backleft#, backtriy#, backtriz#, frontright#, fronttriy#, fronttriz#, backright#, backtriy#, backtriz#<br>      make static object roadtri#,1<br>      texture object roadtri#, 1<br>      inc roadtri#<br>   endif<br><br>   update matrix section<br>   update matrix section + 1<br>   update matrix section + 2<br>   position camera cam_x#, cam_y# + 30, cam_z# - 100<br>   set cursor 0,0<br>   print " frame "    ; frame#<br>   print " zposition" ;matrix_z#<br>   print " real Z position#" ; cam_z#<br>   inc frame#<br>   sync<br>endwhile<br><br>FUNCTION placereflectors(number#, x#, y#, z#, trackwidth#, texture1#, texture2#)<br>         make object box number#,1,10,.1<br>         position object number#, x# - (trackwidth# * .7), y# + 5, z#<br>         make static object number#,1<br>         texture object number#,2<br>         inc number#<br>         make object box number#,1,10,.1<br>         position object number#,x# + (trackwidth# * .7), y# + 5, z#<br>         make static object number#,1<br>         texture object number#,3<br>ENDFUNCTION<br><br>FUNCTION setheight(z#, y#, leftheight#, rightheight#)<br><br>   section = round(z#, 100.0)<br>   sectiongroup = section<br>   section = section * 3 + 1<br>   oldz# = z#<br>   if section &gt; 3 then oldy# = get ground height( (sectiongroup  * 3 + 1) - 3, 500.0, ABS(oldz# - (sectiongroup +.1))  * 10 )<br>   z# = (z# - (((section -1) / 3)*100))<br>   set cursor 0,50<br>   print "setheight Z       : " ; z#<br>   print "setheight matrix  : " ; section<br>   print "section           : " ; sectiongroup<br>   print "setheight Y       : " ; y#<br>   print "setheight oldy    : " ; oldy#<br>   print "setheight oldz    : " ; (oldz# - (((section -1) / 3)+.1)) *10<br>rem   sync<br>   rem set center matrix height<br>   counter# = 10<br>   while counter# &gt; -1<br>      if z# = 1 and section &gt; 3 then SET MATRIX HEIGHT section, counter#, 0, oldy#<br>     SET MATRIX HEIGHT section, counter#, z#, y#<br>      dec counter#<br>   endwhile<br><br>   rem set matrix height for left side<br>   counter# = 10<br>   while counter# &gt; -1<br>      SET MATRIX HEIGHT section + 1, 10 - counter#, z#, y# +  (((counter# * .01) * counter#) * leftheight#)<br>       dec counter#<br>   endwhile<br><br>   rem set matrix height for right side<br>   counter# = 0<br>   while counter# &lt; 11<br>      SET MATRIX HEIGHT section + 2, counter#, z#, y# +  (((counter# * .01) * counter#) * rightheight#)<br>       inc counter#<br>   endwhile<br>ENDFUNCTION section<br><br>FUNCTION preparematrixs(tracklength#, leftheight#, leftwidth#, rightheight#, rightwidth#, groundtex#)<br>   remaindinglength# = tracklength#<br>   while remaindinglength# &gt; 10<br>      dec remaindinglength#,10<br>      inc sections#<br>   endwhile<br>   matrixnumber# = 1<br>   currentsection# = 0<br>   while sections# &gt; currentsection# - 1<br>      rem create center for current section<br>      creatematrix(matrixnumber#, 1000.0, 1000.0, 10.0 , 100.0, 0.0, currentsection# * 1000.0, groundtex#)<br>      inc matrixnumber#<br>      creatematrix(matrixnumber#, leftwidth#, 1000.0, 10.0, 100.0, leftwidth# * -1.0, currentsection# * 1000.0, groundtex#)<br>      inc matrixnumber#<br>      creatematrix(matrixnumber#, rightwidth#, 1000.0, 10.0, 100.0, 1000.0, currentsection# * 1000.0, groundtex#)<br>      inc matrixnumber#<br>      inc currentsection#<br>      set cursor 0,0<br>      print "creating matrix"; matrixnumber#<br>      sync<br>   endwhile<br>   rem create matrix from the remainder<br>   remaindinglength# = int(remaindinglength#)<br>   creatematrix(matrixnumber#, 1000.0, remaindinglength# * 100.0, 10.0, remaindinglength# * 10.0, 0.0, currentsection# * 1000.0, groundtex#)<br>   inc matrixnumber#<br>   creatematrix(matrixnumber#, leftwidth#, remaindinglength# * 100.0, 10.0, remaindinglength# * 10.0, leftwidth# * -1.0, currentsection# * 1000.0,  groundtex#)<br>   inc matrixnumber#<br>   creatematrix(matrixnumber#, rightwidth#, remaindinglength# * 100.0, 10.0, remaindinglength#* 10.0, 1000.0, currentsection# * 1000.0,  groundtex#)<br>ENDFUNCTION<br><br>FUNCTION creatematrix(matrixnumber#, width#, length#, xsections#, zsections#, xpos#, zpos#, texture#)<br>      make matrix matrixnumber#, width#, length# ,xsections#,zsections#<br>      position matrix matrixnumber#,xpos#,0,zpos#<br>      prepare matrix texture matrixnumber#,texture#,1,1<br>      set matrix texture matrixnumber#,1,0<br>      fill matrix matrixnumber#,0,1<br>   rem   set matrix wireframe on matrixnumber#<br>ENDFUNCTION<br><br>FUNCTION round(num#, tonearest#)<br>   ret# = 0<br>   while num# &gt; 0<br>      dec num#, tonearest#<br>      if num# &gt; 0 then inc ret#<br>   endwhile<br>ENDFUNCTION ret#<br>[/CODE]<br>ok, so that's what i want to make. it might be a pretty stupid track editor, but it works perfect for the type of game i'm making, i just need to add functions like addscenery() after it.<br><br>ok now i've tried 2 methods to convert it to blitz, the first that i'll show is using "matrix.bb", which is in &lt;blitzfolder&gt;\samples\si\matrix\matrix.bb &lt; this file needs to be in the same folder, im guessing ill get kicked/sued if i include it here, so i wont :). for me, this seems to create the matrices, but then does nothing. this one needs matrixtexture2.bmp (again, any bmp, but preferably a small one, and not pitch black :) )<br>[CODE]<br>Graphics3D 640,480,16,0<br>SetBuffer BackBuffer()<br>Include "matrix.bb"<br><br>Global camera = CreateCamera()<br>; gonna be for saving (hopefully)<br>;Type trackstat<br>;	Field x#[100]<br>;	Field y#<br>;End Type<br>;was gonna be for the road, but doest work yet<br>;Global road = CreateMesh()<br>;Dim roadpoints(5)<br><br>;roadtexture$ = "roadtexture1.bmp"<br>groundtexture$ = "matrixtexture2.bmp"<br>;trackfilename$ = "testing" + "_road.map"<br><br><br>;Global roadtex = LoadTexture("roadtexture1.bmp")<br>;Global flectred = LoadTexture("reflectred.bmp")<br>;Global flectgrey = LoadTexture("reflectgrey.bmp")<br>;Global terraintex = LoadTexture("matrixtexture2.bmp")<br><br>DB_LoadImage( groundtexture, 4 )<br>tracklength# = 101<br><br>;Dim track.trackstat(tracklength)<br>;For i = 1 To tracklength<br>;	track(i) = New trackstat<br>;Next<br><br>noofterrains = roundint(tracklength, 100)<br>Dim terrainentitys(noofterrains)<br><br>preparematrixs(tracklength#, 100.0, 100.0, 100.0, 100.0, 4.0)<br>cam_z# = 0<br>cam_y# = 0<br>cam_x# = 500<br><br>;set maximum and current corner and slope variables,<br>maxcorner# = 10<br>maxslope# = 5<br>corner# = 0<br>slope# = 0<br>;the amount of tiles we've travelled past<br>matrix_z# = 1 ;: hopefully<br>;check if moving forward to make the track smoother<br>moving# = 0<br>;when this is 10, a reflector is placed<br>reflectcounter# = 0<br>;reflector object no. start at 900 to avoid conflict in the game<br>reflectno# = 1000<br>;set matrix wireframe off 1<br>;1st Triangle to create road from<br>roadtri# = 20000<br>backtriy# = 0<br>fronttriy# = 0<br>backtrix# = 500<br>fronttrix# = 500<br>backtriz# = 0<br>fronttriz# = 0<br>moving# = 0<br>frame# = 0<br>section = 1<br><br>While matrix_z# &lt; tracklength<br>   If moving# = 1<br>    ;  store variables for road triangle polygon creation<br>      backtriy# = cam_y# + 0.5<br>      backtrix# = cam_x#<br>      backtriz# = cam_z#<br>   EndIf<br><br>   ; set moving If up key is pressed, And move To Next z joint in matrix.<br>   If KeyDown(200)=1<br>      cam_z#=cam_z# + 10<br>      moving# = 1<br>   Else<br>      moving# = 0<br>   EndIf<br>      If KeyDown(108) Then cam_z# = cam_z# - 1<br>   If moving# = 1<br><br>      If KeyDown(203)=1 And corner# &gt; maxcorner# * -1 Then corner# = corner - 1<br>      If KeyDown(205)=1 And corner# &lt; maxcorner# Then corner# = corner + 1<br>      If KeyDown(203) = 0 And KeyDown(205) = 0 And corner# &lt; 0 Then corner# = corner# + .5<br>      If KeyDown(203) = 0 And KeyDown(205) = 0 And corner# &gt; 0 Then corner# = corner# - .5<br><br>      If KeyDown(54) = 1 And slope# &lt; maxslope# Then slope# = slope + 1<br>      If KeyDown(157) = 1 And slope# &gt; maxslope# * -1 Then slope# = slope# - 1<br>      If KeyDown(54) = 0 And KeyDown(157) = 0 And slope# &lt; 0 Then slope# = slope# + .5<br>      If KeyDown(54) = 0 And KeyDown(157) = 0 And slope# &gt; 0 Then slope# = slope# - .5<br><br>      cam_x# = cam_x# + corner#<br>      cam_y# = cam_y# + slope#<br>      matrix_z# = matrix_z# + 1<br>      setheight(matrix_z#, cam_y#, 100, 100)<br><br>      fronttriy# = cam_y# + 0.5<br>      fronttrix# = cam_x#<br>      fronttriz# = cam_z#<br>      backleft# = backtrix# - 25<br>      backright# = backtrix# + 25<br>      frontleft# = fronttrix# - 25<br>      frontright# = fronttrix# + 25<br>;ERROR - MEMORY ACCESS VIOLATION, i'm leaving this for later :)<br>	  ;roadpoints(0) = AddVertex(road, frontright#, fronttriy#, fronttriz#)<br>	  ;roadpoints(1) = AddVertex(road, backleft#, backtriy#, backtriz#)<br>	  ;roadpoints(2) = AddVertex(road, frontleft#, fronttriy#, fronttriz#)<br>	  ;roadpoints(3) = AddVertex(road, backleft#, backtriy#, backtriz#)<br>	  ;roadpoints(4) = AddVertex(road, frontright#, fronttriy#, fronttriz#)<br>	  ;roadpoints(5) = AddVertex(road, backright#, backtriy#, backtriz#)<br><br>      ;create triangle polygons For road, texture them, And make them static<br>      ;AddTriangle(road, roadpoints(0), roadpoints(1), roadpoints(2))	<br>	  ;AddTriangle(road, roadpoints(3), roadpoints(4), roadpoints(5))<br>   EndIf<br><br>   PositionEntity camera,cam_x#, cam_y# + 30, cam_z# - 100<br>  ; PositionEntity camera,cam_x#, 60,0<br>   Locate 0,0<br>   Print " frame " + frame#<br>   Print " zposition" + matrix_z#<br>   Print " real Z position#" + cam_z#<br>   frame# = frame# + 1<br>   UpdateWorld<br>   RenderWorld<br>   Flip<br>Wend<br><br>;not worried about this yet.<br>;FUNCTION placereflectors(number#, x#, y#, z#, trackwidth#, texture1#, texture2#)<br>;         make object box number#,1,10,.1<br>;         position object number#, x# - (trackwidth# * .7), y# + 5, z#<br> ;        make static object number#,1<br> ;        texture object number#,2<br> ;        inc number#<br> ;;        make object box number#,1,10,.1<br> ;        position object number#,x# + (trackwidth# * .7), y# + 5, z#<br> ;        make static object number#,1<br>  ;       texture object number#,3<br>;ENDFUNCTION<br><br>FUNCTION setheight(z#, y#, leftheight#, rightheight#)<br>   section = round(z#, 100.0)<br>   sectiongroup = section<br>   section = section * 3 + 1<br>   oldz# = z#<br>   If section &gt; 3 Then oldy# = getgroundheight( (sectiongroup  * 3 + 1) - 3, 500.0, Abs(oldz# - (sectiongroup +.1))  * 10 )<br>   z# = (z# - (((section -1) / 3)*100))<br>  <br> ;  set center matrix height<br>   counter# = 10<br>   While counter# &gt; -1<br>	;try to join 'matrices' together.. doesnt work yet though<br>     If z# = 1 And section &gt; 3 Then SETMATRIXHEIGHT(section, counter#, 0, oldy#)<br>     SETMATRIXHEIGHT(section, counter#, z#, y#)<br>     counter# = counter# + 1<br>   Wend<br>	;left matrix height<br>   counter# = 10<br>   While counter# &gt; -1<br>      SETMATRIXHEIGHT(section + 1, 10 - counter#, z#, y# +  (((counter# * .01) * counter#) * leftheight#))<br>       counter = counter - 1<br>   Wend<br><br>   ; set matrix height for right side<br>   counter# = 0<br>   While counter# &lt; 11<br>      SETMATRIXHEIGHT(section + 2, counter#, z#, y# +  (((counter# * .01) * counter#) * rightheight#))<br>      counter = counter + 1<br>   Wend<br>End Function<br><br>FUNCTION preparematrixs(tracklength#, leftheight#, leftwidth#, rightheight#, rightwidth#, groundtex#)<br>    sections# = round(tracklength#, 100)<br>   remaindinglength# = remainder(tracklength#, 100)<br>   matrixnumber# = 1<br>   currentsection# = 0<br>   while sections# &gt; currentsection# - 1<br>      ; create center for current section<br>      creatematrix(matrixnumber#, 1000.0, 1000.0, 10.0 , 100.0, 0.0, currentsection# * 1000.0, groundtex#)<br>      matrixnumber = matrixnumber + 1<br>      creatematrix(matrixnumber#, leftwidth#, 1000.0, 10.0, 100.0, leftwidth# * -1.0, currentsection# * 1000.0, groundtex#)<br>      matrixnumber = matrixnumber + 1<br>      creatematrix(matrixnumber#, rightwidth#, 1000.0, 10.0, 100.0, 1000.0, currentsection# * 1000.0, groundtex#)<br>      matrixnumber = matrixnumber + 1<br>      currentsection# = currentsection# + 1<br>      ;set cursor 0,0<br>      print "creating matrix"; matrixnumber#<br>     ; sync<br>   Wend<br>   ;create matrix from the remainder<br>   remaindinglength# = int(remaindinglength#)<br>   creatematrix(matrixnumber#, 1000.0, remaindinglength# * 100.0, 10.0, remaindinglength# * 10.0, 0.0, currentsection# * 1000.0, groundtex#)<br>   matrixnumber = matrixnumber + 1<br>   creatematrix(matrixnumber#, leftwidth#, remaindinglength# * 100.0, 10.0, remaindinglength# * 10.0, leftwidth# * -1.0, currentsection# * 1000.0,  groundtex#)<br>   matrixnumber = matrixnumber + 1<br>   creatematrix(matrixnumber#, rightwidth#, remaindinglength# * 100.0, 10.0, remaindinglength#* 10.0, 1000.0, currentsection# * 1000.0,  groundtex#)<br>End Function<br><br>Function creatematrix(matrixnumber#, width#, length#, xsections#, zsections#, xpos#, zpos#, texture#)<br>      makematrix(matrixnumber#, width#, length# ,xsections#,zsections#)<br>      positionmatrix(matrixnumber#,xpos#,0,zpos#)<br>      preparematrixtexture(matrixnumber#,texture#,1,1)<br>      ;setmatrixtexture(matrixnumber#,1,0)<br>      fillmatrix(matrixnumber#,0,1)<br>  ;   set matrix wireframe on matrixnumber#<br>End Function<br><br>Function round(num#, tonearest#)<br>   ret# = 0<br>   While num# &gt; 0<br>      num# = num# - tonearest#<br>      If num# &gt; 0 Then ret# = ret# + 1<br>   Wend<br>	Return ret#<br>End Function <br><br>Function roundint(num, tonearest#)<br>   ret = 0<br>   While num &gt; 0<br>      num = num - tonearest<br>      If num &gt; 0 Then ret = ret + 1<br>   Wend<br>	Return ret<br>End Function<br><br>Function remainder(num#, tonearest#)<br>   ret# = 0<br>   While num# &gt; 0<br>      num# = num# - tonearest#<br>      If num# &gt; 0 Then ret# = num#<br>   Wend<br>	Return ret#<br>End Function<br>[/CODE]<br><br>the final one is how i would preferably have it (using terrains rather than matrices), but i fear that i will have to completely reprogram my game if i do so. i'll explain what i need at the end of this post. the media needed for this is just matrixtexture2.bmp (again, any bmp)<br><br>[CODE]<br>Graphics3D 640,480,16,0<br>SetBuffer BackBuffer()<br><br>Global camera = CreateCamera()<br>Type trackstat<br>	Field x#[100]<br>	Field y#<br>End Type<br>Global road = CreateMesh()<br>Dim roadpoints(5)<br><br>;roadtexture$ = "roadtexture1.bmp"<br>groundtexture$ = "matrixtexture2.bmp"<br>;trackfilename$ = "testing" + "_road.map"<br><br><br>;Global roadtex = LoadTexture("roadtexture1.bmp")<br>;Global flectred = LoadTexture("reflectred.bmp")<br>;Global flectgrey = LoadTexture("reflectgrey.bmp")<br>Global terraintex = LoadTexture("matrixtexture2.bmp")<br>tracklength = 1000<br><br>Dim track.trackstat(tracklength)<br>For i = 1 To tracklength<br>	track(i) = New trackstat<br>Next<br>noofterrains = roundint(tracklength, 100)<br>Dim terrainentitys(noofterrains)<br><br>preparematrixs(tracklength, terraintex)<br>cam_z# = 0<br>cam_y# = 0<br>cam_x# = 500<br><br>;set maximum and current corner and slope variables,<br>maxcorner# = 10<br>maxslope# = 5<br>corner# = 0<br>slope# = 0<br>;rem the amount of tiles we've travelled past<br>matrix_z# = 1 ;: rem hopefully<br>;rem check if moving forward to make the track smoother<br>moving# = 0<br>;rem when this is 10, a reflector is placed<br>reflectcounter# = 0<br>;rem reflector object no. start at 900 to avoid conflict in the game<br>reflectno# = 1000<br>;rem set matrix wireframe off 1<br>;rem 1st Triangle to create road from<br>roadtri# = 20000<br>backtriy# = 0<br>fronttriy# = 0<br>backtrix# = 500<br>fronttrix# = 500<br>backtriz# = 0<br>fronttriz# = 0<br>moving# = 0<br>frame# = 0<br>section = 1<br><br>While matrix_z# &lt; tracklength<br>   If moving# = 1<br>    ;  rem store variables for road triangle polygon creation<br>      backtriy# = cam_y# + 0.5<br>      backtrix# = cam_x#<br>      backtriz# = cam_z#<br>   EndIf<br><br>   ; set moving If upkey is pressed, And move To Next z joint in matrix.<br>   If KeyDown(200)=1<br>      cam_z#=cam_z# + 10<br>      moving# = 1<br>   Else<br>      moving# = 0<br>   EndIf<br>      If KeyDown(108) Then cam_z# = cam_z# - 1<br>   If moving# = 1<br><br>      If KeyDown(203)=1 And corner# &gt; maxcorner# * -1 Then corner# = corner - 1<br>      If KeyDown(205)=1 And corner# &lt; maxcorner# Then corner# = corner + 1<br>      If KeyDown(203) = 0 And KeyDown(205) = 0 And corner# &lt; 0 Then corner# = corner# + .5<br>      If KeyDown(203) = 0 And KeyDown(205) = 0 And corner# &gt; 0 Then corner# = corner# - .5<br><br>      If KeyDown(54) = 1 And slope# &lt; maxslope# Then slope# = slope + 1<br>      If KeyDown(157) = 1 And slope# &gt; maxslope# * -1 Then slope# = slope# - 1<br>      If KeyDown(54) = 0 And KeyDown(157) = 0 And slope# &lt; 0 Then slope# = slope# + .5<br>      If KeyDown(54) = 0 And KeyDown(157) = 0 And slope# &gt; 0 Then slope# = slope# - .5<br><br>      cam_x# = cam_x# + corner#<br>      cam_y# = cam_y# + slope#<br>      matrix_z# = matrix_z# + 1<br>       section = setheight(matrix_z#, cam_y#)<br><br>   ;   write float 1, matrix_z#<br>   ;   write float 1, cam_x#<br>   ;   write float 1, cam_y#<br>   ;   rem set triangle variables for road creation<br>      fronttriy# = cam_y# + 0.5<br>      fronttrix# = cam_x#<br>      fronttriz# = cam_z#<br>      backleft# = backtrix# - 25<br>      backright# = backtrix# + 25<br>      frontleft# = fronttrix# - 25<br>      frontright# = fronttrix# + 25<br>;ERROR - MEMORY ACCESS VIOLATION<br>	  ;roadpoints(0) = AddVertex(road, frontright#, fronttriy#, fronttriz#)<br>	  ;roadpoints(1) = AddVertex(road, backleft#, backtriy#, backtriz#)<br>	  ;roadpoints(2) = AddVertex(road, frontleft#, fronttriy#, fronttriz#)<br>	  ;roadpoints(3) = AddVertex(road, backleft#, backtriy#, backtriz#)<br>	  ;roadpoints(4) = AddVertex(road, frontright#, fronttriy#, fronttriz#)<br>	  ;roadpoints(5) = AddVertex(road, backright#, backtriy#, backtriz#)<br><br>      ;rem create triangle polygons For road, texture them, And make them static<br>     ; AddTriangle(road, roadpoints(0), roadpoints(1), roadpoints(2))	<br>	 ; AddTriangle(road, roadpoints(3), roadpoints(4), roadpoints(5))<br>    ;  make static Object roadtri#,1<br>    ;  texture object roadtri#, 1<br>    ;  inc roadtri#<br>   EndIf<br><br>   PositionEntity camera,cam_x#, cam_y# + 30, cam_z# - 100<br>  ; PositionEntity camera,cam_x#, 60,0   ; debug camera stays at start<br>   Locate 0,0<br>   print " frame "    ; frame#<br>   print " zposition" ;matrix_z#<br>   print " real Z position#" ; cam_z#<br>   frame# = frame# + 1<br>   UpdateWorld<br>   RenderWorld<br>   Flip<br>Wend<br><br>;FUNCTION placereflectors(number#, x#, y#, z#, trackwidth#, texture1#, texture2#)<br>;         make object box number#,1,10,.1<br>;         position object number#, x# - (trackwidth# * .7), y# + 5, z#<br>;         make static object number#,1<br>;         texture object number#,2<br>;         inc number#<br>;         make object box number#,1,10,.1<br>;         position object number#,x# + (trackwidth# * .7), y# + 5, z#<br> ;        make static object number#,1<br>;         texture object number#,3<br>;ENDFUNCTION<br><br>Function setheight(z#, y#)<br>   y# = y# * .001<br>   section = round(z#, 100.0)<br>   z# = remainder(z#, 100.0)<br>   Locate 0,50<br>   ;rem set center matrix height<br>   counter = 128<br>   While counter &gt; -1<br>    ; If z# = 0 And section &gt; 1 Then ModifyTerrain(terrainentitys(section) - 1, 100, z#, y#)<br>     ModifyTerrain(terrainentitys(section), counter, z#, y#)<br>      counter = counter - 1<br>   Wend<br>End Function<br><br>Function preparematrixs(tracklength, texture)<br>   remaindinglength# = tracklength<br>  ; sections = 0<br>   sections = roundint(tracklength, 100)	<br>   For terrain = 0 To sections<br>      makeTerrain(terrain, texture)<br>      ;terrain = terrain + 1<br>   Next<br>End Function<br><br>Function makeTerrain(terrainno, texture)<br>     terrainentitys(terrainno) = CreateTerrain(128)<br>	 ScaleEntity terrainentitys(terrainno),1000,10000,1000,1<br>	 PositionEntity terrainentitys(terrainno), 0, 0, terrainno * 1000<br>     EntityTexture terrainentitys(terrainno), terraintex<br>End Function<br><br>Function round(num#, tonearest#)<br>   ret# = 0<br>   While num# &gt; 0<br>      num# = num# - tonearest#<br>      If num# &gt; 0 Then ret# = ret# + 1<br>   Wend<br>	Return ret#<br>End Function <br><br>Function roundint(num, tonearest#)<br>   ret = 0<br>   While num &gt; 0<br>      num = num - tonearest<br>      If num &gt; 0 Then ret = ret + 1<br>   Wend<br>	Return ret<br>End Function<br><br>Function remainder(num#, tonearest#)<br>   ret# = 0<br>   While num# &gt; 0<br>      num# = num# - tonearest#<br>      If num# &gt; 0 Then ret# = num#<br>   Wend<br>	Return ret#<br>End Function<br>[/CODE]<br><br>the only requirements are:<br>+ flat along the x axis (or at least near the track)<br>+ every z intercept should be 10 units apart in 3d space.<br>i dont care how many terrains/matrices it uses, what type of surface it uses (a mesh, terrain, or matrix). i just want to know how to get it to work like it did in DB.<br><br>please help a poor unfortunate soul that was struck with the disadvantage of knowing that DB exists, before he knew that blitz existed! <br>i know this is alot to ask, but if you can help me, you will definitely get your name in my credits :)<br><br>thanks in advance<br>lecks <br><br></td></tr></table><br>
<a name="249215"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> ps. ignore commented stuff, i'm not worried about that YET ;)<br><br>and please dont tell me i'm going to have to rewrite the logic of my game. all it uses atm is track(zpos(onmatrix), ypos) <br><br></td></tr></table><br>
<a name="249248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gauge</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hrrm, i'm not sure how matrix work in db.  I know the terrain funcion kind of sucks in blitz basic.  Theres alot of people have made 3d tile progs.  I think the best way is to make a terrain one mesh, then have different surfaces.  I've never made a car program either, i'm sorta new to blitz.  If i was to start a racing game i think you'd have to add collisions for each tire of the car maybe? or you could run a type and store the roll, pitch etc.<br><br>Which aspect isn't working exactly, god forbid me, but i'll try downloading darkbasic(no this doesn't damn me to hell, i'll delete it real quick) to see how yours works.<br><br>but I do know one thing...it'll be easier, alot easier to code, and alot easier to edit in blitz! <br><br></td></tr></table><br>
<a name="249250"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> the reason i included the darkbasic code was to show what i wanted to happen... it works in the demo which is only a couple of meg (from memory). this isnt the game, it's only the track editor, so i'm not worried about positioning the car or collision or anything atm. i'm just trying to create a track in this method with the requirements mentioned above. i hope i'll be able to handle the rest after that.<br>all 3 lots of code are the full progs, so you can see, how bad the results ended up :). once again i know this is alot to ask, but if someone with some experience in blitz had a browse through it, i'm sure they could figure it out quite quickly.<br><br>basically probs are in #2, nothing happens, in #3 something happens, but i dont quite understand what :).<br><br>i doubt anyone could understand what i want without downloading the DB classic demo and trying the first code with it (creating the media files mentioned above). dont worry i'm by no means trying to get ppl to try DB, because it seems crap compared to blitz, it's just the only way i can show you my desired result.<br><br>i forgot to mention the controls before too:<br>UP = go - nothing will work without it<br>left/right = change angle for next x (curve)<br>right ctrl/shift = change angle for next y (slope) <br><br></td></tr></table><br>
<a name="249384"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jeremy Alessi</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Man, just ditch that old code if you're trying to make an editor.  You can carve out a nice terrain in Blitz easily just my making a heightmap in photoshop.  The use the driver physics for your cars.  Then just program a placement editor to place trackside objects and whatnot.  <br><br>I know you don't want to see your old code wasted but it seems to me that it'll be quicker for you to reprogram your game using aspects of Blitz which are different from what you were doing with DarkBASIC.  <br><br>It's crazy that it took hours and hours even with MAT Edit to make a nice DB matrix/terrain and you can create the same thing using a heightmap image that'll take 5 mintutes in photoshop.  You need to ditch most of your DB knowledge and focus on learning how Blitz works.  It'll save you lots of time and effort.<br><br>Might I also suggest using a 3rd party modeling utility to create terrains.  I was using terrains in Aerial Antics and it's turning out a lot better now that my artist is creating the terrains in 3DS Max. <br><br></td></tr></table><br>
<a name="249386"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> well i fixed the matrix one, this was the problem:<br>[CODE]<br>  counter# = 10<br>   While counter# &gt; -1<br>	;try to join 'matrices' together.. doesnt work yet though<br>     If z# = 1 And section &gt; 3 Then SETMATRIXHEIGHT(section, counter#, 0, oldy#)<br>     SETMATRIXHEIGHT(section, counter#, z#, y#)<br>     counter# = counter# - 1<br>   Wend<br>[/CODE]<br>(duh).<br>is it legal to use the matrix library in &lt;blitz folder&gt;\samples\si\matrix in projects? <br>if not, would a blitz terrain be the way to go? or is guage correct in saying "I know the terrain funcion kind of sucks in blitz basic"?<br><br>ill attach the full code here once i sort it out properly <br><br></td></tr></table><br>
<a name="249391"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> damn i type too slow :)<br><br>i do want to use blitz terrains rather than Db stuff, but i still need to make the terrain suitable for the game, and i think this could be quite difficult using height maps to create terrains.<br><br>i might give it a try anyway, and see how it goes. the matrix version works ok, but i would rather use blitz features than db features.<br><br>thanks for your input. <br><br>heres the code using matrix.bb (needs a texture matrixtexture2.bmp, or you can change the filename near the top). It's messy, but it sort of works and shows what im trying to do (sort of :) )<br><br>[CODE]<br>Graphics3D 640,480,16,0<br>SetBuffer BackBuffer()<br>Include "matrix.bb"<br><br>Global camera = CreateCamera()<br>; gonna be for saving (hopefully)<br>;Type trackstat<br>;	Field x#[100]<br>;	Field y#<br>;End Type<br>;was gonna be for the road, but doest work yet<br>Global road = CreateMesh()<br>Global roadsurface = CreateSurface(road)<br>Dim roadpoints(5)<br><br>;roadtexture$ = "roadtexture1.bmp"<br>groundtexture$ = "matrixtexture2.bmp"<br>;trackfilename$ = "testing" + "_road.map"<br><br><br>;Global roadtex = LoadTexture("roadtexture1.bmp")<br>;Global flectred = LoadTexture("reflectred.bmp")<br>;Global flectgrey = LoadTexture("reflectgrey.bmp")<br>;Global terraintex = LoadTexture("matrixtexture2.bmp")<br><br>DB_LoadImage( groundtexture, 4 )<br>tracklength# = 2100<br><br>;Dim track.trackstat(tracklength)<br>;For i = 1 To tracklength<br>;	track(i) = New trackstat<br>;Next<br><br>noofterrains = roundint(tracklength, 100)<br>Dim terrainentitys(noofterrains)<br><br>preparematrixs(tracklength#, 100.0, 100.0, 100.0, 100.0, 4.0)<br>cam_z# = 0<br>cam_y# = 0<br>cam_x# = 500<br><br>;set maximum and current corner and slope variables,<br>maxcorner# = 10<br>maxslope# = 5<br>corner# = 0<br>slope# = 0<br>;the amount of tiles we've travelled past<br>matrix_z# = 1 ;: hopefully<br>;check if moving forward to make the track smoother<br>moving# = 0<br>;when this is 10, a reflector is placed<br>reflectcounter# = 0<br>;reflector object no. start at 900 to avoid conflict in the game<br>reflectno# = 1000<br>;set matrix wireframe off 1<br>;1st Triangle to create road from<br>roadtri# = 20000<br>backtriy# = 0<br>fronttriy# = 0<br>backtrix# = 500<br>fronttrix# = 500<br>backtriz# = 0<br>fronttriz# = 0<br>moving# = 0<br>frame# = 0<br>section = 1<br><br>While matrix_z# &lt; tracklength <br>   If moving# = 1<br>    ;  store variables for road triangle polygon creation<br>      backtriy# = cam_y# + 0.5<br>      backtrix# = cam_x#<br>      backtriz# = cam_z#<br>   EndIf<br><br>   ; set moving If up key is pressed, And move To Next z joint in matrix.<br>   If KeyDown(200)=1<br>      cam_z#=cam_z# + 10<br>      moving# = 1<br>   Else<br>      moving# = 0<br>   EndIf<br>      If KeyDown(108) Then cam_z# = cam_z# - 1<br>   If moving# = 1<br><br>      If KeyDown(203)=1 And corner# &gt; maxcorner# * -1 Then corner# = corner - 1<br>      If KeyDown(205)=1 And corner# &lt; maxcorner# Then corner# = corner + 1<br>      If KeyDown(203) = 0 And KeyDown(205) = 0 And corner# &lt; 0 Then corner# = corner# + .5<br>      If KeyDown(203) = 0 And KeyDown(205) = 0 And corner# &gt; 0 Then corner# = corner# - .5<br><br>      If KeyDown(54) = 1 And slope# &lt; maxslope# Then slope# = slope + 1<br>      If KeyDown(157) = 1 And slope# &gt; maxslope# * -1 Then slope# = slope# - 1<br>      If KeyDown(54) = 0 And KeyDown(157) = 0 And slope# &lt; 0 Then slope# = slope# + .5<br>      If KeyDown(54) = 0 And KeyDown(157) = 0 And slope# &gt; 0 Then slope# = slope# - .5<br><br>      cam_x# = cam_x# + corner#<br>      cam_y# = cam_y# + slope#<br>      matrix_z# = matrix_z# + 1<br>      setheight(matrix_z#, cam_y#, 100, 100)<br>      fronttriy# = cam_y# + 0.5<br>      fronttrix# = cam_x#<br>      fronttriz# = cam_z#<br>      backleft# = backtrix# - 25<br>      backright# = backtrix# + 25<br>      frontleft# = fronttrix# - 25<br>      frontright# = fronttrix# + 25<br>	  roadpoints(0) = AddVertex(roadsurface, frontright#, fronttriy#, fronttriz#)<br>	  roadpoints(1) = AddVertex(roadsurface, backleft#, backtriy#, backtriz#)<br>	  roadpoints(2) = AddVertex(roadsurface, frontleft#, fronttriy#, fronttriz#)<br>	  roadpoints(3) = AddVertex(roadsurface, backleft#, backtriy#, backtriz#)<br>	  roadpoints(4) = AddVertex(roadsurface, frontright#, fronttriy#, fronttriz#)<br>	  roadpoints(5) = AddVertex(roadsurface, backright#, backtriy#, backtriz#)<br><br>      ;rem create triangle polygons For road, texture them, And make them static<br>      AddTriangle(roadsurface, roadpoints(0), roadpoints(1), roadpoints(2))	<br>	  AddTriangle(roadsurface, roadpoints(3), roadpoints(4), roadpoints(5))<br>     ; EntityTexture(road, roadtex)<br>   EndIf<br><br>   PositionEntity camera,cam_x#, cam_y# + 30, cam_z# - 100<br>  ; PositionEntity camera,cam_x#, 60,0<br>   Locate 0,0<br>   Print " frame " + frame#<br>   Print " zposition" + matrix_z#<br>   Print " real Z position#" + cam_z#<br>   frame# = frame# + 1<br>   UpdateWorld<br>   RenderWorld<br>   Flip<br>Wend<br><br><br>FUNCTION setheight(z#, y#, leftheight#, rightheight#)<br>   sectiongroup = round(z#, 100.0)<br>	;first matrix number<br>   section = sectiongroup * 3 + 1<br>   oldz# = z#<br>   If section &gt; 3 Then oldy# = getgroundheight( (sectiongroup  * 3 + 1) - 3, 500.0, Abs(oldz# - (sectiongroup +.1))  * 10 )<br>   z# = (z# - (((section -1) / 3)*100))<br>  <br> ;  set center matrix height<br>   counter# = 10<br>   While counter# &gt; -1<br>	;try to join 'matrices' together.. doesnt work yet though<br>     If z# = 1 And section &gt; 3 Then SETMATRIXHEIGHT(section, counter#, 0, oldy#)<br>     SETMATRIXHEIGHT(section, counter#, z#, y#)<br>     counter# = counter# - 1<br>   Wend<br>	;left matrix height<br>   counter# = 10<br>   While counter# &gt; -1<br>      SETMATRIXHEIGHT(section + 1, 10 - counter#, z#, y# +  (((counter# * .01) * counter#) * leftheight#))<br>       counter = counter - 1<br>   Wend<br><br>   ; set matrix height for right side<br>   counter# = 0<br>   While counter# &lt; 11<br>      SETMATRIXHEIGHT(section + 2, counter#, z#, y# +  (((counter# * .01) * counter#) * rightheight#))<br>      counter = counter + 1<br>   Wend<br>End Function<br><br>FUNCTION preparematrixs(tracklength#, leftheight#, leftwidth#, rightheight#, rightwidth#, groundtex#)<br>    sections# = round(tracklength#, 1000)<br>   remaindinglength# = remainder(tracklength#, 1000)<br>   matrixnumber# = 1<br>   currentsection# = 0<br>   while sections# &gt; currentsection# - 1<br>      ; create center for current section<br>      creatematrix(matrixnumber#, 1000.0, 1000.0, 100.0 , 100.0, 0.0, currentsection# * 1000.0, groundtex#)<br>      matrixnumber = matrixnumber + 1<br>      creatematrix(matrixnumber#, leftwidth#, 1000.0, 100.0, 10.0, leftwidth# * -1.0, currentsection# * 1000.0, groundtex#)<br>      matrixnumber = matrixnumber + 1<br>      creatematrix(matrixnumber#, rightwidth#, 1000.0, 100.0, 10.0, 1000.0, currentsection# * 1000.0, groundtex#)<br>      matrixnumber = matrixnumber + 1<br>      currentsection# = currentsection# + 1<br>      ;set cursor 0,0<br>      Print "creating matrix" + matrixnumber#<br>     ; sync<br>   Wend<br>   ;create matrix from the remainder<br>   remaindinglength# = int(remaindinglength#)<br>   creatematrix(matrixnumber#, 1000.0, remaindinglength# * 100.0, 10.0, remaindinglength# * 10.0, 0.0, currentsection# * 1000.0, groundtex#)<br>   matrixnumber = matrixnumber + 1<br>   creatematrix(matrixnumber#, leftwidth#, remaindinglength# * 100.0, 10.0, remaindinglength# * 10.0, leftwidth# * -1.0, currentsection# * 1000.0,  groundtex#)<br>   matrixnumber = matrixnumber + 1<br>   creatematrix(matrixnumber#, rightwidth#, remaindinglength# * 100.0, 10.0, remaindinglength#* 10.0, 1000.0, currentsection# * 1000.0,  groundtex#)<br>End Function<br><br>Function creatematrix(matrixnumber#, width#, length#, xsections#, zsections#, xpos#, zpos#, texture#)<br>      makematrix(matrixnumber#, width#, length# ,xsections#,zsections#)<br>      positionmatrix(matrixnumber#,xpos#,0,zpos#)<br>      preparematrixtexture(matrixnumber#,texture#,1,1)<br>      ;setmatrixtexture(matrixnumber#,1,0)<br>      fillmatrix(matrixnumber#,0,1)<br>  ;   set matrix wireframe on matrixnumber#<br>End Function<br><br>Function round(num#, tonearest#)<br>   ret# = 0<br>   While num# &gt; 0<br>      num# = num# - tonearest#<br>      If num# &gt; 0 Then ret# = ret# + 1<br>   Wend<br>	Return ret#<br>End Function <br><br>Function roundint(num, tonearest#)<br>   ret = 0<br>   While num &gt; 0<br>      num = num - tonearest<br>      If num &gt; 0 Then ret = ret + 1<br>   Wend<br>	Return ret<br>End Function<br><br>Function remainder(num#, tonearest#)<br>   ret# = 0<br>   While num# &gt; 0<br>      num# = num# - tonearest#<br>      If num# &gt; 0 Then ret# = num#<br>   Wend<br>	Return ret#<br>End Function<br>[/CODE] <br><br></td></tr></table><br>
<a name="249455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>i do want to use blitz terrains rather than Db stuff, but i still need to make the terrain suitable for the game, and i think this could be quite difficult using height maps to create terrains<br> <br></div><br>While I'm not about to try and understand the DB code, you don't *have* to use heightmaps to create Blitz terrains -- see the ModifyTerrain command... <br><br></td></tr></table><br>
<a name="249463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can also build meshes on the fly. Also check out code archives for tips... <br><br></td></tr></table><br>
<a name="249624"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> heightmaps didnt work, it didnt create a smooth enough terrain for the road to be placed on.<br><div class="quote"> <br>While I'm not about to try and understand the DB code, you don't *have* to use heightmaps to create Blitz terrains -- see the ModifyTerrain command... <br> <br></div><br>i did try this, but it made the editor run very slow for some reason. may have been my code though, i'm not sure :)<br><div class="quote"> <br>You can also build meshes on the fly. Also check out code archives for tips...<br> <br></div><br>I'm pretty sure the functions in the matrix.bb file creates meshes and uses them as terrains (and calls them matrices). don't quote me on that, but i'm pretty sure it's what it does. I might write my own functions to do this eventually anyway, cutting out the crap thats just there to make it usable in the DB functions. If you have a look at the last piece of code i posted, the road is a mesh being created on the fly. i dont know if i'm doing it the right way though :). <br><br>Thanks for your help guys, i'll figure something out one day :) I think i'm trying to rush through and get it done, so i can see how fast the game will work in blitz.<br><br>ps. is a 128tile x 128tile Terrain or 128tile x 128tile mesh faster? <br><br></td></tr></table><br>
<a name="249632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> is it possible to edit the pts of a mesh after the entity handle has been changed? eg.<br>[CODE]<br>;create mesh and array to use for road<br>Global road = CreateMesh()<br>Global roadsurface = CreateSurface(road)<br>Dim roadpoints(5)<br><br>for i = 1 to 50<br><br>    ;just giving it any numbers :)<br>    backleftx# = frontleftx#<br>    backrightx# = frontrightx#<br>    backz# = frontz#<br>    backy# = fronty#<br>    frontleftx# = i*2<br>    frontrightx# = i*2 + 10<br>    frontz# = i*10<br>    fronty# = i<br><br>    roadpoints(0) = AddVertex(roadsurface, frontrightx#, fronty#, frontz#)<br>   roadpoints(1) = AddVertex(roadsurface, backleftx#, backy#, backz#)<br>   roadpoints(2) = AddVertex(roadsurface, frontleftx#, fronty#, frontz#)<br>   roadpoints(3) = AddVertex(roadsurface, backleftx#, backy#, backz#)<br>   roadpoints(4) = AddVertex(roadsurface, frontrightx#, fronty#, frontz#)<br>   roadpoints(5) = AddVertex(roadsurface, backrightx#, backy#, backz#)<br>    <br>   AddTriangle(roadsurface, roadpoints(0), roadpoints(1), roadpoints(2))	<br>    AddTriangle(roadsurface, roadpoints(3), roadpoints(4), roadpoints(5))<br>next<br>[/CODE]<br>would it then be possible to edit a point in the middle of this mesh? or would i have to create a huge array to handle each vertice? <br><br></td></tr></table><br>
<a name="249660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >IPete2</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Lecks,<br><br>Don't know if this helps, but check out the deforming code in Mark Sibly's "Markio" demo in the MAK folder in the B3D samples - it may be called 'Castle' I can't remember.<br><br>When Markio fires flares into the mesh surface, it deforms into pits.<br><br>IPete2. <br><br></td></tr></table><br>
<a name="249693"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> this probrably would have the same effect, but i think it uses terrains, not meshes. <br><br></td></tr></table><br>
<a name="249872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gauge</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm about 99% sure a 128by 128 tile mesh would be a ton faster then terrain right now.  And i think a 128 by 128 surfaces mesh would be faster then either one.<br><br>So what you need is a tile editor for terrain, etc etc right? <br><br></td></tr></table><br>
<a name="250009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >lecks</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> i've already decided to use mesh terrains rather that blitz terrains, because some demos with large blitz terrains seem to run quite slow, and if i were using terrains, there would be alot of big terrains.<br>i could create my own, but i dont know how to move a vertex after its handle has been overwritten.<br><br>is there some sort of command like<br>selectedvertex = VertexAt(Meshhandle, Xpos#, Ypos#, Zpos#)<br>or do i have to store the handle of every vertex? <br><br></td></tr></table><br>
<a name="250593"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Use Linepicks, then:<br>PickedTriangle() ; Desc. kinda missing :( ,try to search for the word in the forums...<br>and then<br>TriangleVertex ( surface,triangle_index,corner )<br><br>Or maybe also:<br>CollisionTriangle ( entity,index )<br><br>Btw. You can also parse trough all Vertices and search for the nearest Vertex manually - since there is no 3D Command Execution, this might be a lot faster than a linepick. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
