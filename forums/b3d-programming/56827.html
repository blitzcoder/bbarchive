<!DOCTYPE html><html lang="en" ><head ><title >"Hard" maths: angle between 2 triangles ??</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >"Hard" maths: angle between 2 triangles ??</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >"Hard" maths: angle between 2 triangles ??</a><br><br>
<a name="631796"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi<br><br>working on my stencil shadow system its getting late and im a bit tired so if there are math people out there that could help would be nice. If not i'll probably solve it myself tomorrow.<br><br>I need an angle between two triangles that share one edge. So they have 4 verts that can move anywhere in XYZ space, and they share 2 of those verts. Both facing same direction. Each triangle has its plane and its normal defined by the 3 verts that make it up. I need to know the angle (0 to 360) between each of the planes or normals (whichever you want). I was looking into cross product but dont have time tonight so maybe someone can give a hint?<br><br>This is for a predefined list of triangles and edges that is made for each shadow caster so that when two triangles form a cavity (angle smaller than 180) the edge between them is ignored and in this way less calculation and volume updating has to be done each loop because a cavity never casts a shadow, its always "inside". Most systems dont have this optimisation but since blitz is slow enough as it is, i think we really need it. BTW any helpful soul will be included in credits :P<br><br>thanks <br><br></td></tr></table><br>
<a name="631808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> No actually this optimisation isnt crucial so i might leave it for later. Better finish the primary stuff and optimise it after. So this question stays open. <br><br>I figured out the theory of it but putting down the equations, im not so keen on doing. <br><br></td></tr></table><br>
<a name="631812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I believe the dot product of the two normals of the planes is what you want. <br><br></td></tr></table><br>
<a name="631828"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm i was heading in that direction as well but i will try it later. I think this wont be in the first release, but it is a crucial feature that could speed the system up by 140%.<br><br>If someone can just gimmedacodez that would be sweet :) i have enough theoretic ideas as it is. <br><br></td></tr></table><br>
<a name="631872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think this is right .... assuming p &amp; q are vectors<br><br>MagP = sqr( px * px + py * py + pz * pz )<br>MagQ = sqr( qx * qx + qy * qy + qz * qz )<br><br>cos( theta ) = ( px*qx + py*qy + pz*qz ) / ( MagP * MagQ )<br><br>=&gt; Theta = Acos( ( px*qx + py*qy + pz*qz ) / ( MagP * MagQ ) )<br><br>Stevie <br><br></td></tr></table><br>
<a name="631974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> :o <br><br>Looks good to me. But i suppose P and Q are vectors of normals (or probably crossproduct)? I'll test. <br><br></td></tr></table><br>
<a name="631998"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm it works but the problem is it is always giving a positive angle because of Squareing and Squarerooting. I worked out a similar problem before so i will work this one out. It's just a matter of comparing signs of the vectors. Thanks Stevie!<br><br>Here's the code i have now(mess left over from previous tests):<br>Use WASDFC to move camera, and insert,home,pgup,pgdn,delete,end to move the 4th vertex.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,0,2



Global vectorx#
Global vectory#
Global vectorz#
Global vectorw#

Const UPS=60

cam=CreateCamera()
PositionEntity cam, 0,5,-15

l=CreateLight()

period=1000/UPS
time=MilliSecs()-period

v1=CreateSphere()
ScaleEntity v1,0.5,0.5,0.5
v2=CreateSphere()
ScaleEntity v2,0.5,0.5,0.5
v3=CreateSphere()
ScaleEntity v3,0.5,0.5,0.5
v4=CreateSphere()
ScaleEntity v4,0.5,0.5,0.5

cp1=CreateSphere();cross product marker
ScaleEntity cp1,0.5,0.5,0.5
EntityColor cp1, 0,0,250
cp2=CreateSphere()
ScaleEntity cp2,0.5,0.5,0.5
EntityColor cp2, 0,0,250


smesh = CreateMesh()
ssurf = CreateSurface(smesh)

v1x#=-6;left
v1y#=4
v1z#=2
v2x#=0;middle front
v2y#=1
v2z#=4
v3x#=0;middle back
v3y#=1
v3z#=0
v4x#=6;right
v4y#=1
v4z#=2

v1v = AddVertex (ssurf, v1x,v1y,v1z)
v2v = AddVertex (ssurf, v2x,v2y,v2z)
v3v = AddVertex (ssurf, v3x,v3y,v3z)
v4v = AddVertex (ssurf, v4x,v4y,v4z)

AddTriangle (ssurf, v1v,v2v,v3v)
AddTriangle (ssurf, v2v,v4v,v3v)

PositionEntity v1, v1x,v1y,v1z
PositionEntity v2, v2x,v2y,v2z
PositionEntity v3, v3x,v3y,v3z
PositionEntity v4, v4x,v4y,v4z

Repeat
	Repeat
		elapsed=MilliSecs()-time
	Until elapsed
	ticks=elapsed/period
	tween#=Float(elapsed Mod period)/Float(period)

msp# = 0.2

If KeyDown(17) Then MoveEntity cam, 0,0,msp
If KeyDown(31) Then MoveEntity cam, 0,0,-msp
If KeyDown(33) Then MoveEntity cam, 0,msp,0
If KeyDown(46) Then MoveEntity cam, 0,-msp,0
If KeyDown(32) Then MoveEntity cam, msp,0,0
If KeyDown(30) Then MoveEntity cam, -msp,0,0
If KeyDown (203) Then TurnEntity cam, 0,msp*5,0
If KeyDown (205) Then TurnEntity cam, 0,-msp*5,0
If KeyDown (200) Then TurnEntity cam, msp*5,0,0
If KeyDown (208) Then TurnEntity cam, -msp*5,0,0

If KeyDown (199) Then v4y = v4y + msp
If KeyDown (207) Then v4y = v4y - msp
If KeyDown (210) Then v4z = v4z + msp
If KeyDown (201) Then v4z = v4z - msp
If KeyDown (209) Then v4x = v4x + msp
If KeyDown (211) Then v4x = v4x - msp


;update verts
VertexCoords ssurf, v4v,v4x,v4y,v4z


;update spheres representing verts
PositionEntity v1, v1x,v1y,v1z
PositionEntity v2, v2x,v2y,v2z
PositionEntity v3, v3x,v3y,v3z
PositionEntity v4, v4x,v4y,v4z


ax#=v1x-v2x
ay#=v1y-v2y
az#=v1z-v2z
bx#=v1x-v3x
by#=v1y-v3y
bz#=v1z-v3z
CrossProduct(ax,ay,az,bx,by,bz)
t1vx#=vectorx
t1vy#=vectory
t1vz#=vectorz

ax#=v4x-v3x
ay#=v4y-v3y
az#=v4z-v3z
bx#=v4x-v2x
by#=v4y-v2y
bz#=v4z-v2z
CrossProduct(ax,ay,az,bx,by,bz)
t2vx#=vectorx
t2vy#=vectory
t2vz#=vectorz

px# = t1vx
py# = t1vy
pz# = t1vz
qx# = t2vx
qy# = t2vy
qz# = t2vz

MagP# = Sqr( px * px + py * py + pz * pz )
MagQ# = Sqr( qx * qx + qy * qy + qz * qz )

Theta# = ACos( ( px*qx + py*qy + pz*qz ) / ( MagP * MagQ ) )

wtf=False
If t1vx &lt;= 0 And t2vx &gt; 0 Then
wtf=True
ElseIf t1vx &gt;= 0 And t2vx &lt; 0 Then
wtf=True
ElseIf t1vy &lt;= 0 And t2vy &gt; 0 Then
wtf=True
ElseIf t1vy &gt;= 0 And t2vy &lt; 0 Then
wtf=True
ElseIf t1vz &lt;= 0 And t2vz &gt; 0 Then
wtf=True
ElseIf t1vz &gt;= 0 And t2vz &lt; 0 Then
wtf=True
EndIf

If Theta = NaN Then
	djhfsdf$="No Edge"
Else
	djhfsdf$="Edge"
End If

;update the cross product results
PositionEntity cp1, v1x+t1vx,v1y+t1vy,v1z+t1vz
PositionEntity cp2, v4x+t2vx,v4y+t2vy,v4z+t2vz

;show projected lines of cross product
CameraProject (cam, v1x,v1y,v1z)
p1x=ProjectedX()
p1y=ProjectedY()
CameraProject (cam, v1x+t1vx,v1y+t1vy,v1z+t1vz)
pt1x=ProjectedX()
pt1y=ProjectedY()
CameraProject (cam, v4x,v4y,v4z)
p2x=ProjectedX()
p2y=ProjectedY()
CameraProject (cam, v4x+t2vx,v4y+t2vy,v4z+t2vz)
pt2x=ProjectedX()
pt2y=ProjectedY()


	For k=1 To ticks
		time=time+period	
		If KeyHit(1) End
		UpdateWorld	
	Next
	
	RenderWorld tween
	
	Color 255,255,255
Text 10,10,	t1vx + ", " + t1vy + ", " + t1vz
Text 10,20,	t2vx + ", " + t2vy + ", " + t2vz
Text 10,30, Theta
Text 10,40, djhfsdf
Text 10,50, "wtf:" + wtf
	Color 255,00,0
;Line p1x,p1y,pt1x,pt1y
;Line p2x,p2y,pt2x,pt2ya
	Flip

Forever





Function TriangleNormal#(Ax#,Ay#,Az#,Bx#,By#,Bz#,Cx#,Cy#,Cz#)
SubVector Bx#,By#,Bz#,Ax#,Ay#,Az#
ux#=VectorX()
uy#=VectorY()
uz#=VectorZ()
SubVector Cx#,Cy#,Cz#,Bx#,By#,Bz#
vx#=VectorX()
vy#=VectorY()
vz#=VectorZ()
CrossProduct vx#,vy#,vz#,ux#,uy#,uz#
;Normalize vectorx,vectory,vectorz
Return Ax#*vectorx+Ay#*vectory+Az#*vectorz
End Function

Function VectorX#()
Return vectorx
End Function

Function VectorY#()
Return vectory
End Function

Function VectorZ#()
Return vectorz
End Function

Function VectorW#()
Return vectorw
End Function

Function SubVector(Ax#,Ay#,Az#,Bx#,By#,Bz#)
vectorx#=ax#-bx#
vectory#=ay#-by#
vectorz#=az#-bz#
End Function

Function Normalize(nx#,ny#,nz#)
If nx=0 And ny=0 And nz=0 Return
m#=Magnitude(nx#,ny#,nz#)
vectorx#=nx#/m#
vectory#=ny#/m#
vectorz#=nz#/m#
End Function

Function CrossProduct(Ax#,Ay#,Az#,Bx#,By#,Bz#)
vectorx#=Ay#*Bz#-Az#*By#
vectory#=Az#*Bx#-Ax#*Bz#
vectorz#=Ax#*By#-Ay#*Bx#
End Function


Function Magnitude(nx#,ny#,nz#) 
m#= Sqr( (nx*nx) + (ny*ny) + (nz*nz) ) 
Return m# 
End Function</textarea> <br><br></td></tr></table><br>
<a name="632041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok i solved it. If anyone needs a function to check the angle between triangles, or rather the angle between the normals of two triangles, it is contained in there.<br><br>I would have spent much more time if it wasn't for you <b>Stevie G</b>, so thanks again.<br><br>I'm not sure this is useful enough to post it in the code archives :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Checks the angle between (normals of) two triangles.
;By Braincell, February 2006 
;
;Note: If you dont want them to share 2 vertices you can modify the function
;to take 6 verts and calculate the cross prodcut accordingly, ie instead of
;v123 and v432 that is there now, have v123, v456 cross products.
;
;This function was made to be part of the stencil shadow system

Graphics3D 800,600,0,2

;3.bb &gt;&gt; final version with function



Global vectorx#
Global vectory#
Global vectorz#
Global vectorw#

Const UPS=60

cam=CreateCamera()
PositionEntity cam, 0,5,-15

l=CreateLight()

period=1000/UPS
time=MilliSecs()-period

v1=CreateSphere()
ScaleEntity v1,0.5,0.5,0.5
v2=CreateSphere()
ScaleEntity v2,0.5,0.5,0.5
v3=CreateSphere()
ScaleEntity v3,0.5,0.5,0.5
v4=CreateSphere()
ScaleEntity v4,0.5,0.5,0.5

;cp1=CreateSphere();cross product marker
;ScaleEntity cp1,0.5,0.5,0.5
;EntityColor cp1, 0,0,250
;cp2=CreateSphere()
;ScaleEntity cp2,0.5,0.5,0.5
;EntityColor cp2, 0,0,250


smesh = CreateMesh()
ssurf = CreateSurface(smesh)

v1x#=-6;left
v1y#=4
v1z#=2
v2x#=0;middle front
v2y#=1
v2z#=4
v3x#=0;middle back
v3y#=1
v3z#=0
v4x#=6;right
v4y#=1
v4z#=2

v1v = AddVertex (ssurf, v1x,v1y,v1z)
v2v = AddVertex (ssurf, v2x,v2y,v2z)
v3v = AddVertex (ssurf, v3x,v3y,v3z)
v4v = AddVertex (ssurf, v4x,v4y,v4z)

AddTriangle (ssurf, v1v,v2v,v3v)
AddTriangle (ssurf, v2v,v4v,v3v)

PositionEntity v1, v1x,v1y,v1z
PositionEntity v2, v2x,v2y,v2z
PositionEntity v3, v3x,v3y,v3z
PositionEntity v4, v4x,v4y,v4z




.mainloop
Repeat
	Repeat
		elapsed=MilliSecs()-time
	Until elapsed
	ticks=elapsed/period
	tween#=Float(elapsed Mod period)/Float(period)

msp# = 0.2

;WASDFC moves the camera
If KeyDown(17) Then MoveEntity cam, 0,0,msp
If KeyDown(31) Then MoveEntity cam, 0,0,-msp
If KeyDown(33) Then MoveEntity cam, 0,msp,0
If KeyDown(46) Then MoveEntity cam, 0,-msp,0
If KeyDown(32) Then MoveEntity cam, msp,0,0
If KeyDown(30) Then MoveEntity cam, -msp,0,0
If KeyDown (203) Then TurnEntity cam, 0,msp*5,0
If KeyDown (205) Then TurnEntity cam, 0,-msp*5,0
If KeyDown (200) Then TurnEntity cam, msp*5,0,0
If KeyDown (208) Then TurnEntity cam, -msp*5,0,0

;Insert, Delete, Home, End, PgUP, PgDN moves the vertex
If KeyDown (199) Then v4y = v4y + msp
If KeyDown (207) Then v4y = v4y - msp
If KeyDown (210) Then v4z = v4z + msp
If KeyDown (201) Then v4z = v4z - msp
If KeyDown (209) Then v4x = v4x + msp
If KeyDown (211) Then v4x = v4x - msp


;update verts
VertexCoords ssurf, v4v,v4x,v4y,v4z


;update spheres representing verts
PositionEntity v1, v1x,v1y,v1z
PositionEntity v2, v2x,v2y,v2z
PositionEntity v3, v3x,v3y,v3z
PositionEntity v4, v4x,v4y,v4z

af# = AngleBetweenTriangles#(v1x#,v1y#,v1z#,v2x#,v2y#,v2z#,v3x#,v3y#,v3z#,v4x#,v4y#,v4z#)

If af# &lt; 180.0 Then
	txt$ = "No edge."
Else
	txt$ = "Edge."
End If

;update the cross product results (places blue spheres at CP result)
;PositionEntity cp1, v1x+t1vx,v1y+t1vy,v1z+t1vz ;values moved to function
;PositionEntity cp2, v4x+t2vx,v4y+t2vy,v4z+t2vz

	For k=1 To ticks
		time=time+period	
		If KeyHit(1) End
		UpdateWorld	
	Next
	
	RenderWorld tween
	
	Color 255,255,255
Text 10,10, txt
Text 10,25, "Angle: " + af

	Flip

Forever





Function TriangleNormal#(Ax#,Ay#,Az#,Bx#,By#,Bz#,Cx#,Cy#,Cz#)
SubVector Bx#,By#,Bz#,Ax#,Ay#,Az#
ux#=VectorX()
uy#=VectorY()
uz#=VectorZ()
SubVector Cx#,Cy#,Cz#,Bx#,By#,Bz#
vx#=VectorX()
vy#=VectorY()
vz#=VectorZ()
CrossProduct vx#,vy#,vz#,ux#,uy#,uz#
;Normalize vectorx,vectory,vectorz
Return Ax#*vectorx+Ay#*vectory+Az#*vectorz
End Function

Function VectorX#()
Return vectorx
End Function

Function VectorY#()
Return vectory
End Function

Function VectorZ#()
Return vectorz
End Function

Function VectorW#()
Return vectorw
End Function

Function SubVector(Ax#,Ay#,Az#,Bx#,By#,Bz#)
vectorx#=ax#-bx#
vectory#=ay#-by#
vectorz#=az#-bz#
End Function

Function Normalize(nx#,ny#,nz#)
If nx=0 And ny=0 And nz=0 Return
m#=Magnitude(nx#,ny#,nz#)
vectorx#=nx#/m#
vectory#=ny#/m#
vectorz#=nz#/m#
End Function

Function CrossProduct(Ax#,Ay#,Az#,Bx#,By#,Bz#)
vectorx#=Ay#*Bz#-Az#*By#
vectory#=Az#*Bx#-Ax#*Bz#
vectorz#=Ax#*By#-Ay#*Bx#
End Function


Function Magnitude(nx#,ny#,nz#) 
m#= Sqr( (nx*nx) + (ny*ny) + (nz*nz) ) 
Return m# 
End Function



Function AngleBetweenTriangles#(v1x#,v1y#,v1z#,v2x#,v2y#,v2z#,v3x#,v3y#,v3z#,v4x#,v4y#,v4z#)

ax#=v1x-v2x
ay#=v1y-v2y
az#=v1z-v2z
bx#=v1x-v3x
by#=v1y-v3y
bz#=v1z-v3z
CrossProduct(ax,ay,az,bx,by,bz)
t1vx#=vectorx/3
t1vy#=vectory/3
t1vz#=vectorz/3

ax#=v4x-v3x
ay#=v4y-v3y
az#=v4z-v3z
bx#=v4x-v2x
by#=v4y-v2y
bz#=v4z-v2z
CrossProduct(ax,ay,az,bx,by,bz)
t2vx#=vectorx/3
t2vy#=vectory/3
t2vz#=vectorz/3



px# = t1vx
py# = t1vy
pz# = t1vz
qx# = t2vx
qy# = t2vy
qz# = t2vz

MagP# = Sqr( px * px + py * py + pz * pz )
MagQ# = Sqr( qx * qx + qy * qy + qz * qz )


Theta1# =ACos ( ( px*qx + py*qy + pz*qz ) / ( MagP * MagQ ) )


;move refference point by 1000th of cross product and check the change ---- &lt;&lt;&lt; solution
t2mx# = t2vx / 1000.0
t2my# = t2vy / 1000.0
t2mz# = t2vz / 1000.0
v4bx# = v4x + t2mx
v4by# = v4y + t2my
v4bz# = v4z + t2mz
ax#=v4bx-v3x
ay#=v4by-v3y
az#=v4bz-v3z
bx#=v4bx-v2x
by#=v4by-v2y
bz#=v4bz-v2z
CrossProduct(ax,ay,az,bx,by,bz)
t2bvx#=vectorx/3
t2bvy#=vectory/3
t2bvz#=vectorz/3

qx# = t2bvx
qy# = t2bvy
qz# = t2bvz

MagP# = Sqr( px * px + py * py + pz * pz )
MagQ# = Sqr( qx * qx + qy * qy + qz * qz )


Theta2# = ACos ( ( px*qx + py*qy + pz*qz ) / ( MagP * MagQ ) )

If Theta2 &lt; Theta1 Then
	actualangle# = Theta1 + 180
Else
	actualangle# = 180 - Theta1
End If

Return actualangle#


End Function 
</textarea> <br><br></td></tr></table><br>
<a name="632053"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I'm not sure this is useful enough to post it in the code archives <br></div>If it's not already in there, it's certainly worth adding. ;) <br><br></td></tr></table><br>
<a name="632320"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I would have spent much more time if it wasn't for you Stevie G, so thanks again.<br> <br></div><br><br>No problem,  anything to speed up a demo of your shadow thing :)<br><br>p.s. If you're only using normals then no reason to calculate the vector magnitude ... will always be 1? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
