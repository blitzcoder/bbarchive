<!DOCTYPE html><html lang="en" ><head ><title >Triangle Placing to match grid</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Triangle Placing to match grid</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Triangle Placing to match grid</a><br><br>
<a name="1322514"></a>

<a name="1322566"></a>

<a name="1322567"></a>

<a name="1322576"></a>

<a name="1322577"></a>

<a name="1322579"></a>

<a name="1322580"></a>

<a name="1322588"></a>

<a name="1322603"></a>

<a name="1322606"></a>

<a name="1322607"></a>

<a name="1322610"></a>

<a name="1322611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> In attempt to save surfaces and triangles, rather than use a number of cube primitives, I wanted to construct geometry by code to form a single-surface mesh, eradicating overlaps and invisible triangles.<br><br>Generally it seems as though the core concept is working, but there's some issues with the fidelity of placement:<br><br>I would really apprecaite any help orsuggestions on the matter.<br><br>The following code provides an executable overview of the idea and highlights the problem;<br><br><pre class=code>;;Identifies efficient single-surface triangleplacement for square-grid based maps.

;For this example purpose, an ARRAY data type is used, it may be more suitable to utilise banks or other data structures in actual usage.

Graphics3D 1024,768,32,2
SetBuffer BackBuffer()

Global SUN=CreateLight()

Const WLS_TOP_BOUND=1
Const WLS_BOTTOM_BOUND=2
Const WLS_LEFT_BOUND=4
Const WLS_RIGHT_BOUND=8

Const WLS_ROOF_H=16
Const WLS_ROOF_V=32

Dim ARRAY(0,0)
Dim TempArray(0,0)

Type ROOFED
	Field X
	Field Y
End Type

SeedRnd MilliSecs()

Local W=100
Local H=100
;Example Populate Random Grid map (0 = blank, 1 = Wall)
PopulateRandomMap(W,H)
WaitKey()
;Now To call the Function And generate single-surface geometry
Local MESH=CreateMesh()
Local SURF=CreateSurface(MESH)
Walls(W,H,SURF)
;EntityFX MESH,16
EntityAlpha MESH,0.5
UpdateNormals MESH

DISPLAY3DOUTPUT(MESH,W,H)

Function Walls(W,H,Surface,AddTop=True)
	W=W-1
	H=H-1
	
	Local X
	Local Y
	
	Dim TempArray(W,H)
	
	Local Bounds
	
	;First Pass : Identify each grid unit boundaries. This can remove any hidden or adjoining wall faces
	For Y=0 To H
		For X=0 To W
			Bounds=0
			
			If (ARRAY(X,Y)=1)
				Bounds=Bounds+GetTopBound(X,Y)
				Bounds=Bounds+GetBottomBound(X,Y,H)
				Bounds=Bounds+GetLeftBound(X,Y)
				Bounds=Bounds+GetRightBound(X,Y,W)
				
				TempArray(X,Y)=Bounds
			End If
			
		Next
	Next
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	;HORIZONTAL Pass : CHECK FOR CONTINUOUS HORIZONTAL WALL SEGMENTS - EACH WALL HAS A TOP (Z+1) AND BOTTOM (Z+0) FACE ALIGNED WITH X AXIS
	
	Local LengthTop
	Local LengthBottom
	Local CountingTop
	Local CountingBottom
	
	For Y=0 To H
		For X=0 To W
			
			If (TempArray(X,Y) And WLS_TOP_BOUND)
				LengthTop=LengthTop+1
				CountingTop=True
			Else
				If (CountingTop)
					AddZ_PLUSGeometry(X-LengthTop,H-Y,LengthTop,Surface)
					
					LengthTop=0
					CountingTop=False	
				End If
			End If
			
			
			If (TempArray(X,Y) And WLS_BOTTOM_BOUND)
				LengthBottom=LengthBottom+1
				CountingBottom=True
			Else
				If (CountingBottom)
					AddZ_MINUSGeometry(X-LengthBottom,H-Y,LengthBottom,Surface)
					
					LengthBottom=0
					CountingBottom=False	
				End If
			End If
			
			
			
			
		Next
		
		;Break at end of row
		If (CountingTop)
			AddZ_PLUSGeometry(X-LengthTop,H-Y,LengthTop-1,Surface)
			
			LengthTop=0
			CountingTop=False	
		End If
		
		If (CountingBottom)
			AddZ_MINUSGeometry(X-LengthBottom,H-Y,LengthBottom-1,Surface)
			
			LengthBottom=0
			CountingBottom=False	
		End If
		
	Next
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		;VERTICAL Pass: CHECK FOR CONTINUOUS VERTICAL WALL SEGMENTS - EACH WALL HAS A RIGHT (X+1) AND LEFT (X+0) FACE ALIGNED WITH Z AXIS
	Local LengthLeft
	Local LengthRight
	Local CountingLeft
	Local CountingRight
	
	For X=0 To W
		For Y=0 To H
			
			If (TempArray(X,Y) And WLS_LEFT_BOUND)
				LengthLeft=LengthLeft+1
				CountingLeft=True
			Else
				If (CountingLeft)
					AddX_MINUSGeometry(X,H-(Y-LengthLeft),LengthLeft,Surface)
					
					LengthLeft=0
					CountingLeft=False	
				End If
			End If
			
			
			If (TempArray(X,Y) And WLS_RIGHT_BOUND)
				LengthRight=LengthRight+1
				CountingRight=True
			Else
				If (CountingRight)
					AddX_PLUSGeometry(X,H-(Y-LengthRight),LengthRight,Surface)
					
					LengthRight=0
					CountingRight=False	
				End If
			End If
			
			
			
			
		Next
		
		;Break at end of row
		If (CountingLeft)
			AddX_MINUSGeometry(X,H-(Y-LengthLeft),LengthLeft-1,Surface)
			
			LengthLeft=0
			CountingLeft=False
		End If
		
		If (CountingRight)
			AddZ_PLUSGeometry(X,H-(Y-LengthRight),LengthRight-1,Surface)
			
			LengthRight=0
			CountingRight=False	
		End If
		
		
	Next
	
	
	
	
	If (AddTop)
		;Adds a "roof" plane geometry to the walls
		
		;[Block]
	;PLANAR PASS HORIZONTAL 1 : Determines potential rows of wall segments
		
	Local CountingHorizontal
	Local HorizontalLength
	
	For Y=0 To H
		For X=0 To W
			
			If (TempArray(X,Y) And (WLS_TOP_BOUND Or WLS_BOTTOM_BOUND))
				CountingHorizontal=True
				HorizontalLength=HorizontalLength+1
			Else
				If (CountingHorizontal)
					ProcessPlanarHorizontal(X-HorizontalLength,Y,HorizontalLength)
					HorizontalLength=0
					CountingHorizontal=False	
				End If
			End If
		Next
		
		;Break at end of row
		If (CountingHorizontal)
			ProcessPlanarHorizontal(X-HorizontalLength,Y,HorizontalLength-1)
			
			HorizontalLength=0
			CountingHorizontal=False	
		End If
		
		
	Next
	
	;PLANAR PASS VERTICAL 1 : Determines potential columns of wall segments
	
	Local CountingVertical
	Local VerticalLength
	
	For X=0 To W
		For Y=0 To H
			
			If (TempArray(X,Y) And (WLS_LEFT_BOUND Or WLS_RIGHT_BOUND))
				CountingVertical=True
				VerticalLength=VerticalLength+1
			Else
				If (CountingVertical)
					ProcessPlanarVertical(X,Y-VerticalLength,VerticalLength)
					VerticalLength=0
					CountingVertical=False	
				End If
			End If
		Next
		
		;Break at end of row
		If (CountingVertical)
			ProcessPlanarVertical(X,Y-VerticalLength,VerticalLength-1)
			
			VerticalLength=0
			CountingVertical=False	
		End If
		
		
	Next
	
	
	;PLANAR PASS HORIZONTAL 2 : Appliess planar roofing geometry across horizontal wall segments
	
	
	For Y=0 To H
		For X=0 To W
			
			If (TempArray(X,Y) And (WLS_ROOF_H))
				CountingHorizontal=True
				HorizontalLength=HorizontalLength+1
			Else
				If (CountingHorizontal)
					AddPLANAR_XZ_X_Geometry(X-HorizontalLength,H-Y,HorizontalLength,Surface)
					HorizontalLength=0
					CountingHorizontal=False	
				End If
			End If
		Next
		
		;Break at end of row
		If (CountingHorizontal)
			AddPLANAR_XZ_X_Geometry(X-HorizontalLength,H-Y,HorizontalLength-1,Surface)
			
			HorizontalLength=0
			CountingHorizontal=False	
		End If
		
		
	Next
	
	;PLANAR PASS VERTICAL 2:  Appliess planar roofing geometry across horizontal wall segments
	
	
	For X=0 To W
		For Y=0 To H
			
			If (TempArray(X,Y) And (WLS_ROOF_V))
				CountingVertical=True
				VerticalLength=VerticalLength+1
			Else
				If (CountingVertical)
					AddPLANAR_XZ_Z_Geometry(X,H-(Y-VerticalLength),VerticalLength,Surface)
					VerticalLength=0
					CountingVertical=False	
				End If
			End If
		Next
		
		;Break at end of row
		If (CountingVertical)
			AddPLANAR_XZ_Z_Geometry(X,H-(Y-VerticalLength),VerticalLength-1,Surface)
			
			VerticalLength=0
			CountingVertical=False	
		End If
		
		
	Next
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	;[End Block]
End If

Dim TempArray(0,0)

End Function

Function ProcessPlanarHorizontal(X,Y,Length)
	Local X1=X
	Local X2=X+Length
	
	For X=X1 To X2
		TempArray(X,Y)=TempArray(X,Y) Or WLS_ROOF_H
	Next
End Function

Function ProcessPlanarVertical(X,Y,Length)
	Local Y1=Y
	Local Y2=Y+Length
	
	Local Skip
	
	For Y=Y1 To Y2
		Skip=False
		
		If (TempArray(X,Y) And WLS_ROOF_H)
			If (Length&gt;0) 
				TempArray(X,Y)= (TempArray(X,Y) Xor WLS_ROOF_H)
			Else
				Skip=True
			End If
		End If
		
		If (Not(Skip))
			TempArray(X,Y)=(TempArray(X,Y) Or WLS_ROOF_V)
		End If
	
	Next
End Function

Function GetTopBound(X,Y)
	Local Value
	If (Y&gt;0)
		Value=(ARRAY(X,Y-1)=0)
	End If
	If (Value&gt;1) DebugLog("GOtcha")
	Return Value * WLS_TOP_BOUND
End Function

Function GetBottomBound(X,Y,H)
	Local Value
	If (Y&lt;H)
		Value=(ARRAY(X,Y+1)=0)
	End If
	If (Value&gt;1) DebugLog("GOtcha")
	Return Value * WLS_BOTTOM_BOUND
End Function

Function GetLeftBound(X,Y)
	Local Value
	If (X&gt;0)
		Value=(ARRAY(X-1,Y)=0)
	End If
	If (Value&gt;1) DebugLog("GOtcha")
	Return Value * WLS_LEFT_BOUND
End Function

Function GetRightBound(X,Y,W)
	Local Value
	If (X&lt;W)
		Value=(ARRAY(X+1,Y)=0)
	End If
	If (Value&gt;1) DebugLog("GOtcha")
	Return Value * WLS_RIGHT_BOUND
End Function


















;GEOM

Function AddPLANAR_XZ_X_Geometry(X,Z,Length,Surface)
	AddXZPlaneVertexPoints(X,Z,Length-1,1,Surface)
	Local v=CountVertices(Surface)-4
	
	AddTriangle(Surface,v+0,v+1,v+2)
	AddTriangle(Surface,v+3,v+2,v+1)
End Function

Function AddPLANAR_XZ_Z_Geometry(X,Z,Length,Surface)
	AddXZPlaneVertexPoints(X,Z,1,Length-1,Surface)
	Local v=CountVertices(Surface)-4
	
	AddTriangle(Surface,v+0,v+1,v+2)
	AddTriangle(Surface,v+3,v+2,v+1)
End Function

Function AddX_MINUSGeometry(X,Z,Length,Surface)
	AddZAxisVertexPoints(X,Z,Length,Surface)
	Local v=CountVertices(Surface)-4
	
	AddTriangle(Surface,v+1,v+2,v+3)
	AddTriangle(Surface,v+2,v+1,v+0)
End Function

Function AddX_PLUSGeometry(X,Z,Length,Surface)
	AddZAxisVertexPoints(X+1,Z,Length,Surface)
	Local v=CountVertices(Surface)-4
	
	AddTriangle(Surface,v+0,v+1,v+2)
	AddTriangle(Surface,v+3,v+2,v+1)
End Function

Function AddZ_PLUSGeometry(X,Z,Length,Surface)
	AddXAxisVertexPoints(X,Z,Length,Surface)
	Local v=CountVertices(Surface)-4
	
	AddTriangle(Surface,v+1,v+2,v+3)
	AddTriangle(Surface,v+2,v+1,v+0)
End Function

Function AddZ_MINUSGeometry(X,Z,Length,Surface)
	AddXAxisVertexPoints(X+Length,Z-1,0-Length,Surface)
	Local v=CountVertices(Surface)-4
	
	AddTriangle(Surface,v+1,v+2,v+3)
	AddTriangle(Surface,v+2,v+1,v+0)
End Function

Function AddXAxisVertexPoints(X#,Z#,Length,Surface)
	Local X1#=X#
	Local X2#=X#+Length
	
	AddVertex(Surface,X1#,1,Z#,1,0)
	AddVertex(Surface,X2#,1,Z#,0,0)
	AddVertex(Surface,X1#,0,Z#,1,1)
	AddVertex(Surface,X2#,0,Z#,0,1)
End Function

Function AddZAxisVertexPoints(X#,Z#,Length,Surface)
	Local Z1#=Z#-Length
	Local Z2#=Z#
	
	AddVertex(Surface,X#,1,Z1#,1,0)
	AddVertex(Surface,X#,1,Z2#,0,0)
	AddVertex(Surface,X#,0,Z1#,1,1)
	AddVertex(Surface,X#,0,Z2#,0,1)	
End Function

Function AddXZPlaneVertexPoints(X#,Z#,LengthX,LengthZ,Surface)
	Local X1#=X#
	Local X2#=X#+LengthX
	
	Local Z1#=Z#-LengthZ
	Local Z2#=Z#
	
	AddVertex(Surface,X1#,1,Z2#,1,0)
	AddVertex(Surface,X2#,1,Z2#,0,0)
	AddVertex(Surface,X1#,1,Z1#,1,1)
	AddVertex(Surface,X2#,1,Z1#,0,1)	
End Function

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;the following is for example purposes only


Function PopulateRandomMap(W,H)
	;VISUAL OUTPUT
	
	Dim ARRAY(W-1,H-1)
	
	Local Iter
	
	Local Length
	Local X,Y
	
	Local Dir
	
	Local RandX,RandY
	For Iter=1 To 100
		
		Length=Rand(1,Sqr(H))
		Dir=Rand(0,1)
		
		Select (Dir)
			Case 1:
			;VERTICAL
				X=Rand(0,W-1)
				RandY=Rand(0,H-Length)
				
				For Y=RandY To (RandY+Length)-1
					ARRAY(X,Y)=1
				Next
				
			Default:
			;HORIZONTAL
				RandX=Rand(0,W-Length)
				Y=Rand(0,H-1)
				
				For X=RandX To (RandX+Length)-1
					ARRAY(X,Y)=1
				Next
		End Select
		
	Next
	
	DRAWARRAYGRID(W-1,H-1)
	UPDATEVISUALDISPLAY
End Function

;The following is just for a visual depiction of the example and are not required for use of the system

Function DRAWARRAYGRID(W,H)
	Local X
	Local Y
	
	For Y= 0 To H
		For X=0 To W
			Color 0,255*ARRAY(X,Y),255
			Rect X*10,Y*5,10,5,ARRAY(X,Y)
		Next
	Next
End Function

Function DISPLAY3DOUTPUT(Mesh,W,H)
	AmbientLight 128,128,128
	Local Cam=CreateCamera()
	MoveEntity Cam,MeshWidth(Mesh)*0.5,MeshDepth(Mesh)*0.5,0-(MeshWidth(Mesh)*0.75)
	RotateEntity Mesh,-90,0,0,True
	
	Local Wire%				=	False;
	FlushMouse();
	
	Local Prim=True
	
	Local PIV=CreatePivot()
	
	For x=0 To W-1
		For y=0 To H-1
			If ARRAY(x,y)
				c=CreateCube(PIV)
				PositionEntity c,x+0.5,((H-1)-y)-0.5,0,True
				ScaleMesh c,0.45,0.45,0.45
				EntityAlpha c,0.5
				EntityColor c,128,0,0
			End If
		Next
	Next
	
	While Not KeyDown(1)
		Cls
		
		If (KeyHit(57)&gt;0)
			Wire			=	Not(Wire);
			WireFrame			( Wire );
		EndIf;
		
		If KeyHit(28)	
			Prim=Not(Prim)
			If Prim
				ShowEntity PIV
			Else
				HideEntity PIV
			End If
		End If	
		
		TranslateEntity Cam,Float(KeyDown(205)-KeyDown(203))*.1, Float(KeyDown(200)-KeyDown(208))*.1,MouseZSpeed(),1
		
		UpdateWorld
		RenderWorld
		
		
		Color				( 255,128,000 );
		Text				( 10,20,"Arrow -&gt; move" );
		Text				( 10,80,"space -&gt; wireframe" );
		Text				( 10,100,"Enter -&gt; primitives" );
		Text				0,0,TrisRendered()
		
		UPDATEVISUALDISPLAY
	Wend
	
End Function

Function UPDATEVISUALDISPLAY()
	Flip
End Function</pre> <br><br></td></tr></table><br>
<a name="1322548"></a>

<a name="1322549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> why don't you add premade rectangle meshes (each corresponding to the side of a cube) to a surface ?<br>apart from that i would use a similar logic than the one you use (use a 2d array to store the properties of each tile and analyze if there is (or not) a tile at front, at back, at left, at right<br><br>here is the function i use to add one surface to another surface : <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=3291" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=3291</a> <br><br></td></tr></table><br>
<a name="1322556"></a>

<a name="1322586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> The intent is to use the least possible triangles where possible.<br><br>This means, that when a wall segment extends along, say, 5 units, I do not need 10 triangles but just two per each side.<br><br>For example:<br><br>Using indivdual cubes:<br>A wall segment of 3 units comprises a total of 36 triangles:<br>._..._..._.<br>|_|.|_|.|_|<br><br><br>Current method:<br>A wall segment of 3 units comprises just 12 triangles<br>._________.<br>|_________|<br><br>________________________________________________________________________<br>This is detracting form the point of the discussion which is to ask for help in the position of the geometry.<br><br>I suspect, ultimately, it ought to be a minor tweak to the values of Add**Geometry() functions, since otherwise, it seems to be creating the triangles with correct facing etc. <br><br></td></tr></table><br>
<a name="1322557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>The intent is to use the least possible triangles where possible.<br>This means, that when a wall segment extends along, say, 5 units, I do not need 10 triangles but just two per each side.<br> <br></div><br>ok<br><br>but you will encounter a problem (overlapping triangles) when you have tiles arranged in this way :<br>00100<br>11111<br>00100 <br><br></td></tr></table><br>
<a name="1322558"></a>

<a name="1322559"></a>

<a name="1322560"></a>

<a name="1322561"></a>

<a name="1322562"></a>

<a name="1322563"></a>

<a name="1322564"></a>

<a name="1322581"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="1322565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes i took a look at your code, but i am not really in the mood to debug today. sorry<br><br>good luck <br><br></td></tr></table><br>
<a name="1322568"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> i just remembered this code by sswift, maybe it can help : <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=526" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=526</a> <br><br></td></tr></table><br>
<a name="1322569"></a>

<a name="1322582"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am convinced the issue lies within the Add*Geometry() functions or the values passed to them. This should help in narrowing down the root of the issue.<br><br>Thanks for taking the time to look at this, and I do very much appreciate your help and hope that you are feeling better :) <br><br></td></tr></table><br>
<a name="1322570"></a>

<a name="1322571"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> one question :<br>Do you want the walls to care about corners ?<br><pre class=code>
123456
 X
</pre><br>numbers are just to identify the cells, the X is the block a the next line<br>obviously, you can create a wall along the top of the cells from 1 to 6<br>But what do you expect for the bottom wall ?<br>Does it go grom 1 to 6 ? or do you split it in 2 walls (bottom of 1, and bottom of 3 to 6)<br><br><br>Then, just a thing :<br>&gt; in the function DISPLAY3DOUTPUT<br><pre class=code>
If ARRAY(x,y)
	c=CreateCube(PIV)
	PositionEntity c,x,y,0,True
	ScaleMesh c,0.9,0.9,0.9
	EntityAlpha c,0.5
	EntityColor c,128,0,0
</pre><br><br>If you set the position of your cubes every one unit, then your scalemesh is too large -&gt; a cube goes from -1 to 1, so scale to 0.45 if you want it do be a bit lower than one unit. <br><br></td></tr></table><br>
<a name="1322572"></a>

<a name="1322583"></a>

<a name="1322587"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>But what do you expect for the bottom wall ?<br>Does it go grom 1 to 6 ? or do you split it in 2 walls (bottom of 1, and bottom of 3 to 6)<br> <br></div><br>As you will see if you run the example code, the walls do as I want in this regard.<br><br>The top wall would run from 1 to 6<br>the bottom wall will be split into two:<br><br>one segment at 1 (1 unit length)<br>another from 3 to 6 (4 unit length) <br><br></td></tr></table><br>
<a name="1322573"></a>

<a name="1322574"></a>

<a name="1322575"></a>

<a name="1322584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>If you set the position of your cubes every one unit, then your scalemesh is too large -&gt; a cube goes from -1 to 1, so scale to 0.45 if you want it do be a bit lower than one unit. <br> <br></div><br>I forgot this.<br><br>Thank you. <br><br></td></tr></table><br>
<a name="1322578"></a>

<a name="1322585"></a>

<a name="1322590"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Updated the initial code again.<br><br>1) The RED Primitive cubes used as template are now scaled accordingly.<br>2) Horizontal and Vertical Wall sections are now mostly accurate.<br>3) Errors at the extremeties of the map are likely to be non-critical<br>4) Errors as result of parrallel wall segments placed adjacently will not be an issue.<br>5) The PLANAR "roof" seems to fail, I suspect due to situations whereby the n -&gt; n+Length should be n-length to n and the ordering of vertices for triangle addition needs to be amended<br><br>This is what needs to be looked at, and I am not proficient in 3D triangles and vertices to solve it. <br><br></td></tr></table><br>
<a name="1322589"></a>

<a name="1322596"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> here is what I got so far.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Const WLS_TOP_BOUND%	=	1
Const WLS_BOTTOM_BOUND%	=	2
Const WLS_LEFT_BOUND%	=	4
Const WLS_RIGHT_BOUND%	=	8

Const WLS_TOP_LAYER_H%	=	16
Const WLS_TOP_LAYER_V%	=	32


Dim ARRAY%(0,0)
Dim HAS_WALL%(0,0)
Dim WALL_FLAG%(0,0)


Function PopulateRandomMap(W,H)
	Dim ARRAY%(W,H)
	Dim HAS_WALL%(W,H)
	
	W = W-1 : H = H-1
	
	Local Iter%, Length%, X%, Y%, Dir%
	Local RandX%,RandY%
	
	For Iter=1 To 100
		
		Length=Rand(1,Sqr(H+1))
		Dir=Rand(0,1)
		
		Select (Dir)
			Case 1:
			;VERTICAL
				X=Rand(0,W)
				RandY=Rand(0,H-Length+1)
				For Y=RandY To (RandY+Length)-1
					ARRAY(X,Y)=1
				Next
				
			Default:
			;HORIZONTAL
				RandX=Rand(0,W-Length+1)
				Y=Rand(0,H)
				For X=RandX To (RandX+Length)-1
					ARRAY(X,Y)=1
				Next
		End Select
	Next
	
	; tag walls
	Local WallFlag%
	For Y=0 To H
		For X=0 To W
			WallFlag=0;
			If (ARRAY(X,Y)=1)
				If (Y&gt;0)	Then If ARRAY(X,Y-1)=0 Then WallFlag = WallFlag + 1;
				If (Y&lt;H)	Then If ARRAY(X,Y+1)=0 Then WallFlag = WallFlag + 2;
				If (X&gt;0)	Then If ARRAY(X-1,Y)=0 Then WallFlag = WallFlag + 4;
				If (X&lt;W)	Then If ARRAY(X+1,Y)=0 Then WallFlag = WallFlag + 8;
				HAS_WALL(X,Y)=WallFlag;
			EndIf;
		Next;
	Next;
End Function

Function DRAWARRAYGRID(W,H)
	W = W - 1 : H = H - 1
	
	; size of cells
	Local S% = 7
	
	Local X%, Y%, I%, J%
	
	Origin 10,10
	Color 120,120,120 : Rect -10,-10, (W+1)*S + 20, (H+1)*S+20, 1
	Color 010,015,010 : Rect 0,0, (W+1)*S, (H+1)*S, 1
	
	For Y= 0 To H
		For X=0 To W
			; cell 2D coordinates
			J = Y*S : I = X*S
			
			; if array is a block -&gt; show it
			If ARRAY(X,Y)
				Color 100,150,200
				Rect I,J,S,S, 1
			Else
				; empty block
				Color 040,050,040
				Rect I+1,J+1,S-2,S-2, 1
			EndIf
			
			; draw walls
			If HAS_WALL(X,Y)&gt;0
				Color 000,255,255
				; top wall
				If (HAS_WALL(X,Y) And 1) Then Rect I,J,S,2
				; bottom wall
				If (HAS_WALL(X,Y) And 2) Then Rect I,J+S-2,S,2
				; left wall
				If (HAS_WALL(X,Y) And 4) Then Rect I,J,2,S
				; right wall
				If (HAS_WALL(X,Y) And 8) Then Rect I+S-2,J,2,S
			EndIf
		Next
	Next
	
	Origin 0,0
End Function

Function BuildWalls(surf,W,H)
	Dim WALL_FLAG%(W,H);
	W=W-1 : H=H-1;
	Local i%,j%, x%,y%, x0%,y0%,x1%,y1%;
	
	For j = 0 To H
		For i = 0 To W
			; this cell has a top wall
			If ((HAS_WALL(i,j) And 1)&gt;0)
				; if this wall hasn't already been built
				If ((WALL_FLAG(i,j) And 1) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					; find last cell that has this wall
					For x = x0 To W
						If ((HAS_WALL(x,j) And 1)=0) Then Exit;
						WALL_FLAG(x,j) = WALL_FLAG(x,j) Or 1 : x1=x;
					Next;
					
					; build the wall.
					v = AddVertex	(surf, x0  , 0,y0);
						AddVertex	(surf, x1+1, 0,y0);
						AddVertex	(surf, x1+1, 1,y0);
						AddVertex	(surf, x0  , 1,y0);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf;
			EndIf;
			; this cell has a bottom wall
			If ((HAS_WALL(i,j) And 2)&gt;0)
				If ((WALL_FLAG(i,j) And 2) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					For x = x0 To W
						If ((HAS_WALL(x,j) And 2)=0) Then Exit;
						WALL_FLAG(x,j) = WALL_FLAG(x,j) Or 2 : x1=x;
					Next;
					v = AddVertex	(surf, x1+1, 0,y0+1);
						AddVertex	(surf, x0  , 0,y0+1);
						AddVertex	(surf, x0  , 1,y0+1);
						AddVertex	(surf, x1+1, 1,y0+1);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf;
			EndIf;
			; this cell has a left wall
			If ((HAS_WALL(i,j) And 4)&gt;0)
				If ((WALL_FLAG(i,j) And 4) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					For y = y0 To H
						If ((HAS_WALL(i,y) And 4)=0) Then Exit;
						WALL_FLAG(i,y) = WALL_FLAG(i,y) Or 4 : y1=y;
					Next;
					v = AddVertex	(surf, x0, 0,y1+1);
						AddVertex	(surf, x0, 0,y0  );
						AddVertex	(surf, x0, 1,y0  );
						AddVertex	(surf, x0, 1,y1+1);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf;
			EndIf;
			; this cell has a right wall
			If ((HAS_WALL(i,j) And 8)&gt;0)
				If ((WALL_FLAG(i,j) And 8) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					For y = y0 To H
						If ((HAS_WALL(i,y) And 8)=0) Then Exit;
						WALL_FLAG(i,y) = WALL_FLAG(i,y) Or 8 : y1=y;
					Next
					v = AddVertex	(surf, x0+1, 0,y0  );
						AddVertex	(surf, x0+1, 0,y1+1);
						AddVertex	(surf, x0+1, 1,y1+1);
						AddVertex	(surf, x0+1, 1,y0  );
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf
			EndIf
		Next
	Next
	Dim Wall_Flag(0,0)
End Function


Graphics3D 1024,768,0,2
SetBuffer BackBuffer()

SeedRnd MilliSecs()

Local W = 100
Local H = 100

; -------------------------------------------------------------
; Random Map
; -------------------------------------------------------------
	PopulateRandomMap(W,H)

; -------------------------------------------------------------
; build Mesh
; -------------------------------------------------------------
	Local Mesh=CreateMesh()
	Local Surf=CreateSurface(Mesh)
	BuildWalls(Surf, W,H)
	UpdateNormals Mesh
	
; -------------------------------------------------------------
; debug 2d grid
; -------------------------------------------------------------
	DRAWARRAYGRID(W-1,H-1)
	Flip True
	WaitKey()

; -------------------------------------------------------------
; Show in 3D
; -------------------------------------------------------------

	AmbientLight 128,128,128
	
	Local Sun				=	CreateLight		( );
	
	Local piv				=	CreatePivot		( )
	Local pit				=	CreatePivot		( piv );
	Local Cam				=	CreateCamera	( pit );
								PositionEntity	( piv, W/2,0,H/2 );
								TurnEntity		( pit, 45,0,0 );
								MoveEntity		( Cam, 0, 0, -W/2 );
					
	Local mdl				=	CreateCube		( )
								FitMesh			( mdl, .01,.01,.01,.98,.98,.98 )
								FlipMesh		( mdl )
								EntityAlpha		( mdl, 0.25 )
								EntityColor		( mdl, 128,000,000 )
								HideEntity		( mdl )
	
	Local root				=	CreatePivot		( )
	For x=0 To W-1
		For y=0 To H-1
			If ARRAY(x,y)
				PositionEntity	( CopyEntity(mdl,root), x,0,y, True );
			EndIf;
		Next;
	Next;
	
	Local Wire%				=	False;
	FlushMouse();
	
	While ( Not(KeyDown(1)) )
		If (Keyhit(57)&gt;0)
			Wire			=	Not(Wire);
			WireFrame			( Wire );
		EndIf;
		
		Local msx#			=	MouseXSpeed();
		Local msy#			=	MouseYSpeed();
		
		If (MouseDown(2)&gt;0)
			TurnEntity			( piv, 0,-msx,0 );
			TurnEntity			( pit, +msy,0,0 );
		EndIf;
		MoveEntity				( piv, Float(KeyDown(205)-KeyDown(203))*.1, 0, Float(KeyDown(200)-KeyDown(208))*.1 );
		PositionEntity			( cam, 0,0,EntityZ(cam,0)*(1-0.05*Float(MouseZSpeed())) );
		RenderWorld				( );
			
			Color				( 255,128,000 );
			Text				( 10,10,"Arrow -&gt; move" );
			Text				( 10,25,"right mouse -&gt; turn" );
			Text				( 10,40,"mouse wheel -&gt; zoom" );
			Text				( 10,55,"space -&gt; wireframe" );
		Flip					( True );
	Wend
End
</textarea> <br><br></td></tr></table><br>
<a name="1322591"></a>

<a name="1322592"></a>

<a name="1322593"></a>

<a name="1322594"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think you misinterpreted the problem I have with the code. Your code sample does not solve these problems.<br>The problem is with the accuracy of the placement of the triangles.<br><br>__________<br><br>Your code sample has numerous issues of its own:<br><br>1) No roof for the walls - THE PROBLEM I HAVE IS WITH THE ROOF PLACEMENT _ SO HOW DOES IT HELP???<br>2) Wall faces are rotated through Pi * radians. <br><br></td></tr></table><br>
<a name="1322595"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>1) Hidden geometries within wall segments<br>i.e. <br>.___.<br>|_|_|<br><br>In your code the dividing wall is still present and unnecessary.<br> <br></div><br><br>Here, the walls are split everytime it's required.<br>Because, I just don't understand what you're talking about, could you make a screen of what you're trying to explain (and point at the problem you're issuing if possible) ?<br><br><br><div class="quote"> <br>2) No roof for the walls<br> <br></div><br>Yep, I never go further until the first step is validated, I prefer having a robust base to work on :)<br>(So I didn't implement the roof/floors yet ... and it seems I was right, I don't know where we are going)<br><br><br><div class="quote"> <br>3) Wall faces are rotated through Pi * radians. <br> <br></div><br>Same as previous, I don't understand what you're meaning, sorry. <br><br></td></tr></table><br>
<a name="1322597"></a>

<a name="1322598"></a>

<a name="1322599"></a>

<a name="1322600"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so you edited your post ... I suppose there is no problem with the walls then.<br><br><div class="quote"> <br>THE PROBLEM I HAVE IS WITH THE ROOF PLACEMENT _ SO HOW DOES IT HELP???<br> <br></div><br>I think it's time for a break if you start yelling at me for nothing ^^.<br>So, help yourself, I'm not here to support this kind of behavior. <br><br></td></tr></table><br>
<a name="1322601"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Here, the walls are split everytime it's required<br> <br></div>Sorry I was wrong. You are right and the walls are divided correctly! :)<br><br><div class="quote"> <br>Yep, I never go further until the first step is validated, I prefer having a robust base to work on :)<br>(So I didn't implement the roof/floors yet ... and it seems I was right, I don't know where we are going <br></div><br>Roofs are where I am having the most problem, if you see the most recently updated version of my code (amended in first post).<br>Floors arent necessary* but are simply refection of the roof anyway so easy enough to add once roofs are working.<br><br><div class="quote"> <br>Same as previous, I don't understand what you're meaning, sorry.  <br></div><br>Now that I have looked more carefully I think I understand.<br>You have created "Rooms" and "Corridoors" - the faces of the cuboids face inwards - whereas I was intending on an external 'maze' where the walls are 'solid'.<br><br>In your case the walls are visible from INSIDE, yet mine need to be visible from OUTSIDE only.*<br><br>A simple FlipMesh resolved this difference.<br><br>*Hopefully this distinction between inside and outside clarifies a little why the roof is important but floors arent :) <br><br></td></tr></table><br>
<a name="1322602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wasn't intending to "yell" - the caps were to highlight the importance of the roofs. Sorry. <br><br></td></tr></table><br>
<a name="1322604"></a>

<a name="1322605"></a>

<a name="1322608"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok no problem so.<br>If the walls have to be fliped, then the roof will be really complex and need a flood fill algorithm to detect the outline and exlude inner parts.<br><br>So it needs to be devided into the largest convex polygons (or at least into convex polygons ... checking the best computation case could be a total brainacke)<br><br>So, it needs to start from the first "used" cell then find the next point which create the segment (always is the same orientation), anytime you have at least 3 points, you need to check if there is any empty cell in the polygon (else, the polygon is not valid) and compute again and again until all polygons are done<br><br>In other words, it's an ear-clipping algorithm.<br><br><div class="quote"> <br>*Hopefully this distinction between inside and outside clarifies a little why the roof is important but floors arent :) <br> <br></div><br>Actually, it probably does not change anything to the algorithm, but it certainly modify all the result. (I was thinking about an "inside" maze, which would absolutely not look like what you were doing) <br><br></td></tr></table><br>
<a name="1322609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've jsut updated the initial code again.<br><br><div class="quote"> <br><br>So it needs to be devided into the largest convex polygons (or at least into convex polygons ... checking the best computation case could be a total brainacke)<br><br>So, it needs to start from the first "used" cell then find the next point which create the segment (always is the same orientation), anytime you have at least 3 points, you need to check if there is any empty cell in the polygon (else, the polygon is not valid) and compute again and again until all polygons are done<br><br>In other words, it's an ear-clipping algorithm.<br> <br></div><br><br>Well considering there will (in the actual implementation of this system), not be any cases other than single-unit-thick walls - remember t's an external maze, not internal corridors -, then any area considerations should be restricted to the same as the side walls...<br><br>So my code simply checks along the horizontal walls and flags them for a roof, then the same for the vertical - with the caveat that if already earmarked, that section will be skipped over.<br><br>Then, final passes process the data for roof in the same way as the wall creation - extending the geometry to stretch from the start of a section along its length (whether in H or V direction)<br><br>This code is encapsulated between the ;[Block] and ;[End Block] lines (I use IDEal)<br><br>However, there s something faulty in that regions seem to be arbitrarily skipped and this is what I cannot understand. <br><br></td></tr></table><br>
<a name="1322612"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yet another small update to the initial code.<br><br><br>It is so VERY CLOSE now to completion.<br><br>The error with the roof isnow confined to SPECIFIC CASES Where:<br><br><br>Horizontal Wall segments (i.e extending along X axis with only "TOP"(z+1) and BOTTOM(Z-1) faces)<br><br>Length &gt; 2 units<br><br>The segment at Length-1 from the horizontal start of the segment is skipped-<br><br>I am unsure whether to simply "kludge" a specific fix for this, or continue to try and investigate the root of the issue. <br><br></td></tr></table><br>
<a name="1322613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ignore the above. Whilst that scenario described in the post above ALWAYS produces the error, it is not the only circumstance that does so... <br><br></td></tr></table><br>
<a name="1322614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> If there are no "lines" wider than one cell, then it makes things way more simple.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Const WLS_TOP_BOUND%	=	1
Const WLS_BOTTOM_BOUND%	=	2
Const WLS_LEFT_BOUND%	=	4
Const WLS_RIGHT_BOUND%	=	8

Const WLS_TOP_LAYER_H%	=	16
Const WLS_TOP_LAYER_V%	=	32


Dim ARRAY%(0,0)
Dim HAS_WALL%(0,0)
Dim WALL_FLAG%(0,0)


Function PopulateRandomMap(W,H)
	Dim ARRAY%(W,H)
	Dim HAS_WALL%(W,H)
	
	W = W-1 : H = H-1
	
	Local Iter%, Length%, X%, Y%, Dir%
	Local RandX%,RandY%
	
	For Iter=1 To 100
		
		Length=Rand(1,Sqr(H+1))
		Dir=Rand(0,1)
		
		Select (Dir)
			Case 1:
			;VERTICAL
				X=Rand(0,W)
				RandY=Rand(0,H-Length+1)
				For Y=RandY To (RandY+Length)-1
					ARRAY(X,Y)=1
				Next
				
			Default:
			;HORIZONTAL
				RandX=Rand(0,W-Length+1)
				Y=Rand(0,H)
				For X=RandX To (RandX+Length)-1
					ARRAY(X,Y)=1
				Next
		End Select
	Next
	
	; tag walls
	Local WallFlag%
	For Y=0 To H
		For X=0 To W
			WallFlag=0;
			If (ARRAY(X,Y)=1)
				If (Y&gt;0)	Then If ARRAY(X,Y-1)=0 Then WallFlag = WallFlag + 1;
				If (Y&lt;H)	Then If ARRAY(X,Y+1)=0 Then WallFlag = WallFlag + 2;
				If (X&gt;0)	Then If ARRAY(X-1,Y)=0 Then WallFlag = WallFlag + 4;
				If (X&lt;W)	Then If ARRAY(X+1,Y)=0 Then WallFlag = WallFlag + 8;
				HAS_WALL(X,Y)=WallFlag;
			EndIf;
		Next;
	Next;
End Function

Function DRAWARRAYGRID(W,H)
	W = W - 1 : H = H - 1
	
	; size of cells
	Local S% = 7
	
	Local X%, Y%, I%, J%
	
	Origin 10,10
	Color 120,120,120 : Rect -10,-10, (W+1)*S + 20, (H+1)*S+20, 1
	Color 010,015,010 : Rect 0,0, (W+1)*S, (H+1)*S, 1
	
	For Y= 0 To H
		For X=0 To W
			; cell 2D coordinates
			J = Y*S : I = X*S
			
			; if array is a block -&gt; show it
			If ARRAY(X,Y)
				Color 100,150,200
				Rect I,J,S,S, 1
			Else
				; empty block
				Color 040,050,040
				Rect I+1,J+1,S-2,S-2, 1
			EndIf
			
			; draw walls
			If (HAS_WALL(X,Y)&gt;0)
				Color 000,255,255
				; top wall
				If (HAS_WALL(X,Y) And 1) Then Rect I,J,S,2
				; bottom wall
				If (HAS_WALL(X,Y) And 2) Then Rect I,J+S-2,S,2
				; left wall
				If (HAS_WALL(X,Y) And 4) Then Rect I,J,2,S
				; right wall
				If (HAS_WALL(X,Y) And 8) Then Rect I+S-2,J,2,S
			EndIf
		Next
	Next
	
	Origin 0,0
End Function

Function BuildWalls(surf,FloorSurf, W,H)
	Dim WALL_FLAG%(W,H);
	W=W-1 : H=H-1;
	Local i%,j%, x%,y%, x0%,y0%,x1%,y1%;
	
	For j = 0 To H
		For i = 0 To W
			; this cell has a top wall
			If ((HAS_WALL(i,j) And 1)&gt;0) And ((HAS_WALL(i,j) And 1)&gt;0)
				; if this wall hasn't already been built
				If ((WALL_FLAG(i,j) And 1) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					; find last cell that has this wall
					For x = x0 To W
						If ((HAS_WALL(x,j) And 1)=0) Then Exit;
						WALL_FLAG(x,j) = WALL_FLAG(x,j) Or 1 : x1=x;
					Next;
					
					; build the wall.
					v = AddVertex	(surf, x0  , 1,y0) : VertexNormal(surf, v  ,  0, 0,-1);
						AddVertex	(surf, x1+1, 1,y0) : VertexNormal(surf, v+1,  0, 0,-1);
						AddVertex	(surf, x1+1, 0,y0) : VertexNormal(surf, v+2,  0, 0,-1);
						AddVertex	(surf, x0  , 0,y0) : VertexNormal(surf, v+3,  0, 0,-1);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf;
			EndIf;
			; this cell has a bottom wall
			If ((HAS_WALL(i,j) And 2)&gt;0)
				If ((WALL_FLAG(i,j) And 2) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					For x = x0 To W
						If ((HAS_WALL(x,j) And 2)=0) Then Exit;
						WALL_FLAG(x,j) = WALL_FLAG(x,j) Or 2 : x1=x;
					Next;
					v = AddVertex	(surf, x1+1, 1,y0+1) : VertexNormal(surf, v  ,  0, 0,+1);
						AddVertex	(surf, x0  , 1,y0+1) : VertexNormal(surf, v+1,  0, 0,+1);
						AddVertex	(surf, x0  , 0,y0+1) : VertexNormal(surf, v+2,  0, 0,+1);
						AddVertex	(surf, x1+1, 0,y0+1) : VertexNormal(surf, v+3,  0, 0,+1);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf;
			EndIf;
			; this cell has a left wall
			If ((HAS_WALL(i,j) And 4)&gt;0)
				If ((WALL_FLAG(i,j) And 4) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					For y = y0 To H
						If ((HAS_WALL(i,y) And 4)=0) Then Exit;
						WALL_FLAG(i,y) = WALL_FLAG(i,y) Or 4 : y1=y;
					Next;
					v = AddVertex	(surf, x0, 1,y1+1) : VertexNormal(surf, v  , -1, 0, 0);
						AddVertex	(surf, x0, 1,y0  ) : VertexNormal(surf, v+1, -1, 0, 0);
						AddVertex	(surf, x0, 0,y0  ) : VertexNormal(surf, v+2, -1, 0, 0);
						AddVertex	(surf, x0, 0,y1+1) : VertexNormal(surf, v+3, -1, 0, 0);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf;
			EndIf;
			; this cell has a right wall
			If ((HAS_WALL(i,j) And 8)&gt;0)
				If ((WALL_FLAG(i,j) And 8) = 0)
					x0 = i : x1 = i : y0 = j : y1 = j;
					For y = y0 To H
						If ((HAS_WALL(i,y) And 8)=0) Then Exit;
						WALL_FLAG(i,y) = WALL_FLAG(i,y) Or 8 : y1=y;
					Next
					v = AddVertex	(surf, x0+1, 1,y0  ) : VertexNormal(surf, v  , +1, 0, 0);
						AddVertex	(surf, x0+1, 1,y1+1) : VertexNormal(surf, v+1, +1, 0, 0);
						AddVertex	(surf, x0+1, 0,y1+1) : VertexNormal(surf, v+2, +1, 0, 0);
						AddVertex	(surf, x0+1, 0,y0  ) : VertexNormal(surf, v+3, +1, 0, 0);
						AddTriangle	(surf, v,v+1,v+2);
						AddTriangle	(surf, v,v+2,v+3);
				EndIf
			EndIf
		Next
	Next
	Dim WALL_FLAG(0,0)
	
	; build roofs
	Dim WALL_FLAG(W+1,H+1) ; reset wall flags and reuse for roofs
	For j = 0 To H
		For i = 0 To W
			If (ARRAY(i,j)&gt;0)
				If (WALL_FLAG(i,j)=0)
					Local lenghtH = 0;
					Local lengthV = 0;
					; check farthest available cell to the right
					x0 = i : y0 = j;
					x = x0 : y = y0;
					For x = x0 To W
						If (ARRAY(x,j)=0) Then Exit;
						If (WALL_FLAG(x,j)&gt;0) Then Exit;
						x1 = x;
					Next;
					lenghtH = x1-x0;
					; check farthest available to the bottom
					For y = y0 To H
						If (ARRAY(i,y)=0) Then Exit;
						If (WALL_FLAG(i,y)&gt;0) Then Exit;
						y1 = y;
					Next;
					lengthV = y1-y0
					
					; according to the longest segment build a quad
					If (lengthH&gt;=lengthV)
						; horizontal
						For x = x0 To x1
							; tag the cell as built
							WALL_FLAG(x,j) = 1
						Next
						; from x0 to x1+1 (+1 because we need the right segment of the cell)
						v = AddVertex	(surf, x0  , 1,y0+1) : VertexNormal(surf, v  ,  0,+1, 0);
							AddVertex	(surf, x1+1, 1,y0+1) : VertexNormal(surf, v+1,  0,+1, 0);
							AddVertex	(surf, x1+1, 1,y0  ) : VertexNormal(surf, v+2,  0,+1, 0);
							AddVertex	(surf, x0  , 1,y0  ) : VertexNormal(surf, v+3,  0,+1, 0);
							AddTriangle	(surf, v,v+1,v+2);
							AddTriangle	(surf, v,v+2,v+3);
					Else
						; vertical
						For y = y0 To y1
							; tag the cell as built
							WALL_FLAG(i,y) = 1
						Next
						v = AddVertex	(surf, x0  , 1,y1+1) : VertexNormal(surf, v  ,  0,+1, 0);
							AddVertex	(surf, x0+1, 1,y1+1) : VertexNormal(surf, v+1,  0,+1, 0);
							AddVertex	(surf, x0+1, 1,y0  ) : VertexNormal(surf, v+2,  0,+1, 0);
							AddVertex	(surf, x0  , 1,y0  ) : VertexNormal(surf, v+3,  0,+1, 0);
							AddTriangle	(surf, v,v+1,v+2);
							AddTriangle	(surf, v,v+2,v+3);
					EndIf;
				EndIf
			EndIf;
		Next;
	Next;
	Dim WALL_FLAG(0,0)
End Function


Graphics3D 1024,768,0,2
SetBuffer BackBuffer()

SeedRnd MilliSecs()

Local W = 100
Local H = 100

; -------------------------------------------------------------
; Random Map
; -------------------------------------------------------------
	PopulateRandomMap(W,H)

; -------------------------------------------------------------
; build Mesh
; -------------------------------------------------------------
	Local Mesh=CreateMesh()
	Local Surf=CreateSurface(Mesh)
	Local FloorSurf=CreateSurface(Mesh)
	BuildWalls(Surf,FloorSurf, W,H)
	;UpdateNormals Mesh
	
; -------------------------------------------------------------
; debug 2d grid
; -------------------------------------------------------------
	DRAWARRAYGRID(W-1,H-1)
	Flip True
	WaitKey()

; -------------------------------------------------------------
; Show in 3D
; -------------------------------------------------------------

	AmbientLight 128,128,128
	
	Local Sun				=	CreateLight		( 2 );
								PositionEntity	( Sun, W*5,W, -W*5 );
								LightRange		( Sun, W*15 );
								LightColor		( Sun, 255,220,200 );
								
	Local piv				=	CreatePivot		( )
	Local pit				=	CreatePivot		( piv );
	Local Cam				=	CreateCamera	( pit );
								PositionEntity	( piv, W/2,0,H/2 );
								TurnEntity		( pit, 45,0,0 );
								MoveEntity		( Cam, 0, 0, -W/2 );
					
	Local mdl				=	CreateCube		( )
								FitMesh			( mdl, .01,.01,.01,.98,.98,.98 )
								FlipMesh		( mdl )
								EntityAlpha		( mdl, 0.25 )
								EntityColor		( mdl, 128,000,000 )
								HideEntity		( mdl )
	
	Local root				=	CreatePivot		( )
	For x=0 To W-1
		For y=0 To H-1
			If ARRAY(x,y)
				PositionEntity	( CopyEntity(mdl,root), x,0,y, True );
			EndIf;
		Next;
	Next;
	
	Local Wire%				=	False;
	FlushMouse();
	
	While ( Not(KeyDown(1)) )
		If (Keyhit(57)&gt;0)
			Wire			=	Not(Wire);
			WireFrame			( Wire );
		EndIf;
		
		Local msx#			=	MouseXSpeed();
		Local msy#			=	MouseYSpeed();
		
		If (MouseDown(2)&gt;0)
			TurnEntity			( piv, 0,-msx,0 );
			TurnEntity			( pit, +msy,0,0 );
		EndIf;
		MoveEntity				( piv, Float(KeyDown(205)-KeyDown(203))*.1, 0, Float(KeyDown(200)-KeyDown(208))*.1 );
		PositionEntity			( cam, 0,0,EntityZ(cam,0)*(1-0.05*Float(MouseZSpeed())) );
		RenderWorld				( );
			
			Color				( 255,128,000 );
			Text				( 10,10,"Arrow -&gt; move" );
			Text				( 10,25,"right mouse -&gt; turn" );
			Text				( 10,40,"mouse wheel -&gt; zoom" );
			Text				( 10,55,"space -&gt; wireframe" );
		Flip					( True );
	Wend
End
</textarea><br><br><br>ps : I see the issue in your code but it's a bit hard to notice where it comes from, because your code is a bit hard to follow (too many recursive function calls, it does not help tracking stuff).<br>You might want to use Vertex color and color your segment in different colors according to the place it was called from, so you should notice easier which segment is faulty.<br><br>Anyway, I think you have a weird issue that is not visible<br>-&gt; you have segment with no length<br>On "PLANAR PASS VERTICAL 2" : extends from 1 block the length of the segment and they will appear as single blocks (so, with a unit less, they are just empty segment)<br><br>at this part of the code<br><pre class=code>
						If (CountingVertical)
							;AddPLANAR_XZ_Z_Geometry(X,H-(Y-VerticalLength),VerticalLength,Surface)
							AddPLANAR_XZ_Z_Geometry(X,H-(Y-VerticalLength),VerticalLength+1,Surface); Add 1 unit to the length and the blocks appear.
							VerticalLength=0
							CountingVertical=False	
						End If
</pre> <br><br></td></tr></table><br>
<a name="1322615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adding +1 tehre only adds extra unwanted geometry.<br><br>_____________<br><br>The way the counting works is that each square is assessed in sequence the algorithm doesn't "know" it needs to start or stop counting length until it encounters the required trigger value<br><pre class=code>
X		Grid		Counter
0		0			nothing
1		0			nothing
2		1			START COUNTING LENGTH=1
3		1			LENGTH=2
4		1			LENGTH=3
5		0			CEASE COUNT.  CURRENT X=5  - LENGTH (3)  = CORRECT START X 2
6		0
</pre><br><br><br>________________________________<br><br><br>The only exceptions are at the end of the rows/columns, whch, in my actual project will be inaccessible boundaries which are irrelevant.<br><br>This can be identified easily with:<br><pre class=code>
Function ProcessPlanarHorizontal(X,Y,Length)
	If (Length&lt;1) Then DebugLog(X+","+Y+" "+"H Length"+Length)
	
;.......
Function ProcessPlanarVertical(X,Y,Length)
	If (Length&lt;1) Then DebugLog(X+","+Y+" "+"V Length"+Length)
</pre> <br><br></td></tr></table><br>
<a name="1322617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If there are no "lines" wider than one cell, then it makes things way more simple. <br></div><br><br>The code you posted here works perfectly. <br>I am looking through it now to see how to change my code. It is a little difficult because they are similar but not identical approaches.<br><br><br>I apologise for the difficulty in readability of the code I've posted - the ACTUAL project relies on data stored in banks and is reliant on other variables so much that it was simpler to throw this example together.<br><br>Thanks very much for your help in this bobysait and you make it look so easy :) <br><br></td></tr></table><br>
<a name="1322711"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> now have fun setting u,v coords to texture it properly ;) <br><br></td></tr></table><br>
<a name="1322750"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> now have fun setting u,v coords to texture it properly ;)  <br></div><br><br>__<br>Not an issue, no texturing is required.<br><br>However given the triangles are all aligned to axes and set to unit dimensions, the normals belie the 'top','bottom','left','right' or roof  facing, therefore, it is simple to then apply the UV to each accordingly.<br><br>_____________________________________________________________<br><br><br>Well I've made some progress and have the alignment correct, the roof is done, all invisible faces have no geometry and where a longer wall intersects a shorter one, the longer one takes priority in determining the roof geometry. <br><br></td></tr></table><br>
<a name="1323611"></a>

<a name="1323612"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> In the BuildWalls function, I forgot a small mistake (it's not a bug, but it's a totally useless check)<br><br><pre class=code>
	For j = 0 To H
		For i = 0 To W
			; this cell has a top wall
			If ((HAS_WALL(i,j) And 1)&gt;0) And ((HAS_WALL(i,j) And 1)&gt;0)
				; if this wall hasn't already been built
				If ((WALL_FLAG(i,j) And 1) = 0)
</pre><br><br><br>-&gt; If ((HAS_WALL(i,j) And 1)&gt;0) And ((HAS_WALL(i,j) And 1)&gt;0)<br>this is twice the same test, it's an unremoved temporary code that has not been updated.<br><br>replace it with <br><pre class=code>
If ( ( HAS_WALL(i,j) And 1 ) &gt; 0 )
</pre><br>I not "better safe than sorry" but here, a single test will do the same job as two but faster :p <br><br></td></tr></table><br>
<a name="1323926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Bobysait.<br><br>I had to essentially re-write the essence of your code entirely to match the critera and conventions of my actual project (which included a more complex determination of walls than just a binary wall or no wall,as well as using banks rather than arrays) so the minor issues such as that you mention were cleared up and addressed on the way.<br><br>I do appreciate your clarity though :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
