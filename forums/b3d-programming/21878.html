<!DOCTYPE html><html lang="en" ><head ><title >3dsMax Ase -&gt; B3D</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >3dsMax Ase -&gt; B3D</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >3dsMax Ase -&gt; B3D</a><br><br>
<a name="224071"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DareDevil</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> The code is free and all modify is free for all <br>the code is not perfect and not support animation <br><br>;===================================================================== <br>;---------------------------------------------------------------- <br>; Vincenzo Caldarulo <br>; nickname : VinsentX <br>; e-mail: enzo_light@... <br>; main Programmer V&amp;D Software Multimedia <br>;---------------------------------------------------------------- <br>;===================================================================== <br>;**************************** <br>;------------------------- <br>; 3DMax Ase export to B3D <br>; Support Converter: <br>; <br>; - Default Map <br>; - Light Map <br>; - Reflect Map <br>;------------------------- <br>;**************************** <br>; <br>Include "b3dfile.bb" <br><br>Graphics3D 640,480,16,2 <br>SetBuffer BackBuffer() <br><br>;===&gt; <br>Const Simb1 = 32 ; 32 = ASC(" ") <br>const Simb2 = 125; 125 = ASC("}") <br><br>const ArrDim = 200000 <br>const ArrMat = 99 <br>;===&gt; <br>global Obj_name$ <br>global XYZ_Count_vertex <br>global XYZ_Count_face <br>global XYZ_px#, XYZ_py#, XYZ_pz# <br>global XYZ_ax#, XYZ_ay#, XYZ_az#, XYZ_aw# <br>global XYZ_sx#, XYZ_sy#, XYZ_sz# <br>global UVW_Count_vertex <br>global UVW_Count_face <br>global UVW_Count_vertex1 <br>global UVW_Count_face1 <br>global UVW_OffU0# = 1 <br>Global UVW_OffV0# = 1 <br>Global UVW_OffU1# = 1 <br>Global UVW_OffV1# = 1 <br>Global UVW_OffU2# = 1 <br>Global UVW_OffV2# = 1 <br>Global UVW_TileU0# = 1 <br>global UVW_TileV0# = 1 <br>global UVW_TileU1# = 1 <br>global UVW_TileV1# = 1 <br>global UVW_TileU2# = 1 <br>global UVW_TileV2# = 1 <br>global UVW_for_XYZ <br>;===&gt; <br>dim XYZ_vertex#(ArrDim,3) <br>dim XYZ_normal#(ArrDim,3) <br>dim XYZ_face(ArrDim,3) <br>dim UVW_vertex#(ArrDim,3) <br>dim UVW_face(ArrDim,3) <br>dim UVW_vertex1#(ArrDim,3) <br>dim UVW_face1(ArrDim,3) <br>;===&gt; <br>global MAT_Count; <br>;===&gt; <br>dim MatName$(ArrMat) ; nome materiale <br>dim MatTex0$(ArrMat) ; nome texture default <br>dim MatTex1$(ArrMat) ; nome texture lightmap <br>dim MatTex2$(ArrMat) ; nome texture EnvMap <br>dim MatR#(ArrMat) ; color R <br>dim MatG#(ArrMat) ; color G <br>dim MatB#(ArrMat) ; color B <br>dim MatA#(ArrMat) ; Opacity <br>dim MatShine#(ArrMat) ; Shininess <br>;===&gt; <br><br><br>;===&gt; <br>;Convert_Ase_B3d("obj.ASE","Viewer V&amp;D\gfx\Obj.B3D") <br>Text 0,00,"Inizio esportazione" <br>Flip <br><br>global time1 = millisecs() <br>Convert_Ase_B3d("obj.ASE","Obj.B3D") <br>global time2 = millisecs() <br><br>Global ObjExp = loadmesh("obj.b3d"); <br><br>Text 0,10,"Esportazione avvenuta con successo" <br>;===================================================================== <br>;===================================================================== <br>; ------------------------------- <br>; Creation de la caméra <br>; ------------------------------- <br>Global Mouse_X_Speed# <br>Global Mouse_Y_Speed# <br>Global Camera <br>Global Camera_VelX# <br>Global Camera_VelZ# <br>Global Camera_Pitch# <br>Global Camera_Yaw# <br><br>Camera=CreateCamera() <br>rotateentity camera,0,0,0 <br>;PositionEntity camera,290,-600,2380 ; da inc a metri x100 <br>PositionEntity camera,0,0,0 ; da inc a metri x100 <br>CameraRange camera,0.1,10000 <br>;formula del fov camera Zoom =Sqrt(Fov) <br>;CameraZoom camera, sqr(50) ; 1 = 10 di fov // 7.5 = 50 di fov <br>CameraZoom camera, 1 ; 1 = 10 di fov // 7.5 = 50 di fov <br>; ------------------------------- <br>; Chargement de l'objet <br>; ------------------------------- <br>;ObjExp=LoadMesh( "Obj.b3d" ) <br>;ObjExp=LoadAnimMesh( "Obj.b3d" ) <br>;Animate ObjExp, 1 <br>RotateEntity ObjExp,0,0,0 <br>PositionEntity ObjExp,0,0,0 <br>EntityShininess ObjExp,1 <br>PointEntity Camera,ObjExp <br><br>temp = createsphere(8) <br>entityalpha temp,0.5 <br>Dither True <br><br>LightCA = 255 <br>AmbientLight LightCA, LightCA, LightCA <br><br>font=LoadFont( "Arial",20 ) <br>SetFont font <br>;===&gt; <br>MoveMouse GraphicsWidth()/2,GraphicsHeight()/2 <br>;rotateentity camera,-2.7,178,180 <br>While KeyDown(1)=0 <br>Procedure_Freelook(1.05,0.2) <br>updateworld() <br>RenderWorld() <br>Text 0,0,"Esportazione avvenuta con successo" <br>text 0,15,"px:"+entityx(Camera)+"py:"+entityy(Camera)+"pz:"+entityz(Camera) <br>text 0,30,"rx:"+entitypitch(Camera)+"ry:"+entityyaw(Camera)+"rz:"+entityroll(Camera) <br>text 0,45,"Time to export" <br>text 0,60,"Millisecs "+(time2-time1)+" secs "+((time2-time1)/1000) <br>Flip <br>Wend <br>End <br>; ------------------------- <br>; Fonction Freelook <br>; ------------------------- <br>Function Procedure_Freelook(Velocity#,Speed#) <br>AngMax = 89 <br>Mouse_X_Speed=MouseXSpeed()*0.5 <br>Mouse_Y_Speed=MouseYSpeed()*0.5 <br><br>MoveMouse GraphicsWidth()/2,GraphicsHeight()/2 <br>Camera_Pitch=Camera_Pitch+Mouse_Y_Speed <br>Camera_Yaw=Camera_Yaw-Mouse_X_Speed <br><br>If Camera_Pitch&lt;-AngMax Then Camera_Pitch=-AngMax <br>If Camera_Pitch&gt;AngMax Then Camera_Pitch=AngMax <br><br>RotateEntity camera,Camera_Pitch,Camera_Yaw,0 <br><br>If KeyDown(Key_ArrowPad_Left) Camera_VelX=Camera_VelX-Speed# ElseIf KeyDown(Key_ArrowPad_Right) Camera_VelX=Camera_VelX+Speed# <br>; If KeyDown(Key_ArrowPad_Down) Camera_VelZ=Camera_VelZ-Speed# ElseIf KeyDown(Key_ArrowPad_Up) Camera_VelZ=Camera_VelZ+Speed# <br>If MouseDown(2) Camera_VelZ=Camera_VelZ-Speed# ElseIf MouseDown(1) Camera_VelZ=Camera_VelZ+Speed# <br><br>Camera_VelX=Camera_VelX/Velocity# <br>Camera_VelZ=Camera_VelZ/Velocity# <br>MoveEntity camera,Camera_VelX,0,Camera_VelZ <br>End Function <br>;===================================================================== <br>;===================================================================== <br><br><br>;=============================== <br>;--------------------------- <br>; Scrittura stringa <br>;--------------------------- <br>Function ReadStringN$(f,sep$) <br>s$ = ""; <br>SepVal = Asc(sep$) <br><br>While Not Eof(f) <br>let = ReadByte(f); <br><br>if (let = SepVal and s$ &lt;&gt; "") <br>return s <br>else <br>if ((let &gt;= Simb1) and (let &lt;= Simb2) and (let &lt;&gt; SepVal) and (let &lt;&gt; 34)); the code 34 = " from ascii table <br>s$ = s$ + Chr(let) <br>else <br>if (s$ &lt;&gt; "") return s <br>end if <br>end if <br>Wend <br>End Function <br><br>Function EstractName$(str_nome$) <br>s$ = "" <br>lun = len(str_nome) <br>;===&gt; <br>For xc = lun To 1 Step -1 <br>s$ = mid(str_nome,xc,1) <br>If ((s$ = "\") Or (xc=1)) <br>s$ = mid(str_nome,xc+1,lun-xc); <br>exit <br>end if <br>next <br>;===&gt; <br>return s$ <br>;===&gt; <br>end function <br><br>;--------------------------- <br>; Scrittura stringa <br>;--------------------------- <br>Function Convert_Ase_B3d(LoadFile$,SaveFile$) <br>;stop <br>infile = OpenFile(LoadFile$) <br>outfile = Writefile(SaveFile$) <br>WriteBB3D( outfile, "Init" ) <br>StateMesh = 0 ; 1 = Init Root Object <br>While Not Eof(infile) <br>;===&gt; <br>Obj_name$ = "" <br>XYZ_Count_vertex = 0 <br>XYZ_Count_face = 0 <br>UVW_Count_vertex = 0 <br>UVW_Count_face = 0 <br>UVW_Count_vertex1 = 0 <br>UVW_Count_face1 = 0 <br>;===&gt; <br>StateLoad = LoadAse(infile) <br>;===&gt; <br>if ((StateLoad = 1) and (StateMesh = 0)) <br>WriteBB3D( outfile, "Material" ) <br>end if <br>;===&gt; <br>if (StateLoad = 2) <br>;===&gt; <br>if (stateMesh = 0) ; Open Root Object <br>StateMesh = 1 <br>b3dBeginChunk( "NODE" );------------root node <br>b3dWriteString( "root");name <br>b3dWriteFloat( 0 ) ;x_pos <br>b3dWriteFloat( 0 ) ;y_pos <br>b3dWriteFloat( 0 ) ;y_pos <br>b3dWriteFloat( 1 ) ;x_scale <br>b3dWriteFloat( 1 ) ;y_scale <br>b3dWriteFloat( 1 ) ;z_scale <br>b3dWriteFloat( 1 ) ;rot_w <br>b3dWriteFloat( 0 ) ;rot_x <br>b3dWriteFloat( 0 ) ;rot_y <br>b3dWriteFloat( 0 ) ;rot_z <br>end if <br>;===&gt; <br>WriteBB3D( outfile, "Mesh" ) <br>end if <br>;===&gt; <br>Wend <br>;===&gt; <br>if (stateMesh = 1) ; Close Root Object <br>b3dEndChunk() ;end of NODE chunk <br>end if <br>;===&gt; <br>WriteBB3D( outfile, "End" ) <br><br>CloseFile infile <br>CloseFile outfile <br>end function <br><br>;--------------------------- <br>; Scrittura stringa <br>;--------------------------- <br>Function LoadAse(ASE) <br><br>OpenP = 0 <br>While Not Eof(ASE) <br>chunk$ = ReadStringN(ASE," ") <br>;===&gt; <br>if (chunk$ = "*GEOMOBJECT") then <br>;stop <br>While Not Eof(ASE) <br>cluster$ = ReadStringN(ASE," ") <br>;===&gt; <br>if (cluster$ = "{") <br>OpenP = OpenP+1 <br>end if <br>if (cluster$ = "}") then <br>OpenP = OpenP-1 <br>end if <br>if (OpenP &lt;= 0) <br>if (XYZ_Count_vertex&gt;2) <br>return 2 <br>else <br>return 0 <br>end if <br>end if <br>;===&gt; <br>if (cluster$ = "*NODE_NAME") then <br>Obj_name$ = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*TM_POS") then <br>XYZ_px = ReadStringN(ASE," ") <br>XYZ_py = ReadStringN(ASE," ") <br>XYZ_pz = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*TM_ROTAXIS") then <br>XYZ_rx = ReadStringN(ASE," ") <br>XYZ_ry = ReadStringN(ASE," ") <br>XYZ_rz = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*TM_ROTANGLE") then <br>XYZ_rw = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*TM_SCALE") then <br>XYZ_sx = ReadStringN(ASE," ") <br>XYZ_sy = ReadStringN(ASE," ") <br>XYZ_sz = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if cluster$ = "*MATERIAL_REF" then <br>UVW_for_XYZ = ReadStringN(ASE," ") <br>end if <br><br>;===&gt; <br>if (cluster$ = "*MESH") then <br>While Not Eof(ASE) <br>cluster1$ = ReadStringN(ASE," ") <br>;===&gt; <br>if (cluster1$="}") exit <br>;===&gt; <br>if (cluster1$ = "*MESH_NUMVERTEX") then <br>XYZ_Count_vertex = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster1$ = "*MESH_NUMFACES") then <br>XYZ_Count_face = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster1$ = "*MESH_VERTEX_LIST") then <br>MESH_VERTEX_LIST(ASE) <br>end if <br>;===&gt; <br>if (cluster1$ = "*MESH_FACE_LIST") then <br>MESH_FACE_LIST(ASE) <br>end if <br>;===&gt; <br>if cluster1$ = "*MESH_NUMTVERTEX" then <br>UVW_Count_vertex = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if cluster1$ = "*MESH_TVERTLIST" then <br>MESH_TVERTLIST(ASE) <br>end if <br>;===&gt; <br>if cluster1$ = "*MESH_NUMTVFACES" then <br>UVW_Count_face = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if cluster1$ = "*MESH_TFACELIST" then <br>MESH_TFACELIST(ASE) <br>end if <br>;===&gt; <br>if cluster1$ = "*MESH_MAPPINGCHANNEL" then <br>While Not Eof(ASE) <br>chunk1$ = ReadStringN(ASE," ") <br>;===&gt; <br>if (chunk1$="}") exit <br>;===&gt; <br>if chunk1$ = "*MESH_NUMTVERTEX" then <br>UVW_Count_vertex1 = ReadStringN(ASE,"") <br>end if <br>;===&gt; <br>if chunk1$ = "*MESH_TVERTLIST" then <br>MESH_TVERTLIST1(ASE) <br>end if <br>;===&gt; <br>if chunk1$ = "*MESH_NUMTVFACES" then <br>UVW_Count_face1 = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if chunk1$ = "*MESH_TFACELIST" then <br>MESH_TFACELIST1(ASE) <br>end if <br>;===&gt; <br>wend <br>end if <br>;===&gt; <br>if (cluster1$ = "*MESH_NORMALS") then <br>MESH_NORMALS(ASE) <br>end if <br>;===&gt; <br>wend <br>end if <br>;===&gt; <br>wend <br>end if <br>;===&gt; <br>; Chunck *MATERIAL_LIST <br>if chunk$ = "*MATERIAL_LIST" then <br>OpenP = 0 <br>Id_mat = 0 <br>While Not Eof(ASE) <br>cluster$ = ReadStringN(ASE," ") <br>;===&gt; <br>if (cluster$ = "{") <br>OpenP = OpenP+1 <br>end if <br>if (cluster$ = "}") then <br>OpenP = OpenP-1 <br>end if <br>if (OpenP &lt;= 0) <br>if (MAT_Count=&gt;0) <br>return 1 <br>else <br>return 0 <br>end if <br>end if <br>;===&gt; <br>if (cluster$ = "*MATERIAL_COUNT") then <br>cnt = ReadStringN(ASE," ") <br>MAT_Count = cnt-1 <br>end if <br>;===&gt; <br>if (cluster$ = "*MATERIAL") then <br>Id_mat = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*MATERIAL_NAME") then <br>MatName$(Id_mat) = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*MATERIAL_DIFFUSE") then <br>MatR(Id_mat) = ReadStringN(ASE," ") <br>MatG(Id_mat) = ReadStringN(ASE," ") <br>MatB(Id_mat) = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*MATERIAL_SHINE") then <br>MatShine(Id_mat) = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>if (cluster$ = "*MATERIAL_TRANSPARENCY") then <br>val# = ReadStringN(ASE," ") <br>MatA(Id_mat) = 1.0-val <br>end if <br>;===&gt; <br>if (cluster$ = "*MAP_DIFFUSE") then <br>While Not Eof(ASE) <br>cluster1$ = ReadStringN(ASE," ") <br>if (cluster1$="}") exit <br>if (cluster1$="*BITMAP") <br>name$ = ReadStringN(ASE,"") <br>MatTex0$(Id_mat) = EstractName$(name$); <br>end if <br>if (cluster1$="*UVW_U_OFFSET") <br>UVW_OffU0# = ReadStringN(ASE,""); <br>end if <br>if (cluster1$="*UVW_V_OFFSET") <br>UVW_OffV0# = ReadStringN(ASE,""); <br>end if <br>if (cluster1$="*UVW_U_TILING") <br>ut# = ReadStringN(ASE,"") <br>UVW_TileU0# = 1.0/ut#; <br>end if <br>if (cluster1$="*UVW_V_TILING") <br>vt# = ReadStringN(ASE,"") <br>UVW_TileV0# = 1.0/vt#; <br>end if <br>Wend <br>end if <br>;===&gt; <br>if (cluster$ = "*MAP_SELFILLUM") then <br>While Not Eof(ASE) <br>cluster1$ = ReadStringN(ASE," ") <br>if (cluster1$="}") exit <br>if (cluster1$="*BITMAP") <br>name$ = ReadStringN(ASE,"") <br>MatTex1$(Id_mat) = EstractName$(name$); <br>end if <br>if (cluster1$="*UVW_U_OFFSET") <br>UVW_OffU1# = ReadStringN(ASE,""); <br>end if <br>if (cluster1$="*UVW_V_OFFSET") <br>UVW_OffV1# = ReadStringN(ASE,""); <br>end if <br>if (cluster1$="*UVW_U_TILING") <br>ut# = ReadStringN(ASE,"") <br>UVW_TileU1# = 1.0/ut#; <br>end if <br>if (cluster1$="*UVW_V_TILING") <br>vt# = ReadStringN(ASE,"") <br>UVW_TileV1# = 1.0/vt#; <br>end if <br>Wend <br>end if <br>;===&gt; <br>if (cluster$ = "*MAP_REFLECT") then <br>While Not Eof(ASE) <br>cluster1$ = ReadStringN(ASE," ") <br>if (cluster1$="}") exit <br>if (cluster1$="*BITMAP") <br>name$ = ReadStringN(ASE,"") <br>MatTex2$(Id_mat) = EstractName$(name$); <br>end if <br>if (cluster1$="*UVW_U_OFFSET") <br>UVW_OffU2# = ReadStringN(ASE,""); <br>end if <br>if (cluster1$="*UVW_V_OFFSET") <br>UVW_OffV2# = ReadStringN(ASE,""); <br>end if <br>if (cluster1$="*UVW_U_TILING") <br>ut# = ReadStringN(ASE,"") <br>UVW_TileU2# = 1.0/ut#; <br>end if <br>if (cluster1$="*UVW_V_TILING") <br>vt# = ReadStringN(ASE,"") <br>UVW_TileV2# = 1.0/vt#; <br>end if <br>Wend <br>end if <br>;===&gt; <br>if (cluster$ = "*") then <br>Obj_name$ = ReadStringN(ASE," ") <br>end if <br>;===&gt; <br>wend <br>end if <br><br>wend <br><br>end function <br><br><br>;--------------------------- <br>; <br>;--------------------------- <br>Function MESH_NORMALS(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster1$ = ReadStringN(ASE," ") <br>if (cluster1$="*MESH_FACENORMAL") <br>No$ = ReadStringN(ASE," ") <br>XYZ_normal(id,0) = ReadStringN(ASE," ") <br>XYZ_normal(id,1) = ReadStringN(ASE," ") <br>XYZ_normal(id,2) = ReadStringN(ASE," ") <br>id = id+1 <br>end if <br>if (cluster1$="}") exit <br>Wend <br>end function <br>;--------------------------- <br>; <br>;--------------------------- <br>function MESH_VERTEX_LIST(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster2$ = ReadStringN(ASE," ") <br>if (cluster2$="*MESH_VERTEX") <br>No$ = ReadStringN(ASE," ") <br>XYZ_vertex(id,0) = ReadStringN(ASE," ") <br>XYZ_vertex(id,1) = ReadStringN(ASE," ") <br>XYZ_vertex(id,2) = ReadStringN(ASE," ") <br>id = id+1 <br>end if <br>if (cluster2$="}") exit <br>Wend <br>end function <br>;--------------------------- <br>; <br>;--------------------------- <br>function MESH_FACE_LIST(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster2$ = ReadStringN(ASE," ") <br>if (cluster2$="*MESH_FACE") <br>No$ = ReadStringN(ASE," ") <br>No$ = ReadStringN(ASE," ") <br>;--- <br>f1 = ReadStringN(ASE," ") : No$ = ReadStringN(ASE," ") <br>f2 = ReadStringN(ASE," ") : No$ = ReadStringN(ASE," ") <br>f3 = ReadStringN(ASE," ") <br>XYZ_face(id,0) = f1 <br>XYZ_face(id,1) = f2 <br>XYZ_face(id,2) = f3 <br>id = id+1 <br>end if <br>if (cluster2$="}") exit <br>Wend <br>end function <br>;--------------------------- <br>; <br>;--------------------------- <br>function MESH_TVERTLIST(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster2$ = ReadStringN(ASE," ") <br>if (cluster2$="*MESH_TVERT") <br>No$ = ReadStringN(ASE," ") <br>UVW_vertex(id,0) = ReadStringN(ASE," ") <br>UVW_vertex(id,1) = ReadStringN(ASE," ") <br>UVW_vertex(id,2) = ReadStringN(ASE," ") <br>id = id+1 <br>end if <br>if (cluster2$="}") exit <br>wend <br>end function <br>;--------------------------- <br>; <br>;--------------------------- <br>function MESH_TFACELIST(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster2$ = ReadStringN(ASE," ") <br>if (cluster2$="*MESH_TFACE") <br>No$ = ReadStringN(ASE," ") <br>UVW_face(id,0) = ReadStringN(ASE," ") <br>UVW_face(id,1) = ReadStringN(ASE," ") <br>UVW_face(id,2) = ReadStringN(ASE," ") <br>id = id+1 <br>end if <br>if (cluster2$="}") exit <br>wend <br>end function <br>;--------------------------- <br>; <br>;--------------------------- <br>function MESH_TVERTLIST1(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster2$ = ReadStringN(ASE," ") <br>if (cluster2$="*MESH_TVERT") <br>No$ = ReadStringN(ASE," ") <br>UVW_vertex1(id,0) = ReadStringN(ASE," ") <br>UVW_vertex1(id,1) = ReadStringN(ASE," ") <br>UVW_vertex1(id,2) = ReadStringN(ASE," ") <br>id = id+1 <br>end if <br>if (cluster2$="}") exit <br>wend <br>end function <br>;--------------------------- <br>; <br>;--------------------------- <br>function MESH_TFACELIST1(ASE) <br>id = 0 <br>While Not Eof(ASE) <br>cluster2$ = ReadStringN(ASE," ") <br>if (cluster2$="*MESH_TFACE") <br>No$ = ReadStringN(ASE," ") <br>UVW_face1(id,0) = ReadStringN(ASE," ") <br>UVW_face1(id,1) = ReadStringN(ASE," ") <br>UVW_face1(id,2) = ReadStringN(ASE," ") <br>id = id+1 <br>end if <br>if (cluster2$="}") exit <br>wend <br>end function <br>;========================================================================= <br>;========================================================================= <br>;========================================================================= <br>;--------------------------- <br>; <br>;--------------------------- <br><br>Function WriteBB3D( file, state$ ) <br>select state$ <br>;------------------- <br>case "Init" <br>b3dSetFile( file ) <br><br>; b3dWriteString( "Export 3DSMax Ase To B3D" ) ;name <br>; b3dWriteString( "V&amp;D Software Multimedia" ) ;name <br>; b3dWriteString( "Write VinsentX Vincenzo Caldarulo" ) ;name <br><br><br>b3dBeginChunk( "BB3D" ) <br>b3dWriteInt( 1 ) ;version <br>;------------------- <br>case "Material" <br>for Id_mat = 0 to MAT_Count <br>b3dBeginChunk( "TEXS" ) <br>;===&gt; Diffuse map <br>b3dWriteString( MatTex0$(Id_mat) ) <br>b3dWriteInt( 1 ) ;textureflag <br>b3dWriteInt( 2 ) ;textureblend <br>b3dWriteFloat( UVW_OffU0# ) ;x_pos <br>b3dWriteFloat( UVW_OffV0# ) ;y_pos <br>b3dWriteFloat( UVW_TileU0# );x_scale <br>b3dWriteFloat( UVW_TileV0# );y_scale <br>b3dWriteFloat( 0 ) ;rotation <br>;===&gt; Light Map <br>b3dWriteString( MatTex1$(Id_mat) ) <br>b3dWriteInt( 65536) ;textureflag for 2nd ! uv channel [65536=normal, 65584=clamp u,v and so on ...] <br>b3dWriteInt( 2 ) ;textureblend <br>b3dWriteFloat( UVW_OffU1# ) ;x_pos <br>b3dWriteFloat( UVW_OffV1# ) ;y_pos <br>b3dWriteFloat( UVW_TileU1# );x_scale <br>b3dWriteFloat( -UVW_TileV1# );y_scale <br>b3dWriteFloat( 0 ) ;rotation <br>;===&gt; ReflectMap <br>b3dWriteString( MatTex2$(Id_mat) ) <br>b3dWriteInt( 64 ) ;textureflag <br>b3dWriteInt( 2 ) ;textureblend <br>b3dWriteFloat( UVW_OffU2# ) ;x_pos <br>b3dWriteFloat( UVW_OffV2# ) ;y_pos <br>b3dWriteFloat( UVW_TileU2# );x_scale <br>b3dWriteFloat( UVW_TileV2# );y_scale <br>b3dWriteFloat( 0 ) ;rotation <br>;===&gt; <br>b3dEndChunk() ;end of TEXS chunk <br>next <br><br>for Id_mat = 0 to MAT_Count <br>mat = Id_mat*3 <br>b3dBeginChunk( "BRUS" ) <br>;===&gt; <br>b3dWriteInt( 3 ) ;textures per brush[1] <br>b3dWriteString( MatName$(Id_mat) ) ;name <br>b3dWriteFloat( MatR(Id_mat) ) ;red <br>b3dWriteFloat( MatG(Id_mat) ) ;green <br>b3dWriteFloat( MatB(Id_mat) ) ;blue <br>b3dWriteFloat( MatA(Id_mat) ) ;alpha <br>b3dWriteFloat( MatShine(Id_mat) ) ;shininess <br>b3dWriteInt( 0 ) ;blend <br>b3dWriteInt( 1 ) ;FX <br>b3dWriteInt( mat+0 ) ;texture_id UV0 <br>b3dWriteInt( mat+2 ) ;texture_id UV0 <br>b3dWriteInt( mat+1 ) ;texture_id UV1 <br>;===&gt; <br>b3dEndChunk() ;end of BRUS chunk <br>next <br>;------------------- <br>case "Mesh" <br>;stop <br>; if (Obj_name$="Plane01") then stop <br>b3dBeginChunk( "NODE" );------------sub nodes <br>b3dWriteString( Obj_name$);name <br>b3dWriteFloat( 0 ) ;x_pos XYZ_px# <br>b3dWriteFloat( 0 ) ;y_pos XYZ_py# <br>b3dWriteFloat( 0 ) ;y_pos XYZ_pz# <br>b3dWriteFloat( 1 ) ;x_scale XYZ_sx# <br>b3dWriteFloat( 1 ) ;y_scale XYZ_sy# <br>b3dWriteFloat( 1 ) ;z_scale XYZ_sz# <br>b3dWriteFloat( 1 ) ;rot_w XYZ_aw# <br>b3dWriteFloat( 0 ) ;rot_x XYZ_ax# <br>b3dWriteFloat( 0 ) ;rot_y XYZ_ay# <br>b3dWriteFloat( 0 ) ;rot_z XYZ_az# <br>WriteMESH1( mesh1 ) <br>b3dEndChunk() ;end of NODE chunk <br>;------------------- <br>case "End" <br>b3dEndChunk() ;end of BB3D chunk <br>End Select <br>End Function <br>;============================== <br>;--------------------------- <br>; <br>;--------------------------- <br>Function WriteMESH1(curobj ) <br>;stop <br>n_tris = (XYZ_Count_face-1) <br><br>b3dBeginChunk( "MESH" ) <br>b3dWriteInt( -1 ) ;no 'entity' brush-&lt;---the brush!! <br><br>b3dBeginChunk( "VRTS" ) <br>b3dWriteInt( 0 ) ;flags - 0=no 1=normal 2=Vertex color <br>b3dWriteInt( 2 ) ;0 tex_coord sets <br>b3dWriteInt( 3 ) ;0 coords per set <br><br>For j=0 To n_tris <br>For k=2 To 0 step -1 <br>;===&gt; Id di ricostruzione triangoli <br>Id_Vert = XYZ_face(j,k) <br>Id_UV0 = UVW_face(j,k) <br>Id_UV1 = UVW_face1(j,k) <br>;===&gt; XYZ Vertex <br>vx# = XYZ_vertex#(Id_Vert,0) <br>vy# = XYZ_vertex#(Id_Vert,2) <br>vz# = XYZ_vertex#(Id_Vert,1) <br>b3dWriteFloat( vx# ); VX <br>b3dWriteFloat( vy# ); VY <br>b3dWriteFloat( vz# ); VZ <br>;===&gt; XYZ Vertex <br>nx# = XYZ_normal#(Id_Vert,0) <br>ny# = XYZ_normal#(Id_Vert,2) <br>nz# = XYZ_normal#(Id_Vert,1) <br>;b3dWriteFloat( nx# ); NX <br>;b3dWriteFloat( ny# ); NY <br>;b3dWriteFloat( nz# ); NZ <br>;===&gt; UVW 0 Default Map <br>u0# = UVW_vertex#(Id_UV0,0) <br>v0# = UVW_vertex#(Id_UV0,1) <br>w0# = UVW_vertex#(Id_UV0,2) <br>b3dWriteFloat( u0# ) ; U0 <br>b3dWriteFloat( v0# ) ; V0 <br>b3dWriteFloat( w0# ) ; W0 <br>;===&gt; UVW 1 Light Map <br>u1# = UVW_vertex1#(Id_UV1,0) <br>v1# = UVW_vertex1#(Id_UV1,1) <br>w1# = UVW_vertex1#(Id_UV1,2) <br>b3dWriteFloat( u1# ) ; U1 <br>b3dWriteFloat( v1# ) ; V1 <br>b3dWriteFloat( w1# ) ; W1 <br>;===&gt; <br>Next <br>Next <br>b3dEndChunk() ;end of VRTS chunk <br><br>b3dBeginChunk( "TRIS" ) <br>b3dWriteInt( UVW_for_XYZ ) ;brush for these triangles <br><br>For j=0 To n_tris <br>;===&gt; <br>Tris_v = j*3 <br>t1 = Tris_v+0 <br>t2 = Tris_v+1 <br>t3 = Tris_v+2 <br>b3dWriteInt( t1 ); X <br>b3dWriteInt( t2 ); Y <br>b3dWriteInt( t3 ); Z <br>;===&gt; <br>Next <br><br>b3dEndChunk() ;end of TRIS chunk <br><br>b3dEndChunk() ;end of MESH chunk <br><br>End Function <br><br><br><br>all the modifications must be public <br>and pleace comment this ;) <br><br></td></tr></table><br>
<a name="224205"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ckob</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work man but you should post this in code archives :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
