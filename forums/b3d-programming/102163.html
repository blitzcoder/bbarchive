<!DOCTYPE html><html lang="en" ><head ><title >Grass, Bush, Tree system..</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Grass, Bush, Tree system..</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Grass, Bush, Tree system..</a><br><br>
<a name="1218500"></a>

<a name="1218501"></a>

<a name="1218502"></a>

<a name="1218503"></a>

<a name="1218504"></a>

<a name="1218506"></a>

<a name="1218509"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys,<br><br>On my quest of creating a foliage system that is free and flexible I've found  <a href="/codearcs.php?code=2033" target="_blank"> Grass on a landscape (lite version) by Matt Merkulov </a>which was looking good to me:<br><br><img src="http://i61.tinypic.com/bfp2d1.jpg"><br><br>However I of course wanted enhance it a bit so I modified it so that it can now load (Blitz)terrains and multiple simple 3d models as well as the original quad billboards. <br><br><img src="http://i61.tinypic.com/15cj8kp.jpg"><br><img src="http://i57.tinypic.com/hralc2.jpg"><br>(Don't mind the models ugliness, they're only for experimentation, no finals)<br><br><br>Now of course I'm running into some transparency/alpha issue's here and there as I'm using multitextured terrain also:<br><br><img src="http://i62.tinypic.com/mr8i1f.jpg"><br><img src="http://i58.tinypic.com/ra0vti.jpg"><br><br>Code with media <a href="http://www.mediafire.com/download/t84ix1nysojl1u9/Foliage_V0.03.rar" target="_blank">click here</a>.<br>- Does anybody have a suggestion how to reduce/resolve that?<br>- Will MikhailV's FastImage resolve this issue? (I have his FastExtension already) <br><br></td></tr></table><br>
<a name="1218507"></a>

<a name="1218508"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Try to position your different meshes using alpha at a distance high enough so that each bounding box does not cross the others bounding box.<br><br>If you turn each grass mesh in front of the camera each frame, try to position each mesh using alpha at a distance high enough so that each radius (the highest of width or depth) does not cross the others radius.<br><br>If this does not work, you can try to use the flag 4 (hide the black pixels) instead of the flag 2 (alpha).<br><br>If this does not work you want to search in the forums/code archives to find a way to set the order of render of each mesh manually.<br>https://www.google.com/#q=alpha+z+ordering+site:blitzbasic.com <br><br></td></tr></table><br>
<a name="1218510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm didn't think about that flag 4 thinghy, thanks RemiD. That just might come in handy somewhere.<br>I once traveled the z-ordering road for something else, but I vaguely recall it was a pain(for some reason I can't remember, years back).<br><br>Perhaps I need to give it another look. <br><br></td></tr></table><br>
<a name="1218520"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mikorians</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking good, Rick!<br>I swear by flag 4.<br>I have found that trying to do the gfx card's work for it is a dead end because WE can't occlude by polygon. (My opinion) <br><br></td></tr></table><br>
<a name="1218586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did a quick(ugly) test and flag 4 indeed does trick! Now all I need to do is replace the png textures transparency with black, save them as a jpg and adjust the models.<br><br>Thanks guys. <br><br></td></tr></table><br>
<a name="1218610"></a>

<a name="1218611"></a>

<a name="1218612"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK no more z-ordering mess due to alpha textures, but now I of course need to convert some pictures from transparency to black pixels, which needs to be done pretty tight, otherwise gonna look messy:<br><img src="http://i62.tinypic.com/331k61d.jpg"><br><br>I tried MS Paint and Paint.NET, but both do not give me satisfying results.<br><br><b>Any advice on best tools/method for the job?</b><br><i>(I do also have Photoshop, which I didn't install yet cos low on diskspace on this laptop, but if necessary I could use it.)</i> <br><br></td></tr></table><br>
<a name="1218624"></a>

<a name="1218625"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I use photofiltre, all transparent pixels must be colored with 000R,000G,000B, then i save in png. <br><br></td></tr></table><br>
<a name="1218653"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can also use the <a href="http://www.gimp.org/" target="_blank">GIMP</a>, with the tool Layers -&gt; Transparency -&gt; Threshold Alpha.<br>It makes semi-transparent pixels either fully transparent or fully opaque based on a threshold alpha value that you specify.<br><br>Then you can merge that texture layer with a fully black background layer to cover the empty parts. <br><br></td></tr></table><br>
<a name="1218908"></a>

<a name="1218909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mikorians</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I get excellent control with DxtBmp !<br>It's very simple.<br>(Any trouble, save as .TGA) <br><br></td></tr></table><br>
<a name="1236451"></a>

<a name="1236456"></a>

<a name="1236458"></a>

<a name="1236459"></a>

<a name="1236460"></a>

<a name="1236461"></a>

<a name="1236462"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okies, this is not a 'done' deal, needs lots of work still, but posting  for if anyone is interested.<br><br>Managed to get it to swallow a vegetation map(different colors for different plants), my own 3d plant models(quads and combined quads using masked textures rather than alpha) and trees, plus I added a bit of simple wind. <br><br><img src="http://i61.tinypic.com/289f0jm.jpg"><img src="http://i61.tinypic.com/2hq6uxk.jpg"><br><img src="http://i60.tinypic.com/2ewegl1.jpg"><img src="http://i57.tinypic.com/24lsdg6.jpg"><br><br><br>I found on my system(NVIDIA GeForce 8400M GS) the code with trees added to it does about ~30FPS with debug disabled, which leaves too few FPS to be usable in a dynamic game, so kicked it to the curve and put it on hold(for now). (the version without trees, which wasn't updated with other features is doing about 60FPS).<br><br>I'm sure better skilled coders could do a much better job. Probably can be optimized and trees should be handled by separate piece of code for speed gain. Dunno how much can be gained though(I'll see when I have the time).<br><br>Foliage V0.031.bb (without trees, more bushes and higher FPS)<br>Foliage V0.12g.bb (with trees and other features, lower FPS)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Grass rendering algorhytm by Matt Merkulov
;Adapted to suit loaded heightmaps/texturing and allow larger scaling.
;Modularized.
;
;To Do: 
;x abillity to load custom 3d grass/bush models: done, extended to 3 models.
;x grass/bush map: first add ability to selectively add types of grass/bush for different heights.
;x Added bushmap.        
;! Ability to have multiple densities and scales for different grasstypes.
;  Try cilindric grassmodels for certain grasstypes?
;x Waterlelies. horizontal doublesided quad?
;  Seaweed
;  Bushes
;  Grain
;  Berries
;x Trees. Use Tree[d] with animb3d? Using simplified tree worked, but still gave MAV. Try loading in MS3D and lower polycount?
;! Trim down further/ try to introduce more plants first and if same, also some buildings/entities, try within game.
;
;  Let Reed face waterside by checking oposite of height
;
;
;  Make separete layers(meshes) for waterlilies so can move with water, not wind.
;  Also 1 for trees
;  Step1: disable trees in list. same for waterlilies. Check impact om FPS.
;  If higher FPS then put in trees as static objects, then try 3 rowed model of grass?
;    
;
;
;
;        
; COLOR  | COLORVALUE |  HEX      |   RGB        | TYPE
; _____________________________________________________________
; GREEN :  -16711936    FF00FF00    000,255,000    Grass,Bush	x
; YELLOW:  -3584        FFFFF200    255,242,000    Reed			x
; ORANGE:  -32985       FFFF7F27    255,127,039    Grain,Corn
; RED   :  -65536       FFFF0000    255,000,000    Red Berry
; PiNK  :  -20791       FFFFAEC9    255,174,201    Seaweed		x
; LBLUE :  -7039489     FF9495FF    149,149,255    Blue Berry  
; BLUE  :  -16776961    FF0000FF    000,000,255    Bush 
; PURPLE:  -6075996     FFA349A4    163,073,164    Tree Type1 
; BROWN :  -4621737     FFB97A57    185,122,087    Tree Type2 
; DBROWN:  -7645382     FF8B573A    139,078,058    Tree Type3
;
;
;x wind(check other example),
;
;
;Bugs: 
; MAV on using custom loaded 3d grass/bush model: seemed ok now, but reintroduced with trees.
; apperantly appears when 
; Spread of vegetation not always nice, can only do clusters or spread.
; FPS: fully dense population: ~25-45
;
;
;
;
; Workflow for adding texture to B3D file:
; edit texture in  GIMP 
; raise slider of transparency to 25% of right
; new layer, hide prev layer, paint backgr color.
; move up in layer list
; merge down layers
; save as tga.

; in deled:
; import b3d
; copy texture to deled texture folder.
; material editor: remove original material
; add new texture to material, OK
; select all of model.
; select texture to add.
; export as B3D.

; 
;
;
;


.Initialise_Vars
SeedRnd MilliSecs() 


Global ProceduralGfx=False ; set to use in-build terrain generation.
Global Scenery=True

Global LandscapeSize = 512 ;256 ; will change aftr LoadLandscape
Global DitheringTextureSize = 512
Global DitheringTextureScale = 4
;Global LandscapeSizeMask=LandscapeSize - 1
Global LandscapeHeight# = 200; 32
Global LandscapeSizeScale#=8 ;things go wrong soon as above 1, crashes at 8
;Global LandscapeSizeMask# = (LandscapeSize * LandscapeSizeScale) - 1 ;not used?

Global grasstex
Global GrassColor = 100
Global GrassDColor = 20
Global GrassBackground = 100
Global MaxGrassSpreadingRadius# = 0.72;/3 ; min 0.00 - 1.00 max

Dim GreenMapColor(GreenMapSize,GreenMapSize) ; added 


;BUSH LEVELS
Global BushesThreshold#    = 0.0  ;-0.01;displays also below waterline ; -0.05 ;0.28
Global MaxBushesThreshold# = 0.34

Global BushTypesQuantity  = 7     ; original only facilitated in 2 types.
Global BushModelsQuantity = 7     ; Probably only needed for diversity?.
Global BushTextureSize    = 256   ; not needed?

;BUSH SCALES
Global BushModelScaleMin# = 0.03
Global BushModelScaleMax# = 0.06
Global BushModelOverideScale# = 0.5 ; 0.0 disables overidescale


;Used for procedural terrain
Global SandThreshold#  = 0.3
Global HillsMinRadius  = 16
Global HillsMaxRadius  = 64 
Global HillsMinHeight# = 0.2
Global HillsMaxHeight# = 1.0 
Global HillsQuantity#  = 100


;PLAYER 
Global PlayerHeight# = 1.5
Global PlayerSpeedPerSecond# =   10.0   ; 10.0*2
Global PlayerTurnPerSecond#  = 180.0
Global PlayerX#
Global PlayerZ#


;FADER
Global FadingTimeInSeconds# = 1.0;*4
Global MaxAlpha# = 1.0
Global FadingIn  = 1, FadingOut = 2 


;Small grass quadrants - smooth, but slow grass rendering
Global GrassGridCellSize# = 1.0  * LandscapeSizeScale ; 
Global BushesQuantityPerSquare=6 ;6;24 ;12;*2;*5 ; Bushes on one patch. Or i.a.w. density per cluster&lt;&lt;&lt; change upto 24 for denser vegetation clusters
Global GrassRadiusInSquares# = 32;8;16; 32 ; size of the Plant Patches, less size means more visible fading fx and less plants, but increases fps.. 


;Largel grass quadrants - jerky, but fast grass rendering
;Global 
;GrassGridCellSize# = 4.0 * LandscapeSizeScale
;Global BushesQuantityPerSquare = 192
;Global GrassRadiusInSquares# = 8;2


Global GrassGridSize = LandscapeSize * LandscapeSizeScale/ GrassGridCellSize# ;= 512 * 8 / 2.0 *8
Global BushTextureXTexSize# = 1.0 / BushTypesQuantity
Global BushTextureYTexSize# = 1.0 / BushModelsQuantity
Global GrassRadius# = GrassRadiusInSquares# * GrassGridCellSize#
Global grassmap


;ENVIRONMENTAL
Global WaterLevel#=3.0 , water=True 
Global Skybox , sky=True
Global windforce#=0, wind=True


;make Lookup Tables
Dim lcos#(360)
Dim lsin#(360)

For c=0 To 360
	lsin#(c) = Sin(Float c)
Next
For c=0 To 360
	lcos#(c) = Cos(Float c)
Next

;SCREEN
Global screenwidth=1280, screenheight=800, screenmidx=screenwidth/2 , screenmidy=screenheight/2
Graphics3D screenwidth, screenheight,32,1

;CAMERA
Global Camera = CreateCamera()
;CameraRange Camera,0.2,1300 
CameraRange Camera,0.2,2300 
ScaleEntity Camera, 0.3, 0.3, 0.3
PositionEntity Camera, LandscapeSize / 2, 100, LandscapeSize / 2
;RotateEntity Camera, 45, 0, 0
CameraFogMode Camera,1
;CameraFogColor camera,140,140,120
CameraFogColor Camera,240,240,220
;CameraFogColor camera,0,0,256
CameraFogRange Camera,1,1000


;LIGHT
RotateEntity CreateLight(), 45, 45, 0
Global mvx#,mvy#,mvz#,targetpitch#,targetyaw# ; for camcontrols


;GRASS MESH
Type ActiveSquare
	Field X, Z, JustAdded
End Type

Type FadingBush
	Field Alpha#, FadingMode, X, Z
End Type

Type WindSquare
	Field X, Z, degrees#
End Type



Dim ServiceMap(LandscapeSize, LandscapeSize)
Global VisibleActiveSquare = %11
Global InvisibleActiveSquare = %10
Global VisibleSquare = %01
Global InvisibleSquare = %00
Global Visibility = %01
Global Activity = %10

Dim BushModel(BushTypesQuantity - 1, BushModelsQuantity - 1)   ; Array to hold BushModels
Dim BushQuantityMap#(GrassGridSize - 1, GrassGridSize - 1)     ; Array to hold BushQuantity
Dim BushMap(GrassGridSize - 1, GrassGridSize - 1)              ; Array to hold BushMap
Dim BushFader.FadingBush(GrassGridSize - 1, GrassGridSize - 1) ; Array to hold Fader
Global m,m2 ;makes no difference


;Global Landscape = CreateTerrain(LandscapeSize)
Global LandscapeTexture = CreateTexture(LandscapeSize, LandscapeSize, 15) ;procedural
Global LandscapeDitheringTexture = CreateTexture(DitheringTextureSize, DitheringTextureSize, 15)
Global Grass = CreateTexture(BushTextureSize * BushTypesQuantity, BushTextureSize * BushModelsQuantity, 13)

.Setup



;ScaleEntity Landscape,LandscapeSizeScale# , LandscapeHeight#, LandscapeSizeScale#



;LANDSCAPE
;CreateLandscape 
Global Landscape ; = CreateTerrain(LandscapeSize)

;Procedural or loading terrain
If ProceduralGfx=True
	LandscapeSizeScale#=1 : LandscapeHeight#=32 : BushesThreshold# = 0.28:MaxBushesThreshold# = 1.0

    Landscape = CreateTerrain(LandscapeSize)
	CreateLandscape ; Create procedural terrain.
	ScaleEntity Landscape,LandscapeSizeScale# , LandscapeHeight#, LandscapeSizeScale#
	PaintTextures() ; Paint the actual texture created with PaintLandscape()
Else
	LoadLandscape()
	ScaleEntity Landscape,LandscapeSizeScale# , LandscapeHeight#, LandscapeSizeScale#
	LoadLandscapeTexture() ;
EndIf

;TEST MODEL
;		BB=LoadMesh("BushHolder.b3d")
;		ScaleEntity BB,0.5,0.5,0.5
;		grasstex=LoadTexture ("RS15v2_bill.jpg",4)
;		EntityTexture BB,grasstex
;		EntityFX BB, 16
;		EntityAlpha BB, 0.20
;	    PositionEntity BB,338,3.7,280
			

		
; CREATE BUSHES				
TextureFilter "",4;+256 ; Using Black masking for transparency rather than Alpha to avoid z-order issues.
;TextureFilter(BBTex, 1 + 2 + 8 + 16 + 32)
CreateBushes() ; generate our bushes and bush map.

; At cam's x,y,z (so what cam is looking at) take from these positions / grassgridcellsize add the grassgridcell(active square)
; if not done, there will be nothing to show
TryToAddSquare EntityX(Camera) / GrassGridCellSize#, EntityZ(Camera) / GrassGridCellSize#




Global qua ; used for displaying active square#
Global PrevFrameRenderingTimeInSeconds#

; Additional Scenery
If Scenery =True
	CreateWater()
	MakeSkybox()
EndIf


.MainLoop
Repeat

	If KeyDown(200) Or KeyDown(208) Or KeyDown(203) Or KeyDown(205) &lt;&gt;0
		MoveEntity Camera, 0, 0, PrevFrameRenderingTimeInSeconds# * PlayerSpeedPerSecond# * (KeyDown(200) - KeyDown(208))
		TurnEntity Camera, 0, PrevFrameRenderingTimeInSeconds# * PlayerTurnPerSecond# * (KeyDown(203) - KeyDown(205)), 0
	Else 
	 	MouseTurn2(Camera)
	EndIf
	

	PlayerX# = EntityX(Camera)
	PlayerZ# = EntityZ(Camera)
	PositionEntity Camera, PlayerX#, TerrainY#(Landscape, PlayerX#, 0, PlayerZ#) + PlayerHeight#, PlayerZ#
	If Scenery=True
		PositionEntity Skybox,EntityX(Camera),EntityY(Camera),EntityZ(Camera) 
	EndIf
	FrameBeginningTime = MilliSecs()



UpdateBush() ; speaks for itselves.

If wind=True Then UpdateWind()

	RenderWorld

	;Stop

	If FPSCounterResetTime &lt;= MilliSecs() Then
		FPSCounterResetTime = MilliSecs() + 1000
		FPS = FPSCounter
		FPSCounter = 0
	Else
		FPSCounter = FPSCounter + 1
	End If
	Text 0, 0, "Frames / sec:" + FPS + ", activesquares: " + qua
	Text 0,20, "windforce: "+ windforce#


	ScreenshotTaker()



	Flip

	PrevFrameRenderingTimeInSeconds# = 0.001 * (MilliSecs() - FrameBeginningTime)
Until KeyHit(1)

For X = 0 To GrassGridSize - 1
	For Y = 0 To GrassGridSize - 1
		If BushMap(X, Y) Then FreeEntity BushMap(X, Y)
	Next
Next

FreeEntity  Landscape
FreeTexture LandscapeTexture
FreeTexture LandscapeDitheringTexture

Function CreateLandscape()
	SetBuffer FrontBuffer()
	Text 0, 0, "Generating landscape..."
	For n = 1 To HillsQuantity
		HillRadius = Rnd(HillsMinRadius, HillsMaxRadius)
		HillX = Rand(0, LandscapeSize)
		HillY = Rand(0, LandscapeSize)
		HillHeight# = Rnd(HillsMinHeight#, HillsMaxHeight#)

		If -HillRadius &lt; -HillX Then DXFrom = -HillX Else DXFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillX Then DXTo = LandscapeSize - HillX - 1 Else DXTo = HillRadius
		If -HillRadius &lt; -HillY Then DYFrom = -HillY Else DYFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillY Then DYTo = LandscapeSize - HillY - 1 Else DYTo = HillRadius

		For DY = DYFrom To DYTo
			For DX = DXFrom To DXTo
				X = HillX + DX
				Y = HillY + DY
				K# = Sqr(DX * DX + DY * DY) / HillRadius
				If K# &gt; 1.0 Then K# = 1.0
				Height# = 0.5 * (1.0 + Cos(180.0 * K#)) * HillHeight# * HillRadius / 64
				If Height# &gt; TerrainHeight#(Landscape, X, Y) Then ModifyTerrain Landscape, X, Y, Height#
			Next
		Next
	Next
	
	

	SetBuffer FrontBuffer()
	Text 0, 10, "Painting landscape..."
	SetBuffer TextureBuffer(LandscapeTexture)
	For Y = 0 To LandscapeSize - 1
		For X = 0 To LandscapeSize - 1
			If TerrainHeight#(Landscape, X, Y) &gt; SandThreshold# Then
				WritePixel X, Y, $FF00FF00
			Else
				WritePixel X, Y, $FFFFFF00
			End If
		Next
	Next
End Function

Function PaintTextures()
	ScaleTexture LandscapeTexture, LandscapeSize, -LandscapeSize
	TerrainShading Landscape, True

	ScaleTexture LandscapeDitheringTexture, DitheringTextureScale, DitheringTextureScale
	SetBuffer TextureBuffer(LandscapeDitheringTexture)
	For Y = 0 To DitheringTextureSize
		For X = 0 To DitheringTextureSize
			WritePixel X, Y, (Rand(96,160) * $010101) Or $FF000000
		Next
	Next

	EntityTexture Landscape, LandscapeDitheringTexture
	EntityTexture Landscape, LandscapeTexture, 0, 1
	TextureBlend LandscapeTexture, 2
End Function

Function CreateBushes()
    

	;SetBuffer BackBuffer()
	SetBuffer FrontBuffer()
	Text 0, 20, "Creating Meshes..."

	SetBuffer TextureBuffer(Grass) ;set texture buffer to grass texture created earlier with a size of (BushTextureSize * BushModelsQuantity) * (BushTextureSize * BushTypesQuantity). 

	
	
    ; removed procedural gfxcode
    ;LOAD PLANT MODELS INTO ARRAY
	For n1 = 0 To BushTypesQuantity - 1 ; ammount of different bushtypes
		For n2 = 0 To BushModelsQuantity - 1 ; ammount of bushes
			
			m = CreateMesh()
			s = CreateSurface(m) ; s is a surface of mesh m
			
;--GRASS-----------------------------------------------------------------------------------------
			If n1 = 0 Then  ; if counter n1= 0 then bushtype 1, which is a grass(hay) model.
				; Create bushtype 1 with 8 quads012
				; Instead of above in-code creation of bush entity LoadMesh
				;=LoadMesh("Grass_Equatic.b3d")
				m=LoadMesh("Grass_Hay\Grass_Hay4.b3d")
				; using tga, jpg = nogo, in gimp transp slider to right-1. Next: try to left?
				; slider to 
				ScaleEntity m,0.001,0.001,0.001	
				;grasstex=LoadTexture ("Grass_Hay\gras-long-dry-diff3.jpg",4)
				;EntityTexture m,grasstex
				
			ElseIf n1=1 ;if counter n1= 1 then bushtype 2, which is a grass model. 
				; Create bushtype 3 with 4 quads
				; Instead of above in-code creation of bush entity LoadMesh
				m=LoadMesh("Grass\Grass.b3d")
				ScaleEntity m,0.005,0.005,0.005
				;grasstex=LoadTexture ("Grass\grass5f.png",4)
				;EntityTexture m,grasstex
				
;--BUSH------------------------------------------------------------------------------------------	
			ElseIf n1=2 ;if counter n1= 2 then bushtype 3, which is a bush model. 
				; Create bushtype 2 with 4 quads
				; Instead of above in-code creation of bush entity LoadMesh
				m=LoadMesh("Bush1\Bush1c.b3d") ; a. slider to right-1.: clean edges,jagged edges
				                               ; b. slider to left    : rounded edges but artefacts
				                               ; c. slider to 25% from right, most pretty.*
				                               ; d. slider to 50%
				ScaleEntity m,0.005,0.005,0.005
				;grasstex=LoadTexture ("Bush1\RS15v2_bill.jpg",4)
				;EntityTexture m,grasstex				
				
;--EQUATIC---------------------------------------------------------------------------------------				
			ElseIf n1=3 ;if counter n1=3 then bushtype 4, which is a reed model. 
				; Create bushtype 3 with 4 quads			
				; Instead of above in-code creation of bush entity grass e
				m=LoadMesh("Grass_Reed\Grass_Equatic.b3d")
				ScaleEntity m,0.005,0.005,0.005
				;grasstex=LoadTexture ("Grass_Reed\plant_36.tga",4)
				;EntityTexture m,grasstex	
				
				
			ElseIf n1=4 ;if counter n1= 4 then bushtype 5, which is a waterlilly model.  
				; Create bushtype 4 with 1 double sided quad
				; Instead of above in-code creation of bush entity LoadMesh
				m=LoadMesh("Plant_Waterlilly\Plant_WaterLillyLeaf.b3d")
				ScaleEntity m,0.002,0.002,0.002
				;grasstex=LoadTexture ("Grass_Reed\plant_36.tga",4)
				;EntityTexture m,grasstex	
				
				
			ElseIf n1=5 ;if counter n1= 5 then bushtype 6, which is a WaterlillyBloom model.
				; Create bushtype 5 with 1 double sided quad and 2 doublesided bloom quads
				; Instead of above in-code creation of bush entity LoadMesh
				m=LoadMesh("Plant_Waterlilly\Plant_WaterLillyBloom2.b3d")
				ScaleEntity m,0.002,0.002,0.002
				;grasstex=LoadTexture ("Grass_Reed\plant_36.tga",4)
				;EntityTexture m,grasstex
				
;--TREES------------------------------------------------------------------------------------------		
			ElseIf n1=6 ;if counter n1= 6 then bushtype 7, which is a Tree model.  
				; Create bushtype 6
				; Instead of above in-code creation of bush entity LoadMesh
				;m=LoadMesh("Tree\Grass4.b3d")
				m=LoadMesh("Tree\GoodTree2L.b3d")
				
				
			End If		
	
	       ;BushModel(  2(amount of different bushtypes) , 2 (amount of bushes)
		   ;BushModel( 0 to BushTypesQuantity-1 , 0 to BushModelsQuantity-1  ) = m(odel)
			BushModel(n1, n2) = m ;fill aray BushModel(n1,n2) with mesh m which consists out of .. differnt types now.
			
			HideEntity m

			
		Next
		
	Next
	
	;end of BushModel(n1,n2) array creation(list of plant entitties).
    ;now place them as mesh m into array BushMap(x,z).


	;====== LOAD GRASSMAP ==========

    grassmap=LoadImage("gmap.png");	
	flip_vertical(grassmap)
	gmpw=ImageWidth(grassmap)
	gmph=ImageHeight(grassmap)
	;===============================

	SetBuffer FrontBuffer() ; change to buffer to front and whipe clean with white color.
	Color 255, 255, 255 ; set to white
	Text 0, 30, "Generating grass squares (it might take some more time)..."

	;Create Grassgrid(put bushes created above onto an area of predetermined size


	; create grassgrid of preset size  which is LandscapeSize * LandscapeSizeScale/ GrassGridCellSize#{= 2.0  * LandscapeSizeScale}

	For Z = 0 To GrassGridSize - 1 
		For X = 0 To GrassGridSize - 1 ; = LandscapeSize * LandscapeSizeScale/ GrassGridCellSize# ;= 512 * 8 / 2.0 *8 =16384M=16KM


		
			m = CreateMesh(); create new mesh to hold bushmodeltypes at x,y,z of terrain mesh.
			
			;mtex=LoadTexture ("RS15v2_bill.jpg",4)
			;EntityTexture m,mtex
				
			EX# = X * GrassGridCellSize#
			EZ# = Z * GrassGridCellSize#
			EH# = TerrainY(Landscape, EX#, 0, EZ#) ;Landscape TerrainY(height at grassgrid location ex, ez)
			

			
			For n3 = 1 To BushesQuantityPerSquare  ; puting bushes of preset quantity per square

				Repeat
					DX# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					DZ# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					If  Sqr(DX# * DX# + DZ# * DZ#) &lt;= MaxGrassSpreadingRadius# Then
						LX# = DX# * GrassGridCellSize# + EX#
						LZ# = DZ# * GrassGridCellSize# + EZ#
						LH# = TerrainY(Landscape, LX#, 0, LZ#)
						DH# = LH# - EH#
						
						
						Height# = LH# / LandscapeHeight#  ;current height devided by heightscale(=200) so getting to use with %?
						
	
				
						GrassMapZ=Z*GrassGridCellSize / LandscapeSizeScale
						GrassMapX=X*GrassGridCellSize / LandscapeSizeScale
						SetBuffer(ImageBuffer(grassmap))
						LockBuffer(ImageBuffer(grassmap))
						rgb=ReadPixelFast(GrassMapX,GrassMapZ,ImageBuffer(grassmap))	
						UnlockBuffer(ImageBuffer(grassmap))	
							
						
						;Red   =				
						;Green = -16711936
						;Blue  =
		
						; Put 3 random bushtypes
						
						
						If Height# &gt; BushesThreshold#+0.013  And Height# &lt; MaxBushesThreshold# And rgb=-16711936 Then  ;And mapcolor=green1  Then put bushtype1(not rnd as below or just pick from certain types))  
							;Stop
							Quantity# = 1.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
 							If Rnd(1) &lt; Quantity# Then

                                ;pick random bush from stock ( array of 3 at moment) 
								m2 = CopyMesh(BushModel(Rand(0, BushTypesQuantity - 5), Rand(0, BushModelsQuantity - 1)))
								
								;randomize bushmodels width and height scales between min and max scales.
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY#  = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								
								;Allign to the terrain 
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								
								AlignToVector m2, -DY1#, 1.0, -DY2#, 2
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#;/5
								
								;Resize globally (if desired)
								If BushModelOverideScale# &gt; 0.0 Then
									ScaleMesh m2,BushModelOverideScale# ,BushModelOverideScale# ,BushModelOverideScale#  	; if wanna keep them all withiin certain size..
							    EndIf
							
							    s = GetSurface(m2, 1) ; try to get surfce 1 from modeltype m2		
								
								;Index should be in the range 1...CountSurfaces( mesh ), inclusive. 
								;You need To 'get a surface', i.e. get its Handle, in order To be able To Then use 
								;that particular surface with other commands. 

							
							
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0 ; set the normal, not used?
								Next
								
								;put bush onto terrain 								
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2) ;
								PositionMesh m2, DX# * GrassGridCellSize#, DH#, DZ# * GrassGridCellSize#
								
								;copy bushmodel m2 to grassgrid mesh m
								AddMesh m2, m ;
								FreeEntity m2
								
							End If
							
						End If	
						
						
						; When mapcolor is Yellow and around water levels put Reed
						
							
						If Height# &gt; BushesThreshold#+0.013 And Height# &lt; 0.018 And rgb=-3584  Then  ;And mapcolor=Yellow Then put bushtype1(not rnd as below or just pick from certain types))  
							;Stop
							;          = 1.0 *  (Height# say 2.0 - 0.5) / (4.0 - 0.5)
							;                             1.5 / 3.5            
							Quantity# = 100.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
 							If Rnd(1) &lt; Quantity# Then

                                ;pick bush from stock ( array of 1-4 x 1-2 at moment) 
								
								;m2 = CopyMesh(BushModel(Rand(0, BushTypesQuantity - 2), Rand(0, BushModelsQuantity - 1) ))
								
								m2 = CopyMesh(BushModel(3, 0))
								
								;randomize bushmodels width and height scales between min and max scales.
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								
								;Allign to the terrain 
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								
								AlignToVector m2, -DY1#, 1.0, -DY2#, 2
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#;/5
								
								If BushModelOverideScale# &gt; 0.0 Then
									ScaleMesh m2,BushModelOverideScale# ,BushModelOverideScale# ,BushModelOverideScale#  	; if wanna keep them all withiin certain size..
							    EndIf
							
							    s = GetSurface(m2, 1) ; try to get surfce 1 from modeltype m2		
							
								;Index should be in the range 1...CountSurfaces( mesh ), inclusive. 
								;You need To 'get a surface', i.e. get its Handle, in order To be able To Then use 
								;that particular surface with other commands. 

							
							
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0 ; set the normal, not used?
								Next
								
								;put bush onto terrain 								
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2) ;
								;PointEntity m2, Camera 
								PositionMesh m2, DX# * GrassGridCellSize#, DH#, DZ# * GrassGridCellSize#
								
								;copy bushmodel m2 to grassgrid mesh m
								AddMesh m2, m ;
								FreeEntity m2
								
							End If

						End If	
							
						


						; When mapcolor is Pink and on waterlevel put waterlilly.
						; PiNK  :  -20791       FFFFAEC9    255,174,201    Waterlilly
			


                        ; 0-6    0,1,2= grass , 3=reed, 4,5=waterlillies, 6 Tree



						; Put 2 random waterplant types
						
						If Height#=&lt;BushesThreshold#+0.015 And rgb=-20791 Then  							;Stop
						    PlantType=5
							Quantity# = 100.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
 							If Rnd(1) &lt; Quantity# Then


				                ;limit the ammount of flowers 
								modelindxX=Rand(5, BushTypesQuantity -4)
								modelindxY=Rand(0, BushModelsQuantity - 1)
								If prevmodelindxX=5 Then 
									modelindxX=4
								EndIf
								prevmodelindxX=modelindxX
										

								m2 = CopyMesh(BushModel(modelindxX,modelindxY ))
								
						
								;randomize bushmodels width and height scales between min and max scales.
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY#  = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								
								;Allign to the terrain 
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								
								;AlignToVector m2, -DY1#, 1.0, -DY2#, 2 ; disabled for plants on watersurface.
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#;/5
								
								;Resize globally (if desired)
								If BushModelOverideScale# &gt; 0.0 Then
									ScaleMesh m2,BushModelOverideScale# ,BushModelOverideScale# ,BushModelOverideScale#  	; if wanna keep them all withiin certain size..
							    EndIf
							
							    s = GetSurface(m2, 1) ; try to get surfce 1 from modeltype m2		
							
								;Index should be in the range 1...CountSurfaces( mesh ), inclusive. 
								;You need To 'get a surface', i.e. get its Handle, in order To be able To Then use 
								;that particular surface with other commands. 

							
							
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0 ; set the normal, not used?
								Next
								
								;put bush onto terrain 								
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2) ;
								PositionMesh m2, DX# * GrassGridCellSize#, DH#+(WaterLevel#-LH#)+0.02, DZ# * GrassGridCellSize#
								
								
								;copy bushmodel m2 to grassgrid mesh m
								AddMesh m2, m ;
								FreeEntity m2
								
							End If
							
						End If	; End Waterplants


						; Trees
						; BROWN :  -4621737     FFB97A57    185,122,087    Tree Type2    
						; When mapcolor is Brown and around water levels put Brown						
							
							
						If Height# &gt; BushesThreshold#+0.013 And Height# &lt; 0.5 And rgb=-4621737  Then  ;And mapcolor=Brown Then put bushtype1(not rnd as below or just pick from certain types))  
							;Stop
							;          = 1.0 *  (Height# say 2.0 - 0.5) / (4.0 - 0.5)
							;                             1.5 / 3.5            
							Quantity# = 1.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
 							If Rnd(1) &lt; Quantity# Then

                                ;pick bush from stock ( array of 1-4 x 1-2 at moment) 
								
								;m2 = CopyMesh(BushModel(Rand(0, BushTypesQuantity - 2), Rand(0, BushModelsQuantity - 1) ))
								
								m2 = CopyMesh(BushModel(6, 0))
								
								;randomize bushmodels width and height scales between min and max scales.
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								
								;Allign to the terrain 
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								
								;AlignToVector m2, -DY1#, 1.0, -DY2#, 2
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#;/5
								
							 	 If BushModelOverideScale# &gt; 0.0 Then
							 		;ScaleMesh m2,BushModelOverideScale# ,BushModelOverideScale# ,BushModelOverideScale#  	; if wanna keep them all withiin certain size..
   							 		ScaleMesh m2,10 ,10 ,10  	; if wanna keep them all withiin certain size..

							    EndIf
							
							    s = GetSurface(m2, 1) ; try to get surfce 1 from modeltype m2		
							
								;Index should be in the range 1...CountSurfaces( mesh ), inclusive. 
								;You need To 'get a surface', i.e. get its Handle, in order To be able To Then use 
								;that particular surface with other commands. 

							
							
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0 ; set the normal, not used?
								Next
								
								;put bush onto terrain 								
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2) ;
								PositionMesh m2, DX# * GrassGridCellSize#, DH#-0.1, DZ# * GrassGridCellSize#
								
								;copy bushmodel m2 to grassgrid mesh m
								AddMesh m2, m ;
								FreeEntity m2
								
							End If

						End If	

						
						
						
						Exit
					End If
				Forever
			Next
			
			
				
			;fill array BushMap(GrassGridSize - 1, GrassGridSize - 1) with  mesh m  which contains the bushmodel at x,y of grassgrid
			BushMap(X, Z) = m
			PositionEntity m, EX#, EH#, EZ#
		    ;EntityFX m, 16 ; disable backface culling
		    ;put curremt grasstexture on mesh m.
		    ;EntityTexture m, Grass ; ;grass= CreateTexture(BushTextureSize * BushTypesQuantity, BushTextureSize * BushModelsQuantity, 13)
		
			
			HideEntity m
			EntityAlpha m, 0.0 ; set grassgrid mesh's transperancy to 0,0(fully transparent) so wont be seen
			
		Next ; x
	Next ;z

	
    ;free up waste from memory
	If grassmap&lt;&gt;0 Then
		FreeImage grassmap:grassmap=0
	EndIf 
	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			FreeEntity BushModel(n1, n2)
		Next
	Next
End Function

Function CreateQuad(Surface, X1#, Y1#, X2#, Y2#, XTex#, YTex#, DX# = 0, DY# = 0)
	XTex# = XTex# * BushTextureXTexSize#
	YTex# = YTex# * BushTextureYTexSize#
	v1 = AddVertex(Surface, X1#, 0, Y1#, XTex#, YTex# + BushTextureYTexSize#)
	v2 = AddVertex(Surface, X1# + DX#, 1, Y1# + DY#, XTex#, YTex#)
	v3 = AddVertex(Surface, X2# + DX#, 1, Y2# + DY#, XTex# + BushTextureYTexSize#, YTex#)
	v4 = AddVertex(Surface, X2#, 0, Y2#, XTex# + BushTextureYTexSize#, YTex# + BushTextureYTexSize#)
	AddTriangle Surface, v1, v2, v3
	AddTriangle Surface, v3, v4, v1
End Function

Function TryToAddSquare(X, Z)
;First time run:
; At cam's x,y,z (so what cam is looking at) take from these positions / grassgridcellsize add the grassgridcell(active square)
; if not done, there will be nothing to show
; TryToAddSquare EntityX(Camera) / GrassGridCellSize#, EntityZ(Camera) / GrassGridCellSize#

	S.ActiveSquare = New ActiveSquare
	S\X = X
	S\Z = Z
	S\JustAdded = True
	
; Now also add this ActiveSquare to WindSquare to initialize	
	W.WindSquare = New WindSquare ; Fields: X, Z, degrees
	W\X = X
	W\Z = Z
	W\degrees# = 36
End Function
  
Function ExpandSquare(S.ActiveSquare) ; add new square if within limits of grassgrid map
	If S\X &gt; 0 Then TryToAddSquare S\X - 1, S\Z 
	If S\X &lt; GrassGridSize - 1 Then TryToAddSquare S\X + 1, S\Z
	If S\Z &gt; 0 Then TryToAddSquare S\X, S\Z - 1
	If S\Z &lt; GrassGridSize - 1 Then TryToAddSquare S\X, S\Z + 1
End Function

Function CountNeighbors(S.ActiveSquare, NeighborType) ; check if within visible range them add a grassgrid cell
	If S\X &gt; 0 Then If (ServiceMap(S\X - 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\X &lt; GrassGridSize - 1 Then If (ServiceMap(S\X + 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &gt; 0 Then If (ServiceMap(S\X, S\Z - 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &lt; GrassGridSize - 1 Then If (ServiceMap(S\X, S\Z + 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	Return SquaresQuantity
End Function


Function UpdateBush()

	SetBuffer TextureBuffer(LandscapeTexture)
	qua = 0 ; reset ActiveSquare's counter for display later. ActiveSquares are the squares that need to be altered(faded in/out)
	
	For S.ActiveSquare=Each ActiveSquare ; walk through all objects in S.ActiveSquare. &lt;-Type contains Fields: X, Z, JustAdded

		tmp = ServiceMap(S\X, S\Z)
		If (ServiceMap(S\X, S\Z) And Activity) = Activity And S\JustAdded Then ;Activity=10% ? no clue..
	 		Delete S
		Else
			S\JustAdded = False ; set to not added just before.
			Dist# = EntityDistance(BushMap(S\X, S\Z), Camera)
			;Stop
			If Dist# &gt; GrassRadius# Then; if outside our display radius then

				If (ServiceMap(S\X, S\Z) And Visibility) = VisibleSquare Then ; fade out in/visible bushmodels.
					ExpandSquare S ; expand S(quare) if within limits,
					;If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FF00FFFF
					If BushMap(S\X, S\Z) Or GrassMethod = MethodHide Then ; if map has value(so a bushmodel) on x,z or hiden then 
						If BushFader(S\X, S\Z) &lt;&gt; Null Then  ; if fading already then continue bushfading on x,z
							FB.FadingBush = BushFader(S\X, S\Z)
						Else ; if not fading yet, start new fading process on bushmodel.
							FB.FadingBush = New FadingBush
							FB\X = S\X
							FB\Z = S\Z
							FB\Alpha# = MaxAlpha#
							BushFader(S\X, S\Z) = FB
						End If
						FB\FadingMode = FadingOut
					End If
					ServiceMap(S\X, S\Z) = InvisibleActiveSquare
				Else
					If CountNeighbors(S, VisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = InvisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = InvisibleActiveSquare
					End If				
				End If
				
			Else ; if not outside our display radius.
			
				If (ServiceMap(S\X, S\Z) And Visibility) = InvisibleSquare Then ; fade in visible bushmodels.
					ExpandSquare S
					;If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FFFF0000
					ServiceMap(S\X, S\Z) = VisibleActiveSquare
					S\JustAdded = False
					ShowEntity BushMap(S\X, S\Z)				
					If BushFader(S\X, S\Z) &lt;&gt; Null Then
						FB.FadingBush = BushFader(S\X, S\Z)			
					Else
						FB.FadingBush = New FadingBush
						FB\X = S\X
						FB\Z = S\Z
						FB\Alpha# = 0.0
						BushFader(S\X, S\Z) = FB
					End If
					FB\FadingMode = FadingIn
				Else
					If CountNeighbors(S, InvisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = VisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = VisibleActiveSquare
					End If
				End If
			End If
		End If
	Next

	DFading# = PrevFrameRenderingTimeInSeconds# / FadingTimeInSeconds#
	For FB.FadingBush = Each FadingBush
		A# = FB\Alpha#
		If FB\FadingMode = FadingIn Then
			A# = A# + DFading#
			If A# &gt; MaxAlpha# Then A# = MaxAlpha#
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = MaxAlpha# Then Delete FB
		Else
			A# = A# - DFading#
			If A# &lt; 0.0 Then A# = 0.0
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = 0.0 Then
				HideEntity BushMap(FB\X, FB\Z)
				BushFader(FB\X, FB\Z) = Null
				Delete FB
			End If
		End If
	Next

	For S.ActiveSquare=Each ActiveSquare
		qua = qua + 1
	Next
	
	SetBuffer BackBuffer()
	
End Function



;A simple wind function
Function UpdateWind()

	For W.WindSquare=Each WindSquare
	
	
		If BushMap(W\X,W\Z) &lt;&gt; 0 Then
		
			;x#=+lsin(wind)/10.0
			Windz#=lcos(windforce);*5.0
			r=Rnd(15)
			RotateEntity BushMap(W\X+r,W\Z+r), 0,0,Windz#	
		EndIf
		
	Next	
	
	windforce#=windforce#+1.0
	If windforce=360.0 Then 
		windforce=0.0
	EndIf
	
End Function



Function UpdateWind2()

	;x#=+lsin(wind)/10.0
	Windz#=lcos(windforce)*5.0
	r=Rnd(15)
			
	For W.WindSquare=Each WindSquare
		If BushMap(W\X,W\Z) &lt;&gt; 0 Then
			RotateEntity BushMap(W\X+r,W\Z+r), 0,0,Windz#	
		EndIf
	Next	
	
	windforce#=windforce#+1.0
	If windforce=360.0 Then 
		windforce=0.0
	EndIf
	
End Function





;Global wind#

;Function Updatewind(grl.girt)
;a.adirt=grl\cache
;wind#=wind#+1.0
;If wind=360.0 wind=0.0
;While a&lt;&gt;Null
;x#=VertexX(grl\surf,a\index)+lsin(wind)/10.0
;y#=VertexY(grl\surf,a\index)
;z#=VertexZ(grl\surf,a\index)+lcos(wind)/10.0
;VertexCoords grl\surf,a\index,x,y,z
;a=a\link
;Wend
	
;End Function




Function LoadLandscape()
		Landscape=LoadTerrain( "blitzhmp512(2a).png" ) ;512x512x256 heightmap so terra_size=512
		EntityFX Landscape,1	
		TerrainDetail Landscape,8000,True ; if set to 1000 then weird fx
End Function

Function LoadLandscapeTexture()
		Landscape_tex=LoadTexture( "blitzhmptext4096(2).png" )		
		ScaleTexture Landscape_tex,512,512
		tex0=LoadTexture( "detailLIGHT.png" )           ; crackedstone (base texture, which shows through at track,
		;ScaleTexture tex0,2,2	
		ScaleTexture tex0,.5,.5	

		EntityTexture Landscape,Landscape_tex;,0,0 ; original terrain
		EntityTexture Landscape,tex0,0,1	 ; crackedstone (detail)
End Function


Function MouseTurn2(cam1) ;(from sunflares demo)
	mxspd# = MouseXSpeed()*0.25
	myspd# = MouseYSpeed()*0.25

	MoveMouse screenmidx,screenmidy

	targetpitch = targetpitch + myspd
	targetpitch = ClampValue(targetpitch, -360,360) ;85
	targetyaw = targetyaw - mxspd	

	cam_pitch = cam_pitch + (targetpitch - cam_pitch)/8.0
	cam_yaw = cam_yaw + (targetyaw - cam_yaw)/8.0
	
	;RotateEntity player,cam_pitch,cam_yaw,0
	RotateEntity cam1,cam_pitch,cam_yaw,0
	
	If MouseDown(2) Then 
		MoveEntity cam1, 0, 0, PlayerSpeedPerSecond# * PrevFrameRenderingTimeInSeconds#

		;CreateProjectile( cam1 )
	EndIf
End Function 

Function ClampValue(Original#, low#, high#) ;belongs to mouseturn2 (from sunflares demo)
	If Original&lt;low  Then Return low
	If Original&gt;high Then Return high
	Return Original
End Function

Function MakeSkybox()
	Skybox=CreateMesh()
	;front face
	b=LoadBrush( "sky_FR.bmp",49 )
	s=CreateSurface( Skybox,b )
	AddVertex s,-1,+1,-1,0,0:AddVertex s,+1,+1,-1,1,0
	AddVertex s,+1,-1,-1,1,1:AddVertex s,-1,-1,-1,0,1
	AddTriangle s,0,1,2:AddTriangle s,0,2,3
	FreeBrush b
	;left face
	b=LoadBrush( "sky_LF.bmp",49 )
	s=CreateSurface( Skybox,b )
	AddVertex s,+1,+1,-1,0,0:AddVertex s,+1,+1,+1,1,0
	AddVertex s,+1,-1,+1,1,1:AddVertex s,+1,-1,-1,0,1
	AddTriangle s,0,1,2:AddTriangle s,0,2,3
	FreeBrush b
	;back face
	b=LoadBrush( "sky_BK.bmp",49 )
	s=CreateSurface( Skybox,b )
	AddVertex s,+1,+1,+1,0,0:AddVertex s,-1,+1,+1,1,0
	AddVertex s,-1,-1,+1,1,1:AddVertex s,+1,-1,+1,0,1
	AddTriangle s,0,1,2:AddTriangle s,0,2,3
	FreeBrush b
	;right face
	b=LoadBrush( "sky_RT.bmp",49 )
	s=CreateSurface( Skybox,b )
	AddVertex s,-1,+1,+1,0,0:AddVertex s,-1,+1,-1,1,0
	AddVertex s,-1,-1,-1,1,1:AddVertex s,-1,-1,+1,0,1
	AddTriangle s,0,1,2:AddTriangle s,0,2,3
	FreeBrush b
	;top face
	b=LoadBrush( "sky_UP.bmp",49 )
	s=CreateSurface( Skybox,b )
	AddVertex s,-1,+1,+1,0,1:AddVertex s,+1,+1,+1,0,0
	AddVertex s,+1,+1,-1,1,0:AddVertex s,-1,+1,-1,1,1
	AddTriangle s,0,1,2:AddTriangle s,0,2,3
	FreeBrush b
	;bottom face	
	;b=LoadBrush( "sky.bmp",49 )
	;s=CreateSurface( skybox,b )
	;AddVertex s,-1,-1,-1,1,0:AddVertex s,+1,-1,-1,1,1
	;AddVertex s,+1,-1,+1,0,1:AddVertex s,-1,-1,+1,0,0
	;AddTriangle s,0,1,2:AddTriangle s,0,2,3
	;FreeBrush b
	ScaleMesh Skybox,10,10,10
	FlipMesh Skybox
	EntityFX Skybox,9
	EntityOrder Skybox,20
End Function

Function CreateWater()
	water=CreatePlane()
	Water_tex=LoadTexture("Water01.jpg")
	ScaleTexture Water_tex,4,4
	EntityTexture water,Water_tex
	EntityAlpha water,0.75
	PositionEntity water,0,WaterLevel#,0
	UnderWater=CopyEntity (water)
	RotateEntity UnderWater,180,0,0 

End Function
End


Function ScreenshotTaker()
	If KeyHit(14) = 1;Backspace
		For w = 1 To 100
			name$ = "screenshot" + w + ".bmp"
			If FileType(name$) = 0
				If done = 0
					SaveBuffer(FrontBuffer(), name$)
					done = 1
				EndIf
			EndIf
		Next
	EndIf
	done = 0	
End Function

Function ooooooFoliagMapStuffoooooo()
End Function


Function FoliageMapLoad(greenmap) ; initial pseudo code ideas.
; ex: "path\folliagemap.jpg" needs to be same resolution and pic as terrain heightmap but with green on it.

	green_tex=LoadTexture( greenmap ) ; load text
	ScaleTexture green_tex,TerrainWidthScale,TerrainWidthScale  ; scale to heightmapsize, wont do that internally in buffer so need calculate possition using scale?
	
	GreenMapSize=TextureWidth (green_tex)*TerrainWidthScale ; see above, we're going from a square image so only need width as height is same.
	
	;Dim GreenMapColor(GreenMapSize,GreenMapSize) ;set up an array to hold the color data, must be setup in main program.
	
	SetBuffer TextureBuffer(green_tex)
	For GreenMapX=0 To  GreenMapSize 
		For GreenMapY=0 To GreenMapSize
			GreenMapColor(GreenMapX,GreenMapY)=ReadPixel(GreenMapX, GreenMapY)
		Next
	Next	
End Function


Function FoliageMapRead(PlayerX,PlayerZ,VisibleRange) ; pseudo code to readmap arround playerslocation.. needs work


	For CheckedArea=0 To VisibleRange
	
		CurrentGreenMapColor=GreenMapColor(PlayerX+Area,PlayerZ+area) ;scale needs to be added?
	
		If     CurrentGreenMapColor=Green1 Then	; grasstype1(lowgrass) 
			PlantType=grasstype1
				
		ElseIf CurrentGreenMapColor=Green2	; grasstype2(mediumgrass)
			PlantType=grasstype2
		
		ElseIf CurrentGreenMapColor=Green3	; grasstype3(highgrass)
			PlantType=grasstype3
	
	
	
		ElseIf CurrentGreenMapColor=Yellow1	; planttype1(fern)
			PlantType=planttype1
	
		ElseIf CurrentGreenMapColor-Yellow2	; planttype2(herb1) 
			PlantType=planttype2
	
		ElseIf CurrentGreenMapColor-Yellow3	; planttype3(herb2) 
			PlantType=planttype3
	
	
	
		ElseIf CurrentGreenMapColor=Orange1	; veggietype1(grane) 
			PlantType=veggietype1
			
		ElseIf CurrentGreenMapColor=Orange2	; veggietype2(blueberry)
		 	PlantType=veggietype2
		
		ElseIf CurrentGreenMapColor=Orange3	; veggietype3(redberry)
			PlantType=veggietype3
		
	
	
		ElseIf CurrentGreenMapColor=Red1		; bushtype1(lowbush)
			PlantType=bushtype1
	
		ElseIf CurrentGreenMapColor=Red2		; bushtupe2(mediumbush)
			PlantType=bushtype2
	
		ElseIf CurrentGreenMapColor=Red3		; Bushtype3(heighbush)
			PlantType=bushtype3
			
			
	
		ElseIf CurrentGreenMapColor=Brown1	; Treetype1
			PlantType=Treetype1
	
		ElseIf CurrentGreenMapColor=Brown2	; Treetype2	
			PlantType=Treetype2
	
		ElseIf CurrentGreenMapColor=Brown3	; Treetype3
			PlantType=Treetype3
		Else							
	   		PlantType=False				; no plants..
	
		EndIf
	
		If PlantType&gt;False Then
		   PositionEntity PlantType,PlayerX+Area,TerrainHeight(Landscape,PlayerX,PlayerZ),PlayerZ+Area
		EndIf
		
	Next 
	


End Function




;This function is used to flip vertical the grass-map
;This way you get correct placement on the terrain.
Function flip_vertical(img)
	buf=GraphicsBuffer()
	temp=CopyImage(img)
	w=ImageWidth(temp)-1
	h=ImageHeight(temp)-1
	
	LockBuffer(ImageBuffer(img))
	LockBuffer(ImageBuffer(temp))
	
	For x=0 To w
		For y=0 To h
			rgb=ReadPixelFast (x,y,ImageBuffer(temp))
			WritePixelFast x,h-y,rgb,ImageBuffer(img)
		Next
	Next
	
	UnlockBuffer(ImageBuffer(img))
	UnlockBuffer(ImageBuffer(temp))
	
	FreeImage temp
	SetBuffer buf
	Return img
End Function

;---------------------------------------

Function CountPoly(mesh)
	For i=1 To CountSurfaces(mesh)
		n=n+CountTriangles(GetSurface(mesh,i))
	Next
	Return n
End Function





End
;~IDEal Editor Parameters:
;~F#161#18B#358#363#375#37C#3ED#405#42F#435#441#458#45E#490#49E#4AD#4B1#4C4#513#52D
;~C#Blitz3D
</textarea><br><br>Of course some media needed, download here(code included) <a href="https://www.mediafire.com/?yi7xkwql56ukd9j" target="_blank">https://www.mediafire.com/?yi7xkwql56ukd9j</a><br><br>@stayne: as we speak. <br><br></td></tr></table><br>
<a name="1236455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >stayne</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Gad zooks!  Might wanna edit that post. <br><br></td></tr></table><br>
<a name="1236464"></a>

<a name="1236465"></a>

<a name="1236467"></a>

<a name="1236468"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> One way you could decrease the render time and also increase grass density would be to use one pivot and only one quad (4vertices, 2 triangles) for each grass. <br>Then each frame you would be able to rotate the pivot so that it faces the camera and then reposition the vertices at the appropriate position so that the grass is visible by the camera, whatever the camera position orientation. And it would still be a single surface system.<br><br><br>By curiosity, what are you planning to do with this ? <br><br></td></tr></table><br>
<a name="1236471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> The nenuphars add a nice touch, but i think the flower you have put on the plant is an artichoke. ;) <br><br></td></tr></table><br>
<a name="1236475"></a>

<a name="1236476"></a>

<a name="1236477"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RemiD: Decoration in a free roaming environment. I considered that other approach indeed, but I never seen one that gave me a convincing look from all points of view. Also a bit of a shame there are such issues with alpha cos I think was looking way better. <br><br>Just wanted a bush here and there and also to see how far I could push it, but perhaps I can try and see what would look like indeed, won't hurt to try, but not currently working on it due to time restrained. Just put it up cos Hotshot2005 was looking for similar stuff in another thread.<br><br>The 'artisjokes' indeed look very edible. :-) (Gfx where by no means final, just a quick see-what-it-could-look-like) <br><br></td></tr></table><br>
<a name="1236479"></a>

<a name="1236480"></a>

<a name="1236482"></a>

<a name="1236485"></a>

<a name="1236486"></a>

<a name="1236491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here are some simple tweaks made to the code by Matt Merkulov<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Grass rendering algorythm by Matt Merkulov

SeedRnd MilliSecs()

Const LandscapeSize = 256
Const DitheringTextureSize = 512
Const DitheringTextureScale = 4
Const LandscapeSizeMask = LandscapeSize - 1
Const LandscapeHeight# = 25.5

Const GrassColor = 100
Const GrassDColor = 020
Const GrassBackground = 100
Const MaxGrassSpreadingRadius# = 0.72

Const BushesThreshold# = 0.28
Const MaxBushesThreshold# = 0.34
Const SandThreshold# = 0.3
Const HillsMinRadius = 16
Const HillsMaxRadius = 64
Const HillsMinHeight# = 0.2
Const HillsMaxHeight# = 1.0
Const HillsQuantity# = 100

Const BushTypesQuantity = 1
Const BushModelsQuantity = 1
Const BushTextureSize = 256

Const BushModelScaleMin# = 0.3
Const BushModelScaleMax# = 0.6

Const PlayerHeight# = 1.65
Const PlayerSpeedPerSecond# = 10.0
Const PlayerTurnPerSecond# = 180.0

Const FadingTimeInSeconds# = 1.0
Const MaxAlpha# = 1.0



;Small grass quadrants - smooth, but slow grass rendering
Const GrassGridCellSize# = 1.0
Const BushesQuantityPerSquare = 3
Const GrassRadiusInSquares# = 50


;Largel grass quadrants - jerky, but fast grass rendering
;Const GrassGridCellSize# = 8.0
;Const BushesQuantityPerSquare = 192
;Const GrassRadiusInSquares# = 2


Const GrassGridSize = LandscapeSize / GrassGridCellSize#
Const BushTextureXTexSize# = 1.0 / BushTypesQuantity
Const BushTextureYTexSize# = 1.0 / BushModelsQuantity
Const GrassRadius# = GrassRadiusInSquares# * GrassGridCellSize#

Graphics3D 1024, 768,32,2


Camera = CreateCamera()
ScaleEntity camera, 0.3, 0.3, 0.3
PositionEntity Camera, LandscapeSize / 2, 100, LandscapeSize / 2
;RotateEntity Camera, 45, 0, 0


SLight = CreateLight()
LightColor(SLight,250,250,250)
PositionEntity(SLight,0,1000,-1000)
RotateEntity(SLight,45,0,0)

AmbientLight(050,050,050)

Type ActiveSquare
	Field X, Z, JustAdded
End Type

Type FadingBush
	Field Alpha#, FadingMode, X, Z
End Type

Dim ServiceMap(LandscapeSize, LandscapeSize)
Const VisibleActiveSquare = %11
Const InvisibleActiveSquare = %10
Const VisibleSquare = %01
Const InvisibleSquare = %00
Const Visibility = %01
Const Activity = %10

Dim BushModel(BushTypesQuantity - 1, BushModelsQuantity - 1)
Dim BushQuantityMap#(GrassGridSize - 1, GrassGridSize - 1)
Dim BushMap(GrassGridSize - 1, GrassGridSize - 1)
Dim BushFader.FadingBush(GrassGridSize - 1, GrassGridSize - 1)

Global Landscape = CreateTerrain(LandscapeSize)
Global LandscapeTexture = CreateTexture(LandscapeSize, LandscapeSize, 15)
Global LandscapeDitheringTexture = CreateTexture(DitheringTextureSize, DitheringTextureSize, 15)
Global Grass = CreateTexture(BushTextureSize * BushTypesQuantity, BushTextureSize * BushModelsQuantity, 13)
ScaleEntity Landscape, 1, LandscapeHeight#, 1

CreateLandscape

CreateBushes

PaintTextures

TryToAddSquare EntityX(Camera) / GrassGridCellSize#, EntityZ(Camera) / GrassGridCellSize#

Const FadingIn = 1, FadingOut = 2

Repeat
	MoveEntity Camera, 0, 0, PrevFrameRenderingTimeInSeconds# * PlayerSpeedPerSecond# * (KeyDown(200) - KeyDown(208))
	TurnEntity Camera, 0, PrevFrameRenderingTimeInSeconds# * PlayerTurnPerSecond# * (KeyDown(203) - KeyDown(205)), 0

	FrameBeginningTime = MilliSecs()

	PlayerX# = EntityX(Camera)
	PlayerZ# = EntityZ(Camera)
	PositionEntity Camera, PlayerX#, TerrainY#(Landscape, PlayerX#, 0, PlayerZ#) + PlayerHeight#, PlayerZ#

	SetBuffer TextureBuffer(LandscapeTexture)

	qua = 0
	For S.ActiveSquare=Each ActiveSquare
		tmp = ServiceMap(S\X, S\Z)
		If (ServiceMap(S\X, S\Z) And Activity) = Activity And S\JustAdded Then
		 	Delete S
		Else
			S\JustAdded = False
			Dist# = EntityDistance(BushMap(S\X, S\Z), Camera)
			;Stop
			If Dist# &gt; GrassRadius# Then
				If (ServiceMap(S\X, S\Z) And Visibility) = VisibleSquare Then
					ExpandSquare S
					If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FF00FFFF
					If BushMap(S\X, S\Z) Or GrassMethod = MethodHide Then
						If BushFader(S\X, S\Z) &lt;&gt; Null Then
							FB.FadingBush = BushFader(S\X, S\Z)
						Else
							FB.FadingBush = New FadingBush
							FB\X = S\X
							FB\Z = S\Z
							FB\Alpha# = MaxAlpha#
							BushFader(S\X, S\Z) = FB
						End If
						FB\FadingMode = FadingOut
					End If
					ServiceMap(S\X, S\Z) = InvisibleActiveSquare
				Else
					If CountNeighbors(S, VisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = InvisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = InvisibleActiveSquare
					End If
				End If
			Else
				If (ServiceMap(S\X, S\Z) And Visibility) = InvisibleSquare Then
					ExpandSquare S
					If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FFFF0000
					ServiceMap(S\X, S\Z) = VisibleActiveSquare
					S\JustAdded = False
					ShowEntity BushMap(S\X, S\Z)
					If BushFader(S\X, S\Z) &lt;&gt; Null Then
						FB.FadingBush = BushFader(S\X, S\Z)
					Else
						FB.FadingBush = New FadingBush
						FB\X = S\X
						FB\Z = S\Z
						FB\Alpha# = 0.0
						BushFader(S\X, S\Z) = FB
					End If
					FB\FadingMode = FadingIn
				Else
					If CountNeighbors(S, InvisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = VisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = VisibleActiveSquare
					End If
				End If
			End If
		End If
	Next

	DFading# = PrevFrameRenderingTimeInSeconds# / FadingTimeInSeconds#
	For FB.FadingBush = Each FadingBush
		A# = FB\Alpha#
		If FB\FadingMode = FadingIn Then
			A# = A# + DFading#
			If A# &gt; MaxAlpha# Then A# = MaxAlpha#
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = MaxAlpha# Then Delete FB
		Else
			A# = A# - DFading#
			If A# &lt; 0.0 Then A# = 0.0
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = 0.0 Then
				HideEntity BushMap(FB\X, FB\Z)
				BushFader(FB\X, FB\Z) = Null
				Delete FB
			End If
		End If
	Next

	For S.ActiveSquare=Each ActiveSquare
		qua = qua + 1
	Next

	SetBuffer BackBuffer()
	
	RenderWorld

	;Stop

	If FPSCounterResetTime &lt;= MilliSecs() Then
		FPSCounterResetTime = MilliSecs() + 1000
		FPS = FPSCounter
		FPSCounter = 0
	Else
		FPSCounter = FPSCounter + 1
	End If
	Text 0, 0, "Frames / sec:" + FPS + ", activesquares: " + qua

	Flip

	PrevFrameRenderingTimeInSeconds# = 0.001 * (MilliSecs() - FrameBeginningTime)
Until KeyHit(1)

For X = 0 To GrassGridSize - 1
	For Y = 0 To GrassGridSize - 1
		If BushMap(X, Y) Then FreeEntity BushMap(X, Y)
	Next
Next

FreeEntity Landscape
FreeTexture LandscapeTexture
FreeTexture LandscapeDitheringTexture

Function CreateLandscape()
	SetBuffer FrontBuffer()
	Text 0, 0, "Generating landscape..."
	For n = 1 To HillsQuantity
		HillRadius = Rnd(HillsMinRadius, HillsMaxRadius)
		HillX = Rand(0, LandscapeSize)
		HillY = Rand(0, LandscapeSize)
		HillHeight# = Rnd(HillsMinHeight#, HillsMaxHeight#)

		If -HillRadius &lt; -HillX Then DXFrom = -HillX Else DXFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillX Then DXTo = LandscapeSize - HillX - 1 Else DXTo = HillRadius
		If -HillRadius &lt; -HillY Then DYFrom = -HillY Else DYFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillY Then DYTo = LandscapeSize - HillY - 1 Else DYTo = HillRadius

		For DY = DYFrom To DYTo
			For DX = DXFrom To DXTo
				X = HillX + DX
				Y = HillY + DY
				K# = Sqr(DX * DX + DY * DY) / HillRadius
				If K# &gt; 1.0 Then K# = 1.0
				Height# = 0.5 * (1.0 + Cos(180.0 * K#)) * HillHeight# * HillRadius / 64
				If Height# &gt; TerrainHeight#(Landscape, X, Y) Then ModifyTerrain Landscape, X, Y, Height#
			Next
		Next
	Next

	SetBuffer FrontBuffer()
	Text 0, 10, "Painting landscape..."
	SetBuffer TextureBuffer(LandscapeTexture)
	For Y = 0 To LandscapeSize - 1
		For X = 0 To LandscapeSize - 1
			If TerrainHeight#(Landscape, X, Y) &gt; SandThreshold# Then
				;WritePixel X, Y, $FF00FF00
				RandomChoice% = Rand(1,2)
				If(RandomChoice = 1)
 				 Color(000,100,000)
				ElseIf(RandomChoice = 2)
 				 Color(000,080,000)
				EndIf
				Plot(X,Y)
			Else
				;WritePixel X, Y, $FFFFFF00
				Color(100,100,050)
				Plot(X,Y)
			End If
		Next
	Next
End Function

Function PaintTextures()
	ScaleTexture LandscapeTexture, LandscapeSize, -LandscapeSize
	TerrainShading Landscape, True

	ScaleTexture LandscapeDitheringTexture, DitheringTextureScale, DitheringTextureScale
	SetBuffer TextureBuffer(LandscapeDitheringTexture)
	For Y = 0 To DitheringTextureSize
		For X = 0 To DitheringTextureSize
			WritePixel X, Y, (Rand(96,160) * $010101) Or $FF000000
		Next
	Next

	;EntityTexture Landscape, LandscapeDitheringTexture
	;EntityTexture Landscape, LandscapeTexture, 0, 1
	;TextureBlend LandscapeTexture, 2
	TextureBlend(LandscapeTexture,1)
	EntityTexture Landscape, LandscapeTexture,0,0
	
End Function

Function CreateBushes()
	;SetBuffer BackBuffer()
	SetBuffer FrontBuffer()
	Text 0, 20, "Painting textures..."

	SetBuffer TextureBuffer(Grass)
	For Y = 0 To BushTextureSize * BushTypesQuantity - 1
		For X = 0 To BushTextureSize * BushModelsQuantity - 1
			WritePixel X, Y, 256 * GrassBackground
		Next
	Next

	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			
			m = CreateMesh()
			s = CreateSurface(m)
			If n1 = 0 Then
				For nn = 1 To 100 + n2 * 100
					Radius# = Rnd(BushTextureSize / 2, BushTextureSize)
					X = BushTextureSize * (Rnd(0,1) ^ 2 * (Rand(0, 1) * 2 - 1) + 1) * 0.5
					Repeat
						Angle# = Rnd(70, 110)
						X2 = Cos(Angle#) * Radius# + X
						Y2 = BushTextureSize - 1 - Sin(Angle#) * Radius# + n2 * BushTextureSize
					Until X2 &gt;=0 And X2 &lt; BushTextureSize
					For DeltaX = -3 To 3
						Color 0, GrassColor + DeltaX * GrassDColor, 0
						Line X + DeltaX, (n2 + 1) * BushTextureSize - 1, X2, Y2
					Next
				Next
				For nn= 0 To 7
					Angle# = nn * 45
					;CreateQuad s, Cos(Angle# - 45), Sin(Angle# - 45), Cos(Angle# + 45), Sin(Angle# + 45), Cos(Angle#) * 0.75, Sin(Angle#) * 0.75
					CreateQuad s, Cos(Angle#) * 0.5, Sin(Angle#) * 0.5, -Cos(Angle#) * 0.5, -Sin(Angle#) * 0.5, n1, n2, Cos(Angle# + 90), Sin(Angle# + 90)
				Next
			Else
				For nn = 1 To 150 + n2 * 150
					X = Rnd(BushTextureSize * 2 / 5, BushTextureSize * 3 / 5) + BushTextureSize
					Angle# = Rnd(10, 170)
					Radius# = Rnd(0, 1) * (1 - Abs(angle - 90) / 133) *  BushTextureSize
					X2 = Cos(Angle#) * Radius# + BushTextureSize / 2 + BushTextureSize
					Y2 = (n2 + 1) * BushTextureSize - 1 - Sin(Angle#) * Radius# 
					For DeltaX = -3 To 3
						Color 0, GrassColor + DeltaX * GrassDColor, 0
						Line X + DeltaX, (n2 + 1) * BushTextureSize - 1, X2, Y2
					Next
				Next
				For nn = 0 To 3
					Angle# = nn * 45
					xx# = Cos(Angle#)
					yy# = Sin(Angle#)
					CreateQuad s, xx#, yy#, -xx#, -yy#, n1, n2
				Next
			End If
			BushModel(n1, n2) = m
			HideEntity m
		Next
	Next

	SetBuffer FrontBuffer()
	Color 255, 255, 255
	Text 0, 30, "Generating grass squares (it might take some more time)..."

	For Z = 0 To GrassGridSize - 1
		For X = 0 To GrassGridSize - 1
			m = CreateMesh()
			EX# = X * GrassGridCellSize#
			EZ# = Z * GrassGridCellSize#
			EH# = TerrainY(Landscape, EX#, 0, EZ#)
			For n3 = 1 To BushesQuantityPerSquare
				Repeat
					DX# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					DZ# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					If  Sqr(DX# * DX# + DZ# * DZ#) &lt;= MaxGrassSpreadingRadius# Then
						LX# = DX# * GrassGridCellSize# + EX#
						LZ# = DZ# * GrassGridCellSize# + EZ#
						LH# = TerrainY(Landscape, LX#, 0, LZ#)
						DH# = LH# - EH#

						Height# = LH# / LandscapeHeight#
						If Height# &gt; BushesThreshold# Then
							Quantity# = 1.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
							If Rnd(1) &lt; Quantity# Then
								m2 = CopyMesh(BushModel(Rand(0, BushTypesQuantity - 1), Rand(0, BushModelsQuantity - 1)))
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								AlignToVector m2, -DY1#, 1.0, -DY2#, 2
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#
								s = GetSurface(m2, 1)
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0
								Next
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2)
								PositionMesh m2, DX# * GrassGridCellSize#, DH#, DZ# * GrassGridCellSize#
								AddMesh m2, m
								FreeEntity m2
							End If
						End If
						Exit
					End If
				Forever
			Next
			BushMap(X, Z) = m
			PositionEntity m, EX#, EH#, EZ#
			EntityFX m, 16
			EntityTexture m, Grass
			HideEntity m
			EntityAlpha m, 0.0
		Next
	Next

	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			FreeEntity BushModel(n1, n2)
		Next
	Next
End Function

Function CreateQuad(Surface, X1#, Y1#, X2#, Y2#, XTex#, YTex#, DX# = 0, DY# = 0)
	XTex# = XTex# * BushTextureXTexSize#
	YTex# = YTex# * BushTextureYTexSize#
	v1 = AddVertex(Surface, X1#, 0, Y1#, XTex#, YTex# + BushTextureYTexSize#)
	v2 = AddVertex(Surface, X1# + DX#, 1, Y1# + DY#, XTex#, YTex#)
	v3 = AddVertex(Surface, X2# + DX#, 1, Y2# + DY#, XTex# + BushTextureYTexSize#, YTex#)
	v4 = AddVertex(Surface, X2#, 0, Y2#, XTex# + BushTextureYTexSize#, YTex# + BushTextureYTexSize#)
	AddTriangle Surface, v1, v2, v3
	AddTriangle Surface, v3, v4, v1
End Function

Function TryToAddSquare(X, Z)
	S.ActiveSquare = New ActiveSquare
	S\X = X
	S\Z = Z
	S\JustAdded = True
End Function

Function ExpandSquare(S.ActiveSquare)
	If S\X &gt; 0 Then TryToAddSquare S\X - 1, S\Z
	If S\X &lt; GrassGridSize - 1 Then TryToAddSquare S\X + 1, S\Z
	If S\Z &gt; 0 Then TryToAddSquare S\X, S\Z - 1
	If S\Z &lt; GrassGridSize - 1 Then TryToAddSquare S\X, S\Z + 1
End Function

Function CountNeighbors(S.ActiveSquare, NeighborType)
	If S\X &gt; 0 Then If (ServiceMap(S\X - 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\X &lt; GrassGridSize - 1 Then If (ServiceMap(S\X + 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &gt; 0 Then If (ServiceMap(S\X, S\Z - 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &lt; GrassGridSize - 1 Then If (ServiceMap(S\X, S\Z + 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	Return SquaresQuantity
End Function
</textarea><br><br>The idea is this :<br>If you look at the appearance of the grass when it is rendered with textured quads near the camera, you can see that there are different shades of green.<br>So instead of using only one green color to texture the terrain, you use a base green color and others shades of green depending on if there is a grass at this position or not.<br>Then even if there is no textured mesh displayed on the terrain because it is too far from the camera, you can see different shades of green.<br><br>In this code example the render is not ideal because it seems that the normal of the triangles of some quads are not calculated and set properly. But you get the idea...<br><br>To go further if you want to improve the lighting :<br>If you create a light for the sun light, let's say with a color of 250,250,250<br>And then you set the ambientlight to 050,050,050 <br>050 corresponds to 1/5 or 0.2 of 250<br>This means that a triangle which "faces" the light will be colored with 250,250,250<br>and a triangle which "oppose" the light will be colored with 050,050,050<br>So when you want to color your grass, you want to make the top of the grass (the part which will be illuminated) with the base color (000,100,000) and the bottom of the grass (the part which will not be illuminated or only slightly illuminated) with 0.2 of the base color (000,020,000)<br>And to color the terrain, we could use the base color (000,100,000) and the "median" color (000,050,000).<br>Then you need to set the grass meshes to fullbright so that they will not be affected by the light. <br><br></td></tr></table><br>
<a name="1236492"></a>

<a name="1236493"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here are some simple tweaks made to the code by Matt Merkulov<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Grass rendering algorythm by Matt Merkulov

SeedRnd MilliSecs()

Const LandscapeSize = 256
Const DitheringTextureSize = 512
Const DitheringTextureScale = 4
Const LandscapeSizeMask = LandscapeSize - 1
Const LandscapeHeight# = 25.5

Const GrassColor = 100
Const GrassDColor = 020
Const GrassBackground = 100
Const MaxGrassSpreadingRadius# = 0.72

Const BushesThreshold# = 0.28
Const MaxBushesThreshold# = 0.34
Const SandThreshold# = 0.3
Const HillsMinRadius = 16
Const HillsMaxRadius = 64
Const HillsMinHeight# = 0.2
Const HillsMaxHeight# = 1.0
Const HillsQuantity# = 100

Const BushTypesQuantity = 1
Const BushModelsQuantity = 1
Const BushTextureSize = 256

Const BushModelScaleMin# = 0.3
Const BushModelScaleMax# = 0.6

Const PlayerHeight# = 1.65
Const PlayerSpeedPerSecond# = 10.0
Const PlayerTurnPerSecond# = 180.0

Const FadingTimeInSeconds# = 1.0
Const MaxAlpha# = 1.0



;Small grass quadrants - smooth, but slow grass rendering
Const GrassGridCellSize# = 1.0
Const BushesQuantityPerSquare = 3
Const GrassRadiusInSquares# = 50


;Largel grass quadrants - jerky, but fast grass rendering
;Const GrassGridCellSize# = 8.0
;Const BushesQuantityPerSquare = 192
;Const GrassRadiusInSquares# = 2


Const GrassGridSize = LandscapeSize / GrassGridCellSize#
Const BushTextureXTexSize# = 1.0 / BushTypesQuantity
Const BushTextureYTexSize# = 1.0 / BushModelsQuantity
Const GrassRadius# = GrassRadiusInSquares# * GrassGridCellSize#

Graphics3D 1024, 768,32,2


Camera = CreateCamera()
ScaleEntity camera, 0.3, 0.3, 0.3
PositionEntity Camera, LandscapeSize / 2, 100, LandscapeSize / 2
;RotateEntity Camera, 45, 0, 0


SLight = CreateLight()
LightColor(SLight,250,250,250)
PositionEntity(SLight,0,1000,-1000)
RotateEntity(SLight,45,0,0)

AmbientLight(050,050,050)

Type ActiveSquare
	Field X, Z, JustAdded
End Type

Type FadingBush
	Field Alpha#, FadingMode, X, Z
End Type

Dim ServiceMap(LandscapeSize, LandscapeSize)
Const VisibleActiveSquare = %11
Const InvisibleActiveSquare = %10
Const VisibleSquare = %01
Const InvisibleSquare = %00
Const Visibility = %01
Const Activity = %10

Dim BushModel(BushTypesQuantity - 1, BushModelsQuantity - 1)
Dim BushQuantityMap#(GrassGridSize - 1, GrassGridSize - 1)
Dim BushMap(GrassGridSize - 1, GrassGridSize - 1)
Dim BushFader.FadingBush(GrassGridSize - 1, GrassGridSize - 1)

Global Landscape = CreateTerrain(LandscapeSize)
Global LandscapeTexture = CreateTexture(LandscapeSize, LandscapeSize, 15)
Global LandscapeDitheringTexture = CreateTexture(DitheringTextureSize, DitheringTextureSize, 15)
Global Grass = CreateTexture(BushTextureSize * BushTypesQuantity, BushTextureSize * BushModelsQuantity, 13)
ScaleEntity Landscape, 1, LandscapeHeight#, 1

CreateLandscape

CreateBushes

PaintTextures

TryToAddSquare EntityX(Camera) / GrassGridCellSize#, EntityZ(Camera) / GrassGridCellSize#

Const FadingIn = 1, FadingOut = 2

Repeat
	MoveEntity Camera, 0, 0, PrevFrameRenderingTimeInSeconds# * PlayerSpeedPerSecond# * (KeyDown(200) - KeyDown(208))
	TurnEntity Camera, 0, PrevFrameRenderingTimeInSeconds# * PlayerTurnPerSecond# * (KeyDown(203) - KeyDown(205)), 0

	FrameBeginningTime = MilliSecs()

	PlayerX# = EntityX(Camera)
	PlayerZ# = EntityZ(Camera)
	PositionEntity Camera, PlayerX#, TerrainY#(Landscape, PlayerX#, 0, PlayerZ#) + PlayerHeight#, PlayerZ#

	SetBuffer TextureBuffer(LandscapeTexture)

	qua = 0
	For S.ActiveSquare=Each ActiveSquare
		tmp = ServiceMap(S\X, S\Z)
		If (ServiceMap(S\X, S\Z) And Activity) = Activity And S\JustAdded Then
		 	Delete S
		Else
			S\JustAdded = False
			Dist# = EntityDistance(BushMap(S\X, S\Z), Camera)
			;Stop
			If Dist# &gt; GrassRadius# Then
				If (ServiceMap(S\X, S\Z) And Visibility) = VisibleSquare Then
					ExpandSquare S
					If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FF00FFFF
					If BushMap(S\X, S\Z) Or GrassMethod = MethodHide Then
						If BushFader(S\X, S\Z) &lt;&gt; Null Then
							FB.FadingBush = BushFader(S\X, S\Z)
						Else
							FB.FadingBush = New FadingBush
							FB\X = S\X
							FB\Z = S\Z
							FB\Alpha# = MaxAlpha#
							BushFader(S\X, S\Z) = FB
						End If
						FB\FadingMode = FadingOut
					End If
					ServiceMap(S\X, S\Z) = InvisibleActiveSquare
				Else
					If CountNeighbors(S, VisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = InvisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = InvisibleActiveSquare
					End If
				End If
			Else
				If (ServiceMap(S\X, S\Z) And Visibility) = InvisibleSquare Then
					ExpandSquare S
					If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FFFF0000
					ServiceMap(S\X, S\Z) = VisibleActiveSquare
					S\JustAdded = False
					ShowEntity BushMap(S\X, S\Z)
					If BushFader(S\X, S\Z) &lt;&gt; Null Then
						FB.FadingBush = BushFader(S\X, S\Z)
					Else
						FB.FadingBush = New FadingBush
						FB\X = S\X
						FB\Z = S\Z
						FB\Alpha# = 0.0
						BushFader(S\X, S\Z) = FB
					End If
					FB\FadingMode = FadingIn
				Else
					If CountNeighbors(S, InvisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = VisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = VisibleActiveSquare
					End If
				End If
			End If
		End If
	Next

	DFading# = PrevFrameRenderingTimeInSeconds# / FadingTimeInSeconds#
	For FB.FadingBush = Each FadingBush
		A# = FB\Alpha#
		If FB\FadingMode = FadingIn Then
			A# = A# + DFading#
			If A# &gt; MaxAlpha# Then A# = MaxAlpha#
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = MaxAlpha# Then Delete FB
		Else
			A# = A# - DFading#
			If A# &lt; 0.0 Then A# = 0.0
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = 0.0 Then
				HideEntity BushMap(FB\X, FB\Z)
				BushFader(FB\X, FB\Z) = Null
				Delete FB
			End If
		End If
	Next

	For S.ActiveSquare=Each ActiveSquare
		qua = qua + 1
	Next

	SetBuffer BackBuffer()
	
	RenderWorld

	;Stop

	If FPSCounterResetTime &lt;= MilliSecs() Then
		FPSCounterResetTime = MilliSecs() + 1000
		FPS = FPSCounter
		FPSCounter = 0
	Else
		FPSCounter = FPSCounter + 1
	End If
	Text 0, 0, "Frames / sec:" + FPS + ", activesquares: " + qua

	Flip

	PrevFrameRenderingTimeInSeconds# = 0.001 * (MilliSecs() - FrameBeginningTime)
Until KeyHit(1)

For X = 0 To GrassGridSize - 1
	For Y = 0 To GrassGridSize - 1
		If BushMap(X, Y) Then FreeEntity BushMap(X, Y)
	Next
Next

FreeEntity Landscape
FreeTexture LandscapeTexture
FreeTexture LandscapeDitheringTexture

Function CreateLandscape()
	SetBuffer FrontBuffer()
	Text 0, 0, "Generating landscape..."
	For n = 1 To HillsQuantity
		HillRadius = Rnd(HillsMinRadius, HillsMaxRadius)
		HillX = Rand(0, LandscapeSize)
		HillY = Rand(0, LandscapeSize)
		HillHeight# = Rnd(HillsMinHeight#, HillsMaxHeight#)

		If -HillRadius &lt; -HillX Then DXFrom = -HillX Else DXFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillX Then DXTo = LandscapeSize - HillX - 1 Else DXTo = HillRadius
		If -HillRadius &lt; -HillY Then DYFrom = -HillY Else DYFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillY Then DYTo = LandscapeSize - HillY - 1 Else DYTo = HillRadius

		For DY = DYFrom To DYTo
			For DX = DXFrom To DXTo
				X = HillX + DX
				Y = HillY + DY
				K# = Sqr(DX * DX + DY * DY) / HillRadius
				If K# &gt; 1.0 Then K# = 1.0
				Height# = 0.5 * (1.0 + Cos(180.0 * K#)) * HillHeight# * HillRadius / 64
				If Height# &gt; TerrainHeight#(Landscape, X, Y) Then ModifyTerrain Landscape, X, Y, Height#
			Next
		Next
	Next

	SetBuffer FrontBuffer()
	Text 0, 10, "Painting landscape..."
	SetBuffer TextureBuffer(LandscapeTexture)
	For Y = 0 To LandscapeSize - 1
		For X = 0 To LandscapeSize - 1
			If TerrainHeight#(Landscape, X, Y) &gt; SandThreshold# Then
				;WritePixel X, Y, $FF00FF00
				RandomChoice% = Rand(1,2)
				If(RandomChoice = 1)
 				 Color(000,100,000)
				ElseIf(RandomChoice = 2)
 				 Color(000,080,000)
				EndIf
				Plot(X,Y)
			Else
				;WritePixel X, Y, $FFFFFF00
				Color(100,100,050)
				Plot(X,Y)
			End If
		Next
	Next
End Function

Function PaintTextures()
	ScaleTexture LandscapeTexture, LandscapeSize, -LandscapeSize
	TerrainShading Landscape, True

	ScaleTexture LandscapeDitheringTexture, DitheringTextureScale, DitheringTextureScale
	SetBuffer TextureBuffer(LandscapeDitheringTexture)
	For Y = 0 To DitheringTextureSize
		For X = 0 To DitheringTextureSize
			WritePixel X, Y, (Rand(96,160) * $010101) Or $FF000000
		Next
	Next

	;EntityTexture Landscape, LandscapeDitheringTexture
	;EntityTexture Landscape, LandscapeTexture, 0, 1
	;TextureBlend LandscapeTexture, 2
	TextureBlend(LandscapeTexture,1)
	EntityTexture Landscape, LandscapeTexture,0,0
	
End Function

Function CreateBushes()
	;SetBuffer BackBuffer()
	SetBuffer FrontBuffer()
	Text 0, 20, "Painting textures..."

	SetBuffer TextureBuffer(Grass)
	For Y = 0 To BushTextureSize * BushTypesQuantity - 1
		For X = 0 To BushTextureSize * BushModelsQuantity - 1
			WritePixel X, Y, 256 * GrassBackground
		Next
	Next

	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			
			m = CreateMesh()
			s = CreateSurface(m)
			If n1 = 0 Then
				For nn = 1 To 100 + n2 * 100
					Radius# = Rnd(BushTextureSize / 2, BushTextureSize)
					X = BushTextureSize * (Rnd(0,1) ^ 2 * (Rand(0, 1) * 2 - 1) + 1) * 0.5
					Repeat
						Angle# = Rnd(70, 110)
						X2 = Cos(Angle#) * Radius# + X
						Y2 = BushTextureSize - 1 - Sin(Angle#) * Radius# + n2 * BushTextureSize
					Until X2 &gt;=0 And X2 &lt; BushTextureSize
					For DeltaX = -3 To 3
						Color 0, GrassColor + DeltaX * GrassDColor, 0
						Line X + DeltaX, (n2 + 1) * BushTextureSize - 1, X2, Y2
					Next
				Next
				For nn= 0 To 7
					Angle# = nn * 45
					;CreateQuad s, Cos(Angle# - 45), Sin(Angle# - 45), Cos(Angle# + 45), Sin(Angle# + 45), Cos(Angle#) * 0.75, Sin(Angle#) * 0.75
					CreateQuad s, Cos(Angle#) * 0.5, Sin(Angle#) * 0.5, -Cos(Angle#) * 0.5, -Sin(Angle#) * 0.5, n1, n2, Cos(Angle# + 90), Sin(Angle# + 90)
				Next
			Else
				For nn = 1 To 150 + n2 * 150
					X = Rnd(BushTextureSize * 2 / 5, BushTextureSize * 3 / 5) + BushTextureSize
					Angle# = Rnd(10, 170)
					Radius# = Rnd(0, 1) * (1 - Abs(angle - 90) / 133) *  BushTextureSize
					X2 = Cos(Angle#) * Radius# + BushTextureSize / 2 + BushTextureSize
					Y2 = (n2 + 1) * BushTextureSize - 1 - Sin(Angle#) * Radius# 
					For DeltaX = -3 To 3
						Color 0, GrassColor + DeltaX * GrassDColor, 0
						Line X + DeltaX, (n2 + 1) * BushTextureSize - 1, X2, Y2
					Next
				Next
				For nn = 0 To 3
					Angle# = nn * 45
					xx# = Cos(Angle#)
					yy# = Sin(Angle#)
					CreateQuad s, xx#, yy#, -xx#, -yy#, n1, n2
				Next
			End If
			BushModel(n1, n2) = m
			HideEntity m
		Next
	Next

	SetBuffer FrontBuffer()
	Color 255, 255, 255
	Text 0, 30, "Generating grass squares (it might take some more time)..."

	For Z = 0 To GrassGridSize - 1
		For X = 0 To GrassGridSize - 1
			m = CreateMesh()
			EX# = X * GrassGridCellSize#
			EZ# = Z * GrassGridCellSize#
			EH# = TerrainY(Landscape, EX#, 0, EZ#)
			For n3 = 1 To BushesQuantityPerSquare
				Repeat
					DX# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					DZ# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					If  Sqr(DX# * DX# + DZ# * DZ#) &lt;= MaxGrassSpreadingRadius# Then
						LX# = DX# * GrassGridCellSize# + EX#
						LZ# = DZ# * GrassGridCellSize# + EZ#
						LH# = TerrainY(Landscape, LX#, 0, LZ#)
						DH# = LH# - EH#

						Height# = LH# / LandscapeHeight#
						If Height# &gt; BushesThreshold# Then
							Quantity# = 1.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
							If Rnd(1) &lt; Quantity# Then
								m2 = CopyMesh(BushModel(Rand(0, BushTypesQuantity - 1), Rand(0, BushModelsQuantity - 1)))
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								AlignToVector m2, -DY1#, 1.0, -DY2#, 2
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#
								s = GetSurface(m2, 1)
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0
								Next
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2)
								PositionMesh m2, DX# * GrassGridCellSize#, DH#, DZ# * GrassGridCellSize#
								AddMesh m2, m
								FreeEntity m2
							End If
						End If
						Exit
					End If
				Forever
			Next
			BushMap(X, Z) = m
			PositionEntity m, EX#, EH#, EZ#
			EntityFX m, 1+16
			EntityTexture m, Grass
			HideEntity m
			EntityAlpha m, 0.0
		Next
	Next

	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			FreeEntity BushModel(n1, n2)
		Next
	Next
End Function

Function CreateQuad(Surface, X1#, Y1#, X2#, Y2#, XTex#, YTex#, DX# = 0, DY# = 0)
	XTex# = XTex# * BushTextureXTexSize#
	YTex# = YTex# * BushTextureYTexSize#
	v1 = AddVertex(Surface, X1#, 0, Y1#, XTex#, YTex# + BushTextureYTexSize#)
	v2 = AddVertex(Surface, X1# + DX#, 1, Y1# + DY#, XTex#, YTex#)
	v3 = AddVertex(Surface, X2# + DX#, 1, Y2# + DY#, XTex# + BushTextureYTexSize#, YTex#)
	v4 = AddVertex(Surface, X2#, 0, Y2#, XTex# + BushTextureYTexSize#, YTex# + BushTextureYTexSize#)
	AddTriangle Surface, v1, v2, v3
	AddTriangle Surface, v3, v4, v1
End Function

Function TryToAddSquare(X, Z)
	S.ActiveSquare = New ActiveSquare
	S\X = X
	S\Z = Z
	S\JustAdded = True
End Function

Function ExpandSquare(S.ActiveSquare)
	If S\X &gt; 0 Then TryToAddSquare S\X - 1, S\Z
	If S\X &lt; GrassGridSize - 1 Then TryToAddSquare S\X + 1, S\Z
	If S\Z &gt; 0 Then TryToAddSquare S\X, S\Z - 1
	If S\Z &lt; GrassGridSize - 1 Then TryToAddSquare S\X, S\Z + 1
End Function

Function CountNeighbors(S.ActiveSquare, NeighborType)
	If S\X &gt; 0 Then If (ServiceMap(S\X - 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\X &lt; GrassGridSize - 1 Then If (ServiceMap(S\X + 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &gt; 0 Then If (ServiceMap(S\X, S\Z - 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &lt; GrassGridSize - 1 Then If (ServiceMap(S\X, S\Z + 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	Return SquaresQuantity
End Function
</textarea><br><br>The idea is this :<br>If you look at the appearance of the grass when it is rendered with textured quads near the camera, you can see that there are different shades of green.<br>So instead of using only one green color to texture the terrain, you use a base green color and others shades of green depending on if there is a grass at this position or not.<br>Then even if there is no textured mesh displayed on the terrain because it is too far from the camera, you can see different shades of green.<br><br>In this code example the render is not ideal because it seems that the normal of the triangles of some quads are not calculated and set properly. But you get the idea...<br><br>To go further if you want to improve the lighting :<br>If you create a light for the sun light, let's say with a color of 250,250,250<br>And then you set the ambientlight to 050,050,050 <br>050 corresponds to 1/5 or 0.2 of 250<br>This means that a triangle which "faces" the light will be colored with 250,250,250<br>and a triangle which "oppose" the light will be colored with 050,050,050<br>So when you want to color your grass, you want to make the top of the grass (the part which will be illuminated) with the base color (000,100,000) and the bottom of the grass (the part which will not be illuminated or only slightly illuminated) with 0.2 of the base color (000,020,000)<br>And to color the terrain, we could use the base color (000,100,000) and the "median" color (000,050,000).<br>Then you need to set the grass meshes to fullbright so that they will not be affected by the light.<br><br>What would look even better would be to color each grass of a slightly different green color and have the same color for the pixel of terrain color <br><br></td></tr></table><br>
<a name="1236497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice ideas indeed. <br><br></td></tr></table><br>
<a name="1236569"></a>

<a name="1236570"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have reduced the texel size on the terrain color so that one texel corresponds to 0.5*0.5 unit for the terrain<br>This means that it appears that there are 4 grasses for each 1*1unit<br>I have also augmented the square size (containing the grasses) to 10*10 unit so that there are less squares to manage.<br>Now, see how you almost cannot see the grass appear/disappear :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;Grass rendering algorythm by Matt Merkulov

SeedRnd MilliSecs()

Const LandscapeSize = 256
Const DitheringTextureSize = 512
Const DitheringTextureScale = 4
Const LandscapeSizeMask = LandscapeSize - 1
Const LandscapeHeight# = 25.5

Const GrassColor = 100
Const GrassDColor = 020
Const GrassBackground = 100
Const MaxGrassSpreadingRadius# = 0.72

Const BushesThreshold# = 0.28
Const MaxBushesThreshold# = 0.34
Const SandThreshold# = 0.3
Const HillsMinRadius = 16
Const HillsMaxRadius = 64
Const HillsMinHeight# = 0.2
Const HillsMaxHeight# = 1.0
Const HillsQuantity# = 100

Const BushTypesQuantity = 1
Const BushModelsQuantity = 1
Const BushTextureSize = 256

Const BushModelScaleMin# = 0.3
Const BushModelScaleMax# = 0.6

Const PlayerHeight# = 1.65
Const PlayerSpeedPerSecond# = 10.0
Const PlayerTurnPerSecond# = 180.0

Const FadingTimeInSeconds# = 1.0
Const MaxAlpha# = 1.0



;Small grass quadrants - smooth, but slow grass rendering
Const GrassGridCellSize# = 10.0
Const BushesQuantityPerSquare = 3*10*10
Const GrassRadiusInSquares# = 5


;Largel grass quadrants - jerky, but fast grass rendering
;Const GrassGridCellSize# = 8.0
;Const BushesQuantityPerSquare = 192
;Const GrassRadiusInSquares# = 2


Const GrassGridSize = LandscapeSize / GrassGridCellSize#
Const BushTextureXTexSize# = 1.0 / BushTypesQuantity
Const BushTextureYTexSize# = 1.0 / BushModelsQuantity
Const GrassRadius# = GrassRadiusInSquares# * GrassGridCellSize#

Graphics3D 1024, 768,32,2


Camera = CreateCamera()
ScaleEntity camera, 0.3, 0.3, 0.3
PositionEntity Camera, LandscapeSize / 2, 100, LandscapeSize / 2
;RotateEntity Camera, 45, 0, 0


SLight = CreateLight()
LightColor(SLight,250,250,250)
PositionEntity(SLight,0,1000,-1000)
RotateEntity(SLight,45,0,0)

AmbientLight(050,050,050)

Type ActiveSquare
	Field X, Z, JustAdded
End Type

Type FadingBush
	Field Alpha#, FadingMode, X, Z
End Type

Dim ServiceMap(LandscapeSize, LandscapeSize)
Const VisibleActiveSquare = %11
Const InvisibleActiveSquare = %10
Const VisibleSquare = %01
Const InvisibleSquare = %00
Const Visibility = %01
Const Activity = %10

Dim BushModel(BushTypesQuantity - 1, BushModelsQuantity - 1)
Dim BushQuantityMap#(GrassGridSize - 1, GrassGridSize - 1)
Dim BushMap(GrassGridSize - 1, GrassGridSize - 1)
Dim BushFader.FadingBush(GrassGridSize - 1, GrassGridSize - 1)

Global Landscape = CreateTerrain(LandscapeSize)
;Global LandscapeTexture = CreateTexture(LandscapeSize, LandscapeSize, 15)
Global LandscapeTexture
Global Grass = CreateTexture(BushTextureSize * BushTypesQuantity, BushTextureSize * BushModelsQuantity, 13)
ScaleEntity Landscape, 1, LandscapeHeight#, 1

CreateLandscape

CreateBushes

TryToAddSquare EntityX(Camera) / GrassGridCellSize#, EntityZ(Camera) / GrassGridCellSize#

Const FadingIn = 1, FadingOut = 2

Repeat
	MoveEntity Camera, 0, 0, PrevFrameRenderingTimeInSeconds# * PlayerSpeedPerSecond# * (KeyDown(200) - KeyDown(208))
	TurnEntity Camera, 0, PrevFrameRenderingTimeInSeconds# * PlayerTurnPerSecond# * (KeyDown(203) - KeyDown(205)), 0

	FrameBeginningTime = MilliSecs()

	PlayerX# = EntityX(Camera)
	PlayerZ# = EntityZ(Camera)
	PositionEntity Camera, PlayerX#, TerrainY#(Landscape, PlayerX#, 0, PlayerZ#) + PlayerHeight#, PlayerZ#

	SetBuffer TextureBuffer(LandscapeTexture)

	qua = 0
	For S.ActiveSquare=Each ActiveSquare
		tmp = ServiceMap(S\X, S\Z)
		If (ServiceMap(S\X, S\Z) And Activity) = Activity And S\JustAdded Then
		 	Delete S
		Else
			S\JustAdded = False
			Dist# = EntityDistance(BushMap(S\X, S\Z), Camera)
			;Stop
			If Dist# &gt; GrassRadius# Then
				If (ServiceMap(S\X, S\Z) And Visibility) = VisibleSquare Then
					ExpandSquare S
					If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FF00FFFF
					If BushMap(S\X, S\Z) Or GrassMethod = MethodHide Then
						If BushFader(S\X, S\Z) &lt;&gt; Null Then
							FB.FadingBush = BushFader(S\X, S\Z)
						Else
							FB.FadingBush = New FadingBush
							FB\X = S\X
							FB\Z = S\Z
							FB\Alpha# = MaxAlpha#
							BushFader(S\X, S\Z) = FB
						End If
						FB\FadingMode = FadingOut
					End If
					ServiceMap(S\X, S\Z) = InvisibleActiveSquare
				Else
					If CountNeighbors(S, VisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = InvisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = InvisibleActiveSquare
					End If
				End If
			Else
				If (ServiceMap(S\X, S\Z) And Visibility) = InvisibleSquare Then
					ExpandSquare S
					If Paint Then WritePixel S\X * GrassGridCellSize#, S\Z * GrassGridCellSize#, $FFFF0000
					ServiceMap(S\X, S\Z) = VisibleActiveSquare
					S\JustAdded = False
					ShowEntity BushMap(S\X, S\Z)
					If BushFader(S\X, S\Z) &lt;&gt; Null Then
						FB.FadingBush = BushFader(S\X, S\Z)
					Else
						FB.FadingBush = New FadingBush
						FB\X = S\X
						FB\Z = S\Z
						FB\Alpha# = 0.0
						BushFader(S\X, S\Z) = FB
					End If
					FB\FadingMode = FadingIn
				Else
					If CountNeighbors(S, InvisibleSquare) = 0 Then
						ServiceMap(S\X, S\Z) = VisibleSquare
						Delete S
					Else
						ServiceMap(S\X, S\Z) = VisibleActiveSquare
					End If
				End If
			End If
		End If
	Next

	DFading# = PrevFrameRenderingTimeInSeconds# / FadingTimeInSeconds#
	For FB.FadingBush = Each FadingBush
		A# = FB\Alpha#
		If FB\FadingMode = FadingIn Then
			A# = A# + DFading#
			If A# &gt; MaxAlpha# Then A# = MaxAlpha#
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = MaxAlpha# Then Delete FB
		Else
			A# = A# - DFading#
			If A# &lt; 0.0 Then A# = 0.0
			FB\Alpha# = A#
			EntityAlpha BushMap(FB\X, FB\Z), A#
			If A# = 0.0 Then
				HideEntity BushMap(FB\X, FB\Z)
				BushFader(FB\X, FB\Z) = Null
				Delete FB
			End If
		End If
	Next

	For S.ActiveSquare=Each ActiveSquare
		qua = qua + 1
	Next

	SetBuffer BackBuffer()
	
	RenderWorld

	;Stop

	If FPSCounterResetTime &lt;= MilliSecs() Then
		FPSCounterResetTime = MilliSecs() + 1000
		FPS = FPSCounter
		FPSCounter = 0
	Else
		FPSCounter = FPSCounter + 1
	End If
	Text 0, 0, "Frames / sec:" + FPS + ", activesquares: " + qua

	Flip

	PrevFrameRenderingTimeInSeconds# = 0.001 * (MilliSecs() - FrameBeginningTime)
Until KeyHit(1)

For X = 0 To GrassGridSize - 1
	For Y = 0 To GrassGridSize - 1
		If BushMap(X, Y) Then FreeEntity BushMap(X, Y)
	Next
Next

FreeEntity Landscape
FreeTexture LandscapeTexture

Function CreateLandscape()
	SetBuffer FrontBuffer()
	Text 0, 0, "Generating landscape..."
	For n = 1 To HillsQuantity
		HillRadius = Rnd(HillsMinRadius, HillsMaxRadius)
		HillX = Rand(0, LandscapeSize)
		HillY = Rand(0, LandscapeSize)
		HillHeight# = Rnd(HillsMinHeight#, HillsMaxHeight#)

		If -HillRadius &lt; -HillX Then DXFrom = -HillX Else DXFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillX Then DXTo = LandscapeSize - HillX - 1 Else DXTo = HillRadius
		If -HillRadius &lt; -HillY Then DYFrom = -HillY Else DYFrom = -HillRadius
		If HillRadius &gt; LandscapeSize - HillY Then DYTo = LandscapeSize - HillY - 1 Else DYTo = HillRadius

		For DY = DYFrom To DYTo
			For DX = DXFrom To DXTo
				X = HillX + DX
				Y = HillY + DY
				K# = Sqr(DX * DX + DY * DY) / HillRadius
				If K# &gt; 1.0 Then K# = 1.0
				Height# = 0.5 * (1.0 + Cos(180.0 * K#)) * HillHeight# * HillRadius / 64
				If Height# &gt; TerrainHeight#(Landscape, X, Y) Then ModifyTerrain Landscape, X, Y, Height#
			Next
		Next
	Next

   TerrainShading Landscape, True


    LandscapeTexture = CreateTexture(LandscapeSize*2,LandscapeSize*2)
	SetBuffer(TextureBuffer(LandscapeTexture))
	For PX% = 0 To LandscapeSize*2-1 Step 1
     For PY% = 0 To LandscapeSize*2-1 Step 1    
      GX# = Float(PX/2)+0.25
      GY# = LandscapeSize-Float(PY/2)+0.25
      If(TerrainHeight#(Landscape, GX, GY) &gt; SandThreshold#)
       ;WritePixel X, Y, $FF00FF00
       RandomChoice% = Rand(1,2)
       If(RandomChoice = 1)
        Color(000,100,000)
       ElseIf(RandomChoice = 2)
        Color(000,080,000)
       EndIf
       Plot(PX,PY)
      Else
       ;WritePixel X, Y, $FFFFFF00
       Color(100,100,050)
       Plot(PX,PY)
      EndIf
     Next
	Next
	SetBuffer(BackBuffer())
	ScaleTexture(LandscapeTexture,LandscapeSize,LandscapeSize)
	TextureBlend(LandscapeTexture,1)
	EntityTexture(Landscape,LandscapeTexture,0,0)
	
End Function

Function CreateBushes()
	;SetBuffer BackBuffer()
	SetBuffer FrontBuffer()
	Text 0, 20, "Painting textures..."

	SetBuffer TextureBuffer(Grass)
	For Y = 0 To BushTextureSize * BushTypesQuantity - 1
		For X = 0 To BushTextureSize * BushModelsQuantity - 1
			WritePixel X, Y, 256 * GrassBackground
		Next
	Next

	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			
			m = CreateMesh()
			s = CreateSurface(m)
			If n1 = 0 Then
				For nn = 1 To 100 + n2 * 100
					Radius# = Rnd(BushTextureSize / 2, BushTextureSize)
					X = BushTextureSize * (Rnd(0,1) ^ 2 * (Rand(0, 1) * 2 - 1) + 1) * 0.5
					Repeat
						Angle# = Rnd(70, 110)
						X2 = Cos(Angle#) * Radius# + X
						Y2 = BushTextureSize - 1 - Sin(Angle#) * Radius# + n2 * BushTextureSize
					Until X2 &gt;=0 And X2 &lt; BushTextureSize
					For DeltaX = -3 To 3
						Color 0, GrassColor + DeltaX * GrassDColor, 0
						Line X + DeltaX, (n2 + 1) * BushTextureSize - 1, X2, Y2
					Next
				Next
				For nn= 0 To 7
					Angle# = nn * 45
					;CreateQuad s, Cos(Angle# - 45), Sin(Angle# - 45), Cos(Angle# + 45), Sin(Angle# + 45), Cos(Angle#) * 0.75, Sin(Angle#) * 0.75
					CreateQuad s, Cos(Angle#) * 0.5, Sin(Angle#) * 0.5, -Cos(Angle#) * 0.5, -Sin(Angle#) * 0.5, n1, n2, Cos(Angle# + 90), Sin(Angle# + 90)
				Next
			Else
				For nn = 1 To 150 + n2 * 150
					X = Rnd(BushTextureSize * 2 / 5, BushTextureSize * 3 / 5) + BushTextureSize
					Angle# = Rnd(10, 170)
					Radius# = Rnd(0, 1) * (1 - Abs(angle - 90) / 133) *  BushTextureSize
					X2 = Cos(Angle#) * Radius# + BushTextureSize / 2 + BushTextureSize
					Y2 = (n2 + 1) * BushTextureSize - 1 - Sin(Angle#) * Radius# 
					For DeltaX = -3 To 3
						Color 0, GrassColor + DeltaX * GrassDColor, 0
						Line X + DeltaX, (n2 + 1) * BushTextureSize - 1, X2, Y2
					Next
				Next
				For nn = 0 To 3
					Angle# = nn * 45
					xx# = Cos(Angle#)
					yy# = Sin(Angle#)
					CreateQuad s, xx#, yy#, -xx#, -yy#, n1, n2
				Next
			End If
			BushModel(n1, n2) = m
			HideEntity m
		Next
	Next

	SetBuffer FrontBuffer()
	Color 255, 255, 255
	Text 0, 30, "Generating grass squares (it might take some more time)..."

	For Z = 0 To GrassGridSize - 1
		For X = 0 To GrassGridSize - 1
			m = CreateMesh()
			EX# = X * GrassGridCellSize#
			EZ# = Z * GrassGridCellSize#
			EH# = TerrainY(Landscape, EX#, 0, EZ#)
			For n3 = 1 To BushesQuantityPerSquare
				Repeat
					DX# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					DZ# = Rnd(-MaxGrassSpreadingRadius#, MaxGrassSpreadingRadius#)
					If  Sqr(DX# * DX# + DZ# * DZ#) &lt;= MaxGrassSpreadingRadius# Then
						LX# = DX# * GrassGridCellSize# + EX#
						LZ# = DZ# * GrassGridCellSize# + EZ#
						LH# = TerrainY(Landscape, LX#, 0, LZ#)
						DH# = LH# - EH#

						Height# = LH# / LandscapeHeight#
						If Height# &gt; BushesThreshold# Then
							Quantity# = 1.0 * (Height# - BushesThreshold#) / (MaxBushesThreshold# - BushesThreshold#)
							If Rnd(1) &lt; Quantity# Then
								m2 = CopyMesh(BushModel(Rand(0, BushTypesQuantity - 1), Rand(0, BushModelsQuantity - 1)))
								SXZ# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								SY# = Rnd(BushModelScaleMin#, BushModelScaleMax#)
								DY1# = TerrainY(Landscape, LX# + 1.0, 0, LZ#) - LH#
								DY2# = TerrainY(Landscape, LX#, 0, LZ# + 1.0) - LH#
								AlignToVector m2, -DY1#, 1.0, -DY2#, 2
								RotateMesh m2, 0, Rnd(0,359), 0
								ScaleMesh m2, SXZ#, SY#, SXZ#
								s = GetSurface(m2, 1)
								For n = 0 To CountVertices(s) - 1
									VertexNormal s, n, 0, 1, 0
								Next
								RotateMesh m2, EntityPitch(m2), EntityYaw(m2) , EntityRoll(m2)
								PositionMesh m2, DX# * GrassGridCellSize#, DH#, DZ# * GrassGridCellSize#
								AddMesh m2, m
								FreeEntity m2
							End If
						End If
						Exit
					End If
				Forever
			Next
			BushMap(X, Z) = m
			PositionEntity m, EX#, EH#, EZ#
			EntityFX m, 1+16
			EntityTexture m, Grass
			HideEntity m
			EntityAlpha m, 0.0
		Next
	Next

	For n1 = 0 To BushTypesQuantity - 1
		For n2 = 0 To BushModelsQuantity - 1
			FreeEntity BushModel(n1, n2)
		Next
	Next
End Function

Function CreateQuad(Surface, X1#, Y1#, X2#, Y2#, XTex#, YTex#, DX# = 0, DY# = 0)
	XTex# = XTex# * BushTextureXTexSize#
	YTex# = YTex# * BushTextureYTexSize#
	v1 = AddVertex(Surface, X1#, 0, Y1#, XTex#, YTex# + BushTextureYTexSize#)
	v2 = AddVertex(Surface, X1# + DX#, 1, Y1# + DY#, XTex#, YTex#)
	v3 = AddVertex(Surface, X2# + DX#, 1, Y2# + DY#, XTex# + BushTextureYTexSize#, YTex#)
	v4 = AddVertex(Surface, X2#, 0, Y2#, XTex# + BushTextureYTexSize#, YTex# + BushTextureYTexSize#)
	AddTriangle Surface, v1, v2, v3
	AddTriangle Surface, v3, v4, v1
End Function

Function TryToAddSquare(X, Z)
	S.ActiveSquare = New ActiveSquare
	S\X = X
	S\Z = Z
	S\JustAdded = True
End Function

Function ExpandSquare(S.ActiveSquare)
	If S\X &gt; 0 Then TryToAddSquare S\X - 1, S\Z
	If S\X &lt; GrassGridSize - 1 Then TryToAddSquare S\X + 1, S\Z
	If S\Z &gt; 0 Then TryToAddSquare S\X, S\Z - 1
	If S\Z &lt; GrassGridSize - 1 Then TryToAddSquare S\X, S\Z + 1
End Function

Function CountNeighbors(S.ActiveSquare, NeighborType)
	If S\X &gt; 0 Then If (ServiceMap(S\X - 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\X &lt; GrassGridSize - 1 Then If (ServiceMap(S\X + 1, S\Z) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &gt; 0 Then If (ServiceMap(S\X, S\Z - 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	If S\Z &lt; GrassGridSize - 1 Then If (ServiceMap(S\X, S\Z + 1) And Visibility) = NeighborType Then SquaresQuantity = SquaresQuantity + 1
	Return SquaresQuantity
End Function
</textarea><br>As i have said previously an even better approach would be to slightly modify the color of each grass so that it corresponds to the green color of the texel on the terrain color.<br><br>And to make it faster, only have one quad for each grass and each frame oriente the visible grasses to face the camera. <br><br></td></tr></table><br>
<a name="1236576"></a>

<a name="1236577"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks. Indeed much harder to see where the grass ends. Nice effect that really helps. <br><br>One thought was to have a mixed system;<br>For low grass just use single sided billboard quads using pointentity to face the camera and something like the current system for larger bushes and perhaps trees and other stuff. <br><br>That way would speed up things (I think)and still look much better than just using billboards for everything, especially when the cam moves above the terrain while jumping/flying etc.<br>Also would allow for different wind effects(trees shouldn't move as much as grass, waterplants moving along with water).<br><br>However I currently have no 100% clear idea at what point(s) in code and how I can addres the individual bushes to manage the cam facing bits.<br><br>For the wind I kinda cheated using:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function UpdateWind()

	For W.WindSquare=Each WindSquare
	
	
		If BushMap(W\X,W\Z) &lt;&gt; 0 Then
		
			;x#=+lsin(wind)/10.0
			Windz#=lcos(windforce);*5.0
			r=Rnd(15)
			RotateEntity BushMap(W\X+r,W\Z+r), 0,0,Windz#	
		EndIf
		
	Next	
	
	windforce#=windforce#+1.0
	If windforce=360.0 Then 
		windforce=0.0
	EndIf
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1236586"></a>

<a name="1236590"></a>

<a name="1236591"></a>

<a name="1236592"></a>

<a name="1236593"></a>

<a name="1236594"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are several limits with what you can do with the code by Matt Merkulov.<br>The first limit i have seen is that it uses AddMesh instead of a "AddSurface" and i don't think you can keep all the infos about the surface added to the other surface with AddMesh.<br>Not sure about that, i have to do some tests.<br><br>What would be a great improvement for the render would be to add different kinds of grass meshes and grasses textures and that they would be automatically "merged" into one surface with one texture for each 10x10square<br><br>Another improvement would be to first color the terrain with one of the main color used by one of the different grass mesh and then position each corresponding grass mesh at this position with a slight random offset on the x axis and on the z axis<br><br>About replacing the grass detailed meshes by quad meshes, this is not really needed, if you plan to add low tris meshes this should be ok.<br>Keep in mind that one surface can contain up to around 32000 vertices or triangles, but you can also have different surfaces in a mesh so there is no limit. The only limit you have is the target hardware you want to run the game on. I was suggesting to use only a quad for each grass if you want to display many many many grasses on a big terrain.<br><br>For the trees, i would use detailed meshes to display the near enough trees and textured quad meshes to display the far enough trees. <br><br>For the wind, i don't know, i don't think this is a priority. Most players would probably not notice if there is wind or not. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
