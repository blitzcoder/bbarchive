<!DOCTYPE html><html lang="en" ><head ><title >Energy loss problem with physics objects bouncing off each other.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Energy loss problem with physics objects bouncing off each other.</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Energy loss problem with physics objects bouncing off each other.</a><br><br>
<a name="284746"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, can someone who knows about vector math tell me what I'm doing wrong here.<br><br>I've made up a physics demo, using some of Sswift's physics code, which has 100 balls bouncing around inside a cube with gravity applied.<br><br>It looks fairly realistic, for the most part, however there seems to be a problem with energy loss when the balls bounce off each other. They go from flying around so fast that they're barely visible, to lying on the floor of the cube barely moving, within a few minutes.<br><br>This is with a maximum elasticity value of 1.0. The problem was also present before I factored elasticity into the code. This only shows up if the balls are enabled to bounce off each other. If they're only bouncing off the walls then there's no apparent energy loss. My physics code is below.<br><br>Also, how would I go about, mathematically applying thrust to a physics object parellel to the plane of the surface it's standing on, so that it can be properly 'pushed' along an inclined surface (for a game character walking up and down ramps and hills, for example). {edit}I think multiplying the x, y, z, velocity vectors by the respective collision normals to align them to the space of the collision plane, applying the thrust to the x and y vextors, as required, and then multplying the three vectors by the normals calculated from the original velocity vectors to convert them back to global space, would work. I'll have to try it out.{/edit}<br><br>--- Physics code<br><br>; Note: Delta time has already been applied to the gravity# variable at the start of the main loop.<br><br>Function apply_basic_physics( the_entity_data.ENTITY_STRUCT )<br>			the_entity = the_entity_data\entity_handle<br>			vx# = the_entity_data\physics_data\vx#<br>			vy# = the_entity_data\physics_data\vy#<br>			vz# = the_entity_data\physics_data\vz#<br>			;the_mass# = the_entity_data\physics_data\mass#<br>			the_elasticity# = the_entity_data\physics_data\elasticity#<br>			;the_friction# = the_entity_data\physics_data\friction#<br><br>		For the_collision_index = 1 To CountCollisions ( the_entity )<br><br>			the_entity_collided_with = CollisionEntity ( the_entity, the_collision_index )<br>			the_target_entitiy_type = GetEntityType ( the_entity_collided_with )<br><br>			; Get the data structure of the target collision object.<br>			the_target_entity_data.ENTITY_STRUCT = Object.ENTITY_STRUCT( EntityName$ ( the_entity_collided_with ) )<br>			<br>			; Get the collision normals.<br>			coll_nx# = CollisionNX# ( the_entity, the_collision_index )<br>			coll_ny# = CollisionNY# ( the_entity, the_collision_index )<br>			coll_nz# = CollisionNZ# ( the_entity, the_collision_index )<br><br>			; Compute the dot product of the avatars's motion vector and the normal of the surface collided with.<br>			VdotN# = vx# * coll_nx# + vy# * coll_ny# + vz# * coll_nz#<br><br>			; Check if the target collision object has physics properties.<br>			If the_target_entity_data\physics_data &lt;&gt; Null<br><br>				; Calculate the normal force to be applied to the source and target objects.<br>				NFx# = -the_elasticity# * coll_nx# * VdotN#<br>				NFy# = -the_elasticity# * coll_ny# * VdotN#<br>				NFz# = -the_elasticity# * coll_nz# * VdotN#<br><br>				; Apply the positive normal force to the motion vector of the source object.<br>				vx# = vx# + NFx#<br>				vy# = vy# + NFy#<br>				vz# = vz# + NFz#<br><br>				; Apply the negative normal force to the motion vector of the target object.<br>				the_target_entity_data\physics_data\vx# = the_target_entity_data\physics_data\vx# - NFx#<br>				the_target_entity_data\physics_data\vy# = the_target_entity_data\physics_data\vy# - NFy#<br>				the_target_entity_data\physics_data\vz# = the_target_entity_data\physics_data\vz# - NFz#<br><br>			Else<br><br>				; Calculate and add the normal force to the motion vector of the source object.<br>				vx# = vx# + ( -( 1.0 + the_elasticity# ) * coll_nx# * VdotN# )<br>				vy# = vy# + ( -( 1.0 + the_elasticity# ) * coll_ny# * VdotN# )<br>				vz# = vz# + ( -( 1.0 + the_elasticity# ) * coll_nz# * VdotN# )<br><br>			EndIf<br><br>		Next<br><br>		vy# = vy# + gravity#<br><br>		PositionEntity the_entity, EntityX# ( the_entity ) + ( vx# * Delta_Time# ), EntityY# ( the_entity ) + ( vy# * Delta_Time# ), EntityZ# ( the_entity ) + ( vz# * Delta_Time# )<br><br>			the_entity_data\physics_data\vx# = vx#<br>			the_entity_data\physics_data\vy# = vy#<br>			the_entity_data\physics_data\vz# = vz#<br><br><br>		DBG_total_energy# = DBG_total_energy# + Sqr# ( vx# * vx# + vy# * vy# + vz# * vz# ) ; DEBUG CODE :: Calculate the ball's energy.<br><br>End Function <br><br></td></tr></table><br>
<a name="284832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I seem to have sorted this issue out. Most of the loss in energy was simply due to the opposing vectors cancelling each other out. The remainder was probably due to the collision not being recorded by a slower moving object moving away from a faster moving object that hits it.<br><br>I added some code to check for and factor in this type of collision, and now, after a while, the system settles down to an equilibrium state where no energy is being lost.<br><br>Here's my new code.<br><br>Function apply_basic_physics( the_entity_data.ENTITY_STRUCT ) ; the_collision_data.COLLISION_LIST_STRUCT )<br>;	Note:<br>;	The source collision object here is always a physics object. The target collision object may or may not be.<br>			;the_entity_data.ENTITY_STRUCT = the_collision_data\source_entity_data<br>			the_physics_data.PHYSICS_STRUCT = the_entity_data\physics_data<br>			the_entity = the_entity_data\entity_handle<br>			vx# = the_physics_data\vx#<br>			vy# = the_physics_data\vy#<br>			vz# = the_physics_data\vz#<br>			;the_mass# = the_physics_data\mass#<br>			the_elasticity# = the_physics_data\elasticity#<br>			;the_friction# = the_physics_data\friction#<br><br>			;the_target_entity_data.ENTITY_STRUCT = the_collision_data\target_entity_data<br><br>		For the_collision_index = 1 To CountCollisions ( the_entity )<br><br>			the_entity_collided_with = CollisionEntity ( the_entity, the_collision_index )<br>			;the_target_entitiy_type = GetEntityType ( the_entity_collided_with )<br><br>			; Get the data structure of the target collision object.<br>			the_target_entity_data.ENTITY_STRUCT = Object.ENTITY_STRUCT( EntityName$ ( the_entity_collided_with ) )<br>			the_target_physics_data.PHYSICS_STRUCT = the_target_entity_data\physics_data<br>			<br>			; Get the collision normals.<br>			coll_nx# = CollisionNX# ( the_entity, the_collision_index )<br>			coll_ny# = CollisionNY# ( the_entity, the_collision_index )<br>			coll_nz# = CollisionNZ# ( the_entity, the_collision_index )<br><br>			; Compute the dot product of the avatars's motion vector and the normal of the surface collided with.<br>			VdotN# = vx# * coll_nx# + vy# * coll_ny# + vz# * coll_nz#<br><br>			; Check if the target collision object has physics properties.<br>			If the_target_physics_data &lt;&gt; Null<br><br>				; Calculate the normal force to be applied to the source and target objects.<br>				NFx# = -the_elasticity# * coll_nx# * VdotN#<br>				NFy# = -the_elasticity# * coll_ny# * VdotN#<br>				NFz# = -the_elasticity# * coll_nz# * VdotN#<br><br>				; Apply the positive normal force to the motion vector of the source object.<br>				vx# = vx# + NFx#<br>				vy# = vy# + NFy#<br>				vz# = vz# + NFz#<br><br>				; Apply the negative normal force to the motion vector of the target object.<br>				the_target_physics_data\vx# = the_target_physics_data\vx# - NFx#<br>				the_target_physics_data\vy# = the_target_physics_data\vy# - NFy#<br>				the_target_physics_data\vz# = the_target_physics_data\vz# - NFz#<br><br>				If Sgn ( vz# * coll_nz# ) = Sgn ( the_target_physics_data\vz# * coll_nz# )<br><br>					VdotN# = the_target_physics_data\vx# * coll_nx# + the_target_physics_data\vy# * coll_ny# + the_target_physics_data\vz# * coll_nz#<br><br>					; Calculate the normal force to be applied to the source and target objects.<br>					NFx# = -the_target_physics_data\elasticity# * coll_nx# * VdotN#<br>					NFy# = -the_target_physics_data\elasticity# * coll_ny# * VdotN#<br>					NFz# = -the_target_physics_data\elasticity# * coll_nz# * VdotN#<br><br>					; Apply the positive normal force to the motion vector of the target object.<br>					the_target_entity_data\physics_data\vx# = the_target_entity_data\physics_data\vx# + NFx#<br>					the_target_entity_data\physics_data\vy# = the_target_entity_data\physics_data\vy# + NFy#<br>					the_target_entity_data\physics_data\vz# = the_target_entity_data\physics_data\vz# + NFz#<br><br>					; Apply the negative normal force to the motion vector of the source object.<br>					vx# = vx# - NFx#<br>					vy# = vy# - NFy#<br>					vz# = vz# - NFz#<br><br>				EndIf<br><br>			Else<br><br>				; Calculate and add the normal force to the motion vector of the source object.<br>				vx# = vx# + ( -( 1.0 + the_elasticity# ) * coll_nx# * VdotN# )<br>				vy# = vy# + ( -( 1.0 + the_elasticity# ) * coll_ny# * VdotN# )<br>				vz# = vz# + ( -( 1.0 + the_elasticity# ) * coll_nz# * VdotN# )<br><br>			EndIf<br><br>		Next<br><br>		vy# = vy# + gravity#<br><br>		PositionEntity the_entity, EntityX# ( the_entity ) + ( vx# * Delta_Time# ), EntityY# ( the_entity ) + ( vy# * Delta_Time# ), EntityZ# ( the_entity ) + ( vz# * Delta_Time# )<br><br>		DBG_total_energy# = DBG_total_energy# + Sqr# ( vx# * vx# + vy# * vy# + vz# * vz# ) ; DEBUG CODE :: Calculate the ball's energy.<br><br>		the_physics_data\vx# = vx#<br>		the_physics_data\vy# = vy#<br>		the_physics_data\vz# = vz#<br><br>End Function <br><br></td></tr></table><br>
<a name="284840"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Hill</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not really your problem, but something that might be of interest ...<br><br>Long time ago when I were a lad, some of the guys in the Physics lab at the university where I used to work did a lot of very long physical simulations.  I seem to recall that they kept track of the total energy in their system.  Due to small floating point errors, it was common for the energy to gradually drift, so they applied a fudge whereby any excess energy was redistributed evenly (or any deficit was rectified).  This only needed to be done infrequently. <br><br></td></tr></table><br>
<a name="284868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I was thinking of something similar at one point. Only really worth doing, though, if you've got a lot of physics collisions going on over a long period of time. <br><br></td></tr></table><br>
<a name="284892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> The code above has an elasticity constant, but 1.0 is not the correct value for perfectly inelastic collsions. (Those where no energy is lost)<br><br>NFx# =  -the_target_physics_data\elasticity# * coll_nx# * VdotN# <br><br>See that line?  Well in a perfectly inelastic collision, that elasticity value there would be 2.0.  So if you set it to 1.0, then you SHOULD be losing almost all your energy instantly, because that would mean a perfectly elastic collision.<br><br>This line SHOULD say:<br><br>NFx# =  -(1.0 + the_target_physics_data\elasticity#) * coll_nx# * VdotN# <br><br>Then a value of 1.0 for elasticity will represent a bouncy ball and 0.0 will represent a pool ball.  <br><br>Sort of.  <br><br>Those physics don't take into account mass, or how much energy is transferred to the other object.  So 1.0 means (I think it's called) an elastic collision where the ball KEEPS all of it's energy when it collides with the ground, and 0.0 represents an inelastic collision where the ball TRANSFERS all of it's energy to the other object when they collide.<br><br>Here's the kicker though.  Because I'm not transferring energy, if you have anything other than an elasticity of 1.0, then each time energy should be transferred from one ball to another (or from a ball to the floor) the energy is simply "lost".  And that violates the laws of physics.  Of course, if the balls collided with the floor presumably it would have so much mass anyhow that if the balls were not completely inelastic (0.0) then when they hit the floor it would get the energy but only barely budge.  But of course you don't even budge the floor you treat it like an object with infinite mass.  Either way, an even slightly inelastic collision with the floor will cause the balls to eventually slow down because the floor will just store the energy if anything at all, and not give it back.<br><br>Imagine for example pool balls colliding with a wall in a space station.  Most likely they'd hit the wall, and then stick there.  The wall gets all the energy and doesn't give it back.  The ship moves a tiny bit but that is imperceptible because the difference in mass is so great.  Either way, if the collision is inelastic, then the balls come to a rest.<br><br>Now if two inelastic balls of the same SIZE hit eachother in space, well that's a different story.  They'll "bounce" off one another.  One will gain the velocity and direction which the other previously had.  Like when you have those steel balls on string and you let two go at the same time, they both bounce back, over and over again.  Or if you release three, then three pop out on the other side.<br><br>I'm not really sure though why three pop out on the other side, rather than just one moving at three times the speed.  Hm...  I suppose it may have something to do with harmonics or something of the metal.  Or not.  I'll have to ask a physicist. :-)<br><br>Oh and what Steve said also applies.  Floating point numbers aren't perfectly accurate.  Energy can be lost.  You'd have to be really careful with your calculations to make sure that the velocity A plus the veloicity of B before the collision equals the velocity of A plus the velocity of B AFTER the collision.  And even then you might not be safe. <br><br></td></tr></table><br>
<a name="284902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's some physics for you of two objects with variable mass and different coefficients of friction colliding with one another.  Still not 100% proper physics though.  I didn't know what to do when the coefficients of friction (elasticity) are different. <br><br>Be aware that you must make sure that you do this only once for each pair of colliding objects.  If you just detect every object that collides and then determine what it collided with and do this code, then you'll UNDO the energy transfer that takes place when you do it the second time.<br><br>I couldn't think of a way to allow you to do the collisoon code just for one of the objects, transfer the energy, and then do the other.  Like if two balls collide with eachother head on, if you just did one first and then the other after, with the first one, you'd just cancel out it's momentum and end up with 0 movement, and then have nothing to transfer when you get to the second.  They have to transfer their energy simulatanously.  I suppose you could maintain a before and after state for all objects though and operate on the before state and set the after.  Hm...<br><br><pre class=code>
     ; Convert the player's velocities and directions into vectors.
	    	        MagDirToVector(ThisBike)
					MagDirToVector(HitPlayer)

					;DebugLog("Before:")
					;DebugLog(HitPlayer\VECTOR_X#)
					;DebugLog(HitPlayer\VECTOR_Y#)
					;DebugLog(HitPlayer\VECTOR_Z#)
					;DebugLog("")

					; Transfer momentum from one entity to the other.

						; First, get caclulate a vector from the center of mass of the first player,
						; to the center of mass of the second.
						
							CNx# = EntityX#(ThisBike\Pivot, True) - EntityX#(HitPlayer\Pivot, True)
							CNy# = EntityY#(ThisBike\Pivot, True) - EntityY#(HitPlayer\Pivot, True)
							CNz# = EntityZ#(ThisBike\Pivot, True) - EntityZ#(HitPlayer\Pivot, True)
						
						; Normalize the vector.
		
							CNl# = Sqr(CNx#*CNx# + CNy#*CNy# + CNz#*CNz#)
							CNx# = CNx# / CNl#
							CNy# = CNy# / CNl#
							CNz# = CNz# / CNl#

						; Find the length of each of the movement vectors along the normal.

							;V1dotN# = ThisBike\VECTOR_X#*CNx#  + ThisBike\VECTOR_Y#*CNy#  + ThisBike\VECTOR_Z#*CNz#
							;V2dotN# = HitPlayer\VECTOR_X#*CNx# + HitPlayer\VECTOR_Y#*CNy# + HitPlayer\VECTOR_Z#*CNz#

						; Get the mass of the objects involved in the collision.

							Mass1# = 1.0
							Mass2# = 1.0

						; Get the coefficient of restitution of each object.
						
							; The coefficient of restitution is a value between 0 and 1 which defines how elastic
							; the objects that collide are.  A metal ball is inelastic, and would have a coefficient
							; of 0... all energy would be transferred from the first object to the second during
							; a collision.  A basketball on the other hand has a coefficient of 0.6...  So it bounces
							; when it hits the floor rather than transferring all it's energy to the floor.  
							; A baseball, btw, has a coefficient of 0.55.
													
							E1# = 0.25
							E2# = 0.25
							
						; Calculate the coefficient of restitution to use for the collision.
							
							; Note:
							; This is probably not the correct physical way to model a collision when the two
							; objects have different coefficients of friction, but it should work well enough.
																										
							; If the first object is softer than the second object...
							If E1# &gt; E2#
								E# = E1#		; Use the first object's coefficient.
							Else
								E# = E2#		; Use the second object's coefficient.
							EndIf

						; Caclulate the new velocities of the two objects.
							
							C# = CNx# * (ThisBike\VECTOR_X# - HitPlayer\VECTOR_X#) + CNy# * (ThisBike\VECTOR_Y# - HitPlayer\VECTOR_Y#) + CNz# * (ThisBike\VECTOR_Z# - HitPlayer\VECTOR_Z#)
							
							P1# = ((Mass2# * C#) / (Mass1# + Mass2#)) * (1.0 + E#)
							
							ThisBike\VECTOR_X# = ThisBike\VECTOR_X# - P1# * CNx#
							ThisBike\VECTOR_Y# = ThisBike\VECTOR_Y# - P1# * CNy#
							ThisBike\VECTOR_Z# = ThisBike\VECTOR_Z# - P1# * CNz#

							P2# = ((Mass1# * C#) / (Mass1# + Mass2#)) * (1.0 + E#)
							
							HitPlayer\VECTOR_X# = HitPlayer\VECTOR_X# + P2# * CNx#
							HitPlayer\VECTOR_Y# = HitPlayer\VECTOR_Y# + P2# * CNy#
							HitPlayer\VECTOR_Z# = HitPlayer\VECTOR_Z# + P2# * CNz#
	
						; Convert the movement vector back into a magnitude and direction.
							VectorToMagDir(ThisBike,  ThisBike\VECTOR_X#,  ThisBike\VECTOR_Y#,  ThisBike\VECTOR_Z#)
							
						; Store the new movement vector for the player collided with.
						
						    HitPlayer\Vx# = HitPlayer\VECTOR_X#
						    HitPlayer\Vy# = HitPlayer\VECTOR_Y#
							HitPlayer\Vz# = HitPlayer\VECTOR_Z#

</pre> <br><br></td></tr></table><br>
<a name="285171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sswift, the line:<br><br>NFx# = -the_target_physics_data\elasticity# * coll_nx# * VdotN#<br><br>in my code is for collisions where physics objects are bouncing off each other, so the resulting normal force is added to the source object and subtracted from the target object which means its accumulative value should be equivalent to:<br><br>NFx# = -(1.0 + the_target_physics_data\elasticity#) * coll_nx# * VdotN#<br><br><br>Regarding my second set of code above, it seems to be a mistake to factor in the unregistered collision of a slower ball being hit from behind by a faster ball as this seems to result in the normal force being cancelled out (unless there's an error in my code somewhere). A more efficient check for missed collisions using:<br><br>----<br><br>t = 1<br>the_number_of_target_collisions = CountCollisions ( the_entity_collided_with )<br><br>For the_target_collision_index = 1 To the_number_of_target_collisions<br>	If CollisionEntity ( the_entity_collided_with, the_target_collision_index ) = the_entity Then t = 0 : Exit<br>Next<br><br>If t<br><br>----<br><br>instead of:<br><br>----<br><br>If Sgn ( vz# * coll_nz# ) = Sgn ( the_target_physics_data\vz# * coll_nz# )<br><br>----<br><br>made the problem more obvious. The faster ball would simply move around the slower ball like it's climbing over it. There were a few other bugs in this code as well.<br><br><br>Here's a link to the compiled program, anyway. Everything seems to be behaving as it should apart from the energy loss problem.<br><br><a href="http://www.brightrealm.com/downloads/demos/simple_demos/Bouncing_balls.zip" target="_blank">http://www.brightrealm.com/downloads/demos/simple_demos/Bouncing_balls.zip</a> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
