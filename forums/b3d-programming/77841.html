<!DOCTYPE html><html lang="en" ><head ><title >Pointentity Problem</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Pointentity Problem</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Pointentity Problem</a><br><br>
<a name="871751"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I recently started a little game in 3D as an exercise (I'm way more comfortable in 2D), and right now it's best thought of as a 2D-in-3D (baby steps, here) shooter, with an increasing Y position moving things upwards on the screen and an increasing X moving things to the right.<br><br>Using placeholder meshes (CreateCone() mostly), I tried to make homing missiles.  That's where my problems begin.  I remember reading somewhere on these forums that in 3D, PointEntity can be used effectively for homing missiles, and curvier flight paths can easily be implemented by adjusting the optional roll parameter.  Yet no matter how I try it, nothing works.<br><br>My first problem is that PointEntity doesn't point the point of the cone mesh I'm using, but rather a point on the side.  I sort of overcame this with liberal usage of the RotateMesh command, but it still isn't pretty.  Instead of only the roll value determining how much it turns (because I effectively only want the missiles to rotate on the XY plane), it changes - as per the command description - both pitch and yaw values until the missile is somewhat pointing towards it, but the whole thing's rotated like crazy in a direction I don't want. I've tried rotating my meshes so that different axes are switched, and through tinkering in this manner I eventually got PointEntity to point the tip of the cone <i>directly</i> at the target (roll value useless), which seems to be the best I'll ever get.<br><br>Does anyone have any ideas/examples/pseudocode?  Any help would be much appreciated. <br><br></td></tr></table><br>
<a name="871754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Have you tried parenting a pivot at the tip of the cone?<br><br>Or, for less hassle, use positionmesh to make the tip of the cone at 0,0,0. That way, when point entity is used, it will point at the tip of the cone.<br><br>Remember, point entity, points an entity at the 0,0,0 local position of a mesh, it's centre basically. PositionMesh, move the vertices of the mesh away from the centre in your case.<br><br>If that fails, can you post some code to demonstrate your problem :o) <br><br></td></tr></table><br>
<a name="871776"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cones are created pointing upwards along the positive Y axis. PointEntity points the entity along the positive Z axis. You will need to use RotateMesh to rotate the cone 90 degrees on the X axis for it to be pointing in the correct direction.<br><br>eg. RotateMesh cone, 90.0, 0.0, 0.0<br><br>As I understand it, the roll parameter of PointEntity just rotates the source entity on its local Z axis, which is probably not something you are going to need.<br><br><pre class=code>
Global timer = CreateTimer( 25 )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

Global cam = CreateCamera()
CameraZoom cam, 1.6
MoveEntity cam, 2.0, 2.0, -10.0

Global light = CreateLight()

Global cone = CreateCone()
RotateMesh cone, 90.0, 0.0, 0.0
UpdateNormals cone

Global cube = CreateCube()
UpdateNormals cube
PositionEntity cube, 20.0, 10.0, 40.0

While Not KeyHit( 1 )

MoveEntity cube, -0.22, 0.0, 0.0

PointEntity( cone, cube )
MoveEntity cone, 0.0, 0.0, 0.3

UpdateWorld
RenderWorld
Flip

WaitTimer( timer )

Wend

End
</pre> <br><br></td></tr></table><br>
<a name="871789"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jerome Squalor</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> you might want to check out Deltayaw and deltapitch<br>they give you the amout of degrees an entity needs to turn in order to point at another.<br><br>i had a similar question a few months back. the post from StevieG in this thread has a nice function he made try it out.<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=75492#843596" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=75492#843596</a> <br><br></td></tr></table><br>
<a name="871818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is where ...<br><br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1927" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1927</a><br><br>comes in handy.<br><br>You can do similar to point entity using aligntovector also.<br><br>Cheers<br>Stevie <br><br></td></tr></table><br>
<a name="871970"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's an example using AlignToVector.<br><br><pre class=code>
Global vx#, vy#, vz#

Global not_collided = True

Global timer = CreateTimer( 25 )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

Global cam = CreateCamera()
CameraZoom cam, 1.6
MoveEntity cam, 2.0, 2.0, -10.0

Global light = CreateLight()

Global cone = CreateCone()
RotateMesh cone, 90.0, 0.0, 0.0
UpdateNormals cone

Global cube = CreateCube()
UpdateNormals cube
PositionEntity cube, 20.0, 10.0, 40.0

While Not KeyHit( 1 )

	If EntityDistance( cube, cone ) &lt; 1.0
	
		HideEntity cone
		EntityColor cube, 255.0, 0.0, 0.0
		not_collided = False
		
	EndIf
	
	If not_collided
	
		MoveEntity cube, -0.22, 0.0, 0.0
		
		;PointEntity( cone, cube )
		vx# = EntityX( cube, True ) - EntityX( cone, True )
		vy# = EntityY( cube, True ) - EntityY( cone, True )
		vz# = EntityZ( cube, True ) - EntityZ( cone, True )
		AlignToVector( cone, vx#, vy#, vz#, 3, 0.15 )
		MoveEntity cone, 0.0, 0.0, 0.31
	
	EndIf
	
	UpdateWorld
	RenderWorld
	
	Flip
	
	WaitTimer( timer )

Wend

End
</pre> <br><br></td></tr></table><br>
<a name="872876"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks a lot, everyone.  I knew I could've done it with some math and TurnEntity, but I thought PointEntity might've provided an easier way.  Apparently not.<br><br>Thanks for suggesting the AlignToVector technique.  Works like a charm. <br><br></td></tr></table><br>
<a name="875095"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uh oh.  Here's a problem that's currently got me stumped:<br><br>This game is best described as a top-down 2D spaceship game, and the ships move via waypoints.  AlignToVector works perfectly in this setting, except for in one rare scenario.  If the waypoint is set exactly (pixel-perfect) in a straight line behind the ship (see crude ASCII-illustration)...<br><br>  /_\<br><br>   w<br><br>  OR<br><br>w  |&gt;<br><br>...then the ship, instead of turning left or right, turns backwards into the Z axis to get to the waypoint.  As the entire game occurs on the xy plane, this is a very serious problem, and I have found that after this occurs, no amount of waypointing will correct the ship and bring it back onto the plane.  Curiously enough, this occurs even though I'm using AlignToVector with the vector_z# variable set to zero.<br><br>I've tried correcting this with if statements, but they can only reasonably work if the ship is facing either directly up, down, left, or right, and - though I have yet to produce it - I am positive that the effect could occur when the ship is facing any angle in between as well.  The if statements don't work for other reasons as well that I don't want to explain in this post, as they don't seem relevant right now.<br><br>Basically, I'm wondering: is there any relatively simple solution that will keep my ships in the xy plane at all times and still allow me to use AlignToVector to bring my ships to waypoints.  I could of course hard-code a function bringing ships to waypoints with angles and TurnEntity or something like that, but AlignToVector is much simpler and probably more efficient, and I'd really like to stick with it if I can.<br><br>Any ideas? <br><br></td></tr></table><br>
<a name="875103"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GIB3D</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure if this would mess up the way you have set up your code but here is this<br><br><pre class=code>
PositionEntity entity,EntityX(entity),EntityY(entity),0
</pre><br><br>Basicly, it lets it move around on the x and y axis but stays at 0 on the z axis. <br><br></td></tr></table><br>
<a name="875380"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> That works, but - predictably - the ship turns into the Z axis without moving, until it has turned a full 180 degrees.  That's like seeing the Asteroids ship try to turn towards the screen.  For a 2D game, it simply doesn't make sense.  Any other ideas? <br><br></td></tr></table><br>
<a name="875439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think what your getting is a singularity where align to vector does not know which way to turn.  You could use turnentity 0,0,( .0001 or -.0001 ) just before your aligntovector call in this situation to give it a helping hand. <br><br>Alternatively, use the deltaroll code I posted. <br><br>Stevie <br><br></td></tr></table><br>
<a name="876157"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stevie, that wouldn't work either without if statements... what if the TurnEntity call positioned the ship to create the singularity?<br><br>Examining the vector values used in AlignToVector, I could create some if statements to try to do that only during this singularity... except that the same values occur in other scenarios as well...<br><br>I think I'll try implementing some deltaroll-ish code in a day or so.  Just wondering Stevie, what do you use for those helicopter homing missiles in Polymaniacs?  I'd imagine that AlignToVector in that scenario would be more efficient, as the odds of generating the singularity (already difficult to do in 2D) would be virtually impossible in 3D, as every possible target would have to be directly (floating-point precision) behind the missile, and not moving. <br><br></td></tr></table><br>
<a name="876203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Of course you would only use a slight turn if you knew that the singularity was going to occur before you used aligntovector.  Is that really such a hardship?<br><br><pre class=code>
function MYaligntoVector( entity, vx#, vy#, axis = 1, rate# = 1 )

   if vx = 0 and vy &lt; 0  turnentity entity, 0,0,-.0001
   aligntovector entity, vx, vy, 0, axis, rate#

end function
</pre><br><br>With the deltaroll function you will only ever return  -180 or 180 when the target is directly behind the missile so it will work perfectly.   Trust me, I have had to use it myself when doing 2d in 3d on a single plane. Alternatively just use the x/z plane and deltayaw - it's six and half a dozen.<br><br>BTW, I use aligntovector on the z axis for those missiles. <br><br></td></tr></table><br>
<a name="876431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Except from what I found, it wasn't always when vx = 0 and vy &lt; 0.  For instance, what if the ship is facing East?  Then vy would be zero, and vx &lt; 0.  And what if the ship's at an angle?  Not for me.  I'll try deltaroll, thank you very much! <br><br></td></tr></table><br>
<a name="876497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops - my bad - your right on th vx, vy ..<br><br>if you put these lines in first ...<br><br><pre class=code>
function MYaligntoVector( entity, vx#, vy#, axis = 1, rate# = 1 )

    tformvector vx, vy, 0, 0, entity
    if tformedx()=0 and tformedy() &lt; 0 turnentity 0,0,-.0001

   aligntovector entity, vx, vy, 0, axis, rate#

end function
</pre> <br><br></td></tr></table><br>
<a name="876524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> A 'YawToEntity' function. Seems to work well enough. Another possible use for this is in turning bots to face a waypoint entity in a 3D (or 2D in 3D) game.<br><br><pre class=code>

Global timer = CreateTimer( 25 )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

Global cam = CreateCamera()
CameraZoom cam, 1.6
MoveEntity cam, 0.0, 60.0, 0.0
TurnEntity cam, 90.0, 0.0, 0.0

Global light = CreateLight()

Global cone = CreateCone()
RotateMesh cone, 90.0, 0.0, 0.0
UpdateNormals cone
PositionEntity cone, 0.0, 0.0, -20.0

Global cube = CreateCube()
UpdateNormals cube
PositionEntity cube, 40.0, 0.0, 20.0

While Not KeyHit( 1 )

MoveEntity cube, -0.22, 0.0, 0.0

YawToEntity( cone, cube, 0.5 )
;PointEntity( cone, cube )
;MoveEntity cone, 0.0, 0.0, 0.3

UpdateWorld
RenderWorld

Text 10, 10, DeltaYaw( cone, cube )

Flip

WaitTimer( timer )

Wend

End


Function YawToEntity( src_entity, dest_entity, rate# )
; Turns 'src_entity' to point at 'dest_entity' at the rotation rate specified by 'rate#'.

	Local target_yaw# = DeltaYaw( src_entity, dest_entity )
	
	; If the required correction amount is less than the correction amount to be applied...
	If Abs( target_yaw# ) &lt; rate#
		; Point 'src_entity' directly at 'dest_entity' to prevent jittering.
		TurnEntity src_entity, 0.0, target_yaw#, 0.0
	Else
		; Turn 'src_entity' gradually towards 'dest_entity'.
		TurnEntity src_entity, 0.0, rate# * Sgn( target_yaw# ), 0.0
	EndIf
End Function

</pre> <br><br></td></tr></table><br>
<a name="876532"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, but we're talking about the XY plane rather than the XZ plane so you can't use deltayaw.<br><br>This does the same thing but on the XY plane ..<br><br><pre class=code>
Function POINT( Source , Target, Rate#=1.0 )

	TFormPoint 0,0,0 , Target, Source
        DeltaRoll# = vectoryaw( tformedx(), 0 , tformedy() )

        if abs( DeltaRoll ) &gt; Rate 
            turnentity Source, 0,0,DeltaRoll * Rate
        else
            turnentity Source, 0,0,DeltaRoll
        endif

End Function
</pre> <br><br></td></tr></table><br>
<a name="876540"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, everyone.  I'll dabble and tell you what seems to work the best. <br><br></td></tr></table><br>
<a name="876553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a slightly more complex test of the code I posted above.<br><br>One interesting thing I found when targetting stationary objects with missiles, is that if the turn rate is not responsive enough in relation to the collision radius of the target, you can get the missile locked into an orbit around the target.<br><br><pre class=code>
Global timer = CreateTimer( 25 )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

Global cam = CreateCamera()
CameraZoom cam, 1.6
MoveEntity cam, 0.0, 60.0, 0.0
TurnEntity cam, 90.0, 0.0, 0.0

Global light = CreateLight()

Global cone = CreateCone()
RotateMesh cone, 90.0, 0.0, 0.0
UpdateNormals cone
PositionEntity cone, 0.0, 0.0, -20.0

Global cube = CreateCube()
UpdateNormals cube
;PositionEntity cube, 40.0, 0.0, 20.0
PositionEntity cube, Rnd( -30.0, 30.0 ), 0.0, Rnd( -30.0, 30.0 )

While Not KeyHit( 1 )

;MoveEntity cube, -0.22, 0.0, 0.0

If EntityDistance( cone, cube ) &lt; 2.0
	PositionEntity cube, Rnd( -30.0, 30.0 ), 0.0, Rnd( -30.0, 30.0 )
EndIf

YawToEntity( cone, cube, 10.0 )
MoveEntity cone, 0.0, 0.0, 0.5

UpdateWorld
RenderWorld
Flip

WaitTimer( timer )

Wend

End


Function YawToEntity( src_entity, dest_entity, rate# )
; Turns 'src_entity' to point at 'dest_entity' at the rotation rate specified by 'rate#'.

	Local target_yaw# = DeltaYaw( src_entity, dest_entity )
	
	; If the required correction amount is less than the correction amount to be applied...
	If Abs( target_yaw# ) &lt; rate#
		; Point 'src_entity' directly at 'dest_entity' to prevent jittering.
		TurnEntity src_entity, 0.0, target_yaw#, 0.0
	Else
		; Turn 'src_entity' gradually towards 'dest_entity'.
		TurnEntity src_entity, 0.0, rate# * Sgn( target_yaw# ), 0.0
	EndIf
End Function
</pre> <br><br></td></tr></table><br>
<a name="876675"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Bill.  Yes, I had that problem with my old method too, but I believe that as long as the ship's moving and turning at the same time, there's no way to fix the orbiting that I can think of.  Right now, however, my code doesn't use any collisions... it's all EntityDistance stuff.  Any ideas?  Does anyone know how other games fix this problem? <br><br></td></tr></table><br>
<a name="876702"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> This code makes the missile a bit smarter. If the distance and angle relative to the target indicate that an orbit lock is likely, it will disable turning until it has enough distance on the target to get lined up on it.<br><br>Note that I'm still using the xz plane here. The yaw rotational functions are available without the need for bodges, and the EntityYaw function returns more sensible values than the 'get value' functions for the other axiis. <br><br>This code can be used for open space combat, where there's no ground plane for the smart missile to worry about<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; The number of logic updates per second.
Const C_LOGIC_FREQUENCY = 50

; The interval (in milliseconds) between logic updates.
Const C_LOGIC_INTERVAL# = 1000.0 / C_LOGIC_FREQUENCY ; Unused.

Const C_SMART_MISSILE_TEST_DISTANCE# = 10.0
Const C_SMART_MISSILE_TEST_ANGLE# = 60.0
Const C_SMART_MISSILE_NO_TURN_DISTANCE# = 15.0

Global timer = CreateTimer( C_LOGIC_FREQUENCY )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

SeedRnd MilliSecs()

Global cam = CreateCamera()
CameraZoom cam, 1.6
MoveEntity cam, 0.0, 60.0, 0.0
TurnEntity cam, 90.0, 0.0, 0.0

Global light = CreateLight()

Global cone = CreateCone()
RotateMesh cone, 90.0, 0.0, 0.0
UpdateNormals cone
PositionEntity cone, 0.0, 0.0, -20.0

Global cube = CreateCube()
UpdateNormals cube
;PositionEntity cube, 40.0, 0.0, 20.0
PositionEntity cube, Rnd( -5.0, 5.0 ), 0.0, Rnd( -5.0, 5.0 )

Global dist#

While Not KeyHit( 1 )

dist# = EntityDistance( cone, cube )

If allow_turn
	If dist# &lt; C_SMART_MISSILE_TEST_DISTANCE#
		If Abs( DeltaYaw( cone, cube ) ) &gt; C_SMART_MISSILE_TEST_ANGLE#
			allow_turn = False
		EndIf
	EndIf
Else
	If dist# &gt; C_SMART_MISSILE_NO_TURN_DISTANCE# Then allow_turn = True
EndIf

If allow_turn Then YawToEntity cone, cube, 3.0

MoveEntity cone, 0.0, 0.0, 0.5

If dist# &lt; 2.0
	PositionEntity cube, Rnd( -5.0, 5.0 ), 0.0, Rnd( -5.0, 5.0 )
EndIf

UpdateWorld
RenderWorld
Flip

WaitTimer( timer )

Wend

End


Function YawToEntity( src_entity, dest_entity, rate# )
; Turns 'src_entity' to point at 'dest_entity' at the rotation rate specified by 'rate#'.

	Local target_yaw# = DeltaYaw( src_entity, dest_entity )
	
	; If the required correction amount is less than the correction amount to be applied...
	If Abs( target_yaw# ) &lt; rate#
		; Point 'src_entity' directly at 'dest_entity' to prevent jittering.
		TurnEntity src_entity, 0.0, target_yaw#, 0.0
	Else
		; Turn 'src_entity' gradually towards 'dest_entity'.
		TurnEntity src_entity, 0.0, rate# * Sgn( target_yaw# ), 0.0
	EndIf
End Function

</textarea><br><br>This code can be used for ground based combat, where you don't want the missile plowing into the ground plane. The missile only disables turning if it is facing 'upwards'.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

; The number of logic updates per second.
Const C_LOGIC_FREQUENCY = 50

; The interval (in milliseconds) between logic updates.
Const C_LOGIC_INTERVAL# = 1000.0 / C_LOGIC_FREQUENCY ; Unused.

Const C_SMART_MISSILE_TEST_DISTANCE# = 10.0
Const C_SMART_MISSILE_TEST_ANGLE# = 60.0
Const C_SMART_MISSILE_NO_TURN_DISTANCE# = 20.0

Global timer = CreateTimer( C_LOGIC_FREQUENCY )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

SeedRnd MilliSecs()

Global cam = CreateCamera()
CameraZoom cam, 1.6
MoveEntity cam, 0.0, 60.0, 0.0
TurnEntity cam, 90.0, 0.0, 0.0

Global light = CreateLight()

Global cone = CreateCone()
RotateMesh cone, 90.0, 0.0, 0.0
UpdateNormals cone
PositionEntity cone, 0.0, 0.0, -20.0

Global cube = CreateCube()
UpdateNormals cube
PositionEntity cube, Rnd( -5.0, 5.0 ), 0.0, Rnd( -5.0, 5.0 )

Global dist#, allow_turn = True, disable_allow_turn_when_pointing_up = False

While Not KeyHit( 1 )

	dist# = EntityDistance( cone, cube )
	
	If allow_turn
		If dist# &lt; C_SMART_MISSILE_TEST_DISTANCE#
			If Abs( DeltaYaw( cone, cube ) ) &gt; C_SMART_MISSILE_TEST_ANGLE#
				disable_allow_turn_when_pointing_up = True
			EndIf
		EndIf
	Else
		If dist# &gt; C_SMART_MISSILE_NO_TURN_DISTANCE# Then allow_turn = True
	EndIf
	
	If disable_allow_turn_when_pointing_up
		If Abs( EntityYaw( cone ) ) &lt; 89.0 ; Note: 89 degrees is used so that the missile will turn upwards.
			allow_turn = False
			disable_allow_turn_when_pointing_up = False
		EndIf
	EndIf
	
	If allow_turn Then YawToEntity cone, cube, 3.0
	
	MoveEntity cone, 0.0, 0.0, 0.5
	
	If dist# &lt; 2.0
		PositionEntity cube, Rnd( -5.0, 5.0 ), 0.0, Rnd( -5.0, 5.0 )
	EndIf
	
	UpdateWorld
	RenderWorld
	Flip
	
	WaitTimer( timer )

Wend

End


Function YawToEntity( src_entity, dest_entity, rate# )
; Turns 'src_entity' to point at 'dest_entity' at the rotation rate specified by 'rate#'.

	Local target_yaw# = DeltaYaw( src_entity, dest_entity )
	
	; If the required correction amount is less than the correction amount to be applied...
	If Abs( target_yaw# ) &lt; rate#
		; Point 'src_entity' directly at 'dest_entity' to prevent jittering.
		TurnEntity src_entity, 0.0, target_yaw#, 0.0
	Else
		; Turn 'src_entity' gradually towards 'dest_entity'.
		TurnEntity src_entity, 0.0, rate# * Sgn( target_yaw# ), 0.0
	EndIf
End Function

</textarea> <br><br></td></tr></table><br>
<a name="876740"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you add a bit of momentum to the missile it seems to hit the target eventually ...<br><br><pre class=code>
Graphics3D 640,480,16,1

Global CAMERA = CreateCamera()
PositionEntity CAMERA, 0,0,-100 ;50,0
;RotateEntity CAMERA, 90,0,0

Global TARGET = CreateCube()
ScaleEntity TARGET, 2,2,2
EntityColor TARGET, 255,0,0

Type MissileT
	Field Mesh
	Field Flame
	Field Vx#, Vy#
	Field Acceleration#
	Field Momentum#
	Field Turnrate#
End Type
Global MISSILE.missileT = MISSILEcreate( .01, .99, .2 )

;init target
PositionEntity TARGET, Rand(-50,50 ), Rand( -50,50 ) ,0

While Not KeyDown(1)

	;target reached or spawn new target position
	If KeyDown( 57 ) Or EntityDistance( MISSILE\mesh, TARGET ) &lt; 6
		PositionEntity TARGET, Rand(-50,50 ), Rand( -50,50 ) , 0
	EndIf
	
	MISSILEupdate()
	RenderWorld()
	Flip
	
Wend

End

;===========================================================
;===========================================================
;===========================================================

Function MISSILEcreate.MissileT( Acceleration# , Momentum#, TurnRate# )

	;max speed = Acceleration / ( 1- Momentum )

	m.missileT = New missileT
	m\Acceleration = Acceleration
	m\Momentum = Momentum
	m\TurnRate = TurnRate
	m\Mesh = CreateCone()
	FitMesh m\Mesh, -1,0,-1,2,6,2
	m\Flame = CreateCone( 8 , False, m\Mesh )
	RotateMesh m\Flame, 0,0,-180
	FitMesh m\Flame,-1,-4,-1,2,4,2
	EntityColor m\Flame, 255,128,0
	
	Return m

End Function

;===========================================================
;===========================================================
;===========================================================

Function MISSILEupdate()

	For m.missileT = Each missileT
		
		;turn
		POINT( m\Mesh, TARGET, m\TurnRate )
		
		;move
		TFormVector 0,m\Acceleration, 0,m\Mesh, 0
		m\Vx = m\Vx * m\Momentum + TFormedX()
		m\Vy = m\Vy * m\Momentum + TFormedY()
		TranslateEntity m\Mesh, m\Vx, m\Vy, 0		

		;animate flame
		ScaleEntity m\Flame, 1,Rnd( .5, 5 ), 1
		
	Next

End Function

;===========================================================
;===========================================================
;===========================================================

Function POINT( Source , Target, Rate#=1.0 )

	TFormPoint 0,0,0 , Target, Source
	DeltaRoll# = VectorYaw( TFormedX(), 0 , TFormedY() )
	
	If Abs( DeltaRoll ) &gt; Rate 
		TurnEntity Source, 0,0,DeltaRoll * Rate
	Else
		TurnEntity Source, 0,0,DeltaRoll
	EndIf

End Function
</pre> <br><br></td></tr></table><br>
<a name="876849"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks guys, I'll test some things out hopefully today. <br><br></td></tr></table><br>
<a name="876865"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, I've been trying to implement Stevie's DeltaRoll stuff, but I just can't seem to get it to work.  I'm not trying to do any momentum stuff here, just simple turning and moving forwards.  But when I implement it, the value for DeltaRoll always seems to be 90 or -90, and when I have the ship turn each frame, even a slight amount, based on this DeltaRoll value, the sign for DeltaRoll changes every frame, effectively keeping the ship always facing the same direction, regardless of where its target is. <br><br></td></tr></table><br>
<a name="876876"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Buggy, no offence mate but it works in the code I posted above so you're clearly doing something different.<br><br>If you need any further help you need to start posting code to show what your doing 'cos we are not mind readers. <br><br></td></tr></table><br>
<a name="876946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is some code I knocked up to display the values returned by the EntityPitch, EntityYaw, and EntityRoll functions. It illistrates a few points, which I wanted to get clear in my head:<br><br>1 - EntityPitch returns the same values in different quadrants.<br><br>2 - It's important to be clear on where the starting rotation (0.0 degrees) is, and which direction the rotation will turn the entity in relation to the axis you are viewing along, as well as where the 'flipover' points (plus to minus, etc) are in the rotation.<br><br>3 - I have way too much time on my hands.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Const C_CAM_TURN_RATE# = 1.0

Global timer = CreateTimer( 25 )

Graphics3D 800, 600, 0, 2
SetBuffer BackBuffer()

Global cam = CreateCamera()
CameraZoom cam, 1.6
PositionEntity cam, 15.0, 0.0, 0.0

Global light = CreateLight()

Global cone_x = CreateCone() ; Cone points to X+.
RotateMesh cone_x, 0.0, 0.0, -90.0
UpdateNormals cone_x
HideEntity  cone_x

Global cone_y = CreateCone() ; Cone points to Y+.
UpdateNormals cone_y
HideEntity  cone_y

Global cone_z = CreateCone() ; Cone points to Z+.
RotateMesh cone_z, 90.0, 0.0, 0.0
UpdateNormals cone_z
HideEntity  cone_z

Global cone = cone_z
ShowEntity cone

PointEntity cam, cone

Global axis = 1

While Not KeyHit( 1 )

	If KeyHit( 57 )
		axis = axis + 1
		If axis = 4 Then axis = 1
	
		RotateEntity cone, 0.0, 0.0, 0.0
	
		HideEntity cone
		
		If axis = 1 Then PositionEntity cam, 15.0, 0.0, 0.0 : cone = cone_z
		If axis = 2 Then PositionEntity cam, 0.0, 15.0, 0.0 : cone = cone_x
		If axis = 3 Then PositionEntity cam, 0.0, 0.0, 15.0 : cone = cone_y
	
		ShowEntity cone
	
		PointEntity cam, cone
	EndIf
	
	If axis = 1 Then TurnEntity cone, C_CAM_TURN_RATE#, 0.0, 0.0
	If axis = 2 Then TurnEntity cone, 0.0, C_CAM_TURN_RATE#, 0.0
	If axis = 3 Then TurnEntity cone, 0.0, 0.0, C_CAM_TURN_RATE#
	
	UpdateWorld
	RenderWorld
	
	Color 255, 255, 255
	
	Text 10, 10, "Press SPACE to switch to a new axis of rotation"
	
	If axis = 1
		Text 10, 40, "Pitch (X axis): " + EntityPitch( cone )
		Text 10, 60, "Viewing from X+"
		Text 10, 80, "Cone points to Z+"
	EndIf
	
	If axis = 2
		Text 10, 40, "Yaw (Y axis): " + EntityYaw( cone )
		Text 10, 60, "Viewing from Y+"
		Text 10, 80, "Cone points to X+"
	EndIf
	
	If axis = 3
		Text 10, 40, "Roll (Z axis): " + EntityRoll( cone )
		Text 10, 60, "Viewing from Z+"
		Text 10, 80, "Cone points to Y+"
	EndIf
	
	If axis &lt;&gt; 1
	
		Color 200, 0, 0
		
		; -- Draw X+ axis marker.
		CameraProject cam, 5.0, 0.0, 0.0
		Text ProjectedX# (), ProjectedY# (), "X+", True, True
		;^^^^^^
		
		; -- Draw X- axis marker.
		CameraProject cam, -5.0, 0.0, 0.0
		Text ProjectedX# (), ProjectedY# (), "X-", True, True
		;^^^^^^
	
	EndIf
	
	If axis &lt;&gt; 2
	
		Color 240, 240, 0
		
		; -- Draw Y+ axis marker.
		CameraProject cam, 0.0, 5.0, 0.0
		Text ProjectedX# (), ProjectedY# (), "Y+", True, True
		;^^^^^^
		
		; -- Draw Y- axis marker.
		CameraProject cam, 0.0, -5.0, 0.0
		Text ProjectedX# (), ProjectedY# (), "Y-", True, True
		;^^^^^^
	
	EndIf
	
	If axis &lt;&gt; 3
	
		Color 0, 240, 0
		
		; -- Draw Z+ axis marker.
		CameraProject cam, 0.0, 0.0, 5.0
		Text ProjectedX# (), ProjectedY# (), "Z+", True, True
		;^^^^^^
		
		; -- Draw Z- axis marker.
		CameraProject cam, 0.0, 0.0, -5.0
		Text ProjectedX# (), ProjectedY# (), "Z-", True, True
		;^^^^^^
	
	EndIf
	
	Flip
	
	WaitTimer( timer )
	
Wend

End

</textarea> <br><br></td></tr></table><br>
<a name="876953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I recently started a little game in 3D as an exercise (I'm way more comfortable in 2D), and right now it's best thought of as a 2D-in-3D (baby steps, here) shooter, with an increasing Y position moving things upwards on the screen and an increasing X moving things to the right. <br></div><br><br><div class="quote"> But when I implement it, the value for DeltaRoll always seems to be 90 or -90 <br></div><br><br>+90 &amp; -90 are the pitchangle max min so it looks to me as if you're using the XZ axis rather than XY axis which you originally asked for. <br><br></td></tr></table><br>
<a name="877005"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm... it's possible that in trying different ideas, I somehow accidentally switched axes.  Thanks a lot guys for your continued help. <br><br></td></tr></table><br>
<a name="877047"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Buggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yup... I just checked and somewhere amidst all of the fiddling, I had added some RotateNormals and RotateEntity commands that were screwing things up... but I didn't notice because moving entities along each axis moved them the way they were supposed to, and pitch/yaw/roll worked normally as well.<br><br>Without trying to wrap my mind around how that happened, I'm just glad that everything works now, including Stevie G's DeltaRoll stuff and Bill Stanbrook's smart-missile idea.<br><br>Thanks a lot, guys! <br><br></td></tr></table><br>
<a name="891962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bailius Maximus</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stevie G -<br><br>Your DeltaRoll function works like a charm, but like a charm it feels like magic, magic that I can't seem yet to divine.<br><br>How does "TFormPoint 0, 0, 0, Target, Source" produce different TFormedX and Y values as the Source rotates?  I really don't understand how 2 absolute points can be compared in this command in order to get a rotation angle for a Source that can be pointing in any direction to point to a Target entity (doesn't matter which way this entity points).  But as I already said, it works, so what voodoo does it do?<br><br>Along with the above question, I'm also confused by any TForm command that doesn't use an entity as the source and 3D space (i.e., 0) as the destination which seems to be the only examples in the Blitz help docs...seems like the following (potentially more complex?) permutations are also possible:<br>1)  entity, entity (as in your example above and related to this posting)<br>2)  3D world, entity (as in some other examples I've seen)<br>3)  3D world, 3D world (I assume this is possible?)<br><br>Any clarification on these would allow me to keep at least the rest of my hair, and, of course, thanks for all your past help in the forum. <br><br></td></tr></table><br>
<a name="892011"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> All the tformpoint 0,0,0,Target, Source does is finds out what position the Target is relative to the Source in the Sources local coords.  Using the tform commands means that scale and rotation of the source are taken into consideration. <br><br>I use the tform commands alot and they are probably the most useful commands in blitz for me.<br><br>There are loads of uses, too many to list ...<br><br><b>(2) Applying pseudo fiction to a road tyre.</b><br><br>Say Vx, Vy and Vz represent the world velocity of the tyre.  Clearly a tyre can be moving in a different direction to the way it's pointing.  To get the velocity relative to the direction the tyre is pointing use :<br><br><pre class=code>
tformvector Vx#, Vy#, Vz#, 0 , TyreMesh
</pre><br><br>Then, to reduce the velocity on the lateral and longitudinal directions relative to the direction of the tyre ..<br><br><pre class=code>
Vx# = tformedx() * .75
Vy# = tformedy()
Vz# = tformedz() * .99
</pre><br><br>Then to get the new vx, vy , vz in world coords ...<br><br><pre class=code>
tformvector Vx, Vy, Vz, TyreMesh, 0
Vx# = tformedx()
Vy# = tformedy()
Vz# = tformedz()
</pre><br><br><b>(3) World to World</b> <br>This is pretty pointless as the assumption with world coords is that there is no rotation or scale.<br><br>Is there anything specific you don't understand?<br><br>Stevie <br><br></td></tr></table><br>
<a name="892017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bailius Maximus</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stevie - <br>Thank you for your response.<br><br>You've given me something to chew on with respect to the other permutations...I am still confused about the TFormPoint command though.<br><br>TFormVector and TFormNormal give results (at least with the examples in Blitz help docs TForming an entity to 3D space) that are intuitive to me.<br><br>On the other hand, I'm not sure what TFormPoint is telling me (with the resulting TFormedX, etc. commands).  It seems to make sense when the ship is pointing up at zero roll.  It seems to be telling me the ship is in the target's local coordinates - basically a vector from the target to the ship.  But as soon as the ship rotates and does not move it's position, the TFormedX, etc. commands change values (specifically the X and Y versions in the code following program authored originally by you I think (Hit space to change target location and hit G to rotate a bit):<br><br><br>Graphics3D 1280,1024,32,1<br><br>Global Camera = CreateCamera() : PositionEntity Camera, 0, 0, -30<br>Global Ship = CreateCone(): ScaleMesh Ship, 1, 2, 1 : EntityColor Ship, 0,0,255 ;: PositionEntity Ship, +0.000, +0.000, +10.000<br>Global Target = CreateCube() : EntityColor Target,255,0,0<br><br>WireFrame True<br><br>Repeat<br>	<br>	If KeyHit( 57 )<br>		PositionEntity target, Rand(-20,20 ), Rand(-20,20 ), 10<br>	EndIf<br>	<br>	DR# = DELTAroll#( Ship, Target )<br>	<br>	If KeyHit( 34 )<br>		TurnEntity ship, 0, 0, DR# * 0.10<br>	End If<br>	<br>	RenderWorld()<br>	<br>	Text 10,10,"Delta Raw:  "+DR#<br>	<br>	Text 10,30,"TFormedX:   "+TFormedX()<br>	Text 10,40,"TFormedY:   "+TFormedY()<br>	Text 10,50,"TFormedZ:   "+TFormedZ()<br>	<br>	Text 10,70,"Target X:   "+EntityX( target )<br>	Text 10,80,"Target Y:   "+EntityY( target )<br>	Text 10,90,"Target Z:   "+EntityZ( target )<br>	<br>	Text 10,110,"Ship X:   "+EntityX( ship )<br>	Text 10,120,"Ship Y:   "+EntityY( ship )<br>	Text 10,130,"Ship Z:   "+EntityZ( ship )<br>	<br>	Flip<br>	<br>Until KeyDown(1)<br><br>;=================================================================================<br>;=================================================================================<br>;=================================================================================<br><br>Function DELTAroll#( Source , Target )<br>	<br>	TFormPoint 0,0,0 , Target, Source<br>	Return VectorYaw ( TFormedX() , 0 , TFormedY() )<br>	<br>End Function<br><br>So after running the above and hitting spacebar once, the target will move and provide a vector within the TFormed commands in order to get from the target to the ship.  Once G is hit to rotate the ship a bit, the TFormed commands produce different values even though neither entity actually moved locations.  Perhaps the TFormed results are derived from 2 components - relative location and angle of rotation even though 0,0,0 is used in it?  To me, it seems that angle of rotation would only come into play with respect to the TFormed commands if non-zeros were used in the TFormPoint command.<br><br>So I suppose, I'm just not sure what the TFormPoint does and what it is trying to tell the uninitiated through it's TFormedX,Y, and Z commands.  None of the Blitz help docs for TFormPoint addressed angle of rotation.<br><br>I apologize for the long winded-ness fo the above...thanks for your help! <br><br></td></tr></table><br>
<a name="892021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> The changing tformed results are expected behaviour.  You're rotating the source so the target object will be in a different position relative to it's position and rotation.<br><br>In the exmple ..<br><br><pre class=code>
tformpoint 0,0,0,Target, Source
</pre><br><br>If I were to change this to 0,0,10 then the point in world space would be 10 units in front of the target.  Note that the Targets rotation would now come into play.  By using 0,0,0 this ensures the point in world space is exactly where the Target entity is and the Targets rotation is irrelevant here.  <br><br>Make sense? <br><br></td></tr></table><br>
<a name="892040"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bailius Maximus</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again...<br><br>There's nothing, it seems, in the Blitz help docs for TFormPoint that indicates that it can be used in this manner so maybe I'm missing the general point of what TFormPoint does (perhaps I ony understand it's most basic application)...I understand the example where 0,1,0 in local space can be something totally different in world space due to rotation and scaling, but in this case there is no vector provided for all coords are zero (0,0,0).<br><br>Regardless, I was able to get the code to work in my project so again I thank you. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
