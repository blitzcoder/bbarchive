<!DOCTYPE html><html lang="en" ><head ><title >Need help with my 2D level editor</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Need help with my 2D level editor</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Need help with my 2D level editor</a><br><br>
<a name="1123210"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all, I found some code by Krylar that is a complete 2D level Editor... Problem is, it won't work with the maplib.bb :/ If someone can help get Map_SaveBinaryMap(filename$), and Map_LoadBinaryMap(filename$) to work, it would be greatly appreciated! :)<br><br><br>Editor.bb: <br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Include "scancodes.bb"

Graphics 1024,768,0,2
AppTitle "Platform editor v2.0"
SetBuffer BackBuffer()
Include "maplib.bb"
AutoMidHandle False		;Images placed by their top left
TFormFilter 0
;32
Dim map1(32,24)
Dim mapcol(32,24)
Dim mapData(32,24)

Global mapx = 32
Global mapy = 24
Global mapx1 = 0
Global skypos
Global gridon = False
Global mapview = 1024

Global tiles = LoadAnimImage("gfx/Ztileset.bmp",32,32,0,10)
Global sky = LoadImage("gfx\sky1.bmp")
MaskImage tiles,255,0,255
TileImage sky

Global cursorx,cursory
Global gx,gy
Global currenttile=1
Global rpik,rpik2
Global rcol,rcol1,rcol2
Global mode=1
Global coltype=1

Const erasetile = 0

fill()

; Main
While Not KeyHit(1)
Cls


sky()
update()
grid()
control()
info()


Flip
Wend



Function control()

If mode=1
    If KeyDown(k_left) = mapx Then mapx = mapx+1 : mapx1 = mapx1 +1
	If KeyHit(12) And mode=1 Then currenttile=currenttile-1
	If KeyHit(13) And mode=1 Then currenttile=currenttile+1

	
	If KeyHit(34) 
	If gridon=True
	gridon=False
	Else
    gridon=True
	EndIf
	EndIf
	
	If currenttile&lt;0 Then currenttile=9
	If currenttile&gt;9 Then currenttile=0
    If KeyHit(46) Then mode=2	
    gx=MouseX()/32
    gy=MouseY()/32
	Color 256,0,0
	Line MouseX()-10,MouseY(),MouseX()+10,MouseY()
	Line MouseX(),MouseY()-10,MouseX(),MouseY()+10
	If MouseDown(1) And gx &lt; 32 And gy &lt; 24 Then map1(gx,gy)=currenttile
	If MouseDown(2) And gx &lt; 32 And gy &lt; 24 Then map1(gx,gy)=0
	
EndIf

If mode=2 
	If KeyHit(12) And mode=2 Then coltype=coltype-1
	If KeyHit(13) And mode=2 Then coltype=coltype+1
	If coltype&lt;1 Then coltype=1
	If coltype&gt;2 Then coltype=2
	
	Color 256,0,0
	Line MouseX()-10,MouseY(),MouseX()+10,MouseY()
	Line MouseX(),MouseY()-10,MouseX(),MouseY()+10
    gx=MouseX()/32
    gy=MouseY()/32
	If KeyHit(46) Then mode=1
	If MouseDown(1) And gx &lt; 32 And gy &lt; 24 And coltype=1 Then  mapcol(gx,gy)=1
	If MouseDown(1) And gx &lt; 32 And gy &lt; 24 And coltype=2 Then  mapcol(gx,gy)=2
	If MouseDown(2) And gx &lt; 32 And gy &lt; 24 Then mapcol(gx,gy)=0
EndIf


	If KeyHit(59)
		Map_SaveBinarymap("scrollmap2.dat")
	EndIf
	
	If KeyHit(60)
		Map_LoadBinarymap("scrollmap2.dat")
	EndIf
	
	If KeyHit(203)
	mapview=mapview+1
	EndIf
	
	If KeyHit(208)
	
	EndIf
	
End Function



Function update()

If mode=1
For x=0 To mapx
	For Y=0 To mapy
    DrawImage tiles,x*32,y*32,map1(x,y)	
	Next	
Next

Color 0,0,0
Rect 0,0,40,40,1
DrawImage tiles,3,3,currenttile
EndIf

If mode=2
For x=0 To mapx
	For Y=0 To mapy
	DrawImage tiles,x*32,y*32,map1(x,y)	
	If mapcol(x,y)=1
	Color 0,0,0
    Rect x*32,y*32,32,32,0
    EndIf	
	If mapcol(x,y)=2
	Color 255,0,0
    Rect x*32,y*32,32,32,0
    EndIf	
	Next
	Color 0,0,0
    Rect 0,0,40,40,1
    If coltype=1 
	Color 0,0,0
	Rect 3,3,32,32,1
	EndIf
	If coltype=2
	Color 255,0,0 
	Rect 3,3,32,32,1
	EndIf
Next


EndIf

End Function


Function sky()

TileBlock sky,skypos,0 

skypos=skypos+1

End Function


Function info()

If mode=1
Text 100,0,"Press C to change to collision mode   leftclick = place tile   rightclick = remove tile   + and - change tiles"
Text 100,20,"F1 to save - F2 to load   Unfortunatly it only saves as (lvl1.lvl) SOZ"
Text 100,40,"Press D to change to data mode    Press G for grid mode " 

EndIf
If mode=2
Text 100,0,"Press C to change to scenery mode   leftclick = place collision   rightclick = remove collision"
EndIf

End Function



;Function save(filename$)

	;f=WriteFile(filename$)

	;For y=0 To 24
		;For x=0 To 32
			;WriteInt f,map1(x,y)
		;Next
	;Next
	
	;For y=0 To 24
		;For x=0 To 32
			;WriteInt f,mapcol(x,y)
		;Next
	;Next

	;CloseFile f

;End Function


;Function load(filename$)

	;f=OpenFile(filename$)

	;For y=0 To 24
		;For x=0 To 32
			;i=ReadInt(f)
			;map1(x,y)=i
		;Next ;x
	;Next ;y
	
	;For y=0 To 24
		;For x=0 To 32
			;i=ReadInt(f)
			;mapcol(x,y)=i
		;Next ;x
	;Next ;y

	;CloseFile f

;End Function



Function grid()

If gridon=True
For x=0 To mapx
	For y=o To mapy
	Rect x*32,y*32,32,32,0
	Next
Next
EndIf

End Function


Function fill()
For x=0 To mapx
	For y=0 To mapy
    map1(x,y)=5
	Next
Next
End Function</textarea><br><br><br>Here's maplib.bb: <br><br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;***************************************************************************
;*   Library Name: MapLib
;*       Coded By: Krylar
;*   Last Updated: 7/19/2004
;*        Purpose: To allow the loading of tiles and maps for display and
;*                 and scrolling.  Handles both Text and Binary, but does
;*                 NOT do encryption.
;*                 
;*                 Also now includes the collision information and checking. 
;***************************************************************************


;*************************************************************************
;* Begin Map Control Defines
;*************************************************************************

; Type For the TileList
Type Map_Tiles
     Field Image
     Field Width
     Field Height
End Type

; Global to track the number of tiles
Global Map_TotalTiles = 0

; Dimension our tile array
Dim Tile.Map_Tiles(Map_TotalTiles)
Global Map_FullTiles

; Type for the Map_Data
Type Map_Data
     Field TileNumber
End Type

; Globals to track the map dimensions
Global Map_Width = 1
Global Map_Height = 1
Global Map_X_Start = 0
Global Map_Y_Start = 0
Global Map_X_DisplayOffset = 0
Global Map_Y_DisplayOffset = 0
Global Map_ScrollWidth = 0
Global Map_ScrollHeight = 0

; Dimension our Map array
Dim Map.Map_Data(Map_Width,Map_Height)
Dim MapHold.Map_Data(Map_Width,Map_Height)

;*************************************************************************
;* End Map Control Defines
;*************************************************************************
;
;
;
;*************************************************************************
;* Begin Collision Control Defines
;*************************************************************************

; create the Player collision array for bounding boxes on the player
Dim Map_PlayerCollisionArray(16)

; setup the walls type for knowing where all the walls are for collisions
Type Map_Walls
    Field TileNumber
    Field X
    Field Y
End Type

; make the walls type global
Global Wall.Map_Walls = First Map_Walls

;*************************************************************************
;* End Collision Control Defines
;*************************************************************************
;
;
;
;*************************************************************************
;* Begin Map Control Functions
;*************************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadMap(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads ONLY the map, no tiles!
;
; Arguments: 
;    Map_Full_Path$ = Map filename, including the full path
;    MapType = 0=Text, 1=Binary
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadMap(Map_Full_Path$,MapType)

  If MapType = 0
     ; call the Map_ReadDimensions to get the proper rows/columns
     Status = Map_ReadTextMapDimensions(Map_Full_Path$)

     If Status = -1
        Return(-2)
     EndIf  

     ; Now read the actual data from that map file
     Status = Map_LoadTextMap(Map_Full_Path$)
     If Status = -1
        Return(-3)
     EndIf
  Else
     Status = Map_LoadBinaryMap(Map_Full_Path$)
     If Status = -1
        Return(-3)
     EndIf

  EndIf
  Return(0)
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadTiles(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads in the actual tiles to be used
;  with the map.  It takes into account any boxes that may have 
;  been placed around each image by allowing the caller to specify
;  the box widths and heights.
;
; Arguments: 
;    Tile_Full_Path$ = Tile Image file, including the full path
;    TileWidth = Width of the tiles being loaded
;    TileHeight = Height of the tiles being loaded
;    TileSpacer = If there are boxes around the tiles, set this to
;              the number of pixels that the boxes are wide and high.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadTiles(Tile_Full_Path$,TileWidth,TileHeight,TileSpacer)

  For TileCounter = 0 To Map_TotalTiles - 1
      If Tile.Map_Tiles(TileCounter) &lt;&gt; Null
         FreeImage Tile(TileCounter)\Image
         Delete Tile(TileCounter)
      EndIf
  Next

  ; first off let's load the full image containing all the tiles
  ; into a temporary space
  Temp_Image=LoadImage(Tile_Full_Path$)

  ImageSizeX = ImageWidth(Temp_Image)
  ImageSizeY = ImageHeight(Temp_Image)

  TileColumns = ImageSizeX / TileWidth
  TileRows = ImageSizeY / TileHeight

  Dim Tile.Map_Tiles(TileRows * TileColumns )
  
  If Temp_Image = 0
     Return(-1)
  EndIf

  ; get the current buffer so we can restore to it
  CurrentBuffer = GraphicsBuffer()

  ; next make that image the current buffer
  SetBuffer ImageBuffer(Temp_Image)



  ; setup our basic vars.  The X and Y values will be whatever the XSpacer
  ; and YSpacer values are. If they are 0, then it's assumed that there is
  ; no space between the tiles. If you look at the sample images included
  ; with this demo you'll see a white box around each image...that's why
  ; I have these spacers...we don't wanna load the boxes, just the images.
  X = TileSpacer
  Y = TileSpacer

  ; keep track of the number of images
  ImageNumber = 0

  ; run through the total number of rows (minus 1, of course)
  For Rows=0 To TileRows  -1
      ; and run through all the columns per row (minus 1 again)
      For Columns=0 To TileColumns  -1
          ; create a new TileList element and assign it the current
          ; ImageNumber.  Then populate the TileList element with
          ; the TileWidth, TileHeight, and the actual Tile_Image
          Tile.Map_Tiles(ImageNumber) = New Map_Tiles
          Tile(ImageNumber)\Width = TileWidth
          Tile(ImageNumber)\Height = TileHeight

          ; to get the image, we first use CreateImage(...) to make sure
          ; BB allocates enough space in the TileList field Tile_Image 
          Tile(ImageNumber)\Image=CreateImage(TileWidth,TileHeight)

          ; then we grab the image based off the size setup in CreateImage(...)
          ; from our X,Y location
          GrabImage(Tile(ImageNumber)\Image,X,Y)
         
          ; now we add X to the TileWidth and the XSpacer to get the new X position.
          ; So, if our current X = 2, and the TileWidth = 32 and the XSpacer = 2, we'd
          ; have X = 2 + 32 + 2, or 36.  This means that the next time we call         
          ; GrabImage(...) it will start grabbing from the X position 36 (or the 36th pixel 
          ; from the left).         
          X=X + TileWidth + TileSpacer

          ; increment our tile counter (for the array positioning)
          ImageNumber = ImageNumber + 1
      Next
      ; we've finished with that row, so reset X back to the spacer position
      X = TileSpacer

      ; now we add Y to the TileHeight and the YSpacer to get the new Y position.
      ; So, if our current Y = 2, and the TileHeight = 32 and the YSpacer = 2, we'd
      ; have Y = 2 + 32 + 2, or 36.  This means that the next time we call  
      ; GrabImage(...) it will start grabbing from the Y position 36 (or the 36th pixel 
      ; from the top).         
      Y = Y + TileHeight + TileSpacer
  Next
  
  ; restore the buffer
  SetBuffer CurrentBuffer

  ; free the image from memory, so we don't hold memory for no reason
  FreeImage Temp_Image

  ; reset our global tile tracker
  Map_TotalTiles = ImageNumber

  Return(0)
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_ReadTextDimensions(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads in the actual dimensions of
;  the map file and stores the values in Map_Width and Map_Height.
;  This function is for use with TEXT files only.
; Arguments: 
;    Map_Full_Path$ = Map file, including the full path
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_ReadTextMapDimensions(Map_Full_Path$)

  ; first thing we do is open the file using a Pointer Variable (which
  ; is "File" in this case)
  File=ReadFile(Map_Full_Path$);

  ; Then we read the first line of the file...it *should* contain the
  ; width/height data.  If it doesn't, somebody goofed up on the layout
  ; of the file
  MapDimensions$ = ReadLine$(File);

  ; we need to set up some variables to parse the line.  We could just
  ; set this up to have the x,y on two lines and save some trouble from
  ; a coding perspective, but this method makes the map creation more
  ; intuitive for the user...and that's our job ;)
  EndOfString = 0
  Offset = 0

  ; while we haven't reached the end of the string
  While EndOfString = 0
        ; let's first put the current position in the string into Temp$
        ; this is just 1 character from the string cause we use the Mid$(...)
        ; command to yank out that value
        Temp$ = Mid$(MapDimensions$,Offset+1,1)

        ; if that character is not a comma we haven't gone past the length
        ; of the string
        If Temp$ &lt;&gt; "," And (Offset &lt;= Len(MapDimensions$))
          ; then it must be a number, so we save it in the HoldString$
          HoldString$ = HoldString$ + Temp$
        ; otherwise, it's either gone too far or it's the comma seperator
        Else
           ; if we've gone too far, then we know that the Map_Height is done
           If Offset &gt; Len(MapDimensions$)
              ; so we convert the current HoldString$ to an Int and assign it
              Map_Height = Int(HoldString$)
              ; and make sure the While loop breaks
              EndOfString = 1
          ; it must be a comma, so that means our Map_Width value is loaded
          Else
             ; convert the current HoldString$ to an int and assign it
             Map_Width = Int(HoldString$)
             ; reset the HoldString$ to blank so we can start loading Map_Height
             HoldString$ = ""
          EndIf
        EndIf
        ; increase the string position offset by 1 (to move to the next character)
        Offset = Offset + 1
   Wend
   ; we're done, so close the file!
   CloseFile(File)

  Dim Map.Map_Data(Map_Width,Map_Height)

  Map_Init(Map_Width,Map_Height)


  Return(0)
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadTextMap(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads in the actual map information.
;  This function is for use with TEXT files only.
;
; Arguments: 
;    Map_Full_Path$ = Map file, including the full path
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadTextMap(Map_Full_Path$)

  ; first thing we do is open the file using a Pointer Variable (which
  ; is "File" in this case)
  File=ReadFile(Map_Full_Path$);
  ; read the Map dimensions line, but don't do anything with it...this
  ; is just to move to the map data line.  Use the Map_ReadTextDimensions(...)
  ; function for getting the actual Map_Width/Map_Height, so you can DIM
  ; the Map_Data array appropriately
  MapDimensions$ = ReadLine$(File);

  ; set up our vars for array placements.  The X will be for columns, and
  ; the Y will be for rows.  The EndOfFile just let's us keep track of how
  ; far into the file we've gone.
  X=0
  Y=0
  EndOfFile = 0

  ; do this until we reach the end of the file
  While EndOfFile = 0

        ; read a line of data from the file and put it in the MapLine$ string
        MapLine$ = ReadLine$(File);

        ; make sure that the length of the line is more than 1 character
        If Len(MapLine$) &gt; 1

           ; set up our EndOfString var to be 0...this will help us keep
           ; track of the current MapLine$ string position
           EndOfString = 0
           ; This Offset var will let us keep track of our current position
           ; in the MapLine$ string
           Offset = 0

           ; until we reach the end of the MapLine$ string
           While EndOfString = 0
                
                 ; let's first put the current position in the string into Temp$
                 ; this is just 1 character from the string cause we use the Mid$(...)
                 ; command to yank out that value
                 Temp$ = Mid$(MapLine$,Offset+1,1)

                 ; if that character is not a comma we haven't gone past the length
                 ; of the string
                 If Temp$ &lt;&gt; "," And (Offset &lt;= Len(MapLine$)) 
                    ; then it must be a number, so we save it in the HoldString$
                    HoldString$ = HoldString$ + Temp$
                 ; otherwise, it's either gone too far or it's the comma seperator
                 Else
                    ; if we've gone too far, then we know that this line is done
                    If Offset &gt; Len(MapLine$)
                       ; so we make a new Map_Data element in our Map(x,y) array
                       Map.Map_Data(X,Y) = New Map_Data
                       ; fill in the number of the HoldString$ by converting it to an Int
                       Map(X,Y)\TileNumber = Int(HoldString$)
                       ; reset the HoldString$ to a blank
                       HoldString$ = ""
                       ; exit the loop for *this* line (so we can read the next one)
                       EndOfString = 1
                    ; it must be a comma, so that means this column's value is loaded
                    Else
                       ; so we make a new Map_Data element in our Map(x,y) array
                       Map.Map_Data(X,Y) = New Map_Data
                       ; fill in the number of the HoldString$ by converting it to an Int
                       Map(X,Y)\TileNumber = Int(HoldString$)
                       ; reset the HoldString$ to a blank
                       HoldString$ = ""
                       ; Increase the X (or Column) location for the Array
                       X=X+1
                    EndIf
                 EndIf
                 ; add one to our string position offset
                 Offset = Offset + 1
            Wend
            ; set X back to 0 (so we're back to column 0)
            X=0
            ; add 1 to Y (so we move down 1 row in the array)
            Y=Y+1
        ; if we've gone past the length of the file
        Else
            ; then tell the loop to stop cause we're done!
            EndOfFile = 1
        EndIf
   Wend
   ; make sure to close the file!
   CloseFile(File)

  Return(0)

End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_ShowMap(...)
;       Author:  Krylar
; Last Updated: 7/19/2004
;  Description: This function moves and displays a map starting at
; a user-defined top-left corner at whatever width/height the user
; wants.  It will move N/S/E/W directions and do so at whatever 
; distance (speed) the user needs.  
;
; Arguments: 
;    XOffset    = Where to start the left edge
;    YOffset    = Where to start the top edge
;    Direction  = 1-North, 2-South, 3-East, 4-West
;    Distance   = How far to move the map per call
;    ShowWidth  = How many columns to show (tiles)
;    ShowHeight = How many rows to show (tiles)
;    TileWidth  = How Wide are the tiles for the map
;    TileHeight = How High are the tiles for the map
;    ShowBoxes  = 0-No, 1-Show collision Points
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_ShowMap(XOffset,YOffset,Direction,Distance,ShowWidth,ShowHeight,TileWidth,TileHeight,ShowBoxes)
    RowPosition = 0
    ColumnPosition = 0

    ; Which way are we scrolling the map?
    Select Direction 
           Case 1 ; North
                 ; First let's make sure that we're not already on the edge
                 If Map_Y_Start &gt; 0
                    ; Start counting up to zero for our offset
                    Map_Y_DisplayOffset =  Map_Y_DisplayOffset + Distance
                    ; if we hit or go past zero, subtract the amount over 0
                    ; from the TileHeight the user passed along and decrement
                    ; our Map Y starting position
                    If Map_Y_DisplayOffset &gt; 0
                       Map_Y_DisplayOffset = -(TileHeight) + Distance
                       Map_Y_Start = Map_Y_Start - 1    
                    EndIf
                    ; We want to show exactly the ShowHeight
                    Map_ScrollHeight = Map_Y_Start + ShowHeight
                 Else
                    ; since we're already on Zero (top edge), just keep scrolling
                    ; until the offset hits the edge too.  
                    If Map_Y_DisplayOffset &lt; 0
                       Map_Y_DisplayOffset = Map_Y_DisplayOffset + Distance
                    EndIf
                    ; We want to show one over the ShowWidth here so we don't
                    ; end up with blinking edges
                    Map_ScrollHeight = Map_Y_Start + ShowHeight + 1
                 EndIf

           Case 2 ; South
                 ; Verify that we've not gone too far down
                 If Map_Y_Start &lt; Map_Height - ShowHeight - 1 And Map_Y_Start &gt;= 0
                    ; Count down to the AdjustedTileSize (see above)
                    Map_Y_DisplayOffset = Map_Y_DisplayOffset - Distance
                    ; if we hit or go past the negative size, add that amount
                    ; to the Tile size sent by the user and make it negative.
                    If Map_Y_DisplayOffset &lt; -(TileHeight) 
                       Map_Y_DisplayOffset = 0 - Distance
                       ; Increment our Map position
                       Map_Y_Start = Map_Y_Start + 1   
                       ; Do another sanity check to make sure we didn't run over.
                       ; if we did, drop the Map position back 1 and set the offset
                       ; so it's on the edge (no more scrolling)
                       If Map_Y_Start &gt;= Map_Height - ShowHeight
                          Map_Y_Start = Map_Y_Start - 1
                       EndIf 
                    EndIf
                    ; We want to show exactly the ShowHeight
                    Map_ScrollHeight = Map_Y_Start + ShowHeight
                 Else
                    If Map_Y_Start &gt; 0
                       ; We must already be at the point where the right edge is showing, so
                       ; just scroll until the offset hits the edge too.
                       Map_Y_DisplayOffset = Map_Y_DisplayOffset - Distance
                       ; if we hit or go past the negative size, add that amount
                       ; to the Tile size sent by the user and make it negative.
                       If Map_Y_DisplayOffset &lt; -(TileHeight) 
                          Map_Y_DisplayOffset = -(TileHeight)
                       EndIf
                    EndIf
                 EndIf

           Case 3 ; West (Left Arrow key)
                 ; First let's make sure that we're not already on the edge
                 If Map_X_Start &gt; 0
                    ; Start counting up to zero for our offset
                    Map_X_DisplayOffset =  Map_X_DisplayOffset + Distance
                    ; if we hit or go past zero, subtract the amount over 0
                    ; from the TileWidth the user passed along and decrement
                    ; our Map X starting position
                    If Map_X_DisplayOffset &gt; 0
                       Map_X_DisplayOffset = -(TileWidth) + Distance
                       Map_X_Start = Map_X_Start - 1    
                    EndIf
                    ; We want to show exactly the ShowWidth
                    Map_ScrollWidth = Map_X_Start + ShowWidth
                 Else
                    ; since we're already on Zero (left edge), just keep scrolling
                    ; until the offset hits the edge too.  
                    If Map_X_DisplayOffset &lt; 0
                       Map_X_DisplayOffset = Map_X_DisplayOffset + Distance
                    EndIf
                    ; We want to show one over the ShowWidth here so we don't
                    ; end up with blinking edges
                    Map_ScrollWidth = Map_X_Start + ShowWidth + 1
                 EndIf

           Case 4 ; East (Right Arrow Key)
                 ; Verify that we've not gone too far right
                 If Map_X_Start &lt; Map_Width - ShowWidth - 1 And Map_X_Start &gt;= 0
                    ; Count down to the AdjustedTileSize (see above)
                    Map_X_DisplayOffset = Map_X_DisplayOffset - Distance
                    ; if we hit or go past the negative size, add that amount
                    ; to the Tile size sent by the user and make it negative.
                    If Map_X_DisplayOffset &lt; -(TileWidth) 
                       Map_X_DisplayOffset = 0 - Distance
                       ; Increment our Map position
                       Map_X_Start = Map_X_Start + 1   
                       ; Do another sanity check to make sure we didn't run over.
                       ; if we did, drop the Map position back 1 and set the offset
                       ; so it's on the edge (no more scrolling)
                       If Map_X_Start &gt;= Map_Width - ShowWidth
                          Map_X_Start = Map_X_Start - 1
                       EndIf 
                    EndIf
                    ; We want to show exactly the ShowWidth
                    Map_ScrollWidth = Map_X_Start + ShowWidth
                 Else
                    If Map_X_Start &gt; 0
                       ; We must already be at the point where the right edge is showing, so
                       ; just scroll until the offset hits the edge too.
                       Map_X_DisplayOffset = Map_X_DisplayOffset - Distance
                       ; if we hit or go past the negative size, add that amount
                       ; to the Tile size sent by the user and make it negative.
                       If Map_X_DisplayOffset &lt; -(TileWidth) 
                          Map_X_DisplayOffset = -(TileWidth)
                       EndIf
                    EndIf
                 EndIf

           ; we're not moving the map, but the map still needs to be display, so 
           ; just check where we are on the map and then display the proper width/height
           ; to avoid blinking.
           Default
                 If Map_X_Start &lt; Map_Width - ShowWidth
                    Map_ScrollWidth = Map_X_Start + ShowWidth
                 Else
                    Map_ScrollWidth = Map_X_Start + ShowWidth - 1
                 EndIf

                 If Map_Y_Start &lt; Map_Height - ShowHeight
                    Map_ScrollHeight = Map_Y_Start + ShowHeight
                 Else
                    Map_ScrollHeight = Map_Y_Start + ShowHeight - 1
                 EndIf
                 If Distance = -1
                    Map_X_DisplayOffset = 0
                    Map_Y_DisplayOffset = 0
                 EndIf
    End Select

    ; hook up our X, Y values to draw the images at the proper locations
    X = Map_X_DisplayOffset + XOffset
    Y = Map_Y_DisplayOffset + YOffset

    ; and then run through the Arrays and Draw stuff out!
    For Rows = Map_Y_Start To Map_ScrollHeight
        For Columns = Map_X_Start To Map_ScrollWidth
            TileNumber = Map(Columns,Rows)\TileNumber
            ; if the Tile isn't a -1, then draw it
            If TileNumber &lt;&gt; -1
               DrawImage Tile(TileNumber)\Image,X,Y
            EndIf

            ; if the user wants to see the collision boxes, draw them here
            If ShowBoxes = 1
               For Wall.Map_Walls = Each Map_Walls
                   If Wall\TileNumber = TileNumber
                      Color 0,255,255
                      Rect X,Y,TileWidth,TileHeight,0
                      Text X+10,Y+10, TileNumber
                      Exit
                   EndIf
               Next
            EndIf
            ; increase our X position for tile drawing
            X = X + TileWidth
        Next
        ; reset the X position and increase the Y position
        X = Map_X_DisplayOffset + XOffset
        Y = Y + TileHeight
    Next

End Function




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_VerifyMapAndTiles(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function makes sure that all the numbers 
;               within a Map corresponds to all the Tile numbers.
;               It replaces invalid numbers with -1.
;
; Arguments: 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_VerifyMapAndTiles()
    Status = 0
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height - 1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width - 1
            TileNumber = Map(Columns,Rows)\TileNumber
            If TileNumber &gt; Map_TotalTiles
               Map(Columns,Rows)\TileNumber = -1
               Status = -1
            EndIf               
        Next
    Next
    Return(Status)
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_ClearMap(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: Clear the map, but allow it to be blanked to a 
;               particular size.
;
; Arguments: 
;        Width: How wide should the cleared map be defaulted to?
;        Height: How high should the cleared map be defaulted to?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_ClearMap(Width,Height)

    Map_Width = Width
    Map_Height = Height

    Dim Map.Map_Data(Map_Width,Map_Height)
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = -1
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_Init(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function initialize a map with all -1 values
;               for elements.
;
; Arguments: 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_Init(Width,Height)

    Map_Width = Width
    Map_Height = Height

    Dim Map.Map_Data(Map_Width,Map_Height)
    Dim MapHold.Map_Data(Map_Width,Map_Height)
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = -1
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_IncreaseWidth(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function increases the Map width by re-
;               dimensioning the Map array and copying over 
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to increase the width
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_IncreaseWidth(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    CurrentWidth = Map_Width
    CurrentHeight = Map_Height

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Width = Map_Width + Amount
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            If Map.Map_Data(Columns,Rows) = Null
               Map.Map_Data(Columns,Rows) = New Map_Data
               Map(Columns,Rows)\TileNumber = -1
            EndIf
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_DecreaseWidth(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function decreases the Map width by re-
;               dimensioning the Map array and copying over only
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to decrease the width
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_DecreaseWidth(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Width = Map_Width - Amount
    If Map_Width &lt;= MapGridColums
       Map_Width = MapGridColums
    EndIf
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_IncreaseHeight(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function increases the Map height by re-
;               dimensioning the Map array and copying over 
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to increase the height
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_IncreaseHeight(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    CurrentWidth = Map_Width
    CurrentHeight = Map_Height

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Height = Map_Height + Amount
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            If Map.Map_Data(Columns,Rows) = Null
               Map.Map_Data(Columns,Rows) = New Map_Data
               Map(Columns,Rows)\TileNumber = -1
            EndIf
        Next
    Next
    
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_DecreaseHeight(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function decreases the Map height by re-
;               dimensioning the Map array and copying over only
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to decrease the height
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_DecreaseHeight(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Height = Map_Height - Amount
    If Map_Height &lt;= MapGridRows
       Map_Height = MapGridRows
    EndIf
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
End Function




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_SaveBinaryMap(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function saves a map in binary format
;
; Arguments: 
;        SaveFileName$: Name to save it as
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_SaveBinaryMap(SaveFileName$)

    ; first open the file for writing.  This *will* overwrite the
    ; existing file.
    FilePtr = WriteFile(SaveFileName$)

    ; write the Map_Width and Map_Height 
    WriteInt(FilePtr,Map_Width)
    WriteInt(FilePtr,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height - 1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width - 1
            ; get the tilenumber
            TileNumber = Map(Columns,Rows)\TileNumber
            ; write it to the file
            WriteInt(FilePtr,TileNumber)
        Next
    Next
    ; close the file!
    CloseFile(FilePtr)

    Return 0
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadBinaryMap(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function loads a binary map
;
; Arguments: 
;        Map_Full_Path$: Name to load
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadBinaryMap(Map_Full_Path$)

  ; first thing we do is open the file using a Pointer Variable (which
  ; is "File" in this case)
  FilePtr=ReadFile(Map_Full_Path$);

  If FilePtr = -1
     Return -1
  EndIf

  ; for all of the rows (minus 1)
  For Rows = 0 To Map_Height - 1
      ; and for all the columns (minus 1)
      For Columns = 0 To Map_Width - 1
          Delete Map.Map_Data(X,Y)
      Next
  Next

  ; read in the map dimensions
  Map_Width = ReadInt(FilePtr);
  Map_Height = ReadInt(FilePtr);

  Dim Map.Map_Data(Map_Width,Map_Height)

  ; set up our vars for array placements.  The X will be for columns, and
  ; the Y will be for rows.  The EndOfFile just let's us keep track of how
  ; far into the file we've gone.
  X=0
  Y=0
  EndOfFile = 0

  ; for all of the rows (minus 1)
  For Rows = 0 To Map_Height - 1
      ; and for all the columns (minus 1)
      For Columns = 0 To Map_Width - 1
          Map.Map_Data(X,Y) = New Map_Data
          ; read in the encrypted value
          Map(X,Y)\TileNumber = ReadInt(FilePtr)
          ; add 1 to X (so we move 1 column to the right in the array)
          X=X+1
      Next
      ; set X back to 0 (so we're back to column 0)
      X=0
      ; add 1 to Y (so we move down 1 row in the array)
      Y=Y+1
  Next

  ; make sure to close the file!
  CloseFile(FilePtr)

  Return(0)

End Function

;*************************************************************************
;* End Map Control Functions
;*************************************************************************
;
;
;
;*************************************************************************
;* Begin Collision Control Functions                                                  
;*************************************************************************


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION: Map_SetupPlayerBoundingBoxes()
; Author: Krylar
; Last Updated: 7/19/2004
;
; sets up where the x1,y1,x2,y2 values are for the 4 boxes
; that make up the collision points on the player
;
; Arguments:
;          Top, Bottom, Left, Right values of X1, Y1, X2, Y2 - Respectively
;
; Returns: n/a
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_SetupPlayerBoundingBoxes(TopX1,TopY1,TopX2,TopY2,BottomX1,BottomY1,BottomX2,BottomY2,LeftX1,LeftY1,LeftX2,LeftY2,RightX1,RightY1,RightX2,RightY2)
  ; setup the top-box
  Map_PlayerCollisionArray(0) = TopX1
  Map_PlayerCollisionArray(1) = TopY1
  Map_PlayerCollisionArray(2) = TopX2
  Map_PlayerCollisionArray(3) = TopY2
  ; setup the bottom-box
  Map_PlayerCollisionArray(4) = BottomX1
  Map_PlayerCollisionArray(5) = BottomY1
  Map_PlayerCollisionArray(6) = BottomX2
  Map_PlayerCollisionArray(7) = BottomY2
  ; setup the Left-box
  Map_PlayerCollisionArray(8) = LeftX1
  Map_PlayerCollisionArray(9) = LeftY1
  Map_PlayerCollisionArray(10) = LeftX2
  Map_PlayerCollisionArray(11) = LeftY2
  ; setup the Right-box
  Map_PlayerCollisionArray(12) = RightX1
  Map_PlayerCollisionArray(13) = RightY1
  Map_PlayerCollisionArray(14) = RightX2
  Map_PlayerCollisionArray(15) = RightY2
End Function

Function ShowPlayerBoundingBoxes(x,y)
  Color 255,255,0
  Rect X+Map_PlayerCollisionArray(0),Y+Map_PlayerCollisionArray(1),Map_PlayerCollisionArray(2) - Map_PlayerCollisionArray(0),Map_PlayerCollisionArray(3) - Map_PlayerCollisionArray(1),0
  Rect X+Map_PlayerCollisionArray(4),Y+Map_PlayerCollisionArray(5),Map_PlayerCollisionArray(6)-Map_PlayerCollisionArray(4),Map_PlayerCollisionArray(7)-Map_PlayerCollisionArray(5),0
  Rect X+Map_PlayerCollisionArray(8),Y+Map_PlayerCollisionArray(9),Map_PlayerCollisionArray(10)-Map_PlayerCollisionArray(8),Map_PlayerCollisionArray(11)-Map_PlayerCollisionArray(9),0
  Rect X+Map_PlayerCollisionArray(12),Y+Map_PlayerCollisionArray(13),Map_PlayerCollisionArray(14)-Map_PlayerCollisionArray(12),Map_PlayerCollisionArray(15)-Map_PlayerCollisionArray(13),0
  Color 255,255,255
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION: Map_AddWall()
; Author: Krylar
; Last Updated: 7/19/2004
;
; Adds a wall to the collision list
;
; Returns: n/a
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_AddWall(TileToAdd)
   X = 0
   Y = 0
   ; run through all of the map
   For Rows = 0 To Map_Height - 1
       For Columns = 0 To Map_Width - 1
           TileNumber = Map(Columns,Rows)\TileNumber
           ; see if the tile number is one we want designated as a wall
           If TileNumber = TileToAdd
              ; Add it to the Wall Type
              Wall.Map_Walls = New Map_Walls
              Wall\TileNumber = TileNumber
              Wall\X = X
              Wall\Y = Y
           EndIf
           X = X + TileWidth 
       Next
       ; reset X to the beginning of the next row
       X = 0
       ; increase our Y drawing position by the Tile's Height
       Y = Y + TileHeight
   Next

End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION: Map_CheckWallCollisions(...)
; Author: Krylar
; Last Updated: 7/19/2004
;
; Checks an area for collision based on bounding boxes
;
; Returns:
;           0 = no hit
;           1 = collision with wall
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_CheckWallCollision(X,Y)

    ; do one calculation here for each absolute box position
    ; so we don't do them every itteration of our loop below
    BoxTopX1    = X + Map_PlayerCollisionArray(0)
    BoxTopY1    = Y + Map_PlayerCollisionArray(1)
    BoxTopX2    = X + Map_PlayerCollisionArray(2)
    BoxTopY2    = Y + Map_PlayerCollisionArray(3)
    BoxBottomX1 = X + Map_PlayerCollisionArray(4)
    BoxBottomY1 = Y + Map_PlayerCollisionArray(5)
    BoxBottomX2 = X + Map_PlayerCollisionArray(6)
    BoxBottomY2 = Y + Map_PlayerCollisionArray(7)
    BoxLeftX1   = X + Map_PlayerCollisionArray(8)
    BoxLeftY1   = Y + Map_PlayerCollisionArray(9)
    BoxLeftX2   = X + Map_PlayerCollisionArray(10)
    BoxLeftY2   = Y + Map_PlayerCollisionArray(11)
    BoxRightX1  = X + Map_PlayerCollisionArray(12)
    BoxRightY1  = Y + Map_PlayerCollisionArray(13)
    BoxRightX2  = X + Map_PlayerCollisionArray(14)
    BoxRightY2  = Y + Map_PlayerCollisionArray(15)

    ; run through all of the walls
    For Wall.Map_Walls = Each Map_Walls
        XCollision = 0
        YCollision = 0

        ; grab the Type values to speed things up a bit
        WallX = Wall\X
        WallY = Wall\Y
        ; calculate the WallWidth and Height to speed things up
        WallWidth = WallX + TileWidth 
        WallHeight = WallY + TileHeight
     
        ; check the top bounding box
        If BoxTopX1 &gt;= WallX And BoxTopX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxTopY1 &gt;= WallY And BoxTopY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; check the bottom bounding box
        If BoxBottomX1 &gt;= WallX And BoxBottomX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxBottomY1 &gt;= WallY And BoxBottomY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; check the left bounding box
        If BoxLeftX1 &gt;= WallX And BoxLeftX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxLeftY1 &gt;= WallY And BoxLeftY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; check the right bounding box
        If BoxRightX1 &gt;= WallX And BoxRightX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxRightY1 &gt;= WallY And BoxRightY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; if there is a collision on both the X and Y axis, return 1
        If XCollision = 1 And YCollision = 1
           Return 1
        EndIf
    Next
   
  ; no hit so return 0
  Return 0

End Function



;*************************************************************************
;* End Collision Control Functions                                                  
;*************************************************************************</textarea><br><br><br>Here's the demo with all the needed files: <br><br><br><a href="http://www.mediafire.com/?b0i5dp9i3f9qbkb" target="_blank">http://www.mediafire.com/?b0i5dp9i3f9qbkb</a><br><br><br>Thanks for help! :) <br><br></td></tr></table><br>
<a name="1123247"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried looking at Krylar's Level editor, but the import of these 2 functions didn't work &gt;&lt; I don't know why... <br><br></td></tr></table><br>
<a name="1123336"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone? <br><br></td></tr></table><br>
<a name="1123402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can someone help please? <br><br></td></tr></table><br>
<a name="1123458"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I will keep posting until someone answers. :) <br><br></td></tr></table><br>
<a name="1123471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Running what you've provided, you get a runtime error in the maplib.bb in the function Map_SaveBinaryMap() on the line that reads "TileNumber = Map(Columns,Rows)\TileNumber". The MAV lets you know that an object does not exist, which means that you weren't using the system right. This is usually a sign of failing to initialize data (Dims, in this case) before using the functions.<br><br>Krylar's system works, but you have to let his system know first of all how large the total size of the map is. Otherwise, you're going to have an array of 1x1 (default) instead of 32x24 like you wanted.<br><br>To fix this, add this line:<br><pre class=code>
Map_Init(mapx,mapy)
</pre><br>after these existing lines in your game:<br><pre class=code>
Global mapx = 32
Global mapy = 24
Global mapx1 = 0
Global skypos
Global gridon = False
Global mapview = 1024
</pre><br><br>That should point you in the right direction. <br><br></td></tr></table><br>
<a name="1123487"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, thanks Rob. I did EXACTLY as u said. HOWEVER... I'm having one more small problem.... It's saving the map file like this: <br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">32
24
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1
-1</textarea><br><br><br>The first 2 numbers are fine, but the -1 is wrong...<br><br><br>Editor.bb: <br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Include "scancodes.bb"

Graphics 1024,768,0,2
AppTitle "Platform editor v2.0"
SetBuffer BackBuffer()
Include "maplib.bb"
AutoMidHandle False		;Images placed by their top left
TFormFilter 0
;32
Dim map1(32,24)
Dim mapcol(32,24)
Dim mapData(32,24)

Global mapx = 32
Global mapy = 24
Global mapx1 = 0
Global skypos
Global gridon = False
Global mapview = 1024

Global tiles = LoadAnimImage("gfx/Ztileset.bmp",32,32,0,10)
Global sky = LoadImage("gfx\sky1.bmp")
MaskImage tiles,255,0,255
TileImage sky

Global cursorx,cursory
Global gx,gy
Global currenttile=1
Global rpik,rpik2
Global rcol,rcol1,rcol2
Global mode=1
Global coltype=1

Const erasetile = 0

fill()

Map_Init(mapx,mapy)

; Main
While Not KeyHit(1)
	Cls
	
	
	sky()
	update()
	grid()
	control()
	info()
	
	
	Flip
Wend



Function control()
	
	If mode=1
		If KeyDown(k_left) = mapx Then mapx = mapx+1 : mapx1 = mapx1 +1
		If KeyHit(12) And mode=1 Then currenttile=currenttile-1
		If KeyHit(13) And mode=1 Then currenttile=currenttile+1
		
		
		If KeyHit(34) 
			If gridon=True
				gridon=False
			Else
				gridon=True
			EndIf
		EndIf
		
		If currenttile&lt;0 Then currenttile=9
		If currenttile&gt;9 Then currenttile=0
		If KeyHit(46) Then mode=2	
		gx=MouseX()/32
		gy=MouseY()/32
		Color 256,0,0
		Line MouseX()-10,MouseY(),MouseX()+10,MouseY()
		Line MouseX(),MouseY()-10,MouseX(),MouseY()+10
		If MouseDown(1) And gx &lt; 32 And gy &lt; 24 Then map1(gx,gy)=currenttile
		If MouseDown(2) And gx &lt; 32 And gy &lt; 24 Then map1(gx,gy)=0
		
	EndIf
	
	If mode=2 
		If KeyHit(12) And mode=2 Then coltype=coltype-1
		If KeyHit(13) And mode=2 Then coltype=coltype+1
		If coltype&lt;1 Then coltype=1
		If coltype&gt;2 Then coltype=2
		
		Color 256,0,0
		Line MouseX()-10,MouseY(),MouseX()+10,MouseY()
		Line MouseX(),MouseY()-10,MouseX(),MouseY()+10
		gx=MouseX()/32
		gy=MouseY()/32
		If KeyHit(46) Then mode=1
		If MouseDown(1) And gx &lt; 32 And gy &lt; 24 And coltype=1 Then  mapcol(gx,gy)=1
		If MouseDown(1) And gx &lt; 32 And gy &lt; 24 And coltype=2 Then  mapcol(gx,gy)=2
		If MouseDown(2) And gx &lt; 32 And gy &lt; 24 Then mapcol(gx,gy)=0
	EndIf
	
	
	If KeyHit(59)
		Map_SaveBinarymap("scrollmap2.dat")
		Map_DecryptBinaryMap("scrollmap2_decrypted.dat")
	EndIf
	
	If KeyHit(60)
		Map_LoadBinarymap("scrollmap2.dat")
	EndIf
	
	If KeyHit(203)
		mapview=mapview+1
	EndIf
	
	If KeyHit(205)
		
		mapview=mapview-1
		
	EndIf
	
End Function



Function update()
	
	If mode=1
		For x=0 To mapx
			For Y=0 To mapy
				DrawImage tiles,x*32,y*32,map1(x,y)	
			Next	
		Next
		
		Color 0,0,0
		Rect 0,0,40,40,1
		DrawImage tiles,3,3,currenttile
	EndIf
	
	If mode=2
		For x=0 To mapx
			For Y=0 To mapy
				DrawImage tiles,x*32,y*32,map1(x,y)	
				If mapcol(x,y)=1
					Color 0,0,0
					Rect x*32,y*32,32,32,0
				EndIf	
				If mapcol(x,y)=2
					Color 255,0,0
					Rect x*32,y*32,32,32,0
				EndIf	
			Next
			Color 0,0,0
			Rect 0,0,40,40,1
			If coltype=1 
				Color 0,0,0
				Rect 3,3,32,32,1
			EndIf
			If coltype=2
				Color 255,0,0 
				Rect 3,3,32,32,1
			EndIf
		Next
		
		
	EndIf
	
End Function


Function sky()
	
	TileBlock sky,skypos,0 
	
	skypos=skypos+1
	
End Function


Function info()
	
	If mode=1
		Text 100,0,"Press C to change to collision mode   leftclick = place tile   rightclick = remove tile   + and - change tiles"
		Text 100,20,"F1 to save - F2 to load   Unfortunatly it only saves as (lvl1.lvl) SOZ"
		Text 100,40,"Press D to change to data mode    Press G for grid mode " 
		
	EndIf
	If mode=2
		Text 100,0,"Press C to change to scenery mode   leftclick = place collision   rightclick = remove collision"
	EndIf
	
End Function



;Function save(filename$)

	;f=WriteFile(filename$)

	;For y=0 To 24
		;For x=0 To 32
			;WriteInt f,map1(x,y)
		;Next
	;Next

	;For y=0 To 24
		;For x=0 To 32
			;WriteInt f,mapcol(x,y)
		;Next
	;Next

	;CloseFile f

;End Function


;Function load(filename$)

	;f=OpenFile(filename$)

	;For y=0 To 24
		;For x=0 To 32
			;i=ReadInt(f)
			;map1(x,y)=i
		;Next ;x
	;Next ;y

	;For y=0 To 24
		;For x=0 To 32
			;i=ReadInt(f)
			;mapcol(x,y)=i
		;Next ;x
	;Next ;y

	;CloseFile f

;End Function



Function grid()
	
	If gridon=True
		For x=0 To mapx
			For y=o To mapy
				Rect x*32,y*32,32,32,0
			Next
		Next
	EndIf
	
End Function


Function fill()
	For x=0 To mapx
		For y=0 To mapy
			map1(x,y)=5
		Next
	Next
End Function</textarea><br><br><br>maplib.bb (edited to work with a Decrypt function so I can actually READ the file) (Map_DecryptBinaryMap(SaveFileName$)): <br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;***************************************************************************
;*   Library Name: MapLib
;*       Coded By: Krylar
;*   Last Updated: 7/19/2004
;*        Purpose: To allow the loading of tiles and maps for display and
;*                 and scrolling.  Handles both Text and Binary, but does
;*                 NOT do encryption.
;*                 
;*                 Also now includes the collision information and checking. 
;***************************************************************************


;*************************************************************************
;* Begin Map Control Defines
;*************************************************************************

; Type For the TileList
Type Map_Tiles
     Field Image
     Field Width
     Field Height
End Type

; Global to track the number of tiles
Global Map_TotalTiles = 0

; Dimension our tile array
Dim Tile.Map_Tiles(Map_TotalTiles)
Global Map_FullTiles

; Type for the Map_Data
Type Map_Data
     Field TileNumber
End Type

; Globals to track the map dimensions
Global Map_Width = 1
Global Map_Height = 1
Global Map_X_Start = 0
Global Map_Y_Start = 0
Global Map_X_DisplayOffset = 0
Global Map_Y_DisplayOffset = 0
Global Map_ScrollWidth = 0
Global Map_ScrollHeight = 0

; Dimension our Map array
Dim Map.Map_Data(Map_Width,Map_Height)
Dim MapHold.Map_Data(Map_Width,Map_Height)

;*************************************************************************
;* End Map Control Defines
;*************************************************************************
;
;
;
;*************************************************************************
;* Begin Collision Control Defines
;*************************************************************************

; create the Player collision array for bounding boxes on the player
Dim Map_PlayerCollisionArray(16)

; setup the walls type for knowing where all the walls are for collisions
Type Map_Walls
    Field TileNumber
    Field X
    Field Y
End Type

; make the walls type global
Global Wall.Map_Walls = First Map_Walls

;*************************************************************************
;* End Collision Control Defines
;*************************************************************************
;
;
;
;*************************************************************************
;* Begin Map Control Functions
;*************************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadMap(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads ONLY the map, no tiles!
;
; Arguments: 
;    Map_Full_Path$ = Map filename, including the full path
;    MapType = 0=Text, 1=Binary
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadMap(Map_Full_Path$,MapType)

  If MapType = 0
     ; call the Map_ReadDimensions to get the proper rows/columns
     Status = Map_ReadTextMapDimensions(Map_Full_Path$)

     If Status = -1
        Return(-2)
     EndIf  

     ; Now read the actual data from that map file
     Status = Map_LoadTextMap(Map_Full_Path$)
     If Status = -1
        Return(-3)
     EndIf
  Else
     Status = Map_LoadBinaryMap(Map_Full_Path$)
     If Status = -1
        Return(-3)
     EndIf

  EndIf
  Return(0)
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadTiles(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads in the actual tiles to be used
;  with the map.  It takes into account any boxes that may have 
;  been placed around each image by allowing the caller to specify
;  the box widths and heights.
;
; Arguments: 
;    Tile_Full_Path$ = Tile Image file, including the full path
;    TileWidth = Width of the tiles being loaded
;    TileHeight = Height of the tiles being loaded
;    TileSpacer = If there are boxes around the tiles, set this to
;              the number of pixels that the boxes are wide and high.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadTiles(Tile_Full_Path$,TileWidth,TileHeight,TileSpacer)

  For TileCounter = 0 To Map_TotalTiles - 1
      If Tile.Map_Tiles(TileCounter) &lt;&gt; Null
         FreeImage Tile(TileCounter)\Image
         Delete Tile(TileCounter)
      EndIf
  Next

  ; first off let's load the full image containing all the tiles
  ; into a temporary space
  Temp_Image=LoadImage(Tile_Full_Path$)

  ImageSizeX = ImageWidth(Temp_Image)
  ImageSizeY = ImageHeight(Temp_Image)

  TileColumns = ImageSizeX / TileWidth
  TileRows = ImageSizeY / TileHeight

  Dim Tile.Map_Tiles(TileRows * TileColumns )
  
  If Temp_Image = 0
     Return(-1)
  EndIf

  ; get the current buffer so we can restore to it
  CurrentBuffer = GraphicsBuffer()

  ; next make that image the current buffer
  SetBuffer ImageBuffer(Temp_Image)



  ; setup our basic vars.  The X and Y values will be whatever the XSpacer
  ; and YSpacer values are. If they are 0, then it's assumed that there is
  ; no space between the tiles. If you look at the sample images included
  ; with this demo you'll see a white box around each image...that's why
  ; I have these spacers...we don't wanna load the boxes, just the images.
  X = TileSpacer
  Y = TileSpacer

  ; keep track of the number of images
  ImageNumber = 0

  ; run through the total number of rows (minus 1, of course)
  For Rows=0 To TileRows  -1
      ; and run through all the columns per row (minus 1 again)
      For Columns=0 To TileColumns  -1
          ; create a new TileList element and assign it the current
          ; ImageNumber.  Then populate the TileList element with
          ; the TileWidth, TileHeight, and the actual Tile_Image
          Tile.Map_Tiles(ImageNumber) = New Map_Tiles
          Tile(ImageNumber)\Width = TileWidth
          Tile(ImageNumber)\Height = TileHeight

          ; to get the image, we first use CreateImage(...) to make sure
          ; BB allocates enough space in the TileList field Tile_Image 
          Tile(ImageNumber)\Image=CreateImage(TileWidth,TileHeight)

          ; then we grab the image based off the size setup in CreateImage(...)
          ; from our X,Y location
          GrabImage(Tile(ImageNumber)\Image,X,Y)
         
          ; now we add X to the TileWidth and the XSpacer to get the new X position.
          ; So, if our current X = 2, and the TileWidth = 32 and the XSpacer = 2, we'd
          ; have X = 2 + 32 + 2, or 36.  This means that the next time we call         
          ; GrabImage(...) it will start grabbing from the X position 36 (or the 36th pixel 
          ; from the left).         
          X=X + TileWidth + TileSpacer

          ; increment our tile counter (for the array positioning)
          ImageNumber = ImageNumber + 1
      Next
      ; we've finished with that row, so reset X back to the spacer position
      X = TileSpacer

      ; now we add Y to the TileHeight and the YSpacer to get the new Y position.
      ; So, if our current Y = 2, and the TileHeight = 32 and the YSpacer = 2, we'd
      ; have Y = 2 + 32 + 2, or 36.  This means that the next time we call  
      ; GrabImage(...) it will start grabbing from the Y position 36 (or the 36th pixel 
      ; from the top).         
      Y = Y + TileHeight + TileSpacer
  Next
  
  ; restore the buffer
  SetBuffer CurrentBuffer

  ; free the image from memory, so we don't hold memory for no reason
  FreeImage Temp_Image

  ; reset our global tile tracker
  Map_TotalTiles = ImageNumber

  Return(0)
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_ReadTextDimensions(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads in the actual dimensions of
;  the map file and stores the values in Map_Width and Map_Height.
;  This function is for use with TEXT files only.
; Arguments: 
;    Map_Full_Path$ = Map file, including the full path
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_ReadTextMapDimensions(Map_Full_Path$)

  ; first thing we do is open the file using a Pointer Variable (which
  ; is "File" in this case)
  File=ReadFile(Map_Full_Path$);

  ; Then we read the first line of the file...it *should* contain the
  ; width/height data.  If it doesn't, somebody goofed up on the layout
  ; of the file
  MapDimensions$ = ReadLine$(File);

  ; we need to set up some variables to parse the line.  We could just
  ; set this up to have the x,y on two lines and save some trouble from
  ; a coding perspective, but this method makes the map creation more
  ; intuitive for the user...and that's our job ;)
  EndOfString = 0
  Offset = 0

  ; while we haven't reached the end of the string
  While EndOfString = 0
        ; let's first put the current position in the string into Temp$
        ; this is just 1 character from the string cause we use the Mid$(...)
        ; command to yank out that value
        Temp$ = Mid$(MapDimensions$,Offset+1,1)

        ; if that character is not a comma we haven't gone past the length
        ; of the string
        If Temp$ &lt;&gt; "," And (Offset &lt;= Len(MapDimensions$))
          ; then it must be a number, so we save it in the HoldString$
          HoldString$ = HoldString$ + Temp$
        ; otherwise, it's either gone too far or it's the comma seperator
        Else
           ; if we've gone too far, then we know that the Map_Height is done
           If Offset &gt; Len(MapDimensions$)
              ; so we convert the current HoldString$ to an Int and assign it
              Map_Height = Int(HoldString$)
              ; and make sure the While loop breaks
              EndOfString = 1
          ; it must be a comma, so that means our Map_Width value is loaded
          Else
             ; convert the current HoldString$ to an int and assign it
             Map_Width = Int(HoldString$)
             ; reset the HoldString$ to blank so we can start loading Map_Height
             HoldString$ = ""
          EndIf
        EndIf
        ; increase the string position offset by 1 (to move to the next character)
        Offset = Offset + 1
   Wend
   ; we're done, so close the file!
   CloseFile(File)

  Dim Map.Map_Data(Map_Width,Map_Height)

  Map_Init(Map_Width,Map_Height)


  Return(0)
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadTextMap(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function loads in the actual map information.
;  This function is for use with TEXT files only.
;
; Arguments: 
;    Map_Full_Path$ = Map file, including the full path
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadTextMap(Map_Full_Path$)

  ; first thing we do is open the file using a Pointer Variable (which
  ; is "File" in this case)
  File=ReadFile(Map_Full_Path$);
  ; read the Map dimensions line, but don't do anything with it...this
  ; is just to move to the map data line.  Use the Map_ReadTextDimensions(...)
  ; function for getting the actual Map_Width/Map_Height, so you can DIM
  ; the Map_Data array appropriately
  MapDimensions$ = ReadLine$(File);

  ; set up our vars for array placements.  The X will be for columns, and
  ; the Y will be for rows.  The EndOfFile just let's us keep track of how
  ; far into the file we've gone.
  X=0
  Y=0
  EndOfFile = 0

  ; do this until we reach the end of the file
  While EndOfFile = 0

        ; read a line of data from the file and put it in the MapLine$ string
        MapLine$ = ReadLine$(File);

        ; make sure that the length of the line is more than 1 character
        If Len(MapLine$) &gt; 1

           ; set up our EndOfString var to be 0...this will help us keep
           ; track of the current MapLine$ string position
           EndOfString = 0
           ; This Offset var will let us keep track of our current position
           ; in the MapLine$ string
           Offset = 0

           ; until we reach the end of the MapLine$ string
           While EndOfString = 0
                
                 ; let's first put the current position in the string into Temp$
                 ; this is just 1 character from the string cause we use the Mid$(...)
                 ; command to yank out that value
                 Temp$ = Mid$(MapLine$,Offset+1,1)

                 ; if that character is not a comma we haven't gone past the length
                 ; of the string
                 If Temp$ &lt;&gt; "," And (Offset &lt;= Len(MapLine$)) 
                    ; then it must be a number, so we save it in the HoldString$
                    HoldString$ = HoldString$ + Temp$
                 ; otherwise, it's either gone too far or it's the comma seperator
                 Else
                    ; if we've gone too far, then we know that this line is done
                    If Offset &gt; Len(MapLine$)
                       ; so we make a new Map_Data element in our Map(x,y) array
                       Map.Map_Data(X,Y) = New Map_Data
                       ; fill in the number of the HoldString$ by converting it to an Int
                       Map(X,Y)\TileNumber = Int(HoldString$)
                       ; reset the HoldString$ to a blank
                       HoldString$ = ""
                       ; exit the loop for *this* line (so we can read the next one)
                       EndOfString = 1
                    ; it must be a comma, so that means this column's value is loaded
                    Else
                       ; so we make a new Map_Data element in our Map(x,y) array
                       Map.Map_Data(X,Y) = New Map_Data
                       ; fill in the number of the HoldString$ by converting it to an Int
                       Map(X,Y)\TileNumber = Int(HoldString$)
                       ; reset the HoldString$ to a blank
                       HoldString$ = ""
                       ; Increase the X (or Column) location for the Array
                       X=X+1
                    EndIf
                 EndIf
                 ; add one to our string position offset
                 Offset = Offset + 1
            Wend
            ; set X back to 0 (so we're back to column 0)
            X=0
            ; add 1 to Y (so we move down 1 row in the array)
            Y=Y+1
        ; if we've gone past the length of the file
        Else
            ; then tell the loop to stop cause we're done!
            EndOfFile = 1
        EndIf
   Wend
   ; make sure to close the file!
   CloseFile(File)

  Return(0)

End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_ShowMap(...)
;       Author:  Krylar
; Last Updated: 7/19/2004
;  Description: This function moves and displays a map starting at
; a user-defined top-left corner at whatever width/height the user
; wants.  It will move N/S/E/W directions and do so at whatever 
; distance (speed) the user needs.  
;
; Arguments: 
;    XOffset    = Where to start the left edge
;    YOffset    = Where to start the top edge
;    Direction  = 1-North, 2-South, 3-East, 4-West
;    Distance   = How far to move the map per call
;    ShowWidth  = How many columns to show (tiles)
;    ShowHeight = How many rows to show (tiles)
;    TileWidth  = How Wide are the tiles for the map
;    TileHeight = How High are the tiles for the map
;    ShowBoxes  = 0-No, 1-Show collision Points
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_ShowMap(XOffset,YOffset,Direction,Distance,ShowWidth,ShowHeight,TileWidth,TileHeight,ShowBoxes)
    RowPosition = 0
    ColumnPosition = 0

    ; Which way are we scrolling the map?
    Select Direction 
           Case 1 ; North
                 ; First let's make sure that we're not already on the edge
                 If Map_Y_Start &gt; 0
                    ; Start counting up to zero for our offset
                    Map_Y_DisplayOffset =  Map_Y_DisplayOffset + Distance
                    ; if we hit or go past zero, subtract the amount over 0
                    ; from the TileHeight the user passed along and decrement
                    ; our Map Y starting position
                    If Map_Y_DisplayOffset &gt; 0
                       Map_Y_DisplayOffset = -(TileHeight) + Distance
                       Map_Y_Start = Map_Y_Start - 1    
                    EndIf
                    ; We want to show exactly the ShowHeight
                    Map_ScrollHeight = Map_Y_Start + ShowHeight
                 Else
                    ; since we're already on Zero (top edge), just keep scrolling
                    ; until the offset hits the edge too.  
                    If Map_Y_DisplayOffset &lt; 0
                       Map_Y_DisplayOffset = Map_Y_DisplayOffset + Distance
                    EndIf
                    ; We want to show one over the ShowWidth here so we don't
                    ; end up with blinking edges
                    Map_ScrollHeight = Map_Y_Start + ShowHeight + 1
                 EndIf

           Case 2 ; South
                 ; Verify that we've not gone too far down
                 If Map_Y_Start &lt; Map_Height - ShowHeight - 1 And Map_Y_Start &gt;= 0
                    ; Count down to the AdjustedTileSize (see above)
                    Map_Y_DisplayOffset = Map_Y_DisplayOffset - Distance
                    ; if we hit or go past the negative size, add that amount
                    ; to the Tile size sent by the user and make it negative.
                    If Map_Y_DisplayOffset &lt; -(TileHeight) 
                       Map_Y_DisplayOffset = 0 - Distance
                       ; Increment our Map position
                       Map_Y_Start = Map_Y_Start + 1   
                       ; Do another sanity check to make sure we didn't run over.
                       ; if we did, drop the Map position back 1 and set the offset
                       ; so it's on the edge (no more scrolling)
                       If Map_Y_Start &gt;= Map_Height - ShowHeight
                          Map_Y_Start = Map_Y_Start - 1
                       EndIf 
                    EndIf
                    ; We want to show exactly the ShowHeight
                    Map_ScrollHeight = Map_Y_Start + ShowHeight
                 Else
                    If Map_Y_Start &gt; 0
                       ; We must already be at the point where the right edge is showing, so
                       ; just scroll until the offset hits the edge too.
                       Map_Y_DisplayOffset = Map_Y_DisplayOffset - Distance
                       ; if we hit or go past the negative size, add that amount
                       ; to the Tile size sent by the user and make it negative.
                       If Map_Y_DisplayOffset &lt; -(TileHeight) 
                          Map_Y_DisplayOffset = -(TileHeight)
                       EndIf
                    EndIf
                 EndIf

           Case 3 ; West (Left Arrow key)
                 ; First let's make sure that we're not already on the edge
                 If Map_X_Start &gt; 0
                    ; Start counting up to zero for our offset
                    Map_X_DisplayOffset =  Map_X_DisplayOffset + Distance
                    ; if we hit or go past zero, subtract the amount over 0
                    ; from the TileWidth the user passed along and decrement
                    ; our Map X starting position
                    If Map_X_DisplayOffset &gt; 0
                       Map_X_DisplayOffset = -(TileWidth) + Distance
                       Map_X_Start = Map_X_Start - 1    
                    EndIf
                    ; We want to show exactly the ShowWidth
                    Map_ScrollWidth = Map_X_Start + ShowWidth
                 Else
                    ; since we're already on Zero (left edge), just keep scrolling
                    ; until the offset hits the edge too.  
                    If Map_X_DisplayOffset &lt; 0
                       Map_X_DisplayOffset = Map_X_DisplayOffset + Distance
                    EndIf
                    ; We want to show one over the ShowWidth here so we don't
                    ; end up with blinking edges
                    Map_ScrollWidth = Map_X_Start + ShowWidth + 1
                 EndIf

           Case 4 ; East (Right Arrow Key)
                 ; Verify that we've not gone too far right
                 If Map_X_Start &lt; Map_Width - ShowWidth - 1 And Map_X_Start &gt;= 0
                    ; Count down to the AdjustedTileSize (see above)
                    Map_X_DisplayOffset = Map_X_DisplayOffset - Distance
                    ; if we hit or go past the negative size, add that amount
                    ; to the Tile size sent by the user and make it negative.
                    If Map_X_DisplayOffset &lt; -(TileWidth) 
                       Map_X_DisplayOffset = 0 - Distance
                       ; Increment our Map position
                       Map_X_Start = Map_X_Start + 1   
                       ; Do another sanity check to make sure we didn't run over.
                       ; if we did, drop the Map position back 1 and set the offset
                       ; so it's on the edge (no more scrolling)
                       If Map_X_Start &gt;= Map_Width - ShowWidth
                          Map_X_Start = Map_X_Start - 1
                       EndIf 
                    EndIf
                    ; We want to show exactly the ShowWidth
                    Map_ScrollWidth = Map_X_Start + ShowWidth
                 Else
                    If Map_X_Start &gt; 0
                       ; We must already be at the point where the right edge is showing, so
                       ; just scroll until the offset hits the edge too.
                       Map_X_DisplayOffset = Map_X_DisplayOffset - Distance
                       ; if we hit or go past the negative size, add that amount
                       ; to the Tile size sent by the user and make it negative.
                       If Map_X_DisplayOffset &lt; -(TileWidth) 
                          Map_X_DisplayOffset = -(TileWidth)
                       EndIf
                    EndIf
                 EndIf

           ; we're not moving the map, but the map still needs to be display, so 
           ; just check where we are on the map and then display the proper width/height
           ; to avoid blinking.
           Default
                 If Map_X_Start &lt; Map_Width - ShowWidth
                    Map_ScrollWidth = Map_X_Start + ShowWidth
                 Else
                    Map_ScrollWidth = Map_X_Start + ShowWidth - 1
                 EndIf

                 If Map_Y_Start &lt; Map_Height - ShowHeight
                    Map_ScrollHeight = Map_Y_Start + ShowHeight
                 Else
                    Map_ScrollHeight = Map_Y_Start + ShowHeight - 1
                 EndIf
                 If Distance = -1
                    Map_X_DisplayOffset = 0
                    Map_Y_DisplayOffset = 0
                 EndIf
    End Select

    ; hook up our X, Y values to draw the images at the proper locations
    X = Map_X_DisplayOffset + XOffset
    Y = Map_Y_DisplayOffset + YOffset

    ; and then run through the Arrays and Draw stuff out!
    For Rows = Map_Y_Start To Map_ScrollHeight
        For Columns = Map_X_Start To Map_ScrollWidth
            TileNumber = Map(Columns,Rows)\TileNumber
            ; if the Tile isn't a -1, then draw it
            If TileNumber &lt;&gt; -1
               DrawImage Tile(TileNumber)\Image,X,Y
            EndIf

            ; if the user wants to see the collision boxes, draw them here
            If ShowBoxes = 1
               For Wall.Map_Walls = Each Map_Walls
                   If Wall\TileNumber = TileNumber
                      Color 0,255,255
                      Rect X,Y,TileWidth,TileHeight,0
                      Text X+10,Y+10, TileNumber
                      Exit
                   EndIf
               Next
            EndIf
            ; increase our X position for tile drawing
            X = X + TileWidth
        Next
        ; reset the X position and increase the Y position
        X = Map_X_DisplayOffset + XOffset
        Y = Y + TileHeight
    Next

End Function




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_VerifyMapAndTiles(...)
;       Author:  Krylar
; Last Updated: 11/6/01
;  Description: This function makes sure that all the numbers 
;               within a Map corresponds to all the Tile numbers.
;               It replaces invalid numbers with -1.
;
; Arguments: 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_VerifyMapAndTiles()
    Status = 0
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height - 1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width - 1
            TileNumber = Map(Columns,Rows)\TileNumber
            If TileNumber &gt; Map_TotalTiles
               Map(Columns,Rows)\TileNumber = -1
               Status = -1
            EndIf               
        Next
    Next
    Return(Status)
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_ClearMap(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: Clear the map, but allow it to be blanked to a 
;               particular size.
;
; Arguments: 
;        Width: How wide should the cleared map be defaulted to?
;        Height: How high should the cleared map be defaulted to?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_ClearMap(Width,Height)

    Map_Width = Width
    Map_Height = Height

    Dim Map.Map_Data(Map_Width,Map_Height)
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = -1
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_Init(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function initialize a map with all -1 values
;               for elements.
;
; Arguments: 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_Init(Width,Height)

    Map_Width = Width
    Map_Height = Height

    Dim Map.Map_Data(Map_Width,Map_Height)
    Dim MapHold.Map_Data(Map_Width,Map_Height)
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = -1
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_IncreaseWidth(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function increases the Map width by re-
;               dimensioning the Map array and copying over 
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to increase the width
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_IncreaseWidth(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    CurrentWidth = Map_Width
    CurrentHeight = Map_Height

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Width = Map_Width + Amount
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            If Map.Map_Data(Columns,Rows) = Null
               Map.Map_Data(Columns,Rows) = New Map_Data
               Map(Columns,Rows)\TileNumber = -1
            EndIf
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_DecreaseWidth(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function decreases the Map width by re-
;               dimensioning the Map array and copying over only
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to decrease the width
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_DecreaseWidth(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Width = Map_Width - Amount
    If Map_Width &lt;= MapGridColums
       Map_Width = MapGridColums
    EndIf
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_IncreaseHeight(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function increases the Map height by re-
;               dimensioning the Map array and copying over 
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to increase the height
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_IncreaseHeight(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    CurrentWidth = Map_Width
    CurrentHeight = Map_Height

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Height = Map_Height + Amount
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To CurrentHeight-1
        ; and for all the columns (minus 1)
        For Columns = 0 To CurrentWidth-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            If Map.Map_Data(Columns,Rows) = Null
               Map.Map_Data(Columns,Rows) = New Map_Data
               Map(Columns,Rows)\TileNumber = -1
            EndIf
        Next
    Next
    
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_DecreaseHeight(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function decreases the Map height by re-
;               dimensioning the Map array and copying over only
;               the appropriate number of elements.
;
; Arguments: 
;        Amount: How far to decrease the height
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_DecreaseHeight(Amount)

    ; dimension the temporary array
    Dim MapHold.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            MapHold.Map_Data(Columns,Rows) = New Map_Data
            MapHold(Columns,Rows)\TileNumber = Map(Columns,Rows)\TileNumber
        Next
    Next

    Map_Height = Map_Height - Amount
    If Map_Height &lt;= MapGridRows
       Map_Height = MapGridRows
    EndIf
    Dim Map.Map_Data(Map_Width,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height-1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width-1
            Map.Map_Data(Columns,Rows) = New Map_Data
            Map(Columns,Rows)\TileNumber = MapHold(Columns,Rows)\TileNumber
        Next
    Next
    
End Function




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_SaveBinaryMap(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function saves a map in binary format
;
; Arguments: 
;        SaveFileName$: Name to save it as
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_SaveBinaryMap(SaveFileName$)

    ; first open the file for writing.  This *will* overwrite the
    ; existing file.
    FilePtr = WriteFile(SaveFileName$)

    ; write the Map_Width and Map_Height 
    WriteInt(FilePtr,Map_Width)
    WriteInt(FilePtr,Map_Height)

    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height - 1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width - 1
            ; get the tilenumber
            TileNumber = Map(Columns,Rows)\TileNumber
            ; write it to the file
            WriteInt(FilePtr,TileNumber)
        Next
    Next
    ; close the file!
    CloseFile(FilePtr)

    Return 0
End Function




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_DecryptBinaryMap(...)
;       Author:  Thundros
; Last Updated: 1/25/12
;  Description: This function saves a map in decrypted format
;
; Arguments: 
;        SaveFileName$: Name to save/decrypt it as
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_DecryptBinaryMap(SaveFileName$)
	
    ; first open the file for writing.  This *will* overwrite the
    ; existing file.
    FilePtr = WriteFile(SaveFileName$)
	
    ; write the Map_Width and Map_Height 
    WriteLine(FilePtr,Str Map_Width)
    WriteLine(FilePtr,Str Map_Height)
	
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height - 1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width - 1
            ; get the tilenumber
            TileNumber = Map(Columns,Rows)\TileNumber
            ; write it to the file
            WriteLine(FilePtr,TileNumber)
        Next
    Next
    ; close the file!
    CloseFile(FilePtr)
	
    Return 0
End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_LoadBinaryMap(...)
;       Author:  Krylar
; Last Updated: 1/18/02
;  Description: This function loads a binary map
;
; Arguments: 
;        Map_Full_Path$: Name to load
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_LoadBinaryMap(Map_Full_Path$)

  ; first thing we do is open the file using a Pointer Variable (which
  ; is "File" in this case)
  FilePtr=ReadFile(Map_Full_Path$);

  If FilePtr = -1
     Return -1
  EndIf

  ; for all of the rows (minus 1)
  For Rows = 0 To Map_Height - 1
      ; and for all the columns (minus 1)
      For Columns = 0 To Map_Width - 1
          Delete Map.Map_Data(X,Y)
      Next
  Next

  ; read in the map dimensions
  Map_Width = ReadInt(FilePtr);
  Map_Height = ReadInt(FilePtr);

  Dim Map.Map_Data(Map_Width,Map_Height)

  ; set up our vars for array placements.  The X will be for columns, and
  ; the Y will be for rows.  The EndOfFile just let's us keep track of how
  ; far into the file we've gone.
  X=0
  Y=0
  EndOfFile = 0

  ; for all of the rows (minus 1)
  For Rows = 0 To Map_Height - 1
      ; and for all the columns (minus 1)
      For Columns = 0 To Map_Width - 1
          Map.Map_Data(X,Y) = New Map_Data
          ; read in the encrypted value
          Map(X,Y)\TileNumber = ReadInt(FilePtr)
          ; add 1 to X (so we move 1 column to the right in the array)
          X=X+1
      Next
      ; set X back to 0 (so we're back to column 0)
      X=0
      ; add 1 to Y (so we move down 1 row in the array)
      Y=Y+1
  Next

  ; make sure to close the file!
  CloseFile(FilePtr)

  Return(0)

End Function

;*************************************************************************
;* End Map Control Functions
;*************************************************************************
;
;
;
;*************************************************************************
;* Begin Collision Control Functions                                                  
;*************************************************************************


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION: Map_SetupPlayerBoundingBoxes()
; Author: Krylar
; Last Updated: 7/19/2004
;
; sets up where the x1,y1,x2,y2 values are for the 4 boxes
; that make up the collision points on the player
;
; Arguments:
;          Top, Bottom, Left, Right values of X1, Y1, X2, Y2 - Respectively
;
; Returns: n/a
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_SetupPlayerBoundingBoxes(TopX1,TopY1,TopX2,TopY2,BottomX1,BottomY1,BottomX2,BottomY2,LeftX1,LeftY1,LeftX2,LeftY2,RightX1,RightY1,RightX2,RightY2)
  ; setup the top-box
  Map_PlayerCollisionArray(0) = TopX1
  Map_PlayerCollisionArray(1) = TopY1
  Map_PlayerCollisionArray(2) = TopX2
  Map_PlayerCollisionArray(3) = TopY2
  ; setup the bottom-box
  Map_PlayerCollisionArray(4) = BottomX1
  Map_PlayerCollisionArray(5) = BottomY1
  Map_PlayerCollisionArray(6) = BottomX2
  Map_PlayerCollisionArray(7) = BottomY2
  ; setup the Left-box
  Map_PlayerCollisionArray(8) = LeftX1
  Map_PlayerCollisionArray(9) = LeftY1
  Map_PlayerCollisionArray(10) = LeftX2
  Map_PlayerCollisionArray(11) = LeftY2
  ; setup the Right-box
  Map_PlayerCollisionArray(12) = RightX1
  Map_PlayerCollisionArray(13) = RightY1
  Map_PlayerCollisionArray(14) = RightX2
  Map_PlayerCollisionArray(15) = RightY2
End Function

Function ShowPlayerBoundingBoxes(x,y)
  Color 255,255,0
  Rect x+Map_PlayerCollisionArray(0),y+Map_PlayerCollisionArray(1),Map_PlayerCollisionArray(2) - Map_PlayerCollisionArray(0),Map_PlayerCollisionArray(3) - Map_PlayerCollisionArray(1),0
  Rect x+Map_PlayerCollisionArray(4),y+Map_PlayerCollisionArray(5),Map_PlayerCollisionArray(6)-Map_PlayerCollisionArray(4),Map_PlayerCollisionArray(7)-Map_PlayerCollisionArray(5),0
  Rect x+Map_PlayerCollisionArray(8),y+Map_PlayerCollisionArray(9),Map_PlayerCollisionArray(10)-Map_PlayerCollisionArray(8),Map_PlayerCollisionArray(11)-Map_PlayerCollisionArray(9),0
  Rect x+Map_PlayerCollisionArray(12),y+Map_PlayerCollisionArray(13),Map_PlayerCollisionArray(14)-Map_PlayerCollisionArray(12),Map_PlayerCollisionArray(15)-Map_PlayerCollisionArray(13),0
  Color 255,255,255
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION: Map_AddWall()
; Author: Krylar
; Last Updated: 7/19/2004
;
; Adds a wall to the collision list
;
; Returns: n/a
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_AddWall(TileToAdd)
   X = 0
   Y = 0
   ; run through all of the map
   For Rows = 0 To Map_Height - 1
       For Columns = 0 To Map_Width - 1
           TileNumber = Map(Columns,Rows)\TileNumber
           ; see if the tile number is one we want designated as a wall
           If TileNumber = TileToAdd
              ; Add it to the Wall Type
              Wall.Map_Walls = New Map_Walls
              Wall\TileNumber = TileNumber
              Wall\X = X
              Wall\Y = Y
           EndIf
           X = X + TileWidth 
       Next
       ; reset X to the beginning of the next row
       X = 0
       ; increase our Y drawing position by the Tile's Height
       Y = Y + TileHeight
   Next

End Function



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION: Map_CheckWallCollisions(...)
; Author: Krylar
; Last Updated: 7/19/2004
;
; Checks an area for collision based on bounding boxes
;
; Returns:
;           0 = no hit
;           1 = collision with wall
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_CheckWallCollision(X,Y)

    ; do one calculation here for each absolute box position
    ; so we don't do them every itteration of our loop below
    BoxTopX1    = X + Map_PlayerCollisionArray(0)
    BoxTopY1    = Y + Map_PlayerCollisionArray(1)
    BoxTopX2    = X + Map_PlayerCollisionArray(2)
    BoxTopY2    = Y + Map_PlayerCollisionArray(3)
    BoxBottomX1 = X + Map_PlayerCollisionArray(4)
    BoxBottomY1 = Y + Map_PlayerCollisionArray(5)
    BoxBottomX2 = X + Map_PlayerCollisionArray(6)
    BoxBottomY2 = Y + Map_PlayerCollisionArray(7)
    BoxLeftX1   = X + Map_PlayerCollisionArray(8)
    BoxLeftY1   = Y + Map_PlayerCollisionArray(9)
    BoxLeftX2   = X + Map_PlayerCollisionArray(10)
    BoxLeftY2   = Y + Map_PlayerCollisionArray(11)
    BoxRightX1  = X + Map_PlayerCollisionArray(12)
    BoxRightY1  = Y + Map_PlayerCollisionArray(13)
    BoxRightX2  = X + Map_PlayerCollisionArray(14)
    BoxRightY2  = Y + Map_PlayerCollisionArray(15)

    ; run through all of the walls
    For Wall.Map_Walls = Each Map_Walls
        XCollision = 0
        YCollision = 0

        ; grab the Type values to speed things up a bit
        WallX = Wall\X
        WallY = Wall\Y
        ; calculate the WallWidth and Height to speed things up
        WallWidth = WallX + TileWidth 
        WallHeight = WallY + TileHeight
     
        ; check the top bounding box
        If BoxTopX1 &gt;= WallX And BoxTopX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxTopY1 &gt;= WallY And BoxTopY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; check the bottom bounding box
        If BoxBottomX1 &gt;= WallX And BoxBottomX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxBottomY1 &gt;= WallY And BoxBottomY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; check the left bounding box
        If BoxLeftX1 &gt;= WallX And BoxLeftX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxLeftY1 &gt;= WallY And BoxLeftY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; check the right bounding box
        If BoxRightX1 &gt;= WallX And BoxRightX2 &lt;= WallWidth
           XCollision = 1
        EndIf
        If BoxRightY1 &gt;= WallY And BoxRightY2 &lt;= WallHeight
           YCollision = 1
        EndIf

        ; if there is a collision on both the X and Y axis, return 1
        If XCollision = 1 And YCollision = 1
           Return 1
        EndIf
    Next
   
  ; no hit so return 0
  Return 0

End Function



;*************************************************************************
;* End Collision Control Functions                                                  
;*************************************************************************</textarea><br><br><br>Here's the decrypt function: <br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     Function: Map_DecryptBinaryMap(...)
;       Author:  Thundros
; Last Updated: 1/25/12
;  Description: This function saves a map in decrypted format
;
; Arguments: 
;        SaveFileName$: Name to save/decrypt it as
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Function Map_DecryptBinaryMap(SaveFileName$)
	
    ; first open the file for writing.  This *will* overwrite the
    ; existing file.
    FilePtr = WriteFile(SaveFileName$)
	
    ; write the Map_Width and Map_Height 
    WriteLine(FilePtr,Str Map_Width)
    WriteLine(FilePtr,Str Map_Height)
	
    ; for all of the rows (minus 1)
    For Rows = 0 To Map_Height - 1
        ; and for all the columns (minus 1)
        For Columns = 0 To Map_Width - 1
            ; get the tilenumber
            TileNumber = Map(Columns,Rows)\TileNumber
            ; write it to the file
            WriteLine(FilePtr,TileNumber)
        Next
    Next
    ; close the file!
    CloseFile(FilePtr)
	
    Return 0
End Function</textarea><br><br><br>The format I need, is it saves the Map's width, then height, then the tile number. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
