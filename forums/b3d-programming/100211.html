<!DOCTYPE html><html lang="en" ><head ><title >Lighting/Renderworld question</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Lighting/Renderworld question</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Lighting/Renderworld question</a><br><br>
<a name="1181544"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi there.<br><br>So, I have a planet that is not really as big as it looks; to keep it within the default 1-1000 unit camera range, I've reduced it in size and use EntityOrder to put it in front of the skybox and behind the space ships.  So far, so good.<br><br>The problem is, it reflects the light coming from the exploding ships, which, while cool looking, is highly inaccurate.<br><br>I have discovered that I can actually make the planet full size (I mean, actual size as in 1 meter/blitz unit!) if I want, and adjust the camera range accordingly.  This would require three separate renders; one for the skybox, one for the planet, and one for everything else.<br><br>Or, I can leave the planet where it is and not bother with the camera range, and just turn off the explosion lights during the planet render.  Still multiple renders, just a different trick being employed.<br><br>A. Which of these is better, or will actually work?<br><br>B. Is there another option I haven't though of?<br><br><a href="http://www.lumpcat.com/files/ShipDemo.zip" target="_blank">Here</a> is the newest demo.  You'll see the planet is much improved with more colors and general richness.  Press Enter to generate a new one.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="1181547"></a>

<a name="1181548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Set the planet to use the FullBright and Vertex-Color FXs, then light your planet manually*.<br><br>* You can try LightMesh, but I think setting each vertice's colors manually with some algorithm of your choice may look better, as you might be able to use some coloring effects in your code (according to the sun's position etc.).<br>Note doing this should be very slow, so you'd light the planet as soon as you created it, then you'd leave it colored like that. <br><br></td></tr></table><br>
<a name="1181553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the response.<br><br>I should mention that the planet rotates, so it needs to reflect the sunlight naturally.  Fullbright would prevent that.  I like where your head is at, though!<br><br>(Actually it rotates unusually fast currently so I can see all of it.  Forgot to mention that.  Normally it's slower) <br><br></td></tr></table><br>
<a name="1181560"></a>

<a name="1181561"></a>

<a name="1181562"></a>

<a name="1181563"></a>

<a name="1181564"></a>

<a name="1181565"></a>

<a name="1181566"></a>

<a name="1181574"></a>

<a name="1181575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sure, off the top of my head: try layering meshes, all full-bright but educatedly colored.<br><br><img src="http://i46.tinypic.com/2e4ckuf.png"><br><br>Your original planet (#2), with a dark overlay mesh (#1) and highlight overlay mesh (#3).<br>The dark and light overlay meshes should have the Multiply and Add EntityBlend values respectively (default entityblend mode is Alpha, and it wouldn't work for this effect). <br>You can smoothly fade part of these overlay meshes with vertex-alpha, since they'll be full-bright and won't be receiving light.<br><br>The idea is that the original planet spins normally, but these overlay meshes blend whatever detail passes through them. <br><br></td></tr></table><br>
<a name="1181580"></a>

<a name="1181581"></a>

<a name="1181631"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can also use multiple rendering pass if you set the ClsMode of the camera and use clever pivots<br><br>It's as fast as only one renderworld (or almost as fast)<br><br>------------------------------------------<br>- how to :<br>------------------------------------------<br>If we don't clear the Color buffer, the pixels remains (which is actually the desired effet) but the take care to clear the depth buffer !<br>else you 'll have some undesired entities from Far space drawn front of some objects on earth<br><br>(it's due to the pixel compare function that compares a "depth" which actually is not the "real" depth, but the depth according to the camera range.<br>for ex : a cube at 10 meters from camera -&gt; Depth = 10/1.0 = 10<br>a planet at 5 000 000 from camera : 5 000 000 / 1000 000 = 5<br>the planet is front.)<br><br>So, Clear the depth buffer on each rendering pass !<br><br>------------------------------------------<br><br><br>Then, the process :<br><br>+ create a pivot for each "degree" of rendering (space-sky-earth-[micro?])<br>+ use some const to deal with the scales (and remember that, even if we can use large float number, the precision will be lost at some range (probably a very big range, but anyway))<br>+ when you create something, attach it to the good pivot (a tree is parented to earth, a planet is parented to the space, a cloud is parented to the sky ...etc ...)<br><br>for rendering :<br>1 - Hide all layer's pivots and show the space's one <br>-&gt; Set the clsmode to clear everything (as it's the first rendering, it needs to clear the previous frame)<br>-&gt; render the world<br>2 - hide everything but the next step pivot (in this case, it's the sky pivot)<br>-&gt; set clsmode to clear the depth buffer but not the color buffer<br>-&gt; render the world<br>3 - hide everything [.....] etc ... (same as the second pass with the next pivot)<br><br>4- .... do the same for each rendering depth you need.<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 1024,600,0,2
SetBuffer BackBuffer()

Global Pivot_Universe	=	CreatePivot		( )
Global Pivot_Space		=	CreatePivot		( Pivot_Universe )
Global Pivot_Sky		=	CreatePivot		( Pivot_Universe )
Global Pivot_World		=	CreatePivot		( Pivot_Universe )

Const SPACE_UNIT#		=	10000000.0		; 10 000 km pretty far (but not that far actually)
Const SKY_UNIT#			=	10000.0			; atmospher at 10 km height
Const WORLD_UNIT#		=	1.0				; blitz unit ... 1 unit = 1 meter


Local PLANET_SIZE#		=	SPACE_UNIT*.01
Local planet1			=	CreateSphere	( 12, Pivot_Space )
							PositionEntity	( planet1, -SPACE_UNIT*4,SPACE_UNIT*1,SPACE_UNIT*6 )
							EntityColor		( planet1, 200,050,000 )
							ScaleEntity		( planet1, PLANET_SIZE*50,PLANET_SIZE*50,PLANET_SIZE*50 ) ; big red planet
							
Local planet2			=	CreateSphere	( 8, Pivot_Space )
							PositionEntity	( planet2, +SPACE_UNIT*2,SPACE_UNIT,SPACE_UNIT*7 )
							EntityOrder		( planet2, 900 )
							ScaleEntity		( planet2, PLANET_SIZE*10,PLANET_SIZE*10,PLANET_SIZE*10 ) ; small blue planet

Local sun				=	CreateLight		( 2, Pivot_Universe )
							MoveEntity		( sun, SPACE_UNIT*2,SPACE_UNIT*5,-SPACE_UNIT*4 )
							LightRange		( sun, SPACE_UNIT*10 )
							LightColor		( sun, 250,230,200 )


AmbientLight				( 10,15,25 )
Local sky				=	CreateSphere	( 10, Pivot_Sky )
							FlipMesh		( sky )
							; a nice light blue color for the sky
							EntityColor		( sky, 50,120,255 )
							; for a smart effect of the atmosphere on the planet (by day) -&gt; Blend 3 (LightBlend)
							EntityBlend		( sky , 3 )
							EntityFX		( sky, 1+8 )
							ScaleEntity		( sky, SKY_UNIT*2, SKY_UNIT*2, SKY_UNIT*2 )

Local Skylight			=	CreateLight		( 2, Pivot_Universe )
							MoveEntity		( Skylight, -SKY_UNIT*2,-SKY_UNIT*2, SKY_UNIT*2 )
							LightRange		( Skylight, SKY_UNIT*4 )
							LightColor		( Skylight, +10,15,20 )

; ... a plane for the earth ... kind of hyper-realistic, isn't it ?!
Local earth				=	CreatePlane		( 10, Pivot_World )
							EntityColor		( earth, 50,90,20 )
							
For n = 1 To 500
	Local scaley#		=	Rnd				( 2.0,5.0 )
	Local obj			=	CreateBloc		( Rnd(2.0,10.0), scaley, Rnd(2.0,10), .2, Pivot_World )
							PositionEntity	( obj, Rnd(-500,500), scaley, Rnd(-500,500) )
Next

Local Player			=	CreatePivot		( earth )
Local Player_Head		=	CreatePivot		( Player )
							PositionEntity	( Player_Head, 0,1.8,0 )
Local Player_VelX#		=	.12
Local Player_VelZ#		=	.2

Local cam				=	CreateCamera	( Player_Head )

Local help				=	False
Local wirespace%		=	False
Local wiresky			=	False
Local wireworld			=	False

Local st  = MilliSecs() - 17
Local mt  = 0
Local dt# = 16.7, coef#=1.0
Local fps = 0, fpsc=0, fpst = 0

Repeat
	
	dt = (MilliSecs()-st)-mt
	mt = MilliSecs()-st
	If dt&lt;1 Then dt=1
	
	coef = dt*60.0/1000.0
	
	fpsc=fpsc+1 : If fpst&lt;mt Then fpst=fpst+1000:fps=fpsc:fpsc=0
	
	If KeyHit(59) Then help=Not(help)
	If KeyHit(60) Then wireworld=Not(wireworld)
	If KeyHit(61) Then wiresky=Not(wiresky)
	If KeyHit(62) Then wirespace=Not(wirespace)
	
	Local msx# = MouseXSpeed()
	Local msy# = MouseYSpeed()
	
	If MouseDown(2)
		TurnEntity		( Player		, 0000, -msx, 000 )
		TurnEntity		( Player_Head	, +msy, +000, 000 )
	EndIf
	
	MoveEntity Player, Float(KeyDown(205)-KeyDown(203))*Player_VelX*coef, 0, Float(KeyDown(200)-KeyDown(208))*Player_VelZ*coef
	
	Render_World ( cam, wireworld, wiresky, wirespace )
	
	If Not(help)
		Text 10,10,"F1 - help"
	Else
		Text 10,10,"fps : "+fps
		Text 10,25,"F2 : wireframe world ["+wireworld+"]"
		Text 10,40,"F3 : wireframe sky   ["+wiresky+"]"
		Text 10,55,"F4 : wireframe space ["+wirespace+"]"
		Text 10,70,"Arrows to move"
		Text 10,85,"Right Mouse button to turn"
	EndIf
	
	Flip False
	
Until KeyDown(1)

End


Function Render_World(cam,wireworld=False, wiresky=False, wirespace=False)
	
	; assert the camera is not attached to some entities which will be hidden at any stage of the render process
		Local parent = GetParent(cam)
		EntityParent cam,0
		
		; if you have some stuff attached to the camera, you can use a temporary pivot to attach them before rendering
		; else it will be rendered at the stage that fit the camerarange
		
	; 1st pass - render space -
		ShowEntity		( Pivot_Space )
		HideEntity		( Pivot_Sky )
		HideEntity		( Pivot_World )
		; set cls mode to true, true (clear everything)
		CameraClsMode	( cam, True, True )
		CameraRange		( cam, SPACE_UNIT*.1,SPACE_UNIT*1000 )
		WireFrame		( wirespace )
		RenderWorld		( )
	
	; 2nd pass - render sky -
		HideEntity		( Pivot_Space )
		ShowEntity		( Pivot_Sky )
		HideEntity		( Pivot_World )
	; -&gt; clear the depth buffer only (just "Add" the rendering pass)
		CameraClsMode	( cam, False, True )
		CameraRange		( cam, SKY_UNIT*.1,SKY_UNIT*1000 )
		WireFrame		( wiresky )
		RenderWorld		( )
	
	; 3rd pass - render the world (On Earth) -
		HideEntity		( Pivot_Space )
		HideEntity		( Pivot_Sky )
		ShowEntity		( Pivot_World )
		; same as the sky mode &gt; Add the rendering pass to the current buffer.
		CameraClsMode	( cam, False, True )
		CameraRange		( cam, WORLD_UNIT*.1,WORLD_UNIT*1000 )
		WireFrame		( wireworld )
		RenderWorld		( )
		
	; eventually, show the pivots ... (for some post-rendering ?)
		ShowEntity		( Pivot_Space )
		ShowEntity		( Pivot_Sky )
		
	; get the camera parented again
		EntityParent cam, parent
		
End Function


; a cube with borders and corners (just for fun)
Function CreateBloc(w#,h#,d#, edgesize#=.2, parent%=0)
	Local m = CreateMesh(parent)
	Local s = CreateSurface(m)
	Local e# = edgesize
	Local w1#=w, w2#=w-e
	Local h1#=h, h2#=h-e
	Local d1#=d, d2#=d-e
	AddVertex(s, -w2,-h1,-d2):AddVertex(s, +w2,-h1,-d2):AddVertex(s, +w2,-h1,+d2):AddVertex(s, -w2,-h1,+d2):For i = 00 To 03:VertexNormal s,i,0,-1,0:Next
	AddVertex(s, -w2,+h1,+d2):AddVertex(s, +w2,+h1,+d2):AddVertex(s, +w2,+h1,-d2):AddVertex(s, -w2,+h1,-d2):For i = 04 To 07:VertexNormal s,i,0,+1,0:Next
	AddVertex(s, +w2,-h2,-d1):AddVertex(s, -w2,-h2,-d1):AddVertex(s, -w2,+h2,-d1):AddVertex(s, +w2,+h2,-d1):For i = 08 To 11:VertexNormal s,i,0,0,-1:Next
	AddVertex(s, -w2,-h2,+d1):AddVertex(s, +w2,-h2,+d1):AddVertex(s, +w2,+h2,+d1):AddVertex(s, -w2,+h2,+d1):For i = 12 To 15:VertexNormal s,i,0,0,+1:Next
	AddVertex(s, -w1,-h2,-d2):AddVertex(s, -w1,-h2,+d2):AddVertex(s, -w1,+h2,+d2):AddVertex(s, -w1,+h2,-d2):For i = 16 To 19:VertexNormal s,i,-1,0,0:Next
	AddVertex(s, +w1,-h2,+d2):AddVertex(s, +w1,-h2,-d2):AddVertex(s, +w1,+h2,-d2):AddVertex(s, +w1,+h2,+d2):For i = 20 To 23:VertexNormal s,i,+1,0,0:Next
	For f = 0 To 5:AddTriangle s,f*4+0,f*4+1,f*4+2:AddTriangle s,f*4+0,f*4+2,f*4+3:Next
	; corner triangles
	AddTriangle s, 00,16,09:AddTriangle s, 04,18,15:AddTriangle s, 07,10,19:AddTriangle s, 03,12,17
	AddTriangle s, 01,08,21:AddTriangle s, 06,22,11:AddTriangle s, 05,14,23:AddTriangle s, 02,20,13
	; borders
	AddTriangle s, 00,08,01:AddTriangle s, 00,09,08:AddTriangle s, 01,20,02:AddTriangle s, 01,21,20
	AddTriangle s, 02,12,03:AddTriangle s, 02,13,12:AddTriangle s, 03,16,00:AddTriangle s, 03,17,16
	AddTriangle s, 09,19,10:AddTriangle s, 09,16,19:AddTriangle s, 21,11,22:AddTriangle s, 21,08,11
	AddTriangle s, 13,23,14:AddTriangle s, 13,20,23:AddTriangle s, 12,18,17:AddTriangle s, 12,15,18
	AddTriangle s, 10,06,11:AddTriangle s, 10,07,06:AddTriangle s, 22,05,23:AddTriangle s, 22,06,05
	AddTriangle s, 14,04,15:AddTriangle s, 14,05,04:AddTriangle s, 18,07,19:AddTriangle s, 18,04,07
	Return m
End Function

</textarea><br><br><br>[EDIT]<br>A small SDK to create render pass<br>(I added a funny Inverse fog on the really neay range, that fake ambient oclusion of the "player" when near from the cube or anything)<br><br>And a more colorfull sky using the vertex color of the mesh<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 1024,600,0,2;user32_GetSystemMetrics(0),user32_GetSystemMetrics(1),0,3
SetBuffer BackBuffer()

Global Pivot_Universe	=	CreatePivot		( )
Global Pivot_Space		=	NewRenderPivot	( Pivot_Universe )
Global Pivot_Sky		=	NewRenderPivot	( Pivot_Universe )
Global Pivot_World		=	NewRenderPivot	( Pivot_Universe )

Const SPACE_UNIT#		=	10000000.0		; 10 000 km pretty far (but not that far actually)
Const SKY_UNIT#			=	10000.0			; atmospher at 10 km height
Const WORLD_UNIT#		=	1.0				; blitz unit ... 1 unit = 1 meter

Const ID_RENDER_SPACE%	=	1
Const ID_RENDER_SKY%	=	2
Const ID_RENDER_WORLD%	=	3
Local PASS.RenderPass[3]
PASS[ID_RENDER_SPACE]	=	NewRenderPass	( Pivot_Space	, SPACE_UNIT*000.1, SPACE_UNIT*10000, True , 250,160,050, SPACE_UNIT*0008,SPACE_UNIT*0100, False, True)
PASS[ID_RENDER_SKY  ]	=	NewRenderPass	( Pivot_Sky		, SKY_UNIT  *000.1, SKY_UNIT  *10000, False, 000,000,000, .1,1000, False, True)
PASS[ID_RENDER_WORLD]	=	NewRenderPass	( Pivot_World	, WORLD_UNIT*002.0, WORLD_UNIT*10000, True , 040,060,100, WORLD_UNIT*0050,WORLD_UNIT*0400 , False, True)
							; fake ambient shadow of the camera
							NewRenderPass	( Pivot_World	, WORLD_UNIT*000.1, WORLD_UNIT*002.5, True , 001,001,001, WORLD_UNIT*02.0,WORLD_UNIT*00.5 , False, True, False)

Local PLANET_SIZE#		=	SPACE_UNIT*.01
Local planet1			=	CreateSphere	( 12, Pivot_Space )
							PositionEntity	( planet1, -SPACE_UNIT*4,SPACE_UNIT*1,SPACE_UNIT*6 )
							EntityColor		( planet1, 200,050,000 )
							ScaleEntity		( planet1, PLANET_SIZE*50,PLANET_SIZE*50,PLANET_SIZE*50 ) ; big red planet
							
Local planet2			=	CreateSphere	( 8, Pivot_Space )
							PositionEntity	( planet2, +SPACE_UNIT*2,SPACE_UNIT,SPACE_UNIT*7 )
							EntityOrder		( planet2, 900 )
							ScaleEntity		( planet2, PLANET_SIZE*10,PLANET_SIZE*10,PLANET_SIZE*10 ) ; small blue planet
							
Local planet3			=	CreateSphere	( 12, Pivot_Space )
							PositionEntity	( planet3, -SPACE_UNIT*6,SPACE_UNIT*3,-SPACE_UNIT*9 )
							EntityColor		( planet3, 020,255,180 )
							ScaleEntity		( planet3, PLANET_SIZE*30,PLANET_SIZE*30,PLANET_SIZE*30 ) ; midle greenish planet
							
Local planet4			=	CreateSphere	( 12, Pivot_Space )
							PositionEntity	( planet4, +SPACE_UNIT*1,SPACE_UNIT*6,-SPACE_UNIT*3 )
							EntityColor		( planet4, 200,160,030 )
							ScaleEntity		( planet4, PLANET_SIZE*80,PLANET_SIZE*80,PLANET_SIZE*80 ) ; put your hand up ... you can almost touch it
							

Local sun				=	CreateLight		( 2, Pivot_Universe )
							MoveEntity		( sun, SPACE_UNIT*40,SPACE_UNIT*50,-SPACE_UNIT*40 )
							LightRange		( sun, SPACE_UNIT*60 )
							LightColor		( sun, 250,230,200 )


AmbientLight				( 10,15,25 )
Local sky				=	CreateSphere	( 16, Pivot_Sky )
							FlipMesh		( sky )
							; a nice light blue color for the sky
							EntityColor		( sky, 50,120,255 )
							; for a smart effect of the atmosphere on the planet (by day) -&gt; Blend 3 (LightBlend)
							EntityBlend		( sky , 3 )
							EntityFX		( sky, 1+2+8 )
							ScaleEntity		( sky, SKY_UNIT*2, SKY_UNIT*2, SKY_UNIT*2 )
							s = GetSurface(sky,1)
							For v=0 To CountVertices(s)-1
								y#=VertexY(s,v)
								If y&gt;0 Then y=1.0-(1.0-y)^2:VertexColor s,v,225-y*220,235-y*235,255-y*190
							Next
							
Local Skylight			=	CreateLight		( 2, Pivot_Universe )
							MoveEntity		( Skylight, -SKY_UNIT*2,-SKY_UNIT*2, SKY_UNIT*2 )
							LightRange		( Skylight, SKY_UNIT*4 )
							LightColor		( Skylight, +10,15,20 )

; ... a plane for the earth ... kind of hyper-realistic, isn't it ?!
Local earth				=	CreatePlane		( 10, Pivot_World )
							EntityColor		( earth, 50,90,20 )

Local NbObj = 200
For n = 1 To NbObj
	Local scaley#		=	Rnd				( 3.0,8.0 )
	Local obj			=	CreateBloc		( Rnd(2.0,10.0), scaley, Rnd(2.0,10), .2, Pivot_World )
							PositionEntity	( obj, Rnd(-NbObj,NbObj), scaley, Rnd(-NbObj,NbObj) )
Next

Local Player			=	CreatePivot		( earth )
Local Player_Head		=	CreatePivot		( Player )
							PositionEntity	( Player_Head, 0,1.8,0 )
Local Player_VelX#		=	.12
Local Player_VelZ#		=	.2

Local cam				=	CreateCamera	( Player_Head )

Local help				=	False
Local wirespace%		=	False
Local wiresky			=	False
Local wireworld			=	False

Local st  = MilliSecs() - 17
Local mt  = 0
Local dt# = 16.7, coef#=1.0
Local fps = 0, fpsc=0, fpst = 0

Repeat
	
	dt = (MilliSecs()-st)-mt
	mt = MilliSecs()-st
	If dt&lt;1 Then dt=1
	
	coef = dt*60.0/1000.0
	
	fpsc=fpsc+1 : If fpst&lt;mt Then fpst=fpst+1000:fps=fpsc:fpsc=0
	
	If KeyHit(59) Then help=Not(help)
	If KeyHit(60) Then PASS[ID_RENDER_WORLD]\wire=Not(PASS[ID_RENDER_WORLD]\wire)
	If KeyHit(61) Then PASS[ID_RENDER_SKY  ]\wire=Not(PASS[ID_RENDER_SKY  ]\wire)
	If KeyHit(62) Then PASS[ID_RENDER_SPACE]\wire=Not(PASS[ID_RENDER_SPACE]\wire)
	
	Local msx# = MouseXSpeed()
	Local msy# = MouseYSpeed()
	
	If MouseDown(2)
		TurnEntity		( Player		, 0000, -msx, 000 )
		TurnEntity		( Player_Head	, +msy, +000, 000 )
	EndIf
	
	MoveEntity Player, Float(KeyDown(205)-KeyDown(203))*Player_VelX*coef, 0, Float(KeyDown(200)-KeyDown(208))*Player_VelZ*coef
	
	Render_World ( cam, wireworld, wiresky, wirespace )
	
	If Not(help)
		Text 10,10,"F1 - help"
	Else
		Text 10,10,"fps : "+fps
		Text 10,25,"F2 : wireframe world ["+PASS[ID_RENDER_WORLD]\wire+"]"
		Text 10,40,"F3 : wireframe sky   ["+PASS[ID_RENDER_SKY  ]\wire+"]"
		Text 10,55,"F4 : wireframe space ["+PASS[ID_RENDER_SPACE]\wire+"]"
		Text 10,70,"Arrows to move"
		Text 10,85,"Right Mouse button to turn"
	EndIf
	
	Flip False
	
Until KeyDown(1)

End

Type RenderPivot
	Field pivot
End Type

Type RenderPass
	Field clsc,clsd
	Field rangenear#,rangefar#
	Field fogmode%
	Field fogr,fogg,fogb
	Field fognear#,fogfar#
	Field pivot.RenderPivot
	Field wire%
End Type

Function NewRenderPivot(parent%)
	Local pivot = CreatePivot(parent)
	Local rp.RenderPivot = New RenderPivot
	rp\pivot = pivot
	NameEntity(pivot,Handle(rp))
	Return pivot
End Function

Function NewRenderPass.RenderPass(pivot,rangenear#,rangefar#, fogmode%,fogr,fogg,fogb,fognear#,fogfar#, clsc,clsd, wire%=False)
	Local rp.RenderPass = New RenderPass
	rp\rangenear=rangenear
	rp\rangefar=rangefar
	rp\fogmode=fogmode
	rp\fogr=fogr
	rp\fogg=fogg
	rp\fogb=fogb
	rp\fognear=fognear
	rp\fogfar=fogfar
	rp\clsc=clsc
	rp\clsd=clsd
	rp\wire=wire
	rp\pivot = Object.RenderPivot(EntityName(pivot))
	Return rp
End Function

Function Render_World(cam,wireworld=False, wiresky=False, wirespace=False)
	
	; assert the camera is not attached to some entities which will be hidden at any stage of the render process
		Local parent = GetParent(cam)
		EntityParent cam,0
		
		; if you have some stuff attached to the camera, you can use a temporary pivot to attach them before rendering
		; else it will be rendered at the stage that fit the camerarange
		
		Local nb=0
		Local pass.RenderPass
		
		For pass = Each RenderPass
			
			If nb=0
				CameraClsMode	( cam, True, True )
			Else
				CameraClsMode	( cam, pass\clsc,pass\clsd )
			EndIf
			Local pivot.RenderPivot
			For pivot = Each RenderPivot
				HideEntity pivot\pivot
			Next
			ShowEntity pass\pivot\pivot
			CameraRange		( cam, pass\rangenear,pass\rangefar )
			CameraFogMode	( cam, pass\fogmode )
			If pass\fogmode
				CameraFogColor	( cam, pass\fogr,pass\fogg,pass\fogb )
				CameraFogRange	( cam, pass\fognear, pass\fogfar )
			EndIf
			WireFrame pass\wire
			RenderWorld
			nb=nb+1
		Next
		
	; get the camera parented again
		EntityParent cam, parent
		
;	; 1st pass - render space -
;		ShowEntity		( Pivot_Space )
;		HideEntity		( Pivot_Sky )
;		HideEntity		( Pivot_World )
;		; set cls mode to true, true (clear everything)
;		CameraRange		( cam, SPACE_UNIT*.1,SPACE_UNIT*1000 )
;		WireFrame		( wirespace )
;		RenderWorld		( )
;	
;	; 2nd pass - render sky -
;		HideEntity		( Pivot_Space )
;		ShowEntity		( Pivot_Sky )
;		HideEntity		( Pivot_World )
;	; -&gt; clear the depth buffer only (just "Add" the rendering pass)
;		CameraClsMode	( cam, False, True )
;		CameraRange		( cam, SKY_UNIT*.1,SKY_UNIT*1000 )
;		WireFrame		( wiresky )
;		RenderWorld		( )
;	
;	; 3rd pass - render the world (On Earth) -
;		HideEntity		( Pivot_Space )
;		HideEntity		( Pivot_Sky )
;		ShowEntity		( Pivot_World )
;		; same as the sky mode &gt; Add the rendering pass to the current buffer.
;		CameraClsMode	( cam, False, True )
;		CameraRange		( cam, WORLD_UNIT*.1,WORLD_UNIT*1000 )
;		WireFrame		( wireworld )
;		RenderWorld		( )
;		
;	; eventually, show the pivots ... (for some post-rendering ?)
;		ShowEntity		( Pivot_Space )
;		ShowEntity		( Pivot_Sky )
		
		
End Function


; a cube with borders and corners (just for fun)
Function CreateBloc(w#,h#,d#, edgesize#=.2, parent%=0)
	Local m = CreateMesh(parent)
	Local s = CreateSurface(m)
	Local e# = edgesize
	Local w1#=w, w2#=w-e
	Local h1#=h, h2#=h-e
	Local d1#=d, d2#=d-e
	AddVertex(s, -w2,-h1,-d2):AddVertex(s, +w2,-h1,-d2):AddVertex(s, +w2,-h1,+d2):AddVertex(s, -w2,-h1,+d2):For i = 00 To 03:VertexNormal s,i,0,-1,0:Next
	AddVertex(s, -w2,+h1,+d2):AddVertex(s, +w2,+h1,+d2):AddVertex(s, +w2,+h1,-d2):AddVertex(s, -w2,+h1,-d2):For i = 04 To 07:VertexNormal s,i,0,+1,0:Next
	AddVertex(s, +w2,-h2,-d1):AddVertex(s, -w2,-h2,-d1):AddVertex(s, -w2,+h2,-d1):AddVertex(s, +w2,+h2,-d1):For i = 08 To 11:VertexNormal s,i,0,0,-1:Next
	AddVertex(s, -w2,-h2,+d1):AddVertex(s, +w2,-h2,+d1):AddVertex(s, +w2,+h2,+d1):AddVertex(s, -w2,+h2,+d1):For i = 12 To 15:VertexNormal s,i,0,0,+1:Next
	AddVertex(s, -w1,-h2,-d2):AddVertex(s, -w1,-h2,+d2):AddVertex(s, -w1,+h2,+d2):AddVertex(s, -w1,+h2,-d2):For i = 16 To 19:VertexNormal s,i,-1,0,0:Next
	AddVertex(s, +w1,-h2,+d2):AddVertex(s, +w1,-h2,-d2):AddVertex(s, +w1,+h2,-d2):AddVertex(s, +w1,+h2,+d2):For i = 20 To 23:VertexNormal s,i,+1,0,0:Next
	For f = 0 To 5:AddTriangle s,f*4+0,f*4+1,f*4+2:AddTriangle s,f*4+0,f*4+2,f*4+3:Next
	; corner triangles
	AddTriangle s, 00,16,09:AddTriangle s, 04,18,15:AddTriangle s, 07,10,19:AddTriangle s, 03,12,17
	AddTriangle s, 01,08,21:AddTriangle s, 06,22,11:AddTriangle s, 05,14,23:AddTriangle s, 02,20,13
	; borders
	AddTriangle s, 00,08,01:AddTriangle s, 00,09,08:AddTriangle s, 01,20,02:AddTriangle s, 01,21,20
	AddTriangle s, 02,12,03:AddTriangle s, 02,13,12:AddTriangle s, 03,16,00:AddTriangle s, 03,17,16
	AddTriangle s, 09,19,10:AddTriangle s, 09,16,19:AddTriangle s, 21,11,22:AddTriangle s, 21,08,11
	AddTriangle s, 13,23,14:AddTriangle s, 13,20,23:AddTriangle s, 12,18,17:AddTriangle s, 12,15,18
	AddTriangle s, 10,06,11:AddTriangle s, 10,07,06:AddTriangle s, 22,05,23:AddTriangle s, 22,06,05
	AddTriangle s, 14,04,15:AddTriangle s, 14,05,04:AddTriangle s, 18,07,19:AddTriangle s, 18,04,07
	Return m
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1181664"></a>

<a name="1181665"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rroff</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd seriously reccomend using something like Bobysait suggested rather than trying to hack it up by other methods.<br><br>Depending on how your world is setup you can either hide/show groups for the rendering or use a small section outside of the main world and render a camera from there first then do a second render without clearing the color buffer from where the actual player's eye is. <br><br></td></tr></table><br>
<a name="1181674"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Captain Wicker (crazy hillbilly)</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Axel Wheeler: Search the forums for a program called "planet creator". I believe it is open source and is written in BlitzMax + miniB3D (Blitz3D). could have what you are looking for.. <br><br></td></tr></table><br>
<a name="1181702"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> You guys are awesome!  I work weekends and don't have time to digest this right now, but hopefully I'll get a chance in the morning...<br><br>Thanks all! <br><br></td></tr></table><br>
<a name="1181703"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Bobysait: how would you work out letting the player\ships come near those planets, or even enter their atmostphere, land etc? <br><br></td></tr></table><br>
<a name="1181706"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> At the moment they are reaaaaally far from the planet, I don't think Axel was trying to make them landing.<br><br>The method here is just to separate the different background at different scale.<br>If you want a ship to land on a planet, then it means the planet is not that far, but its size would be so large when the ship will come close to the planet, that the float won't enable a good precision for this kind of thing unless you rescale the planet to something descent, but inappropriate for a "planet"<br>So maybe, if we want this kind of thing, you need a Spore-like system.<br><br>-&gt; the zoom out effect when you live a planet and come to a universe scaling.<br>Everything is just resized.<br><br><br>I'm testing a system where the global pivots are suitable for this kind of purpose.<br>I'll post it soon. <br><br></td></tr></table><br>
<a name="1181759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ZJP</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Salut Boby )<br><br><br>JP972 <br><br></td></tr></table><br>
<a name="1182054"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>how would you work out letting the player\ships come near those planets, or even enter their atmostphere, land etc?  <br></div><br>I like the Eve-Online method for this. Adjusting scale factors depending on the precision required.<br><br>While in orbit and around a few thousand kilometres from the planet, the planet and maybe its moons can be "attached" to the Skybox as described in this thread - yet when approaching the planet, the scale is altered and LOD changes reflect this:<br>The Planet and (Moons?) become Meshes, the Star may be attached to the Skybox.<br>Small MESH Objects still in orbit can be freed, but if they still need referencing, stick a Sprite (or flat quad) if they still need to be visible, or just a Pivot to the relevant Skybox position.<br>Clouds/atmosphere etc. can be realised.<br><br>By committing these changes through careful use of Hiding then Freeing entities and 'Loading' then Showing (or Swapping) the entities this can be achieved smoothly and, even masked (as with Eve) via the use of a "Warp Drive" effect so it's not so obvious as things are popping into and out of existance.<br>With the descent to a planet's surface, this 'masking effect' can be achieved with something like atmospheric burn-up or 'ploughing through cloud layers' provided of course that the planet has an atmosphere.<br><br>Regardless of the approach, it's pretty unfeasible to have a consistent and comprehensive single-scaled planetary system. Just modelling the Earth, Moon and Sun to scales of size and distance can stretch the floating point arithmetic and rendering capabilities. <br>Every space game or simulation in existence has always had a procedure for either altering scale or occluding via "rooms" (consider X games where each 'sector' in the universe had to be reached via a "gate" - effectively the same as a door between adjacent rooms which allowed specific point-to-point travel with no visibility through) <br><br></td></tr></table><br>
<a name="1182745"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok I can update you on this:<br><br>Based on Bobysait's comment I basically went with a modified form of my first option; that is, the spinning planet is full size and distance and is rendered in the same Renderworld as the skybox, but it's entity order is later (closer) so one render takes care of skybox, planet, and stars (which are EntityCopies of the same quad set to different colors).<br><br>The second render is standard 1-1000 range and takes care of everything that travels.  This is working fine so far.<br><br>This is most similar to Bobysait's solution except that he suggests using a system to hide the near entities during the far render and vice versa. <br><br>This would be a burden since near objects also include things like fragments of broken ships and particles of various kinds (bullets, etc.).  Add to this the fact that I am sometimes parenting and unparenting the various objects to other things during a given frame, so there is overhead in making sure everything ends up parented to a "hideme" pivot for rendering purposes.  Doable, of course, but I wondered what the time saved would really be.  I wrote a test.  Long story short, it turns out that hiding the entities would save a little time, but most of the time saved is due to them being out of sight (i.e. in front of the camera range).  I guess the difference is because if they are hidden the system dismisses them faster than having to calculate their distance and do a test.  <br><br>So the lesson is, if I scale up the number of nearby objects, I should consider hiding them during the far render to save a bit of extra time.  (Of course there's no need to hide the far objects during the near render; there aren't enough of them to make a noticeable time difference.)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D(1280,1024,32,2)
SetBuffer(BackBuffer())

Global cam=CreateCamera()
CameraClsMode(cam,True,True)

AmbientLight(32,32,100)
Global sun=CreateLight()
LightColor(sun,255,255,150)
RotateEntity(sun,45,45,0)

Global basePivot=CreatePivot()

Local i
Local t.Thing
Local z#
Local aveTime#

Type Thing
	Field e
End Type

; Create a bunch of things in the near render space

For i=1 To 2000
	t.Thing=New Thing
	t\e=CreateCube()
	EntityColor(t\e,Rnd(255),Rnd(255),Rnd(255))
	RotateEntity(t\e,Rnd(255),Rnd(255),Rnd(255))
	z#=Rnd(20,1000)
	PositionEntity(t\e,Rnd(-z/2,z/2),Rnd(-z/2,z/2),z)
	EntityParent(t\e,basePivot)
Next

; Create one object in the far render space

Local farSphere=CreateSphere()
ScaleEntity(farSphere,10000,10000,10000)
PositionEntity(farSphere,0,0,30000)
EntityColor(farSphere,Rnd(255),Rnd(255),Rnd(255))

Local startTime,endTime

While Not KeyHit(1)
	
	startTime=MilliSecs()
	
	If KeyDown(57)
		HideEntity(basePivot) 
	Else
		ShowEntity(basePivot)
	EndIf
	
	CameraClsMode(cam,True,True)
	CameraRange(cam,1000,1000000) 
	RenderWorld()
	ShowEntity(basePivot)
	CameraClsMode(cam,False,True)
	CameraRange(cam,1,1000)
;	This line will actually render the near objects, not needed for the test, but uncomment it if you want to see both renders
	;RenderWorld()
	
	endTime=MilliSecs()
	aveTime#=aveTime#*.5+(endTime-startTime)*.5
	
	Text(0,0,"Average render time in ms is: "+aveTime#)
	Text(500,0,"Press Space to hide the near objects.")
	Color(0,255,0)
	Rect(0,15,aveTime*20.0,15,1)
	Color(255,255,255)
	For i=1 To 30
		Text(i*20,30,i,1)
	Next
	Flip()
	Delay(10)
Wend
</textarea> <br><br></td></tr></table><br>
<a name="1183162"></a>

<a name="1183163"></a>

<a name="1183164"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> The stuff behind the "global pivots" is a bit more complicated.<br><br>When you call "renderworld", the entities are drawn according to the hierarchy.<br>Just imagine that blitz use a kind of Linked-List for the "root" entities, and all the other entities are accessibles only with the hierarchy<br>relative to those roots. so when the renderworld is called, it first loops the Root-entities and for each root, it performs a simple<br>"If Show=true Then render children"<br><br>if we made this in blitz it would/could(/should?) looks like this<br><pre class=code>
Type Entity
   field bbEntity ; the blitz entity
   field nextentity.Entity ; the next entity in the hierarchy (the next "child")
   field preventity.Entity ; the previous (for doubly-linked list)
   field parent.Entity ; the parent ^^
   field firstchild.Entity ; the first child of this entity
   field lastchild.Entity ; and the last one.
   
   field Mat.Matrix ; the global 4*3 matrix (blitz3d use more than just a 4*3 matrix, it can be seen in the memory, where we find offsets for quaternions, position, scale, origin etc ... but let's simplify this with a single 4*3 matrix)
   field show ; a boolean value true/false (des/activated with Hide/ShowEntity)
   field .... all the entity stuff (class, flags, associated/derived objects etc ...)
End type


Type RootEntity
   Field entity.Entity
End Type

Type Camera
   Field entity.Entity
   Field frustum.Frustum
   Field ProjMat.Matrix
   Field ModelViewMat.Matrix
End type

Function RenderWorld()
  For camera= Each Camera
      if camera\Projmode&gt;0
         if camera\show=true
            For Root = Each RootEntity
                RenderEntity Root\Entity, Camera
            Next
         endif
      endif
  Next
End Function


Function RenderEntity(entity.Entity,camera.Camera)
   If Entity\Show=false then Return
   ; Else performs a frustum test with the bounding box if the entity is a "renderable" class
   Select EntityClass(entity\bbEntity)
       case "Mesh"
          If EntityInFrustum(entity,camera\Frustum)
            RenderMesh(entity)
          Endif
       case "Terrain"
          If EntityInFrustum(entity,camera\Frustum)
            RenderTerrain(entity)
          Endif
       case "Sprite", .... 
          If EntityInFrustum(entity,camera\Frustum)
            RenderSprite(entity)
          Endif
   End Select
   
   ; finally, call the renderentity on each child (recursively)
   child = entity\firstChild
   while child&lt;&gt;null
      RenderEntity(child,camera)
      child=child\nextentity
   wend
End function
</pre><br><br><br>So, when you have a simple pivot containing all entities for a layer (like the background vs foreground layers), the renderworld<br>will only perform one : "If Backgroundpivot\show = false then Return" (it's not exactly what is involved, but it's almost the same)<br>When you don't hide the "root pivot", the renderworld will perform the "If Show = true/False" and as it is not hidden, it will check<br>for each children (recursively) the frustum check ("EntityInView Test") and some other internal stuff<br>Then, if you manage a lot of entities (like sprites for fake-stars or things like this) on a layer, then, just think you'll render<br>the layer twice<br><br>Of course, if there is only two planets (less than 10 entities) it saves ... 0.001 ms (?) which is not noticable ...<br><br>One other point to check is that, some machines are lower on rendering lots of triangles as it really depends on both cpu AND gpu<br>- with a good cpu and bad graphics card, rendering many entities won't be a big deal unless each entities is made of lots of polygons :<br>and as you ask the graphics card to render them twice it will be twice lower.<br>- with a bad cpu and a good graphics card, you can go for two or three or more renderworld without problems, but the framerate will decrease with more entities.<br><br>So, in both cases, hiding the pivot you don't nead to render on the current rendering pass will prevent users with low cpu or low gpu (or both) from drastic slowdown.<br><br>and of course, it's required only if you envisage to broadcast your app/game(s)<br><br><br><br>Hope it's not too confused, but I think this post can maybe help people to understand what is involved in almost graphics engines based on hierarchy<br>and then why some codes are slow or not depending on the computers that run them <br><br></td></tr></table><br>
<a name="1183467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Axel Wheeler</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, Bobysait, that is extremely useful information.  Thanks! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
