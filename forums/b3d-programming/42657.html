<!DOCTYPE html><html lang="en" ><head ><title >Blitz3D C++ geometry code</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Blitz3D C++ geometry code</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=82" >Blitz3D Programming</a>/<a href="#bottom" >Blitz3D C++ geometry code</a><br><br>
<a name="477654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I frequently get asked questions about Blitz3D's internal math routines.<br><br>So here, in all its glory, is the geom.h file from Blitz3D. It's in C++, so it may be a bit confusing, but the math should be pretty obvious.<br><br>Have fun - and please let me know if you find any bugs!<br><br>Mark<br><br><pre class=code>
#ifndef GEOM_H
#define GEOM_H

#include &lt;math.h&gt;

class Vector;
class Line;
class Plane;
class Matrix;
class Transform;

const float PI=3.14159265359f;		//180 degrees
const float TWOPI=PI*2.0f;			//360 degrees
const float HALFPI=PI*.5f;			//90  degrees
const float QUARTERPI=PI*.25f;		//45  degrees
const float EPSILON=.000001f;		//small value
const float INFINITY=10000000.0f;	//big value

class Vector{
public:
	float x,y,z;

	Vector():x(0),y(0),z(0){
	}
	Vector( float x,float y,float z ):x(x),y(y),z(z){
	}
	operator float*(){
		return &amp;x;
	}
	operator const float *(){
		return &amp;x;
	}
	float &amp;operator[]( int n ){
		return (&amp;x)[n]; 
	}
	float operator[]( int n )const{
		return (&amp;x)[n]; 
	}
	Vector operator-()const{
		return Vector( -x,-y,-z ); 
	}
	Vector operator*( float scale )const{
		return Vector( x*scale,y*scale,z*scale );
	}
	Vector operator*( const Vector &amp;q )const{
		return Vector( x*q.x,y*q.y,z*q.z );
	}
	Vector operator/( float scale )const{
		return Vector( x/scale,y/scale,z/scale );
	}
	Vector operator/( const Vector &amp;q )const{
		return Vector( x/q.x,y/q.y,z/q.z );
	}
	Vector operator+( const Vector &amp;q )const{
		return Vector( x+q.x,y+q.y,z+q.z );
	}
	Vector operator-( const Vector &amp;q )const{
		return Vector( x-q.x,y-q.y,z-q.z );
	}
	Vector &amp;operator*=( float scale ){
		x*=scale;y*=scale;z*=scale;return *this;
	}
	Vector &amp;operator*=( const Vector &amp;q ){
		x*=q.x;y*=q.y;z*=q.z;return *this;
	}
	Vector &amp;operator/=( float scale ){
		x/=scale;y/=scale;z/=scale;return *this;
	}
	Vector &amp;operator/=( const Vector &amp;q ){
		x/=q.x;y/=q.y;z/=q.z;return *this;
	}
	Vector &amp;operator+=( const Vector &amp;q ){
		x+=q.x;y+=q.y;z+=q.z;return *this;
	}
	Vector &amp;operator-=( const Vector &amp;q ){
		x-=q.x;y-=q.y;z-=q.z;return *this;
	}
	bool operator&lt;( const Vector &amp;q )const{
		if( fabs(x-q.x)&gt;EPSILON ) return x&lt;q.x ? true : false;
		if( fabs(y-q.y)&gt;EPSILON ) return y&lt;q.y ? true : false;
		return fabs(z-q.z)&gt;EPSILON &amp;&amp; z&lt;q.z;
	}
	bool operator==( const Vector &amp;q )const{
		return fabs(x-q.x)&lt;=EPSILON &amp;&amp; fabs(y-q.y)&lt;=EPSILON &amp;&amp; fabs(z-q.z)&lt;=EPSILON;
	}
	bool operator!=( const Vector &amp;q )const{
		return fabs(x-q.x)&gt;EPSILON || fabs(y-q.y)&gt;EPSILON || fabs(z-q.z)&gt;EPSILON;
	}
	float dot( const Vector &amp;q )const{
		return x*q.x+y*q.y+z*q.z;
	}
	Vector cross( const Vector &amp;q )const{
		return Vector( y*q.z-z*q.y,z*q.x-x*q.z,x*q.y-y*q.x );
	}
	float length()const{
		return sqrtf(x*x+y*y+z*z);
	}
	float distance( const Vector &amp;q )const{
		float dx=x-q.x,dy=y-q.y,dz=z-q.z;return sqrtf(dx*dx+dy*dy+dz*dz);
	}
	Vector normalized()const{
		float l=length();return Vector( x/l,y/l,z/l );
	}
	void normalize(){
		float l=length();x/=l;y/=l;z/=l;
	}
	float yaw()const{
		return -atan2f( x,z );
	}
	float pitch()const{
		return -atan2f( y,sqrtf( x*x+z*z ) );
	}
	void clear(){
		x=y=z=0;
	}
};

class Line{
public:
	Vector o,d;
	Line(){
	}
	Line( const Vector &amp;o,const Vector &amp;d ):o(o),d(d){
	}
	Line operator+( const Vector &amp;q )const{
		return Line( o+q,d );
	}
	Line operator-( const Vector &amp;q )const{
		return Line( o-q,d );
	}
	Vector operator*( float q )const{
		return o+d*q;
	}
	Vector nearest( const Vector &amp;q )const{
		return o+d*(d.dot(q-o)/d.dot(d));
	}
};

class Plane{
public:
	Vector n;
	float d;

	Plane():d(0){
	}
	//normal/offset form
	Plane( const Vector &amp;n,float d ):n(n),d(d){
	}
	//point/normal form
	Plane( const Vector &amp;p,const Vector &amp;n ):n(n),d(-n.dot(p)){
	}
	//create plane from tri
	Plane( const Vector &amp;v0,const Vector &amp;v1,const Vector &amp;v2 ){
		n=(v1-v0).cross(v2-v0).normalized();d=-n.dot(v0);
	}
	Plane operator-()const{
		return Plane( -n,-d );
	}
	float t_intersect( const Line &amp;q )const{
		return -distance(q.o)/n.dot(q.d);
	}
	Vector intersect( const Line &amp;q )const{
		return q*t_intersect(q);
	}
	Line intersect( const Plane &amp;q )const{
		Vector lv=n.cross( q.n ).normalized();
		return Line( q.intersect( Line( nearest( n*-d ),n.cross(lv) ) ),lv );
	}
	Vector nearest( const Vector &amp;q )const{
		return q-n*distance(q);
	}
	void negate(){
		n=-n;d=-d;
	}
	float distance( const Vector &amp;q )const{
		return n.dot(q)+d;
	}
};

struct Quat{
	float w;
	Vector v;
	Quat():w(1){
	}
	Quat( float w,const Vector &amp;v ):w(w),v(v){
	}
	Quat operator-()const{
		return Quat( w,-v );
	}
	Quat operator+( const Quat &amp;q )const{
		return Quat( w+q.w,v+q.v );
	}
	Quat operator-( const Quat &amp;q )const{
		return Quat( w-q.w,v-q.v );
	}
	Quat operator*( const Quat &amp;q )const{
		return Quat( w*q.w-v.dot(q.v),q.v.cross(v)+q.v*w+v*q.w );
	}
	Vector operator*( const Vector &amp;q )const{
		return (*this * Quat(0,q) * -*this).v;
	}
	Quat operator*( float q )const{
		return Quat( w*q,v*q );
	}
	Quat operator/( float q )const{
		return Quat( w/q,v/q );
	}
	float dot( const Quat &amp;q )const{
		return v.x*q.v.x+v.y*q.v.y+v.z*q.v.z+w*q.w;
	}
	float length()const{
		return sqrtf( w*w+v.x*v.x+v.y*v.y+v.z*v.z );
	}
	void normalize(){
		*this=*this/length();
	}
	Quat normalized()const{
		return *this/length();
	}
	Quat slerpTo( const Quat &amp;q,float a )const{
		Quat t=q;
		float d=dot(q),b=1-a;
		if( d&lt;0 ){ t.w=-t.w;t.v=-t.v;d=-d; }
		if( d&lt;1-EPSILON ){
			float om=acosf( d );
			float si=sinf( om );
			a=sinf( a*om )/si;
			b=sinf( b*om )/si;
		}
		return *this*b + t*a;
	}
	Vector i()const{
		float xz=v.x*v.z,wy=w*v.y;
		float xy=v.x*v.y,wz=w*v.z;
		float yy=v.y*v.y,zz=v.z*v.z;
		return Vector( 1-2*(yy+zz),2*(xy-wz),2*(xz+wy) );
	}
	Vector j()const{
		float yz=v.y*v.z,wx=w*v.x;
		float xy=v.x*v.y,wz=w*v.z;
		float xx=v.x*v.x,zz=v.z*v.z;
		return Vector( 2*(xy+wz),1-2*(xx+zz),2*(yz-wx) );
	}
	Vector k()const{
		float xz=v.x*v.z,wy=w*v.y;
		float yz=v.y*v.z,wx=w*v.x;
		float xx=v.x*v.x,yy=v.y*v.y;
		return Vector( 2*(xz-wy),2*(yz+wx),1-2*(xx+yy) );
	}
};

class Matrix{
	static Matrix tmps[64];
	static Matrix &amp;alloc_tmp(){ static int tmp=0;return tmps[tmp++&amp;63];	}
	friend class Transform;
public:
	Vector i,j,k;

	Matrix():i(Vector(1,0,0)),j(Vector(0,1,0)),k(Vector(0,0,1)){
	}
	Matrix( const Vector &amp;i,const Vector &amp;j,const Vector &amp;k ):i(i),j(j),k(k){
	}
	Matrix( const Quat &amp;q ){
		float xx=q.v.x*q.v.x,yy=q.v.y*q.v.y,zz=q.v.z*q.v.z;
		float xy=q.v.x*q.v.y,xz=q.v.x*q.v.z,yz=q.v.y*q.v.z;
		float wx=q.w*q.v.x,wy=q.w*q.v.y,wz=q.w*q.v.z;
		i=Vector( 1-2*(yy+zz),2*(xy-wz),2*(xz+wy) ),
		j=Vector( 2*(xy+wz),1-2*(xx+zz),2*(yz-wx) ),
		k=Vector( 2*(xz-wy),2*(yz+wx),1-2*(xx+yy) );
	}
	Matrix( float angle,const Vector &amp;axis ){
		const Vector &amp;u=axis;
		float c=cosf(angle),s=sinf(angle);
		float x2=axis.x*axis.x,y2=axis.y*axis.y,z2=axis.z*axis.z;
		i=Vector( x2+c*(1-x2),u.x*u.y*(1-c)-u.z*s,u.z*u.x*(1-c)+u.y*s );
		j=Vector( u.x*u.y*(1-c)+u.z*s,y2+c*(1-y2),u.y*u.z*(1-c)-u.x*s );
		k=Vector( u.z*u.x*(1-c)-u.y*s,u.y*u.z*(1-c)+u.x*s,z2+c*(1-z2) );
	}
	Vector &amp;operator[]( int n ){
		return (&amp;i)[n]; 
	}
	const Vector &amp;operator[]( int n )const{
		return (&amp;i)[n];
	}
	Matrix &amp;operator~()const{
		Matrix &amp;m=alloc_tmp();
		m.i.x=i.x;m.i.y=j.x;m.i.z=k.x;
		m.j.x=i.y;m.j.y=j.y;m.j.z=k.y;
		m.k.x=i.z;m.k.y=j.z;m.k.z=k.z;
		return m;
	}
	float determinant()const{
		return i.x*(j.y*k.z-j.z*k.y )-i.y*(j.x*k.z-j.z*k.x )+i.z*(j.x*k.y-j.y*k.x );
	}
	Matrix &amp;operator-()const{
		Matrix &amp;m=alloc_tmp();
		float t=1.0f/determinant();
		m.i.x= t*(j.y*k.z-j.z*k.y);m.i.y=-t*(i.y*k.z-i.z*k.y);m.i.z= t*(i.y*j.z-i.z*j.y);
		m.j.x=-t*(j.x*k.z-j.z*k.x);m.j.y= t*(i.x*k.z-i.z*k.x);m.j.z=-t*(i.x*j.z-i.z*j.x);
		m.k.x= t*(j.x*k.y-j.y*k.x);m.k.y=-t*(i.x*k.y-i.y*k.x);m.k.z= t*(i.x*j.y-i.y*j.x);
		return m;
	}
	Matrix &amp;cofactor()const{
		Matrix &amp;m=alloc_tmp();
		m.i.x= (j.y*k.z-j.z*k.y);m.i.y=-(j.x*k.z-j.z*k.x);m.i.z= (j.x*k.y-j.y*k.x);
		m.j.x=-(i.y*k.z-i.z*k.y);m.j.y= (i.x*k.z-i.z*k.x);m.j.z=-(i.x*k.y-i.y*k.x);
		m.k.x= (i.y*j.z-i.z*j.y);m.k.y=-(i.x*j.z-i.z*j.x);m.k.z= (i.x*j.y-i.y*j.x);
		return m;
	}
	bool operator==( const Matrix &amp;q )const{
		return i==q.i &amp;&amp; j==q.j &amp;&amp; k==q.k;
	}
	bool operator!=( const Matrix &amp;q )const{
		return i!=q.i || j!=q.j || k!=q.k;
	}
	Vector operator*( const Vector &amp;q )const{
		return Vector( i.x*q.x+j.x*q.y+k.x*q.z,i.y*q.x+j.y*q.y+k.y*q.z,i.z*q.x+j.z*q.y+k.z*q.z );
	}
	Matrix &amp;operator*( const Matrix &amp;q )const{
		Matrix &amp;m=alloc_tmp();
		m.i.x=i.x*q.i.x+j.x*q.i.y+k.x*q.i.z;m.i.y=i.y*q.i.x+j.y*q.i.y+k.y*q.i.z;m.i.z=i.z*q.i.x+j.z*q.i.y+k.z*q.i.z;
		m.j.x=i.x*q.j.x+j.x*q.j.y+k.x*q.j.z;m.j.y=i.y*q.j.x+j.y*q.j.y+k.y*q.j.z;m.j.z=i.z*q.j.x+j.z*q.j.y+k.z*q.j.z;
		m.k.x=i.x*q.k.x+j.x*q.k.y+k.x*q.k.z;m.k.y=i.y*q.k.x+j.y*q.k.y+k.y*q.k.z;m.k.z=i.z*q.k.x+j.z*q.k.y+k.z*q.k.z;
		return m;
	}
	void orthogonalize(){
		k.normalize();
		i=j.cross( k ).normalized();
		j=k.cross( i );
	}
	Matrix &amp;orthogonalized()const{
		Matrix &amp;m=alloc_tmp();
		m=*this;m.orthogonalize();
		return m;
	}
};

class Box{
public:
	Vector a,b;
	Box():a( Vector(INFINITY,INFINITY,INFINITY) ),b( Vector(-INFINITY,-INFINITY,-INFINITY) ){
	}
	Box( const Vector &amp;q ):a(q),b(q){
	}
	Box( const Vector &amp;a,const Vector &amp;b ):a(a),b(b){
	}
	Box( const Line &amp;l ):a(l.o),b(l.o){
		update( l.o+l.d );
	}
	void clear(){
		a.x=a.y=a.z=INFINITY;
		b.x=b.y=b.z=-INFINITY;
	}
	bool empty()const{
		return b.x&lt;a.x || b.y&lt;a.y || b.z&lt;a.z;
	}
	Vector centre()const{
		return Vector( (a.x+b.x)*.5f,(a.y+b.y)*.5f,(a.z+b.z)*.5f );
	}
	Vector corner( int n )const{
		return Vector( ((n&amp;1)?b:a).x,((n&amp;2)?b:a).y,((n&amp;4)?b:a).z );
	}
	void update( const Vector &amp;q ){
		if( q.x&lt;a.x ) a.x=q.x;if( q.y&lt;a.y ) a.y=q.y;if( q.z&lt;a.z ) a.z=q.z;
		if( q.x&gt;b.x ) b.x=q.x;if( q.y&gt;b.y ) b.y=q.y;if( q.z&gt;b.z ) b.z=q.z;
	}
	void update( const Box &amp;q ){
		if( q.a.x&lt;a.x ) a.x=q.a.x;if( q.a.y&lt;a.y ) a.y=q.a.y;if( q.a.z&lt;a.z ) a.z=q.a.z;
		if( q.b.x&gt;b.x ) b.x=q.b.x;if( q.b.y&gt;b.y ) b.y=q.b.y;if( q.b.z&gt;b.z ) b.z=q.b.z;
	}
	bool overlaps( const Box &amp;q )const{
		return
		(b.x&lt;q.b.x?b.x:q.b.x)&gt;=(a.x&gt;q.a.x?a.x:q.a.x) &amp;&amp;
		(b.y&lt;q.b.y?b.y:q.b.y)&gt;=(a.y&gt;q.a.y?a.y:q.a.y) &amp;&amp;
		(b.z&lt;q.b.z?b.z:q.b.z)&gt;=(a.z&gt;q.a.z?a.z:q.a.z);
	}
	void expand( float n ){
		a.x-=n;a.y-=n;a.z-=n;b.x+=n;b.y+=n;b.z+=n;
	}
	float width()const{
		return b.x-a.x;
	}
	float height()const{
		return b.y-a.y;
	}
	float depth()const{
		return b.z-a.z;
	}
	bool contains( const Vector &amp;q ){
		return q.x&gt;=a.x &amp;&amp; q.x&lt;=b.x &amp;&amp; q.y&gt;=a.y &amp;&amp; q.y&lt;=b.y &amp;&amp; q.z&gt;=a.z &amp;&amp; q.z&lt;=b.z;
	}
};

class Transform{
	static Transform tmps[64];
	static Transform &amp;alloc_tmp(){ static int tmp=0;return tmps[tmp++&amp;63]; }
public:
	Matrix m;
	Vector v;

	Transform(){
	}
	Transform( const Matrix &amp;m ):m(m){
	}
	Transform( const Vector &amp;v ):v(v){
	}
	Transform( const Matrix &amp;m,const Vector &amp;v ):m(m),v(v){
	}
	Transform &amp;operator-()const{
		Transform &amp;t=alloc_tmp();
		t.m=-m;t.v=t.m*-v;
		return t;
	}
	Transform &amp;operator~()const{
		Transform &amp;t=alloc_tmp();
		t.m=~m;t.v=t.m*-v;
		return t;
	}
	Vector operator*( const Vector &amp;q )const{
		return m*q+v;
	}
	Line operator*( const Line &amp;q )const{
		Vector t=(*this)*q.o;
		return Line( t,(*this)*(q.o+q.d)-t );
	}
	Box operator*( const Box &amp;q )const{
		Box t( (*this*q.corner(0) ) );
		for( int k=1;k&lt;8;++k ) t.update( *this*q.corner(k) );
		return t;
	}
	Transform &amp;operator*( const Transform &amp;q )const{
		Transform &amp;t=alloc_tmp();
		t.m=m*q.m;t.v=m*q.v+v;
		return t;
	}
	bool operator==( const Transform &amp;q )const{
		return m==q.m &amp;&amp; v==q.v;
	}
	bool operator!=( const Transform &amp;q )const{
		return !operator==( q );
	}
};

inline float transformRadius( float r,const Matrix &amp;t ){
	static const float sq_3=sqrtf(1.0f/3.0f);
	return (t * Vector( sq_3,sq_3,sq_3 )).length()*r;
}

inline Matrix pitchMatrix( float q ){
	return Matrix( Vector(1,0,0),Vector(0,cosf(q),sinf(q)),Vector(0,-sinf(q),cosf(q)) );
}

inline Matrix yawMatrix( float q ){
	return Matrix( Vector(cosf(q),0,sinf(q)),Vector(0,1,0),Vector(-sinf(q),0,cosf(q)) );
}

inline Matrix rollMatrix( float q ){
	return Matrix( Vector(cosf(q),sinf(q),0),Vector(-sinf(q),cosf(q),0),Vector(0,0,1) );
}

inline float matrixPitch( const Matrix &amp;m ){
	return m.k.pitch();
}

inline float matrixYaw( const Matrix &amp;m ){
	return m.k.yaw();
}

inline float matrixRoll( const Matrix &amp;m ){
	return atan2f( m.i.y,m.j.y );
}

inline Matrix scaleMatrix( float x,float y,float z ){
	return Matrix( Vector( x,0,0 ),Vector( 0,y,0 ),Vector( 0,0,z ) );
}

inline Matrix scaleMatrix( const Vector &amp;scale ){
	return Matrix( Vector( scale.x,0,0 ),Vector( 0,scale.y,0 ),Vector( 0,0,scale.z ) );
}

inline Quat pitchQuat( float p ){
	return Quat( cosf(p/-2),Vector( sinf(p/-2),0,0 ) );
}

inline Quat yawQuat( float y ){
	return Quat( cosf(y/2),Vector( 0,sinf(y/2),0 ) );
}

inline Quat rollQuat( float r ){
	return Quat( cosf(r/-2),Vector( 0,0,sinf(r/-2) ) );
}

inline Matrix rotationMatrix( float p,float y,float r ){
	return yawMatrix(y)*pitchMatrix(p)*rollMatrix(r);
}

inline Matrix rotationMatrix( const Vector &amp;rot ){
	return yawMatrix(rot.y)*pitchMatrix(rot.x)*rollMatrix(rot.z);
}

inline float quatPitch( const Quat &amp;q ){
	return q.k().pitch();
}

inline float quatYaw( const Quat &amp;q ){
	return q.k().yaw();
}

inline float quatRoll( const Quat &amp;q ){
	return matrixRoll( q );
}

inline Quat matrixQuat( const Matrix &amp;p ){
	Matrix m=p;
	m.orthogonalize();
	float t=m.i.x+m.j.y+m.k.z,w,x,y,z;
	if( t&gt;EPSILON ){
		t=sqrtf( t+1 )*2;
		x=(m.k.y-m.j.z)/t;
		y=(m.i.z-m.k.x)/t;
		z=(m.j.x-m.i.y)/t;
		w=t/4;
	}else if( m.i.x&gt;m.j.y &amp;&amp; m.i.x&gt;m.k.z ){
		t=sqrtf( m.i.x-m.j.y-m.k.z+1 )*2;
		x=t/4;
		y=(m.j.x+m.i.y)/t;
		z=(m.i.z+m.k.x)/t;
		w=(m.k.y-m.j.z)/t;
	}else if( m.j.y&gt;m.k.z ){
		t=sqrtf( m.j.y-m.k.z-m.i.x+1 )*2;
		x=(m.j.x+m.i.y)/t;
		y=t/4;
		z=(m.k.y+m.j.z)/t;
		w=(m.i.z-m.k.x)/t;
	}else{
		t=sqrtf( m.k.z-m.j.y-m.i.x+1 )*2;
		x=(m.i.z+m.k.x)/t;
		y=(m.k.y+m.j.z)/t;
		z=t/4;
		w=(m.j.x-m.i.y)/t;
	}
	return Quat( w,Vector( x,y,z ) );
}

#endif
</pre> <br><br></td></tr></table><br>
<a name="477719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tom</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you very much!<br><br>Tom<br>p.s. More more more!!! :) <br><br></td></tr></table><br>
<a name="477734"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >fredborg</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you!<br><br>PS: I agree with Toms PS :) <br><br></td></tr></table><br>
<a name="477752"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, sweet.<br><br>Does Blitz store 3x3 matrices?  I've been storing Eulers, converting to quats, transforming the necessary mat elements, and converting back to eulers.  It might be faster to store a 3x3 matrix, and use gl matrix commands instead of glRotatef().<br><br>But then, I finally got my transformations working (using Blitz3D results as a guide) so maybe I should leave it damn well alone. <br><br></td></tr></table><br>
<a name="477761"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Lucky I never tried to make my own 3D engine, (looks a bit complicated!) <br><br></td></tr></table><br>
<a name="477762"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SoggyP</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Greetings Puppies,<br><br>Nice job Mark.  I can understand the code but have no idea what it actually means :0)<br><br>Peace,<br><br>Jes <br><br></td></tr></table><br>
<a name="477806"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Blackledge</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now I remember why I'm quite happy to pay Mark Sibly whatever he charges, and just walk away with the result!<br>Cheers, Mark. <br><br></td></tr></table><br>
<a name="477882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Picklesworth</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Mark<br>I'm always very impressed by code that I can not understand :D <br><br></td></tr></table><br>
<a name="477927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >wizzlefish</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Me too! :P <br><br></td></tr></table><br>
<a name="477959"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> It would be VERY useful if someone converted this to Blitz, for all the people doing OpenGL stuff. <br><br></td></tr></table><br>
<a name="477980"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WolRon</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm kind of confused.  I thought header files weren't really intended to contain the implementation (except for Inlines), but it appears that that's how Mark uses them. <br><br></td></tr></table><br>
<a name="478017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Braincell</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome! Its a great beginning Mark, hopefully throughout the years you'll keep 'em coming. Nice to see the true faces of all those commands we use. Not trivial stuff. <br><br></td></tr></table><br>
<a name="478203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RiverRatt</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> What is and ESPILON? <br><br></td></tr></table><br>
<a name="478215"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DJWoodgate</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is the fifth letter of the Greek alphabet.  Apparently first used by the Hungarian mathmetician Paul Erdos to denote a very small or insignificant quantity.<br><br>In this case it is a very small value, that is still representable using the floating point numbering system.  It is used to determine if two numbers are approximately equal, because floating point numbers usually accumulate small rounding errors which make exact comparisons unlikely to suceeed.  So here Epsilon is just about significant, and anything less than Epsilon is deemed to be insignificant<br><br>I guess all these Greek letters get used in maths because the Greeks were apparently rather good at it.  So I am pretty sure I have no Greek ancestors.  In any event If that is the only question you have about the above then you are a lot Greeker than me. <br><br></td></tr></table><br>
<a name="478228"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WolRon</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did he say Greeker or geekier? :) <br><br></td></tr></table><br>
<a name="478262"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tom</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> hehe :)<br><br>Here's me being 'geek'<br><br>&lt;Sarge&gt; scouse did you see the tutorial i sent<br>&lt;Scouse&gt; no sir<br>&lt;Sarge&gt; i will send it to you in a bit<br>&lt;Scouse&gt; wow, what kind of compression is that?<br>&lt;Scouse&gt; nerd joke, sorry :P<br><br>Tom <br><br></td></tr></table><br>
<a name="478276"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DJWoodgate</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very good.  Try this.<br><a href="http://www.cs.bris.ac.uk/Research/QuantumComputing/compression.html" target="_blank">http://www.cs.bris.ac.uk/Research/QuantumComputing/compression.html</a>  <br><br>"Although compression for sources of pure state is now quite well understood,..."<br>Not by us non Greeks it isn't. :( <br><br></td></tr></table><br>
<a name="478335"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh hell, you are a saint Mark :).   Thanks a ton! <br><br></td></tr></table><br>
<a name="478365"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >morduun</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> LMAO @ Tom XD <br><br></td></tr></table><br>
<a name="478734"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Out of curiosity, are you making this source public domain or is there a specific license you want people to adhere to? <br><br></td></tr></table><br>
<a name="478790"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't think Mark has patented basic 3D maths. <br><br></td></tr></table><br>
<a name="478905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlackD</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I don't think Mark has patented basic 3D maths.  <br></div><br>Yeah - someone else already tried that. :p <br><br></td></tr></table><br>
<a name="479044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I patented eye balls.  Pay up or I cut them out ;) <br><br></td></tr></table><br>
<a name="479046"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ShadowTurtle</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> btw, blitz3d source code...<br><br>i want a good compiler sdk for add more cool features in compiling <br><br></td></tr></table><br>
<a name="479191"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Out of curiosity, are you making this source public domain or is there a specific license you want people to adhere to? <br> <br></div><br><br>This code is completely public domain - do whatever you want with it! <br><br></td></tr></table><br>
<a name="479217"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh lord, now you've done it... Noel will surely defile it. <br><br></td></tr></table><br>
<a name="479355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ckob</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> sweet :)<br><br>now if we could get you to release the rest of the blitz3d code :P <br><br></td></tr></table><br>
<a name="479761"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> "Right now I could stand to hug you.  I won't.  But you know what I mean."<br><br>Futurama quotes are nice. <br><br></td></tr></table><br>
<a name="480611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm pleased to see the use of <br>return *this. <br><br>Nice and fast.<br><br>You 'could' save a few nano seconds by converting your math labels to #DEFINE's<br><br>eg.<br><br>const float PI=3.14159265359f;//180 degrees<br><br>#DEFINE PI=3.14159265359f;//180 degrees <br><br></td></tr></table><br>
<a name="480812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >boomboom</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> you know the old saying, take care of the nano seconds and the seconds will take care of themselves. <br><br></td></tr></table><br>
<a name="481643"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ruz</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I understood everything up until the green lettering. <br><br></td></tr></table><br>
<a name="481885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >shamanenCoder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> thx thx thx mark!!! <br><br></td></tr></table><br>
<a name="481984"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sir Gak</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> As long as we're talking about Greek letters (like EPSILON), why not replace "INFINITY" with "OMEGA", the Greek letter normally used to represent Infinity?  :) <br><br></td></tr></table><br>
<a name="483718"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sweenie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Small question.<br><br>The Transform-class has a method called QuatRoll.<br>This method calls the Matrixroll method passing a Quat as parameter, but the Matrixroll method is defined to only accept a Matrix.<br>Is this wrong or is it just me that doesn't get it? <br><br></td></tr></table><br>
<a name="483725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >flying willy</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd like to find out how to convert quat to euler using the above code. I will then impliment it in the ode wrapper. <br><br></td></tr></table><br>
<a name="483732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DJWoodgate</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Flying Willy, See the matrix class. My guess is that this is the quat to euler rotation matrix conversion. (as below - the matrix itself is defined as the three vectors, i,j,k)<br><br>Sweenie, I do not use C++ (seems I am going to have to make the effort - if only to make sense of this sort of stuff) but maybe the code is using this to implicitly cast a quat to a matrix? <br><br><pre class=code>
  	Matrix( const Quat &amp;q ){
		float xx=q.v.x*q.v.x,yy=q.v.y*q.v.y,zz=q.v.z*q.v.z;
		float xy=q.v.x*q.v.y,xz=q.v.x*q.v.z,yz=q.v.y*q.v.z;
		float wx=q.w*q.v.x,wy=q.w*q.v.y,wz=q.w*q.v.z;
		i=Vector( 1-2*(yy+zz),2*(xy-wz),2*(xz+wy) ),
		j=Vector( 2*(xy+wz),1-2*(xx+zz),2*(yz-wx) ),
		k=Vector( 2*(xz-wy),2*(yz+wx),1-2*(xx+yy) );
        }
</pre><br>There is also some stuff on the code archives dealing with quats.  Not tested though, I have never used them directly. <br><br></td></tr></table><br>
<a name="483775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sweenie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Aha, you mean that if a function "ask" for a reference to a matrix and you instead pass a quaternion as reference, the matrix constructor above will kick in and convert it for you.<br>I never knew that could be done, but then again , my C++ knowledge is pretty limited as well. <br><br></td></tr></table><br>
<a name="485354"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EddieRay</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> The above code looks like a version of the constructor for a Matrix object that initializes the i,j,k vectors of the Matrix object from the given Quat object.  I'm guessing it is just computing the rotation matrix that corresponds to the quaternion... but I don't know enough about quaternions to verify that statement... ;-)<br><br>Hope this helps... <br><br></td></tr></table><br>
<a name="487493"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jeroen</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> I really don't understand the math that's going on! <br><br></td></tr></table><br>
<a name="488182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drago</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> yeah, that is one of the advantages (or disadvantages since it makes a temp var that may not be released at all.) of C++, since what that will compile to is basically this.<br><br><pre class=code>
MatrixRoll(Matrix(q));
' which the compiler then changes to
Matrix tmp = Matrix(q);
MatrixRoll(tmp);
</pre><br><br>which is why some programmers, make sure they do the conversion themselves, since then they can keep account of ALL vars that are created. <br><br></td></tr></table><br>
<a name="492265"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SkyCube</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Guess this is nice for the real "hardcore" 3d math kind of people.  Don't get me wrong I like trigonometry (especially when using for game development), but  I don't think I would be able to program it like Mark does here.<br><br>My whole reason for using Blitz was to not have to worry about this type of thing (no offense intended). <br><br></td></tr></table><br>
<a name="492896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >my_name_is_alex_hello__</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its great that you are posting up source code from BB3D like that Mark, it would be greater if I could understand it, but thats a seperate issue... <br><br></td></tr></table><br>
<a name="493838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EddieRay</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Drago:  You said it bruthah!  I hate this aspect of C++, and this is the typical and accepted way people use the language all the time.  I steer clear of big C++ class libraries because of this sort of nonsense.  And, don't even get me started on C++ "templates" or the "let's try (and fail) to code our way around the fundamental shortcomings of C++" that is called "STL" (the Standard Templates Library).  LOL! <br><br></td></tr></table><br>
<a name="495835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >aab</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is exactly what im doing in maths right now...<br>neat! <br><br></td></tr></table><br>
<a name="535782"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >podperson</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1) Epsilon is often used in mathematics to represent an arbitrary small number. Possibly the most commonly written sentence fragment in analysis is: "For every epsilon &gt; 0, there exists delta such that..." (substitute the actual epsilon and delta characters, hastily scrawled in chalk, for additional realism).<br><br>Paul Erdos did not invent this convention (which is far older than he) but is, apparently, known for referring to children as epsilons.<br><br>2) Omega is not used to represent infinity (not that I've seen, anyway). Usually infinity is represented by:<br><br>Aleph (hebrew letter) with a numerical subscript.<br>The infinity symbol (sideways 8), although this is almost always used to represent countable infinity (Aleph 0)<br>The italic c (for continuum), representing the degree of infiniteness of the Real Numbers (which is at least Aleph 1).<br><br>3) Very elegant C++ -- I love it. <br><br></td></tr></table><br>
<a name="537201"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Damien Sturdy</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> He's a better programmer than me, thats for sure.<br><br>I got lost at<br><pre class=code>
#ifndef GEOM_H
</pre><br>:P<br><br><br>Just kidding- but i never got much farther... <br><br></td></tr></table><br>
<a name="542583"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone had any luck getting this to compile?<br><br>I tried to import it in Bmax, and got about a dozen parse errors.(MingW is set up.) <br><br></td></tr></table><br>
<a name="548869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> It compiles fine in visual studio. <br><br></td></tr></table><br>
<a name="587895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FredMe</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you to show us this part of code,<br>it shows the IDE is very good coded. <br><br></td></tr></table><br>
<a name="608744"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dark Ray</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, Thanks! <br><br></td></tr></table><br>
<a name="615639"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >poopla</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Huh, comming back and looking at this now I understand everything but the quats.<br><br>I get them a little but require more study to make any use of them :). <br><br></td></tr></table><br>
<a name="616491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >aab</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Same here: Apart from Quaternions the adventurous high school student can make sense of the code.<br>I know 'of' them though..and their use in interpolating a coordinate through a spline. The imaginery side of maths is quite something. <br><br></td></tr></table><br>
<a name="655723"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RGR</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Quaternions in most Animation Files do not need the multi line code examples you usually find (and most of them do not function anyway, endless formulas and Codelines produce wrong results - at least when I wanted to convert *.wrl or *.LiA files to B3D)<br>After some try and error tests I found this:<br>For instance to convert a Quaternion of the animation keys from a VRML-File (extension .wrl) to use it on a *.b3d file, all you need is this:<br><pre class=code>w#=w#*180/Pi
pitch#=x#*w#
yaw#=-y#*w#
roll#=z#*w#</pre><br>or <br><pre class=code>w#=w#*180/Pi
RotateEntity bone,x#*w#,-y#*w#,z#*w#</pre><br>After <b>years of research</b> I'm convinced the Quaternion thing is just a Hoax ;-)<br>. <br><br></td></tr></table><br>
<a name="739763"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sonokong</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Am I the only one who doesn't understand all the code? <br><br></td></tr></table><br>
<a name="739830"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warren</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're about 8 months too slow with that "joke". <br><br></td></tr></table><br>
<a name="743628"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sonokong</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> You would be right if it actually WAS a joke. :)<br>Although it's 8 months slow, it still is related to the other posts. <br><br></td></tr></table><br>
<a name="747647"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sonokong</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> So there! <br>pwned <br><br></td></tr></table><br>
<a name="783863"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've just spent the last few hours scouring nigh on every math site on the net, and wouldn't you know it, the equation I was after could be found here all along. That'll teach me to go looking elsewhere without checking here first. Thanks for the code. <br><br></td></tr></table><br>
<a name="818488"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >simonh</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a BMax version:<br><br><pre class=code>Const TWOPI:Float=Pi*2.0		'360 degrees
Const HALFPI:Float=Pi*.5		'90  degrees
Const QUARTERPI:Float=Pi*.25	'45  degrees
Const EPSILON:Float=.000001		'small value
Const INFINITY:Float=10000000.0	'big value

Type TVec

	Field x:Float,y:Float,z:Float

	Method Copy:TVec()
		Local q:TVec=New TVec
		q.x=x; q.y=y; q.z=z
		Return q
	End Method

	Function Create0:TVec()
		Local q:TVec=New TVec
		q.x=0.0; q.y=0.0; q.z=0.0
		Return q
	End Function
	
	Function Create:TVec(x#,y#,z#)
		Local q:TVec=New TVec
		q.x=x#; q.y=y#; q.z=z#
		Return q
	End Function
	
	Rem
	operator Float*() ' ? operator overload
		Return &amp;x;
	}
	
	operator Const Float *() ' ? operator overload
		Return &amp;x;
	}
	
	Float &amp;operator[]( Int n ) ' ? operator overload
		Return (&amp;x)[n]; 
	}
	
	Float operator[]( Int n ) ' ? operator overload
		Return (&amp;x)[n]; 
	}
	End Rem
	
	Method Negate:TVec() ' - operator overload
		Return TVec.Create( -x,-y,-z )
	End Method
	
	Method Multiply:TVec( scale:Float ) ' * operator overload
		Return TVec.Create( x*scale,y*scale,z*scale )
	End Method
	
	Method MultiplyVector:TVec( q:TVec ) ' * operator overload
		Return TVec.Create( x*q.x,y*q.y,z*q.z )
	End Method
	
	Method Divide:TVec( scale:Float ) ' / operator overload
		Return TVec.Create( x/scale,y/scale,z/scale )
	End Method
	
	Method DivideVector:TVec( q:TVec ) ' / operator overload
		Return TVec.Create( x/q.x,y/q.y,z/q.z )
	End Method
	
	Method Add:TVec( q:TVec ) ' + operator overload
		Return TVec.Create( x+q.x,y+q.y,z+q.z )
	End Method
	
	Method Subtract:TVec( q:TVec ) ' - operator overload
		Return TVec.Create( x-q.x,y-q.y,z-q.z )
	End Method
	
	Rem
	Vector &amp;operator*=( Float scale ) ' *= operator overload
		x*=scale;y*=scale;z*=scale;Return *this;
	}
	Vector &amp;operator*=( Const Vector &amp;q ) ' *= operator overload
		x*=q.x;y*=q.y;z*=q.z;Return *this;
	}
	Vector &amp;operator/=( Float scale ) ' /= operator overload
		x/=scale;y/=scale;z/=scale;Return *this;
	}
	Vector &amp;operator/=( Const Vector &amp;q ) ' /= operator overload
		x/=q.x;y/=q.y;z/=q.z;Return *this;
	}
	End Rem
	
	Method Inc( q:TVec ) ' += operator overload
		x:+q.x;y:+q.y;z:+q.z
	End Method
	
	Method Dec( q:TVec ) ' -= operator overload
		x:-q.x;y:-q.y;z:-q.z
	End Method
	
	Method LessThan:Int( q:TVec ) ' &lt; operator overload
		If( Abs(x-q.x)&gt;EPSILON )
			If x&lt;q.x Then Return True Else Return False
		EndIf
		If( Abs(y-q.y)&gt;EPSILON )
			If y&lt;q.y Then Return True Else Return False
		EndIf
		Return Abs(z-q.z)&gt;EPSILON And z&lt;q.z
	End Method
	
	Method Equals:Int( q:TVec ) ' = operator overload
		Return Abs(x-q.x)&lt;=EPSILON And Abs(y-q.y)&lt;=EPSILON And Abs(z-q.z)&lt;=EPSILON
	End Method
	
	Method Inequality:Int( q:TVec ) ' != operator overload
		Return Abs(x-q.x)&gt;EPSILON Or Abs(y-q.y)&gt;EPSILON Or Abs(z-q.z)&gt;EPSILON
	End Method
	
	Method Dot:Float( q:TVec )
		Return x*q.x+y*q.y+z*q.z
	End Method
	
	Method Cross:TVec( q:TVec )
		Return TVec.Create( y*q.z-z*q.y,z*q.x-x*q.z,x*q.y-y*q.x )
	End Method
	
	Method Length:Float()
		Return Sqr(x*x+y*y+z*z)
	End Method
	
	Method Distance:Float( q:TVec )
		Local dx:Float=x-q.x; Local dy:Float=y-q.y; Local dz:Float=z-q.z; Return Sqr(dx*dx+dy*dy+dz*dz)
	End Method
	
	Method Normalized:TVec()
		Local l:Float=Length(); Return TVec.Create( x/l,y/l,z/l )
	End Method
	
	Method Normalize()
		Local l:Float=Length(); x:/l; y:/l; z:/l
	End Method
	
	Method Yaw:Float()
		Return -ATan2( x,z )
	End Method
	
	Method Pitch:Float()
		Return -ATan2( y,Sqr( x*x+z*z ) )
	End Method
	
	Method Clear()
		x=0;y=0;z=0
	End Method
	
End Type

Type TLine

	Field o:TVec,d:TVec
	
	Function Create0:TLine()
		Local line:TLine=New Tline
		line.o=TVec.Create(0.0,0.0,0.0)
		line.d=TVec.Create(0.0,0.0,0.0)
		Return line
	End Function

	Function Create:TLine(o:TVec,d:TVec)
		Local line:TLine=New Tline
		line.o=TVec.Create(o.x,o.y,o.z)
		line.d=TVec.Create(d.x,d.y,d.z)
		Return line
	End Function
	
	Method Add:TLine( q:TVec ) ' + operator overload
		Return Create( o.Add(q),d );
	End Method
	
	Method Subtract:TLine( q:TVec ) ' - operator overload
		Return Create( o.Subtract(q),d );
	End Method
	
	Method Multiply:TVec( q:Float ) ' * operator overload
		Return o.Add(d.Multiply(q))
	End Method
	
	Method Nearest:TVec( q:TVec )
		Return o.Add( d.Multiply( ( d.Dot(q.Subtract(o)) / d.Dot(d) ) ) )
	End Method
	
End Type

Type TPlane

	Field n:TVec
	Field d:Float
	
	Method Copy:TPlane()
		Local plane:TPlane=New TPlane
		plane.n=TVec.Create(n.x,n.y,n.z)
		plane.d=d
		Return plane
	End Method

	Function Create0:TPlane()
		Local plane:TPlane=New TPlane
		plane.n=TVec.Create(0.0,0.0,0.0)
		plane.d=0.0
		Return plane
	End Function

	' normal/offset form
	Function Create:TPlane(n:TVec,d:Float)
		Local plane:TPlane=New TPlane
		plane.n=TVec.Create(n.x,n.y,n.z)
		plane.d=d
		Return plane
	End Function

	' point/normal form
	Function Create1:TPlane(p:TVec,n:TVec)
		Local plane:TPlane=New TPlane
		plane.n=TVec.Create(n.x,n.y,n.z)
		plane.d=n.Negate().Dot(p)
		Return plane
	End Function

	' create plane from tri
	Function CreateFromTri:TPlane(v0:TVec,v1:TVec,v2:TVec)
		Local plane:TPlane=New TPlane
		plane.n=(v1.Subtract(v0)).Cross(v2.Subtract(v0)).normalized()
		plane.d=plane.n.Negate().Dot(v0)
		Return plane
	End Function

	Method Negate:TPlane() ' - operator overload
		Return TPlane.Create( n.Negate(),-d )
	End Method
	
	Method t_intersect:Float( q:TLine )
		Return -Distance(q.o)/n.Dot(q.d)
	End Method
	
	Method IntersectLine:TVec( q:TLine )
		Return q.Multiply(t_intersect(q))
	End Method
	
	Method IntersectPlane:TLine( q:TPlane )
		Local lv:TVec=n.Cross( q.n ).Normalized()
		Return TLine.Create( q.IntersectLine( TLine.Create( Nearest( n.Multiply(-d) ),n.Cross(lv) ) ),lv )
	End Method
	
	Method Nearest:TVec( q:TVec )
		Return q.Subtract(n.Multiply(Distance(q)))
	End Method
	
	Method Negate2()
		n=n.Negate();d=-d
	End Method
	
	Method Distance:Float(q:TVec)
		Return n.Dot(q)+d
	End Method

End Type

Type TQuat

	Field w:Float
	Field v:TVec
	
	Function Create0:TQuat()
		Local q:TQuat=New TQuat
		q.w=1.0
		Return q
	End Function
	
	Function Create:TQuat( w:Float,v:TVec )
		Local q:TQuat=New TQuat
		q.w=1.0
		q.v.x=v.x
		q.v.y=v.y
		q.v.z=v.z
		Return q
	End Function
	
	Method Negate:TQuat() ' - operator overload
		Return TQuat.Create( w,v.Negate() )
	End Method
	
	Method Add:TQuat( q:TQuat ) ' + operator overload
		Return TQuat.Create( w+q.w,v.Add(q.v) )
	End Method
	
	Method Subtract:TQuat( q:TQuat ) ' - operator overload
		Return TQuat.Create( w-q.w,v.Subtract(q.v) )
	End Method
	
	Method Multiply:TQuat( q:TQuat ) ' * operator overload
		Return TQuat.Create( w*q.w-v.dot(q.v),(q.v.cross(v)).Add(q.v.Multiply(w)).Add(v.Multiply(q.w)) )
	End Method
	
	Method MultiplyVector:TVec( q:TVec ) ' * operator overload
		Return ( Self.Multiply(TQuat.Create(0,q)).Multiply(Self.Negate()) ).v
	End Method
	
	Method MultiplyFloat:TQuat( q:Float ) ' * operator overload
		Return TQuat.Create( w*q,v.Multiply(q) )
	End Method
	
	Method Divide:TQuat( q:Float ) ' / operator overload
		Return TQuat.Create( w/q,v.Divide(q) )
	End Method
	
	Method Dot:Float( q:TQuat )
		Return v.x*q.v.x+v.y*q.v.y+v.z*q.v.z+w*q.w
	End Method
	
	Method Length:Float()
		Return Sqr( w*w+v.x*v.x+v.y*v.y+v.z*v.z )
	End Method
	
	Method Normalize()
		w=w/Length()
		v.x=v.x/Length()
		v.y=v.y/Length()
		v.z=v.z/Length()
	End Method
	
	Method Normalized:TQuat()
		Local q:TQuat=New TQuat
		q.w=q.w/Length()
		q.v.x=q.v.x/Length()
		q.v.y=q.v.y/Length()
		q.v.z=q.v.z/Length()
		Return q
	End Method
	
	Method SlerpTo:TQuat( q:TQuat,a:Float )
		Local t:TQuat=q
		Local d:Float=dot(q),b:Float=1-a
		If( d&lt;0 ) t.w=-t.w; t.v=t.v.Negate(); d=-d
		If( d&lt;1-EPSILON )
			Local om:Float=ACos( d )
			Local si:Float=Sin( om )
			a=Sin( a*om )/si
			b=Sin( b*om )/si
		EndIf
		Return (Self.MultiplyFloat(b)).Add(t.MultiplyFloat(a))
	End Method
	
	Method i:TVec()
		Local xz:Float=v.x*v.z,wy:Float=w*v.y
		Local xy:Float=v.x*v.y,wz:Float=w*v.z
		Local yy:Float=v.y*v.y,zz:Float=v.z*v.z
		Return TVec.Create( 1-2*(yy+zz),2*(xy-wz),2*(xz+wy) )
	End Method
	
	Method j:TVec()
		Local yz:Float=v.y*v.z,wx:Float=w*v.x
		Local xy:Float=v.x*v.y,wz:Float=w*v.z
		Local xx:Float=v.x*v.x,zz:Float=v.z*v.z
		Return TVec.Create( 2*(xy+wz),1-2*(xx+zz),2*(yz-wx) )
	End Method
	
	Method k:TVec()
		Local xz:Float=v.x*v.z,wy:Float=w*v.y
		Local yz:Float=v.y*v.z,wx:Float=w*v.x
		Local xx:Float=v.x*v.x,yy:Float=v.y*v.y
		Return TVec.Create( 2*(xz-wy),2*(yz+wx),1-2*(xx+yy) )
	End Method
	
End Type

Type TMat

	Field i:TVec,j:TVec,k:TVec
	
	Method Copy:TMat()
		Local m:TMat=New TMat	
		m.i=TVec.Create(i.x,i.y,i.z)
		m.j=TVec.Create(j.x,j.y,j.z)
		m.k=TVec.Create(k.x,k.y,k.z)
		Return m
	End Method

	Function Create0:TMat()
		Local m:TMat=New TMat
		m.i=TVec.Create(1,0,0); m.j=TVec.Create(0,1,0); m.k=TVec.Create(0,0,1)
		Return m
	End Function
	
	Function Create:TMat( i:TVec,j:TVec,k:TVec )
		Local m:TMat=New TMat
		m.i=i; m.j=j; m.k=k
		Return m
	End Function
	
	Function CreateFromQuat:TMat( q:TQuat )
		Local m:TMat=New TMat
		Local xx:Float=q.v.x*q.v.x,yy:Float=q.v.y*q.v.y,zz:Float=q.v.z*q.v.z
		Local xy:Float=q.v.x*q.v.y,xz:Float=q.v.x*q.v.z,yz:Float=q.v.y*q.v.z
		Local wx:Float=q.w*q.v.x,wy:Float=q.w*q.v.y,wz:Float=q.w*q.v.z
		m.i=TVec.Create( 1-2*(yy+zz),2*(xy-wz),2*(xz+wy) )
		m.j=TVec.Create( 2*(xy+wz),1-2*(xx+zz),2*(yz-wx) )
		m.k=TVec.Create( 2*(xz-wy),2*(yz+wx),1-2*(xx+yy) )
		Return m
	End Function
	
	Function CreateFromAngle:TMat( angle:Float,axis:TVec )
		Local m:TMat=New TMat
		Local u:TVec=axis
		Local c:Float=Cos(angle),s:Float=Sin(angle)
		Local x2:Float=axis.x*axis.x,y2:Float=axis.y*axis.y,z2:Float=axis.z*axis.z
		m.i=TVec.Create( x2+c*(1-x2),u.x*u.y*(1-c)-u.z*s,u.z*u.x*(1-c)+u.y*s )
		m.j=TVec.Create( u.x*u.y*(1-c)+u.z*s,y2+c*(1-y2),u.y*u.z*(1-c)-u.x*s )
		m.k=TVec.Create( u.z*u.x*(1-c)-u.y*s,u.y*u.z*(1-c)+u.x*s,z2+c*(1-z2) )
		Return m
	End Function
	
	Rem
	Vector &amp;operator[]( Int n ){
		Return (&amp;i)[n]; 
	}
	Const Vector &amp;operator[]( Int n )Const{
		Return (&amp;i)[n];
	}
	End Rem
	
	Method Inverse:TMat() ' ~ operator overload - inverse?
		Local m:TMat=TMat.Create0()
		m.i.x=i.x;m.i.y=j.x;m.i.z=k.x
		m.j.x=i.y;m.j.y=j.y;m.j.z=k.y
		m.k.x=i.z;m.k.y=j.z;m.k.z=k.z
		Return m
	End Method
	
	Method Determinant:Float()
		Return i.x*(j.y*k.z-j.z*k.y )-i.y*(j.x*k.z-j.z*k.x )+i.z*(j.x*k.y-j.y*k.x )
	End Method
	
	Method Negate:TMat() ' - operator overload
		Local m:TMat=TMat.Create0()
		Local t:Float=1.0/Determinant()
		m.i.x= t*(j.y*k.z-j.z*k.y);m.i.y=-t*(i.y*k.z-i.z*k.y);m.i.z= t*(i.y*j.z-i.z*j.y)
		m.j.x=-t*(j.x*k.z-j.z*k.x);m.j.y= t*(i.x*k.z-i.z*k.x);m.j.z=-t*(i.x*j.z-i.z*j.x)
		m.k.x= t*(j.x*k.y-j.y*k.x);m.k.y=-t*(i.x*k.y-i.y*k.x);m.k.z= t*(i.x*j.y-i.y*j.x)
		Return m
	End Method

	Method Cofactor:TMat()
		Local m:TMat=TMat.Create0()
		m.i.x= (j.y*k.z-j.z*k.y);m.i.y=-(j.x*k.z-j.z*k.x);m.i.z= (j.x*k.y-j.y*k.x)
		m.j.x=-(i.y*k.z-i.z*k.y);m.j.y= (i.x*k.z-i.z*k.x);m.j.z=-(i.x*k.y-i.y*k.x)
		m.k.x= (i.y*j.z-i.z*j.y);m.k.y=-(i.x*j.z-i.z*j.x);m.k.z= (i.x*j.y-i.y*j.x)
		Return m
	End Method	
	
	Method Equals:Int( q:TMat ) ' == operator overload
		Return i=q.i And j=q.j And k=q.k
	End Method
	
	Method Inequality:Int( q:TMat  ) ' != operator overload
		Return i&lt;&gt;q.i Or j&lt;&gt;q.j Or k&lt;&gt;q.k
	End Method
	
	Method MultiplyVector:TVec( q:TVec ) ' * operator overload
		Return TVec.Create( i.x*q.x+j.x*q.y+k.x*q.z,i.y*q.x+j.y*q.y+k.y*q.z,i.z*q.x+j.z*q.y+k.z*q.z )
	End Method
	
	Method Multiply:TMat( q:TMat ) ' * operator overload
		Local m:TMat=TMat.Create0()
		m.i.x=i.x*q.i.x+j.x*q.i.y+k.x*q.i.z;m.i.y=i.y*q.i.x+j.y*q.i.y+k.y*q.i.z;m.i.z=i.z*q.i.x+j.z*q.i.y+k.z*q.i.z
		m.j.x=i.x*q.j.x+j.x*q.j.y+k.x*q.j.z;m.j.y=i.y*q.j.x+j.y*q.j.y+k.y*q.j.z;m.j.z=i.z*q.j.x+j.z*q.j.y+k.z*q.j.z
		m.k.x=i.x*q.k.x+j.x*q.k.y+k.x*q.k.z;m.k.y=i.y*q.k.x+j.y*q.k.y+k.y*q.k.z;m.k.z=i.z*q.k.x+j.z*q.k.y+k.z*q.k.z
		Return m
	End Method
	
	Method Orthogonalize()
		k.Normalize()
		i=j.Cross( k ).Normalized()
		j=k.Cross( i )
	End Method
	
	Method Orthogonalized:TMat()
		Local m:TMat=TMat.Create0()
		m.Orthogonalize()
		Return m
	End Method
	
End Type

Type TBox

	Field a:TVec,b:TVec
	
	Function Create0:TBox()
		Local box:TBox=New TBox
		box.a=TVec.Create(INFINITY,INFINITY,INFINITY)
		box.b=TVec.Create(-INFINITY,-INFINITY,-INFINITY)
		Return box
	End Function
	
	Function CreateFromPoint:TBox( q:TVec )
		Local box:TBox=New TBox
		box.a=TVec.Create(q.x,q.y,q.z)
		box.b=TVec.Create(q.x,q.y,q.z)
		Return box
	End Function
	
	Function Create:TBox( a:TVec,b:TVec )
		Local box:TBox=New TBox
		box.a=TVec.Create(a.x,a.y,a.z)
		box.b=TVec.Create(b.x,b.y,b.z)
		Return box
	End Function
	
	Function CreateFromLine:TBox( l:TLine )
		Local box:TBox=New TBox
		box.a=TVec.Create(l.o.x,l.o.y,l.o.z)
		box.b=TVec.Create(l.o.x,l.o.y,l.o.z)
		box.UpdateFromVector( l.o.Add(l.d) )
		Return box
	End Function
	
	Method Clear()
		a.x=INFINITY;a.y=INFINITY;a.z=INFINITY
		b.x=-INFINITY;b.y=-INFINITY;b.z=-INFINITY
	End Method
	
	Method Empty:Int()
		Return b.x&lt;a.x Or b.y&lt;a.y Or b.z&lt;a.z
	End Method
	
	Method Centre:TVec()
		Return TVec.Create( (a.x+b.x)*.5,(a.y+b.y)*.5,(a.z+b.z)*.5 )
	End Method
	
	Method Corner:TVec( n:Int )
		Local x#=n&amp;1;If x Then x=b.x Else x=a.x
		Local y#=n&amp;2;If y Then y=b.y Else y=a.y
		Local z#=n&amp;4;If z Then z=b.z Else z=a.z
		Return TVec.Create( x,y,z )
	End Method
	
	Method UpdateFromVector( q:TVec )
		If q.x&lt;a.x Then a.x=q.x
		If q.y&lt;a.y Then a.y=q.y
		If q.z&lt;a.z Then a.z=q.z
		If q.x&gt;b.x Then b.x=q.x
		If q.y&gt;b.y Then b.y=q.y
		If q.z&gt;b.z Then b.z=q.z
	End Method
	
	Method UpdateFromBox( q:TBox )
		If q.a.x&lt;a.x Then a.x=q.a.x
		If q.a.y&lt;a.y Then a.y=q.a.y
		If q.a.z&lt;a.z Then a.z=q.a.z
		If q.b.x&gt;b.x Then b.x=q.b.x
		If q.b.y&gt;b.y Then b.y=q.b.y
		If q.b.z&gt;b.z Then b.z=q.b.z
	End Method
	
	Method Overlaps:Int( q:TBox )
		Local x#=b.x&lt;q.b.x;If x Then x=b.x Else x=q.b.x
		Local y#=b.y&lt;q.b.y;If y Then y=b.y Else y=q.b.y
		Local z#=b.z&lt;q.b.z;If z Then z=b.z Else z=q.b.z
		Return x And y And z
	End Method
	
	Method Expand( n:Float )
		a.x:-n;a.y:-n;a.z:-n;b.x:+n;b.y:+n;b.z:+n
	End Method
	
	Method Width:Int()
		Return b.x-a.x
	End Method
	
	Method Height:Int()
		Return b.y-a.y
	End Method
	
	Method Depth:Int()
		Return b.z-a.z
	End Method
	
	Method Contains:Int( q:TVec )
		Return q.x&gt;=a.x And q.x&lt;=b.x And q.y&gt;=a.y And q.y&lt;=b.y And q.z&gt;=a.z And q.z&lt;=b.z
	End Method
	
End Type

Type TTransform

	Field m:TMat
	Field v:TVec

	Function Create0:TTransform()
		Local tform:TTransform=New TTransform
		tform.m:TMat=TMat.Create0()
		tform.v:TVec=TVec.Create0()
		Return tform
	End Function

	Function CreateFromMatrix:TTransform(m:TMat)
		Local tform:TTransform=New TTransform
		tform.m=m.Copy()
		Return tform
	End Function
	
	Function CreateFromVector:TTransform(v:TVec)
		Local tform:TTransform=New TTransform
		tform.v=TVec.Create(v.x,v.y,v.z)
		Return tform
	End Function
	
	Function Create:TTransform(m:TMat,v:TVec)
		Local tform:TTransform=New TTransform
		tform.m=m.Copy()
		tform.v=TVec.Create(v.x,v.y,v.z)
		Return tform
	End Function
	
	Method Negate:TTransform() ' - operator overload
		Local t:TTransform=New TTransform
		t.m=m.Negate();t.v=t.m.MultiplyVector(v.Negate())
		Return t
	End Method
	
	Method Inverse:TTransform() ' ~ operator overload
		Local t:TTransform=New TTransform
		t.m=m.Inverse();t.v=t.m.MultiplyVector(v.Negate())
		Return t
	End Method
	
	Method MultiplyVector:TVec( q:TVec ) ' * operator overload
		Return m.MultiplyVector(q).Add(v)
	End Method
	
	Method MultiplyLine:TLine( q:TLine ) ' * operator overload
		Local t:TVec=Self.MultiplyVector(q.o)
		Return TLine.Create( t,Self.MultiplyVector(q.o.Add(q.d)).Subtract(t) )
	End Method
	
	Method MultiplyBox:TBox( q:TBox ) ' * operator overload
		Local t:TBox=TBox.CreateFromPoint(Self.MultiplyVector(q.corner(0)))
		For Local k:Int=1 To 8
			t.UpdateFromVector( Self.MultiplyVector(q.corner(k)) )
		Next
		Return t
	End Method
	
	Method MultiplyTransform:TTransform( q:TTransform ) ' operator overload
		Local t:TTransform=New TTransform
		t.m=m.Multiply(q.m);t.v=m.MultiplyVector(q.v.Add(v))
		Return t
	End Method
	
	Method Equals:Int( q:TTransform ) ' == operator overload
		Return m.Equals(q.m) And v.Equals(q.v)
	End Method
	
	Method Inequality:Int( q:TTransform ) ' != operator overload
		Return Not Equals( q )
	End Method
	
End Type

Function TransformRadius:Float( r:Float,t:TMat )
	Local sq_3:Float=Sqr(1.0/3.0)
	Return t.MultiplyVector( TVec.Create(sq_3,sq_3,sq_3) ).length()*r
End Function

Function PitchMatrix:TMat( q:Float )
	Return TMat.Create( TVec.Create(1,0,0),TVec.Create(0,Cos(q),Sin(q)),TVec.Create(0,-Sin(q),Cos(q)) )
End Function

Function YawMatrix:TMat( q:Float )
	Return TMat.Create( TVec.Create(Cos(q),0,Sin(q)),TVec.Create(0,1,0),TVec.Create(-Sin(q),0,Cos(q)) )
End Function

Function RollMatrix:TMat( q:Float )
	Return TMat.Create( TVec.Create(Cos(q),Sin(q),0),TVec.Create(-Sin(q),Cos(q),0),TVec.Create(0,0,1) )
End Function

Function MatrixPitch:Float( m:TMat )
	Return m.k.pitch()
End Function

Function MatrixYaw:Float( m:TMat )
	Return m.k.yaw()
End Function

Function MatrixRoll:Float( m:TMat )
	Return ATan2( m.i.y,m.j.y )
End Function

Function ScaleMatrix:TMat( x:Float,y:Float,z:Float )
	Return TMat.Create( TVec.Create( x,0,0 ),TVec.Create( 0,y,0 ),TVec.Create( 0,0,z ) )
End Function

Function ScaleMatrix1:TMat( scale:TVec )
	Return TMat.Create( TVec.Create( scale.x,0,0 ),TVec.Create( 0,scale.y,0 ),TVec.Create( 0,0,scale.z ) )
End Function

Function PitchQuat:TQuat( p:Float )
	Return TQuat.Create( Cos(p/-2),TVec.Create( Sin(p/-2),0,0 ) )
End Function

Function YawQuat:TQuat( y:Float )
	Return TQuat.Create( Cos(y/2),TVec.Create( 0,Sin(y/2),0 ) )
End Function

Function RollQuat:TQuat( r:Float )
	Return TQuat.Create( Cos(r/-2),TVec.Create( 0,0,Sin(r/-2) ) )
End Function

Function RotationMatrix:TMat( p:Float,y:Float,r:Float )
	Return YawMatrix(y).Multiply(PitchMatrix(p)).Multiply(RollMatrix(r))
End Function

Function RotationMatrix1:TMat( rot:TVec )
	Return YawMatrix(rot.y).Multiply(PitchMatrix(rot.x)).Multiply(RollMatrix(rot.z))
EndFunction

Function QuatPitch:Float( q:TQuat )
	Return q.k().Pitch()
End Function

Function QuatYaw:Float( q:TQuat )
	Return q.k().Yaw()
End Function

Function QuatRoll:Float( q:TQuat )
	Return MatrixRoll( TMat.CreateFromQuat(q) )
End Function

Function MatrixQuat:TQuat( p:TMat )
	Local m:TMat m=p
	m.Orthogonalize()
	Local t:Float=m.i.x+m.j.y+m.k.z,w:Float,x:Float,y:Float,z:Float
	If( t&gt;EPSILON )
		t=Sqr( t+1 )*2
		x=(m.k.y-m.j.z)/t
		y=(m.i.z-m.k.x)/t
		z=(m.j.x-m.i.y)/t
		w=t/4
	Else If( m.i.x&gt;m.j.y And m.i.x&gt;m.k.z )
		t=Sqr( m.i.x-m.j.y-m.k.z+1 )*2
		x=t/4
		y=(m.j.x+m.i.y)/t
		z=(m.i.z+m.k.x)/t
		w=(m.k.y-m.j.z)/t
	Else If( m.j.y&gt;m.k.z )
		t=Sqr( m.j.y-m.k.z-m.i.x+1 )*2
		x=(m.j.x+m.i.y)/t
		y=t/4
		z=(m.k.y+m.j.z)/t
		w=(m.i.z-m.k.x)/t
	Else
		t=Sqr( m.k.z-m.j.y-m.i.x+1 )*2
		x=(m.i.z+m.k.x)/t
		y=(m.k.y+m.j.z)/t
		z=t/4
		w=(m.j.x-m.i.y)/t
	EndIf
	Return TQuat.Create( w,TVec.Create( x,y,z ) )
End Function</pre><br>Heavy useage of this is likely to be quite a bit slower than C++ due to the Bmax functions not being inlined and also due to the GC having to collect lots of vector objects. <br><br></td></tr></table><br>
<a name="825768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>const float EPSILON=.000001f;		//small value
const float INFINITY=10000000.0f;	//big value</pre>How come EPSILON uses 6 decimal places but INFINITY uses 8? <br><br></td></tr></table><br>
<a name="829714"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> @SimonH<br><br>in "Type TQuat"<br>You'd better store the lenght locally...<br><pre class=code>
	Method Length:Float()
		Return Sqr( w*w+v.x*v.x+v.y*v.y+v.z*v.z )
	End Method
	
	Method Normalize()
		local l_lenght:float=Lenght()
		w=w/l_lenght
		v.x=v.x/l_lenght
		v.y=v.y/l_lenght
		v.z=v.z/l_lenght
	End Method
</pre><br><br>idem for Method Normalized:TQuat()<br><br>@ Mark Sibly<br>not sure, but it seems to be the same<br>(i'm not easy with C++ programing ... so... )<br>I don't know how pointer "this" is archived, and don't know about redondant routines...<br><pre class=code>

	void normalize(){
		float l_lenght=length();
		*this=*this/l_length;
	}
	Quat normalized()const{
		float l_lenght=length();
		return *this/l_length;
	}
</pre> <br><br></td></tr></table><br>
<a name="829920"></a>

<a name="1168897"></a>

<a name="1168898"></a>

<a name="1168899"></a>

<a name="1168900"></a>

<a name="1168901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> in the quat code ( bmax version )<br><pre class=code>
	Method Normalized:TQuat()
		Local q:TQuat=New TQuat
		q.w=q.w/Length()
		q.v.x=q.v.x/Length()
		q.v.y=q.v.y/Length()
		q.v.z=q.v.z/Length()
		Return q
	End Method
</pre><br>if we operand "/lentght()" to the new quat, the result is "0" =&gt; q is a "new" quat, so (as there is no "Method New()" to set w as "1"), all its value are 0,0,0,0 , instead of copying the callback quat<br><br>you should add a New() method as the original C++ file and use the copy constructor instead of new<br><pre class=code>
	Method New()
		w=1
		v = TVec.Create(0,0,0)
	End Method
	Method Copy:TQuat()
		local q:TQuat = New TQuat
		q.w=w; q.v = v.copy()
		return q
	End Method
	Method Normalized:TQuat()
		Local q:TQuat=Copy()
		q.w=q.w/Length()
		q.v.x=q.v.x/Length()
		q.v.y=q.v.y/Length()
		q.v.z=q.v.z/Length()
		Return q
	End Method
</pre><br><br><br><br><br>[EDIT 1]<br>in Type TMat<br><pre class=code>
	Method Orthogonalized:TMat()
		Local m:TMat=TMat.Create0()
		m.Orthogonalize()
		Return m
	End Method
</pre><br><br>It does not copy the matrix, then ortogonalize... it only return a new "Identity + orthogonalized"<br><br>should be :<br><pre class=code>
	Method Orthogonalized:TMat()
		local m:TMat = Copy()
		m.Orthogonalize()
		return m
	End Method
</pre><br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1168902"></a>

<a name="1168903"></a>

<a name="1210692"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> [double post, sorry for that] <br><br></td></tr></table><br>
<a name="963690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AJ00200</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark, have you ever considered making a math website.<br>Or a gsme; Mark Math (ages 2 and up)? <br><br></td></tr></table><br>
<a name="1200257"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BLaBZ</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is there a tutorial or reference that shows how the b3d entity commands can be represented using these classes?<br><br>ie: TranslateEntity,MoveEntity,RotateEntity,TurnEntity,PositionEntity, etc?<br><br>I think I have it figured out but it'd be great if someone else could should more light on this.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="1207905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ching</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> My brain hurts. <br><br></td></tr></table><br>
<a name="1207918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> My brain hurts too. <br><br></td></tr></table><br>
<a name="1208454"></a>

<a name="1208455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SLotman</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> Something hurts here too... but much lower...<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>...my feet, what did you expect?<br><br>Seriously now, you guys resurrected a 9 years old thread?! Holy necroposting Batman!!! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
