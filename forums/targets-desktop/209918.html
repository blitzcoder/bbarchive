<!DOCTYPE html><html lang="en" ><head ><title >Tips / Tricks for silky-smooth 60fps</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Tips / Tricks for silky-smooth 60fps</h1><a href="forums.php" >Monkey Targets Forums</a>/<a href="topics.php?forum=300" >Desktop</a>/<a href="#bottom" >Tips / Tricks for silky-smooth 60fps</a><br><br>
<a name="2107236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey!<br><br>I'm starting a new project for Desktop, and while likely going to be mojo1 for compatibility purposes (probably because mojo2 won't have Spine bindings for a while), I noticed that even with small demos, I'm often getting a lot of hiccupping which is causing SwapRate 1 projects to dip below the 60fps threshold.  In previous projects, this wasn't a big deal, since I was doing puzzle games and other casual games which didn't require a "perfect" 60fps, but now it's starting to get under my skin a bit, and I'd like to know what you guys have done to get around this.<br><br>I've heard that the bmax and xna targets don't have these issues, but I'm not willing to switch to these.  I <i>am</i> however, willing to entertain switching to mojo2 + angle, if it's been shown to really provide that reliability boost I'm looking for.<br><br>I don't believe I'm smashing up the GC much, but I don't have any experience with app profiling (particularly C++), so I can't say for sure if I'm doing something that's constantly irritating GC.  But, for argument purposes, let's pretend that I'm not doing this and taking "optimize your code to use the GC less" off the table.  What other ways have you guys been able to achieve a stable 60fps in Monkey without the hiccups which seem to plague GLFW / Android projects?  Will switching to Angle as a target help?  Is trying to aim for SwapRate 1 with uncapped UpdateRate generally a bad idea?  Do other targets have these same hiccups? <br><br></td></tr></table><br>
<a name="2107243"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> It might just be the GC, because even with my own delta-timing module, it's hard to get it to stutter.<br><br>I put this together when Mojo 2 came out (Modified, so my 'deltatime' module is optional):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Public

' Preprocessor related:
#SMOOTHNESS_DEMO_DELTATIME = False ' True

' GLFW configuration:
#GLFW_WINDOW_TITLE="Smoothness Test"
#GLFW_WINDOW_WIDTH=640
#GLFW_WINDOW_HEIGHT=640

#GLFW_WINDOW_SAMPLES=0
#GLFW_WINDOW_RESIZABLE=False
#GLFW_WINDOW_DECORATED=True
#GLFW_WINDOW_FLOATING=False
#GLFW_WINDOW_FULLSCREEN=False

#GLFW_SWAP_INTERVAL=1

#MOJO_AUTO_SUSPEND_ENABLED=False
#MOJO_IMAGE_FILTERING_ENABLED=False

' Imports:
Import mojo2

#If SMOOTHNESS_DEMO_DELTATIME
	Import deltatime
#End

' Classes:
Class Application Extends App Final
	' Constant variable(s):
	' Nothing so far.
	
	' Constructor(s):
	Method OnCreate:Int()
		' Constant variable(s):
		Const Size:Float = 64.0
		
		SetUpdateRate(0)
		SetSwapInterval(1)
		
		Graphics = New Canvas()
		
		#If SMOOTHNESS_DEMO_DELTATIME
			DeltaTime = New DeltaTime(60, 0.0, 4)
		#End
		
		Shader.SetDefaultShader(Shader.FastShader())
		
		Rectangles = New List&lt;Rectangle&gt;()
		
		For Local I:= 0 Until (DeviceHeight()/Size)
			Local FI:= Float(I)
			Local P:= (FI*Size)
			
			Rectangles.AddLast(New Rectangle(P, P, Size, Size, 2.0, Rectangle.RIGHT)) ' (Min(FI+2.0, 5.0))
		Next
		
		Capped = True
		
		' Return the default response.
		Return 0
	End
	
	' Methods:
	Method OnUpdate:Int()
		#If SMOOTHNESS_DEMO_DELTATIME
			DeltaTime.Update()
		#End
		
		UpTime = Millisecs()
		
		For Local R:= Eachin Rectangles
			#If SMOOTHNESS_DEMO_DELTATIME
				R.Update(DeltaTime)
			#Else
				R.Update()
			#End
		Next
		
		If (KeyHit(KEY_SPACE)) Then
			If (Not Capped) Then
				SetSwapInterval(1)
				
				Capped = True
			Else
				SetSwapInterval(0)
				
				Capped = False
			Endif
		Endif
		
		' Return the default response.
		Return 0
	End
	
	Method OnRender:Int()
		' Local variable(s):
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		
		' Return the default response.
		Return 0
	End
	
	' Fields:
	Field Graphics:Canvas
	
	#If SMOOTHNESS_DEMO_DELTATIME
		Field DeltaTime:DeltaTime
	#End
	
	Field UpTime:Int
	
	' Collections:
	Field Rectangles:List&lt;Rectangle&gt;
	
	' Booleans / Flags:
	Field Capped:Bool
End

Class Rectangle
	' Constant variable(s):
	Const LEFT:= False
	Const RIGHT:= True
	
	' Constructor(s):
	Method New(X:Float, Y:Float, Width:Float, Height:Float, Speed:Float, Direction:Bool=RIGHT)
		Self.X = X
		Self.Y = Y
		
		Self.Width = Width
		Self.Height = Height
		
		Self.Speed = Speed
		
		Self.Direction = Direction
	End
	
	' Methods:
	#If SMOOTHNESS_DEMO_DELTATIME
		Method Update:Void(DeltaTime:DeltaTime)
			Local Delta:Float = DeltaTime.Delta
	#Else
		Method Update:Void()
			Local Delta:Float = 1.0
	#End
			If ((X+Width) &gt;= DeviceWidth()) Then
				Direction = LEFT
			Elseif (X &lt;= 0.0) Then
				Direction = RIGHT
			Endif
			
			Select Direction
				Case LEFT
					X -= (Speed * Delta)
				Case RIGHT
					X += (Speed * Delta)
			End Select
			
			Return
		End
	
	Method Render:Void(Graphics:DrawList)
		Graphics.SetColor(1.0, 1.0, 1.0)
		
		Graphics.DrawRect(X, Y, Width, Height)
		
		Return
	End
	
	' Fields:
	Field X:Float, Y:Float
	Field Width:Float, Height:Float
	
	Field Speed:Float
	
	' Booleans / Flags:
	Field Direction:Bool
End

' Functions:
Function Main:Int()
	New Application()
	
	' Return the default response.
	Return 0
End
</textarea><br><i>Tested with both the GLFW3 and GLFW+ANGLE targets.</i><br><br>It's smooth for me. The only time it isn't is when using a high frame-average with my 'deltatime' module, or when the framerate is uncapped without it (<a href="https://en.wikipedia.org/wiki/Screen_tearing" target="_blank">Tearing</a>). Press space to toggle the frame-cap. <br><br></td></tr></table><br>
<a name="2107242"></a>

<a name="2107241"></a>

<a name="2107240"></a>

<a name="2107239"></a>

<a name="2107244"></a>

<a name="2107245"></a>

<a name="2107246"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did you get a lot of hiccups for similar code on glfw3 when using mojo1?  Hmm,.... I'm getting some stuttering on this app too for some reason, I wonder if it's related to my setup<br><br>Edit 2:  I need your DeltaTime class to compile it with the delta time enabled ! <br><br></td></tr></table><br>
<a name="2107247"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just enable 'SMOOTHNESS_DEMO_DELTATIME' at the top, and you can <a href="https://github.com/Regal-Internet-Brothers/deltatime" target="_blank">grab this</a>. <br><br></td></tr></table><br>
<a name="2107292"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> In mojo1 i'm using only one global variable and that is [dt] and use that with every movement.<br>(Speed * dt.delta)<br><br>I test this code using mojo2 and the one above in this forum and both don't give me a super smooth movement.<br>There are very small stotter in the rects.<br><br>Using GLFW3, OSX, Monkey 84c, NVIDIA Quadro 2000 (must be able to show this simple thing smoothly)<br><br>@ImmutableOctet(SKNG)<br>Don't you see non stottering, and a super smooth movement (after pressing space) ?<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Public

' Preprocessor related:
#SMOOTHNESS_DEMO_DELTATIME = True ' True

' GLFW configuration:
#GLFW_WINDOW_TITLE="Smoothness Test"
#GLFW_WINDOW_WIDTH=640
#GLFW_WINDOW_HEIGHT=640

#GLFW_WINDOW_SAMPLES=0
#GLFW_WINDOW_RESIZABLE=False
#GLFW_WINDOW_DECORATED=True
#GLFW_WINDOW_FLOATING=False
#GLFW_WINDOW_FULLSCREEN=False

#GLFW_SWAP_INTERVAL=1

#MOJO_AUTO_SUSPEND_ENABLED=False
#MOJO_IMAGE_FILTERING_ENABLED=False

' Imports:
Import mojo2

Global dt:DeltaTime

Class DeltaTime	
	Field targetfps:Float = 60
	Field currentticks:Float
	Field lastticks:Float
	Field frametime:Float
	Field delta:Float
	
	Method New (fps:Float)
		targetfps = fps
		lastticks = Millisecs()
	End
	
	Method Update:Void()
		currentticks = Millisecs()
		frametime = currentticks - lastticks
		delta = frametime / (1000.0 / targetfps)
		lastticks = currentticks
	End
End

' Classes:
Class Application Extends App Final
	' Constant variable(s):
	' Nothing so far.
	
	' Constructor(s):
	Method OnCreate:Int()
		' Constant variable(s):
		Const Size:Float = 64.0
		
		SetUpdateRate(0)
		SetSwapInterval(1)
		
		Graphics = New Canvas()
		
		#If SMOOTHNESS_DEMO_DELTATIME
			dt = New DeltaTime(60)
		#End
		
		Shader.SetDefaultShader(Shader.FastShader())
		
		Rectangles = New List&lt;Rectangle&gt;()
		
		For Local I:= 0 Until (DeviceHeight()/Size)
			Local FI:= Float(I)
			Local P:= (FI*Size)
			
			Rectangles.AddLast(New Rectangle(P, P, Size, Size, 2.0, Rectangle.RIGHT)) ' (Min(FI+2.0, 5.0))
		Next
		
		Capped = True
		
		' Return the default response.
		Return 0
	End
	
	' Methods:
	Method OnUpdate:Int()
		dt.Update
		
		UpTime = Millisecs()
		
		For Local R:= Eachin Rectangles

				R.Update()

		Next
		
		If (KeyHit(KEY_SPACE)) Then
			If (Not Capped) Then
				SetSwapInterval(1)
				
				Capped = True
			Else
				SetSwapInterval(0)
				
				Capped = False
			Endif
		Endif
		
		' Return the default response.
		Return 0
	End
	
	Method OnRender:Int()
		' Local variable(s):
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		
		' Return the default response.
		Return 0
	End
	
	' Fields:
	Field Graphics:Canvas
		
	Field UpTime:Int
	
	' Collections:
	Field Rectangles:List&lt;Rectangle&gt;
	
	' Booleans / Flags:
	Field Capped:Bool
End

Class Rectangle
	' Constant variable(s):
	Const LEFT:= False
	Const RIGHT:= True
	
	' Constructor(s):
	Method New(X:Float, Y:Float, Width:Float, Height:Float, Speed:Float, Direction:Bool=RIGHT)
		Self.X = X
		Self.Y = Y
		
		Self.Width = Width
		Self.Height = Height
		
		Self.Speed = Speed
		
		Self.Direction = Direction
	End
	
	' Methods:
		Method Update:Void()

			If ((X+Width) &gt;= DeviceWidth()) Then
				Direction = LEFT
			Elseif (X &lt;= 0.0) Then
				Direction = RIGHT
			Endif
			
			Select Direction
				Case LEFT
					X -= (Speed * dt.delta)
				Case RIGHT
					X += (Speed * dt.delta)
			End Select
			
			Return
		End
	
	Method Render:Void(Graphics:DrawList)
		Graphics.SetColor(1.0, 1.0, 1.0)
		
		Graphics.DrawRect(X, Y, Width, Height)
		
		Return
	End
	
	' Fields:
	Field X:Float, Y:Float
	Field Width:Float, Height:Float
	
	Field Speed:Float
	
	' Booleans / Flags:
	Field Direction:Bool
End

' Functions:
Function Main:Int()
	New Application()
	
	' Return the default response.
	Return 0
End
</textarea><br>co<br><br><br><br>EDIT:<br>Its hard to see on a video, but you can see it maybe.<br><a href="https://youtu.be/FA-_tqHWYsU" target="_blank">https://youtu.be/FA-_tqHWYsU</a><br>(and you can see a little gab at the top, between to rects)<br><br>but again, a video is not the best way to show the problem<br><br>EDIT2:<br>OMG, I thought I did know how to handle the basic game principles.<br>Stuttinger is not done, so after searching this forum, I found this topic.<br><a href="http://www.monkey-x.com/Community/posts.php?topic=1436&amp;page=-" target="_blank">http://www.monkey-x.com/Community/posts.php?topic=1436&amp;page=-</a><br>With ends with:<br>"The bottom line is this: if you want to lock to the frame, you are best advised to perform your game update in the OnRender."<br><br><br>So I place everything inside the onRender() and what do you think...<br>Super smooth !<br><br>But now i'm wondering, what I have been learned/read to put everything in the update is wrong. Or maybe not necessary, in this case it gaves me very smooth graphics.<br><br>But how much can you put in the onRender only, without using OnUpdate() ?<br>Everything ?<br><br>This is a very interesting point for me, maybe someone can give some extra info about this topic.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Public

' Preprocessor related:
#SMOOTHNESS_DEMO_DELTATIME = True

' GLFW configuration:
#GLFW_WINDOW_TITLE="Smoothness Test"
#GLFW_WINDOW_WIDTH=640
#GLFW_WINDOW_HEIGHT=640

#GLFW_WINDOW_SAMPLES=0
#GLFW_WINDOW_RESIZABLE=False
#GLFW_WINDOW_DECORATED=True
#GLFW_WINDOW_FLOATING=False
#GLFW_WINDOW_FULLSCREEN=False

#GLFW_SWAP_INTERVAL=1

#MOJO_AUTO_SUSPEND_ENABLED=False
#MOJO_IMAGE_FILTERING_ENABLED=False

' Imports:
Import mojo2

Class DeltaTime
	' Global variable(s):
	
	' Defualts:
	Global Default_FPS:Int = 60
	Global Default_DeltaLog_Size:Int = 20
	
	Global Default_MinimumDelta:Float = 0.0 ' 0.1
	
	' Constructor(s):
	Method New(MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		Construct(MinimumDelta, DeltaLog_Size)
	End
	
	Method New(FPS:Int, MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		Construct(FPS, MinimumDelta, DeltaLog_Size)
	End
	
	Method Construct:DeltaTime(MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		' Local variable(s):
		Local FPS:= UpdateRate()
		
		If (FPS &lt;&gt; 0) Then
			Self.UseUpdateRate = True
		Endif
		
		' Call the main implementation.
		Return Construct(FPS, MinimumDelta, DeltaLog_Size)
	End
	
	Method Construct:DeltaTime(FPS:Int, MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		If (FPS = 0) Then
			FPS = Default_FPS
		Endif
		
		' Assign the ideal frame-rate to the input.
		Self.IdealFPS = FPS
		
		' Set the previous frame's time value to the current time.
		Self.TimePreviousFrame = Millisecs()
		
		' Assign the current frame's time-value to the same as the previous frame.
		Self.TimeCurrentFrame = Self.TimePreviousFrame ' Millisecs()
		
		' Set the minimum delta-value.
		Self.MinimumDelta = MinimumDelta
		
		If (Self.DeltaLog.Length &gt; 0) Then
			Self.DeltaLog = Self.DeltaLog.Resize(DeltaLog_Size)
		Else
			Self.DeltaLog = New Float[DeltaLog_Size]
		Endif
		
		' Return this object so it may be pooled.
		Return Self
	End
	
	' Destructor(s):
	
	' This is just a quick wrapper for 'Free'.
	Method Discard:DeltaTime()
		Return Free()
	End
	
	Method Free:DeltaTime()
		Reset()
		
		' Return this object so it may be pooled.
		Return Self
	End
	
	' Methods:
	Method Reset:Void(FPS:Int, CatchUp:Bool=False)
		' Set the ideal framerate.
		IdealFPS = FPS
		
		' Call the main implementation.
		Reset(CatchUp)
		
		Return
	End
	
	Method Reset:Void(CatchUp:Bool=False)
		' Set the previous frame's time value to the current time.
		If (Not CatchUp) Then
			TimePreviousFrame = Millisecs()
		Else
			TimePreviousFrame = TimeCurrentFrame
		Endif
		
		' Assign the current frame's time-value to the same as the previous frame.
		TimeCurrentFrame = Millisecs()
		
		' Set the 'delta' to 0.0.
		Delta = 0.0
		
		' Set the delta-node to zero.
		DeltaNode = 0
		
		' Reset the delta-log.
		ResetLog()
		
		Return
	End
	
	Method ResetLog:Void()
		ResetLog(DeltaLog)
		
		Return
	End
	
	Method ResetLog:Void(DeltaLog:Float[])
		' Set all of the delta-log's elements to 0.0.
		For Local Index:= 0 Until DeltaLog.Length
			DeltaLog[Index] = 0.0
		Next
		
		Return
	End
	
	Method Update:Void()
		' Check if we're supposed to be using the update-rate:
		If (UseUpdateRate) Then
			' Check if the update-rate is different from the ideal framerate.
			If (Self._IdealFPS &lt;&gt; UpdateRate()) Then ' IdealFPS
				' "Reset" using the new update-rate.
				Reset(UpdateRate(), True)
			Endif
		Endif
		
		' Capture the current time (In milliseconds):
		TimePreviousFrame = TimeCurrentFrame
		TimeCurrentFrame = Millisecs()
		
		' Update the delta-log based on the number of milliseconds since the last time we did this:
		DeltaLog[DeltaNode] = Float(TimeCurrentFrame-TimePreviousFrame) * IdealInterval
		DeltaNode = (DeltaNode+1) Mod DeltaLog.Length
		
		' Calculate the current delta:
		
		' Assign the delta to 0.0 before anything else.
		Delta = 0.0
		
		' Iterate through the delta-log, and add to the delta-value.
		For Local Index:= 0 Until DeltaLog.Length
			Delta += DeltaLog[Index]
		Next
		
		' Fix the delta value. (Calculate an average/mean)
		Delta /= DeltaLog.Length
		
		Delta = Max(Delta, MinimumDelta)
		
		' Assign the value of the inverted delta.
		InvDelta = 1.0 / Delta
		
		Return
	End
	
	' Properties:
	
	' The 'IdealFPS' property describes the ideal frame-rate/update-rate
	' that math/other using this object was built around:
	Method IdealFPS:Int() Property
		Return Self._IdealFPS
	End
	
	Method IdealFPS:Void(Input:Int) Property
		Self._IdealFPS = Input
		
		CalculateIdealInterval()
		
		Return
	End
	
	Method CalculateIdealInterval:Float()
		If (Self._IdealFPS &lt;&gt; 0) Then ' IdealFPS
			IdealInterval = 1.0/(1000.0/Float(Self._IdealFPS)) ' IdealFPS
		Else
			IdealInterval = 0.0
		Endif
		
		' Return the calculated interval.
		Return IdealInterval
	End
	
	' Fields (Public):
	
	' The ideal interval this application should run at.
	Field IdealInterval:Float
	
	' These variables are used to take snapshots of the up-time of this
	' application (In milliseconds); they are then used to calculate a "delta-value":
	Field TimePreviousFrame:Int
	Field TimeCurrentFrame:Int
	
	' This acts as a log of "frame-differentials", which are then
	' processed into the active "delta-value" of the current frame.
	Field DeltaLog:Float[]
	
	' The current "node" (Position) in the 'DeltaLog' array.
	Field DeltaNode:Int
	
	' The last delta-value calculated from the 'DeltaLog'.
	Field Delta:Float
	
	' The minimum value 'Delta' can be.
	Field MinimumDelta:Float
	
	' A cache containing the inverse form of 'Delta'.
	Field InvDelta:Float
	
	' Booleans / Flags:
	
	' This describes if the update-rate of the application should be used.
	Field UseUpdateRate:Bool
	
	' Fields (Private):
	Private
	
	' Ideal values:
	
	' This acts as the internal storage for the 'IdealFPS' property.
	Field _IdealFPS:Int
	
	Public
End


' Classes:
Class Application Extends App Final
	' Constant variable(s):
	' Nothing so far.
	
	' Constructor(s):
	Method OnCreate:Int()
		' Constant variable(s):
		Const Size:Float = 64.0
		
		SetUpdateRate(0)
		SetSwapInterval(1)
		
		Graphics = New Canvas()
		
		#If SMOOTHNESS_DEMO_DELTATIME
			DeltaTime = New DeltaTime(60, 0.0, 4)
		#End
		
		Shader.SetDefaultShader(Shader.FastShader())
		
		Rectangles = New List&lt;Rectangle&gt;()
		
		For Local I:= 0 Until (DeviceHeight()/Size)
			Local FI:= Float(I)
			Local P:= (FI*Size)
			
			Rectangles.AddLast(New Rectangle(P, P, Size, Size, 2.0, Rectangle.RIGHT)) ' (Min(FI+2.0, 5.0))
		Next
		
		Capped = True
		
		' Return the default response.
		Return 0
	End
	
	' Methods:
	Method OnUpdate:Int()
		Return 0
	End
	
	Method OnUpdate2:Int()
		#If SMOOTHNESS_DEMO_DELTATIME
			DeltaTime.Update()
		#End
		
		UpTime = Millisecs()
		
		For Local R:= Eachin Rectangles
			#If SMOOTHNESS_DEMO_DELTATIME
				R.Update(DeltaTime)
			#Else
				R.Update()
			#End
		Next

			If (Not Capped) Then
				SetSwapInterval(1)
				
				Capped = True
			Else
				SetSwapInterval(0)
				
				Capped = False
			Endif

		' Return the default response.
		Return 0
	End
	
	Method OnRender:Int()
		OnUpdate2()
		' Local variable(s):
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		
		' Return the default response.
		Return 0
	End
	
	' Fields:
	Field Graphics:Canvas
	
	#If SMOOTHNESS_DEMO_DELTATIME
		Field DeltaTime:DeltaTime
	#End
	
	Field UpTime:Int
	
	' Collections:
	Field Rectangles:List&lt;Rectangle&gt;
	
	' Booleans / Flags:
	Field Capped:Bool
End

Class Rectangle
	' Constant variable(s):
	Const LEFT:= False
	Const RIGHT:= True
	
	' Constructor(s):
	Method New(X:Float, Y:Float, Width:Float, Height:Float, Speed:Float, Direction:Bool=RIGHT)
		Self.X = X
		Self.Y = Y
		
		Self.Width = Width
		Self.Height = Height
		
		Self.Speed = Speed
		
		Self.Direction = Direction
	End
	
	' Methods:
	#If SMOOTHNESS_DEMO_DELTATIME
		Method Update:Void(DeltaTime:DeltaTime)
			Local Delta:Float = DeltaTime.Delta
	#Else
		Method Update:Void()
			Local Delta:Float = 1.0
	#End
			If ((X+Width) &gt;= DeviceWidth()) Then
				Direction = LEFT
			Elseif (X &lt;= 0.0) Then
				Direction = RIGHT
			Endif
			
			Select Direction
				Case LEFT
					X -= (Speed * Delta)
				Case RIGHT
					X += (Speed * Delta)
			End Select
			
			Return
		End
	
	Method Render:Void(Graphics:DrawList)
		Graphics.SetColor(1.0, 1.0, 1.0)
		
		Graphics.DrawRect(X, Y, Width, Height)
		
		Return
	End
	
	' Fields:
	Field X:Float, Y:Float
	Field Width:Float, Height:Float
	
	Field Speed:Float
	
	' Booleans / Flags:
	Field Direction:Bool
End

' Functions:
Function Main:Int()
	New Application()
	
	' Return the default response.
	Return 0
End
</textarea> <br><br></td></tr></table><br>
<a name="2107288"></a>

<a name="2107266"></a>

<a name="2107264"></a>

<a name="2107254"></a>

<a name="2107253"></a>

<a name="2107252"></a>

<a name="2107263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> It really depends on the setup, I guess. If I press space, I do get the stuttering, as it's tearing/inconsistent with the delta-timing. If it's just running normally, I get perfect results. I'm really not sure if Mojo 1 would be any different; I could run some tests, I guess. Either way, using a global variable makes effectively no difference.<br><br>Here's what I get with GLFW+ANGLE on Windows (Delta-timing on): <a href="https://www.youtube.com/watch?v=EwcqzBCow5E" target="_blank">https://www.youtube.com/watch?v=EwcqzBCow5E</a> <b>(Video's currently processing; not sure if 60FPS will work)</b><br><br>I get the same results with normal GLFW3, from what I can tell. As I said, it does get inconsistent with higher framerates, though. That's partially my demo's configuration, though.<br><br><i>Basic System Information:</i><br>CPU: AMD Phenom II X4 820<br><b>GPU: AMD Radeon HD 6950</b><br>OS: <i>Windows 8.1</i> (x64) <br><br></td></tr></table><br>
<a name="2107262"></a>

<a name="2107265"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ImmutableOctet(SKNG)<br>See my edit one topic above yours, its very super smooth now.<br>But gives more questions than answers haha. <br><br></td></tr></table><br>
<a name="2107267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're supposed to update everything in 'OnUpdate', but delta-timing might be interesting to try in 'OnRender'. The fact is, the operating system and driver usually dictate when 'OnRender' is called, so it can be called at any point. For this reason, updating in 'OnRender' is discouraged. <br><br></td></tr></table><br>
<a name="2107293"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm now testing several things using OnRender() OnUpdate() SetUpdateRate() DeltaTimer<br><br>I thought you did set SetUpdateRate(60), I din't know about SetUpdateRate(0) because the documentation says:<br>This is the number of times per second that the application's OnUpdate method should be called. Commonly used update rates are 15, 30 or 60 updates per second.<br><br>OnRender is also called at the same frequency if possible (after each OnUpdate), meaning SetUpdateRate effectively also sets the target frames per second.<br><br>But don't say it could be 0.<br><a href="http://www.monkey-x.com/Community/posts.php?topic=8156" target="_blank">http://www.monkey-x.com/Community/posts.php?topic=8156</a><br><br><br>Slight stutter<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SetUpdateRate(60)
Method OnUpdate:Int()	
		DeltaTime.Update()
		UpTime = Millisecs()
		
		For Local R:= Eachin Rectangles
			R.Update(DeltaTime)
		Next
			
		If (Not Capped) Then
			SetSwapInterval(1)
				
			Capped = True
		Else
			SetSwapInterval(0)
			Capped = False
		Endif
		
		Return 0
	End

	Method OnRender:Int()
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		Return 0
	End
</textarea><br><br>stuttering<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SetUpdateRate(60)
Method OnUpdate:Int()	
		Return 0
	End
		
	Method OnRender:Int()
		' -------------------------------------
		DeltaTime.Update()
		UpTime = Millisecs()
		For Local R:= Eachin Rectangles
			R.Update(DeltaTime)
		Next
		If (Not Capped) Then
			SetSwapInterval(1)
				
			Capped = True
		Else
			SetSwapInterval(0)
			Capped = False
		Endif
		' -------------------------------------
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		Return 0
	End
</textarea><br><br>super smooth<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SetUpdateRate(0)
Method OnUpdate:Int()	
		Return 0
	End
		
	Method OnRender:Int()
		' -------------------------------------
		DeltaTime.Update()
		UpTime = Millisecs()
		For Local R:= Eachin Rectangles
			R.Update(DeltaTime)
		Next
		If (Not Capped) Then
			SetSwapInterval(1)
				
			Capped = True
		Else
			SetSwapInterval(0)
			Capped = False
		Endif
		' -------------------------------------
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		Return 0
	End
</textarea><br><br>very slight stuttering<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SetUpdateRate(0)
Method OnUpdate:Int()
		UpTime = Millisecs()
		For Local R:= Eachin Rectangles
			R.Update(DeltaTime)
		Next
		If (Not Capped) Then
			SetSwapInterval(1)
				
			Capped = True
		Else
			SetSwapInterval(0)
			Capped = False
		Endif
		Return 0
	End
		
	Method OnRender:Int()
		' -------------------------------------
		DeltaTime.Update()
		' -------------------------------------
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		Return 0
	End
</textarea><br><br>Super smooth<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SetUpdateRate(0)

Method OnUpdate:Int()
		For Local R:= Eachin Rectangles
			R.Update(DeltaTime)
		Next
		If (Not Capped) Then
			SetSwapInterval(1)
				
			Capped = True
		Else
			SetSwapInterval(0)
			Capped = False
		Endif
		Return 0
	End
		
	Method OnRender:Int()
		' -------------------------------------
		DeltaTime.Update()
		UpTime = Millisecs()
		' -------------------------------------
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		Return 0
	End
</textarea><br><br>So put the delta inside the onRender() and use SetUpdateRate(0)<br>This is the Glfw3 target and I don't know how other targets will handle this.<br><br>Final test code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Public

' GLFW configuration:
#GLFW_WINDOW_TITLE="Smoothness Test"
#GLFW_WINDOW_WIDTH=640
#GLFW_WINDOW_HEIGHT=640

#GLFW_WINDOW_SAMPLES=0
#GLFW_WINDOW_RESIZABLE=False
#GLFW_WINDOW_DECORATED=True
#GLFW_WINDOW_FLOATING=False
#GLFW_WINDOW_FULLSCREEN=False

#GLFW_SWAP_INTERVAL=1

#MOJO_AUTO_SUSPEND_ENABLED=False
#MOJO_IMAGE_FILTERING_ENABLED=False

' Imports:
Import mojo2

Class DeltaTime
	' Global variable(s):
	
	' Defualts:
	Global Default_FPS:Int = 60
	Global Default_DeltaLog_Size:Int = 20
	
	Global Default_MinimumDelta:Float = 0.0 ' 0.1
	
	' Constructor(s):
	Method New(MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		Construct(MinimumDelta, DeltaLog_Size)
	End
	
	Method New(FPS:Int, MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		Construct(FPS, MinimumDelta, DeltaLog_Size)
	End
	
	Method Construct:DeltaTime(MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		' Local variable(s):
		Local FPS:= UpdateRate()
		
		If (FPS &lt;&gt; 0) Then
			Self.UseUpdateRate = True
		Endif
		
		' Call the main implementation.
		Return Construct(FPS, MinimumDelta, DeltaLog_Size)
	End
	
	Method Construct:DeltaTime(FPS:Int, MinimumDelta:Float=Default_MinimumDelta, DeltaLog_Size:Int=Default_DeltaLog_Size)
		If (FPS = 0) Then
			FPS = Default_FPS
		Endif
		
		' Assign the ideal frame-rate to the input.
		Self.IdealFPS = FPS
		
		' Set the previous frame's time value to the current time.
		Self.TimePreviousFrame = Millisecs()
		
		' Assign the current frame's time-value to the same as the previous frame.
		Self.TimeCurrentFrame = Self.TimePreviousFrame ' Millisecs()
		
		' Set the minimum delta-value.
		Self.MinimumDelta = MinimumDelta
		
		If (Self.DeltaLog.Length &gt; 0) Then
			Self.DeltaLog = Self.DeltaLog.Resize(DeltaLog_Size)
		Else
			Self.DeltaLog = New Float[DeltaLog_Size]
		Endif
		
		' Return this object so it may be pooled.
		Return Self
	End
	
	' Destructor(s):
	
	' This is just a quick wrapper for 'Free'.
	Method Discard:DeltaTime()
		Return Free()
	End
	
	Method Free:DeltaTime()
		Reset()
		
		' Return this object so it may be pooled.
		Return Self
	End
	
	' Methods:
	Method Reset:Void(FPS:Int, CatchUp:Bool=False)
		' Set the ideal framerate.
		IdealFPS = FPS
		
		' Call the main implementation.
		Reset(CatchUp)
		
		Return
	End
	
	Method Reset:Void(CatchUp:Bool=False)
		' Set the previous frame's time value to the current time.
		If (Not CatchUp) Then
			TimePreviousFrame = Millisecs()
		Else
			TimePreviousFrame = TimeCurrentFrame
		Endif
		
		' Assign the current frame's time-value to the same as the previous frame.
		TimeCurrentFrame = Millisecs()
		
		' Set the 'delta' to 0.0.
		Delta = 0.0
		
		' Set the delta-node to zero.
		DeltaNode = 0
		
		' Reset the delta-log.
		ResetLog()
		
		Return
	End
	
	Method ResetLog:Void()
		ResetLog(DeltaLog)
		
		Return
	End
	
	Method ResetLog:Void(DeltaLog:Float[])
		' Set all of the delta-log's elements to 0.0.
		For Local Index:= 0 Until DeltaLog.Length
			DeltaLog[Index] = 0.0
		Next
		
		Return
	End
	
	Method Update:Void()
		' Check if we're supposed to be using the update-rate:
		If (UseUpdateRate) Then
			' Check if the update-rate is different from the ideal framerate.
			If (Self._IdealFPS &lt;&gt; UpdateRate()) Then ' IdealFPS
				' "Reset" using the new update-rate.
				Reset(UpdateRate(), True)
			Endif
		Endif
		
		' Capture the current time (In milliseconds):
		TimePreviousFrame = TimeCurrentFrame
		TimeCurrentFrame = Millisecs()
		
		' Update the delta-log based on the number of milliseconds since the last time we did this:
		DeltaLog[DeltaNode] = Float(TimeCurrentFrame-TimePreviousFrame) * IdealInterval
		DeltaNode = (DeltaNode+1) Mod DeltaLog.Length
		
		' Calculate the current delta:
		
		' Assign the delta to 0.0 before anything else.
		Delta = 0.0
		
		' Iterate through the delta-log, and add to the delta-value.
		For Local Index:= 0 Until DeltaLog.Length
			Delta += DeltaLog[Index]
		Next
		
		' Fix the delta value. (Calculate an average/mean)
		Delta /= DeltaLog.Length
		
		Delta = Max(Delta, MinimumDelta)
		
		' Assign the value of the inverted delta.
		InvDelta = 1.0 / Delta
		
		Return
	End
	
	' Properties:
	
	' The 'IdealFPS' property describes the ideal frame-rate/update-rate
	' that math/other using this object was built around:
	Method IdealFPS:Int() Property
		Return Self._IdealFPS
	End
	
	Method IdealFPS:Void(Input:Int) Property
		Self._IdealFPS = Input
		
		CalculateIdealInterval()
		
		Return
	End
	
	Method CalculateIdealInterval:Float()
		If (Self._IdealFPS &lt;&gt; 0) Then ' IdealFPS
			IdealInterval = 1.0/(1000.0/Float(Self._IdealFPS)) ' IdealFPS
		Else
			IdealInterval = 0.0
		Endif
		
		' Return the calculated interval.
		Return IdealInterval
	End
	
	' Fields (Public):
	
	' The ideal interval this application should run at.
	Field IdealInterval:Float
	
	' These variables are used to take snapshots of the up-time of this
	' application (In milliseconds); they are then used to calculate a "delta-value":
	Field TimePreviousFrame:Int
	Field TimeCurrentFrame:Int
	
	' This acts as a log of "frame-differentials", which are then
	' processed into the active "delta-value" of the current frame.
	Field DeltaLog:Float[]
	
	' The current "node" (Position) in the 'DeltaLog' array.
	Field DeltaNode:Int
	
	' The last delta-value calculated from the 'DeltaLog'.
	Field Delta:Float
	
	' The minimum value 'Delta' can be.
	Field MinimumDelta:Float
	
	' A cache containing the inverse form of 'Delta'.
	Field InvDelta:Float
	
	' Booleans / Flags:
	
	' This describes if the update-rate of the application should be used.
	Field UseUpdateRate:Bool
	
	' Fields (Private):
	Private
	
	' Ideal values:
	
	' This acts as the internal storage for the 'IdealFPS' property.
	Field _IdealFPS:Int
	
	Public
End


' Classes:
Class Application Extends App Final
	' Constant variable(s):
	' Nothing so far.
	
	' Constructor(s):
	Method OnCreate:Int()
		' Constant variable(s):
		Const Size:Float = 64.0
		
		SetUpdateRate(0)
		SetSwapInterval(1)
		
		Graphics = New Canvas()
		
		DeltaTime = New DeltaTime(60, 0.0, 4)
		
		Shader.SetDefaultShader(Shader.FastShader())
		
		Rectangles = New List&lt;Rectangle&gt;()
		
		For Local I:= 0 Until (DeviceHeight()/Size)
			Local FI:= Float(I)
			Local P:= (FI*Size)
			
			Rectangles.AddLast(New Rectangle(P, P, Size, Size, 2.0, Rectangle.RIGHT)) ' (Min(FI+2.0, 5.0))
		Next
		
		Capped = True
		
		' Return the default response.
		Return 0
	End
	
	' Methods:
	Method OnUpdate:Int()
		For Local R:= Eachin Rectangles
			R.Update(DeltaTime)
		Next
		If (Not Capped) Then
			SetSwapInterval(1)
				
			Capped = True
		Else
			SetSwapInterval(0)
			Capped = False
		Endif
		Return 0
	End
		
	Method OnRender:Int()
		' -------------------------------------
		DeltaTime.Update()
		UpTime = Millisecs()
		' -------------------------------------
		Local ColorTime:= (UpTime / 10)
		
		Graphics.Clear(Sin(ColorTime), 0.25, Cos(ColorTime))
		
		For Local R:= Eachin Rectangles
			R.Render(Graphics)
		Next
		
		Graphics.Flush()
		Return 0
	End
	
	' Fields:
	Field Graphics:Canvas
	
	Field DeltaTime:DeltaTime
	
	Field UpTime:Int
	
	' Collections:
	Field Rectangles:List&lt;Rectangle&gt;
	
	' Booleans / Flags:
	Field Capped:Bool
End

Class Rectangle
	' Constant variable(s):
	Const LEFT:= False
	Const RIGHT:= True
	
	' Constructor(s):
	Method New(X:Float, Y:Float, Width:Float, Height:Float, Speed:Float, Direction:Bool=RIGHT)
		Self.X = X
		Self.Y = Y
		
		Self.Width = Width
		Self.Height = Height
		
		Self.Speed = Speed
		
		Self.Direction = Direction
	End
	
	' Methods:
		Method Update:Void(DeltaTime:DeltaTime)
			Local Delta:Float = DeltaTime.Delta

			If ((X+Width) &gt;= DeviceWidth()) Then
				Direction = LEFT
			Elseif (X &lt;= 0.0) Then
				Direction = RIGHT
			Endif
			
			Select Direction
				Case LEFT
					X -= (Speed * Delta)
				Case RIGHT
					X += (Speed * Delta)
			End Select
			
			Return
		End
	
	Method Render:Void(Graphics:DrawList)
		Graphics.SetColor(1.0, 1.0, 1.0)
		
		Graphics.DrawRect(X, Y, Width, Height)
		
		Return
	End
	
	' Fields:
	Field X:Float, Y:Float
	Field Width:Float, Height:Float
	
	Field Speed:Float
	
	' Booleans / Flags:
	Field Direction:Bool
End

' Functions:
Function Main:Int()
	New Application()
	
	' Return the default response.
	Return 0
End
</textarea> <br><br></td></tr></table><br>
<a name="2107271"></a>

<a name="2107286"></a>

<a name="2107287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ImmutableOctet(SKNG):  thanks a bunch.  I'm starting to believe that Firefox and Jungle maxing out my primary CPU core is the reason for the large amount of hiccups I'm seeing in my monkey builds; as everything seems to run smooth until loading up all of my "usual applications"  (I haven't thoroughly tested to see if the problem persists, but I just wanted to point out that there doesn't seem to be any problem with the code you posted.)  I feel like there might be some "fragility" either in my system or in the way Monkey games work, or possibly how we expect them to work given the usual coding patterns, but I'm still unsure as to which of these it is (although I believe my system's the most significant factor here, despite it being new).<br><br>CPU:  Core i3-4360  <br>GPU:  NVidia GTX 750<br>OS:  Windows 8.1 u1  (x64)<br><br><br>@GC-Martijn:   Please consider using [codebox]  instead of [code] for posting long blocks of code;  it takes up far less space and makes it easier to skim a thread -- I'd love to dig into your post but I find myself being distracted by the very large code blocks... <br><br></td></tr></table><br>
<a name="2107294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GC-Martijn</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> updated the topics. <br>the last code gives me at the moment the best results. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
