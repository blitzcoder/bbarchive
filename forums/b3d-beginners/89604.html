<!DOCTYPE html><html lang="en" ><head ><title >Easier GUI Mouseclick/icon checks</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Easier GUI Mouseclick/icon checks</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Easier GUI Mouseclick/icon checks</a><br><br>
<a name="1017848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just posting here to hear everyone's thoughts/suggestions...<br><br>One part of coding games or anything with a language such as B3D (which lacks any native GUI capability, save for mouseX, MouseY and the various GetKey/GetMouse functions,) is that I hate.. actually detest, having to code in a GUI. Having to either create some kinda data structure to handle menus, or record/pre-define the positions/functions of various icons etc.<br><br> had a sudden thought whilst being otherwise occupied (where all the best ideas come!) that maybe a kinda hifdden interfface could be used, and this hidden interface is what the mouse clicks are checked on.<br><br>How it may work, is that the hidden interface is a blank full-screen image or sprite etc, with different coloured shapes (presumably rectangles, though anything works!) arranged at the icon positions and scaled to size if necessary.<br><br>Instead of checking the MosueX and MouseY between various coordinates and seeing if the coords are within the bioundaries for whichever icon, simply a (hopefully faster????) check is made on the proportional X/Y of the image, and the RGB (or aRGB) value returned with something like ReadPixelFast from the HIDDEN interface buffer.<br><br>This way, it can be ascertained what icon is clicked by testing for, say, $FF00FF (magenta?) then  icon #1 is clicked, but if $000000 is returned, (black?) then no icon is clicked, and so no result.<br><br>This may take a little organisation in setting up, but I'm certain it would be easier than checking through atual icon X,Y and width heights to find what's been clicked on.<br>In theory, I''m thinking it would be faster too... ?<br><br>Is this a possibility, has anyone tried something like this before? Or.. am I completely insane since there's a MUCH simpler way of doing it all that I'm too dumb to notice ;)<br><br>NOTE: External progs, such as DevilsGUI system, or say, windows API calls etc. are beyond the sscope of this, since Im, more concerned about really customised UI systems. <br><br></td></tr></table><br>
<a name="1017865"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I created a very simple 3D GUI for use with my Arkanoid level editor.<br>It only has buttons and some simply requesters (Yes/No and a color picker), but I got it working like I wanted too.<br><br>It uses pickable quads for the buttons.<br><br>For the requesters, I just created a quad to which a texture is applied.<br>To simulate the buttons, I created invisible (but pickable) quads in front of the requester-quad.<br>By checking which triangle was clicked, I could see if the user clicked the "Yes" or "No" button on the requester.<br><br>You could check it out here:<br><a href="http://users.telenet.be/vge/Arkanoid3D/Arkanoid3D.zip" target="_blank">http://users.telenet.be/vge/Arkanoid3D/Arkanoid3D.zip</a><br><br>The full source-code of the editor and the game are included, as is the source-code of the 3D-GUI.<br><br>But: I don't know how to make it pixel-perfect, so using it could result in slightly blurry buttons. <br><br></td></tr></table><br>
<a name="1017866"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice.. I think I actually gave that game a try some time ago. I was a big fan of the original, so it was good to see :D<br><br>But yeah, 3D UI is made a bit easier with CameraPicks and linePicks etc., and a more simple interfacte with just a couple of buttons is probably better coded specifically for those buttons. I was really considering smmething along the lines of having a larger number of possible icons to click, and where the same icons may appear on different 'menu screens'.<br><br>---<br><br>incidentally, for pixel-perfectness, you just need to make the pick radii smaller and the quad textures to have flag 8 (mipmapped) disabled. Thwere's something about pixel-perfect sprites in the code-arcs, dunno, that might apply to the quads too ? <br><br></td></tr></table><br>
<a name="1017873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> What I meann with "not pixel-perfect" is the fact that the buttons aren't the exact size on the screen when they are rendered.<br><br>The button's image can be 256x32 pixels, but when rendered, the quad could cover a size of 300x38 pixels on the screen when the button is rendered.<br><br>So I would need to find the exact distance to the camera (and the exact size of the button quad) to get the rendered-size equal to the image-size.<br><br>I didn't bother with that, as it was only a simply editor.<br><br>That also explains why the text on the buttons could be blurry, as 1 pixel of a character (on the image/texture) could cover 1.15 pixels or so onscreen when the quad is rendered with that text on it.<br><br>I don't know if this makes any sense. <br><br></td></tr></table><br>
<a name="1017874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bugger picks :) What to do, is align the 3d GUI elements so your 3d elements dimensions, match exactly the 2d pixels on the screen. Then all you do, is to rectsoverlap checks. Obviously, what you do is create every 3d GUI element on the one surface, and initially do a camerapick, to see if the GUI is checked.<br><br>For elements that need to be hidden, simply move there vertices off screen, as making them invisible via vertexalpha will still cause them to be picked. <br><br></td></tr></table><br>
<a name="1017876"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Seems that the 3D route is much preferred over old 2#D stuff anyway then :) <br><br></td></tr></table><br>
<a name="1017880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I still use 2d for my own editors, as i can't be assed setting up 3d :) <br><br></td></tr></table><br>
<a name="1017881"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> So would my suggestion be of use? <br><br></td></tr></table><br>
<a name="1017890"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> It sounds to me like it has potential. I was going to redesign my GUI anyway... will try this out and see if it's faster.<br><br>One enhancement to your original suggestion though (assuming I've understood correctly) - rather than assigning arbitrary colours to buttons like $FF00FF, just make each colour that gadget's index in your GUI's "all-gadgets" bank or array (or its Handle() ). That way no ifs or loops are required: as long as the colour isn't your "null" colour (say $FFFFFF), just access the bank or array index with the value returned by ReadPixelFast.<br><br>Hmmm... on the other hand, would it still be faster taking into account the time taken to render the interface buffer? If each gadget had a second quad, with the vertices already set to the index colour, it might do away with the need for a loop there...<br><br>Certainly worth a test, simply by virtue of being different and therefore more fun. <br><br></td></tr></table><br>
<a name="1017896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Surely the ultimate speed comes from just doing rectoverlaps? <br><br></td></tr></table><br>
<a name="1017901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> That'd be fastest for checking whether the mouse is over one specific gadget, but you still need to iterate through a list of gadgets to check whether they overlap the mouse. I'm sure it could be optimised, but the main difference is that there is no loop at all in Malice's method; you go straight from the test to the gadget (or to no gadget). O(1) vs. O(n) (I think).<br><br>Of course, that advantage is irrelevant if you're also doing something else that loops through all the gadgets anyway.<br><br>Also, as a bonus, you don't need to test which gadget is on top if more than one overlap the cursor, because the magic of rendering handles that. Not that I think this is a significant difference. And if you were really clever, you could take advantage of masked textures to allow gadgets to be any shape you want!<br><br>I don't think you'd see a significant speed improvement in either case (both are probably pretty fast ways of doing it unless you have ten bajillion gadgets slowing down your system) but personally I'm drawn to the simplicity of the idea. <br><br></td></tr></table><br>
<a name="1017983"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree, the speed difference would be minimal, and checking handles with RectOverlap would be potentially more reliable.<br><br>RectOverlaps though, still require so many variables, such as the size and position of the icons and possibly a mouse cursor image.<br>With the 'colour method', there's only the actual mouse pointer location and the pixel from an image buffer. Though again, this is a very minimal gain in memory, and perhaps lost out since using the image buffer itself.<br><br>The mention of other shapes I think is most relevant, although presumably most 'button' type objects would be rectangular or perhaps with slightly rounded edges, but circular buttons or trangular arrows for some circumstances may be nice. <br>I wonder if from a user point of view, though, if the pixel-perfectness is potentially a disadvantage, as soemtimes it may be beneficial to have a rectangular bounding box rather than require clicking so precisely.<br><br>The simplicity was what really gave me the serious thought about the idea, and why I posted in the first place. I am sure there are at least some circumstanes where such an implementation may be required.<br><br>The iteration of checking would never need to be specific to handles, only to colours. Whether this makes a difference or not is really due to how it's implemented I imagine, some relevance may need to be given to the colours according to the 'menu screen' in which they appear, but this is little different from handles.<br><br>Yasha, it seems you've gone a little more in depth than me, of course, the original premise posted may well do with some optimisation, and things like the use of banks is interesting, something I'd not gotten as far as thinking.<br><br>I'm working on something myself, more of a tech - demo test, really and I'd be interested in your results too.<br>If there's any serious benefits or disadvantages they may well come to light through actual 'practical' use of the idea, rather than just theorising the possibilities :) <br><br></td></tr></table><br>
<a name="1017990"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay... some further thoughts...<br><br>Since the ARGB value returned from ReadPixel is a somewhat arbitrary, bbut remains a uniquely identifiable value, which is not as random as say, an image handle (numerical value) then there's certainly some opportunities there.<br><br>If the actual value returned is somehow linked to the functionality of the gadget (one would need to be pretty specific about the colours they used in the hidden UI image buffer) but the theory goes..<br>Bitwise operations on a return value could be a real advantage. Even so much as potentially CHANGING the colours within the image, this change could be simple, such as changing the RED component from 0 to 255 etc. reflecting a toggle, or maybe the blue component might be a scale of values. Whilst only the GREEN component is required for identifying the specific gadget.<br>This would limit a total number of gadgets to 255 but that ought to be plenty.<br><br>A direct array or such of the gadget colours (or just green component) can be predefined, which should be a little easier and quicker than checking individual handles, since again, we can deal with bitwise operation on a single byte. This ought to be faster... <br><br></td></tr></table><br>
<a name="1017997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, i understand what your up to now :) Very interesting idea! <br><br></td></tr></table><br>
<a name="1017999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah I thought you seemed a little dismissive at first, Ross... Wondered if you did see what I was getting at.<br>Who knows, it may turn out to be a complete waste of time and way too much ework for no real benefit, but it's certainly intriguing to find out :)<br><br>All in all, I wonder why B3D ever incorporated the gadget UI stuff that I hear BlitzPlus has? <br><br></td></tr></table><br>
<a name="1018022"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> How are you handling gadgets that are hidden? <br><br></td></tr></table><br>
<a name="1018024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Alpha (vertex alpha) would work; just set it to zero and the gadget doesn't get rendered to the "interface buffer", so it can't be picked up by the mouse.<br><br>Or in a pure-2D system... simply don't draw it. <br><br></td></tr></table><br>
<a name="1018025"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm sure alphaed vertices still get picked by a camerapick. <br><br></td></tr></table><br>
<a name="1018031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think we're describing different things. Here's what I have in mind (which upon closer inspection, I don't think is actually what Malice was suggesting... sorry):<br><br><br>1) Get hold of a pixel-perfect quad system. Not too hard to design a simple one, or just rip the core out of <a href="/posts.php?topic=78304" target="_blank">Draw3D</a> or SpriteCandy or whatever your preferred drawing system is.<br><br>2) The way these normally work is with the drawing surface (or surfaces, as a surface can't have multiple textures side-by-side, so you need one for each image, but this is a detail - you can fit the main GUI into one surface) as a child of the camera. Now create a second camera/surface arrangement to act as the "interface buffer". (Quad systems should be fullbright anyway, but it's essential for this to work, so make sure it's fullbright.)<br><br>3) Set the interface camera's ClsColor to $FFFFFF. Apply a new, masked (<b>not</b> alpha) copy of the GUI texture to the interface surface, and go over it replacing all the non-masked areas with completely white pixels.<br><br>4) Each time you add a gadget to the main system, add a copy of it within the interface setup. VertexColor those vertices with the index number of that gadget in whatever list you're using (i.e. gadget 0 is coloured 0,0,0; gadget 1 is coloured 0,0,1; gadget 256 is coloured 0,1,0 etc.).<br><br>5) Every time you need to update the GUI, make sure the interface system is also updated with each gadget's new vertex positions. If the gadget is hidden or otherwise disabled, also set its alpha to 0. Don't change its colour.<br><br>6) Every time you need to get input from the GUI, render the interface scene without the rest of the world, and store it somehow. Then ReadPixelFast at the mouse coordinates; if the pixel is less than $FFFFFF (disregarding alpha), clickedGadget.TGadget = GlobalGadgetList(pixel)... or Object.TGadget(pixel)... or Object.TGadget(PeekInt(GadgetBank, pixel)). Whichever.<br><br><br>That's what I immediately thought of when reading Malice's idea. No idea how close it is to the mark. Although it might not be the fastest way around the problem, it's so simple and straightforward (things like window ordering or disabling gadgets pretty much take care of themselves) that it would be a good foundation for a general-purpose system. I think I will be giving it a try. <br><br></td></tr></table><br>
<a name="1018040"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> It seems we do have our wires crossed.<br>My idea was purely 2D, I didn't want to address 3D stuff at all.<br><br>The importance of my idea was the ability to identify the location of the mouse cursor by a particular colour, which not only mayy represent a specific 'gadget', but things like the 'state' and 'value' of the gadget could also be known, without having to iterate through all the gadgets individually.<br><br>What it seems Yasha's doing, is taking the idea of the (never rendered - only the buffer is checked) 'overlay', and applying that to a 3D window, so I suppose ultimately the effect could be the same, so I'm still interested :) it would certainly improve accuracy of mouseclicks, since these would be registered against 2D coords rather than interacting with the 3D world. <br><br></td></tr></table><br>
<a name="1018058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>The importance of my idea was the ability to identify the location of the mouse cursor by a particular colour, which not only mayy represent a specific 'gadget', but things like the 'state' and 'value' of the gadget could also be known, without having to iterate through all the gadgets individually.<br> <br></div><br><br>I briefly skimmed the suggestion so forgive me if I've missed something. <br><br>While this color based gadget type may sound clever in theory I don't think it is very practical and there is little scope for expansion of properties.  For example, how would you handle properties such as visibile / active, scale etc...  I think it would be very messy to code and you should just stick to tried and tested methods.<br><br>Checking through 100's of gadgets to see if the mouse has overlapped is trivial in terms of speed with rects overlap.  It's unlikely that you would have a menu that cluttered in the first place.  I think you are trying to optimise when it isn't really necessary. <br><br></td></tr></table><br>
<a name="1018079"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> While this color based gadget type may sound clever in theory I don't think it is very practical and there is little scope for expansion of properties. For example, how would you handle properties such as visibile / active, scale etc... I think it would be very messy to code and you should just stick to tried and tested methods.<br><br>Checking through 100's of gadgets to see if the mouse has overlapped is trivial in terms of speed with rects overlap. It's unlikely that you would have a menu that cluttered in the first place. I think you are trying to optimise when it isn't really necessary. <br> <br></div><br><br>First, please dont confuse the original ieda with something that would mimic the functionality of something like Visual Basic gadgets. I never actually brought 'gadgets' into the discussion, nor 3D, nor overlapping gadgets. Not that I object to any of the discussion on those.<br><br>What I was really aiming for with the initial thought, was a simpler front-end for a typical game, or perhaps tthe  panel of control 'icons' during gameplay. Some form of menu system with buttons, maybe sliders and checkboxes at the most, but nothing too complex.<br><br>Consider the concept for this icon-driven menu system or UI or whatever you want to call it, in 2D (though it would work equally well for 3D)<br><br>The code for doing such, to me, is  a pain, even with a pretty neat Type based system, mainly, having to identify about 6 pieces of information for every possible icon.<br><br>i.e. <br>IF MOUSE BUTTON CLICKED<br>X of topleft<br>Y of topleft<br>Width<br>Height<br>MouseX<br>MouseY<br><br>Admittedly, simplified by some careful arrangement / scaling and relationship of the positions of the icons etc. bt still so many pieces of information may be needed to chweck through just to identify if a particular icon was clicked on. Even then, the return value (traditiohally) will only tell you something like:<br>A Type instance or handle relating to that icon<br><br>What's then required is iteration through types, or some other method to identify the funcitonality related to that particular icon.<br><br>However, with the 'colour-idea' (I should probably think up some kinda name for it), only 2 pieces of information are needed.<br>MouseX<br>MouseY<br><br>The return value can then identify a more specific 'description' of the icon and its functionality, including perhaps, its current state and maybe even values stored.<br>The opportunities to work wioth the bit values of the result are also much more accessible, than, say, extra fields in a Type or something.<br><br>Scaling can't be a problem, since in creating the 'vissible UI' then the hidden colour buffer is going to be drawn up from that. That should never be an issue.<br><br>As for hundreds of gadgets etc. and overlapping, I do not see any reason why a UI would be made with overlapping objects. There will always be something that is considered "At the front" and it is this that would be used to determine the colour on the hidden buffer.<br><br>It may sound messy at first, but once you can envisage the actual simplicity of  literally just <br><br>ReadPixelFast(MouseX),MouseY(),HiddenImageBuffer())<br><br>giving you an exact description of the target icon that has been clicked, then I think there COULD be some potential in there that just needs to find the right slot to fill :)<br><br>this all started purely as an alternative to checking 6 pieces of information for n different 'icons' each of which would need be checked every time the mouse clicks. <br><br></td></tr></table><br>
<a name="1018181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Serpent</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like your idea Malice.  In my severely limited experience coding in Blitz I've had troubled times writing GUIs with only a few buttons.  I've used a MouseInRect function approach, but your's is a lot neater - in fact, you'd just need a select case structure for the ReadPixelFast call and you can find the button without going through a list - great idea. <br><br></td></tr></table><br>
<a name="1018192"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> A very simplified examle:<br><br><pre class=code>
; Disable buttons by removing the button reference bit valuefrom this.
Global ENABLED_BUTTON_BITS=255

While (Not (KeyDown(1)))
Draw VisibleUIImage,0,0

If MouseHit(1)
 Local MX=MouseX(),MY=MouseY()
 Flushmouse
 Local Button=GetButtonPress(MX,MY)
 DoButtonFunction(Button)
End if
Flip
Wend

Function GetButtonPress(X,Y)
 LockBuffer(ImageBuffer(InvisibleUIImage))
 Local ColourValue=ReadPixelFast(X,Y,ImageBuffer(InvisibleUIImage))
 UnlockBuffer (ImageBuffer(InvisibleUIImage))
 ;We can see if the button is enabled or disabled directly:
 If ((ENABLED_BUTTON_BITS And ((ColourValue And 255) Shr 8))=((ColourValue And 255) Shr 8) ) Then Return ((ColourValue And 255) Shr 8))
; Else, return 0 for no button clicked...
Return False
End Function

</pre><br><br>So, there's no rectoverlap, no list iteration and no need to know any more than the mouse location and a single return value identifieds the specific button by reference, not needing to be obtained from  a handle or type object, and even ensures that a 'disabled' button has no effect. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
