<!DOCTYPE html><html lang="en" ><head ><title >Linked Lists using Custom Types</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Linked Lists using Custom Types</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Linked Lists using Custom Types</a><br><br>
<a name="248145"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AKJ</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is some minimalist code to create and walk linked lists.<br><br>There are 3 sections of code:<br>1  Forward linked lists<br>2  Backward linked lists<br>3  Bidirectional linked lists<br><br>Anthony Jordan<br><br><br>; ---------------------------------------------------------<br><br><br>; Forward Linked List  AKJ  30-Jul-03<br>; Create a forward-linked list of 4 items, then cycle through all the items.<br><br>Type item<br>	Field id<br>	Field nextitem.item ; This field is being recursively defined as custom type 'item'<br>End Type<br><br>; Create the list<br>address.item = Null ; Variable to point to items in the list<br>For i=1 To 4<br>	mylist.item=New item<br>	mylist\id=i<br>	If address&lt;&gt;Null Then address\nextitem=mylist ; Forward link of the previous item<br>	address = mylist ; Address of the current item<br>Next ; i<br>; Fill in the forward link of the last item<br>address\nextitem=First item<br><br>; Now walk the links and display the list<br>mylist = First item  ; Arbitrary starting point<br>For i=1 To 10 ; Walk the list repeatedly<br>	Print "  "+mylist\id+"  "+Str$(mylist\nextitem)<br>	mylist = mylist\nextitem ; Use the link to go to the next item in the list<br>Next ; i<br><br>WaitKey()<br><br><br>; ---------------------------------------------------------<br><br><br>; Backward Linked List  AKJ  30-Jul-03<br>; Create a backward-linked list of 4 items, then cycle through all the items.<br><br>Type item<br>	Field id<br>	Field previtem.item ; This field is being recursively defined as custom type 'item'<br>End Type<br><br>; Create the list<br>address.item = Null ; Variable to point to items in the list<br>For i=1 To 4<br>	mylist.item=New item<br>	mylist\id=i<br>	mylist\previtem=address ; Address of the previous item<br>	address = mylist ; Address of the current item<br>Next ; i<br>; Fill in the backward link of the first item<br>mylist = First item<br>mylist\previtem=address<br><br>; Now walk the links and display the list<br>mylist = First item ; Arbitrary starting point<br>For i=1 To 10 ; Walk the list repeatedly<br>	Print "  "+mylist\id+"  "+Str$(mylist\previtem)<br>	mylist = mylist\previtem ; Use the link to go to the previous item in the list<br>Next ; i<br><br>WaitKey()<br><br><br>; ---------------------------------------------------------<br><br><br>; Bidirectional Linked List  AKJ  30-Jul-03<br>; Create a bidirectional-linked list of 4 items, then cycle through all the items.<br><br>Type item<br>	Field id<br>	Field previtem.item ; This field is being recursively defined as custom type 'item'<br>	Field nextitem.item ; Also recursively defined<br>End Type<br><br>; Create the list<br>address.item = Null ; Variable to point to items in the list<br>For i=1 To 4<br>	mylist.item=New item<br>	mylist\id=i<br>	If address&lt;&gt;Null<br>		mylist\previtem=address ; Backward link of the current item<br>		address\nextitem=mylist ; Forward link of the previous item<br>	EndIf<br>	address = mylist ; Address of the current item<br>Next ; i<br>; Fill in the backward link  of the first item<br>mylist = First item<br>mylist\previtem=address<br>; Fill in the forward link of the last item<br>address\nextitem=mylist<br><br>; Now walk the links and display the list<br>mylist = First item ; Arbitrary starting point<br>For i=1 To 10 ; Walk the forward links<br>	Print "  "+mylist\id+"  "+Str$(mylist\previtem)+"  "+Str$(mylist\nextitem)<br>	mylist = mylist\nextitem ; Use the link to go to the next item in the list<br>Next ; i<br>Print ""<br>For i=1 To 10 ; Walk the backward links<br>	Print "  "+mylist\id<br>	mylist = mylist\previtem ; Use the link to go to the previous item in the list<br>Next ; i<br><br>WaitKey() <br><br></td></tr></table><br>
<a name="248179"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >soja</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't get it.  Why implement your own linked lists for custom types when they're built-in to Blitz? <br><br></td></tr></table><br>
<a name="248236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AKJ</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> The code is intended as a skeletal structure.  You can adapt it to link items in non-standard ways.  Indeed, the given code implements circular lists which are not built-in to Blitz.<br><br>Another point is that the code shows how easy it is to determine the addresses of items in a list.  A subset of these could then be stored in a separate array (or list) to provide direct access to the start of sub-lists within the main list.<br><br>Also, the links can easily be altered at runtime, which means (for example) that the list (or any subset of it) could be sorted first by one field and then later on by a different field, simply by appropriately rewriting the contents of the link fields.  This could (for example) be a useful way of rearranging the visibility z-order of a large list of objects from various viewpoints.<br><br>My incentive for producing the code was to make it easier for me to convert some C programs in my possession to BlitzPlus.  These programs make heavy use of list-like data structures which did not map easily to Basic code.<br><br>Anthony Jordan <br><br></td></tr></table><br>
<a name="248270"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >soja</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the explanation <br><br></td></tr></table><br>
<a name="248286"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Foppy</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I use home-made linked lists like that in my tile engine to store all objects that are on the same tile on the map. As an object moves from one tile to the other, it is removed from the list of the tile it left, and added to the list of the tile it moves to.<br><br>These lists are then used in collision detection. Suppose the player is on a given tile; in order to check for collisions with enemies you now only have to check the linked lists of enemies in that tile and the adjacent tiles (assuming no object is bigger than one tile), which is much better than checking for collisions with all enemies!<br><br>These lists can also be used for more efficient z-order drawing, drawing first the top row of tiles and the objects on those tiles, then the next row etc. All in all I can really recommend this way of doing a tile engine. There's of course a little bit of extra work involved in calls to functions for handling the lists, but, with things like collision detection, or for instance AI where the enemy has to look for nearby enemies, the amount of time saved is bigger as you avoid the quadratic aspect of checking everything with everything. <br><br></td></tr></table><br>
<a name="248405"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmm, what happens if the player is between 2 - or 4, for that matter - tiles? The last time I did a tile-based game with loads of enemies, I used a 'shifted grid' method for collision detection which also means you don't have to check everything-colliding-against-everything. Worked very well. Anyways... <br><br></td></tr></table><br>
<a name="248546"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Foppy</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> The player can never be *between* two tiles (well, depending on the program of course). In my case the position of the player is the position of the upper-left corner of its image. Now, this point is always on a tile, and never inbetween two tiles; when you move from one tile, you always end up on another tile.<br><br>Of course, the image of the player can be in two tiles at the same time (or 4 tiles even) when you are moving near to the border between two tiles. But this is why for collision detection, you have to check the tile you are technically in *and* the adjacent tiles to take overlap into account (the player image could stick out onto an adjacent tile, and likewise, enemies could also be sticking out onto your tile).<br><br>I don't know how the 'shifted grid' method works. In general I would think that the trick is to somehow have a link from location (tile) to objects on that location. That way, you check for nearby locations, and through these locations you find the nearby objects. That is what I do using the linked lists. Is 'shifted grid' something similar? <br><br></td></tr></table><br>
<a name="248916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shifted grid (if I can remember :)) basically involves dividing the play area into a grid and then only checking for collisions between the objects that lie within the same grid. That is, only check for collisions against other objects that are near by - this avoids redundant checks such as checking if an object is colliding with another on the other side of the play area.<br><br>However, it's possible a collision can occur between two objects that lie on the edge of two adjacent grids so the grid has to be 'shifted' up, down, left, right and the collision tests performed again. There are other refinements that can be made to the basic algorythm but that's basically it. It's an especially effective technique when you has loads of objects in a large (scrollable) playing area. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
