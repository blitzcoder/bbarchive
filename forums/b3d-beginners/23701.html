<!DOCTYPE html><html lang="en" ><head ><title >Types within types issues</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Types within types issues</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Types within types issues</a><br><br>
<a name="245301"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam_128</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br> I am attempting to use blitz's "type" functions to create types within types. This works very well, until I attempt to access individual types within each parent type. I believe it has something to do with the way I am reading back the data within the for / next loops.<br><br>Here is a simple example:<br><br>&lt;b&gt;<br>Type children<br> Field name$<br>End Type<br><br>Type parents<br> Field name$<br> Field child.children<br>End Type<br><br><br> <br> ;parent steve<br> parent.parents = New parents<br> parent\name$="steve"<br> parent\child = New children<br> parent\child\name$="steve/julie"<br> parent\child = New children<br> parent\child\name$="steve/justin"<br><br><br> ;parent bob<br> parent.parents = New parents<br> parent\name$="bob"<br> parent\child = New children<br> parent\child\name$="bob/mike"<br> parent\child = New children<br> parent\child\name$="bob/stacie"<br><br><br><br><br><br> For parent = Each parents<br>  Print parent\name$<br>   For parent\child = Each children<br>    Print "  "+parent\child\name$<br>   Next<br>  Next<br>&lt;b&gt;<br><br><br>When I execute this code, each parent contains 4 children. Apparently the 'For parent\child = each children' bit is looping through each parents child and returning everything. All i want is the specific parents child.<br><br>I attempted to 'For parent\child = each parent\child\children' but this did not work. Any suggetsions would be greatly appreciated :) <br><br></td></tr></table><br>
<a name="245304"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> give each child a number, then use that? i'm sort of misisng the point tho, so sorry bout that :) <br><br></td></tr></table><br>
<a name="245324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SurreaL</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hm. One way you could do that would be to give some sort of identifier so the children knew which parent they belonged to. Right now only the parent knows which child he has created last (you're overwriting the child pointer with every new child created) and thus theres no way to do what you want with the way you're representing your data.<br><br>One way would be to have an integer field in your parent type, "children" or something, which would contain a handle to a bank. I've suggested a bank because they can be dynamically allocated/resized to suit a dynamic amoutn of children. Within this bank you could either do a simple approach, of storing a unique "id" number which you then assign to each child when creating them, or you could go a step further and just store the Handle of the object in the bank. Then you could use Object later to dereference a Type handle to the children listed in the bank.<br><br>But. Probably the easiest way, as long as you know how many children each parent could have, would be to have an array of types within the Parent type. ie something like this would allow for 3 kids:<br><br>Type Parent<br>Field Name$<br>Field Children.Child[2]<br>End Type<br><br>Type Child<br>Field Name$<br>End Type<br><br>Then you can create your objects like this:<br><br>Dad.Parent = New Parent<br>Dad\Name = "Jimmy"<br>Dad\Children[0] = New Child<br>Dad\Children[0]\Name = "Kiddo 1"<br>Dad\Children[1] = New Child<br>Dad\Children[1]\Name = "Kiddo 2"<br>Dad\Children[2] = New Child<br>Dad\Children[2]\Name = "Kiddo 3"<br><br>Mom.Parent = New Parent<br>Mom\Name = "Missus"<br>Mom\Children[0] = New Child<br>Mom\Children[0]\Name = "Kiddo 4"<br>Mom\Children[1] = New Child<br>Mom\Children[1]\Name = "Kiddo 5"<br>Mom\Children[2] = New Child<br>Mom\Children[2]\Name = "Kiddo 6"<br><br>etc etc<br><br>Then to run through all of the families..<br><br>For Folks.Parent = Each Parent<br>	Print "Parent: " + Folks\Name<br>	For counter = 0 to 2<br>		Print "Child: " + Folks\Children[counter]\Name<br>	Next<br>Next<br><br>This is all just off the top off my head, but it should compile.. as you can see it works fairly well, except now you have to know exactly how many children the parents can have. Also, there will be wasted memory if say one parent has 3 kids and another has 5.. Of course you have to allocate your array to support as many children as any of your parents could possibly have. This is the disadvantage. Thats why the bank method I was explaining before would be better, but a bit more complex as well. It would have the advantage of being able to dynamically support as many children as you wanted within each parent, however. (This is a fairly good advantage.) And if you coded around it, you could technically store different handles of different *kinds* of types (whether for example it be a Child type, or even another Parent, or whatever you wanted) But I digress..<br><br>Let me know if that helped ;) <br><br></td></tr></table><br>
<a name="245333"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Foppy</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think part of the problem is illustrated by the way you have named your types. The child object is called "children", but a better name would be "child". Since although the entire collection of objects of this type can be called a collection of children, each object in this collection is still an individual "child".<br><br>When you create an object of type "child", this is only one object. It is not a collection of objects. The same is true for a field inside another type: the "children" field in your parent type is really just one single child object.<br><br>I see you repeatedly create a new child and assign it to this "children" field in the parent type. However, that way what you are doing is simply replacing the previously created child with a new one: the "children" field will contain only the last object you assigned to it.<br><br>There is also a misunderstanding of the "For Each" command. This command will always visit *every* object of a given class, no matter when or where in your program each object was created. When you have created a number of "children" for one parent, and also a number of such objects for another parent, and also a few spare children; using "For Each Children" you will visit all of them one by one. This explains the result you got. (But it is also caused by the point I made above.)<br><br>So if you want to create a list of children for every parent, you need more than just one "child" field in the parent type. You need a list of child objects.<br><br>Maybe I am going to fast now, but you can create such a list by means of a "linked list" of child objects. For this, you add to the child type a field called "nextChild", and this should be of the type "Children". Now when you assign a child to a parent, you simply assign it to its Children field. Then when you want to assign a second child to the same parent, you assign the second child to the "nextChild" field of the first child. This way you are building a linked list of children objects.<br><br>Here's how the child type would look:<br><br><pre class=code>
Type CHILD
   Field name$ 
   Field nextChild.CHILD
End Type

Type parents 
   Field name$ 
   Field child.CHILD
End Type
</pre><br><br>I didn't change the name "parents" but "parent" would be better (or "PARENT", I personally like to use all-uppercase names for types). You can now change the rest of the code to use the "linked list" idea:<br><br><pre class=code>
;parent steve 
parent.parents = New parents 
parent\name$="steve" 

parent\child = New CHILD
parent\child\name$="steve/julie" 

parent\child\nextChild = New CHILD
parent\child\nextChild\name$="steve/justin" 

parent\child\nextChild\nextChild = Null

;parent bob 
parent.parents = New parents 
parent\name$="bob" 

parent\child = New CHILD 
parent\child\name$="bob/mike" 

parent\child\nextChild = New CHILD 
parent\child\nextChild\name$="bob/stacie" 

parent\child\nextChild\nextChild = Null
</pre><br><br>As you can see, with the second child, instead of saying "\child = new CHILD", it says "\child\nextChild = new Child". So a new CHILD is created and assigned to the "nextChild" field of the first child, building a linked list of two such objects.<br><br>Also note how the linked lists are closed off by assigning "Null" to the nextChild field of the last child in the list. "Null" means there is no object.<br><br>To print out the linked list of child objects for every parent, you have to walk through this linked list. For this you can use a temporary CHILD variable that you point at the objects in the list one by one, until you reach the end of the list.<br><br><pre class=code>
For parent = Each parents 
   Print parent\name$ 

   tempChild.CHILD = parent\child

   While tempChild &lt;&gt; NULL
      Print " "+tempChild\name
      tempChild = tempChild\nextChild
   Wend

Next
</pre><br><br>I assign the first child the parent has to the tempChild variable. If it is not NULL, I print its name. Then, the nextChild is assigned to the temporary variable. This goes on until at some moment the variable is equal to NULL (meaning there is no object).<br><br>Maybe this linked list idea is all a bit heavy to start with but this (or similar techniques) is something you would need to get the kind of program you were aiming for.<br><br>edit: or an array, or a bank, as Surreal suggests ;)<br><br>The linked list method is great when you don't know in advance how many children you will need for each parent, you can just keep adding them.<br><br>By the way, they are even more handy when you also write a set of functions for handling these lists, as obviously the above example is a bit cumbersome; you have to keep repeating "nextChild\nextChild" etcetera while in reality you wouldn't know in advance how many there are; this would have to be done in a more automatic way by a function that decides which child is the last in the list, adding a new child behind that one. <br><br></td></tr></table><br>
<a name="245808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Adam_128</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for all of the tips!<br><br>Surreal had a good idea, but unfortunatly I do not know how large my child datatypes will get.<br><br>Foppy also had a great idea, and thanks for explaining types in types for me.<br><br>I think that the easiest way to address this would be to use an array for the children:<br><br><br>Type children<br> Field name$<br>End Type<br><br>Type parents<br> field childIndex<br> Field name$<br>End Type<br><br><br>parent.parents = new parents<br>dim child.children(255) ;max of 255 parents.<br><br>parent\name$="Steve"<br>parent\childIndex=1<br>child(parent\childIndex) = new children<br>child(parent\childIndex)\name$="Steve/julie"<br>child(parent\childIndex) = new children<br>child(parent\childIndex)\name$="Steve/justin"<br><br>... Don't need to finish, the rest is implied.<br><br><br>I think this is the easiest way to keep the data seperate, and the code simple.<br><br>Thanks for the help, and let me know what you think! <br><br></td></tr></table><br>
<a name="245869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Foppy</td><td align="right"><font class=tiny>(Posted 2003)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> That will leave you with (partly) the same problem as before: you are creating two children, but each time assign them to the same position in the array. One "children" variable (in this case, one position in the array) is just that, a (pointer to a) single children object, and not a collection of children. I mean here:<br><br>child(parent\childIndex) = new children <br>child(parent\childIndex)\name$="Steve/julie" <br>child(parent\childIndex) = new children <br>child(parent\childIndex)\name$="Steve/justin"<br><br>parent\childIndex will be the same number in both cases (1). So this means child(parent\childIndex) will also be the same position in your array. So if you now try to print the name of Steve's children by accessing that position of the array, what you will find there is a pointer to just the second child, "Justin". Although the first child *has* been created and is somewhere in memory, the array does not contain a pointer to it; this was overwritten by the assignment of the second child to that position.<br><br>In principle this big array could be a solution to your problem. Just make the array big enough so you have virtually no limit to the number of children per parent. Although there is still a limit so you would have to check for that. And you would need to solve the above problem; your program should assign each child to a different position of the array, and keep track of which ranges of positions in the array belong to one parent. It is not obvious how to do this, as you say you don't know in advance how many children a parent will have. If you want to use an array, Surreals solution of using one array for every parent (inside the parent type) seems better than using one big array that is shared by all parents. In both cases you have to make the arrays big enough in advance. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
