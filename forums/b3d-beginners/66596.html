<!DOCTYPE html><html lang="en" ><head ><title >Anagrams - Combinations/Perumatations</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Anagrams - Combinations/Perumatations</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Anagrams - Combinations/Perumatations</a><br><br>
<a name="743940"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt Vinyl</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all,<br><br>I'm putting together a word game (using B3D) but am having a bit of a headache with one particular part.<br><br>Basically, an 8-letter word is picked at random from a dictionary, and each of the 8 letters are then placed in an array.<br><br>How can I then 'check' (against the dictionary) all words that can be made from these letters? (i'm limiting it to 3-8 letter words, so things like that 'at' and 'so' are not necessary.<br><br>One thing I also need to take into account, is that if a word contains more than one of the same letters, I don't want it to count the words twice. For example, if the 8 letter word was 'ARRANGED' I wouldn't want to include the word 'ARE' twice.<br><br>Let me know if you need any further info!<br><br>:)<br><br>Cheers,<br>Matt... <br><br></td></tr></table><br>
<a name="743953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Couldn't you just use an existing anagram server and parse the resulting page?:<br>http://www.ssynth.co.uk/~gay/cgi-bin/nph-an?line=fawlty+towers&amp;words=3&amp;dict=antworth<br>http://wordsmith.org/anagram/anagram.cgi?anagram=fawlty+towers&amp;language=english&amp;d=3&amp;include=&amp;exclude=&amp;n=3&amp;m=&amp;source=adv&amp;a=n&amp;l=n&amp;q=n <br><br></td></tr></table><br>
<a name="743960"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt Vinyl</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, quite possible. Trouble is, there's about 80000+ 8 letter words that are included in my dictionary, which means 'pre-parsing' any data manually wouldn't really be an option. It really needs to be done 'dynamically'. (My dictionary is just a .txt file that has been imported into an array...<br><br>Cheers though!<br>M. <br><br></td></tr></table><br>
<a name="743965"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was having a little think about this and quickly realised that it's way more complex than I'd anticipated, mostly because (as an erstwhile hobbyist coder) I'm used to iterating rather than permutating. <i>(And why wouldn't I be... my spell checker doesn't even think 'permutating' is a real word!)</i><br><br>But I digress, there's a neat article that explains what permutations logically are (and therefore how to build the blasted things) <a href="http://www.cut-the-knot.org/Curriculum/Combinatorics/JohnsonTrotter.shtml" target="_blank">here</a>. Made me go "Oooh, of course!". <br><br></td></tr></table><br>
<a name="743974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt Vinyl</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oooh, good stuff! I'll take a look at that.<br><br>Agreed, it at first sounded simple, but soon became a lot more involved than I thought it would! :) <br><br></td></tr></table><br>
<a name="743976"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well thats because permutating isnt a real word <br><br></td></tr></table><br>
<a name="743998"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pfft. 'Conscientization' isn't a real word either but it's still of vital importance to those who use it. Permutating permutating permutating permutating. [Does little permutating dance] <br><br></td></tr></table><br>
<a name="744016"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> HA Fool ;) <br>Ive nothing against you using any madeup word you want. I was explaining to you the reason your spellchecker didnt think it was a real word, was because it wasnt. <br><br></td></tr></table><br>
<a name="744070"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Permutation sounds like something very smart, but as far as I see this is pretty simple, isn't it?<br><br>Simply parse the dictionary. If a word consists of characters that are all contained in the array then you can add them to the permutation list.You may also check the list for double entries. Did I miss something?<br><br>eg:<br><br>word$="ARRANGED"<br><br>dict$=read word by word from the directory<br><br>noway=0<br>for i=1 to len(dict$)<br> mi$=mid$(dict$,i,1)<br> if instr(word$,mi$)=0<br>  noway=1 ; uses chars we ain't got in our word<br> endif<br>next<br>if noway=0 then add it to the list. <br><br></td></tr></table><br>
<a name="744117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Subirenihil</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Loop through all permutations that are the same length as the original word.<br>For each permutation check if it is a word or if the first 3 letters are a word, first four letters, five letters, etc.<br>If it is a word, check and see if you already have it.<br><br>You could check if you already have that word first instead of if its a word. <br><br></td></tr></table><br>
<a name="744146"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Simply parse the dictionary. If a word consists of characters that are all contained in the array then you can add them to the permutation list.You may also check the list for double entries. Did I miss something?<br> <br></div><br><br>No, I think that's probably the most straightforward way of going about it. [EDIT: Removed rest - think I misread you. But anyway, yeah, I had gotten caught up on generating every possible permutation because, that way, if a 'proper' anagram exists for a word it will crop up somewhere along the permutation list... longwinded though as you'd still have to parse each permutation to discount the gobbledygook.]<br><br>Re coding the thing. I'd wrap each letter of the original string in a type with a 'used' field (set to false for each instance before each dictionary check begins) so you could easily remove letters from the equation once they had been matched and thus avoid problems associated with letter repetition.<br><br><br>*See Subirenihil's post. <br><br></td></tr></table><br>
<a name="744166"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, something like this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Type originalLetter
	Field char$
	Field used
End Type
Global currentOriginalLetter.originalLetter=Null
Global currentDictionaryWord$=""



While True
	Cls : Locate 0,0
	For currentOriginalLetter=Each originalLetter
		Delete currentOriginalLetter
	Next

	original$=Lower(Input$("Enter a source word: "))
	originalLength=Len(original$)
	
	For i=1 To originalLength
		currentOriginalLetter = New originalLetter
		currentOriginalLetter\char$=Mid$(original$,i,1)
	Next

	Print
	Print "'"+original$+"' contains the following..."

	fileIn=ReadFile("exampleDict.txt")
	While Not Eof(fileIn)
		currentDictionaryWord$=ReadLine$(fileIn)
		If match() = True Then Print currentDictionaryWord$
	Wend
	CloseFile fileIn
	
	Print
	Print "&lt;Any key&gt;"
	WaitKey
Wend
End

Function match()
	Local failures=0
	For currentOriginalLetter=Each originalLetter
		currentOriginalLetter\used=False
	Next
	
	For i=1 To Len(currentDictionaryWord$)
		thisLetterMatched=False
		For currentOriginalLetter=Each originalLetter
			If Mid$(currentDictionaryWord$,i,1)=currentOriginalLetter\char$ And currentOriginalLetter\used=False
				thisLetterMatched=True
				currentOriginalLetter\used=True
			EndIf
			If thisLetterMatched=True Then Exit	
		Next
		If thisLetterMatched=False Then failures=failures+1
	Next
	
	If failures=0
		Return True
	Else
		Return False
	EndIf	
End Function
</textarea><br><br>exampleDict.txt is just a text file containing...<br><pre class=code>
hello
this
is
an
example
dictionary
with
one
entry
per
line
so
blitz
can
read
it
easily
</pre><br><br>So, for example, if you enter 'blitzbasic' as your source word you will get three results from the example dictionary... is, blitz &amp; it. Not an anagram engine in itself, but it should help you build one.<br><br>EDIT: Can't help thinking that, rather than trying to reinvent the wheel based on all the incomplete ideas and code snips that we post, you should probably just reference an <a href="http://www.gtoal.com/wordgames/anagrams.html" target="_blank">existing solution</a>. <br><br></td></tr></table><br>
<a name="744290"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't see what's wrong with my method. you even don't need a "used field" when you simply check each character of a dictionary entry with INSTR to see if i's part of the orginal main word. Ok maybe I didn't get this right, you said you don't want an anagram to be listed twice, which could be filtered easily. If you want to prevent single letters from being used multiple times then you may use the "used" field, as described, or a count_usage field that has to be 1 for valid matches.<br><br>I also think it's wrong to generate a list of possible anagrams if you are going to remove those that are not part of the dictionary anyway. <br><br></td></tr></table><br>
<a name="744311"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>you even don't need a "used field" when you simply check each character of a dictionary entry with INSTR to see if i's part of the orginal main word.<br> <br></div><br>Well the letters that constitute the sub-word may simply be in the wrong order. 'Let Val sue I' is an (awfully crap) anagram of 'televisual' but INSTR would never recognise the presence of 'let', 'val' or 'sue' unless the source set was sufficiently reordered.<br><br><div class="quote"> <br>I also think it's wrong to generate a list of possible anagrams if you are going to remove those that are not part of the dictionary anyway.<br> <br></div><br><br>Continuing with the above example, exploring every possible permutation would simply ensure that the original set was sufficiently reordered for INST to be helpful. Yes, you'd get a lot of crap to disregard that way, but somewhere along the line you will also get 'Let Val sue I' along with every other valid anagram... it's a brute force way of getting valid results into a set in a fairly easy to parse format.<br><br>Incidentally, the parser I posted would be better suited to a more elegant search as it does not need letters to be in the correct order in order to recognise dictionary entries. You could simply pull out all the sub-words and go on to see whether or not there are any perfect combinations. (The gold medal would be an engine that tested for perfect combinations that made at least some dim sort of syntactical sense). <br><br></td></tr></table><br>
<a name="744626"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> quote:<br>ensure that the original set was sufficiently reordered for INST to be helpful.<br><br>I was talking about to use INSTR to determine if ONE letter is part of a word. Not entire words. When you test all letters of word 1 against the letters of word 2 then you will know how many times each one is contained in word 2. as long as this is one time, it's an anagram. It would be pretty insane to create an array of all potential permutations, only to compare them.<br><br>But maybe I misunderstood the whole thing. <br><br></td></tr></table><br>
<a name="744843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I was talking about to use INSTR to determine if ONE letter is part of a word. Not entire words. When you test all letters of word 1 against the letters of word 2 then you will know how many times each one is contained in word 2. as long as this is one time, it's an anagram. It would be pretty insane to create an array of all potential permutations, only to compare them.<br> <br></div><br><br>I get you - for a one word anagram it's spot on. If you want more complex results (like a bunch of sub words that are comprised of the original word's letters) then I don't think you can get away without the kind of branching permutation tree covered in the article I linked. I'm holding off on a complete solution because it seems to me that (scary) recursive functions would be appropriate. :/ <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
