<!DOCTYPE html><html lang="en" ><head ><title >Two Entity collision response?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Two Entity collision response?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Two Entity collision response?</a><br><br>
<a name="1290518"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear community,<br><br>I have been trying to wrap my head around this several times, as the problem is haunting me since my first (few) steps in 3D programming, but maybe I am missunderstanding/missusing the collision detection functions of B3D.<br><br>I have two cars and one track. I assign the constants <pre class=code>const col_world = 1</pre> and the constant <pre class=code>const col_car = 2</pre>. After that I give my track the <pre class=code>EntityType track,col_world</pre> and the car the <pre class=code>EntityType car,col_car</pre>. After that I set <pre class=code>Collisions car_col,world_col,2,2</pre>. Works like a charm.<br><br>Now I have two cars, both collide. When I assign Car1 the <pre class=code>EntityType col_car</pre> and Car2 the <pre class=code>EntityType col_car</pre> and set <pre class=code>Collisions col_car,col_car,2,2</pre> it works, but only one entity responds (Car1)...which is correct I guess? But how can I get the second entity to response? Do I have to use another technique? Think about a LAN Game. Do I have to do<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
col_player1,col_player2,col_player3
collisions col_player1,col_player2
collisions col_player1,col_player3
(...)
</textarea><br><br>Thanks in advance and kind regards. <br><br></td></tr></table><br>
<a name="1290541"></a>

<a name="1290542"></a>

<a name="1290543"></a>

<a name="1290544"></a>

<a name="1290545"></a>

<a name="1290546"></a>

<a name="1290547"></a>

<a name="1290548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You may want to take a look at this code example ( <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=3141" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=3141</a> ) which demonstrates how to detect collisions with different turning moving ellipsoid colliders.<br><br>If this does not work, i remember that i have done tests about collisions of different turning moving ellipsoid colliders and the idea was to have one constant to store the start id of the collision group and use one different id for each turning moving entity of the collision group. And define collisions between each collision group (each entity).<br><br>For example :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
const GroupTerrains = 1 ;static mesh collidable
const GroupRoads = 2 ;static mesh collidable
const GroupThings = 100 ;turningmoving ellipsoid collider

global ThingsCount
dim ThingCollider(10)

;create the collidables, create the colliders, add to a collision group
global TerrainCollidable = loadmesh("terrain.b3d")
entitytype(TerrainCollidable ,GroupTerrains)

global RoadCollidable = loadmesh("road.b3d")
entitytype(RoadCollidable ,GroupRoads)

For i% = 1 to 10 step 1
 ThingsCount = ThingsCount + 1
 Id% = ThingsCount
 ThingCollider(Id) = createpivot()
 entityradius(ThingCollider(Id),0.25)
 entitytype(ThingCollider(Id),GroupThings+Id) ; so the group id will be 101, 102, 103, etc...
Next

;define collisions detection and response between collision groups
For Id% = 1 to ThingsCount step 1
 Collisions(GroupThings+Id,GroupTerrains ,2,2) ;between this thing and terrains
 Collisions(GroupThings+Id,GroupRoads ,2,2) ;between this thing and roads
 For OId% = 1 to ThingsCount step 1
  If( OId &lt;&gt; Id )
   Collisions(GroupThings+Id,GroupThings+OId,1,2) ;between this thing and others things
  endif
 Next
Next
</textarea><br><br>That's the idea... <br><br></td></tr></table><br>
<a name="1290563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> My masterpiece is finally done! :D Idc if any of you hate it. I'm PROUD of it!<br><br>Here's a special type of Collision demo I made!<br><br>Collision_Demo_3D.bb :: <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">;Grab the current Milliseconds at the beginning of our Program
Global time = MilliSecs ( )

;Create a Randomized Seed in order to make all other Random operations MUCH more Random
SeedRnd time

;Set up a 3D DirectX-enabled Graphics window at specified width, height, depth, and start it in Windowed mode { 2 }
Graphics3D(800, 600, 0, 2)

;Set the Buffer to the BackBuffer ( ) and turn the Scene on
SetBuffer BackBuffer ( )

;Camera-Collision Value
Global type_cam      =     1

;Scene-Collision Value
Global type_lvl      =     2

;Player-Collision Value
Global type_car      =     3

;Object-Collision Value
Global type_obj      =     4

;Wall-Collision Value
Global type_wall     =     5

;Set a variable for "Gravity" in the Scene
Global grav#

;Create Player's Type Data
Type Player

	Field id
	
	Field MoveSpeed#
	Field TurnSpeed#

	Field XPosition#
	Field YPosition#
	Field ZPosition#

	Field XRotation#
	Field YRotation#
	Field ZRotation#

	Field XScale#
	Field YScale#
	Field ZScale#

End Type

;Grab our Player's Type Data
Global MyPlayer.Player = New Player

MyPlayer\id = CreateCube ( )

MyPlayer\MoveSpeed# =     0.3
MyPlayer\TurnSpeed# =     1.0

MyPlayer\XPosition# =    70.0
MyPlayer\YPosition# =   1.001
MyPlayer\ZPosition# =    55.0

MyPlayer\XRotation# =     0.0
MyPlayer\YRotation# =   100.0
MyPlayer\ZRotation# =     0.0

MyPlayer\XScale#    =     1.0
MyPlayer\YScale#    =     1.0
MyPlayer\ZScale#    =     1.0

;Position / Rotate / Scale DEFAULT Player
PositionEntity MyPlayer\id, MyPlayer\XPosition#, MyPlayer\YPosition#, MyPlayer\ZPosition#
RotateEntity MyPlayer\id, MyPlayer\XRotation#, MyPlayer\YRotation#, MyPlayer\ZRotation#
ScaleEntity MyPlayer\id, MyPlayer\XScale#, MyPlayer\YScale#, MyPlayer\ZScale#

;Turn on Polygonal Collisions for DEFAULT Player
EntityPickMode MyPlayer\id, 2
EntityType MyPlayer\id, type_car

;Give more X-Radius Collision in order to stop Player from "popping" through wall
EntityRadius MyPlayer\id, 2.0, 0.01

;Create our Object Data Type
Type Obj

	Field id

	Field count
	Field total_count

	Field XPosition#
	Field YPosition#
	Field ZPosition#

	Field XRotation#
	Field YRotation#
	Field ZRotation#

	Field XScale#
	Field YScale#
	Field ZScale#

End Type

;Create / Position / Turn on Polygonal Collisions for Camera
Global cam = CreateCamera ( MyPlayer\id )
PositionEntity cam, 0, 1.001, -10
EntityPickMode cam, 2
EntityType cam, type_cam

;Turn on FULL Lighting for Scene
AmbientLight 255, 255, 255

;Create / Color / Scale / Draw Sky before everything else / Flip the Sky upside down to see 'INSIDE' of Sky
Global sky = CreateCube ( )
EntityColor sky, 107, 207, 252
ScaleEntity sky, 25, 25, 25
EntityOrder sky, 1000
FlipMesh sky

;Create / Color / turn on Polygonal Collisions for ground
Global ground = CreatePlane ( )
EntityColor ground, 0, 64, 0
EntityPickMode ground, 2
EntityType ground, type_obj

;Set our "Object(s)" type
Global MyObject.Obj = New Obj

;How many dummy Object(s) is / are created in the Scene?
MyObject\total_count = 30

Dim Objs ( MyObject\total_count )

;Create / Scale / Color / Position / turn on Polygonal Collision for dummy Object(s) in the Scene
For x = 1 To MyObject\total_count

	MyObject\count = MyObject\count + 1

	Objs ( x ) = CreateCube ( )
	MyObject\id = Objs ( x )
	EntityColor MyObject\id, Rand ( 0, 255 ), Rand ( 0, 255 ), Rand ( 0, 255 )
	PositionEntity MyObject\id, Rnd ( -50.0, 50.0 ), 1.001, Rnd ( 50.0, 150.0 )
	RotateEntity MyObject\id, 0.0, Rnd ( -359, 359 ), 0.0
	EntityAlpha MyObject\id, Rnd ( 0.45, 0.85 )
	EntityPickMode MyObject\id, 2
	EntityType MyObject\id, type_obj

;End of Creating dummy Object(s) to fill up the Scene
Next

;Create / Scale / Color / Position / turn on Polygonal Collision for Wall
Global wall = CreateCube ( )
ScaleEntity wall, 100.0, 100.0, 0.01
EntityColor wall, 0, 128, 255
PositionEntity wall, -15.0, 1.001, 10.0
EntityPickMode wall, 2
EntityType wall, type_wall

Collisions type_car, type_scene, 2, 3 ;Full Sliding Polygonal Collision between Player &amp; Scene { Ground }
Collisions type_car, type_obj, 2, 3 ;Full Sliding Polygonal Collision between Player &amp; Object { Box ON the Ground }
Collisions type_obj, type_car, 1, 1 ;Full Sliding Polygonal Collision between Object &amp; Player { Box ON the Ground }
Collisions type_car, type_wall, 2, 3 ;PREVENT Polygonal Sliding Collision between Player &amp; Wall { Wall ON the Ground }
Collisions type_obj, type_obj, 2, 3 ;Full Sliding Polygonal Collision between an Object &amp; another Object { Box ON the Ground }
Collisions type_obj, type_wall, 2, 3 ;Full Sliding Polygonal Collision between Object(s) in Scene &amp; Wall { Box / wall ON the Ground }

	;While Main Loop is active and the Escape key is NOT hit or held down
	While Not KeyDown ( 1 )

		;For every Player created in the Scene { Which is currently at this point in time, only 1 Player }
		For MyPlayer.Player = Each Player

			;If the Player's Position is 'above' the 'ground'
			If ( EntityY# ( MyPlayer\id, 1 ) &gt; 1.001 )

				;Turn on Gravity when in the 'air'
				grav# = grav# * 1.0

			;Otherwise, 
			Else
			
				;Turn off Gravity when not in the 'air'
				grav# = 0.0

			;EndIf
			EndIf

			;Set Gravity regardless of on OR off
			TranslateEntity MyPlayer\id, 0, grav#, 0

			;Position the Sky at the Player's coordinates ALWAYS
			PositionEntity sky, EntityX# ( MyPlayer\id, 1 ), EntityY# ( MyPlayer\id, 1 ), EntityZ# ( MyPlayer\id, 1 )

			;Move the Player with W/S or Up/Down at chosen constant speed
			MoveEntity MyPlayer\id, 0, 0, ( KeyDown ( 17 ) - KeyDown ( 31 ) Or KeyDown ( 200 ) - KeyDown ( 208 ) ) * MyPlayer\MoveSpeed#

			;Turn the Player with A/D or Left/Right at chosen constant speed
			TurnEntity MyPlayer\id, 0, ( KeyDown ( 30 ) - KeyDown ( 32 ) Or KeyDown ( 203 ) - KeyDown ( 205 ) ) * MyPlayer\TurnSpeed#, 0

			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;			
			;
			; *** More than one Collision response example
			;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

			;If the Player collided either with a wall
			If ( Check_Collisions ( MyPlayer\id, type_wall ) )

				;Do something here
				EntityColor MyPlayer\id, Rand ( 0, 255 ), Rand ( 0, 255 ), Rand ( 0, 255 )

			;EndIf
			EndIf

			;If the Player collided with an Object in the Scene
			If Check_Collisions ( MyPlayer\id, type_obj )

				;Do something here
				EntityColor MyPlayer\id, Rand ( 0, 255 ), Rand ( 0, 255 ), Rand ( 0, 255 )
			
			;EndIf
			EndIf

		;End of checking for every Player in the Scene
		Next

		;Turn on Collision &amp; Update World / Objects
		UpdateWorld

		;Render the World
		RenderWorld

		;For every Object in our Scene
		For MyObject.Obj = Each Obj

			;Count each Object in the Scene
			For x = 1 To MyObject\count

				;Move each Object in Scene in a small Circle
				MoveEntity Objs ( x ), 0, 0, 0.1

				;Turn each Object in Scene in a small Circle
				TurnEntity Objs ( x ), 0, 0.1, 0

				;If one Object collides with another Object in the Scene
				If Check_Collisions ( Objs ( x ), type_obj )
				
					;Do something here
					DebugLog "'" + Objs ( x ) + "' hit"
					
				;EndIf
				EndIf

			;End of Counting each Object in the Scene
			Next

		;End of checking for each Object in the Scene
		Next

			;For each Player in the Scene
			For MyPlayer.Player = Each Player

				;Display Text
				Text 10,  10, "XPos# : "  + EntityX# ( MyPlayer\id, 1 )
				Text 10,  30, "YPos# : "  + EntityY# ( MyPlayer\id, 1 )
				Text 10,  50, "ZPos# : "  + EntityZ# ( MyPlayer\id, 1 )
					
				Text 10,  70, "XRot# : "  + EntityPitch# ( MyPlayer\id, 1 )
				Text 10,  90, "YRot# : "  + EntityYaw# ( MyPlayer\id, 1 )
				Text 10, 110, "ZRot# : " + EntityRoll# ( MyPlayer\id, 1 )
	
				Text 10, 130, "grav# : " + grav#

			;End of checking for every Player in the Scene
			Next

		;Flip the Scene into view / Refresh the Scene
		Flip

	;End of Game's Main While Loop
	Wend

;Silently End the Program when escape is hit or the Program exits
End

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FUNCTION(S) SECTION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Function Check_Collisions ( idA, idB )

	If ( EntityCollided ( idA, idB ) ) Then Return 1

	Return 0

End Function
</textarea><br><br>Hope this helps!<br><br>Enjoy!<br><br>~GF <br><br></td></tr></table><br>
<a name="1290565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> when you updatecollisions, then you can access to the collisions encountered<br>-&gt; you can use EntityCollided to get the second entity of the current collisions (according to entitytype specified)<br>-&gt; or you can CollisionEntity to get the second entity involved in the collisions at specified index ( Index is the collision index of the entity when you loop the collisions encountered on the last UpdateWorld, in the range 1 to CountCollisions(entity) )<br><br>Notice that when 2 entity collide while both moving, they will generate a collision, but then will pass one through the other<br>The blitz3d collisions are nice for some stuff, but not very accurate for "great physic" stuff. <br><br></td></tr></table><br>
<a name="1290686"></a>

<a name="1290687"></a>

<a name="1290688"></a>

<a name="1290689"></a>

<a name="1290690"></a>

<a name="1290691"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey guys,<br><br>thanks for helping me out on this.<br><br>@RemiD<br>Your first example features exactly what I want to achieve. Is it limited to spheres only? If so, should I<br>- declare the car as a sphere collider (how do I determine the radius then)? Except for guessing, because that doesn't help me understand the fundamentals at all.<br>- use a sphere the same radius as the collider, make it the car's parent, make the sphere invisible (alpha = 0)?<br><br>A sphere doesn't come into my mind at first, when checking for collisions of boxy cars. But my several tries showed, that it generates great smoothing at corners etc.<br><br>@Guy Fawkes<br>Thanks for sharing this mate. It gave me a good understanding, how to access the entities, which are affected by the collision. Maybe I ditch the internal Blitz collision response and code the responses myself. Since it's an arcadish racer, I might be able to use both movement vectors and apply them in the oppisite direction on collision (I'm a noob, that idea may be ridiculous).<br><br>@Bobysait<br>Thanks for the further info on working out the entities that collide. It helped me to understand Guy Fawke's code. Your hint is very much appreciated, because that was exactly what I was experiencing. Both cars, all set up, both moving, sliding through each other. But it's an arcade racer (and I'm new to 3D), so I couldn't understand, why all cars stopped reacting. <br><br></td></tr></table><br>
<a name="1290692"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey guys,<br><br>thanks for helping me out on this.<br><br>@RemiD<br>Your first example features exactly what I want to achieve. Is it limited to spheres only? If so, should I<br>- declare the car as a sphere collider (how do I determine the radius then)? Except for guessing, because that doesn't help me understand the fundamentals at all.<br>- use a sphere the same radius as the collider, make it the car's parent, make the sphere invisible (alpha = 0)?<br><br>A sphere doesn't come into my mind at first, when checking for collisions of boxy cars. But my several tries showed, that it generates great smoothing at corners etc.<br><br>@Guy Fawkes<br>Thanks for sharing this mate. It gave me a good understanding, how to access the entities, which are affected by the collision. Maybe I ditch the internal Blitz collision response and code the responses myself. Since it's an arcadish racer, I might be able to use both movement vectors and apply them in the oppisite direction on collision (I'm a noob, that idea may be ridiculous).<br><br>@Bobysait<br>Thanks for the further info on working out the entities that collide. It helped me to understand Guy Fawke's code. Your hint is very much appreciated, because that was exactly what I was experiencing. Both cars, all set up, both moving, sliding through each other. But it's an arcade racer (and I'm new to 3D), so I couldn't understand, why all cars stopped reacting. <br><br></td></tr></table><br>
<a name="1290700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Most of the time, 3D perception is just a 2D with some different elevation.<br>If you can "transform" the 3D logic to a 2D system, then you 'll be able to use 2D collisions library (that works much better)<br><br>For example, cars on a track mostly involve only 2D reactions (except if you need some jumps and gravity)<br>Box2D or any kind of verlet collision system will be great for this. Those are 2D physic library that should be better than the blitz3d collisions.<br><br>And yes, Blitz3D collisions can acheive different kind of response for collisions (sliding/stop etc ... with different kind of interactions elipsoid/box/polygons) but it only works for the "receiver". The emitter will always use an elipsoid for collisions, and that's what makes it fast ... and hard to use accurately in most cases. <br><br></td></tr></table><br>
<a name="1290712"></a>

<a name="1290713"></a>

<a name="1290714"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Guy Fawkes's code has several errors, (as always) so don't take this as a reliable example...<br><br><br>There is another way which i have used in the past to detect collisions between turningmoving non sphere shapes. (for example cars or spaceships)<br><br>The idea is to have a pivot for the root of your turningmoving entity, that you will use to turn move (or rotate translate) the entity.<br>And a hull made of several ellipsoid colliders set as child of the root pivot.<br>And have one collision group per turningmoving entity so that one turningmoving entity can detect a collision against another turningmoving entity (as explained in my previous example). (the ellipsoid colliders of the same turningmoving entity can be in the same collision group).<br><br>Also to prevent inaccuracies, you can calculate collision in steps, in each step you turn move (or rotate translate) only one turningmoving entity (and consequently its hull made of several ellipsoids colliders), then calculate the collisions between this turningmoving entity and the others entities (statics collidables and the others turningmoving collidables (which are static in this step)). With this approach, you have a hull made of several ellipsoids colliders for each turningmoving entity and a low tris mesh collidable for each static and for each turningmoving entity (when it is static).<br><br>With the same logic, you can forget about the collision system and use several linepicks cast from a position related to the root pivot and in a specific direction and with a specific length depending on the orientation and speed of the entity. And have a low tris mesh pickable for each static and for each turningmoving entity (when it is static).<br><br>Alternatively, take a look at the car physics example of BlitzBullet : <a href="http://www.blitzbasic.com/Community/posts.php?topic=95713" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=95713</a> <br><br></td></tr></table><br>
<a name="1290764"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Remi... Go screw yourself. At least I tried. D***... <br><br></td></tr></table><br>
<a name="1290804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RemiD<br>The collisions are for a LAN game, I have converted (or should I say: wanted to convert) from 2D to 3D. At the beginning I had all clients simulate the physics themselves = horrible to keep synced. Then I broke down the physics to: two cars collide, reverse their vx and vy, so they don't collide anymore. Your basic arcadish 2D collision.<br><br>Then I jumped to 3D collisions, which I have been trying literally the whole day. Your example worked, yes. But if I assign the car the radius it needs to detect the collision with other cars, it overdetects collisions with the world and slows you down everytime you try to go on a ramp or sth. Then I've tried the 2D approach. On MeshIntersect(car1,car2), set collision to true, give both cars an impact in their opposite direction, so they don't collide anymore. Worked at first, but then a car got stuck in a corner due to level collision and the collision paramter never went false = both cars were stuck. Ugh. Then I tried an example from the codearcs (something with vehicle movement on terrain) and it provided beautiful movement worldwise. But went crazy when car to car collisions came into play. I really worked hard on this game and have gained a basic grasp of 3D programming in the process, but right now I feel stupid and frustrated. Should I seperate the collisions car-&gt;world and car-&gt;car? Maybe use the actual car mesh for the collision detection with the world (radius 0.25,0.25 work fine) and then a sphere for car to car (how do I translate the effects of the slide then?). Phew. <br><br></td></tr></table><br>
<a name="1290810"></a>

<a name="1290811"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Should I seperate the collisions car-&gt;world and car-&gt;car?<br> <br></div><br>No, car-&gt;world is ok but to detect collisions between turningmoving cars you want to have one collision group for each car (the colliders of the same car can be in the same collision group) and if you want it to be more accurate, only turnmove detectcollisions reorientereposition one entity at a time (so all others turningmoving entities are static during this step)<br><br>About meshesintersect, you can indeed use this, it will be fast enough if you use a distance check before, to see which entities are near enough and must be considered for the meshesintersect check, but you won't be able to get the collision point or the collision normal...<br><br>An alternative to meshesintersect is the coldet lib to calculate collisions between meshes. Search the forum about that.<br><br>To decrease the mstime it takes to calculate collisions, you want to use low details meshes for collidables (the obstacles shapes) and medium/high details meshes for the renderers (the shape you want to display).<br>You want to position the collidables at the same position with the same orientation than the renderers and set their alpha to 0.<br>Then when you need to calculate collisions, only consider the collidables meshes (low details), not the renderers meshes (high details).<br><br>If you use the blitz3d collisions system with ellipsoids colliders and low details meshes collidables, it should be fast enough, unless your map has really complex shapes or is too big... <br><br></td></tr></table><br>
<a name="1290814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again for the reply. I will try to use MeshIntersect. Could you tell me, why I would need collisions points/normals? <br><br></td></tr></table><br>
<a name="1290815"></a>

<a name="1290816"></a>

<a name="1290817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also for meshesintersect, use low details meshes to decrease the time it takes to calculate.<br><br>About the possibility to get hat is the collided surface, the collision point, the collision normal, this is to be able to know which part of the car was collided, to be able to emit particles from the collision point, in the direction of the collision normal. <br>The normal is a vector (an arrow...) which starts from the triangle (a surface is made of vertices and triangles...) and which points to the direction the triangle faces/is oriented towards/looks at. <br><br></td></tr></table><br>
<a name="1290820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh snap. I have achieved some nice effects with MeshesIntersect (been working and trying for couple of hours now). This is it, stripped down basically, but I still have some trouble with it. If you would be so kind and look at my function below. The other car doesn't respond to the collision, but if I didn't get the loop wrong, it should check: this.car = car 1 against other.car = car 2 and after that this.car = car 2 against other.car = car 1. Then I basically retrieve the speed in all directions of car 2 and store it to the variables ix to iz (impact x to impact z). In the next step I apply the impacts to them untill there is no collision happening. As I've said, car 1 does respond, car 2 doesn't. And I need a way to retrieve the direction, in which the cars to push (I'm afraid, that's why ppl want to know the collision normals :P). Any chance of calculating it with...say...DeltaYaw? Thanks in advance.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function CarCollision()
	
	For this.car = Each car
		For other.car = Each car
			If MeshesIntersect(this\e,other\e) And this\coll = False And this\e &lt;&gt; other\e Then
				this\coll = True
				this\ix = this\ix + other\vx ;recv an impact from the other car
				this\iy = this\iy + other\vy ;recv an impact from the other car
				this\iz = this\iz + other\vz ;recv an impact from the other car
			Else
				this\coll = False
			End If
		Next
	Next
	
	For this.car = Each car
		If this\coll = True Then
			this\vx = this\ix
			this\vy =  this\iy
			this\vz = this\iz
		End If
	Next
	
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1290881"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>And I need a way to retrieve the direction, in which the cars to push (I'm afraid, that's why ppl want to know the collision normals :P). Any chance of calculating it with...say...DeltaYaw?<br> <br></div><br>If you use vectors to translate your cars, when one car collides with another car you could indeed invert the vector but it will look inaccurate and ugly compared to being able to get the collided surface, the collision point, the collision normal, and calculate the direction in which the car must be redirected...<br><br>To go further, you could also use linearvelocity (moving speed) and angularvelocity (turning speed) to turn move your cars, for this take a look at a physics engine like Bullet (BlitzBullet) <br><br></td></tr></table><br>
<a name="1290893"></a>

<a name="1290894"></a>

<a name="1290895"></a>

<a name="1290896"></a>

<a name="1290898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Guy Fawkes :<br>Proud or not, your code actually contains errors<br><br>Collisions type_car, type_scene, 2, 3<br>-&gt; type_scene not defined<br><br>grav# = grav# * 1.0<br>-&gt; grav is always "0" in your code.<br>0.0 * 1.0 is still 0.0.<br><br>your sky (which sould seriously be replaced with a CameraClsColor instead of a monochrome fliped cube) should be positioned with the camera position, not the player, and BTW, you have a loop for "all players" which assume you can load more than 1 player, the "sky" will be positioned on the last one. It's definitely not what you want.<br><br>Regarding the collisions :<br><br>You update the player collisions before the UpdateWorld ...<br>So, you react each frame on the collisions from the previous frame rendered.<br>Call UpdateWorld "Before" your "For each" loop on player type<br><br>You update object collisions after updateworld ... which seems to be good, but ... it's still not !<br>You call the renderworld after updateworld, so the "obj" Types are not updated before the next frame too.<br><br>What you should have done :<br>1 - move/rotate entities<br>2 - UpdateWorld to update collisions<br>3 - Intercept collision states (replace entities if required)<br>4 - update things that relates on position of "physical" entities<br>5 - Renderworld when everything is ok<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; move/rotate player(s)
For MyPlayer.Player = Each Player
	If ( EntityY# ( MyPlayer\id, 1 ) &gt; 1.001 )
		grav# = grav# * 1.0
	Else
		grav# = 0.0
	EndIf
	TranslateEntity MyPlayer\id, 0, grav#, 0
	MoveEntity MyPlayer\id, 0, 0, ( KeyDown ( 17 ) - KeyDown ( 31 ) Or KeyDown ( 200 ) - KeyDown ( 208 ) ) * MyPlayer\MoveSpeed#
	TurnEntity MyPlayer\id, 0, ( KeyDown ( 30 ) - KeyDown ( 32 ) Or KeyDown ( 203 ) - KeyDown ( 205 ) ) * MyPlayer\TurnSpeed#, 0
Next

; move/rotate obj(s)
For MyObject.Obj = Each Obj
	For x = 1 To MyObject\count
		MoveEntity Objs ( x ), 0, 0, 0.1
		TurnEntity Objs ( x ), 0, 0.1, 0
	Next
Next

; update world collisions
UpdateWorld()

; update post-collisions
For MyPlayer.Player = Each Player
	If ( Check_Collisions ( MyPlayer\id, type_wall ) )
		EntityColor MyPlayer\id, Rand ( 0, 255 ), Rand ( 0, 255 ), Rand ( 0, 255 )
	ElseIf Check_Collisions ( MyPlayer\id, type_obj )
		EntityColor MyPlayer\id, Rand ( 0, 255 ), Rand ( 0, 255 ), Rand ( 0, 255 )
	EndIf
Next

For MyObject.Obj = Each Obj
	For x = 1 To MyObject\count
		If Check_Collisions ( Objs ( x ), type_obj )
			DebugLog "'" + Objs ( x ) + "' hit"
		EndIf
	Next
Next

; position the sky just before the renderworld
; and the sky is related to the camera. (whatever you camera is parented to a player)
PositionEntity sky, EntityX(cam,1), EntityY(cam,1), EntityZ(cam,1)

; Then you can render the scene when everything is in its right place.
RenderWorld

</textarea><br><br>Then your collisions will be updated correctly.<br><br>But ... there still remain  2 things :<br><br>1 / checking collisions against another collision_type is not very usefull, it doesn't return the position or the normal of the impact so there is nothing to do with but random entitycolor ...<br>-&gt; for more robust collisions, you need to traverse all collisions with a "for c = 1 to countcollisions(entity)" and retreive the collisions informations using CollisionX(entity, c)/CollisionNx(entity,c) etc ...<br>You'll then be able to react on effective collisions.<br><br>2 / it still does not resolve the problem of two entities moving. they will generate a collision event and a small sliding on a single frame, but on the next loop, they will both traverse the other entity.<br>So, your code doesn't solve anything, but show a sample that is actually harder to read, sorry for that, but I can't approve your sample as a good example for understanding the problem of this topic.<br><br>ps : and there is no need to comment on every lines.<br>If the guy that read your code doesn't know what a "Else" or a "Endif" or a "Next" is, there is no way he will understand the purpose of the collisions. "First things First" he need to read some doc on blitz3d syntax, don't you think ? <br><br></td></tr></table><br>
<a name="1290900"></a>

<a name="1290901"></a>

<a name="1290902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >funkmaster5000</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If you use vectors to translate your cars, when one car collides with another car you could indeed invert the vector but it will look inaccurate and ugly compared to being able to get the collided surface, the collision point, the collision normal, and calculate the direction in which the car must be redirected... <br></div><br><br>I know you want to introduce a physics engine to me, but I need to grasp the basics before moving on to advanced examples (including a "whole" engine).<br><br>I have managed to use reverse vectors on collision. What happens is, that car 1 bounces back, when it hits car 2, car 2 stays still. So basically I have managed to move them out of the collision zone, so that they don't get stuck or accelerate forever. It doesn't look that smooth, like you've said, but I'm proud on it for my first 3D project! Still I don't get, why only 1 car is affected and the other isn't. What I want to happen is (Pseudo):<br><br>-On collision car 1 to car 2(3,4,5)<br>-Apply the velocity(x,y,z) of car 1 to the impact(x,y,z) of car 2(3,4,5)<br>-Apply the velocity(x,y,z) of car 2(3,4,5) to the impact(x,y,z) of car 1<br><br>-On collision car 2 to car 1(3,4,5)<br>-Apply the velocity(x,y,z) of car 2 to the impact(x,y,z) of car 1(3,4,5)<br>-Apply the velocity(x,y,z) of car 1(3,4,5) to the impact(x,y,z) of car 2<br><br>(Loop through all...)<br><br>-Apply the impact to all cars<br><br>What might work too, since it's an arcade game, compare the speed of the cars and if one is faster, apply an impact to the slower car and reduce the faster car's speed to a slower value (harcoded).<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function CarCollision()
	For this.car = Each car
		For other.car = Each car
			If MeshesIntersect(this\e,other\e) And this\coll = False And this\e &lt;&gt; other\e Then
				this\coll = True
				this\ix = this\ix + other\vx ;recv an impact from the other car
				this\iy = this\iy + other\vy ;recv an impact from the other car
				this\iz = this\iz + other\vz ;recv an impact from the other car
			Else
				this\coll = False
			End If
		Next
	Next
	
	For this.car = Each car
		If this\coll = True Then
			TFormVector this\ix,this\iy,this\iz,this\e,0 ;form a vector out of the impact values
			this\vx = TFormedX() ;and apply the orces
			this\vy =  TFormedY()
			this\vz = TFormedZ()
		End If
	Next
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1290903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I know you want to introduce a physics engine to me<br> <br></div><br>Not really, i just suggested the available possibilities with Blitz3d...<br><br><br>You can get the collided surface, the collision point, the collision normal, with the Blitz3d collision system, and it is easy to use.<br><br>You may like this code example : <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=415" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=415</a> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
