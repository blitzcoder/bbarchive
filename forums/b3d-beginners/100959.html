<!DOCTYPE html><html lang="en" ><head ><title >3d coordinates to 2d coordinates if the point is b</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >3d coordinates to 2d coordinates if the point is b</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >3d coordinates to 2d coordinates if the point is b</a><br><br>
<a name="1196195"></a>

<a name="1196196"></a>

<a name="1196198"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello,<br><br>I want to draw a grid with the command Line()<br><br>With Blitz3d i know that i can use CameraProject() to find the 2D coordinates of 3D points if the points are in front of the camera.<br>;For point A<br>CameraProject(Camera,AX,AY,AZ)<br>APX = ProjectedX()<br>APY = ProjectedY()<br>;For point B<br>CameraProject(Camera,BX,BY,BZ)<br>BPX = ProjectedX()<br>BPY = ProjectedY()<br>;Then i draw the line<br>Line(APX,APY,BPX,BPY)<br><br>It works well, see :<br><img src="http://imageshack.us/a/img689/8319/r13c.png"><br><br>But what if the 3d points are behind the camera ?<br><br>CameraProject() does not seem to help in this case... See :<br><img src="http://imageshack.us/a/img607/7553/kquh.png"><br><br>Do you know a way to calculate the 2d coordinates (pixel coordinates) of 3d points whatever where there are in the 3d world (in front of or behind the camera) ?<br>If yes, can you please explain ?<br><br>Please note that my camera can have different pitch and yaw, so this complicates things even more.<br><br>Thanks, <br><br></td></tr></table><br>
<a name="1196218"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dale Nation</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If the points are not seen by the camera, they do not have 2d coordinates... it would seem CameraProject() should work. What is the problem with it? <br><br></td></tr></table><br>
<a name="1196223"></a>

<a name="1196224"></a>

<a name="1196227"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> This issue is obviously that the camera projection defaults to 0,0 if the point isn't in front of the camera.<br><br>Assuming you want to draw a line between 3d points A and B, check both points to determine whether they are infront or behind the camera. <br><br><pre class=code>
tformpoint Ax,Ay,Az,0,camera
AInfront = ( tformedz() &gt; MIN_CAM_RANGE ) 
tformpoint Bx, By, Bz, 0, Camera
BInfront = ( tformedz() &gt; MIN_CAM_RANGE )
</pre><br>  <br>I neither point is in front don't draw the line.  If both points are in front then draw as normal.  Else work out the intersection point between the line and a plane.  The line would be from the point in front to the point behind.  The plane is effectively the camera of the view fostrum.  Once you have the new point, draw the line from the point infront to the intersection point.<br><br>See Line-Plane intersection on this page:<br><a href="http://geomalgorithms.com/a05-_intersect-1.html" target="_blank">http://geomalgorithms.com/a05-_intersect-1.html</a><br><br>The point on the plane would be:<br><br><pre class=code>
Tformpoint 0,0,MIN_CAM_RANGE, CAMERA, 0
Px# = tformedx()
Py# = tformedy()
Pz# = tformedz()
</pre><br><br>The plane normal would be ...<br><br><pre class=code>
Tformnormal 0,0,1,CAMERA, 0
Nx# = tformedx()
Ny# = tformedy()
Nz# = tformedz()
</pre><br><br>MIN_CAM_RANGE will normally be 1 but this would have to be adjusted if you set a new camerrange or change the camerazoom.<br><br>Stevie <br><br></td></tr></table><br>
<a name="1196228"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is also a ProjectedZ(), which will normally be the "near" value for the camera range.<br><br>But it will be zero for points not in front of the camera, or beyond the camera far value. In that case the ProjectedX() and ProjectedY() also return zero, but are meaningless. <br><br></td></tr></table><br>
<a name="1196229"></a>

<a name="1196230"></a>

<a name="1196231"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I want to find a way to convert the 3d coordinates of a 3d point to 2d coordinates (in pixels) even if the 3d point is behind the camera.<br>With this i will be able to always draw the lines of the grid even if the camera is in the middle of the grid.<br>With CameraProject i can't calculate the 2d coordinates of a 3d point if the 3d point is behind the camera.<br><br>This code shows that it is possible to draw a line even if the start point or end point is outside of the 2d screen<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D(800,600,32,2)
SetBuffer(BackBuffer())
SeedRnd(MilliSecs())

Camera = CreateCamera()
CameraRange(Camera,0.1,1000)
PositionEntity(Camera,0,1.6,0)

For i% = 1 To 100
 ThingMesh = CreateCube()
 ScaleMesh(ThingMesh,0.1/2,0.1/2,0.1/2)
 EntityColor(ThingMesh,Rand(000,255),Rand(000,255),Rand(000,255))
 PositionEntity(ThingMesh,Rnd(-10,10),Rnd(0,3),Rnd(0,20))
Next

RenderWorld()

For i% = 1 To 10
 Color(Rand(000,255),Rand(000,255),Rand(000,255))
 Line(Rand(-100000,-1),Rand(-100000,-1),399,299)
Next

For i% = 1 To 10
 Color(Rand(000,255),Rand(000,255),Rand(000,255))
 Line(Rand(600,100000),Rand(-100000,-1),399,299)
Next

For i% = 1 To 10
 Color(Rand(000,255),Rand(000,255),Rand(000,255))
 Line(Rand(-100000,-1),Rand(600,100000),399,299)
Next

For i% = 1 To 10
 Color(Rand(000,255),Rand(000,255),Rand(000,255))
 Line(Rand(800,100000),Rand(600,100000),399,299)
Next

Flip(1)
FlushKeys()
WaitKey()
</textarea><br><br>So i assumed it must be possible to do it.<br><br><br><br>Stevie G&gt;&gt;Thanks i will study your explanations. <br><br></td></tr></table><br>
<a name="1196270"></a>

<a name="1196271"></a>

<a name="1196273"></a>

<a name="1196274"></a>

<a name="1196275"></a>

<a name="1196276"></a>

<a name="1196277"></a>

<a name="1196278"></a>

<a name="1196321"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Isn't it possible to flip the camera in it's local Z axis, do a CameraProject() with all the points that were considered behind it, then flip it again to normality and invert the signs of the XY coordinates of those backwards projections?<br><br>EDIT: No.<br><br>EDIT2: Okay, here's what you need. <br>Like Stevie G listed...<br>- For every pair of points in front of the camera, draw line like usual.<br>- For every pair behind the camera, don't draw anything.<br>- For every pair where one of the points is behind the camera, use a Ray -&gt; Plane intersection routine by Elias_t, from the code archives: <a href="http://blitzbasic.com/codearcs/codearcs.php?code=942" target="_blank">http://blitzbasic.com/codearcs/codearcs.php?code=942</a><br><br>- As the plane, consider the camera's NEAR PLANE (it's usually +1.0 in the Z axis of the camera). You need three points of that plane to input to the function, and you can retrieve these three points by doing TFormPoint( X, Y, 1, Camera, 0) three times, using different X and Y values. It doesn't matter what are the XY values, as long as they describe three different points that represent a triangle contained in the plane.<br>- As the ray, use the two 3D grid points.<br><br>The function will return the coordinates of the intersection located at your near plane, and this intersection will be 'ahead' of the camera, so CameraProject() will return valid screen coordinates that you can draw your lines. <br>Note this is going to cost performance, and you only need to use this function for points behind the camera - so a worst case scenario would be all your points are behind it. In any case, it's 7x faster than LinePicks.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global IntersectedX#, IntersectedY#, IntersectedZ#


;-------------------------------------------------
Graphics3D( 800, 600, 0, 2 )

camera	=	CreateCamera()
		CameraRange( camera, 0.5, 1000 )

l	=	CreateLight( 1 )
		TurnEntity( l, 30, 60, 0 )

;Visualize the triangle that defines the plane.
m	=	CreateMesh()
		s	=	CreateSurface( m )
		v0	=	AddVertex( s, -2, 2, 5 )
		v1	=	AddVertex( s, 2, 2, 5 )
		v2	=	AddVertex( s, -2, -2, 5 )
		AddTriangle( s, v0, v1, v2 )
		;v3	=	AddVertex( s,2,-2, 5 )	;Extra vert to make a quad.
		;AddTriangle( s, v1, v3, v2 )
		EntityColor m,60,160,10
		UpdateNormals m

;3 vertices of the triangle that define a plane.
v0x#	=	VertexX( s, v0 )
v0y#	=	VertexY( s, v0 )
v0z#	=	VertexZ( s, v0 )

v1x#	=	VertexX( s, v1 )
v1y#	=	VertexY( s, v1 )
v1z#	=	VertexZ( s, v1 )

v2x#	=	VertexX( s, v2 )
v2y#	=	VertexY( s, v2 )
v2z#	=	VertexZ( s, v2 )

;Object to represent the start of the ray segment.
rayStart	=	CreateSphere()
				EntityColor rayStart,255,0,0
				ScaleEntity raystart,0.1,0.1,0.1
				
;Direct coordinates of the end of the ray segment.
rayEndX#	=	0
rayEndY#	=	-500
rayEndZ#	=	1000


While Not KeyHit(1)

	PositionEntity( rayStart, (MouseX()-400)/400.0, -(MouseY()-300)/400.0, 1 ) 

	res	=	RayPlaneIntersect( EntityX(rayStart),EntityY(rayStart),EntityZ(rayStart), rayEndX, rayEndY, rayEndZ, v0x,v0y,v0z, v1x,v1y,v1z, v2x,v2y,v2z )
	
	PositionEntity( rayStart, IntersectedX, IntersectedY, IntersectedZ, True )

	RenderWorld()

	CameraProject( camera, rayEndX, rayEndY, rayEndZ )
	Line MouseX(),MouseY(),ProjectedX(),ProjectedY()

	Text( 10, 20, res )
	If res
		Text( 10, 20, "Intersected" )
		Text( 10, 100, IntersectedX )
		Text( 10, 120, IntersectedY )
		Text( 10, 140, IntersectedZ )
	EndIf
	
	Flip
Wend

End



;-----------------------------------------------------------------
; FUNCTION RayPlaneIntersect(...) by Elias_t.
;	Tests the intersection of a ray segment against a plane.
;
; INPUT:
;	p1x#, p1y#, p1z# -&gt; One of the points of the ray segment.
;	p2x#, p2y#, p2z# -&gt; The other point of the ray segment.
;
;	pax#, pay#, paz# -&gt; One of the points of the triangle that defines the plane.
;	pbx#, pby#, pbz# -&gt; Same as above.
;	pcx#, pcy#, pcz# -&gt; Same as above.
;
;	Note: The SIZE of the triangle defined does not matter. A plane is always INFINITE. The triangle is
;	used only for figuring the orientation and position of the plane.
;
; OUTPUT:
;	The function returns True in case there is an intersection, False otherwise.
;	If there is an intersection, the point of intersection is stored in the IntersectedX#, IntersectedY#
;	and IntersectedZ# globals. The point of intersection is given in WORLD COORDINATES.
;-----------------------------------------------------------------

Function RayPlaneIntersect(p1x#,p1y#,p1z#, p2x#,p2y#,p2z#, pax#,pay#,paz#, pbx#,pby#,pbz#, pcx#,pcy#,pcz#)

	Local d#
	Local total#,denom#,mu#
	Local nx#,ny#,nz#
				
	Local dx1#=(pcx - pax)
	Local dy1#=(pcy - pay)
	Local dz1#=(pcz - paz)

	Local dx2#=(pbx - pax)
	Local dy2#=(pby - pay)
	Local dz2#=(pbz - paz)

	nx#=(dy1*dz2)-(dz1*dy2)
	ny#=(dz1*dx2)-(dx1*dz2)
	nz#=(dx1*dy2)-(dy1*dx2)

	;------------------------------------

	d = - nx * pax - ny * pay - nz * paz

	;Calculate the position on the line that intersects the plane.
	denom = nx * (p2x - p1x) + ny * (p2y - p1y) + nz * (p2z - p1z);
	
	If (Abs(denom) &lt; 0.0001) Return False ;Line and plane don't intersect.
      
	mu = - (d + nx * p1x + ny * p1y + nz * p1z) / denom
	IntersectedX = p1x + mu * (p2x - p1x)
	IntersectedY = p1y + mu * (p2y - p1y)
	IntersectedZ = p1z + mu * (p2z - p1z)
	
	;comment this out if you want an infinite ray
	If (mu &lt; 0 Or mu &gt; 1) Return False ;Intersection not along line segment.
      
	Return True

End Function</textarea> <br><br></td></tr></table><br>
<a name="1196281"></a>

<a name="1196282"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stevie G</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Kryzon, that sounds like a very familiar concept!<br><br>You only need a 1 point on the plane and it's normal.  You don't need to faf about with 3 points as they are primarily used to get the plane normal - you can use the camera entity to get this information.  Elias's function can then be reduced to ...<br><br><pre class=code>
Function RayPlaneIntersect(p1x#,p1y#,p1z#, p2x#,p2y#,p2z#, Entity, OffsetZ# =1.0 )

	Local d#
	Local total#,denom#,mu#
	Local nx#, ny#, nz#
	Local pax#, pay#, paz#
	
	;get a point on the plane
	TFormPoint 0,0,OffsetZ,Entity, 0
	pax# = TFormedX()
	pay# = TFormedY()
	paz# = TFormedZ()
	
	;get plane normal
	TFormNormal 0,0,1,Entity,0
	nx# = TFormedX()
	ny# = TFormedY()
	nz# = TFormedZ()

	;------------------------------------

	d = - nx * pax - ny * pay - nz * paz

	;Calculate the position on the line that intersects the plane.
	denom = nx * (p2x - p1x) + ny * (p2y - p1y) + nz * (p2z - p1z);
	
	If (Abs(denom) &lt; 0.0001) Return False ;Line and plane don't intersect.
      
	mu = - (d + nx * p1x + ny * p1y + nz * p1z) / denom
	IntersectedX = p1x + mu * (p2x - p1x)
	IntersectedY = p1y + mu * (p2y - p1y)
	IntersectedZ = p1z + mu * (p2z - p1z)
	
	;comment this out if you want an infinite ray
	If (mu &lt; 0 Or mu &gt; 1) Return False ;Intersection not along line segment.
      
	Return True

End Function
</pre><br><br>Where Entity = camera entity, OffsetZ = camera near range<br><br>In fact, you could put your whole line drawing function into the same function.  I haven't tested but this *should* work ..<br><br><pre class=code>
Function Line3Dto2D( p1x#,p1y#,p1z#, p2x#,p2y#,p2z#, Entity, OffsetZ# =1.0 )

	Local d#
	Local total#,denom#,mu#
	Local nx#, ny#, nz#
	Local pax#, pay#, paz#
	Local InFront1 , InFront2
	Local x1#,y1#,x2#,y2#
	Local InterX#, InterY#, InterZ#
	
	;Is point 1 if infront of plane?
	TFormPoint p1x, p1y, p1z, 0, Entity : InFront1 = ( TFormedZ() &gt; OffsetZ )
	;Is point 2 if infront of plane?
	TFormPoint p2x, p2y, p2z, 0, Entity : InFront2 = ( TFormedZ() &gt; OffsetZ )
	
	;Exit if both points behind plane
	If ( Not InFront1 ) And ( Not InFront2 ) Return
	
	If InFront1 And InFront2	
		;Draw line normally
		CameraProject Entity, p1x,p1y,p1z
		x1# = ProjectedX()
		y1# = ProjectedY()
		CameraProject Entity, p2x,p2y,p2z
		x2# = ProjectedX()
		y2# = ProjectedY()
	Else
		;Get a point on the plane
		TFormPoint 0,0,OffsetZ,Entity, 0
		pax# = TFormedX()
		pay# = TFormedY()
		paz# = TFormedZ()
		
		;Get plane normal
		TFormNormal 0,0,1,Entity,0
		nx# = TFormedX()
		ny# = TFormedY()
		nz# = TFormedZ()
		
		;Calculate intersection point
		;There must be one as one Line is infront And the other is behind plane
		d = - nx * pax - ny * pay - nz * paz
		denom = nx * (p2x - p1x) + ny * (p2y - p1y) + nz * (p2z - p1z);
		mu = - (d + nx * p1x + ny * p1y + nz * p1z) / denom
		InterX = p1x + mu * (p2x - p1x)
		InterY = p1y + mu * (p2y - p1y)
		InterZ = p1z + mu * (p2z - p1z)

		If InFront1
			;Point 1 is in front, point 2 is behind
			CameraProject Entity, p1x,p1y,p1z
			x1# = ProjectedX()
			y1# = ProjectedY()
			CameraProject Entity, InterX,InterY,InterZ
			x2# = ProjectedX()
			y2# = ProjectedY()
		Else
			;Point 2 is in front, point 1 is behind
			CameraProject Entity, p2x,p2y,p2z
			x1# = ProjectedX()
			y1# = ProjectedY()
			CameraProject Entity, InterX,InterY,InterZ
			x2# = ProjectedX()
			y2# = ProjectedY()
		EndIf
	EndIf

	Line x1,y1,x2,y2

End Function
</pre> <br><br></td></tr></table><br>
<a name="1196306"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Isn't it possible to flip the camera in it's local Z axis, do a CameraProject()... <br>EDIT: No.<br>EDIT2: Okay, here's what you need. <br>Like Floyd listed... <br></div><br>That wasn't me.<br><br>Actually my first thought was the z-flip idea. Doesn't quite work.<br>Then I thought of turning the camera 180 degrees on its y-axis. No.<br><br>So here's the latest version of that plan. Imagine the point, camera and plane in space. There is an infinite line determined by the point and the camera. Every point on this line projects the same point on the plane.<br><br>So if a point is behind the camera ( opposite side from the plane ) we consider the point reflected through the camera. If the camera is at the origin then just flipping all the signs would suffice. But in general we need to do a little calculation.<br><br>Let P and Q be two points in space. (P-Q) is the vector from Q to P. Then we have<br><br>P + (P-Q)<br><br>is the "mirror image" of the point Q reflected through the point P. This would be a lot clearer with picture.<br><br>Anyway, if the point is behind the camera we find the coordinates of the reflected point by<br><br>CameraX + (CameraX-PointX), and likewise for Y,Z.<br><br>Then use CameraProject on the reflected point.<br><br>This is untested, but looks right in my head. <br><br></td></tr></table><br>
<a name="1196310"></a>

<a name="1196311"></a>

<a name="1196312"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hah! I gave up too soon on the "manipulate the camera" idea.<br><br>For some reason I thought the projection was on the plane z=1 even with the z-axis flipped. But that wasn't it.<br><br>So my "reflect the point through the camera" approach is most easily implemented as<br><br>ScaleEntity camera, -1,-1,-1<br><br>and then project for points behind the camera. <br><br></td></tr></table><br>
<a name="1196341"></a>

<a name="1197131"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Stevie G: Thank you for the changes. Supplying only the entity is much more convenient than having to worry about the orientation of the plane or any vertex positions. That is very interesting.<br> <br><div class="quote"> Like Floyd listed... <br></div><div class="quote"> That wasn't me. <br></div><br>Disregard that, I was in auto-reply mode. <br>I realize now it was Stevie G; he also suggested the plane intersection, which is what inspired me to look in the code archives for some code that did just that.<br><br>About the mirror reflection, I think I understand the idea behind, but please correct me if I'm wrong. You are taking the "displacement" of the camera in relation to the point, and continuing that displacement as the point itself, so you get the equivalent of seeing this point with a flipped camera while the camera remains untouched. I was thinking of using TForm for that, but directly going to math like you are doing is much faster. The scale should do the same as well.<br>I still don't think it would work, because the vector from point-behind to point-in-front (which is what we wish to render on the screen as a line) is not the same as the vector from mirrored-point to point-in-front. <br>If you imagine a lot of scenarios for this, some of them won't fit. For instance, the point-in-front being close to the camera and the point-behind being very far away.<br><br>- - - - -<br>Just for trivia, Direct3D can do this task quite simply: vertex line-lists. <br>You define a "vertex stream" - an array of vertices - and call for DrawPrimitive on this array in line-list mode: the hardware renders 2D lines between the vertices, even if the camera is intersecting the connections between them. <br>It's how software like 3DS Max etc. draw their 3D grids. It would be a boon to this kind of work to have this accessible.<br>It would require a lot of effort to be invoked from Blitz3D, however. <br>You would need to <a href="http://www.steve-oh.com/blog/index.php/directx-70a-sdk-download/" target="_blank">download the SDK for Direct3D 7</a>. <br>Then make a DLL that wraps d3dDevice-&gt;DrawPrimitive() by taking as parameters the list of vertices and the camera's matrix, setting up the immediate mode and everything. <br>Then create a DECLS of that. <br>It's not impossible, though, since you can retrieve the Direct3DDevice7 and the HWND with the SystemProperty() function. <br><br></td></tr></table><br>
<a name="1196397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello again. What a coincidence.<br>Today I got to know that the AShadow Engine, a library in the lines of FastExtention, is now freeware.<br><br>AShadow Engine wraps some of Direct3D 7. With the help of this engine, it's [somewhat] easy to perform the real 3D lines as intended without the need to calculate plane intersections or anything else.<br><br>Check the sample below:<br><img src="http://i40.tinypic.com/ifzh1i.png"><br><br>Before running this code, you need the AShadow engine in your userlibs ( <a href="http://andreyman.ucoz.ru/load/3-1-0-5" target="_blank">http://andreyman.ucoz.ru/load/3-1-0-5</a> ).<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">; Example of building a real 3D grid using the AShadow engine and Direct3D 7.
;
; Original thread: <a href="http://blitzbasic.com/Community/posts.php?topic=100959" target="_blank">http://blitzbasic.com/Community/posts.php?topic=100959</a>
;___________________________________________________________________________

Graphics3D 800,600,0,2


;Initiate the AShadow Engine's hook:
;____________________________________________________________________________
Direct3D7=SystemProperty$("Direct3D7")
Direct3DDevice7=SystemProperty$("Direct3DDevice7")
Direct3DDraw7=SystemProperty$("DirectDraw7")
AppHWND=SystemProperty$("AppHWND")
AppHINSTANCE=SystemProperty$("AppHINSTANCE")

If Direct3D7=0 RuntimeError "FATAL ERROR: Can't get access to Drect3DDevice!"

BBSetSystemControl (Direct3D7,Direct3DDevice7,Direct3DDraw7)
;____________________________________________________________________________


;Create a grid mesh. No triangles, just vertices.
;Each CONSECUTIVE pair of vertices is considered a 3D line.
;You can rotate, scale etc. the grid by applying these transformations to the
;mesh entity.

grid	=	CreateMesh()
			EntityOrder( grid, -999 ) ;The grid always needs to be rendered last. It will still be Z-tested against the scene.

gridSurface	=	CreateSurface( grid )
				For loopVerts = 0 To 9
					For row = 0 To 1
 						AddVertex( gridSurface, row, 0, loopVerts/9.0 )
						Next 

					For column = 0 To 1 
						AddVertex( gridSurface, loopVerts/9.0, 0, column )
					Next 
				Next
				
				Const VERTEX_COUNT = 40
				PositionMesh( grid, -0.5, 0, -0.5 )
				ScaleMesh( grid, 40, 1, 40 )
				
cameraPivot	=	CreatePivot()

camera	=	CreateCamera()
			MoveEntity( camera, 0, 5, -10 )
			EntityParent( camera, cameraPivot )			
			
cube	=	CreateCube()
			EntityColor( cube, 10, 60, 200 )


			
l	=	CreateLight( 1 )
		TurnEntity( l, 60, 20, 0 )

MoveMouse( 400, 300 )
While Not KeyHit( 1 )
	
	TranslateEntity( camera, 0, (KeyDown(30)-KeyDown(44)) * 0.1, 0 )
	PointEntity( camera, cameraPivot )
	TurnEntity( cameraPivot, 0, 0.25, 0 )
		
	UpdateWorld()
	RenderWorld()

	;Start the hacky grid rendering pass after the RenderWorld.
	;-------------------------------------------------------------------------------------------------------------
	BBBeginScene()
		
		;D3DRS_ZENABLE = 7;
		BBSetRenderState( 7, True ) ;Allows the grid to react to other 3D objects in the scene.
		
		;RGBA - Diffuse color.
		BBSetDiffuseMaterial( 220, 0, 225, 255 ) ;Defines a solid color for the grid.
		
		;FROM MSDN:
		;// Primitives supported by draw-primitive API
		;typedef enum _D3DPRIMITIVETYPE {
		;    D3DPT_POINTLIST     = 1,
		;    D3DPT_LINELIST      = 2,
		;    D3DPT_LINESTRIP     = 3,
		;    D3DPT_TRIANGLELIST  = 4,
		;    D3DPT_TRIANGLESTRIP = 5,
		;    D3DPT_TRIANGLEFAN   = 6,
		;    D3DPT_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
		;}
		
		;BBDrawPrimitive( d3dptPrimitiveType, VerticesStart, dwVertexCount, dwFlags )
		BBDrawPrimitive( 2, retI( gridSurface + 28 ), VERTEX_COUNT, 0 ) ;Render the grid in one call.	
		
		;The address to the surface geometry data seems to be retrieved by peeking an Int.
		;AShadow already has a function to peek an int address, it's RetI%().
		;The address is (Surface handle + 28). This was taken from AShadow.bb.
	
	BBEndScene()
	;--------------------------------------------------------------------------------------------------------------
		
	Text 10,10,"Use the A and Z keys to control the camera."	
		
	Flip
Wend 

End</textarea> <br><br></td></tr></table><br>
<a name="1196430"></a>

<a name="1196431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon&gt;&gt;Very good ! Thanks for the example. :) <br><br></td></tr></table><br>
<a name="1196694"></a>

<a name="1196765"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello. I've worked on my code for a bit, tried making it more robust.<br><br>Some things work differently now, and you can have multiple cameras rendering the grid, different viewports, zoom etc. I know it doesn't sound like much, but trust me in that it was complicated to achieve.<br>Semi-transparent entities and their interaction with the grid isn't perfect right now, but I think this can be addressed by someone taking their time with the render-states. <br>I was more concerned with the cameras and entity transforms, which I think are the most difficult part.<br><br>It's also got some more information for anyone trying to do more complex things with the Andreyman AShadow engine with the Direct3D immediate mode.<br><br><img src="http://i41.tinypic.com/ayskfs.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">; Example #2 of building a real 3D grid using the AShadow engine and Direct3D 7.
;
; Original thread: <a href="http://blitzbasic.com/Community/posts.php?topic=100959" target="_blank">http://blitzbasic.com/Community/posts.php?topic=100959</a>
;___________________________________________________________________________

;Try with different resolutions and ratios, but make sure to update the values in the viewports and projection generation.
Graphics3D 400,600,0,2


;Initiate the AShadow Engine's hook:
;____________________________________________________________________________
Direct3D7=SystemProperty$("Direct3D7")
Direct3DDevice7=SystemProperty$("Direct3DDevice7")
Direct3DDraw7=SystemProperty$("DirectDraw7")
AppHWND=SystemProperty$("AppHWND")
AppHINSTANCE=SystemProperty$("AppHINSTANCE")

If Direct3D7=0 RuntimeError "FATAL ERROR: Can't get access to Drect3DDevice!"

BBSetSystemControl (Direct3D7,Direct3DDevice7,Direct3DDraw7)
;____________________________________________________________________________


;Notes: 

;	- The memory address of a bank's data is (Bank_handle + 4).
;
;	- The memory address of a surface's geometry data is (Surface_handle + 28).
;
;	- The grid must always be considered "visible" by all cameras in your Blitz3D scene. In order for this to happen, you 
;can give it a gigantic MeshCullBox(), preferably with a volume bigger than that of your entire scene.
;If it's not considered visible, some entities might end up being coloured the same way as the grid. This is from Blitz3D optimizing
;things by not updating some brushes when it thinks that there's no need for it. This has no relation to EntityOrder().


grid	=	CreateMesh()
			;Creating a very big cull-box so the grid is always visible.
			MeshCullBox( grid, -100000, -100000, -100000, 200000, 200000, 200000 )
gridSurface	=	CreateSurface( grid )
				For loopVerts = 0 To 31
					For row = 0 To 1
 						AddVertex( gridSurface, row, 0, loopVerts/31.0 )
						Next 

					For column = 0 To 1 
						AddVertex( gridSurface, loopVerts/31.0, 0, column )
					Next 
				Next
							
				Const VERTEX_COUNT = 128
				PositionMesh( grid, -0.5, 0, -0.5 )
				ScaleMesh( grid, 64, 1, 64 )

		
cube	=	CreateCube()
			EntityColor( cube, 10, 60, 200 )
			EntityAlpha( cube, 0.8 )


sph	=	CreateSphere()			
		ScaleEntity( sph, 0.9, 0.9, 0.9 )


l	=	CreateLight( 1 )
		TurnEntity( l, 60, 20, 0 )


cameraPivot	=	CreatePivot()


camera	=	CreateCamera( cameraPivot )
			CameraClsColor( camera, 10, 40, 40 )
			MoveEntity( camera, 0, 5, -10 )
			Local near# = 1, far# = 50
			CameraRange( camera, near, far )
			zoom# = 1.0
			CameraZoom( camera, zoom )
			viewportW# = 400
			viewportH# = 300
			CameraViewport( camera, 0, 0, viewportW#, viewportH# )

			
camera2	=	CreateCamera()
			CameraClsColor( camera2, 30, 40, 20 )
			CameraViewport( camera2, 0, 300, 400, 300 )
			MoveEntity( camera2, 10, 10, -1 )
			PointEntity( camera2, cameraPivot )
			tempZoom# = 1

;Matrices needed by D3D. 
;4x4 floats = 64 bytes.

;View matrix, relates to the camera. Regenerated in real-time.
viewMatrix		=	CreateBank( 4 * 4 * 4 )

;Projection Matrix, relates to the camera. You need to generate one of these for each camera you're rendering the grid in.
;It's generated once, but you'll need to regenerate it again if you change the camera's viewport, zoom, near or far values in 
;the middle of the program. If you don't change the camera's settings you can re-use the same one over and over.
projectionMatrix	=	CreateBank( 4 * 4 * 4 ) : GenerateProjectionMatrix( projectionMatrix, viewportW, viewportH, near, far, zoom )
projectionMatrix_2	=	CreateBank( 4 * 4 * 4 ) : GenerateProjectionMatrix( projectionMatrix_2, 400, 300, 1, 1000, 1 )

;If somehow the grid becomes distorted, make sure you're supplying the projection with the same values you're using for your camera.

;World matrix, based on the entity being rendered. Regenerated in real-time.
worldMatrix		=	CreateBank( 4 * 4 * 4 )


MoveMouse( 400, 300 )
While Not KeyHit( 1 )
	Delay 10
	
	;Update entities, AI etc.
	TranslateEntity( camera, 0, ( KeyDown( 30 ) - KeyDown( 44 ) ) * 0.1, 0 )
	PointEntity( camera, cameraPivot )
	TurnEntity( cameraPivot, 0, 0.25, 0 )
	TurnEntity( camera, 0, ( KeyDown( 18 ) - KeyDown( 16 ) ) * 0.5, 0 )
	
	TurnEntity( grid, KeyDown( 57 ) * 0.8, KeyDown( 57 ) * 0.8, KeyDown( 57 ) * 0.8 )
	
			
	UpdateWorld() 
	RenderWorld()
	
	
	;Start the immediate mode rendering.
	;- - - - - - - - - - - - - - - - - - - - - - - - - -
	
	;Do a pass like this once per camera view, if you need more than one view of the grid.
	;On every pass, supply the appropriate camera entity and projection matrix.
	BBBeginScene()
	
		;D3DRS_ZENABLE = 7; (Enable Z-Test so the grid can be hidden by other 3D objects.)
		BBSetRenderState( 7, True )
		
		;RGBA - Diffuse color of the grid.
		BBSetDiffuseMaterial( 220, 0, 225, 255 )
		
		;CAMERA #1
		;-----------------------------------------
			;Set the viewport to the desired size.
			BBSetViewport( 0, 0, 400, 300 )	
			
			;1) Update the VIEW transform:
			GenerateViewMatrix( camera, viewMatrix )
			BBSetTransform( 2, retI( viewMatrix + 4 ) )
		
			;2) Re-use the PROJECTION transform (if no changes were made to the camera's settings):
			BBSetTransform( 3, retI( projectionMatrix + 4 ) )
						
			;3) Update the WORLD (entity) transform:
		
				;Use AShadow's auxiliary function for setting an entity's world transform.
				BBSetEntityTransformMatrix( grid, 0 ) ;No idea what the 'mode' parameter does. Just leave it as 'zero'.	
			
				;Or optionally comment the above line and use the following to do it manually.
				;GenerateWorldMatrix( grid, worldMatrix )
				;BBSetTransform( 1, retI( worldMatrix + 4 ) )
			
			BBDrawPrimitive( 2, retI( gridSurface + 28 ), VERTEX_COUNT, 0 )		
		;-----------------------------------------
		
		;CAMERA #2
		;-----------------------------------------
			BBSetViewport( 0, 300, 400, 300 )
						
			GenerateViewMatrix( camera2, viewMatrix )
			BBSetTransform( 2, retI( viewMatrix + 4 ) )
			
			tempZoom = Cos( EntityYaw( cameraPivot )*2 ) * 0.25 + 1 
			CameraZoom( camera2, tempZoom )
			
			;Generate a new projection for camera2, since we're changing one of its settings.
			GenerateProjectionMatrix( projectionMatrix_2, 400, 300, 1, 1000, tempZoom )  
			BBSetTransform( 3, retI( projectionMatrix_2 + 4 ) )
			
			;BBSetEntityTransformMatrix( grid, 0 ) ;There's no need to set the world transform for the grid again. 
			;It's the same grid we're rendering again.
	
			BBDrawPrimitive( 2, retI( gridSurface + 28 ), VERTEX_COUNT, 0 )
		;-----------------------------------------
		
	BBEndScene()
	;- - - - - - - - - - - - - - - - - - - - - - - - - -
	
	;Render 2D elements.
	Text 10,10,"Use the A and Z keys to control the camera."
	Text 10,30,"Hold SPACE to spin the grid."	
		
	Flip
Wend 


;Copies an entity's world matrix into a bank of floats.
Function GenerateWorldMatrix( entity%, bankMatrix% )  
	
	Local index = 0

	For j = 0 To 3
	
		For i = 0 To 2
			PokeFloat( bankMatrix, index, GetMatElement( entity, j, i ) ) : index = index + 4
		Next
		PokeFloat( bankMatrix, index, 0 ) : index = index + 4 ;Additional column. Blitz3D entities have 4x3 matrices; D3D uses 4x4.
	
	Next
	
	PokeFloat( bankMatrix, index-4, 1.0 ) ;The additional column for the last row has the value 1.0.
	
	;A Blitz3D identity matrix:
	;1 0 0 
	;0 1 0
	;0 0 1
	;0 0 0
	
	;A Direct3D identity matrix (note the additional column):
	;1 0 0 0
	;0 1 0 0
	;0 0 1 0
	;0 0 0 1
		
End Function


;Creates a projection matrix for a camera based on its settings.
Function GenerateProjectionMatrix( bankMatrix%, viewportW#=1.0, viewportH#=0.75, camNear# = 1, camFar# = 1000, camZoom# = 1 )
	
	;ViewportW and viewportH are simply the width and height of the viewport for the camera you're generating the projection matrix.
	Local viewRatio# = Float( viewportH ) / viewportW
	
	;In 3D units.
	Local viewWidth# = 2.0 
	Local viewHeight# = 2.0 * viewRatio

	;The following is based on the Direct3D 7 documentation. Can't thank enough that material.
	
	w# = ( 2.0 * camNear ) / ( viewWidth / camZoom )	;w = 1.0 (when camZoom = 1)
	h# = ( 2.0 * camNear ) / ( viewHeight / camZoom )	;h = 1.0 * viewRatio (when camZoom = 1)
	
	Q# = camFar / ( camFar - camNear )
	PokeFloat( bankMatrix, 0, w )
	PokeFloat( bankMatrix, 20, h )
	PokeFloat( bankMatrix, 40, Q )
	PokeFloat( bankMatrix, 44, 1.0 )
	PokeFloat( bankMatrix, 56, ( -Q * camNear ) )

End Function


;Creates a view matrix for a camera.
Function GenerateViewMatrix( camera%, bankMatrix% )

	;Retrieve the camera's "front" vector.
	Local nX#, nY#, nZ#
	TFormNormal( 0, 0, 1, camera, 0 )
	nX = TFormedX()
	nY = TFormedY()
	nz = TFormedZ()
	
	;Retrieve the camera's "right" vector.
	Local uX#, uY#, uZ#
	TFormNormal( 1, 0, 0, camera, 0 )
	uX = TFormedX()
	uY = TFormedY()
	uZ = TFormedZ()
	
	;Retrieve the camera's "up" vector.
	Local vX#, vY#, vZ#
	TFormNormal( 0, 1, 0, camera, 0 )
	vX = TFormedX()
	vY = TFormedY()
	vZ = TFormedZ()
	
	;Retrieve camera's translation in world space.
	Local pX#, pY#, pZ#
	Local tempX# = EntityX( camera, True )
	Local tempY# = EntityY( camera, True )
	Local tempZ# = EntityZ( camera, True )
	pX = - DotProduct( uX, uY, uZ, tempX, tempY, tempZ )
	pY = - DotProduct( vX, vY, vZ, tempX, tempY, tempZ )
	pZ = - DotProduct( nX, nY, nZ, tempX, tempY, tempZ )
	
	;Some values are not necessary to poke since they are zero.
	PokeFloat( bankMatrix, 0, uX ) : PokeFloat( bankMatrix, 4, vX ) : PokeFloat( bankMatrix, 8, nX ); : PokeFloat( bankMatrix, 12, 0 ) 
	PokeFloat( bankMatrix, 16, uY ): PokeFloat( bankMatrix, 20, vY ): PokeFloat( bankMatrix, 24, nY );: PokeFloat( bankMatrix, 28, 0 )
	PokeFloat( bankMatrix, 32, uZ ): PokeFloat( bankMatrix, 36, vZ ): PokeFloat( bankMatrix, 40, nZ );: PokeFloat( bankMatrix, 44, 0 )
	PokeFloat( bankMatrix, 48, pX ): PokeFloat( bankMatrix, 52, pY ): PokeFloat( bankMatrix, 56, pZ ) : PokeFloat( bankMatrix, 60, 1 )
	
End Function


Function DotProduct#( x#, y#, z#, a#, b#, c# )
	Return x*a + y*b + z*c
End Function


End</textarea> <br><br></td></tr></table><br>
<a name="1196725"></a>

<a name="1196726"></a>

<a name="1196727"></a>

<a name="1196728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon&gt;&gt;Wow ! This seems complicated !<br><br>Is there no other way to achieve the same render ?<br><br>I think of 2 ways :<br><br><br>1)Use 2 cameras, use the camera pointer to set each camera to render the grid (so 2 renders)<br>No idea on how to do it but i guess that :<br>BBBeginScene()<br>BBSetRenderState(7,True) ;D3DRS_ZENABLE = 7<br>BBSetDiffuseMaterial(255,255,255,255)<br>BBDrawPrimitive( 2, retI(Gridv3Surface+28), Gridv3VerticesCount, 0 )<br>BBEndScene()<br>are linked to a Camera<br><br><br>2)Use only one camera, render each view and copyrect to 2 different images, then draw one image above (or aside) of the other.<br><br><br>Anyway good work. It would be good to know if it is compatible with most machines, i will do some tests. <br><br></td></tr></table><br>
<a name="1196845"></a>

<a name="1196846"></a>

<a name="1196847"></a>

<a name="1196848"></a>

<a name="1196849"></a>

<a name="1196967"></a>

<a name="1196968"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are shortcuts you can take; If it's a game with a single camera, it's much easier to handle.<br>If you need more, you can code a framework behind it to take away most of the work (automating tasks like rendering all cameras, etc.). <br>In a way, like a RenderWorld().<br><br>Try working on this:<br><br><img src="http://i40.tinypic.com/1234fwz.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle( "Immediate Mode - Primitive Rendering" )
Graphics3D( 800, 600, 0, 2 )


;Notes: 
;
;	- To avoid having a standard Blitz3D mesh getting colored like one of the Direct3D primitives by mistake, give that mesh 
;	a custom brush.
;	
;	- If you HideEntity a mesh so it's not rendered by Blitz3D, somehow its matrix is deactivated (?). 
;	So primitives won't show if you're using AShadow's SetEntityTransformMatrix() on hidden meshes. If you use GetMatElement(), the entity's 
;	matrix is somehow restored. Check the DrawD3DMesh function.


;---------------------------
Const D3DRS_ZENABLE	= 7 
Const D3DRS_ZWRITE	= 14
Const D3DRS_SRCBLEND = 19
Const D3DRS_DESTBLEND = 20

Dim D3DMatrices%(4)
	;0 - View.
	;1 - Projection.
	;2 - World.
	;3 - Blitz3D View.
	;4 - Blitz3D Projection.

Type D3DMesh
	Field mesh%
	Field surfaceAddress%
	Field numVertices%
	Field mat.D3DMaterial
	
	Field primitiveType%
   ;Field states.RenderStates
End Type

Type D3DMaterial
	Field diffuseColorR#
	Field diffuseColorG#
	Field diffuseColorB#
	
	Field ambientColorR#
	Field ambientColorG#
	Field ambientColorB#
	
	Field specularColorR#
	Field specularColorG#
	Field specularColorB#
	
	Field emissiveColorR#
	Field emissiveColorG#
	Field emissiveColorB#
	
	Field specularpower#
End Type

Type D3DCamera
	Field entity%
	Field viewX#, viewY#
	Field viewW#, viewH#
	Field near#, far#
	Field zoom#
	Field projMode%
End Type 

InitD3D()
;---------------------------


grid1	=	util_CreateGridMesh( 32 )
			CreateD3DMesh( grid1, 50, 100, 50 )
			EntityColor grid1,255,0,0
			ScaleEntity( grid1, 30, 1, 30 )
			MoveEntity( grid1, 0, -3, 10 )		
			
grid2	=	util_CreateGridMesh( 6 )
			CreateD3DMesh( grid2, 220, 0, 80 )
			MoveEntity( grid2, 2, 2, 0 )
			ScaleEntity( grid2, 2, 1, 2 )
			TurnEntity( grid2, 40, 0 ,20 )

sphere	=	CreateSphere( 24 )
			CreateD3DMesh( sphere, 240, 170, 0, 1 )
			MoveEntity( sphere, -2, 2, 0 )
			TurnEntity( sphere, -70, 70, 0 )
			HideEntity( sphere )
			
cube	=	CreateCube()
			customBrush = CreateBrush(0,0,255)
			PaintMesh( cube, customBrush ) 
			MoveEntity( cube, 0, -1, 0 )
			ScaleEntity( cube, 0.7, 0.7, 0.7 )			
			
Local d3d_camera.D3DCamera
d3d_camera	=	CreateD3DCamera()
				D3DCameraZoom( d3d_camera, 1.2 )
				D3DCameraProjMode( d3d_camera, 1 )
				D3DCameraViewport( d3d_camera, 20, 20, 400, 400 )
				CameraClsColor( d3d_camera\entity, 30, 50, 50 )
				MoveEntity( d3d_camera\entity, 0, 0.55, -5 )

Local d3d_camera2.D3DCamera		
d3d_camera2	=	CreateD3DCamera()
				D3DCameraZoom( d3d_camera2, 4 )
				D3DCameraViewport( d3d_camera2, 20, 440, 760, 140 )
				CameraClsColor( d3d_camera2\entity, 10, 20, 20 )				
				MoveEntity( d3d_camera2\entity, 4, 0, -1)
				PointEntity( d3d_camera2\entity, sphere )
				TurnEntity( d3d_camera2\entity, 5, 5, 0)
				

Local d3d_camera3.D3DCamera		
d3d_camera3	=	CreateD3DCamera()
				D3DCameraZoom( d3d_camera3, 5 )
				D3DCameraViewport( d3d_camera3, 440, 20, 340, 300 )
				CameraClsColor( d3d_camera3\entity, 30, 50, 50 )
				MoveEntity( d3d_camera3\entity, 10, 0, 0)
				TurnEntity( d3d_camera3\entity, 9, 20, 45)
				
							
Local fpsTimer = CreateTimer( 60 )

l	=	CreateLight( 1 )
		TurnEntity( l, 30, 60, 0 )
		
AmbientLight 255,0,0 

While Not KeyHit( 1 )
	WaitTimer( fpsTimer )
	
	TurnEntity( grid2, 0.5, 0.45, 0.45 )
	TurnEntity( sphere, 0.1, 0.11, 0.13 )
	TurnEntity( cube, 0.3, -0.3, 0.3 )
	
	;3D
	UpdateWorld()
	RenderWorld()
	
	;Direct3D
	RenderD3D()
	
	;2D
	;[...]
	
	Flip
Wend
 
End


Function RenderD3D()
	BBBeginScene()
	
		D3DMatrices( 3 ) = BBGetTransform( 2 )
		D3DMatrices( 4 ) = BBGetTransform( 3 )

		BBSetRenderState( D3DRS_ZENABLE, True )
		BBSetRenderState( D3DRS_ZWRITE, True )
		BBSetRenderState( D3DRS_SRCBLEND, 2 )
		BBSetRenderState( D3DRS_DESTBLEND, 1 )
		
		For c.D3DCamera = Each D3DCamera
			
			If c\projMode Then
			
				SetD3DCamera( c )			
			
				For m.D3DMesh = Each D3DMesh
					DrawD3DMesh( m )
				Next 
			
			EndIf 
		
		Next
		
		BBSetTransform( 2, D3DMatrices( 3 ) )
		BBSetTransform( 3, D3DMatrices( 4 ) )
		
	BBEndScene()
End Function


Function SetD3DCamera( c.D3DCamera )
	GenerateViewMatrix( c )
	BBSetTransform( 2, retI( D3DMatrices( 0 ) + 4 ) )
	
	GenerateProjectionMatrix( c )
	BBSetTransform( 3, retI( D3DMatrices( 1 ) + 4 ) )
	
	BBSetViewport( c\viewX, c\viewY, c\viewW, c\viewH )
End Function 


Function DrawD3DMesh( m.D3DMesh )
	
	BBSetMaterial( m\mat )
	
	;GenerateWorldMatrix( m )
	;BBSetTransform( 1, retI( D3DMatrices(2) + 4 ) )
	
	GetMatElement( m\mesh, 0, 0 ) ;Fix to avoid hidden meshes' matrices being deactivated. Comment this line to see the effects.
	BBSetEntityTransformMatrix( m\mesh, 0 ) 
		
	BBDrawPrimitive( m\primitiveType, retI( m\surfaceAddress ), m\numVertices, 0 )

End Function


Function InitD3D()
	
	Direct3D7		=	SystemProperty$("Direct3D7")
	Direct3DDevice7	=	SystemProperty$("Direct3DDevice7")
	Direct3DDraw7	=	SystemProperty$("DirectDraw7")
	
	If Direct3D7 = 0 Then RuntimeError( "FATAL ERROR: Unable to access Direct3D device." )
	BBSetSystemControl( Direct3D7, Direct3DDevice7, Direct3DDraw7 )
	
	D3DMatrices( 0 ) = CreateBank( 64 ) ;View
	D3DMatrices( 1 ) = CreateBank( 64 ) ;Proj.
	D3DMatrices( 2 ) = CreateBank( 64 ) ;World
	
End Function


Function CreateD3DMesh.D3DMesh( mesh, r%, g%, b%, primitiveType% = 2 )
	
	Local m.D3DMesh = New D3DMEsh
	
	m\mesh	=	mesh
				MeshCullBox( mesh, -100000, -100000, -100000, 200000, 200000, 200000 )
	
	m\surfaceAddress	=	GetSurface( mesh, 1 ) + 28
	m\numVertices		=	CountVertices( GetSurface( mesh, 1 ) )
	m\primitiveType		=	primitiveType
	
	m\mat.D3DMaterial	=	New D3DMaterial
							m\mat\emissiveColorR = (r / 255.0)
							m\mat\emissiveColorG = (g / 255.0)
							m\mat\emissiveColorB = (b / 255.0)
	Return m
	
End Function 


Function CreateD3DCamera.D3DCamera()
	
	Local c.D3DCamera = New D3DCamera
	c\entity = CreateCamera()
	c\viewX = 0
	c\viewY = 0
	c\viewW = GraphicsWidth()
	c\viewH = GraphicsHeight()
	c\near = 1
	c\far = 1000
	c\zoom = 1
	c\projMode = 1
	
	Return c
	
End Function 


Function D3DCameraProjMode( c.D3DCamera, mode% )
	
	c\projMode = mode
	CameraProjMode( c\entity, mode )
	
End Function


Function D3DCameraZoom( c.D3DCamera, zoom# )
	
	c\zoom = zoom
	CameraZoom( c\entity, zoom )
	
End Function


Function D3DCameraRange( c.D3DCamera, near#, far# )
	
	c\near = near
	c\far = far
	CameraRange( c\entity, near, far )
	
End Function 


Function D3DCameraViewport( c.D3DCamera, x%, y%, width%, height% )
	
	c\viewX# = x
	c\viewY# = y
	c\viewW# = width
	c\viewH# = height
	CameraViewport( c\entity, x, y, width, height )
	
End Function 


Function FreeD3DMesh( m.D3DMesh )

	Delete m\mat
	Delete m
	
End Function


Function FreeD3DCamera( c.D3DCamera )

	FreeEntity c\entity
	Delete c

End Function


Function util_CreateGridMesh( segments#, parent%=0 )
	
	Local mesh = CreateMesh()
	EntityParent( mesh, parent )
	
	Local surf = CreateSurface( mesh )
	
	segments = segments - 1
	Local tempSegment = 0
	
	While ( tempSegment &lt;= segments )
		AddVertex( surf, 0, 0, tempSegment / segments )
		AddVertex( surf, 1, 0, tempSegment / segments )
		
		AddVertex( surf, tempSegment / segments, 0, 0 )
		AddVertex( surf, tempSegment / segments, 0, 1 )
		
		tempSegment = tempSegment + 1
	Wend
	
	PositionMesh( mesh, -0.5, 0, -0.5 )
	Return mesh
	
End Function


Function GenerateWorldMatrix( m.D3DMesh )  
	
	Local bankMatrix% = D3DMatrices( 2 )
	Local index = 0

	For j = 0 To 3
	
		For i = 0 To 2
			PokeFloat( bankMatrix, index, GetMatElement( m\mesh, j, i ) ) : index = index + 4
		Next
		PokeFloat( bankMatrix, index, 0 ) : index = index + 4
	
	Next
	
	PokeFloat( bankMatrix, index-4, 1.0 )
		
End Function


Function GenerateProjectionMatrix( c.D3DCamera )
	
	Local bankMatrix% = D3DMatrices( 1 )
	Local viewRatio# = Float( c\viewH ) / c\viewW

	Local viewWidth# = 2.0 
	Local viewHeight# = 2.0 * viewRatio
	
	Local w#, h#, Q#
	If c\projMode = 1 Then
		w = ( 2.0 * c\near ) / ( viewWidth / c\zoom )
		h = ( 2.0 * c\near ) / ( viewHeight / c\zoom )
		Q = c\far / ( c\far - c\near )		
		PokeFloat( bankMatrix, 44, 1.0 )
		PokeFloat( bankMatrix, 60, 0.0 )
	Else
		w = 2.0 / ( viewWidth / c\zoom )
		h = 2.0 / ( viewHeight / c\zoom )
		Q = 1.0 / ( c\far - c\near )		
		PokeFloat( bankMatrix, 44, 0.0 )
		PokeFloat( bankMatrix, 60, 1.0 )
	EndIf
	
	PokeFloat( bankMatrix, 0, w )
	PokeFloat( bankMatrix, 20, h )
	PokeFloat( bankMatrix, 40, Q )
	PokeFloat( bankMatrix, 56, ( -Q * c\near ) )

End Function


Function GenerateViewMatrix( c.D3DCamera )

	Local nX#, nY#, nZ#
	TFormNormal( 0, 0, 1, c\entity, 0 )
	nX = TFormedX()
	nY = TFormedY()
	nz = TFormedZ()

	Local uX#, uY#, uZ#
	TFormNormal( 1, 0, 0, c\entity, 0 )
	uX = TFormedX()
	uY = TFormedY()
	uZ = TFormedZ()

	Local vX#, vY#, vZ#
	TFormNormal( 0, 1, 0, c\entity, 0 )
	vX = TFormedX()
	vY = TFormedY()
	vZ = TFormedZ()
	
	Local pX#, pY#, pZ#
	Local tempX# = EntityX( c\entity, True )
	Local tempY# = EntityY( c\entity, True )
	Local tempZ# = EntityZ( c\entity, True )
	pX = - DotProduct( uX, uY, uZ, tempX, tempY, tempZ )
	pY = - DotProduct( vX, vY, vZ, tempX, tempY, tempZ )
	pZ = - DotProduct( nX, nY, nZ, tempX, tempY, tempZ )
	
	Local bankMatrix% = D3DMatrices( 0 )
	PokeFloat( bankMatrix, 0, uX ) : PokeFloat( bankMatrix, 4, vX ) : PokeFloat( bankMatrix, 8, nX ); : PokeFloat( bankMatrix, 12, 0 ) 
	PokeFloat( bankMatrix, 16, uY ): PokeFloat( bankMatrix, 20, vY ): PokeFloat( bankMatrix, 24, nY );: PokeFloat( bankMatrix, 28, 0 )
	PokeFloat( bankMatrix, 32, uZ ): PokeFloat( bankMatrix, 36, vZ ): PokeFloat( bankMatrix, 40, nZ );: PokeFloat( bankMatrix, 44, 0 )
	PokeFloat( bankMatrix, 48, pX ): PokeFloat( bankMatrix, 52, pY ): PokeFloat( bankMatrix, 56, pZ ) : PokeFloat( bankMatrix, 60, 1 )
	
End Function


Function DotProduct#( x#, y#, z#, a#, b#, c# )
	Return x*a + y*b + z*c
End Function


End</textarea><br><br>EDIT: Updated the code with orthogonal projection mode for the primitive rendering. <br><br></td></tr></table><br>
<a name="1196853"></a>

<a name="1196854"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have not managed to implement the first approach that i mentionned but the second approach works.<br><br>Very nice render with the dots.<br><br>These renders with lines and dots could be used for a futuristic game, for example, imagine using the render with the dots to display a 3d projection like this <img src="http://www.thereviewcrew.com/wp-content/uploads/2010/11/tony_stark_hologram1-1024x440.jpg"><br><br>Or to display the result of a scan of a terrain or of an object, etc... <br><br></td></tr></table><br>
<a name="1224119"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stevie G&gt;&gt;I want to thank you again for your Line3dTo2d code example. :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
