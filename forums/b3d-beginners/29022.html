<!DOCTYPE html><html lang="en" ><head ><title >The use of TFormVector</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >The use of TFormVector</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >The use of TFormVector</a><br><br>
<a name="306293"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlueWolf</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I just purchased Blitz3D and was looking around the docs at the commands and such. I have begun working on my own little secret project :)<br><br>Well anyway the question<br><br>of what importance is the x,y,z of the vector?<br><br>Thanks <br><br></td></tr></table><br>
<a name="306313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warren</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> x,y,z is what defines the vector ... I guess I'm not sure what your question is.<br><br>TFormVector is used to translate a vector from one space to another.  So from local space to world space, for example. <br><br></td></tr></table><br>
<a name="306332"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) sinu</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> i always use x ie<br><br>tformvector 1,0,1,x,ent1,ent2<br><br>if thats what your asking which gives me the correct results in 3d. <br><br></td></tr></table><br>
<a name="306334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlueWolf</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh okay I think I will try that<br>thanks sinu and EpicBoy <br><br></td></tr></table><br>
<a name="306335"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vectors are used to represent a lot of things.  The direction a vertex points for when you're doing lighting.  The direction a face points, for hidden surface removal.  The speed and direction your objects in your game are moving.  The TFormVector TFormPoint and TFormNormal commands are very powerful and allow you to transform/rotate/scale vectors and points from one space into another.  In other words, when you drive you car, it always moves along IT'S Z axis, but it does not always move along the Z axis of the WORLD.  The car and the world have different coordinate spaces.  All vertex positions for the car are in car space.<br><br>The End. <br><br></td></tr></table><br>
<a name="306347"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlueWolf</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm... this is all rather confusing :)<br>Basically I am trying to use a vector to find the distance between two points. My code looks like this<br><pre class=code> TFormVector par1\oldx,par1\oldy,par\oldz,par1,par2
vx= TFormedX()
vy= TFormedY()
xz= TFormedZ()
delta_length= Sqr(vx*vx)+(vy*vy)+(vz*vz)
</pre><br><br>Where par1 and par2 are the two points I am finding the distance between and vx,vy and vz are the vectors positions. From what I have read here it dosen't look like I am doing it right :/ <br><br></td></tr></table><br>
<a name="306388"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warren</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's entirely the wrong tool for the job.  TFormVector translates a vector from one space to another, it doesn't measure distance the between two entities.<br><br>Check out EntityDistance.  If you don't want to do the calc yourself, just create two pivots at the appropriate locations and do an EntityDistance on them. <br><br></td></tr></table><br>
<a name="306397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlueWolf</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> What would be the right way to go about it then??(without using EntityDistance)<br><br>Thankyou for putting up with my my ignorance :-) <br><br></td></tr></table><br>
<a name="306452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> D# = Sqr((X1#-X2#)*(X1#-X2#) + (Y1#-Y2#)*(Y1#-Y2#) + (Z1#-Z2#)*(Z1#-Z2#))<br><br>That's the fast way.  Use if you're gonna call it a thousand times a frame.<br><br>D# = Sqr((X1#-X2#)^2 + (Y1#-Y2#)^2 + (Z1#-Z2#)^2)<br><br>This is the math way.  X^2 is slower than X*X.  Takes less typing and looks cleaner so use this if you're not calling it often.<br><br>D2# = (X1#-X2#)*(X1#-X2#) + (Y1#-Y2#)*(Y1#-Y2#) + (Z1#-Z2#)*(Z1#-Z2#)<br><br>Use this when you need to simply COMPARE two distances to dtermine if one object is farther away than another, and you intend to make that comparison a thousand times a frame for various objects.  Ie, If (D2a# &gt; D2b#) then object 1 is in front of object 2.<br><br>Note that you can also use this trick of using squared distances to determine if an obejct is farther away than a certain distance.<br><br>If D2# &gt; (Distance*Distance) Then object is greater than distance away from whatever. <br><br></td></tr></table><br>
<a name="306468"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you want some real fps then try this:<br><pre class=code>
global dx#,dy#,dz#,dist#

dx=x1-x2
dy=y1-y2
dz=z1-z2
dist=sqr(dx*dx+dy*dy+dz*dz)
</pre> <br><br></td></tr></table><br>
<a name="306479"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Have you actually benchmarked that to see if it's faster?  Cause it's not always faster to remove redundant calculations.  Especially when the redudancy is an add or a subtract which are very inexpensive operations.  I'm pretty sure I alreay benchmarked that and determined it was not actually an optimization. <br><br></td></tr></table><br>
<a name="306578"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for that distance equation swift :) I think someone should put a post in the tutorials with a list of equations, and their uses :) <br><br></td></tr></table><br>
<a name="306616"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlueWolf</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the equations! <br><br><div class="quote"> I think someone should put a post in the tutorials with a list of equations, and their uses <br></div><br><br>that would be a good idea especially for newbies like me :) <br><br></td></tr></table><br>
<a name="306629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are a billion equations, and the use of many of them is not immediately apparent. :-)<br><br>For example, I could tell you the plane equation, but that would be useless to you if you don't know enough math to find clever ways to make use of it because you don't understand what the equation represents.<br><br>Look in the code archives for Ray Intersect Triangle, a function I wrote, and take a look at the source to that and you'll leanr how to determine if a ray is intersecting a triangle, but also how to use the dot product equation to determine how much a vector points in the same direction as another vector, and how to use the cross product to take two vectors and find a third which is at 90 degrees to them.  (Ie, the normal of a triangle, if given two sides of the triangle for the vectors.)<br><br>And that's just the tip of the iceberg.  I have a whole text file full of various equations which are useful for making games, but right now they're probably too complicated for you to use if you just learned the distance equation. :-) <br><br></td></tr></table><br>
<a name="306632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I mean't just simple one's, such as 2 line interect, distance equation, acceration equations. Sorta basic one. I know a few basic one, but probably not enough to warrant a list :) <br><br></td></tr></table><br>
<a name="306954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AbbaRue</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> sswift:  I sure would like a copy of that text file full of equations. <br><br></td></tr></table><br>
<a name="306973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay.  Here's the file.  Of course I didn't write down every single equation I use in this file. :-)  And there's some discussions I kept between me and some physics/math guys on a few of the more difficult subjects.<br><br><br><br><br><br><br>-------------------------------<br><br>"I wish I could remember the math term for and how to caclulate that sort of comparison. Like if you have 5 vertcies, it's 5+4+3+2+1 which is 15 comparisons."<br><br>- n(n+1)/2 is probably what you are looking for. <br><br>---------------------------------------<br><br> Anyway, here's the logic for the friction force: suppose we've<br>got a surface normal norm = (nx, ny, nz), and a gravity vector<br>running in the y direction grav = (0, 1, 0). We take their vector<br>cross-product to get a "sideways" vector<br><br>sideways = (sx, sy, sz) = (-nz / n, 0, -nx / n)<br><br>...where n = sqrt( nx * nx + nz * nz) is a normalizing factor, to<br>keep 'sideways' of unit length. n is also equal to the sine of the<br>angle between 'norm' and 'grav'.<br><br>Next thing to do is to vector-cross-product 'sideways' with 'norm',<br>thereby getting a unit vector that's in the plane of the surface,<br>going uphill:<br><br>uphill = sideways x norm = (-ny * nx / n, (nz * nz + nx * nx) / n, -ny * nz / n)<br>= (-ny * nx / n, n, -ny * nz / n)<br><br>Now we gotta multiply 'uphill' by the sine of the inclination... which,<br>as I mentioned a few paragraphs ago, happens to be n. So:<br><br>friction_force = uphill * n = (-ny * nx, n^2, -ny * nz)<br>= (-ny * nx, nx * nx + nz * nz, -ny * nz)<br><br>...which means that you can compute the force vector without having to<br>do square roots or other unpleasant forms of math. <br><br><br><br><br>Reducing velocity only in a direction perpendicular to the face collided with:<br>------------------------------------------------------------------------------<br> Assume V is the velocity vector and N is the normal.<br>N is perpendicular to the surface and has length 1.<br>The component of V in the direction of N is given by the dot product.<br><br>If you wanted to reduce velocity by 10% in the N direction then you would subtract:<br><br>V = V - 0.1 * (N dot V) * N ; pseudocode.<br><br>Of course, in Blitz you have to handle the x,y,z components separately:<br><br>Assume dot#, nx#, vx# etc. are all defined.<br><br>dot = nx*vx + ny*vy + nz*vz<br>vx = vx - 0.1*dot*nx<br>vy = vy - 0.1*dot*ny<br>vz = vz - 0.1*dot*nz<br><br><br>(N dot V) * N is the projection of V onto N. <br><br><br>OR..............<br><br><br>Dot# = NX * Item\SpdX + NY * Item\SpdY + NZ * Item\SpdZ<br><br>ReflectX# = NX * Dot#<br><br>ReflectY# = NY * Dot#<br><br>ReflectZ# = NZ * Dot#<br><br><br><br>; 1.0 stops bouncing<br><br>; 2.0 produces a perfect bounce (no loss of energy)<br><br>bounce# = 1.1   ; Retain only 10% of the energy<br><br><br><br>Item\SpdX = Item\SpdX - ReflectX# * bounce#<br><br>Item\SpdY = Item\SpdY - ReflectY# * bounce#<br><br>Item\SpdZ = Item\SpdZ - ReflectZ# * bounce#<br><br><br><br><br>&lt;Polytope&gt; max(|x|,|y|)=r, where max(a,b) = (|a+b|+|a-b|)/2<br>&lt;sswift&gt; if C is less than like 1...<br>&lt;sswift&gt; That would tell you the points to plot.;<br>&lt;PdoX&gt; so you mean, |x| + |y| - |xy| &lt;= 1<br>&lt;Polytope&gt; combine them and you get ||x|+|y||+||x|-|y||=2r<br>&lt;sswift&gt; is there an equation for abs too? :-)<br>&lt;PdoX&gt; |x| = sqrt(x^2)<br>&lt;PdoX&gt; though thats cheating<br><br><br>&lt;PdoX&gt; sswift: When two objects collide with initial energies E_1 and E_2, they end up with final energies E_1' E_2' where E_1 + E_2 = E_1' + E_2' + Q, where Q is the energy lost<br>&lt;PdoX&gt; (energy lost to vibration,etc. everything taken from kinetic energy)<br>&lt;PdoX&gt; For elastic collisions, you have Q=0<br>&lt;PdoX&gt; For inelastic, Q=E_1+E_2 (all)<br>&lt;PdoX&gt; actually, I need to be more careful here..<br>&lt;PdoX&gt; I'm in the Center of mass frame.<br><br><br>Fixed point numbers:<br>--------------------<br>Let's say that your range is [Ra .. Rb]. Ra can be a negative number or a positive number.<br><br>So let's say you want to compress an angle from -180 to +180 in your fixed point representation, and let's say you want to use 2 bytes for your fixed point number. For that we use a value of 65536. (256*256)<br><br><br>Then what you do to convert to fixed point is this:<br><br>FixedNum = ((FloatNum-Float(Ra)) / Float(Rb-Ra)) * 65536.0<br><br><br>And then to convert back you do this:<br><br>FloatNum# = ((Float(FixedNum) / 65536.0) * Float(Rb-Ra)) + Float(Ra)<br><br><br>And THAT will work for any range. Before I made a mistake, and the range always had to start with 0.<br><br>What THIS does is it first shifts the floating point number so it is in the range of 0..(Rb-Ra) So for example with -180 .. 180, RB-Ra is 360. So we get a range of 0..360.<br><br>Then after doing that it's divided by the number of numbers in the range, in this case 360, which scales it down to a number 0..1, THEn that number is multiplied by our fixed point maximum number, which is 65536.0, and we end up with an integer from 0..65536.<br><br>Then on the other end 65536 is converted back to 0..1, and then from there to 0..360, and then from there -180 is added to it which gives us our floating point number in the range of -180..180.<br><br>Don't concern yourself with the MOD stuff, that's only if you want to wrap values, and you can do that to the value before you do this equation.<br><br><br><br><br>Quaternions:<br>------------<br><br>A unit quaternion adheres to the following equation: <br>W^2+X^2+Y^2+Z^2 = 1<br><br><br><br>finding uniform random points around a point on a sphere.<br>---------------------------------------------------------<br>Find a point on the unit sphere:<br>P = (a,b,c)  <br><br>The first step is to find a point N on the unit sphere which is 90 degrees (arc length) away.<br><br>N = (a/sqrt(a^2+b^2) ,  -b/sqrt(a^2+b^2), 0)    <br>will work unless a=b=0.<br><br>now let T = PxN. so P,N,T are at right angles to each other<br><br>now let's see. we want to parameterize the circle of radius r centered at P<br><br>R = P*cos(r) + N*sin(r)*cos(t) + T*sin(r)*sin(t) should work<br><br>pick a random angle t between 0 and 360 and you have a random point in the circle<br><br><br><br>So in sphere space using P(0,0,1) N(0,1,0) T(1,0,0):<br><br><br>r = radius from point at 0,0,1<br>t = random number between 0 and 360<br><br>Rx = sin(r)*sin(t) <br>Ry = sin(r)*cos(t)<br>Rz = cos(r)<br><br><br><br>Radius should be set randonly too.  I think.  I think I can clip radius to create a hole.<br><br><br>Finding UNFORM random points on a sphere:  (Ie: no pole clustering)<br>----------------------------------<br>choose a random angle t and a random number z between -1 and 1, then let r=sqrt(1-z^2), x=r*cos(t), y=r*sin(t).<br>then (x,y,z) is a random point on the sphere<br>(of radius 1, centered at the origin)<br><br><br>OR:<br><br>To generate a random point on the sphere, it is necessary only to generate two random numbers, <br>z between -R and R, <br><br>phi between 0 and 2 pi, each with a uniform distribution<br><br>To find the latitude (theta) of this point, note that z=Rsin(theta), so: <br><br>theta=sin-1(z/R)<br><br>its longitude is phi.<br><br>In rectilinear coordinates:<br><br>x=R*cos(theta)*cos(phi)<br>y=R*cos(theta)*sin(phi)<br>z=R*sin(theta)=z<br><br><br><br>Note that in both methods points will appear to be  clustered if you attempt to step through it.  The lattitude lines become more sparse as the longitude lines become more dense, so random points will be evenly distributed, but if you plot even lonigtude lines it will look wrong.<br><br><br><br>&lt;Polytope&gt; there is an amazing fact, which I don't know how to explain without calculus.<br>&lt;Polytope&gt; if you enclose a sphere in a cylinder (with no top or bottom) then the sphere and the cylinder have the same surface area.<br>&lt;Polytope&gt; moreover,if you project from the cylinder to the sphere, towards the axis of the cylinder, then this projection preserves area.<br>&lt;Polytope&gt; so, to choose random points on a sphere, you can just choose random points on a vertical cylinder, then project the points horizontally to the sphere.<br>&lt;monochrom&gt; The height of the cylinder is the diameter of the sphere, right?<br>&lt;Polytope&gt; monochrom: yes<br>&lt;Polytope&gt; archimedes discovered this somehow, waay before calculus. this is astonishing to me<br><br><br><br>---------------------------<br><br>"The extra 1m/s is therefore stored like a battery in form of kinetic energy in the object. If it would go upwards while it has the energy stored, it would use up that energy until the kinetic "battery" is used up."<br><br><br>Hm... that gives me an idea...  <br><br>The correct way to model a ball would be to deform it when it hits the ground, and then undeform it over a period of time pushing it against the ground... This way the ball would actually be in contact with the ground much more often cause as it deforms it deforms downward maintaining contact with the ground.<br><br>In my current system the ball doesn't deform.  When it hits the gorund it instantly changes direction and loses contact with the ground.  This means that ground friction is only applied for a split second.<br><br>Of course, it seems odd to consider applying ground friction for an object moving in a direction away from the ground.  You usually think of ground friction like ab object being slid over sandpaper.  It doesn't make sense for it to affect the ball when it simply bounces straight up and down on the sandpaper, even if it's only doing it for a split second.<br><br><br>So I wonder if perhaps the physics which I am using is far too simplified.  But these are the physics they teach in high school and all over the web!  Why are they teaching stuff that's wrong?<br><br><br>I think maybe my idea about applying certain forces to certain "axis" would work.  <br><br>For example, the ground friction would be applied only to forces in the XZ axis relative to the normal of the surface collided with.  IE, a sliding force along the surface would be damped, but vertical forces, (vertical relative to the normal of the surface that is) would not.<br><br>If I went that route then I could apply a seprate model to forces which lie on the Y axis relative to the surface normal.  So the "downward" force (downward realtive to the surface normal) when the ball hits the surface, would be cut by 50% on the rebound but the velocity on the XZ plane would remain untouched by the damping force.<br><br><br>Then, if I combine that with the idea about deforming the ball, so that the ball stays in constant contact with the plane if it is rolling along it, and stays in contact much longer when it collides at a shallow angle to it an ounces back up...  If I do that, then ground friction should be modeled more accurately and more consistently on systems which calculate the physics at diffrent speeds! :-)<br><br><br><br><br><br>--------- <br><br><br><br>quaterion is four numbers. One of them is w.<br>The other three are x,y,z which give a vector ( axis ) around which to rotate.<br>w is the cosine of half the angle of rotation.<br><br><br><br>Dtermining if two line segments intersect:<br>------------------------------------------<br><br>Let A,B,C,D be 2-space position vectors.  Then the directed line segments AB &amp; CD are given by:<br><br>        AB=A+r(B-A), r in [0,1]<br>        CD=C+s(D-C), s in [0,1]<br><br>If AB &amp; CD intersect, then<br><br>        A+r(B-A)=C+s(D-C), or<br><br>        Ax+r(Bx-Ax)=Cx+s(Dx-Cx)<br>        Ay+r(By-Ay)=Cy+s(Dy-Cy)  for some r,s in [0,1]<br><br>Solving the above for r and s yields<br><br>            (Ay-Cy)(Dx-Cx)-(Ax-Cx)(Dy-Cy)<br>        r = -----------------------------  (eqn 1)<br>            (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)<br><br>            (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)<br>        s = -----------------------------  (eqn 2)<br>            (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)<br><br>Let P be the position vector of the intersection point, then<br><br>        P=A+r(B-A) or<br><br>        Px=Ax+r(Bx-Ax)<br>        Py=Ay+r(By-Ay)<br><br>By examining the values of r &amp; s, you can also determine some other limiting conditions:<br><br>        If 0&lt;=r&lt;=1 &amp; 0&lt;=s&lt;=1, intersection exists<br>            r&lt;0 or r&gt;1 or s&lt;0 or s&gt;1 line segments do not intersect<br><br>    * If the denominator in eqn 1 is zero, AB &amp; CD are parallel<br><br>    * If the numerator in eqn 1 is also zero, AB &amp; CD are coincident<br><br>If the intersection point of the 2 lines are needed (lines in this context mean infinite lines) regardless whether the two line segments intersect, then<br><br>    * If r&gt;1, P is located on extension of AB<br>    * If r&lt;0, P is located on extension of BA<br>    * If s&gt;1, P is located on extension of CD<br>    * If s&lt;0, P is located on extension of DC<br><br>Also note that the denominators of eqn 1 &amp; 2 are identical.<br><br><br><br><br>Plane equation and Sphere/Frustum Intersection Tests<br>----------------------------<br><br>Ax + By + Cz = D<br><br>    A = y1 (z2 - z3) + y2 (z3 - z1) + y3 (z1 - z2)<br>    B = z1 (x2 - x3) + z2 (x3 - x1) + z3 (x1 - x2)<br>    C = x1 (y2 - y3) + x2 (y3 - y1) + x3 (y1 - y2)<br>- D = x1 (y2 z3 - y3 z2) + x2 (y3 z1 - y1 z3) + x3 (y1 z2 - y2 z1)<br><br><br><br>We'll need to figure out the plane equation for each one of those six planes:<br><br>A*x + B*y + C*z + D = 0<br><br><br>...that plane equation calculation can be done one-time whenever the view frustum is set up.<br><br>Note that for an arbitary point (px,py,pz), the distance to the plane is:<br><br>d = A*px + B*py + C*pz + D<br><br><br>...so for each vertex of your bounding volume, you can measure the distance to each of those planes.<br><br>For a sphere: Just toss the center point of the sphere into the equation above - and if the (signed) distance places the center point more than 'radius' units outside any of the planes then you can cull the object.<br><br><br><br>* In the plane equation mentioned above, (A,B,C) is the surface normal of the plane and D is the distance from the origin to the plane - measured such that D is positive for planes that face the origin and negative from those that don't.<br><br><br><br>------------------<br><br><br><br>Diffuse and phong lighting:<br><br><br>                  ^N<br>		  |<br>	    Lÿÿÿ  |     R        V<br>	     \ÿÿ  |    /      __/<br>	      \ÿ  |   /    __/<br>	       \  |  /  __/<br>		\ | /__/<br>		 \|//<br>     -------------.--------------<br>		  P<br>		  ^<br>		  point under consideration<br><br><br>  It's important you know what these values actually are:<br><br>  N	= surface normal<br>  L     = unit vector between point and light<br>  V	= unit vector between point and view<br>  R     = light reflection unit vector (mirror of L about N)<br><br><br>  First, the diffuse relfection is given by the Lamertian Relfection<br>  equation:<br><br>    diffuse = Kd * (N dot L)<br><br>  Where Kd is the diffuse relfection constant. (N dot L) is the same as<br>  the cosine of the angle between N and L, so as the angle decrease, the<br>  resulting diffuse value is higher.<br><br>  Phong gave spectral reflectivity as:<br><br>    diffuse + Ks * (R dot V)^n<br><br><br><br>other source:<br><br> lambert's "the light is dependant on the angle it hits the surface" law.<br>Use the dotproduct to get that value. <br><br>Angle = Dotproduct( Normal, vLightVector );<br><br>If Angle is negative then the light doesn't reach the point, otherwise use the<br>Angle multiplied with the light's color as the diffuse component. Oh, by the way,<br>colors are in the range [0.0, 1.0].<br><br><br><br><br><br><br>How to calculate the new vector of a ball which has struck a wall.<br>(Also the normal force?)<br>------------------------------------------------------------------<br><br>v = v - 2*n*(v . n)<br> <br><br><br>(v . n = dot product of v and n... see below.)<br><br><br><br>Dot product of two vectors:<br>---------------------------<br>AdotB = ax*bx + ay*by + az*bz<br><br><br><br>Air Friction:<br>-------------<br><br>Here's how to compute air friction:<br><br>air_friction_force = air_friction_constant * vehicle_velocity^2<br><br>A good air friction constant might be 0.2<br><br>Then:<br><br>new_velocity = old_velocity - air_friction_force * time<br><br><br><br><br><br>---------------------------------------------------------------------------------------------------------------<br>The "normal force" - How to make an object "richochet" off a surface, or move downhill when pulled by gravity.<br>---------------------------------------------------------------------------------------------------------------<br><br>When an object impacts a surface, whether it is fired from a cannon, or is simply being pulled downwards by <br>gravity, a "normal force" is generated which is equal in strength to the forces which were acting on the object<br>when it hit.<br><br>This "normal force" (NF for short), is ALWAYS perpendicular the the surface.<br><br>Making pool balls bounce off bumpers and making a ball roll down a hill is done in the same way, and is very <br>simple to do.<br><br>All you have to do is find the velocity vector of the ball when it hit.  In other words, add up the forces acting on it, like gravity, and the force applied to it when it was fired from the cannon.<br><br>Then when the ball hits the surface, calclulate a vector which is perpendicular to the surface, and which has the same magnitude as the forces which were acting on the ball at that moment, and add theforce vector of the ball to the normal force... The result will be a vactor which points in the expected direction.<br><br>For example, if you have a flat section of land, the normal force is straight up.  And the force acting on the ball, gravity, points straight down.  When you add them, they cancel eachother out exactly and the ball doesn't move at all, just as you'd expect.<br><br>If on the other hand the ball is rolling across the surface in addition to being pulled down by gravity, then the ball will continue to roll across the surface, but will still not move downwards at all.<br><br>Now if you have a hill, then the normal force points away from the hill... not straight up like on the flat plane example.  So when you add the NF to the gravity acting on the ball, the result is a vector which points down the hill... so the ball rolls down the hill as expected!<br><br><br><br>-----------------------------------------------------<br>Finding the closest point on a line to another point.<br>-----------------------------------------------------<br>(x1, y1, z1), (x2, y2, z2) = ends of line segment<br>(x3, y3, y3) = point<br><br><br>u =<br><br>(x3 - x1)(x2 - x1) + (y3 - y1)(y2 - y1) + (z3 - z1)(z2 - z1)<br>-----------------------------------------------------------<br>(x2 - x1)(x2 - x1) + (y2 - y1)(y2 - y1) + (z2 - z1)(z2 - z1)<br><br><br><br>u = the location between the two end points of the line which is closest to the point.<br><br>If u is not between 0 and 1 then the closest point is not between P1 and P2<br><br><br>----------------------------<br>LINE-SPHERE-INTERSECTION<br>----------------------------<br><br>To find out if a line intersects a sphere, find the closest point on the line to the center of the sphere.<br>Then calculate the location of that point using U.<br>And finally, find out the if the distance from that point to the center of the sphere is less than the radius of the sphere.<br><br><br><br>------------------<br>DEGREES TO RADIANS<br>------------------<br><br>R = D * (Pi / 180)<br><br><br>------------------<br>RADIANS TO DEGREES<br>------------------<br><br>D = R * 180/pi <br><br><br>--------------------------------------------------------------<br>The angle to change a wheel for movement over a given distance.<br>--------------------------------------------------------------<br><br>A = angle in radians <br>R = Radius of wheel<br>D= Distance moved<br><br>D = R * A<br><br>A = D/R<br><br><br>-----------<br>SOUND<br>-----------<br><br>Volume = the volume of the sound.<br><br>MinDist =<br>The distance at which the sound is at 100% volume.  The sound will not get any louder closer than this.<br>This has a big effect on how quickly the sound falls off.  Since the sound card cannot make sounds that are extemely loud, it's probably best to set this value to around 1 meter, in your game units.  Ie, 64, if 64 units equals a meter in your game.<br>          <br>SoundDistance = The distance to the sound.<br><br>maxvolume = the maximum volume of your sound.<br><br>Volume = (MinDist^2 * MaxVolume) / (SoundDistance + MinDist)^2<br><br><br>-----------<br>DISTANCE<br>-----------<br>dist = sqrt( (x1 - x2)^2  + (y1 - y2)^2  + (z1 - z2)^2 )<br><br>-------------<br>CIRCUMFERENCE<br>-------------<br>C = 2PiR<br><br>Circumfurence = 2 * Pi * Radius<br><br><br>--------<br>MOMENTUM<br>--------<br>P=MV  <br><br>Momentum = Mass x Velocity<br><br><br>------------------------------<br>POINT BETWEEN TWO OTHER POINTS<br>------------------------------<br>CX = AX + D * (BX-AX)   <br>CY = AY + D * (BY-AY)<br><br>D = Distance 0 .. 1<br>(AX,AY)(BX,BY) = Endpoints of line segment AB.<br><br><br>------------------------------------------<br>POLAR COORDINATES TO CARTESIAN COORDINATES<br>------------------------------------------<br>X = Radius * Cos(Theta)<br>Y = Radius * Sin(Theta)<br><br>Converts polar coordinates into cartesian coordinates.  Drawing a pixel at X,Y for Theta 0..360 at a fixed radius would draw a circle.<br><br>------------------------------------------<br>Angle of a point from 0,0<br>------------------------------------------<br>Angle = ARCSIN(Y/R)<br>or<br>Angle = ARCCOS(X/R)<br><br>------------<br>NORMAL FORCE<br>------------<br>Fn = Fg * Cos(Theta)<br><br>If on a slope, <br>Fn = Normal Force<br>Fg = Force of gravity<br>Theta = Angle of the slope<br><br>The normal force is the force perpendicular to the angle of the slope, which needs to be added to the <br>force of gravity to determine how much accleration from gravity will actually affect the object.<br><br><br>-----------------------------------<br>CONVERTING A FORCE INTO XYZ VECTORS <br>-----------------------------------<br>Mxz = M * Cos(Ty)<br>Fy = M * Sin(Ty)<br>Fx = Mxz * Cos(Txz)<br>Fz = Mxz * Sin(Txz)<br><br>This equation converts a vector described in the polar coordinate system to one in the cartesian coordinate system.<br>The force is described with a magnitude (M) and two angles, an inclination (Ty) and a direction (Txz) on the XZ plane.<br><br>Fx, Fy, and Fz are the resulting forces on each axis.<br><br><br>------------------------------<br>CALCULATING THE CENTER OF MASS<br>------------------------------<br><br>Total_Mass = (mass1 + mass2 + ...)<br><br>x3 = (mass1*x1 + mass2*x2 + ...) / Total_Mass<br>y3 = (mass1*y1 + mass2*y2 + ...) / Total_Mass<br>z3 = (mass1*z1 + mass2*z2 + ...) / Total_Mass<br><br>Calculates a scaled average of the locations so that the center is closest to the more massive objects.<br><br>--------------------------------------------<br>CALCULATING THE CROSS-PRODUCT OF TWO VECTORS<br>--------------------------------------------<br><br>v and w are two vectors in 3-dimensional space<br><br>v x w (read "v cross w") is a vector whose magnitude is the product of the magnitudes of v and w, that is perpendicular to both v and w, and whose direction is given by the right-hand rule.<br><br>To compute a cross-product, usually what you end up doing is computing a determinant.  Write a 3x3 matrix with the first row being the components of v, the second row being the components of w, and the third row being the unit vectors, i j k.  The determinant of that is the cross-product of v and w<br><br>abc = xyz force 1<br>def = xyz force 2<br><br>(a,b,c) * (d,e,f) = (bf-ce, cd-af, ae-bd)<br><br>------<br>TORQUE<br>------<br><br>The torque generated by a force on a system is given by r x F.<br><br>r = The position vector of the point where the force is applied relatively to the center of mass.<br>F = A force vector.<br><br>r = (a,b,c)<br>F = (d,e,f) <br><br>T_F = (bf-ce, cd-af, ae-bd)<br><br>T_F is the torque generated by F.<br><br>So you compute the torques generated by all forces<br>you sum them (vector sum) and then you divide the resulting vector by the "moment of inertia"<br><br>"moment of intertia":<br>it's a measure of the system's "resistance" to rotation, if you want<br>it's a function of the point masses and their distance from the center of mass<br><br><br>are your "rods" mass-less?<br>then you just need to sum up m_i * r_i^2, i *think*<br>where m_i is a point mass, and r_i is its distance from the center of mass<br>divide the sum of torques by that quantity, and that's the angular acceleration vector<br>so if you have 2 objects, one with mass 1kg at 2 meters, and another with mass 2kg at 3 meters, the unnamed quantity is 1*2^2 + 2*3^2 = 22<br><br><br>to get the linear acceleration of a point from that, you compute (angular acceleration) x r<br>where r is the position vector of a point relative to the center of mass<br>x denotes a cross-product, again<br><br><br><br> the angular acceleration is a global measure of the rotational acceleration of the system<br>but, something close to the center of mass accelerates less (linearly) than something far from it<br> you take the A x r cross-product to take that into account<br> A x r will give you an acceleration vector, which you can add to the acceleration vector resulting from the sum of forces (which we computed a while ago)<br>the sum of those two is the acceleration of an individual point in the system<br><br><br>acceleration of system's center of mass = sum of forces / mass of system<br><br>--------<br>SPRINGS<br>--------<br><br><a href="http://www.pcug.org.au/~apurdam/doublespring/doublespring.html" target="_blank">http://www.pcug.org.au/~apurdam/doublespring/doublespring.html</a><br>two masses, connected by one spring:<br><br>M1, M2 = masses<br>k = coefficient of stiffness of the spring<br>x1, x2 = the displacements of the masses from their positions of equilibrium<br>x1'', x2'' = the acceleration for M1 and M2<br>r = viscous damping<br>x1', x2' = velocity of masses (from previous frame?)<br><br>x1''= k / (M1*(x2-x1)) - r*x1'<br>x2''= k / (M2*(x1-x2)) - r*x2'<br><br><br><br>misc notes:<br><br>Logarithmic Impulse formula.<br>Impulse  = Log(RestSpan) - Log(CurrentSpan)  <br><br>Note: this is a different from the usual linear spring formula which is taught in physics classes.  With the logarithmic formula, it should be impossible to completely compress the spring.  It also means that springs that have long rest lengths vibrate much slower than short ones.  <br><br><br>---------<br>Jet thrust against atmosphere<br>---------<br><br>throtte = 0..1<br><br>thrust = throttle * max( max_thrust * (max_height - height) / max_height, 0)<br><br><br>------------------------------------------------------------------------<br>Only allowing velocity along a specific axis or in a specific diredction<br>------------------------------------------------------------------------<br><br>If you have a vehicle like a hovercraft, then it's okay to allow the hovercraft to have inertia and slide<br>around in any direction.  But if you have a wheeled vehicle, or a tank, then you won't want the vehicle to slide<br>sideways if it's on an incline... you only want it to be able to roll forward or backward.<br><br>This is pretty easy to fix.  <br><br>Take your vehicle's momentum which you've just calculated by adding it's moemntum from the previous frame and adding the forces acting on the vehicle, and convert it into an angle and a magnitude.  A = The angle, B = the magnitude.<br><br>C = The angle your tank is facing.  Note that this can be totally diffrent from the angle the tank is trying to move in.<br><br>Now do the following calculation:<br><br>D = A-C<br><br>D is the angle of your momentum vector if it were translated into a space where A = 0... where your tank is facing along the X axis.<br><br>Now, create a new vector... where D is it's angle, and B is it's magnitude.  <br><br>Next, convert the vector into X and Y components.  Then discard the Y component of the velocty, because that doesn't lie on the axis the tank can roll along.  The value you have remaining, X, is the amount of velcoity which is along the axis the tank can move along.<br><br>Finally, use X as your magnitude, and C (your tanks face driection) as your angle.  That is your tank's new momentum vector.  Convert it into X and Y components if need be.<br><br>Note that you only want to do this sort of thing when your tank is on the ground.  And you might want to do some aditional calculations... for example, your tank might be able to move along the Y axis, but there might be a lot of friction if it does so.  So if you tank is moving sideways through the air fast, when it lands, you might want it to slide a bit before coming to a stop.  If you give that axis a lot of friction and add the remaining velcoity to the forwar dmomentum then you can allow for that.<br><br><br><br><br><br><br><br>Bresenham's lines drawing algorithm:<br><br><br>    public void lineBresenham(int x0, int y0, int x1, int y1, Color color)<br>    {<br>        int pix = color.getRGB();<br>        int dy = y1 - y0;<br>        int dx = x1 - x0;<br>        int stepx, stepy;<br><br>        if (dy &lt; 0) { dy = -dy;  stepy = -1; } else { stepy = 1; }<br>        if (dx &lt; 0) { dx = -dx;  stepx = -1; } else { stepx = 1; }<br>        dy &lt;&lt;= 1;                                                  // dy is now 2*dy<br>        dx &lt;&lt;= 1;                                                  // dx is now 2*dx<br><br>        raster.setPixel(pix, x0, y0);<br>        if (dx &gt; dy) {<br>            int fraction = dy - (dx &gt;&gt; 1);                         // same as 2*dy - dx<br>            while (x0 != x1) {<br>                if (fraction &gt;= 0) {<br>                    y0 += stepy;<br>                    fraction -= dx;                                // same as fraction -= 2*dx<br>                }<br>                x0 += stepx;<br>                fraction += dy;                                    // same as fraction -= 2*dy<br>                raster.setPixel(pix, x0, y0);<br>            }<br>        } else {<br>            int fraction = dx - (dy &gt;&gt; 1);<br>            while (y0 != y1) {<br>                if (fraction &gt;= 0) {<br>                    x0 += stepx;<br>                    fraction -= dy;<br>                }<br>                y0 += stepy;<br>                fraction += dx;<br>                raster.setPixel(pix, x0, y0);<br>            }<br>        }<br>    }<br><br><br><br><br>Lighting:<br><br>&lt;Jaia&gt; 1/x^2 is all nice and good<br>&lt;Jaia&gt; but there are 2 problems<br>&lt;Jaia&gt; first it blows up at the source, x=0<br>&lt;Jaia&gt; so we must start at some small but non-0 x<br>&lt;Jaia&gt; 2nd it never quite hits 0 though it gets close<br>&lt;Jaia&gt; so we must modify it a bit<br>&lt;Jaia&gt; the distance we need to get to is R<br>&lt;sswift&gt; So lets say I wanted the version that blows up... how would I do that, just for the sake of argument?<br>&lt;Jaia&gt; well you can use it directly B(x) = 1/x^2<br>&lt;Jaia&gt; but the 2 problems remain<br>&lt;Jaia&gt; near x=0 it blows up<br>&lt;sswift&gt; Cause I can make 0 distance a special case, and clamp the value to 255.<br>&lt;Jaia&gt; that's no good<br>&lt;sswift&gt; But that doesn't take R into account<br>&lt;Jaia&gt; since for x small but non0 it gets arbitrarily high<br>&lt;Jaia&gt; so simple claming is not a good idea<br>&lt;Jaia&gt; well we need to take R into account<br>&lt;Jaia&gt; this relates to the 2nd problem<br>&lt;Jaia&gt; basically R sets our scale<br>&lt;Jaia&gt; so really x/R is what is important here<br>&lt;Jaia&gt; x/R is 'normalised', it goes from 0 to 1<br>&lt;sswift&gt; I know someone gave me a simpler equation a long time ago which created an expoential curve between two points...<br>&lt;sswift&gt; I used it to make craters.<br>&lt;Jaia&gt; do you want exponential or 1/x^2?<br>&lt;Jaia&gt; they are quite different<br>&lt;sswift&gt; They are?<br>&lt;sswift&gt; :-)<br>&lt;sswift&gt; I tohught light fell off expoentially.<br>&lt;Jaia&gt; yes<br>&lt;Jaia&gt; e^(-x) is finite at x=0<br>&lt;Jaia&gt; and decays must more rapidly<br>&lt;Jaia&gt; 1/x^2 is a more accurate model<br>&lt;sswift&gt; And you know this how? :-)<br>&lt;Jaia&gt; since as you propagate the area of the spherical fronts of the light wave<br>&lt;Jaia&gt; goes as x^2<br>&lt;sswift&gt; You know about lighting? :-)<br>&lt;Jaia&gt; so the light intensity goes as 1/x^2<br>&lt;Jaia&gt; it's an area so it goes as ~ x^2<br>&lt;Jaia&gt; so we want the inverse of that<br>&lt;Jaia&gt; (with some constant of course but we care about overall dependence)<br>&lt;Jaia&gt; here is something you can do<br>&lt;Jaia&gt; x/R goes from 0 to 1<br>&lt;Jaia&gt; so let's split it into 100<br>&lt;Jaia&gt; x/100R<br>&lt;Jaia&gt; this is our tick mark<br>&lt;Jaia&gt; i mean, R/100<br>&lt;Jaia&gt; so we have something like<br>&lt;Jaia&gt; (R/100)^2 / (x + R/100)^2<br>&lt;Jaia&gt; notice this is equal to 1 at x=0<br>&lt;Jaia&gt; and then fall off as the inverse square as we want<br>&lt;Jaia&gt; so all it remains is to multiply by 255<br>&lt;Jaia&gt; 255(R/100)^2 / (x + R/100)^2<br>&lt;Jaia&gt; so at x=0 the value is 255 as desired and it will fall off in the desired way<br>&lt;sswift&gt; okay<br>&lt;Jaia&gt; at x=R we have 255/(101)^2 &lt;&lt; 1<br>&lt;Jaia&gt; which is quite small<br>&lt;Jaia&gt; basically the tick mark is R/100<br>&lt;Jaia&gt; we have 100 of these to get to R<br>&lt;Jaia&gt; each time i double the tick marks, i quarter the intesity, etc.<br>&lt;sswift&gt; So what's better or worse aobut this question than the other one you gave me?<br>&lt;sswift&gt; equation<br>&lt;Jaia&gt; well ... this one is slightly more accurate<br>&lt;Jaia&gt; the other one was exactly 0 at x=R<br>&lt;Jaia&gt; but at the expense of bending the 1/x^2 falling off rate a bit<br>&lt;Jaia&gt; to push it down enough<br>&lt;sswift&gt; If it's below 1 at R, then it'll be clamped cause I have integers.<br>&lt;Jaia&gt; but here it's so small at x=R it's totally fine<br>&lt;sswift&gt; So...<br>&lt;sswift&gt; this 100 bit...<br>&lt;Jaia&gt; 255(R/5)^2 / (x + R/5)^2<br>&lt;Jaia&gt; use that then<br>&lt;sswift&gt; Does it matter at all what that number is&gt;<br>&lt;Jaia&gt; this is enough<br>&lt;Jaia&gt; no no ...<br>&lt;Jaia&gt; 255(R/20)^2 / (x + R/20)^2<br>&lt;Jaia&gt; yes<br>&lt;Jaia&gt; 255/(number+1)^2 is the value at x=R<br>&lt;Jaia&gt; so i use 20<br>&lt;Jaia&gt; 255/(21^2) &lt; 255/400 &lt; 0.5<br>&lt;Jaia&gt; so we're ok<br>&lt;Jaia&gt; 255/(21^2) &lt; 255/400 &lt; 0.8<br>&lt;Jaia&gt; anyway<br>&lt;sswift&gt; So....<br>&lt;sswift&gt; What if I use a really large number there?<br>&lt;sswift&gt; That would mnake it more accurate?<br>&lt;sswift&gt; closer to 0?<br>&lt;Jaia&gt; no, not really ...<br>&lt;Jaia&gt; this is a little bit cheating<br>&lt;Jaia&gt; the requirement that it's "negligible" at x=R is somewhat artificial<br>&lt;Jaia&gt; and not precise<br>&lt;Jaia&gt; it's very vague in fact<br>&lt;Jaia&gt; the most sensible thing to do i think, without any other info<br>&lt;sswift&gt; Will it change the visible appearance of the lighting in any way?<br>&lt;Jaia&gt; is to make it just barely small enough at x=R<br>&lt;Jaia&gt; oh yes<br>&lt;sswift&gt; How so?<br>&lt;Jaia&gt; if you make that number huge<br>&lt;Jaia&gt; it will drop off immediately<br>&lt;Jaia&gt; near the source<br>&lt;sswift&gt; oh<br>&lt;Jaia&gt; and will be almost 0 throughout the whole range from 0 to R<br>&lt;Jaia&gt; that's like pushing R very far off<br>&lt;Jaia&gt; so that the tail of 1/x^2 is very small<br>&lt;Jaia&gt; i would make the tail just barely small enough at x=R<br>&lt;Jaia&gt; just below 1<br>&lt;Jaia&gt; so it fits your requirement<br>&lt;Jaia&gt; but still shows decay over the range<br>&lt;sswift&gt; That sounds like in my crater simulation... I could increase the exponent to ^3 ^4... and that would push the crater wall off into the distance.<br>&lt;Jaia&gt; without dying too quickly<br>&lt;Jaia&gt; and being uninteresting<br>&lt;Jaia&gt; right<br>&lt;Jaia&gt; 20 might be ok<br>&lt;Jaia&gt; 255(R/20)^2 / (x + R/20)^2<br>&lt;Jaia&gt; this is saying "R is quite far, but not extremely far so that most of the range the intensity is tiny"<br>&lt;sswift&gt; Okay<br>&lt;sswift&gt; I think I understand.  If I have a problem I can tweak it to get it to look right by increasing ro decreasing that value.<br>&lt;Jaia&gt; to give you an idea<br>&lt;Jaia&gt; look at the value at x = R/2<br>&lt;Jaia&gt; halfway<br>&lt;Jaia&gt; it will be 255/(11)^2 = 255/121 ~ 2<br>&lt;Jaia&gt; from 255 to 2 halfway<br>&lt;Jaia&gt; this is a good check to see if it fits what you want<br>&lt;Jaia&gt; whatever c you pick<br>&lt;Jaia&gt; 255(R/N)^2 / (x + R/N)^2<br>&lt;Jaia&gt; N rather<br>&lt;Jaia&gt; for x=0 it's always 255<br>&lt;Jaia&gt; for x=R/2 it's 255/(N/2 + 1)^2<br>&lt;Jaia&gt; and for x=R it's 255/(N+1)^1<br>&lt;Jaia&gt; and for x=R it's 255/(N+1)^2<br>&lt;Jaia&gt; so this should give you a good idea<br>&lt;sswift&gt; The lightness will drop to 2 halfway to R with a value of R/2?<br>&lt;Jaia&gt; from 255 to 2<br>&lt;Jaia&gt; as you go from 0 to R/2<br>&lt;Jaia&gt; (on your way to R)<br>&lt;Jaia&gt; if that seems too low, drop N a bit<br>&lt;Jaia&gt; to 16 say<br>&lt;sswift&gt; Tht's increasing N. :-)<br>&lt;sswift&gt; Okay<br>&lt;Jaia&gt; then at x=R it's 255/17^2 = 255/289 &lt; 1<br><br><br>The Attenuation Function<br><br>1 / ( c0 + c1 * d + c2 * d * d )<br><br>*By Setting the constants c0, c1 &amp; c2, you can<br>adjust the falloff ramp of the light<br>*Setting c1 = 0, c2 &gt; 0 will give you a radial<br>distance squared falloff<br>*Setting c1 &gt; 0, c2 = 0 gives a linear falloff<br>*Attenuation denominators less than one will give<br>very large factors, thus making the light too<br>bright close up<br>*To avoid this, make sure c0 is set To some<br>positive number, 1 Or greater<br><br><br><br>&lt;Jaia&gt; 1/(x^2 + c)<br>&lt;sswift&gt; what is C<br>&lt;Jaia&gt; well, let's see<br>&lt;Jaia&gt; at x=0 we get 1/c<br>&lt;Jaia&gt; so we'll add another constant d<br>&lt;Jaia&gt; d/(x^2 + c)<br>&lt;Jaia&gt; d/c = 255<br>&lt;Jaia&gt; so x is given in the same units as R is?<br>&lt;sswift&gt; yes<br>&lt;Jaia&gt; ok<br>&lt;Jaia&gt; d/(x^2/R^2 + c)<br>&lt;Jaia&gt; at x=R we'll set it to 1<br>&lt;Jaia&gt; d/(1+c) = 1<br>&lt;Jaia&gt; d = 1+c<br>&lt;Jaia&gt; 255c = 1+c<br>&lt;Jaia&gt; c = 1/254<br>&lt;Jaia&gt; d = 255/254<br>&lt;Jaia&gt; change the value of d/(1+c) if you want<br>&lt;Jaia&gt; this is the value at x=R<br>&lt;Jaia&gt; d/c=255 is fixed<br>&lt;Jaia&gt; d/(1+c) is the final value, play with it if d/(1+c) = 1 seems no good<br>&lt;Jaia&gt; so we get as an idea<br>&lt;Jaia&gt; (255/254) / (x^2/R^2 + 1/254)<br>&lt;sswift&gt; Is that it?<br>&lt;sswift&gt; :-)<br>&lt;Jaia&gt; yup<br>&lt;Jaia&gt; play with d/(1+c) as i said<br>&lt;Jaia&gt; (you always have d/c = 255)<br>&lt;Jaia&gt; d/(x^2 + c) is our general rule<br>&lt;Jaia&gt; d/(1+c) gives the value of intensity at R<br>&lt;Jaia&gt; i set it to 1 here<br>&lt;Jaia&gt; (255/254) / (x^2/R^2 + 1/254)<br>&lt;Jaia&gt; and got that<br><br>&lt;Jaia&gt; and got that<br>&lt;sswift&gt; Why did you not set it to 0?<br>&lt;Jaia&gt; you can't<br>&lt;Jaia&gt; this function is never 0<br>&lt;Jaia&gt; d/(1+c) = 0<br>&lt;Jaia&gt; d = 0<br>&lt;Jaia&gt; oops<br>&lt;Jaia&gt; and besides<br>&lt;Jaia&gt; make it too small<br>&lt;Jaia&gt; will push out R too far<br>&lt;Jaia&gt; effectively speaking<br>&lt;Jaia&gt; as we discussed before<br>&lt;sswift&gt; hm...<br>&lt;Jaia&gt; your inensity will die out immediately<br>&lt;Jaia&gt; and be tiny for most of the range<br>&lt;sswift&gt; Could you perhaps make the range start at 256, go to 1, and then subtract 1 from the end result?<br>&lt;Jaia&gt; if you want<br>&lt;Jaia&gt; sure<br>&lt;sswift&gt; Is there anyhtign bad about that?<br>&lt;Jaia&gt; (256/255) / (x^2/R^2 + 1/255) - 1<br>&lt;Jaia&gt; not at all<br>&lt;Jaia&gt; in fact it's a good idea<br>&lt;sswift&gt; (256/255) / (x^2/r^2 + 1/255)  - 1<br>&lt;sswift&gt; You typed it first<br>&lt;sswift&gt; :-)<br>&lt;Jaia&gt; that looks ok<br>&lt;sswift&gt; at least I know I was right<br>&lt;Jaia&gt; in general<br>&lt;Jaia&gt; d / (x^2/R^2 + c) - d/(1+c)<br>&lt;Jaia&gt; d/(1+c) is what your value at R would have been<br>&lt;Jaia&gt; so it will be useful to see how far you're pushing R<br>&lt;Jaia&gt; as before<br><br><br><br><br>&lt;Jaia&gt; 256c / (x^2/R^2 + 1/255) - 256c/(1+c)<br>&lt;Jaia&gt; c is our free parameter<br>&lt;Jaia&gt; the last term, 256c/(1+c) sets the scale<br>&lt;Jaia&gt; is it's much less than 1, it probably dies too quickly<br>&lt;Jaia&gt; i'd keep it around 1 or 2 or so<br>&lt;Jaia&gt; but maybe higher even<br>&lt;Jaia&gt; play with it<br>&lt;Jaia&gt; in all cases the value at R is 0<br>&lt;Jaia&gt; oh no ...<br>&lt;Jaia&gt; ack<br>&lt;Jaia&gt; d / (x^2/R^2 + c) - d/(1+c)<br>&lt;sswift&gt; ack what<br>&lt;sswift&gt; :-)<br>&lt;Jaia&gt; d/c - d/(1+c) = 255<br>&lt;Jaia&gt; d = 255/(1/c + 1/(1+c))<br>&lt;Jaia&gt; so this is d in terms of c<br>&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/c + 1/(1+c)) / (1+c)<br>&lt;Jaia&gt; that last term<br>&lt;Jaia&gt; - 255/blah blah<br>&lt;Jaia&gt; that's what you don't want too small<br>&lt;Jaia&gt; set it to 1-5 or so<br>&lt;Jaia&gt; and see how it works<br>&lt;Jaia&gt; the lower it is, the faster it decays<br>&lt;sswift&gt; what was wrong with this?  (256/255) / (x^2/r^2 + 1/255)  - 1<br>&lt;Jaia&gt; this is the case for 1<br>&lt;Jaia&gt; it may work well<br>&lt;Jaia&gt; i just gave you a more general case<br>&lt;sswift&gt; ah.<br>&lt;Jaia&gt; where you can tweak the parameter at will<br>&lt;Jaia&gt; just solve that last term<br>&lt;Jaia&gt; 255(1/(c(1+c)) + 1)<br>&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/(c(1+c) + 1)<br>&lt;Jaia&gt; ...<br>&lt;Jaia&gt; same thing<br>&lt;Jaia&gt; just cleaned up a bit<br>&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/(c(1+c)) + 1)<br>&lt;Jaia&gt; the one you gave has - 1<br>&lt;Jaia&gt; as a case<br>&lt;Jaia&gt; by changing c<br>&lt;Jaia&gt; you can make the - number different<br>&lt;Jaia&gt; for a certain c you get - 1<br>&lt;Jaia&gt; as you showed<br>&lt;Jaia&gt; change c to get different values - something<br>&lt;sswift&gt; Okay<br>&lt;Jaia&gt; making that something bigger makes the decay slower<br>&lt;Jaia&gt; etc.<br><br>&lt;Jaia&gt; etc.<br>&lt;Jaia&gt; unless i made a mistake<br>&lt;Jaia&gt; let me see<br>&lt;Jaia&gt; d/(x^2/R^2 + c)<br>&lt;Jaia&gt; d/(x^2/R^2 + c) - d/(1+c)<br>&lt;Jaia&gt; d/c - d/(1+c) = 255<br>&lt;Jaia&gt; d = 255/(1/c + 1/(1+c))<br>&lt;Jaia&gt; ya, looks ok<br><br><br>lighting<br>--------<br><br>; DX7 Lighting equation:<br>; Attenuation = 1 / (C0 + C1*D + C2*D*D)<br>;<br>; For some reason this equation does not seem to produce the expected results!<br>;<br>; In Blitz:<br>; C0,C2 = 0.  C1=Light radius.<br>;<br>; Mark has said that Blitz's lighting follows this equation:<br>; Brightness = 1.0 / (Distance / Light_Radius)  <br>;<br>; Which does what the DX7 equation should do, but I don't know why they're so different.<br>;<br>; The shadow system on the other hand uses a modified linear falloff. <br>;<br>; This is so that the distance at which the shadow attenuates completely is not really<br>; far away from it's origin.  If we used the other equations, a caster would almost<br>; never be outside a light's range, and that would be very bad for the framerate!<br>																																				<br>; Standard linear falloff equation:<br>;<br>;    L = Lightness<br>;    R = Light max radius<br>;    D = Distance from light<br>;<br>; L = (R - D) / R <br>																								<br>; Linear falloff, modified to be offset so that: <br>;<br>;    If D &lt; R1  then L &gt; 1<br>;    If D = R1  then L = 1<br>;    If D &gt;= R2 then L = 0<br>;<br>; L = (R2 - (D-R1)) / R2 <br>																												<br>Light_Falloff# = (R2# - (Vdist# - R1#)) / R2#<br>																<br>; Clamp the falloff value if we are outside max_range, or inside min_range.<br><br>If (Light_Falloff# &lt; 0) Then Light_Falloff# = 0<br>If (Light_Falloff# &gt; 1) Then Light_Falloff# = 1<br>																					<br>																<br>; Convert the falloff value to a color for this vertex.<br>Light_Falloff# = 255.0 * (1.0 - Light_Falloff#)															<br><br><br><br><br><br>a = 1 / (c0 + c1*d + c2*d*d)<br><br>converts to:<br><br>v = light_r * light_min_radius / distance<br><br>Which can be inverted to:<br><br>d = light_r * light_min_radius / v<br><br>To find out the distance at which v becomes some value. <br><br></td></tr></table><br>
<a name="307044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> that's some nice stuff. saved it, thanks <br><br></td></tr></table><br>
<a name="307108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> whoa! Thanks man :) Longest post ever, worth it tho :) <br><br></td></tr></table><br>
<a name="307254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AbbaRue</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks alot sswift:  I should get lots of help from this list. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
