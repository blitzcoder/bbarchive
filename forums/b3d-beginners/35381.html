<!DOCTYPE html><html lang="en" ><head ><title >Anyone know hot to resolve this?(2d coordinates re</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Anyone know hot to resolve this?(2d coordinates re</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Anyone know hot to resolve this?(2d coordinates re</a><br><br>
<a name="384820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hallo to all.<br>It's about all day that i'm trying to solve a problem but don't know what to do.<br>I have a program that track record of the mouse click and store the position of the mouse pointer in an array so i can access those coordinates later for drawing object at these coords.<br>The problem is that this method works well if all the drawing <br>operations are on screen.....but if i've a playfield much bigger that the screen?<br>I have a playfield of 2000 * 2000 and the screen is displayed at 0,0 (x and y pos go from 0,0 to 2000,2000) i want to track record even of the point that are actually outside of the screen...if i use the command "origin"don't work because the record are always stored as i draw onscreen....What can i do?<br>What's the method of record coordinates that are ouside of the screen res?(like track record of pixel 1500,750?)<br>I hope it's not a tricky work because i have much code to change -_-' <br><br></td></tr></table><br>
<a name="384993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure I really understand what you want but I think you just need to convert your mouse click positions to world coords, by adding the mouse x,y positions to the screen's woord coords. That is, the top-left corner of the screen should have a position (offset) in your 2000*2000 world - just add the mouse x,y to this. <br><br></td></tr></table><br>
<a name="385076"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just subtract the location of the top left corner of the screen in the world from the location of the point in the world.<br><br>If your world is 1000x1000 and your screen is 100x100 and the top left corner of the screeen is at 200,200 in the world when the player clicks the center of it, then the point they clicked is at 50,50 in the screen and 250, 250 in the world, and if you then move the screen to the right by 50 pixels so it is as 250, 200, and then subtract that from the point's world location of 250, 250, then you are left with 0, 50, which is the point at which to plot the point on the current viewport. <br><br></td></tr></table><br>
<a name="385128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think i understand what you are telling me.<br>My world start at 0,0 and end at 2000,2000.<br>I use to set the points to place object this function:<br>set_path(mousex(),mousey()<br>I must change into this set_path([screenxpos-mousex()],[screenypos-mousey()]) if i have understand well.....<br>Another method that i have thinked is use the keyboard to scroll the world,and at the center of the world i place a sort of "aiming" circle,and set the points at the circle position...sot the function is simple: positionX=xworld-320<br>positionY=yworld-240 (if the screen if 640*480...).<br>But now that i have read much more deep the post of big10p i think that his tips works best:the formula is (i hope...)<br>xpath=xoffset+mousex()<br>ypath=yoffset+mousey()<br>Right? <br><br></td></tr></table><br>
<a name="385252"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nope...the formula don't work....if i make this the mouse rest in screen coords...and the path also.<br>I give up......i try playing with screen offset (and the only command to do this in blitz is origin)but all change that i made give strange result...but none works. <br><br></td></tr></table><br>
<a name="385254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think Swift has understand well...but effectively i don't know how to practice it's information... <br><br></td></tr></table><br>
<a name="385261"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> A brief explanation.<br>I set up a playfield of 1000 * 1000 (i have used the standard tileimage command) from 0,0 to 1000,1000.<br>The playfield start at 0,0 and is wide 640*480.<br>I decide to plot a pixel at 800*800 world coords.....<br>So i use the command origin to sroll the playfield....i use 2 text command to track the mouse position(but the mouse position is relatives to screen coords).<br>How can i change the 2 text command (that actually just print the mouse x and y position...)to print the actual mouse x and y position BUT in playfield coordinates??<br>I think that this is the problem....and on top of that i want the mouse to stay always on screen and not follow the playfield..so i think it's tricky use of the origin command...too tricky for me!<br>(the program after i have set up 10 points move an object trough all the points starting from point 1 to arrive at point 10...a sort of a path movement algo...but if i don't know how to translate screen coords in world coords the function of the movement don't work because my array are always full of screen coords and not of world coords..) <br><br></td></tr></table><br>
<a name="385298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's the code...bad writted because of the many tentatives of correction...commented in italian...and use of xlntii....<br>the code of the path setting are just under the ;M A I N text...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;frametimer=CreateTimer(60)
Include "XSTART.BB"
AppTitle "Resolution selector"
;un semplice requester per decidere la risoluzione dello schermo
Print "What screen resolution do you want to use?"
Print "1] 640*480"
Print "2] 800*600"
Print "3] 1024*768"
Print "4] 1280*1024"
scelta%=Input("Choose a resolution:")
Print ("Fullscreen? 1) YES     2) NO")
fullscreen%=Input()
Select scelta
	Case 1
	screen_height%=640
	screen_width%=480
	Case 2
	screen_height%=800
	screen_width%=600 
	Case 3
	screen_height%=1024
	screen_width%=768
	Case 4
	screen_height%=1280
	screen_width%=1024
End Select

Graphics screen_height,screen_width,32,fullscreen%
GUI_GFXSETUP()
;Window
Window = GUI_WINDOW(0,0,160,400,"Path-points Creator","",62,0,$00DADADA,$007682BC,$00FFFFFF,$00C8C8C8,$006470AA)
;Gadgets
Button1 = GUI_BUTTON(Window,8,32,104,"New path","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button2 = GUI_BUTTON(Window,8,56,104,"Load path","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button3 = GUI_BUTTON(Window,8,80,104,"Save path","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button4 = GUI_BUTTON(Window,8,104,104,"Try loaded p.","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button5 = GUI_BUTTON(Window,8,128,104,"Try new p.","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button6 = GUI_BUTTON(Window,8,152,104,"N° nodes","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button7 = GUI_BUTTON(Window,8,176,104,"Speed","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button8 = GUI_BUTTON(Window,8,200,104,"Precision","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button9 = GUI_BUTTON(Window,8,224,104,"Smoothness","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button10 = GUI_BUTTON(Window,8,248,104,"Objects","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button11 = GUI_BUTTON(Window,8,272,104,"Background","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button12 = GUI_BUTTON(Window,8,320,104,"Clear all path","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
Button13 = GUI_BUTTON(Window,8,368,104,"Exit","",0,1,"",$00EEEEEE,$00D2D2D2,$00000000)
GUI_OPENWIN(Window)	;abbiamo finito di creare la finestra perciò la apriamo
;Creazione look-up table e precalcolamenti vari...
;******************************************************************************
Dim Sin2#(720)
Dim Cos2#(720)
Const SinCos_modifier=360
For loop=0 To 719
	Sin2#(loop)=Sin(loop)		
	Cos2#(loop)=Cos(loop)
Next
;******************************************************************************


AppTitle "Path Generator:create up to 10 path nodes!                                Matteo M. 2004"	;titolo applicazione

;Caricamento immagini con relativo handle
;******************************************************************************
Const iNumRotations=36
Dim ObjectFrames(iNumRotations)
LoadObject("alien.tga",iNumRotations)
Global enemy$
;******************************************************************************
Function LoadObject(ObjectName$,Rotations) 
    ; Load the player image and point to it with "imgTemp"
  imgTemp = LoadImage(ObjectName$)
MidHandle imgTemp
  ; see if the image was loaded successfully
  If imgTemp = 0
     Text 100,100,"Invalid Image!"    
  Else
     ; set it's mask (transparent color)
     MaskImage imgTemp,0,0,0
	 ; now run through the loop and rotate the image
     For iLoop=0 To Rotations-1
           ; first copy the original image into the current frame
      	 ObjectFrames(iLoop)=CopyImage( imgTemp )
           ; rotate the frame the appropriate number of degrees
           RotateImage ObjectFrames(iLoop), iLoop*360/Rotations
MidHandle ObjectFrames(iLoop)
     Next
  EndIf
End Function  
Function AngleToTarget(X#, Y#, XTarget#, YTarget#,Speed#, ShipDir, Rotations,Smoothness#)

    ; Calculate what the next x,y position of the ship would be 
    ; if it kept moving in its current direction  
    StraightX# = X# + (Sin2(ShipDir) * Speed#)
    StraightY# = Y# + (Cos2(ShipDir) * Speed#)

    ; Calculate what the next x,y position of the ship would be 
    ; if it turned one unit left and moved forward from there
    LeftShipDir = ShipDir - 1
    If LeftShipDir &lt; 0
        LeftShipDir = Rotations - 1
    EndIf
    LeftX# = X# + (Sin2(LeftShipDir) * Speed#)
    LeftY# = Y# + (Cos2(LeftShipDir) * Speed#)

    ; Calculate what the next x,y position of the ship would be 
    ; if it turned one unit right and moved forward from there
    RightShipDir = ShipDir + 1
    If RightShipDir &gt; Rotations - 1
        RightShipDir = 1 
    EndIf
    RightX# = X# + (Sin2(RightShipDir) * Speed#)
    RightY# = Y# + (Cos2(RightShipDir) * Speed#)

    ; using our above calculated projections, let's see what
    ; the distance is between the target and each projection
    StraightDist# = GetDistance#(StraightX,StraightY,XTarget,YTarget)
    LeftDist# = GetDistance#(LeftX,LeftY,XTarget,YTarget)
    RightDist# = GetDistance#(RightX,RightY,XTarget,YTarget)

    ; if the Left distance is less than the Straight and the
    ; Right distances, the the best direction to turn would
    ; be left.  That will bring us closer to the target.
    If LeftDist &lt; StraightDist And LeftDist &lt; RightDist
        ; see if there is enough of an angle to warrant 
        ; changing the dir...if this was left out the ship
        ; will shake madly when it gets close to the target
        If StraightDist - LeftDist &gt; Smoothness
           ; change the ship dir accordingly
           ShipDir = LeftShipDir
        EndIf
    EndIf

    ; if the Right distance is less than the Straight and the
    ; Left distances, the the best direction to turn would
    ; be Right.
    If RightDist &lt; StraightDist And RightDist &lt; LeftDist
        ; see if there is enough of an angle to warrant 
        ; changing the dir...if this was left out the ship
        ; will shake madly when it gets close to the target
        If StraightDist - RightDist &gt; Smoothness
            ; change the ship dir accordingly
            ShipDir = RightShipDir
        EndIf
    EndIf

    ; return the appropriate direction
    Return(ShipDir)
End Function
Function GetDistance#(XSource#,YSource#,XTarget#,YTarget#)
    ; find the difference between the source and target
    XDist# = XTarget - XSource
    YDist# = YTarget - YSource
    ; use a little math
    TotalDist# = Sqr#((XDist * XDist) + (YDist * YDist))
    ; return the value
    Return (TotalDist)
End Function
;caricamento fonts
;******************************************************************************
Global caratteri=LoadFont("Comic Sans MS",20,0,0,0)
;******************************************************************************









;dichiarazione variabili globali,dimensionamento arrays,maniglie degli sprites,variabili e costanti varie
;******************************************************************************


Global terreno=LoadImage("terreno.bmp") ;a simple texture of 256*256 





Global uscita%
Global percorso%
Global salvapath%
Global provapath%
Global clearpath%
Global npath%
Global num%
Global caricapath%
Global creapath%
Global testcurrent%
Global mouse1%	;questa e la variabile assegnata al pulsante del mouse...
Global mouse2%	;idem per il tasto destro.....
;MidHandle puntatore%	;la maniglia del puntatore è il suo centro esatto
HidePointer	;nasconde il puntatore del mouse
Global try$
Dim pathx#(max_path_points)	;array che serve per leggere i dati del percorso corrente
Dim pathy#(max_path_points)	;idem sopra...
Global path_counter%=-1	;contatore dei nodi
Global prova%
Global puntatori%
Global a.alieno	;il type a 
Global b.alieno	;il type b
Const max_path_points%=10	;il numero massimo di nodi da utilizzare nell'array
Global startdrawing%		;mi serve per far sapere che ho cliccato il pulsante per disegnare il percorso
Global alieno_creato%		;mi serve per dire che ho caricato un immagine dell'oggetto
Global sfondo%
Global velocity%
Global speedo%	;la velocita degli oggetti
Global smootho%	;la grandezza della curva che fanno gli oggetti in prossimita degli angoli
Global morbidezza%
Global accurat%	;la precisione dell'approssimazione nel calcolo dei path points....va in base alla velocita,piu e alta
				;e piu deve essere alta la precisione,altrimenti l'oggetto salta i nodi.....
Global precisiun%
Const num_frames% = 36	; Frames are 0 to 32 costante cosi e piu veloce!
Const seg# = (360.0/Float(num_frames))	;usato per velocizzare il calcolo della direzione..usando costanti!
Const half_seg# = seg/2.0	;idem
;******************************************************************************

;creazione "type"
;******************************************************************************
Type alieno
	Field posizionex# 
	Field posizioney# 
	Field velocita%   ;questa va benissimo integer
	Field angolo# 
	Field angolo2# 
	Field pathx#[max_path_points] 
	Field pathy#[max_path_points] 
	Field smoothness%
	Field precisione%
	Field current_path%
	Field path_counter%
	Field distanza#
	Field cx#
	Field cy#
	;Field percorso
End Type
;******************************************************************************

;funzioni varie:creazione oggetti,interfaccia,movimenti,disegno nodi ecc. ecc.
;******************************************************************************
Function crea_alieno_drawn(speed,smooth,precis)
	If creapath=0 Then Goto uscita5
	b.alieno=New alieno
	read_drawn_path()
	If velocity=1
		b\velocita=speedo
	Else b\velocita=1
	EndIf
	b\angolo#=0
	b\angolo2#=0
	If morbidezza=1
		b\smoothness=smootho
	Else b\smoothness=15
	EndIf
	If precisiun=1
		b\precisione=accurat
	Else b\precisione=10
	EndIf
	b\path_counter=-1
	b\distanza=0
	b\current_path=0; resetta il nodo corrente a zero
	b\cx=b\pathx[0]; setta le coordinate del rettangolo al primo nodo (cioe il nodo che e memorizzato nell'array)
	b\cy=b\pathy[0]
	movement_started=1; e il "flag" della partenza del movimento
	b\posizionex=b\pathx#[0]	;questa e la partenza dell'oggetto,cioe il primo nodo!
	b\posizioney=b\pathy#[0]	;idem come sopra per l'asse y
	.uscita5
End Function

Function crea_alieno(speed,smooth,precis)
		a.alieno=New alieno
		read_path()
		If velocity=1
			a\velocita#=speedo
		Else a\velocita#=1
		EndIf
		a\angolo#=0
		a\angolo2#=0
		If morbidezza=1
			a\smoothness=smootho
		Else a\smoothness=15
		EndIf
		If precisiun =1
			a\precisione=accurat
		Else a\precisione=10
		EndIf
		a\path_counter=-1
		a\distanza=0
		a\current_path=0; resetta il nodo corrente a zero
		a\cx=a\pathx[0]; setta le coordinate del rettangolo al primo nodo (cioe il nodo che e memorizzato nell'array)
		a\cy=a\pathy[0]
		;movement_started=1; e il "flag" della partenza del movimento
		a\posizionex=a\pathx#[0]	;questa e la partenza dell'oggetto,cioe il primo nodo!
		a\posizioney=a\pathy#[0]	;idem come sopra per l'asse y
		percorso=0
End Function

Function muovi_alieno_drawn()
	If creapath=0 Then Goto uscita3
	For b.alieno=Each alieno
	;draw_current_path()
	b\angolo#=0			;setto l'angolo a zero
	If b\current_path &lt; b\path_counter Then;cosi facendo siamo sicuri che il nodo corrente sia minore di quello massimo consentito
	 								 ;nell'array
		b\angolo=ATan2(b\pathy[b\current_path+1]-b\pathy[b\current_path],b\pathx[b\current_path+1]-b\pathx[b\current_path])+360
		;calcola l'angolo tra il nodo corrente e il prossimo nodo
		b\cx=b\cx+Cos2(b\angolo)*b\velocita;aumenta le coordinate x del rettangolo formato dal nodo e dall'origine,cioe quel rettangolo
							   ;che si viene a formare se tracciassimo i lati dal punto di origine delle coordinate
							   ;dello schermo a quelle del punto dove risiede il nodo
							
		b\cy=b\cy+Sin2(b\angolo)*b\velocita;aumenta le coordinate y del rettangolo formato dal nodo e dall'origine,cioe quel rettangolo
							   ;che si viene a formare se tracceremo i lati dal punto di origine delle coordinate
						   ;dello schermo a quelle del punto dove risiede il nodo

		;Color 100,200,100; cambia il colore di disegno
		;Rect b\cx-3,b\cy-3,6,6; disegna il rettangolino centrale alle sue coordinate
		If Abs(b\cx-b\pathx[b\current_path+1]) &lt; b\precisione And Abs(b\cy-b\pathy[b\current_path+1]) &lt; b\precisione Then
			;se le coordinate del famoso rettangolo (costruito tramite i punti di origine e del nodo...)sono entro TOT pixel
			;di distanza dal PROSSIMO nodo (questa e una sorta di approssimazione,cioe e come una campo di forza che attrae
			;l'oggetto...se il campo di forza e piccolo l'oggetto prosegue con l'angolatura che aveva prima e se ne
			;infischiera dei nodi obbligatori...)
			b\current_path=b\current_path+1; setta il nodo corrente come il prossimo nodo contenuto nell'array
			b\cx=b\pathx[b\current_path]; setta le coordinate del famoso rettangolo (formato da BLA BLA BLA...)a quelle del nodo corrente
			b\cy=b\pathy[b\current_path];idem come sopra con le coordinate y
			;tutto questo viene calcolato con la variabile "precisione"
		End If
	End If
	;If current_path =&gt; path_counter Then current_path=0
	b\angolo2=ATan2( b\cy - b\posizioney, b\cx - b\posizionex )+360; calcola l'angolo tra le coordinate del nodo e quelle dell'oggetto che si vuole muovere
	b\distanza=Sqr( (b\posizionex-b\cx)*(b\posizionex-b\cx)+(b\posizioney-b\cy)*(b\posizioney-b\cy) ); calcola la distanza tra loro due
	;DebugLog dist	
	;DebugLog b\velocita		;apre la finestra di debug con i valori della distanza in real-time
	b\posizionex=b\posizionex+(Cos2(b\angolo2)/1)*(b\distanza / b\smoothness); muovi l'oggetto ad una velocita relativa alla distanza...il parametro "smoothness" e la
										  ; "morbidezza" della curva che fara l'oggetto da muovere...piu e morbida la curva
										  ;piu sara lenta
	b\posizioney=b\posizioney+(Sin2(b\angolo2)/1)*(b\distanza / b\smoothness);idem come sopra per la coordinata y
	;inserimento funzioni calcolo direzione
	;*********************************************************
	;num_frames% = iNumRotations	; Frames are 0 to rotation number
	;seg# = (360.0/Float(num_frames))
	fotogramma% = Floor((((ATan2( b\cy - b\posizioney, b\cx - b\posizionex ) + half_seg) + (360.0+90.0)) Mod 360.0) / seg);serve per decidere il fotogramma che va in base alla direzione
	DrawImage (ObjectFrames(fotogramma),b\posizionex,b\posizioney)
	;DrawImage enemy,b\posizionex,b\posizioney; disegna l'oggetto
	b\path_counter=b\path_counter+1; incrementa il contatore dei nodi
;precedente funzione set_path() ora inglobata all'interno di muovi_alieno()    
	If b\path_counter&gt;max_path_points-1 Then ; se il contatore dei nodi e piu grande del numero massimo di nodi resettalo a 1
    	b\path_counter=max_path_points-1
    End If
;precedente funzione di loop tra i nodi,ora inglobata all'interno di muovi_alieno()
If b\current_path=max_path_points-1 Then; se il nodo corrente e 9 (per simulare un percorso ciclico...)
	b\pathx[max_path_points-1]=b\pathx[0]
	b\pathy[max_path_points-1]=b\pathy[0]
	b\cx=b\pathx[0]	  ; setta le coordinate del rettangolo al primo path-point
	b\cy=b\pathy[0]
	b\current_path=0; setta il percorso corrente al primo che e stato dichiarato
End If							

Next
.uscita3
End Function

Function muovi_alieno()
For a.alieno=Each alieno
	a\angolo#=0			;setto l'angolo a zero
	If a\current_path &lt; a\path_counter Then;cosi facendo siamo sicuri che il nodo corrente sia minore di quello massimo consentito
	 								 ;nell'array
		a\angolo=ATan2(a\pathy[a\current_path+1]-a\pathy[a\current_path],a\pathx[a\current_path+1]-a\pathx[a\current_path])+360
		;a\angolo\angolo+360		;aggiunta fatta per far si che atan2 non sia negativo dato che va da -180 a +180
		;calcola l'angolo tra il nodo corrente e il prossimo nodo
		a\cx=a\cx+Cos2(a\angolo)*a\velocita;aumenta le coordinate x del rettangolo formato dal nodo e dall'origine,cioe quel rettangolo
							   ;che si viene a formare se tracciassimo i lati dal punto di origine delle coordinate
							   ;dello schermo a quelle del punto dove risiede il nodo
							
		a\cy=a\cy+Sin2(a\angolo)*a\velocita;aumenta le coordinate y del rettangolo formato dal nodo e dall'origine,cioe quel rettangolo
										  ;che si viene a formare se tracceremo i lati dal punto di origine delle coordinate
						  				  ;dello schermo a quelle del punto dove risiede il nodo
		If Abs(a\cx-a\pathx[a\current_path+1]) &lt; a\precisione And Abs(a\cy-a\pathy[a\current_path+1]) &lt; a\precisione Then
			;se le coordinate del famoso rettangolo (costruito tramite i punti di origine e del nodo...)sono entro TOT pixel
			;di distanza dal PROSSIMO nodo (questa e una sorta di approssimazione,cioe e come una campo di forza che attrae
			;l'oggetto...se il campo di forza e piccolo l'oggetto prosegue con l'angolatura che aveva prima e se ne
			;infischiera dei nodi obbligatori...)
			a\current_path=a\current_path+1; setta il nodo corrente come il prossimo nodo contenuto nell'array
			a\cx=a\pathx[a\current_path]; setta le coordinate del famoso rettangolo (formato da BLA BLA BLA...)a quelle del nodo corrente
			a\cy=a\pathy[a\current_path];idem come sopra con le coordinate y
			;tutto questo viene calcolato con la variabile "precisione"			
		End If
	End If
	a\angolo2=ATan2( a\cy - a\posizioney, a\cx - a\posizionex )+360	; calcola l'angolo tra le coordinate del nodo e quelle dell'oggetto che si vuole muovere
	
	a\distanza=Sqr( (a\posizionex-a\cx)*(a\posizionex-a\cx)+(a\posizioney-a\cy)*(a\posizioney-a\cy) ); calcola la distanza tra loro due
	a\posizionex=a\posizionex+(Cos2(a\angolo2)/1)*(a\distanza / a\smoothness); muovi l'oggetto ad una velocita relativa alla distanza...il parametro "smoothness" e la
										  ; "morbidezza" della curva che fara l'oggetto da muovere...piu e morbida la curva
										  ;piu sara lenta
	a\posizioney=a\posizioney+(Sin2(a\angolo2)/1)*(a\distanza / a\smoothness);idem come sopra per la coordinata y
	
	;inserimento funzioni calcolo direzione
	;*********************************************************
	;num_frames% = iNumRotations	; Frames are 0 to rotation number
	;seg# = (360.0/Float(num_frames))
	fotogramma% = Floor((((ATan2( a\cy - a\posizioney, a\cx - a\posizionex ) + half_seg) + (360.0+90.0)) Mod 360.0) / seg);serve per decidere il fotogramma che va in base alla direzione
	DrawImage (ObjectFrames(fotogramma),a\posizionex,a\posizioney)
	a\path_counter=a\path_counter+1; incrementa il contatore dei nodi
	;precedente funzione set_path() ora inglobata all'interno di muovi_alieno()    
	If a\path_counter&gt;max_path_points-1 Then ; se il contatore dei nodi e piu grande del numero massimo di nodi resettalo a 1
    	a\path_counter=max_path_points-1
    End If
;precedente funzione di loop tra i nodi,ora inglobata all'interno di muovi_alieno()
If a\current_path=max_path_points-1 Then; se il nodo corrente e 9 (per simulare un percorso ciclico...)
	a\pathx[max_path_points-1]=a\pathx[0]
	a\pathy[max_path_points-1]=a\pathy[0]
	a\cx=a\pathx[0]	  ; setta le coordinate del rettangolo al primo path-point
	a\cy=a\pathy[0]
	a\current_path=0; setta il percorso corrente al primo che e stato dichiarato
End If								
Next
End Function

Function draw_path_points()
	For loop=0 To a\path_counter; fai un loop tra tutti i nodi
		Color 100,100,200
		Rect a\pathx[loop],a\pathy[loop],2,2
		If loop&lt;a\path_counter Then;fai questo loop solo se il nodo corrente e piu basso del numero massimo di nodi
			Rect a\pathx[loop+1]-1,a\pathy[loop+1]-1,2,2; disegna un rettangolo sul nodo
			Color 50,50,150; cambia il colore di disegno
			Line a\pathx[loop],a\pathy[loop],a\pathx[loop+1],a\pathy[loop+1]; disegna una linea tra il nodo corente e il prossimo
		End If
	Next
End Function

Function draw_current_path()
	For loop=0 To b\path_counter; fai un loop tra tutti i nodi
		Color 100,100,200
		Rect b\pathx[loop],b\pathy[loop],2,2
		If loop&lt;b\path_counter Then;fai questo loop solo se il nodo corrente e piu basso del numero massimo di nodi
			Rect b\pathx[loop+1]-1,b\pathy[loop+1]-1,2,2; disegna un rettangolo sul nodo
			Color 50,50,150; cambia il colore di disegno
			Line b\pathx[loop],b\pathy[loop],b\pathx[loop+1],b\pathy[loop+1]; disegna una linea tra il nodo corente e il prossimo
		End If
	Next
End Function

Function read_path()				;funzione che carica da file i dati dei nodi
	file=ReadFile(try$)					;apro il file creato precedentemente per la lettura
	If file=0 Then Goto uscita			;se non ho aperto nessun file o se il file non esiste esci dalla funzione
	pointer=0							;puntatore al movimento nel file...aumenta di 4 in 4 siccome per un valore nei
									;file vengono allocati automaticamente 4 byte di dati (numeri,stringhe ecc ecc)
	pointer2=0							;puntatore al valore che,incrementando,fa si che leggo i valori nell'array ciclicamente
	For x=1 To max_path_points						;scorre tutti e 10 i valori
		SeekFile (file,pointer)				;mi muovo all'interno del file cosi
		a\pathx#[pointer2]=ReadFloat (file)	;leggo il valore x ,un float-number dentro il primo valore nell'array
		pointer=pointer+4					;mi sposto al prossimo dato dentro il file
		a\pathy#[pointer2]=ReadFloat (file)	;leggo il valore y
		pointer2=pointer2+1					;passo ai prossimi due valori nell'array
		pointer=pointer+4					;mi sposto ancora al prossimo dato nel file
	Next
	CloseFile (file)					;chiudo il file
	.uscita
End Function

Function write_path_nodes()
Locate 0,570		;mi sposto quasi alla fine dello schermo con il cursore
nomefile$=Input("Digita il nome del file da salvare:")		;digito il nome del file da salvare,ricordarsi di mettere .txt

fileout=WriteFile (nomefile$)		;scrivo il file con il nome che ho digitato sopra,se esiste gia con quel nome lo sovrascrive
try2=0										;questo mi serve per scorrere tra il numero di nodi in modo da usare un for--next
											;per leggerli tutti
											
For a.alieno=Each alieno		;questo va fatto per tutti i type "alieno",cioe gli oggetti che muoverò									
For x=1 To max_path_points								;scrivi solo da x=1 a x=10,cioe scrivi 10 volte
WriteFloat (fileout,a\pathx#[try2])									;il try tra parentesi e la variabile che contiene
WriteFloat (fileout,a\pathy#[try2])									;il numero del nodo corrente dell'array!!!
try2=try2+1					;incremento di uno...cioe dico che il nodo e il prossimo dell'array
Next
Next
CloseFile (fileout)			;chiudo il file
End Function

Function setpath(x,y)
	path_counter=path_counter+1; incrementa il contatore dei nodi
    If path_counter&gt;max_path_points-1 Then; se il contatore dei nodi e piu grande del numero massimo di nodi resettalo a 1
    	path_counter=0	;percorso ancora da iniziare
    	pathx(path_counter)=MouseX()	;resetto anche le coordinate x e y del primo nodo
    	pathy(path_counter)=MouseY()
    Else; altrimenti 
		pathx(path_counter)=x;memorizza le coordinate x e y del nodo
		pathy(path_counter)=y
    End If
End Function

Function draw_current_path2()
	For loop=0 To path_counter; fai un loop tra tutti i nodi
		Color 100,100,200
		Rect pathx(loop),pathy(loop),2,2
		If loop&lt;path_counter Then;fai questo loop solo se il nodo corrente e piu basso del numero massimo di nodi
			Rect pathx(loop+1)-1,pathy(loop+1)-1,2,2; disegna un rettangolo sul nodo
			Color 50,50,150; cambia il colore di disegno
			Line pathx(loop),pathy(loop),pathx(loop+1),pathy(loop+1); disegna una linea tra il nodo corente e il prossimo
		End If
	Next
End Function

Function read_drawn_path()
	If creapath=0 Then Goto uscita2	;se non e stato premuto precedentemente il pulsante crea esci dalla funzione
	punt=0
	For trigger=1 To max_path_points
		b\pathx#[punt]=pathx(punt)
		b\pathy#[punt]=pathy(punt)
		punt=punt+1
	Next
	.uscita2
End Function
;******************************************************************************

;M A I N
;codice delle finestre
Global screenx=0
Global screeny=0
Global x=320
Global y=240
While Not uscita=1	;fino a che uscita non e uguale a 1
SetBuffer BackBuffer():Cls
;Origin MouseX(),MouseY()

;disegna_layer2()				;i'm trying to draw layer 2 first so i draw in my main it firstly(like any other object in BB...)
;disegna_layer1()				;the second layer
;disegna_layer3()
;MapTiles()

Origin screenx,screeny
MapTiles()
;WaitTimer(frametimer)		;framelimiter semplice
;If triggher_sfondo=1
;	DrawImage sfondo,0,0
;EndIf
Origin 0,0
GUI()

;Origin screenx,screeny

Color 200,200,200
provapath=0	;devo dichiararlo sempre all'inizio altrimenti memorizza il valore anche se l'ho premuto precedentemente...
mouse1=MouseHit(1)
mouse2=MouseHit(2)


joy1=JoyHit(1)
;x=JoyX()
;y=JoyY()


;screenx=screenx+x
;screeny=screeny+y


If KeyDown(200)=True Then screeny=screeny-1
If KeyDown(208)=True Then screeny=screeny+1
If KeyDown(205)=True Then screenx=screenx+1
If KeyDown(203)=True Then screenx=screenx-1
Color 255,0,0
Rect x,y,4,4




If startdrawing=1
		;Origin 0,0
	;If KeyHit(57)=True	;barra spaziatrice
	If mouse2=True	;se il pulsante destro del mouse
		;Origin screenx,screeny
		pathx(current_path)=MouseX()	;resetto anche le coordinate x e y del primo nodo
    	pathy(current_path)=MouseY()
		
		setpath((screenx+MouseX()),(screeny+MouseY()))
		;Origin 0,0
	EndIf
	If pathx(max_path_points)&lt;&gt;pathx(0)
		pathx(max_path_points)=pathx(0)		;queste due routine sono una specie di autocorrezione dell'ultimo nodo
	EndIf						;facendolo diventare uguale al primo
	If pathy(max_path_points)&lt;&gt;pathy(0)
		pathy(max_path_points)=pathy(0)
	EndIf
	Origin screenx,screeny
	draw_current_path2()
	creapath=1
	;Origin 0,0
EndIf

    Select EV_RELEASE()
        Case Button1		;disegno un percorso nuovo
        startdrawing=1
		
			
        Case Button2		;carico un percorso
        	try$=IO_FileRequest$("Load path:",".txt|")
			percorso=1
			caricapath=0
			
        Case Button3		;salvo il percorso appena disegnato,non quello caricato!
        	write_path_nodes()	;lo salva  nella directory di esecuzione del programma
			salvapath=0
			
        Case Button4		;provo il percorso caricato
        	If percorso=1
				crea_alieno(10,15,5)
				provapath=0
				percorso=0
			EndIf
			
        Case Button5		;provo il percorso appena disegnato

			;pathx(0)=screenx+pathx(0)
			;pathy(0)=screeny+pathy(0)
			;pathx(1)=screenx+pathx(1)
			;pathy(1)=screeny+pathy(1)
			;pathx(2)=screenx+pathx(2)
			;pathy(2)=screeny+pathy(2)
			;pathx(3)=screenx+pathx(3)
			;pathy(3)=screeny+pathy(3)
			;pathx(4)=screenx+pathx(4)
			;pathy(4)=screeny+pathy(4)
			;pathx(5)=screenx+pathx(5)
			;pathy(5)=screeny+pathy(5)
			;pathx(6)=screenx+pathx(6)
			;pathy(6)=screeny+pathy(6)
			;pathx(7)=screenx+pathx(7)
			;pathy(7)=screeny+pathy(7)
			;pathx(8)=screenx+pathx(8)
			;pathy(8)=screeny+pathy(8)
			;pathx(9)=screenx+pathx(9)
			;pathy(9)=screeny+pathy(9)
			;pathx(10)=screenx+pathx(10)
			;pathy(10)=screeny+pathy(10)
		

			


        	crea_alieno_drawn(10,15,5)
			testcurrent=0
			creapath=0
			startdrawing=0
			
        Case Button6		;decido il numero di nodi del percorso che voglio creare
        	Locate 0,570
			num=Input("How many path nodes?:")
			npath=0
        Case Button7
        	Locate 0,570
			speedo=Input("How fast the object must be?:")
			velocity=1
        Case Button8
        	Locate 0,570
        	accurat=Input ("How much accurate the point approximation must be [depends on speed!]?:")
			precisiun=1
        Case Button9
        	Locate 0,570
        	smootho=Input ("How large the curves must be?:")
			morbidezza=1
        Case Button10
        	enemy=LoadImage (IO_FileRequest$("Load object image:",".bmp|"))
        	MidHandle enemy
        	alieno_creato=1
        Case Button11
			sfondo=LoadImage (IO_FileRequest$("Load background image:",".bmp|"))
			If  sfondo &lt;&gt; False
			triggher_sfondo=1
			EndIf
        Case Button12
			For a.alieno=Each alieno
				Delete a
			Next
			For b.alieno=Each alieno
				Delete b
			Next
		puntator=0
		clearpath=0
		path_counter=0
		creapath=0
		current_path=0
		movement_started=0
		percorso=0
		provapath=0
		startdrawing=0
		triggher_sfondo=0
		velocity=0
		morbidezza=0
		precisiun=0
        Case Button13
			uscita=1
			
        Default

    End Select


Text 0,0,"X:"+Str$(screenx)+"  Y:"+Str$(screeny)


SetFont caratteri
If alieno_creato=1
;Origin screenx,screeny
	muovi_alieno()
	muovi_alieno_drawn()
EndIf
Origin 0,0
Flip
Wend

Function MapTiles()
tilex=0
tiley=0
For tiley=0 To 2560 Step 256
For tilex=0 To 640 Step 256
DrawBlock terreno,tilex,tiley
Next
Next
End Function






;cancello tutti gli oggetti,immagini,ecc ecc creati
GUI_FREEWIN(Window)
FreeImage sfondo
FreeImage enemy
For a.alieno=Each alieno
	Delete a
Next
For b.alieno=Each alieno
	Delete b
Next
End
;E N D    M A I N
</textarea><br><br>For test the movement you must create first a path of 9 points...then load an image (there's a requester...)...then set up the speed...then try the current path...that's all.<br><br>I give up completely.....all serious games require this functionality and i don't know how to make this,so i give up(the code above is non-functional...so to see anything move you must scroll the screen with the keyboard)<br>Feel free to take any part of this code (i don't think it's of use to anyone but...). <br><br></td></tr></table><br>
<a name="385355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have reproduced the error in a much smaller code to read!<br>The eror is the same...a sort of mirror around the center of the world axis (0,0)...<br><pre class=code>
Type oggetto
Field posx
Field posy
End Type


Graphics 640,480,32,1
SetBuffer BackBuffer()
Global terreno=LoadImage("terreno.bmp") ;a simple texture of 256*256 
Global enemy=LoadImage("enemy.bmp")
MidHandle enemy
Global screenx=0
Global screeny=0
Global posx=200
Global posy=200
Global offset=1
While Not KeyHit(1)=True
Cls
x=MouseX()
y=MouseY()
mouse1=MouseHit(1)
Origin screenx,screeny
MapTiles()
;Origin 0,0
If KeyDown(200)=True Then screeny=screeny+1
If KeyDown(208)=True Then screeny=screeny-1
If KeyDown(205)=True Then screenx=screenx+1
If KeyDown(203)=True Then screenx=screenx-1

If KeyHit(57)=True Then screenx=0:screeny=0	;if i hit the spacebar

Rect MouseX(),MouseY(),9,9
;Origin screenx,screeny



If mouse1=True
create_enemy(screenx+MouseX(),screeny+MouseY())
EndIf






draw_enemy()
Origin 0,0

Color 255,255,255
Text 50,400,("Mouse X world coords:"+(screenx-MouseX()))
Text 50,410,("Mouse Y world coords:"+(screeny-MouseY()))
Color 255,0,0
Text 50,430,("X offset world coords:"+screenx)
Text 50,440,("Y offset world coords:"+screeny)
Color 0,0,255
Text 50,450,("X mouse world coords:"+(screenx+MouseX()))
Text 50,460,("Y mouse world coords:"+(screeny+MouseY()))



;If MouseHit(1)=True
	



Flip
Wend

Function MapTiles()
tilex=0
tiley=0
For tiley=0 To 2560 Step 256
For tilex=0 To 640 Step 256
DrawBlock terreno,tilex,tiley
Next
Next
End Function


Function draw_enemy1()
DrawImage enemy,posx,posy
posx=posx
posy=posy+offset
If posy =&lt; 0 Then offset=1
If posy =&gt; 100 Then offset=-1
End Function



Function create_enemy(x,y)
a.oggetto=New oggetto
a\posx=x
a\posy=y
End Function

Function draw_enemy()
For a.oggetto = Each oggetto
DrawImage enemy,a\posx,a\posy
Next
End Function
</pre><br><br>If i understand this i can make the other program work...so as my game... <br><br></td></tr></table><br>
<a name="385389"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eBusiness</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's what happens when you change values at random in order to solve a bug.<br><br><pre class=code>Type oggetto
Field posx
Field posy
End Type


Graphics 640,480,32,1
SetBuffer BackBuffer()
Global terreno=LoadImage("c:\jacob\blitz\shooter test\floor104.bmp") ;a simple texture of 256*256 
Global enemy=LoadImage("c:\jacob\blitz\5inarowicon.bmp")
MidHandle enemy
Global screenx=0
Global screeny=0
Global posx=200
Global posy=200
Global offset=1
While Not KeyHit(1)=True
Cls
x=MouseX()
y=MouseY()
mouse1=MouseHit(1)
MapTiles()
;Origin 0,0
If KeyDown(200)=True Then screeny=screeny-1
If KeyDown(208)=True Then screeny=screeny+1
If KeyDown(205)=True Then screenx=screenx+1
If KeyDown(203)=True Then screenx=screenx-1

If KeyHit(57)=True Then screenx=0:screeny=0	;if i hit the spacebar

Rect MouseX(),MouseY(),9,9
;Origin screenx,screeny



If mouse1=True
create_enemy(MouseX()+screenx,MouseY()+screeny)
EndIf






draw_enemy()
Origin 0,0

Color 255,255,255
Text 50,400,("Mouse X world coords:"+(MouseX()+screenx))
Text 50,410,("Mouse Y world coords:"+(MouseY()+screeny))
Color 255,0,0
Text 50,430,("X offset world coords:"+screenx)
Text 50,440,("Y offset world coords:"+screeny)
Color 0,0,255
Text 50,450,("X mouse coords:"+MouseX())
Text 50,460,("Y mouse coords:"+MouseY())



;If MouseHit(1)=True
	



Flip
Wend

Function MapTiles()
tilex=0
tiley=0
For tiley=0 To 2560 Step 256
For tilex=0 To 640 Step 256
DrawBlock terreno,tilex-screenx,tiley-screeny
Next
Next
End Function


Function draw_enemy1()
DrawImage enemy,posx,posy
posx=posx
posy=posy+offset
If posy =&lt; 0 Then offset=1
If posy =&gt; 100 Then offset=-1
End Function



Function create_enemy(x,y)
a.oggetto=New oggetto
a\posx=x
a\posy=y
End Function

Function draw_enemy()
For a.oggetto = Each oggetto
DrawImage enemy,a\posx-screenx,a\posy-screeny
Next
End Function</pre> <br><br></td></tr></table><br>
<a name="385453"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have changed at random because i have run lost...<br>But effectively the only modification that i see(except that you have eliminated many variables....early this code as the same as yours)is the draw enemy position function..<br>Effectively i haven't tryed to modify this....<br>So it's not the setpoint function that was wrong...but also the display function..... <br><br></td></tr></table><br>
<a name="385463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eBusiness</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> We all know that programming first really get hard when you reach the +/- dilemma. <br><br></td></tr></table><br>
<a name="385516"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Valgar</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes.<br>I must say a big "thank you" because now i have learned another way to move tiled background...just like the manual of Blitz say "the drawimage command is wrapped so it draws outside the screen".....now i use this "virtual offset" instead to play with Origin....i have modified my map placer/editor/mover with your modification and all goes exceptionally well!<br>Now i can go to sleep @_@ <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
