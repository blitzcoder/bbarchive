<!DOCTYPE html><html lang="en" ><head ><title >Atlas textures - Can Blitz3d do it?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Atlas textures - Can Blitz3d do it?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Atlas textures - Can Blitz3d do it?</a><br><br>
<a name="1188499"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Imperium</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> A Texture atlas is a large image containing a collection of sub-images, or "atlas" which contains many smaller sub-images, each of which is a texture for some part of a 3D object. The sub-textures can be rendered by modifying the texture coordinates of the object's uvmap on the atlas, essentially telling it which part of the image its texture is in.<br><br>That being said the point of this is to cut down on the amount of draws for texture information. The goal would be to free up some of the CPU. <br><br></td></tr></table><br>
<a name="1188509"></a>

<a name="1188510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> to cut down on the amount of draws for texture information. The goal would be to free up some of the CPU. <br></div><br><br>Can you elaborate?<br><br>Blitz3D can do atlasing well enough, because it's not really a formal technique so much as a generalisation of UV map support; but it's not immediately obvious what impact this would have either way on performance (unless you combine the objects as well into larger ones). <br><br></td></tr></table><br>
<a name="1188519"></a>

<a name="1188521"></a>

<a name="1188522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Imperium</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I came across an interesting read this book: Game Art: Creation, Direction, and Careers.<br><br><a href="http://www.amazon.com/Game-Art-Creation-Direction-Development/dp/1584503955" target="_blank">http://www.amazon.com/Game-Art-Creation-Direction-Development/dp/1584503955</a><br><br>On page 192 &amp; 193 it discusses Atlas textures and reusing UV's on objects. I will scan and upload the page so I don't have to type it. But it basically says this will help optimize the performance of draw calls which helps taken some burden off of the cpu. <br><br></td></tr></table><br>
<a name="1188526"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Blitz3D can do it, and you can even set your UVs up in your favorite modelling application.<br>So each mesh's UVs will "capture" the relevant section from the atlas you want to texture each mesh with.<br><br>The thing is, texture atlasing by itself isn't that much of an optimization. I've read that the overall improvement is minimal. The overhead of rendering things is still the major problem.<br><br>What texture atlasing does best is open the door for <i>single surface</i> systems. Then you're not only doing texture atlasing and reducing the amount of texture switching, but you're also rendering most of your meshes with a single call.<br>This constitutes <i>batching</i>, a common optimization for hardware-accelerated real-time graphics. <br><br></td></tr></table><br>
<a name="1188529"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have the feeling that you're talking about an engine tweak that requires access to the kind of low-level control Blitz3D doesn't expose. Making two separate objects in Blitz3D use the same texture isn't going to change the number of draw calls at all, because Blitz3D will use the same set of calls as part of the draw process for each object. The only way to change that from within B3D code is to do as Kryzon suggests and batch whole game objects into single surfaces within a mesh.<br><br><br>Things to consider:<br><br>-- texture changes like this are practically free on modern systems, reducing the number of calls to this particular part of the API is going to have no observable effect unless you have hundreds of thousands of objects<br><br>-- combining objects into a single surface speeds up the drawing, but if you need to move the sub-objects around, you now need to do it with VertexCoords calls, which will eat up the performance gain tenfold<br><br>-- do you have <i>any</i> reason to believe this is slowing down your program? Remember Knuth's golden rule: "premature optimisation is the root of all evil". Unless you have measured and <i>know</i> that this is your speed bottleneck, "optimisations" like this are a complete waste of your time, obfuscating your code and your art assets for no reason (and quite possibly slowing it down, because optimisation is both hard and unintuitive) <br><br></td></tr></table><br>
<a name="1188536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Making two separate objects in Blitz3D use the same texture isn't going to change the number of draw calls at all, because Blitz3D will use the same set of calls as part of the draw process for each object. <br></div><br>I'd forgotten about that. I' not sure how the engine deals with the same brush being applied to several entities with the same EntityOrder.<br><br>Even if they all use the same brush, Blitz3D might just re-bind all textures every time it renders a mesh, making the effort fruitless. It's a simple check to see if the current brush is different than the previous one, so I'm hoping Mark put it there.<br>In case he didn't, the only improvement with this would be less memory use from having a single texture instead of several individual ones - which is probably negligible. <br><br></td></tr></table><br>
<a name="1188567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I' not sure how the engine deals with the same brush being applied to several entities with the same EntityOrder. <br></div><br><br>For the record, brushes are copy-on-assign and every entity and surface has precisely one internal brush that takes on properties when Paint-ed (this is why you need to free brushes that are extracted: because the extracted brush is a standalone copy not attached to, and that never will be attached to, an entity).<br><br>Textures are a brush property and have their own management system; textures are reference counted (one ref for every surface and entity, plus one for the code handle), and also cached (so loading the same texture twice will not cost any extra memory). As many objects as you like can share a texture without it being duplicated.<br><br><br><div class="quote"> It's a simple check to see if the current brush is different than the previous one, so I'm hoping Mark put it there. <br></div><br><br>I think it does do this. <br><br></td></tr></table><br>
<a name="1188648"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Imperium</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> No this post was  meant to stimulate a discussion. My code has no speed issues. I was unfamiliar with the term Atlas textures until I came across it browsing one of my books. <br><br></td></tr></table><br>
<a name="1190050"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would imagine this is more a topic for the 3D forum, but anyway - <br>I haven't really read into the technical aspects of this "Atlas"ing, nor do I expect I fully understand all that's required but it did ptovoke the following thoughts:<br><br>1) Isn't this a means of say, LOD alterations in relation to the textures rather than the polygons of a surface?<br><br>2) Isn't this what DX actually does (behind the scenes) with regards to the MIP levels of DDS?<br><br>3) If the above is correct (or at least, close enough to the mark) I can imagine some situation whereby scale factors are used to calculate the level opf detail, required as well as the UV position.<br>This differs from the MIP-mapping of DDS etc. since it involves actually changing the texture for a specific UV region based on "how close the camera is"<br><br>For example:<br><br>VISIBLE Proportion of Surface:<br>100%<br>UV Range= 0.0 -&gt; 1.0<br><br>10%<br>UV Range= 0.0 -&gt;0.10<br><br>1%<br>UV Range= 0.0 -&gt; 0.01<br><br>0.1%<br>UV = 0.0 -&gt;<br><br><br><br><br>So at a zoom level, where only, say 1% of the mesh is visible, a texture that represents the scale of 1% (though the raw texture still at 'regular size' i.e. 512 pixels etc.) is then drawn to fill the region of <br><br>(U,V)..................((U+(U*0.01),V)<br>  |..........|................|<br>  |----------+----------------|<br>  |..........|................|<br>(U,V+(V*0.01)_(U+(U*0.01), V+(V*0.01))<br><br><br><br>Presumably, though, this would be better if the entire mesh is swapped with a minimum few polygons that actually represent the size/shape of the visible region and the UV for this new surface can be attributed in full?<br><br><br><br><br><br><br><br><br><br><br><br><br><br>I suppose ultimately, the real case for any optimisation potential or impact will be how the image data for this atlas is loaded and processed - Do you take up a wealth of VRAM to store the textures, or risk slowdown in the "loading-in" of a new atlas/detail level etc.,???? <br><br></td></tr></table><br>
<a name="1190076"></a>

<a name="1190077"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I understand what you're proposing. Kinda like a "reverse" mipmapping.<br><br>Mipmapping gives you a simpler texture the farthest you are from the 1:1 pixel to texel ratio (screen pixel vs texture pixel). If you have less screen pixels to represent more texels, the GPU uses a simpler texture so you don't need to waste video memory with a huge texture with texels that would be skipped by the sampler, and the visual result is nearly the same.<br>If you're closer than that (that is, if you're closer to a triangle and you have more screen pixels than texels), mipmapping is simply not used by the GPU; But in your case, you'd want it to use a high-detail texture.<br><br>I don't know why people didn't do this, but I think it just was not practical. Having your artists make very detailed textures that wouldn't be seen so much from triangles being more likely to be away from the camera than very close.<br>You could maybe use this if you're doing software rasterizing, or using procedural textures (textures generated in real time by the CPU or GPU). <br><br></td></tr></table><br>
<a name="1190275"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I found your description much clearer and it really made sense, Kryzon.<br> <br><div class="quote"> <br>I don't know why people didn't do this, but I think it just was not practical. Having your artists make very detailed textures that wouldn't be seen so much from triangles being more likely to be away from the camera than very close <br></div><br>Sounds very likely to me.<br><br>I Just had a bizarre thought, sorry if this is getting off-topic a little, but since it's possible to quickly modify vertices' UV values (Well, actual modifying is quick, identifying which of the verts to modify is likely the slow bit)<br>I wonder how it would work out if instead of increasing the texels between UV to meet the visible pixels, the texture was reduced - relying on the texture repetition to invoke an almost "fractal"-like appearance. <br>Admittedly, this would not be good for games unless maybe dealing with terrain or normally "repetitive" surfaces etc... <br><br></td></tr></table><br>
<a name="1190757"></a>

<a name="1190758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Imperium</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can Blitz3d do voxels? I've always loved how terrain looked when those are used. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
