<!DOCTYPE html><html lang="en" ><head ><title >OOP kind of basic scripting..eehh converter thing?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >OOP kind of basic scripting..eehh converter thing?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >OOP kind of basic scripting..eehh converter thing?</a><br><br>
<a name="1033678"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, this is just a show off on something i'm tinkering with:  It has no real application but its really uh i'm not sure....scripting maybe... well here it is.<br><br>Well I got inheritance and part of encapsulation to work, I think.<br><br>Will convert:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Class foo
	field a%
	field b$
	Method addone()
		a = a + 1	; Add one to field a
	End Method
	Private
	Method fillString(Say$)
		b = say		; Change the string b
	End Method
End Class

class bar : foo
	field x#	
	field y#
	field z#
	Method MoveX(Amount#)
		x = x + Amount
	end method
	method MoveY(Amount#)
		y = y + Amount
	end method
	method MoveZ(Amount#)
		z = z + Amount
	end method
end class

f.foo = New foo

t.bar = new bar

f.fillString("Boo!")

t.MoveX(12)

print f.b

t.MoveX(-6)

f.addone()

print t.x

Print f.a

f.a++

Print f.a

f.a--

print f.a

t.addone()

print t.a

print t.b

WaitKey()

</textarea><br><br>to working b3d code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
f.foo = New foo

t.bar = New bar

fillString_foo( f , "Boo!")

MoveX_bar( t , 12)

Print f\b

MoveX_bar( t , -6)

addone_foo( f )

Print t\x

Print f\a

f\a = f\a + 1

Print f\a

f\a = f\a - 1

Print f\a

addone_bar( t )

Print t\a

Print t\b

WaitKey()


Type foo
	Field a%
	Field b$
End Type
Function addone_foo(This.foo)
	This\a = This\a + 1	; Add one to field a
End Function
Function fillString_foo(This.foo,Say$)
	This\b = say		; Change the string b
End Function

Type bar
	Field a%
	Field b$
	Field x#	
	Field y#
	Field z#
End Type
Function addone_bar(This.bar)
	This\a = This\a + 1	; Add one to field a
End Function
Function MoveX_bar(This.bar,Amount#)
	This\x = This\x + Amount
End Function
Function MoveY_bar(This.bar,Amount#)
	This\y = This\y + Amount
End Function
Function MoveZ_bar(This.bar,Amount#)
	This\z = This\z + Amount
End Function

</textarea><br><br>Source<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global file = ReadFile("test.OB") ;The Objective Blitz3D file can be changed to whatever.

Global file2 = WriteFile("out.bb");The name of the converted output file to Objective Blitz3D.

Global LineIn$

ConvertOOPcode()	;run through the code to find classes and methods
WriteBlitzCode()	;Convert to Blitz3d code

CloseFile(file2)	;close the output file so that it can be debuged through blitz
CloseFile(file)		;close the Objective Blitz3D file

;Include "out.bb" 	;Open "out.bb" and run in any blitz3d ide, it will work!

End ;end the program

;Define Key words, not really used, but know that they are used in Objective Blitz3D
Const Class$ = "Class"
Const EndClass$ = "End Class"
Const Method$ = "Method"
Const EndMethod$ = "End Method"
Const Public$ = "Public"	;to be added - no I dont think its necessary..
Const Private$ = "Private"	


;Define all Class, Class within Class not supported yet.
;But inharitence is.
Type Class
	Field Name$
	Field Name_Lower$
	Field ClassTabs
	Field FieldBank
	Field FieldTabs
	Field TypesPointer$
	Field ParentClass.Class
	Field ContainMethods
	Field ContainPrivates
	Field ContainPublics
End Type

Type Method
	Field parentPTR.Class
	Field Name$
	Field Name_Lower$
	Field MethodReturnType%
	Field MethodParameters$
	Field MethodTab
	Field MethodCodeBank
	Field MethodCodeTabs
	Field Private
End Type

Function ConvertOOPcode()
	
	Local LineCount,TabCount,T.Class,Name$,OldBS,M.Method,LineRead,C.Class,ParentName$
	
	While Not Eof(file)
		
		LineRead = False
		LineIn$ = ReadLine(file):LineCount = LineCount + 1
		TabCount = RemoveTabs()
		ti = 0 : si = 0

		If Left$(LineIn$,Len(Class$)) = "Class" Or Left$(LineIn$,Len(Class$)) = "class" Then
			T.Class = ProcessClass.Class(LineIn$,TabCount)
			cf = 0:cm = 0
			LineRead = True
		EndIf
		If Left$(LineIn$,Len(EndClass$)) = "End Class" Or Left$(LineIn$,Len(EndClass$)) = "end Class" Or Left$(LineIn$,Len(EndClass$)) = "End class" Or Left$(LineIn$,Len(EndClass$)) = "end class" Then LineRead = True
		
		If Left$(LineIn$,5) = "Field" Or Left$(LineIn$,5) = "field" Then
			cf = ProcessField(T , cf, TabCount)
			LineRead = True
		EndIf
		If Left$(LineIn$,7) = "Private" Or Left$(LineIn$,7) = "private" Then T\ContainPrivates = True:LineRead = True
		If (LineIn$ = "End Method" Or LineIn$ = "end Method" Or LineIn$ = "End method" Or LineIn$ = "end method") Then MethodFlag = False:LineRead = True

		If MethodFlag Then
		
			OldBS = BankSize(M\MethodCodeBank)
			ResizeBank (M\MethodCodeBank,OldBS+Len(LineIn$)+1)
			ResizeBank(M\MethodCodeTabs,BankSize(M\MethodCodeTabs)+1)
			
			PokeByte(M\MethodCodeTabs,cmc,TabCount)
			cmc = cmc + 1
			
			For i = 1 To Len(LineIn$)
				what = Asc(Mid$(LineIn$,i,1))
				PokeByte(M\MethodCodeBank,(OldBS -1) + i,what)
			Next
			
			PokeByte(M\MethodCodeBank,(OldBS -1) + i,0)
			LineRead = True
		EndIf

		If Left$(LineIn$,6) = "Method" Or Left$(LineIn$,6) = "method" Then
			cmc = 0
			T\ContainMethods = True
			
			M.Method = New Method
			tm$ =  Right$(LineIn$,Len(LineIn$)-7)
			startx = 0: endx = 0
			For j = 1 To Len( tm )
				If Mid$(tm,j,1) = "(" Then StartX = j
				If Mid$(tm,j,1) = ")" Then EndX = j
			Next
			M\Name$ = Left$(tm,startx-1)
			If endx - startx &gt; 1 Then M\MethodParameters$ = Mid$(tm,startx+1,(endx-2)-startx+1)
			M\MethodTab = TabCount
			M\parentPTR = T
			M\MethodCodeBank = CreateBank()
			M\MethodCodeTabs = CreateBank()
			If T\ContainPrivates = True Then M\Private = True
			MethodFlag = True
			LineRead = True
		EndIf
		If LineRead = False Then 
			tol$ = Objective_Line$(LineIn$)
			If tol$ &lt;&gt; "" Then WriteLine(file2,tol$):WriteLine(file2,"")
		EndIf
	Wend
End Function

Function WriteBlitzCode()

	Local T.Class

	For T.Class = Each Class
		
		WriteLine(file2,"")
		
		If T\ParentClass = Null Then
			WriteLine(file2,ReplaceTabs$("Type" + " " + T\Name,T\ClassTabs))
		Else
			WriteLine(file2,ReplaceTabs$("Type" + " " + T\Name,T\ClassTabs))
			ProcessTypes(T\ParentClass)
		EndIf
		
		ProcessTypes(T)
		
		WriteLine(file2,ReplaceTabs$("End Type",T\ClassTabs))
		If T\ContainMethods = True And T\ParentClass = Null Then 
			WriteMethods(T)
		Else
			WriteParentMethods(T\ParentClass,T\Name)
			WriteMethods(T)
		EndIf
	Next
End Function

Function WriteMethods(T.Class)

	Local M.Method,Method,BS,Code$,mct,LIN$
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T Then
			
			tBS = 0:mct = 0
			If M\MethodParameters&lt;&gt;"" Then
				LIN$ = "Function "+ M\Name$+"_"+T\Name$+"(This."+T\Name+","+M\MethodParameters+")"
			Else
				LIN$ = "Function "+M\Name$+"_"+T\Name$+"(This."+T\Name$+")"
			EndIf
			WriteLine(file2,ReplaceTabs$(LIN$,M\MethodTab-1))
			BS = BankSize(M\MethodCodeBank)-1
			.NextLineOfCode
			For i = tBS To BS
				If PeekByte(M\MethodCodeBank,i) = 0 Then
					Code$=RewriteCodeForType(T,Code$)
					WriteLine(file2,ReplaceTabs$(Code$,PeekByte(M\MethodCodeTabs,mct)-1))
					Code$ = "":mct = mct + 1
					tbs = i + 1: Goto NextLineOfCode
				Else
					Code$ = Code$ + Chr(PeekByte(M\MethodCodeBank,i))
				EndIf
			Next
			WriteLine(file2,ReplaceTabs$("End Function",M\MethodTab-1))
		EndIf
	Next
End Function

Function WriteParentMethods(T.Class,Name$)

	Local M.Method,Method,BS,Code$,mct,LIN$
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T And M\Private = False Then
			
			tBS = 0:mct = 0
			If M\MethodParameters&lt;&gt;"" Then
				LIN$ = "Function "+ M\Name$+"_"+Name$+"(This."+Name+","+M\MethodParameters+")"
			Else
				LIN$ = "Function "+M\Name$+"_"+Name$+"(This."+Name$+")"
			EndIf
			WriteLine(file2,ReplaceTabs$(LIN$,M\MethodTab-1))
			BS = BankSize(M\MethodCodeBank)-1
			.NextLineOfCode
			For i = tBS To BS
				If PeekByte(M\MethodCodeBank,i) = 0 Then
					Code$=RewriteCodeForType(T,Code$)
					WriteLine(file2,ReplaceTabs$(Code$,PeekByte(M\MethodCodeTabs,mct)-1))
					Code$ = "":mct = mct + 1
					tbs = i + 1: Goto NextLineOfCode
				Else
					Code$ = Code$ + Chr(PeekByte(M\MethodCodeBank,i))
				EndIf
			Next
			WriteLine(file2,ReplaceTabs$("End Function",M\MethodTab-1))
		EndIf
	Next
End Function

Function RewriteCodeForType$(T.Class,Code$)
	Local StartX,EndX,I,Trig,J,TB=0,Out$,Fv$,Final$
	For I = 1 To Len(Code$)
		If Mid$(Code$,I,1) &lt;&gt;" " And Trig = 0 Then StartX = I: Trig = 1
		If Mid$(Code$,I,1) = " " Then 
			Trig = 0
			For J = 0 To BankSize(T\FieldBank)-1
				If PeekByte(T\FieldBank,J) = 0 Then 
					If Fv$ = Mid$(Code$,StartX,(I)-startx) Then 
						Code$=Left$(Code$,StartX-1)+"This\"+Fv$+Mid$(Code$,I,(Len(Code$) - I)+1)
					Else
						Fv$ = ""
					EndIf
				Else
					If PeekByte(T\FieldBank,J) &gt; 47 Then Fv$ = Fv$ + Chr(PeekByte(T\FieldBank,J))
				EndIf
			Next
		EndIf
	Next
	Return Code$
End Function

Function Objective_Line$(Code$)

	Local I,J,Fv$,TrigPLUS1,TrigMINUS1,TrigIsField,M.Method,TypesPointer$,StartX,K,Perenth,T.Class

	For T.Class = Each Class

		I = 0 :tn$ = "":StartX = 0:Point = 0:ThisPointer$=""
		
		For I = 1 To Len(Code$)
	
			If Mid$(Code$,I,1) = " " Then StartX = I
			
			If Mid$(Code$,I,1) = "." And Mid$(Code$,I+1,Len(T\Name$)) = T\Name$ Then
				If StartX = 0 Then
					T\TypesPointer$ = Mid$(Code$,1,(I) - 1)
				Else
					T\TypesPointer$ = Mid$(Code$,StartX,(I - 1) - StartX)
				EndIf
			Else If Mid$(Code$,I,1) = "." Then
				If StartX = 0 Then
					ThisPointer$ = Mid$(Code$,1,(I) - 1)
				Else
					ThisPointer$ = Mid$(Code$,StartX,(I - 1) - StartX)
				EndIf
			EndIf
			
			If Mid$(Code$,I,1) = "." And Mid$(Code$,I+1,Len(T\Name$))&lt;&gt; T\Name$ Then
				
				For J = 0 To BankSize(T\FieldBank)-1
					If PeekByte(T\FieldBank,J) = 0 Then 
						If Mid$(Code$,I+1,Len(T\Name$)) = Fv$ Then 
							Code$ = Mid$(Code$,1,I-1)+"\"+ Mid$(Code$,I+1,Len(Code$)-I+1)
							TrigIsField = True
						EndIf
						Fv$ = ""
					Else
						If PeekByte(T\FieldBank,J) &gt; 47 Then Fv$ = Fv$ + Chr(PeekByte(T\FieldBank,J))
					EndIf
				Next
				
				If Right$(Code$,2) = "++" Then TrigPLUS1 = True
				If Right$(Code$,2) = "--" Then TrigMINUS1 = True
				
				If TrigPLUS1 = True Or TrigMINUS1 = True Then Code$ = Left$(Code$,Len(Code$)-2)
				
				For J = 0 To BankSize(T\FieldBank)-1
					If PeekByte(T\FieldBank,J) = 0 Then 
						If Mid$(Code$,I+1,Len(T\Name$)) = Fv$ Then 
							Code$ = Mid$(Code$,1,I-1)+"\"+ Mid$(Code$,I+1,Len(Code$)-I+1)
						EndIf
						Fv$ = ""
					Else
						If PeekByte(T\FieldBank,J) &gt; 47 Then Fv$ = Fv$ + Chr(PeekByte(T\FieldBank,J))
					EndIf
				Next
				
				If TrigPLUS1 = True Then Code$ = Code$+ " = " +Code$+" + 1"
				If TrigMINUS1 = True Then Code$ = Code$+ " = " +Code$+" - 1"
				
				If TrigIsField = False And T\TypesPointer = ThisPointer Then

					For M.Method = Each Method
						tn$ =  Mid$(Code$,I+1,Len(M\Name$))
						If tn$ = M\Name$ And (T = M\parentPTR Or T\ParentClass = M\parentPTR) Then
							For K = 1 To Len(Code$)
								If Mid$(Code$,K,1) = "(" Then Perenth = K+1
							Next
							If Right$(Code$,2)="()" Then
								Code$ = M\Name$+"_"+T\Name$+"( "+T\TypesPointer+" "+Mid$(Code$,Perenth,Len(Code$) - Perenth+1)
							Else
								Code$ = M\Name$+"_"+T\Name$+"( "+T\TypesPointer+" , "+Mid$(Code$,Perenth,Len(Code$) - Perenth+1)
							EndIf
						EndIf
					Next
				EndIf
				
			EndIf
		Next
	Next
	Return Code$
End Function

Function ProcessClass.Class(LineIn$,TabCount)
	tlin = Len(LineIn$)-Len("Class")
		
	If tlin &lt;= 0 Then RuntimeError "Error @ Line: "+ LineCount+" Class has no name!"
	ParentName$ = ""
	
	T.Class = New Class
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,i,1) = ";" Then si = i
		If Mid$(LineIn$,i,1) = ":" Then ti = i
	Next

	If ti &lt;&gt; 0 Then ParentName$ = RemoveSpaces$(Mid$(LineIn$,(ti+1),(si-ti)-2))
	If ParentName$ &lt;&gt; "" Then
		For C.Class = Each Class
			If C\Name$=ParentName$ Or C\Name_Lower$=ParentName$ Then 
				T\ParentClass = C:T\Name = Mid$(LineIn$,7,ti - 8)
			EndIf
		Next
	Else
		T\Name = Right$(LineIn$,tlin-1)
	EndIf
	T\Name_Lower = Lower(T\name)
	T\ClassTabs = TabCount
	T\FieldBank = CreateBank()
	T\FieldTabs = CreateBank()
	T\ContainMethods = False

	LineRead = True
	Return T
End Function

Function ProcessField(T.Class,cf,TabCount)
	i = 0
	fieldName$ = Right$(LineIn$,Len(LineIn$)-6)
	
	OldBS = BankSize(T\fieldbank)
	ResizeBank(T\fieldbank,OldBS + Len(fieldName$)+1)
	ResizeBank(T\fieldtabs,BankSize(T\fieldtabs)+1)
	
	PokeByte(T\FieldTabs,cf,TabCount)
	
	;cf = cf + 1
	
	For i = 1 To (Len(fieldName$))
		what = Asc(Mid$(fieldName$,i,1))
		PokeByte(T\FieldBank,(OldBS-1) + i,what)
	Next
	
	PokeByte(T\FieldBank,(OldBS-1) + i,0)
	Return cf + 1
End Function

Function ProcessTypes(T.Class)
	.NextField
	
	BS =  BankSize(T\FieldBank)-1

	For i = TempBankPosition To BS
		value = PeekByte(T\FieldBank,i)
		If Chr(value) = Chr(0) Then 
			TempBankPosition = i + 1: Goto CompleteField
		Else 
			Fld$ = Fld$ + Chr(value)
		EndIf
	Next

	.CompleteField

	WriteLine (file2,ReplaceTabs$("Field" + " " + Fld$,PeekByte(T\FieldTabs,cf)))

	Fld$ = ""
	cf = cf + 1

	If i &lt; BS Then Goto NextField

End Function

; Remove Tabs from the OO code if any, keep track of how many there are
Function RemoveTabs()

	Local tc = 0
	
	While Left$(LineIn$,1) = Chr(9)
		tc = tc + 1
		LineIn$ = Right$(LineIn$,Len(LineIn$)-1)
	Wend
	
	Return tc
	
End Function

; Replace Tabs from the OO code so that the readablity is still present.
Function ReplaceTabs$(In$,Tabs)
	
	Local i
	
	For i = 1 To Tabs
		In$ = Chr(9) + In$
	Next
	
	Return In$
	
End Function

; Remove Spaces does exactly that from a string.
Function RemoveSpaces$(in$)
	
	While Left$(in$,1) = " "
		in$ = Right$(in$,Len(in$)-1)
	Wend
	
	Return in$
	
End Function


</textarea> <br><br></td></tr></table><br>
<a name="1033821"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> nice. it seems mark is trying to do the opposite with bmax2 :)<br><br>edit: what is out.bb?<br>edit2: nevermind I see... it doesnt work if out.bb isnt made before the file is compiled though.. I think a b3d to bmax converter would be relatively easy to make seing how simple this seems. <br><br></td></tr></table><br>
<a name="1033841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yea, it seems that  "Include file$" is compiled before any other procedural code.  Which is kind of dumb, as it skips program flow, making this which should work, not work.<br><br>Edit:  I mean, it copy's the code into the source file before compiled (kind of), but as the file isn't created yet it errors.  Wish there was a way around this. like an ExecuteBlitz3D( file$ ) would be awesome. That way it works sequentially after the main chunk of code is run. <br><br></td></tr></table><br>
<a name="1033847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Blitz3D isn't interpreted, so there's no way you could execute dynamically generated source at runtime - you need a scripting language for that. <br><br></td></tr></table><br>
<a name="1033853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> oops updated, with stuff.<br><br>cool!?<br><br>@Yasha: Maybe Blitz3D code could be made into an interpreted language via a userlib?  That might have some usefulness. <br><br></td></tr></table><br>
<a name="1034020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sure, that was called BlitzVirtualMachine (now BriskVM) :) <br><br></td></tr></table><br>
<a name="1034222"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Big update for this bit of code.  I should explain, I know very little about object oriented programming, and I don't know what I'm missing so if you do please let me know. Thanks.<br><br>Will Convert:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Space Invader like simpler Clone Writen in OB
; A test of OB capabilities

Class Position
	field X#
	Field Y#
	Method MoveX(Amount#)
		X = X + Amount
	end Method
	Method MoveY(Amount#)
		Y = Y + Amount
	end Method
	Method SetX(Pos#)
		x = Pos
	end Method
	Method SetY(Pos#)
		y = Pos
	end method
end Class

Class Player : Position
	Field Image

	Private
	
	Field Health
	field Shot_Timer
	Field Killed
	Field Number_Lives
	Field Player_Shots
	Field Mega_Bombs
	Field Level
	
	Method LossLife()
		Number_Lives = Number_Lives - 1
	end Method
	Method GainLife()
		Number_Lives = Number_LIves + 1
	End Method
	Method UseMegaBomb()
		Mega_Bombs = Mega_Bombs - 1
	end Method
	Method GainMegaBomb()
		Mega_Bombs = Mega_Bombs + 1
	End Method
	Method LevelUp()
		Level = level + 1
	end Method
	Method CreatePlayerImage()
		Image = CreateImage(32,32)
		SetBuffer ImageBuffer(Image)
		Color 0,0,255
		Line 0,32-1,15-1,0
		line 15-1,0,32-1,32-1
		line 32-1,32-1,0,32-1
		SetBuffer BackBuffer()
		Color 255,255,255
	End Method
	Method Controls()
		if keydown(203) then x = x - 4
		if keydown(205) then x = x + 4
		if x &lt; 0 then x = 0
		if x &gt; graphicswidth() then x = Graphicswidth()
		if keydown(200) and player_shots &lt; Max_Player_Shots and Shot_Timer &lt;= 0 then 
			S.PlayerShot = New playershot
			s.Setx(X)
			s.Sety(y)
			s.SetSpeed(5)
			player_shots = player_shots + 1
			Shot_Timer = (4)
		endif
		shot_Timer = shot_Timer - 1
	end method
	Method Draw()
		DrawImage Image,x,y
	end Method
	Method TestShots()
		for s.enemyshot = each enemyshot
			deltaX = s.x - x
			deltaX = deltax * deltaX
			deltaY = s.y - y
			deltaY = deltaY * deltaY
			dist = deltax + deltaY
			if dist &lt; 15*15 then 
				health = health - 1
				delete s
			endif
		next
	end method
end class

Class PlayerShot : Position
	Field Velocity#

	Method Destructor()
		Delete
	end Method
	Method SetSpeed(Speed#)
		Velocity = speed
	end Method
	Method Update()
		MoveY(-velocity)
		If y &lt; 0 then 
			Destructor()
			play.Player_shots = play.player_shots - 1
		endif
	end method
	Method Draw()
		color 255,255,255
		line x,y,x,y+velocity
	end method
end Class

Class EnemyShot : Position
	Field Velocity#
	
	Method Destructor()
		Delete
	end Method
	Method SetSpeed(Speed#)
		Velocity = speed
	end Method
	Method Update()
		movey( velocity)
		If y &gt; Graphicsheight() then 
			Destructor()
		endif
	end method
	Method Draw()
		color 255,255,255
		line x,y,x,y-velocity
	end method
end class

Class Enemy : Player
	field Life
	Field Mover
	Field MoveTimer
	Field ShotTimer
	Method CreateImage()
		Image = CreateImage(32,32)
		SetBuffer Imagebuffer(Image)
		Color 255,0,0
		Line 0,0,32-1,0
		line 32-1,0,15-1,32-1
		line 15-1,32-1,0,0
		setbuffer Backbuffer()
		color 255,255,255
	end method
	Method Draw()
		DrawImage Image,x,y
	end method
	Method Update()
		if moveTimer &lt;= 0 then 
			moveTimer = rand(300)
			Mover = Rand(0,1)
		endif
		if mover = 1 then
			movex(1)
		else
			movex(-1)
		endif
		if x &lt; 0 or x &gt; graphicswidth() then mover = 1 - mover
		if ShotTimer &lt;= 0 then 
			es.enemyshot = new enemyshot
			es.setx(x)
			es.sety(y)
			es.setspeed(2)
			Shottimer = rand(200)
		endif
		movetimer = movetimer -1
		shottimer = shottimer -1
	end Method
	Method TestShots()
		for s.Playershot = each playershot
			deltaX = s.x - x
			deltaX = deltax * deltaX
			deltaY = s.y - y
			deltaY = deltaY * deltaY
			dist = deltax + deltaY
			if dist &lt; 15*15 then 
				life = life - 1
				play.Player_shots = Play.Player_shots - 1
				delete s
			endif
			if life &lt;= 0 then
				play.killed = play.killed + 1
				delete
				return
			endif
		next
	end method
end class

Graphics3D 800,600,32,2
SetBuffer BackBuffer()
seedrnd millisecs()
AutoMidHandle true

Global Play.Player = new Player
Play.Number_Lives = 3
Global Max_Player_Shots = 25
Play.Player_shots = 0
Play.Mega_Bombs = 4
Play.CreatePlayerImage()
Play.Level = 5
play.setx(Graphicswidth()/2)
Play.sety(Graphicsheight()-15)

CreateLevel( Play.Level )

While not keyhit(1)
	cls
	UpdateControls()
	DrawEverything()
	play.Testshots()
	if play.killed = play.level then 
		play.level =  play.level * 2
		createlevel( play.level)
	endif
	if play.health &lt;= 0 and play.number_lives &lt;= 0 then 
		print "Game Over"
		waitkey()
		end
	endif
	if play.health &lt;= 0 then 
		play.health = play.level
		play.Number_lives = play.number_lives - 1
	endif
	locate 0,0
	print "Health: " + play.health
	print "Lives: " + play.Number_lives
	flip
wend

Function DrawEverything()
	Play.Draw()
	for e.enemy = each enemy
		e.draw()
	next
	for s.PlayerShot = each playershot
		s.draw()
	next
	for es.enemyshot = each enemyshot
		es.draw()
	next
end Function

Function CreateLevel(Level)
	play.killed = 0
	play.Health = 4
	for I = 1 to Level
		E.Enemy = new Enemy
		e.CreateImage()
		e.life = rand(1,10)
		e.SetX(Rand(GraphicsWidth()))
		e.Sety(Rand(GraphicsHeight()/2-16)+16)
	next
End Function

function UpdateControls()
	Play.Controls()
	for E.enemy = each enemy
		e.Update()
		e.TestShotS()
	next
	for S.Playershot = each playershot
		S.Update()
	next
	for es.enemyshot = each enemyshot
		es.update()
	next
end function
</textarea><br><br>To working  Blitz3d Code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Space Invader Clone Writen in OB
; A test of OB capabilities
Graphics3D 800,600,32,2
SetBuffer BackBuffer()
SeedRnd MilliSecs()
AutoMidHandle True
Global Play.Player = New Player
Play\Number_Lives = 3
Global Max_Player_Shots = 25
Play\Player_shots = 0
Play\Mega_Bombs = 4
CreatePlayerImage_Player( Play )
Play\Level = 5
SetX_Player( Play , GraphicsWidth()/2)
SetY_Player( Play , GraphicsHeight()-15)
CreateLevel( Play\Level )
While Not KeyHit(1)
	Cls
	UpdateControls()
	DrawEverything()
	TestShots_Player( Play )
	If play\killed = play\level Then 
		play\level =  play\level * 2
		createlevel( play\level)
	EndIf
	If play\health &lt;= 0 And play\number_lives &lt;= 0 Then 
		Print "Game Over"
		WaitKey()
		End
	EndIf
	If play\health &lt;= 0 Then 
		play\health = play\level
		play\Number_lives = play\number_lives - 1
	EndIf
	Locate 0,0
	Print "Health: " + play\health
	Print "Lives: " + play\Number_lives
	Flip
Wend
Function DrawEverything()
	Draw_Player( Play )
	For e.enemy = Each enemy
		Draw_Enemy( e )
	Next
	For s.PlayerShot = Each playershot
		Draw_PlayerShot( s )
	Next
	For es.enemyshot = Each enemyshot
		Draw_EnemyShot( es )
	Next
End Function
Function CreateLevel(Level)
	play\killed = 0
	play\Health = 4
	For I = 1 To Level
		E.Enemy = New Enemy
		CreateImage_Enemy( E )
		e\life = Rand(1,10)
		SetX_Enemy( E , Rand(GraphicsWidth()))
		SetY_Enemy( E , Rand(GraphicsHeight()/2-16)+16)
	Next
End Function
Function UpdateControls()
	Controls_Player( Play )
	For E.enemy = Each enemy
		Update_Enemy( E )
		TestShots_Enemy( E )
	Next
	For S.Playershot = Each playershot
		Update_PlayerShot( S )
	Next
	For es.enemyshot = Each enemyshot
		Update_EnemyShot( es )
	Next
End Function

Type Position
	Field X#	
	Field Y#	
End Type
Function MoveX_Position(This.Position,Amount#)
	This\X = This\X + Amount
End Function
Function MoveY_Position(This.Position,Amount#)
	This\Y = This\Y + Amount
End Function
Function SetX_Position(This.Position,Pos#)
	This\X = Pos
End Function
Function SetY_Position(This.Position,Pos#)
	This\Y = Pos
End Function

Type Player
	Field X#	
	Field Y#	
	Field Image%	
	Field Health%	
	Field Shot_Timer%	
	Field Killed%	
	Field Number_Lives%	
	Field Player_Shots%	
	Field Mega_Bombs%	
	Field Level%	
End Type
Function MoveX_Player(This.Player,Amount#)
	This\X = This\X + Amount
End Function
Function MoveY_Player(This.Player,Amount#)
	This\Y = This\Y + Amount
End Function
Function SetX_Player(This.Player,Pos#)
	This\X = Pos
End Function
Function SetY_Player(This.Player,Pos#)
	This\Y = Pos
End Function
Function LossLife_Player(This.Player)
	This\Number_Lives = This\Number_Lives - 1
End Function
Function GainLife_Player(This.Player)
	This\Number_Lives = This\Number_Lives + 1
End Function
Function UseMegaBomb_Player(This.Player)
	This\Mega_Bombs = This\Mega_Bombs - 1
End Function
Function GainMegaBomb_Player(This.Player)
	This\Mega_Bombs = This\Mega_Bombs + 1
End Function
Function LevelUp_Player(This.Player)
	This\Level = This\Level + 1
End Function
Function CreatePlayerImage_Player(This.Player)
	This\Image = CreateImage(32,32)
	SetBuffer ImageBuffer(This\Image)
	Color 0,0,255
	Line 0,32-1,15-1,0
	Line 15-1,0,32-1,32-1
	Line 32-1,32-1,0,32-1
	SetBuffer BackBuffer()
	Color 255,255,255
End Function
Function Controls_Player(This.Player)
	If KeyDown(203) Then This\X = This\X - 4
	If KeyDown(205) Then This\X = This\X + 4
	If This\X &lt; 0 Then This\X = 0
	If This\X &gt; GraphicsWidth() Then This\X = GraphicsWidth()
	If KeyDown(200) And This\Player_Shots &lt; Max_Player_Shots And This\Shot_Timer &lt;= 0 Then 
		S.PlayerShot = New playershot
		SetX_PlayerShot( S , This\X)
		SetY_PlayerShot( S , This\Y)
		SetSpeed_PlayerShot( S , 5)
		This\Player_Shots = This\Player_Shots + 1
		This\Shot_Timer = (4)
	EndIf
	This\Shot_Timer = This\Shot_Timer - 1
End Function
Function Draw_Player(This.Player)
	DrawImage This\Image,This\X,This\Y
End Function
Function TestShots_Player(This.Player)
	For s.enemyshot = Each enemyshot
		deltaX = s\x - This\X
		deltaX = deltax * deltaX
		deltaY = s\y - This\Y
		deltaY = deltaY * deltaY
		dist = deltax + deltaY
		If dist &lt; 15*15 Then 
			This\Health = This\Health - 1
			Delete s
		EndIf
	Next
End Function

Type PlayerShot
	Field X#	
	Field Y#	
	Field Velocity#	
End Type
Function MoveX_PlayerShot(This.PlayerShot,Amount#)
	This\X = This\X + Amount
End Function
Function MoveY_PlayerShot(This.PlayerShot,Amount#)
	This\Y = This\Y + Amount
End Function
Function SetX_PlayerShot(This.PlayerShot,Pos#)
	This\X = Pos
End Function
Function SetY_PlayerShot(This.PlayerShot,Pos#)
	This\Y = Pos
End Function
Function Destructor_PlayerShot(This.PlayerShot)
	Delete This
End Function
Function SetSpeed_PlayerShot(This.PlayerShot,Speed#)
	This\Velocity = speed
End Function
Function Update_PlayerShot(This.PlayerShot)
	MoveY_PlayerShot( This , -This\Velocity)
	If This\Y &lt; 0 Then 
		Destructor_PlayerShot( This )
		play\Player_shots = play\player_shots - 1
	EndIf
End Function
Function Draw_PlayerShot(This.PlayerShot)
	Color 255,255,255
	Line This\X,This\Y,This\X,This\Y+This\Velocity
End Function

Type EnemyShot
	Field X#	
	Field Y#	
	Field Velocity#	
End Type
Function MoveX_EnemyShot(This.EnemyShot,Amount#)
	This\X = This\X + Amount
End Function
Function MoveY_EnemyShot(This.EnemyShot,Amount#)
	This\Y = This\Y + Amount
End Function
Function SetX_EnemyShot(This.EnemyShot,Pos#)
	This\X = Pos
End Function
Function SetY_EnemyShot(This.EnemyShot,Pos#)
	This\Y = Pos
End Function
Function Destructor_EnemyShot(This.EnemyShot)
	Delete This
End Function
Function SetSpeed_EnemyShot(This.EnemyShot,Speed#)
	This\Velocity = speed
End Function
Function Update_EnemyShot(This.EnemyShot)
	MoveY_EnemyShot( This ,  This\Velocity)
	If This\Y &gt; GraphicsHeight() Then 
		Destructor_EnemyShot( This )
	EndIf
End Function
Function Draw_EnemyShot(This.EnemyShot)
	Color 255,255,255
	Line This\X,This\Y,This\X,This\Y-This\Velocity
End Function

Type Enemy
	Field Image%	
	Field X#	
	Field Y#	
	Field Life%	
	Field Mover%	
	Field MoveTimer%	
	Field ShotTimer%	
End Type
Function MoveX_Enemy(This.Enemy,Amount#)
	This\X = This\X + Amount
End Function
Function MoveY_Enemy(This.Enemy,Amount#)
	This\Y = This\Y + Amount
End Function
Function SetX_Enemy(This.Enemy,Pos#)
	This\X = Pos
End Function
Function SetY_Enemy(This.Enemy,Pos#)
	This\Y = Pos
End Function
Function CreateImage_Enemy(This.Enemy)
	This\Image = CreateImage(32,32)
	SetBuffer ImageBuffer(This\Image)
	Color 255,0,0
	Line 0,0,32-1,0
	Line 32-1,0,15-1,32-1
	Line 15-1,32-1,0,0
	SetBuffer BackBuffer()
	Color 255,255,255
End Function
Function Draw_Enemy(This.Enemy)
	DrawImage This\Image,This\X,This\Y
End Function
Function Update_Enemy(This.Enemy)
	If This\MoveTimer &lt;= 0 Then 
		This\MoveTimer = Rand(300)
		This\Mover = Rand(0,1)
	EndIf
	If This\Mover = 1 Then
		MoveX_Enemy( This , 1)
	Else
		MoveX_Enemy( This , -1)
	EndIf
	If This\X &lt; 0 Or This\X &gt; GraphicsWidth() Then This\Mover = 1 - This\Mover
	If This\ShotTimer &lt;= 0 Then 
		es.enemyshot = New enemyshot
		SetX_EnemyShot( es , This\X)
		SetY_EnemyShot( es , This\Y)
		SetSpeed_EnemyShot( es , 2)
		This\ShotTimer = Rand(200)
	EndIf
	This\MoveTimer = This\MoveTimer -1
	This\ShotTimer = This\ShotTimer -1
End Function
Function TestShots_Enemy(This.Enemy)
	For s.Playershot = Each playershot
		deltaX = s\x - This\X
		deltaX = deltax * deltaX
		deltaY = s\y - This\Y
		deltaY = deltaY * deltaY
		dist = deltax + deltaY
		If dist &lt; 15*15 Then 
			This\Life = This\Life - 1
			play\Player_shots = Play\Player_shots - 1
			Delete s
		EndIf
		If This\Life &lt;= 0 Then
			play\killed = play\killed + 1
			Delete This
			Return
		EndIf
	Next
End Function

</textarea><br><br>Source:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
FileName$ = "InVaders"
Global file = ReadFile(FileName+".OB") ;The Objective Blitz3D file can be changed to whatever.

Global file2 = WriteFile(FileName+".bb");The name of the converted output file to Objective Blitz3D.

Global LineIn$

ConvertOOPcode()	;run through the code to find classes and methods
WriteBlitzCode()	;Convert to Blitz3d code

CloseFile(file2)	;close the output file so that it can be debuged through blitz
CloseFile(file)		;close the Objective Blitz3D file

;Include "out.bb" 	;Open "out.bb" and run in any blitz3d ide, it will work!

End ;end the program

;Define Key words, not really used, but know that they are used in Objective Blitz3D
Const Class$ = "Class"
Const EndClass$ = "End Class"
Const Method$ = "Method"
Const EndMethod$ = "End Method"
Const Public$ = "Public"	;to be added - no I dont think its necessary..
Const Private$ = "Private"	
Const Destructor$ = "Destructor"
;Define all Class, Class within Class not supported yet.
;But inharitence is.
Type Class
	Field Name$
	Field Name_Lower$
	Field ClassTabs
	Field TypesPointer$
	Field ParentClass.Class
	Field ContainMethods
	Field ContainPrivates
	Field ContainPublics
	Field Comment$
End Type

Type Fields
	Field Name$
	Field Name_Lower$
	Field VariableType
	Field Tabs
	Field ParentClass.Class
	Field Private
	Field Comment$
End Type

Type Method
	Field parentPTR.Class
	Field Name$
	Field Name_Lower$
	Field MethodReturnType%
	Field MethodParameters$
	Field MethodTab
	Field MethodCodeBank
	Field MethodCodeTabs
	Field Private
	Field Comment$
End Type

Function ConvertOOPcode()
	
	Local LineCount,TabCount,T.Class,Name$,OldBS,M.Method,LineRead,C.Class,ParentName$
	
	While Not Eof(file)
		
		LineRead = False
		LineIn$ = ReadLine(file):LineCount = LineCount + 1
		TabCount = RemoveTabs()
		ti = 0 : si = 0

		If Left$(LineIn$,Len(Class$)) = "Class" Or Left$(LineIn$,Len(Class$)) = "class" Then
			T.Class = ProcessClass.Class(LineIn$,TabCount)
			cf = 0:cm = 0
			LineRead = True
		EndIf
		If Left$(LineIn$,Len(EndClass$)) = "End Class" Or Left$(LineIn$,Len(EndClass$)) = "end Class" Or Left$(LineIn$,Len(EndClass$)) = "End class" Or Left$(LineIn$,Len(EndClass$)) = "end class" Then LineRead = True
		
		If Left$(LineIn$,5) = "Field" Or Left$(LineIn$,5) = "field" Then
			ProcessField(LineIn$, T , TabCount)
			LineRead = True
		EndIf
		If Left$(LineIn$,7) = "Private" Or Left$(LineIn$,7) = "private" Then T\ContainPrivates = True:LineRead = True
		If (LineIn$ = "End Method" Or LineIn$ = "end Method" Or LineIn$ = "End method" Or LineIn$ = "end method") Then MethodFlag = False:LineRead = True

		If MethodFlag Then
		
			OldBS = BankSize(M\MethodCodeBank)
			ResizeBank (M\MethodCodeBank,OldBS+Len(LineIn$)+1)
			ResizeBank(M\MethodCodeTabs,BankSize(M\MethodCodeTabs)+1)
			
			PokeByte(M\MethodCodeTabs,cmc,TabCount)
			cmc = cmc + 1
			
			For i = 1 To Len(LineIn$)
				what = Asc(Mid$(LineIn$,i,1))
				PokeByte(M\MethodCodeBank,(OldBS -1) + i,what)
			Next
			
			PokeByte(M\MethodCodeBank,(OldBS -1) + i,0)
			LineRead = True
		EndIf

		If Left$(LineIn$,6) = "Method" Or Left$(LineIn$,6) = "method" Then
			cmc = 0
			T\ContainMethods = True
			
			M.Method = New Method
			tm$ =  Right$(LineIn$,Len(LineIn$)-7)
			startx = 0: endx = 0
			For j = 1 To Len( tm )
				If Mid$(tm,j,1) = "(" Then StartX = j
				If Mid$(tm,j,1) = ")" Then EndX = j
			Next
			M\Name$ = Left$(tm,startx-1)
			M\Name_Lower = Lower(M\Name)
			If endx - startx &gt; 1 Then M\MethodParameters$ = Mid$(tm,startx+1,(endx-2)-startx+1)
			M\MethodTab = TabCount
			M\parentPTR = T
			M\MethodCodeBank = CreateBank()
			M\MethodCodeTabs = CreateBank()
			If T\ContainPrivates = True Then M\Private = True
			MethodFlag = True
			LineRead = True
		EndIf
		If LineRead = False Then 
			If Left$(LineIn$,1) &lt;&gt; ";" Then
				If LineIn$ &lt;&gt; "" Then tol$ = Objective_Line$(LineIn$):WriteLine(file2,ReplaceTabs$(tol$,TabCount));:WriteLine(file2,"")
			Else
				WriteLine(file2,ReplaceTabs$(LineIn$,TabCount))
			EndIf
		EndIf
	Wend
End Function

Function WriteBlitzCode()

	Local T.Class,TT.Class

	For T.Class = Each Class
		
		WriteLine(file2,"")
		
		TT = T\ParentClass
		If TT &lt;&gt; Null Then	
			WriteLine(file2,ReplaceTabs$("Type" + " " + T\Name,T\ClassTabs))
			While TT &lt;&gt; Null 
				ProcessTypesParent(TT)
				TT = TT\ParentClass
			Wend
		Else
			WriteLine(file2,ReplaceTabs$("Type" + " " + T\Name,T\ClassTabs))
		EndIf
		ProcessTypes(T)
		
		WriteLine(file2,ReplaceTabs$("End Type",T\ClassTabs))
		If T\ContainMethods = True And T\ParentClass = Null Then 
			WriteMethods(T)
		Else
			TT = T\ParentClass
			While TT &lt;&gt; Null
				WriteParentMethods(TT,T\Name)
				TT = TT\ParentClass
			Wend
			WriteMethods(T)
		EndIf
	Next
End Function

Function WriteMethods(T.Class)

	Local M.Method,Method,BS,Code$,mct,LIN$
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T Then
			
			tBS = 0:mct = 0
			If M\MethodParameters&lt;&gt;"" Then
				LIN$ = "Function "+ M\Name$+"_"+T\Name$+"(This."+T\Name+","+M\MethodParameters+")"
			Else
				LIN$ = "Function "+M\Name$+"_"+T\Name$+"(This."+T\Name$+")"
			EndIf
			WriteLine(file2,ReplaceTabs$(LIN$,M\MethodTab-1))
			BS = BankSize(M\MethodCodeBank)-1
			.NextLineOfCode
			For i = tBS To BS
				If PeekByte(M\MethodCodeBank,i) = 0 Then
					Code$=RewriteCodeForType(T,Code$)
					WriteLine(file2,ReplaceTabs$(Code$,PeekByte(M\MethodCodeTabs,mct)-1))
					Code$ = "":mct = mct + 1
					tbs = i + 1: Goto NextLineOfCode
				Else
					Code$ = Code$ + Chr(PeekByte(M\MethodCodeBank,i))
				EndIf
			Next
			WriteLine(file2,ReplaceTabs$("End Function",M\MethodTab-1))
		EndIf
	Next
End Function

Function WriteParentMethods(T.Class,Name$)

	Local M.Method,Method,BS,Code$,mct,LIN$
	If Not T\ContainMethods Then Return
	For M.Method = Each Method
		If M\parentPTR = T And M\Private = False Then
			
			tBS = 0:mct = 0
			If M\MethodParameters&lt;&gt;"" Then
				LIN$ = "Function "+ M\Name$+"_"+Name$+"(This."+Name+","+M\MethodParameters+")"
			Else
				LIN$ = "Function "+M\Name$+"_"+Name$+"(This."+Name$+")"
			EndIf
			WriteLine(file2,ReplaceTabs$(LIN$,M\MethodTab-1))
			BS = BankSize(M\MethodCodeBank)-1
			.NextLineOfCode
			For i = tBS To BS
				If PeekByte(M\MethodCodeBank,i) = 0 Then
					Code$=RewriteCodeForType(T,Code$)
					WriteLine(file2,ReplaceTabs$(Code$,PeekByte(M\MethodCodeTabs,mct)-1))
					Code$ = "":mct = mct + 1
					tbs = i + 1: Goto NextLineOfCode
				Else
					Code$ = Code$ + Chr(PeekByte(M\MethodCodeBank,i))
				EndIf
			Next
			WriteLine(file2,ReplaceTabs$("End Function",M\MethodTab-1))
		EndIf
	Next
End Function

Function RewriteCodeForType$(T.Class,Code$)
	
	Local StartX,EndX,I,Trig,J.Fields,TB=0,Out$,Fv$,Final$,Tex$,K.Method
	
	For K.Method = Each Method
		If Lower(Left$(Code$,Len(K\Name)+1)) = K\Name_Lower+" " Or Lower(Left$(Code$,Len(K\Name)+1)) = K\Name_Lower+"("Then
			For I = 1 To Len(Code$)
				If Mid$(Code,I,1) = "(" And krig = False Then StartX = I:ktrig = True
			Next
			If Right$(Code,2) = "()" Then 
				Code$ = K\Name+"_"+T\Name+"( This )"
			Else
				Code$ = K\Name+"_"+T\Name+"( This , "+Right$(Code,Len(Code)-(StartX))
			EndIf
		EndIf
	Next
	
		
		Code$ = Objective_Line$(Code$)

	If Lower(Code$) = "delete" Then 
		Code$ = "Delete This"
	Else If Lower(Code$) = "new" Then 
		Code$ = "This."+T\Name+" = New "+T\Name
	Else
		For I = 1 To Len(Code$)
			
			;If Code$ = "if x &lt; 0 or x &gt; graphicswidth() then mover = 1 - mover" Then Stop
			Tex = Mid$(Code$,I,1)
			If (Tex &lt;&gt; " " Or Tex = "(" Or Tex = "," Or Tex = "+" Or Tex = "-" Or Tex = "=" Or Tex = "/" Or Tex = "*" Or Tex = "&lt;" Or Tex = "&gt;" Or Tex = ":") And Trig = 0 Then StartX = I: Trig = 1
			If Tex = " " Or Tex = "(" Or Tex = ")" Or Tex = "," Or Tex = "+" Or Tex = "-" Or Tex = "=" Or Tex = "/" Or Tex = "*" Or Tex = "&lt;" Or Tex = "&gt;" Or Tex = ":" Or I = Len(Code$) Then 
				Trig = 0
				For J.Fields = Each Fields 
					texm$ = Lower(Mid$(Code$,StartX,(I)-(startx-1)))
					texm = RemoveRightSideTabs_Spaces$(texm$)
					If texm = "" Then Goto skipp
					If I = Len(Code$) Then
						texn$ = Lower(Mid$(Code$,StartX,i-(StartX-1)))
						If Right$(Texn,1) = ")" Then texn = Left$(texn,Len(texn)-1)
						If J\Name_Lower = texn And Tex = ")" Then
							Code$=Left$(Code$,StartX-1)+"This\"+J\Name+")"
							I = I + 5
							Goto Skipp
						Else If J\Name_Lower = Lower(Right$(Code,I-StartX+1)) Then
							Code$=Left$(Code$,StartX-1)+"This\"+J\Name
							I = I + 5
							Goto skipp
						EndIf
					Else
						If J\Name_Lower = Lower(Mid$(Code$,StartX,(I)-startx)) Then 
							Code$=Left$(Code$,StartX-1)+"This\"+J\Name+Mid$(Code$,I,(Len(Code$) - I)+1)
							I = I + 5
							Goto skipp
						EndIf
					EndIf
				Next
				.skipp
			EndIf
			;If Tex = "." Then Code$ = Left$(Code$,i-1) + "\"+ Right$(Code$,Len(Code$)-i)
		Next
	EndIf
	
	Return Code$
	
End Function

Function Objective_Line$(Code$)

	Local I,J.Fields,Fv$,TrigPLUS1,TrigMINUS1,TrigIsField,M.Method,TypesPointer$,StartX,K,Perenth,T.Class,Tex$
	Local TT.Class
	If Left$(Code$,6) = "Global" Then GlobalFlag = True:Code$ = Right$(Code$,Len(Code$)-7)
	
	For T.Class = Each Class
		;If Code$ = "Play.CreatePlayerImage()" Then Stop
		I = 0 :tn$ = "":StartX = 0:Point = 0:ThisPointer$=""
		
		For I = 1 To Len(Code$)
			Tex = Mid$(Code$,I,1)
			If Tex = " " Then StartX = I
			
			If Tex = "." And Lower(Mid$(Code$,I+1,Len(T\Name$)+1)) = T\Name_lower$+" " Then
				If StartX = 0 Then
					T\TypesPointer$ = Mid$(Code$,1,(I) - 1)
				Else
					T\TypesPointer$ = Mid$(Code$,StartX+1,(I - 1) - StartX)
				EndIf
			Else If Tex = "." Then
				If StartX = 0 Then
					ThisPointer$ = Mid$(Code$,1,(I) - 1)
				Else
					ThisPointer$ = Mid$(Code$,StartX+1,I  - (StartX + 1))
				EndIf
			EndIf
			
			If Tex = "." And Lower(Mid$(Code$,I+1,Len(T\Name$)+1))&lt;&gt; T\Name_Lower$+" " Then
				
				For J.Fields = Each Fields
					If J\ParentClass = T Then
						If Lower(Mid$(Code$,I+1,Len(T\Name$))) = J\Name_Lower Then
							Code$ = Mid$(Code$,1,I-1)+"\"+ Mid$(Code$,I+1,Len(Code$)-I+1)
							TrigIsField = True
						EndIf
					EndIf
				Next
				
				If Right$(Code$,2) = "++" Then TrigPLUS1 = True
				If Right$(Code$,2) = "--" Then TrigMINUS1 = True
				
				If TrigPLUS1 = True Or TrigMINUS1 = True Then Code$ = Left$(Code$,Len(Code$)-2)
				
				For J.Fields = Each Fields
					If J\ParentClass = T Then
						whatTh$ = Lower(Mid$(Code$,I+1,Len(J\Name$)))
						If WhatTh$ = J\Name_Lower Then 
							Code$ = Mid$(Code$,1,I-1)+"\"+ Mid$(Code$,I+1,Len(Code$)-I+1)
						EndIf
					EndIf
				Next
				
				If TrigPLUS1 = True Then Code$ = Code$+ " = " +Code$+" + 1"
				If TrigMINUS1 = True Then Code$ = Code$+ " = " +Code$+" - 1"
				
				If TrigIsField = False And Lower(T\TypesPointer) = Lower(ThisPointer) Then

					For M.Method = Each Method
						tkp =0 
						tn$ = Lower( Mid$(Code$,I+1,Len(M\Name$)))
						If tn$ = M\Name_Lower$ Then 
							
							ParentTrigger = False
							TT = M\parentPTR
							While TT&lt;&gt;Null
								If (TT = M\parentPTR) Then
									ParentTrigger = True
								EndIf
								TT=TT\ParentClass
							Wend
							If ParentTrigger = True Then
								For K = 1 To Len(Code$)
									If Mid$(Code$,K,1) = "(" And tkp = 0 Then Perenth = K+1 :tkp = 1
								Next
								If Right$(Code$,2)="()" Then
									Code$ = M\Name$+"_"+T\Name$+"( "+T\TypesPointer+" "+Mid$(Code$,Perenth,Len(Code$) - Perenth+1)
								Else
									Code$ = M\Name$+"_"+T\Name$+"( "+T\TypesPointer+" , "+Mid$(Code$,Perenth,Len(Code$) - Perenth+1)
								EndIf
							EndIf
						EndIf
					Next
				EndIf
				
			EndIf
		Next
	Next
	If GlobalFlag Then
		Return "Global "+Code$
	Else
		Return Code$
	EndIf
End Function

Function ProcessClass.Class(LineIn$,TabCount)
	
	Local T.Class,C.Class,TLIN,ParentName$,TI,SI,I
	
	ParentName$ = ""
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then TI = I
	Next
	
	T.Class = New Class
	
	If SI &lt;&gt; 0 Then T\Comment = Right$(LineIn$,Len(LineIn$) - (SI-1)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	TLIN = Len(LineIn$)-Len("Class")
	If TLIN &lt;= 0 Then RuntimeError "Error @ Line: "+ LineCount+" Class has no name!"
	
	If TI &lt;&gt; 0 Then ParentName$ = RemoveSpaces$(Mid$(LineIn$,(TI+1),(SI - TI)-2))
	
	If ParentName$ &lt;&gt; "" Then
		For C.Class = Each Class
			If C\Name$=ParentName$ Or C\Name_Lower$=ParentName$ Then 
				T\ParentClass = C:T\Name = Mid$(LineIn$,7,TI - 8)
			EndIf
		Next
	Else
		T\Name = Right$(LineIn$, TLIN - 1)
	EndIf
	
	T\Name_Lower = Lower(T\name)
	T\ClassTabs = TabCount
	T\ContainMethods = False
	
	Return T
	
End Function

Function ProcessField(LineIn$,T.Class,TabCount)
	
	Local FieldName$,F.Fields,I,SI,TI
	
	For I = 1 To Len(LineIn$)
		If Mid$(LineIn$,I,1) = ";" Then SI = I
		If Mid$(LineIn$,I,1) = ":" Then TI = I		;Might use this for Privatization
	Next
	
	F.Fields = New Fields
	
	If SI &lt;&gt; 0 Then F\Comment = Right$(LineIn$,Len(LineIn$)-(SI-1)):LineIn$ = Left$(LineIn$,SI-1)
	
	LineIn$ = RemoveRightSideTabs_Spaces$(LineIn$)
	
	Select True
		Case Right$(LineIn$,1)="%"
			F\VariableType=0
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="$"
			F\VariableType=1
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Case Right$(LineIn$,1)="#"
			F\VariableType=2
			LineIn$ = Left$(LineIn$,Len(LineIn$)-1)
		Default
			F\VariableType=0
	End Select
	
	FieldName$ = Right$(LineIn$,Len(LineIn$)-6)
	F\Name = FieldName
	F\Name_Lower = Lower(FieldName)
	F\ParentClass = T
	F\Tabs = TabCount
	F\Private = T\ContainPrivates
	
End Function

Function ProcessTypes(T.Class)
	
	Local F.Fields,FT$
	
	For F.Fields = Each Fields
		FT = ""
		If F\ParentClass = T Then
			Select True
				Case F\VariableType = 0
					FT = "%"
				Case F\VariableType = 1
					FT = "$"
				Case F\VariableType = 2
					FT = "#"
			End Select
			WriteLine (file2,ReplaceTabs$("Field" + " " + F\Name+FT+Chr(9)+F\Comment,F\Tabs))
		EndIf
	Next
	
End Function

Function ProcessTypesParent(T.Class)
	
	Local F.Fields,FT$
	
	For F.Fields = Each Fields
		FT = ""
		
		If F\ParentClass = T And F\Private = False Then
			Select True
				Case F\VariableType = 0
					FT = "%"
				Case F\VariableType = 1
					FT = "$"
				Case F\VariableType = 2
					FT = "#"
			End Select
			WriteLine (file2,ReplaceTabs$("Field" + " " + F\Name+FT+Chr(9)+F\Comment,F\Tabs))
		EndIf
	Next
	
End Function

; Remove Tabs from the OO code if any, keep track of how many there are
Function RemoveTabs()

	Local tc = 0
	
	While Left$(LineIn$,1) = Chr(9)
		tc = tc + 1
		LineIn$ = Right$(LineIn$,Len(LineIn$)-1)
	Wend
	
	Return tc
	
End Function

; Replace Tabs from the OO code so that the readablity is still present.
Function ReplaceTabs$(In$,Tabs)
	
	Local i
	
	For i = 1 To Tabs
		In$ = Chr(9) + In$
	Next
	
	Return In$
	
End Function

; Remove Spaces does exactly that from a string.
Function RemoveSpaces$(in$)
	
	While Left$(in$,1) = " "
		in$ = Right$(in$,Len(in$)-1)
	Wend
	
	Return in$
	
End Function

; Remove Spaces and tabs on the right side(does not keep track of them)
Function RemoveRightSideTabs_Spaces$(In$)
	
	While Right$(In$,1) = " " Or Right$(In$,1) = Chr(9)
		In$ = Left$(In$,Len(In$)-1)
	Wend
	
	Return In$
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1035305"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MusicianKool</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is a more updated version of the above in my worklogs.<br><br>Wanted to show how the progress is going, and i'm not sure this should be here anymore it's kind of advanced to outside beginners stuff but, whatever i guess. I'm still working out the kinks but i have the beginning to OOPS to C++.<br><br>will convert OOPS:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; Comment test for cpp
#include &lt;iostream&gt; 		;Must use this include for using print and other commands
#include &lt;string&gt;			;Must be used to do strings
using namespace std

Class foo 					;Test Comment on Class
	field a% 				;Test Comment on Field
	field b$
	Method addhundo() 	;Test Comment on Method
		a += 100			;Test Comment on Method code
	end method				;Test Comment on Method Exit
End Class 					;Test Comment on Class exit

Function Main() 			;Test Comment on function
	foo f					;This creates a new class foo where f is the handle trying to make f.foo = new foo mean the same thing.
	print f.a
	f.addhundo()
	print f.a
	f.b = "Hello World!"
	print f.b
	Waitkey
end function				;Test Comment on function exit

</textarea><br><br>to working c++:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
// Comment test for cpp
#include &lt;iostream&gt; 		  // Must use this include for using print and other commands
#include &lt;string&gt;			  // Must be used to do strings
using namespace std;

class foo { //Test Comment on Class
public:
	int a;	//Test Comment on Field
	string b;	
	foo ();
	void addhundo ();
};//Test Comment on Class exit
foo::foo() { 
	a = 0;
	b = "";
} 
void foo::addhundo() { //Test Comment on Method
	a += 100;//Test Comment on Method code
} //Test Comment on Method Exit
void main(){//Test Comment on function
	foo f					;//This creates a new class foo where f is the handle trying to make f.foo = new foo mean the same thing.
	cout &lt;&lt; f.a &lt;&lt; endl;
	f.addhundo();
	cout &lt;&lt; f.a &lt;&lt; endl;
	f.b = "Hello World!";
	cout &lt;&lt; f.b &lt;&lt; endl;
	system("PAUSE");
}//Test Comment on function exit


</textarea><br><br>to early to hand out the source cause I have to figure out how to handle string variables better, well class string variables are easy but general strings are going to be a bit harder.  keeping track of individual variables is a pain but it can be done.<br><br>Edit: After a bit of research I found an easy way to do stings. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
