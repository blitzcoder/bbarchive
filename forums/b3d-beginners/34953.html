<!DOCTYPE html><html lang="en" ><head ><title >Physics for Stupid People like me</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Physics for Stupid People like me</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Physics for Stupid People like me</a><br><br>
<a name="378976"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Where is a good place to learn about Physics, For games, where they go over the formula in basic steps.<br>I have played around with Tokamak, and want to try to do some things on my own.<br><br>First I am trying to have a player slid down a ramp, and at the bottom fly off with believable physics (like a Ski jumper). If the player doesn't have enought forward velocity, he wouldn't even make it off the ramp.<br><br>Can someone point me to a great site, that explains these types of physical simulations.<br><br>Thanks,<br>Eric <br><br></td></tr></table><br>
<a name="379093"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eBusiness</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dunno about sites, but to do what you describe (with Blitz collisions), set collision type 2, set three variables for the objects movement vector, for every loop:<br>Subtract a gravity constant from the y-vector<br>Store the object position in three extra variables<br>Move the object acording to the movement vector<br>Call UpdateWorld<br>Set the movement vector to the objects new position, minus the old position that you stored<br><br>This does not take friction into account<br><br>If you want the object to be bouncy replace the last line with:<br>Set the movement vector to (the objects new position, minus the old position that you stored)+a*((the objects new position, minus the old position that you stored)-old movement vector)<br><br>Set a to a number between 0 and 1, 1 for full bounce.<br><br>Edit: Ehhh, skip what I said about bouncing, there is a flaw making the bounce sorta random, the rest should work though. <br><br></td></tr></table><br>
<a name="379100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eBusiness</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, whatever, you better learn it yourself. Vector math is inevitable <a href="http://www.physics.uoguelph.ca/tutorials/vectors/vectors.html" target="_blank">http://www.physics.uoguelph.ca/tutorials/vectors/vectors.html</a><br><br>Hmmm, something's missing from that site, dunno what it's called in english, I'll try a search. <br><br></td></tr></table><br>
<a name="379117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eBusiness</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Projecting, found this <a href="http://chortle.ccsu.edu/VectorLessons/vectorIndex.html" target="_blank">http://chortle.ccsu.edu/VectorLessons/vectorIndex.html</a> should contain all about vectors. Now we just need the physics. <br><br></td></tr></table><br>
<a name="379121"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey thanks, I glanced at it and will really learn something from this, I hope!! hahah Thanks<br><br>Eric <br><br></td></tr></table><br>
<a name="379255"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AbbaRue</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could start with "A Brief History of Time by Stephen Hawking "  <br>That covers the topic of the formation of the Universe, and should give you some background. <br>Or you could go to the following website, which explains things in more Computer related terms.  <br><a href="http://www-courses.cs.uiuc.edu/~cs318/lectures.html" target="_blank">http://www-courses.cs.uiuc.edu/~cs318/lectures.html</a> <br>And down the page on the following site you have other coarse pages:<br>101, 125, 225, 231, 232, 273, 290, 296, 299, 311, 321, 323,  <br><a href="http://www-courses.cs.uiuc.edu/" target="_blank">http://www-courses.cs.uiuc.edu/</a><br>You will need Adobe Acrobat for this because it's in .pdf format. <br><br><br>Take your choice. <br><br></td></tr></table><br>
<a name="379324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do a google search for "Chris Heckler" and "Jeff Lander". Both very cluey blokes in regard to game physics.<br><br>Also check out the physics articles at <a href="http://www.gamedev.net/" target="_blank">http://www.gamedev.net/</a> , <a href="http://www.gamasutra.com/" target="_blank">http://www.gamasutra.com/</a> and similar sites.<br><br>There's also several different physics engines in the 3d code archives on this site, which are worth checking out. There are some physics tutorials over at <a href="http://www.blitzcoder.com/" target="_blank">http://www.blitzcoder.com/</a> , too.<br><br>One thing I've found with physics is that the standard newbie method of integrating physics, using simple euler integration ( velocity = velocity + thrust : position = position + velocity ), doesn't cut it due to numerical instabilities that end up causing an accumulation of energy. There are various other methods of integrating physics, such as verlet, runga katta 4, etc, which you should also look into. <br><br></td></tr></table><br>
<a name="379457"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eBusiness</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> due to numerical instabilities <br></div>You talk about the bouncing ball right? Going higher and higher for no obvious reason. Normal flawy code is like this:<pre class=code>position=position+velocity
velocity=velocity+acceleration
If [ball hit floor] Then velocity=-velocity</pre>The ball will gain more and more height, because when the ball hit the floor, first acceleration due to gravity is added, then velocity is inverted, resulting in the ball launching upwards with greater speed than it came down with, the fix however is simple:<pre class=code>position=position+velocity
velocity=velocity+½acceleration
If [ball hit floor] Then velocity=-velocity
velocity=velocity+½acceleration</pre>This can be made a bit smoother:<pre class=code>position=position+velocity+½acceleration
velocity=velocity+acceleration
If [ball hit floor] Then velocity=-velocity</pre> <br><br></td></tr></table><br>
<a name="379654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Physt</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Coefficient of Restitution<br><br>If [ball hit floor] Then velocity=(-velocity * .92)<br><br>The ball loses energy when it hits the floors. <br><br></td></tr></table><br>
<a name="379731"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WolRon</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Only superballs have a coefficient of 90%.  All other balls have less. <br><br></td></tr></table><br>
<a name="379740"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CyberHeater</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think Sswift first posted this stuff.  Some of it might be usefull.<br><br>Okay. Here's the file. Of course I didn't write down every single equation I use in this file. :-) And there's some discussions I kept between me and some physics/math guys on a few of the more difficult subjects.<br><br><br><br><br><br><br>-------------------------------<br><br>"I wish I could remember the math term for and how to caclulate that sort of comparison. Like if you have 5 vertcies, it's 5+4+3+2+1 which is 15 comparisons."<br><br>- n(n+1)/2 is probably what you are looking for.<br><br>---------------------------------------<br><br>Anyway, here's the logic for the friction force: suppose we've<br>got a surface normal norm = (nx, ny, nz), and a gravity vector<br>running in the y direction grav = (0, 1, 0). We take their vector<br>cross-product to get a "sideways" vector<br><br>sideways = (sx, sy, sz) = (-nz / n, 0, -nx / n)<br><br>...where n = sqrt( nx * nx + nz * nz) is a normalizing factor, to<br>keep 'sideways' of unit length. n is also equal to the sine of the<br>angle between 'norm' and 'grav'.<br><br>Next thing to do is to vector-cross-product 'sideways' with 'norm',<br>thereby getting a unit vector that's in the plane of the surface,<br>going uphill:<br><br>uphill = sideways x norm = (-ny * nx / n, (nz * nz + nx * nx) / n, -ny * nz / n)<br>= (-ny * nx / n, n, -ny * nz / n)<br><br>Now we gotta multiply 'uphill' by the sine of the inclination... which,<br>as I mentioned a few paragraphs ago, happens to be n. So:<br><br>friction_force = uphill * n = (-ny * nx, n^2, -ny * nz)<br>= (-ny * nx, nx * nx + nz * nz, -ny * nz)<br><br>...which means that you can compute the force vector without having to<br>do square roots or other unpleasant forms of math.<br><br><br><br><br>Reducing velocity only in a direction perpendicular to the face collided with:<br>------------------------------------------------------------------------------<br>Assume V is the velocity vector and N is the normal.<br>N is perpendicular to the surface and has length 1.<br>The component of V in the direction of N is given by the dot product.<br><br>If you wanted to reduce velocity by 10% in the N direction then you would subtract:<br><br>V = V - 0.1 * (N dot V) * N ; pseudocode.<br><br>Of course, in Blitz you have to handle the x,y,z components separately:<br><br>Assume dot#, nx#, vx# etc. are all defined.<br><br>dot = nx*vx + ny*vy + nz*vz<br>vx = vx - 0.1*dot*nx<br>vy = vy - 0.1*dot*ny<br>vz = vz - 0.1*dot*nz<br><br><br>(N dot V) * N is the projection of V onto N.<br><br><br>OR..............<br><br><br>Dot# = NX * Item\SpdX + NY * Item\SpdY + NZ * Item\SpdZ<br><br>ReflectX# = NX * Dot#<br><br>ReflectY# = NY * Dot#<br><br>ReflectZ# = NZ * Dot#<br><br><br><br>; 1.0 stops bouncing<br><br>; 2.0 produces a perfect bounce (no loss of energy)<br><br>bounce# = 1.1 ; Retain only 10% of the energy<br><br><br><br>Item\SpdX = Item\SpdX - ReflectX# * bounce#<br><br>Item\SpdY = Item\SpdY - ReflectY# * bounce#<br><br>Item\SpdZ = Item\SpdZ - ReflectZ# * bounce#<br><br><br><br><br>&lt;Polytope&gt; max(|x|,|y|)=r, where max(a,b) = (|a+b|+|a-b|)/2<br>&lt;sswift&gt; if C is less than like 1...<br>&lt;sswift&gt; That would tell you the points to plot.;<br>&lt;PdoX&gt; so you mean, |x| + |y| - |xy| &lt;= 1<br>&lt;Polytope&gt; combine them and you get ||x|+|y||+||x|-|y||=2r<br>&lt;sswift&gt; is there an equation for abs too? :-)<br>&lt;PdoX&gt; |x| = sqrt(x^2)<br>&lt;PdoX&gt; though thats cheating<br><br><br>&lt;PdoX&gt; sswift: When two objects collide with initial energies E_1 and E_2, they end up with final energies E_1' E_2' where E_1 + E_2 = E_1' + E_2' + Q, where Q is the energy lost<br>&lt;PdoX&gt; (energy lost to vibration,etc. everything taken from kinetic energy)<br>&lt;PdoX&gt; For elastic collisions, you have Q=0<br>&lt;PdoX&gt; For inelastic, Q=E_1+E_2 (all)<br>&lt;PdoX&gt; actually, I need to be more careful here..<br>&lt;PdoX&gt; I'm in the Center of mass frame.<br><br><br>Fixed point numbers:<br>--------------------<br>Let's say that your range is [Ra .. Rb]. Ra can be a negative number or a positive number.<br><br>So let's say you want to compress an angle from -180 to +180 in your fixed point representation, and let's say you want to use 2 bytes for your fixed point number. For that we use a value of 65536. (256*256)<br><br><br>Then what you do to convert to fixed point is this:<br><br>FixedNum = ((FloatNum-Float(Ra)) / Float(Rb-Ra)) * 65536.0<br><br><br>And then to convert back you do this:<br><br>FloatNum# = ((Float(FixedNum) / 65536.0) * Float(Rb-Ra)) + Float(Ra)<br><br><br>And THAT will work for any range. Before I made a mistake, and the range always had to start with 0.<br><br>What THIS does is it first shifts the floating point number so it is in the range of 0..(Rb-Ra) So for example with -180 .. 180, RB-Ra is 360. So we get a range of 0..360.<br><br>Then after doing that it's divided by the number of numbers in the range, in this case 360, which scales it down to a number 0..1, THEn that number is multiplied by our fixed point maximum number, which is 65536.0, and we end up with an integer from 0..65536.<br><br>Then on the other end 65536 is converted back to 0..1, and then from there to 0..360, and then from there -180 is added to it which gives us our floating point number in the range of -180..180.<br><br>Don't concern yourself with the MOD stuff, that's only if you want to wrap values, and you can do that to the value before you do this equation.<br><br><br><br><br>Quaternions:<br>------------<br><br>A unit quaternion adheres to the following equation:<br>W^2+X^2+Y^2+Z^2 = 1<br><br><br><br>finding uniform random points around a point on a sphere.<br>---------------------------------------------------------<br>Find a point on the unit sphere:<br>P = (a,b,c)<br><br>The first step is to find a point N on the unit sphere which is 90 degrees (arc length) away.<br><br>N = (a/sqrt(a^2+b^2) , -b/sqrt(a^2+b^2), 0)<br>will work unless a=b=0.<br><br>now let T = PxN. so P,N,T are at right angles to each other<br><br>now let's see. we want to parameterize the circle of radius r centered at P<br><br>R = P*cos(r) + N*sin(r)*cos(t) + T*sin(r)*sin(t) should work<br><br>pick a random angle t between 0 and 360 and you have a random point in the circle<br><br><br><br>So in sphere space using P(0,0,1) N(0,1,0) T(1,0,0):<br><br><br>r = radius from point at 0,0,1<br>t = random number between 0 and 360<br><br>Rx = sin(r)*sin(t)<br>Ry = sin(r)*cos(t)<br>Rz = cos(r)<br><br><br><br>Radius should be set randonly too. I think. I think I can clip radius to create a hole.<br><br><br>Finding UNFORM random points on a sphere: (Ie: no pole clustering)<br>----------------------------------<br>choose a random angle t and a random number z between -1 and 1, then let r=sqrt(1-z^2), x=r*cos(t), y=r*sin(t).<br>then (x,y,z) is a random point on the sphere<br>(of radius 1, centered at the origin)<br><br><br>OR:<br><br>To generate a random point on the sphere, it is necessary only to generate two random numbers,<br>z between -R and R,<br><br>phi between 0 and 2 pi, each with a uniform distribution<br><br>To find the latitude (theta) of this point, note that z=Rsin(theta), so:<br><br>theta=sin-1(z/R)<br><br>its longitude is phi.<br><br>In rectilinear coordinates:<br><br>x=R*cos(theta)*cos(phi)<br>y=R*cos(theta)*sin(phi)<br>z=R*sin(theta)=z<br><br><br><br>Note that in both methods points will appear to be clustered if you attempt to step through it. The lattitude lines become more sparse as the longitude lines become more dense, so random points will be evenly distributed, but if you plot even lonigtude lines it will look wrong.<br><br><br><br>&lt;Polytope&gt; there is an amazing fact, which I don't know how to explain without calculus.<br>&lt;Polytope&gt; if you enclose a sphere in a cylinder (with no top or bottom) then the sphere and the cylinder have the same surface area.<br>&lt;Polytope&gt; moreover,if you project from the cylinder to the sphere, towards the axis of the cylinder, then this projection preserves area.<br>&lt;Polytope&gt; so, to choose random points on a sphere, you can just choose random points on a vertical cylinder, then project the points horizontally to the sphere.<br>&lt;monochrom&gt; The height of the cylinder is the diameter of the sphere, right?<br>&lt;Polytope&gt; monochrom: yes<br>&lt;Polytope&gt; archimedes discovered this somehow, waay before calculus. this is astonishing to me<br><br><br><br>---------------------------<br><br>"The extra 1m/s is therefore stored like a battery in form of kinetic energy in the object. If it would go upwards while it has the energy stored, it would use up that energy until the kinetic "battery" is used up."<br><br><br>Hm... that gives me an idea...<br><br>The correct way to model a ball would be to deform it when it hits the ground, and then undeform it over a period of time pushing it against the ground... This way the ball would actually be in contact with the ground much more often cause as it deforms it deforms downward maintaining contact with the ground.<br><br>In my current system the ball doesn't deform. When it hits the gorund it instantly changes direction and loses contact with the ground. This means that ground friction is only applied for a split second.<br><br>Of course, it seems odd to consider applying ground friction for an object moving in a direction away from the ground. You usually think of ground friction like ab object being slid over sandpaper. It doesn't make sense for it to affect the ball when it simply bounces straight up and down on the sandpaper, even if it's only doing it for a split second.<br><br><br>So I wonder if perhaps the physics which I am using is far too simplified. But these are the physics they teach in high school and all over the web! Why are they teaching stuff that's wrong?<br><br><br>I think maybe my idea about applying certain forces to certain "axis" would work.<br><br>For example, the ground friction would be applied only to forces in the XZ axis relative to the normal of the surface collided with. IE, a sliding force along the surface would be damped, but vertical forces, (vertical relative to the normal of the surface that is) would not.<br><br>If I went that route then I could apply a seprate model to forces which lie on the Y axis relative to the surface normal. So the "downward" force (downward realtive to the surface normal) when the ball hits the surface, would be cut by 50% on the rebound but the velocity on the XZ plane would remain untouched by the damping force.<br><br><br>Then, if I combine that with the idea about deforming the ball, so that the ball stays in constant contact with the plane if it is rolling along it, and stays in contact much longer when it collides at a shallow angle to it an ounces back up... If I do that, then ground friction should be modeled more accurately and more consistently on systems which calculate the physics at diffrent speeds! :-)<br><br><br><br><br><br>---------<br><br><br><br>quaterion is four numbers. One of them is w.<br>The other three are x,y,z which give a vector ( axis ) around which to rotate.<br>w is the cosine of half the angle of rotation.<br><br><br><br>Dtermining if two line segments intersect:<br>------------------------------------------<br><br>Let A,B,C,D be 2-space position vectors. Then the directed line segments AB &amp; CD are given by:<br><br>AB=A+r(B-A), r in [0,1]<br>CD=C+s(D-C), s in [0,1]<br><br>If AB &amp; CD intersect, then<br><br>A+r(B-A)=C+s(D-C), or<br><br>Ax+r(Bx-Ax)=Cx+s(Dx-Cx)<br>Ay+r(By-Ay)=Cy+s(Dy-Cy) for some r,s in [0,1]<br><br>Solving the above for r and s yields<br><br>(Ay-Cy)(Dx-Cx)-(Ax-Cx)(Dy-Cy)<br>r = ----------------------------- (eqn 1)<br>(Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)<br><br>(Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)<br>s = ----------------------------- (eqn 2)<br>(Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)<br><br>Let P be the position vector of the intersection point, then<br><br>P=A+r(B-A) or<br><br>Px=Ax+r(Bx-Ax)<br>Py=Ay+r(By-Ay)<br><br>By examining the values of r &amp; s, you can also determine some other limiting conditions:<br><br>If 0&lt;=r&lt;=1 &amp; 0&lt;=s&lt;=1, intersection exists<br>r&lt;0 or r&gt;1 or s&lt;0 or s&gt;1 line segments do not intersect<br><br>* If the denominator in eqn 1 is zero, AB &amp; CD are parallel<br><br>* If the numerator in eqn 1 is also zero, AB &amp; CD are coincident<br><br>If the intersection point of the 2 lines are needed (lines in this context mean infinite lines) regardless whether the two line segments intersect, then<br><br>* If r&gt;1, P is located on extension of AB<br>* If r&lt;0, P is located on extension of BA<br>* If s&gt;1, P is located on extension of CD<br>* If s&lt;0, P is located on extension of DC<br><br>Also note that the denominators of eqn 1 &amp; 2 are identical.<br><br><br><br><br>Plane equation and Sphere/Frustum Intersection Tests<br>----------------------------<br><br>Ax + By + Cz = D<br><br>A = y1 (z2 - z3) + y2 (z3 - z1) + y3 (z1 - z2)<br>B = z1 (x2 - x3) + z2 (x3 - x1) + z3 (x1 - x2)<br>C = x1 (y2 - y3) + x2 (y3 - y1) + x3 (y1 - y2)<br>- D = x1 (y2 z3 - y3 z2) + x2 (y3 z1 - y1 z3) + x3 (y1 z2 - y2 z1)<br><br><br><br>We'll need to figure out the plane equation for each one of those six planes:<br><br>A*x + B*y + C*z + D = 0<br><br><br>...that plane equation calculation can be done one-time whenever the view frustum is set up.<br><br>Note that for an arbitary point (px,py,pz), the distance to the plane is:<br><br>d = A*px + B*py + C*pz + D<br><br><br>...so for each vertex of your bounding volume, you can measure the distance to each of those planes.<br><br>For a sphere: Just toss the center point of the sphere into the equation above - and if the (signed) distance places the center point more than 'radius' units outside any of the planes then you can cull the object.<br><br><br><br>* In the plane equation mentioned above, (A,B,C) is the surface normal of the plane and D is the distance from the origin to the plane - measured such that D is positive for planes that face the origin and negative from those that don't.<br><br><br><br>------------------<br><br><br><br>Diffuse and phong lighting:<br><br><br>^N<br>|<br>Lÿÿÿ | R V<br>\ÿÿ | / __/<br>\ÿ | / __/<br>\ | / __/<br>\ | /__/<br>\|//<br>-------------.--------------<br>P<br>^<br>point under consideration<br><br><br>It's important you know what these values actually are:<br><br>N = surface normal<br>L = unit vector between point and light<br>V = unit vector between point and view<br>R = light reflection unit vector (mirror of L about N)<br><br><br>First, the diffuse relfection is given by the Lamertian Relfection<br>equation:<br><br>diffuse = Kd * (N dot L)<br><br>Where Kd is the diffuse relfection constant. (N dot L) is the same as<br>the cosine of the angle between N and L, so as the angle decrease, the<br>resulting diffuse value is higher.<br><br>Phong gave spectral reflectivity as:<br><br>diffuse + Ks * (R dot V)^n<br><br><br><br>other source:<br><br>lambert's "the light is dependant on the angle it hits the surface" law.<br>Use the dotproduct to get that value.<br><br>Angle = Dotproduct( Normal, vLightVector );<br><br>If Angle is negative then the light doesn't reach the point, otherwise use the<br>Angle multiplied with the light's color as the diffuse component. Oh, by the way,<br>colors are in the range [0.0, 1.0].<br><br><br><br><br><br><br>How to calculate the new vector of a ball which has struck a wall.<br>(Also the normal force?)<br>------------------------------------------------------------------<br><br>v = v - 2*n*(v . n)<br><br><br><br>(v . n = dot product of v and n... see below.)<br><br><br><br>Dot product of two vectors:<br>---------------------------<br>AdotB = ax*bx + ay*by + az*bz<br><br><br><br>Air Friction:<br>-------------<br><br>Here's how to compute air friction:<br><br>air_friction_force = air_friction_constant * vehicle_velocity^2<br><br>A good air friction constant might be 0.2<br><br>Then:<br><br>new_velocity = old_velocity - air_friction_force * time<br><br><br><br><br><br>---------------------------------------------------------------------------------------------------------------<br>The "normal force" - How to make an object "richochet" off a surface, or move downhill when pulled by gravity.<br>---------------------------------------------------------------------------------------------------------------<br><br>When an object impacts a surface, whether it is fired from a cannon, or is simply being pulled downwards by<br>gravity, a "normal force" is generated which is equal in strength to the forces which were acting on the object<br>when it hit.<br><br>This "normal force" (NF for short), is ALWAYS perpendicular the the surface.<br><br>Making pool balls bounce off bumpers and making a ball roll down a hill is done in the same way, and is very<br>simple to do.<br><br>All you have to do is find the velocity vector of the ball when it hit. In other words, add up the forces acting on it, like gravity, and the force applied to it when it was fired from the cannon.<br><br>Then when the ball hits the surface, calclulate a vector which is perpendicular to the surface, and which has the same magnitude as the forces which were acting on the ball at that moment, and add theforce vector of the ball to the normal force... The result will be a vactor which points in the expected direction.<br><br>For example, if you have a flat section of land, the normal force is straight up. And the force acting on the ball, gravity, points straight down. When you add them, they cancel eachother out exactly and the ball doesn't move at all, just as you'd expect.<br><br>If on the other hand the ball is rolling across the surface in addition to being pulled down by gravity, then the ball will continue to roll across the surface, but will still not move downwards at all.<br><br>Now if you have a hill, then the normal force points away from the hill... not straight up like on the flat plane example. So when you add the NF to the gravity acting on the ball, the result is a vector which points down the hill... so the ball rolls down the hill as expected!<br><br><br><br>-----------------------------------------------------<br>Finding the closest point on a line to another point.<br>-----------------------------------------------------<br>(x1, y1, z1), (x2, y2, z2) = ends of line segment<br>(x3, y3, y3) = point<br><br><br>u =<br><br>(x3 - x1)(x2 - x1) + (y3 - y1)(y2 - y1) + (z3 - z1)(z2 - z1)<br>-----------------------------------------------------------<br>(x2 - x1)(x2 - x1) + (y2 - y1)(y2 - y1) + (z2 - z1)(z2 - z1)<br><br><br><br>u = the location between the two end points of the line which is closest to the point.<br><br>If u is not between 0 and 1 then the closest point is not between P1 and P2<br><br><br>----------------------------<br>LINE-SPHERE-INTERSECTION<br>----------------------------<br><br>To find out if a line intersects a sphere, find the closest point on the line to the center of the sphere.<br>Then calculate the location of that point using U.<br>And finally, find out the if the distance from that point to the center of the sphere is less than the radius of the sphere.<br><br><br><br>------------------<br>DEGREES TO RADIANS<br>------------------<br><br>R = D * (Pi / 180)<br><br><br>------------------<br>RADIANS TO DEGREES<br>------------------<br><br>D = R * 180/pi<br><br><br>--------------------------------------------------------------<br>The angle to change a wheel for movement over a given distance.<br>--------------------------------------------------------------<br><br>A = angle in radians<br>R = Radius of wheel<br>D= Distance moved<br><br>D = R * A<br><br>A = D/R<br><br><br>-----------<br>SOUND<br>-----------<br><br>Volume = the volume of the sound.<br><br>MinDist =<br>The distance at which the sound is at 100% volume. The sound will not get any louder closer than this.<br>This has a big effect on how quickly the sound falls off. Since the sound card cannot make sounds that are extemely loud, it's probably best to set this value to around 1 meter, in your game units. Ie, 64, if 64 units equals a meter in your game.<br><br>SoundDistance = The distance to the sound.<br><br>maxvolume = the maximum volume of your sound.<br><br>Volume = (MinDist^2 * MaxVolume) / (SoundDistance + MinDist)^2<br><br><br>-----------<br>DISTANCE<br>-----------<br>dist = sqrt( (x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2 )<br><br>-------------<br>CIRCUMFERENCE<br>-------------<br>C = 2PiR<br><br>Circumfurence = 2 * Pi * Radius<br><br><br>--------<br>MOMENTUM<br>--------<br>P=MV<br><br>Momentum = Mass x Velocity<br><br><br>------------------------------<br>POINT BETWEEN TWO OTHER POINTS<br>------------------------------<br>CX = AX + D * (BX-AX)<br>CY = AY + D * (BY-AY)<br><br>D = Distance 0 .. 1<br>(AX,AY)(BX,BY) = Endpoints of line segment AB.<br><br><br>------------------------------------------<br>POLAR COORDINATES TO CARTESIAN COORDINATES<br>------------------------------------------<br>X = Radius * Cos(Theta)<br>Y = Radius * Sin(Theta)<br><br>Converts polar coordinates into cartesian coordinates. Drawing a pixel at X,Y for Theta 0..360 at a fixed radius would draw a circle.<br><br>------------------------------------------<br>Angle of a point from 0,0<br>------------------------------------------<br>Angle = ARCSIN(Y/R)<br>or<br>Angle = ARCCOS(X/R)<br><br>------------<br>NORMAL FORCE<br>------------<br>Fn = Fg * Cos(Theta)<br><br>If on a slope,<br>Fn = Normal Force<br>Fg = Force of gravity<br>Theta = Angle of the slope<br><br>The normal force is the force perpendicular to the angle of the slope, which needs to be added to the<br>force of gravity to determine how much accleration from gravity will actually affect the object.<br><br><br>-----------------------------------<br>CONVERTING A FORCE INTO XYZ VECTORS<br>-----------------------------------<br>Mxz = M * Cos(Ty)<br>Fy = M * Sin(Ty)<br>Fx = Mxz * Cos(Txz)<br>Fz = Mxz * Sin(Txz)<br><br>This equation converts a vector described in the polar coordinate system to one in the cartesian coordinate system.<br>The force is described with a magnitude (M) and two angles, an inclination (Ty) and a direction (Txz) on the XZ plane.<br><br>Fx, Fy, and Fz are the resulting forces on each axis.<br><br><br>------------------------------<br>CALCULATING THE CENTER OF MASS<br>------------------------------<br><br>Total_Mass = (mass1 + mass2 + ...)<br><br>x3 = (mass1*x1 + mass2*x2 + ...) / Total_Mass<br>y3 = (mass1*y1 + mass2*y2 + ...) / Total_Mass<br>z3 = (mass1*z1 + mass2*z2 + ...) / Total_Mass<br><br>Calculates a scaled average of the locations so that the center is closest to the more massive objects.<br><br>--------------------------------------------<br>CALCULATING THE CROSS-PRODUCT OF TWO VECTORS<br>--------------------------------------------<br><br>v and w are two vectors in 3-dimensional space<br><br>v x w (read "v cross w") is a vector whose magnitude is the product of the magnitudes of v and w, that is perpendicular to both v and w, and whose direction is given by the right-hand rule.<br><br>To compute a cross-product, usually what you end up doing is computing a determinant. Write a 3x3 matrix with the first row being the components of v, the second row being the components of w, and the third row being the unit vectors, i j k. The determinant of that is the cross-product of v and w<br><br>abc = xyz force 1<br>def = xyz force 2<br><br>(a,b,c) * (d,e,f) = (bf-ce, cd-af, ae-bd)<br><br>------<br>TORQUE<br>------<br><br>The torque generated by a force on a system is given by r x F.<br><br>r = The position vector of the point where the force is applied relatively to the center of mass.<br>F = A force vector.<br><br>r = (a,b,c)<br>F = (d,e,f)<br><br>T_F = (bf-ce, cd-af, ae-bd)<br><br>T_F is the torque generated by F.<br><br>So you compute the torques generated by all forces<br>you sum them (vector sum) and then you divide the resulting vector by the "moment of inertia"<br><br>"moment of intertia":<br>it's a measure of the system's "resistance" to rotation, if you want<br>it's a function of the point masses and their distance from the center of mass<br><br><br>are your "rods" mass-less?<br>then you just need to sum up m_i * r_i^2, i *think*<br>where m_i is a point mass, and r_i is its distance from the center of mass<br>divide the sum of torques by that quantity, and that's the angular acceleration vector<br>so if you have 2 objects, one with mass 1kg at 2 meters, and another with mass 2kg at 3 meters, the unnamed quantity is 1*2^2 + 2*3^2 = 22<br><br><br>to get the linear acceleration of a point from that, you compute (angular acceleration) x r<br>where r is the position vector of a point relative to the center of mass<br>x denotes a cross-product, again<br><br><br><br>the angular acceleration is a global measure of the rotational acceleration of the system<br>but, something close to the center of mass accelerates less (linearly) than something far from it<br>you take the A x r cross-product to take that into account<br>A x r will give you an acceleration vector, which you can add to the acceleration vector resulting from the sum of forces (which we computed a while ago)<br>the sum of those two is the acceleration of an individual point in the system<br><br><br>acceleration of system's center of mass = sum of forces / mass of system<br><br>--------<br>SPRINGS<br>--------<br><br>www.pcug.org.au/~apurdam/doublespring/doublespring.html<br>two masses, connected by one spring:<br><br>M1, M2 = masses<br>k = coefficient of stiffness of the spring<br>x1, x2 = the displacements of the masses from their positions of equilibrium<br>x1'', x2'' = the acceleration for M1 and M2<br>r = viscous damping<br>x1', x2' = velocity of masses (from previous frame?)<br><br>x1''= k / (M1*(x2-x1)) - r*x1'<br>x2''= k / (M2*(x1-x2)) - r*x2'<br><br><br><br>misc notes:<br><br>Logarithmic Impulse formula.<br>Impulse = Log(RestSpan) - Log(CurrentSpan)<br><br>Note: this is a different from the usual linear spring formula which is taught in physics classes. With the logarithmic formula, it should be impossible to completely compress the spring. It also means that springs that have long rest lengths vibrate much slower than short ones.<br><br><br>---------<br>Jet thrust against atmosphere<br>---------<br><br>throtte = 0..1<br><br>thrust = throttle * max( max_thrust * (max_height - height) / max_height, 0)<br><br><br>------------------------------------------------------------------------<br>Only allowing velocity along a specific axis or in a specific diredction<br>------------------------------------------------------------------------<br><br>If you have a vehicle like a hovercraft, then it's okay to allow the hovercraft to have inertia and slide<br>around in any direction. But if you have a wheeled vehicle, or a tank, then you won't want the vehicle to slide<br>sideways if it's on an incline... you only want it to be able to roll forward or backward.<br><br>This is pretty easy to fix.<br><br>Take your vehicle's momentum which you've just calculated by adding it's moemntum from the previous frame and adding the forces acting on the vehicle, and convert it into an angle and a magnitude. A = The angle, B = the magnitude.<br><br>C = The angle your tank is facing. Note that this can be totally diffrent from the angle the tank is trying to move in.<br><br>Now do the following calculation:<br><br>D = A-C<br><br>D is the angle of your momentum vector if it were translated into a space where A = 0... where your tank is facing along the X axis.<br><br>Now, create a new vector... where D is it's angle, and B is it's magnitude.<br><br>Next, convert the vector into X and Y components. Then discard the Y component of the velocty, because that doesn't lie on the axis the tank can roll along. The value you have remaining, X, is the amount of velcoity which is along the axis the tank can move along.<br><br>Finally, use X as your magnitude, and C (your tanks face driection) as your angle. That is your tank's new momentum vector. Convert it into X and Y components if need be.<br><br>Note that you only want to do this sort of thing when your tank is on the ground. And you might want to do some aditional calculations... for example, your tank might be able to move along the Y axis, but there might be a lot of friction if it does so. So if you tank is moving sideways through the air fast, when it lands, you might want it to slide a bit before coming to a stop. If you give that axis a lot of friction and add the remaining velcoity to the forwar dmomentum then you can allow for that.<br><br><br><br><br><br><br><br>Bresenham's lines drawing algorithm:<br><br><br>public void lineBresenham(int x0, int y0, int x1, int y1, Color color)<br>{<br>int pix = color.getRGB();<br>int dy = y1 - y0;<br>int dx = x1 - x0;<br>int stepx, stepy;<br><br>if (dy &lt; 0) { dy = -dy; stepy = -1; } else { stepy = 1; }<br>if (dx &lt; 0) { dx = -dx; stepx = -1; } else { stepx = 1; }<br>dy &lt;&lt;= 1; // dy is now 2*dy<br>dx &lt;&lt;= 1; // dx is now 2*dx<br><br>raster.setPixel(pix, x0, y0);<br>if (dx &gt; dy) {<br>int fraction = dy - (dx &gt;&gt; 1); // same as 2*dy - dx<br>while (x0 != x1) {<br>if (fraction &gt;= 0) {<br>y0 += stepy;<br>fraction -= dx; // same as fraction -= 2*dx<br>}<br>x0 += stepx;<br>fraction += dy; // same as fraction -= 2*dy<br>raster.setPixel(pix, x0, y0);<br>}<br>} else {<br>int fraction = dx - (dy &gt;&gt; 1);<br>while (y0 != y1) {<br>if (fraction &gt;= 0) {<br>x0 += stepx;<br>fraction -= dy;<br>}<br>y0 += stepy;<br>fraction += dx;<br>raster.setPixel(pix, x0, y0);<br>}<br>}<br>}<br><br><br><br><br>Lighting:<br><br>&lt;Jaia&gt; 1/x^2 is all nice and good<br>&lt;Jaia&gt; but there are 2 problems<br>&lt;Jaia&gt; first it blows up at the source, x=0<br>&lt;Jaia&gt; so we must start at some small but non-0 x<br>&lt;Jaia&gt; 2nd it never quite hits 0 though it gets close<br>&lt;Jaia&gt; so we must modify it a bit<br>&lt;Jaia&gt; the distance we need to get to is R<br>&lt;sswift&gt; So lets say I wanted the version that blows up... how would I do that, just for the sake of argument?<br>&lt;Jaia&gt; well you can use it directly B(x) = 1/x^2<br>&lt;Jaia&gt; but the 2 problems remain<br>&lt;Jaia&gt; near x=0 it blows up<br>&lt;sswift&gt; Cause I can make 0 distance a special case, and clamp the value to 255.<br>&lt;Jaia&gt; that's no good<br>&lt;sswift&gt; But that doesn't take R into account<br>&lt;Jaia&gt; since for x small but non0 it gets arbitrarily high<br>&lt;Jaia&gt; so simple claming is not a good idea<br>&lt;Jaia&gt; well we need to take R into account<br>&lt;Jaia&gt; this relates to the 2nd problem<br>&lt;Jaia&gt; basically R sets our scale<br>&lt;Jaia&gt; so really x/R is what is important here<br>&lt;Jaia&gt; x/R is 'normalised', it goes from 0 to 1<br>&lt;sswift&gt; I know someone gave me a simpler equation a long time ago which created an expoential curve between two points...<br>&lt;sswift&gt; I used it to make craters.<br>&lt;Jaia&gt; do you want exponential or 1/x^2?<br>&lt;Jaia&gt; they are quite different<br>&lt;sswift&gt; They are?<br>&lt;sswift&gt; :-)<br>&lt;sswift&gt; I tohught light fell off expoentially.<br>&lt;Jaia&gt; yes<br>&lt;Jaia&gt; e^(-x) is finite at x=0<br>&lt;Jaia&gt; and decays must more rapidly<br>&lt;Jaia&gt; 1/x^2 is a more accurate model<br>&lt;sswift&gt; And you know this how? :-)<br>&lt;Jaia&gt; since as you propagate the area of the spherical fronts of the light wave<br>&lt;Jaia&gt; goes as x^2<br>&lt;sswift&gt; You know about lighting? :-)<br>&lt;Jaia&gt; so the light intensity goes as 1/x^2<br>&lt;Jaia&gt; it's an area so it goes as ~ x^2<br>&lt;Jaia&gt; so we want the inverse of that<br>&lt;Jaia&gt; (with some constant of course but we care about overall dependence)<br>&lt;Jaia&gt; here is something you can do<br>&lt;Jaia&gt; x/R goes from 0 to 1<br>&lt;Jaia&gt; so let's split it into 100<br>&lt;Jaia&gt; x/100R<br>&lt;Jaia&gt; this is our tick mark<br>&lt;Jaia&gt; i mean, R/100<br>&lt;Jaia&gt; so we have something like<br>&lt;Jaia&gt; (R/100)^2 / (x + R/100)^2<br>&lt;Jaia&gt; notice this is equal to 1 at x=0<br>&lt;Jaia&gt; and then fall off as the inverse square as we want<br>&lt;Jaia&gt; so all it remains is to multiply by 255<br>&lt;Jaia&gt; 255(R/100)^2 / (x + R/100)^2<br>&lt;Jaia&gt; so at x=0 the value is 255 as desired and it will fall off in the desired way<br>&lt;sswift&gt; okay<br>&lt;Jaia&gt; at x=R we have 255/(101)^2 &lt;&lt; 1<br>&lt;Jaia&gt; which is quite small<br>&lt;Jaia&gt; basically the tick mark is R/100<br>&lt;Jaia&gt; we have 100 of these to get to R<br>&lt;Jaia&gt; each time i double the tick marks, i quarter the intesity, etc.<br>&lt;sswift&gt; So what's better or worse aobut this question than the other one you gave me?<br>&lt;sswift&gt; equation<br>&lt;Jaia&gt; well ... this one is slightly more accurate<br>&lt;Jaia&gt; the other one was exactly 0 at x=R<br>&lt;Jaia&gt; but at the expense of bending the 1/x^2 falling off rate a bit<br>&lt;Jaia&gt; to push it down enough<br>&lt;sswift&gt; If it's below 1 at R, then it'll be clamped cause I have integers.<br>&lt;Jaia&gt; but here it's so small at x=R it's totally fine<br>&lt;sswift&gt; So...<br>&lt;sswift&gt; this 100 bit...<br>&lt;Jaia&gt; 255(R/5)^2 / (x + R/5)^2<br>&lt;Jaia&gt; use that then<br>&lt;sswift&gt; Does it matter at all what that number is&gt;<br>&lt;Jaia&gt; this is enough<br>&lt;Jaia&gt; no no ...<br>&lt;Jaia&gt; 255(R/20)^2 / (x + R/20)^2<br>&lt;Jaia&gt; yes<br>&lt;Jaia&gt; 255/(number+1)^2 is the value at x=R<br>&lt;Jaia&gt; so i use 20<br>&lt;Jaia&gt; 255/(21^2) &lt; 255/400 &lt; 0.5<br>&lt;Jaia&gt; so we're ok<br>&lt;Jaia&gt; 255/(21^2) &lt; 255/400 &lt; 0.8<br>&lt;Jaia&gt; anyway<br>&lt;sswift&gt; So....<br>&lt;sswift&gt; What if I use a really large number there?<br>&lt;sswift&gt; That would mnake it more accurate?<br>&lt;sswift&gt; closer to 0?<br>&lt;Jaia&gt; no, not really ...<br>&lt;Jaia&gt; this is a little bit cheating<br>&lt;Jaia&gt; the requirement that it's "negligible" at x=R is somewhat artificial<br>&lt;Jaia&gt; and not precise<br>&lt;Jaia&gt; it's very vague in fact<br>&lt;Jaia&gt; the most sensible thing to do i think, without any other info<br>&lt;sswift&gt; Will it change the visible appearance of the lighting in any way?<br>&lt;Jaia&gt; is to make it just barely small enough at x=R<br>&lt;Jaia&gt; oh yes<br>&lt;sswift&gt; How so?<br>&lt;Jaia&gt; if you make that number huge<br>&lt;Jaia&gt; it will drop off immediately<br>&lt;Jaia&gt; near the source<br>&lt;sswift&gt; oh<br>&lt;Jaia&gt; and will be almost 0 throughout the whole range from 0 to R<br>&lt;Jaia&gt; that's like pushing R very far off<br>&lt;Jaia&gt; so that the tail of 1/x^2 is very small<br>&lt;Jaia&gt; i would make the tail just barely small enough at x=R<br>&lt;Jaia&gt; just below 1<br>&lt;Jaia&gt; so it fits your requirement<br>&lt;Jaia&gt; but still shows decay over the range<br>&lt;sswift&gt; That sounds like in my crater simulation... I could increase the exponent to ^3 ^4... and that would push the crater wall off into the distance.<br>&lt;Jaia&gt; without dying too quickly<br>&lt;Jaia&gt; and being uninteresting<br>&lt;Jaia&gt; right<br>&lt;Jaia&gt; 20 might be ok<br>&lt;Jaia&gt; 255(R/20)^2 / (x + R/20)^2<br>&lt;Jaia&gt; this is saying "R is quite far, but not extremely far so that most of the range the intensity is tiny"<br>&lt;sswift&gt; Okay<br>&lt;sswift&gt; I think I understand. If I have a problem I can tweak it to get it to look right by increasing ro decreasing that value.<br>&lt;Jaia&gt; to give you an idea<br>&lt;Jaia&gt; look at the value at x = R/2<br>&lt;Jaia&gt; halfway<br>&lt;Jaia&gt; it will be 255/(11)^2 = 255/121 ~ 2<br>&lt;Jaia&gt; from 255 to 2 halfway<br>&lt;Jaia&gt; this is a good check to see if it fits what you want<br>&lt;Jaia&gt; whatever c you pick<br>&lt;Jaia&gt; 255(R/N)^2 / (x + R/N)^2<br>&lt;Jaia&gt; N rather<br>&lt;Jaia&gt; for x=0 it's always 255<br>&lt;Jaia&gt; for x=R/2 it's 255/(N/2 + 1)^2<br>&lt;Jaia&gt; and for x=R it's 255/(N+1)^1<br>&lt;Jaia&gt; and for x=R it's 255/(N+1)^2<br>&lt;Jaia&gt; so this should give you a good idea<br>&lt;sswift&gt; The lightness will drop to 2 halfway to R with a value of R/2?<br>&lt;Jaia&gt; from 255 to 2<br>&lt;Jaia&gt; as you go from 0 to R/2<br>&lt;Jaia&gt; (on your way to R)<br>&lt;Jaia&gt; if that seems too low, drop N a bit<br>&lt;Jaia&gt; to 16 say<br>&lt;sswift&gt; Tht's increasing N. :-)<br>&lt;sswift&gt; Okay<br>&lt;Jaia&gt; then at x=R it's 255/17^2 = 255/289 &lt; 1<br><br><br>The Attenuation Function<br><br>1 / ( c0 + c1 * d + c2 * d * d )<br><br>*By Setting the constants c0, c1 &amp; c2, you can<br>adjust the falloff ramp of the light<br>*Setting c1 = 0, c2 &gt; 0 will give you a radial<br>distance squared falloff<br>*Setting c1 &gt; 0, c2 = 0 gives a linear falloff<br>*Attenuation denominators less than one will give<br>very large factors, thus making the light too<br>bright close up<br>*To avoid this, make sure c0 is set To some<br>positive number, 1 Or greater<br><br><br><br>&lt;Jaia&gt; 1/(x^2 + c)<br>&lt;sswift&gt; what is C<br>&lt;Jaia&gt; well, let's see<br>&lt;Jaia&gt; at x=0 we get 1/c<br>&lt;Jaia&gt; so we'll add another constant d<br>&lt;Jaia&gt; d/(x^2 + c)<br>&lt;Jaia&gt; d/c = 255<br>&lt;Jaia&gt; so x is given in the same units as R is?<br>&lt;sswift&gt; yes<br>&lt;Jaia&gt; ok<br>&lt;Jaia&gt; d/(x^2/R^2 + c)<br>&lt;Jaia&gt; at x=R we'll set it to 1<br>&lt;Jaia&gt; d/(1+c) = 1<br>&lt;Jaia&gt; d = 1+c<br>&lt;Jaia&gt; 255c = 1+c<br>&lt;Jaia&gt; c = 1/254<br>&lt;Jaia&gt; d = 255/254<br>&lt;Jaia&gt; change the value of d/(1+c) if you want<br>&lt;Jaia&gt; this is the value at x=R<br>&lt;Jaia&gt; d/c=255 is fixed<br>&lt;Jaia&gt; d/(1+c) is the final value, play with it if d/(1+c) = 1 seems no good<br>&lt;Jaia&gt; so we get as an idea<br>&lt;Jaia&gt; (255/254) / (x^2/R^2 + 1/254)<br>&lt;sswift&gt; Is that it?<br>&lt;sswift&gt; :-)<br>&lt;Jaia&gt; yup<br>&lt;Jaia&gt; play with d/(1+c) as i said<br>&lt;Jaia&gt; (you always have d/c = 255)<br>&lt;Jaia&gt; d/(x^2 + c) is our general rule<br>&lt;Jaia&gt; d/(1+c) gives the value of intensity at R<br>&lt;Jaia&gt; i set it to 1 here<br>&lt;Jaia&gt; (255/254) / (x^2/R^2 + 1/254)<br>&lt;Jaia&gt; and got that<br><br>&lt;Jaia&gt; and got that<br>&lt;sswift&gt; Why did you not set it to 0?<br>&lt;Jaia&gt; you can't<br>&lt;Jaia&gt; this function is never 0<br>&lt;Jaia&gt; d/(1+c) = 0<br>&lt;Jaia&gt; d = 0<br>&lt;Jaia&gt; oops<br>&lt;Jaia&gt; and besides<br>&lt;Jaia&gt; make it too small<br>&lt;Jaia&gt; will push out R too far<br>&lt;Jaia&gt; effectively speaking<br>&lt;Jaia&gt; as we discussed before<br>&lt;sswift&gt; hm...<br>&lt;Jaia&gt; your inensity will die out immediately<br>&lt;Jaia&gt; and be tiny for most of the range<br>&lt;sswift&gt; Could you perhaps make the range start at 256, go to 1, and then subtract 1 from the end result?<br>&lt;Jaia&gt; if you want<br>&lt;Jaia&gt; sure<br>&lt;sswift&gt; Is there anyhtign bad about that?<br>&lt;Jaia&gt; (256/255) / (x^2/R^2 + 1/255) - 1<br>&lt;Jaia&gt; not at all<br>&lt;Jaia&gt; in fact it's a good idea<br>&lt;sswift&gt; (256/255) / (x^2/r^2 + 1/255) - 1<br>&lt;sswift&gt; You typed it first<br>&lt;sswift&gt; :-)<br>&lt;Jaia&gt; that looks ok<br>&lt;sswift&gt; at least I know I was right<br>&lt;Jaia&gt; in general<br>&lt;Jaia&gt; d / (x^2/R^2 + c) - d/(1+c)<br>&lt;Jaia&gt; d/(1+c) is what your value at R would have been<br>&lt;Jaia&gt; so it will be useful to see how far you're pushing R<br>&lt;Jaia&gt; as before<br><br><br><br><br>&lt;Jaia&gt; 256c / (x^2/R^2 + 1/255) - 256c/(1+c)<br>&lt;Jaia&gt; c is our free parameter<br>&lt;Jaia&gt; the last term, 256c/(1+c) sets the scale<br>&lt;Jaia&gt; is it's much less than 1, it probably dies too quickly<br>&lt;Jaia&gt; i'd keep it around 1 or 2 or so<br>&lt;Jaia&gt; but maybe higher even<br>&lt;Jaia&gt; play with it<br>&lt;Jaia&gt; in all cases the value at R is 0<br>&lt;Jaia&gt; oh no ...<br>&lt;Jaia&gt; ack<br>&lt;Jaia&gt; d / (x^2/R^2 + c) - d/(1+c)<br>&lt;sswift&gt; ack what<br>&lt;sswift&gt; :-)<br>&lt;Jaia&gt; d/c - d/(1+c) = 255<br>&lt;Jaia&gt; d = 255/(1/c + 1/(1+c))<br>&lt;Jaia&gt; so this is d in terms of c<br>&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/c + 1/(1+c)) / (1+c)<br>&lt;Jaia&gt; that last term<br>&lt;Jaia&gt; - 255/blah blah<br>&lt;Jaia&gt; that's what you don't want too small<br>&lt;Jaia&gt; set it to 1-5 or so<br>&lt;Jaia&gt; and see how it works<br>&lt;Jaia&gt; the lower it is, the faster it decays<br>&lt;sswift&gt; what was wrong with this? (256/255) / (x^2/r^2 + 1/255) - 1<br>&lt;Jaia&gt; this is the case for 1<br>&lt;Jaia&gt; it may work well<br>&lt;Jaia&gt; i just gave you a more general case<br>&lt;sswift&gt; ah.<br>&lt;Jaia&gt; where you can tweak the parameter at will<br>&lt;Jaia&gt; just solve that last term<br>&lt;Jaia&gt; 255(1/(c(1+c)) + 1)<br>&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/(c(1+c) + 1)<br>&lt;Jaia&gt; ...<br>&lt;Jaia&gt; same thing<br>&lt;Jaia&gt; just cleaned up a bit<br>&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/(c(1+c)) + 1)<br>&lt;Jaia&gt; the one you gave has - 1<br>&lt;Jaia&gt; as a case<br>&lt;Jaia&gt; by changing c<br>&lt;Jaia&gt; you can make the - number different<br>&lt;Jaia&gt; for a certain c you get - 1<br>&lt;Jaia&gt; as you showed<br>&lt;Jaia&gt; change c to get different values - something<br>&lt;sswift&gt; Okay<br>&lt;Jaia&gt; making that something bigger makes the decay slower<br>&lt;Jaia&gt; etc.<br><br>&lt;Jaia&gt; etc.<br>&lt;Jaia&gt; unless i made a mistake<br>&lt;Jaia&gt; let me see<br>&lt;Jaia&gt; d/(x^2/R^2 + c)<br>&lt;Jaia&gt; d/(x^2/R^2 + c) - d/(1+c)<br>&lt;Jaia&gt; d/c - d/(1+c) = 255<br>&lt;Jaia&gt; d = 255/(1/c + 1/(1+c))<br>&lt;Jaia&gt; ya, looks ok<br><br><br>lighting<br>--------<br><br>; DX7 Lighting equation:<br>; Attenuation = 1 / (C0 + C1*D + C2*D*D)<br>;<br>; For some reason this equation does not seem to produce the expected results!<br>;<br>; In Blitz:<br>; C0,C2 = 0. C1=Light radius.<br>;<br>; Mark has said that Blitz's lighting follows this equation:<br>; Brightness = 1.0 / (Distance / Light_Radius)<br>;<br>; Which does what the DX7 equation should do, but I don't know why they're so different.<br>;<br>; The shadow system on the other hand uses a modified linear falloff.<br>;<br>; This is so that the distance at which the shadow attenuates completely is not really<br>; far away from it's origin. If we used the other equations, a caster would almost<br>; never be outside a light's range, and that would be very bad for the framerate!<br><br>; Standard linear falloff equation:<br>;<br>; L = Lightness<br>; R = Light max radius<br>; D = Distance from light<br>;<br>; L = (R - D) / R<br><br>; Linear falloff, modified to be offset so that:<br>;<br>; If D &lt; R1 then L &gt; 1<br>; If D = R1 then L = 1<br>; If D &gt;= R2 then L = 0<br>;<br>; L = (R2 - (D-R1)) / R2<br><br>Light_Falloff# = (R2# - (Vdist# - R1#)) / R2#<br><br>; Clamp the falloff value if we are outside max_range, or inside min_range.<br><br>If (Light_Falloff# &lt; 0) Then Light_Falloff# = 0<br>If (Light_Falloff# &gt; 1) Then Light_Falloff# = 1<br><br><br>; Convert the falloff value to a color for this vertex.<br>Light_Falloff# = 255.0 * (1.0 - Light_Falloff#)<br><br><br><br><br><br>a = 1 / (c0 + c1*d + c2*d*d)<br><br>converts to:<br><br>v = light_r * light_min_radius / distance<br><br>Which can be inverted to:<br><br>d = light_r * light_min_radius / v<br><br>To find out the distance at which v becomes some value. <br><br></td></tr></table><br>
<a name="380251"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> All of my secrets, revealed!  The horror!<br><br>Here's the latest version of that document. :-)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Point inside concave bounding volume:
-------------------------------------

Dtemrining if a point is inside a convex bounding volume 
is easy... just dtermine if the point is on the back side
of all planes that form the volume.  But what if the volume 
is concave, or is unknown?

Containment within a non-convex volume:

If the volume is concave, the best test for
containment is the piercing test. We take a ray,
for simplicity parallel to one of the axes, and
count the number of intersections it makes
leaving the body. If that is odd, the point is
contained, if even then it is outside.


Also, if any point of an object is inside a volume, then the object definitely intersects that volume.
However, it is possible for an object to intersect a volume without any of its points being inside the volume,
nor any of the volume's points inside it.  So this is a "sloppy" test which will only allow us to quickly
determine many, but not all, of the objects that intersect a concave volume.


Logarithmic spirals:
--------------------


 It is not too hard to solve for A and B simply do the following:
(easier with pen and paper so I will use * for multiply here)
R1=A*exp(B*t1)
R2=A*Exp(B*t2)

(ln is log to the base e here)

ln(R1)= ln(A) + B*t1 , this is equation 1
ln(R2)= ln(A) + B*t2 , this is equation 2

Multiply equation 1 by t2/t1

(t2/t1)*ln(R1) = (t2/t1)*ln(A) + B*t2 , this is equation 3

subtract equation 2 from equation 3

(t2/t1)*ln(R1) - ln(R2) = (t2/t1)*ln(A) - ln(A), and the B terms cancel giving us equation 4

Solve equation 4 for A:

(t2/t1)*ln(R1) - ln(R2) = ((t2/t1) - 1)*ln(A)

ln(A) = [(t2/t1)*ln(R1) - ln(R2)]/[(t2/t1)-1]

so A = exp[(t2/t1)*ln(R1) - ln(R2)]/[(t2/t1)-1]

then solve for B by substituting A back into either equation 1 or equation 2, we shall do equation 1.

ln(R1) = ln(A) + B*t1

B = [ln(R1) - ln(A)]/t1

B = (ln(R1)/t1) - [(t2/t1)*ln(R1) - ln(R2)]/[(t2/t1)-1]/t1

which gives us our equations for A and B 




rearranging an equation with an exponent:
-----------------------------------------

b = a^p

Is the same as:

a = b^(1/p)


Also:

B = A^P = Exp(P*Log(A))
Thus P * Log(A) = Log(B),
Thus P = Log(B) / Log(A) 


Log follows these rules:

1. Log(x*y) = Log(x) + Log(y)
2. Log(x^y) = y * Log(x)

This all started with the polar equation R = A*Exp(B*theta).

Taking logarithms changes this to Log(R) = Log(A) + B*theta. 



length of an arc on a circle of radius R:
-----------------------------------------
&lt;sswift&gt; Could someone tell me, given a circle of radius R, what is the length of an arc of one degree on that circle?  
&lt;factorRSA&gt; degree*pi/180*R
&lt;factorRSA&gt; or rad*R


normals:
----------------------


You only need to store two components of a normal, because you know that the result has to add
up to 1.  So you can store just the X and the Y components of the normal, and extract the Z 
from that, like so:
	

newVec.z = sqrtf(1 - (sqr(newVec.x) + sqr(newVec.y)));

since Normalized mean its magnitude is 1, and the magnitude is
sqr(x) + sqr(y) + sqr(z)? 




-------------------------------

"I wish I could remember the math term for and how to caclulate that sort of comparison. Like if you have 5 vertcies, it's 5+4+3+2+1 which is 15 comparisons."

- n(n+1)/2 is probably what you are looking for. 

---------------------------------------

 Anyway, here's the logic for the friction force: suppose we've
got a surface normal norm = (nx, ny, nz), and a gravity vector
running in the y direction grav = (0, 1, 0). We take their vector
cross-product to get a "sideways" vector

sideways = (sx, sy, sz) = (-nz / n, 0, -nx / n)

...where n = sqrt( nx * nx + nz * nz) is a normalizing factor, to
keep 'sideways' of unit length. n is also equal to the sine of the
angle between 'norm' and 'grav'.

Next thing to do is to vector-cross-product 'sideways' with 'norm',
thereby getting a unit vector that's in the plane of the surface,
going uphill:

uphill = sideways x norm = (-ny * nx / n, (nz * nz + nx * nx) / n, -ny * nz / n)
= (-ny * nx / n, n, -ny * nz / n)

Now we gotta multiply 'uphill' by the sine of the inclination... which,
as I mentioned a few paragraphs ago, happens to be n. So:

friction_force = uphill * n = (-ny * nx, n^2, -ny * nz)
= (-ny * nx, nx * nx + nz * nz, -ny * nz)

...which means that you can compute the force vector without having to
do square roots or other unpleasant forms of math. 




Reducing velocity only in a direction perpendicular to the face collided with:
------------------------------------------------------------------------------
 Assume V is the velocity vector and N is the normal.
N is perpendicular to the surface and has length 1.
The component of V in the direction of N is given by the dot product.

If you wanted to reduce velocity by 10% in the N direction then you would subtract:

V = V - 0.1 * (N dot V) * N ; pseudocode.

Of course, in Blitz you have to handle the x,y,z components separately:

Assume dot#, nx#, vx# etc. are all defined.

dot = nx*vx + ny*vy + nz*vz
vx = vx - 0.1*dot*nx
vy = vy - 0.1*dot*ny
vz = vz - 0.1*dot*nz


(N dot V) * N is the projection of V onto N. 


OR..............


Dot# = NX * Item\SpdX + NY * Item\SpdY + NZ * Item\SpdZ

ReflectX# = NX * Dot#

ReflectY# = NY * Dot#

ReflectZ# = NZ * Dot#



; 1.0 stops bouncing

; 2.0 produces a perfect bounce (no loss of energy)

bounce# = 1.1   ; Retain only 10% of the energy



Item\SpdX = Item\SpdX - ReflectX# * bounce#

Item\SpdY = Item\SpdY - ReflectY# * bounce#

Item\SpdZ = Item\SpdZ - ReflectZ# * bounce#




&lt;Polytope&gt; max(|x|,|y|)=r, where max(a,b) = (|a+b|+|a-b|)/2
&lt;sswift&gt; if C is less than like 1...
&lt;sswift&gt; That would tell you the points to plot.;
&lt;PdoX&gt; so you mean, |x| + |y| - |xy| &lt;= 1
&lt;Polytope&gt; combine them and you get ||x|+|y||+||x|-|y||=2r
&lt;sswift&gt; is there an equation for abs too? :-)
&lt;PdoX&gt; |x| = sqrt(x^2)
&lt;PdoX&gt; though thats cheating


&lt;PdoX&gt; sswift: When two objects collide with initial energies E_1 and E_2, they end up with final energies E_1' E_2' where E_1 + E_2 = E_1' + E_2' + Q, where Q is the energy lost
&lt;PdoX&gt; (energy lost to vibration,etc. everything taken from kinetic energy)
&lt;PdoX&gt; For elastic collisions, you have Q=0
&lt;PdoX&gt; For inelastic, Q=E_1+E_2 (all)
&lt;PdoX&gt; actually, I need to be more careful here..
&lt;PdoX&gt; I'm in the Center of mass frame.


Fixed point numbers:
--------------------
Let's say that your range is [Ra .. Rb]. Ra can be a negative number or a positive number.

So let's say you want to compress an angle from -180 to +180 in your fixed point representation, and let's say you want to use 2 bytes for your fixed point number. For that we use a value of 65536. (256*256)


Then what you do to convert to fixed point is this:

FixedNum = ((FloatNum-Float(Ra)) / Float(Rb-Ra)) * 65536.0


And then to convert back you do this:

FloatNum# = ((Float(FixedNum) / 65536.0) * Float(Rb-Ra)) + Float(Ra)


And THAT will work for any range. Before I made a mistake, and the range always had to start with 0.

What THIS does is it first shifts the floating point number so it is in the range of 0..(Rb-Ra) So for example with -180 .. 180, RB-Ra is 360. So we get a range of 0..360.

Then after doing that it's divided by the number of numbers in the range, in this case 360, which scales it down to a number 0..1, THEn that number is multiplied by our fixed point maximum number, which is 65536.0, and we end up with an integer from 0..65536.

Then on the other end 65536 is converted back to 0..1, and then from there to 0..360, and then from there -180 is added to it which gives us our floating point number in the range of -180..180.

Don't concern yourself with the MOD stuff, that's only if you want to wrap values, and you can do that to the value before you do this equation.




Quaternions:
------------

A unit quaternion adheres to the following equation: 
W^2+X^2+Y^2+Z^2 = 1



finding uniform random points around a point on a sphere.
---------------------------------------------------------
Find a point on the unit sphere:
P = (a,b,c)  

The first step is to find a point N on the unit sphere which is 90 degrees (arc length) away.

N = (a/sqrt(a^2+b^2) ,  -b/sqrt(a^2+b^2), 0)    
will work unless a=b=0.

now let T = PxN. so P,N,T are at right angles to each other

now let's see. we want to parameterize the circle of radius r centered at P

R = P*cos(r) + N*sin(r)*cos(t) + T*sin(r)*sin(t) should work

pick a random angle t between 0 and 360 and you have a random point in the circle



So in sphere space using P(0,0,1) N(0,1,0) T(1,0,0):


r = radius from point at 0,0,1
t = random number between 0 and 360

Rx = sin(r)*sin(t) 
Ry = sin(r)*cos(t)
Rz = cos(r)



Radius should be set randonly too.  I think.  I think I can clip radius to create a hole.


Finding UNFORM random points on a sphere:  (Ie: no pole clustering)
----------------------------------
choose a random angle t and a random number z between -1 and 1, then let r=sqrt(1-z^2), x=r*cos(t), y=r*sin(t).
then (x,y,z) is a random point on the sphere
(of radius 1, centered at the origin)


OR:

To generate a random point on the sphere, it is necessary only to generate two random numbers, 
z between -R and R, 

phi between 0 and 2 pi, each with a uniform distribution

To find the latitude (theta) of this point, note that z=Rsin(theta), so: 

theta=sin-1(z/R)

its longitude is phi.

In rectilinear coordinates:

x=R*cos(theta)*cos(phi)
y=R*cos(theta)*sin(phi)
z=R*sin(theta)=z



Note that in both methods points will appear to be  clustered if you attempt to step through it.  The lattitude lines become more sparse as the longitude lines become more dense, so random points will be evenly distributed, but if you plot even lonigtude lines it will look wrong.



&lt;Polytope&gt; there is an amazing fact, which I don't know how to explain without calculus.
&lt;Polytope&gt; if you enclose a sphere in a cylinder (with no top or bottom) then the sphere and the cylinder have the same surface area.
&lt;Polytope&gt; moreover,if you project from the cylinder to the sphere, towards the axis of the cylinder, then this projection preserves area.
&lt;Polytope&gt; so, to choose random points on a sphere, you can just choose random points on a vertical cylinder, then project the points horizontally to the sphere.
&lt;monochrom&gt; The height of the cylinder is the diameter of the sphere, right?
&lt;Polytope&gt; monochrom: yes
&lt;Polytope&gt; archimedes discovered this somehow, waay before calculus. this is astonishing to me



---------------------------

"The extra 1m/s is therefore stored like a battery in form of kinetic energy in the object. If it would go upwards while it has the energy stored, it would use up that energy until the kinetic "battery" is used up."


Hm... that gives me an idea...  

The correct way to model a ball would be to deform it when it hits the ground, and then undeform it over a period of time pushing it against the ground... This way the ball would actually be in contact with the ground much more often cause as it deforms it deforms downward maintaining contact with the ground.

In my current system the ball doesn't deform.  When it hits the gorund it instantly changes direction and loses contact with the ground.  This means that ground friction is only applied for a split second.

Of course, it seems odd to consider applying ground friction for an object moving in a direction away from the ground.  You usually think of ground friction like ab object being slid over sandpaper.  It doesn't make sense for it to affect the ball when it simply bounces straight up and down on the sandpaper, even if it's only doing it for a split second.


So I wonder if perhaps the physics which I am using is far too simplified.  But these are the physics they teach in high school and all over the web!  Why are they teaching stuff that's wrong?


I think maybe my idea about applying certain forces to certain "axis" would work.  

For example, the ground friction would be applied only to forces in the XZ axis relative to the normal of the surface collided with.  IE, a sliding force along the surface would be damped, but vertical forces, (vertical relative to the normal of the surface that is) would not.

If I went that route then I could apply a seprate model to forces which lie on the Y axis relative to the surface normal.  So the "downward" force (downward realtive to the surface normal) when the ball hits the surface, would be cut by 50% on the rebound but the velocity on the XZ plane would remain untouched by the damping force.


Then, if I combine that with the idea about deforming the ball, so that the ball stays in constant contact with the plane if it is rolling along it, and stays in contact much longer when it collides at a shallow angle to it an ounces back up...  If I do that, then ground friction should be modeled more accurately and more consistently on systems which calculate the physics at diffrent speeds! :-)





--------- 



quaterion is four numbers. One of them is w.
The other three are x,y,z which give a vector ( axis ) around which to rotate.
w is the cosine of half the angle of rotation.



Dtermining if two line segments intersect:
------------------------------------------

Let A,B,C,D be 2-space position vectors.  Then the directed line segments AB &amp; CD are given by:

        AB=A+r(B-A), r in [0,1]
        CD=C+s(D-C), s in [0,1]

If AB &amp; CD intersect, then

        A+r(B-A)=C+s(D-C), or

        Ax+r(Bx-Ax)=Cx+s(Dx-Cx)
        Ay+r(By-Ay)=Cy+s(Dy-Cy)  for some r,s in [0,1]

Solving the above for r and s yields

            (Ay-Cy)(Dx-Cx)-(Ax-Cx)(Dy-Cy)
        r = -----------------------------  (eqn 1)
            (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)

            (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
        s = -----------------------------  (eqn 2)
            (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)

Let P be the position vector of the intersection point, then

        P=A+r(B-A) or

        Px=Ax+r(Bx-Ax)
        Py=Ay+r(By-Ay)

By examining the values of r &amp; s, you can also determine some other limiting conditions:

        If 0&lt;=r&lt;=1 &amp; 0&lt;=s&lt;=1, intersection exists
            r&lt;0 or r&gt;1 or s&lt;0 or s&gt;1 line segments do not intersect

    * If the denominator in eqn 1 is zero, AB &amp; CD are parallel

    * If the numerator in eqn 1 is also zero, AB &amp; CD are coincident

If the intersection point of the 2 lines are needed (lines in this context mean infinite lines) regardless whether the two line segments intersect, then

    * If r&gt;1, P is located on extension of AB
    * If r&lt;0, P is located on extension of BA
    * If s&gt;1, P is located on extension of CD
    * If s&lt;0, P is located on extension of DC

Also note that the denominators of eqn 1 &amp; 2 are identical.




Plane equation and Sphere/Frustum Intersection Tests
----------------------------

Ax + By + Cz = D

    A = y1 (z2 - z3) + y2 (z3 - z1) + y3 (z1 - z2)
    B = z1 (x2 - x3) + z2 (x3 - x1) + z3 (x1 - x2)
    C = x1 (y2 - y3) + x2 (y3 - y1) + x3 (y1 - y2)
- D = x1 (y2 z3 - y3 z2) + x2 (y3 z1 - y1 z3) + x3 (y1 z2 - y2 z1)



We'll need to figure out the plane equation for each one of those six planes:

A*x + B*y + C*z + D = 0


...that plane equation calculation can be done one-time whenever the view frustum is set up.

Note that for an arbitary point (px,py,pz), the distance to the plane is:

d = A*px + B*py + C*pz + D


...so for each vertex of your bounding volume, you can measure the distance to each of those planes.

For a sphere: Just toss the center point of the sphere into the equation above - and if the (signed) distance places the center point more than 'radius' units outside any of the planes then you can cull the object.



* In the plane equation mentioned above, (A,B,C) is the surface normal of the plane and D is the distance from the origin to the plane - measured such that D is positive for planes that face the origin and negative from those that don't.



------------------



Diffuse and phong lighting:


                  ^N
		  |
	    Lÿÿÿ  |     R        V
	     \ÿÿ  |    /      __/
	      \ÿ  |   /    __/
	       \  |  /  __/
		\ | /__/
		 \|//
     -------------.--------------
		  P
		  ^
		  point under consideration


  It's important you know what these values actually are:

  N	= surface normal
  L     = unit vector between point and light
  V	= unit vector between point and view
  R     = light reflection unit vector (mirror of L about N)


  First, the diffuse relfection is given by the Lamertian Relfection
  equation:

    diffuse = Kd * (N dot L)

  Where Kd is the diffuse relfection constant. (N dot L) is the same as
  the cosine of the angle between N and L, so as the angle decrease, the
  resulting diffuse value is higher.

  Phong gave spectral reflectivity as:

    diffuse + Ks * (R dot V)^n



other source:

 lambert's "the light is dependant on the angle it hits the surface" law.
Use the dotproduct to get that value. 

Angle = Dotproduct( Normal, vLightVector );

If Angle is negative then the light doesn't reach the point, otherwise use the
Angle multiplied with the light's color as the diffuse component. Oh, by the way,
colors are in the range [0.0, 1.0].






How to calculate the new vector of a ball which has struck a wall.
(Also the normal force?)
------------------------------------------------------------------

v = v - 2*n*(v . n)
 


(v . n = dot product of v and n... see below.)



Dot product of two vectors:
---------------------------
AdotB = ax*bx + ay*by + az*bz



Air Friction:
-------------

Here's how to compute air friction:

air_friction_force = air_friction_constant * vehicle_velocity^2

A good air friction constant might be 0.2

Then:

new_velocity = old_velocity - air_friction_force * time





---------------------------------------------------------------------------------------------------------------
The "normal force" - How to make an object "richochet" off a surface, or move downhill when pulled by gravity.
---------------------------------------------------------------------------------------------------------------

When an object impacts a surface, whether it is fired from a cannon, or is simply being pulled downwards by 
gravity, a "normal force" is generated which is equal in strength to the forces which were acting on the object
when it hit.

This "normal force" (NF for short), is ALWAYS perpendicular the the surface.

Making pool balls bounce off bumpers and making a ball roll down a hill is done in the same way, and is very 
simple to do.

All you have to do is find the velocity vector of the ball when it hit.  In other words, add up the forces acting on it, like gravity, and the force applied to it when it was fired from the cannon.

Then when the ball hits the surface, calclulate a vector which is perpendicular to the surface, and which has the same magnitude as the forces which were acting on the ball at that moment, and add theforce vector of the ball to the normal force... The result will be a vactor which points in the expected direction.

For example, if you have a flat section of land, the normal force is straight up.  And the force acting on the ball, gravity, points straight down.  When you add them, they cancel eachother out exactly and the ball doesn't move at all, just as you'd expect.

If on the other hand the ball is rolling across the surface in addition to being pulled down by gravity, then the ball will continue to roll across the surface, but will still not move downwards at all.

Now if you have a hill, then the normal force points away from the hill... not straight up like on the flat plane example.  So when you add the NF to the gravity acting on the ball, the result is a vector which points down the hill... so the ball rolls down the hill as expected!



-----------------------------------------------------
Finding the closest point on a line to another point.
-----------------------------------------------------
(x1, y1, z1), (x2, y2, z2) = ends of line segment
(x3, y3, y3) = point


u =

(x3 - x1)(x2 - x1) + (y3 - y1)(y2 - y1) + (z3 - z1)(z2 - z1)
-----------------------------------------------------------
(x2 - x1)(x2 - x1) + (y2 - y1)(y2 - y1) + (z2 - z1)(z2 - z1)



u = the location between the two end points of the line which is closest to the point.

If u is not between 0 and 1 then the closest point is not between P1 and P2


----------------------------
LINE-SPHERE-INTERSECTION
----------------------------

To find out if a line intersects a sphere, find the closest point on the line to the center of the sphere.
Then calculate the location of that point using U.
And finally, find out the if the distance from that point to the center of the sphere is less than the radius of the sphere.



------------------
DEGREES TO RADIANS
------------------

R = D * (Pi / 180)


------------------
RADIANS TO DEGREES
------------------

D = R * 180/pi 


--------------------------------------------------------------
The angle to change a wheel for movement over a given distance.
--------------------------------------------------------------

A = angle in radians 
R = Radius of wheel
D= Distance moved

D = R * A

A = D/R


-----------
SOUND
-----------

Volume = the volume of the sound.

MinDist =
The distance at which the sound is at 100% volume.  The sound will not get any louder closer than this.
This has a big effect on how quickly the sound falls off.  Since the sound card cannot make sounds that are extemely loud, it's probably best to set this value to around 1 meter, in your game units.  Ie, 64, if 64 units equals a meter in your game.
          
SoundDistance = The distance to the sound.

maxvolume = the maximum volume of your sound.

Volume = (MinDist^2 * MaxVolume) / (SoundDistance + MinDist)^2


-----------
DISTANCE
-----------
dist = sqrt( (x1 - x2)^2  + (y1 - y2)^2  + (z1 - z2)^2 )

-------------
CIRCUMFERENCE
-------------
C = 2PiR

Circumfurence = 2 * Pi * Radius


--------
MOMENTUM
--------
P=MV  

Momentum = Mass x Velocity


------------------------------
POINT BETWEEN TWO OTHER POINTS
------------------------------
CX = AX + D * (BX-AX)   
CY = AY + D * (BY-AY)

D = Distance 0 .. 1
(AX,AY)(BX,BY) = Endpoints of line segment AB.


------------------------------------------
POLAR COORDINATES TO CARTESIAN COORDINATES
------------------------------------------
X = Radius * Cos(Theta)
Y = Radius * Sin(Theta)

Converts polar coordinates into cartesian coordinates.  Drawing a pixel at X,Y for Theta 0..360 at a fixed radius would draw a circle.

------------------------------------------
Angle of a point from 0,0
------------------------------------------
Angle = ARCSIN(Y/R)
or
Angle = ARCCOS(X/R)

------------
NORMAL FORCE
------------
Fn = Fg * Cos(Theta)

If on a slope, 
Fn = Normal Force
Fg = Force of gravity
Theta = Angle of the slope

The normal force is the force perpendicular to the angle of the slope, which needs to be added to the 
force of gravity to determine how much accleration from gravity will actually affect the object.


-----------------------------------
CONVERTING A FORCE INTO XYZ VECTORS 
-----------------------------------
Mxz = M * Cos(Ty)
Fy = M * Sin(Ty)
Fx = Mxz * Cos(Txz)
Fz = Mxz * Sin(Txz)

This equation converts a vector described in the polar coordinate system to one in the cartesian coordinate system.
The force is described with a magnitude (M) and two angles, an inclination (Ty) and a direction (Txz) on the XZ plane.

Fx, Fy, and Fz are the resulting forces on each axis.


------------------------------
CALCULATING THE CENTER OF MASS
------------------------------

Total_Mass = (mass1 + mass2 + ...)

x3 = (mass1*x1 + mass2*x2 + ...) / Total_Mass
y3 = (mass1*y1 + mass2*y2 + ...) / Total_Mass
z3 = (mass1*z1 + mass2*z2 + ...) / Total_Mass

Calculates a scaled average of the locations so that the center is closest to the more massive objects.

--------------------------------------------
CALCULATING THE CROSS-PRODUCT OF TWO VECTORS
--------------------------------------------

v and w are two vectors in 3-dimensional space

v x w (read "v cross w") is a vector whose magnitude is the product of the magnitudes of v and w, that is perpendicular to both v and w, and whose direction is given by the right-hand rule.

To compute a cross-product, usually what you end up doing is computing a determinant.  Write a 3x3 matrix with the first row being the components of v, the second row being the components of w, and the third row being the unit vectors, i j k.  The determinant of that is the cross-product of v and w

abc = xyz force 1
def = xyz force 2

(a,b,c) * (d,e,f) = (bf-ce, cd-af, ae-bd)

IE:

x3 = y1*z2 - z1*y2
y3 = z1*x2 - x1*z2
z3 = x1*y2 - y1*x2


------
TORQUE
------

The torque generated by a force on a system is given by r x F.

r = The position vector of the point where the force is applied relatively to the center of mass.
F = A force vector.

r = (a,b,c)
F = (d,e,f) 

T_F = (bf-ce, cd-af, ae-bd)

T_F is the torque generated by F.

So you compute the torques generated by all forces
you sum them (vector sum) and then you divide the resulting vector by the "moment of inertia"

"moment of intertia":
it's a measure of the system's "resistance" to rotation, if you want
it's a function of the point masses and their distance from the center of mass


are your "rods" mass-less?
then you just need to sum up m_i * r_i^2, i *think*
where m_i is a point mass, and r_i is its distance from the center of mass
divide the sum of torques by that quantity, and that's the angular acceleration vector
so if you have 2 objects, one with mass 1kg at 2 meters, and another with mass 2kg at 3 meters, the unnamed quantity is 1*2^2 + 2*3^2 = 22


to get the linear acceleration of a point from that, you compute (angular acceleration) x r
where r is the position vector of a point relative to the center of mass
x denotes a cross-product, again



 the angular acceleration is a global measure of the rotational acceleration of the system
but, something close to the center of mass accelerates less (linearly) than something far from it
 you take the A x r cross-product to take that into account
 A x r will give you an acceleration vector, which you can add to the acceleration vector resulting from the sum of forces (which we computed a while ago)
the sum of those two is the acceleration of an individual point in the system


acceleration of system's center of mass = sum of forces / mass of system

--------
SPRINGS
--------

<a href="http://www.pcug.org.au/~apurdam/doublespring/doublespring.html" target="_blank">http://www.pcug.org.au/~apurdam/doublespring/doublespring.html</a>
two masses, connected by one spring:

M1, M2 = masses
k = coefficient of stiffness of the spring
x1, x2 = the displacements of the masses from their positions of equilibrium
x1'', x2'' = the acceleration for M1 and M2
r = viscous damping
x1', x2' = velocity of masses (from previous frame?)

x1''= k / (M1*(x2-x1)) - r*x1'
x2''= k / (M2*(x1-x2)) - r*x2'



misc notes:

Logarithmic Impulse formula.
Impulse  = Log(RestSpan) - Log(CurrentSpan)  

Note: this is a different from the usual linear spring formula which is taught in physics classes.  With the logarithmic formula, it should be impossible to completely compress the spring.  It also means that springs that have long rest lengths vibrate much slower than short ones.  


---------
Jet thrust against atmosphere
---------

throtte = 0..1

thrust = throttle * max( max_thrust * (max_height - height) / max_height, 0)


------------------------------------------------------------------------
Only allowing velocity along a specific axis or in a specific diredction
------------------------------------------------------------------------

If you have a vehicle like a hovercraft, then it's okay to allow the hovercraft to have inertia and slide
around in any direction.  But if you have a wheeled vehicle, or a tank, then you won't want the vehicle to slide
sideways if it's on an incline... you only want it to be able to roll forward or backward.

This is pretty easy to fix.  

Take your vehicle's momentum which you've just calculated by adding it's moemntum from the previous frame and adding the forces acting on the vehicle, and convert it into an angle and a magnitude.  A = The angle, B = the magnitude.

C = The angle your tank is facing.  Note that this can be totally diffrent from the angle the tank is trying to move in.

Now do the following calculation:

D = A-C

D is the angle of your momentum vector if it were translated into a space where A = 0... where your tank is facing along the X axis.

Now, create a new vector... where D is it's angle, and B is it's magnitude.  

Next, convert the vector into X and Y components.  Then discard the Y component of the velocty, because that doesn't lie on the axis the tank can roll along.  The value you have remaining, X, is the amount of velcoity which is along the axis the tank can move along.

Finally, use X as your magnitude, and C (your tanks face driection) as your angle.  That is your tank's new momentum vector.  Convert it into X and Y components if need be.

Note that you only want to do this sort of thing when your tank is on the ground.  And you might want to do some aditional calculations... for example, your tank might be able to move along the Y axis, but there might be a lot of friction if it does so.  So if you tank is moving sideways through the air fast, when it lands, you might want it to slide a bit before coming to a stop.  If you give that axis a lot of friction and add the remaining velcoity to the forwar dmomentum then you can allow for that.







Bresenham's lines drawing algorithm:


    public void lineBresenham(int x0, int y0, int x1, int y1, Color color)
    {
        int pix = color.getRGB();
        int dy = y1 - y0;
        int dx = x1 - x0;
        int stepx, stepy;

        if (dy &lt; 0) { dy = -dy;  stepy = -1; } else { stepy = 1; }
        if (dx &lt; 0) { dx = -dx;  stepx = -1; } else { stepx = 1; }
        dy &lt;&lt;= 1;                                                  // dy is now 2*dy
        dx &lt;&lt;= 1;                                                  // dx is now 2*dx

        raster.setPixel(pix, x0, y0);
        if (dx &gt; dy) {
            int fraction = dy - (dx &gt;&gt; 1);                         // same as 2*dy - dx
            while (x0 != x1) {
                if (fraction &gt;= 0) {
                    y0 += stepy;
                    fraction -= dx;                                // same as fraction -= 2*dx
                }
                x0 += stepx;
                fraction += dy;                                    // same as fraction -= 2*dy
                raster.setPixel(pix, x0, y0);
            }
        } else {
            int fraction = dx - (dy &gt;&gt; 1);
            while (y0 != y1) {
                if (fraction &gt;= 0) {
                    x0 += stepx;
                    fraction -= dy;
                }
                y0 += stepy;
                fraction += dx;
                raster.setPixel(pix, x0, y0);
            }
        }
    }




Lighting:

&lt;Jaia&gt; 1/x^2 is all nice and good
&lt;Jaia&gt; but there are 2 problems
&lt;Jaia&gt; first it blows up at the source, x=0
&lt;Jaia&gt; so we must start at some small but non-0 x
&lt;Jaia&gt; 2nd it never quite hits 0 though it gets close
&lt;Jaia&gt; so we must modify it a bit
&lt;Jaia&gt; the distance we need to get to is R
&lt;sswift&gt; So lets say I wanted the version that blows up... how would I do that, just for the sake of argument?
&lt;Jaia&gt; well you can use it directly B(x) = 1/x^2
&lt;Jaia&gt; but the 2 problems remain
&lt;Jaia&gt; near x=0 it blows up
&lt;sswift&gt; Cause I can make 0 distance a special case, and clamp the value to 255.
&lt;Jaia&gt; that's no good
&lt;sswift&gt; But that doesn't take R into account
&lt;Jaia&gt; since for x small but non0 it gets arbitrarily high
&lt;Jaia&gt; so simple claming is not a good idea
&lt;Jaia&gt; well we need to take R into account
&lt;Jaia&gt; this relates to the 2nd problem
&lt;Jaia&gt; basically R sets our scale
&lt;Jaia&gt; so really x/R is what is important here
&lt;Jaia&gt; x/R is 'normalised', it goes from 0 to 1
&lt;sswift&gt; I know someone gave me a simpler equation a long time ago which created an expoential curve between two points...
&lt;sswift&gt; I used it to make craters.
&lt;Jaia&gt; do you want exponential or 1/x^2?
&lt;Jaia&gt; they are quite different
&lt;sswift&gt; They are?
&lt;sswift&gt; :-)
&lt;sswift&gt; I tohught light fell off expoentially.
&lt;Jaia&gt; yes
&lt;Jaia&gt; e^(-x) is finite at x=0
&lt;Jaia&gt; and decays must more rapidly
&lt;Jaia&gt; 1/x^2 is a more accurate model
&lt;sswift&gt; And you know this how? :-)
&lt;Jaia&gt; since as you propagate the area of the spherical fronts of the light wave
&lt;Jaia&gt; goes as x^2
&lt;sswift&gt; You know about lighting? :-)
&lt;Jaia&gt; so the light intensity goes as 1/x^2
&lt;Jaia&gt; it's an area so it goes as ~ x^2
&lt;Jaia&gt; so we want the inverse of that
&lt;Jaia&gt; (with some constant of course but we care about overall dependence)
&lt;Jaia&gt; here is something you can do
&lt;Jaia&gt; x/R goes from 0 to 1
&lt;Jaia&gt; so let's split it into 100
&lt;Jaia&gt; x/100R
&lt;Jaia&gt; this is our tick mark
&lt;Jaia&gt; i mean, R/100
&lt;Jaia&gt; so we have something like
&lt;Jaia&gt; (R/100)^2 / (x + R/100)^2
&lt;Jaia&gt; notice this is equal to 1 at x=0
&lt;Jaia&gt; and then fall off as the inverse square as we want
&lt;Jaia&gt; so all it remains is to multiply by 255
&lt;Jaia&gt; 255(R/100)^2 / (x + R/100)^2
&lt;Jaia&gt; so at x=0 the value is 255 as desired and it will fall off in the desired way
&lt;sswift&gt; okay
&lt;Jaia&gt; at x=R we have 255/(101)^2 &lt;&lt; 1
&lt;Jaia&gt; which is quite small
&lt;Jaia&gt; basically the tick mark is R/100
&lt;Jaia&gt; we have 100 of these to get to R
&lt;Jaia&gt; each time i double the tick marks, i quarter the intesity, etc.
&lt;sswift&gt; So what's better or worse aobut this question than the other one you gave me?
&lt;sswift&gt; equation
&lt;Jaia&gt; well ... this one is slightly more accurate
&lt;Jaia&gt; the other one was exactly 0 at x=R
&lt;Jaia&gt; but at the expense of bending the 1/x^2 falling off rate a bit
&lt;Jaia&gt; to push it down enough
&lt;sswift&gt; If it's below 1 at R, then it'll be clamped cause I have integers.
&lt;Jaia&gt; but here it's so small at x=R it's totally fine
&lt;sswift&gt; So...
&lt;sswift&gt; this 100 bit...
&lt;Jaia&gt; 255(R/5)^2 / (x + R/5)^2
&lt;Jaia&gt; use that then
&lt;sswift&gt; Does it matter at all what that number is&gt;
&lt;Jaia&gt; this is enough
&lt;Jaia&gt; no no ...
&lt;Jaia&gt; 255(R/20)^2 / (x + R/20)^2
&lt;Jaia&gt; yes
&lt;Jaia&gt; 255/(number+1)^2 is the value at x=R
&lt;Jaia&gt; so i use 20
&lt;Jaia&gt; 255/(21^2) &lt; 255/400 &lt; 0.5
&lt;Jaia&gt; so we're ok
&lt;Jaia&gt; 255/(21^2) &lt; 255/400 &lt; 0.8
&lt;Jaia&gt; anyway
&lt;sswift&gt; So....
&lt;sswift&gt; What if I use a really large number there?
&lt;sswift&gt; That would mnake it more accurate?
&lt;sswift&gt; closer to 0?
&lt;Jaia&gt; no, not really ...
&lt;Jaia&gt; this is a little bit cheating
&lt;Jaia&gt; the requirement that it's "negligible" at x=R is somewhat artificial
&lt;Jaia&gt; and not precise
&lt;Jaia&gt; it's very vague in fact
&lt;Jaia&gt; the most sensible thing to do i think, without any other info
&lt;sswift&gt; Will it change the visible appearance of the lighting in any way?
&lt;Jaia&gt; is to make it just barely small enough at x=R
&lt;Jaia&gt; oh yes
&lt;sswift&gt; How so?
&lt;Jaia&gt; if you make that number huge
&lt;Jaia&gt; it will drop off immediately
&lt;Jaia&gt; near the source
&lt;sswift&gt; oh
&lt;Jaia&gt; and will be almost 0 throughout the whole range from 0 to R
&lt;Jaia&gt; that's like pushing R very far off
&lt;Jaia&gt; so that the tail of 1/x^2 is very small
&lt;Jaia&gt; i would make the tail just barely small enough at x=R
&lt;Jaia&gt; just below 1
&lt;Jaia&gt; so it fits your requirement
&lt;Jaia&gt; but still shows decay over the range
&lt;sswift&gt; That sounds like in my crater simulation... I could increase the exponent to ^3 ^4... and that would push the crater wall off into the distance.
&lt;Jaia&gt; without dying too quickly
&lt;Jaia&gt; and being uninteresting
&lt;Jaia&gt; right
&lt;Jaia&gt; 20 might be ok
&lt;Jaia&gt; 255(R/20)^2 / (x + R/20)^2
&lt;Jaia&gt; this is saying "R is quite far, but not extremely far so that most of the range the intensity is tiny"
&lt;sswift&gt; Okay
&lt;sswift&gt; I think I understand.  If I have a problem I can tweak it to get it to look right by increasing ro decreasing that value.
&lt;Jaia&gt; to give you an idea
&lt;Jaia&gt; look at the value at x = R/2
&lt;Jaia&gt; halfway
&lt;Jaia&gt; it will be 255/(11)^2 = 255/121 ~ 2
&lt;Jaia&gt; from 255 to 2 halfway
&lt;Jaia&gt; this is a good check to see if it fits what you want
&lt;Jaia&gt; whatever c you pick
&lt;Jaia&gt; 255(R/N)^2 / (x + R/N)^2
&lt;Jaia&gt; N rather
&lt;Jaia&gt; for x=0 it's always 255
&lt;Jaia&gt; for x=R/2 it's 255/(N/2 + 1)^2
&lt;Jaia&gt; and for x=R it's 255/(N+1)^1
&lt;Jaia&gt; and for x=R it's 255/(N+1)^2
&lt;Jaia&gt; so this should give you a good idea
&lt;sswift&gt; The lightness will drop to 2 halfway to R with a value of R/2?
&lt;Jaia&gt; from 255 to 2
&lt;Jaia&gt; as you go from 0 to R/2
&lt;Jaia&gt; (on your way to R)
&lt;Jaia&gt; if that seems too low, drop N a bit
&lt;Jaia&gt; to 16 say
&lt;sswift&gt; Tht's increasing N. :-)
&lt;sswift&gt; Okay
&lt;Jaia&gt; then at x=R it's 255/17^2 = 255/289 &lt; 1


The Attenuation Function

1 / ( c0 + c1 * d + c2 * d * d )

*By Setting the constants c0, c1 &amp; c2, you can
adjust the falloff ramp of the light
*Setting c1 = 0, c2 &gt; 0 will give you a radial
distance squared falloff
*Setting c1 &gt; 0, c2 = 0 gives a linear falloff
*Attenuation denominators less than one will give
very large factors, thus making the light too
bright close up
*To avoid this, make sure c0 is set To some
positive number, 1 Or greater



&lt;Jaia&gt; 1/(x^2 + c)
&lt;sswift&gt; what is C
&lt;Jaia&gt; well, let's see
&lt;Jaia&gt; at x=0 we get 1/c
&lt;Jaia&gt; so we'll add another constant d
&lt;Jaia&gt; d/(x^2 + c)
&lt;Jaia&gt; d/c = 255
&lt;Jaia&gt; so x is given in the same units as R is?
&lt;sswift&gt; yes
&lt;Jaia&gt; ok
&lt;Jaia&gt; d/(x^2/R^2 + c)
&lt;Jaia&gt; at x=R we'll set it to 1
&lt;Jaia&gt; d/(1+c) = 1
&lt;Jaia&gt; d = 1+c
&lt;Jaia&gt; 255c = 1+c
&lt;Jaia&gt; c = 1/254
&lt;Jaia&gt; d = 255/254
&lt;Jaia&gt; change the value of d/(1+c) if you want
&lt;Jaia&gt; this is the value at x=R
&lt;Jaia&gt; d/c=255 is fixed
&lt;Jaia&gt; d/(1+c) is the final value, play with it if d/(1+c) = 1 seems no good
&lt;Jaia&gt; so we get as an idea
&lt;Jaia&gt; (255/254) / (x^2/R^2 + 1/254)
&lt;sswift&gt; Is that it?
&lt;sswift&gt; :-)
&lt;Jaia&gt; yup
&lt;Jaia&gt; play with d/(1+c) as i said
&lt;Jaia&gt; (you always have d/c = 255)
&lt;Jaia&gt; d/(x^2 + c) is our general rule
&lt;Jaia&gt; d/(1+c) gives the value of intensity at R
&lt;Jaia&gt; i set it to 1 here
&lt;Jaia&gt; (255/254) / (x^2/R^2 + 1/254)
&lt;Jaia&gt; and got that

&lt;Jaia&gt; and got that
&lt;sswift&gt; Why did you not set it to 0?
&lt;Jaia&gt; you can't
&lt;Jaia&gt; this function is never 0
&lt;Jaia&gt; d/(1+c) = 0
&lt;Jaia&gt; d = 0
&lt;Jaia&gt; oops
&lt;Jaia&gt; and besides
&lt;Jaia&gt; make it too small
&lt;Jaia&gt; will push out R too far
&lt;Jaia&gt; effectively speaking
&lt;Jaia&gt; as we discussed before
&lt;sswift&gt; hm...
&lt;Jaia&gt; your inensity will die out immediately
&lt;Jaia&gt; and be tiny for most of the range
&lt;sswift&gt; Could you perhaps make the range start at 256, go to 1, and then subtract 1 from the end result?
&lt;Jaia&gt; if you want
&lt;Jaia&gt; sure
&lt;sswift&gt; Is there anyhtign bad about that?
&lt;Jaia&gt; (256/255) / (x^2/R^2 + 1/255) - 1
&lt;Jaia&gt; not at all
&lt;Jaia&gt; in fact it's a good idea
&lt;sswift&gt; (256/255) / (x^2/r^2 + 1/255)  - 1
&lt;sswift&gt; You typed it first
&lt;sswift&gt; :-)
&lt;Jaia&gt; that looks ok
&lt;sswift&gt; at least I know I was right
&lt;Jaia&gt; in general
&lt;Jaia&gt; d / (x^2/R^2 + c) - d/(1+c)
&lt;Jaia&gt; d/(1+c) is what your value at R would have been
&lt;Jaia&gt; so it will be useful to see how far you're pushing R
&lt;Jaia&gt; as before




&lt;Jaia&gt; 256c / (x^2/R^2 + 1/255) - 256c/(1+c)
&lt;Jaia&gt; c is our free parameter
&lt;Jaia&gt; the last term, 256c/(1+c) sets the scale
&lt;Jaia&gt; is it's much less than 1, it probably dies too quickly
&lt;Jaia&gt; i'd keep it around 1 or 2 or so
&lt;Jaia&gt; but maybe higher even
&lt;Jaia&gt; play with it
&lt;Jaia&gt; in all cases the value at R is 0
&lt;Jaia&gt; oh no ...
&lt;Jaia&gt; ack
&lt;Jaia&gt; d / (x^2/R^2 + c) - d/(1+c)
&lt;sswift&gt; ack what
&lt;sswift&gt; :-)
&lt;Jaia&gt; d/c - d/(1+c) = 255
&lt;Jaia&gt; d = 255/(1/c + 1/(1+c))
&lt;Jaia&gt; so this is d in terms of c
&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/c + 1/(1+c)) / (1+c)
&lt;Jaia&gt; that last term
&lt;Jaia&gt; - 255/blah blah
&lt;Jaia&gt; that's what you don't want too small
&lt;Jaia&gt; set it to 1-5 or so
&lt;Jaia&gt; and see how it works
&lt;Jaia&gt; the lower it is, the faster it decays
&lt;sswift&gt; what was wrong with this?  (256/255) / (x^2/r^2 + 1/255)  - 1
&lt;Jaia&gt; this is the case for 1
&lt;Jaia&gt; it may work well
&lt;Jaia&gt; i just gave you a more general case
&lt;sswift&gt; ah.
&lt;Jaia&gt; where you can tweak the parameter at will
&lt;Jaia&gt; just solve that last term
&lt;Jaia&gt; 255(1/(c(1+c)) + 1)
&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/(c(1+c) + 1)
&lt;Jaia&gt; ...
&lt;Jaia&gt; same thing
&lt;Jaia&gt; just cleaned up a bit
&lt;Jaia&gt; 255/(1/c + 1/(1+c)) / (x^2/R^2 + c) - 255/(1/(c(1+c)) + 1)
&lt;Jaia&gt; the one you gave has - 1
&lt;Jaia&gt; as a case
&lt;Jaia&gt; by changing c
&lt;Jaia&gt; you can make the - number different
&lt;Jaia&gt; for a certain c you get - 1
&lt;Jaia&gt; as you showed
&lt;Jaia&gt; change c to get different values - something
&lt;sswift&gt; Okay
&lt;Jaia&gt; making that something bigger makes the decay slower
&lt;Jaia&gt; etc.

&lt;Jaia&gt; etc.
&lt;Jaia&gt; unless i made a mistake
&lt;Jaia&gt; let me see
&lt;Jaia&gt; d/(x^2/R^2 + c)
&lt;Jaia&gt; d/(x^2/R^2 + c) - d/(1+c)
&lt;Jaia&gt; d/c - d/(1+c) = 255
&lt;Jaia&gt; d = 255/(1/c + 1/(1+c))
&lt;Jaia&gt; ya, looks ok


lighting
--------

; DX7 Lighting equation:
; Attenuation = 1 / (C0 + C1*D + C2*D*D)
;
; For some reason this equation does not seem to produce the expected results!
;
; In Blitz:
; C0,C2 = 0.  C1=Light radius.
;
; Mark has said that Blitz's lighting follows this equation:
; Brightness = 1.0 / (Distance / Light_Radius)  
;
; Which does what the DX7 equation should do, but I don't know why they're so different.
;
; The shadow system on the other hand uses a modified linear falloff. 
;
; This is so that the distance at which the shadow attenuates completely is not really
; far away from it's origin.  If we used the other equations, a caster would almost
; never be outside a light's range, and that would be very bad for the framerate!
																																				
; Standard linear falloff equation:
;
;    L = Lightness
;    R = Light max radius
;    D = Distance from light
;
; L = (R - D) / R 
																								
; Linear falloff, modified to be offset so that: 
;
;    If D &lt; R1  then L &gt; 1
;    If D = R1  then L = 1
;    If D &gt;= R2 then L = 0
;
; L = (R2 - (D-R1)) / R2 
																												
Light_Falloff# = (R2# - (Vdist# - R1#)) / R2#
																
; Clamp the falloff value if we are outside max_range, or inside min_range.

If (Light_Falloff# &lt; 0) Then Light_Falloff# = 0
If (Light_Falloff# &gt; 1) Then Light_Falloff# = 1
																					
																
; Convert the falloff value to a color for this vertex.
Light_Falloff# = 255.0 * (1.0 - Light_Falloff#)															





a = 1 / (c0 + c1*d + c2*d*d)

converts to:

v = light_r * light_min_radius / distance

Which can be inverted to:

d = light_r * light_min_radius / v

To find out the distance at which v becomes some value.
</textarea> <br><br></td></tr></table><br>
<a name="380256"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow you guys are pretty amazing, I wish I could just get my head around this stuff.<br><br>If I put my player on a slanted surface, and I align his vector to the surface normal, how can I determine the direction he should slide, and that he will pick up speed and then when the jump curves up he will follow it and launch off the end. What do I have to understand. <br><br>I have been reading a book about physics but when I try to put them on the computer it all fails.<br><br>What is the best way to understand this stuff.?<br><br>Best Regards,<br>Eric <br><br></td></tr></table><br>
<a name="380263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> "If I put my player on a slanted surface, and I align his vector to the surface normal, how can I determine the direction he should slide, and that he will pick up speed and then when the jump curves up he will follow it and launch off the end. What do I have to understand."<br><br><br>The first thing you need to do is revamp the way you move objects around.<br><br>Calculate the number of seconds a frame takes as a floating point number.  To do this, determine the number of milliseconds between one frame and the next, and then divide  that by 1000.<br><br>Next, specify a velocity for each of your objects in meters per second, or blitz units per second.  If one Blitz unit is one meter, then you can easily use meters per second without concernign yourself with converting units.  You want to use meters per second because so much of physics uses metric measurements of speed, metric measurements of mass, etc.<br><br>Next, for each object, store it's velocity on each axis.  Ie, how far the object is moving in each direction in the world.  Vx#, Vy#, Vz#.  Initially, this will usually be 0.<br><br>This velocity vector stores both DIRECTION of movement, and SPEED.  Alternatively, you could store the direction and speed of the object instead, but you will have to convert vack and forth between a vector and a speed and direction normal often when doing physics, so you might as well store the smaller of the two datasets.<br><br>Now, when you need to convert from a vector to a speed and direction normal you would do this:<br><br>Speed# = Sqr(Vx#^2 + Vy#^2 + Vz^2)<br>Direction_X# = Vx# / Speed#<br>Direction_Y# = Vy# / Speed#<br>Direction_Z# = Vz# / Speed#<br><br>What you end up with is a speed, and a vector with a length of 1... a normal, which defines the direction of travel.<br><br>To be continued... <br><br></td></tr></table><br>
<a name="380266"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now that you have an object which has a velocity, let's accelerate it with gravity.<br><br>First, define your gravity normal.  This is the direction in which gravity pulls the object.  For most games, gravity will pull downward.  But in space games, gravity will pull you towards the center of a planet.  <br><br>But quickly... to calculate that planet gravity normal, subtract the position of the space ship from the position of the planet, and then normalize the vector.  Normalizing the vector means convert it to a normal.  And to do that, you do what I did above to what I will refer to as vector Vxyz... Vx, Vy, Vz.  The normal is the direction.<br><br>But for your game, gravity probably points downward.  And the normal for that gravity will always be 0, -1, 0.<br><br>Place those three values into Gx#, Gy#, Gz#, and you have your gravity normal.<br><br>On to part 3... <br><br></td></tr></table><br>
<a name="380270"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> (Btw, I'm positng this in parts cause my PC tends to crash and I don't want to have to retype it all.)<br><br><br>Now that we have our gravity normal, we need to define the acceleration of gravity.  Earth gravity accelerates an object at 9.8 meters per second squared.  There's those meters I warned you about!  This is where it things get very tricky if you don't have one unit equal to one meter.  So for the sake of this tutorial, I will assume that is the scale of your world.  One unit = one meter.<br><br>Now, what 9.8 meters per second squared means in layman's terms is that every second, your object will move 9.8 meters per second FASTER.  So in the first second it will accelerate to 9.8 meters per second... and in the second second, it will acceltate to 19.6 meters per second.<br><br>Now here's how you make gravity affect an object.<br><br>; This can be computed once at the start of the program, <br>; unless you're doing space planet physics.<br>GravityAcceleration# = 9.8<br>Gvx# = Gx# * GravityAcceleration#<br>Gvy# = Gy# * GravityAcceleration#<br>Gvz# = Gz# * GravityAcceleration#<br><br><br>; Heres what you do each frame.<br>Vx# = Vx# + (Gvx# * FrameSeconds#)<br>Vy# = Vy# + (Gvy# * FrameSeconds#)<br>Vz# = Vz# + (Gvz# * FrameSeconds#)<br><br><br>Note how I am adding the gravity vector / force to the object's velocity.  When a new force is applied to your object, you just add it to the object's vector.  However, gravity is a bit different than other forces.  With gravity, mass is not important.  <br><br>Well... at the scale we are working at, it is not important.  The earth does pull on the sun even as the sun pulls on the earth.<br><br>Note also that I have multiplied the gravity vector by the number of second the frame took.<br><br>The gravity vector says "I pull downward at 9.8 meters per second!" and the framesecond variable says "Oh yeah?  Well you only have a tenth of a second this frame to act on the object, so you only get to accelerate it by an additional 0.98 meters per second!"<br><br>On to part 4... <br><br></td></tr></table><br>
<a name="380274"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now let's set up some types for your players/objects...<br><br><pre class=code>
Type Player
   Field Entity
   Field Vx#
   Field Vy#
   Field Vz#
End Type
</pre><br><br>Once you've done that, take all the Vxyz's I've written above and replace them with ThisPlayer\Vx# for example.<br><br>Then you can loop through all your players and do physics like so:<br><br><pre class=code>
For ThePlayer.Player = Each Player
;Do physics here with ThisPlayer\Vx#, Vy#, Vz#.
Next
</pre><br><br>Then once you've done that, you can move on to the final step...<br><br><pre class=code>
For ThePlayer.Player = Each Player
; Do some physics here.
; Check for collisions.
; If collision with level then bounce player off level.
; If collision with another player then bounce players off eachother.
TranslateEntity ThisPlayer\Entity, ThisPlayer\Vx#*FrameSeconds#, ThisPlayer\Vy#*FrameSeconds#, ThisPlayer\Vz#*FrameSeconds#
Next
</pre><br><br>Note how I have used translateentity, and not moveentity.  The player's direction of movment is ultimately NEVER affected by the direction they are facing.  Their face direction ONLY changes the direction of any thrust they apply to themsevles.  That change in thrust direction is what changes their direction.  <br><br>There are however certain exceptions to this rule if you want to do for example hover racing physics without getting into physics which are too complicated.  But that is beyond the scope of this disucussion.<br><br>Now there's one last peice of the puzzle to make your object properly affected by gravity.  And that is taking into account the surface normal and calculating rebound.  But I don't think I'll write about that right now, I'm kinda tired of typing. :-) <br><br></td></tr></table><br>
<a name="380275"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh and btw... I just realised that what you are describing is a skateboarding simulation.  I am not sure if the physics I am describing to you will be adequate for that.  They are correct physics, but the physics of real life interactions is a LOT more complicated than the simplest case I am describing to you here.  I am not sure that if you took my ball simulation and stuck it in a half pipe if it would behave as expected.  Consider the difference between putting a rubber ball in a half pipe, and a bowling ball in a half pipe.  The rubber ball as it rolls down the half pipe might at some point jump off the surface if it encounters any imperfections in the surface.  And a polygonal model is FULL of imperfections.  The surfaces are angular.  So my ball simulation might jump off the surface.  But not neccessarily for the same reason that that rubber ball might jump off the surface.  It is a tough problem.  I think it has something to do with elastic versus inelastic collisions.<br><br>Anyhow I'm not saying it won't work.  I'm just saying I'm not sure if it will.<br><br>In other words, your problem may be too complex for you to solve.  A skateboaridng simulation might not be the best way to first venture into physics. :-) <br><br></td></tr></table><br>
<a name="380279"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Swift,<br><br>I am preparing to print all that you wrote, You have explained quite a bit and I am getting ready to try to absorb it all.<br><br>My Game isn't really a game, I am just trying to learn how to make certain events happen.<br><br>Right now I have an Object that looks like a Childs sliding board except that at the bottom it curves up. I have a ball at the top that I want to roll down, and follow the curve.<br><br>I have been reading these boards for quiet some time, and I have really envyed your ability. I hope in the future you might help me to understand how to get these physics equations to work in a gaming environment.<br><br>Normalizing, Cross Product, Dot Product... When you have time... Can you please explain, how these will help me in programming.<br><br>Best Regards,<br>Eric <br><br></td></tr></table><br>
<a name="380281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Normalizing makes a vector have a length of 1.  This basically gives you a starting point...  The normal tells you a direction something points, and because it has a length of 1, if you multiply it by a magnitude, say, 10, then it will have a length of 10.  This length of 10 might represent a speed of 10 meters per second, or 10 blitz units per second, or it might be a distance to move a vertex away from the surface of an object.<br><br>A dot product is what you get when you multiply two normals with the dot product formula.  Dot# = V1x#*V2x# + V1y#*V2y# + V1z#*V2z#<br><br>If the two normals point towards eachother, or away from eachohter, ie, in opposite directons, the result will be -1.  If they point 90 degrees away from one another, ie, perpendicular to one another, the result will be 0.  If one points away from the other, ie, they point in the same direction, the result will be 1.<br><br>The dot product is used for many things, but most often for calculating lighting.  If you make a normal that points in the same direction a light points, and you have a normal for a vertex, or face, which tells which direction the vertex or face points, and you do a dot product, if the face faces towards the light, the result will be -1, and if it faces parralel to the light or away from the light, it will be between 0 and 1.  This tells you exactly how bright the surface should be.<br><br><br>A cross product gives you a vector which is 90 degrees from two other vectors.  In other words, if you make a vector that points down the Z axis, and a vector that points down the X axis, and do a cross product on them, the result will be a vector that points up the Y axis.  This is how you calculate the normal of a polygon.  You take two sides, calculate the cross product, and then normalize the vector so it has a lenght of 1, making it a normal. <br><br></td></tr></table><br>
<a name="380283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks...Still a blur, But in time it will all fit...<br><br>OK back to your original explanation.  Now I have some of your formulae sorted... How do I add my own inputs to Direction... Now My Object is an Arrow. I want my Arrow to move in the direction it is facing. Using your equations.<br><br>I just am using my arrow keys, using the Turn Entity Command on the Z Axis.<br><br>So basically, I should just add an impulse to the Correct Axis, I'm assuming is the 'X' Axis.<br><br>And then add some sort of Friction to slow it Down.. Like <br>VX#=VX#*.95<br><br>Is my thinking in the right Direction?<br><br>Regards,<br>Eric <br><br></td></tr></table><br>
<a name="380291"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Unless your arrow is a missile, you do not want to apply thrust to it every frame, but rather apply an initial thrust to it, and then use air friction to slow it down.<br><br>To apply the initial velocity, do the following:<br><br>TFormNormal 0, 0, 1, Arrow, 0<br>Thrust_Nx# = TFormedX()<br>Thrust_Ny# = TFormedY()<br>Thrust_Nz# = TFormedZ()<br><br>You now have a direction normal that points in the same direction as your arrow is pointing.<br><br>Now, decide on how much speed you want to add to your arrow initially, in meters per second.<br><br>Thrust# = 10.0<br><br>Now, combine the two into a vector.<br><br>ArrowThrust_Vx# = Thrust_Nx# * Thrust#<br>ArrowThrust_Vy# = Thrust_Ny# * Thrust#<br>ArrowThrust_Vz# = Thrust_Nz# * Thrust#<br><br>You now have a vector which is 10 units long and points in the same direction as your arrow.<br><br>Now you just add this initial thrust vector to the arrow's thrust vector.  It might, alter the arrow's direction of movement if it is in a different direction than the arrow is currently moving.  You only do this ONCE when the arrow is released.<br><br>Arrow_Vx# = Arrow_Vx# + ArrowThrust_Vx#<br>Arrow_Vy# = Arrow_Vy# + ArrowThrust_Vy#<br>Arrow_Vz# = Arrow_Vz# + ArrowThrust_Vz#<br><br>Now, assuming your arrow was motionless when it began it is now moving at ten meters per second...  <br><br>Oops, I just relaised I made a mistake in oen of my earlier posts.<br><br>This line:<br><br>TranslateEntity ThisPlayer\Entity, ThisPlayer\Vx#, ThisPlayer\Vy#, ThisPlayer\Vz#<br><br>Must actually be:<br><br>TranslateEntity ThisPlayer\Entity, ThisPlayer\Vx#*FrameSeconds#, ThisPlayer\Vy#*FrameSeconds#, ThisPlayer\Vz#*FrameSeconds#<br><br>I have corrected it.<br><br>This is because the velocity vecotr of the entity is how fast is is moving in meters per second, and each frame, we only want to move it the right distance for the time passed.  Ie, is a tenth of a second has passed, we only move it at a tenth of it's current speed, so that when 10 frames have elaapsed, and an exntire second has passed, the arrow has moved 10 meters if it is moving 10 meters per second. <br><br></td></tr></table><br>
<a name="380294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now to do air friction...<br><br>To do physically correct air friction, you must convert the object's velocity vector into a speed and a direction.<br><br>I already told you how to do that above, but I will show you again here:<br><br>Speed# = Sqr(Vx#^2 + Vy#^2 + Vz^2)<br>Direction_X# = Vx# / Speed#<br>Direction_Y# = Vy# / Speed#<br>Direction_Z# = Vz# / Speed# <br><br>Once you have the speed and direction of the object, you can do this:<br><br>Air_Friction_Force# = AIR_FRICTION_CONSTANT# * Velocity#^2.0	<br>Velocity# = Velocity# - (Air_Friction_Force# * Time_Delta_Sec#)<br><br>Time_delta_sec# is the name I use instead of FrameSeconds#  for my frame timer.  I left it like that so you wouldn't be confused if I paste other physics code from my games and forget to change the variables.<br><br>Velocity# here is also a different variable name I use.  This time, it is the Speed# variable above.  So this becomes:<br><br>Air_Friction_Force# = AIR_FRICTION_CONSTANT# * Speed#^2.0	<br>Speed# = Speed# - (Air_Friction_Force# * FrameSeconds#)<br><br>Now you's asking yourself... What is air friction constant?<br><br>Air Friction Constant, is a value which is a combination of two factors.  One is the viscosity of the air.  Ie, how thick the air is.  Air... water... they're the same thing basically in physics, except that water is thicker and thus causes more drag when you try to move through it quickly.  The other is how areodynamic the object is.<br><br>In my games I do not differntiate between objects with regards to the amount of air friction they have.  As far as I am concerned, they all have the same areodynamic properties, and so I don't have to combine their areodynamic value with the air's viscocity.  I just chose a value which felt like an average air friction.  For now, you don't really need to worry about whether an arrow travels through the air more easily than a person or a car or a rock.<br><br>Here are the constants I have defined for my physics:<br>Const GRAVITY# = 9.8<br>Const AIR_FRICTION_CONSTANT# = 0.2<br>Const GROUND_FRICTION_CONSTANT# = 0.5 <br><br></td></tr></table><br>
<a name="380296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now that you have calculated the object's new speed after taking into account the amount of air frictoon at it's current speed, you need to convert it back to a velocity vector so you can store that and use it to move the object.<br><br>But first, you need to make sure your speed has not gone negative.  Speed can never be negative in physics.  If it is it just means your object stopped somewhere in the middle of the time tick you just calculated in your physics.  Physics in games is an approximation.  Like a sound is samples 44 thousand times a second, we sample our physics 60 times a second or more, but sometimes that is not enough to accurately represent the motion of the objects.<br><br>So...<br><br>If Speed# &lt; 0 then Speed# = 0<br><br><br>And finally, we convert back to the vector:<br><br>Vx# = Direction_X# * Speed#<br>Vy# = Direction_Y# * Speed#<br>Vz# = Direction_Z# * Speed#<br><br><br>All done.  Your arrow will now shoot out of your bow at 10 meters per second, and the air friction will cause it to gradually slow down (_very_ gradually, unless it is moving VERY fast, amd then it slows it down very quickly.) and it will fall towards the earth in a parabolic arc until it collides with it at which point it will probably slide along the ground because the air friction hasn't slowed it to a stop, and gravity is still pulling on it, and we have not modeled ground friction or loss of energy when the object strikes the ground.<br><br>But for simplicty's sake, when it hits the ground you could just set Vxyz# to 0,0,0 and turn off the other physics simulation.<br><br>Oh btw, an arrow will turn to rotate in the direction it is moving.  You can simulate this by taking it's current position, subtracitng it from it's last position, and then using aligntovector() to align the arrow's Z axis to the XYZ vector you got when you subtracted those two positions from one another. <br><br></td></tr></table><br>
<a name="380298"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> One last thing.  Here is the formula to compute the effect of ground friction on an entity.  <br><br>Air friction is very mild when an object is moving at a low speed... an object will coast forever with only air friction affecting it.  But it kicks in when the object is moving really fast, so if you apply constant thrust, air friction will prevent the object from continuing to accelerate to thousands of miles per hour.  That is what the velocity squared bit does.  <br><br>Ground friction on the other hand does not depend on how fast the object is moving.  Ground friction slows an object down at a constant rate.  Ie, each second the object slides along the ground, it will move one meter per second slower.<br><br>Ground friction is was causes a fast moving object to slide along the ground rapidly, slow down quickly, and come to a jarring halt suddenly.<br><br>This is the ground friction equation:<br><br>Velocity# = Velocity# - (GROUND_FRICTION_CONSTANT# * Time_Delta_Sec#)<br><br>And note that here, just like with air friction, you MUST check to see if Velocity has gone negative and reset it to 0 if it has.<br><br>Actually... on second thought, checking with air frictioon might actually not be worthwile since it is probably impossible for the object to slow to 0 speed with air friction.  But there's still a chance, and it doesn't hurt to be safe.  Negative velocities make physics simulations blow up. <br><br></td></tr></table><br>
<a name="380522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shawn,<br><br>I have some of this Working, and I really appreciate you taking as much time as you did explaining this to me.<br><br>These Statments I understand, as I now have my Arrow Moving.<br><br>TFormNormal 0, 0, 1, Arrow, 0 <br>Thrust_Nx# = TFormedX() <br>Thrust_Ny# = TFormedY() <br>Thrust_Nz# = TFormedZ() <br><br>Where does the Gravity Vector come into play. My Code Below is with your help, How do I add the gravity? I want to make sure when my character is heading up a hill, he starts to slide backwards if I apply no forward thrust<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
gravity#=9.8
Friction#=.5
AngularV#=360
PhysicsTime#=.001
Time=MilliSecs()
Pointer=CreateSphere(8)
ScaleEntity Pointer,.1,.1,.1
EntityColor Pointer,255,0,0
Pointer1=CreateSphere(8)
ScaleEntity Pointer1,.1,.1,.1
EntityColor Pointer1,0,255,0

Repeat
 	 If KeyDown(205) 
			TurnEntity Character\Body,0,-AngularV#*PhysicsTime#,0
			End If
			If KeyDown(203)
				TurnEntity Character\Body,0,AngularV#*PhysicsTime#,0
			End If 
			If KeyDown(57)
			If Not Animating(Character\body) Then Animate Character\Body,3,3,1
				Thrust#=2
 			Else
				Thrust#=Thrust#*.95
			EndIf 

			TFormNormal 0, 0, 1, Character\Body, 0 
			Thrust_NX# = TFormedX() 
			Thrust_Ny# = TFormedY() 
			Thrust_Nz# = TFormedZ() 
			
			TFormNormal 0,-1,0,Character\body,0
			  
			Grav_NX# = TFormedX()  
			Grav_Ny# = TFormedY() 
			Grav_Nz# = TFormedZ() 

			
			Character\Vx# = ( Thrust_Nx# * Thrust#)  + (Grav_Nx#*Gravity#) 
			Character\Vy# = ( Thrust_Ny# * Thrust#)  + (Grav_Ny#*Gravity#) 
			Character\Vz# = ( Thrust_Nz# * Thrust#)  + (Grav_Nz#*Gravity#) 
 
			Character\Speed#=Sqr(Character\VX#^2+Character\VY#^2+Character\VZ#^2)
		  

			
			
			LinePick EntityX#(Character\Body),EntityY#(Character\Body)+5,EntityZ#(Character\Body),0,-10,0,0.2
			TranslateEntity Character\Body, Character\Vx#*PhysicsTime#,Character\Vy#*PhysicsTime# , Character\Vz#*PhysicsTime# 
 			AlignToVector Character\Body,PickedNX#(),PickedNY#(),PickedNZ#(),2,.15
 
			PhysicsTime#=(MilliSecs()-Time)/1000.00
			Time = MilliSecs()
			If Time &gt; F_time Then
				F_Time = Time + 1000
				FPS = Fcount
				fcount = 0
			Else
				fcount = fcount + 1
			End If
	
	Update_Camera(PhysicsTime#)
	
	UpdateWorld	
	RenderWorld  
			;PositionEntity Pointer ,EntityX#(Character\Body)+(Character\Vx#),EntityY#(Character\Body)+(Character\Vy#),EntityZ#(Character\Body)+(Character\Vz#)
			;PositionEntity Pointer1,EntityX#(Character\Body)-(Grav_NX#),EntityY#(Character\Body)-(Grav_NY#),EntityZ#(Character\Body)-(Grav_NZ#) 
	
 

	Text 10,12,Thrust_NX#+" "+Grav_NX#
	Text 10,24,Thrust_Ny#+" "+Grav_Ny#
	Text 10,36,Thrust_Nz#+" "+Grav_Nz#
	Text 10,48,"Entity Yaw"+EntityRoll(Character\body)
	Flip
	     
Until KeyHit(1)

</textarea><br><br><br>Why Doesn't My character Slide down the slop he is on?<br>I know you don't have the graphics, but I can climb up a slope but once I get up I can't go back down the slop. It's like gravity on a slop works in reverse.<br>Regards,<br>Eric <br><br></td></tr></table><br>
<a name="381358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Something else to be aware of with physics is this nasty little bug I posted a bug report on several updates ago (link below). The bottom post in the bug report topic includes code to compensate for it.<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=27508" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=27508</a> <br><br></td></tr></table><br>
<a name="381442"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why doesn't he slide down the slope?  Because you've got the physics all wrong. :-)<br><br>Wrong:<br>Character\Vx# = ( Thrust_Nx# * Thrust#)  + (Grav_Nx#*Gravity#) <br>Character\Vy# = ( Thrust_Ny# * Thrust#)  + (Grav_Ny#*Gravity#) <br>Character\Vz# = ( Thrust_Nz# * Thrust#)  + (Grav_Nz#*Gravity#) <br><br>I never told you how to apply thrust constantly, only how to apply instant thrust at the moment an arrow was released.<br><br>But I did tell you that when you add gravity you have to do something like Vx = Vx + Gx. <br><br>You're not even doing that here.  You've got these equations all messed up.<br><br>Take smaller steps.  You should have tried to get gravity working by itself first.  Then gotten instant thrust working.  Then you could have asked how to apply thrust over a period of time.<br><br><br>First off, this is all wrong:<br><br>If KeyDown(57)<br>If Not Animating(Character\body) Then Animate Character\Body,3,3,1<br>Thrust#=2<br>Else<br>Thrust#=Thrust#*.95<br>EndIf <br><br><br>Do this instead.  This is how you apply constant thrust.<br>If your player keeps accelerating forever, that it CORRECT!  That is not a mistake.  The problem is that you are not simulating air friction to limit his top speed.<br><br>; If player is pushing forward, increase speed by 10 meters per second, per second.<br>If KeyDown(57)<br>Thrust# = 10.0<br>Else<br>Thrust# = 0 <br>endif<br><br><br>Next, calcualte the direction of the thrust, which you have done correctly.<br><br>TFormNormal 0, 0, 1, Character\Body, 0 <br>Thrust_NX# = TFormedX() <br>Thrust_Ny# = TFormedY() <br><br>Thrust_Nz# = TFormedZ() <br><br><br>Now, calculate the thrust vector.<br>Thrust_Vx# = Thrust_NX# * Thrust#<br>Thrust_Vy# = Thrust_NY# * Thrust#<br>Thrust_Vz# = Thrust_NZ# * Thrust#<br><br><br>And finally, add the amount of thrust that should be applied during the time this frame took.<br>Vx# = Vx# + Thrust_Vx#*PhysicsTime#<br>Vy# = Vy# + Thrust_Vy#*PhysicsTime#<br>Vz# = Vz# + Thrust_Vz#*PhysicsTime#<br><br><br>That means this:<br>PhysicsTime#=(MilliSecs()-Time)/1000.00<br><br>Belongs at the top of the physics, not down the bottom.<br><br><br>This is also wrong:<br>TFormNormal 0,-1,0,Character\body,0<br>Grav_NX# = TFormedX()  <br>Grav_Ny# = TFormedY() <br>Grav_Nz# = TFormedZ() <br><br>This is right:<br>Grav_Nx# = 0<br>Grav_Ny# = -1<br>Grav_Nz# = 0<br><br><br>And this is wrong:<br>Character\Vx# = ( Thrust_Nx# * Thrust#)  + (Grav_Nx#*Gravity#) <br>Character\Vy# = ( Thrust_Ny# * Thrust#)  + (Grav_Ny#*Gravity#) <br>Character\Vz# = ( Thrust_Nz# * Thrust#)  + (Grav_Nz#*Gravity#) <br><br><br>This is right:<br>Character\Vx# = Character\Vx# + (Grav_Nx#*Gravity#)<br>Character\Vy# = Character\Vy# + (Grav_Ny#*Gravity#)<br>Character\Vz# = Character\Vz# + (Grav_Nz#*Gravity#)<br><br><br>This is wrong:<br>	LinePick EntityX#(Character\Body),EntityY#(Character\Body)+5,EntityZ#(Character\Body),0,-10,0,0.2<br>	TranslateEntity Character\Body, Character\Vx#*PhysicsTime#,Character\Vy#*PhysicsTime# , Character\Vz#*PhysicsTime# <br>	AlignToVector Character\Body,PickedNX#(),PickedNY#(),PickedNZ#(),2,.15<br><br><br>This  is right:<br>TranslateEntity Character\Body, Character\Vx#*PhysicsTime#,Character\Vy#*PhysicsTime# , Character\Vz#*PhysicsTime#<br><br><br>You should not be using linepick to calculate the height of the ground, you should be using collisions to dtermine when the object hits the ground, that way you can find the angle of the ground beneath the player.<br><br>And you should not be angling the player to the angle of the ground....  unless you're doing a skateboard simulation...<br><br>Which may be why you were calculating gravity in that funny way...  I suppose maybe you were trying to simulate centrifical force?  To make the player stick to the half pipe?  That's probably not the correct way to simulate that, but if it works for you... But add it AFTER you get the rest of the physics working! <br><br></td></tr></table><br>
<a name="381576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shawn,<br><br>Again, Thanks, I can honestly admit, that I tried to get the code to work with your previous explainations.. But I couldn't get it to work, so then I started playing around, and came up with the code that you just help me with. I am not a professional Programer, only a hobbyist, and the mathematical concepts elude me sometimes. So thanks for bearing with me. I will work with the examples you have laided out. Again, many thanks for taking the time.<br><br>Best Regards,<br>Eric <br><br></td></tr></table><br>
<a name="381586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> s=ut+1/2at^2<br><br>where u=initial velocity<br>s= horizontal displacement<br>a=acceleration<br>t=time<br><br>For a body after launch. <br><br></td></tr></table><br>
<a name="381615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whoopsie, made a mistake.<br><br><br>This is right:<br>Character\Vx# = Character\Vx# + (Grav_Nx#*Gravity#)<br>Character\Vy# = Character\Vy# + (Grav_Ny#*Gravity#)<br>Character\Vz# = Character\Vz# + (Grav_Nz#*Gravity#)<br><br><br>Actually, that is wrong.<br><br><br>This is right:<br>Character\Vx# = Character\Vx# + (Grav_Nx#*Gravity#)*PhysicsTime#<br>Character\Vy# = Character\Vy# + (Grav_Ny#*Gravity#)*PhysicsTime#<br>Character\Vz# = Character\Vz# + (Grav_Nz#*Gravity#)*PhysicsTime# <br><br></td></tr></table><br>
<a name="381629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shawn,<br><br>As I am looking at this Code,<br><br>Why do you Use PhysicsTime# in the above calculation and again in the Translate Entity command?<br><br>Regards,<br>Eric <br><br></td></tr></table><br>
<a name="381635"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vx, Vy, and Vz are the speed and direction of your entity in meters per second on each axis of the world.<br><br>Let's say your entity is moving at 10 meters per second.<br><br>If the current frame only takes 1/10th of a second to render, then you only want to move the entity one meter that frame.  That way, over the ovurse of a second the entity will have moved 10 meters.<br><br>If you did not scale the speed by the time a frame takes in seconds, then you would move the entity the same distance every frame, and the entity would move faster when you have a higher framerate, and slower when you have a lower framerate. <br><br></td></tr></table><br>
<a name="381636"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> And the reason I use it here:<br>Character\Vx# = Character\Vx# + (Grav_Nx#*Gravity#)*PhysicsTime# <br><br>Is because...<br><br>Gravity increases your speed by 9.8 meters per second, every second.<br><br>So, if the current frame is only 1/10th of a second, the gravity only has time enough to accelerate the object by .98 meters per second. <br><br></td></tr></table><br>
<a name="381898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok I got the code working, I am starting to understand how it all fits together. My character Continues in the direction I apply thrust. He is moving around like a space ship. Now I need to apply ground Friction. You told me to take this in pieces and that is what I am doing. <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
gravity#=.98
Friction#=.5
AngularV#=360

Time=MilliSecs()
GX#=0
GY#=-1
GZ#=0
Repeat
			PhysicsTime#=(MilliSecs()-Time)/1000.00 	 		
			If KeyDown(205) 
				TurnEntity Character\Body,0,-AngularV#*PhysicsTime#,0
			End If
			If KeyDown(203)
				TurnEntity Character\Body,0,AngularV#*PhysicsTime#,0
			End If 
			If KeyDown(200)
				Thrust#=5.0
 			Else
				Thrust#=0
			EndIf 
				  
			TFormNormal 0,0,1,Character\Body,0	
			Thrust_NX#=TFormedX()
			Thrust_NY#=TFormedY()
			Thrust_NZ#=TFormedZ()
			
		  	ThrustVectorX#=Thrust_NX#*Thrust#
			ThrustVectorY#=Thrust_NY#*Thrust#
 			ThrustVectorZ#=Thrust_NZ#*Thrust#

			Character\Vx#=Character\Vx#+ThrustVectorX#*PhysicsTime#
		 	Character\Vy#=Character\Vy#+ThrustVectorY#*PhysicsTime#
			Character\Vz#=Character\Vz#+ThrustVectorZ#*PhysicsTime#
			
			Character\Vx#=Character\Vx#+(GX#*Gravity#)*PhysicsTime#
		 	Character\Vy#=Character\Vy#+(GY#*Gravity#)*PhysicsTime#
			Character\Vz#=Character\Vz#+(GZ#*Gravity#)*PhysicsTime#

 
			
			TranslateEntity Character\Body, Character\Vx#*PhysicsTime#,Character\Vy#*PhysicsTime# , Character\Vz#*PhysicsTime# 
			C=CountCollisions(Character\Body)
			If C
				For Index=1 To C
					If CollisionNY#(Character\Body,Index)&gt;.5
					 AlignToVector Character\Body,CollisionNX#(Character\Body,Index),CollisionNY#(Character\Body,Index),CollisionNZ#(Character\Body,Index),2,.2
 					End If 

				Next 
			End If 
			PhysicsTime#=(MilliSecs()-Time)/1000.00
			Time = MilliSecs()
			If Time &gt; F_time Then
				F_Time = Time + 1000
				FPS = Fcount
				fcount = 0
			Else
				fcount = fcount + 1
			End If
	
	Update_Camera(PhysicsTime#)
	
	UpdateWorld	
	RenderWorld  
	 
	Flip
	     
Until KeyHit(1)
</textarea><br><br>Here is where I am... Look just like you've instructed<br><br>I think :)<br><br>Eric <br><br></td></tr></table><br>
<a name="381962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, but adding ground friction will only cause the space ship to slow down when you let off the gas.  It will not prevent it from accelerating forever.<br><br>If your ship won't move after you implement ground friction, then either you don't have enough thrust to overcome the ground friction, or the ground friction is too great. <br><br></td></tr></table><br>
<a name="381973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wayne</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> 'You should not be using linepick to calculate the height of the ground, you should be using collisions to dtermine when the object hits the ground, that way you can find the angle of the ground beneath the player. '<br><br>I don't agree with swifts linepick statement.  8)<br>I agree the linepick originally shown is of no value. <br><br>I prefer to use linepick to determine if a collision occured anywhere along my vector of travel, and then calculate any refelection(s) and continue until my line segment is complete for the unit of time. <br><br>I do this because blitz collisions fail for smaller obejects moving at higher rates of speed over a mesh. I imagine the sphere passes completly thru mesh or whatever and no intersection exists. <br><br></td></tr></table><br>
<a name="381992"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am trying to make this simple for him Wayne.  <br><br>Of course one can use a line pick for collisions, but it makes things more complicated, and I have never encounted the problem you refer to with regular collisions except when dealing with Bltiz terrains.  (The morphing appaears to screw up collisions.)<br><br>I had to choose one method to describe, so I chose the simplest one, which I use myself, and which works for most things perfeclty fine. :-) <br><br></td></tr></table><br>
<a name="382009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >(tu) ENAY</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Where's all your Matrix maths? ;) <br><br></td></tr></table><br>
<a name="382101"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok Shawn,<br><br>How do I change my code, so my character moves like a person would move. hahah Not Like he's on Ice.. I am assuming I need ground friction. But where do I apply that force?<br><br>Regards,<br>Eric <br><br></td></tr></table><br>
<a name="382114"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> "I am assuming I need ground friction. But where do I apply that force?"<br><br>At the start of the physics, before you add the thrust and gravity.  Same for air friction. <br><br></td></tr></table><br>
<a name="382116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Btw, for your game, you will probably want ground friction constant to be something you store in the player/enemy/item types.  That way you can have a high ground friction constant for the player, but a lower one for an object like a ball. <br><br></td></tr></table><br>
<a name="382202"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> I could actually change ground friction based on what I am standing on correct? Like looking at what texture is on a triangle and adjusting Ground Friction to that. Correct?<br><br>Ok..I add the same ground friction to Each of the Axis correct? <br><br>Regards,<br>Eric <br><br></td></tr></table><br>
<a name="382212"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> "I could actually change ground friction based on what I am standing on correct?"<br><br>Yes, definitely, but I'm not going to work out how to determine what texture you're standing on for you.  I haven't done it before, and it might be complicated. :-)<br><br><br>"Ok..I add the same ground friction to Each of the Axis correct?"<br><br>No.<br><br>Convert the vector to a speed and direction, as described above, do the following equation on the speed, clamp the speed to 0 if it goes below 0, and then convert back to a vector.<br><br><br>Speed# = Sqr(Vx#^2 + Vy#^2 + Vz^2)<br>Direction_X# = Vx# / Speed#<br>Direction_Y# = Vy# / Speed#<br>Direction_Z# = Vz# / Speed#<br><br>Speed# = Speed# - (GROUND_FRICTION_CONSTANT# * Time_Delta_Sec#) <br><br>If Speed# &lt; 0 then Speed# = 0<br><br>Vx# = Direction_X# * Speed#<br>Vy# = Direction_Y# * Speed#<br>Vz# = Direction_Z# * Speed# <br><br></td></tr></table><br>
<a name="382259"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya know Shawn,<br><br>I think my problem is, that I can't visualize how all these calculations take place, and that's probably why this isn't catching on. Is this program that you have been helping me on. Have we used any Dot Products or Cross Product equivalents? I need to investigate Vectors and Scalars. If I could visualise what's happening. Where The vectors are pointing. Anyhow in your examples, part of my confusion is the Variables we have been using.. Just tell me 2 more things.. #1 Your variables above Vx,Vy,Vz...Are they refering to my Character\VX...Etc?<br><br>and #2... I want my character to Jump. Is that hard to incorporate?<br><br>Best Regards,<br>Eric <br><br></td></tr></table><br>
<a name="382270"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> "Have we used any Dot Products or Cross Product equivalents?"<br><br>No.<br><br><br>"#1 Your variables above Vx,Vy,Vz...Are they refering to my Character\VX...Etc?"<br><br>Yes.  I'm just using shorthand.  Whenever I say Vx, I'm reffering to the Vx of whatever object it is you're doing the physics on at that moment.<br><br>"I want my character to Jump. Is that hard to incorporate?"<br><br>Not at all.  A jump is a vertical acceleration.  Rememebr the arrow example?  Calculate your direction... which is 0,1,0 and then decide on the amount of thrust... say... 10 meters per second...  And then multiply those together to get a vector as I showed with the arrow example...  And then add the result to Vx Vy Vz... ONCE.  The frame the player hits jump occurs, add it all, and then don't add any more.  <br><br>Just make sure when the player hits jump that you check to see if they are colliding with the ground first.  If they're not, then they can't jump... otherwise they'd be able to jump again while in the air. :-)<br><br>But you can worry about that later. <br><br></td></tr></table><br>
<a name="382422"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shawn, <br><br>I got all your code working and it seems to be falling into place.<br><br>Please take another look at this code.<br><br>Notice I have 3 lines remarked out. Everything runs, without ground friction. Once I un remark these three lines.. All my variable go NaN. and nothing runs.. I tried to track it down in debug mode. But can't Can you help. <br><br><br>The lines are           ;Vx# = Direction_X# * Speed#  <br>			;Vy# = Direction_Y# * Speed#  <br>			;Vz# = Direction_Z# * Speed#  <br><br>Regards,<br>Eric<br><br><br><pre class=code>
Friction#=0.5
gravity#=9.8
 
AngularV#=360
Jump#=5
Time=MilliSecs()
GX#=0
GY#=-1
GZ#=0
JX#=0
JY#=1
JZ#=0

Repeat
 
			PhysicsTime#=(MilliSecs()-Time)/1000.00 	 		
			If KeyDown(205) 
				TurnEntity Character,0,-AngularV#*PhysicsTime#,0
			End If
			If KeyDown(203)
				TurnEntity Character,0,AngularV#*PhysicsTime#,0
			End If 
			If KeyDown(200)
				Thrust#=5.0
 			Else
				Thrust#=0
			EndIf 
			C=CountCollisions(Character)
			If C
			VY#=0
				For Index=1 To C
					If CollisionNY#(Character,Index)&gt;.5
					 AlignToVector Character,CollisionNX#(Character,Index),CollisionNY#(Character,Index),CollisionNZ#(Character,Index),2,.2
 					End If 

				Next 
			End If 
			
			If KeyHit(57) And C=True
			JumpX#=JX#*Jump#
			JumpY#=JY#*Jump#
			JumpZ#=JZ#*Jump#
			Vx#=Vx#+JumpX#
		 	Vy#=Vy#+JumpY#
			Vz#=Vz#+JumpZ#
			End If 
				  
			TFormNormal 0,0,1,Character,0	
			Thrust_NX#=TFormedX()
			Thrust_NY#=TFormedY()
			Thrust_NZ#=TFormedZ()
			
		  	ThrustVectorX#=Thrust_NX#*Thrust#
			ThrustVectorY#=Thrust_NY#*Thrust#
 			ThrustVectorZ#=Thrust_NZ#*Thrust#

			Vx#=Vx#+(ThrustVectorX#*PhysicsTime#)+(GX#*Gravity#*PhysicsTime#)
		 	Vy#=Vy#+(ThrustVectorY#*PhysicsTime#)+(GY#*Gravity#*PhysicsTime#)
			Vz#=Vz#+(ThrustVectorZ#*PhysicsTime#)+(GZ#*Gravity#*PhysicsTime#)
								
			Speed# = Sqr(Vx#^2 + Vy#^2 + Vz#^2) 
			Direction_X# = Vx# / Speed# 
			Direction_Y# = Vy# / Speed# 
			Direction_Z# = Vz# / Speed# 
					
			Speed# = Speed# - (Friction# * PhysicsTime#) 

			If Speed# &lt; 0 Then Speed# = 0 

			;Vx# = Direction_X# * Speed#  
			;Vy# = Direction_Y# * Speed#  
			;Vz# = Direction_Z# * Speed#  

 
 
			
			TranslateEntity Character, Vx#*PhysicsTime#,Vy#*PhysicsTime# , Vz#*PhysicsTime# 
		
	 
			Time = MilliSecs()
			If Time &gt; F_time Then
				F_Time = Time + 1000
				FPS = Fcount
				fcount = 0
			Else
				fcount = fcount + 1
			End If
	
	Update_Camera(PhysicsTime#)
	 
	UpdateWorld	
	RenderWorld  
	   
	Flip
	     
Until KeyHit(1)
</pre> <br><br></td></tr></table><br>
<a name="382436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't tell what is going wrong just by looking at it.  Make a demo I can actually run by creating a sphere on a plane, and then I can debug it.<br><br>Ps:<br>Vx#=Vx#+(ThrustVectorX#*PhysicsTime#)+(GX#*Gravity#*PhysicsTime#)<br>		 	Vy#=Vy#+(ThrustVectorY#*PhysicsTime#)+(GY#*Gravity#*PhysicsTime#)<br>			Vz#=Vz#+(ThrustVectorZ#*PhysicsTime#)+(GZ#*Gravity#*PhysicsTime#)<br><br>Even though you CAN combine equations, it doesn't mean you should.  In the long run you'll be better off if you don't.  If you want to disable gravity later, or change how gravit ybehaves... or any number of things... you'll be better off keeping your equations simple, and seperate and adding all forces seperately. <br><br></td></tr></table><br>
<a name="382563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good Advice..<br><br>I actually combined them just before I sent my code..go figure.<br><br>Anyhow, When I get home, I will send you a copy of the code that you can run.<br><br>Best Regards,<br>Eric<br><br>BTW Where are you located? I am in Pennsylvania. <br><br></td></tr></table><br>
<a name="382615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> New Hampshire.<br><br>I drove through Pennsyvania once.  The highlights of my tour were a neverending highway with no sign of civilization in sight, torrential downpours, and Amish people eating at a Dennys. <br><br></td></tr></table><br>
<a name="382618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> hahahahh How True that is... :) I work in a town that is 30 mins from home, and is predominately Amish. 95 Degrees, 95% humitity and their riding a bike in a heavy weight full length dress. I don't know how they do it. <br><br></td></tr></table><br>
<a name="382687"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shawn,<br><br>Here is the Code.. Please forgive the sloppyness<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 1024,768,32,2
AntiAlias True 
 
Global Character=CreateCube()
ScaleEntity Character,.01,.01,.1
EntityColor Character,0,355,0
EntityType Character,2
;******************************* Camera Target *************************************
Global Target=CreatePivot(Character)
;******************************* Camera *************************************
Global Camera=CreateCamera()
CameraRange camera,.01,600
PositionEntity Camera,0,10,-10
;******************************* Board *************************************
Global Board=CreatePlane()
	EntityPickMode Board,2
	Tex=CreateTexture(128,128)
	SetBuffer TextureBuffer(Tex)
	 ClsColor 150,50,50
	Cls
	
	For j=0 To 128 Step 64
	Rect 0,j,128,16
	Rect j,0,16,128
	Next 
	SetBuffer BackBuffer()
	EntityTexture Board,Tex
	EntityType Board,1 
 

 
 
     
Collisions 2,1,2,3
 
set_player()
Friction#=0.5
gravity#=9.8
 
AngularV#=360
Jump#=10
Time=MilliSecs()
GX#=0
GY#=-1
GZ#=0
JX#=0
JY#=1
JZ#=0

Repeat
 
			PhysicsTime#=(MilliSecs()-Time)/1000.00 	 		
			If KeyDown(205) 
				TurnEntity Character,0,-AngularV#*PhysicsTime#,0
			End If
			If KeyDown(203)
				TurnEntity Character,0,AngularV#*PhysicsTime#,0
			End If 
			If KeyDown(200)
				Thrust#=5.0
 			Else
				Thrust#=0
			EndIf 
			
			C=CountCollisions(Character)
			If C
			VY#=0
				For Index=1 To C
					If CollisionNY#(Character,Index)&gt;.5
					 AlignToVector Character,CollisionNX#(Character,Index),CollisionNY#(Character,Index),CollisionNZ#(Character,Index),2,.2
 					End If 

				Next 
			End If 
			
			If KeyHit(57) And C=True
			JumpX#=JX#*Jump#
			JumpY#=JY#*Jump#
			JumpZ#=JZ#*Jump#
			Vx#=Vx#+JumpX#
		 	Vy#=Vy#+JumpY#
			Vz#=Vz#+JumpZ#
			End If 
				  
			TFormNormal 0,0,1,Character,0	
			Thrust_NX#=TFormedX()
			Thrust_NY#=TFormedY()
			Thrust_NZ#=TFormedZ()
			
		  	ThrustVectorX#=Thrust_NX#*Thrust#
			ThrustVectorY#=Thrust_NY#*Thrust#
 			ThrustVectorZ#=Thrust_NZ#*Thrust#

			Vx#=Vx#+(ThrustVectorX#*PhysicsTime#)+(GX#*Gravity#*PhysicsTime#)
		 	Vy#=Vy#+(ThrustVectorY#*PhysicsTime#)+(GY#*Gravity#*PhysicsTime#)
			Vz#=Vz#+(ThrustVectorZ#*PhysicsTime#)+(GZ#*Gravity#*PhysicsTime#)
								
			Speed# = Sqr(Vx#^2 + Vy#^2 + Vz#^2) 
			Direction_X# = Vx# / Speed# 
			Direction_Y# = Vy# / Speed# 
			Direction_Z# = Vz# / Speed# 
					
			Speed# = Speed# - (Friction# * PhysicsTime#) 

			If Speed# &lt; 0 Then Speed# = 0 

			;Vx# = Direction_X# * Speed# 
			;Vy# = Direction_Y# * Speed#  
			;Vz# = Direction_Z# * Speed#  

 
 
			
			TranslateEntity Character, Vx#*PhysicsTime#,Vy#*PhysicsTime# , Vz#*PhysicsTime# 
		
	 
			Time = MilliSecs()
			If Time &gt; F_time Then
				F_Time = Time + 1000
				FPS = Fcount
				fcount = 0
			Else
				fcount = fcount + 1
			End If
	
	Update_Camera(PhysicsTime#)
	 
	UpdateWorld	
	RenderWorld  
	   
	Flip
	     
Until KeyHit(1)
 
ClearWorld True,True,True 
End 


Function update_Camera(PhysicsTime#)
	dx#=EntityX( target,True)-EntityX( camera )
	dz#=EntityZ( target,True)-EntityZ( camera )
	dy#=EntityY( target)-EntityY( camera )
	TranslateEntity Camera,dx#*PhysicsTime#,dy#*PhysicsTime#,dz#*PhysicsTime#
	PointEntity Camera,Character
End Function 


 Function Set_Player()
	PositionEntity Character,0,25,0
	ScaleEntity Character,.25,.25,.5
	ResetEntity Character
	EntityRadius Character,.5,.45
	LinePick 0,15,0,0,-100,0
    PositionEntity Character,PickedX(),PickedY()+.21,PickedZ()
  	PositionEntity Camera,0,50,-50
	ResetEntity Target
	PositionEntity Target,0,5,-05
End Function 
</textarea> <br><br></td></tr></table><br>
<a name="382690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> I found the problem.<br><br>The problem is when your car first starts out it is not moving, so Vx# Vy# Vz# are 0.<br><br>As a result, speed is calculated to be 0, which is fine, but the car has no direction of travel.  Since Vx# / 0 = NaN, Direction becomes NaN.<br><br>Then, the code you commented out tries to convert speed and direction back into a vector, but when it does this, it multiples speed by NaN, which results in the vector becoming NaN, which then screws up all future caclulations.<br><br>The solution is to check when you convert from a vector to a speed and direction whether speed is 0 or not.<br><br>Like so:<br><br>			Speed# = Sqr(Vx#^2 + Vy#^2 + Vz#^2)<br>	<br>			If Speed# &gt; 0  <br>				Direction_X# = Vx# / Speed# <br>				Direction_Y# = Vy# / Speed# <br>				Direction_Z# = Vz# / Speed# <br>			Else<br>				Direction_X# = 0 <br>				Direction_Y# = 0 <br>				Direction_Z# = 0<br>			EndIf		<br><br><br>If it is 0, you set direction to a safe value.  Any value will do really, so we choose 0.<br><br>In my own code, I do things a little differently.  Instead of doing this check, what I do is I check to see if speed is 0 before I do my friction calculations.  If it is, I skip them.  There is no reason to check to see if the ship has slowed down any if it's speed is already 0.  And adding thrust does not require you to convert your vector to a speed and direction.<br><br>So perhaps you should do that instead of what I suggested above.  Calculate the speed before you do friction... you can skip the direction calculation... and then only do the friction calculations if the speed is greater than 0. <br><br></td></tr></table><br>
<a name="382712"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, It's all working now... Thanks for all your help.<br>I choose to only Calc The Direction if my Speed not  Zero.<br><br>Now I am going to attempt. Inclines. Right now, My character goes up and down them fine, I align him using The collision method you recommend. What My goal is, is depending on the angle of incline he will slid back down.<br><br>Thanks Again,<br>Eric <br><br></td></tr></table><br>
<a name="382731"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's one more thing you need to do.  And you need to check speed for this too.  Which is why I suggested you check that once anread of doing ti a bunch of seperate times. :-)<br><br>I don't have time to explain this in detail, but basically, this is how you make an object bounce off the level.  And you must do this, or else every second the object sits on the ground it is acceleratin downward from gravity, and just gaining energy that will make it stick to the ground even when you try to jump.<br><br>To make this work you need to get the collision normal between the object and the level.  This is a simple way to do that but might not work well for multiple objects in Blitz.  You'll have to get someoen else to help you fix up the collision code to make it robust, I ahven't got a ready made solution for that.<br><br>Anyhow, once you knwo the collision normal, you then can calculate the reflection angle given the angle the object was moving when it hit, and the angle of the surface.  Then the object will bounce off the surface.  Or it will just sit on the ground and not move, and NOT build up lots of downward momentum while it sits there, as gravity is canceled out each frame.<br><br><pre class=code>
	; If the entity collided with the level, make it bounce.
			If Entity_Hit &gt; 0 

				; Calculate bounce:

	    			; Get the normal of the surface which the entity collided with.    
					Nx# = CollisionNX(ballpos, 1)
					Ny# = CollisionNY(ballpos, 1)
					Nz# = CollisionNZ(ballpos, 1)
		
				; Compute the dot product of the entity's motion vector and the normal of the surface collided with.
					VdotN# = Vx#*Nx# + Vy#*Ny# + Vz#*Nz#
							
				; Calculate the normal force.
					NFx# = -2.0 * Nx# * VdotN#
					NFy# = -2.0 * Ny# * VdotN#
					NFz# = -2.0 * Nz# * VdotN#

				; Add the normal force to the direction vector.
					Vx# = Vx# + NFx#
					Vy# = Vy# + NFy#
					Vz# = Vz# + NFz#
</pre><br><br><br>Btw, there's your dot product. :-) <br><br></td></tr></table><br>
<a name="382757"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> With my original code, I lied I can go up inclines but not down, it seems like I get stuck when I turn down hill.<br><br>any Ideas <br><br></td></tr></table><br>
<a name="383834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Shawn,<br><br>Are you still there?<br><br>I need one last piece of advice. About my question above.. It refers to the code you evaluated for me.<br><br>Regards,<br>Eric<br><br>BTW Your bounce code works well, Thanks<br><br>Eric <br><br></td></tr></table><br>
<a name="383844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll need to see a demonstration program to tell you what's wrong there.  There should be no issue with going downhill, unless perhaps when you specified the collision mode, you specified the one that does not allow sliding downhill.  But you should not have to turn that on to be able to walk down hills.  So make a demonstration program. <br><br></td></tr></table><br>
<a name="383913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have no way to link to a program, It there a place that I can send it to you? <br><br></td></tr></table><br>
<a name="383937"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> My email address, which is in my profile. <br><br></td></tr></table><br>
<a name="383961"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> I sent the File, Please let me know if it made it. <br><br></td></tr></table><br>
<a name="384001"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes I got it I will look at it when I have the time. <br><br></td></tr></table><br>
<a name="384014"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK Thanks. <br><br></td></tr></table><br>
<a name="384771"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> I checked your code.  Your problem is that you are applying thrust only when the player is colliding with the ground.<br><br>When the player walks down a hill, they make a series of small bounces, so every other frame they may not be colliding with the ground.  This causes them to slow down a bit because no thrust is being applied.<br><br>To correct for this, if you want to apply thrust only when the player is colliding with the ground, then store the state of the last frame or two as far as collisions go, and if the player collided with the ground in the last three frames, then consider them as currently colliding with the ground for the purpouses of applying thrust.<br><br>You may also wish to do this for the purpouses of applying ground friction as well.  Apply it if the player collided in any of the last three frames.  That way if they bounce slightly they won't speed up from ground friction being disabled momentarily. <br><br></td></tr></table><br>
<a name="384779"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Eric</td><td align="right"><font class=tiny>(Posted 2004)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Amazing!! I will do that As Soon as I get home.<br><br>I am also working on a Space shooter, If I take away the Gravity# Most of this code will work for the Ship. <br>This little training course has been very helpful and very appreciated.<br><br>Regards,<br>Eric <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
