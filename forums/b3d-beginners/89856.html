<!DOCTYPE html><html lang="en" ><head ><title >Standard 3rd person controls?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Standard 3rd person controls?</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Standard 3rd person controls?</a><br><br>
<a name="1021208"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm trying to work on my first small game, and I need to know how to make standard 3rd person controls, similair to the ones in Super Mario 64. The type of controls that I'm talking about has been used in countless 3d platformers. Can someone with some experience help me out? please reply.thanks. <br><br></td></tr></table><br>
<a name="1021215"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Doggie</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure just what, but a good start might be Blitz3d/Samples/Mak/Castle/castle.bb <br><br></td></tr></table><br>
<a name="1021279"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doggie<br>well, I tried it, but it wasn't what I had in mind. I'm trying to achieve the controls thats similiar to the ones in Super Mario 64. <br><br></td></tr></table><br>
<a name="1021293"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not a lot of people know how to do this in these forums (unless I'm mistaking that for a lack of effort to try so).<br><br>Most will use globally aligned controls, meaning you will turn regarding the world's origin's axis. It's a simple TurnEntity(player,[...]).<br><br>What Super Mario 64 along with other N64 and Dual Shock PSOne games do is use <b>the camera as reference to know in what direction the player should turn</b>. <br>This method works better with analog controllers like gamepads. However, even with keyboards it's still great, since the player will have control of his character with the current view direction as reference, not some static axes.<br>By itself, this method does not allow strafing (walking sideways while aiming elsewhere, FPS style) - it can be added without a problem, though.<br><br>The method works like so:<br><pre class=code>
;Before anything takes place in your game:

VectorPivot = CreatePivot()
EntityParent(VectorPivot, Camera, False) ;False makes the pivot snap to the camera's orientation and position automatically.
</pre>Then, in your game loop or whatever:<br><pre class=code>
;You need a previously declared constant such as "pSpeed#" or something like that. It's the Player's movement speed.

;This snippet needs to run AFTER you pointed your camera to the player.

RotateEntity(VectorPivot, 0, EntityYaw(VectorPivot,True) , 0, True)

TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, VectorPivot, 0)

;The KeyRight, KeyLeft and the other variables are simple key states: KeyRight = KeyDown(203). 
;Makes it easier to handle.

AlignToVector(Player, TFormedX(), 0, TFormedZ(), 3) 
MoveEntity(Player, 0, 0, pSpeed)
</pre><br>Coded this blindly (i.e: didn't test it).<br><br>EDIT: Tested. Seems to work. <br><br></td></tr></table><br>
<a name="1021301"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GIB3D</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
InitGraphics()
FlushMouse

Global Light = CreateLight(2)
LightRange Light,6
PositionEntity Light,0,8,0


Global Camera_YPivot = CreatePivot()
Global Camera_XPivot = CreatePivot(Camera_YPivot)
Global Camera = CreateCamera(Camera_XPivot) : CameraFogMode Camera,1 : CameraFogRange Camera,100,400
	PositionEntity Camera,0,2,-5
	
Global Player = CreateCone():EntityTexture Player,GTexture(256)
RotateMesh Player,90,0,0
PositionEntity Player,-5,2,0

Global PlayerTurnPivot = CreateSphere(3)

Local Ground = CreatePlane()
EntityTexture Ground,GTexture(510,Rand(1,3))
EntityPickMode Ground,2
EntityType Ground,3

Local Sky = CreateSphere(3,Player)
EntityTexture Sky,GTexture(64,3)
EntityPickMode Sky,2
ScaleMesh Sky,200,200,200
FlipMesh Sky


Global LeftGun = CreateCone() : RotateMesh LeftGun,90,0,0 : ScaleMesh LeftGun,.25,.25,.5
Global RightGun = CopyMesh(LeftGun)
Global GunPointPivot = CreateSphere(3):EntityFX GunPointPivot,5:EntityColor GunPointPivot,255,0,0:EntityAlpha GunPointPivot,.5

Collisions 2,3,2,2

MouseXSpeed()
MouseYSpeed()
FlushMouse
While Not KeyDown(1)
	TranslateEntity Camera,0,(KeyDown(18)-KeyDown(16))*.5,MouseZSpeed() ; Zoom Camera
	
	;Guns
	CameraPick Camera,MouseX(),MouseY()
	PositionEntity GunPointPivot,PickedX(),PickedY(),PickedZ()
	
	TFormPoint -1,0,1,Player,0
	TranslateEntity LeftGun,((TFormedX())-EntityX(LeftGun,1))*.9,(TFormedY()-EntityY(LeftGun,1))*.9,(TFormedZ()-EntityZ(LeftGun,1))*.9
	TFormPoint 1,0,1,Player,0
	TranslateEntity RightGun,((TFormedX())-EntityX(RightGun,1))*.9,(TFormedY()-EntityY(RightGun,1))*.9,(TFormedZ()-EntityZ(RightGun,1))*.9
	
	If MouseDown(2)
		PointEntity LeftGun,GunPointPivot
		PointEntity RightGun,GunPointPivot
	Else
		RotateEntity LeftGun,0,EntityYaw(Player),0
		RotateEntity RightGun,0,EntityYaw(Player),0
	EndIf
	
	If MouseDown(1)
		CreateBullet(EntityX(LeftGun),EntityY(LeftGun),EntityZ(LeftGun),EntityPitch(LeftGun),EntityYaw(LeftGun),Rnd(.5,1),30)
		CreateBullet(EntityX(RightGun),EntityY(RightGun),EntityZ(RightGun),EntityPitch(RightGun),EntityYaw(RightGun),Rnd(.5,1),30)
	EndIf
	;Guns
	
	Local Sprint# = KeyDown(42)*2
	
	If Sprint &lt;&gt; 0
		TFormVector (KeyDown(32)-KeyDown(30))*.1*Sprint,0,(KeyDown(17)-KeyDown(31))*.1*Sprint,Camera_YPivot,0
	Else
		TFormVector (KeyDown(32)-KeyDown(30))*.1,0,(KeyDown(17)-KeyDown(31))*.1,Camera_YPivot,0
	EndIf
	
	TranslateEntity Player,TFormedX(),0,TFormedZ()
	
	If TFormedX() &lt;&gt; 0 Or TFormedZ() &lt;&gt; 0 ; Process turning
		PositionEntity PlayerTurnPivot,EntityX(Camera_YPivot,1)+TFormedX()*30,0,EntityZ(Camera_YPivot,1)+TFormedZ()*30
		TurnEntity Player,0,DeltaYaw(Player,PlayerTurnPivot)*.1,0
	EndIf
	
	FUNC_GTATurnCamera(Player,Camera_XPivot,Camera_YPivot)
	
	UpdateBullet()
	
	UpdateWorld
	RenderWorld
	
	Flip
	
Wend
End

Type Bullet
	Field Model
	Field Life,Speed#
End Type

Function CreateBullet(x#,y#,z#,pitch#,yaw#,speed#,life)
	Local a.Bullet = New Bullet
		a\Model = CreateSphere(4) : RotateMesh a\Model,90,0,0; : ScaleMesh a\Model,.25,.25,.25
		EntityColor a\Model,255,128,0
		EntityAlpha a\Model,Rnd(.1,1)
		EntityType a\Model,2
		
		RotateEntity a\Model,Rand(30,-30),Rand(30,-30),0
		
		Local Size# = Rnd(.5,1)
		ScaleMesh a\Model,Size,Size,Size
		
		PositionEntity a\Model,x,y,z
		RotateEntity a\Model,pitch,yaw,0
		
		a\Life = life
		a\Speed = speed
End Function

Function UpdateBullet()
	Local a.Bullet
	
	For a.Bullet = Each Bullet
		a\Life = a\Life - 1
		MoveEntity a\Model,0,0,a\Speed
		TurnEntity a\Model,0,0,10
		
		If a\Life =&lt; 0 Or CountCollisions(a\Model)
			FreeEntity a\Model
			Delete a
		EndIf
	Next
End Function

Function FUNC_GTATurnCamera(parent,xpivot,ypivot,turn_multiplier#=1)
	TranslateEntity ypivot,(EntityX(parent,1)-EntityX(ypivot,1))*.1,(EntityY(parent,1)-EntityY(ypivot,1))*.1,(EntityZ(parent,1)-EntityZ(ypivot,1))*.1
	
	TurnEntity ypivot,0,-MouseXSpeed()*turn_multiplier,0
	TurnEntity xpivot,MouseYSpeed()*turn_multiplier,0,0
	
	RotateEntity xpivot,EntityPitch(xpivot),0,0
	
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
End Function

Function InitGraphics(w = 1024, h = 768,title$="Blitz3D Program",exit_message$="")
	Graphics3D w, h, 32, 2
	SetBuffer BackBuffer()
	SeedRnd MilliSecs()
	
	If exit_message &lt;&gt; ""
		AppTitle title,exit_message
			Else
				AppTitle title
	EndIf
End Function

Function GTexture(size=64,rgb_dominant=2) ; Green Checkered Texture
	Local T = CreateTexture(size,size,1+256)
	Local Red,Green,Blue
	
	Select rgb_dominant
		Case 2 ; Green
			Red = 38
			Green = 148
			Blue = 0
		Case 3 ; Blue
			Red = 0
			Green = 38
			Blue = 148
		Default ; Red
			Red = 148
			Green = 0
			Blue = 38
	End Select
	
	SetBuffer TextureBuffer(T)
		Color Red,Green,Blue
		Rect 0,0,size,size
		
		Color Red*1.4,Green*1.4,Blue*1.4
		Rect size/2,0,size/2,size/2
		Rect 0,size/2,size/2,size/2
	SetBuffer BackBuffer()
	ScaleTexture T,4,4
	PositionTexture T,.25,.25
	
	Return T
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1021427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon<br>I tried to implement your code into mine, but all I got were some pretty ugly results.<br>heres the code.<br>;test;<br><br>Graphics3D 1280,600,32,2<br><br>Const GRAVITY#=-1.8<br>Const pSpeed#=2<br><br>Const TYPE_PLAYER=1,TYPE_TARGET=3,TYPE_WATER=3<br>Const TYPE_SCENERY=10,TYPE_TERRAIN=11<br><br>Collisions TYPE_PLAYER,TYPE_TERRAIN,2,3<br>Collisions TYPE_PLAYER,TYPE_SCENERY,2,3<br>Collisions TYPE_TARGET,TYPE_TERRAIN,2,2<br>Collisions TYPE_TARGET,TYPE_SCENERY,2,2<br>Collisions 1,2,2,2<br><br>seq=1<br><br>;player;<br>player=LoadAnimMesh ("media/Mechanibal.b3d")<br>playertex=LoadTexture ("media/(_Tg)mars70@...")<br>PositionEntity player,0,400,40<br>ScaleEntity player,.2,.2,.2<br>EntityShininess player,0<br>ExtractAnimSeq player,100,125<br>Animate player,2,1,seq,10<br>EntityRadius player,3,3<br>EntityType player,TYPE_PLAYER<br><br>;Lego Island;<br>island=LoadMesh("land3.b3d")<br>islandtex=LoadTexture("media/Untitled2.png",256+4)<br>islandtex2=LoadTexture("wood.png",256)<br>EntityShininess island,0<br>PositionEntity island,0,-160,60<br>ScaleEntity island,10,10,10<br>EntityFX island,0<br>EntityType island,TYPE_TERRAIN<br><br>;tree;<br>island2=LoadMesh("tree.b3d")<br>islandtex2=LoadTexture("media/Untitled2.png",256)<br>islandtex3=LoadTexture("wood.png",256)<br>EntityShininess island2,1<br>PositionEntity island2,30,-100,-120<br>ScaleEntity island2,1,1,1<br>EntityFX island2,0<br>EntityType island2,TYPE_TERRAIN<br><br>;water;<br>water = CreatePlane ()<br>h20=LoadTexture("patch (2).png")<br>EntityTexture water,h20<br>ScaleTexture h20, 50, 50<br>PositionEntity water,0,-140,60<br>EntityShininess water,0<br>EntityFX island,0<br>EntityType water,TYPE_TERRAIN<br><br>;camera (AKA the player);<br>camera=CreateCamera(target)<br>PositionEntity camera,0,200,-60<br>MoveEntity camera,0,3,-50 <br>PointEntity camera,player<br><br>VectorPivot = CreatePivot()<br>EntityParent(VectorPivot, camera, False) ;False makes the pivot snap to the camera's orientation and position automatically.<br><br>;light;<br>LightPivot = CreatePivot()<br>TurnEntity LightPivot, 0, 1800, 0<br><br>Light=CreateLight(1, LightPivot)<br>TurnEntity Light, 60, 0, 0<br>LightColor Light,225,100,0<br><br>;target;<br>target=CreatePivot( player )<br>MoveEntity Target,0,80,-350 <br>RotateEntity Target,0,80,0<br>	<br>;sky/fog/range;<br>sky=CreateSphere(100)<br>skytex=LoadTexture("media/sky_RT.jpg")<br>EntityTexture sky,skytex<br>ScaleEntity sky,9000,9000,9000<br>CameraFogMode camera,10<br>CameraFogColor camera,200, 220, 255<br>CameraRange camera, 1,50000<br>CameraFogRange camera,1,2500-10<br>CameraClsColor camera,200,220,255<br>FlipMesh sky<br><br>smooth=True<br>;move camera;<br>While Not KeyDown(1)<br>RotateEntity(VectorPivot, 0, EntityYaw(VectorPivot,True) , 0, True)<br>TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, VectorPivot, 0)<br>KeyRight = KeyDown(203)<br>KeyLeft = KeyDown(208) <br>TurnEntity sky,0,.1,0<br>TranslateEntity player,0,GRAVITY,0<br><br>AlignToVector(player, TFormedX(), 0, TFormedZ(), 3) <br>MoveEntity(player, 0, 0, pSpeed)<br><br>If Not KeyDown(1)<br>dx#=EntityX( target,True )-EntityX( camera )<br>		dy#=EntityY( target,True )-EntityY( camera )<br>		dz#=EntityZ( target,True )-EntityZ( camera )<br>	    TranslateEntity camera,dx*.3,dy*.1,dz*.3<br>		EndIf<br>	    PointEntity camera,player<br>	<br>UpdateWorld<br>RenderWorld<br>Flip<br>Wend				<br>End<br>I think maybe the problem could be in the camera, but i'm not sure. can you help? <br>please reply <br><br></td></tr></table><br>
<a name="1021577"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Doggie</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> You might want to make a zip file that includes your b3d model. Believe it or not sometimes it's the model itself that throws things off. Also makes it easier for others to test your code. If you're worried about someone using it or something just say "please don't use the included model for commercial purposes" ;) <br><br></td></tr></table><br>
<a name="1021711"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doggie<br>I think making and uploading a zip file would be over complicating it. I'll modify my code and chane the models with basic shapes. Just give me some time to modify the code:) <br><br></td></tr></table><br>
<a name="1021727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello TaGames.<br><br>I didn't give a tough look on your code so I can't say anything about it. Just make sure to adapt the example into your code, and not simply copy it. If you can't understand exactly what each line is doing, then nobody here can help you (no offense!).<br><br>That AlignToVector is the quick and dirty way to do the method, but it's certainly not the best. If you keep oscilating away and into the camera, the model turns in the X axis and screws everything up. Might work for a primitive, but not a player mesh.<br><br>The best is to do something like GIB3D did. We need to use another pivot so the player can turn to it with DeltaYaw, and don't use the Pitch axis.<br><br>Create another pivot, maybe called "PlayerOrientation", and use it like so:<br><pre class=code>
;Replace the AlignToVector line from the snippet I showed previously with this:

TFormPoint(TFormedX(),0,TFormedZ(),Player,0)
PositionEntity(PlayerOrientation,TFormedX(),TFormedY(),TFormedZ(),True)
TurnEntity(Player,0,DeltaYaw(Player,PlayerOrientation),0,True)
</pre><br>All those 3 lines should replace the AlignToVector line. Also, make sure to create the PlayerOrientation pivot (no need to pre-place it anywhere, those 3 lines take care of that). <br><br></td></tr></table><br>
<a name="1021796"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon<br>I am having trouble understanding this code, and your right about how no one can help me if I don't understand it. I don't understand this code, so in result I just keep on copy and pasting yours into mine, and I keep getting horrific results. I need alot of help understanding your code and method.<br>;test;<br><br>Graphics3D 1280,600,32,2<br><br>Const GRAVITY#=-1.8<br>Const pSpeed#=2<br><br>Const TYPE_PLAYER=1,TYPE_TARGET=3,TYPE_WATER=3<br>Const TYPE_SCENERY=10,TYPE_TERRAIN=11<br><br>Collisions TYPE_PLAYER,TYPE_TERRAIN,2,3<br>Collisions TYPE_PLAYER,TYPE_SCENERY,2,3<br>Collisions TYPE_TARGET,TYPE_TERRAIN,2,2<br>Collisions TYPE_TARGET,TYPE_SCENERY,2,2<br>Collisions 1,2,2,2<br><br>seq=1<br><br>;player;<br>player=LoadAnimMesh ("media/Mechanibal.b3d")<br>playertex=LoadTexture ("media/(_Tg)mars70@...")<br>PositionEntity player,0,400,40<br>ScaleEntity player,.2,.2,.2<br>EntityShininess player,0<br>ExtractAnimSeq player,100,125<br>Animate player,2,1,seq,10<br>EntityRadius player,3,3<br>EntityType player,TYPE_PLAYER<br><br>;Lego Island;<br>island=LoadMesh("land3.b3d")<br>islandtex=LoadTexture("media/Untitled2.png",256+4)<br>islandtex2=LoadTexture("wood.png",256)<br>EntityShininess island,0<br>PositionEntity island,0,-160,60<br>ScaleEntity island,10,10,10<br>EntityFX island,0<br>EntityType island,TYPE_TERRAIN<br><br>;tree;<br>island2=LoadMesh("tree.b3d")<br>islandtex2=LoadTexture("media/Untitled2.png",256)<br>islandtex3=LoadTexture("wood.png",256)<br>EntityShininess island2,1<br>PositionEntity island2,30,-100,-120<br>ScaleEntity island2,1,1,1<br>EntityFX island2,0<br>EntityType island2,TYPE_TERRAIN<br><br>;water;<br>water = CreatePlane ()<br>h20=LoadTexture("patch (2).png")<br>EntityTexture water,h20<br>ScaleTexture h20, 50, 50<br>PositionEntity water,0,-140,60<br>EntityShininess water,0<br>EntityFX island,0<br>EntityType water,TYPE_TERRAIN<br><br>;camera (AKA the player);<br>camera=CreateCamera(target)<br>PositionEntity camera,0,200,-60<br>MoveEntity camera,0,3,-50 <br>PointEntity camera,player<br><br>PlayerOrientation = CreatePivot()<br>EntityParent(PlayerOrientation , camera, False) ;False makes the pivot snap to the camera's orientation and position automatically.<br><br>;light;<br>LightPivot = CreatePivot()<br>TurnEntity LightPivot, 0, 1800, 0<br><br>Light=CreateLight(1, LightPivot)<br>TurnEntity Light, 60, 0, 0<br>LightColor Light,225,100,0<br><br>;target;<br>target=CreatePivot( player )<br>MoveEntity Target,0,80,-350 <br>RotateEntity Target,0,80,0<br>	<br>;sky/fog/range;<br>sky=CreateSphere(100)<br>skytex=LoadTexture("media/sky_RT.jpg")<br>EntityTexture sky,skytex<br>ScaleEntity sky,9000,9000,9000<br>CameraFogMode camera,10<br>CameraFogColor camera,200, 220, 255<br>CameraRange camera, 1,50000<br>CameraFogRange camera,1,2500-10<br>CameraClsColor camera,200,220,255<br>FlipMesh sky<br><br>smooth=True<br>;move camera;<br>While Not KeyDown(1)<br>If KeyDown(200)<br>KeyRight = KeyDown(200) <br>EndIf<br>TurnEntity sky,0,.1,0<br>TranslateEntity player,0,GRAVITY,0<br>TFormPoint(TFormedX(),0,TFormedZ(),player,0)<br>PositionEntity(PlayerOrientation,TFormedX(),TFormedY(),TFormedZ(),True)<br>TurnEntity(player,0,DeltaYaw(player,PlayerOrientation),0,True)<br><br>If Not KeyDown(1)<br>dx#=EntityX( target,True )-EntityX( camera )<br>		dy#=EntityY( target,True )-EntityY( camera )<br>		dz#=EntityZ( target,True )-EntityZ( camera )<br>	    TranslateEntity camera,dx*.3,dy*.1,dz*.3<br>		EndIf<br>	    PointEntity camera,player<br>	RotateEntity(PlayerOrientation, 0, EntityYaw(PlayerOrientation,True) , 0, True)<br>	TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, PlayerOrientation, 0)<br><br><br>UpdateWorld<br>RenderWorld<br>Flip<br>Wend				<br>End<br><br>can you please explain? <br><br></td></tr></table><br>
<a name="1021828"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey there, TAGames.<br><br>A few basic, general tips just to start off with:<br><br>1) Put your posted code into 'code' tags so it's easier to see and neater on the boards<br> [ codebox ]  ;Code Here [ / codebox ]<br>(Without the spaces!)<br><br>2) If you are having real trouble with a large chucnk of code, and honestly can't seem to understand a lot of it, then try to break it down into smaller pieces and concentrate on the smaller pieces one at a time.<br><br>As for the code posted above, since I dont have the various media files associated with it, can you explain a little more on "WHAT" problem you are having with it now? <br><br></td></tr></table><br>
<a name="1021908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Malice<br>The part in the code thats troubling me is this part.<br>This part is what I don't understand. When I put it in, the characters movements didn't work, the camera just started freaking out nonstop! I hope that now it's clearer<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">While Not KeyDown(1)
If KeyDown(200)
KeyRight = KeyDown(200)
EndIf
TurnEntity sky,0,.1,0
TranslateEntity player,0,GRAVITY,0
TFormPoint(TFormedX(),0,TFormedZ(),player,0)
PositionEntity(PlayerOrientation,TFormedX(),TFormedY(),TFormedZ(),True)
TurnEntity(player,0,DeltaYaw(player,PlayerOrientation),0,True)

If Not KeyDown(1)
dx#=EntityX( target,True )-EntityX( camera )
		dy#=EntityY( target,True )-EntityY( camera )
		dz#=EntityZ( target,True )-EntityZ( camera )
	    TranslateEntity camera,dx*.3,dy*.1,dz*.3
		EndIf
	    PointEntity camera,player
	
	RotateEntity(PlayerOrientation, 0, EntityYaw(PlayerOrientation,True) , 0, True)
TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, PlayerOrientation, 0)

UpdateWorld
RenderWorld
Flip
Wend				
End</textarea> <br><br></td></tr></table><br>
<a name="1022275"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well for starters, this bit is probably going to cause problems if it doesn't already:<br><br><pre class=code>
If KeyDown(200)
KeyRight = KeyDown(200)
EndIf
</pre><br><br>If you took your finger off the key, there's nothing to tell KeyRight to go back to 0, so it will remain as "True".<br>You can remove the 'Ifs' and just have the following, so KeyRight is updated automatically.<br><pre class=code>
KeyRight = KeyDown(200)
</pre><br><br>Next, onto the actual camera problem:<br><br>Every loop, the camera is moving closer to the target with this code:<br><br><pre class=code>
dx#=EntityX( target,True )-EntityX( camera )
		dy#=EntityY( target,True )-EntityY( camera )
		dz#=EntityZ( target,True )-EntityZ( camera )
	    TranslateEntity camera,dx*.3,dy*.1,dz*.3
</pre><br><br>Try adding in some distance checks and see if that makes a difference.<br>I cannot tell what kind of distances are suitable, so you'd have to experiment a little, but here's the basic idea:<br><br><pre class=code>
If ((EntityDistance(camera,target)&lt;2) or (EntityDistance(camera,target)&gt;5))
dx#=EntityX( target,True )-EntityX( camera )
		dy#=EntityY( target,True )-EntityY( camera )
		dz#=EntityZ( target,True )-EntityZ( camera )
	    TranslateEntity camera,dx*.3,dy*.1,dz*.3
End If
</pre> <br><br></td></tr></table><br>
<a name="1022349"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> malice<br>I tried your idea out, and I even did some tweaking here and there, but I think that the problem lies in this bit of the code.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
TFormPoint(TFormedX(),0,TFormedZ(),player,0)
PositionEntity(PlayerOrientation,TFormedX(),TFormedY(),TFormedZ(),True)
TurnEntity(player,0,DeltaYaw(player,PlayerOrientation),0,True)


If ((EntityDistance(camera,target)&lt;2) Or (EntityDistance(camera,target)&gt;5))
dx#=EntityX( target,True )-EntityX( camera )
		dy#=EntityY( target,True )-EntityY( camera )
		dz#=EntityZ( target,True )-EntityZ( camera )
	    TranslateEntity camera,dx*.3,dy*.1,dz*.3
End If

	    PointEntity camera,player
	
	RotateEntity(PlayerOrientation, 0, EntityYaw(PlayerOrientation,True) , 0, True)
TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, PlayerOrientation, 0)
</textarea><br>I think that the lines that are making the camera jerk and twitch could be this one<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
TFormPoint(TFormedX(),0,TFormedZ(),player,0)
PositionEntity(PlayerOrientation,TFormedX(),TFormedY(),TFormedZ(),True)
TurnEntity(player,0,DeltaYaw(player,PlayerOrientation),0,True)
</textarea><br>and this one<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	RotateEntity(PlayerOrientation, 0, EntityYaw(PlayerOrientation,True) , 0, True)
TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, PlayerOrientation, 0)
</textarea><br><br>I'm sorry about being so difficult, it's just that the controls that i'm trying to achieve are very important for the sake of this game. <br><br></td></tr></table><br>
<a name="1022431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> What happened to VectorPivot? why did you take it away?<br><br>You were told to "create <i>another</i> pivot", not replace the one already in use. Check post #9. <br><br></td></tr></table><br>
<a name="1022443"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon<br>Sorry, I did that by accident<br>I added VectorPivot and PlayerOrientation and I even brushed up the code. Now the camera doesn't twitch and jerk, but the player doesn't turn to any directions when he moves(if I press the right key, he doesn't turn right etc..)<br>I tried pointing the player to the vectorpivot but that just made it go all wonky.<br>What part of the code is supposed to make the player point in the correct directions?<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;test;

Include "include\FastExt.bb"
Include "include\ShadowsSimple.bb"

Graphics3D 1280,600,32,1

InitExt
TextureAnisotropy
TextureLodBias

CreateShadow 0,1									; &lt;&lt;&lt;&lt;&lt;   create shadows (with quality=1) and customize his characteristics
ShadowRange 90
ShadowPower .9
ShadowFade 100										; &lt;&lt;&lt;&lt;&lt;   set shadow range (70x70)
ShadowTexture = ShadowTexture()						; &lt;&lt;&lt;&lt;&lt;   get first shadow texture (shadow map)

Noise = LoadTexture("media\bump_noise.png")			; &lt;&lt;&lt;&lt;&lt;  load noise texture and set BUMP blend
TextureBlend Noise, FE_BUMP
ScaleTexture Noise, 0.15, 0.15

FadeOutTexture = LoadTexture("media\fade.png", 59)
ShadowFade FadeOutTexture
 
Const GRAVITY#=-1.8
Const pSpeed#=2

	Global GlowAlpha# = 101.0
	Global GlowDarkPasses = 1
	Global GlowBlurPasses = 4
	Global GlowBlurRadius# = 0.35
	Global GlowQuality = 0
	Global GlowColorRed = 255
	Global GlowColorGreen = 255
	Global GlowColorBlue = 255
	Global GlowAlphaTexture = 0
	; Variables for adjusting the effect
	Global DofNear# = 750
	Global DofFar# = 1400
	Global DofDirection = 1
	Global DofBlurPasses = 4
	Global DofBlurRadius# = 0.35
	Global DofQuality = 100


Const TYPE_PLAYER=1,TYPE_TARGET=3,TYPE_WATER=3
Const TYPE_SCENERY=10,TYPE_TERRAIN=11

Collisions TYPE_PLAYER,TYPE_TERRAIN,2,3
Collisions TYPE_PLAYER,TYPE_SCENERY,2,3
Collisions TYPE_TARGET,TYPE_TERRAIN,2,2
Collisions TYPE_TARGET,TYPE_SCENERY,2,2
Collisions 1,2,2,2

seq=1

VectorPivot = CreatePivot()
EntityParent(VectorPivot, camera, False) ;False makes the pivot snap to the camera's orientation and position automatically.
PlayerOrientation = CreatePivot()
EntityParent(PlayerOrientation, camera, False) ;False makes the pivot snap to the camera's orientation and position automatically.

;player;
player=LoadAnimMesh ("media/Mechanibal.b3d")
playertex=LoadTexture ("media/(_Tg)mars70@...")
PositionEntity player,0,400,40
ScaleEntity player,.2,.2,.2
EntityShininess player,0
ExtractAnimSeq player,100,125
Animate player,2,1,seq,10
EntityRadius player,3,3
EntityType player,TYPE_PLAYER
createshadowcaster player

;Lego Island;
island=LoadMesh("gearstaff.b3d")
islandtex=LoadTexture("media/Untitled2.png",256+4)
islandtex2=LoadTexture("wood.png",256)
EntityShininess island,0
PositionEntity island,0,-160,60
ScaleEntity island,10,10,10
EntityFX island,0
EntityType island,TYPE_TERRAIN
EntityTexture island, Noise, 0, 1										; &lt;&lt;&lt;&lt;&lt;  place noise texture before shadow texture
EntityTexture island, ShadowTexture, 0, 2		; &lt;&lt;&lt;&lt;&lt;   place shadow texture to receiver

;tree;
island2=LoadMesh("tree.b3d")
islandtex2=LoadTexture("media/Untitled2.png",256)
islandtex3=LoadTexture("wood.png",256)
EntityShininess island2,1
PositionEntity island2,30,-100,-120
ScaleEntity island2,1,1,1
EntityFX island2,0
EntityType island2,TYPE_TERRAIN
EntityTexture island2, Noise, 0, 1										; &lt;&lt;&lt;&lt;&lt;  place noise texture before shadow texture
EntityTexture island2, ShadowTexture, 0, 2		; &lt;&lt;&lt;&lt;&lt;   place shadow texture to receiver

;water;
water = CreatePlane ()
h20=LoadTexture("patch (2).png")
EntityTexture water,h20
ScaleTexture h20, 50, 50
PositionEntity water,0,-140,60
EntityShininess water,0
EntityFX island,0
EntityType water,TYPE_TERRAIN
EntityTexture island, Noise, 0, 1										; &lt;&lt;&lt;&lt;&lt;  place noise texture before shadow texture
EntityTexture water, ShadowTexture, 0, 2					; &lt;&lt;&lt;&lt;&lt;   place shadow texture to receiver

;camera (AKA the player);
camera=CreateCamera(target)
PositionEntity camera,0,200,-60
MoveEntity camera,0,3,-50 

;light;
LightPivot = CreatePivot()
TurnEntity LightPivot, 0, 1800, 0

Light=CreateLight(1, LightPivot)
TurnEntity Light, 60, 0, 0

ShadowLight Light	

;target;
target=CreatePivot( player )
MoveEntity Target,0,80,-350 
RotateEntity Target,0,80,0

;crosshair;
CH = LoadImage ("media/crosshair.bmp")
MaskImage CH, 255, 0, 255
MidHandle CH
	
;sky/fog/range;
sky=CreateSphere(100)
skytex=LoadTexture("media/sky_RT.jpg")
EntityTexture sky,skytex
ScaleEntity sky,9000,9000,9000
CameraFogMode camera,10
CameraFogColor camera,200, 220, 255
CameraRange camera, 1,50000
CameraFogRange camera,1,2500-10
CameraClsColor camera,200,220,255
FlipMesh sky

smooth=True
;move camera;
While Not KeyDown(1)
PointEntity camera,player
TranslateEntity player,0,GRAVITY,0
If KeyDown(200)
MoveEntity player,0,0,2
EndIf
If KeyDown(208)
MoveEntity player,0,0,-2
EndIf
If KeyDown(203)
MoveEntity player,-1,0,0
EndIf
If KeyDown(205)
MoveEntity player,1,0,0
EndIf

RotateEntity(VectorPivot, 0, EntityYaw(VectorPivot,True) , 0, True)

TFormVector(KeyRight-KeyLeft , 0, KeyUp-KeyDown, VectorPivot, 0)

TFormPoint(TFormedX(),0,TFormedZ(),player,0)
PositionEntity(PlayerOrientation,TFormedX(),TFormedY(),TFormedZ(),True)
TurnEntity(player,0,DeltaYaw(player,PlayerOrientation),0,True)

If Not KeyDown(1)
dx#=EntityX( target,True )-EntityX( camera )
		dy#=EntityY( target,True )-EntityY( camera )
		dz#=EntityZ( target,True )-EntityZ( camera )
	    TranslateEntity camera,dx*.3,dy*.1,dz*.3
EndIf
	
;attach crosshair;	
x = (MouseX () - x) / 3 + x
y = (MouseY () - y) / 3 + y
		
DrawImage CH, x, y
FlushKeys()

UpdateWorld
UpdateShadows player
RenderWorld

CustomPostprocessGlow GlowAlpha, GlowDarkPasses, GlowBlurPasses, GlowBlurRadius, GlowQuality, GlowColorRed, GlowColorGreen, GlowColorBlue, GlowAlphaTexture
RenderPostprocess FE_GLOW
CustomPostprocessDOF DofNear, DofFar, DofDirection, DofBlurPasses, DofBlurRadius, DofQuality
RenderPostprocess FE_DOF
Flip
Wend
FreeShadows	
DeInitExt					
End
</textarea> <br><br></td></tr></table><br>
<a name="1022467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Check post #9 for that too. It answers that precise question (if you want, I can quote the line that says that).<br><br><div class="quote"> What part of the code is supposed to make the player point in the correct directions? <br></div><br>I don't mean this in a demotivational way, but you REALLY shouldn't try to write code you don't understand. <br>If you can't visualize what your code is doing, you won't be able to solve it's bugs on your own (whether you're a beginner or advanced user).<br><br>I highly suggest you take the time to learn what each line is doing, even if that is the most boring thing of all. If you don't take the time to do that, it's impossible to get any better at this. <br><br></td></tr></table><br>
<a name="1022471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon<br>I understand what you mean. I'll try to understand the functions of the code better. Who knows, maybe i'll make my own version of the code that will work just aswell. That's what happened to me while I was trying to learn how to make a player align to the terrian. I ended up making my own code that worked. Thanks for trying to help. <br><br></td></tr></table><br>
<a name="1022840"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_PJ_</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I understand what you mean. I'll try to understand the functions of the code better. Who knows, maybe i'll make my own version of the code that will work just aswell. That's what happened to me while I was trying to learn how to make a player align to the terrian. I ended up making my own code that worked. Thanks for trying to help. <br> <br></div><br>That's how the learning process works with blitz :)<br><br>As I stated before, if you don't fully understand the entiretyy of a  chunk of code, concentrate on smaller parts until you are confident that each smaller part works as intended.<br>for example, a 3rd-persson camera code might be made up of the following smaller parts:<br><br><br>1) create player<br>2) create pivot with player as parent<br>3) create camera with the pivot as parent<br>4) place the camera at a reasonable distance from the pivot<br>5) ensure distance and facing of pivot is correct wrt player<br>6) ensure distance and facing of camera is correct with wrt pivot <br><br></td></tr></table><br>
<a name="1022873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Guys, I have looked and understood each of the functions of the code, I have checked many times and I have no doubt in myself that the code is executed correctly. After seeing how the code hasn't been working, I then studied it again and again, both by code and in game, and I realized the problem was all in my camera. The camera in my game was programmed so that it would STAY BEHIND the player AT ALL TIMES. The characters movements are correct, it's the camera that was messing it up.<br><br>Does anyone know any camera code that would work for this situation?<br>please reply <br><br></td></tr></table><br>
<a name="1024231"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grindalf</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Super ugly code taken from something i made years ago.<br>but you might be able to take the ideas and clean it up or something(because im to lazy lol)<br>double tap a direction to run<br><br>;----------code-----------<br>Graphics3D 800,600,32,2<br>SeedRnd MilliSecs()<br><br><br><br>player=CreateCube()<br>cam=CreateCamera()<br>cam_piv=CreatePivot()<br><br><br><br><br>Type cubes<br>	Field mesh<br>End Type<br>;---create random cubes to walk around---<br>For tmp=1 To 50<br>	cube.cubes=New cubes<br>	cube\mesh=CreateCube()<br>	PositionEntity cube\mesh,Rand(-100,100),0,Rand(-100,100)<br>Next<br><br><br><br><br><br><br><br>While KeyDown(1)=False<br><br>	kh_200=False:If KeyHit(200)=True kh_200=True<br>	kh_208=False:If KeyHit(208)=True kh_208=True<br>	kh_203=False:If KeyHit(203)=True kh_203=True<br>	kh_205=False:If KeyHit(205)=True kh_205=True<br>	kh_28=False:If KeyHit(28)=True kh_28=True<br><br><br>	;--camera physics--<br>	PositionEntity cam_piv,EntityX(player),EntityY(player),EntityZ(player)<br>	PositionEntity cam,EntityX(cam_piv),EntityY(cam_piv),EntityZ(cam_piv)<br>	RotateEntity cam,0,EntityYaw(cam_piv),0<br>	MoveEntity cam,0,5,-20<br><br>	tmp_yaw=EntityYaw(cam_piv)<br>	tmp_yaw2=EntityYaw(player)<br>	If tmp_yaw&lt;0 Then tmp_yaw=tmp_yaw+360<br>	If tmp_yaw2&lt;0 Then tmp_yaw2=tmp_yaw2+360<br><br>	If cam_active=True Then<br>		If tmp_yaw2&lt;tmp_yaw-180 Then<br>			TurnEntity cam_piv,0,1,0<br>		ElseIf tmp_yaw2&gt;tmp_yaw+180 Then<br>			TurnEntity cam_piv,0,-1,0<br>		ElseIf tmp_yaw2&gt;tmp_yaw Then<br>			TurnEntity cam_piv,0,1,0<br>		ElseIf tmp_yaw2&lt;tmp_yaw Then<br>			TurnEntity cam_piv,0,-1,0<br>		End If<br>	End If<br><br>    ;--controlls--<br>	If key_200_timer&gt;0 key_200_timer=key_200_timer-1:If kh_200=True running=True<br>	If kh_200=True And key_200_timer=0 key_200_timer=15<br>	If key_208_timer&gt;0 key_208_timer=key_208_timer-1:If kh_208=True running=True<br>	If kh_208=True And key_208_timer=0 key_208_timer=15<br>	If key_203_timer&gt;0 key_203_timer=key_203_timer-1:If kh_203=True running=True<br>	If kh_203=True And key_203_timer=0 key_203_timer=15<br>	If key_205_timer&gt;0 key_205_timer=key_205_timer-1:If kh_205=True running=True<br>	If kh_205=True And key_205_timer=0 key_205_timer=15<br>	If KeyDown(200)=False And KeyDown(208)=False And KeyDown(203)=False And KeyDown(205)=False Then running=False<br>    idle=True:cam_active=False<br>	If KeyDown(203) And KeyDown(200) Then<br>		RotateEntity player,0,EntityYaw(cam_piv)+45,0:idle=False:cam_active=True<br>	ElseIf KeyDown(205) And KeyDown(200) Then<br>		RotateEntity player,0,EntityYaw(cam_piv)-45,0:idle=False:cam_active=True<br>	ElseIf KeyDown(205) And KeyDown(208) Then<br>		RotateEntity player,0,EntityYaw(cam_piv)-135,0:idle=False:cam_active=True<br>	ElseIf KeyDown(203) And KeyDown(208) Then<br>		RotateEntity player,0,EntityYaw(cam_piv)+135,0:idle=False:cam_active=True<br>	ElseIf KeyDown(203) Then <br>		RotateEntity player,0,EntityYaw(cam_piv)+90,0:idle=False:cam_active=True<br>	ElseIf KeyDown(205) Then <br>		RotateEntity player,0,EntityYaw(cam_piv)-90,0:idle=False:cam_active=True<br>	ElseIf KeyDown(200) Then<br>		RotateEntity player,0,EntityYaw(cam_piv),0:idle=False:cam_active=True<br>	ElseIf KeyDown(208) Then <br>		RotateEntity player,0,EntityYaw(cam_piv)-180,0:idle=False:cam_active=False<br>	End If<br>	If idle=False And running=False Then MoveEntity player,0,0,.15<br>	If idle=False And running=True Then MoveEntity player,0,0,.3<br><br>	UpdateWorld<br>	RenderWorld<br>	Delay 1<br>	Flip<br>Wend<br>End <br><br></td></tr></table><br>
<a name="1024672"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello TAGames,<br><br>I used to have the same problem with 3rd person controls, and after a long time of playing around with some different functions, I finally came up with some code that helped me a lot. I am a Zelda fan, and have created my own little game based off of the series. I believe that the code is very easy to understand, but I am happy to answer any questions that you may have. Rather than give you the actual code, which is cluttered with everything else tied into my game, I will give you some Pseudo code, and explain it as I go along. The basic idea is to create a pivot that changes it's location relative to the character model based on user input (keyboard, mouse, joystick, ect.), and then to "point" the character at the pivot.<br><br>First, set up your graphics and a camera. For this example, I have called the camera simply "camera".<br><br>Next, create four global variables. Two will be for pivots (just declare the variables for now and we will create the pivots later), and let's call them piv1 and piv2 for this example. The other two are just variables to carry the x and z position of the 2nd pivot (piv2). Let's call those variables pivx and pivz for this example.<br><br>Global piv1<br>Global piv2<br>Global pivx<br>Global pivz<br><br>Now you will want to use a custom function to load your character model. The function should look like what is contained in the brackets (note that it is always good practice to declare your character variable name as global prior to this function):<br>{<br>Function CreateCharacter()<br><br>piv1 = CreatePivot()<br>piv2 = CreatePivot()<br><br>EntityParent piv2,piv1  ;The 1st pivot is now a parent to the 2nd pivot.<br>                                  ;This is needed to obtain relative position<br>                                  ;of your character, and without this line,<br>                                  ;the function will either fail or produce<br>                                  ;very random results.<br><br>;Load the character model here, and let's call him "player" in this example<br><br>;At this point, you will want to set up your character as much as possible,<br>;meaning that you can rotate, position, get animation, ect., before the game<br>;loop starts. The reason being is so that in the future, you can call the function ;"CreatePlayer" when making a new level, and Blitz now has a wonderful guide to do all ;of the grunt work for you.<br><br>End Function<br>}<br><br>Next, set up the rest of your game (load the rooms, lights, music, ect.)<br><br><br><br><br><br>And start the main loop (While Not Keydown(1), the loop is inside the brackets):<br>{<br>Update3rdPersonCamera ;Somewhere at the beginning of the loop, call this<br>                                    ;function to update your 3rd person camera, which<br>                                    ;is posted below.<br><br>Perform all game functions and updates as you normally would<br><br>Render the world, flip it, text drawing, ect., goes here<br>}<br>Wend<br><br><br><br><br><br>Now here is the function "Update3rdPersonCamera", which was called in the loop:<br><br><br><br>Function Update3rdPersonCamera()<br><br>PointEntity camera,player ;Point the camera at the character<br><br>If Keydown(75) ;If we push the number pad left key<br>     MoveEntity camera,-5,0,0 ;Effectively orbits the camera left around the character<br>EndIf<br><br>If KeyDown(77) ;If we push the number pad right key<br>    MoveEntity camera,5,0,0 ;Effectively orbits the camera right around the character<br>EndIf<br><br>;So far, this is pretty straight forward. Now, let's develop some code<br>;to help us determine how the character should rotate itself based<br>;upon which button we are pushing as well as how the camera is<br>;rotated. Because a keyboard has four basic directions (up arrow,<br>;down arrow, left arrow, and right arrow), let's focus on positioning<br>;our pivots in four basic directions (north, south, west, and east)<br>;based upon the camera's perspective. In other words, the up arrow<br>;will always correspond to north for the camera, which is straight <br>;forward into the screen. The down arrow will correspond to south <br>;for the camera, which is backward away from the screen. The<br>;left arrow will correspond to west for the camera, which is to<br>;the left in the 3D world, and the right arrow will correspond to east<br>;for the camera, which is to the right in the 3D world.<br><br>If KeyDown(200) ;If we push the up arrow<br>    pivz = 50 ;Set our global variable of pivz to 50<br>EndIf<br><br>If KeyDown(208) ;If we push the down arrow<br>    pivz = -50 ;Set our global variable of pivz to -50<br>EndIf<br><br>If KeyDown(203) ;If we push the left arrow<br>    pivx = -50 ;Set our global variable of pivx to -50<br>EndIf<br><br>If KeyDown(205) ;If we push the right arrow<br>    pivx = 50 ;Set our global variable of pivx to 50<br>EndIf<br><br>If Not KeyDown(200) ;If the up arrow is release<br>    If Not KeyDown(208) ;and if the down arrow is released<br>        pivz = 0 ;Reset the local "z" position of the 2nd pivot<br>    EndIf<br>EndIf<br><br>If Not KeyDown(203) ;If the left arrow is release<br>    If Not KeyDown(205) ;and if the right arrow is released<br>        pivx = 0 ;Reset the local "x" position of the 2nd pivot<br>    EndIf<br>EndIf<br><br>;This sets up a clean way to make a "box" of directions<br>;to surround our character. From here, the next step is <br>;to position the pivots accordingly, and to "point" the<br>;character at the 2nd pivot, thus rotating the character<br>;to point in the direction that we tell it to<br><br>RotateEntity piv1,0,EntityYaw(camera),0<br>                                                           ;Rotate the 1st pivot to match<br>                                                           ;the camera's current rotation<br><br>PositionEntity piv1,EntityX(player),EntityY(player),EntityZ(player) <br>                                                           ;Position the 1st pivot exactly<br>                                                           ;where your character is<br><br>PositionEntity piv2,pivx,EntityY(player),pivz,False<br>                                                           ;This is the most important<br>                                                           ;part. We want to position<br>                                                           ;the 2nd pivot in a way that<br>                                                           ;is offset from the 1st pivot.<br>                                                           ;Remember that we had earlier<br>                                                           ;set the 1st pivot to be a parent<br>                                                           ;to the 2nd pivot, so when we<br>                                                           ;first created the pivots, they<br>                                                           ;were initially create at the point<br>                                                           ;0,0,0. When we tell piv1 to go<br>                                                           ;to the x,y,z location of the <br>                                                           ;character, piv2 did the exact<br>                                                           ;same thing. Now when we <br>                                                           ;tell the piv2 to go to the <br>                                                           ;point at pivx,EntityY(player),pivz,False,<br>                                                           ;we are saying that pivot 2<br>                                                           ;should be positioned at pivx<br>                                                           ;(which is either 50 or -50),<br>                                                           ;EntityY(player) (the y value of the<br>                                                           ;character so we have consistent <br>                                                           ;results), and pivz (which is either<br>                                                           ;50 or -50). Now, the important<br>                                                           ;concept to understand is the last<br>                                                           ;constant of False, which tells<br>                                                           ;Blitz that we want it to be based<br>                                                           ;off of where the pivot 2 already<br>                                                           ;was. For example, if the character<br>                                                           ;was located at 10,15,30, the pivot<br>                                                           ;will position itself at the same location, and<br>                                                           ;then move itself in a relative<br>                                                           ;direction from the point, and the<br>                                                           ;new coordinates would be <br>                                                           ;something like 10,15,80 (30+50<br>                                                           ;is 80, which is where the pivot<br>                                                           ;would go if we pushed the up key).<br><br>If EntityDistance(piv2,player) &gt;= 10 ;Don't rotate the character unless<br>                                                     ;unless the distance between the<br>                                                     ;character and piv2 is greater than<br>                                                     ;or equal to 10. Otherwise the <br>                                                     ;character spazzes out when no<br>                                                     ;button is pressed.<br>    <br>    pitch  = EntityPitch(player) ;Get the pitch rotation of the model<br>    <br>    roll = EntityRoll(player) ;Get the roll rotation of the model<br>    <br>    PointEntity player,piv2 ;Point the character in the correct direction<br>    <br>    RotateEntity player,pitch,EntityYaw(player),roll<br>                                                           ;This line simply corrects any<br>                                                           ;unintended rotation other than<br>                                                           ;on the y-axis. x-axis and z-axis<br>                                                           ;can tilt the character is strange<br>                                                           ;ways.<br>    <br>    ;The code below in brackets is completely optional, and allows for<br>    ;the character to walk in the direction that he is facing, and the<br>    ;camera moves with him at the same speed.<br>{<br>    MoveEntity player,0,0,1 ;make the character walk or move in the<br>                                       ;direction that he is facing<br>    pitch = EntityPitch(camera) ;get the temporary rotation of the camera<br><br>    yaw = EntityYaw(camera) ;get the temporary rotation of the camera<br><br>    roll = EntityRoll(camera) ;get the temporary rotation of the camera<br><br>    RotateEntity camera,EntityPitch(player),EntityYaw(player),EntityRoll(player)<br>    ;The above line rotates the camera to match the rotation of the player<br><br>    MoveEntity camera,0,0,1<br>    ;Move the camera at the same pace and direction as the player moved<br><br>    RotateEntity camera,pitch,yaw,roll ;Return the camera back to it's original<br>                                                       ;rotation. This allows for cool camera<br>                                                       ;tricks such as pushing right while still<br>                                                       ;pointing at the player (a.k.a. sweeping)<br>}<br><br>EndIf<br><br>;Finally, add camera code to correct any distance issues, such as the <br>;camera is too close or the camera is too far away. (Note that the values<br>;will need tweaking, because I just pulled this off of the top of my<br>;head for this example)<br><br>If EntityDistance(player,camera) &gt; 100<br>    PointEntity camera,player<br>    MoveEntity camera,0,0,5<br>EndIf<br><br>If EntityDistance(player,camera) &lt; 10<br>  PointEntity camera,player<br>  MoveEntity camera,0,0,-5<br>EndIf<br><br>End Function<br><br><br><br>If you have everything set up correctly, you should see a result in which when you push the up arrow, the character will point in that direction and move in that direction. The same applies with all of the other three arrow buttons, as well as camera orbiting with the number pad left and number pad right buttons.<br><br>After reviewing my way old code, I've noticed that there are certainly faster ways of performing this routine without creating as many variables and pivots. I won't go into detail, because this tutorial has already gone way longer than I intended. Put simply, you could omit the 1st pivot as it's only purpose is to gather the x,y,z location of the player. But Blitz can do this already with the functions EntityX(), EntityY(), and EntityZ().<br><br>You can also change the code to accept mouse and joystick input as well. Play around with it, and see what you can come up with.<br><br>I am always glad to answer any questions you may have, and I do have source code available. However, it is very lengthy, and it would not be practical to post the entire 20 pages or so of my game on the forums. If you would like, however, I can send you the file and you can see for yourself.<br><br>This is only one way to perform this routine, but if you find another process that works better, by all means, use it. Also, I highly recommend obtaining a thorough understanding of my code before you try to implement it into your game. Good luck, and I hope that you can someday market your game.<br><br>-Rob Merrick <br><br></td></tr></table><br>
<a name="1024971"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob the Great<br>sorry that I haven't replied in such a long time. I have tried to dot down the code, and I have just got one little problem. For some reason, the Update3rdPersonCamera doesn't seem to recongnize the the camera, when I clearly created it at the beggining of the code. Should I create another function for creating the function, or is it the way that I set up your code?<br>I put down the code so you can see how I set it up. I didn't use any 3d models becuase I just wanted to test first:)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics3D 800,600,1,2

Global piv1
Global piv2
Global pivx
Global pivz

camera=CreateCamera()

Function CreateCharacter()

piv1 = CreatePivot()
piv2 = CreatePivot()

EntityParent piv2,piv1 

player=CreateCube()

End Function

While Not KeyDown(1)
Update3rdPersonCamera
RenderWorld 
Flip
Wend

Function Update3rdPersonCamera()

PointEntity camera,player ;Point the camera at the character

If KeyDown(75) ;If we push the number pad left key
MoveEntity camera,-5,0,0 ;Effectively orbits the camera left around the character
EndIf

If KeyDown(77) ;If we push the number pad right key
MoveEntity camera,5,0,0 ;Effectively orbits the camera right around the character
EndIf
If KeyDown(200) ;If we push the up arrow
pivz = 50 ;Set our global variable of pivz to 50
EndIf

If KeyDown(208) ;If we push the down arrow
pivz = -50 ;Set our global variable of pivz to -50
EndIf

If KeyDown(203) ;If we push the left arrow
pivx = -50 ;Set our global variable of pivx to -50
EndIf

If KeyDown(205) ;If we push the right arrow
pivx = 50 ;Set our global variable of pivx to 50
EndIf

If Not KeyDown(200) ;If the up arrow is release
If Not KeyDown(208) ;and if the down arrow is released
pivz = 0 ;Reset the local "z" position of the 2nd pivot
EndIf
EndIf

If Not KeyDown(203) ;If the left arrow is release
If Not KeyDown(205) ;and if the right arrow is released
pivx = 0 ;Reset the local "x" position of the 2nd pivot
EndIf
EndIf

RotateEntity piv1,0,EntityYaw(camera),0
;Rotate the 1st pivot to match
;the camera's current rotation

PositionEntity piv1,EntityX(player),EntityY(player),EntityZ(player) 
;Position the 1st pivot exactly
;where your character is

PositionEntity piv2,pivx,EntityY(player),pivz,False

If EntityDistance(piv2,player) &gt;= 10 ;Don't rotate the character unless
;unless the distance between the
;character and piv2 is greater than
;or equal to 10. Otherwise the 
;character spazzes out when no
;button is pressed.

pitch = EntityPitch(player) ;Get the pitch rotation of the model

roll = EntityRoll(player) ;Get the roll rotation of the model

PointEntity player,piv2 ;Point the character in the correct direction

RotateEntity player,pitch,EntityYaw(player),roll
;This line simply corrects any
;unintended rotation other than
;on the y-axis. x-axis and z-axis
;can tilt the character is strange
;ways.
MoveEntity player,0,0,1 ;make the character walk or move in the
;direction that he is facing
pitch = EntityPitch(camera) ;get the temporary rotation of the camera

yaw = EntityYaw(camera) ;get the temporary rotation of the camera

roll = EntityRoll(camera) ;get the temporary rotation of the camera

RotateEntity camera,EntityPitch(player),EntityYaw(player),EntityRoll(player)
;The above line rotates the camera to match the rotation of the player

MoveEntity camera,0,0,1
;Move the camera at the same pace and direction as the player moved

RotateEntity camera,pitch,yaw,roll ;Return the camera back to it's original
;rotation. This allows for cool camera
;tricks such as pushing right while still
;pointing at the player (a.k.a. sweeping)


EndIf

If EntityDistance(player,camera) &gt; 100
PointEntity camera,player
MoveEntity camera,0,0,5
EndIf

If EntityDistance(player,camera) &lt; 10
PointEntity camera,player
MoveEntity camera,0,0,-5
EndIf

End Function
</textarea><br>please reply. Nothings worst than being abandoned from a post, especially a post like this:( <br><br></td></tr></table><br>
<a name="1024973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GIB3D</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> It might help if you make the camera and player global ;) <br><br></td></tr></table><br>
<a name="1025021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> GIB3D<br>I tried. It still did not recongnize it:( <br><br></td></tr></table><br>
<a name="1025041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> I haven't had a chance to try out the sample code that I provided. Keep in mind that I only extracted the parts related to 3rd person camera control from my game, which is in a very very messy state right now. So, I'm going to try the code you've provided and see if I can figure out the problem. If not, I bet I still have the earlier test version, which is a small program written similar to this one and uses a cube as a player. Give me a little bit and I will write back to you.<br>-Rob Merrick <br><br></td></tr></table><br>
<a name="1025042"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so I've checked out the code, and there were a lot of problems with it. Remember to always declare variables as global if you want to use them everywhere else in the program. Also, I have updated the function "CreatePlayer" in order to perform the actions you wanted. Make sure that you return your model loaded from this function with the "Return" command, otherwise you will have blitz thinking that "player = 0" or "player = ".<br><br>I've updated the code to provide a little more depth. I think that the function was working, but you couldn't see the different angles because a cube looks the same from any four of the directions you view it at. So, I've posted some tested and working code now below. Let me know what you think.<br><br>-Rob Merrick <br><br></td></tr></table><br>
<a name="1025043"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Graphics3D 800,600,1,2  ;Set up graphics<br><br>;Create global pivot variables, two are for the pivots and two are for the positions<br>Global piv1<br>Global piv2<br>Global pivx<br>Global pivz<br><br>Global camera=CreateCamera()  ;Create a camera and make sure it is global<br><br>light = CreateLight()  ;Create a light to give a sense of depth, looks better<br>PositionEntity light,10,10,10<br><br>PositionEntity camera,0,10,-5  ;Move the camera up and back a little, just to help with depth perception<br><br>Function CreateCharacter()  ;Call this function to set up your 3rd person camera and create a player<br><br>	piv1 = CreatePivot() ;create two pivots for 3rd person camera<br>	piv2 = CreatePivot()<br><br>	EntityParent piv2,piv1  ;assign 2nd pivot to have a parent of the 1st one, needs this line for relative positioning<br>	<br>	character = CreateCube() ;create or load your character here<br>	ball = CreateSphere()  ;I've created a ball to represent the front of the character<br>	MoveEntity ball,0,0,1  ;Position the ball to the front of the cube<br>	EntityParent ball,character  ;just tells the ball to follow wherever the cube goes<br>	Return character  ;IMPORTANT! Without this line, you've created a character, but the character is not saved as "player"<br><br>End Function<br><br>Global player=CreateCharacter()  ;creates the player from above and saved it as "player"<br><br>PointEntity light,player  ;just point the light at the player<br><br>While Not KeyDown(1)  ;main loop<br>	Update3rdPersonCamera()  ;update the camera<br>	PositionEntity camera,EntityX(camera),10,EntityZ(camera)  ;this just ensures that the height of the camera doesn't change<br>	RenderWorld  ;update everything<br>	Text 0,0,"player yaw: " + EntityYaw(player) ;get information to the screen<br>	Text 0,20,"player x: " + EntityX(player)<br>	Text 0,40,"player y: " + EntityY(player)<br>	Text 0,60,"player z: " + EntityZ(player)<br>	Text 0,100,"camera yaw: " + EntityYaw(camera)<br>	Text 0,120,"camera x: " + EntityX(camera)<br>	Text 0,140,"camera y: " + EntityY(camera)<br>	Text 0,160,"camera z: " + EntityZ(camera)<br>	Flip<br>Wend<br><br>Function Update3rdPersonCamera()<br><br>	PointEntity camera,player ;Point the camera at the character<br>	<br>	If KeyDown(75) ;If we push the number pad left key<br>		MoveEntity camera,-.5,0,.05 ;Effectively orbits the camera left around the character<br>	EndIf<br>	<br>	If KeyDown(77) ;If we push the number pad right key<br>		MoveEntity camera,.5,0,.05 ;Effectively orbits the camera right around the character<br>	EndIf<br>	<br>	If KeyDown(200) ;If we push the up arrow<br>		pivz = 50 ;Set our global variable of pivz to 50<br>	EndIf<br>	<br>	If KeyDown(208) ;If we push the down arrow<br>		pivz = -50 ;Set our global variable of pivz to -50<br>	EndIf<br>	<br>	If KeyDown(203) ;If we push the left arrow<br>		pivx = -50 ;Set our global variable of pivx to -50<br>	EndIf<br>	<br>	If KeyDown(205) ;If we push the right arrow<br>		pivx = 50 ;Set our global variable of pivx to 50<br>	EndIf<br>	<br>	If Not KeyDown(200) ;If the up arrow is release<br>		If Not KeyDown(208) ;and if the down arrow is released<br>			pivz = 0 ;Reset the local "z" position of the 2nd pivot<br>		EndIf<br>	EndIf<br>	<br>	If Not KeyDown(203) ;If the left arrow is release<br>		If Not KeyDown(205) ;and if the right arrow is released<br>			pivx = 0 ;Reset the local "x" position of the 2nd pivot<br>		EndIf<br>	EndIf<br>	<br>	RotateEntity piv1,0,EntityYaw(camera),0<br>	;Rotate the 1st pivot to match<br>	;the camera's current rotation<br>	<br>	PositionEntity piv1,EntityX(player),EntityY(player),EntityZ(player) <br>	;Position the 1st pivot exactly<br>	;where your character is<br>	<br>	PositionEntity piv2,pivx,EntityY(player),pivz,False<br>	<br>	If EntityDistance(piv2,player) &gt;= 10 ;Don't rotate the character unless<br>	;unless the distance between the<br>	;character and piv2 is greater than<br>	;or equal to 10. Otherwise the <br>	;character spazzes out when no<br>	;button is pressed.<br>	<br>	pitch = EntityPitch(player) ;Get the pitch rotation of the model<br>	<br>	roll = EntityRoll(player) ;Get the roll rotation of the model<br>	<br>	PointEntity player,piv2 ;Point the character in the correct direction<br>	<br>	RotateEntity player,pitch,EntityYaw(player),roll<br>	;This line simply corrects any<br>	;unintended rotation other than<br>	;on the y-axis. x-axis and z-axis<br>	;can tilt the character is strange<br>	;ways.<br>	MoveEntity player,0,0,1 ;make the character walk or move in the<br>	;direction that he is facing<br>	pitch = EntityPitch(camera) ;get the temporary rotation of the camera<br>	<br>	yaw = EntityYaw(camera) ;get the temporary rotation of the camera<br>	<br>	roll = EntityRoll(camera) ;get the temporary rotation of the camera<br>	<br>	RotateEntity camera,EntityPitch(player),EntityYaw(player),EntityRoll(player)<br>	;The above line rotates the camera to match the rotation of the player<br>	<br>	MoveEntity camera,0,0,1<br>	;Move the camera at the same pace and direction as the player moved<br>	<br>	RotateEntity camera,pitch,yaw,roll ;Return the camera back to it's original<br>	;rotation. This allows for cool camera<br>	;tricks such as pushing right while still<br>	;pointing at the player (a.k.a. sweeping)<br>	<br>		<br>	EndIf<br>	<br>	If EntityDistance(player,camera) &gt; 100<br>		PointEntity camera,player<br>		MoveEntity camera,0,0,5<br>	EndIf<br><br>	If EntityDistance(player,camera) &lt; 10<br>		PointEntity camera,player<br>		MoveEntity camera,0,0,-5<br>	EndIf<br><br>End Function <br><br></td></tr></table><br>
<a name="1025044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> On a side note, I've never posted a topic before. How do you embed the code so it looks nice like you did above? Thanks for the help!<br><br>-Rob Merrick <br><br></td></tr></table><br>
<a name="1025062"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Doggie</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code> use brackets around the word "code" and then "/code" </pre> <br><br></td></tr></table><br>
<a name="1025100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool. Let me post the code again to help clean it up. As a programmer, I like using tabs and spaces to help seperate functions and whatnot.<br><br><pre class=code>
Graphics3D 800,600,1,2  ;Set up graphics

;Create global pivot variables, two are for the pivots and two are for the positions
Global piv1
Global piv2
Global pivx
Global pivz

Global camera=CreateCamera()  ;Create a camera and make sure it is global

light = CreateLight()  ;Create a light to give a sense of depth, looks better
PositionEntity light,10,10,10

PositionEntity camera,0,10,-5  ;Move the camera up and back a little, just to help with depth perception

Function CreateCharacter()  ;Call this function to set up your 3rd person camera and create a player

	piv1 = CreatePivot() ;create two pivots for 3rd person camera
	piv2 = CreatePivot()

	EntityParent piv2,piv1  ;assign 2nd pivot to have a parent of the 1st one, needs this line for relative positioning
	
	character = CreateCube() ;create or load your character here
	ball = CreateSphere()  ;I've created a ball to represent the front of the character
	MoveEntity ball,0,0,1  ;Position the ball to the front of the cube
	EntityParent ball,character  ;just tells the ball to follow wherever the cube goes
	Return character  ;IMPORTANT! Without this line, you've created a character, but the character is not saved as "player"

End Function

Global player=CreateCharacter()  ;creates the player from above and saved it as "player"

PointEntity light,player  ;just point the light at the player

While Not KeyDown(1)  ;main loop
	Update3rdPersonCamera()  ;update the camera
	PositionEntity camera,EntityX(camera),10,EntityZ(camera)  ;this just ensures that the height of the camera doesn't change
	RenderWorld  ;update everything
	Text 0,0,"player yaw: " + EntityYaw(player) ;get information to the screen
	Text 0,20,"player x: " + EntityX(player)
	Text 0,40,"player y: " + EntityY(player)
	Text 0,60,"player z: " + EntityZ(player)
	Text 0,100,"camera yaw: " + EntityYaw(camera)
	Text 0,120,"camera x: " + EntityX(camera)
	Text 0,140,"camera y: " + EntityY(camera)
	Text 0,160,"camera z: " + EntityZ(camera)
	Flip
Wend

Function Update3rdPersonCamera()

	PointEntity camera,player ;Point the camera at the character
	
	If KeyDown(75) ;If we push the number pad left key
		MoveEntity camera,-.5,0,.05 ;Effectively orbits the camera left around the character
	EndIf
	
	If KeyDown(77) ;If we push the number pad right key
		MoveEntity camera,.5,0,.05 ;Effectively orbits the camera right around the character
	EndIf
	
	If KeyDown(200) ;If we push the up arrow
		pivz = 50 ;Set our global variable of pivz to 50
	EndIf
	
	If KeyDown(208) ;If we push the down arrow
		pivz = -50 ;Set our global variable of pivz to -50
	EndIf
	
	If KeyDown(203) ;If we push the left arrow
		pivx = -50 ;Set our global variable of pivx to -50
	EndIf
	
	If KeyDown(205) ;If we push the right arrow
		pivx = 50 ;Set our global variable of pivx to 50
	EndIf
	
	If Not KeyDown(200) ;If the up arrow is release
		If Not KeyDown(208) ;and if the down arrow is released
			pivz = 0 ;Reset the local "z" position of the 2nd pivot
		EndIf
	EndIf
	
	If Not KeyDown(203) ;If the left arrow is release
		If Not KeyDown(205) ;and if the right arrow is released
			pivx = 0 ;Reset the local "x" position of the 2nd pivot
		EndIf
	EndIf
	
	RotateEntity piv1,0,EntityYaw(camera),0
	;Rotate the 1st pivot to match
	;the camera's current rotation
	
	PositionEntity piv1,EntityX(player),EntityY(player),EntityZ(player) 
	;Position the 1st pivot exactly
	;where your character is
	
	PositionEntity piv2,pivx,EntityY(player),pivz,False
	
	If EntityDistance(piv2,player) &gt;= 10 ;Don't rotate the character unless
	;unless the distance between the
	;character and piv2 is greater than
	;or equal to 10. Otherwise the 
	;character spazzes out when no
	;button is pressed.
	
	pitch = EntityPitch(player) ;Get the pitch rotation of the model
	
	roll = EntityRoll(player) ;Get the roll rotation of the model
	
	PointEntity player,piv2 ;Point the character in the correct direction
	
	RotateEntity player,pitch,EntityYaw(player),roll
	;This line simply corrects any
	;unintended rotation other than
	;on the y-axis. x-axis and z-axis
	;can tilt the character is strange
	;ways.
	MoveEntity player,0,0,1 ;make the character walk or move in the
	;direction that he is facing
	pitch = EntityPitch(camera) ;get the temporary rotation of the camera
	
	yaw = EntityYaw(camera) ;get the temporary rotation of the camera
	
	roll = EntityRoll(camera) ;get the temporary rotation of the camera
	
	RotateEntity camera,EntityPitch(player),EntityYaw(player),EntityRoll(player)
	;The above line rotates the camera to match the rotation of the player
	
	MoveEntity camera,0,0,1
	;Move the camera at the same pace and direction as the player moved
	
	RotateEntity camera,pitch,yaw,roll ;Return the camera back to it's original
	;rotation. This allows for cool camera
	;tricks such as pushing right while still
	;pointing at the player (a.k.a. sweeping)
	
		
	EndIf
	
	If EntityDistance(player,camera) &gt; 100
		PointEntity camera,player
		MoveEntity camera,0,0,5
	EndIf

	If EntityDistance(player,camera) &lt; 10
		PointEntity camera,player
		MoveEntity camera,0,0,-5
	EndIf

End Function
</pre> <br><br></td></tr></table><br>
<a name="1025112"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry to be annoying with the replies, but here is another demo adapted from the code above. This version shows more in depth what is really happening in the 3D world.<br><br><pre class=code>
;Rob Merrick's 3rd Person Camera Test and Demo.

;This program sets up a character figure, a terrain, and trees, and 
;demonstrates the use of a 3rd person camera. I use this similar routine
;in a zelda game that I have designed. Note that the zelda game was only
;made for "shits and giggles", and I do not make any profit from the
;copyrighted material.

;Virtually every line is commented to ensure that whoever reads it can clearly understand
;what's happening.

;This routine is still a fairly inefficient one. I have taken code that is years old and
;written it in a way to give example of how a 3rd person camera works.
;It is based on the commands of relative positioning from the blitz3d engine.

;This code can be re-written to support joystick commands and other forms of input, and it
;was originally design to do so. For more information, contact me and I will provide
;other variations of this code.

;I consider this code to be open-source, and I do not require any credit that this code may
;appear in. I'm sure I'm not the first person to come up with this idea, but if you do
;desire to add in my credit, I will go by the name of Rob Merrick.

;For a complete version of my game demo, visit www.merrickproductions.com/videogame.htm.

;Thank you for your interest, and enjoy!


;Program Setup
;--------------------------------------------------------------------------------------------------------------------------

Graphics3D 800,600,1,2           ;Set up graphics

SetBuffer BackBuffer()           ;Set up double buffer. Makes smoother graphics.

Global piv1                      ;Create global pivot variables, two are for
Global piv2                      ;the pivots and two are for the positions.
Global pivx
Global pivz

Global camera=CreateCamera()     ;Create a camera and make sure it is global

Global plane = CreatePlane()     ;Let's Create a little ground for our player.
EntityColor plane,125,100,50     ;Give the ground a brown color
PositionEntity plane,0,-1,0      ;Move the ground down a little bit

CreateRandomTerrain()            ;Call a function to generate some "trees"

light = CreateLight()            ;Create a light to give a sense of depth, looks better
PositionEntity light,10,10,10    ;Move the light to give some shading effects

PositionEntity camera,0,10,-5    ;Move the camera up and back a little, just to help with depth perception

Global player=CreateCharacter()  ;Call a funtion to create the main character and save it as "player"

PointEntity light,player         ;just point the light at the player

;--------------------------------------------------------------------------------------------------------------------------
;End the Program Setup


;Start the Main Loop
;--------------------------------------------------------------------------------------------------------------------------


While Not KeyDown(1)                                          ;main loop

	Update3rdPersonCamera()                                   ;update the camera-This should be towards the top of the loop to avoid problems
	PositionEntity camera,EntityX(camera),10,EntityZ(camera)  ;this just ensures that the height of the camera doesn't change
	RenderWorld                                               ;update everything, get new positions and prepare to draw to the screen
	Text 0,0,"player yaw: " + EntityYaw(player)               ;get information to the screen
	Text 0,20,"player x: " + EntityX(player)
	Text 0,40,"player y: " + EntityY(player)
	Text 0,60,"player z: " + EntityZ(player)
	Text 0,100,"camera yaw: " + EntityYaw(camera)
	Text 0,120,"camera x: " + EntityX(camera)
	Text 0,140,"camera y: " + EntityY(camera)
	Text 0,160,"camera z: " + EntityZ(camera)
	Text 300,0,"3rd Person Camera Control:"                   ;Give controls information to the screen
	Text 300,20,"Push the arrow keys to point"
	Text 300,40,"the character in that direction."
	Text 300,60,"Push the pad left and right arrows"
	Text 300,80,"to orbit that camera in that direction."
	Flip                                                      ;The actual drawing process for blitz. Flipping the double buffer
	
Wend

End                                                           ;When you leave the main loop, always call this command.

;--------------------------------------------------------------------------------------------------------------------------
;End the Main Loop


;Start the Functions List
;--------------------------------------------------------------------------------------------------------------------------

Function CreateCharacter()               ;Call this function to set up your 3rd person camera and create a player

	piv1 = CreatePivot()                 ;create two pivots for 3rd person camera
	piv2 = CreatePivot()

	EntityParent piv2,piv1               ;assign 2nd pivot to have a parent of the 1st one, needs this line for
										 ;relative positioning
	
	character = CreateCube()             ;create or load your character here
	ball = CreateSphere()                ;I've created a ball to represent the front of the character
	MoveEntity ball,0,0,1                ;Position the ball to the front of the cube
	EntityParent ball,character          ;just tells the ball to follow wherever the cube goes
	Return character                     ;IMPORTANT! Without this line, you've created a character, but the character
										 ;is not saved as "player"

End Function

Function Update3rdPersonCamera()         ;Call this function to update your 3rd person camera

	PointEntity camera,player            ;Point the camera at the character
	
	If KeyDown(75)                       ;If we push the number pad left key
		MoveEntity camera,-.5,0,.05      ;Effectively orbits the camera left around the character
	EndIf
	
	If KeyDown(77)                       ;If we push the number pad right key
		MoveEntity camera,.5,0,.05       ;Effectively orbits the camera right around the character
	EndIf
	
	If KeyDown(200)                      ;If we push the up arrow
		pivz = 50                        ;Set our global variable of pivz to 50
	EndIf
	
	If KeyDown(208)                      ;If we push the down arrow
		pivz = -50                       ;Set our global variable of pivz to -50
	EndIf
	
	If KeyDown(203)                      ;If we push the left arrow
		pivx = -50                       ;Set our global variable of pivx to -50
	EndIf
	
	If KeyDown(205)                      ;If we push the right arrow
		pivx = 50                        ;Set our global variable of pivx to 50
	EndIf
	
	If Not KeyDown(200)                  ;If the up arrow is release...
		If Not KeyDown(208)              ;and if the down arrow is released
			pivz = 0                     ;Reset the local "z" position of the 2nd pivot
		EndIf
	EndIf
	
	If Not KeyDown(203)                  ;If the left arrow is release...
		If Not KeyDown(205)              ;and if the right arrow is released
			pivx = 0                     ;Reset the local "x" position of the 2nd pivot
		EndIf
	EndIf
	
	RotateEntity piv1,0,EntityYaw(camera),0
	                                     ;Rotate the 1st pivot to match
	                                     ;the camera's current rotation
	
	PositionEntity piv1,EntityX(player),EntityY(player),EntityZ(player) 
	                                     ;Position the 1st pivot exactly
	                                     ;where your character is
	
	PositionEntity piv2,pivx,EntityY(player),pivz,False
	                                     ;Position the 2nd pivot in a 
	                                     ;relative spot to your character
	                                     ;with the vector of the variables
	                                     ;pivx and pivz added to the x and
	                                     ;z values. Note that the "False"
	                                     ;command is what makes this whole
	                                     ;function work correctly.
	
	If EntityDistance(piv2,player) &gt;= 10 ;Don't rotate the character unless
		                                 ;the distance between the
		                                 ;character and piv2 is greater than
		                                 ;or equal to 10. Otherwise the 
		                                 ;character spazzes out when no
		                                 ;button is pressed.
		
		pitch = EntityPitch(player)      ;Get the pitch rotation of the model
		
		roll = EntityRoll(player)        ;Get the roll rotation of the model
		
		PointEntity player,piv2          ;Point the character in the correct direction
		
		RotateEntity player,pitch,EntityYaw(player),roll
		                                 ;This line simply corrects any
		                                 ;unintended rotation other than
		                                 ;on the y-axis. x-axis and z-axis
		                                 ;can tilt the character is strange
		                                 ;ways.
		
		MoveEntity player,0,0,1          ;make the character walk or move in the
		                                 ;direction that he is facing
		
		pitch = EntityPitch(camera)      ;get the temporary rotation of the camera
		
		yaw = EntityYaw(camera)          ;get the temporary rotation of the camera
		
		roll = EntityRoll(camera)        ;get the temporary rotation of the camera
		
		RotateEntity camera,EntityPitch(player),EntityYaw(player),EntityRoll(player)
		                                 ;The above line rotates the camera to match
									     ;The rotation of the player
		
		MoveEntity camera,0,0,1
		                                 ;Move the camera at the same pace and direction
										 ;as the player moved
		
		RotateEntity camera,pitch,yaw,roll 
		                                 ;Return the camera back to it's original
		                                 ;rotation. This allows for cool camera
		                                 ;tricks such as pushing right while still
		                                 ;pointing at the player (a.k.a. sweeping)
		
		
	EndIf
	
	;Now let's do some camera distance checking and correct any problems
	
	If EntityDistance(player,camera) &gt; 100 ;If the camera is too far away...
		PointEntity camera,player          ;Point the camera at the player
		MoveEntity camera,0,0,5            ;Move the camera 5 units closer to the player
	EndIf

	If EntityDistance(player,camera) &lt; 10  ;If the camera is too close...
		PointEntity camera,player          ;Point the camera at the player
		MoveEntity camera,0,0,-5           ;Move the camera 5 units further from the player
	EndIf

End Function                               ;End the Function



Function CreateRandomTerrain()                               ;Call this function to generate trees.

	For x = 0 To 1000                                        ;Do this block 1000 times
		cone = CreateCone()                                  ;Create a cone
		EntityColor cone,0,125,0                             ;Color it mid tone green
		PositionEntity cone,Rand(-500,500),0,Rand(-500,500)  ;Position it on a random x and z location
	Next                                                     ;Tell blitz that this is the end of the block.

End Function                                                 ;End the Function

;------------------------------------------------------------------------------------------------------------
;End the Functions List
</pre> <br><br></td></tr></table><br>
<a name="1025122"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cubed Inc.</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob the Great<br>The code is very nice and it achieved the movements correctly, but the character doesn't "turn" towards the directions, instead it just points.<br>I should have said this in the first place, but i'm also trying to make the character rotate or turn in the correct direction as well with everything else. Your code is almost perfect for my problem, it's just that it doesn't "turn". Regardless, it's still a great code. Thanks for trying to help:) <br><br></td></tr></table><br>
<a name="1025130"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you wanted to spend the time, try setting up a system where you can rotate the character over time based on the new point where the character should be pointed. I'm not sure how to go about that, but somebody else may have some tips or pointers. Also, I originally designed this program to work with a joystick, so there is less of a snap between one point and another due to the fact that the joystick has a wider range of directions than just the four basic directions. Anyways, good luck with everything!<br><br>-Rob Merrick <br><br></td></tr></table><br>
<a name="1025131"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rob the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> One last note, there is a function in blitz called "AlignToVector", which may be useful. It's supposed to gradually turn an entity to a new rotation, but I haven't played around with it enough to know much about it. <br><br></td></tr></table><br>
<a name="1176364"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> I know this is an old topic, but is there a way to control the speed movement of the player? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
