<!DOCTYPE html><html lang="en" ><head ><title >Draw boxes and lines, move them, and zoom</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Draw boxes and lines, move them, and zoom</h1><a href="forums.php" >Blitz3D Forums</a>/<a href="topics.php?forum=5" >Blitz3D Beginners Area</a>/<a href="#bottom" >Draw boxes and lines, move them, and zoom</a><br><br>
<a name="1302366"></a>

<a name="1303116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Still struggling with what seems should be simple.  Can anyone point me in the right direction with this?<br><br>I am importing a 2D CAD file (DXF) format.  I need to draw some "tooling" rectangles on the screen.  I need to move the tooling and change the size of the tooling.  I need to be able to move the "part" around on the screen and be able to zoom in on the part and tooling to get a better look.  I am struggling with the methods to do this.  I will show you my code below and would appreciate some help with this.  If you have an idea, you can use rectangles to show me how it is done.  This is a simulation tool that will allow me to setup a pressbrake (a machine used to bend steel into 3D shapes).<br><br>Thanks for any help.<br>Here is my code...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;I am trying to import a 2D DXF cad file, draw some tooling shapes onto the screen, then move the "part" around on
;the screen to match up with the tooling.  I need to be able to position tooling where needed and the part where
;needed.  I need to be able to zoom in on any particular area to get a closer look when moving things around.
;If you have an idea, you could just use rectangles to show me how it is done.

Graphics 800,600,16 

Global MyOriginX# = 10
Global MyOriginY# = 590
Global MyScale# = 1
Global CenterX# = 400
Global CenterY# = 300

Type MyLines
	Field GraphicType$;LINE, CIRCLE, OR ARC
	Field SX#		  ;LINE START POINT X
	Field SY#		  ;LINE START POINT Y
	Field EX#		  ;LINE END POINT X
	Field EY#		  ;LINE END POINT Y
	Field SA#         ;ARC START ANGLE
	Field EA#         ;ARC END ANGLE
	Field R#          ;ARC RADIUS
	Field LColor$	  ;LINE COLOR
	Field LName$	  ;LINE NAME
	Field Dir$        ;BEND DIRECTION
	Field Angle#      ;BEND ANGLE
	Field BendLength# ;BEND LENGTH
	Field Punch$      ;PUNCH
	Field Die$        ;Die
	Field ZL#         ;ZLeft
	Field ZR#         ;ZRight
	Field XL#         ;XLeft
	Field XR#         ;XRight
End Type


fntArial=LoadFont("Calibri",15,False,False,False)
SetFont fntArial 


;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")


; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	Cls
	
	If KeyDown(203)
		MovePartX(-2)
	End If
	If KeyDown(205)
		MovePartX(2)
	End If		
	If KeyDown(200)
		MoveParty(2)
	End If
	If KeyDown(208)
		MoveParty(-2)
	End If		
	If KeyHit(23)	;zoom in
		;This zoom idea is not working like I want
		MyScale = MyScale + 1
	End If		
	If KeyHit(24)	;zoom out
		;This zoom idea is not working like I want
		MyScale = MyScale - 1
	End If		

	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw an example tool to experiment with
	DrawRam()

	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				;If gl\DIR$ &lt;&gt; "N/A" Then
				;	Color 255, 0, 0
				;Else
				;	Color 0, 255, 0
				;End If
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				DrawCircle(gl\SX#, gl\SY#, gl\R#)

			Case "ARC"
				DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)

			Default
			
		End Select
	Next
	;Let's draw the part now above...

	Flip
	
Wend 



Function ImportDXFFile(FileName$)

	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			
		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				
		End If

	Wend
	CloseFile(File)
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX + SX# * MyScale, MyOriginY - SY# * MyScale, MyOriginX + EX# * MyScale, MyOriginY - EY# * MyScale
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	
	Color 0,255,0	
	Oval(MyOriginX + SX# * MyScale, MyOriginY - SY# * MyScale, R# * MyScale, R# * MyScale, 0)
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)

	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + .5
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend			
		End If
	End If
	
	;Text MyOriginX + CPX# + Cos(SA#) * R#, MyOriginY - CPY# - Sin(SA#) * R#, SA# + " " + EA#
End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 255, 0, 0
	;Line 0, 300, 800,300
	Rect CenterX# + 30 * MyScale - (12 * MyScale), CenterY# - 10*MyScale - (1 * MyScale), 12 * MyScale, 2 * MyScale, False
	
End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount
				gl\EX# = gl\EX# + Amount
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount
				gl\EX# = gl\EX# + Amount

			Case "ARC"
				gl\SX = gl\SX# + Amount
				gl\EX# = gl\EX# + Amount
			Default
			
		End Select
	Next
End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY = gl\SY# + Amount
				gl\EY# = gl\EY# + Amount
				
			Case "CIRCLE"
				gl\SY = gl\SY# + Amount
				gl\EY# = gl\EY# + Amount

			Case "ARC"
				gl\SY = gl\SY# + Amount
				gl\EY# = gl\EX# + Amount
			Default
			
		End Select
	Next
End Function

Function RotatePart(Amount#)
	;This code has not been started.  I need to rotate each geometry type by the angle amount passed into the function
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"

				
			Case "CIRCLE"


			Case "ARC"

			
		End Select
	Next
End Function

Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the Y-Axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"

				
			Case "CIRCLE"


			Case "ARC"

			
		End Select
	Next
End Function
</textarea><br><br>Below is the contents of the c:\Temp\junkoriginal5.txt file<br>Just paste this into a text file named c:\Temp\junkoriginal5.txt <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
LINE,0.000,0.125,0.000,11.750
LINE,0.250,12.000,11.500,12.000
LINE,12.000,11.500,12.000,1.000
LINE,11.000,0.000,0.125,0.000
LINE,6.282,6.220,6.817,6.754
LINE,7.414,6.507,7.414,5.938
LINE,6.213,5.600,6.768,4.719
LINE,7.414,5.938,7.414,4.906
LINE,1.637,3.213,3.137,3.213
LINE,4.637,2.213,4.637,1.213
LINE,4.637,1.213,3.137,1.213
LINE,1.637,3.213,1.637,2.213
LINE,3.137,3.213,4.637,2.213
LINE,3.137,1.213,1.637,2.213
LINE,6.970,9.801,8.385,8.386
LINE,9.092,9.093,7.677,10.508
ARC,0.125,0.125,0.125,180.000,270.000
ARC,0.250,11.750,0.250,90.000,180.000
ARC,11.500,11.500,0.500,0.000,90.000
ARC,11.000,1.000,1.000,270.000,0.000
ARC,7.064,6.507,0.350,0.000,135.000
ARC,6.636,5.866,0.500,135.000,212.227
ARC,7.064,4.906,0.350,212.227,0.000
ARC,8.738,8.740,0.500,225.000,45.000
ARC,7.324,10.154,0.500,45.000,225.000
CIRCLE,3.000,8.938,2.500
</textarea> <br><br></td></tr></table><br>
<a name="1302756"></a>

<a name="1303117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got the moving and zooming figured out.<br><br>*** Still need help with the rotating and flipping functions at the bottom.<br><br>If you need the CAD data, you can paste the DXF CAD data from the section above to a text file on:  c:\temp\junkoriginal.txt<br><br>Here is my code so far:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 800,600,16 

Global MyOriginX# = 10
Global MyOriginY# = 590
Global MyScale# = 1


Type MyLines
	Field GraphicType$  ;LINE, CIRCLE, OR ARC
	Field SX#           ;LINE START POINT X
	Field SY#           ;LINE START POINT Y
	Field EX#           ;LINE END POINT X
	Field EY#           ;LINE END POINT Y
	Field SA#           ;ARC START ANGLE
	Field EA#           ;ARC END ANGLE
	Field R#            ;ARC RADIUS
	Field LColor$       ;LINE COLOR
	Field LName$        ;LINE NAME
	Field Dir$          ;BEND DIRECTION
	Field Angle#        ;BEND ANGLE
	Field BendLength#   ;BEND LENGTH
	Field Punch$        ;PUNCH
	Field Die$          ;Die
	Field ZL#           ;ZLeft
	Field ZR#           ;ZRight
	Field XL#           ;XLeft
	Field XR#           ;XRight
End Type


fntArial=LoadFont("Calibri",15,False,False,False)
SetFont fntArial 


;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")


; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	Cls
	
	;Move "CAMERA" type functionality below...
	If KeyDown(37) Then ;(K Key)
		MyOriginX = MyOriginX - 4
	End If
	If KeyDown(38) Then ;(L Key)
		MyOriginX = MyOriginX + 4
	End If
	If KeyDown(22) Then ;(U Key)
		MyOriginY# = MyOriginY# - 4
	End If
	If KeyDown(32) Then ;(D Key)
		MyOriginY# = MyOriginY# + 4
	End If
	;Move "CAMERA" type functionality above...
	

	;Flip part below...
	If KeyHit(33) Then
		FlipPart()
	End If
	;Flip part abouve...

	;Rotate Part...
	If KeyHit(19) ;(R key)
		RotatePart(45)
	End If
	
	;Move Part around on the screen below...
	If KeyDown(203) ;(Left key)
		MovePartX(-.125)
	End If
	If KeyDown(205) ;(Right Key)
		MovePartX(.125)
	End If		
	If KeyDown(200) ;(Up Key)
		MoveParty(.125)
	End If
	If KeyDown(208) ;(Down Key)
		MoveParty(-.125)
	End If		
	;Move Part around on the screen above...


	;Zoom functionality below...
	If KeyDown(23)	;zoom in (I key)
		MyScale = MyScale + 1
	End If		
	If KeyDown(24)	;zoom out (O Key)
		MyScale = MyScale - 1
	End If		
	;Zoom functionality above...


	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw an example tool to experiment with
	DrawRam()

	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				DrawCircle(gl\SX#, gl\SY#, gl\R#)

			Case "ARC"
				DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)

			Default
			
		End Select
	Next
	;Let's draw the part now above...

	Flip
	
Wend 



Function ImportDXFFile(FileName$)

	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			
		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				
		End If

	Wend
	CloseFile(File)
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, MyOriginX# + EX# * MyScale#, MyOriginY# - EY# * MyScale#
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	R# = R# * MyScale
	Color 0,255,0	
	Oval(MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, R#, R#, 0)
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	;No ARC command so trying to create an arc by drawing pixels from a center point at a given radius, start angle, and end agle
	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + .5
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend			
		End If
	End If
	
	;Text MyOriginX + CPX# + Cos(SA#) * R#, MyOriginY - CPY# - Sin(SA#) * R#, SA# + " " + EA#
End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 255, 0, 0
	;Line 0, 300, 800,300
	Rect MyOriginX# + 30 * MyScale# - (12 * MyScale#), MyOriginY# - 10 * MyScale# - (1 * MyScale#), 12 * MyScale#, 2 * MyScale#, False
	
End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#

			Case "ARC"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
				
			Case "CIRCLE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#

			Case "ARC"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function RotatePart(Amount#)
	;This code has not been started.  I need to rotate each geometry type by the angle amount passed into the function
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				;*** Need help with this code
								
			Case "CIRCLE"
				;*** Need help with this code.  It is not rotating correctly.
				;gl\SX# = gl\SX# * Cos(Amount#) - gl\SY# * Sin(Amount#)
				;gl\SY# = gl\SY# * Cos(Amount#) + gl\SX# * Sin(Amount#)
				;*** Need help with this code
						
			Case "ARC"
				;*** Need help with this code
			
		End Select
	Next
End Function

Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the Y-Axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
				
			Case "CIRCLE"
				;*** Need some help with this code.  It is not flipping across vertical axis correctly.
				gl\SX# = gl\SX# * -1

			Case "ARC"
				;Need help with this code.  It is not flipping across the vertical axis correctly
				gl\SX# = gl\SX# * -1
				gl\EA# = gl\SA# + 180
				gl\SA# = gl\EA#
			
		End Select
	Next
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1302823"></a>

<a name="1302824"></a>

<a name="1302826"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Give it a try (I changed the filename so watch out):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics 800,600,0,2

Global MyOriginX# = 10
Global MyOriginY# = 590
Global MyScale# = 10

Global fpsTimer = CreateTimer( 30 )


Type MyLines
	Field GraphicType$  ;LINE, CIRCLE, OR ARC
	Field SX#           ;LINE START POINT X
	Field SY#           ;LINE START POINT Y
	Field EX#           ;LINE END POINT X
	Field EY#           ;LINE END POINT Y
	Field SA#           ;ARC START ANGLE
	Field EA#           ;ARC END ANGLE
	Field R#            ;ARC RADIUS
	Field LColor$       ;LINE COLOR
	Field LName$        ;LINE NAME
	Field Dir$          ;BEND DIRECTION
	Field Angle#        ;BEND ANGLE
	Field BendLength#   ;BEND LENGTH
	Field Punch$        ;PUNCH
	Field Die$          ;Die
	Field ZL#           ;ZLeft
	Field ZR#           ;ZRight
	Field XL#           ;XLeft
	Field XR#           ;XRight
End Type


fntArial=LoadFont("Calibri",15,False,False,False)
SetFont fntArial 


;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
ImportDXFFile ("junkoriginal.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")


SetBuffer BackBuffer() ;Set once, this state remains throughout the rest of the program.


; Wait for ESC to hit 
While Not KeyHit(1)
	WaitTimer( fpsTimer )
	Cls
	
	;Move "CAMERA" type functionality below...
	If KeyDown(37) Then ;(K Key)
		MyOriginX = MyOriginX - 4
	End If
	If KeyDown(38) Then ;(L Key)
		MyOriginX = MyOriginX + 4
	End If
	If KeyDown(22) Then ;(U Key)
		MyOriginY# = MyOriginY# - 4
	End If
	If KeyDown(32) Then ;(D Key)
		MyOriginY# = MyOriginY# + 4
	End If
	;Move "CAMERA" type functionality above...
	

	;Flip part below...
	If KeyHit(33) Then
		FlipPart()
	End If
	;Flip part abouve...

	;Rotate Part...
	If KeyHit(19) ;(R key)
		RotatePart(45)
	End If
	
	;Move Part around on the screen below...
	If KeyDown(203) ;(Left key)
		MovePartX(-.125)
	End If
	If KeyDown(205) ;(Right Key)
		MovePartX(.125)
	End If		
	If KeyDown(200) ;(Up Key)
		MoveParty(.125)
	End If
	If KeyDown(208) ;(Down Key)
		MoveParty(-.125)
	End If		
	;Move Part around on the screen above...


	;Zoom functionality below...
	If KeyDown(23)	;zoom in (I key)
		MyScale = MyScale + 1
	End If		
	If KeyDown(24)	;zoom out (O Key)
		MyScale = MyScale - 1
	End If		
	;Zoom functionality above...


	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw an example tool to experiment with
	DrawRam()

	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				DrawCircle(gl\SX#, gl\SY#, gl\R#)

			Case "ARC"
				DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)

			Default
			
		End Select
	Next
	;Let's draw the part now above...

	Flip
	
Wend 



Function ImportDXFFile(FileName$)

	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			
		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				
		End If

	Wend
	CloseFile(File)
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, MyOriginX# + EX# * MyScale#, MyOriginY# - EY# * MyScale#
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	R# = R# * MyScale
	Color 0,255,0	
	Oval(MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, R#, R#, 0)
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	;No ARC command so trying to create an arc by drawing pixels from a center point at a given radius, start angle, and end agle
	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + .5
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend			
		End If
	End If
	
	;Text MyOriginX + CPX# + Cos(SA#) * R#, MyOriginY - CPY# - Sin(SA#) * R#, SA# + " " + EA#
End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 255, 0, 0
	;Line 0, 300, 800,300
	Rect MyOriginX# + 30 * MyScale# - (12 * MyScale#), MyOriginY# - 10 * MyScale# - (1 * MyScale#), 12 * MyScale#, 2 * MyScale#, False
	
End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#

			Case "ARC"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
				
			Case "CIRCLE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#

			Case "ARC"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function RotatePart(Amount#)
	;This code has not been started.  I need to rotate each geometry type by the angle amount passed into the function
	
	;Read up on "affine transformations".
	
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				;*** Need help with this code
				
				;The line segment should rotate around some point. What point it is?
				
				;This point could be the start point of the segment, or the middle of the segment (equally between the start and end).
				;Rotating by the centre, which is more complicated.
				
				;Find the current centre of the segment.
				Local lineCentreX# = ( gl\SX + gl\EX ) / 2.0
				Local lineCentreY# = ( gl\SY + gl\EY ) / 2.0
				
				;Move a "copy" of the segment so that its centre is located at the origin (point [0,0] ).
				Local localSX# = gl\SX - lineCentreX
				Local localSY# = gl\SY - lineCentreY
				
				Local localEX# = gl\EX - lineCentreX
				Local localEY# = gl\EY - lineCentreY
				
				;Rotate this copy by the amount.
				Local lineCos# = Cos( Amount )
				Local lineSin# = Sin( Amount )
				
				Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
				Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
				
				Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
				Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
				
				;Change the original segment to have the points of the rotated copy.
				
				gl\SX = newSX + lineCentreX
				gl\SY = newSY + lineCentreY
				
				gl\EX = newEX + lineCentreX
				gl\EY = newEY + lineCentreY
								
			Case "CIRCLE"
			
				;How are you supposed to rotate a circle? The circle is the same in any direction.
				;For the circle to be different it would need to be an ellipse (two radii, X and Y).
				;But it should be difficult to draw by plotting, maybe you should use 3D.
			
			Case "ARC"
				
				;Add the angle value to the start and end angle values.
				
				gl\SA = gl\SA + Amount
				gl\EA = gl\EA + Amount
			
		End Select
	Next
End Function

Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the Y-Axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
				
			Case "CIRCLE"
				;*** Need some help with this code.  It is not flipping across vertical axis correctly.
				gl\SX# = gl\SX# * -1

			Case "ARC"
				;Need help with this code.  It is not flipping across the vertical axis correctly
				gl\SX# = gl\SX# * -1
				gl\EA# = gl\SA# + 180
				gl\SA# = gl\EA#
			
		End Select
	Next
End Function</textarea><br><br>If you know C++ then I recommend that you try using the Qt library, it's got a lot of functionality for making visual applications like designers etc. It has graphics primitives (arcs, circles, lines etc.) and does transformations for you, like rotating, moving and scaling things with simple functions.<br><br>It's LGPL licensed, which allows you to make proprietary (closed-source) applications and sell them, you just need to distribute the Qt DLLs with your program.<br><br><a href="http://doc.qt.io/qt-5/examples-graphicsview.html" target="_blank">http://doc.qt.io/qt-5/examples-graphicsview.html</a> <br><br></td></tr></table><br>
<a name="1302833"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon,<br>Thanks for the code and I appreciate the time you have taken to try to help me.  It does not seem to work exactly as I need.  I don't know why I cannot wrap my brain around this problem.  I have made some progress and have attached the latest version of the code below.  When the user presses the R key, I want the entire "part" picture to rotate by the amount the user requests (Ex:  10 Deg CCW.)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 1200,900,16 

Global MyOriginX# = -600
Global MyOriginY# = 600
Global MyScale# = 30
Global MachineCenterLineX# = 60
Global MachineCenterLineY# = 300
Global ToolHeight# = 2 ;( 2 inch tool height for drawing tool images onto the screen)

AppTitle "K=Cam Left,"+"L=Cam Rt," + "U=Cam UP," + "D=Cam Dn,"+"R=Rot," + "F=Flip," + "I=ZoomIn,"+  "O-ZoomOut," + "T=Add Tool," + "Arrows Move Prt"


Type MyLines
	Field GraphicType$  ;LINE, CIRCLE, OR ARC
	Field SX#           ;LINE START POINT X
	Field SY#           ;LINE START POINT Y
	Field EX#           ;LINE END POINT X
	Field EY#           ;LINE END POINT Y
	Field SA#           ;ARC START ANGLE
	Field EA#           ;ARC END ANGLE
	Field R#            ;ARC RADIUS
	Field LColor$       ;LINE COLOR
	Field LName$        ;LINE NAME
	Field Dir$          ;BEND DIRECTION
	Field Angle#        ;BEND ANGLE
	Field BendLength#   ;BEND LENGTH
	Field Punch$        ;PUNCH
	Field Die$          ;Die
	Field ZL#           ;ZLeft
	Field ZR#           ;ZRight
	Field XL#           ;XLeft
	Field XR#           ;XRight
End Type

Type MyTools
	Field ToolName$     ;Tool Name
	Field ToolLength#   ;Tool Length
	Field ToolLocation# ;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed $    ;Tool reversed (YES Or NO)
	
End Type

;Let's add a tool for testing...
tl.MyTools = New MyTools
tl\ToolName$ = "MT030017000P"
tl\ToolLength# = 12.000
tl\ToolLocation# = 0.000
tl\Reversed = "NO"



fntArial=LoadFont("Calibri",15,False,False,False)
SetFont fntArial 


;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")
;ImportDXFFile ("C:\Temp\junkoriginal7.txt")


MovePartX(30)


; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls
	
	;Move "CAMERA" type functionality below...
	If KeyDown(37) Then ;(K Key)
		MyOriginX = MyOriginX - 10
	End If
	If KeyDown(38) Then ;(L Key)
		MyOriginX = MyOriginX + 10
	End If
	If KeyDown(22) Then ;(U Key)
		MyOriginY# = MyOriginY# - 10
	End If
	If KeyDown(32) Then ;(D Key)
		MyOriginY# = MyOriginY# + 10
	End If
	;Move "CAMERA" type functionality above...
	

	;Flip part below...
	If KeyHit(33) Then
		FlipPart()
	End If
	;Flip part abouve...

	;Rotate Part...
	If KeyHit(19) ;(R key)
		RotatePart(5)
	End If
	
	;Move Part around on the screen below...
	If KeyDown(203) ;(Left key)
		MovePartX(-.125)
	End If
	If KeyDown(205) ;(Right Key)
		MovePartX(.125)
	End If		
	If KeyDown(200) ;(Up Key)
		MoveParty(.125)
	End If
	If KeyDown(208) ;(Down Key)
		MoveParty(-.125)
	End If		
	;Move Part around on the screen above...


	;Zoom functionality below...
	If KeyDown(23)	;zoom in (I key)
		MyScale = MyScale + 1
	End If		
	If KeyDown(24)	;zoom out (O Key)
		MyScale = MyScale - 1
	End If		
	;Zoom functionality above...


	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...


	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw the Ram now...
	DrawRam()


	;Let's draw the tooling now below...
	DrawTooling()
	;Let's draw the tooling now above...


	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				;DrawCircle(gl\SX#, gl\SY#, gl\R#)
				DrawArc(gl\SX#, gl\SY#, 0, 359.5, gl\R#)
				
			Case "ARC"
				DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)

			Default
			
		End Select
	Next
	;Let's draw the part now above...

	Flip
	
Wend 



Function ImportDXFFile(FileName$)

	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			
		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				
		End If

	Wend
	CloseFile(File)
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, MyOriginX# + EX# * MyScale#, MyOriginY# - EY# * MyScale#
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	;R# = R# * MyScale
	;Oval(MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, R#, R#, 0)
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	;No ARC command so trying to create an arc by drawing pixels from a center point at a given radius, start angle, and end agle
	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + .5
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend			
		End If
	End If
	
	;Text MyOriginX + CPX# + Cos(SA#) * R#, MyOriginY - CPY# - Sin(SA#) * R#, SA# + " " + EA#
End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 75, 75, 75

	;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
	Line MyOriginX# + 0, MachineCenterLineY#, MyOriginX# + 60 * MyScale, MachineCenterLineY#
	For I = 1 To 60
		Line MyOriginX# + (60 - I) * MyScale, MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MachineCenterLineY# - .25 * MyScale#
		Text MyOriginX# + (60 - I) * MyScale - 8, MachineCenterLineY# + 1 * MyScale#, "-" + I
	Next

	;Draw centerline marker on the bed...
	Line MyOriginX# + 60 * MyScale, MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MachineCenterLineY# - 3 * MyScale#	


	;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
	Line MyOriginX# + 60 * MyScale, MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MachineCenterLineY#
	For I = 1 To 60
		Line MyOriginX# + (60 + I) * MyScale, MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MachineCenterLineY# - .25 * MyScale#
		Text MyOriginX# + (60 + I) * MyScale - 8, MachineCenterLineY# + 1 * MyScale#, "+" + I
	Next
End Function

Function DrawTooling()
	Color 0, 0, 255
	For tl.MyTools = Each MyTools
		Rect((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MachineCenterLineY# - ToolHeight# * MyScale# / 2, tl\ToolLength * MyScale#, ToolHeight# * MyScale#, False)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MachineCenterLineY# - ToolHeight# * MyScale# / 2, Mid(tl\ToolName$,4,5)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MachineCenterLineY# - (ToolHeight# - 1) * MyScale# / 2, tl\ToolLength#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MachineCenterLineY# - (ToolHeight# - 2) * MyScale# / 2, tl\ToolLocation# + " " + tl\Reversed$
	Next

End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#

			Case "ARC"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
				
			Case "CIRCLE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#

			Case "ARC"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
			Default
			
		End Select
	Next
End Function

Function RotatePart(Amount#)
	;This code has not been started.  I need to rotate each geometry type by the angle amount passed into the function
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				;*** Need help with this code
				
				;When the user wants to rotate the part, the entire part needs to rotate to the angle passed into the function.  If the user wants to rotate
				; 10 degrees CCW, then the entire part picture needs to rotate 10 deg CCW.
				
				
				;The code below was provided by Kryzon and is not working as desired.  Press the R key and things get messy.
				
				
				;This point could be the start point of the segment, or the middle of the segment (equally between the start and end).
				;Rotating by the centre, which is more complicated.
				
				;Find the current centre of the segment.
				Local lineCentreX# = ( gl\SX + gl\EX ) / 2.0
				Local lineCentreY# = ( gl\SY + gl\EY ) / 2.0
				
				;Move a "copy" of the segment so that its centre is located at the origin (point [0,0] ).
				Local localSX# = gl\SX - lineCentreX
				Local localSY# = gl\SY - lineCentreY
				
				Local localEX# = gl\EX - lineCentreX
				Local localEY# = gl\EY - lineCentreY
				
				;Rotate this copy by the amount.
				Local lineCos# = Cos( Amount )
				Local lineSin# = Sin( Amount )
				
				Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
				Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
				
				Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
				Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
				
				;Change the original segment to have the points of the rotated copy.
				
				gl\SX = newSX + lineCentreX
				gl\SY = newSY + lineCentreY
				
				gl\EX = newEX + lineCentreX
				gl\EY = newEY + lineCentreY				
								
			Case "CIRCLE"
				;*** Need help with this code.  It is not rotating correctly.
				;gl\SX# = gl\SX# * Cos(Amount#) - gl\SY# * Sin(Amount#)
				;gl\SY# = gl\SY# * Cos(Amount#) + gl\SX# * Sin(Amount#)
				;*** Need help with this code
						
			Case "ARC"
				;*** Need help with this code
			
		End Select
	Next
End Function

Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the vertical axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
				
			Case "CIRCLE"
				gl\SX# = gl\SX# * -1

			Case "ARC"
				;Need help with this code.  It is not flipping across the vertical axis correctly
				gl\SX# = gl\SX# * -1
				
				If gl\SA# &lt; gl\EA# Then


				Else
				
				End If
				
				gl\EA# = gl\SA# + 180
				gl\SA# = gl\EA#
			
		End Select
	Next
End Function


Function AddTooling()
	tl.MyTools = New MyTools
	tl\ToolName$ = Input("What is the Tool Name? ")
	tl\ToolLength =Input("What is the tool length? ")
	tl\ToolLocation = Input("What is the tool location? ")
	tl\Reversed = Input("Is the tool reversed? YES or NO: ")
End Function












</textarea> <br><br></td></tr></table><br>
<a name="1302852"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> When you rotate something, you rotate it around a point. Without specifying that point you can't do it.<br>That example I posted chose to rotate each line around their centre, so each line had a different rotation point.<br><br>If you want to rotate the entire arrangement of parts in your scene then you need to specify the point that they will rotate around before anything else.<br><br>In design programs this is usually the centre of the bounding rectangle of the selection -- that is, you have a bunch of selected objects and you rotate them all around the centre of the rectangle that encloses all objects.<br>This is not the same as the average centre (sum all positions and divide by the number of objects) because this would make the centre closer to clusters than separate objects far away. <br><br></td></tr></table><br>
<a name="1302886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK.  I'll have another look at it after work tonight.  I am thinking I want to rotate about the origin 0,0.  I think I need to move the part to 0,0, rotate all of the geometry and then move it back to the original location.  I'll try to work with this tonight.  Thanks again for helping me with this.  I am excited about the progress I have made so far and can't wait until it is finished.  It will allow me to program for a machine offline without the operators from having to do it while the machine is not running. <br><br></td></tr></table><br>
<a name="1302911"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you move each part to 0,0 then they all will be rotated separately. If you want to rotate them all by the same point you need to subtract the location of that point from each part, rotate each part, then add back the location of the point.<br><br>You subtract the same point from all different parts no matter where they are, and this is what makes them all rotate around the same point.<br>When you subtract the location of that point from the location of the part it's as if you're viewing that point as the "origin", and all parts rotate around it. <br><br></td></tr></table><br>
<a name="1302914"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon...I am very close with your help.  I am still having an issue with the arcs drawing correctly.  If you press the R button a bunch of times, you will see the problem.  Do you know what I have done wrong?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 1200,900,16 

AppTitle "K=Cam Left,"+"L=Cam Rt," + "U=Cam UP," + "D=Cam Dn,"+"R=Rot," + "F=Flip," + "I=ZoomIn,"+  "O-ZoomOut," + "T=Add Tool," + "Arrows Move Prt," + "E=Edit," + "M=Select Item 2 Mov," + "A=Ram Details,"

Global MyOriginX# = -900;-600
Global MyOriginY# = 400;600
Global MyScale# = 25
Global MachineCenterLineX# = 60
Global MachineCenterLineY# = 0;300
Global ToolHeight# = 2 ;( 2 inch tool height for drawing tool images onto the screen)
Global EditMode = 0
Global SelectedX# =0.0
Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
;Global ShowRamDetail = 1
Global RamDetailsToShow$ = "RAM-All"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5


Type MyLines
	Field GraphicType$  ;LINE, CIRCLE, OR ARC
	Field SX#           ;LINE START POINT X
	Field SY#           ;LINE START POINT Y
	Field EX#           ;LINE END POINT X
	Field EY#           ;LINE END POINT Y
	Field SA#           ;ARC START ANGLE
	Field EA#           ;ARC END ANGLE
	Field R#            ;ARC RADIUS
	Field IsBendLine$   ;IS A BEND LINE YES or NO
	Field LColor$       ;LINE COLOR
	Field LName$        ;LINE NAME
	Field Dir$          ;BEND DIRECTION
	Field Angle#        ;BEND ANGLE
	Field BendLength#   ;BEND LENGTH
	Field Punch$        ;PUNCH
	Field Die$          ;Die
	Field ZL#           ;ZLeft
	Field ZR#           ;ZRight
	Field XL#           ;XLeft
	Field XR#           ;XRight
End Type

Type MyTools
	Field ToolNumber$   ;Tool Number
	Field ToolName$     ;Tool Name
	Field ToolLength#   ;Tool Length
	Field ToolLocation# ;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     ;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#
	Field SY#
	Field EX#
	Field EY#
End Type

Type MyRightGage
	Field SX#
	Field SY#
	Field EX#
	Field EY#
End Type

;Let's add a couple tools for testing...
tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "1"
tl\ToolName$ = "MT030017000P"
tl\ToolLength# = 12.000
tl\ToolLocation# = -0.75
tl\Reversed = "NO"

tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "2"
tl\ToolName$ = "MT030095000P"
tl\ToolLength# = 4.000
tl\ToolLocation# = -18.000
tl\Reversed = "NO"

tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "3"
tl\ToolName$ = "MT030125000P"
tl\ToolLength# = 8.000
tl\ToolLocation# = 12.000
tl\Reversed = "NO"

ImportLeftGage()
ImportRightGage()


fntArial=LoadFont("Calibri",15,False,False,False)
SetFont fntArial 


;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")
;ImportDXFFile ("C:\Temp\junkoriginal7.txt")
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")


;Let's move the gages into view...
ItemToMove$ = "RIGHTGAGE"
MoveGageX(58)

ItemToMove$ = "LEFTGAGE"
MoveGageX(47)

ItemToMove$ = "BOTHGAGES"
MoveGageY(2)

ItemToMove$ = "PART"
MovePartX(47.25)
MovePartY(-10)

; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	;let's put a ItemToMove selector on the screen...
	Rect 1, 1, 100, 20, False
	Text 3, 2, ItemToMove$
	
	;let's put a Ram Details selector on the screen...
	;Rect 1, 25, 100, 20, False
	;Text 3, 26, RamDetailsToShow$
	
	;Move "CAMERA" type functionality below...
	If KeyDown(37) Then ;(K Key)
		Select ItemToMove$
			Case "PART"
				MyOriginX = MyOriginX - 10
		End Select
	End If
	
	If KeyDown(38) Then ;(L Key)
		Select ItemToMove$
			Case "PART"
				MyOriginX = MyOriginX + 10
		End Select
	End If
	
	If KeyDown(22) Then ;(U Key)
		MyOriginY# = MyOriginY# - 10
	End If
	
	If KeyDown(32) Then ;(D Key)
		MyOriginY# = MyOriginY# + 10
	End If
	;Move "CAMERA" type functionality above...
	

	;Flip part below...
	If KeyHit(33) Then
		FlipPart()
	End If
	;Flip part abouve...

	;Rotate Part...
	If KeyHit(19) ;(R key)
		RotatePart(RotationAmount#)
	End If
	
	;Move Part around on the screen below...
	If KeyDown(203) ;(Left key)
		Select ItemToMove$
			Case "PART"
				MovePartX(-.125)
			Case "BOTHGAGES"
				MoveGageX(-.125)
			Case "LEFTGAGE"
				MoveGageX(-.125)
			Case "RIGHTGAGE"
				MoveGageX(-.125)
			Case "TOOLS"
			
		End Select
	End If
	If KeyDown(205) ;(Right Key)
		Select ItemToMove$
			Case "PART"
				MovePartX(.125)
			Case "BOTHGAGES"
				MoveGageX(.125)
			Case "LEFTGAGE"
				MoveGageX(.125)
			Case "RIGHTGAGE"
				MoveGageX(.125)
			Case "TOOLS"
			
		End Select
	End If		
	If KeyDown(200) ;(Up Key)
		Select ItemToMove$
			Case "PART"
				MoveParty(.125)
			Case "BOTHGAGES"
				MoveGageY(.125)
			Case "LEFTGAGE"
				MoveGageY(.125)
			Case "RIGHTGAGE"
				MoveGageY(.125)
			Case "TOOLS"
			
		End Select
	End If
	If KeyDown(208) ;(Down Key)
		Select ItemToMove$
			Case "PART"
				MovePartY(-.125)
			Case "BOTHGAGES"
				MoveGageY(-.125)
			Case "LEFTGAGE"
				MoveGageY(-.125)
			Case "RIGHTGAGE"
				MoveGageY(-.125)
			Case "TOOLS"
			
		End Select
	End If		
	;Move Part around on the screen above...


	;Zoom functionality below...
	If KeyDown(23)	;zoom in (I key)
		MyScale = MyScale + 1
	End If		
	If KeyDown(24)	;zoom out (O Key)
		MyScale = MyScale - 1
	End If		
	;Zoom functionality above...


	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	
	;Edit bend lines
	If KeyHit(18) Then	;(E Key)
		EditMode = 1
	End If 
	
	If MouseDown(2) Then	;(right mouse button)
		;let's get the edit line data from the user and update the part
		
		EditMode = 0
	End If
	
	If KeyHit(50) Then
		Select ItemToMove$
			Case "PART"
				ItemToMove$ = "BOTHGAGES"
			Case "BOTHGAGES"
				ItemToMove$ = "LEFTGAGE"
			Case "LEFTGAGE"
				ItemToMove$ = "RIGHTGAGE"
			Case "RIGHTGAGE"
				ItemToMove$ = "TOOLS"
			Default
				ItemToMove$ = "PART"
				
		End Select
	End If
	
	If KeyHit(30) Then	;(A key)
		Select RamDetailsToShow$
			Case "RAM-All"
				RamDetailsToShow$ = "RAM-Medium"
			Case "RAM-Medium"
				RamDetailsToShow$= "RAM-Low"
			Default
				RamDetailsToShow$ = "RAM-All"
		End Select
	End If

	If KeyHit(16) Then	;(Q key)
		Select RotationAmount#
			Case 45
				RotationAmount# = 90
			Case 90
				RotationAmount# = 5
			Case 5
				RotationAmount# = 1
			Default
				RotationAmount# = 45
		End Select
	End If
	
	
	If EditMode = 1 Then
		If MouseHit(1) Then
			SelectedX# = MouseX()
			SelectedY# = MouseY()
		
			;Let's get the data from the picked line and put it into a file and show it to the user
			fileout = WriteFile("C:\Temp\EditLine.txt")
			WriteLine(fileout,"THIS IS THE DATA FROM THE LINE YOU PICKED")
			WriteLine(fileout,"GRAPHIC TYPE         :")
			WriteLine(fileout,"START X              :")
			WriteLine(fileout,"END X                :")
			WriteLine(fileout,"START Y              :")
			WriteLine(fileout,"END Y                :")
			WriteLine(fileout,"START ANGLE          :")
			WriteLine(fileout,"END ANGLE            :")
			WriteLine(fileout,"RADIUS               :")
			WriteLine(fileout,"IS BEND LINE         :")
			WriteLine(fileout,"BEND LENGTH          :")		
			WriteLine(fileout,"LINE COLOR           :")
			WriteLine(fileout,"lINE NAME            :")
			WriteLine(fileout,"BEND DIRECTION       :")
			WriteLine(fileout,"PUNCH NAME           :")
			WriteLine(fileout,"DIE NAME             :")
			WriteLine(fileout,"Z-LEFT               :")
			WriteLine(fileout,"Z-RIGHT              :")
			WriteLine(fileout,"X-LEFT               :")
			WriteLine(fileout,"X-RIGHT              :")

			CloseFile(fileout)
			
			ExecFile("C:\Temp\EditLine.txt")
			
		End If
		
		;Let's find the line the user clicks on and edit it...
		For gl.MyLines = Each MyLines
			;MoveMouse gl\SX#, gl\SY#
			;junk = Input("Is this it" + gl\LName$)
			If Abs(SelectedX# - gl\SX#) &lt; 10 And Abs(SelectedY# - gl\SY#) &lt; 10 Then
				
				MoveMouse gl\SX#, gl\SY#
			End If
		Next
		;End If		
	End If
	
	If EditMode = 1 Then
		Rect MouseX() -4, MouseY() -5, 10, 10, False
	End If
	
	
	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw the Ram now...
	DrawRam()

	;Let's draw the tooling now below...
	DrawTooling()
	;Let's draw the tooling now above...

	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				;DrawCircle(gl\SX#, gl\SY#, gl\R#)
				DrawArc(gl\SX#, gl\SY#, 0, 359.5, gl\R#)
				
			Case "ARC"
				DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)

			Default
			
		End Select
	Next
	;Let's draw the part now above...

	Text 200, 200, (MyOriginX# + MachineCenterX) + " " + (MyOriginY# - MachineCenterY)

	Flip
	
Wend 

;Now that the program is finished, let's output the data...
OutputData()



Function ImportDXFFile(FileName$)

	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\IsBendLine$ = "NO"		
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			
		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\IsBendLine$ = "NO"			
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				
		End If

	Wend
	CloseFile(File)
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, MyOriginX# + EX# * MyScale#, MyOriginY# - EY# * MyScale#
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	;R# = R# * MyScale
	;Oval(MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, R#, R#, 0)
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	;No ARC command so trying to create an arc by drawing pixels from a center point at a given radius, start angle, and end agle
	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + .5
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend			
		End If
	End If
	
	;Text MyOriginX + CPX# + Cos(SA#) * R#, MyOriginY - CPY# - Sin(SA#) * R#, SA# + " " + EA#
End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 75, 75, 75

	Select RamDetailsToShow$
		Case "RAM-All"
		
			;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
			Line MyOriginX# + 0, MyOriginY# - MachineCenterLineY#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				Text MyOriginX# + (60 - I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "-" + I
			Next
		
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
		
			;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				Text MyOriginX# + (60 + I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "+" + I
			Next
		Case "RAM-Medium"
			;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
			Line MyOriginX# + 0, MyOriginY# - MachineCenterLineY#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				;Text MyOriginX# + (60 - I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "-" + I
			Next
		
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
		
			;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				;Text MyOriginX# + (60 + I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "+" + I
			Next
		
		Case "RAM-Low"
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
	End Select
	
End Function

Function DrawTooling()
	Color 0, 0, 255
	For tl.MyTools = Each MyTools
		Rect ((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - ToolHeight# * MyScale# / 2, tl\ToolLength * MyScale#, ToolHeight# * MyScale#, False)
		Line ((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY#, (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#) + tl\ToolLength# * MyScale#, MyOriginY# - MachineCenterLineY#)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - ToolHeight# * MyScale# / 2, Mid(tl\ToolName$,4,5)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 1) * MyScale# / 2, tl\ToolLength#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 2) * MyScale# / 2, tl\ToolLocation#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 3) * MyScale# / 2, tl\Reversed$
	Next

End Function

Function DrawGages()
	Color 255, 0, 0
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#)
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#)
	Next
	
End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#

			Case "ARC"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
				
			Case "CIRCLE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#

			Case "ARC"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
			Default
			
		End Select
	Next
End Function

Function MoveGageX(Amount#)
	Select ItemToMove$
		Case "BOTHGAGES"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SX# = lg\SX# + Amount#	
				lg\EX# = lg\EX# + Amount#	
			Next
			For rg.MyRightGage = Each MyRightGage
				rg\SX# = rg\SX# + Amount#	
				rg\EX# = rg\EX# + Amount#	
			Next
		Case "LEFTGAGE"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SX# = lg\SX# + Amount#	
				lg\EX# = lg\EX# + Amount#	
			Next		
		Case "RIGHTGAGE"
			For rg.MyRightGage = Each MyRightGage
				rg\SX# = rg\SX# + Amount#	
				rg\EX# = rg\EX# + Amount#	
			Next		
	End Select	
End Function

Function MoveGageY(Amount#)
	Select ItemToMove$
		Case "BOTHGAGES"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SY# = lg\SY# + Amount#	
				lg\EY# = lg\EY# + Amount#	
			Next
			For rg.MyRightGage = Each MyRightGage
				rg\SY# = rg\SY# + Amount#	
				rg\EY# = rg\EY# + Amount#	
			Next
		Case "LEFTGAGE"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SY# = lg\SY# + Amount#	
				lg\EY# = lg\EY# + Amount#	
			Next		
		Case "RIGHTGAGE"
			For rg.MyRightGage = Each MyRightGage
				rg\SY# = rg\SY# + Amount#	
				rg\EY# = rg\EY# + Amount#	
			Next		
	End Select	
End Function

Function RotatePart(Amount#)
	;This function was possible with help from Kryzon.  Thanks Kryzon.
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"

				;Find the current centre of the segment.
				Local lineCentreX# = MachineCenterLineX# ;( gl\SX + gl\EX ) / 2.0
				Local lineCentreY# = MachineCenterLineY# ;( gl\SY + gl\EY ) / 2.0
				
				;Move a "copy" of the segment so that its centre is located at the origin (point [0,0] ).
				Local localSX# = gl\SX - lineCentreX
				Local localSY# = gl\SY - lineCentreY
				
				Local localEX# = gl\EX - lineCentreX
				Local localEY# = gl\EY - lineCentreY
				
				;Rotate this copy by the amount.
				Local lineCos# = Cos( Amount )
				Local lineSin# = Sin( Amount )
				
				Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
				Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
				
				Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
				Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
				
				;Change the original segment to have the points of the rotated copy.
				
				gl\SX = newSX + lineCentreX
				gl\SY = newSY + lineCentreY
				
				gl\EX = newEX + lineCentreX
				gl\EY = newEY + lineCentreY				

								
			Case "CIRCLE"
							
				;Find the current centre of the segment.
				Local clineCentreX# = MachineCenterLineX# ;( gl\SX + gl\EX ) / 2.0
				Local clineCentreY# = MachineCenterLineY# ;( gl\SY + gl\EY ) / 2.0
				
				;Move a "copy" of the segment so that its centre is located at the origin (point [0,0] ).
				Local clocalSX# = gl\SX - clineCentreX
				Local clocalSY# = gl\SY - clineCentreY
				
				Local clocalEX# = gl\EX - clineCentreX
				Local clocalEY# = gl\EY - clineCentreY
				
				;Rotate this copy by the amount.
				Local clineCos# = Cos( Amount )
				Local clineSin# = Sin( Amount )
				
				Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
				Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
				
				Local cnewEX# = ( clocalEX * clineCos ) - ( clocalEY * clineSin )
				Local cnewEY# = ( clocalEX * clineSin ) + ( clocalEY * clineCos )
				
				;Change the original segment to have the points of the rotated copy.
				
				gl\SX = cnewSX + clineCentreX
				gl\SY = cnewSY + clineCentreY
				
				gl\EX = cnewEX + clineCentreX
				gl\EY = cnewEY + clineCentreY	
										
			Case "ARC"
			
				;Find the current centre of the segment.
				Local alineCentreX# = MachineCenterLineX# ;( gl\SX + gl\EX ) / 2.0
				Local alineCentreY# = MachineCenterLineY# ;( gl\SY + gl\EY ) / 2.0
				
				;Move a "copy" of the segment so that its centre is located at the origin (point [0,0] ).
				Local alocalSX# = gl\SX - alineCentreX
				Local alocalSY# = gl\SY - alineCentreY
				
				Local alocalEX# = gl\EX - alineCentreX
				Local alocalEY# = gl\EY - alineCentreY
				
				;Rotate this copy by the amount.
				Local alineCos# = Cos( Amount )
				Local alineSin# = Sin( Amount )
				
				Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
				Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
				
				Local anewEX# = ( alocalEX * alineCos ) - ( alocalEY * alineSin )
				Local anewEY# = ( alocalEX * alineSin ) + ( alocalEY * alineCos )
				
				;Change the original segment to have the points of the rotated copy.
				
				gl\SX = anewSX + alineCentreX
				gl\SY = anewSY + alineCentreY
				
				gl\EX = anewEX + alineCentreX
				gl\EY = anewEY + alineCentreY	
				
				gl\SA# = gl\SA# + Amount#
				gl\EA# = gl\EA# + Amount#
				
							
		End Select
	Next
End Function

Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the vertical axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
				
			Case "CIRCLE"
				gl\SX# = gl\SX# * -1

			Case "ARC"
				;Need help with this code.  It is not flipping across the vertical axis correctly
				gl\SX# = gl\SX# * -1
				
				If gl\SA# &lt; gl\EA# Then


				Else
				
				End If
				
				gl\EA# = gl\SA# + 180
				gl\SA# = gl\EA#
			
		End Select
	Next
End Function


Function AddTooling()
	tl.MyTools = New MyTools
	tl\ToolName$ = "MTOXXXXX000P"
	tl\ToolLength =12.000
	tl\ToolLocation = .5
	tl\Reversed = "NO"
End Function


Function OutputData()
	fileout = WriteFile("C:\Temp\mydata.txt")

	WriteLine(fileout, "StartGeometryInformation")
	WriteLine(fileout, "GeometryName,StartX,StartY,EndX,EndY,StartAngle,EndAngle,Radius,IsBendLine,GeometryColor,BendDirection,BendAngle,BendLength,Punch,Die,Z-Left,Z-Right,X-Left,X-Right")
	For gl.MyLines = Each MyLines
		WriteLine(fileout, gl\LName$ + "," + gl\SX# + "," + gl\SY# + "," + gl\EX# + "," + gl\EY# + "," + gl\SA# + "," + gl\EA# + "," + gl\R# + "," + gl\IsBendLine$ + "," + gl\LColor$ + "," + gl\DIR$ + "," + gl\Angle# + "," + CalcDistance(gl\SX#, gl\SY#, gl\EX#, gl\EY#) + "," + gl\Punch$ + "," + gl\Die$ + "," + gl\ZL# + "," + gl\ZR# + "," + gl\XL# + "," + gl\XR#)
	Next
	WriteLine(fileout, "EndGeometryInformation")
	
	WriteLine(fileout, "StartToolingInformation")
	WriteLine(fileout, "ToolNumber,ToolName,ToolLength,ToolLocation,ToolReversed?")
	For tl.MyTools = Each MyTools
		WriteLine(fileout, tl\ToolNumber$ + "," + tl\ToolName$ + "," + tl\ToolLength# + "," + tl\ToolLocation# + "," + tl\Reversed)
	Next
	WriteLine(fileout, "EndToolingInformation")

	CloseFile(fileout)

End Function

Function ImportLeftGage()

;Below are the coordinates for drawing the gage finger...
;DrawLine(2.000,0.000,2.000,2.500)
;DrawLine(2.000,2.500,0.000,2.500)
;DrawLine(0.000,2.500,0.000,1.000)
;DrawLine(2.000,0.000,1.750,0.000)
;DrawLine(1.750,0.000,1.750,0.125)
;DrawLine(1.750,0.125,0.000,1.000)
;DrawLine(0.000,1.000,1.000,1.000)
;DrawLine(1.000,1.000,1.000,2.500)

lg.MyLeftGage = New MyLeftGage
lg\SX# = 2
lg\SY# = 0
lg\EX# = 2
lg\EY# = 2.5

lg.MyLeftGage = New MyLeftGage
lg\SX# = 2
lg\SY# = 2.5
lg\EX# = 0
lg\EY# =2.5

lg.MyLeftGage = New MyLeftGage
lg\SX# = 0
lg\SY# = 2.5
lg\EX# = 0
lg\EY# = 1

lg.MyLeftGage = New MyLeftGage
lg\SX# = 2
lg\SY# = 0
lg\EX# = 1.75
lg\EY# = 0

lg.MyLeftGage = New MyLeftGage
lg\SX# = 1.75
lg\SY# = 0
lg\EX# = 1.75
lg\EY# = .125

lg.MyLeftGage = New MyLeftGage
lg\SX# = 1.75
lg\SY# = .125
lg\EX# = 0
lg\EY# = 1

lg.MyLeftGage = New MyLeftGage
lg\SX# = 0
lg\SY# = 1
lg\EX# = 1
lg\EY# = 1

lg.MyLeftGage = New MyLeftGage
lg\SX# = 1
lg\SY# = 1
lg\EX# = 1
lg\EY# = 2.5


End Function

Function ImportRightGage()

;Below are the coordinates for drawing the gage finger...
;DrawLine(0.000,0.000,0.000,2.500)
;DrawLine(0.000,2.500,2.000,2.500)
;DrawLine(2.000,2.500,2.000,1.000)
;DrawLine(0.000,0.000,0.250,0.000)
;DrawLine(0.250,0.000,0.250,0.125)
;DrawLine(0.250,0.125,2.000,1.000)
;DrawLine(2.000,1.000,1.000,1.000)
;DrawLine(1.000,1.000,1.000,2.500)

rg.MyRightGage = New MyRightGage
rg\SX# = 0
rg\SY# = 0
rg\EX# = 0
rg\EY# = 2.5

rg.MyRightGage  = New MyRightGage
rg\SX# = 0
rg\SY# = 2.5
rg\EX# = 2
rg\EY# = 2.5

rg.MyRightGage  = New MyRightGage
rg\SX# = 2
rg\SY# = 2.5
rg\EX# = 2
rg\EY# = 1

rg.MyRightGage  = New MyRightGage
rg\SX# = 0
rg\SY# = 0
rg\EX# = .25
rg\EY# = 0

rg.MyRightGage  = New MyRightGage
rg\SX# = .25
rg\SY# = 0
rg\EX# = .25
rg\EY# = .125

rg.MyRightGage  = New MyRightGage
rg\SX# = .25
rg\SY# = .125
rg\EX# = 2
rg\EY# = 1

rg.MyRightGage  = New MyRightGage
rg\SX# = 2
rg\SY# = 1
rg\EX# = 1
rg\EY# = 1

rg.MyRightGage  = New MyRightGage
rg\SX# = 1
rg\SY# = 1
rg\EX# = 1
rg\EY# = 2.5
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1302923"></a>

<a name="1302924"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your arc drawing code needs angles between (0, 359), so in the RotatePart function you need wrap the angles of the arc to that range.<br><br>This is the RotatePart function alone, with that correction (plus some stuff cut out from the circle and arc parts):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				
				;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
				Local localSX# = gl\SX - MachineCenterLineX
				Local localSY# = gl\SY - MachineCenterLineY
				
				Local localEX# = gl\EX - MachineCenterLineX
				Local localEY# = gl\EY - MachineCenterLineY
				
				;Rotate this copy by the angle amount.
				Local lineCos# = Cos( Amount )
				Local lineSin# = Sin( Amount )
				
				Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
				Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
				
				Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
				Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
				
				;Change the original segment to have the points of the rotated copy
				;but moved to the position of the original.
				
				gl\SX = newSX + MachineCenterLineX
				gl\SY = newSY + MachineCenterLineY
				
				gl\EX = newEX + MachineCenterLineX
				gl\EY = newEY + MachineCenterLineY				
								
			Case "CIRCLE"
							
				Local clocalSX# = gl\SX - MachineCenterLineX
				Local clocalSY# = gl\SY - MachineCenterLineY
				
				Local clineCos# = Cos( Amount )
				Local clineSin# = Sin( Amount )
				
				Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
				Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
				
				gl\SX = cnewSX + MachineCenterLineX
				gl\SY = cnewSY + MachineCenterLineY
				
				;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
			Case "ARC"
			
				Local alocalSX# = gl\SX - MachineCenterLineX
				Local alocalSY# = gl\SY - MachineCenterLineY
				
				Local alineCos# = Cos( Amount )
				Local alineSin# = Sin( Amount )
				
				Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
				Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
				
				gl\SX = anewSX + MachineCenterLineX
				gl\SY = anewSY + MachineCenterLineY
				
				;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
				
				gl\SA# = ( gl\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
				gl\EA# = ( gl\EA# + Amount# ) Mod 360
							
		End Select
	Next
End Function</textarea> <br><br></td></tr></table><br>
<a name="1302948"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Works perfectly!  Thanks for your help.  I couldn't have gotten this to work without your help.  I really appreciate it. <br><br></td></tr></table><br>
<a name="1302962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> What are some better ways to get input from the user?  Rather than hitting Function keys and keyboard keys, is there a better way and how is it done?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 1200,900,16 

AppTitle "F1=PrtDetails," + "F2=MovAmt,"+ "F3=Flip," +"F4=Rot," + "F5=RotAmt," + "F6=ZmIn," + "F7-ZmOut," + "F8=CamLft,"+"F9=CamRt," + "F10=CamUP," + "F11=CamDn," + "T=AddTool," + "E=Edit," + "M=Select Item 2 Mov," + "F12=Ram Details,"

Global MyOriginX# = -900;-600
Global MyOriginY# = 400;600
Global MyScale# = 25
Global MachineCenterLineX# = 60
Global MachineCenterLineY# = 0;300
Global ToolHeight# = 2 ;( 2 inch tool height for drawing tool images onto the screen)
Global EditMode = 0
Global SelectedX# =0.0
Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .125
Global ZAxisLeft# = -59.5
Global ZAxisRight# = -58.5
Global XAxisRight# = 0
Global XAxisLeft# = 0

Type MyLines
	Field GraphicType$  ;LINE, CIRCLE, OR ARC
	Field SX#           ;LINE START POINT X
	Field SY#           ;LINE START POINT Y
	Field EX#           ;LINE END POINT X
	Field EY#           ;LINE END POINT Y
	Field SA#           ;ARC START ANGLE
	Field EA#           ;ARC END ANGLE
	Field R#            ;ARC RADIUS
	Field IsBendLine$   ;IS A BEND LINE YES or NO
	Field LColor$       ;LINE COLOR
	Field LName$        ;LINE NAME
	Field Dir$          ;BEND DIRECTION
	Field Angle#        ;BEND ANGLE
	Field BendLength#   ;BEND LENGTH
	Field Punch$        ;PUNCH
	Field Die$          ;Die
	Field ZL#           ;ZLeft
	Field ZR#           ;ZRight
	Field XL#           ;XLeft
	Field XR#           ;XRight
End Type

Type MyTools
	Field ToolNumber$   ;Tool Number
	Field ToolName$     ;Tool Name
	Field ToolLength#   ;Tool Length
	Field ToolLocation# ;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     ;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#
	Field SY#
	Field EX#
	Field EY#
End Type

Type MyRightGage
	Field SX#
	Field SY#
	Field EX#
	Field EY#
End Type

;Let's add a couple tools for testing...
tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "1"
tl\ToolName$ = "MT030017000P"
tl\ToolLength# = 12.000
tl\ToolLocation# = -0.75
tl\Reversed = "NO"

tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "2"
tl\ToolName$ = "MT030095000P"
tl\ToolLength# = 4.000
tl\ToolLocation# = -18.000
tl\Reversed = "NO"

tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "3"
tl\ToolName$ = "MT030125000P"
tl\ToolLength# = 8.000
tl\ToolLocation# = 12.000
tl\Reversed = "NO"

ImportLeftGage()
ImportRightGage()


fntArial=LoadFont("Calibri",15,False,False,False)
fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 

;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")
;ImportDXFFile ("C:\Temp\junkoriginal7.txt")
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")


;Let's move the gages into view...
ItemToMove$ = "RIGHTGAGE"
MoveGageX(58)

ItemToMove$ = "LEFTGAGE"
MoveGageX(47)

ItemToMove$ = "BOTHGAGES"
MoveGageY(2)

ItemToMove$ = "PART"
MovePartX(47.25)
MovePartY(-10)

; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	If KeyHit(59) Then	;F1
		Select PartDetailsToShow$
			Case "HIGH"
				PartDetailsToShow$ = "MED"
			Case "MED"
				PartDetailsToShow$ = "LOW"
			Case "LOW"
				PartDetailsToShow$ = "HIGH"
		End Select
	End If

	;Let's set the Movement Amount below...
	If KeyHit(60) Then	;F2
		Select MovementAmount#
			Case .125
				MovementAmount# = .5
			Case .5
				MovementAmount# = 1
			Case 1
				MovementAmount# = 6
			Case 6
				MovementAmount# = .125
		End Select
	End If

	;Flip part below...
	If KeyHit(61) Then	;F3
		FlipPart()
	End If
	;Flip part abouve...

	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If

	If KeyHit(63) Then	;(F5)
		Select RotationAmount#
			Case 45
				RotationAmount# = 90
			Case 90
				RotationAmount# = 5
			Case 5
				RotationAmount# = 1
			Default
				RotationAmount# = 45
		End Select
	End If
		
	;Zoom functionality below...
	If KeyDown(64)	;zoom in (F6)
		MyScale = MyScale + 1
		MyOriginX = MyOriginX - 60	;This keeps the view centered when zooming in/out
	End If		

	If KeyDown(65)	;zoom out (F7)
		MyScale = MyScale - 1
		MyOriginX = MyOriginX + 60	;This keeps the view centered when zooming in/out
	End If		
	;Zoom functionality above...

	;Move "CAMERA" type functionality below...
	If KeyDown(66) Then ;(F8)	;Move CAM left
		Select ItemToMove$
			Case "PART"
				MyOriginX = MyOriginX - 10
		End Select
	End If
	
	If KeyDown(67) Then ;(F9)	;Move CAM right
		Select ItemToMove$
			Case "PART"
				MyOriginX = MyOriginX + 10
		End Select
	End If
	
	If KeyDown(68) Then ;(F10)	;Move CAM Up
		MyOriginY# = MyOriginY# - 10
	End If
	
	If KeyDown(87) Then ;(F11)	;Move CAM Down
		MyOriginY# = MyOriginY# + 10
	End If
	;Move "CAMERA" type functionality above...

	If KeyHit(88) Then	;(F12)
		Select RamDetailsToShow$
			Case "RAM-All"
				RamDetailsToShow$ = "RAM-Medium"
			Case "RAM-Medium"
				RamDetailsToShow$= "RAM-Low"
			Default
				RamDetailsToShow$ = "RAM-All"
		End Select
	End If

	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	
	;Edit bend lines
	If KeyHit(18) Then	;(E Key)
		EditMode = 1
	End If 
	
	If MouseDown(2) Then	;(right mouse button)
		;let's get the edit line data from the user and update the part
		
		EditMode = 0
	End If
	
	If KeyHit(50) Then	;(M key)
		Select ItemToMove$
			Case "PART"
				ItemToMove$ = "BOTHGAGES"
			Case "BOTHGAGES"
				ItemToMove$ = "LEFTGAGE"
			Case "LEFTGAGE"
				ItemToMove$ = "RIGHTGAGE"
			Case "RIGHTGAGE"
				ItemToMove$ = "TOOLS"
			Default
				ItemToMove$ = "PART"
				
		End Select
	End If
	
	;Move Part around on the screen below...
	If KeyDown(203) ;(Left key)
		Select ItemToMove$
			Case "PART"
				MovePartX(-MovementAmount#)
			Case "BOTHGAGES"
				MoveGageX(-MovementAmount#)
				;ZAxisLeft# = ZAxisLeft# - MovementAmount#
				;ZAxisRight# = ZAxisRight# - MovementAmount#
			Case "LEFTGAGE"
				MoveGageX(-MovementAmount#)
				;ZAxisLeft# = ZAxisLeft# - MovementAmount#
			Case "RIGHTGAGE"
				MoveGageX(-MovementAmount#)
				;ZAxisRight# = ZAxisRight# - MovementAmount#
			Case "TOOLS"
			
		End Select
	End If
	If KeyDown(205) ;(Right Key)
		Select ItemToMove$
			Case "PART"
				MovePartX(MovementAmount#)
			Case "BOTHGAGES"
				MoveGageX(MovementAmount#)
				;ZAxisLeft# = ZAxisLeft# + MovementAmount#
				;ZAxisRight# = ZAxisRight# + MovementAmount#
			Case "LEFTGAGE"
				MoveGageX(MovementAmount#)
				;ZAxisLeft# = ZAxisLeft# + MovementAmount#
			Case "RIGHTGAGE"
				MoveGageX(MovementAmount#)
				;ZAxisRight# = ZAxisRight# + MovementAmount#
			Case "TOOLS"
			
		End Select
	End If		
	If KeyDown(200) ;(Up Key)
		Select ItemToMove$
			Case "PART"
				MoveParty(MovementAmount#)
			Case "BOTHGAGES"
				MoveGageY(MovementAmount#)
				;XAxisLeft# = ZAxisLeft# - MovementAmount#
				;XAxisRight# = ZAxisRight# - MovementAmount#
			Case "LEFTGAGE"
				MoveGageY(MovementAmount#)
				;XAxisLeft# = ZAxisLeft# - MovementAmount#
			Case "RIGHTGAGE"
				MoveGageY(MovementAmount#)
				;XAxisRight# = ZAxisRight# - MovementAmount#
			Case "TOOLS"
			
		End Select
	End If
	If KeyDown(208) ;(Down Key)
		Select ItemToMove$
			Case "PART"
				MovePartY(-MovementAmount#)
			Case "BOTHGAGES"
				MoveGageY(-MovementAmount#)
				;XAxisLeft# = ZAxisLeft# + MovementAmount#
				;XAxisRight# = ZAxisRight# + MovementAmount#
			Case "LEFTGAGE"
				MoveGageY(-MovementAmount#)
				;XAxisLeft# = ZAxisLeft# + MovementAmount#
			Case "RIGHTGAGE"
				MoveGageY(-MovementAmount#)
				;XAxisRight# = ZAxisRight# + MovementAmount#
			Case "TOOLS"
			
		End Select
	End If		
	;Move Part around on the screen above...
	
	;let's put up some information on the screen to let the user know what the various settings are...
	Color 255,255,0
	SetFont fntCourier
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Mov Amount  : " + MovementAmount#
	Text 1, 30, "Rot Amt     : " + RotationAmount#
	Text 1, 45, "Prt Details : " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + ZAxisLeft#
	Text 1, 90, "Z Axis Right: " + ZAxisRight#
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	SetFont fntArial
		
	If EditMode = 1 Then


		SelectedX# = MouseX()
		SelectedY# = MouseY()
		
		;Let's find the line the user clicks on and edit it...
		For gl.MyLines = Each MyLines
			If Abs(SelectedX# - (MyOriginX# + gl\SX# * MyScale#)) &lt; 5 And Abs(SelectedY# - (MyOriginY# - gl\SY# * MyScale)) &lt; 5 Then
				MoveMouse MyOriginX# + gl\SX# * MyScale#, MyOriginY# - gl\SY# * MyScale
				Text MouseX() + 8, MouseY() -25, "Angle: " + gl\Angle# + ", DIR: " + gl\DIR$ + ", BendLength: " + gl\BendLength#
			
				If MouseHit(1) Then	;Let's get the data from the picked line and put it into a file and show it to the user
					MoveMouse MouseX(), MouseY() + 20
					
					fileout = WriteFile("C:\Temp\EditLine.txt")
					;WriteLine(fileout,"THIS IS THE DATA FROM THE LINE YOU PICKED")
					WriteLine(fileout,"GRAPHIC TYPE         :" + gl\GraphicType$)
					WriteLine(fileout,"LINE NAME            :" + gl\LName$)
					WriteLine(fileout,"START X              :" + gl\SX#)
					WriteLine(fileout,"START Y              :" + gl\SY#)
					WriteLine(fileout,"END X                :" + gl\EX#)
					WriteLine(fileout,"END Y                :" + gl\EY#)
					WriteLine(fileout,"START ANGLE          :" + gl\SA#)
					WriteLine(fileout,"END ANGLE            :" + gl\EA#)
					WriteLine(fileout,"RADIUS               :" + gl\R#)
					WriteLine(fileout,"IS BEND LINE         :" + gl\IsBendLine$)
					WriteLine(fileout,"LINE COLOR           :" + gl\LColor$)
					WriteLine(fileout,"X-LEFT               :" + gl\XL#)
					WriteLine(fileout,"X-RIGHT              :" + gl\XR#)
					WriteLine(fileout,"BEND ANGLE           :" + gl\Angle$)
					WriteLine(fileout,"BEND DIRECTION       :" + gl\DIR$)
					WriteLine(fileout,"BEND LENGTH          :" + gl\BendLength#)		
					WriteLine(fileout,"PUNCH NAME           :" + gl\Punch$)
					WriteLine(fileout,"DIE NAME             :" + gl\Die$)
					WriteLine(fileout,"Z-LEFT               :" + gl\ZL#)
					WriteLine(fileout,"Z-RIGHT              :" + gl\ZR#)
		
					CloseFile(fileout)
					
					ExecFile("C:\Temp\EditLine.txt")
					
				End If			
			End If
		Next
	End If
	
	If EditMode = 1 Then
		Rect MouseX() -4, MouseY() -5, 10, 10, False
	End If
	
	
	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw the Ram now...
	DrawRam()

	;Let's draw the tooling now below...
	DrawTooling()
	;Let's draw the tooling now above...

	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
					DrawArc(gl\SX#, gl\SY#, 0, 359.5, gl\R#)
				End If
				
			Case "ARC"
				If PartDetailsToShow$ = "HIGH" Then
					DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)
				End If
		End Select
	Next
	;Let's draw the part now above...

	Flip
	
Wend 

;Now that the program is finished, let's output the data...
OutputData()



Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			
			I = I + 1
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\IsBendLine$ = "NO"		
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			
		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\IsBendLine$ = "NO"			
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				
		End If

	Wend
	CloseFile(File)
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, MyOriginX# + EX# * MyScale#, MyOriginY# - EY# * MyScale#
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, (MyOriginX# + SX# * MyScale#) + ", " + (MyOriginY# - SY# * MyScale#) ;, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	;R# = R# * MyScale
	;Oval(MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, R#, R#, 0)
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	;No ARC command so trying to create an arc by drawing pixels from a center point at a given radius, start angle, and end agle
	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + .5
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + .5
			Wend			
		End If
	End If
	
	;Text MyOriginX + CPX# + Cos(SA#) * R#, MyOriginY - CPY# - Sin(SA#) * R#, SA# + " " + EA#
End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 75, 75, 75

	Select RamDetailsToShow$
		Case "RAM-All"
		
			;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
			Line MyOriginX# + 0, MyOriginY# - MachineCenterLineY#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				Text MyOriginX# + (60 - I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "-" + I
			Next
		
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
		
			;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				Text MyOriginX# + (60 + I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "+" + I
			Next
		Case "RAM-Medium"
			;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
			Line MyOriginX# + 0, MyOriginY# - MachineCenterLineY#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				;Text MyOriginX# + (60 - I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "-" + I
			Next
		
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
		
			;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				;Text MyOriginX# + (60 + I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "+" + I
			Next
		
		Case "RAM-Low"
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
	End Select
	
End Function

Function DrawTooling()
	Color 0, 0, 255
	For tl.MyTools = Each MyTools
		Rect ((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - ToolHeight# * MyScale# / 2, tl\ToolLength * MyScale#, ToolHeight# * MyScale#, False)
		Line ((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY#, (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#) + tl\ToolLength# * MyScale#, MyOriginY# - MachineCenterLineY#)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - ToolHeight# * MyScale# / 2, Mid(tl\ToolName$,4,5)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 1) * MyScale# / 2, tl\ToolLength#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 2) * MyScale# / 2, tl\ToolLocation#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 3) * MyScale# / 2, tl\Reversed$
	Next

End Function

Function DrawGages()
	Color 255, 0, 0
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#)
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#)
	Next
	
End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#

			Case "ARC"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
			Default
			
		End Select
	Next
End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
				
			Case "CIRCLE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#

			Case "ARC"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
			Default
			
		End Select
	Next
End Function

Function MoveGageX(Amount#)
	Select ItemToMove$
		Case "BOTHGAGES"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SX# = lg\SX# + Amount#	
				lg\EX# = lg\EX# + Amount#	
			Next
			For rg.MyRightGage = Each MyRightGage
				rg\SX# = rg\SX# + Amount#	
				rg\EX# = rg\EX# + Amount#	
			Next
			ZAxisLeft# = ZAxisLeft# + Amount#
			ZAxisRight# = ZAxisRight# + Amount#

		Case "LEFTGAGE"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SX# = lg\SX# + Amount#	
				lg\EX# = lg\EX# + Amount#	
			Next		
			ZAxisLeft# = ZAxisLeft# + Amount#

		Case "RIGHTGAGE"
			For rg.MyRightGage = Each MyRightGage
				rg\SX# = rg\SX# + Amount#	
				rg\EX# = rg\EX# + Amount#	
			Next		
			ZAxisRight# = ZAxisRight# + Amount#

	End Select	
End Function

Function MoveGageY(Amount#)
	Bottom# = 0
	If XAxisRight# &lt;= 0 And Amount# &lt; 0Then
		 Bottom# = 1
	End If
	If XAxisLeft# &lt;= 0 And Amount# &lt; 0 Then
		Bottom# = 1
	End If
	If Bottom# &lt;&gt; 1 Then
	Select ItemToMove$
		Case "BOTHGAGES"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SY# = lg\SY# + Amount#	
				lg\EY# = lg\EY# + Amount#	
			Next
			For rg.MyRightGage = Each MyRightGage
				rg\SY# = rg\SY# + Amount#	
				rg\EY# = rg\EY# + Amount#	
			Next
			XAxisLeft# = XAxisLeft# + Amount#
			XAxisRight# = XAxisRight# + Amount#

		Case "LEFTGAGE"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SY# = lg\SY# + Amount#	
				lg\EY# = lg\EY# + Amount#	
			Next		
			XAxisLeft# = ZAxisLeft# + Amount#

		Case "RIGHTGAGE"
			For rg.MyRightGage = Each MyRightGage
				rg\SY# = rg\SY# + Amount#	
				rg\EY# = rg\EY# + Amount#	
			Next		
			XAxisRight# = ZAxisRight# + Amount#

	End Select	
	End If
End Function

Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				
				;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
				Local localSX# = gl\SX - MachineCenterLineX
				Local localSY# = gl\SY - MachineCenterLineY
				
				Local localEX# = gl\EX - MachineCenterLineX
				Local localEY# = gl\EY - MachineCenterLineY
				
				;Rotate this copy by the angle amount.
				Local lineCos# = Cos( Amount )
				Local lineSin# = Sin( Amount )
				
				Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
				Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
				
				Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
				Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
				
				;Change the original segment to have the points of the rotated copy
				;but moved to the position of the original.
				
				gl\SX = newSX + MachineCenterLineX
				gl\SY = newSY + MachineCenterLineY
				
				gl\EX = newEX + MachineCenterLineX
				gl\EY = newEY + MachineCenterLineY				
								
			Case "CIRCLE"
							
				Local clocalSX# = gl\SX - MachineCenterLineX
				Local clocalSY# = gl\SY - MachineCenterLineY
				
				Local clineCos# = Cos( Amount )
				Local clineSin# = Sin( Amount )
				
				Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
				Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
				
				gl\SX = cnewSX + MachineCenterLineX
				gl\SY = cnewSY + MachineCenterLineY
				
				;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
			Case "ARC"
			
				Local alocalSX# = gl\SX - MachineCenterLineX
				Local alocalSY# = gl\SY - MachineCenterLineY
				
				Local alineCos# = Cos( Amount )
				Local alineSin# = Sin( Amount )
				
				Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
				Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
				
				gl\SX = anewSX + MachineCenterLineX
				gl\SY = anewSY + MachineCenterLineY
				
				;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
				
				gl\SA# = ( gl\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
				gl\EA# = ( gl\EA# + Amount# ) Mod 360
							
		End Select
	Next
End Function


Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the vertical axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
				
			Case "CIRCLE"
				gl\SX# = gl\SX# * -1

			Case "ARC"
				;Need help with this code.  It is not flipping across the vertical axis correctly
				gl\SX# = gl\SX# * -1
				
				If gl\SA# &lt; gl\EA# Then


				Else
				
				End If
				
				gl\EA# = gl\SA# + 180
				gl\SA# = gl\EA#
			
		End Select
	Next
End Function


Function AddTooling()
	tl.MyTools = New MyTools
	tl\ToolName$ = "MTOXXXXX000P"
	tl\ToolLength =12.000
	tl\ToolLocation = .5
	tl\Reversed = "NO"
End Function


Function OutputData()
	fileout = WriteFile("C:\Temp\mydata.txt")

	WriteLine(fileout, "StartGeometryInformation")
	WriteLine(fileout, "GeometryName,StartX,StartY,EndX,EndY,StartAngle,EndAngle,Radius,IsBendLine,GeometryColor,BendDirection,BendAngle,BendLength,Punch,Die,Z-Left,Z-Right,X-Left,X-Right")
	For gl.MyLines = Each MyLines
		WriteLine(fileout, gl\LName$ + "," + gl\SX# + "," + gl\SY# + "," + gl\EX# + "," + gl\EY# + "," + gl\SA# + "," + gl\EA# + "," + gl\R# + "," + gl\IsBendLine$ + "," + gl\LColor$ + "," + gl\DIR$ + "," + gl\Angle# + "," + CalcDistance(gl\SX#, gl\SY#, gl\EX#, gl\EY#) + "," + gl\Punch$ + "," + gl\Die$ + "," + gl\ZL# + "," + gl\ZR# + "," + gl\XL# + "," + gl\XR#)
	Next
	WriteLine(fileout, "EndGeometryInformation")
	
	WriteLine(fileout, "StartToolingInformation")
	WriteLine(fileout, "ToolNumber,ToolName,ToolLength,ToolLocation,ToolReversed?")
	For tl.MyTools = Each MyTools
		WriteLine(fileout, tl\ToolNumber$ + "," + tl\ToolName$ + "," + tl\ToolLength# + "," + tl\ToolLocation# + "," + tl\Reversed)
	Next
	WriteLine(fileout, "EndToolingInformation")

	CloseFile(fileout)

End Function

Function ImportLeftGage()

	;Below are the coordinates for drawing the gage finger...
	;DrawLine(2.000,0.000,2.000,2.500)
	;DrawLine(2.000,2.500,0.000,2.500)
	;DrawLine(0.000,2.500,0.000,1.000)
	;DrawLine(2.000,0.000,1.750,0.000)
	;DrawLine(1.750,0.000,1.750,0.125)
	;DrawLine(1.750,0.125,0.000,1.000)
	;DrawLine(0.000,1.000,1.000,1.000)
	;DrawLine(1.000,1.000,1.000,2.500)
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 2
	lg\SY# = 0
	lg\EX# = 2
	lg\EY# = 2.5
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 2
	lg\SY# = 2.5
	lg\EX# = 0
	lg\EY# =2.5
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 0
	lg\SY# = 2.5
	lg\EX# = 0
	lg\EY# = 1
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 2
	lg\SY# = 0
	lg\EX# = 1.75
	lg\EY# = 0
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 1.75
	lg\SY# = 0
	lg\EX# = 1.75
	lg\EY# = .125
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 1.75
	lg\SY# = .125
	lg\EX# = 0
	lg\EY# = 1
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 0
	lg\SY# = 1
	lg\EX# = 1
	lg\EY# = 1
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 1
	lg\SY# = 1
	lg\EX# = 1
	lg\EY# = 2.5

End Function

Function ImportRightGage()

	;Below are the coordinates for drawing the gage finger...
	;DrawLine(0.000,0.000,0.000,2.500)
	;DrawLine(0.000,2.500,2.000,2.500)
	;DrawLine(2.000,2.500,2.000,1.000)
	;DrawLine(0.000,0.000,0.250,0.000)
	;DrawLine(0.250,0.000,0.250,0.125)
	;DrawLine(0.250,0.125,2.000,1.000)
	;DrawLine(2.000,1.000,1.000,1.000)
	;DrawLine(1.000,1.000,1.000,2.500)
	
	rg.MyRightGage = New MyRightGage
	rg\SX# = 0
	rg\SY# = 0
	rg\EX# = 0
	rg\EY# = 2.5
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 0
	rg\SY# = 2.5
	rg\EX# = 2
	rg\EY# = 2.5
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 2
	rg\SY# = 2.5
	rg\EX# = 2
	rg\EY# = 1
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 0
	rg\SY# = 0
	rg\EX# = .25
	rg\EY# = 0
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = .25
	rg\SY# = 0
	rg\EX# = .25
	rg\EY# = .125
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = .25
	rg\SY# = .125
	rg\EX# = 2
	rg\EY# = 1
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 2
	rg\SY# = 1
	rg\EX# = 1
	rg\EY# = 1
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 1
	rg\SY# = 1
	rg\EX# = 1
	rg\EY# = 2.5

End Function
</textarea> <br><br></td></tr></table><br>
<a name="1302972"></a>

<a name="1302973"></a>

<a name="1302974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Standard in software is a combination of mouse + keyboard. People should be able to click and drag things like vertices etc.<br><br>I don't know how much time you have left to make this tool, if you were hired to make it etc. but I really recommend using BlitzMax and MaxGUI (you can find a <a href="http://xerra.dexteritydesign.co.uk/max-gui-beginner-tutorials-hosting/" target="_blank">tutorial series here</a>), or even C++ and Qt like I mentioned before.<br>If you want people to feel familiar with your program then you need to use a GUI library so you can have things like buttons, menus, sliders etc. that look the same as those of other programs that they use.<br><br>I also suggest improving your code. If you have separate kinds of parts (circle, arc, line etc.), make one Type for each instead of having the same type that includes unused parameters to all types of objects.<br>C++ or BlitzMax will help you in this regard as they have more advanced ways to use classes (user types). The better you organise things, the less chances of making bugs.<br><br>An example of what you can do with Types in BlitzMax:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type BasePart

	Const CLASS_LINE:Int	= 1
	Const CLASS_ARC:Int	= 2
	Const CLASS_CIRCLE:Int	= 3

	Field class:Int
	Field x:Float, y:Float

End Type


Type LinePart Extends BasePart

	Method New()		
		class = CLASS_LINE
	End Method

	Field endX:Float, endY:Float

End Type


Type CirclePart Extends BasePart

	Method New()		
		class = CLASS_CIRCLE
	End Method

	Field radius:Float

End Type

Local myCircle:CirclePart = New CirclePart
myCircle.x	= 350
myCircle.y	= 400
myCircle.radius	= 3.14</textarea> <br><br></td></tr></table><br>
<a name="1302977"></a>

<a name="1302978"></a>

<a name="1302979"></a>

<a name="1302980"></a>

<a name="1302981"></a>

<a name="1302982"></a>

<a name="1302984"></a>

<a name="1302986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't listen to him. He's nothing but an indoctrination of what the system WANT him to be. Be your OWN programmer! USE the methods these indoctrinators tell you NOT to use! And break FREE from your "college" program. It's nothing but a prison for your mind. Prison being a constant bad-intention loop even if you mean well. <b><u>DON'T FALL FOR IT!</u></b> Sure! C++ &amp; Blitzmax are nice! BUT! It will take you <b><u>YEARS</u></b> to do something you already have within you in Blitz3D in "A" year if not MONTHS!<br><br>Oh! And for the record. Say whatever you all want because I am not responding to <b><u>ANYONE</u></b> who thinks indoctrination by going to "college" is cool &amp; / or OK!<br><br>Here's a hint : Use the Code Snippets, bud! You'll find your way!<br><br>Infact, here's the links to both the Code Archives thread &amp; the Code Archives pages:<br><br>Code Archives PAGE: <br><br><a href="/codearcs.php" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php</a><br><br>Code Archives THREAD: <br><br><a href="/topics.php" target="_blank">http://www.blitzbasic.com/codearcs/topics.php</a><br><br>HAVE AT IT!<br><br>Have honor within yourself!<br><br>~GF <br><br></td></tr></table><br>
<a name="1302983"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK.  Got it.  I am not a programmer.  This is a project that I am doing for my team of sheet metal fabricators.  I am trying to create a way to allow people in the office to simulate a pressbrake and create a program that can be sent out to the machine to make production parts.  <br><br>The basic concept is this:<br>1) Use the CAD system to export out a 2D DXF file<br>2) Extract the lines, arcs from the DXF file and open them up and display in Blitz<br>3) Click on each "bend line" and enter bend angle, bend direction, backgage settings, etc.<br>4) Add tooling to the Blitz screen and position for each bend<br>5)Export out all of these data points that can be formatted into a program that can make the pressbrake bend the parts<br><br>I do understand your points about my code and I do intend to clean it up after I get all of the concepts working.<br><br>There is more professional grade software available but it is very expensive...about $40K so I am creating the "poor man's" version.  It is rinky dink but will allow me and my team to take a big step forward and increase our productivity.<br><br>I am having a lot of fun doing it.  I am learning a lot and I am thankful for your help.  If I can get everything working like I want, then I'll look at redoing it in BlitzMax or something else.  I have always wanted to learn C++ but have not committed the time.  At a glance, it seems very complicated.<br><br>Thanks again for all of your help.  I am stunned that people that I don't know and don't know me are willing to dedicate their personal time to help out. <br><br></td></tr></table><br>
<a name="1302985"></a>

<a name="1302987"></a>

<a name="1302992"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> This link is an example of what I would like to be able to accomplish someday.  Does anyone know how this type of 3D simulation is accomplished?  how can I take any 2D flat part like the one I have been using in my code above and convert it into something that can be shown and simulated bending?<br><br>link to video on youtube:  <a href="https://www.youtube.com/watch?v=3YP0Xxxqjrw" target="_blank">https://www.youtube.com/watch?v=3YP0Xxxqjrw</a> <br><br></td></tr></table><br>
<a name="1302993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> For anyone interested in my project.  Here is my latest version:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 1200,900,16 

AppTitle "F1=PrtDetails," + "F2=MovAmt,"+ "F3=Flip," +"F4=Rot," + "F5=RotAmt," + "F6=ZmIn," + "F7-ZmOut," + "F8=CamLft,"+"F9=CamRt," + "F10=CamUP," + "F11=CamDn," + "T=AddTool," + "E=Edit," + "M=Select Item 2 Mov," + "F12=Ram Details,"

Global MyOriginX# = -900;-600
Global MyOriginY# = 400;600
Global MyScale# = 25
Global MachineCenterLineX# = 60
Global MachineCenterLineY# = 0;300
Global ToolHeight# = 2 ;( 2 inch tool height for drawing tool images onto the screen)
Global EditMode = 0
Global SelectedX# =0.0
Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .125
Global ZAxisLeft# = -59.5
Global ZAxisRight# = -58.5
Global XAxisRight# = 0
Global XAxisLeft# = 0
Global MinimumXOfPart = 10000
Global MaximumXofPart = -10000
Global MinimumYOfPart = 10000
Global MaximumYOfPart = -10000
Global PartCenterX# = 10000
Global PartCenterY# = 10000
Global PartFlipped$ = "NO"	;Can be YES or NO
Global PartAngle# = 0


Type MyLines
	Field GraphicType$  ;LINE, CIRCLE, OR ARC
	Field SX#           ;LINE START POINT X
	Field SY#           ;LINE START POINT Y
	Field EX#           ;LINE END POINT X
	Field EY#           ;LINE END POINT Y
	Field SA#           ;ARC START ANGLE
	Field EA#           ;ARC END ANGLE
	Field R#            ;ARC RADIUS
	Field IsBendLine$   ;IS A BEND LINE YES or NO
	Field LColor$       ;LINE COLOR
	Field LName$        ;LINE NAME
	Field Dir$          ;BEND DIRECTION
	Field Angle#        ;BEND ANGLE
	Field BendLength#   ;BEND LENGTH
	Field Punch$        ;PUNCH
	Field Die$          ;Die
	Field ZL#           ;ZLeft
	Field ZR#           ;ZRight
	Field XL#           ;XLeft
	Field XR#           ;XRight
End Type

Type MyTools
	Field ToolNumber$   ;Tool Number
	Field ToolName$     ;Tool Name
	Field ToolLength#   ;Tool Length
	Field ToolLocation# ;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     ;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#
	Field SY#
	Field EX#
	Field EY#
End Type

Type MyRightGage
	Field SX#
	Field SY#
	Field EX#
	Field EY#
End Type

;Let's add a couple tools for testing...
tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "1"
tl\ToolName$ = "MT030017000P"
tl\ToolLength# = 12.000
tl\ToolLocation# = -0.75
tl\Reversed = "NO"

tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "2"
tl\ToolName$ = "MT030095000P"
tl\ToolLength# = 4.000
tl\ToolLocation# = -18.000
tl\Reversed = "NO"

tl.MyTools = New MyTools
tl\ToolNumber$ = "Tool_" + "3"
tl\ToolName$ = "MT030125000P"
tl\ToolLength# = 8.000
tl\ToolLocation# = 12.000
tl\Reversed = "NO"

ImportLeftGage()
ImportRightGage()


fntArial=LoadFont("Calibri",15,False,False,False)
fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 

;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")
;ImportDXFFile ("C:\Temp\junkoriginal4.txt")
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")
;ImportDXFFile ("C:\Temp\junkoriginal7.txt")
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")


;Let's move the gages into view...
ItemToMove$ = "RIGHTGAGE"
MoveGageX(58)

ItemToMove$ = "LEFTGAGE"
MoveGageX(47)

ItemToMove$ = "BOTHGAGES"
MoveGageY(2)

ItemToMove$ = "PART"
MovePartX(47.25)
MovePartY(-10)

; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	If KeyHit(59) Then	;F1
		Select PartDetailsToShow$
			Case "HIGH"
				PartDetailsToShow$ = "MED"
			Case "MED"
				PartDetailsToShow$ = "LOW"
			Case "LOW"
				PartDetailsToShow$ = "HIGH"
		End Select
	End If

	;Let's set the Movement Amount below...
	If KeyHit(60) Then	;F2
		Select MovementAmount#
			Case .125
				MovementAmount# = .5
			Case .5
				MovementAmount# = 1
			Case 1
				MovementAmount# = 6
			Case 6
				MovementAmount# = .125
		End Select
	End If

	;Flip part below...
	If KeyHit(61) Then	;F3
		FlipPart()
	End If
	;Flip part abouve...

	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If

	If KeyHit(63) Then	;(F5)
		Select RotationAmount#
			Case 45
				RotationAmount# = 90
			Case 90
				RotationAmount# = 5
			Case 5
				RotationAmount# = 1
			Default
				RotationAmount# = 45
		End Select
	End If
		
	;Zoom functionality below...
	If KeyDown(64)	;zoom in (F6)
		If MyScale# &lt; 176 Then
			MyScale# = MyScale# + 1
			MyOriginX = MyOriginX - 60	;This keeps the view centered when zooming in/out
		End If
	End If		

	If KeyDown(65)	;zoom out (F7)
		If MyScale - 1 &gt; 8 Then
			MyScale = MyScale - 1
			MyOriginX = MyOriginX + 60	;This keeps the view centered when zooming in/out
		End If
	End If		
	;Zoom functionality above...

	;Move "CAMERA" type functionality below...
	If KeyDown(66) Then ;(F8)	;Move CAM left
		Select ItemToMove$
			Case "PART"
				MyOriginX = MyOriginX - 10
		End Select
	End If
	
	If KeyDown(67) Then ;(F9)	;Move CAM right
		Select ItemToMove$
			Case "PART"
				MyOriginX = MyOriginX + 10
		End Select
	End If
	
	If KeyDown(68) Then ;(F10)	;Move CAM Up
		MyOriginY# = MyOriginY# - 10
	End If
	
	If KeyDown(87) Then ;(F11)	;Move CAM Down
		MyOriginY# = MyOriginY# + 10
	End If
	;Move "CAMERA" type functionality above...

	If KeyHit(88) Then	;(F12)
		Select RamDetailsToShow$
			Case "RAM-All"
				RamDetailsToShow$ = "RAM-Medium"
			Case "RAM-Medium"
				RamDetailsToShow$= "RAM-Low"
			Default
				RamDetailsToShow$ = "RAM-All"
		End Select
	End If

	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	
	;Edit bend lines
	If KeyHit(18) Then	;(E Key)
		EditMode = 1
	End If 
	
	If MouseDown(2) Then	;(right mouse button)
		;let's get the edit line data from the user and update the part
		
		EditMode = 0
	End If
	
	If KeyHit(50) Then	;(M key)
		Select ItemToMove$
			Case "PART"
				ItemToMove$ = "BOTHGAGES"
			Case "BOTHGAGES"
				ItemToMove$ = "LEFTGAGE"
			Case "LEFTGAGE"
				ItemToMove$ = "RIGHTGAGE"
			Case "RIGHTGAGE"
				ItemToMove$ = "TOOLS"
			Default
				ItemToMove$ = "PART"
				
		End Select
	End If
	
	;Move Part around on the screen below...
	If KeyDown(203) ;(Left key)
		Select ItemToMove$
			Case "PART"
				MovePartX(-MovementAmount#)

			Case "BOTHGAGES"
				MoveGageX(-MovementAmount#)

			Case "LEFTGAGE"
				MoveGageX(-MovementAmount#)

			Case "RIGHTGAGE"
				MoveGageX(-MovementAmount#)

			Case "TOOLS"
			
		End Select
	End If
	If KeyDown(205) ;(Right Key)
		Select ItemToMove$
			Case "PART"
				MovePartX(MovementAmount#)
			Case "BOTHGAGES"
				MoveGageX(MovementAmount#)

			Case "LEFTGAGE"
				MoveGageX(MovementAmount#)

			Case "RIGHTGAGE"
				MoveGageX(MovementAmount#)

			Case "TOOLS"
			
		End Select
	End If		
	If KeyDown(200) ;(Up Key)
		Select ItemToMove$
			Case "PART"
				MoveParty(MovementAmount#)
			Case "BOTHGAGES"
				MoveGageY(MovementAmount#)

			Case "LEFTGAGE"
				MoveGageY(MovementAmount#)

			Case "RIGHTGAGE"
				MoveGageY(MovementAmount#)

			Case "TOOLS"
			
		End Select
	End If
	If KeyDown(208) ;(Down Key)
		Select ItemToMove$
			Case "PART"
				MovePartY(-MovementAmount#)
			Case "BOTHGAGES"
				MoveGageY(-MovementAmount#)

			Case "LEFTGAGE"
				MoveGageY(-MovementAmount#)

			Case "RIGHTGAGE"
				MoveGageY(-MovementAmount#)

			Case "TOOLS"
			
		End Select
	End If		
	;Move Part around on the screen above...
	
	;let's put up some information on the screen to let the user know what the various settings are...
	Color 255,255,0
	SetFont fntCourier
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Mov Amount  : " + MovementAmount#
	Text 1, 30, "Rot Amt     : " + RotationAmount#
	Text 1, 45, "Prt Details : " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + ZAxisLeft#
	Text 1, 90, "Z Axis Right: " + ZAxisRight#
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	Text 1, 135,"Zoom        : " + MyScale#
	Text 1, 150,"Part CenterX: " + PartCenterX#
	Text 1, 165,"Part CenterY: " + PartCenterY#
	Text 1, 180,"Prt Flipped?: " + PartFlipped$
	Text 1, 195,"Prt Angle   : " + PartAngle#
	
	SetFont fntArial
		
	If EditMode = 1 Then


		SelectedX# = MouseX()
		SelectedY# = MouseY()
		
		;Let's find the line the user clicks on and edit it...
		For gl.MyLines = Each MyLines
			If Abs(SelectedX# - (MyOriginX# + (gl\SX# + gl\EX#) / 2 * MyScale#)) &lt; 5 And Abs(SelectedY# - (MyOriginY# - (gl\SY# + gl\EY#) / 2 * MyScale)) &lt; 5 Then
				MoveMouse MyOriginX# + (gl\SX# + gl\EX#) / 2 * MyScale#, MyOriginY# - (gl\SY# + gl\EY#) / 2 * MyScale
				
				
				Msg$ = "Line: " + gl\LName$ + ", IsBendLine: " + gl\IsBendLine$ + ", X-Left: " + gl\XL# + ", X-Right: " + gl\XR# + ", Bend Angle: " + gl\Angle$ + ", Bend Direction: " + gl\DIR$ + ", Z-Left: " + gl\ZL# + ", Z-Right: " + gl\ZR#

				
				Text MouseX() + 8, MouseY() -25, Msg$
			
				If MouseHit(1) Then	;Let's get the data from the picked line and put it into a file and show it to the user
					MoveMouse MouseX(), MouseY() + 25
					
					fileout = WriteFile("C:\Temp\EditLine.txt")
					;WriteLine(fileout,"THIS IS THE DATA FROM THE LINE YOU PICKED")
					WriteLine(fileout,"GRAPHIC TYPE         :" + gl\GraphicType$)
					WriteLine(fileout,"LINE NAME            :" + gl\LName$)
					WriteLine(fileout,"START X              :" + gl\SX#)
					WriteLine(fileout,"START Y              :" + gl\SY#)
					WriteLine(fileout,"END X                :" + gl\EX#)
					WriteLine(fileout,"END Y                :" + gl\EY#)
					WriteLine(fileout,"START ANGLE          :" + gl\SA#)
					WriteLine(fileout,"END ANGLE            :" + gl\EA#)
					WriteLine(fileout,"RADIUS               :" + gl\R#)
					WriteLine(fileout,"IS BEND LINE         :" + gl\IsBendLine$)
					WriteLine(fileout,"LINE COLOR           :" + gl\LColor$)
					WriteLine(fileout,"X-LEFT               :" + gl\XL#)
					WriteLine(fileout,"X-RIGHT              :" + gl\XR#)
					WriteLine(fileout,"BEND ANGLE           :" + gl\Angle$)
					WriteLine(fileout,"BEND DIRECTION       :" + gl\DIR$)
					WriteLine(fileout,"BEND LENGTH          :" + gl\BendLength#)		
					WriteLine(fileout,"PUNCH NAME           :" + gl\Punch$)
					WriteLine(fileout,"DIE NAME             :" + gl\Die$)
					WriteLine(fileout,"Z-LEFT               :" + gl\ZL#)
					WriteLine(fileout,"Z-RIGHT              :" + gl\ZR#)
		
					CloseFile(fileout)
					
					ExecFile("C:\Temp\EditLine.txt")
					
				End If			
			End If
		Next
	End If
	
	If EditMode = 1 Then
		Rect MouseX() -4, MouseY() -5, 10, 10, False
	End If
	
	
	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Draw the Ram now...
	DrawRam()

	;Let's draw the tooling now below...
	DrawTooling()
	;Let's draw the tooling now above...

	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#)
				
			Case "CIRCLE"
				If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
					DrawArc(gl\SX#, gl\SY#, 0, 359.5, gl\R#)
				End If
				
			Case "ARC"
				If PartDetailsToShow$ = "HIGH" Then
					DrawArc(gl\SX#, gl\SY#, gl\SA#, gl\EA#, gl\R#)
				End If
		End Select
	Next
	;Let's draw the part now above...

	Flip
	
Wend 

;Now that the program is finished, let's output the data...
OutputData()



Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\R# = R#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "N/A"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\Punch$ = "MT030017000P"
			gl\Die$ = "MT030013000D"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			
			I = I + 1
			
			If MinimumXOfPart &gt; SX# Then
				MinimumXOfPart = SX#
			End If
			If MinimumXOfPart &gt; EX# Then
				MinimumXOfPart = EX#
			End If
			If MaximumXOfPart &lt; SX# Then
				MaximumXOfPart = SX#
			End If
			If MaximumXOfPart &lt; EX# Then
				MaximumXOfPart = EX#
			End If
			
			If MinimumYOfPart &gt; SY# Then
				MinimumYOfPart = SY#
			End If
			If MinimumYOfPart &gt; EY# Then
				MinimumYOfPart = EY#
			End If
			If MaximumYOfPart &lt; SY# Then
				MaximumYOfPart = SY#
			End If
			If MaximumYOfPart &lt; EY# Then
				MaximumYOfPart = EY#
			End If			
			
			
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "CIRCLE"
			gl\LName$ = "CIRCLE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = 999
			gl\EA# = 999
			gl\R# = R#
			gl\IsBendLine$ = "NO"		
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999			

			I = I + 1

		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "ARC"
			gl\LName$ = "ARC_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = 999
			gl\EY# = 999
			gl\SA# = SA#
			gl\EA# = EA#
			gl\R# = R#
			gl\IsBendLine$ = "NO"			
			gl\LColor$ = "N/A"
			gl\DIR$ = "N/A"
			gl\Angle# = 999
			gl\BendLength# = 999
			gl\Punch$ = "N/A"
			gl\Die$ = "N/A"
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999				

			I = I + 1

		End If

	Wend
	CloseFile(File)
	
	
	;Let's calculate the PartCenterX and PartCenterY...
	PartCenterX# = ( MaximumXOfPart - MinimumXOfPart ) / 2
	PartCenterY# = ( MaximumYOfPart - MinimumYOfPart ) / 2
	
End Function


Function DrawLine(SX#, SY#, EX#, EY#)

	Color 0,255,0
	Line MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, MyOriginX# + EX# * MyScale#, MyOriginY# - EY# * MyScale#
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, "&lt;--- " + CalcDistance(SX#, SY#, EX#, EY#)
	;Text MyOriginX + EX# * MyScale + 10, MyOriginY - EY# * MyScale -5, (MyOriginX# + SX# * MyScale#) + ", " + (MyOriginY# - SY# * MyScale#) ;, SY#, EX#, EY#)

End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	;R# = R# * MyScale
	;Oval(MyOriginX# + SX# * MyScale#, MyOriginY# - SY# * MyScale#, R#, R#, 0)
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
	
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	;No ARC command so trying to create an arc by drawing pixels from a center point at a given radius, start angle, and end agle
	Color 0, 255, 0
	SX# = SX# * MyScale
	SY# = SY# * MyScale
	R# = R# * MyScale
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
			SA# = SA# + 2	;.5 will give a more defined arc
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot MyOriginX + SX# + Cos(SA#) * R#, MyOriginY - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend			
		End If
	End If

End Function


Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function DrawRam()
	Color 75, 75, 75

	Select RamDetailsToShow$
		Case "RAM-All"
		
			;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
			Line MyOriginX# + 0, MyOriginY# - MachineCenterLineY#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				Text MyOriginX# + (60 - I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "-" + I
			Next
		
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
		
			;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				Text MyOriginX# + (60 + I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "+" + I
			Next
		Case "RAM-Medium"
			;Draw horizontal line indicating tooling centerline from -60 to 0 or centerline
			Line MyOriginX# + 0, MyOriginY# - MachineCenterLineY#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 - I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				;Text MyOriginX# + (60 - I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "-" + I
			Next
		
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
		
			;Draw horizontal line indicating tooling centerline from 0 or centerline to +60 inches
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY#, MyOriginX# + 120 * MyScale#, MyOriginY# - MachineCenterLineY#
			For I = 1 To 60
				Line MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# + .25 * MyScale#, MyOriginX# + (60 + I) * MyScale, MyOriginY# - MachineCenterLineY# - .25 * MyScale#
				;Text MyOriginX# + (60 + I) * MyScale - 8, MyOriginY# - MachineCenterLineY# + 1 * MyScale#, "+" + I
			Next
		
		Case "RAM-Low"
			;Draw centerline marker on the bed...
			Line MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# + 3 * MyScale#, MyOriginX# + 60 * MyScale, MyOriginY# - MachineCenterLineY# - 3 * MyScale#	
		
	End Select
	
End Function

Function DrawTooling()
	Color 0, 0, 255
	For tl.MyTools = Each MyTools
		Rect ((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - ToolHeight# * MyScale# / 2, tl\ToolLength * MyScale#, ToolHeight# * MyScale#, False)
		Line ((MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY#, (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#) + tl\ToolLength# * MyScale#, MyOriginY# - MachineCenterLineY#)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - ToolHeight# * MyScale# / 2, Mid(tl\ToolName$,4,5)
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 1) * MyScale# / 2, tl\ToolLength#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 2) * MyScale# / 2, tl\ToolLocation#
		Text (MyOriginX# + MachineCenterLineX# * MyScale# + tl\ToolLocation# * MyScale#) - (tl\ToolLength# * MyScale#), MyOriginY# - MachineCenterLineY# - (ToolHeight# - 3) * MyScale# / 2, tl\Reversed$
	Next

End Function

Function DrawGages()
	Color 255, 0, 0
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#)
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#)
	Next
	
End Function

Function MovePartX(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
				
			Case "CIRCLE"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#

			Case "ARC"
				gl\SX = gl\SX# + Amount#
				gl\EX# = gl\EX# + Amount#
			Default
			
		End Select
	Next
	PartCenterX# = PartCenterX# + Amount#

End Function

Function MovePartY(Amount#)
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
				
			Case "CIRCLE"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#

			Case "ARC"
				gl\SY# = gl\SY# + Amount#
				gl\EY# = gl\EY# + Amount#
			Default
			
		End Select
	Next
	PartCenterY# = PartCenterY# + Amount#
End Function

Function MoveGageX(Amount#)
	Select ItemToMove$
		Case "BOTHGAGES"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SX# = lg\SX# + Amount#	
				lg\EX# = lg\EX# + Amount#	
			Next
			For rg.MyRightGage = Each MyRightGage
				rg\SX# = rg\SX# + Amount#	
				rg\EX# = rg\EX# + Amount#	
			Next
			ZAxisLeft# = ZAxisLeft# + Amount#
			ZAxisRight# = ZAxisRight# + Amount#

		Case "LEFTGAGE"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SX# = lg\SX# + Amount#	
				lg\EX# = lg\EX# + Amount#	
			Next		
			ZAxisLeft# = ZAxisLeft# + Amount#

		Case "RIGHTGAGE"
			For rg.MyRightGage = Each MyRightGage
				rg\SX# = rg\SX# + Amount#	
				rg\EX# = rg\EX# + Amount#	
			Next		
			ZAxisRight# = ZAxisRight# + Amount#

	End Select	
End Function

Function MoveGageY(Amount#)
	Bottom# = 0
	If XAxisRight# &lt;= 0 And Amount# &lt; 0Then
		 Bottom# = 1
	End If
	If XAxisLeft# &lt;= 0 And Amount# &lt; 0 Then
		Bottom# = 1
	End If
	If Bottom# &lt;&gt; 1 Then
	Select ItemToMove$
		Case "BOTHGAGES"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SY# = lg\SY# + Amount#	
				lg\EY# = lg\EY# + Amount#	
			Next
			For rg.MyRightGage = Each MyRightGage
				rg\SY# = rg\SY# + Amount#	
				rg\EY# = rg\EY# + Amount#	
			Next
			XAxisLeft# = XAxisLeft# + Amount#
			XAxisRight# = XAxisRight# + Amount#

		Case "LEFTGAGE"
			For lg.MyLeftGage = Each MyLeftGage
				lg\SY# = lg\SY# + Amount#	
				lg\EY# = lg\EY# + Amount#	
			Next		
			XAxisLeft# = ZAxisLeft# + Amount#

		Case "RIGHTGAGE"
			For rg.MyRightGage = Each MyRightGage
				rg\SY# = rg\SY# + Amount#	
				rg\EY# = rg\EY# + Amount#	
			Next		
			XAxisRight# = ZAxisRight# + Amount#

	End Select	
	End If
End Function

Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				
				;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
				Local localSX# = gl\SX - PartCenterX# ;MachineCenterLineX
				Local localSY# = gl\SY - PartCenterY# ;MachineCenterLineY
				
				Local localEX# = gl\EX - PartCenterX# ;PartCenterX# ;MachineCenterLineX
				Local localEY# = gl\EY - PartCenterY# ;PartCenterY# ;MachineCenterLineY
				
				;Rotate this copy by the angle amount.
				Local lineCos# = Cos( Amount )
				Local lineSin# = Sin( Amount )
				
				Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
				Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
				
				Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
				Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
				
				;Change the original segment to have the points of the rotated copy
				;but moved to the position of the original.
				
				gl\SX = newSX + PartCenterX# ;MachineCenterLineX
				gl\SY = newSY + PartCenterY# ;MachineCenterLineY
				
				gl\EX = newEX + PartCenterX# ;MachineCenterLineX
				gl\EY = newEY + PartCenterY# ;MachineCenterLineY				
								
			Case "CIRCLE"
							
				Local clocalSX# = gl\SX - PartCenterX# ;MachineCenterLineX
				Local clocalSY# = gl\SY - PartCenterY# ;MachineCenterLineY
				
				Local clineCos# = Cos( Amount )
				Local clineSin# = Sin( Amount )
				
				Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
				Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
				
				gl\SX = cnewSX + PartCenterX# ;MachineCenterLineX
				gl\SY = cnewSY + PartCenterY# ;MachineCenterLineY
				
				;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
			Case "ARC"
			
				Local alocalSX# = gl\SX - PartCenterX# ;MachineCenterLineX
				Local alocalSY# = gl\SY - PartCenterY# ;MachineCenterLineY
				
				Local alineCos# = Cos( Amount )
				Local alineSin# = Sin( Amount )
				
				Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
				Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
				
				gl\SX = anewSX + PartCenterX# ;MachineCenterLineX
				gl\SY = anewSY + PartCenterY# ;MachineCenterLineY
				
				;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
				
				gl\SA# = ( gl\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
				gl\EA# = ( gl\EA# + Amount# ) Mod 360
							
		End Select
	Next
	
	PartAngle# = PartAngle# + Amount#
	If PartAngle# &gt;= 360 Then
		PartAngle# = PartAngle# - 360
	End If
	
End Function


Function FLipPart()
	;This code has not been started.  I need to mirror the geometry about the vertical axis
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
				
			Case "CIRCLE"
				gl\SX# = gl\SX# * -1

			Case "ARC"
				;Need help with this code.  It is not flipping across the vertical axis correctly
				gl\SX# = gl\SX# * -1
				
				If gl\SA# &lt; gl\EA# Then


				Else
				
				End If
				
				gl\EA# = gl\SA# + 180
				gl\SA# = gl\EA#
			
		End Select
	Next
	
	Select PartFlipped$
		Case "YES"
			PartFlipped$ = "NO"
		Case "NO"
			PartFlipped$ = "YES"
	End Select
	
End Function


Function AddTooling()
	tl.MyTools = New MyTools
	tl\ToolName$ = "MTOXXXXX000P"
	tl\ToolLength =12.000
	tl\ToolLocation = .5
	tl\Reversed = "NO"
End Function


Function OutputData()
	fileout = WriteFile("C:\Temp\mydata.txt")

	WriteLine(fileout, "StartGeometryInformation")
	WriteLine(fileout, "GeometryName,StartX,StartY,EndX,EndY,StartAngle,EndAngle,Radius,IsBendLine,GeometryColor,BendDirection,BendAngle,BendLength,Punch,Die,Z-Left,Z-Right,X-Left,X-Right")
	For gl.MyLines = Each MyLines
		WriteLine(fileout, gl\LName$ + "," + gl\SX# + "," + gl\SY# + "," + gl\EX# + "," + gl\EY# + "," + gl\SA# + "," + gl\EA# + "," + gl\R# + "," + gl\IsBendLine$ + "," + gl\LColor$ + "," + gl\DIR$ + "," + gl\Angle# + "," + CalcDistance(gl\SX#, gl\SY#, gl\EX#, gl\EY#) + "," + gl\Punch$ + "," + gl\Die$ + "," + gl\ZL# + "," + gl\ZR# + "," + gl\XL# + "," + gl\XR#)
	Next
	WriteLine(fileout, "EndGeometryInformation")
	
	WriteLine(fileout, "StartToolingInformation")
	WriteLine(fileout, "ToolNumber,ToolName,ToolLength,ToolLocation,ToolReversed?")
	For tl.MyTools = Each MyTools
		WriteLine(fileout, tl\ToolNumber$ + "," + tl\ToolName$ + "," + tl\ToolLength# + "," + tl\ToolLocation# + "," + tl\Reversed)
	Next
	WriteLine(fileout, "EndToolingInformation")

	CloseFile(fileout)

End Function

Function ImportLeftGage()

	;Below are the coordinates for drawing the gage finger...
	;DrawLine(2.000,0.000,2.000,2.500)
	;DrawLine(2.000,2.500,0.000,2.500)
	;DrawLine(0.000,2.500,0.000,1.000)
	;DrawLine(2.000,0.000,1.750,0.000)
	;DrawLine(1.750,0.000,1.750,0.125)
	;DrawLine(1.750,0.125,0.000,1.000)
	;DrawLine(0.000,1.000,1.000,1.000)
	;DrawLine(1.000,1.000,1.000,2.500)
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 2
	lg\SY# = 0
	lg\EX# = 2
	lg\EY# = 2.5
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 2
	lg\SY# = 2.5
	lg\EX# = 0
	lg\EY# =2.5
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 0
	lg\SY# = 2.5
	lg\EX# = 0
	lg\EY# = 1
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 2
	lg\SY# = 0
	lg\EX# = 1.75
	lg\EY# = 0
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 1.75
	lg\SY# = 0
	lg\EX# = 1.75
	lg\EY# = .125
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 1.75
	lg\SY# = .125
	lg\EX# = 0
	lg\EY# = 1
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 0
	lg\SY# = 1
	lg\EX# = 1
	lg\EY# = 1
	
	lg.MyLeftGage = New MyLeftGage
	lg\SX# = 1
	lg\SY# = 1
	lg\EX# = 1
	lg\EY# = 2.5

End Function

Function ImportRightGage()

	;Below are the coordinates for drawing the gage finger...
	;DrawLine(0.000,0.000,0.000,2.500)
	;DrawLine(0.000,2.500,2.000,2.500)
	;DrawLine(2.000,2.500,2.000,1.000)
	;DrawLine(0.000,0.000,0.250,0.000)
	;DrawLine(0.250,0.000,0.250,0.125)
	;DrawLine(0.250,0.125,2.000,1.000)
	;DrawLine(2.000,1.000,1.000,1.000)
	;DrawLine(1.000,1.000,1.000,2.500)
	
	rg.MyRightGage = New MyRightGage
	rg\SX# = 0
	rg\SY# = 0
	rg\EX# = 0
	rg\EY# = 2.5
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 0
	rg\SY# = 2.5
	rg\EX# = 2
	rg\EY# = 2.5
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 2
	rg\SY# = 2.5
	rg\EX# = 2
	rg\EY# = 1
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 0
	rg\SY# = 0
	rg\EX# = .25
	rg\EY# = 0
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = .25
	rg\SY# = 0
	rg\EX# = .25
	rg\EY# = .125
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = .25
	rg\SY# = .125
	rg\EX# = 2
	rg\EY# = 1
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 2
	rg\SY# = 1
	rg\EX# = 1
	rg\EY# = 1
	
	rg.MyRightGage  = New MyRightGage
	rg\SX# = 1
	rg\SY# = 1
	rg\EX# = 1
	rg\EY# = 2.5

End Function
</textarea> <br><br></td></tr></table><br>
<a name="1303118"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't figure out why my "CAMERA" functionality is not working properly.  If you run the code below and press the F10 or F11 keys, you will see that the graphics do not pan left and right like I want.  It pans at an angle rather than just left and right.  Can anyone find my error or suggest another way to be able to pan left / right?  I am using my Scale value to zoom in and out and that is working fine for me...but I need some way to pan left and right.<br><br>Thanks for any help you can offer,<br><br>Here is the contents of the CAD file for this program...<br>*** copy this data into a text file on C:\Temp\junkoriginal5.txt<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
LINE,0.000,0.125,0.000,11.750
LINE,0.250,12.000,11.500,12.000
LINE,12.000,11.500,12.000,1.000
LINE,11.000,0.000,0.125,0.000
LINE,6.282,6.220,6.817,6.754
LINE,7.414,6.507,7.414,5.938
LINE,6.213,5.600,6.768,4.719
LINE,7.414,5.938,7.414,4.906
LINE,1.637,3.213,3.137,3.213
LINE,4.637,2.213,4.637,1.213
LINE,4.637,1.213,3.137,1.213
LINE,1.637,3.213,1.637,2.213
LINE,3.137,3.213,4.637,2.213
LINE,3.137,1.213,1.637,2.213
LINE,6.970,9.801,8.385,8.386
LINE,9.092,9.093,7.677,10.508
ARC,0.125,0.125,0.125,180.000,270.000
ARC,0.250,11.750,0.250,90.000,180.000
ARC,11.500,11.500,0.500,0.000,90.000
ARC,11.000,1.000,1.000,270.000,0.000
ARC,7.064,6.507,0.350,0.000,135.000
ARC,6.636,5.866,0.500,135.000,212.227
ARC,7.064,4.906,0.350,212.227,0.000
ARC,8.738,8.740,0.500,225.000,45.000
ARC,7.324,10.154,0.500,45.000,225.000
CIRCLE,3.000,8.938,2.500
</textarea><br><br>Here is the main program code...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 900,900,16 

AppTitle "F1=PrtDetails," + "F2=MovAmt,"+ "F3=Flip," +"F4=Rot," + "F5=RotAmt," + "F6=ZmIn," + "F7-ZmOut," + "F8=CamLft,"+"F9=CamRt," + "F10=CamUP," + "F11=CamDn," + "T=AddTool," + "E=Edit," + "M=Select Item 2 Mov," + "F12=Ram Details,"

;Global MyOriginX# = 450
;Global MyOriginY# = 450
Global MyScale# = 5
;Global EditMode = 0
;Global SelectedX# =0.0
;Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .5
Global ZAxisLeft# = 0
Global ZAxisRight# = 0
Global XAxisRight# = 0
Global XAxisLeft# = 0
Global PartLocationX# = 0
Global PartLocationY# = 0
Global MinimumXOfPart# = 10000
Global MaximumXofPart# = -10000
Global MinimumYOfPart# = 10000
Global MaximumYOfPart# = -10000
Global PartCenterX# = 10000
Global PartCenterY# = 10000
Global PartFlipped$ = "NO"	;Can be YES or NO
Global PartAngle# = 0
Global CenterX# = 0 ;18
Global CenterY# = 450
Global ToolWidth# = 1.5
Global ToolCount# = 0

Type MyLines
	Field GraphicType$      ;LINE, CIRCLE, OR ARC
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
	Field IsBendLine$       ;IS A BEND LINE YES or NO
	Field LColor$           ;LINE COLOR
	Field LName$            ;LINE NAME
	Field BendSeqNumber#    ;BEND SEQUENCE NUMBER
	Field Dir$              ;BEND DIRECTION UP or Dn
	Field Angle#            ;BEND ANGLE
	Field BendLength#       ;BEND LENGTH
	Field ZL#               ;ZLeft
	Field ZR#               ;ZRight
	Field XL#               ;XLeft
	Field XR#               ;XRight
	Field InsideBend$	    ;INSIDE BEND DIMENSION INSIDE or OUTSIDE
	Field FO_L#             ;FINGER OFFSET LEFT
	Field FO_R#             ;FINGER OFFSET Right
	Field GageTopOfFinger$  ;GAGE ON TOP OF THE BACKGAGE FINGER ...GAGETOP or GAGENORMAL
End Type

Type MyCircles
	Field GraphicType$      ;CIRCLE
	Field CName$			;CIRCLE NAME
	Field SX#               ;CIRCLE START POINT X
	Field SY#               ;CIRCLE START POINT Y
	Field EX#               ;CIRCLE END POINT X
	Field EY#               ;CIRCLE END POINT Y
	Field R#				;CIRCLE RADIUS

End Type

Type MyArcs
	Field GraphicType$      ;ARC
	Field AName$			;ARC NAME
	Field SX#               ;ARC START POINT X
	Field SY#               ;ARC START POINT Y
	Field SA#				;ARC START ANGLE
	Field EA#				;ARC END ANGLE
	Field R#				;ARC RADIUS
End Type

Type MyTools
	Field Id				;Tool Id
	Field Name$         	;Tool Number
	Field Length#   		;Tool Length
	Field Location# 		;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     	;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyRightGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyBed
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type


;Import Part Data...
;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")	;Lots of holes
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")	;Metric Units
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
;ImportDXFFile ("C:\Temp\junkoriginal9.txt")
ImportDXFFile ("C:\Temp\junkoriginal5.txt")

;Import Gage Data...
ImportGage ("C:\Temp\LeftFinger.txt", "LEFT")
ImportGage ("C:\Temp\RightFinger.txt", "RIGHT")


;Import Bed Data...
ImportBed("C:\Temp\AutoformBed.txt")
ItemToMove$ = "BED"
MoveItem(CenterX#, "X")


;Let's move the items into view...
ItemToMove$ = "RIGHTGAGE"
MoveItem(CenterX# + 12, "X")

ItemToMove$ = "LEFTGAGE"
MoveItem(CenterX# - 12, "X")

ItemToMove$ = "BOTHGAGES"
MoveItem(2, "Y")

ItemToMove$ = "PART"
MoveItem(CenterX# - PartCenterX#, "X")
MoveItem(-PartCenterY# - 12, "Y")


;Let's setup some fonts...
Global fntArial=LoadFont("Calibri",15,False,False,False)
Global fntArialLG= LoadFont("Calibri",25,False,False,False)
LoadFont("Calibri",20,False,False,False)
Global fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 




;Let's add a tool to begin with...
AddTooling()


; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls


	;Let's display some of the various conditions and settings for the user...
	UpdatePositions()
	

	;DrawTooling now...
	DrawTooling()

	;Draw the Ram now...
	DrawBed()


	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now...
	DrawPart()

	;Move items around on the screen below...
	If KeyDown(203) ;(Left key)
		MoveItem(-MovementAmount#, "X")
	End If
	If KeyDown(205) ;(Right Key)
		MoveItem(MovementAmount#, "X")
	End If		
	If KeyDown(200) ;(Up Key)
		MoveItem(MovementAmount#, "Y")
	End If
	If KeyDown(208) ;(Down Key)
		MoveItem(-MovementAmount#, "Y")
	End If		

	;Let the user select what needs to move...
	If KeyHit(50) Then	;(M key)
		SelectItem()
	End If
	
	;Zoom below...
	If KeyDown(64)	;zoom in (F6)
		Zoom(1)
	End If		

	If KeyDown(65)	;zoom out (F7)
		Zoom(-1)
	End If		

	;Let's set the Movement Amount below...
	If KeyHit(60) Then	;F2
		UpdateMovementAmount()
	End If	

	;Let's set the level of details to show on the part, lower selection speeds up part movement
	If KeyHit(59) Then	;F1
		SelectPartDetailLevel()
	End If

	If KeyHit(63) Then	;(F5)
		SelectRotationAmount()
	End If
	
	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If	
	
	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	;Move "CAMERA" type functionality below...
	If KeyDown(66) Then ;(F8)	;Move CAM left
		CenterX# = CenterX# - 10
	End If
	
	If KeyDown(67) Then ;(F9)	;Move CAM right
		CenterX# = CenterX# + 10
	End If

	If KeyDown(68) Then ;(F10)	;Move CAM Up
		CenterY# = CenterY# - 10
	End If
	
	If KeyDown(87) Then ;(F11)	;Move CAM Down
		CenterY# = CenterY# + 10
	End If
	;Move "CAMERA" type functionality above...


	displayToolDetails()

		
	Flip
	
Wend 

Function DrawPart()
	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#, gl\LColor$)
		End Select
	Next
	If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
		For cl.MyCircles = Each MyCircles
			DrawArc(cl\SX#, cl\SY#, 0, 359.5, cl\R#)
		Next
	End If

	If PartDetailsToShow$ = "HIGH" Then
		For al.MyArcs = Each MyArcs
			DrawArc(al\SX#, al\SY#, al\SA#, al\EA#, al\R#)
		Next					
	End If
End Function

Function DrawBed()
	For bg.MyBed = Each MyBed
		DrawLine(bg\SX#, bg\SY#, bg\EX#, bg\EY#, "GRAY")
	Next
End Function

Function MoveItem(Amount#, Direction$)
	Select Direction$
		Case "X"
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SX = gl\SX# + Amount#
						gl\EX# = gl\EX# + Amount#
					Next
					For cl.MyCircles = Each MyCircles
						cl\SX# = cl\SX# + Amount#
						cl\EX# = cl\EX# + Amount#
					Next
					For ga.MyArcs = Each MyArcs
						ga\SX# = ga\SX# + Amount#
					Next
														
					PartCenterX# = PartCenterX# + Amount#
					PartLocationX# = PartLocationX# + Amount#
					
				Case "BOTHGAGES"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next
					ZAxisLeft# = ZAxisLeft# + Amount#
					ZAxisRight# = ZAxisRight# + Amount#
		
				Case "LEFTGAGE"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next		
					ZAxisLeft# = ZAxisLeft# + Amount#
		
				Case "RIGHTGAGE"
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next		
					ZAxisRight# = ZAxisRight# + Amount#

				Case "BED"
					For bg.MyBed = Each MyBed
						bg\SX# = bg\SX# + Amount#	
						bg\EX# = bg\EX# + Amount#	
					Next	
					
				Case "TOOLS"
					For gt.MyTools = Each MyTools
						gt\Location#  = gt\Location# + Amount#	
					Next					
			End Select	
		
		Case "Y"
			BottomL# = 0
			BottomR# = 0
			If XAxisRight# &lt;= 0 And Amount# &lt;= 0 Then
				 BottomR# = 1
			End If
			If XAxisLeft# &lt;= 0 And Amount# &lt;= 0 Then
				BottomL# = 1
			End If
		
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SY# = gl\SY# + Amount#
						gl\EY# = gl\EY# + Amount#
					Next
					
					For gc.MyCircles = Each MyCircles
						gc\SY# = gc\SY# + Amount#
						gc\EY# = gc\EY# + Amount#
					Next
					
					For ga.MyArcs = Each MyArcs
						ga\SY# = ga\SY# + Amount#
					Next
						
					PartCenterY# = PartCenterY# + Amount#
					PartLocationY# = PartLocationY# + Amount#
													
				Case "BOTHGAGES"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next
						XAxisLeft# = XAxisLeft# + Amount#
					End If
		
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next
						XAxisRight# = XAxisRight# + Amount#
					End If
					
				Case "LEFTGAGE"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next		
						XAxisLeft# = XAxisLeft# + Amount#
					End If
					
				Case "RIGHTGAGE"
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next		
						XAxisRight# = XAxisRight# + Amount#
					End If
			End Select	
		
	End Select
		
End Function


Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "GREEN"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			gl\BendSeqNumber# = 1
			gl\InsideBend$ = "OUTSIDE"
			gl\FO_L# = 0
			gl\FO_R# = 0
			gl\GageTopOfFinger$ = "GAGENORMAL"
			
			
			If MinimumXOfPart# &gt; SX# Then
				MinimumXOfPart# = SX#
			End If
			If MinimumXOfPart# &gt; EX# Then
				MinimumXOfPart# = EX#
			End If
			If MaximumXOfPart# &lt; SX# Then
				MaximumXOfPart# = SX#
			End If
			If MaximumXOfPart# &lt; EX# Then
				MaximumXOfPart# = EX#
			End If
			
			If MinimumYOfPart# &gt; SY# Then
				MinimumYOfPart# = SY#
			End If
			If MinimumYOfPart# &gt; EY# Then
				MinimumYOfPart# = EY#
			End If
			If MaximumYOfPart# &lt; SY# Then
				MaximumYOfPart# = SY#
			End If
			If MaximumYOfPart# &lt; EY# Then
				MaximumYOfPart# = EY#
			End If			
			
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gc.MyCircles = New MyCircles
			gc\GraphicType$ = "CIRCLE"
			gc\CName$ = "CIRCLE_" + I
			gc\SX# = SX#
			gc\SY# = SY#
			gc\EX# = 999
			gc\EY# = 999
			gc\R# = R#

		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			ga.MyArcs = New MyArcs
			ga\GraphicType$ = "ARC"
			ga\AName$ = "ARC_" + I
			ga\SX# = SX#
			ga\SY# = SY#
			ga\SA# = SA#
			ga\EA# = EA#
			ga\R# = R#
			
		End If
		
		I = I + 1

	Wend
	CloseFile(File)
	
	
	;Let's calculate the PartCenterX and PartCenterY...
	PartCenterX# = ( MaximumXOfPart# - MinimumXOfPart# ) / 2
	PartCenterY# = ( MaximumYOfPart# - MinimumYOfPart# ) / 2
	
End Function

Function ImportGage(FileName$, LorR$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			If LorR$ = "LEFT" Then
				lg.MyLeftGage = New MyLeftGage
				lg\SX# = SX#
				lg\SY# = SY#
				lg\EX# = EX#
				lg\EY# = EY#
			End If
			If LorR$ = "RIGHT" Then
				rg.MyRightGage = New MyRightGage
				rg\SX# = SX#
				rg\SY# = SY#
				rg\EX# = EX#
				rg\EY# = EY#
			End If

		End If
	Wend
	CloseFile(File)
End Function

Function ImportBed(fileName$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			bg.MyBed = New MyBed
			bg\SX# = SX#
			bg\SY# = SY#
			bg\EX# = EX#
			bg\EY# = EY#
		End If
	Wend
	CloseFile(File)
End Function


Function DrawGages()
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#, "GREEN")
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#, "GREEN")
	Next
End Function

Function DrawLine(SX#, SY#, EX#, EY#, LineColor$)

	Select LineColor$
		Case "GREEN"
			Color 0, 255, 0
		Case "RED"
			Color 255, 0, 0
		Case "YELLOW"
			Color 255, 255, 0
		Case "GRAY"
			Color 75, 75, 75
		Default
			Color 0, 255, 0
	End Select

	Line CenterY# + SX# * MyScale#, CenterY# - SY# * MyScale#, CenterY# + EX# * MyScale#, CenterY# - EY# * MyScale#

End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)

	Color 0, 255, 0
	SX# = SX# * MyScale#
	SY# = SY# * MyScale#
	R# = R# * MyScale#
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot CenterY# + SX# + Cos(SA#) * R#, CenterY# - SY# - Sin(SA#) * R#
			SA# = SA# + 2	;.5 will give a more defined arc
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot CenterY# + SX# + Cos(SA#) * R#, CenterY# - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot CenterY# + SX# + Cos(SA#) * R#, CenterY# - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend			
		End If
	End If

End Function

Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function Zoom(Amount#)
	MyScale# = MyScale# + Amount#
	If MyScale# &lt; 5 Then
		MyScale# = 5
	End If
End Function

Function SelectItem()

	Select ItemToMove$
		Case "PART"
			ItemToMove$ = "BOTHGAGES"
		Case "BOTHGAGES"
			ItemToMove$ = "LEFTGAGE"
		Case "LEFTGAGE"
			ItemToMove$ = "RIGHTGAGE"
		Case "RIGHTGAGE"
			ItemToMove$ = "TOOLS"
		Default
			ItemToMove$ = "PART"
			
	End Select
		
End Function

Function UpdatePositions()
	Color 255,255,0
	SetFont fntCourier
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Move Amount : " + MovementAmount#
	Text 1, 30, "Rotation Amt: " + RotationAmount#
	Text 1, 45, "Part Details: " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + (ZAxisLeft# -CenterX#)
	Text 1, 90, "Z Axis Right: " + (ZAxisRight# - CenterX#)
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	Text 1, 135,"Zoom Level  : " + MyScale#
	Text 1, 150,"Part CenterX: " + PartCenterX#
	Text 1, 165,"Part CenterY: " + PartCenterY#
	Text 1, 180,"Prt Flipped?: " + PartFlipped$
	Text 1, 195,"Part Angle  : " + PartAngle#
	Text 1, 210,"Part Loc X  : " + PartLocationX#
	Text 1, 225,"Part Loc Y  : " + PartLocationY#
	
	SetFont fntArial
	
End Function

Function UpdateMovementAmount()
	Select MovementAmount#
		Case .125
			MovementAmount# = .5
		Case .5
			MovementAmount# = 1
		Case 1
			MovementAmount# = 6
		Case 6
			MovementAmount# = .125
	End Select
End Function

Function SelectPartDetailLevel()
	Select PartDetailsToShow$
		Case "HIGH"
			PartDetailsToShow$ = "MED"
		Case "MED"
			PartDetailsToShow$ = "LOW"
		Case "LOW"
			PartDetailsToShow$ = "HIGH"
	End Select
End Function

Function SelectRotationAmount()
	Select RotationAmount#
		Case 90
			RotationAmount# = 1
		Case 1
			RotationAmount# = 5
		Case 5
			RotationAmount# = 45
		Case 45
			RotationAmount# = 90
		Default
			RotationAmount# = 45
	End Select
End Function

Function GetUserInput$(Msg$)
	ReturnData$ = Input(Msg$)
	Return ReturnData$
End Function


Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
				
		;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
		Local localSX# = gl\SX - PartCenterX#
		Local localSY# = gl\SY - PartCenterY#
		
		Local localEX# = gl\EX - PartCenterX#
		Local localEY# = gl\EY - PartCenterY#
		
		;Rotate this copy by the angle amount.
		Local lineCos# = Cos( Amount )
		Local lineSin# = Sin( Amount )
		
		Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
		Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
		
		Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
		Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
		
		;Change the original segment to have the points of the rotated copy
		;but moved to the position of the original.
		
		gl\SX = newSX + PartCenterX#
		gl\SY = newSY + PartCenterY#
		
		gl\EX = newEX + PartCenterX#
		gl\EY = newEY + PartCenterY#			
	Next
	
	
	For gc.MyCircles = Each MyCircles

		Local clocalSX# = gc\SX - PartCenterX#
		Local clocalSY# = gc\SY - PartCenterY#
		
		Local clineCos# = Cos( Amount )
		Local clineSin# = Sin( Amount )
		
		Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
		Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
		
		gc\SX = cnewSX + PartCenterX#
		gc\SY = cnewSY + PartCenterY#
		
		;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
	Next
	
	For ga.MyArcs = Each MyArcs

		Local alocalSX# = ga\SX - PartCenterX#
		Local alocalSY# = ga\SY - PartCenterY#
		
		Local alineCos# = Cos( Amount )
		Local alineSin# = Sin( Amount )
		
		Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
		Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
		
		ga\SX = anewSX + PartCenterX#
		ga\SY = anewSY + PartCenterY#
		
		;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
		
		ga\SA# = ( ga\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
		ga\EA# = ( ga\EA# + Amount# ) Mod 360
							
	Next
	
	PartAngle# = PartAngle# + Amount#
	If PartAngle# &gt;= 360 Then
		PartAngle# = PartAngle# - 360
	End If
	
End Function


Function AddTooling()

	If ToolCount# = 0 Then
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount
		gt\Name$ = "MT030013000D"
		gt\Length# = 12
		gt\Location# = 0
		gt\Reversed$ = "NO"	
	
	Else

		SetFont fntArialLG
		
		Cls
		Flip
		
		FlushKeys
		Locate 50, 100
		;Local Name$ = GetUserInput("Enter Tool Name like:  MT030013000D...")
	
		FlushKeys
		Locate 50, 125
		;Local Length# = GetUserInput("Enter Tool Length:...")
	
		FlushKeys
		Locate 50, 150
		;Local Location$ = GetUserInput("Enter Tool Location:...")
	
		FlushKeys
		Locate 50, 175
		;Local Reversed$ = "NO"; GetUserInput("Tool Reversed? YES Or NO...")
		
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount#
		gt\Name$ = "MT026073000P";Name$
		gt\Length# = 6
		gt\Location# = (ToolCount# * 8) + ToolCount#
		gt\Reversed$ = "NO";Reversed$
		
		ToolCount# = ToolCount# + 1
		
		SetFont fntArial
		
	End If
	
		
End Function

Function DrawTooling()
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		DrawLine(SX#, SY#, EX#, EY#, "RED")
		DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "RED")
		DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "RED")
		DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "RED")
	Next
End Function

Function DisplayToolDetails()

	SetFont fntCourier
	
	I = 20
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		;Text 200, I, gt\Name$ + ", " + SX# + ",  " + SY# + ",  " + EX# + ",  " + EY# + ", Location:..." + gt\Location# + ", Length:" + gt\Length#
		Text 600, 2, "Tooling Data for debug purposes----------"
		Text 600, I, gt\Name$  + ", Location:-" + gt\Location# + ", Length:-" + gt\Length#
		
		I = I + 25
		;DrawLine(SX#, SY#, EX#, EY#, "RED")
		;DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "RED")
		;DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "RED")
		;DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "RED")
	Next

	SetFont fntArial
	
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1303130"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> In your drawing code you're adding CenterY to all coordinates:<br><pre class=code>Line CenterY# + SX# * MyScale#, CenterY# - SY# * MyScale#, CenterY# + EX# * MyScale#, CenterY# - EY# * MyScale#</pre>The signature of the Line function is Line( x1, y1, x2, y2 ), with all parameters being of integer type. <br><br></td></tr></table><br>
<a name="1303147"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I added the CenterY# so that my drawing would appear in the middle of the screen.  When I remove the CenterY#, the drawing goes off screen to the upper left corner.  Do you know how I can fix it?<br><br>latest version of code here...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 900,900,16 

AppTitle "F1=PrtDet," + "F2=MovAmt," +"F4=Rot," + "F5=RotAmt," + "F8=CamLft,"+"F9=CamRt," + "F10=CamUP," + "F11=CamDN," + "T=AddTl," + "M=Sel Item 2 Mov"

Global MyScale# = 5
;Global EditMode = 0
;Global SelectedX# =0.0
;Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .5
Global ZAxisLeft# = 0
Global ZAxisRight# = 0
Global XAxisRight# = 0
Global XAxisLeft# = 0
Global PartLocationX# = 0
Global PartLocationY# = 0
Global MinimumXOfPart# = 10000
Global MaximumXofPart# = -10000
Global MinimumYOfPart# = 10000
Global MaximumYOfPart# = -10000
Global PartCenterX# = 10000
Global PartCenterY# = 10000
Global PartFlipped$ = "NO"	;Can be YES or NO
Global PartAngle# = 0
Global CenterX# = 0 ;18
Global CenterY# = 450;450
Global ToolWidth# = 1.5
Global ToolCount# = 0

Type MyLines
	Field GraphicType$      ;LINE, CIRCLE, OR ARC
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
	Field IsBendLine$       ;IS A BEND LINE YES or NO
	Field LColor$           ;LINE COLOR
	Field LName$            ;LINE NAME
	Field BendSeqNumber#    ;BEND SEQUENCE NUMBER
	Field Dir$              ;BEND DIRECTION UP or Dn
	Field Angle#            ;BEND ANGLE
	Field BendLength#       ;BEND LENGTH
	Field ZL#               ;ZLeft
	Field ZR#               ;ZRight
	Field XL#               ;XLeft
	Field XR#               ;XRight
	Field InsideBend$	    ;INSIDE BEND DIMENSION INSIDE or OUTSIDE
	Field FO_L#             ;FINGER OFFSET LEFT
	Field FO_R#             ;FINGER OFFSET Right
	Field GageTopOfFinger$  ;GAGE ON TOP OF THE BACKGAGE FINGER ...GAGETOP or GAGENORMAL
End Type

Type MyCircles
	Field GraphicType$      ;CIRCLE
	Field CName$			;CIRCLE NAME
	Field SX#               ;CIRCLE START POINT X
	Field SY#               ;CIRCLE START POINT Y
	Field EX#               ;CIRCLE END POINT X
	Field EY#               ;CIRCLE END POINT Y
	Field R#				;CIRCLE RADIUS

End Type

Type MyArcs
	Field GraphicType$      ;ARC
	Field AName$			;ARC NAME
	Field SX#               ;ARC START POINT X
	Field SY#               ;ARC START POINT Y
	Field SA#				;ARC START ANGLE
	Field EA#				;ARC END ANGLE
	Field R#				;ARC RADIUS
End Type

Type MyTools
	Field Id				;Tool Id
	Field Name$         	;Tool Number
	Field Length#   		;Tool Length
	Field Location# 		;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     	;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyRightGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyBed
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type


;Import Part Data...
;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")	;Lots of holes
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")	;Metric Units
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
;ImportDXFFile ("C:\Temp\junkoriginal9.txt")
;ImportDXFFile ("C:\Temp\junkoriginal5.txt")

;For testing, I am going to write this 2D CAD data to a text file on c:\tempjunkoriginal.txt"
fileout = WriteFile("C:\Temp\Test_2D_DXF_CAD_Data.txt")
	WriteLine(fileout, "Line,0.000,0.125,0.000,11.750")
	WriteLine(fileout, "Line,0.250,12.000,11.500,12.000")
	WriteLine(fileout, "Line,12.000,11.500,12.000,1.000")
	WriteLine(fileout, "Line,11.000,0.000,0.125,0.000")
	WriteLine(fileout, "Line,6.282,6.220,6.817,6.754")
	WriteLine(fileout, "Line,7.414,6.507,7.414,5.938")
	WriteLine(fileout, "Line,6.213,5.600,6.768,4.719")
	WriteLine(fileout, "Line,7.414,5.938,7.414,4.906")
	WriteLine(fileout, "Line,1.637,3.213,3.137,3.213")
	WriteLine(fileout, "Line,4.637,2.213,4.637,1.213")
	WriteLine(fileout, "Line,4.637,1.213,3.137,1.213")
	WriteLine(fileout, "Line,1.637,3.213,1.637,2.213")
	WriteLine(fileout, "Line,3.137,3.213,4.637,2.213")
	WriteLine(fileout, "Line,3.137,1.213,1.637,2.213")
	WriteLine(fileout, "Line,6.970,9.801,8.385,8.386")
	WriteLine(fileout, "Line,9.092,9.093,7.677,10.508")
	WriteLine(fileout, "ARC,0.125,0.125,0.125,180.000,270.000")
	WriteLine(fileout, "ARC,0.250,11.750,0.250,90.000,180.000")
	WriteLine(fileout, "ARC,11.500,11.500,0.500,0.000,90.000")
	WriteLine(fileout, "ARC,11.000,1.000,1.000,270.000,0.000")
	WriteLine(fileout, "ARC,7.064,6.507,0.350,0.000,135.000")
	WriteLine(fileout, "ARC,6.636,5.866,0.500,135.000,212.227")
	WriteLine(fileout, "ARC,7.064,4.906,0.350,212.227,0.000")
	WriteLine(fileout, "ARC,8.738,8.740,0.500,225.000,45.000")
	WriteLine(fileout, "ARC,7.324,10.154,0.500,45.000,225.000")
	WriteLine(fileout, "CIRCLE,3.000,8.938,2.500")
CloseFile(fileout)

ImportDXFFile ("C:\Temp\Test_2D_DXF_CAD_Data.txt")



;Import Gage Data...
;For testing, I am going to write this Left Gage data to a text file on c:\temp\leftfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,0.125,0.000,0.125,2.500")
	WriteLine(fileout, "Line,0.125,2.500,-1.875,2.500")
	WriteLine(fileout, "Line,-1.875,2.500,-1.875,1.000")
	WriteLine(fileout, "Line,0.125,0.000,-0.125,0.000")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,0.125")
	WriteLine(fileout, "Line,-0.125,0.125,-1.875,1.000")
	WriteLine(fileout, "Line,-1.875,1.000,-0.875,1.000")
	WriteLine(fileout, "Line,-0.875,1.000,-0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\LeftFinger.txt", "LEFT")


;For testing, I am going to write this Right Gage data to a text file on c:\temp\rightfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,2.500")
	WriteLine(fileout, "Line,-0.125,2.500,1.875,2.500")
	WriteLine(fileout, "Line,1.875,2.500,1.875,1.000")
	WriteLine(fileout, "Line,-0.125,0.000,0.125,0.000")
	WriteLine(fileout, "Line,0.125,0.000,0.125,0.125")
	WriteLine(fileout, "Line,0.125,0.125,1.875,1.000")
	WriteLine(fileout, "Line,1.875,1.000,0.875,1.000")
	WriteLine(fileout, "Line,0.875,1.000,0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\RightFinger.txt", "RIGHT")


;Import Bed Data...
ImportBed("C:\Temp\AutoformBed.txt")
ItemToMove$ = "BED"
MoveItem(CenterX#, "X")


;Let's move the items into view...
ItemToMove$ = "RIGHTGAGE"
MoveItem(CenterX# + 12, "X")

ItemToMove$ = "LEFTGAGE"
MoveItem(CenterX# - 12, "X")

ItemToMove$ = "BOTHGAGES"
MoveItem(2, "Y")

ItemToMove$ = "PART"
MoveItem(CenterX# - PartCenterX#, "X")
MoveItem(-PartCenterY# - 12, "Y")


;Let's setup some fonts...
Global fntArial=LoadFont("Calibri",15,False,False,False)
Global fntArialLG= LoadFont("Calibri",25,False,False,False)
LoadFont("Calibri",20,False,False,False)
Global fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 




;Let's add a tool to begin with...
AddTooling()


; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	Text 300, 10, "Mousewheel to zoom in and out"

	;Let's display some of the various conditions and settings for the user...
	UpdatePositions()
	

	;DrawTooling now...
	DrawTooling()

	;Draw the Ram now...
	DrawBed()


	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now...
	DrawPart()

	;Move items around on the screen below...
	If KeyDown(203) ;(Left key)
		MoveItem(-MovementAmount#, "X")
	End If
	If KeyDown(205) ;(Right Key)
		MoveItem(MovementAmount#, "X")
	End If		
	If KeyDown(200) ;(Up Key)
		MoveItem(MovementAmount#, "Y")
	End If
	If KeyDown(208) ;(Down Key)
		MoveItem(-MovementAmount#, "Y")
	End If		

	;Let the user select what needs to move...
	If KeyHit(50) Then	;(M key)
		SelectItem()
	End If
	
	;Let's set the Movement Amount below...
	If KeyHit(60) Then	;F2
		UpdateMovementAmount()
	End If	

	;Let's set the level of details to show on the part, lower selection speeds up part movement
	If KeyHit(59) Then	;F1
		SelectPartDetailLevel()
	End If

	If KeyHit(63) Then	;(F5)
		SelectRotationAmount()
	End If
	
	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If	
	
	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	;Move "CAMERA" type functionality below...
	If KeyDown(66) Then ;(F8)	;Move CAM left
		CenterX# = CenterX# - 10
	End If
	
	If KeyDown(67) Then ;(F9)	;Move CAM right
		CenterX# = CenterX# + 10
	End If

	If KeyDown(68) Then ;(F10)	;Move CAM Up
		CenterY# = CenterY# - 10
	End If
	
	If KeyDown(87) Then ;(F11)	;Move CAM Down
		CenterY# = CenterY# + 10
	End If
	;Move "CAMERA" type functionality above...


	;Disply tooling details to the user...
	DisplayToolDetails()

	
	;Let's use the mousewheel to zoom in / out...
	If MouseZ() &lt;&gt; SaveMouseZ# Then
		If MouseZ() &gt; SaveMouseZ# Then
			Zoom(-3)
		Else
			Zoom(3)
		End If
		SaveMouseZ# = MouseZ()
	End If


	;Let's use the mouse to move items on the screen...
	If MouseDown(1) And KeyDown(29) Then
		MoveItem(-MovementAmount#, "X")
	End If
	If MouseDown(2) And KeyDown(29) Then
		MoveItem(MovementAmount#, "X")
	End If
	



	
	Flip
	
Wend 

Function DrawPart()
	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#, gl\LColor$)
		End Select
	Next
	If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
		For cl.MyCircles = Each MyCircles
			DrawArc(cl\SX#, cl\SY#, 0, 359.5, cl\R#)
		Next
	End If

	If PartDetailsToShow$ = "HIGH" Then
		For al.MyArcs = Each MyArcs
			DrawArc(al\SX#, al\SY#, al\SA#, al\EA#, al\R#)
		Next					
	End If
End Function

Function DrawBed()
	For bg.MyBed = Each MyBed
		DrawLine(bg\SX#, bg\SY#, bg\EX#, bg\EY#, "GRAY")
	Next
End Function

Function MoveItem(Amount#, Direction$)
	Select Direction$
		Case "X"
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SX# = gl\SX# + Amount#
						gl\EX# = gl\EX# + Amount#
					Next
					For cl.MyCircles = Each MyCircles
						cl\SX# = cl\SX# + Amount#
						cl\EX# = cl\EX# + Amount#
					Next
					For ga.MyArcs = Each MyArcs
						ga\SX# = ga\SX# + Amount#
					Next
														
					PartCenterX# = PartCenterX# + Amount#
					PartLocationX# = PartLocationX# + Amount#
					
				Case "BOTHGAGES"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next
					ZAxisLeft# = ZAxisLeft# + Amount#
					ZAxisRight# = ZAxisRight# + Amount#
		
				Case "LEFTGAGE"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next		
					ZAxisLeft# = ZAxisLeft# + Amount#
		
				Case "RIGHTGAGE"
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next		
					ZAxisRight# = ZAxisRight# + Amount#

				Case "BED"
					For bg.MyBed = Each MyBed
						bg\SX# = bg\SX# + Amount#	
						bg\EX# = bg\EX# + Amount#	
					Next	
					
				Case "TOOLS"
					For gt.MyTools = Each MyTools
						gt\Location#  = gt\Location# + Amount#	
					Next					
			End Select	
		
		Case "Y"
			BottomL# = 0
			BottomR# = 0
			If XAxisRight# &lt;= 0 And Amount# &lt;= 0 Then
				 BottomR# = 1
			End If
			If XAxisLeft# &lt;= 0 And Amount# &lt;= 0 Then
				BottomL# = 1
			End If
		
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SY# = gl\SY# + Amount#
						gl\EY# = gl\EY# + Amount#
					Next
					
					For gc.MyCircles = Each MyCircles
						gc\SY# = gc\SY# + Amount#
						gc\EY# = gc\EY# + Amount#
					Next
					
					For ga.MyArcs = Each MyArcs
						ga\SY# = ga\SY# + Amount#
					Next
						
					PartCenterY# = PartCenterY# + Amount#
					PartLocationY# = PartLocationY# + Amount#
													
				Case "BOTHGAGES"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next
						XAxisLeft# = XAxisLeft# + Amount#
					End If
		
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next
						XAxisRight# = XAxisRight# + Amount#
					End If
					
				Case "LEFTGAGE"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next		
						XAxisLeft# = XAxisLeft# + Amount#
					End If
					
				Case "RIGHTGAGE"
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next		
						XAxisRight# = XAxisRight# + Amount#
					End If
			End Select	
		
	End Select
		
End Function


Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "GREEN"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			gl\BendSeqNumber# = 1
			gl\InsideBend$ = "OUTSIDE"
			gl\FO_L# = 0
			gl\FO_R# = 0
			gl\GageTopOfFinger$ = "GAGENORMAL"
			
			
			If MinimumXOfPart# &gt; SX# Then
				MinimumXOfPart# = SX#
			End If
			If MinimumXOfPart# &gt; EX# Then
				MinimumXOfPart# = EX#
			End If
			If MaximumXOfPart# &lt; SX# Then
				MaximumXOfPart# = SX#
			End If
			If MaximumXOfPart# &lt; EX# Then
				MaximumXOfPart# = EX#
			End If
			
			If MinimumYOfPart# &gt; SY# Then
				MinimumYOfPart# = SY#
			End If
			If MinimumYOfPart# &gt; EY# Then
				MinimumYOfPart# = EY#
			End If
			If MaximumYOfPart# &lt; SY# Then
				MaximumYOfPart# = SY#
			End If
			If MaximumYOfPart# &lt; EY# Then
				MaximumYOfPart# = EY#
			End If			
			
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gc.MyCircles = New MyCircles
			gc\GraphicType$ = "CIRCLE"
			gc\CName$ = "CIRCLE_" + I
			gc\SX# = SX#
			gc\SY# = SY#
			gc\EX# = 999
			gc\EY# = 999
			gc\R# = R#

		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			ga.MyArcs = New MyArcs
			ga\GraphicType$ = "ARC"
			ga\AName$ = "ARC_" + I
			ga\SX# = SX#
			ga\SY# = SY#
			ga\SA# = SA#
			ga\EA# = EA#
			ga\R# = R#
			
		End If
		
		I = I + 1

	Wend
	CloseFile(File)
	
	
	;Let's calculate the PartCenterX and PartCenterY...
	PartCenterX# = ( MaximumXOfPart# - MinimumXOfPart# ) / 2
	PartCenterY# = ( MaximumYOfPart# - MinimumYOfPart# ) / 2
	
End Function

Function ImportGage(FileName$, LorR$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			If LorR$ = "LEFT" Then
				lg.MyLeftGage = New MyLeftGage
				lg\SX# = SX#
				lg\SY# = SY#
				lg\EX# = EX#
				lg\EY# = EY#
			End If
			If LorR$ = "RIGHT" Then
				rg.MyRightGage = New MyRightGage
				rg\SX# = SX#
				rg\SY# = SY#
				rg\EX# = EX#
				rg\EY# = EY#
			End If

		End If
	Wend
	CloseFile(File)
End Function

Function ImportBed(fileName$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			bg.MyBed = New MyBed
			bg\SX# = SX#
			bg\SY# = SY#
			bg\EX# = EX#
			bg\EY# = EY#
		End If
	Wend
	CloseFile(File)
End Function


Function DrawGages()
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#, "GREEN")
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#, "GREEN")
	Next
End Function

Function DrawLine(SX#, SY#, EX#, EY#, LineColor$)

	Select LineColor$
		Case "GREEN"
			Color 0, 255, 0
		Case "RED"
			Color 255, 0, 0
		Case "YELLOW"
			Color 255, 255, 0
		Case "GRAY"
			Color 75, 75, 75
		Case "BLUE"
			Color 0, 0, 255
		Default
			Color 0, 255, 0
	End Select

	;Line CenterY# + SX# * MyScale#, CenterY# - SY# * MyScale#, CenterY# + EX# * MyScale#, CenterY# - EY# * MyScale#
	Line SX# * MyScale#, SY# * MyScale#, EX# * MyScale#, EY# * MyScale#

End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)

	Color 0, 255, 0
	SX# = SX# * MyScale#
	SY# = SY# * MyScale#
	R# = R# * MyScale#
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			;Plot CenterY# + SX# + Cos(SA#) * R#, CenterY# - SY# - Sin(SA#) * R#
			Plot SX# + Cos(SA#) * R#, SY# - Sin(SA#) * R#
			SA# = SA# + 2	;.5 will give a more defined arc
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				;Plot CenterY# + SX# + Cos(SA#) * R#, CenterY# - SY# - Sin(SA#) * R#
				Plot SX# + Cos(SA#) * R#, SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				;Plot CenterY# + SX# + Cos(SA#) * R#, CenterY# - SY# - Sin(SA#) * R#
				Plot SX# + Cos(SA#) * R#, SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend			
		End If
	End If

End Function

Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function Zoom(Amount#)
	MyScale# = MyScale# + Amount#
	If MyScale# &lt; 5 Then
		MyScale# = 5
	End If
End Function

Function SelectItem()

	Select ItemToMove$
		Case "PART"
			ItemToMove$ = "BOTHGAGES"
		Case "BOTHGAGES"
			ItemToMove$ = "LEFTGAGE"
		Case "LEFTGAGE"
			ItemToMove$ = "RIGHTGAGE"
		Case "RIGHTGAGE"
			ItemToMove$ = "TOOLS"
		Default
			ItemToMove$ = "PART"
			
	End Select
		
End Function

Function UpdatePositions()
	Color 255,255,0
	SetFont fntCourier
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Move Amount : " + MovementAmount#
	Text 1, 30, "Rotation Amt: " + RotationAmount#
	Text 1, 45, "Part Details: " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + (ZAxisLeft# -CenterX#)
	Text 1, 90, "Z Axis Right: " + (ZAxisRight# - CenterX#)
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	Text 1, 135,"Zoom Level  : " + MyScale#
	Text 1, 150,"Part CenterX: " + PartCenterX#
	Text 1, 165,"Part CenterY: " + PartCenterY#
	Text 1, 180,"Prt Flipped?: " + PartFlipped$
	Text 1, 195,"Part Angle  : " + PartAngle#
	Text 1, 210,"Part Loc X  : " + PartLocationX#
	Text 1, 225,"Part Loc Y  : " + PartLocationY#
	
	SetFont fntArial
	
End Function

Function UpdateMovementAmount()
	Select MovementAmount#
		Case .125
			MovementAmount# = .5
		Case .5
			MovementAmount# = 1
		Case 1
			MovementAmount# = 6
		Case 6
			MovementAmount# = .125
	End Select
End Function

Function SelectPartDetailLevel()
	Select PartDetailsToShow$
		Case "HIGH"
			PartDetailsToShow$ = "MED"
		Case "MED"
			PartDetailsToShow$ = "LOW"
		Case "LOW"
			PartDetailsToShow$ = "HIGH"
	End Select
End Function

Function SelectRotationAmount()
	Select RotationAmount#
		Case 90
			RotationAmount# = 1
		Case 1
			RotationAmount# = 5
		Case 5
			RotationAmount# = 45
		Case 45
			RotationAmount# = 90
		Default
			RotationAmount# = 45
	End Select
End Function

Function GetUserInput$(Msg$)
	ReturnData$ = Input(Msg$)
	Return ReturnData$
End Function


Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
				
		;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
		Local localSX# = gl\SX - PartCenterX#
		Local localSY# = gl\SY - PartCenterY#
		
		Local localEX# = gl\EX - PartCenterX#
		Local localEY# = gl\EY - PartCenterY#
		
		;Rotate this copy by the angle amount.
		Local lineCos# = Cos( Amount )
		Local lineSin# = Sin( Amount )
		
		Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
		Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
		
		Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
		Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
		
		;Change the original segment to have the points of the rotated copy
		;but moved to the position of the original.
		
		gl\SX = newSX + PartCenterX#
		gl\SY = newSY + PartCenterY#
		
		gl\EX = newEX + PartCenterX#
		gl\EY = newEY + PartCenterY#			
	Next
	
	
	For gc.MyCircles = Each MyCircles

		Local clocalSX# = gc\SX - PartCenterX#
		Local clocalSY# = gc\SY - PartCenterY#
		
		Local clineCos# = Cos( Amount )
		Local clineSin# = Sin( Amount )
		
		Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
		Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
		
		gc\SX = cnewSX + PartCenterX#
		gc\SY = cnewSY + PartCenterY#
		
		;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
	Next
	
	For ga.MyArcs = Each MyArcs

		Local alocalSX# = ga\SX - PartCenterX#
		Local alocalSY# = ga\SY - PartCenterY#
		
		Local alineCos# = Cos( Amount )
		Local alineSin# = Sin( Amount )
		
		Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
		Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
		
		ga\SX = anewSX + PartCenterX#
		ga\SY = anewSY + PartCenterY#
		
		;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
		
		ga\SA# = ( ga\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
		ga\EA# = ( ga\EA# + Amount# ) Mod 360
							
	Next
	
	PartAngle# = PartAngle# + Amount#
	If PartAngle# &gt;= 360 Then
		PartAngle# = PartAngle# - 360
	End If
	
End Function


Function AddTooling()

	If ToolCount# = 0 Then
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount
		gt\Name$ = "MT030013000D"
		gt\Length# = 12
		gt\Location# = 0
		gt\Reversed$ = "NO"	
	
	Else

		SetFont fntArialLG
		
		Cls
		Flip
		
		FlushKeys
		Locate 50, 100
		;Local Name$ = GetUserInput("Enter Tool Name like:  MT030013000D...")
	
		FlushKeys
		Locate 50, 125
		;Local Length# = GetUserInput("Enter Tool Length:...")
	
		FlushKeys
		Locate 50, 150
		;Local Location$ = GetUserInput("Enter Tool Location:...")
	
		FlushKeys
		Locate 50, 175
		;Local Reversed$ = "NO"; GetUserInput("Tool Reversed? YES Or NO...")
		
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount#
		gt\Name$ = "MT026073000P";Name$
		gt\Length# = 6
		gt\Location# = (ToolCount# * 8) + ToolCount#
		gt\Reversed$ = "NO";Reversed$
		
		ToolCount# = ToolCount# + 1
		
		SetFont fntArial
		
	End If
	
		
End Function

Function DrawTooling()
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		DrawLine(SX#, SY#, EX#, EY#, "BLUE")
		DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "BLUE")
		DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "BLUE")
		DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "BLUE")
	Next
End Function

Function DisplayToolDetails()

	SetFont fntCourier
	
	I = 20
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		;Text 200, I, gt\Name$ + ", " + SX# + ",  " + SY# + ",  " + EX# + ",  " + EY# + ", Location:..." + gt\Location# + ", Length:" + gt\Length#
		Text 600, 2, "Tooling Data for debug purposes----------"
		Text 600, I, gt\Name$  + ", Location:" + gt\Location# + ", Length:" + gt\Length#
		
		I = I + 25
		;DrawLine(SX#, SY#, EX#, EY#, "RED")
		;DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "RED")
		;DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "RED")
		;DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "RED")
	Next

	SetFont fntArial
	
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1303150"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon...<br>I forgot to say Thanks, so...Thanks again for the help.<br><br>Next things I need to implement:<br><br>*** I need to be able to click on 2 lines and add a new line that is parallel and exactly in between the 2 lines picked<br><br>*** I need to be able to click on 2 lines and display a vertical distance, if lines are horizontal, or a horizontal distance if the 2 lines are vertical.<br><br>*** I need to click on a line on the part, rotate it to horizontal, then move the part up to the centerline of the "bed" or centerscreen.<br><br>*** I need to be able to click on a line and edit the properties of the line, like BendDirection, Angle, X, Z, settings, etc.<br><br>*** I need to be able to capture all of the positions for the gages, tooling, part and save them somehow and be able to recall them and "play" them back.  Example:  The part is a sheet metal part that can have 1 or more bends.  For each bend, I will position the tooling, part and gages.  After positioning these things for bend 1, I will save the data and move on to the next bend.  Once all of the bends have been processed, I will want to recall the data for each bend and play them back on the screen.  Finally, when the user is satisfied, all of the data for all of the bends will be exported out so that I can massage it to make a program that will be used at our pressbrake to do the actual physical bending. <br><br></td></tr></table><br>
<a name="1303206"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Zooming and panning problem is better now.  I discovered the Origin command and that seems to have helped me out.  I still think I have something wrong but it seems to work so I am marching forward.<br><br>If you have ideas or suggestions that would improve what I am doing, please let me know.<br><br>I am starting to work on the code to save the bend data the user has entered and be able to read it back in and "play" all of the movements.<br><br>Is there a SPLIT command in Blitz like in VBA or VB?  This would help me a bunch reading comma separated data back into Blitz without having to parse all of the data with my code.<br><br><br>latest version of code is below...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 900,900,16 

AppTitle "F1=PrtDet," + "F2=MovAmt," +"F4=Rot," + "F5=RotAmt," + "F8=CamLft,"+"F9=CamRt," + "F10=CamUP," + "F11=CamDN," + "T=AddTl," + "M=Sel Item 2 Mov"
Global PanZoomX# = GraphicsWidth() / 2
Global PanZoomY# = GraphicsHeight() / 2  

Global MyScale# = 10
Global EditMode = 0
Global SelectedX# =0.0
Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .5
Global ZAxisLeft# = 0
Global ZAxisRight# = 0
Global XAxisRight# = 0
Global XAxisLeft# = 0
Global PartLocationX# = 0
Global PartLocationY# = 0
Global MinimumXOfPart# = 10000
Global MaximumXofPart# = -10000
Global MinimumYOfPart# = 10000
Global MaximumYOfPart# = -10000
Global PartCenterX# = 10000
Global PartCenterY# = 10000
Global PartFlipped$ = "NO"	;Can be YES or NO
Global PartAngle# = 0
Global CenterX# = 0
Global CenterY# = 0
Global ToolWidth# = 1.5
Global ToolCount# = 0

Type MyLines
	Field GraphicType$      ;LINE, CIRCLE, OR ARC
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
	Field IsBendLine$       ;IS A BEND LINE YES or NO
	Field LColor$           ;LINE COLOR
	Field LName$            ;LINE NAME
	Field BendSeqNumber#    ;BEND SEQUENCE NUMBER
	Field Dir$              ;BEND DIRECTION UP or Dn
	Field Angle#            ;BEND ANGLE
	Field BendLength#       ;BEND LENGTH
	Field ZL#               ;ZLeft
	Field ZR#               ;ZRight
	Field XL#               ;XLeft
	Field XR#               ;XRight
	Field InsideBend$	    ;INSIDE BEND DIMENSION INSIDE or OUTSIDE
	Field FO_L#             ;FINGER OFFSET LEFT
	Field FO_R#             ;FINGER OFFSET Right
	Field GageTopOfFinger$  ;GAGE ON TOP OF THE BACKGAGE FINGER ...GAGETOP or GAGENORMAL
End Type

Type MyCircles
	Field GraphicType$      ;CIRCLE
	Field CName$			;CIRCLE NAME
	Field SX#               ;CIRCLE START POINT X
	Field SY#               ;CIRCLE START POINT Y
	Field EX#               ;CIRCLE END POINT X
	Field EY#               ;CIRCLE END POINT Y
	Field R#				;CIRCLE RADIUS

End Type

Type MyArcs
	Field GraphicType$      ;ARC
	Field AName$			;ARC NAME
	Field SX#               ;ARC START POINT X
	Field SY#               ;ARC START POINT Y
	Field SA#				;ARC START ANGLE
	Field EA#				;ARC END ANGLE
	Field R#				;ARC RADIUS
End Type

Type MyTools
	Field Id				;Tool Id
	Field Name$         	;Tool Number
	Field Length#   		;Tool Length
	Field Location# 		;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     	;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyRightGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyBed
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type


;Import Part Data...
;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")	;Lots of holes
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")	;Metric Units
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
;ImportDXFFile ("C:\Temp\junkoriginal9.txt")
;ImportDXFFile ("C:\Temp\junkoriginal5.txt")

;For testing, I am going to write this 2D CAD data to a text file on c:\tempjunkoriginal.txt"
fileout = WriteFile("C:\Temp\Test_2D_DXF_CAD_Data.txt")
	WriteLine(fileout, "Line,0.000,0.125,0.000,11.750")
	WriteLine(fileout, "Line,0.250,12.000,11.500,12.000")
	WriteLine(fileout, "Line,12.000,11.500,12.000,1.000")
	WriteLine(fileout, "Line,11.000,0.000,0.125,0.000")
	WriteLine(fileout, "Line,6.282,6.220,6.817,6.754")
	WriteLine(fileout, "Line,7.414,6.507,7.414,5.938")
	WriteLine(fileout, "Line,6.213,5.600,6.768,4.719")
	WriteLine(fileout, "Line,7.414,5.938,7.414,4.906")
	WriteLine(fileout, "Line,1.637,3.213,3.137,3.213")
	WriteLine(fileout, "Line,4.637,2.213,4.637,1.213")
	WriteLine(fileout, "Line,4.637,1.213,3.137,1.213")
	WriteLine(fileout, "Line,1.637,3.213,1.637,2.213")
	WriteLine(fileout, "Line,3.137,3.213,4.637,2.213")
	WriteLine(fileout, "Line,3.137,1.213,1.637,2.213")
	WriteLine(fileout, "Line,6.970,9.801,8.385,8.386")
	WriteLine(fileout, "Line,9.092,9.093,7.677,10.508")
	WriteLine(fileout, "ARC,0.125,0.125,0.125,180.000,270.000")
	WriteLine(fileout, "ARC,0.250,11.750,0.250,90.000,180.000")
	WriteLine(fileout, "ARC,11.500,11.500,0.500,0.000,90.000")
	WriteLine(fileout, "ARC,11.000,1.000,1.000,270.000,0.000")
	WriteLine(fileout, "ARC,7.064,6.507,0.350,0.000,135.000")
	WriteLine(fileout, "ARC,6.636,5.866,0.500,135.000,212.227")
	WriteLine(fileout, "ARC,7.064,4.906,0.350,212.227,0.000")
	WriteLine(fileout, "ARC,8.738,8.740,0.500,225.000,45.000")
	WriteLine(fileout, "ARC,7.324,10.154,0.500,45.000,225.000")
	WriteLine(fileout, "CIRCLE,3.000,8.938,2.500")
CloseFile(fileout)
ImportDXFFile ("C:\Temp\Test_2D_DXF_CAD_Data.txt")



;Import Gage Data...
;For testing, I am going to write this Left Gage data to a text file on c:\temp\leftfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,0.125,0.000,0.125,2.500")
	WriteLine(fileout, "Line,0.125,2.500,-1.875,2.500")
	WriteLine(fileout, "Line,-1.875,2.500,-1.875,1.000")
	WriteLine(fileout, "Line,0.125,0.000,-0.125,0.000")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,0.125")
	WriteLine(fileout, "Line,-0.125,0.125,-1.875,1.000")
	WriteLine(fileout, "Line,-1.875,1.000,-0.875,1.000")
	WriteLine(fileout, "Line,-0.875,1.000,-0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\LeftFinger.txt", "LEFT")


;For testing, I am going to write this Right Gage data to a text file on c:\temp\rightfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,2.500")
	WriteLine(fileout, "Line,-0.125,2.500,1.875,2.500")
	WriteLine(fileout, "Line,1.875,2.500,1.875,1.000")
	WriteLine(fileout, "Line,-0.125,0.000,0.125,0.000")
	WriteLine(fileout, "Line,0.125,0.000,0.125,0.125")
	WriteLine(fileout, "Line,0.125,0.125,1.875,1.000")
	WriteLine(fileout, "Line,1.875,1.000,0.875,1.000")
	WriteLine(fileout, "Line,0.875,1.000,0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\RightFinger.txt", "RIGHT")



Origin 450,450 



;Import Bed Data...
ImportBed("C:\Temp\AutoformBed.txt")
ItemToMove$ = "BED"
MoveItem(CenterX#, "X")


;Let's move the items into view...
ItemToMove$ = "RIGHTGAGE"
MoveItem(CenterX# + 12, "X")

ItemToMove$ = "LEFTGAGE"
MoveItem(CenterX#- 12, "X")

ItemToMove$ = "BOTHGAGES"
MoveItem(2, "Y")

ItemToMove$ = "PART"
MoveItem(CenterX# - PartCenterX#, "X")
MoveItem(-PartCenterY# - 12, "Y")


;Let's setup some fonts...
Global fntArial=LoadFont("Calibri",15,False,False,False)
Global fntArialLG= LoadFont("Calibri",25,False,False,False)
LoadFont("Calibri",20,False,False,False)
Global fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 




;Let's add a tool to begin with...
AddTooling()




; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	Text 300, 10, "Mousewheel to zoom in and out"

	;Let's display some of the various conditions and settings for the user...
	UpdatePositions()
	

	;DrawTooling now...
	DrawTooling()

	;Draw the Ram now...
	DrawBed()


	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now...
	DrawPart()

	;Move items around on the screen below...
	If KeyDown(203) ;(Left key)
		MoveItem(-MovementAmount#, "X")
	End If
	If KeyDown(205) ;(Right Key)
		MoveItem(MovementAmount#, "X")
	End If		
	If KeyDown(200) ;(Up Key)
		MoveItem(MovementAmount#, "Y")
	End If
	If KeyDown(208) ;(Down Key)
		MoveItem(-MovementAmount#, "Y")
	End If		

	;Let the user select what needs to move...
	If KeyHit(50) Then	;(M key)
		SelectItem()
	End If
	
	;Let's set the Movement Amount below...
	If KeyHit(60) Then	;F2
		UpdateMovementAmount()
	End If	

	;Let's set the level of details to show on the part, lower selection speeds up part movement
	If KeyHit(59) Then	;F1
		SelectPartDetailLevel()
	End If

	If KeyHit(63) Then	;(F5)
		SelectRotationAmount()
	End If
	
	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If	
	
	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	;Move "CAMERA" type functionality below...
	If KeyDown(66) Then ;(F8)	;Move CAM left
		;CenterX# = CenterX# - 10
		PanZoomX# = PanZoomX# -10
	End If
	
	If KeyDown(67) Then ;(F9)	;Move CAM right
		;CenterX# = CenterX# + 10
		PanZoomX# = PanZoomX# +10
	End If

	If KeyDown(68) Then ;(F10)	;Move CAM Up
		;CenterY# = CenterY# - 10
		PanZoomY# = PanZoomY# -10		
	End If
	
	If KeyDown(87) Then ;(F11)	;Move CAM Down
		;CenterY# = CenterY# + 10
		PanZoomY# = PanZoomY# + 10		
	End If
	;Move "CAMERA" type functionality above...


	;Disply tooling details to the user...
	DisplayToolDetails()

	
	;Let's use the mousewheel to zoom in / out...
	If MouseZ() &lt;&gt; SaveMouseZ# Then
		If MouseZ() &gt; SaveMouseZ# Then
			Zoom(-3)
		Else
			Zoom(3)
		End If
		SaveMouseZ# = MouseZ()
	End If


	;Let's use the mouse to move items on the screen...
	;If MouseDown(1) And KeyDown(29) Then
	;	MoveItem(-MovementAmount#, "X")
	;End If
	;If MouseDown(2) And KeyDown(29) Then
	;	MoveItem(MovementAmount#, "X")
	;End If
	

	;Let's see if the user wants to edit any bends...
	;This is not working and needs some work
	;If MouseDown(2) Then
	;	EditBends
	;End If


	;Let's see if the user wants to save the data...
	If KeyHit(31) Then
		SaveData()
	End If
	
	If KeyHit(32) Then
		PlaySteps()
	End If
	
	Flip
	
Wend 

Function DrawPart()
	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#, gl\LColor$)
		End Select
	Next
	If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
		For cl.MyCircles = Each MyCircles
			DrawArc(cl\SX#, cl\SY#, 0, 359.5, cl\R#)
		Next
	End If

	If PartDetailsToShow$ = "HIGH" Then
		For al.MyArcs = Each MyArcs
			DrawArc(al\SX#, al\SY#, al\SA#, al\EA#, al\R#)
		Next					
	End If
End Function

Function DrawBed()
	For bg.MyBed = Each MyBed
		DrawLine(bg\SX#, bg\SY#, bg\EX#, bg\EY#, "GRAY")
	Next
End Function

Function MoveItem(Amount#, Direction$)
	Select Direction$
		Case "X"
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SX# = gl\SX# + Amount#
						gl\EX# = gl\EX# + Amount#
					Next
					For cl.MyCircles = Each MyCircles
						cl\SX# = cl\SX# + Amount#
						cl\EX# = cl\EX# + Amount#
					Next
					For ga.MyArcs = Each MyArcs
						ga\SX# = ga\SX# + Amount#
					Next
														
					PartCenterX# = PartCenterX# + Amount#
					PartLocationX# = PartLocationX# + Amount#
					
				Case "BOTHGAGES"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next
					ZAxisLeft# = ZAxisLeft# + Amount#
					ZAxisRight# = ZAxisRight# + Amount#
		
				Case "LEFTGAGE"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next		
					ZAxisLeft# = ZAxisLeft# + Amount#
		
				Case "RIGHTGAGE"
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next		
					ZAxisRight# = ZAxisRight# + Amount#

				Case "BED"
					For bg.MyBed = Each MyBed
						bg\SX# = bg\SX# + Amount#	
						bg\EX# = bg\EX# + Amount#	
					Next	
					
				Case "TOOLS"
					For gt.MyTools = Each MyTools
						gt\Location#  = gt\Location# + Amount#	
					Next					
			End Select	
		
		Case "Y"
			BottomL# = 0
			BottomR# = 0
			If XAxisRight# &lt;= 0 And Amount# &lt;= 0 Then
				 BottomR# = 1
			End If
			If XAxisLeft# &lt;= 0 And Amount# &lt;= 0 Then
				BottomL# = 1
			End If
		
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SY# = gl\SY# + Amount#
						gl\EY# = gl\EY# + Amount#
					Next
					
					For gc.MyCircles = Each MyCircles
						gc\SY# = gc\SY# + Amount#
						gc\EY# = gc\EY# + Amount#
					Next
					
					For ga.MyArcs = Each MyArcs
						ga\SY# = ga\SY# + Amount#
					Next
						
					PartCenterY# = PartCenterY# + Amount#
					PartLocationY# = PartLocationY# + Amount#
													
				Case "BOTHGAGES"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next
						XAxisLeft# = XAxisLeft# + Amount#
					End If
		
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next
						XAxisRight# = XAxisRight# + Amount#
					End If
					
				Case "LEFTGAGE"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next		
						XAxisLeft# = XAxisLeft# + Amount#
					End If
					
				Case "RIGHTGAGE"
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next		
						XAxisRight# = XAxisRight# + Amount#
					End If
			End Select	
		
	End Select
		
End Function


Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "GREEN"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			gl\BendSeqNumber# = 1
			gl\InsideBend$ = "OUTSIDE"
			gl\FO_L# = 0
			gl\FO_R# = 0
			gl\GageTopOfFinger$ = "GAGENORMAL"
			
			
			If MinimumXOfPart# &gt; SX# Then
				MinimumXOfPart# = SX#
			End If
			If MinimumXOfPart# &gt; EX# Then
				MinimumXOfPart# = EX#
			End If
			If MaximumXOfPart# &lt; SX# Then
				MaximumXOfPart# = SX#
			End If
			If MaximumXOfPart# &lt; EX# Then
				MaximumXOfPart# = EX#
			End If
			
			If MinimumYOfPart# &gt; SY# Then
				MinimumYOfPart# = SY#
			End If
			If MinimumYOfPart# &gt; EY# Then
				MinimumYOfPart# = EY#
			End If
			If MaximumYOfPart# &lt; SY# Then
				MaximumYOfPart# = SY#
			End If
			If MaximumYOfPart# &lt; EY# Then
				MaximumYOfPart# = EY#
			End If			
			
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gc.MyCircles = New MyCircles
			gc\GraphicType$ = "CIRCLE"
			gc\CName$ = "CIRCLE_" + I
			gc\SX# = SX#
			gc\SY# = SY#
			gc\EX# = 999
			gc\EY# = 999
			gc\R# = R#

		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			ga.MyArcs = New MyArcs
			ga\GraphicType$ = "ARC"
			ga\AName$ = "ARC_" + I
			ga\SX# = SX#
			ga\SY# = SY#
			ga\SA# = SA#
			ga\EA# = EA#
			ga\R# = R#
			
		End If
		
		I = I + 1

	Wend
	CloseFile(File)
	
	
	;Let's calculate the PartCenterX and PartCenterY...
	PartCenterX# = ( MaximumXOfPart# - MinimumXOfPart# ) / 2
	PartCenterY# = ( MaximumYOfPart# - MinimumYOfPart# ) / 2
	
End Function

Function ImportGage(FileName$, LorR$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			If LorR$ = "LEFT" Then
				lg.MyLeftGage = New MyLeftGage
				lg\SX# = SX#
				lg\SY# = SY#
				lg\EX# = EX#
				lg\EY# = EY#
			End If
			If LorR$ = "RIGHT" Then
				rg.MyRightGage = New MyRightGage
				rg\SX# = SX#
				rg\SY# = SY#
				rg\EX# = EX#
				rg\EY# = EY#
			End If

		End If
	Wend
	CloseFile(File)
End Function

Function ImportBed(fileName$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			bg.MyBed = New MyBed
			bg\SX# = SX#
			bg\SY# = SY#
			bg\EX# = EX#
			bg\EY# = EY#
		End If
	Wend
	CloseFile(File)
End Function


Function DrawGages()
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#, "GREEN")
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#, "GREEN")
	Next
End Function

Function DrawLine(SX#, SY#, EX#, EY#, LineColor$)
	
	Origin PanZoomX#, PanZoomY# 
	
	Select LineColor$
		Case "GREEN"
			Color 0, 255, 0
		Case "RED"
			Color 255, 0, 0
		Case "YELLOW"
			Color 255, 255, 0
		Case "GRAY"
			Color 75, 75, 75
		Case "BLUE"
			Color 0, 0, 255
		Default
			Color 0, 255, 0
	End Select

	Line SX# * MyScale#, -SY# * MyScale#, EX# * MyScale#, -EY# * MyScale#
	
	Origin 0, 0
	
End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	
	Origin PanZoomX#, PanZoomY#  
	
	Color 0, 255, 0
	
	SX# = SX# * MyScale#
	SY# = SY# * MyScale#
	R# = R# * MyScale#
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
			SA# = SA# + 2	;.5 will give a more defined arc
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend			
		End If
	End If
	
	Origin 0, 0
	 
End Function

Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function Zoom(Amount#)
	MyScale# = MyScale# + Amount#
	If MyScale# &lt; 5 Then
		MyScale# = 5
	End If
End Function

Function SelectItem()

	Select ItemToMove$
		Case "PART"
			ItemToMove$ = "BOTHGAGES"
		Case "BOTHGAGES"
			ItemToMove$ = "LEFTGAGE"
		Case "LEFTGAGE"
			ItemToMove$ = "RIGHTGAGE"
		Case "RIGHTGAGE"
			ItemToMove$ = "TOOLS"
		Default
			ItemToMove$ = "PART"
			
	End Select
		
End Function

Function UpdatePositions()
	Color 255,255,0
	SetFont fntCourier
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Move Amount : " + MovementAmount#
	Text 1, 30, "Rotation Amt: " + RotationAmount#
	Text 1, 45, "Part Details: " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + (ZAxisLeft# -CenterX#)
	Text 1, 90, "Z Axis Right: " + (ZAxisRight# - CenterX#)
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	Text 1, 135,"Zoom Level  : " + MyScale#
	Text 1, 150,"Part CenterX: " + PartCenterX#
	Text 1, 165,"Part CenterY: " + PartCenterY#
	Text 1, 180,"Prt Flipped?: " + PartFlipped$
	Text 1, 195,"Part Angle  : " + PartAngle#
	Text 1, 210,"Part Loc X  : " + PartLocationX#
	Text 1, 225,"Part Loc Y  : " + PartLocationY#
	
	SetFont fntArial
	
End Function

Function UpdateMovementAmount()
	Select MovementAmount#
		Case .125
			MovementAmount# = .5
		Case .5
			MovementAmount# = 1
		Case 1
			MovementAmount# = 6
		Case 6
			MovementAmount# = .125
	End Select
End Function

Function SelectPartDetailLevel()
	Select PartDetailsToShow$
		Case "HIGH"
			PartDetailsToShow$ = "MED"
		Case "MED"
			PartDetailsToShow$ = "LOW"
		Case "LOW"
			PartDetailsToShow$ = "HIGH"
	End Select
End Function

Function SelectRotationAmount()
	Select RotationAmount#
		Case 90
			RotationAmount# = 1
		Case 1
			RotationAmount# = 5
		Case 5
			RotationAmount# = 45
		Case 45
			RotationAmount# = 90
		Default
			RotationAmount# = 45
	End Select
End Function

Function GetUserInput$(Msg$)
	ReturnData$ = Input(Msg$)
	Return ReturnData$
End Function


Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
				
		;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
		Local localSX# = gl\SX - PartCenterX#
		Local localSY# = gl\SY - PartCenterY#
		
		Local localEX# = gl\EX - PartCenterX#
		Local localEY# = gl\EY - PartCenterY#
		
		;Rotate this copy by the angle amount.
		Local lineCos# = Cos( Amount )
		Local lineSin# = Sin( Amount )
		
		Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
		Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
		
		Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
		Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
		
		;Change the original segment to have the points of the rotated copy
		;but moved to the position of the original.
		
		gl\SX = newSX + PartCenterX#
		gl\SY = newSY + PartCenterY#
		
		gl\EX = newEX + PartCenterX#
		gl\EY = newEY + PartCenterY#			
	Next
	
	
	For gc.MyCircles = Each MyCircles

		Local clocalSX# = gc\SX - PartCenterX#
		Local clocalSY# = gc\SY - PartCenterY#
		
		Local clineCos# = Cos( Amount )
		Local clineSin# = Sin( Amount )
		
		Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
		Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
		
		gc\SX = cnewSX + PartCenterX#
		gc\SY = cnewSY + PartCenterY#
		
		;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
	Next
	
	For ga.MyArcs = Each MyArcs

		Local alocalSX# = ga\SX - PartCenterX#
		Local alocalSY# = ga\SY - PartCenterY#
		
		Local alineCos# = Cos( Amount )
		Local alineSin# = Sin( Amount )
		
		Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
		Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
		
		ga\SX = anewSX + PartCenterX#
		ga\SY = anewSY + PartCenterY#
		
		;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
		
		ga\SA# = ( ga\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
		ga\EA# = ( ga\EA# + Amount# ) Mod 360
							
	Next
	
	PartAngle# = PartAngle# + Amount#
	If PartAngle# &gt;= 360 Then
		PartAngle# = PartAngle# - 360
	End If
	
End Function


Function AddTooling()

	If ToolCount# = 0 Then
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount
		gt\Name$ = "MT030013000D"
		gt\Length# = 12
		gt\Location# = 0
		gt\Reversed$ = "NO"	
	
	Else

		SetFont fntArialLG
		
		Cls
		Flip
		
		FlushKeys
		Locate 50, 100
		;Local Name$ = GetUserInput("Enter Tool Name like:  MT030013000D...")
	
		FlushKeys
		Locate 50, 125
		;Local Length# = GetUserInput("Enter Tool Length:...")
	
		FlushKeys
		Locate 50, 150
		;Local Location$ = GetUserInput("Enter Tool Location:...")
	
		FlushKeys
		Locate 50, 175
		;Local Reversed$ = "NO"; GetUserInput("Tool Reversed? YES Or NO...")
		
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount#
		gt\Name$ = "MT026073000P";Name$
		gt\Length# = 6
		gt\Location# = (ToolCount# * 8) + ToolCount#
		gt\Reversed$ = "NO";Reversed$
		
		ToolCount# = ToolCount# + 1
		
		SetFont fntArial
		
	End If
	
		
End Function

Function DrawTooling()
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		DrawLine(SX#, SY#, EX#, EY#, "BLUE")
		DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "BLUE")
		DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "BLUE")
		DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "BLUE")
	Next
End Function

Function DisplayToolDetails()

	SetFont fntCourier
	
	I = 20
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		;Text 200, I, gt\Name$ + ", " + SX# + ",  " + SY# + ",  " + EX# + ",  " + EY# + ", Location:..." + gt\Location# + ", Length:" + gt\Length#
		Text 600, 2, "Tooling Data for debug purposes----------"
		Text 600, I, gt\Name$  + ", Location:" + gt\Location# + ", Length:" + gt\Length#
		
		I = I + 25
		;DrawLine(SX#, SY#, EX#, EY#, "RED")
		;DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "RED")
		;DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "RED")
		;DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "RED")
	Next

	SetFont fntArial
	
End Function

Function EditBends()
	While EditMode = 1
	If EditMode = 1 Then


		SelectedX# = MouseX()
		SelectedY# = MouseY()
		
		;Let's find the line the user clicks on and edit it...
		For gl.MyLines = Each MyLines
			If Abs(SelectedX# - (MyOriginX# + (gl\SX# + gl\EX#) / 2 * MyScale#)) &lt; 5 And Abs(SelectedY# - (MyOriginY# - (gl\SY# + gl\EY#) / 2 * MyScale)) &lt; 5 Then
				MoveMouse MyOriginX# + (gl\SX# + gl\EX#) / 2 * MyScale#, MyOriginY# - (gl\SY# + gl\EY#) / 2 * MyScale
				
				
				Msg$ = gl\LName$ + ", IsBendLine: " + gl\IsBendLine$ + ", X-Left: " + gl\XL# + ", X-Right: " + gl\XR# + ", Bend Angle: " + gl\Angle$ + ", Bend Direction: " + gl\DIR$ + ", Z-Left: " + gl\ZL# + ", Z-Right: " + gl\ZR#

				SetFont fntArialLG
				Text MouseX() + 8, MouseY() - 250, "Press L to MOVE LINE LEFT"
				Text MouseX() + 8, MouseY() - 225, "Press R to MOVE LINE RIGHT"
				Text MouseX() + 8, MouseY() - 200, "Press N to MOVE LINE DOWN"
				Text MouseX() + 8, MouseY() - 175, "Press M to MOVE LINE UP"
				Text MouseX() + 8, MouseY() - 150, "Press C to copy Line Down"
				Text MouseX() + 8, MouseY() - 125, "Press D to delete this line"
				Text MouseX() + 8, MouseY() - 100, "Press B to Make this Line a Bend LINE"
				Text MouseX() + 8, MouseY() - 75, "Press Z to Set Bend Direction"
				

				SetFont fntArial
				Text MouseX() + 8, MouseY() -25, Msg$
			
				If MouseHit(1) Then	;Let's get the data from the picked line and put it into a file and show it to the user
					MoveMouse MouseX(), MouseY() + 25
					
					fileout = WriteFile("C:\Temp\EditLine.txt")
					;WriteLine(fileout,"THIS IS THE DATA FROM THE LINE YOU PICKED")
					WriteLine(fileout,"GRAPHIC TYPE         :" + gl\GraphicType$)
					WriteLine(fileout,"LINE NAME            :" + gl\LName$)
					WriteLine(fileout,"START X              :" + gl\SX#)
					WriteLine(fileout,"START Y              :" + gl\SY#)
					WriteLine(fileout,"END X                :" + gl\EX#)
					WriteLine(fileout,"END Y                :" + gl\EY#)
					WriteLine(fileout,"IS BEND LINE         :" + gl\IsBendLine$)
					WriteLine(fileout,"LINE COLOR           :" + gl\LColor$)
					WriteLine(fileout,"X-LEFT               :" + gl\XL#)
					WriteLine(fileout,"X-RIGHT              :" + gl\XR#)
					WriteLine(fileout,"BEND ANGLE           :" + gl\Angle$)
					WriteLine(fileout,"BEND DIRECTION       :" + gl\DIR$)
					WriteLine(fileout,"BEND LENGTH          :" + gl\BendLength#)		
					WriteLine(fileout,"Z-LEFT               :" + gl\ZL#)
					WriteLine(fileout,"Z-RIGHT              :" + gl\ZR#)
		
					CloseFile(fileout)
					
					ExecFile("C:\Temp\EditLine.txt")

				End If
				
				If KeyHit(32) Then	;(D key) DELETE LINE
					Delete gl
				End If
				If KeyHit(48) Then	;(B Key) TOGGLE ISBENDLINE
					Select gl\IsBendLine$
						Case "YES"
							gl\IsBendLine$ = "NO"
							gl\LColor$ = "GREEN"
						Case "NO"
							gl\IsBendLine$ = "YES"
							gl\LColor$ = "YELLOW"
					End Select

				End If	
				If KeyHit(44) Then	;(Z Key) TOGGLE BEND DIRECTION
					Select gl\DIR$
						Case "UP"
							gl\DIR$ = "DN"
							gl\LColor$ = "RED"
						Case "DN"
							gl\DIR$ = "UP"
							gl\LColor$ = "YELLOW"
					End Select
				End If
				If KeyHit(46) Then	;(C Key) COPY HORIZONTAL LINE DOWN
					saveSX# = gl\SX#
					saveSY# = gl\SY#
					saveEX# = gl\EX#
					saveEY# = gl\EY#
					;saveR# = gl\R#
					saveIsBendLine$ = "NO"
					saveLColor$ = "GREEN"
					saveDIR$ = "UP"
					saveAngle# = 90
					saveBendLength# = CalcDistance(SX#, SY#, EX#, EY#)
					saveZL# = gl\ZL#
					saveZR# = gl\ZR#
					saveXL# = gl\XL#
					saveXR# = gl\XR#				


					gl.MyLines = New MyLines
					gl\GraphicType$ = "LINE"
					gl\LName$ = "LINE_" + I
					gl\SX# = saveSX#
					gl\SY# = saveSY# - .1
					gl\EX# = saveEX#
					gl\EY# = saveEY# - .1
					;gl\R# = saveR#
					saveIsBendLine$ = "NO"
					saveLColor$ = "GREEN"
					saveDIR$ = "UP"
					saveAngle# = 90
					saveBendLength# = CalcDistance(SX#, SY#, EX#, EY#)
					gl\ZL# = saveZL#
					gl\ZR# = saveZR#
					gl\XL# = saveXL#
					gl\XR# = saveXR#
					
				End If
				
				If KeyHit(49) Then	;(N Key)  MOVE LINE DOWN VERTICALLY
					gl\SY# = gl\SY# - .02
					gl\EY# = gl\EY# - .02
				End If
				If KeyHit(50) Then	;(M Key)  MOVE LINE UP VERTICALLY
					gl\SY# = gl\SY# + .02
					gl\EY# = gl\EY# + .02
				End If	
				If KeyHit(38) Then	;(L Key)  MOVE LINE LEFT HORIZONTALLY
					gl\SX# = gl\SX# - .02
					gl\EX# = gl\EX# - .02
				End If
				If KeyHit(19) Then	;(R Key)  MOVE LINE RIGHT HORIZONTALLY
					gl\SX# = gl\SX# + .02
					gl\EX# = gl\EX# + .02
				End If	
				
				
				
				;Text 300, 250, MouseX() + ", " + MouseY()
				Text 300, 300, "gage location x: " + ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60)
				Text 300, 325, "gage location Y: " + (PartLocationY# + MaximumYOfPart# + gl\SY#)
				
				
				If KeyHit(34) Then	;(G Key)  MOVE GAGES TO SELECTED LINE
					

					SaveItemToMove$ = ItemToMove$


					;Let's move the left gage into position now...
					LGageLocX# = ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60) - 2 - (.85 * (gl\EX# - gl\SX#) / 2)
					LGageLocY# = (PartLocationY# + MaximumYOfPart# + gl\SY#)

					RGageLocX# = ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60) + 2 + (.85 * (gl\EX# - gl\SX#) / 2)
					RGageLocY# = (PartLocationY# + MaximumYOfPart# + gl\SY#)

					DistanceToMoveX# = LGageLocX# - ZAxisLeft#
					DistanceToMoveY# = (XAxisLeft# - LGageLocY#)
					
					If XAxisLeft# - DistanceToMoveY# &lt;= 0 Then
						DistanceToMoveY# = DistanceToMoveY# - (XAxisLeft# + DistanceToMoveY#)
					End If
					
					ItemToMove$ = "LEFTGAGE"

					MoveItem(DistanceToMoveX#, "X")
					;MoveGageY(DistanceToMoveY#)


					DistanceToMoveX# = RGageLocX# - ZAxisRight#
					DistanceToMoveY# = (XAxisRight# - RGageLocY#)
					
					If XAxisRight# - DistanceToMoveY# &lt;= 0 Then
						DistanceToMoveY# = DistanceToMoveY# - (XAxisRight# + DistanceToMoveY#)				
					End If

					ItemToMove$ = "RIGHTGAGE"

					MoveItem(DistanceToMoveX#, "X")
					;MoveGageY(DistanceToMoveY#)
					
					

					ItemToMove$ = SaveItemToMove$

				End If
				
				
				;Lets move the bend line up to the machine centerline Y
				If KeyHit(24) Then
					If (PartLocationY# + MaximumYOfPart# + gl\SY#) &lt; 0 Then
						While (PartLocationY# + MaximumYOfPart# + gl\SY#) &lt; 0
							MoveItem(.001, "Y")
							;WaitKey()
						Wend
					Else
						While (PartLocationY# + MaximumYOfPart# + gl\SY#) &gt; 0
							MoveItem(-.001, "Y")
							;WaitKey()
						Wend
					End If
				End If
											
			End If
		Next
		
	End If
	
	If EditMode = 1 Then
		Rect MouseX() -4, MouseY() -5, 10, 10, False
	End If

	Wend
End Function

Function SaveData()
;This function will save all of the setup details to a text file that can be used to read the data back in at a later date.  This code is just started and not ready for anyone to use it


	fileout = WriteFile("C:\Temp\mydata.txt")

	WriteLine(fileout, "Start Part Geometry Information")
	WriteLine(fileout, "Part Rotation Angle: " + PartAngle#)
	WriteLine(fileout, "Part Flipped       : " + PartFlipped$)
	WriteLine(fileout, "GeometryName,StartX,StartY,EndX,EndY,StartAngle,EndAngle,Radius,IsBendLine,GeometryColor,BendDirection,BendAngle,BendLength,Punch,Die,Z-Left,Z-Right,X-Left,X-Right,InsideBend,FingerOffset-L,FingerOffset-R,GageTopOfFinger?")
	For gl.MyLines = Each MyLines
		WriteLine(fileout, gl\LName$ + "," + gl\SX# + "," + gl\SY# + "," + gl\EX# + "," + gl\EY# + "," + gl\IsBendLine$ + "," + gl\LColor$ + "," + gl\DIR$ + "," + gl\Angle# + "," + CalcDistance(gl\SX#, gl\SY#, gl\EX#, gl\EY#) + "," + gl\ZL# + "," + gl\ZR# + "," + gl\XL# + "," + gl\XR# + "," + gl\InsideBend$ + "," + gl\FO_L# + "," + FO_R# + "," + gl\GageTopOfFinger$)
	Next
	WriteLine(fileout, "End Part Geometry Information")
	
	;Let's save the left gage information...
	WriteLine(fileout, "Start Left Gage Information")
	;For lg.MyLeftGage = Each MyLeftGage
	;	WriteLine(fileout, + lg\SX# + "," + lg\SY# + "," + lg\EX# + "," + lg\EY#)
	;Next	
	WriteLine(fileout, "ZAxisLeft          : " + ZAxisLeft#)
	WriteLine(fileout, "XAxisLeft          : " + XAxisLeft#)
	WriteLine(fileout, "End Left Gage Information")

	;Let's save the right gage information...
		WriteLine(fileout, "Start Right Gage Information")
	For rg.MyLeftGage = Each MyLeftGage
		WriteLine(fileout, + rg\SX# + "," + rg\SY# + "," + rg\EX# + "," + rg\EY#)
	Next	
	WriteLine(fileout, "End Right Gage Information")
	
	;Let's save the tooling information...
	WriteLine(fileout, "Start Tooling Information")
	WriteLine(fileout, "ToolId,Name,ToolLength,ToolLocation,ToolReversed")
	For tl.MyTools = Each MyTools
		WriteLine(fileout, "ID          : " + tl\Id#)
		WriteLine(fileout, "Name        : " + tl\Name$)
		WriteLine(fileout, "Length      : " + tl\Length#)
		WriteLine(fileout, "Location    : " + tl\Location#)
		WriteLine(fileout, "Reversed    : " + tl\Reversed$)
	Next
	WriteLine(fileout, "End Tooling Information")

	CloseFile(fileout)


End Function


Function PlaySteps()
;This function will read in data that was previously saved and all the user to continue working.  This code is just started and is not ready for anyone to use.

	file=OpenFile("C:\Temp\MyData.txt")
	SaveItemToMove$ = ItemToMove$
	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		;Lets' find the first bend ...
		StringToSearchFor$ = "ZAxisLeft          :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then


			NewPosition# = Trim(Mid(Hold$, 22))
			;Let's move the left finger into position...
			
			ItemToMove$ = "LEFTGAGE"					
			If ZAxisleft# &gt;= NewPosition# Then
				While ZAxisLeft# &gt; NewPosition#
					MoveItem(-.001, "X")
				Wend
				NewPosition# = ZAxisleft#
			End If
			If ZAxisleft# &lt; NewPosition#
				While ZAxisLeft# &lt; NewPosition#
				
					MoveItem(.001, "X")
				Wend
			End If					

			ItemToMove$ = SaveItemToMove$
		End If
	Wend
	CloseFile(file)


	ToolCount# = 0
	file=OpenFile("C:\Temp\MyData.txt")

	For gt.MyTools = Each MyTools
		Delete gt
	Next

	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		;Lets' find the first bend ...
		StringToSearchFor$ = "ID          :"
		
		Found = Instr(Hold$, StringToSearchFor$)
		If Found &gt; 0  Then 
		
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))

			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			ToolCount# = ToolCount# + 1
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			ToolCount# = ToolCount# + 1
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			ToolCount# = ToolCount# + 1
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$

			ToolCount# = ToolCount# + 1
							
		End If
	Wend
	CloseFile(file)
	

End Function
</textarea> <br><br></td></tr></table><br>
<a name="1303210"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> When I remove the CenterY#, the drawing goes off screen to the upper left corner. Do you know how I can fix it? <br></div><br>You need to add CenterX to all X coordinates and CenterY to all Y coordinates. This should prevent the parts from sliding diagonally which is caused by adding the same value to all coordinates. <br><br></td></tr></table><br>
<a name="1303211"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Kryzon.  I'm not using CenterX and CenterY now but I'll revisit that later if needed.  What timezone are you in?  I couldn't sleep last night thinking about this dang project so I logged on and I noticed you responded to one of my questions around midnight Eastern time.  Do you program for a living or just for fun? <br><br></td></tr></table><br>
<a name="1303212"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> What IDE do you use?  I am using the default IDE that came with Blitz3D when I bought it many years ago.  It is very difficult to work with.  Is there anything better that you would recommend? <br><br></td></tr></table><br>
<a name="1303220"></a>

<a name="1303221"></a>

<a name="1303222"></a>

<a name="1303223"></a>

<a name="1303224"></a>

<a name="1303226"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> The problem is that Blitz3D is a 10+ year old product, so most of the options that were available at that time have been discontinued in expired websites or need patches to work with the latest version of Windows.<br>This is also reflected in the amount of people here that would be able to help you.<br><br>There seems to be IDEal left. I haven't used it:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=105793#1294830" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=105793#1294830</a><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=105599" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=105599</a> (patch thread?)<br><br>Additionally, try BlitzPlus instead of Blitz3D (download at the <a href="/Account/produpdates.php" target="_blank">bottom of this page</a>, you need to be logged in).<br>BlitzPlus allows you to make a GUI for your program, it should feel more natural. The language syntax is the same as Blitz3D without the 3D functions (in fact, if you copy and paste your program it should work as it is).<br>At the very least you can add a menu bar, buttons and sliders to the window, and slowly work your way into a tool that is usable for production. There is also a code archives section with examples for inspiration: <a href="http://www.blitzbasic.com/codearcs/codearcs.php?cat=10&amp;order=&amp;asc=&amp;lang_id=1" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?cat=10&amp;order=&amp;asc=&amp;lang_id=1</a><br><br>You can use this tool as a visual designer for the interface of your program (you need to build it with BlitzPlus first to get the .EXE -- this also means that this tool itself was made with BlitzPlus):<br><a href="https://github.com/wiebow/guide" target="_blank">https://github.com/wiebow/guide</a><br><br>Anyway, best of luck. <br><br></td></tr></table><br>
<a name="1303225"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK.  I'll give that a try.  I am trying to get this wrapped up good enough so I can start using it at work.  I plan to keep plowing thru this until I get something I can use then look at BP.<br><br>I have added some EDIT LINES ability for anyone interested.  Right mouse click near the mid point of a line and it should SNAP to the midpoint and display some options for editing.  I don't really like it but it kinda works.  I am sure my ideas are not the best so don't laugh too much.  I will keep plugging away.<br><br>The next problem I have and don't have any good ideas is how can I allow the user to set certain properties for every BEND line and save the settings along the way and then allow the user to PLAY back all of the positions that he / she has set.<br><br>Latest version of code is below<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 900,900,16 

AppTitle "F1=PrtDet," + "F2=MovAmt," +"F4=Rot," + "F5=RotAmt," + "F8=CamLft,"+"F9=CamRt," + "F10=CamUP," + "F11=CamDN," + "T=AddTl," + "M=Sel Item 2 Mov"
Global PanZoomX# = GraphicsWidth() / 2
Global PanZoomY# = GraphicsHeight() / 2  

Global MyScale# = 10
Global EditMode = 0
Global SelectedX# =0.0
Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .5
Global ZAxisLeft# = 0
Global ZAxisRight# = 0
Global XAxisRight# = 0
Global XAxisLeft# = 0
Global PartLocationX# = 0
Global PartLocationY# = 0
Global MinimumXOfPart# = 10000
Global MaximumXofPart# = -10000
Global MinimumYOfPart# = 10000
Global MaximumYOfPart# = -10000
Global PartCenterX# = 10000
Global PartCenterY# = 10000
Global PartFlipped$ = "NO"	;Can be YES or NO
Global PartAngle# = 0
Global CenterX# = 0
Global CenterY# = 0
Global ToolWidth# = 1.5
Global ToolCount# = 0
Global MaterialGauge$ = "14"		;Can be 11, 14, 16, 18, 20, 22, 24, 26
Global MaterialType$ = "MILD"		;Can be MILD, STAINLESS

Type MyLines
	Field GraphicType$      ;LINE, CIRCLE, OR ARC
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
	Field IsBendLine$       ;IS A BEND LINE YES or NO
	Field LColor$           ;LINE COLOR
	Field LName$            ;LINE NAME
	Field BendSeqNumber#    ;BEND SEQUENCE NUMBER
	Field Dir$              ;BEND DIRECTION UP or Dn
	Field Angle#            ;BEND ANGLE
	Field BendLength#       ;BEND LENGTH
	Field ZL#               ;ZLeft
	Field ZR#               ;ZRight
	Field XL#               ;XLeft
	Field XR#               ;XRight
	Field InsideBend$	    ;INSIDE BEND DIMENSION INSIDE or OUTSIDE
	Field FO_L#             ;FINGER OFFSET LEFT
	Field FO_R#             ;FINGER OFFSET Right
	Field GageTopOfFinger$  ;GAGE ON TOP OF THE BACKGAGE FINGER ...GAGETOP or GAGENORMAL
End Type

Type MyCircles
	Field GraphicType$      ;CIRCLE
	Field CName$			;CIRCLE NAME
	Field SX#               ;CIRCLE START POINT X
	Field SY#               ;CIRCLE START POINT Y
	Field EX#               ;CIRCLE END POINT X
	Field EY#               ;CIRCLE END POINT Y
	Field R#				;CIRCLE RADIUS

End Type

Type MyArcs
	Field GraphicType$      ;ARC
	Field AName$			;ARC NAME
	Field SX#               ;ARC START POINT X
	Field SY#               ;ARC START POINT Y
	Field SA#				;ARC START ANGLE
	Field EA#				;ARC END ANGLE
	Field R#				;ARC RADIUS
End Type

Type MyTools
	Field Id				;Tool Id
	Field Name$         	;Tool Number
	Field Length#   		;Tool Length
	Field Location# 		;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     	;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyRightGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyBed
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type


;Import Part Data...
;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")	;Lots of holes
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")	;Metric Units
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
;ImportDXFFile ("C:\Temp\junkoriginal9.txt")
;ImportDXFFile ("C:\Temp\junkoriginal5.txt")

;For testing, I am going to write this 2D CAD data to a text file on c:\tempjunkoriginal.txt"
fileout = WriteFile("C:\Temp\Test_2D_DXF_CAD_Data.txt")
	WriteLine(fileout, "Line,0.000,0.125,0.000,11.750")
	WriteLine(fileout, "Line,0.250,12.000,11.500,12.000")
	WriteLine(fileout, "Line,12.000,11.500,12.000,1.000")
	WriteLine(fileout, "LINE,11.000,12.000,11.000,0.000")
	WriteLine(fileout, "Line,11.000,0.000,0.125,0.000")
	WriteLine(fileout, "Line,6.282,6.220,6.817,6.754")
	WriteLine(fileout, "Line,7.414,6.507,7.414,5.938")
	WriteLine(fileout, "Line,6.213,5.600,6.768,4.719")
	WriteLine(fileout, "Line,7.414,5.938,7.414,4.906")
	WriteLine(fileout, "Line,1.637,3.213,3.137,3.213")
	WriteLine(fileout, "Line,4.637,2.213,4.637,1.213")
	WriteLine(fileout, "Line,4.637,1.213,3.137,1.213")
	WriteLine(fileout, "Line,1.637,3.213,1.637,2.213")
	WriteLine(fileout, "Line,3.137,3.213,4.637,2.213")
	WriteLine(fileout, "Line,3.137,1.213,1.637,2.213")
	WriteLine(fileout, "Line,6.970,9.801,8.385,8.386")
	WriteLine(fileout, "Line,9.092,9.093,7.677,10.508")
	WriteLine(fileout, "ARC,0.125,0.125,0.125,180.000,270.000")
	WriteLine(fileout, "ARC,0.250,11.750,0.250,90.000,180.000")
	WriteLine(fileout, "ARC,11.500,11.500,0.500,0.000,90.000")
	WriteLine(fileout, "ARC,11.000,1.000,1.000,270.000,0.000")
	WriteLine(fileout, "ARC,7.064,6.507,0.350,0.000,135.000")
	WriteLine(fileout, "ARC,6.636,5.866,0.500,135.000,212.227")
	WriteLine(fileout, "ARC,7.064,4.906,0.350,212.227,0.000")
	WriteLine(fileout, "ARC,8.738,8.740,0.500,225.000,45.000")
	WriteLine(fileout, "ARC,7.324,10.154,0.500,45.000,225.000")
	WriteLine(fileout, "CIRCLE,3.000,8.938,2.500")
CloseFile(fileout)
ImportDXFFile ("C:\Temp\Test_2D_DXF_CAD_Data.txt")



;Import Gage Data...
;For testing, I am going to write this Left Gage data to a text file on c:\temp\leftfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,0.125,0.000,0.125,2.500")
	WriteLine(fileout, "Line,0.125,2.500,-1.875,2.500")
	WriteLine(fileout, "Line,-1.875,2.500,-1.875,1.000")
	WriteLine(fileout, "Line,0.125,0.000,-0.125,0.000")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,0.125")
	WriteLine(fileout, "Line,-0.125,0.125,-1.875,1.000")
	WriteLine(fileout, "Line,-1.875,1.000,-0.875,1.000")
	WriteLine(fileout, "Line,-0.875,1.000,-0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\LeftFinger.txt", "LEFT")


;For testing, I am going to write this Right Gage data to a text file on c:\temp\rightfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,2.500")
	WriteLine(fileout, "Line,-0.125,2.500,1.875,2.500")
	WriteLine(fileout, "Line,1.875,2.500,1.875,1.000")
	WriteLine(fileout, "Line,-0.125,0.000,0.125,0.000")
	WriteLine(fileout, "Line,0.125,0.000,0.125,0.125")
	WriteLine(fileout, "Line,0.125,0.125,1.875,1.000")
	WriteLine(fileout, "Line,1.875,1.000,0.875,1.000")
	WriteLine(fileout, "Line,0.875,1.000,0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\RightFinger.txt", "RIGHT")



Origin 450,450 



;Import Bed Data...
ImportBed("C:\Temp\AutoformBed.txt")
ItemToMove$ = "BED"
MoveItem(CenterX#, "X")


;Let's move the items into view...
ItemToMove$ = "RIGHTGAGE"
MoveItem(CenterX# + 12, "X")

ItemToMove$ = "LEFTGAGE"
MoveItem(CenterX#- 12, "X")

ItemToMove$ = "BOTHGAGES"
MoveItem(2, "Y")

ItemToMove$ = "PART"
MoveItem(CenterX# - PartCenterX#, "X")
MoveItem(-PartCenterY# - 12, "Y")


;Let's setup some fonts...
Global fntArial=LoadFont("Calibri",15,False,False,False)
Global fntArialLG= LoadFont("Calibri",25,False,False,False)
LoadFont("Calibri",20,False,False,False)
Global fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 




;Let's add a tool to begin with...
AddTooling()




; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	Text 300, 10, "Mousewheel to zoom in and out"

	;Let's display some of the various conditions and settings for the user...
	UpdatePositions()
	

	;DrawTooling now...
	DrawTooling()

	;Draw the Ram now...
	DrawBed()


	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now...
	DrawPart()

	;Move items around on the screen below...
	If KeyDown(203) ;(Left key)
		MoveItem(-MovementAmount#, "X")
	End If
	If KeyDown(205) ;(Right Key)
		MoveItem(MovementAmount#, "X")
	End If		
	If KeyDown(200) ;(Up Key)
		MoveItem(MovementAmount#, "Y")
	End If
	If KeyDown(208) ;(Down Key)
		MoveItem(-MovementAmount#, "Y")
	End If		

	;Let the user select what needs to move...
	If KeyHit(50) Then	;(M key)
		SelectItem()
	End If
	
	;Let's set the Movement Amount below...
	If KeyHit(60) Then	;F2
		UpdateMovementAmount()
	End If	

	;Let's set the level of details to show on the part, lower selection speeds up part movement
	If KeyHit(59) Then	;F1
		SelectPartDetailLevel()
	End If

	If KeyHit(63) Then	;(F5)
		SelectRotationAmount()
	End If
	
	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If	
	
	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...

	;Move "CAMERA" type functionality below...
	If KeyDown(66) Then ;(F8)	;Move CAM left
		;CenterX# = CenterX# - 10
		PanZoomX# = PanZoomX# -10
	End If
	
	If KeyDown(67) Then ;(F9)	;Move CAM right
		;CenterX# = CenterX# + 10
		PanZoomX# = PanZoomX# +10
	End If

	If KeyDown(68) Then ;(F10)	;Move CAM Up
		;CenterY# = CenterY# - 10
		PanZoomY# = PanZoomY# -10		
	End If
	
	If KeyDown(87) Then ;(F11)	;Move CAM Down
		;CenterY# = CenterY# + 10
		PanZoomY# = PanZoomY# + 10		
	End If
	;Move "CAMERA" type functionality above...


	;Disply tooling details to the user...
	DisplayToolDetails()

	
	;Let's use the mousewheel to zoom in / out...
	If MouseZ() &lt;&gt; SaveMouseZ# Then
		If MouseZ() &gt; SaveMouseZ# Then
			Zoom(-3)
		Else
			Zoom(3)
		End If
		SaveMouseZ# = MouseZ()
	End If


	;Let's use the mouse to move items on the screen...
	;If MouseDown(1) And KeyDown(29) Then
	;	MoveItem(-MovementAmount#, "X")
	;End If
	;If MouseDown(2) And KeyDown(29) Then
	;	MoveItem(MovementAmount#, "X")
	;End If
	

	;Let's see if the user wants to edit any bends...
	;This is not working and needs some work
	If MouseDown(2) Then
		Select EditMode
			Case 1
				EditMode = 0
			Case 0
				EditMode = 1
				;EditBends()		
		End Select
	End If



	If EditMode = 1 Then

		;Let's find the line the user clicks on and edit it...

		SelectedX# = MouseX()
		SelectedY# = MouseY()
		
		;Let's find the line the user clicks on and edit it...
		For gl.MyLines = Each MyLines
			If Abs(SelectedX# - (PanZoomX# + (gl\SX# + gl\EX#) / 2 * MyScale#)) &lt; 5 And Abs(SelectedY# - (PanZoomY# - (gl\SY# + gl\EY#) / 2 * MyScale)) &lt; 5 Then
				MoveMouse PanZoomX# + (gl\SX# + gl\EX#) / 2 * MyScale#, PanZoomY# - (gl\SY# + gl\EY#) / 2 * MyScale
				
				Msg$ = gl\LName$ + ", IsBendLine: " + gl\IsBendLine$ + ", X-Left: " + gl\XL# + ", X-Right: " + gl\XR# + ", Bend Angle: " + gl\Angle$ + ", Bend Direction: " + gl\DIR$ + ", Z-Left: " + gl\ZL# + ", Z-Right: " + gl\ZR#

				SetFont fntArialLG
				Text MouseX() + 8, MouseY() - 250, "Press L to MOVE LINE LEFT"
				Text MouseX() + 8, MouseY() - 225, "Press R to MOVE LINE RIGHT"
				Text MouseX() + 8, MouseY() - 200, "Press N to MOVE LINE DOWN"
				Text MouseX() + 8, MouseY() - 175, "Press M to MOVE LINE UP"
				Text MouseX() + 8, MouseY() - 150, "Press C to copy Line Down"
				Text MouseX() + 8, MouseY() - 125, "Press D to delete this line"
				Text MouseX() + 8, MouseY() - 100, "Press B to Make this Line a Bend LINE"
				Text MouseX() + 8, MouseY() - 75, "Press Z to Set Bend Direction"
				

				SetFont fntArial
				Text MouseX() + 8, MouseY() -25, Msg$
			
				If MouseHit(1) Then	;Let's get the data from the picked line and put it into a file and show it to the user
					MoveMouse MouseX(), MouseY() + 25
					
					fileout = WriteFile("C:\Temp\EditLine.txt")
					WriteLine(fileout,"GRAPHIC TYPE         :" + gl\GraphicType$)
					WriteLine(fileout,"LINE NAME            :" + gl\LName$)
					WriteLine(fileout,"START X              :" + gl\SX#)
					WriteLine(fileout,"START Y              :" + gl\SY#)
					WriteLine(fileout,"END X                :" + gl\EX#)
					WriteLine(fileout,"END Y                :" + gl\EY#)
					WriteLine(fileout,"IS BEND LINE         :" + gl\IsBendLine$)
					WriteLine(fileout,"LINE COLOR           :" + gl\LColor$)
					WriteLine(fileout,"X-LEFT               :" + gl\XL#)
					WriteLine(fileout,"X-RIGHT              :" + gl\XR#)
					WriteLine(fileout,"BEND ANGLE           :" + gl\Angle$)
					WriteLine(fileout,"BEND DIRECTION       :" + gl\DIR$)
					WriteLine(fileout,"BEND LENGTH          :" + gl\BendLength#)		
					WriteLine(fileout,"Z-LEFT               :" + gl\ZL#)
					WriteLine(fileout,"Z-RIGHT              :" + gl\ZR#)
		
					CloseFile(fileout)
					
					ExecFile("C:\Temp\EditLine.txt")

				End If
				
				If KeyHit(32) Then	;(D key) DELETE LINE
					Delete gl
				End If
				If KeyHit(48) Then	;(B Key) TOGGLE ISBENDLINE
					Select gl\IsBendLine$
						Case "YES"
							gl\IsBendLine$ = "NO"
							gl\LColor$ = "GREEN"
						Case "NO"
							gl\IsBendLine$ = "YES"
							gl\LColor$ = "YELLOW"
					End Select

				End If	
				If KeyHit(44) Then	;(Z Key) TOGGLE BEND DIRECTION
					Select gl\DIR$
						Case "UP"
							gl\DIR$ = "DN"
							gl\LColor$ = "RED"
						Case "DN"
							gl\DIR$ = "UP"
							gl\LColor$ = "YELLOW"
					End Select
				End If
				If KeyHit(46) Then	;(C Key) COPY HORIZONTAL LINE DOWN
					saveSX# = gl\SX#
					saveSY# = gl\SY#
					saveEX# = gl\EX#
					saveEY# = gl\EY#
					saveIsBendLine$ = "NO"
					saveLColor$ = "GREEN"
					saveDIR$ = "UP"
					saveAngle# = 90
					saveBendLength# = CalcDistance(SX#, SY#, EX#, EY#)
					saveZL# = gl\ZL#
					saveZR# = gl\ZR#
					saveXL# = gl\XL#
					saveXR# = gl\XR#				


					gl.MyLines = New MyLines
					gl\GraphicType$ = "LINE"
					gl\LName$ = "LINE_" + I
					gl\SX# = saveSX#
					gl\SY# = saveSY# - .1
					gl\EX# = saveEX#
					gl\EY# = saveEY# - .1
					saveIsBendLine$ = "NO"
					saveLColor$ = "GREEN"
					saveDIR$ = "UP"
					saveAngle# = 90
					saveBendLength# = CalcDistance(SX#, SY#, EX#, EY#)
					gl\ZL# = saveZL#
					gl\ZR# = saveZR#
					gl\XL# = saveXL#
					gl\XR# = saveXR#
					
				End If
				
				If KeyHit(49) Then	;(N Key)  MOVE LINE DOWN VERTICALLY
					gl\SY# = gl\SY# - .02
					gl\EY# = gl\EY# - .02
				End If
				If KeyHit(50) Then	;(M Key)  MOVE LINE UP VERTICALLY
					gl\SY# = gl\SY# + .02
					gl\EY# = gl\EY# + .02
				End If	
				If KeyHit(38) Then	;(L Key)  MOVE LINE LEFT HORIZONTALLY
					gl\SX# = gl\SX# - .02
					gl\EX# = gl\EX# - .02
				End If
				If KeyHit(19) Then	;(R Key)  MOVE LINE RIGHT HORIZONTALLY
					gl\SX# = gl\SX# + .02
					gl\EX# = gl\EX# + .02
				End If	
				
				
				If KeyHit(34) Then	;(G Key)  MOVE GAGES TO SELECTED LINE
					

					SaveItemToMove$ = ItemToMove$


					;Let's move the left gage into position now...
					LGageLocX# = ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60) - 2 - (.85 * (gl\EX# - gl\SX#) / 2)
					LGageLocY# = (PartLocationY# + MaximumYOfPart# + gl\SY#)

					RGageLocX# = ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60) + 2 + (.85 * (gl\EX# - gl\SX#) / 2)
					RGageLocY# = (PartLocationY# + MaximumYOfPart# + gl\SY#)

					DistanceToMoveX# = LGageLocX# - ZAxisLeft#
					DistanceToMoveY# = (XAxisLeft# - LGageLocY#)
					
					If XAxisLeft# - DistanceToMoveY# &lt;= 0 Then
						DistanceToMoveY# = DistanceToMoveY# - (XAxisLeft# + DistanceToMoveY#)
					End If
					
					ItemToMove$ = "LEFTGAGE"

					MoveItem(DistanceToMoveX#, "X")

					DistanceToMoveX# = RGageLocX# - ZAxisRight#
					DistanceToMoveY# = (XAxisRight# - RGageLocY#)
					
					If XAxisRight# - DistanceToMoveY# &lt;= 0 Then
						DistanceToMoveY# = DistanceToMoveY# - (XAxisRight# + DistanceToMoveY#)				
					End If

					ItemToMove$ = "RIGHTGAGE"

					MoveItem(DistanceToMoveX#, "X")

					ItemToMove$ = SaveItemToMove$

				End If
				
				
				;Lets move the bend line up to the machine centerline Y
				If KeyHit(24) Then
					If (PartLocationY# + MaximumYOfPart# + gl\SY#) &lt; 0 Then
						While (PartLocationY# + MaximumYOfPart# + gl\SY#) &lt; 0
							MoveItem(.001, "Y")
							;WaitKey()
						Wend
					Else
						While (PartLocationY# + MaximumYOfPart# + gl\SY#) &gt; 0
							MoveItem(-.001, "Y")
							;WaitKey()
						Wend
					End If
				End If
											
			End If
		Next
		
	End If
	
	If EditMode = 1 Then
		Rect MouseX() -4, MouseY() -4, 8, 8, False
	End If

































	;Let's see if the user wants to save the data...
	If KeyHit(31) Then
		SaveData()
	End If
	
	If KeyHit(32) Then
		PlaySteps()
	End If
	
	Flip
	
Wend 

Function DrawPart()
	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#, gl\LColor$)
		End Select
	Next
	If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
		For cl.MyCircles = Each MyCircles
			DrawArc(cl\SX#, cl\SY#, 0, 359.5, cl\R#)
		Next
	End If

	If PartDetailsToShow$ = "HIGH" Then
		For al.MyArcs = Each MyArcs
			DrawArc(al\SX#, al\SY#, al\SA#, al\EA#, al\R#)
		Next					
	End If
End Function

Function DrawBed()
	For bg.MyBed = Each MyBed
		DrawLine(bg\SX#, bg\SY#, bg\EX#, bg\EY#, "GRAY")
	Next
End Function

Function MoveItem(Amount#, Direction$)
	Select Direction$
		Case "X"
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SX# = gl\SX# + Amount#
						gl\EX# = gl\EX# + Amount#
					Next
					For cl.MyCircles = Each MyCircles
						cl\SX# = cl\SX# + Amount#
						cl\EX# = cl\EX# + Amount#
					Next
					For ga.MyArcs = Each MyArcs
						ga\SX# = ga\SX# + Amount#
					Next
														
					PartCenterX# = PartCenterX# + Amount#
					PartLocationX# = PartLocationX# + Amount#
					
				Case "BOTHGAGES"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next
					ZAxisLeft# = ZAxisLeft# + Amount#
					ZAxisRight# = ZAxisRight# + Amount#
		
				Case "LEFTGAGE"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next		
					ZAxisLeft# = ZAxisLeft# + Amount#
		
				Case "RIGHTGAGE"
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next		
					ZAxisRight# = ZAxisRight# + Amount#

				Case "BED"
					For bg.MyBed = Each MyBed
						bg\SX# = bg\SX# + Amount#	
						bg\EX# = bg\EX# + Amount#	
					Next	
					
				Case "TOOLS"
					For gt.MyTools = Each MyTools
						gt\Location#  = gt\Location# + Amount#	
					Next					
			End Select	
		
		Case "Y"
			BottomL# = 0
			BottomR# = 0
			If XAxisRight# &lt;= 0 And Amount# &lt;= 0 Then
				 BottomR# = 1
			End If
			If XAxisLeft# &lt;= 0 And Amount# &lt;= 0 Then
				BottomL# = 1
			End If
		
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SY# = gl\SY# + Amount#
						gl\EY# = gl\EY# + Amount#
					Next
					
					For gc.MyCircles = Each MyCircles
						gc\SY# = gc\SY# + Amount#
						gc\EY# = gc\EY# + Amount#
					Next
					
					For ga.MyArcs = Each MyArcs
						ga\SY# = ga\SY# + Amount#
					Next
						
					PartCenterY# = PartCenterY# + Amount#
					PartLocationY# = PartLocationY# + Amount#
													
				Case "BOTHGAGES"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next
						XAxisLeft# = XAxisLeft# + Amount#
					End If
		
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next
						XAxisRight# = XAxisRight# + Amount#
					End If
					
				Case "LEFTGAGE"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next		
						XAxisLeft# = XAxisLeft# + Amount#
					End If
					
				Case "RIGHTGAGE"
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next		
						XAxisRight# = XAxisRight# + Amount#
					End If
			End Select	
		
	End Select
		
End Function


Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "GREEN"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			gl\BendSeqNumber# = 1
			gl\InsideBend$ = "OUTSIDE"
			gl\FO_L# = 0
			gl\FO_R# = 0
			gl\GageTopOfFinger$ = "GAGENORMAL"
			
			
			If MinimumXOfPart# &gt; SX# Then
				MinimumXOfPart# = SX#
			End If
			If MinimumXOfPart# &gt; EX# Then
				MinimumXOfPart# = EX#
			End If
			If MaximumXOfPart# &lt; SX# Then
				MaximumXOfPart# = SX#
			End If
			If MaximumXOfPart# &lt; EX# Then
				MaximumXOfPart# = EX#
			End If
			
			If MinimumYOfPart# &gt; SY# Then
				MinimumYOfPart# = SY#
			End If
			If MinimumYOfPart# &gt; EY# Then
				MinimumYOfPart# = EY#
			End If
			If MaximumYOfPart# &lt; SY# Then
				MaximumYOfPart# = SY#
			End If
			If MaximumYOfPart# &lt; EY# Then
				MaximumYOfPart# = EY#
			End If			
			
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gc.MyCircles = New MyCircles
			gc\GraphicType$ = "CIRCLE"
			gc\CName$ = "CIRCLE_" + I
			gc\SX# = SX#
			gc\SY# = SY#
			gc\EX# = 999
			gc\EY# = 999
			gc\R# = R#

		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			ga.MyArcs = New MyArcs
			ga\GraphicType$ = "ARC"
			ga\AName$ = "ARC_" + I
			ga\SX# = SX#
			ga\SY# = SY#
			ga\SA# = SA#
			ga\EA# = EA#
			ga\R# = R#
			
		End If
		
		I = I + 1

	Wend
	CloseFile(File)
	
	
	;Let's calculate the PartCenterX and PartCenterY...
	PartCenterX# = ( MaximumXOfPart# - MinimumXOfPart# ) / 2
	PartCenterY# = ( MaximumYOfPart# - MinimumYOfPart# ) / 2
	
End Function

Function ImportGage(FileName$, LorR$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			If LorR$ = "LEFT" Then
				lg.MyLeftGage = New MyLeftGage
				lg\SX# = SX#
				lg\SY# = SY#
				lg\EX# = EX#
				lg\EY# = EY#
			End If
			If LorR$ = "RIGHT" Then
				rg.MyRightGage = New MyRightGage
				rg\SX# = SX#
				rg\SY# = SY#
				rg\EX# = EX#
				rg\EY# = EY#
			End If

		End If
	Wend
	CloseFile(File)
End Function

Function ImportBed(fileName$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			bg.MyBed = New MyBed
			bg\SX# = SX#
			bg\SY# = SY#
			bg\EX# = EX#
			bg\EY# = EY#
		End If
	Wend
	CloseFile(File)
End Function


Function DrawGages()
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#, "GREEN")
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#, "GREEN")
	Next
End Function

Function DrawLine(SX#, SY#, EX#, EY#, LineColor$)
	
	Origin PanZoomX#, PanZoomY# 
	
	Select LineColor$
		Case "GREEN"
			Color 0, 255, 0
		Case "RED"
			Color 255, 0, 0
		Case "YELLOW"
			Color 255, 255, 0
		Case "GRAY"
			Color 75, 75, 75
		Case "BLUE"
			Color 0, 0, 255
		Default
			Color 0, 255, 0
	End Select

	Line SX# * MyScale#, -SY# * MyScale#, EX# * MyScale#, -EY# * MyScale#
	;Text SX# * MyScale#, -SY# * MyScale#, SX# * MyScale# + ", " +  -SY# * MyScale#
	
	Origin 0, 0
	
End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	
	Origin PanZoomX#, PanZoomY#  
	
	Color 0, 255, 0
	
	SX# = SX# * MyScale#
	SY# = SY# * MyScale#
	R# = R# * MyScale#
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
			SA# = SA# + 2	;.5 will give a more defined arc
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend			
		End If
	End If
	
	Origin 0, 0
	 
End Function

Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function Zoom(Amount#)
	MyScale# = MyScale# + Amount#
	If MyScale# &lt; 5 Then
		MyScale# = 5
	End If
End Function

Function SelectItem()

	Select ItemToMove$
		Case "PART"
			ItemToMove$ = "BOTHGAGES"
		Case "BOTHGAGES"
			ItemToMove$ = "LEFTGAGE"
		Case "LEFTGAGE"
			ItemToMove$ = "RIGHTGAGE"
		Case "RIGHTGAGE"
			ItemToMove$ = "TOOLS"
		Default
			ItemToMove$ = "PART"
			
	End Select
		
End Function

Function UpdatePositions()
	Color 255,255,0
	SetFont fntCourier
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Move Amount : " + MovementAmount#
	Text 1, 30, "Rotation Amt: " + RotationAmount#
	Text 1, 45, "Part Details: " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + (ZAxisLeft# -CenterX#)
	Text 1, 90, "Z Axis Right: " + (ZAxisRight# - CenterX#)
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	Text 1, 135,"Zoom Level  : " + MyScale#
	Text 1, 150,"Part CenterX: " + PartCenterX#
	Text 1, 165,"Part CenterY: " + PartCenterY#
	Text 1, 180,"Prt Flipped?: " + PartFlipped$
	Text 1, 195,"Part Angle  : " + PartAngle#
	Text 1, 210,"Part Loc X  : " + PartLocationX#
	Text 1, 225,"Part Loc Y  : " + PartLocationY#
	
	SetFont fntArial
	
End Function

Function UpdateMovementAmount()
	Select MovementAmount#
		Case .125
			MovementAmount# = .5
		Case .5
			MovementAmount# = 1
		Case 1
			MovementAmount# = 6
		Case 6
			MovementAmount# = .125
	End Select
End Function

Function SelectPartDetailLevel()
	Select PartDetailsToShow$
		Case "HIGH"
			PartDetailsToShow$ = "MED"
		Case "MED"
			PartDetailsToShow$ = "LOW"
		Case "LOW"
			PartDetailsToShow$ = "HIGH"
	End Select
End Function

Function SelectRotationAmount()
	Select RotationAmount#
		Case 90
			RotationAmount# = 1
		Case 1
			RotationAmount# = 5
		Case 5
			RotationAmount# = 45
		Case 45
			RotationAmount# = 90
		Default
			RotationAmount# = 45
	End Select
End Function

Function GetUserInput$(Msg$)
	ReturnData$ = Input(Msg$)
	Return ReturnData$
End Function


Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
				
		;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
		Local localSX# = gl\SX - PartCenterX#
		Local localSY# = gl\SY - PartCenterY#
		
		Local localEX# = gl\EX - PartCenterX#
		Local localEY# = gl\EY - PartCenterY#
		
		;Rotate this copy by the angle amount.
		Local lineCos# = Cos( Amount )
		Local lineSin# = Sin( Amount )
		
		Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
		Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
		
		Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
		Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
		
		;Change the original segment to have the points of the rotated copy
		;but moved to the position of the original.
		
		gl\SX = newSX + PartCenterX#
		gl\SY = newSY + PartCenterY#
		
		gl\EX = newEX + PartCenterX#
		gl\EY = newEY + PartCenterY#			
	Next
	
	
	For gc.MyCircles = Each MyCircles

		Local clocalSX# = gc\SX - PartCenterX#
		Local clocalSY# = gc\SY - PartCenterY#
		
		Local clineCos# = Cos( Amount )
		Local clineSin# = Sin( Amount )
		
		Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
		Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
		
		gc\SX = cnewSX + PartCenterX#
		gc\SY = cnewSY + PartCenterY#
		
		;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
	Next
	
	For ga.MyArcs = Each MyArcs

		Local alocalSX# = ga\SX - PartCenterX#
		Local alocalSY# = ga\SY - PartCenterY#
		
		Local alineCos# = Cos( Amount )
		Local alineSin# = Sin( Amount )
		
		Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
		Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
		
		ga\SX = anewSX + PartCenterX#
		ga\SY = anewSY + PartCenterY#
		
		;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
		
		ga\SA# = ( ga\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
		ga\EA# = ( ga\EA# + Amount# ) Mod 360
							
	Next
	
	PartAngle# = PartAngle# + Amount#
	If PartAngle# &gt;= 360 Then
		PartAngle# = PartAngle# - 360
	End If
	
End Function


Function AddTooling()

	If ToolCount# = 0 Then
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount
		gt\Name$ = "MT030013000D"
		gt\Length# = 12
		gt\Location# = 0
		gt\Reversed$ = "NO"	
	
	Else

		SetFont fntArialLG
		
		Cls
		Flip
		
		FlushKeys
		Locate 50, 100
		;Local Name$ = GetUserInput("Enter Tool Name like:  MT030013000D...")
	
		FlushKeys
		Locate 50, 125
		;Local Length# = GetUserInput("Enter Tool Length:...")
	
		FlushKeys
		Locate 50, 150
		;Local Location$ = GetUserInput("Enter Tool Location:...")
	
		FlushKeys
		Locate 50, 175
		;Local Reversed$ = "NO"; GetUserInput("Tool Reversed? YES Or NO...")
		
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount#
		gt\Name$ = "MT026073000P";Name$
		gt\Length# = 6
		gt\Location# = (ToolCount# * 8) + ToolCount#
		gt\Reversed$ = "NO";Reversed$
		
		ToolCount# = ToolCount# + 1
		
		SetFont fntArial
		
	End If
	
		
End Function

Function DrawTooling()
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		DrawLine(SX#, SY#, EX#, EY#, "BLUE")
		DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "BLUE")
		DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "BLUE")
		DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "BLUE")
	Next
End Function

Function DisplayToolDetails()

	SetFont fntCourier
	
	I = 20
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		;Text 200, I, gt\Name$ + ", " + SX# + ",  " + SY# + ",  " + EX# + ",  " + EY# + ", Location:..." + gt\Location# + ", Length:" + gt\Length#
		Text 600, 2, "Tooling Data for debug purposes----------"
		Text 600, I, gt\Name$  + ", Location:" + gt\Location# + ", Length:" + gt\Length#
		
		I = I + 25
		;DrawLine(SX#, SY#, EX#, EY#, "RED")
		;DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "RED")
		;DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "RED")
		;DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "RED")
	Next

	SetFont fntArial
	
End Function

Function EditBends()



	
End Function

Function SaveData()
;This function will save all of the setup details to a text file that can be used to read the data back in at a later date.  This code is just started and not ready for anyone to use it


	fileout = WriteFile("C:\Temp\mydata.txt")

	WriteLine(fileout, "Start Part Geometry Information")
	WriteLine(fileout, "Material Gauge     : " + MaterialGauge$)
	WriteLine(fileout, "Material Type      : " + MaterialType$)
	WriteLine(fileout, "Part Rotation Angle: " + PartAngle#)
	WriteLine(fileout, "Part Flipped       : " + PartFlipped$)
	WriteLine(fileout, "GeometryName,StartX,StartY,EndX,EndY,StartAngle,EndAngle,Radius,IsBendLine,GeometryColor,BendDirection,BendAngle,BendLength,Punch,Die,Z-Left,Z-Right,X-Left,X-Right,InsideBend,FingerOffset-L,FingerOffset-R,GageTopOfFinger?")
	For gl.MyLines = Each MyLines
		WriteLine(fileout, gl\LName$ + "," + gl\SX# + "," + gl\SY# + "," + gl\EX# + "," + gl\EY# + "," + gl\IsBendLine$ + "," + gl\LColor$ + "," + gl\DIR$ + "," + gl\Angle# + "," + CalcDistance(gl\SX#, gl\SY#, gl\EX#, gl\EY#) + "," + gl\ZL# + "," + gl\ZR# + "," + gl\XL# + "," + gl\XR# + "," + gl\InsideBend$ + "," + gl\FO_L# + "," + FO_R# + "," + gl\GageTopOfFinger$)
	Next
	WriteLine(fileout, "End Part Geometry Information")
	
	;Let's save the left gage information...
	WriteLine(fileout, "Start Left Gage Information")
	;For lg.MyLeftGage = Each MyLeftGage
	;	WriteLine(fileout, + lg\SX# + "," + lg\SY# + "," + lg\EX# + "," + lg\EY#)
	;Next	
	WriteLine(fileout, "ZAxisLeft          : " + ZAxisLeft#)
	WriteLine(fileout, "XAxisLeft          : " + XAxisLeft#)
	WriteLine(fileout, "End Left Gage Information")

	;Let's save the right gage information...
		WriteLine(fileout, "Start Right Gage Information")
	For rg.MyLeftGage = Each MyLeftGage
		WriteLine(fileout, + rg\SX# + "," + rg\SY# + "," + rg\EX# + "," + rg\EY#)
	Next	
	WriteLine(fileout, "End Right Gage Information")
	
	;Let's save the tooling information...
	WriteLine(fileout, "Start Tooling Information")
	WriteLine(fileout, "ToolId,Name,ToolLength,ToolLocation,ToolReversed")
	For tl.MyTools = Each MyTools
		WriteLine(fileout, "ID          : " + tl\Id#)
		WriteLine(fileout, "Name        : " + tl\Name$)
		WriteLine(fileout, "Length      : " + tl\Length#)
		WriteLine(fileout, "Location    : " + tl\Location#)
		WriteLine(fileout, "Reversed    : " + tl\Reversed$)
	Next
	WriteLine(fileout, "End Tooling Information")

	CloseFile(fileout)


End Function


Function PlaySteps()
;This function will read in data that was previously saved and all the user to continue working.  This code is just started and is not ready for anyone to use.

	file=OpenFile("C:\Temp\MyData.txt")
	SaveItemToMove$ = ItemToMove$
	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		;Lets' find the first bend ...
		StringToSearchFor$ = "ZAxisLeft          :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then


			NewPosition# = Trim(Mid(Hold$, 22))
			;Let's move the left finger into position...
			
			ItemToMove$ = "LEFTGAGE"					
			If ZAxisleft# &gt;= NewPosition# Then
				While ZAxisLeft# &gt; NewPosition#
					MoveItem(-.001, "X")
				Wend
				NewPosition# = ZAxisleft#
			End If
			If ZAxisleft# &lt; NewPosition#
				While ZAxisLeft# &lt; NewPosition#
				
					MoveItem(.001, "X")
				Wend
			End If					

			ItemToMove$ = SaveItemToMove$
		End If
	Wend
	CloseFile(file)


	ToolCount# = 0
	file=OpenFile("C:\Temp\MyData.txt")

	For gt.MyTools = Each MyTools
		Delete gt
	Next

	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		;Lets' find the first bend ...
		StringToSearchFor$ = "ID          :"
		
		Found = Instr(Hold$, StringToSearchFor$)
		If Found &gt; 0  Then 
		
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))

			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			ToolCount# = ToolCount# + 1
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			ToolCount# = ToolCount# + 1
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			ToolCount# = ToolCount# + 1
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$

			ToolCount# = ToolCount# + 1
							
		End If
	Wend
	CloseFile(file)
	

End Function
</textarea>. <br><br></td></tr></table><br>
<a name="1303841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> My Math is very weak and looking for some help drawing my ARCS after flipping the part (mirror about the Y Axis).  Would someone (Kryzon?) bail me out with my ARC flipping function?<br><br>The latest version of my code is below.  Please look at the ARC section in the FlipPart function.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Graphics 1350,675,16 

AppTitle ""
Global PanZoomX# = GraphicsWidth() / 2
Global PanZoomY# = GraphicsHeight() / 2  

Global MyScale# = 10
Global EditMode = 0
Global SelectedX# =0.0
Global SelectedY# = 0.0
Global ItemToMove$ = "PART"	;Can be PART, LEFTGAGE, RIGHTGAGE, BOTHGAGES, TOOLS
Global RamDetailsToShow$ = "RAM-Low"	;Can be RAM-All, RAM-Medium, RAM-Low
Global RotationAmount# = 5
Global PartDetailsToShow$ = "HIGH"	;Can be HIGH, MED, LOW
Global MovementAmount# = .5
Global ZAxisLeft# = 0
Global ZAxisRight# = 0
Global XAxisRight# = 0
Global XAxisLeft# = 0
Global PartLocationX# = 0
Global PartLocationY# = 0
Global MinimumXOfPart# = 10000
Global MaximumXofPart# = -10000
Global MinimumYOfPart# = 10000
Global MaximumYOfPart# = -10000
Global PartCenterX# = 10000
Global PartCenterY# = 10000
Global PartFlipped$ = "NO"	;Can be YES or NO
Global PartAngle# = 0
Global CenterX# = 0
Global CenterY# = 0
Global ToolWidth# = 1.5
Global ToolCount# = 0
Global MaterialGage$ = "14"		;Can be 11, 14, 16, 18, 20, 22, 24, 26
Global MaterialType$ = "MILD"		;Can be MILD, STAINLESS

Type MyLines
	Field GraphicType$      ;LINE, CIRCLE, OR ARC
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
	Field IsBendLine$       ;IS A BEND LINE YES or NO
	Field LColor$           ;LINE COLOR
	Field LName$            ;LINE NAME
	Field BendSeqNumber#    ;BEND SEQUENCE NUMBER
	Field Dir$              ;BEND DIRECTION UP or Dn
	Field Angle#            ;BEND ANGLE
	Field BendLength#       ;BEND LENGTH
	Field ZL#               ;ZLeft
	Field ZR#               ;ZRight
	Field XL#               ;XLeft
	Field XR#               ;XRight
	Field InsideBend$	    ;INSIDE BEND DIMENSION INSIDE or OUTSIDE
	Field FO_L#             ;FINGER OFFSET LEFT
	Field FO_R#             ;FINGER OFFSET Right
	Field GageTopOfFinger$  ;GAGE ON TOP OF THE BACKGAGE FINGER ...GAGETOP or GAGENORMAL
End Type

Type MyCircles
	Field GraphicType$      ;CIRCLE
	Field CName$			;CIRCLE NAME
	Field SX#               ;CIRCLE START POINT X
	Field SY#               ;CIRCLE START POINT Y
	Field EX#               ;CIRCLE END POINT X
	Field EY#               ;CIRCLE END POINT Y
	Field R#				;CIRCLE RADIUS

End Type

Type MyArcs
	Field GraphicType$      ;ARC
	Field AName$			;ARC NAME
	Field SX#               ;ARC START POINT X
	Field SY#               ;ARC START POINT Y
	Field SA#				;ARC START ANGLE
	Field EA#				;ARC END ANGLE
	Field R#				;ARC RADIUS
End Type

Type MyTools
	Field Id				;Tool Id
	Field Name$         	;Tool Number
	Field Length#   		;Tool Length
	Field Location# 		;Tool Location on bed (centerline of machine to rigth edge of tool)
	Field Reversed$     	;Tool reversed (YES Or NO)
End Type

Type MyLeftGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyRightGage
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type

Type MyBed
	Field SX#               ;LINE START POINT X
	Field SY#               ;LINE START POINT Y
	Field EX#               ;LINE END POINT X
	Field EY#               ;LINE END POINT Y
End Type


;Import Part Data...
;ImportDXFFile ("C:\Temp\junkoriginal1.txt")
;ImportDXFFile ("C:\Temp\junkoriginal2.txt")
;ImportDXFFile ("C:\Temp\junkoriginal3.txt")	;Lots of holes
;ImportDXFFile ("C:\Temp\junkoriginal6.txt")	;Metric Units
;ImportDXFFile ("C:\Temp\junkoriginal8.txt")
;ImportDXFFile ("C:\Temp\junkoriginal9.txt")
;ImportDXFFile ("C:\Temp\junkoriginal5.txt")

;For testing, I am going to write this 2D CAD data to a text file on c:\tempjunkoriginal.txt"
fileout = WriteFile("C:\Temp\Test_2D_DXF_CAD_Data.txt")
	WriteLine(fileout, "Line,0.000,0.125,0.000,11.750")
	WriteLine(fileout, "Line,0.250,12.000,11.500,12.000")
	WriteLine(fileout, "Line,12.000,11.500,12.000,1.000")
	WriteLine(fileout, "LINE,11.000,12.000,11.000,0.000")
	WriteLine(fileout, "Line,11.000,0.000,0.125,0.000")
	WriteLine(fileout, "Line,6.282,6.220,6.817,6.754")
	WriteLine(fileout, "Line,7.414,6.507,7.414,5.938")
	WriteLine(fileout, "Line,6.213,5.600,6.768,4.719")
	WriteLine(fileout, "Line,7.414,5.938,7.414,4.906")
	WriteLine(fileout, "Line,1.637,3.213,3.137,3.213")
	WriteLine(fileout, "Line,4.637,2.213,4.637,1.213")
	WriteLine(fileout, "Line,4.637,1.213,3.137,1.213")
	WriteLine(fileout, "Line,1.637,3.213,1.637,2.213")
	WriteLine(fileout, "Line,3.137,3.213,4.637,2.213")
	WriteLine(fileout, "Line,3.137,1.213,1.637,2.213")
	WriteLine(fileout, "Line,6.970,9.801,8.385,8.386")
	WriteLine(fileout, "Line,9.092,9.093,7.677,10.508")
	WriteLine(fileout, "ARC,0.125,0.125,0.125,180.000,270.000")
	WriteLine(fileout, "ARC,0.250,11.750,0.250,90.000,180.000")
	WriteLine(fileout, "ARC,11.500,11.500,0.500,0.000,90.000")
	WriteLine(fileout, "ARC,11.000,1.000,1.000,270.000,0.000")
	WriteLine(fileout, "ARC,7.064,6.507,0.350,0.000,135.000")
	WriteLine(fileout, "ARC,6.636,5.866,0.500,135.000,212.227")
	WriteLine(fileout, "ARC,7.064,4.906,0.350,212.227,0.000")
	WriteLine(fileout, "ARC,8.738,8.740,0.500,225.000,45.000")
	WriteLine(fileout, "ARC,7.324,10.154,0.500,45.000,225.000")
	WriteLine(fileout, "CIRCLE,3.000,8.938,2.500")
CloseFile(fileout)
ImportDXFFile ("C:\Temp\Test_2D_DXF_CAD_Data.txt")



;Import Gage Data...
;For testing, I am going to write this Left Gage data to a text file on c:\temp\leftfinger.txt"
fileout = WriteFile("C:\Temp\leftfinger.txt")
	WriteLine(fileout, "Line,0.125,0.000,0.125,2.500")
	WriteLine(fileout, "Line,0.125,2.500,-1.875,2.500")
	WriteLine(fileout, "Line,-1.875,2.500,-1.875,1.000")
	WriteLine(fileout, "Line,0.125,0.000,-0.125,0.000")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,0.125")
	WriteLine(fileout, "Line,-0.125,0.125,-1.875,1.000")
	WriteLine(fileout, "Line,-1.875,1.000,-0.875,1.000")
	WriteLine(fileout, "Line,-0.875,1.000,-0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\LeftFinger.txt", "LEFT")


;For testing, I am going to write this Right Gage data to a text file on c:\temp\rightfinger.txt"
fileout = WriteFile("C:\Temp\Rightfinger.txt")
	WriteLine(fileout, "Line,-0.125,0.000,-0.125,2.500")
	WriteLine(fileout, "Line,-0.125,2.500,1.875,2.500")
	WriteLine(fileout, "Line,1.875,2.500,1.875,1.000")
	WriteLine(fileout, "Line,-0.125,0.000,0.125,0.000")
	WriteLine(fileout, "Line,0.125,0.000,0.125,0.125")
	WriteLine(fileout, "Line,0.125,0.125,1.875,1.000")
	WriteLine(fileout, "Line,1.875,1.000,0.875,1.000")
	WriteLine(fileout, "Line,0.875,1.000,0.875,2.500")
CloseFile(fileout)
ImportGage ("C:\Temp\RightFinger.txt", "RIGHT")



Origin 450,450 



;Import Bed Data...
;For testing, I am going to write this Right Gage data to a text file on c:\temp\rightfinger.txt"
fileout = WriteFile("C:\Temp\AutoformBed.txt")
	WriteLine(fileout, "Line,-60.000,-1.250,-60.000,1.250")
	WriteLine(fileout, "Line,-60.000,1.250,60.000,1.250")
	WriteLine(fileout, "Line,60.000,1.250,60.000,-1.250")
	WriteLine(fileout, "Line,60.000,-1.250,-60.000,-1.250")
	WriteLine(fileout, "Line,-60.000,0.000,60.000,0.000")
	WriteLine(fileout, "Line,0.000,-1.250,0.000,1.250")
CloseFile(fileout)
ImportBed("C:\Temp\AutoformBed.txt")
ItemToMove$ = "BED"
MoveItem(CenterX#, "X")


;Let's move the items into view...
ItemToMove$ = "RIGHTGAGE"
MoveItem(CenterX# + 12, "X")

ItemToMove$ = "LEFTGAGE"
MoveItem(CenterX#- 12, "X")

ItemToMove$ = "BOTHGAGES"
MoveItem(2, "Y")

ItemToMove$ = "PART"
MoveItem(CenterX# - PartCenterX#, "X")
MoveItem(-PartCenterY# - 12, "Y")


;Let's setup some fonts...
Global fntArial=LoadFont("Calibri",15,False,False,False)
Global fntArialLG= LoadFont("Calibri",25,False,False,False)
LoadFont("Calibri",20,False,False,False)
Global fntCourier=LoadFont("Courier New",15,False,False,False)
SetFont fntArial 




;Let's add a tool to begin with...
AddTooling()




; Wait for ESC to hit 
While Not KeyHit(1)
	SetBuffer BackBuffer()

	ClsColor 0, 0, 0
	Cls

	;Let's display some of the various conditions and settings for the user...
	UpdatePositions()
	

	;DrawTooling now...
	DrawTooling()

	;Draw the Ram now...
	DrawBed()

	If KeyHit(88) Then	;(F12)
		SelectRamDetailLevel()
	End If

	;Let's draw the backgages now...
	DrawGages()


	;Let's draw the part now...
	DrawPart()

	;Move items around on the screen below...
	If KeyDown(203) ;(Left key)
		MoveItem(-MovementAmount#, "X")
	End If
	If KeyDown(205) ;(Right Key)
		MoveItem(MovementAmount#, "X")
	End If		
	If KeyDown(200) ;(Up Key)
		MoveItem(MovementAmount#, "Y")
	End If
	If KeyDown(208) ;(Down Key)
		MoveItem(-MovementAmount#, "Y")
	End If		

;	;Let the user select what needs to move...
;	If KeyHit(50) Then	;(M key)
;		SelectItem()
;	End If
;	
;	;Let's set the Movement Amount below...
;	If KeyHit(60) Then	;F2
;		UpdateMovementAmount()
;	End If	
;
;	;Let's set the level of details to show on the part, lower selection speeds up part movement
;	If KeyHit(59) Then	;F1
;		SelectPartDetailLevel()
;	End If
;
;	If KeyHit(63) Then	;(F5)
;		SelectRotationAmount()
;	End If
;	
	;Rotate Part...
	If KeyHit(62) ;(F4 key)
		RotatePart(RotationAmount#)
	End If	
	
	;Let's see if the user wants to add some tooling below...
	If KeyHit(20) Then	;(T key)
		AddTooling()
	End If
	;Let's see if the user wants to add some tooling above...
;
;	;Move "CAMERA" type functionality below...
;	If KeyDown(66) Then ;(F8)	;Move CAM left
;		PanZoomX# = PanZoomX# -10
;	End If
;	
;	If KeyDown(67) Then ;(F9)	;Move CAM right
;		PanZoomX# = PanZoomX# +10
;	End If
;
;	If KeyDown(68) Then ;(F10)	;Move CAM Up
;		PanZoomY# = PanZoomY# -10		
;	End If
;	
;	If KeyDown(87) Then ;(F11)	;Move CAM Down
;		PanZoomY# = PanZoomY# + 10		
;	End If
;	;Move "CAMERA" type functionality above...


	;Disply tooling details to the user...
	DisplayToolDetails()

	
	;Let's use the mousewheel to zoom in / out...
	If MouseZ() &lt;&gt; SaveMouseZ# Then
		If MouseZ() &gt; SaveMouseZ# Then
			Zoom(-3)
		Else
			Zoom(3)
		End If
		SaveMouseZ# = MouseZ()
	End If


	;Let's use the mouse to move items on the screen...
	;If MouseDown(1) And KeyDown(29) Then
	;	MoveItem(-MovementAmount#, "X")
	;End If
	;If MouseDown(2) And KeyDown(29) Then
	;	MoveItem(MovementAmount#, "X")
	;End If
	

	;Let's see if the user wants to edit any bends...
	;This is not working and needs some work
	If MouseDown(2) Then
		Select EditMode
			Case 1
				EditMode = 0
			Case 0
				EditMode = 1
				;EditBends()		
		End Select
	End If



	If EditMode = 1 Then

		;Let's find the line the user clicks on and edit it...

		SelectedX# = MouseX()
		SelectedY# = MouseY()
		
		;Let's find the line the user clicks on and edit it...
		For gl.MyLines = Each MyLines
			If Abs(SelectedX# - (PanZoomX# + (gl\SX# + gl\EX#) / 2 * MyScale#)) &lt; 5 And Abs(SelectedY# - (PanZoomY# - (gl\SY# + gl\EY#) / 2 * MyScale)) &lt; 5 Then
				MoveMouse PanZoomX# + (gl\SX# + gl\EX#) / 2 * MyScale#, PanZoomY# - (gl\SY# + gl\EY#) / 2 * MyScale
				
				Msg$ = gl\LName$ + ", IsBendLine: " + gl\IsBendLine$ + ", X-Left: " + gl\XL# + ", X-Right: " + gl\XR# + ", Bend Angle: " + gl\Angle$ + ", Bend Direction: " + gl\DIR$ + ", Z-Left: " + gl\ZL# + ", Z-Right: " + gl\ZR#

				SetFont fntArialLG
				Text MouseX() + 8, MouseY() - 250, "Press L to MOVE LINE LEFT"
				Text MouseX() + 8, MouseY() - 225, "Press R to MOVE LINE RIGHT"
				Text MouseX() + 8, MouseY() - 200, "Press N to MOVE LINE DOWN"
				Text MouseX() + 8, MouseY() - 175, "Press M to MOVE LINE UP"
				Text MouseX() + 8, MouseY() - 150, "Press C to copy Line Down"
				Text MouseX() + 8, MouseY() - 125, "Press D to delete this line"
				Text MouseX() + 8, MouseY() - 100, "Press B to Make this Line a Bend LINE"
				Text MouseX() + 8, MouseY() - 75, "Press Z to Set Bend Direction"
				

				SetFont fntArial
				Text MouseX() + 8, MouseY() -25, Msg$
			
				If MouseHit(1) Then	;Let's get the data from the picked line and put it into a file and show it to the user
					MoveMouse MouseX(), MouseY() + 25
					Cls
					Flip
					FlushKeys
					Ans$ = Input("Copy Z Axis Dimensions to this step? 1 = Yes ")
					If Ans$ = "1" Then
						gl\ZL# = ZAxisLeft#
						gl\ZR# = ZAxisRight#
					End If
					
					fileout = WriteFile("C:\Temp\EditLine.txt")
					WriteLine(fileout,"GRAPHIC TYPE         :" + gl\GraphicType$)
					WriteLine(fileout,"LINE NAME            :" + gl\LName$)
					WriteLine(fileout,"IS BEND LINE         :" + gl\IsBendLine$)
					WriteLine(fileout,"BEND SEQUENCE NUMBER :" + GL\BendSeqNumber#)
					WriteLine(fileout,"BEND ANGLE           :" + gl\Angle$)
					WriteLine(fileout,"BEND DIRECTION       :" + gl\DIR$)
					WriteLine(fileout,"BEND LENGTH          :" + gl\BendLength#)		
					WriteLine(fileout,"INSIDE BEND          :" + GL\InsideBend$)
					WriteLine(fileout,"GAGE TOP OF FINGER   :" + GL\GageTopOfFinger$)
					WriteLine(fileout,"X-LEFT               :" + gl\XL#)
					WriteLine(fileout,"X-RIGHT              :" + gl\XR#)
					WriteLine(fileout,"Z-LEFT               :" + gl\ZL#)
					WriteLine(fileout,"Z-RIGHT              :" + gl\ZR#)
					WriteLine(fileout,"FINGER OFFSET LEFT   :" + GL\FO_L#)
					WriteLine(fileout,"FINGER OFFSET RIGHT  :" + GL\FO_R#)
					WriteLine(fileout,"START X              :" + gl\SX#)
					WriteLine(fileout,"START Y              :" + gl\SY#)
					WriteLine(fileout,"END X                :" + gl\EX#)
					WriteLine(fileout,"END Y                :" + gl\EY#)
					WriteLine(fileout,"LINE COLOR           :" + gl\LColor$)
					CloseFile(fileout)
					
					ExecFile("C:\Temp\EditLine.txt")
					
					Cls
					Text GraphicsWidth() / 2, 20, "Hit any key to continue..."
					WaitKey()
					FlushKeys
					;read in text file just created now...
					ReadInEditedLine()

				End If
				
				If KeyHit(32) Then	;(D key) DELETE LINE
					Delete gl
				End If
				If KeyHit(48) Then	;(B Key) TOGGLE ISBENDLINE
					Select gl\IsBendLine$
						Case "YES"
							gl\IsBendLine$ = "NO"
							gl\LColor$ = "GREEN"
						Case "NO"
							gl\IsBendLine$ = "YES"
							gl\LColor$ = "YELLOW"
					End Select

				End If	
				If KeyHit(44) Then	;(Z Key) TOGGLE BEND DIRECTION
					Select gl\DIR$
						Case "UP"
							gl\DIR$ = "DN"
							gl\LColor$ = "RED"
						Case "DN"
							gl\DIR$ = "UP"
							gl\LColor$ = "YELLOW"
					End Select
				End If
				If KeyHit(46) Then	;(C Key) COPY HORIZONTAL LINE DOWN
					saveSX# = gl\SX#
					saveSY# = gl\SY#
					saveEX# = gl\EX#
					saveEY# = gl\EY#
					saveIsBendLine$ = "NO"
					saveLColor$ = "GREEN"
					saveDIR$ = "UP"
					saveAngle# = 90
					saveBendLength# = CalcDistance(SX#, SY#, EX#, EY#)
					saveZL# = gl\ZL#
					saveZR# = gl\ZR#
					saveXL# = gl\XL#
					saveXR# = gl\XR#				


					gl.MyLines = New MyLines
					gl\GraphicType$ = "LINE"
					gl\LName$ = "LINE_" + I
					gl\SX# = saveSX#
					gl\SY# = saveSY# - .1
					gl\EX# = saveEX#
					gl\EY# = saveEY# - .1
					saveIsBendLine$ = "NO"
					saveLColor$ = "GREEN"
					saveDIR$ = "UP"
					saveAngle# = 90
					saveBendLength# = CalcDistance(SX#, SY#, EX#, EY#)
					gl\ZL# = saveZL#
					gl\ZR# = saveZR#
					gl\XL# = saveXL#
					gl\XR# = saveXR#
					
				End If
				
				If KeyHit(49) Then	;(N Key)  MOVE LINE DOWN VERTICALLY
					gl\SY# = gl\SY# - .02
					gl\EY# = gl\EY# - .02
				End If
				If KeyHit(50) Then	;(M Key)  MOVE LINE UP VERTICALLY
					gl\SY# = gl\SY# + .02
					gl\EY# = gl\EY# + .02
				End If	
				If KeyHit(38) Then	;(L Key)  MOVE LINE LEFT HORIZONTALLY
					gl\SX# = gl\SX# - .02
					gl\EX# = gl\EX# - .02
				End If
				If KeyHit(19) Then	;(R Key)  MOVE LINE RIGHT HORIZONTALLY
					gl\SX# = gl\SX# + .02
					gl\EX# = gl\EX# + .02
				End If	
				
				
				If KeyHit(34) Then	;(G Key)  MOVE GAGES TO SELECTED LINE
					

					SaveItemToMove$ = ItemToMove$


					;Let's move the left gage into position now...
					LGageLocX# = ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60) - 2 - (.85 * (gl\EX# - gl\SX#) / 2)
					LGageLocY# = (PartLocationY# + MaximumYOfPart# + gl\SY#)

					RGageLocX# = ((gl\EX# - gl\SX#) / 2 + PartLocationX# - 60) + 2 + (.85 * (gl\EX# - gl\SX#) / 2)
					RGageLocY# = (PartLocationY# + MaximumYOfPart# + gl\SY#)

					DistanceToMoveX# = LGageLocX# - ZAxisLeft#
					DistanceToMoveY# = (XAxisLeft# - LGageLocY#)
					
					If XAxisLeft# - DistanceToMoveY# &lt;= 0 Then
						DistanceToMoveY# = DistanceToMoveY# - (XAxisLeft# + DistanceToMoveY#)
					End If
					
					ItemToMove$ = "LEFTGAGE"

					MoveItem(DistanceToMoveX#, "X")

					DistanceToMoveX# = RGageLocX# - ZAxisRight#
					DistanceToMoveY# = (XAxisRight# - RGageLocY#)
					
					If XAxisRight# - DistanceToMoveY# &lt;= 0 Then
						DistanceToMoveY# = DistanceToMoveY# - (XAxisRight# + DistanceToMoveY#)				
					End If

					ItemToMove$ = "RIGHTGAGE"

					MoveItem(DistanceToMoveX#, "X")

					ItemToMove$ = SaveItemToMove$

				End If
				
				
				;Lets move the bend line up to the machine centerline Y
				If KeyHit(24) Then
					If (PartLocationY# + MaximumYOfPart# + gl\SY#) &lt; 0 Then
						While (PartLocationY# + MaximumYOfPart# + gl\SY#) &lt; 0
							MoveItem(.001, "Y")
							;WaitKey()
						Wend
					Else
						While (PartLocationY# + MaximumYOfPart# + gl\SY#) &gt; 0
							MoveItem(-.001, "Y")
							;WaitKey()
						Wend
					End If
				End If
											
			End If
		Next
		
	End If
	
	If EditMode = 1 Then
		Rect MouseX() -4, MouseY() -4, 8, 8, False
	End If


	;Let's see if the user is over a tool and if so, pop up the tooling information...
	PopUpToolingInfo()
	

	;draw cross-hairs...
	;Color 255,255,0
	;Line MouseX(), 0, MouseX(),GraphicsHeight()
	;Line 0, MouseY(), GraphicsWidth(), MouseY()
	;HidePointer


	;Let's see if the user wants to save the data...
	If KeyHit(31) Then	;(S Key)
		SaveData()
	End If
	
	If KeyHit(32) Then	;(D Key)
		PlaySteps()
	End If

	If MouseHit(1) Then
		X# = MouseX()
		Y#= MouseY()
		WhereClicked(X#, Y#)
	End If


	;Let's test OPEN PART2
	If KeyHit(24) Then
		OpenPart()
	End If
	
	;Let's import the tooling setup...
	If KeyHit(23) Then
		ImportToolingSetup()
	End If

	;Let's put some CAMERA rectangles on the screen to control the camera...

	Text 2, 580, "CAMERA"
		
	Rect 2, 625, 20, 20, False
	Text 3, 628, "LFT"
	
	Rect 23, 625, 20, 20, False
	Text 27, 628, "RT"
	
	Rect 14, 600, 20, 20, False
	Text 16, 603, "UP"

	Rect 14, 650, 20, 20, False
	Text 16, 653, "DN"
	
	
	;Let's put some rotate rectangles on the screen for rotating the part...
	
	Text 57, 580, "ROTATE PART"
	Rect 65, 600, 20, 20, False
	Text 67, 603, "LFT"
	
	Rect 90, 600, 20, 20, False
	Text 93, 603, "RT"
	
	Text 65, 640, "FLIP PART"
	
	;Let's put some move part rectangles on the screen for moving the part
	Text 147, 580, "MOVE PRT"
		
	Rect 150, 625, 20, 20, False
	Text 153, 628, "LFT"
	
	Rect 173, 625, 20, 20, False
	Text 177, 628, "RT"
	
	Rect 164, 600, 20, 20, False
	Text 166, 603, "UP"

	Rect 164, 650, 20, 20, False
	Text 166, 653, "DN"		
	
	Flip
	
Wend 

Function DrawPart()
	;Let's draw the part now below...
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				DrawLine(gl\SX#, gl\SY#, gl\EX#, gl\EY#, gl\LColor$)
		End Select
	Next
	If PartDetailsToShow$ = "HIGH" Or PartDetailsToShow$ = "MED" Then
		For cl.MyCircles = Each MyCircles
			DrawArc(cl\SX#, cl\SY#, 0, 359.5, cl\R#)
		Next
	End If

	If PartDetailsToShow$ = "HIGH" Then
		For al.MyArcs = Each MyArcs
			DrawArc(al\SX#, al\SY#, al\SA#, al\EA#, al\R#)
		Next					
	End If
End Function

Function DrawBed()
	For bg.MyBed = Each MyBed
		DrawLine(bg\SX#, bg\SY#, bg\EX#, bg\EY#, "GRAY")
	Next
End Function

Function MoveItem(Amount#, Direction$)
	Select Direction$
		Case "X"
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SX# = gl\SX# + Amount#
						gl\EX# = gl\EX# + Amount#
					Next
					For cl.MyCircles = Each MyCircles
						cl\SX# = cl\SX# + Amount#
						cl\EX# = cl\EX# + Amount#
					Next
					For ga.MyArcs = Each MyArcs
						ga\SX# = ga\SX# + Amount#
					Next
														
					PartCenterX# = PartCenterX# + Amount#
					PartLocationX# = PartLocationX# + Amount#
					
				Case "BOTHGAGES"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next
					ZAxisLeft# = ZAxisLeft# + Amount#
					ZAxisRight# = ZAxisRight# + Amount#
		
				Case "LEFTGAGE"
					For lg.MyLeftGage = Each MyLeftGage
						lg\SX# = lg\SX# + Amount#	
						lg\EX# = lg\EX# + Amount#	
					Next		
					ZAxisLeft# = ZAxisLeft# + Amount#
		
				Case "RIGHTGAGE"
					For rg.MyRightGage = Each MyRightGage
						rg\SX# = rg\SX# + Amount#	
						rg\EX# = rg\EX# + Amount#	
					Next		
					ZAxisRight# = ZAxisRight# + Amount#

				Case "BED"
					For bg.MyBed = Each MyBed
						bg\SX# = bg\SX# + Amount#	
						bg\EX# = bg\EX# + Amount#	
					Next	
					
				Case "TOOLS"
					For gt.MyTools = Each MyTools
						gt\Location#  = gt\Location# + Amount#	
					Next					
			End Select	
		
		Case "Y"
			BottomL# = 0
			BottomR# = 0
			If XAxisRight# &lt;= 0 And Amount# &lt;= 0 Then
				 BottomR# = 1
			End If
			If XAxisLeft# &lt;= 0 And Amount# &lt;= 0 Then
				BottomL# = 1
			End If
		
			Select ItemToMove$
				Case "PART"
					For gl.MyLines = Each MyLines
						gl\SY# = gl\SY# + Amount#
						gl\EY# = gl\EY# + Amount#
					Next
					
					For gc.MyCircles = Each MyCircles
						gc\SY# = gc\SY# + Amount#
						gc\EY# = gc\EY# + Amount#
					Next
					
					For ga.MyArcs = Each MyArcs
						ga\SY# = ga\SY# + Amount#
					Next
						
					PartCenterY# = PartCenterY# + Amount#
					PartLocationY# = PartLocationY# + Amount#
													
				Case "BOTHGAGES"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next
						XAxisLeft# = XAxisLeft# + Amount#
					End If
		
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next
						XAxisRight# = XAxisRight# + Amount#
					End If
					
				Case "LEFTGAGE"
					If BottomL# = 0 Then
						For lg.MyLeftGage = Each MyLeftGage
							lg\SY# = lg\SY# + Amount#	
							lg\EY# = lg\EY# + Amount#	
						Next		
						XAxisLeft# = XAxisLeft# + Amount#
					End If
					
				Case "RIGHTGAGE"
					If BottomR# = 0 Then
						For rg.MyRightGage = Each MyRightGage
							rg\SY# = rg\SY# + Amount#	
							rg\EY# = rg\EY# + Amount#	
						Next		
						XAxisRight# = XAxisRight# + Amount#
					End If
			End Select	
		
	End Select
		
End Function


Function ImportDXFFile(FileName$)
	I = 1
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#)
		
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = "LINE_" + I
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\IsBendLine$ = "NO"
			gl\LColor$ = "GREEN"
			gl\DIR$ = "UP"
			gl\Angle# = 90
			gl\BendLength# = CalcDistance(SX#, SY#, EX#, EY#)
			gl\ZL# = 999
			gl\ZR# = 999
			gl\XL# = 999
			gl\XR# = 999
			gl\BendSeqNumber# = 1
			gl\InsideBend$ = "OUTSIDE"
			gl\FO_L# = 0
			gl\FO_R# = 0
			gl\GageTopOfFinger$ = "GAGENORMAL"
			
			
			If MinimumXOfPart# &gt; SX# Then
				MinimumXOfPart# = SX#
			End If
			If MinimumXOfPart# &gt; EX# Then
				MinimumXOfPart# = EX#
			End If
			If MaximumXOfPart# &lt; SX# Then
				MaximumXOfPart# = SX#
			End If
			If MaximumXOfPart# &lt; EX# Then
				MaximumXOfPart# = EX#
			End If
			
			If MinimumYOfPart# &gt; SY# Then
				MinimumYOfPart# = SY#
			End If
			If MinimumYOfPart# &gt; EY# Then
				MinimumYOfPart# = EY#
			End If
			If MaximumYOfPart# &lt; SY# Then
				MaximumYOfPart# = SY#
			End If
			If MaximumYOfPart# &lt; EY# Then
				MaximumYOfPart# = EY#
			End If			
			
		End If

		
		If Instr(Hold$,"CIRCLE") Then
			Hold$ = Mid$(Hold$,8)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			R# = Trim(Hold$)
	
			;DrawCircle(CX#, CY#, R#)
			
			gc.MyCircles = New MyCircles
			gc\GraphicType$ = "CIRCLE"
			gc\CName$ = "CIRCLE_" + I
			gc\SX# = SX#
			gc\SY# = SY#
			gc\EX# = 999
			gc\EY# = 999
			gc\R# = R#

		End If	

		If Instr(Hold$,"ARC") Then
			Hold$ = Mid$(Hold$, 5)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				R# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If

			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SA# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EA# = Trim(Hold$)
	
			;DrawArc(SX#, SY#, SA#, EA#, R#)
			
			ga.MyArcs = New MyArcs
			ga\GraphicType$ = "ARC"
			ga\AName$ = "ARC_" + I
			ga\SX# = SX#
			ga\SY# = SY#
			ga\SA# = SA#
			ga\EA# = EA#
			ga\R# = R#
			
		End If
		
		I = I + 1

	Wend
	CloseFile(File)
	
	
	;Let's calculate the PartCenterX and PartCenterY...
	PartCenterX# = ( MaximumXOfPart# - MinimumXOfPart# ) / 2
	PartCenterY# = ( MaximumYOfPart# - MinimumYOfPart# ) / 2
	
End Function

Function ImportGage(FileName$, LorR$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			If LorR$ = "LEFT" Then
				lg.MyLeftGage = New MyLeftGage
				lg\SX# = SX#
				lg\SY# = SY#
				lg\EX# = EX#
				lg\EY# = EY#
			End If
			If LorR$ = "RIGHT" Then
				rg.MyRightGage = New MyRightGage
				rg\SX# = SX#
				rg\SY# = SY#
				rg\EX# = EX#
				rg\EY# = EY#
			End If

		End If
	Wend
	CloseFile(File)
End Function

Function ImportBed(fileName$)
	file=OpenFile(FileName$)
	While Not Eof(file)
		Hold$ = Upper$(ReadLine$(file))
		
		If Instr(Hold$,"LINE") Then
			Hold$ = Mid$(Hold$,6)
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				SY# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			Found = Instr(Hold$,",")
			If Found &gt; 0 Then
				EX# = Left(Hold$,Found-1)
				Hold$ = Mid(Hold$,Found + 1)
			End If
			
			EY# = Trim(Hold$)
	
			;DrawLine(SX#,SY#,EX#,EY#, "GREEN")
		
			bg.MyBed = New MyBed
			bg\SX# = SX#
			bg\SY# = SY#
			bg\EX# = EX#
			bg\EY# = EY#
		End If
	Wend
	CloseFile(File)
End Function


Function DrawGages()
	For lg.MyLeftGage = Each MyLeftGage
		DrawLine(lg\SX#, lg\SY#, lg\EX#, lg\EY#, "GREEN")
	Next
	For rg.MyRightGage = Each MyRightGage
		DrawLine(rg\SX#, rg\SY#, rg\EX#, rg\EY#, "GREEN")
	Next
End Function

Function DrawLine(SX#, SY#, EX#, EY#, LineColor$)
	
	Origin PanZoomX#, PanZoomY# 
	
	Select LineColor$
		Case "GREEN"
			Color 0, 255, 0
		Case "RED"
			Color 255, 0, 0
		Case "YELLOW"
			Color 255, 255, 0
		Case "GRAY"
			Color 75, 75, 75
		Case "BLUE"
			Color 0, 0, 255
		Default
			Color 0, 255, 0
	End Select

	Line SX# * MyScale#, -SY# * MyScale#, EX# * MyScale#, -EY# * MyScale#
	;Text SX# * MyScale#, -SY# * MyScale#, SX# * MyScale# + ", " +  -SY# * MyScale#
	
	Origin 0, 0
	
End Function

Function DrawCircle(SX#, SY#, R#)
	Color 0,255,0
	DrawArc(SX#, SY#, 0, 359.5, R#)	;Let's use the draw arc code instead to draw circles
End Function

Function DrawArc(SX#, SY#, SA#, EA#, R#)
	
	Origin PanZoomX#, PanZoomY#  
	
	Color 0, 255, 0
	
	SX# = SX# * MyScale#
	SY# = SY# * MyScale#
	R# = R# * MyScale#
	If SA# = 360 Then
		SA# = 0
	End If
	If SA# &lt;= EA# Then
		While SA# &lt;= EA#
			Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
			SA# = SA# + 2	;.5 will give a more defined arc
		Wend
	Else
		If EA# &lt; 360 Then
			While 360 &gt; SA#
				Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend
			SA# = 0
        
			While SA# &lt;= EA#
				Plot SX# + Cos(SA#) * R#, - SY# - Sin(SA#) * R#
				SA# = SA# + 2	;.5 will give a more defined arc
			Wend			
		End If
	End If
	
	Origin 0, 0
	 
End Function

Function FlipPart()
	For gl.MyLines = Each MyLines
		Select gl\GraphicType$
			Case "LINE"
				gl\SX# = gl\SX# * -1
				gl\EX# = gl\EX# * -1
		End Select
	Next 
	
	For gc.MyCircles = Each MyCircles
		gc\SX# = gc\SX# * -1
	Next
	
	For ga.MyArcs = Each MyArcs
		;*** Need help with this code.  The arcs are not drawing correctly after flipping (Mirror about the Y Axis).  My Math is very weak.
		ga\SX# = ga\SX# * -1
		
		If ga\SA# &lt; ga\EA# Then


		Else
		
		End If
		
		ga\EA# = ga\SA# + 180
		ga\SA# = ga\EA#	
	
	Next

	Select PartFlipped$
		Case "YES"
			PartFlipped$ = "NO"
		Case "NO"
			PartFlipped$ = "YES"
	End Select

End Function

Function RotatePart(Amount#)

	For gl.MyLines = Each MyLines
				
		;Move a "copy" of the segment so that it considers the MachineCenter point as the origin.
		Local localSX# = gl\SX - PartCenterX#
		Local localSY# = gl\SY - PartCenterY#
		
		Local localEX# = gl\EX - PartCenterX#
		Local localEY# = gl\EY - PartCenterY#
		
		;Rotate this copy by the angle amount.
		Local lineCos# = Cos( Amount )
		Local lineSin# = Sin( Amount )
		
		Local newSX# = ( localSX * lineCos ) - ( localSY * lineSin )
		Local newSY# = ( localSX * lineSin ) + ( localSY * lineCos )
		
		Local newEX# = ( localEX * lineCos ) - ( localEY * lineSin )
		Local newEY# = ( localEX * lineSin ) + ( localEY * lineCos )
		
		;Change the original segment to have the points of the rotated copy
		;but moved to the position of the original.
		
		gl\SX = newSX + PartCenterX#
		gl\SY = newSY + PartCenterY#
		
		gl\EX = newEX + PartCenterX#
		gl\EY = newEY + PartCenterY#			
	Next
	
	
	For gc.MyCircles = Each MyCircles

		Local clocalSX# = gc\SX - PartCenterX#
		Local clocalSY# = gc\SY - PartCenterY#
		
		Local clineCos# = Cos( Amount )
		Local clineSin# = Sin( Amount )
		
		Local cnewSX# = ( clocalSX * clineCos ) - ( clocalSY * clineSin )
		Local cnewSY# = ( clocalSX * clineSin ) + ( clocalSY * clineCos )
		
		gc\SX = cnewSX + PartCenterX#
		gc\SY = cnewSY + PartCenterY#
		
		;The EX and EY values of a circle part are never used, a circle only has a start point (its centre).
										
	Next
	
	For ga.MyArcs = Each MyArcs

		Local alocalSX# = ga\SX - PartCenterX#
		Local alocalSY# = ga\SY - PartCenterY#
		
		Local alineCos# = Cos( Amount )
		Local alineSin# = Sin( Amount )
		
		Local anewSX# = ( alocalSX * alineCos ) - ( alocalSY * alineSin )
		Local anewSY# = ( alocalSX * alineSin ) + ( alocalSY * alineCos )
		
		ga\SX = anewSX + PartCenterX#
		ga\SY = anewSY + PartCenterY#
		
		;The EX and EY values of an arc part are never used, an arc only has a start point (its centre).
		
		ga\SA# = ( ga\SA# + Amount# ) Mod 360 ;Wrap the angle value to the [0, 359] range so it's drawn properly.
		ga\EA# = ( ga\EA# + Amount# ) Mod 360
							
	Next
	
	PartAngle# = PartAngle# + Amount#
	If PartAngle# &gt;= 360 Then
		PartAngle# = PartAngle# - 360
	End If
	
End Function

Function CalcDistance(SX#, SY#, EX#, EY#)
	d# = Sqr((EX# - SX#)*(EX# - SX#) + (SY# - EY#)*(SY# - EY#))
	Return d#
End Function

Function Zoom(Amount#)
	MyScale# = MyScale# + Amount#
	If MyScale# &lt; 5 Then
		MyScale# = 5
	End If
End Function

Function SelectItem()

	Select ItemToMove$
		Case "PART"
			ItemToMove$ = "BOTHGAGES"
		Case "BOTHGAGES"
			ItemToMove$ = "LEFTGAGE"
		Case "LEFTGAGE"
			ItemToMove$ = "RIGHTGAGE"
		Case "RIGHTGAGE"
			ItemToMove$ = "TOOLS"
		Default
			ItemToMove$ = "PART"
			
	End Select
		
End Function

Function UpdatePositions()

	Color 255,255,0
	
	SetFont fntCourier
	
	Text 1,  2, "Item to Move: " + ItemToMove$
	Text 1, 15, "Move Amount : " + MovementAmount#
	Text 1, 30, "Rotation Amt: " + RotationAmount#
	Text 1, 45, "Part Details: " + PartDetailsToShow$
	Text 1, 60, "Ram Details : " + RamDetailsToShow$
	Text 1, 75, "Z Axis Left : " + (ZAxisLeft# -CenterX#)
	Text 1, 90, "Z Axis Right: " + (ZAxisRight# - CenterX#)
	Text 1, 105,"X Axis Left : " + XAxisLeft#
	Text 1, 120,"X Axis Right: " + XAxisRight#
	Text 1, 135,"Zoom Level  : " + MyScale#
	Text 1, 150,"Part CenterX: " + PartCenterX#
	Text 1, 165,"Part CenterY: " + PartCenterY#
	Text 1, 180,"Prt Flipped?: " + PartFlipped$
	Text 1, 195,"Part Angle  : " + PartAngle#
	Text 1, 210,"Part Loc X  : " + PartLocationX#
	Text 1, 225,"Part Loc Y  : " + PartLocationY#
	Text 1, 240,"Material GA : " + MaterialGage$
	Text 1, 255,"MaterialType: " + MaterialType$
	
	SetFont fntArial
	
End Function

Function UpdateMovementAmount()
	Select MovementAmount#
		Case .125
			MovementAmount# = .5
		Case .5
			MovementAmount# = 1
		Case 1
			MovementAmount# = 6
		Case 6
			MovementAmount# = .125
	End Select
End Function

Function SelectPartDetailLevel()
	Select PartDetailsToShow$
		Case "HIGH"
			PartDetailsToShow$ = "MED"
		Case "MED"
			PartDetailsToShow$ = "LOW"
		Case "LOW"
			PartDetailsToShow$ = "HIGH"
	End Select
End Function

Function SelectRamDetailLevel()
		Select RamDetailsToShow$
			Case "RAM-All"
				RamDetailsToShow$ = "RAM-Medium"
			Case "RAM-Medium"
				RamDetailsToShow$= "RAM-Low"
			Default
				RamDetailsToShow$ = "RAM-All"
		End Select
End Function

Function SelectRotationAmount()
	Select RotationAmount#
		Case 90
			RotationAmount# = 1
		Case 1
			RotationAmount# = 5
		Case 5
			RotationAmount# = 45
		Case 45
			RotationAmount# = 90
		Default
			RotationAmount# = 45
	End Select
End Function

Function GetUserInput$(Msg$)
	ReturnData$ = Input(Msg$)
	Return ReturnData$
End Function



Function AddTooling()

	If ToolCount# = 0 Then
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount
		gt\Name$ = "MT030013000D"
		gt\Length# = 12
		gt\Location# = 0
		gt\Reversed$ = "NO"	
	
	Else

		SetFont fntArialLG
		
		Cls
		Flip
		
		FlushKeys
		Locate 50, 100
		;Local Name$ = GetUserInput("Enter Tool Name like:  MT030013000D...")
	
		FlushKeys
		Locate 50, 125
		;Local Length# = GetUserInput("Enter Tool Length:...")
	
		FlushKeys
		Locate 50, 150
		;Local Location$ = GetUserInput("Enter Tool Location:...")
	
		FlushKeys
		Locate 50, 175
		;Local Reversed$ = "NO"; GetUserInput("Tool Reversed? YES Or NO...")
		
		ToolCount# = ToolCount# + 1
		gt.MyTools = New MyTools
		gt\Id# = ToolCount#
		gt\Name$ = "MT026073000P";Name$
		gt\Length# = 6
		gt\Location# = (ToolCount# * 8) + ToolCount#
		gt\Reversed$ = "NO";Reversed$
		
		ToolCount# = ToolCount# + 1
		
		SetFont fntArial
		
	End If
	
		
End Function

Function DrawTooling()
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		DrawLine(SX#, SY#, EX#, EY#, "BLUE")
		DrawLine(SX#, SY# - ToolWidth#, EX#, EY# - ToolWidth#, "BLUE")
		DrawLine(SX#, SY#, SX#, SY# - ToolWidth#, "BLUE")
		DrawLine(EX#, EY#, EX#, EY# - ToolWidth#, "BLUE")
	Next
End Function

Function DisplayToolDetails()

	SetFont fntCourier
	
	I = 20
	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2

		Text 600, 2, "Tooling Data"
		Text 600, I, gt\Name$  + ", Location:" + gt\Location# + ", Length:" + gt\Length#
		
		I = I + 25
	Next

	SetFont fntArial
	
End Function

Function EditBends()



	
End Function

Function SaveData()
;This function will save all of the setup details to a text file that can be used to read the data back in at a later date.  This code is just started and not ready for anyone to use it


	fileout = WriteFile("C:\Temp\mydata.txt")

	;WriteLine(fileout, "Start Part Geometry Information")
	WriteLine(fileout, "Material Gage      : " + MaterialGage$)
	WriteLine(fileout, "Material Type      : " + MaterialType$)
	WriteLine(fileout, "Part Rotation Angle: " + PartAngle#)
	WriteLine(fileout, "Part Flipped       : " + PartFlipped$)
	WriteLine(fileout, "Part CenterX       : " + PartCenterX#)
	WriteLine(fileout, "Part CenterY       : " + PartCenterY#)
	WriteLine(fileout, "Part Loc X         : " + PartLocationX#)
	WriteLine(fileout, "Part Loc Y         : " + PartLocationY#)

	For gl.MyLines = Each MyLines
		WriteLine(fileout, gl\LName$ + "," + gl\SX# + "," + gl\SY# + "," + gl\EX# + "," + gl\EY# + "," + gl\IsBendLine$ + "," + gl\LColor$ + "," + gl\DIR$ + "," + gl\Angle# + "," + CalcDistance(gl\SX#, gl\SY#, gl\EX#, gl\EY#) + "," + gl\ZL# + "," + gl\ZR# + "," + gl\XL# + "," + gl\XR# + "," + gl\InsideBend$ + "," + gl\FO_L# + "," + FO_R# + "," + gl\GageTopOfFinger$)
	Next
	For gc.MyCircles = Each MyCircles
		WriteLine(fileout, gc\CName$ + "," + gc\SX# + "," + gc\SY# + "," + gc\EX# + "," + gc\EY# + "," + gc\R#)
	Next
	For ga.MyArcs = Each MyArcs
		WriteLine(fileout, ga\AName$ + "," + ga\SX# + "," + ga\SY# + "," + ga\SA# + "," + ga\EA# + "," + ga\R#)
	Next		
	CloseFile(fileout)
	
	;Let's save the tooling information...
	fileout = WriteFile("C:\Temp\ToolingSetup.txt")
	For tl.MyTools = Each MyTools
		WriteLine(fileout, "ID                 : " + tl\Id#)
		WriteLine(fileout, "Name               : " + tl\Name$)
		WriteLine(fileout, "Length             : " + tl\Length#)
		WriteLine(fileout, "Location           : " + tl\Location#)
		WriteLine(fileout, "Reversed           : " + tl\Reversed$)
	Next
	CloseFile(fileout)


End Function

Function OpenPart()
	
	For gl.MyLines = Each MyLines
		Delete gl
	Next

	For gc.MyCircles = Each MyCircles
		Delete gc
	Next
	
	For ga.MyArcs = Each MyArcs
		Delete ga
	Next
	
	file=OpenFile("C:\Temp\MyData.txt")
	While Not Eof(file)	
		
		Hold$ = ReadLine$(file)
		
		StringToSearchFor$ = "Material Gage      :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			MaterialGage$ = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Material Type      :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			MaterialType$ = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Part Rotation Angle:"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			PartRotationAngle# = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Part Flipped       :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			PartFlipped$ = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Part CenterX       :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			PartCenterX# = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Part CenterY       :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			PartCenterY# = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Part Loc X         :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			PartLocationX# = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Part Loc Y         :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			PartLocationY# = Trim(Mid(Hold$, Found + Len(StringToSearchFor$)))
		End If

		
		;Let's get all of the line data and add it to the lines type...
		StringToSearchFor$ = "LINE_"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				LName$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SX# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SY# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				EX# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				EY# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				IsBendLine$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				LColor$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				DIR$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				Angle# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				BendLength# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				ZL# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				ZR# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				XL# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				XR# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				InsideBend$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				FOL_L# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				FOL_R# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If

			GageTopOfFinger$ = Trim(Mid(Hold$, 1))
			
			gl.MyLines = New MyLines
			gl\GraphicType$ = "LINE"
			gl\LName$ = LName$
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\IsBendLine$ = IsBendLine$
			gl\LColor$ = LColor$
			gl\DIR$ = DIR$
			gl\Angle# = Angle#
			gl\BendLength# = BendLength#
			gl\ZL# = ZL#
			gl\ZR# = ZR#
			gl\XL# = XL#
			gl\XR# = XR#
			gl\InsideBend$ = InsideBend$
			gl\FO_L# = FO_L#
			gl\FO_R# = FO_R#
			gl\GageTopOfFinger$ = GageTopOfFinger$

		End If

		;Let's get all of the circle data and add it to the circles type...

		StringToSearchFor$ = "CIRCLE_"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then

			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				CName$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SX# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SY# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				EX# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				EY# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			R# = Trim(Mid(Hold$, 1))
		
			gc.MyCircles = New MyCircles
			gc\GraphicType$ = "CIRCLE"
			gc\SX# = SX#
			gc\SY# = SY#
			gc\EX# = EX#
			gc\EY# = EY#
			gc\R# = R#

		End If

		StringToSearchFor$ = "ARC_"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then

			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				AName$ = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SX# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SY# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				SA# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			Found# = Instr(Hold$, ",")
			If Found# &gt; 0 Then
				EA# = Trim(Mid(Hold$, 1, Found -1))
				Hold$ = Mid(Hold$, Found + 1)
			End If
		
			R# = Trim(Mid(Hold$, 1))
		
			ga.MyArcs = New MyArcs
			ga\GraphicType$ = "ARC"
			ga\AName$ = AName$
			ga\SX# = SX#
			ga\SY# = SY#
			ga\SA# = SA#
			ga\EA# = EA#
			ga\R# = R#

		End If

	Wend
	CloseFile(file)
	
End Function


Function PlaySteps()
;This function will read in data that was previously saved and all the user to continue working.  This code is just started and is not ready for anyone to use.

	file=OpenFile("C:\Temp\MyData.txt")
	SaveItemToMove$ = ItemToMove$
	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		;Lets' find the first bend ...
		StringToSearchFor$ = "ZAxisLeft          :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then


			NewPosition# = Trim(Mid(Hold$, 22))
			;Let's move the left finger into position...
			
			ItemToMove$ = "LEFTGAGE"					
			If ZAxisleft# &gt;= NewPosition# Then
				While ZAxisLeft# &gt; NewPosition#
					MoveItem(-.001, "X")
				Wend
				NewPosition# = ZAxisleft#
			End If
			If ZAxisleft# &lt; NewPosition#
				While ZAxisLeft# &lt; NewPosition#
				
					MoveItem(.001, "X")
				Wend
			End If					

			ItemToMove$ = SaveItemToMove$
		End If
	Wend
	CloseFile(file)


	ToolCount# = 0
	file=OpenFile("C:\Temp\MyData.txt")

	For gt.MyTools = Each MyTools
		Delete gt
	Next

	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		;Lets' find the first bend ...
		StringToSearchFor$ = "ID          :"
		
		Found = Instr(Hold$, StringToSearchFor$)
		If Found &gt; 0  Then 
		
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))

			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			ToolCount# = ToolCount# + 1
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			ToolCount# = ToolCount# + 1
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			ToolCount# = ToolCount# + 1
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
			
			Hold$ = ReadLine$(file)
			Id# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 15))
			
			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 15))
			
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$

			ToolCount# = ToolCount# + 1
							
		End If
	Wend
	CloseFile(file)
	

End Function

Function PopUpToolingInfo()

	SelectedX# = MouseX()
	SelectedY# = MouseY()

	For gt.MyTools = Each MyTools
		SX# = gt\Location#
		SY# = ToolWidth#/2
		EX# = gt\Location# - gt\Length#
		EY# = ToolWidth#/2
		If Abs(SelectedX# - (PanZoomX# + (SX# + EX#) / 2 * MyScale#)) &lt; 5 And Abs(SelectedY# - (PanZoomY# - (SY# + EY#) / 2 * MyScale)) &lt; 5 Then
			MoveMouse PanZoomX# + (SX# + EX#) / 2 * MyScale#, PanZoomY# - (SY# + EY#) / 2 * MyScale
			SetFont fntCourier
			Text PanZoomX# + (SX# + EX#) / 2 * MyScale#, PanZoomY# - (SY# + EY# + 26) / 2 * MyScale, "Id      : " + gt\Id#
			Text PanZoomX# + (SX# + EX#) / 2 * MyScale#, PanZoomY# - (SY# + EY# + 23) / 2 * MyScale, "Name    : " + gt\Name$
			Text PanZoomX# + (SX# + EX#) / 2 * MyScale#, PanZoomY# - (SY# + EY# + 20) / 2 * MyScale, "Location: " + gt\Location#
			Text PanZoomX# + (SX# + EX#) / 2 * MyScale#, PanZoomY# - (SY# + EY# + 17) / 2 * MyScale, "Length  : " + gt\Length#
			Text PanZoomX# + (SX# + EX#) / 2 * MyScale#, PanZoomY# - (SY# + EY# + 14) / 2 * MyScale, "Reversed: " + gt\Reversed$
			SetFont fntArial
		End If
	Next
End Function

Function WhereClicked(SelectedX#, SelectedY#)
	

	;Item to move...	
	If SelectedX# &gt;= 95 And SelectedX# &lt; 195 Then
		;Item to move...
		If SelectedY# &gt; 2 And SelectedY# &lt; 15 Then
			SelectItem()
		End If
		
		;Movement amount...
		If SelectedY# &gt; 15 And SelectedY# &lt; 30 Then
			UpdateMovementAmount()
		End If	
		
		;rotation amount...
		If SelectedY# &gt; 30 And SelectedY# &lt; 45 Then
			SelectRotationAmount()
		End If	

		;select part details level...
		If SelectedY# &gt; 45 And SelectedY# &lt; 60 Then
			SelectPartDetailLevel()
		End If	

		;Select Ram Detail Level...
		If SelectedY# &gt; 60 And SelectedY# &lt; 75 Then
			SelectRamDetailLevel()
		End If	

		;Material Gage...
		If SelectedY# &gt; 240 And SelectedY# &lt; 255 Then
			SelectMaterialGage()
		End If	

		;Material Type...
		If SelectedY# &gt; 255 And SelectedY# &lt; 275 Then
			SelectMaterialType()
		End If	

	End If
	
	
	If SelectedY# &gt; 625 And SelectedY# &lt; 645 Then
		;CAM Left...
		If SelectedX# &gt; 2 And SelectedX# &lt; 22 Then
			PanZoomX# = PanZoomX# - 75
		End If
		
		;CAM right...
		If SelectedX# &gt; 23 And SelectedX# &lt; 43 Then
			PanZoomX# = PanZoomX# + 75
		End If		
	End If
		
	If SelectedX# &gt; 14 And SelectedX# &lt; 34 Then
		;CAM up...
		If SelectedY# &gt; 600 And SelectedY# &lt; 620 Then
			PanZoomY# = PanZoomY# - 75		
		End If
		;CAM dn...
		If SelectedY# &gt; 650 And SelectedY# &lt; 670 Then
			PanZoomY# = PanZoomY# + 75		
		End If
	End If
			
	
	If selectedY# &gt; 600 And SelectedY# &lt; 620 Then
		;Rotate left...
		If selectedX# &gt; 65 And selectedX# &lt; 85 Then
			RotatePart(RotationAmount#)			
		End If
		;Rotate right...
		If selectedX# &gt; 90 And selectedX# &lt; 115 Then
			RotatePart(RotationAmount# + (360 - RotationAmount# * 2))
		End If		
	End If
	
	;Flip Part...
	If SelectedX# &gt; 65 And SelectedX# &lt; 115 Then
		If SelectedY# &gt; 640 And SelectedY# &lt; 655 Then
			FlipPart()
		End If
	End If
	
	;Move part...
	If SelectedY# &gt; 625 And SelectedY# &lt; 645 Then
		;PART Left...
		If SelectedX# &gt; 150 And SelectedX# &lt; 170 Then
			SaveItem$ = SelectedItem$
			SelectedItem$ = "PART"
			MoveItem(-MovementAmount#, "X")
		End If
		
		;PART right...
		If SelectedX# &gt; 173 And SelectedX# &lt; 193 Then
			SaveItem$ = SelectedItem$
			SelectedItem$ = "PART"
			MoveItem(MovementAmount#, "X")
		End If		
	End If
		
	If SelectedX# &gt; 164 And SelectedX# &lt; 184 Then
		;PART up...
		If SelectedY# &gt; 600 And SelectedY# &lt; 620 Then
			SaveItem$ = SelectedItem$
			SelectedItem$ = "PART"
			MoveItem(MovementAmount#, "Y")	
		End If
		;PART dn...
		If SelectedY# &gt; 650 And SelectedY# &lt; 670 Then
			SaveItem$ = SelectedItem$
			SelectedItem$ = "PART"
			MoveItem(-MovementAmount#, "Y")			
		End If
	End If

End Function


Function ReadInEditedLine()

	file=OpenFile("C:\Temp\EditLine.txt")
	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		

		StringToSearchFor$ = "GRAPHIC TYPE         :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			GraphicType$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "LINE NAME            :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			LName$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "IS BEND LINE         :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			IsBendLine$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "BEND SEQUENCE NUMBER :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			BendSeqNumber# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "BEND ANGLE           :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			Angle$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "BEND DIRECTION       :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			DIR$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "BEND LENGTH          :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			BendLength# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "INSIDE BEND          :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			InsideBend$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "GAGE TOP OF FINGER   :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			GageTopOfFinger$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "X-LEFT               :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			XL# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "X-RIGHT              :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			XR# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Z-LEFT               :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			ZL# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "Z-RIGHT              :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			ZR# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "FINGER OFFSET LEFT   :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			FO_L# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "FINGER OFFSET RIGHT  :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			FO_R# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "START X              :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			SX# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "START Y              :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			SY# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "END X                :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			EX# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "END Y                :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			EY# = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If

		StringToSearchFor$ = "LINE COLOR           :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			LColor$ = Trim(Mid(Hold$, Found# + Len(StringToSearchFor$)))
		End If


	Wend
	CloseFile(file)

	For gl.MyLines = Each MyLines
	
		If gl\LName$ = LName$ Then
			gl\GraphicType$ = GraphicType$
			gl\LName$ = LName$
			gl\IsBendLine$ = IsBendLine$
			gL\BendSeqNumber# = BendSeqNumber#
			gl\Angle$ = Angle$
			gl\DIR$ = DIR$
			gl\BendLength# = BendLength#
			gL\InsideBend$ = InsideBend$
			gL\GageTopOfFinger$ = GageTopOfFinger$
			gl\XL# = XL#
			gl\XR# = XR#
			gl\ZL# = ZL#
			gl\ZR# = ZR#
			gL\FO_L# = FO_L#
			gL\FO_R# = FO_R#
			gl\SX# = SX#
			gl\SY# = SY#
			gl\EX# = EX#
			gl\EY# = EY#
			gl\LColor$ = LColor$
		
		End If
	
	Next

End Function



Function SelectMaterialGage()
	Select MaterialGage$
		Case "14"
			MaterialGage$ = "16"
		Case "16"
			MaterialGage$ = "18"
		Case "18"
			MaterialGage$ = "20"
		Case "20"
			MaterialGage$ = "22"
		Case "22"
			MaterialGage$ = "24"
		Case "24"
			MaterialGage$ = "11"
		Case "11"
			MaterialGage$ = "14"
		Default
			MaterialGage$ = "14"
	End Select
End Function

Function SelectMaterialType()
	Select MaterialType$
		Case "MILD"
			MaterialType$ = "STAINLESS"
		Case "STAINLESS"
			MaterialType$ = "MILD"
		Default
			MaterialType$ = "MILD"
	End Select
End Function


Function ImportToolingSetup()

	For gt.MyTools = Each MyTools
		Delete gt
	Next

	file=OpenFile("C:\Temp\ToolingSetup.txt")
	While Not Eof(file)	
		Hold$ = ReadLine$(file)
		
		StringToSearchFor$ = "ID                 :"
		Found# = Instr(Hold$, StringToSearchFor$)
		If Found# &gt; 0 Then
			Id# = Trim(Mid(Hold$, 21))

			Hold$ = ReadLine$(file)
			Name$ = Trim(Mid(Hold$, 21))

			Hold$ = ReadLine$(file)
			Length# = Trim(Mid(Hold$, 21))

			Hold$ = ReadLine$(file)
			Location# = Trim(Mid(Hold$, 21))

			Hold$ = ReadLine$(file)
			Reversed$ = Trim(Mid(Hold$, 21))
		
			gt.MyTools = New MyTools
			gt\Id# = Id#
			gt\Name$ = Name$
			gt\Length# = Length#
			gt\Location# = Location#
			gt\Reversed$ = Reversed$
		End If
	Wend
	CloseFile(file)

End Function

</textarea> <br><br></td></tr></table><br>
<a name="1303843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> There seems to be IDEal left. I haven't used it: <br></div><br><br>IDeal is awesome, the workspace function is great for having numerous tabs open with respect to a project. <br><br></td></tr></table><br>
<a name="1303885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>	For ga.MyArcs = Each MyArcs
		;*** Need help with this code.  The arcs are not drawing correctly after flipping (Mirror about the Y Axis).  My Math is very weak.
		
		ga\SX# = ga\SX# * -1
		
		Local startCos#	= -Cos( ga\SA ) ;Negating the 'cosine' (the horizontal component) so it flips around the vertical axis.
		Local startSin#	= Sin( ga\SA )
		
		Local endCos#	= -Cos( ga\EA )
		Local endSin#	= Sin( ga\EA )

		ga\SA = ( ATan2( endSin, endCos ) + 360 ) Mod 360
		ga\EA = ( ATan2( startSin, startCos ) + 360 ) Mod 360
	
	Next</pre> <br><br></td></tr></table><br>
<a name="1303901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >hollifd</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kryzon...<br>Thanks!  Your code works perfectly!<br><br>You are the best!<br><br>Thanks again,<br>David <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
