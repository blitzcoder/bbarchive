<!DOCTYPE html><html lang="en" ><head ><title >Blitz Double</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='Dll that enables double precision, language=bb, category=User Libs'><meta name='author' content='Abram'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 ><a href=codearcs.php>Code archives</a>/<a href=codearcs.php?cat=14>User Libs</a>/Blitz Double</h1><div class="quote">This code has been declared by its author to be Public Domain code.</div><br><a href="1905.bb">Download source code</a><br><br><table width="100%" cellspacing="0" cellpadding="0"><tr ><td width="100%"><table width=100% cellspacing=0 cellpadding=0><tr ><td class=headleft></td><td class=head><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitz Double by Abram</td><td align="right">2007 </td></tr></table></td><td class=headright></td></tr></table></td></tr><tr ><td class="cell"> For all of you that finds the accuracy of the Blitz float not sufficient I have made a dll that includes many functions to operate on doubles. <br><br>Unfortunately I had no place to upload a compiled dll but hopefully someone that reads this can compile a dll and add a link. Otherwise I can always mail a compiled version. </td></tr><tr ><td class="cell"><pre class="code">Save the following in you userlibs as "blitzdouble.decls"

.lib "blitzdouble.dll"
DoubleMultiply(A,B,Out) : "_DoubleMultiply@12"
DoubleDivide(A,B,Out) : "_DoubleDivide@12"
DoubleAdd(A,B,Out) : "_DoubleAdd@12"
DoubleSubtract(A,B,Out) : "_DoubleSubtract@12"
Double2Float#(A) : "_Double2Float@4"
Double2Int%(A) : "_Double2Int@4"
DoubleAssignFromString(Out,B$) : "_DoubleAssignFromString@8"
DoubleAssignFromFloat(Out,B#) : "_DoubleAssignFromFloat@8"
DoubleAssignFromInt(Out,B) : "_DoubleAssignFromInt@8"
DoubleAssign(Out,B) : "_DoubleAssign@8"
Double2String$(A) : "_Double2String@4"
DoubleSqrt(A,Out) : "_DoubleSqrt@8"
DoubleSin(A,Out) : "_DoubleSin@8"
DoubleCos(A,Out) : "_DoubleCos@8"
DoubleASin(A,Out) : "_DoubleASin@8"
DoubleACos(A,Out) : "_DoubleACos@8"
DoubleATan(A,Out) : "_DoubleATan@8"
DoubleATan2(A,B,Out) : "_DoubleATan2@12"
DoubleTan(A,Out) : "_DoubleTan@8"
DoubleAbs(A,Out) : "_DoubleAbs@8"
DoubleLog(A,Out) : "_DoubleLog@8"
DoubleLog10(A,Out) : "_DoubleLog10@8"
DoublePow(A,B,Out) : "_DoublePow@12"
DoubleExp(A,Out) : "_DoubleExp@8"
DoubleCeiling(A,Out) : "_DoubleCeiling@8"
DoubleFloor(A,Out) : "_DoubleFloor@8"
DoubleSinh(A,Out) : "_DoubleSinh@8"
DoubleCosh(A,Out) : "_DoubleCosh@8"
DoubleSign%(A) : "_DoubleSign@4"
DoubleEqualLessThan%(A,B) : "_DoubleEqualLessThan@8"
DoubleLessThan%(A,B) : "_DoubleLessThan@8"
DoubleEqualTo%(A,B) : "_DoubleEqualTo@8"
DoubleEqualBiggerThan%(A,B) : "_DoubleEqualBiggerThan@8"
DoubleBiggerThan%(A,B) : "_DoubleBiggerThan@8"
DoubleSetFPUDoubleMode() : "_DoubleSetFPUDoubleMode@0"
DoubleSetFPUSingleMode() : "_DoubleSetFPUSingleMode@0"</pre></td></tr></table><br><a name="comments">Comments</a><br><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abram</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Example Code: <br><br>; Create some banks to store the double variables<br>Local MyDouble_1 = CreateBank(8)<br>Local MyDouble_2 = CreateBank(8)<br>Local MyDouble_3 = CreateBank(8)<br>Local MyDouble_4 = CreateBank(8)<br>Local MyDouble_5 = CreateBank(8)<br><br>Print "Assign from string"<br>DoubleAssignFromString(MyDouble_5,"3.2361567664646")<br>DoubleAssignFromString(MyDouble_3,"36337.58583466")<br>DoubleAssignFromString(MyDouble_4,"4792.94923023755")<br>Print Double2String(MyDouble_5)<br>Print Double2String(MyDouble_4)<br>Print Double2String(MyDouble_3)<br><br>; Normally Blitz Basic has the processor set to single precision,<br>; DoubleSetFPUDoubleMode sets the processor to double precision calculations,<br>; as long as you only use BlitzDouble calculations it should be safe to let<br>; it stay in double precision mode... but it seems to be no problems also to<br>; let Blitz Basic floats operate in Double Mode, but that needs to be tested<br>; alot more than I have done...<br><br>DoubleMultiply(MyDouble_3,MyDouble_4,MyDouble_1)<br>Print: Print "Multiply (without setting FPU to double mode)"<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: "+(36337.58583466*4792.94923023755)<br><br>DoubleSetFPUDoubleMode() <br><br>DoubleMultiply(MyDouble_3,MyDouble_4,MyDouble_1)<br>Print: Print "Multiply (after FPU in double mode)"<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: "+(36337.58583466*4792.94923023755)<br><br><br>DoubleDivide(MyDouble_3,MyDouble_4,MyDouble_1)<br>Print : Print "Divide"<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: "+(36337.58583466/4792.94923023755)<br><br>WaitKey<br>Print : Print "Add"<br>DoubleAdd(MyDouble_3,MyDouble_4,MyDouble_1)<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: "+(36337.58583466+4792.94923023755)<br><br>Print : Print "Substract"<br>DoubleSubtract(MyDouble_3,MyDouble_4,MyDouble_1)<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: "+ (36337.58583466-4792.94923023755)<br><br>Print : Print "Assign from float"<br>Local TestaFloat# = 1.4369736<br>DoubleAssignFromFloat(MyDouble_1,TestaFloat#)<br>Print "Double: " + Double2Float(MyDouble_1)<br>Print "Float: " + TestaFloat#<br><br>Print : Print "Pow"<br>DoubleAssignFromString(MyDouble_3,"2")<br>DoubleAssignFromString(MyDouble_4,"4.005")<br>DoublePow(MyDouble_3,MyDouble_4,MyDouble_1)<br>Print "Double: "+Double2String(MyDouble_1)<br><br>Print : Print "Sinus"<br>DoubleAssignFromString(MyDouble_3,"0.156782")<br>DoubleSin(MyDouble_3,MyDouble_1)<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: " + Sin(0.156782*180/Pi)<br><br>Print : Print "Cosinus"<br>DoubleAssignFromString(MyDouble_3,"0.156782")<br>DoubleCos(MyDouble_3,MyDouble_1)<br>Print "Double: "+Double2String(MyDouble_1)<br>Print "Float: " + Cos(0.156782*180/Pi)<br><br>Local Loops = 10000000<br>Print : Print "Speed Test ("+Loops+" Divisions)"<br>DoubleAssignFromString(MyDouble_3,"1.01234")<br>DoubleAssignFromString(MyDouble_4,"0.99999888")<br>Local Var1# = 1.01234<br>Local Var2# = 0.99999888<br>Local Var3# = -1;<br>Local StartTime=MilliSecs()<br>For i=1 To Loops<br>DoubleDivide(MyDouble_3,MyDouble_4,MyDouble_3)<br>Next<br>Local EndTime=MilliSecs()<br>Print "Double took: "+(EndTime-StartTime)+"ms with result: "+Double2String(MyDouble_3)<br>StartTime=MilliSecs()<br>For i=1 To Loops<br>Var1 = Var1/Var2<br>Next<br>EndTime=MilliSecs()<br>Print "Float took: "+(EndTime-StartTime)+"ms with result: "+Var1<br><br>Print : Print "Speed Test ("+Loops+" Multiplications)"<br>DoubleAssignFromString(MyDouble_3,"1.01234")<br>DoubleAssignFromString(MyDouble_4,"0.99999888")<br>Var1# = 1.01234<br>Var2# = 0.99999888<br>Var3# = -1;<br>StartTime=MilliSecs()<br>For i=1 To Loops<br>DoubleMultiply(MyDouble_3,MyDouble_4,MyDouble_3)<br>Next<br>EndTime=MilliSecs()<br>Print "Double took: "+(EndTime-StartTime)+"ms with result: "+Double2String(MyDouble_3)<br><br>StartTime=MilliSecs()<br>For i=1 To Loops<br>Var1 = Var1*Var2<br>Next<br>EndTime=MilliSecs()<br>Print "Float took: "+(EndTime-StartTime)+"ms with result: "+Var1<br><br>Print : Print "Sign"<br>DoubleAssignFromInt(MyDouble_3,0)<br>Print "Sign: "+Double2String(MyDouble_3)+" is "+DoubleSign(MyDouble_3)<br>DoubleAssignFromInt(MyDouble_3,-4)<br>Print "Sign: "+Double2String(MyDouble_3)+" is "+DoubleSign(MyDouble_3)<br>DoubleAssignFromInt(MyDouble_3,9)<br>Print "Sign: "+Double2String(MyDouble_3)+" is "+DoubleSign(MyDouble_3)<br><br>Print : Print "Sign"<br>DoubleAssignFromInt(MyDouble_3,0)<br>Print "Sign of "+Double2String(MyDouble_3)+" is "+DoubleSign(MyDouble_3)<br>DoubleAssignFromInt(MyDouble_3,-4)<br>Print "Sign of "+Double2String(MyDouble_3)+" is "+DoubleSign(MyDouble_3)<br>DoubleAssignFromInt(MyDouble_3,9)<br>Print "Sign of "+Double2String(MyDouble_3)+" is "+DoubleSign(MyDouble_3)<br><br>DoubleAssignFromFloat(MyDouble_3,2.468764)<br>DoubleCeiling(MyDouble_3,MyDouble_1)<br>DoubleFloor(MyDouble_3,MyDouble_2)<br>Print "Ceiling of "+Double2String(MyDouble_3)+" is "+Double2String(MyDouble_1)<br>Print "Floor of "+Double2String(MyDouble_3)+" is "+Double2String(MyDouble_2)<br><br>DoubleAssignFromFloat(MyDouble_3,-2.468764)<br>DoubleCeiling(MyDouble_3,MyDouble_1)<br>DoubleFloor(MyDouble_3,MyDouble_2)<br>Print "Ceiling of "+Double2String(MyDouble_3)+" is "+Double2String(MyDouble_1)<br>Print "Floor of "+Double2String(MyDouble_3)+" is "+Double2String(MyDouble_2)<br><br>WaitKey() <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abram</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> // Blitz double. Made by Örjan Abramsson 2007-03-16.<br>// Feel free to make any improvements that you find necessary.<br>// Code will be faster if it is compiled with SIZECHECK 0 which<br>// will disable the security check of the banksize, but if you know how to <br>// use the dll, this check is not necessary :)<br>// Just dont hold me responsible for any program crashes if this check is<br>// disabled... and also not when the check is enabled... Just to<br>// be on the safe side :)<br>// Have fun with the code<br><br>#include &lt;afxwin.h&gt;<br>#include &lt;float.h&gt;<br>#include "stdafx.h"<br>#include "math.h"<br>#define BBDECL extern "C" _declspec(dllexport)<br>#define BBCALL _stdcall<br>#define CONVERTDOUBLE(A) *(double *)(*(int *)((char *)(A)+4))<br><br>unsigned int _TheOrginalFPUMode=0;<br>#define ALWAYS_SET_DOUBLEPRECISION 0 <br>// To be used if the FPU mode shall be set to double just before<br>// calculations and back to Blitz Basic Mode afterwards.<br>// That way should be 100% secure... letting it stay in double<br>// mode might perhaps have unknown effects in Blitz 3D?<br>// Try to set this flag to 0 at your own risk, but if you do<br>// remember to also call DoubleSetFPUDoubleMode, otherwise the<br>// double calculations will not work. DoubleSetFPUDoubleMode is not<br>// needed when this flag is set to 1.<br><br>#define SIZECHECK 0 // If you know that you will not send banks with sizes different than 8<br>// define SIZECHECK to 0 and the dll will compile without the check<br>// and thus improve the speed of the dll. Then you can also remove<br>// #include &lt;afxwin.h&gt; since the check is the only place for AfxMessageBox<br><br>// Bank Information:<br>// When receiving a bank from blitz basic the adress to the<br>// memory is stored in an offset of +4. The Size of the bank<br>// is stored at +8 as an integer<br><br>// Type Casting explanation for CONVERTDOUBLE(A) (double *)(*(int *)((char *)(A)+4))<br>// A + 4 is the adress to the memory where the bank is stored<br>// therefore (char *)A + 4, in order to have the adress of the bank.<br>// To be able to interpret this as an adress this is casted to an integerpointer<br>// therefore (int *)((char *)A+4). This is then a pointer to a memory adress.<br>// In order to read the adress we check what the pointer is pointing at with<br>// *(int *)((char *)A+4), which returns an integer which we interpret as the adress<br>// to a double with (double *)(*(int *)((char *)A+4)), which finally gives the adress<br>// where we can work with our double. The last step with *(double *)(*(int *)((char *)A+4))<br>// is so that we work with the value and not the pointer of the double.<br>// Explaination is just as confusing as the line when I read it myself... sorry.<br><br><br>#if SIZECHECK<br>inline bool CheckBankSize(void *Bank)<br>{<br>	int BankSize=*(int *)((char *)Bank+8);<br>	if(BankSize!=8) // Bank size shall be 8 for a double<br>	{<br>		char Buffer[200];<br>		sprintf(Buffer,"Blitz Double Bank Size Error\nBank size is: %d should be 8",BankSize);<br>		AfxMessageBox(Buffer,MB_ICONSTOP|MB_OK);<br>		return false;<br>	}<br>	return true;<br>}<br>#endif<br><br>BBDECL void BBCALL DoubleMultiply(void *A,void *B,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)= (CONVERTDOUBLE(A)) * (CONVERTDOUBLE(B));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleDivide(void *A,void *B,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br> <br> 	CONVERTDOUBLE(Out)= (CONVERTDOUBLE(A)) / (CONVERTDOUBLE(B));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleAdd(void *A,void *B,void *Out)<br>{<br><br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)= (CONVERTDOUBLE(A)) + (CONVERTDOUBLE(B));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleSubtract(void *A,void *B,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)= (CONVERTDOUBLE(A)) - (CONVERTDOUBLE(B));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br><br>}<br><br>BBDECL float BBCALL Double2Float(void *A)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	float TheData=(float)CONVERTDOUBLE(A);<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	<br>	return TheData;<br>}<br><br>BBDECL int BBCALL Double2Int(void *A)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	int TheData=(int)CONVERTDOUBLE(A);<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	<br>	return TheData;<br><br>}<br><br>BBDECL void BBCALL DoubleAssignFromString(void *Out,char *B)<br>{<br><br>#if SIZECHECK<br>	if( CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=atof(B);<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleAssignFromFloat(void *Out,float B)<br>{<br><br>#if SIZECHECK<br>	if( CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=(double)B;<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleAssignFromInt(void *Out,int B)<br>{<br><br>#if SIZECHECK<br>	if( CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=(double)B;<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleAssign(void *Out,void *B)<br>{<br><br>#if SIZECHECK<br>	if( CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=CONVERTDOUBLE(B);<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL const char* BBCALL Double2String(void *A)<br>{<br><br>#if SIZECHECK<br>	if( CheckBankSize(A)==false )<br>		return "Bank Size Error";<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	static char _buf[30];<br>	sprintf(_buf,"%.20g",CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return _buf;<br>}<br><br>BBDECL void BBCALL DoubleSqrt(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=sqrt(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br><br>}<br><br>BBDECL void BBCALL DoubleSin(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=sin(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleCos(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=cos(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleASin(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=asin(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleACos(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=acos(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleATan(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=atan(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleATan2(void *A,void *B,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=atan2(CONVERTDOUBLE(A),CONVERTDOUBLE(B));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleTan(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	<br>	CONVERTDOUBLE(Out)=tan(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleAbs(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)=abs(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleLog(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)=log(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleLog10(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)=log10(CONVERTDOUBLE(A));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoublePow(void *A,void *B,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br><br>	CONVERTDOUBLE(Out)=pow(CONVERTDOUBLE(A),CONVERTDOUBLE(B));<br><br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleExp(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	CONVERTDOUBLE(Out)=exp(CONVERTDOUBLE(A));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleCeiling(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	CONVERTDOUBLE(Out)=ceil(CONVERTDOUBLE(A));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleFloor(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	CONVERTDOUBLE(Out)=floor(CONVERTDOUBLE(A));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleSinh(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	CONVERTDOUBLE(Out)=sinh(CONVERTDOUBLE(A));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL void BBCALL DoubleCosh(void *A,void *Out)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(Out)==false )<br>		return;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	CONVERTDOUBLE(Out)=cosh(CONVERTDOUBLE(A));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>}<br><br>BBDECL int BBCALL DoubleSign(void *A)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false  )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	int TheSign= (CONVERTDOUBLE(A) &gt; 0) - (CONVERTDOUBLE(A) &lt; 0);<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return TheSign;<br>}<br><br>BBDECL int BBCALL DoubleEqualLessThan(void *A,void *B)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	int TheResult= (CONVERTDOUBLE(A)) &lt;= (CONVERTDOUBLE(B));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return TheResult;<br>}<br><br>BBDECL int BBCALL DoubleLessThan(void *A,void *B)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	int TheResult= (CONVERTDOUBLE(A)) &lt; (CONVERTDOUBLE(B));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return TheResult;<br>}<br><br>BBDECL int BBCALL DoubleEqualTo(void *A,void *B)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	int TheResult= (CONVERTDOUBLE(A)) == (CONVERTDOUBLE(B));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return TheResult;<br>}<br><br>BBDECL int BBCALL DoubleEqualBiggerThan(void *A,void *B)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	int TheResult= (CONVERTDOUBLE(A)) &gt;= (CONVERTDOUBLE(B));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return TheResult;<br>}<br><br>BBDECL int BBCALL DoubleBiggerThan(void *A,void *B)<br>{<br>#if SIZECHECK<br>	if( CheckBankSize(A)==false || CheckBankSize(B)==false )<br>		return 0;<br>#endif<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	unsigned int OrginalMode = _controlfp( 0, 0 );<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>#endif<br>	int TheResult= (CONVERTDOUBLE(A)) &gt; (CONVERTDOUBLE(B));<br>#if ALWAYS_SET_DOUBLEPRECISION<br>	_controlfp( OrginalMode, 0xfffff );<br>#endif<br>	return TheResult;<br>}<br><br>BBDECL void BBCALL DoubleSetFPUDoubleMode(void)<br>{<br>	if(_TheOrginalFPUMode==0)<br>	{<br>		_TheOrginalFPUMode = _controlfp( 0, 0 );<br>	}<br>	_controlfp( _CW_DEFAULT, 0xfffff );<br>}<br><br>BBDECL void BBCALL DoubleSetFPUSingleMode(void)<br>{<br>	if(_TheOrginalFPUMode!=0)<br>	{<br>		_controlfp( _TheOrginalFPUMode, 0xfffff );<br>	}<br>} <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >humanspacecraft</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Abram, this was urgently needed!<br>Doubelfun with floats can be downloaded from:<br><br><a href="http://www.electricdesire.com/blitz/blitzdouble.rar" target="_blank">http://www.electricdesire.com/blitz/blitzdouble.rar</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >humanspacecraft</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> -- <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abram</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Happy to be of help, glad that you find it useful. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jfk EO-11110</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Very nice addition, thanks a lot! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RGR</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Did no-one check if the results are exact? See the following:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=58849" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=58849</a><br><br>Doubles in a dll don't work with Blitz3D! Everything after the 7th digit is wrong<br><br>I wrote about that many month ago:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=58828#654531" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=58828#654531</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abram</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Updated code where also the results are correct is now available..... Double precision in Blitz3D is really possible :)<br><br>Sorry about having such a major bug... but at least it is gone now. Just got blind of when I saw that more decimals were available at first.<br><br>Have updated the code on this page, make sure your downloaded code matched the one presented here, otherwise it will not work. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RGR</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Hi, great work :-)<br>Thanks for the quick fix and delivery by mail.<br>Ralph <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >humanspacecraft</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> The updated version is now also available here:<br>www.electricdesire.com/blitz/blitzdouble.rar <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abram</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Updated once again, got a request for a lot of functions that I had not included in the dll. Functions to compare doubles and some more maths functions. Also made an option to set the FPU to double mode only in the start of the program, which increases the speed of the dll a lot... Just remember to set it to single mode after the calculations are done, otherwise I have no idea if there will be secondary effects in other parts of your programs..<br>Or you can use compile with the ALWAYS_SET_DOUBLEPRECISION set to 1 and this will not be  a problem.<br>Hope this will be the last update for a long while :)<br>(Code once again mailed to humanspacecraft, thanks a lot for hosting) <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >humanspacecraft</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Here the freshly extended version:<br><a href="http://www.electricdesire.com/blitz/blitzdoubleXL.rar" target="_blank">http://www.electricdesire.com/blitz/blitzdoubleXL.rar</a> <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Loktar</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> This is pretty cool... so does this mean i could finally make a space game with realistic distances between planets :) ? <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Graythe</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Abram, bloody marvellous! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AD</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> I downloaded the zip files and the exe files work fine - however when I try to edit and run/compile the .bb file in BB2D v1.68 it keeps saying "function not found", also there is no "userlibs" folder in my version of BB2D.<br><br>Please explain how to use this Double function as I am eager to use it! <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abram</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> I am not sure which version of Blitz that first introduced userlibs, but you should upgrade to the latest version of Blitz Basic and you will have a folder that is named userlibs. With your current version I do not think it will work... sorry. The exe files are compiled with version 1.98, and I guess that is why you do not get it to work. <br><br></td></tr></table><br><table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AD</td><td align="right"><font class=tiny>2007</font></td></tr></table></td></tr><tr ><td class="posttext"> That's a shame. I have the Blitz Basic free version that came with a magazine (IDE: v1.68, Linker v1.24, Runtime v1.68)<br><br>I do have BlitzMax, but still aren't used to using it.<br><br>Oh well, thank you for at least attempting to beat the double issue with BB2D. <br><br></td></tr></table><br><a href="codearcs.php" >Code Archives Forum</a><table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
