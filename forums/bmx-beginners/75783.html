<!DOCTYPE html><html lang="en" ><head ><title >Reflection and name().</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Reflection and name().</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >Reflection and name().</a><br><br>
<a name="846984"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> How can you use the type name returned from ttypeid name() method to cast an object back to it's original type?<br><pre class=code>
SuperStrict
Type ttest
   Field x:Int
End Type

Local test1:ttest=New ttest
test1.x=5
Local test2:Object=Object(test1)


Local id:TTypeId=TTypeId.ForObject(test2)
Local typename:String=id.name()
Print typename
'Print typename(test2).x
</pre><br>Obviously this is much simplified but I have my original type name in a string variable called 'typename'. <br>Unfortunately, I can't use that to cast my original object. If you uncomment the print statement you get message <br>'Expression of string cannot be invoked'<br>Am I missing something? <br><br></td></tr></table><br>
<a name="846988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Azathoth</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you're using reflection why do you need to cast? Reflection already allows you to access members.<br><br>Edit: Casting implies you have an idea what the type should be. <br><br></td></tr></table><br>
<a name="846990"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> How would I do that? In my example, how would I print the value of x for my object? <br>In addition, by casting back to the original object type I can then use all my existing function/method calls which rely on that type. <br>Or am I missing something?<br><br>&lt;edit&gt; <br>Yep, I thought I could get a VERY good idea what the type is by using reflection and then casting. <br><br></td></tr></table><br>
<a name="846994"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jake L.</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
For fld:TField=eachin id.EnumFields()
   if fld.TypeID().Name()="Int" then fld.SetInt(test2,42)
next
</pre><br><br>Of course this works without EnumFields, but I'm at work, so I   can't lookup how to get the field without it. Once you have a TField and a valid object, you can use the various Set... methods. <br><br></td></tr></table><br>
<a name="846997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I must really be missing something then.<br>Using reflection I can get the original type and supertype of an object as a string variable. I can also get all the fields, functions and methods of that class.<br>However, once I have used reflection to get that information I have to keep using the reflection types to access the information unless I use them in select/case or if/end the type back to it's original type? <br><br></td></tr></table><br>
<a name="847338"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jake L.</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, maybe I don't understand your question/problem. I thought you're looking for a way to set a field's value - that's what the code does. <br><br></td></tr></table><br>
<a name="847345"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I probably oversimplified the code I posted. Basically, I am looking for the best method to find out an objects type and cast back to it.<br>I thought I could use reflection to get the typename and then use that to cast the object. This would avoided using select/case or if/endif statements. <br><br></td></tr></table><br>
<a name="847350"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jake L.</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, understand. I guess it's impossible, but maybe someone can proove me wrong, I'm interested in this, too. <br><br></td></tr></table><br>
<a name="847372"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Reflection will only get you the type name and allow you to create an instance of that type.<br>it will not automagically cast anything.<br><br>So with the TTypeID.Name() you need to use a Switch and cast it accordingly.<br><br>question is what you really want to do with that and why you death cast it (-&gt; to object) instead of a common type that you are going to use, as I do not believe that there is a reason to cast it down to object as only "familiar" class instances are pushed into the same functionality. <br><br></td></tr></table><br>
<a name="847395"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> question is what you really want to do with that and why you death cast it (-&gt; to object) instead of a common type that you are going to use, as I do not believe that there is a reason to cast it down to object as only "familiar" class instances are pushed into the same functionality. <br> <br></div><br>I don't push it down to object or 'death cast' it. Bmax does when it returns an object from the TLink value method.<br>Maybe my oversimplified code has confused you. <br><br></td></tr></table><br>
<a name="847444"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> The thing is, it really doesn't makes sense at all. You have to consider that BlitzMax is a statically typed language. This means in particular that you can't call a method if you don't know at compile time which method to call (as opposed to what would happen in dynamicly typed languages where you could call anything you want, and the runtime would figure if the method actually exists or not - and fail if not). <br><br>(NOTE: The only dynamic part is that you may have overriden the method, and which version amongst all the overriden methods is decided at runtime. But the compiler still needs to know the method (as declared in the top most type that declares it)).<br><br>Given that we're dealing with a statically typed language:<br>- either you  know the method in advance (at compile time), which implies that you knwo the type already. In this case you should use a simple cast in the first palce<br>- either you discover the type at runtime via reflection, but then the object you're working on is practically untyped (more precisely, it's known simply as being an instance of "Object", you can't tell much more at compile time). This means you may only call methods in the "Object" type.<br><br>So yes, if you discover a method at runtime via reflection, you'll have to use reflection too if you want to call it. <br><br></td></tr></table><br>
<a name="847507"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> even if TList gives a object back you still can cast it to your "basic type" that is held within that list. thats actually no problem. <br><br></td></tr></table><br>
<a name="847530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK, I'll bite : What do you mean by 'basic type'. <br>Are you suggesting that objects on a list should all be off the same type or extended from the same type? <br><br></td></tr></table><br>
<a name="847538"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Extending from the same basic type.<br><br>I don't assume that you (as realworld example) would store car, turnips and pens in the same list. you would have a lit for vegetables, for vehicles and one for pens of all kind and then extend turnip from vegetable, car from vehicle and any pen type you use from pen.<br><br>Now you can implement basic functionality on those base type that those kind of things have and that stuff you don't implement but that must be present can still pe put in as method xyz() Abstract so extending types must implement it.<br><br>that way you can just cast to the base type in the for ... = eachin list part instead of using a select case structure to do "individual casting" that might not even be needed.<br><br>But this might depend on what you want to achieve.<br><br>A simple example of such a thing is Entity in Blitz3D for example ... they all extend from it and share the "base featuerset" ie entity commands <br><br></td></tr></table><br>
<a name="847548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't understand : Why would I not have pens and turnips on the same list? What about a shopping list , RPG Inventory, Objects on a tile etc? On that I might have :<br>Knife extends TWeapon<br>Turnip extends TVegetable<br>Pen extends TWriting_Implements.<br>OK, it might be better to TWeapon with a field TSpec which extends to TKnife_spec but, for my question, that is all irrelevant.<br>The basic question was 'Can I use Reflection to cast?'<br>The answer appears to be 'no, not directly' so I am happy with that. <br><br></td></tr></table><br>
<a name="847550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> In an inventory you would store TItem most likely, wouldn't you? (or from java end TStorable, no mather if inventory or box or whatever)<br><br>In BM, a usefull and clever class design etc is more than only decoration. If you don't have it you won't stand a chance getting it implemented bug and head ache free as the imports etc will start to get ugly clustered etc. The final result is degraded performance in worst case even slower than Blitz3D<br><br>Thats why I pointed that one out. <br><br></td></tr></table><br>
<a name="847557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could you explain more what you are suggesting please? <br><br></td></tr></table><br>
<a name="848515"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> well a class TItem that holds the basic functionality you might need for any item + a method that returns the type of the item as integer (for fast select or straight usage as array index)<br><br>for example you could have a method use() abstract as all items are used in a way and the extended types implement that each in its own way. pen would write something, turnip would heal or grant "stuffed" attribute, a knife would cut or attack ...<br>this kind of stuff.<br><br>think first of the "common" class and then think about the specialisted extended classes that the player actually will "see" (in an rpg for example) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
