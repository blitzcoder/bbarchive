<!DOCTYPE html><html lang="en" ><head ><title >VectorText! -Drawing Strings via DrawLine Function</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >VectorText! -Drawing Strings via DrawLine Function</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >VectorText! -Drawing Strings via DrawLine Function</a><br><br>
<a name="986387"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey guys,<br><br>I spent a few hours last night programming a realtime "Font" of neat vectortext.<br><br>The code was made in superstrict but I removed superstrict as I include it in my projects.<br><br>If you're going to use this function for your own projects:<br>Save it as a file called "VectorText.bmx" or whatever you want to call it, Then make a new bmx file and be sure to put:<br><pre class=code>
Include "VectorText.bmx"
</pre><br>OR put it in a mod! <br><br>It basically is one function that you can use called "VecDrawText"<br>To use:<br><pre class=code>
VecDrawText(X,Y,TEXTSIZE)
</pre><br><br>Your feedback is welcome, including if I wasted my time and there is a WAY easier way to code this type of function, or if it's already been done LOL.<br><br>Thanks guys!<br><br>Here is the code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function DrawVleftST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, Ox, oY) 'Verticle Left Straight

End Function
']
Function DrawVrightST(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + LetterSize
	Local Y:Float = Oy + LetterSize
    DrawLine (X, Y, X, Oy)  'Verticle Right Straight
 	
End Function
'Half Top [
Function DrawVleftTopST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, oY, Ox, Hy) 'Verticle Left TOP Straight
	
End Function
'Half Bottom [
Function DrawVleftBottomST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hy:Float = Oy + Lettersize / 2
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, Ox, Hy) 'Verticle Left BOTTOM Straight
	
End Function
'Half Top ]
Function DrawVrightTopST(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + LetterSize
	Local Hy:Float = Oy + Lettersize / 2
    DrawLine (X, oY, X, Hy)  'Verticle Right Straight
	
End Function
'Half Bottom ]
Function DrawVrightBottomST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hy:Float = Oy + Lettersize / 2
	Local X:Float = Ox + LetterSize
	Local Y:Float = Oy + LetterSize
    DrawLine (X, Y, X, Hy)  'Verticle Right Straight
	
End Function
'Top
Function DrawHtopST(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	DrawLine (ox, oy, x, oy) 'Horizontal Top Straight
	
End Function
'Bottom
Function DrawHbottomST(Ox:Float, Oy:Float, LetterSize:Float)

	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, X, Y) 'Horizontal Bottom Straight
	
End Function
'\
Function DrawFullBS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Oy, X, Y) 'Full \ BackSlash
	
End Function
'Top \
Function DrawHalfTBS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Oy, hx, hy) 'Half Upper \ BackSlash
	
End Function
'Bottom \
Function DrawHalfLBS(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (x, y, Hx, Hy) 'Half Lower \ BackSlash
End Function
'/
Function DrawFullS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, X, Oy) 'Full / Slash

End Function
'Top /
Function DrawTS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (X, Oy, Hx, Hy) 'Half Upper / Slash
	
End Function
'Bottom /
Function DrawLS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Y, Hx, Hy) 'Half Lower / Slash
	
End Function
'-
Function DrawFullDash(Ox:Float, Oy:Float, LetterSize:Float)

	Local X:Float = Ox + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Hy, X, Hy)  'Draw a Full -

End Function
'Left -
Function DrawLeftDash(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Hy, HX, Hy)  'Draw a Left - (half a full dash)

End Function
'Right -
Function DrawRightDash(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (X, Hy, HX, Hy)  'Draw a Right - (half a full dash)

End Function
'|
Function DrawPipe(Ox:Float, Oy:Float, LetterSize:Float)

	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	DrawLine (Hx, Y, Hx, Oy)
	
End Function
'Low |
Function DrawBottomPipe(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Hx, Y, Hx, Hy)
	
End Function
'Top |
Function DrawTopPipe(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Hx, Oy, Hx, Hy)
	
End Function
'Top &gt;
Function DrawTopRightChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Ox, Oy, X, Hy)
End Function
'Bottom &gt;
Function DrawBottomRightChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2	
	DrawLine(Ox, Y, x, Hy)
End Function
'Full &gt;
Function DrawRightChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Ox, Oy, X, Hy)
	DrawLine(Ox, Y, x, Hy)
	
End Function
'Top &lt;
Function DrawTopLeftChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(X, OY, Ox, Hy)
End Function
'Bottom &lt;
Function DrawBottomLeftChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2	
	DrawLine(X, Y, Ox, Hy)
End Function
'Full &lt;
Function DrawLeftChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(X, Y, Ox, Hy)
	DrawLine(X, OY, Ox, Hy)
	
End Function
'A damn D
Function DrawaDamnD(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 3
	Local Hy:Float = Oy + Lettersize / 28
	Local Hyd:Float = Oy + Lettersize / 1.028
	DrawLine(Ox, Oy, X, Hy)
	DrawLine(Ox, Y, x, Hyd)
	DrawLine(x, Hy, X, Hyd)
End Function
'A damn V
Function DrawaV(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	DrawLine(ox, oy, hx, y)
	DrawLine(x, oy, hx, y)
End Function
'Upside Down Carrot
Function DrawUSDCarrot(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(ox, oy, hx, hy)
	DrawLine(x, oy, hx, hy)
		
End Function
'Left Half Carrot
Function DrawLeftHalfCarrot(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(hx, oy, ox, hy)
		
End Function



Function DrawLetter_A (X:Float, Y:Float, S:Float)

	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_B (X:Float, Y:Float, S:Float)
		
	DrawVleftST(X, Y, S)
	DrawaDamnD(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_C (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)

End Function

Function DrawLetter_D (X:Float, Y:Float, S:Float)
	DrawVleftST(X, Y, S)
	DrawaDamnD(X, Y, S)
End Function

Function DrawLetter_E (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_F (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_G (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawRightDash(X, Y, S)
	DrawVrightBottomST(X, Y, S)
	
End Function

Function DrawLetter_H (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_I (X:Float, Y:Float, S:Float)
	
	DrawPipe(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	
End Function

Function DrawLetter_J (X:Float, Y:Float, S:Float)
	
	DrawVrightST(X, Y, S)
	DrawVleftBottomST(X, Y, S)
	DrawHbottomST(X, Y, S)
	
End Function

Function DrawLetter_K (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawLeftChevron(X, Y, S)
	
End Function

Function DrawLetter_L (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHbottomST(X, Y, S)
	
End Function
Function DrawLetter_M (X:Float, Y:Float, S:Float)
	
	DrawHtopST(X, Y, S)
	DrawTopPipe(X, Y, S)
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	
	
End Function

Function DrawLetter_N (X:Float, Y:Float, S:Float)
	
	DrawFullBS(X, Y, S)
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	
	
End Function

Function DrawLetter_O (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawHtopST(X, Y, S)
		
	
End Function

Function DrawLetter_P (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVrightTopST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function
Function drawletter_Q (X:Float, y:Float, S:Float)

	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHalfLBS(X, Y, S)
	
End Function

Function drawletter_R (X:Float, y:Float, S:Float)

	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVrightTopST(X, Y, S)
	DrawFullDash(X, Y, S)
	DrawBottomLeftChevron(X, Y, S)
End Function

Function DrawLetter_S (X:Float, Y:Float, S:Float)
	
	DrawVleftTopST(X, Y + 1, S)
	DrawVrightBottomST(X, Y, S - 1)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_T (X:Float, Y:Float, S:Float)
	
	DrawPipe(X, Y, S)
	DrawHtopST(X, Y, S)
End Function

Function DrawLetter_U (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawHbottomST(X, Y, S)

End Function

Function DrawLetter_V (X:Float, Y:Float, S:Float)
	
	DrawaV(X, Y, S)

End Function

Function DrawLetter_W (X:Float, Y:Float, S:Float)
	
	DrawHbottomST(X, Y, S)
	DrawBottomPipe(X, Y, S)
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	
	
End Function

Function DrawLetter_X (X:Float, Y:Float, S:Float)
	DrawFullS(X, Y, S)
	DrawFullBS(X, Y, S)
End Function

Function DrawLetter_Y(X:Float, Y:Float, S:Float)
	DrawUSDCarrot(X, Y, S)
	DrawBottomPipe(X, Y, S)
End Function

Function DrawLetter_Z(X:Float, Y:Float, S:Float)
	DrawHtopST(X, Y, S)
	DrawFullS(X, Y, S)
	DrawHbottomST(X, Y, S)
End Function

Function DrawNumber_0(X:Float, Y:Float, S:Float)
	DrawLetter_O(X, Y, S)
	DrawFullS(X, Y, S)
End Function

Function DrawNumber_1(X:Float, Y:Float, S:Float)
	DrawPipe(X, Y, S)
	DrawLeftHalfCarrot(X, Y, S)
	DrawHbottomST(X, Y, S)
End Function

Function DrawNumber_2(X:Float, Y:Float, S:Float)
	DrawVrightTopST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawVleftBottomST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function

Function DrawNumber_3(X:Float, Y:Float, S:Float)
	DrawVrightST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function

Function DrawNumber_4(X:Float, Y:Float, S:Float)
	DrawVleftTopST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function
Function DrawNumber_5(X:Float, Y:Float, S:Float)
	DrawVleftTopST(X, Y, S)
	DrawVrightBottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawFullDash(x, y, s)
	DrawHbottomST(X, Y, S)
End Function
Function DrawNumber_6(X:Float, Y:Float, S:Float)
	DrawVleftST(X, Y, S)
	DrawVrightBottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function
Function DrawNumber_7(X:Float, Y:Float, S:Float)
	DrawHtopST(X, Y, S)
	DrawFullS(X, Y, S)
End Function
Function DrawNumber_8(X:Float, Y:Float, S:Float)
	DrawLetter_O(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawNumber_9(X:Float, Y:Float, S:Float)

	DrawVrightST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVleftTopST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function


'TEST

'Graphics 640, 240
'Local S:Float = 4
'Repeat
'	If KeyDown(KEY_NUMADD) S:+.1
'	If KeyDown(KEY_NUMSUBTRACT) S:-.1
'	Cls
'	Local Sep:Float = S * 2
'	DrawLetter_A Sep, 20, S
'	DrawLetter_B Sep * 2, 20, S
'	DrawLetter_C Sep * 3, 20, S
'	DrawLetter_D Sep * 4, 20, S
'	DrawLetter_E Sep * 5, 20, S
'	DrawLetter_F Sep * 6, 20, S
'	DrawLetter_G Sep * 7, 20, S
'	DrawLetter_H Sep * 8, 20, S
'	DrawLetter_I Sep * 9, 20, S
'	DrawLetter_J Sep * 10, 20, S
'	DrawLetter_K Sep * 11, 20, S
'	DrawLetter_L Sep * 12, 20, S
'	DrawLetter_M Sep * 13, 20, S
'	DrawLetter_N Sep * 14, 20, S
'	DrawLetter_O Sep * 15, 20, S
'	DrawLetter_P Sep * 16, 20, S
'	drawletter_Q Sep * 17, 20, S
'	drawletter_R Sep * 18, 20, S
'	DrawLetter_S Sep * 19, 20, S
'	DrawLetter_T Sep * 20, 20, S
'	DrawLetter_U Sep * 21, 20, S
'	DrawLetter_V Sep * 22, 20, S
'	DrawLetter_W Sep * 23, 20, S
'	DrawLetter_X Sep * 24, 20, S
'	DrawLetter_Y Sep * 25, 20, S
'	DrawLetter_Z Sep * 26, 20, S
'	DrawNumber_0 Sep, 60, S
'	DrawNumber_1 Sep * 2, 60, S
'	DrawNumber_2 Sep * 3, 60, S
'	DrawNumber_3 Sep * 4, 60, S
'	DrawNumber_4 Sep * 5, 60, S
'	DrawNumber_5 Sep * 6, 60, S
'	DrawNumber_6 Sep * 7, 60, S
'	DrawNumber_7 Sep * 8, 60, S
'	DrawNumber_8 Sep * 9, 60, S
'	DrawNumber_9 Sep * 10, 60, S
'	Flip
'Until KeyHit(KEY_ESCAPE)
'


Function VecDrawText(Text:String, X:Int, Y:Int, Scale:Float = 6)
	Local Seperate:Float = Scale * 2
	For Local N:Int = 1 To Len(Text)
		If Mid:String(Upper(Text), N, 1) = "A" DrawLetter_A (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "B" DrawLetter_B (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "C" DrawLetter_C (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "D" DrawLetter_D (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "E" DrawLetter_E (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "F" DrawLetter_F (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "G" DrawLetter_G (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "H" DrawLetter_H (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "I" DrawLetter_I (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "J" DrawLetter_J (x + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "K" DrawLetter_K (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "L" DrawLetter_L (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "M" DrawLetter_M (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "N" DrawLetter_N (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "O" DrawLetter_O (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "P" DrawLetter_P (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "Q" drawletter_Q (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "R" drawletter_R (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "S" DrawLetter_S (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "T" DrawLetter_T (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "U" DrawLetter_U (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "V" DrawLetter_V (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "W" DrawLetter_W (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "X" DrawLetter_X (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "Y" DrawLetter_Y (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "Z" DrawLetter_Z (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "0" DrawNumber_0 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "1" DrawNumber_1 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "2" DrawNumber_2 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "3" DrawNumber_3 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "4" DrawNumber_4 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "5" DrawNumber_5 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "6" DrawNumber_6 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "7" DrawNumber_7 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "8" DrawNumber_8 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "9" DrawNumber_9 (X + Seperate * N, Y, Scale)
			

'		Print Mid:String(Upper(Text), N, 1)
	Next
End Function

'EXAMPLE! COMMENT THIS OUT IF YOU ARE USING THIS AS AN INCLUDE
Local PrintText:String = "Lorem ipsum dolor sit amet"
Graphics 640, 480
Cls
VecDrawText(PrintText, 10, 100)
Flip
WaitKey
</textarea><br><br>Simply Copy Paste and run. (It has an example running at the bottom that you should comment out if you use this for your own projects) <br><br></td></tr></table><br>
<a name="986403"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Any idea how the draw speed of this compared to normas DrawText?<br><br>If it's faster, it could be very convenient for printing debug diagnostic info to the screen <br><br></td></tr></table><br>
<a name="986408"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd assume it'd be slower because instead of drawing a line of text we're drawing several lines. <br><br></td></tr></table><br>
<a name="986424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was starting to read through your code and then realized that you made one function for every character of the alphabet. lol .... You know, all you need is some kind of array of `font data` ie local coordinates to draw a line from-to, and then just zip through a string of text pulling data from the array and drawing lines in a single function. But still, the way you did it works :-)<br><br>I would think this might actually render faster then DrawText because DrawText has to consider texture pixels which have to be masked, whereas you aren't doing any texturing or masking ... just that you have a bit more geometry data. <br><br></td></tr></table><br>
<a name="986530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> A little modification of the code above after "'EXAMPLE !...." as shown below for getting the time  results leads to more or less 5  times more time needed for VecDrawText() against DrawText(). <br><br><pre class=code>
'EXAMPLE! COMMENT THIS OUT IF YOU ARE USING THIS AS AN INCLUDE

Local start:Int
Local start2:Int
Local endtext:Int
Local PrintText:String = "Lorem ipsum dolor sit amet"

Graphics 640, 480
Repeat
Cls

  If endtext =0 Then
  start =MilliSecs()
  For Local z:Int =0 To 1000
    VecDrawText(PrintText, 10, 100)
  Next
  start2 =MilliSecs()
  For Local z:Int =0 To 1000
    DrawText PrintText, 10,100
  Next
  endtext =MilliSecs()
  End If
  DrawText "Time for 1000x VecDrawText() : "+Trim$(start2 -start), 10,100
  DrawText "Time for 1000x DrawText ()   : "+Trim$(endtext -start2), 10,130



Flip

Forever
</pre> <br><br></td></tr></table><br>
<a name="986551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> A little modification of the code above after "'EXAMPLE !...." as shown below for getting the time results leads to more or less 5 times more time needed for VecDrawText() against DrawText().  <br></div><br><br>Interesting.<br><br>On my PC, the DrawVectorText version is almost 8 times slower than DrawText in that sample. <br><br></td></tr></table><br>
<a name="986834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow.. pretty slow!  Thanks xMicky.  I wonder if it's how I made it (ie: lots of function calls) - not sure though.<br><br>Anywhoot, I made it primarily for a vector based video game. <br><br></td></tr></table><br>
<a name="986846"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whoa... you'd be better to vectorize the pixels in a font and then use those points to redraw them at whatever scale... you could in fact add special effects too at that point.  This is aside from using some vector font mod of course.  Since you are considering a vector based video game I would suggest getting a vector based mod and do everything up vector based.<br><br>I say that because you are limited to LED type display here <br><br></td></tr></table><br>
<a name="986847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> DrawLine is very inefficient. <br><br></td></tr></table><br>
<a name="986848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_Skully</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Brucey,<br><br>I use drawline a little, whats faster? <br><br></td></tr></table><br>
<a name="986863"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> whats faster?<br>At a guess, drawing an OpenGL or DX7 line list. <br><br></td></tr></table><br>
<a name="986866"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> You need to remember that Max2D is fairly generic. This makes it easier for you to knock something cool together relatively quickly, without needing to know about all the underlying lower-level graphics stuff.<br>This comes at a price, though.<br><br>Here's what happens, more or less, when you call DrawLine for OpenGL :<br><pre class=code>
level 1 : max2d

	_max2dDriver.DrawLine gc.handle_x,gc.handle_y, gc.handle_x+x2-x,gc.handle_y+y2-y,..
		x+gc.origin_x,y+gc.origin_y

level 2 : glmax2d

		DisableTex
		glBegin GL_LINES
		glVertex2f x0*ix+y0*iy+tx+.5,x0*jx+y0*jy+ty+.5
		glVertex2f x1*ix+y1*iy+tx+.5,x1*jx+y1*jy+ty+.5
		glEnd
</pre><br>This is also handling origin and transformations for you.<br><br>If you know what you want, you can obviously create your own drawline which you can skip stuff you don't need, and perhaps, as matibee suggests, batch a whole set of lines together - which will be much faster. <br><br></td></tr></table><br>
<a name="986867"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> TonyG once suggested a list of improvements that would fit well within a better Max2D... things like batched drawing.<br><br>DrawText is another painfully slow routine - if you consider how it works.<br>Single-surface text drawing is an order of magnitude faster. <br><br></td></tr></table><br>
<a name="986871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Matt...<br><br>The way you're doing things is pretty inefficient, at least in terms of code length. As IH suggested, an array of plot points for each letter would have been easier, however, I find your approach to the problem intriguing. You must have put a lot of effort into it, and it's interesting how you've built the characters up from a set of parts. <br><br></td></tr></table><br>
<a name="986874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey thanks guys, yeah I just tackled the project with limited knowledge.  I plan on abandoning this method and using bitmap fonts from this point on.  It still was a good coding exercise I guess lol :)  I appreciate your feedback. <br><br></td></tr></table><br>
<a name="986929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't be put off. Speed isn't everything, and vector drawing has its place... like the retro game you're making. <br><br></td></tr></table><br>
<a name="987008"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> One great advantage of your vector text is that you don't have to care, what fonts are installed on the end-users PC and that there are no font-related-copyright-questions to deal with at all.<br><br>I assume, the speed could be increased in the way ImaginaryHuman pointed out; many function-calls and string-operations for each char are probably a heavy weight slow-down, Drawline() alone should not be the reason for the major time difference against DrawText(). <br><br></td></tr></table><br>
<a name="987015"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was planning on using the vector text code, but turning all of the letters into images (via code) and just drawing the pictures instead.  My primary focus is just making a cool font for the game.  I'm thinking that pixmapping should increase speed. <br><br></td></tr></table><br>
<a name="987029"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have no idea how to do this as an array.  All of the from-to coordinates are dependant on what the X,Y and lettersize are.  If I need to draw a letter, then I use functions to draw each part of the letter (each line).<br><br>I only know the basics of arrays, not sure how arrays of arrays work or resizing them etc.  Not sure if I'd have to do that, but I can't seem to figure out how it would work just using an array.<br><br>I've spent the last 4 hours trying to figure this out.  Do I need to create an array for every part? <br><br>I did it like this:<br><pre class=code>
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	'Top [ (TopLeftStr) IS Ox, oY, Ox, Hy
	Local TopLeftStr:Float[3]
	TopLeftStr[0] = Ox ; TopLeftStr[1] = Oy ; TopLeftStr[2] = Ox ; TopLeftStr[3] = Hy
	'Bottom [ = Ox, Y, Ox, Hy
	Local BottomLeftStr:Float[3]
</pre><br>But that doesn't make any sense to me.  It's like I'm creating a bunch of arrays for no reason.  <br><br>I can't figure out what type of Array to make becuase I dont know how I'd pull the data from the array to draw each line.  Since every single letter uses a different amount of lines, I'd be telling the computer to draw so many lines per letter thus the lines of code would differ.  I dont know how many arrays to make, and reading the BlitzMax manual on arrays is not helping me at all.  If you care to shed some light then please do so.  Otherwise I can just keep the code as it is and do some pixmapping.  I've spent the last 4 hours getting frustrated with arrays so I think I'm going to take a much needed break.. :S <br><br></td></tr></table><br>
<a name="987108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> How to code a text with DrawLine() is not at least a question of the personal style of the programmer; for a fast hack, I would think of  something like (only for "x", "y", "z") the following, which needs  round about 3times more than DrawText() (which may become worse, if letters are used which need more Drawline()'s) :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Graphics 800,600
Local start:Int
Local start2:Int
Local endtext:Int
Local PrintText:String ="XYZXYZXYZXYZ"

While Not (KeyHit(key_escape) Or AppTerminate())
	Cls
	
	If endtext =0 Then
		start =MilliSecs()
		For Local z:Int =0 To 1000
			DrawLineText(PrintText, 100, 100, .4)
		Next
		start2 =MilliSecs()
		For Local z:Int =0 To 1000
			DrawText PrintText, 100, 100
		Next
		endtext =MilliSecs()
             End If
             DrawText "Time for 1000x DrawLineText() : "+Trim$(start2 -start), 10,100
             DrawText "Time for 1000x DrawText ()   : "+Trim$(endtext -start2), 10,13

	     Flip
Wend

Function DrawLineText(t:String, x:Float, y:Float, size:Float =1, condense:Float =10, r:Int =255, g:Int =255, b:Int =255) 

     SetColor r, g, b

     For Local z:Int =0  To t.Length-1
	 If t[z] =88 Or t[z] =120 Then
	   ' x, X
            DrawLine x, y +size *20, x +size *10, y
           DrawLine x, y, x +size *10, y +size *20
           x :+(10 +condense) *size
         ElseIf t[z] =121 Or t[z] =89 Then
	    ' y, Y
	    DrawLine x, y, x +size *5, y +size *10
	    DrawLine x, y +size *20, x +size *10, y
            x :+(10 +condense) *size			
        ElseIf t[z] =122 Or t[z] =90 Then
	   'z, Z
	   DrawLine x, y, x +size *10, y
	   DrawLine x +size *10, y, x, y +size *20
	   DrawLine x, y +size *20, x +size *10,  y +size *20
           x :+(10 +condense) *size				   
       End If
   Next

End Function 
</textarea><br><br>Perhaps the question for the speed was a turn into a wrong direction anyway, because even a 5 to 10 times slower text drawing compared to DrawText() may be more than fast enough to keep the app running with a sufficient frame rate, if not the whole screen is filled with text; it might be a good idea to test this performance first before spending time to make your text drawing faster... <br><br></td></tr></table><br>
<a name="987132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thought that was an interesting way that you went through the print string.  Still don't fully grasp it but wow that's a neat way to do it!  As far as drawing the text through if statements! that's the same thing I did with the exception of calling a function isntead of just putting the drawline commands there.  I did that to make it easier on me to read my own code.   <br><br>Anyway I was trying to see if I could make it all grab the drawline points from an array but that just didnt work.  I think that's because it's not possible! lol.  <br><br>My goal right now is to learn how to use grabimage in a for next loop by grabbing different parts of the screen so I can take the alphabet and use a drawimage function instead of a drawline function.  This should be faster than drawing lines with each step.<br><br>I wanted to say that my friends computer (factory shipped xp) runs my game at only 25fps, while on my computer it runs at 120fps.  So I am hoping that if I get this vectortext thing turned into just a bitmap font that I create on the fly in the game itself I can increase speed on his computer.<br><br>My main goal of coding is to code as efficiently as possible without sacrificing a reasonable understanding of the syntax. <br><br></td></tr></table><br>
<a name="987157"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK, you demanded it...;)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict
Graphics 800,600
Local start:Int
Local start2:Int
Local endtext:Int
Local PrintText:String ="XYZXYZXYZXYZXYZ"

Global charData:Int[]
InitChars()

While Not (KeyHit(key_escape) Or AppTerminate())

	Cls

	If endtext =0 Then
		start =MilliSecs()
		For Local z:Int =0 To 1000
			DrawLineText(PrintText, 100, 100, .4)
		Next
		start2 =MilliSecs()
		For Local z:Int =0 To 1000
			DrawText PrintText, 100, 100
		Next
		endtext =MilliSecs()
  End If
  DrawText "Time for 1000x DrawLineText() : "+Trim$(start2 -start), 10,100
  DrawText "Time for 1000x DrawText ()   : "+Trim$(endtext -start2), 10,13

	Flip
Wend


Function InitChars()

  charData =New Int[56]

  'header......&gt;
  charData[0] =6 'six chars defined ="x", "y", "z", "X", "Y", "Z"
  ' asc-values of chars
  charData[1] =88
  charData[2] =89
  charData[3] =90
  charData[4] =120
  charData[5] =121
  charData[6] =122
  ' three data for each char: data start, linecount, char's width
  charData[7] =25
  charData[8] =2
  charData[9] =20
  charData[10] =34
  charData[11] =2
  charData[12] =20
  charData[13] =43
  charData[14] =3
  charData[15] =20
  charData[16] =25
  charData[17] =2
  charData[18] =20
  charData[19] =34
  charData[20] =2
  charData[21] =20
  charData[22] =43
  charData[23] =3
  charData[24] =20
  'char data.....&gt;
  'x, X
  charData[25] =0
  charData[26] =0
  charData[27] =20
  charData[28] =20
  charData[29] =0
  charData[30] =20
  charData[31] =20
  charData[32] =0
  charData[33] =20
  ' y, Y
  charData[34] =0
  charData[35] =0
  charData[36] =10
  charData[37] =10
  charData[38] =20
  charData[39] =0
  charData[40] =0
  charData[41] =20
  charData[42] =20
  'z, Z
  charData[43] =0
  charData[44] =0
  charData[45] =10
  charData[46] =0
  charData[47] =10
  charData[48] =0
  charData[49] =0
  charData[50] =20
  charData[51] =0
  charData[52] =20
  charData[53] =10
  charData[54] =20
  charData[55] =20

End Function

Function DrawLineText(t:String, x:Float, y:Float, size:Float =1, condense:Float =10) 

	For Local z:Int =0 To t.Length-1
	   For Local zz:Int =1 To charData[0]
	     If t[z] =charData[zz] Then
          Local start:Int =charData[zz *3 +4]        
          For Local zzz:Int =1 To charData[zz *3 +5]
            DrawLine x +charData[start] *size, y +charData[start +1] *size, x +charData[start +2] *size, y +charData[start +3] *size
            start :+4
          Next  
          x :+(charData[zz *3 +6] +condense) *size
         Exit
       End If  
     Next
   Next

End Function 
</textarea> <br><br></td></tr></table><br>
<a name="987171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fascinating..<br><br><pre class=code>
SuperStrict
Local t:String = "hello world"

For Local i:Int = 0 To t.length - 1
	Print t[i]
	
Next
</pre><br>I just hacked that together because I've just learned how to find the ASCII codes of each character in a string without using old basic string functions.  Very nice and helpful, thank you!  I'm going to dissect your code a bit further so I can fully understand it. <br><br></td></tr></table><br>
<a name="987183"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I want to thank you for that bit of code.<br><br>I've been dissecting it and I'm starting to understand what it does.<br>I have added print functions and a waitkey that helps explain what its doing within each cycle.<br><br>The only part I don't understand is how [zz*3+4] works???  I assume it's used to gather how many maximum lines are drawn, but what I don't understand is that if [zz] = 120, and you multiple that by 3 and add 4 you come up with a number that is much higher then how many lines that are needed to be drawn.  Since there is no CharData[364] that would = the amount of lines drawn I'm also confused. Can you tell me how that part works?   Thanks!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Function DrawLineText(t:String, x:Float, y:Float, size:Float =1, condense:Float =10) 
	Print "Reading String that is " + (t.Length - 1) + " characters long."
	For Local z:Int = 0 To t.Length - 1 ' reads the ascii codes of the string
	   Print "Reading " + z + " of " + (t.Length - 1)
	   Print "CharData[0] = " + charData[0]
	   Print "Now zz is going from 1 to the maximum number of defined characters"
	   Print "looking for a match..."
	   For Local zz:Int = 1 To charData[0]
		Print t[z] + " compared to " + charData[zz]
	     If t[z] = charData[zz] Then 'If we find the ascii code for the letter we draw it
		 Print "The Ascii code of the string matches the Chardata string!"
          Local start:Int = charData[zz * 3 + 4] 'So the start is at the maximum lines we need to draw, not sure why?

          For Local zzz:Int = 1 To charData[zz * 3 + 5] 'For zzz = 1 to how many lines we need to draw.
			 Print "Drawing Line" + zzz + " of " + charData[zz * 3 + 5]
			 Print "CharData[zz] is " + charData[zz]
			 Print "CharData[zz*3+5 is]" + charData[zz * 3 + 5]
             Print charData[zz] * 3 + 5 'so [zz*3+5] does not = [zz]*3 + 5.  But why!?
			DrawLine x + charData[start] * size, y + charData[start + 1] * size, x + charData[start + 2] * size, y + charData[start + 3] * size
			Flip
			WaitKey()
            start:+4 'start +4, hmmm
          Next  
          x:+(charData[zz * 6 + 6] + condense) * size
         Exit
       End If  
     Next
   Next
Cls
End Function 
</textarea> <br><br></td></tr></table><br>
<a name="987205"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I have updated the code.<br><br>You now have two functions<br><br>VecDrawText()<br><br>And Vecdraw_img_text()<br><br>VecDraw_img_text() is faster than drawtext!!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

'Initialize Text *****

Graphics 320, 240
Cls
Global VecChar:TImage[96]
SetColor 255, 255, 255
SetBlend ALPHABLEND
Const FONTSIZE:Float = 12
For Local i:Int = 0 To 95
	Cls
	If i = 15 DrawFullS(0, 0, FontSize)
	If i = 16 DrawNumber_0(0, 0, FontSize)
	If i = 17 DrawNumber_1(0, 0, FontSize)
	If i = 18 DrawNumber_2(0, 0, FontSize)
	If i = 19 DrawNumber_3(0, 0, FontSize)
	If i = 20 DrawNumber_4(0, 0, FontSize)
	If i = 21 DrawNumber_5(0, 0, FontSize)
	If i = 22 DrawNumber_6(0, 0, FontSize)
	If i = 23 DrawNumber_7(0, 0, FontSize)
	If i = 24 DrawNumber_8(0, 0, FontSize)
	If i = 25 DrawNumber_9(0, 0, FontSize)
	If i = 28 DrawLeftChevron(0, 0, FontSize)
	If i = 30 DrawRightChevron(0, 0, FontSize)
	If i = 33 Or i = 65 DrawLetter_A(0, 0, FontSize)
	If i = 34 Or i = 66 DrawLetter_B(0, 0, FontSize)
	If i = 35 Or i = 67 DrawLetter_C(0, 0, FontSize)
	If i = 36 Or i = 68 DrawLetter_D(0, 0, FontSize)
	If i = 37 Or i = 69 DrawLetter_E(0, 0, FontSize)
	If i = 38 Or i = 70 DrawLetter_F(0, 0, FontSize)
	If i = 39 Or i = 71 DrawLetter_G(0, 0, FontSize)
	If i = 40 Or i = 72 DrawLetter_H(0, 0, FontSize)
	If i = 41 Or i = 73 DrawLetter_I(0, 0, FontSize)
	If i = 42 Or i = 74 DrawLetter_J(0, 0, FontSize)
	If i = 43 Or i = 75 DrawLetter_K(0, 0, FontSize)
	If i = 44 Or i = 76 DrawLetter_L(0, 0, FontSize)
	If i = 45 Or i = 77 DrawLetter_M(0, 0, FontSize)
	If i = 46 Or i = 78 DrawLetter_N(0, 0, FontSize)
	If i = 47 Or i = 79 DrawLetter_O(0, 0, FontSize)
	If i = 48 Or i = 80 DrawLetter_P(0, 0, FontSize)
	If i = 49 Or i = 81 drawletter_Q(0, 0, FontSize)
	If i = 50 Or i = 82 drawletter_R(0, 0, FontSize)
	If i = 51 Or i = 83 DrawLetter_S(0, 0, FontSize)
	If i = 52 Or i = 84 DrawLetter_T(0, 0, FontSize)
	If i = 53 Or i = 85 DrawLetter_U(0, 0, FontSize)
	If i = 54 Or i = 86 DrawLetter_V(0, 0, FontSize)
	If i = 55 Or i = 87 DrawLetter_W(0, 0, FontSize)
	If i = 56 Or i = 88 DrawLetter_X(0, 0, FontSize)
	If i = 57 Or i = 89 DrawLetter_Y(0, 0, FontSize)
	If i = 58 Or i = 90 DrawLetter_Z(0, 0, FontSize)
	If i = 60 DrawFullS(0, 0, FontSize)
	VecChar[i] = CreateImage(FontSize + 1, FontSize + 1, 1, DYNAMICIMAGE | MASKEDIMAGE)
	GrabImage VecChar[i], 0, 0
Next

Function DrawVleftST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, Ox, oY) 'Verticle Left Straight

End Function
']
Function DrawVrightST(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + LetterSize
	Local Y:Float = Oy + LetterSize
    DrawLine (X, Y, X, Oy)  'Verticle Right Straight
 	
End Function
'Half Top [
Function DrawVleftTopST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, oY, Ox, Hy) 'Verticle Left TOP Straight
	
End Function
'Half Bottom [
Function DrawVleftBottomST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hy:Float = Oy + Lettersize / 2
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, Ox, Hy) 'Verticle Left BOTTOM Straight
	
End Function
'Half Top ]
Function DrawVrightTopST(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + LetterSize
	Local Hy:Float = Oy + Lettersize / 2
    DrawLine (X, oY, X, Hy)  'Verticle Right Straight
	
End Function
'Half Bottom ]
Function DrawVrightBottomST(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hy:Float = Oy + Lettersize / 2
	Local X:Float = Ox + LetterSize
	Local Y:Float = Oy + LetterSize
    DrawLine (X, Y, X, Hy)  'Verticle Right Straight
	
End Function
'Top
Function DrawHtopST(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	DrawLine (ox, oy, x, oy) 'Horizontal Top Straight
	
End Function
'Bottom
Function DrawHbottomST(Ox:Float, Oy:Float, LetterSize:Float)

	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, X, Y) 'Horizontal Bottom Straight
	
End Function
'\
Function DrawFullBS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Oy, X, Y) 'Full \ BackSlash
	
End Function
'Top \
Function DrawHalfTBS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Oy, hx, hy) 'Half Upper \ BackSlash
	
End Function
'Bottom \
Function DrawHalfLBS(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (x, y, Hx, Hy) 'Half Lower \ BackSlash
End Function
'/
Function DrawFullS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	DrawLine (Ox, Y, X, Oy) 'Full / Slash

End Function
'Top /
Function DrawTS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (X, Oy, Hx, Hy) 'Half Upper / Slash
	
End Function
'Bottom /
Function DrawLS(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Y, Hx, Hy) 'Half Lower / Slash
	
End Function
'-
Function DrawFullDash(Ox:Float, Oy:Float, LetterSize:Float)

	Local X:Float = Ox + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Hy, X, Hy)  'Draw a Full -

End Function
'Left -
Function DrawLeftDash(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (Ox, Hy, HX, Hy)  'Draw a Left - (half a full dash)

End Function
'Right -
Function DrawRightDash(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine (X, Hy, HX, Hy)  'Draw a Right - (half a full dash)

End Function
'|
Function DrawPipe(Ox:Float, Oy:Float, LetterSize:Float)

	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	DrawLine (Hx, Y, Hx, Oy)
	
End Function
'Low |
Function DrawBottomPipe(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Hx, Y, Hx, Hy)
	
End Function
'Top |
Function DrawTopPipe(Ox:Float, Oy:Float, LetterSize:Float)

	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Hx, Oy, Hx, Hy)
	
End Function
'Top &gt;
Function DrawTopRightChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Ox, Oy, X, Hy)
End Function
'Bottom &gt;
Function DrawBottomRightChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2	
	DrawLine(Ox, Y, x, Hy)
End Function
'Full &gt;
Function DrawRightChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(Ox, Oy, X, Hy)
	DrawLine(Ox, Y, x, Hy)
	
End Function
'Top &lt;
Function DrawTopLeftChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(X, OY, Ox, Hy)
End Function
'Bottom &lt;
Function DrawBottomLeftChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2	
	DrawLine(X, Y, Ox, Hy)
End Function
'Full &lt;
Function DrawLeftChevron(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(X, Y, Ox, Hy)
	DrawLine(X, OY, Ox, Hy)
	
End Function
'A damn D
Function DrawaDamnD(Ox:Float, Oy:Float, LetterSize:Float)
	
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 3
	Local Hy:Float = Oy + Lettersize / 28
	Local Hyd:Float = Oy + Lettersize / 1.028
	DrawLine(Ox, Oy, X, Hy)
	DrawLine(Ox, Y, x, Hyd)
	DrawLine(x, Hy, X, Hyd)
End Function
'A damn V
Function DrawaV(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	DrawLine(ox, oy, hx, y)
	DrawLine(x, oy, hx, y)
End Function
'Upside Down Carrot
Function DrawUSDCarrot(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(ox, oy, hx, hy)
	DrawLine(x, oy, hx, hy)
		
End Function
'Left Half Carrot
Function DrawLeftHalfCarrot(Ox:Float, Oy:Float, LetterSize:Float)
	Local X:Float = Ox + Lettersize
	Local Y:Float = Oy + Lettersize
	Local Hx:Float = Ox + Lettersize / 2
	Local Hy:Float = Oy + Lettersize / 2
	DrawLine(hx, oy, ox, hy)
		
End Function



Function DrawLetter_A (X:Float, Y:Float, S:Float)

	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_B (X:Float, Y:Float, S:Float)
		
	DrawVleftST(X, Y, S)
	DrawaDamnD(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_C (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)

End Function

Function DrawLetter_D (X:Float, Y:Float, S:Float)
	DrawVleftST(X, Y, S)
	DrawaDamnD(X, Y, S)
End Function

Function DrawLetter_E (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_F (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_G (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawRightDash(X, Y, S)
	DrawVrightBottomST(X, Y, S)
	
End Function

Function DrawLetter_H (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_I (X:Float, Y:Float, S:Float)
	
	DrawPipe(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	
End Function

Function DrawLetter_J (X:Float, Y:Float, S:Float)
	
	DrawVrightST(X, Y, S)
	DrawVleftBottomST(X, Y, S)
	DrawHbottomST(X, Y, S)
	
End Function

Function DrawLetter_K (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawLeftChevron(X, Y, S)
	
End Function

Function DrawLetter_L (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHbottomST(X, Y, S)
	
End Function
Function DrawLetter_M (X:Float, Y:Float, S:Float)
	
	DrawHtopST(X, Y, S)
	DrawTopPipe(X, Y, S)
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	
	
End Function

Function DrawLetter_N (X:Float, Y:Float, S:Float)
	
	DrawFullBS(X, Y, S)
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	
	
End Function

Function DrawLetter_O (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawHtopST(X, Y, S)
		
	
End Function

Function DrawLetter_P (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVrightTopST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function
Function drawletter_Q (X:Float, y:Float, S:Float)

	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHalfLBS(X, Y, S)
	
End Function

Function drawletter_R (X:Float, y:Float, S:Float)

	DrawVleftST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVrightTopST(X, Y, S)
	DrawFullDash(X, Y, S)
	DrawBottomLeftChevron(X, Y, S)
End Function

Function DrawLetter_S (X:Float, Y:Float, S:Float)
	
	DrawVleftTopST(X, Y + 1, S)
	DrawVrightBottomST(X, Y, S - 1)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawLetter_T (X:Float, Y:Float, S:Float)
	
	DrawPipe(X, Y, S)
	DrawHtopST(X, Y, S)
End Function

Function DrawLetter_U (X:Float, Y:Float, S:Float)
	
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawHbottomST(X, Y, S)

End Function

Function DrawLetter_V (X:Float, Y:Float, S:Float)
	
	DrawaV(X, Y, S)

End Function

Function DrawLetter_W (X:Float, Y:Float, S:Float)
	
	DrawHbottomST(X, Y, S)
	DrawBottomPipe(X, Y, S)
	DrawVleftST(X, Y, S)
	DrawVrightST(X, Y, S)
	
	
End Function

Function DrawLetter_X (X:Float, Y:Float, S:Float)
	DrawFullS(X, Y, S)
	DrawFullBS(X, Y, S)
End Function

Function DrawLetter_Y(X:Float, Y:Float, S:Float)
	DrawUSDCarrot(X, Y, S)
	DrawBottomPipe(X, Y, S)
End Function

Function DrawLetter_Z(X:Float, Y:Float, S:Float)
	DrawHtopST(X, Y, S)
	DrawFullS(X, Y, S)
	DrawHbottomST(X, Y, S)
End Function

Function DrawNumber_0(X:Float, Y:Float, S:Float)
	DrawLetter_O(X, Y, S)
	DrawFullS(X, Y, S)
End Function

Function DrawNumber_1(X:Float, Y:Float, S:Float)
	DrawPipe(X, Y, S)
	DrawLeftHalfCarrot(X, Y, S)
	DrawHbottomST(X, Y, S)
End Function

Function DrawNumber_2(X:Float, Y:Float, S:Float)
	DrawVrightTopST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawVleftBottomST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function

Function DrawNumber_3(X:Float, Y:Float, S:Float)
	DrawVrightST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function

Function DrawNumber_4(X:Float, Y:Float, S:Float)
	DrawVleftTopST(X, Y, S)
	DrawVrightST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function
Function DrawNumber_5(X:Float, Y:Float, S:Float)
	DrawVleftTopST(X, Y, S)
	DrawVrightBottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawFullDash(x, y, s)
	DrawHbottomST(X, Y, S)
End Function
Function DrawNumber_6(X:Float, Y:Float, S:Float)
	DrawVleftST(X, Y, S)
	DrawVrightBottomST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawHbottomST(X, Y, S)
	DrawFullDash(X, Y, S)
End Function
Function DrawNumber_7(X:Float, Y:Float, S:Float)
	DrawHtopST(X, Y, S)
	DrawFullS(X, Y, S)
End Function
Function DrawNumber_8(X:Float, Y:Float, S:Float)
	DrawLetter_O(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function

Function DrawNumber_9(X:Float, Y:Float, S:Float)

	DrawVrightST(X, Y, S)
	DrawHtopST(X, Y, S)
	DrawVleftTopST(X, Y, S)
	DrawFullDash(X, Y, S)
	
End Function




Function VecDrawText(Text:String, X:Int, Y:Int, Scale:Float = 6)
	Local Seperate:Float = Scale * 2
	For Local N:Int = 1 To Len(Text)
		If Mid:String(Upper(Text), N, 1) = "A" DrawLetter_A (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "B" DrawLetter_B (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "C" DrawLetter_C (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "D" DrawLetter_D (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "E" DrawLetter_E (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "F" DrawLetter_F (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "G" DrawLetter_G (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "H" DrawLetter_H (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "I" DrawLetter_I (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "J" DrawLetter_J (x + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "K" DrawLetter_K (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "L" DrawLetter_L (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "M" DrawLetter_M (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "N" DrawLetter_N (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "O" DrawLetter_O (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "P" DrawLetter_P (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "Q" drawletter_Q (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "R" drawletter_R (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "S" DrawLetter_S (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "T" DrawLetter_T (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "U" DrawLetter_U (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "V" DrawLetter_V (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "W" DrawLetter_W (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "X" DrawLetter_X (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "Y" DrawLetter_Y (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "Z" DrawLetter_Z (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "0" DrawNumber_0 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "1" DrawNumber_1 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "2" DrawNumber_2 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "3" DrawNumber_3 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "4" DrawNumber_4 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "5" DrawNumber_5 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "6" DrawNumber_6 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "7" DrawNumber_7 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "8" DrawNumber_8 (X + Seperate * N, Y, Scale)
		If Mid:String(Upper(Text), N, 1) = "9" DrawNumber_9 (X + Seperate * N, Y, Scale)
			

'		Print Mid:String(Upper(Text), N, 1)
	Next
End Function


Function VecDraw_img_Text(Text:String, X, Y, Scale:Float = FONTSIZE)
	SetScale scale *.1, scale *.1
	For Local n = 0 To Text.Length - 1
		DrawImage(VecChar[Text[n] - 32], x, y)
		x:+scale * (FONTSIZE *.15)
	Next
	SetScale(1, 1)
End Function
Local PrintText:String = "This is just a Test"

Graphics 640, 480
Repeat

  If endtext = 0 Then
  start = MilliSecs()
  For Local z:Int =0 To 1000
    VecDrawText(PrintText, 10, 10)
  Next
  start2 = MilliSecs()
  For Local zz:Int = 0 To 1000
    DrawText PrintText, 10, 30
  Next
  start3 = MilliSecs()
  For Local zzz:Int = 0 To 1000
    VecDraw_img_Text PrintText, 10, 50
  Next
  endtext = MilliSecs()
  End If
  DrawText "Time for 1000x VecDrawText() : " + Trim:String(start2 - start), 10, 100
  DrawText "Time for 1000x DrawText ()   : " + Trim:String(start3 - start2), 10, 120
  DrawText "Time for 1000x VecDraw_img_Text ()   : " + Trim:String(endtext - start3), 10, 140
  



Flip


Until KeyHit(KEY_ESCAPE) Or AppTerminate()


</textarea> <br><br></td></tr></table><br>
<a name="987322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> True, on my notebook VecDraw_img_ext needed 69 ms, DrawText 79 ms.  Seems, you have made very good progress over  the last few days :)<br><br>What does the term [zz*3 +4] means ?<br>zz is the array index where the asc-value of the char was found, which is to print next. For each char then the array contains three special informations:<br>#1: where in the array the data for the Drawline-commands starts,<br>#2: how many lines are to draw to display that char,<br>#3: the width in pixel of that char.<br>Those triples starts at index 7 in the array, which belongs to the first defined char, then at index 10 stands the triple for the second defined char, at 13 the infos for char#3...you get 7, 10, 13 as values for zz =1,2,3 if you calculate: zz*3 +4.<br><br>Erm, don't know, whether your question indicates, that you already discovered this: the term is correct, but ONLY for 6 defined chars in the<br>array . For the general case of n chars the term must be: [zz *3 +charData[0] -2]. Sorry, I wrote the code yesterday on the fly and took the first term that jumped into my eye. <br><br></td></tr></table><br>
<a name="987339"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ugh, I don't get it!<br><br>What's a triple?<br><br>Is the #1,#2,#3 the zz the 3 and the 4?<br><br>How does [zz*3+4] find the amount of lines that need to be drawn?<br><br>It's my understanding that [zz] where exactly in the array we're dealing with.. That's called the index right? (not 100%) but since [zz]'s index holds an ASCII code, of say... 120, then isn't 120*3+4 like way higher than the amount of lines that need to be drawn, say 2???? :S :S :S<br><br><pre class=code>
         For Local zzz:Int = 1 To charData[zz * 3 + 5] 'For zzz = 1 to how many lines we need to draw.
</pre><br><br>Draw a line in this for..next loop.. WTF?  I dont get that part lol <br><br></td></tr></table><br>
<a name="987353"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> a "triple" is a set of three, here: data values belonging to/describing the same char; is this in english not a used phrase, I took it as such, translating from german ?<br><br>[zz*3 +4] does NOT lead to the count of lines to draw, but to the array index, where the coordinates for the char starts.<br><br>[zz*3 +5] does NOT hold an ASCII-value, but the count of lines of the char<br><br>In a short, the array is build as such:<br><br>charData[0] =count of defined chars<br>charData[1] =ASCII of first defined char<br>charData[2] =ASCII of second defined char<br>...and so on until:<br>charData[6] =ASCII of sixth defined char<br>chardata[1*3 +4=7]: array index, which hold array index, where  <br>                                    chars#1 data starts <br>chardata[1*3 +5=8]:line count of char #1  <br>chardata[1*3 +6=9]:width of char#1         <br>chardata[2*3 +4=10]: array index,  which hold array index, where     <br>                                     chars#2 data starts <br>chardata[2*3 +5=11]:line count of char #2  <br>chardata[2*3 +6=12]:width of char#2         <br>...                                                                  <br>charData[charData[7]] :start of data of char#1<br>....                                                                      <br>charData[charData[10]] :start of data of char#2 <br>.... <br><br></td></tr></table><br>
<a name="987608"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt McFarland</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> ohhhhhh, that makes sense.  Thanks! so if I had about 36 characters or more, then I'd do zzz*36 + start coordinates, then + the line count.. then + another thing which is for the condense part..  condense.. sup with condense anyway? <br><br></td></tr></table><br>
<a name="987748"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xMicky</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Condense is just an additional distance between the chars to make the text wider or more condensed. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
