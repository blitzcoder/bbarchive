<!DOCTYPE html><html lang="en" ><head ><title >Optimizing my game</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Optimizing my game</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >Optimizing my game</a><br><br>
<a name="826464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> So, I have a main loop that is pretty heavy. In it, we have movement, collision and magnetism for each object, and my game can get some hundred objects on the screen at the same time.<br><br>It doesn't produce much slowdown really, but I think lower end systems wouldn't be able to run this so well. So, at the very least, I'm optimizing the loop a lot.<br><br>Now, I have some optimizing questions:<br><br>Question 1:<br>Methods and functions can be very clean and nice, but do they use extra resources complared to just having the code directly in the loop?<br><br>For example, to do collisions between objects, the distance between objects are constantly checked. I have a function that returns the distance between two objects, and it gets used several hundred times a second at it's worst. Would putting the distance code directly into the loop help optimize some?<br><br>Question 2:<br>When I refer to objects, does ever step within it cause a slight extra resource use?<br>For example, let's say that I do this:<br><pre class=code>
Object1.XPosition = Self.ParentUniverse.Player.Location1X
Object1.YPosition = Self.ParentUniverse.Player.Location1Y
Object2.XPosition = Self.ParentUniverse.Player.Location1X
Object2.YPosition = Self.ParentUniverse.Player.Location1Y
</pre><br>would this be faster or slower?:<br><pre class=code>
Local temp1 = Self.ParentUniverse.Player.Location1X
Local temp2 = Self.ParentUniverse.Player.Location1X
Object1.XPosition = temp1
Object1.YPosition = temp2
Object2.XPosition = temp1
Object2.YPosition = temp2
</pre><br><br>Since, although we use two extra local variables, we avoid accessing values though so many objects.<br><br>Question3:<br>If a draw command is called with an X and Y position that is outside the screen (like -500,-200), will it be done or ignored? <br><br></td></tr></table><br>
<a name="826467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could easily benchmark it --<br><br>look at millisecs(), loop through a million iterations of each snippet, and look at millisecs() again. <br><br></td></tr></table><br>
<a name="826469"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's not going to make that much difference. There are probably other optimisations you can do which make much more of a difference. Without knowing how you've coded it you might want a custom collision routine, shifted grid checking, array vs list vs custom list check etc etc. <br><br></td></tr></table><br>
<a name="826477"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> xlsior:<br>Ah, thanks. This will be very useful.<br><br>tonyg:<br>I suspected that much, but, I was thinking that even small things can become much when done several hundred times a second.<br><br>But, anyways, is there a list somewhere over common traps for ineffective code? (such as deciding between an array or list) <br><br></td></tr></table><br>
<a name="826482"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you aren't already, use Strict or SuperStrict. Apart from doing some extra compile-time error checking, it results in slightly more efficient code.<br><br>1) Yes, there is some overhead, but the cost is minimal.<br><br>3) It will certainly get as far as asking the driver to perform the task. You might find it's better to do a bounds check first, if you know that the resulting draw won't be visible. <br><br></td></tr></table><br>
<a name="826514"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> In your distance checking code, use squared distances instead of actual distances, if you can. This'll cut out the need to use Sqr(). <br><br></td></tr></table><br>
<a name="826520"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Try not to constantly create and remove objects as it increases the number of times GC is run. Use arrays or reuse existing objects (do a search for 'Object pooling') Try not to use strings for the same reason. <br><br></td></tr></table><br>
<a name="826531"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> big10p:<br>Squared distances? Sorry, not quite following you, what is a squared distance?<br><br>tonyg:<br>Unfortunately, I have to create and destroy a lot of objects. (I'll try to reuse) However, could I run the Garbage collector manually to make sure it doesn't run too often? <br><br></td></tr></table><br>
<a name="826548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep you can run manual GC. You probably *don't* have to destroy the objects though. If they're bullets have a pre-built list/array of bullets with a pointer to the next free one. Once 'dead' mark it is 'available' and you won't put it into GC. There is a good post on Object pools (you did read it... didn't you?) which explains the benefits. <br><br></td></tr></table><br>
<a name="826551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Squared distances? Sorry, not quite following you, what is a squared distance? <br></div>Say your sprites have a collision radius: instead of calculating the actual distance between two sprites (which requires a call to Sqr), you can work with the squared distance between the two sprites, instead. e.g. (pseudo code)<br><br>dx# = s1.x - s2.x<br>dy# = s1.y - s2.y<br><br>dist_sqr# = dx * dx + dy * dy<br><br>if dist_sqr &lt; (s1.rad * s1.rad + s2.rad * s2.rad) then sprites have collided!<br><br>This assumes that sprite x/y refers to the centre of the sprites, BTW. <br><br></td></tr></table><br>
<a name="826557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >QuietBloke</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> of course if you go one step further and have a field radsquared in each sprite which contains rad*rad.<br>That way you can say :<br><br>if dist_sqr &lt; ( s1.radSquared + s2.radSquared ) then collided. <br><br></td></tr></table><br>
<a name="826562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> tonyg:<br>Ah, I see. Yes, I have a machine gun kinda thing, so this could be very useful. Thanks!<br><br>big10p and QuietBloke:<br>Ah, thanks, but it won't do. Physics is very important in my game, and this won't give me the possibilities I want. If you bounce into another object, there is a very nice collision system which bounces and does damage both.<br><br>HOWEVER, It could be an idea to apply both. First have a square collision system that saves a lot of resources with it's easy calculating, and then, when we are sure they are close enough, then I could apply my own advanced collision.<br><br>I'm not sure how much more effective it would be, since it does add a new calculation for ever bounce. I guess it depends on how often objects bounce and how large the playing area is. I shall do both and test them. <br><br></td></tr></table><br>
<a name="826578"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, you can use it for an initial check before proceeding with a more involved collision check. If you then need the actual distance between the two objects, you can, of course, just do dist# = Sqr(dist_sqr). <br><br></td></tr></table><br>
<a name="826580"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you have lots of objects which might collide there is a good post on 'shifted grid collisions'. You did search for it... didn't you? <br><br></td></tr></table><br>
<a name="826583"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> You mean this demo I did?<br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=1065" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=1065</a><br><br>Or, is there another one done in bmax? <br><br></td></tr></table><br>
<a name="826598"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do optimise, but if it means your code is less readable, as it would if you were to unroll loops or move code out of methods, then I would avoid it. <br><br></td></tr></table><br>
<a name="826600"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would say use as many Local variables as you can, inline small pieces of code rather than functionalizing or OOPing everything, find better algorithms, and find ways to split up your problem into smaller groups so you don't have to compare every object against every other object. <br><br></td></tr></table><br>
<a name="826602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does bmax support inline functions? I wish Blitz3D did.<br><br>I agree with Beaker, although there's always occasions where you want to squeeze the last bit of speed out of some code. While the overhead of a function call is usually negligible, it can become significant if the function is called many, many times per loop - especially if said function takes a bucket load of params, as they'll have to be pushed on the stack every call. <br><br></td></tr></table><br>
<a name="826603"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure how useful it would be to your own program, but you could consider creating a lookup table of precalculated or reused results.<br><br>For example, it seems you are making some kind of space game. If the stars do not move during a period of time then instead of calculating their distance every time you need a calculation, store the distances in a table.<br><br>Each star might have to have its own table with calculated distances to the other stars. This will use up more memory, but looking up a value in a table is much quicker than calculating it. If the stars move, simply update the value in the tables and use that from now on.<br><br>Be warned, if you are using a large number of stars or other objects the memory usage can become prohibitively large as each new object requires a new entry in every other objects' table. <br><br></td></tr></table><br>
<a name="826729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmmh, this shifted grid collision system seems like perfect for me. hmmmmmmh.<br><br>[reads up on it to understand how it works] <br><br></td></tr></table><br>
<a name="827321"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> In my limited blitzmax experience the bottleneck, if there is one, is usally GPU related not CPU related. <br><br></td></tr></table><br>
<a name="827327"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh? To me, I can't see how simply drawing 100 sprites on the screen can ever compare to having a full 3D world with anti-aliasing and light that is reflected of metal, and all that stuff.<br><br>Or am I completely in the wrong here? <br><br></td></tr></table><br>
<a name="827350"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Or am I completely in the wrong here?  <br></div><br><br>You are not wrong but you seem to be asking the wrong question again.<br><br><div class="quote"> simply drawing 100 sprites on the screen  <br></div><br>It is no problem to draw &gt;1000 sprites on the screen so its odd you are having problems with 100. This goes back to the earlier suggestion that something else could be optimised rather than the overhead in calling methods. <br><br></td></tr></table><br>
<a name="827351"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> tonyg, you got it all wrong &gt;&gt;<br><br>The reason my game runs slow is because of all the math, collisions and magnetism and such. I never really talked about any slowdown because of sprites.<br><br>My post, when talking about 100 sprites, was a reply to the post above, were JGOware said that the bottleneck could be GPU instead of CPU related. <br><br></td></tr></table><br>
<a name="827360"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> ... and, I believe, JGOware was stating that you're more likely to get a performance issue transferring data to the GPU than using the CPU.<br>With that in mind :<br>Have you timed your code without drawing anything?<br>What is the difference between the maths+draw vs the draw? Simply time your update logic and not your draw logic.<br>.<br>Another point,  you haven't given much to go on so people are guessing things that might help. <br>Your original question concerned the overhead for calling functions/methods (even 1000's of times). A quick test on my machine suggested using methods adds 1ms per 10000 calls.<br>I understand the argument that every ms counts but I doubt that will make a slow framerate into an acceptable framerate. <br><br></td></tr></table><br>
<a name="827363"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Think you will have to post (partially) the code of your collision-checks... <br><br>a) to see which objects are checked against (and how many)<br>b) how you check.<br><br>Checking 500 Objects for collision against each other (unregular) can be a frame-cutter. May be you have an unrecognized bottleneck there.<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="827373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, I think we have a pretty big missunderstanding here. When I coded the game, I pretty much saw what was slowing down the most. So, I already knew this.<br><br>However, I wasn't sure on optimizing much, so I made this topic to clear up a few questions I had. I've gotten good responses, and I'm now in the proccess of unlagging my game based on this. There is no need to guess on what things might help, since I've already gotten help.<br><br>But, since you asked, I'll supply my collision code:<br><pre class=code>
  Method ObjectsCollide(Object1:TObject, Object2:TObject)
    Local CollisionDistance:Float = (((Object1.XSize + Object1.YSize) / 2) / 2) + (((Object2.XSize + Object2.YSize) / 2) / 2)
    Local CurrentDistance:Float = DistanceBetweenPoints(Object1.XPosition,Object1.YPosition,Object2.XPosition,Object2.YPosition)
      If CollisionDistance &gt; CurrentDistance
        Local CollisionAngle:Float = ATan2(Object2.YPosition-Object1.YPosition, Object2.XPosition-Object1.XPosition)
        Local moveDist1:Float = (CollisionDistance-CurrentDistance)*(Object2.Weight/Float((Object1.Weight+Object2.Weight)))
        Local moveDist2:Float = (CollisionDistance-CurrentDistance)*(Object1.Weight/Float((Object1.Weight+Object2.Weight)))
        Object1.XPosition = Object1.XPosition + moveDist1*Cos(CollisionAngle+180)
        Object1.YPosition = Object1.YPosition + moveDist1*Sin(CollisionAngle+180)
        Object2.XPosition = Object2.XPosition + moveDist2*Cos(CollisionAngle)
        Object2.YPosition = Object2.YPosition + moveDist2*Sin(CollisionAngle)
        Local nX:Float = Cos(CollisionAngle)
        Local nY:Float = Sin(CollisionAngle)
        Local a1:Float = Object1.XSpeed*nX + Object1.YSpeed*nY
        Local a2:Float = Object2.XSpeed*nX + Object2.YSpeed*nY
        Local optimisedP:Float = (2.0 * (a1-a2)) / (Object1.Weight + Object2.Weight)
        Object1.XSpeed = Object1.XSpeed - (optimisedP*Object2.Weight*nX)
        Object1.YSpeed = Object1.YSpeed - (optimisedP*Object2.Weight*nY)
        Object2.XSpeed = Object2.XSpeed + (optimisedP*Object1.Weight*nX)
        Object2.YSpeed = Object2.YSpeed + (optimisedP*Object1.Weight*nY)
    End If
  End Method
</pre><br><br>notes: this is only part of the code. I've not included the code for the functions like DistanceBetweenPoints() since I think you guys can figure out what that means ;) <br><br></td></tr></table><br>
<a name="827379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Busy in there, isn't it?<br><br>If you are using Sqr() in DistanceBetweenPoints() that'll slow it down a bit.<br>There's a couple of unnecessary calls to Cos()/Sin() too.<br><br>You may (or may not) find the code less busy if you were to change things like :<br><pre class=code>
Object1.XSpeed = Object1.XSpeed -
</pre><br>to<br><pre class=code>
Object1.XSpeed :-
</pre><br>Not an optimisation.. but it makes it easier to read.<br><br>How many object crashing into each other before you notice it slowing down? <br><br></td></tr></table><br>
<a name="827382"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vilu</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> One way to optimize trigonometry is to create pre-calculated arrays of Sin()/Cos() functions instead of calling Sin()/Cos() every time.<br><br>For example, create a float array called CosValues[360] and prepopulate it with Cosine values for degrees 1 - 360 for quick lookup. The same for Sin(). The drawback of course is the inaccuracy caused by the 1 degree granularity, but the performance is surely worth it. <br><br></td></tr></table><br>
<a name="827388"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Arghh, not the lookup table debate again?! This could muddy the water. :P<br><br>Personally, I don't bother with them these days. Modern processors seem to have pretty much made their use redundant, IMO. <br><br></td></tr></table><br>
<a name="827390"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vilu</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm... I've been using lookup tables for Sin, Cos and Tan for a long time now, and the last time I did a performance test indicated that lookup tables were, in fact, a whole lot faster than calling the functions directly. <br><br>When I get home, I'll run another test on my old laptop and post the results. <br><br></td></tr></table><br>
<a name="827391"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another thing to sum up the code:<br><br><pre class=code>
        Local a1:Float = Object1.XSpeed*nX + Object1.YSpeed*nY
        Local a2:Float = Object2.XSpeed*nX + Object2.YSpeed*nY
        Local optimisedP:Float = (2.0 * (a1-a2)) / (Object1.Weight + Object2.Weight)
</pre><br><br>could be written as:<br><pre class=code>
        Local optimisedP:Float = (2.0 * ((Object1.XSpeed-Object2.XSpeed)*nX  + (Object1.YSpeed - Object2.YSpeed)*nY)) / (Object1.Weight + Object2.Weight)
</pre><br><br>Would be shorter and uses less variables (locals).<br><br>For better readability use bruceys suggestion (x :+ y)<br>and be sure to use "short names" to identify easy things like positions:<br><br>Object1.X (PositionX could also be posX) <br>Object1.vX (velocityX)<br>Object1.mass (Weight is using Gravity, its no fixed value I think)<br>Object1.dX (delta - speed)<br><br>Although its nice to have variables really really declaring their usage itself, some variables have nearly standard name schemes. ... So "current" would become "curr" and "distance" becomes "dist" and so on.<br><br>This makes code-lines way shorter and takes away the frighting of "i better make locals to shorten one line of calculation to have a better overview".<br><br><br>Another thing... are your objects stored as TObject? I see no cast to your object-type: TMyRock(object1)<br><br><br>bye<br>mB <br><br></td></tr></table><br>
<a name="827392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Brucey:<br>Yeah, I've already noticed a few small things I could improve, but generally I find this collision code very fast. I can have several hundred objects collide often without any problems. (but, not combined with everything else in the game, such as magnetism, then it starts to lag. But, I'm making a grid collision system now, like the one big10p had)<br><br>Vilu:<br>Thanks, I shall test if it causes any trouble, and it not, use it. <br><br></td></tr></table><br>
<a name="827393"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> MichaelB:<br>Yeah, you are right, I could shorten a lot of stuff. Would make my life easier too. ^^ (if only there was a replace function over several files at once)<br><br>As for the TObject, it's not here, since I really don't need to show it in addition to the collision code. TObject is simply an abstract type for all my space objects. <br><br></td></tr></table><br>
<a name="827394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> So whats the count ? How many objects may be on screen without delay ... and which count makes it lag (low fps or whatever).<br><br>The function you showed was the one used for ONE collision-check. <br><br>With the grid collision system you still may run into problems (imagine a big rock exploding into 100 rocks - they surely share the same grid for a short while ... making a huge comparison-round needed).<br><br>If all of them have magnetic abilities... you may think about  cutting down redundant checks... if two rocks wont influence through magnetics, they mostly (if you think of magnetics as gravity instead of + and - ) wont collide in this moment.<br>If using + and - and they don't attract, you also wont have to check for collision between both objects.<br><br>So you may search some ways to avoid additional checks (in addition to the grid which separates all objects into a kind of groups).<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="827399"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> With the grid collision system you still may run into problems (imagine a big rock exploding into 100 rocks - they surely share the same grid for a short while ... making a huge comparison-round needed). <br></div>Sure, but it should still be faster than checking every object against every other object. The secret to getting the most out of grid collisions is in tweaking the grid sector size to fit the actual game. <br><br></td></tr></table><br>
<a name="827402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> MichaelB:<br>there generally aren't THAT many objects on the screen at the same time. Because of the scrolling, I have a "object is only updated if it is within 1500 pixels of the player", thus, I am pretty sure I will never have above 250 objects at the same time, and that will only be the very extreme cases. It's on the tip of lagging right now with 250 objects on a relative medicore computer, but I'm sure that with grind collisions and other methods presented to me here, I can reduce the lag away.<br><br>As for magnetism, it can't be put into the grind system. you see, magnetism can have really really long range, so it would cross several grinds. Making the grinds bigger to make up for this would make the optimizing weaker to the point that grinds doesn't help so much anymore.<br><br>Instead, I'm going to make a much simpler and more optimized magnetic formula, that "caches" how it attracts objects, and if their position and weight haven't changed too much, use the cache instead of calculating everything over and over.<br><br>Oh, and no, they don't all have magnetic abilities. Magnets are very rare, usually only one or two at the screen at the same time, so they aren't that big of a problem. <br><br></td></tr></table><br>
<a name="827411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> @big10p:<br><br>wasn't meant as negative aspect of grid systems... you just may have to glue it to other things to make things like exploding rocks work (small pieces excluded from normal grid-comparison ... or so).<br><br>In a short test I compared a list of 150 objects straight against 150 other objects (circle-collision). It made my old 1,7GHz Athlon laggy.<br>So 250 objects... may be a bit more work ;D.<br><br>Hope the grid helps.<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="827417"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vilu</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just did the Sin() lookup table performance comparison by generating 10 million random values:<br><br><pre class=code>
SuperStrict

' Create and populate the sin array
Local SinValues:Float[360] 
For Local i:Int = 0 To 359
	SinValues[i] = Sin(i) 
Next

' Lookup table performance
Local start:Int = MilliSecs() 
For Local i:Int = 1 To 10000000
	Local Sin:Float = SinValues[Rnd(0, 359)] 
Next
Print "Lookup table time: " + (MilliSecs() - start) 

' Sin call performance
start:Int = MilliSecs() 
For Local i:Int = 1 To 10000000
	Local Sin:Float = Sin(Rnd(0, 359)) 
Next
Print "Sin() call time: " + (MilliSecs() - start) 
</pre><br><br>I got 4600ms for lookup table time and 5140ms for Sin() call time using a 1.5GHz ThinkPad. The difference is quite small but is it negligible?<br><br>@Drakim:<br>A bit off-topic but anyway: As you can see above, array referencing works with floats and doubles as well (Rnd() returns a double), but it rounds it up to the next largest integer. That is, arrayname[342.11] and arrayname[342.99] are both equivalent to arrayname[343]. So you'll lose precision here as well unless you do a proper rounding of the lookup value. <br><br></td></tr></table><br>
<a name="827419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
SuperStrict

' Create and populate the sin array
Global SinValues:Float[360] 
For Local i:Int = 0 To 359
	SinValues[i] = Sin(i) 
Next

Local degree:Int =0
' Lookup table performance
Global start:Int 
start = MilliSecs() 
For Local i:Int = 1 To 10000000
	Local Sin:Float = SinValues[degree] 
	degree:+1
	If degree &gt; 360 Then degree = 0
Next
Print "Lookup table time: " + (MilliSecs() - start) 

' Sin call performance
degree=0
start:Int = MilliSecs() 
For Local i:Int = 1 To 10000000
'	Local Sin:Float = Sin(Rnd(0, 10)) 
	Local Sin:Float = Sin(degree) 
	degree:+1
	If degree &gt; 360 Then degree = 0
Next
Print "Sin() call time: " + (MilliSecs() - start) 


'rnd call performance
start:Int = MilliSecs() 
For Local i:Int = 1 To 10000000
	Local MyRND:Float = Rnd(0, 359) 
Next
Print "rnd() call time: " + (MilliSecs() - start) 
</pre><br><br>using another method than rnd (or just checking for a fixed value) speeds up the lookup to be a 10th of the time a sin-calculation needs.<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="827420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vilu</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm using Rnd() in both tests so the difference must come from the Sin() usage. <br><br></td></tr></table><br>
<a name="827421"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Edited my post... I know that rnd makes unordered access, you can emulate this by preparing a "randomized" list of 360 numbers from 1 to 360... shuffling them after a certain step.<br><br>May some with knowhow say if it has to do something with stacks or other caches... <br><br>btw the code above gives:<br>Lookup table time: 43<br>Sin() call time: 921<br>rnd() call time: 1993<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="827433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd be interested to know how you calculate magnetism in your game. Perhaps this could be causing slowdown? <br><br></td></tr></table><br>
<a name="827436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> meh, sure, but as I said earlier, I am going to remake this to have a cache system, so this is outdated. But hints and tips are still wanted :)<br><br><pre class=code>
  Method ObjectsMagnet(Object1:TObject,Object2:TObject)
    Local Distance:Float = DistanceBetweenPoints(Object1.XPosition, Object1.YPosition, Object2.XPosition, Object2.YPosition)
    If Distance &lt; Object2.MagnetRange
      Local CollisionDistance:Float = (((Object1.XSize + Object1.YSize) / 2) / 2) + (((Object2.XSize + Object2.YSize) / 2) / 2)
      If Distance &gt; CollisionDistance * 1.1
        Local PercentPowerModifier:Float = ((Distance / Object2.MagnetRange) - 1) * (-1)
        If PercentPowerModifier &gt; 0.5 Then PercentPowerModifier = 0.5
        Local AngleNegative:Int = 0
        Local ModifiedPower:Float = Object2.MagnetPower 
        If Object2.MagnetPower &lt; 0
          ModifiedPower :* -1
          AngleNegative = 180
        End If
        Local ModifiedMagnetPowerObject1:Float = PercentPowerModifier * PreventNegative(ModifiedPower - Object1.Weight)
        Local ModifiedMagnetPowerObject2:Float = PercentPowerModifier * PreventNegative(ModifiedPower - Object2.Weight)
        Local Angle:Float = DegreesBetweenPoints(Object1.XPosition, Object1.YPosition, Object2.XPosition, Object2.YPosition)      
        Object1.XSpeed :+ Sin(Angle + AngleNegative) * ModifiedMagnetPowerObject1
        Object1.YSpeed :+ Cos(Angle + AngleNegative) * ModifiedMagnetPowerObject1
        Object2.XSpeed :+ Sin(Angle+180 - AngleNegative) * ModifiedMagnetPowerObject2
        Object2.YSpeed :+ Cos(Angle+180 - AngleNegative) * ModifiedMagnetPowerObject2
      End If
    End If
  End Method
</pre><br><br>notes: this is still an effect in development. You'll see strange things like the line:<br><pre class=code>If Distance &gt; CollisionDistance * 1.1</pre><br>which doesn't make sense just yet. <br><br></td></tr></table><br>
<a name="827437"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >big10p</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure those lookup table tests are particularly valid as they dont represent real world useage of sin/cos. i.e. making a whole bunch of sin calls/lookups inside a loop.<br><br>I'm sketchy of cache functioning in modern CPU's but I think when the first lookup is made, a whole block of data is transferred to the cache (i.e. the entire array), and so, from then on it's simply doing a lookup from cache mem which is bound to be faster. <br><br></td></tr></table><br>
<a name="827451"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Although it's no speed-killer you should avoid things like:<br><pre class=code>
      Local CollisionDistance:Float = (((Object1.XSize + Object1.YSize) / 2) / 2) + (((Object2.XSize + Object2.YSize) / 2) / 2)
</pre><br><br>you could shorten it (and save about 33% of needed calculations):<br><pre class=code>
      Local CollisionDistance:Float = (Object1.XSize + Object1.YSize + Object2.XSize + Object2.YSize) / 4
</pre><br><br>I know that it may just be not optimized for the sake of "not final and just to see if the effect is reached".<br><br>But when you sum up such small improvements, the speed will increase a bit too (especially when the bottleneck seems to be the cpu).<br><br>After you included your grid-methods, try to narrow the lag down using some Profiler-Functions (search the codebase), this will provide some information which may be needful (don't worry about a possible mem-leak, coz every call is logged, the mem usage increases slightly).<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="827617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> What I mean is, do all magnetic objects update their magnetism to each other every cycle? If you have a lot of magnetic objects, that must be many calls. <br><br></td></tr></table><br>
<a name="827663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> update their magnetism for each other every cycle? I'm not sure what you mean but, this is how it works:<br><br>Every frame, the magnets applies a X speed on all metal based objects in it's magnetic range Y in the direction of the magnet.<br><br>Magnets however isn't such a big problem, mostly because I already had a few tricks of optimizing ready, and that there is almost never more than 3 magnets alive at the same time. <br><br></td></tr></table><br>
<a name="827838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> There, here is my new collide code:<br><br><pre class=code>
  Method ObjectsCollide(Object1:TObject, Object2:TObject)
    Local CollisionDistance:Float = (Object1.XSize + Object1.YSize + Object2.XSize + Object2.YSize) / 4
    Local CurrentDistance:Float = DistanceBetweenPoints(Object1.XPos,Object1.YPos,Object2.XPos,Object2.YPos)
      If CollisionDistance &gt; CurrentDistance
        Local CollisionAngle:Float = ATan2(Object2.YPos-Object1.YPos, Object2.XPos-Object1.XPos)
        Local moveDist1:Float = (CollisionDistance-CurrentDistance)*(Object2.Weight/Float(Object1.Weight+Object2.Weight))
        Local moveDist2:Float = (CollisionDistance-CurrentDistance)*(Object1.Weight/Float(Object1.Weight+Object2.Weight))
        Object1.XPos = Object1.XPos + moveDist1*CacheTable.GetCos(PreventInvalidAngle(CollisionAngle+180))
        Object1.YPos = Object1.YPos + moveDist1*CacheTable.GetSin(PreventInvalidAngle(CollisionAngle+180))
        Object2.XPos = Object2.XPos + moveDist2*CacheTable.GetCos(PreventInvalidAngle(CollisionAngle))
        Object2.YPos = Object2.YPos + moveDist2*CacheTable.GetSin(PreventInvalidAngle(CollisionAngle))
        Local nX:Float = CacheTable.GetCos(PreventInvalidAngle(CollisionAngle))
        Local nY:Float = CacheTable.GetSin(PreventInvalidAngle(CollisionAngle))
        Local OptimisedP:Float = (2.0*((Object1.XSpeed*nX+Object1.YSpeed*nY)-(Object2.XSpeed*nX+Object2.YSpeed*nY)))/(Object1.Weight+Object2.Weight)
        Object1.XSpeed :- (OptimisedP*Object2.Weight*nX)
        Object1.YSpeed :- (OptimisedP*Object2.Weight*nY)
        Object2.XSpeed :+ (OptimisedP*Object1.Weight*nX)
        Object2.YSpeed :+ (OptimisedP*Object1.Weight*nY)
    End If
  End Method
</pre><br><br>It runs quite nicely, and I've been able to have up to 600 objects and still have about 60 fps (about 1.35 delta), which isn't a problem at all. I think especially the lookup tables did the trick.<br><br>But, a quick question. How am I to apply damage to the objects that collide? I can't for my life find out how to extract the force out of this formula. Any help? <br><br></td></tr></table><br>
<a name="827842"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LarsG</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> One way of doing it it is to add together the velocity of the two objects which collided.<br>The total combined velocity should give you some idea of what damage it would make. <br><br></td></tr></table><br>
<a name="827843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> ah, but how do I get the velocity?<br><br>The movement of the objects are determined by an XSpeed and YSpeed, which can be both negative and positive (depending on what way you go). So how would I get the velocity out of these two variables?<br><br>For example, if an object moves up and right, it might have the speed:<br>XSpeed = 9<br>YSpeed = -4<br><br>How would I get the real velocity out of this? <br><br></td></tr></table><br>
<a name="827846"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LarsG</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can just use that speed variable as your velocity.<br><br>I'm sure there are a few guys here who might have a nice math formula to do this.<br>If not, I think you might have to do some "clever" checking to see what damage might be, depending on if they travel in the "same" direction, or if they are colliding head to head.. <br><br></td></tr></table><br>
<a name="827847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't make this "clever" math &gt;&lt;, I tried three different ways, but they all had major gaps and faults. Could anyone help me?<br><br>Oh, another optimizing question (which is kinda the real topic at hand)<br><br>My objects are now starting to get really really many fields, around 20 or so. All fields vary for the different objects upon creation, thus, my creation function takes almost 20 parameters now. It's a messy thing.<br><br>However, I've also heard that parameters is a bit of a slowdown. Is this true? And if so, is there a cleaner better way to do things?<br><br>In JavaScript, I could create objects in a way that allowed me to only specify the parameters I wanted, and the unspecified would get their default value. Is this possible in BlitzMax? <br><br></td></tr></table><br>
<a name="827849"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> What is xspeed measured in? Pixels per sec? Pixels per cycle? It is better to do your direction stuff in vectors . There are some good vector math libs in the Code Archives. I found <a href="http://www.bettiesart.com/tc/blitz/index.html" target="_blank"> this </a> useful in Blitzbasic days.<br>As for objects, I try and limit them to about 7-10 attributes. After that I create sub-types. <br>I haven't noticed any slowdown but I am not doing intensive collision tests. From what I have seen in your project I would first make working code that is readable (at the moment it is like having a pencil jabbed in my eye) and then optimise later. Having said that some people swear by the 'optimise from the start' approach.<br>You can set default values in Bmax either by <br>a) setting it in the field statement :<br>    field name:string="Bob"<br>or<br>b) within the function calls.<br>    function create(name:string="Bob") <br><br></td></tr></table><br>
<a name="827855"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> tonyg:<br>I thought vectors was a lot heavier to calculate, and because my game will have lots of objects with lots of constant movement, I thought of it as a straight ahead dead end. Am I wrong?<br><br>When it comes to the objects, I really need that many attributes for various things in my game. I can't divide into sub-types anymore because they are already divided into so many subtypes.<br>(unless I start making types like "rock1", "rock2" and "rock3" etc, instead of having a size field from 1 to 20. But I'm not willing to destroy my remaining humanity in order to avoid some parameters.)<br><br>As for optimizing, I must optimize from the start. It's just how I work, sorry. ^^, But I won't do the insane optimizing such as not using functions to avoid calls. After some testing I found that it's not near worth it in any way.<br><br>And I can't agree with you that the code hurts my eyes. It may be bias from writing it, but it's clear and nice for me :D<br><br>Lastly, the parameters. Even if I put default values in the fields, I still have to supply all the parameters right? Thus, if I want the possibility to use all parameters, I have to use it every time after all. I JavaScript, you could skip parameters in order to let the default apply instead. <br><br></td></tr></table><br>
<a name="827859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vectors should be OK as I am sure many people have used them for fast-paced games. There is the source for a 'grid-wars' game which might show how they implemented it. Do a search on these forums/<br>.<br>If you post the object and its fields it will be interesting to get feedback on how others might do the same.<br>Maybe we have misunderstood each other. <br>Your TRock object might have : <br><pre class=code>
field image
field xpos
field ypos
field alpha
field blend
</pre><br>which can all be replaced by <br><pre class=code>
field sprite:TSprite
</pre><br>or a field which points to a 'TRock_Attrib' object. This sub-object contains size, damage, TColor etc. <br>.<br>I understand the optimise first approach but, personally, find myself testing more and more bizarre solutions which complicate matters.<br>.<br>It is difficult to comment on the readability of other people's code. e.g.  I would have<br><pre class=code>        Object1.xpos=etcetcetc </pre><br>replaced by <br><pre class=code>        Object1.updatepos() </pre><br>but that's probably a personal thing.<br>.<br>If you put params in the fields you can leave the function call blank :<br><pre class=code>
type TRock
   field size:int
   field color_red:int
   function create(red:int,size:int=4)
   end function
end type
local myrock:trock=trock.create(255)
print myrock.size
</pre> <br><br></td></tr></table><br>
<a name="827901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> But, let's say you want to specify what size that TRock is going to have, but I want to leave the color_red field to it's default, is that possible?<br><br>Because, you simply skipped the last parameter, since you have a default for that. However, how do you skip the parameters that aren't last? <br><br></td></tr></table><br>
<a name="827943"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
Type TRock
   Field size:Int
   Field color_red:Int
   Field color_green:Int
   Field color_blue:Int=10
   Function Create:trock(red:Int,green:Int=255,size:Int=4)
		Local temp:trock=New trock
		temp.size=size
		temp.color_red=red
		temp.color_green=green
		Return temp
   End Function
End Type
Local myrock:trock=trock.Create(255,,3)
Print myrock.size
Print myrock.color_red
Print myrock.color_green
Print myrock.color_blue
</pre><br>I don't think you can skip the first parm <br><br></td></tr></table><br>
<a name="827944"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LarsG</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can't, as far as I know.. <br><br></td></tr></table><br>
<a name="828008"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I don't think you can skip the first parm <br></div><br>Of course you can, as long as you give it a default :-)<br><div class="quote"> <br>Function abc(a:Int = 5, b:Int = 1, c:Int = 2)<br>	Print a<br>	Print b<br>	Print c<br>End Function<br><br>abc(,2)<br>abc(,6,3)<br>abc()<br> <br></div> <br><br></td></tr></table><br>
<a name="828026"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> Optimizing code is always good, but I've coded demos with hundreds of sprites moving around, and the frame rate stays at the 50-100 fps mark, even on lower end machines. And my code is extremly high level, hardly any optimizing on the code end. But I did focus on techniques to improve graphic drawing. Some obvious considerations:<br><br>16bit is still faster than 32bit in every test I've performed.<br>Use lower res (640x480, 800x600) for fast action games. I still see BMax coders making their games run in high resolutions and they stutter on older machines.<br>Instead of drawing lots of smaller tiles (16x16,32x32, etc) draw 128x128 or larger tiles. The less you draw every loop the faster it will be. <br><br></td></tr></table><br>
<a name="828059"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Brucey, yes. you are right. I can only believe I hit a different problem when I tried it and assumed it was the missing parm. <br><br></td></tr></table><br>
<a name="828064"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> To the "how much damage" thing:<br><br>To calculate the "velocity" you need to 4 Points (Point = x,y)<br>Obj1.OldPosition, Obj1.NewPosition<br>Obj2.OldPosition, Obj2.NewPosition<br><br>OldPosition = X,Y<br>NewPosition = X+dx, Y+dy<br><br>Having 4 Points you can calculate the angle between the 2 Lines:<br>Line1(Obj1.OldPosition, Obj1.NewPosition)<br>Line2(Obj2.OldPosition, Obj2.NewPosition)<br><br>The one with "Mass*LineLength" bigger than the other object is the "winner" of a collision (more force, cinectic energy mass/2 * speed^2)<br><br>Now you have a energy (cinectic energy) connected to a direction (Line1 and Line2).<br><br>The bigger "energyline" (linelength * mass) will be the hypothenuse the other is mostly the ankathede (dunno if its the same in english).<br><br><br>cos(energylineSmall / energylineBig) = angle of power the objects hit together with. <br><br>The smaller the angle the bigger the impact (like a train colliding into another train driving into the straight opposite direction,  compared to a car crashing into another on the crossroad).<br><br>If the Angle is near 180 then Object1 moves faster than Object2 (on the same movement-path) and hitting it will do a ForceDamage of Force1-Force2).<br><br>Assume Object1 has very less Force than Object2, then damage done to Object1 is (Force2 - Force1). Object2 would have a damage done of Force1.<br><br><br>With the collision angle and the damage (forces) you can additionally calculate the new direction the objects take.<br><br><br><br>Before I write too much without bringing some effort into it (for you).<br>This was just a bit of brain-smashing to give some ideas.<br><br><br>To add some kind of summary:<br>Damage done is force*angle of collision.<br>Force is mass/2 * speed^2 (E_cinetic).<br>New direction of movement is angle of collision (0-100%) * PathObject1 + (100%-angle of collision)*PathObject2).<br><br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="828490"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> MichaelB:<br>This is a bit over my head, so I need to read over it carefully and test it, but some quick questions for it:<br><br>If object1 travels to the north at 90 speed, and object2, which is behind object1, travels at 95 speed, it should eventinally catch up.<br><br>However, due to the way they travel (the same way and almost the same speed), there should really be almost no damage, despite that object2 holds the high speed of 95, simply because object1 holds almost the same speed, "canceling out" 90 of the 95 speed, thus only making the impact one of 5 speed (really simple terms).<br><br>Any system I've made does not take this into account. for me, as object2 reaches object1, it would deal massive damage at it, despite that it would be a lot more realistic if almost no damage was dealt.<br><br>How will your system react to that situation? <br><br></td></tr></table><br>
<a name="828527"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> the damage dealt in this situation is:<br>(check internet for "impulse" or cinetic energy)<br><br>Object1.Energy = Object1.Mass / 2 * Object1.speed^2<br>Object2.Energy = Object2.Mass / 2 * Object2.speed^2<br><br>To simplify the damage calculation you would say that the difference of the objects energies is the damage done.<br><br>If you are not satisfied with this you will have to take the angle of collision and then multiply the difference of energies with a factor from 0 to 1.0 (depending on angle).<br><br>To make it a bit more realistic you could decrease the energy of the objects about the difference:<br><br>local backupenergy:int=Object1.energy<br>Object1.energy = Object1.energy - Object2.energy<br>Object2.energy = Object2.energy - backupenergy<br><br>If one of the objects has its energy below 0, its destroyed<br>The survivor of the crash has eventually lost a bit of its mass (size) and/or speed (remember mass/2 * speed^2 = energy).<br><br><br>The result of this is, if a really huuuge, heavy and/or fast object crashs into a smaller/slower one, the last is destroyed and "big boss" is still alive (but he wont care for the loss of a bit energy).<br><br><br>This brings another idea in the game: they can "melt" together... loosing a bit of energy while crashing (they loose some mass) but afterwards they got heavy and strong.<br><br><br>Hope this helps,<br><br>bye<br>MB <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
