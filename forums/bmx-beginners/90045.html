<!DOCTYPE html><html lang="en" ><head ><title >WindowBox Scrolling Help.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >WindowBox Scrolling Help.</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >WindowBox Scrolling Help.</a><br><br>
<a name="1023347"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok.  Below is the code for a basic windowbox that I'm working on.  It's far from complete, but I've ran into a snag already.  If you run the code as is, it will print in the windowbox fine, except it's not printing out the last line of the last command if the window is full....  I've been messing with this for three hours, so I think I've probably just over thunk the problem.  If anyone can help, I'd appreciated it.<br><br><pre class=code>
Strict
Graphics 800,600,0,60

Local mywindow:windowbox=WindowBox.Create()
mywindow.setwindowfont("c:\windows\fonts\consola.ttf",18)
mywindow.setpos(100,200)
mywindow.setsize(20,10)
'mywindow.settexture("text_texture.png")

Cls
SetColor 255,255,255
SetBlend AlphaBlend

mywindow.show()
mywindow.CurX=0
mywindow.CurY=0
mywindow.printwrap("Hello.")
Flip
Delay(100)
mywindow.printwrap("This is a test of something.")
Flip
Delay(100)
mywindow.printwrap("And something is nothing, but the nothing is something in the morning.")
Flip
Delay(100)
mywindow.printwrap("Then the mountains came crashing to the shore.")
Flip
Delay(100)
mywindow.printwrap("Sometimes when the clocks stop, the world stops with them.")
Flip
'Delay(100)
'mywindow.printwrap("Even more printing that is fun.")
'Flip
'Delay(100)
'mywindow.printwrap("And more printing.")
'Flip
'Delay(100)
'mywindow.printwrap("Things are not funny in the morning.")
'Flip

Repeat
Until KeyDown(KEY_ESCAPE) Or AppTerminate()

Type WindowBox
	'Global WindowBoxList:TList = New TList
	
	Field Font_Name:String
	Field Font_Size:Int
	Field FontMaxWidth:Int
	Field FontMaxHeight:Int
	Field ScreenWidth:Int
	Field ScreenHeight:Int
	Field WindowXPos:Int
	Field WindowYPos:Int
	Field WindowWidth:Int
	Field WindowHeight:Int
	Field TexturePath:String
	Field TextureImage:TImage = New TImage
	Field CurX:Int
	Field CurY:Int
	Field TextLines:String[100]
	Field CurTextLine:Int
	Field CurTopLine:Int
	
	Function Create:WindowBox()
		Local w:WindowBox = New WindowBox
		w.SetWindowFont(Null,8)
		w.ScreenWidth=GraphicsWidth()
		w.ScreenHeight=GraphicsHeight()
		w.SetPos(0,0)
		w.SetSize(10,10)
		w.CurX=0
		w.CurY=0
		For Local i:Int=0 To 99
			w.TextLines[i]=""
		Next
		w.CurTextLine=0
		w.CurTopLine=0
		
'		WindowBoxList.addlast(w:WindowBox)
		Return w:WindowBox
	End Function

	Method SetWindowFont(Font_Namex:String,Font_Sizex:Int)
		Local font:timagefont=LoadImageFont(font_namex,font_sizex,SMOOTHFONT)
		SetImageFont(font)
		Font_Name=Font_Namex
		Font_Size=Font_Sizex
		FontMaxWidth=TextWidth(Chr(0))
		FontMaxHeight=TextHeight(Chr(0))
		For Local i:Int=1 To 255
			If TextWidth(Chr(i))&gt;FontMaxWidth Then FontMaxWidth=TextWidth(Chr(i))
			If TextHeight(Chr(i))&gt;FontMaxHeight Then FontMaxHeight=TextWidth(Chr(i))
		Next
	End Method
	
	Method SetPos(xpos:Int, ypos:Int)
		WindowXPos=xpos
		windowYPos=ypos
	End Method
	
	Method SetSize(xsize:Int, ysize:Int)
		WindowWidth=xsize
		WindowHeight=ysize
	End Method
	
	Method DrawBorder()
		SetColor 255,255,255
		Local x:Int=WindowXPos
		Local x1:Int=WindowXPos+(WindowWidth*FontMaxWidth)+FontMaxWidth
		Local y:Int=WindowYPos
		Local y1:Int=WindowYPos+(WindowHeight*FontMaxHeight)
		
		DrawLine(x-5,y-5,x1+5,y-5)
		DrawLine(x-5,y-5,x-5,y1+5)
		DrawLine(x1+5,y-5,x1+5,y1+5)
		DrawLine(x-5,y1+5,x1+5,y1+5)
	End Method
			
	Method Show()
		Local x1:Int=(WindowWidth*(FontMaxWidth))
		Local y1:Int=(WindowHeight*(FontMaxHeight))
		DrawBorder()
		'DrawImageRect(TextureImage,WindowXPos,WindowYPos,x1,y1)
	End Method
	
	Method SetTexture(TexturePathx:String)
		TextureImage = LoadImage(TexturePathx)
	End Method
	
	Method PrintWrap(Text:String)
		Local words:String[]
		Local soffx:Int=WindowXPos
		Local soffy:Int=WindowYPos
		
		words=Text.split(Chr(32))
		For Local t:String=EachIn words
			If Len(t)&lt;WindowWidth-CurX Then
				TextLines[CurTextLine]=TextLines[CurTextLine]+t
			Else
				CurX=0
				CurY=CurY+1
				If CurY &gt; WindowHeight Then
					CurTopLine=CurTopLine+1
				EndIf
				CurTextLine=CurTextLine+1
				TextLines[CurTextLine]=TextLines[CurTextLine]+t
			End If
			If Instr(".?!",Right(t,1))&lt;&gt;0 Then
				CurX=CurX+Len(t)+2
				TextLines[CurTextLine]=TextLines[CurTextLine]+"  "
			Else
				CurX=CurX+Len(t)+1
				TextLines[CurTextLine]=TextLines[CurTextLine]+" "
			EndIf

			If CurX &gt; WindowWidth Then
				CurX=0
				CurY=CurY+1
				If CurY &gt; WindowHeight Then
					CurTopLine=CurTopLine+1
				EndIf
				CurTextLine=CurTextLine+1
			EndIf			
		Next
		SetColor 0,0,0
		DrawRect(WindowXPos,WindowYPos,WindowWidth*FontMaxWidth,(WindowHeight)*FontMaxHeight)
		SetColor 255,255,255
		For Local i:Int=CurTopLine To WindowHeight+CurTopLine-1
			DrawText(TextLines[i],soffx+FontMaxWidth,soffy+((i-CurTopLine)*FontMaxHeight))
		Next
	End Method
	 
End Type
</pre><br><br>Thanks :D <br><br></td></tr></table><br>
<a name="1023356"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> you owe me five dollars for five minutes of my time.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Graphics 800,600,0,60

Local mywindow:windowbox=WindowBox.Create()
mywindow.setwindowfont("c:\windows\fonts\consola.ttf",18)
mywindow.setpos(100,200)
mywindow.setsize(20,10)
'mywindow.settexture("text_texture.png")

Cls
SetColor 255,255,255
SetBlend AlphaBlend

mywindow.show()
mywindow.CurX=0
mywindow.CurY=0
mywindow.printwrap("Hello.")
Flip
Delay(100)
mywindow.printwrap("This is a test of something.")
Flip
Delay(100)
mywindow.printwrap("And something is nothing, but the nothing is something in the morning.")
Flip
Delay(100)
mywindow.printwrap("Then the mountains came crashing To the shore.")
Flip
Delay(100)
mywindow.printwrap("Sometimes when the clocks stop, the world stops with them.")
Flip
'Delay(100)
'mywindow.printwrap("Even more printing that is fun.")
'Flip
'Delay(100)
'mywindow.printwrap("And more printing.")
'Flip
'Delay(100)
'mywindow.printwrap("Things are not funny in the morning.")
'Flip

Repeat
Until KeyDown(KEY_ESCAPE) Or AppTerminate()

Type WindowBox
	'Global WindowBoxList:TList = New TList
	
	Field Font_Name:String
	Field Font_Size:Int
	Field FontMaxWidth:Int
	Field FontMaxHeight:Int
	Field ScreenWidth:Int
	Field ScreenHeight:Int
	Field WindowXPos:Int
	Field WindowYPos:Int
	Field WindowWidth:Int
	Field WindowHeight:Int
	Field TexturePath:String
	Field TextureImage:TImage = New TImage
	Field CurX:Int
	Field CurY:Int
	Field TextLines:String[100]
	Field CurTextLine:Int
	Field CurTopLine:Int
	
	Function Create:WindowBox()
		Local w:WindowBox = New WindowBox
		w.SetWindowFont(Null,8)
		w.ScreenWidth=GraphicsWidth()
		w.ScreenHeight=GraphicsHeight()
		w.SetPos(0,0)
		w.SetSize(10,10)
		w.CurX=0
		w.CurY=0
		For Local i:Int=0 To 99
			w.TextLines[i]=""
		Next
		w.CurTextLine=0
		w.CurTopLine=0
		
'		WindowBoxList.addlast(w:WindowBox)
		Return w:WindowBox
	End Function

	Method SetWindowFont(Font_Namex:String,Font_Sizex:Int)
		Local font:timagefont=LoadImageFont(font_namex,font_sizex,SMOOTHFONT)
		SetImageFont(font)
		Font_Name=Font_Namex
		Font_Size=Font_Sizex
		FontMaxWidth=TextWidth(Chr(0))
		FontMaxHeight=TextHeight(Chr(0))
		For Local i:Int=1 To 255
			If TextWidth(Chr(i))&gt;FontMaxWidth Then FontMaxWidth=TextWidth(Chr(i))
			If TextHeight(Chr(i))&gt;FontMaxHeight Then FontMaxHeight=TextWidth(Chr(i))
		Next
	End Method
	
	Method SetPos(xpos:Int, ypos:Int)
		WindowXPos=xpos
		windowYPos=ypos
	End Method
	
	Method SetSize(xsize:Int, ysize:Int)
		WindowWidth=xsize
		WindowHeight=ysize
	End Method
	
	Method DrawBorder()
		SetColor 255,255,255
		Local x:Int=WindowXPos
		Local x1:Int=WindowXPos+(WindowWidth*FontMaxWidth)+FontMaxWidth
		Local y:Int=WindowYPos
		Local y1:Int=WindowYPos+(WindowHeight*FontMaxHeight)
		
		DrawLine(x-5,y-5,x1+5,y-5)
		DrawLine(x-5,y-5,x-5,y1+5)
		DrawLine(x1+5,y-5,x1+5,y1+5)
		DrawLine(x-5,y1+5,x1+5,y1+5)
	End Method
			
	Method Show()
		Local x1:Int=(WindowWidth*(FontMaxWidth))
		Local y1:Int=(WindowHeight*(FontMaxHeight))
		DrawBorder()
		'DrawImageRect(TextureImage,WindowXPos,WindowYPos,x1,y1)
	End Method
	
	Method SetTexture(TexturePathx:String)
		TextureImage = LoadImage(TexturePathx)
	End Method
	
	Method PrintWrap(Text:String)
		Local words:String[]
		Local soffx:Int=WindowXPos
		Local soffy:Int=WindowYPos
		
		words=Text.split(Chr(32))
		For Local t:String=EachIn words
			If Len(t)&lt;WindowWidth-CurX Then
				If CurX = 0 Then CurY=CurY+1 ' ******************************************************************
				TextLines[CurTextLine]=TextLines[CurTextLine]+t
			Else
				CurX=0
				CurY=CurY+1
				If CurY &gt; WindowHeight Then
					CurTopLine=CurTopLine+1
				EndIf
				CurTextLine=CurTextLine+1
				TextLines[CurTextLine]=TextLines[CurTextLine]+t
			End If
			If Instr(".?!",Right(t,1))&lt;&gt;0 Then
				CurX=CurX+Len(t)+2
				TextLines[CurTextLine]=TextLines[CurTextLine]+"  "
			Else
				CurX=CurX+Len(t)+1
				TextLines[CurTextLine]=TextLines[CurTextLine]+" "
			EndIf

			If CurX &gt; WindowWidth Then
				CurX=0
				CurY=CurY+1
				If CurY &gt; WindowHeight Then
					CurTopLine=CurTopLine+1
				EndIf
				CurTextLine=CurTextLine+1
			EndIf			
		Next
		SetColor 0,0,0
		DrawRect(WindowXPos,WindowYPos,WindowWidth*FontMaxWidth,(WindowHeight)*FontMaxHeight)
		SetColor 255,255,255
		For Local i:Int=CurTopLine To WindowHeight+CurTopLine-1
			DrawText(TextLines[i],soffx+FontMaxWidth,soffy+((i-CurTopLine)*FontMaxHeight))
		Next
	End Method
	 
End Type
</textarea> <br><br></td></tr></table><br>
<a name="1023413"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doh!<br><br>Thanks!  I was sure I had been looking at that code for too long.<br><br>Your fix is perfect!<br><br>:D <br><br></td></tr></table><br>
<a name="1023465"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm... I have dug myself into a corner by sheer lack of planning.  This routine works perfectly (Now with Jesse's help.  I guess I still owe him that $5 bucks.)   I even added the ability to add ~n (returns) to the output.<br><br>The problem:  Because of the way I elected to do the actual printing, and scrolling of the text, I am now having a heck of a time adding color codes.   Oops.  The original method for printing was (I thought), slick and to the point.<br><br>Guess it's back to the drawing board. Ho, Hum. :(<br><br>I've only seen one actual module that does most of what I want to accomplish, libtcod, but even that didn't handle scrolling the text in the window when it filled up.  I've seen no other code that allows for automatic scrolling when the text reaches the bottom of the window.  I would have loved to use libtcod, but it is unfinished, and buggy as hell, and doesn't allow the use of standard fonts without jumping through hoops.<br><br>Any suggestions on doing this more effectively?  Or has someone already written this type of windowbox routine for BMax, and I just didn't find it in the code archives?<br><br>Thanks. :D <br><br></td></tr></table><br>
<a name="1023479"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I hope you have enough money because this info will cost you $10,000. <br>you can easily do it by saving types to the line array instead of saving strings. I have it working. I was going to post it but I think you should try it first. The way I did it is by crating a word type that included a color type I also crated a line type that stores the words in a list. each type store its length in pixels and chars so make it easier to display. and the only type that displays is the the text is the word type. give it your best shot and if you can't figure it out I'll post what I got.<br><br>ROFL.......<br>just so there won't be any misunderstanding, this is about the first sentence. <br><br></td></tr></table><br>
<a name="1023673"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I've changed this up, and it looks nicer, but still needs a lot of polish, and I need to change my actual print routine, it's bollocks and looks ugly if you slow it down.  Plus the code handling is still a bit flaky, but works.  :D<br><br>Again, here is the code I've come up with.  Do NOT use this is a real project because it's crap! ha ha<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Graphics 800,600,0,60

Local mywindow:windowbox=WindowBox.Create()

mywindow.setwindowfont("c:\windows\fonts\consola.ttf",18)
mywindow.setpos(50,50)
mywindow.setsize(20,10)
'mywindow.settexture("text_texture.png")

Cls
SetColor 255,255,255
SetBlend AlphaBlend

mywindow.show()
mywindow.CurX=0
mywindow.CurY=0
mywindow.printwrap("{Yellow}Hello.")
mywindow.printwrap("{White}This is a {Red}test {White}of something.")
mywindow.printwrap("And more testing is in order.")
mywindow.printwrap("Because the {Yellow}National {White}concensis is that I'm more {Red}off {White}than more on.")
mywindow.printwrap("Even more {Red}unbelievable {White}is that this thing might be working.")
Flip

Repeat
Until KeyDown(KEY_ESCAPE) Or AppTerminate()

Type WindowBox
	'Global WindowBoxList:TList = New TList
	Global WinCodes:Codes=New Codes.Create()
		
	Field Font_Name:String
	Field Font_Size:Int
	Field FontMaxWidth:Int
	Field FontMaxHeight:Int
	Field ScreenWidth:Int
	Field ScreenHeight:Int
	Field WindowXPos:Int
	Field WindowYPos:Int
	Field WindowWidth:Int
	Field WindowHeight:Int
	Field TexturePath:String
	Field TextureImage:TImage = New TImage
	Field CurX:Int
	Field CurY:Int
	Field TextLines:TextLine[100]
	Field CurTextLine:Int
	Field CurTopLine:Int
	Field CurRed:Int
	Field CurGreen:Int
	Field CurBlue:Int
	
	Function Create:WindowBox()
		Local w:WindowBox = New WindowBox
		w.SetWindowFont(Null,8)
		w.ScreenWidth=GraphicsWidth()
		w.ScreenHeight=GraphicsHeight()
		w.SetPos(100,100)
		w.SetSize(10,10)
		w.CurX=0
		w.CurY=0
		w.CurRed=255
		w.CurGreen=255
		w.CurBlue=255
		w.CurTextLine=0
		w.CurTopLine=0
		w.TextLines[0]=New TextLine.Create()
'		WindowBoxList.addlast(w:WindowBox)
		Return w:WindowBox
	End Function

	Method SetWindowFont(Font_Namex:String,Font_Sizex:Int)
		Local font:timagefont=LoadImageFont(font_namex,font_sizex,SMOOTHFONT)
		SetImageFont(font)
		Font_Name=Font_Namex
		Font_Size=Font_Sizex
		FontMaxWidth=TextWidth(Chr(0))
		FontMaxHeight=TextHeight(Chr(0))
		For Local i:Int=1 To 255
			If TextWidth(Chr(i))&gt;FontMaxWidth Then FontMaxWidth=TextWidth(Chr(i))
			If TextHeight(Chr(i))&gt;FontMaxHeight Then FontMaxHeight=TextWidth(Chr(i))
		Next
	End Method
	
	Method SetPos(xpos:Int, ypos:Int)
		WindowXPos=xpos
		windowYPos=ypos
	End Method
	
	Method SetSize(xsize:Int, ysize:Int)
		WindowWidth=xsize
		WindowHeight=ysize
	End Method
	
	Method DrawBorder()
		SetColor 255,255,255
		Local x:Int=WindowXPos
		Local x1:Int=WindowXPos+(WindowWidth*FontMaxWidth)+FontMaxWidth
		Local y:Int=WindowYPos
		Local y1:Int=WindowYPos+(WindowHeight*FontMaxHeight)
		
		DrawLine(x-5,y-5,x1+5,y-5)
		DrawLine(x-5,y-5,x-5,y1+5)
		DrawLine(x1+5,y-5,x1+5,y1+5)
		DrawLine(x-5,y1+5,x1+5,y1+5)
	End Method
			
	Method Show()
		Local x1:Int=(WindowWidth*(FontMaxWidth))
		Local y1:Int=(WindowHeight*(FontMaxHeight))
		DrawBorder()
		'DrawImageRect(TextureImage,WindowXPos,WindowYPos,x1,y1)
	End Method
	
	Method SetTexture(TexturePathx:String)
		TextureImage = LoadImage(TexturePathx)
	End Method

	Method SetDefaultColor(Redx:Int,Greenx:Int,Bluex:Int)
		CurRed=Redx
		CurGreen=Greenx
		CurBlue=Bluex
	End Method
	
	Method PrintWrap(Text:String)
		Local words:String[]
		Local Ret:String[]
		Local soffx:Int=WindowXPos
		Local soffy:Int=WindowYPos
		Local codex:String
		Local wordx:String
		Local kcodevalue:Int
		
		words=Text.split(Chr(32))
		
		For Local t:String=EachIn words
			Ret=t.split(Chr(10))
			t=Left(t,Len(t)-(Len(ret)-1))
			If Left(t,1)="{" Then
				Local y:String[]
				y=t.split("{")
				For Local j:String=EachIn y
					Local tt:Int=Instr(j,"}")
					codex=Left(j,tt-1)
					wordx=Mid(j,tt+1)
					kcodevalue=WinCodes.GetCode(codex)
				Next
			Else
				wordx=t
				codex="None"
				kcodevalue=0
			EndIf
			If wordx.length&lt;WindowWidth-CurX Then
				If CurX=0 Then CurY=CurY+1
					TextLines[CurTextLine].AddWord(wordx,wordx.length,codex,kcodevalue)
				Else
					CurX=0
					CurY=CurY+1
					If CurY &gt; WindowHeight Then
						CurTopLine=CurTopLine+1
					EndIf
					CurTextLine=CurTextLine+1
					TextLines[CurTextLine]=New TextLine.Create()
					TextLines[CurTextLine].AddWord(wordx,wordx.length,codex,kcodevalue)
				End If
				CurX=CurX+wordx.length+1
			
				If CurX &gt; WindowWidth Then
					CurX=0
					CurY=CurY+1
					If CurY &gt; WindowHeight Then
						CurTopLine=CurTopLine+1
					EndIf
					CurTextLine=CurTextLine+1
				EndIf			
			
				If Len(Ret)&gt;1 Then
					For Local i:Int=1 To Len(ret)-1
						CurX=0
						CurY=CurY+1
						If CurY &gt; WindowHeight Then
							CurTopLine=CurTopLine+1
						EndIf
						CurTextLine=CurTextLine+1
						TextLines[CurTextLine]=New TextLine.Create()
						TextLines[CurTextLine].AddWord("~n",1,"~n",10)
					Next
				EndIf
		Next
		
		SetColor 0,0,0
		DrawRect(WindowXPos,WindowYPos,WindowWidth*FontMaxWidth,(WindowHeight)*FontMaxHeight)
		SetColor CurRed,CurGreen,CurBlue
		Local i:Int=CurTopLine
		Local xpos:Int
		Local ypos:Int
		While (TextLines[i]&lt;&gt;Null) And (i&lt;=(WindowHeight+CurTopLine-1))
			xpos=0
			ypos=(i-CurTopLine)*FontMaxHeight
			For Local j:Words=EachIn TextLines[i].WordList
				If j.thecodevalue&lt;&gt;0 Then
					WinCodes.codefunc[j.thecodevalue]
				EndIf
				DrawText(j.theword,soffx+xpos,soffy+ypos)
				xpos=xpos+((j.thelength+1)*FontMaxWidth)

			Next
		i=i+1
		Wend
	End Method
	 
End Type

Type Words
	Field theword:String
	Field thecode:String
	Field thecodevalue:Int
	Field thelength:Int
	
	Function Create:Words(thewordx:String,thelengthx:Int,thecodex:String,thecodevaluex:Int)
		Local w:Words=New Words
		w.theword=thewordx
		w.thelength=thelengthx
		w.thecode=thecodex
		w.thecodevalue=thecodevaluex
		Return w
	End Function
End Type

Type TextLine
	Field wordlist:TList=CreateList()

	Function Create:TextLine()
		Local w:Textline=New Textline
		Return w
	End Function
	
	Method AddWord(w:String,l:Int,c:String,v:Int)
			ListAddLast(wordlist,words.Create(w,l,c,v))
	End Method

End Type

Type Codes
	Field codefunc()[]
	
	Function Create:Codes()
		Local w:codes=New codes
		w.codefunc=w.codefunc[..255]
		w.codefunc[0]=w.f0
		w.codefunc[1]=w.f1
		w.codefunc[2]=w.f2
		w.codefunc[3]=w.f3
		w.codefunc[4]=w.f4
		w.codefunc[10]=w.f10
		w.codefunc[32]=w.f32
		Return w:Codes
	End Function
	
	Function f0()
		'Print "None"
	End Function
	
	Function f1()
		'Black
		SetColor 0,0,0
	End Function
	
	Function f2()
		'White
		SetColor 255,255,255
	End Function
	
	Function f3()
		'Yellow
		SetColor 255,255,0
	End Function
	
	Function f4()
		'Red
		SetColor 255,0,0
	End Function
	
	Function f10()
		'Print "chr(10)"
	End Function
	
	Function f32()
		'Print "Space"
	End Function
	
	Method GetCode:Int(x:String)
		Select x
		Case "Black"; Return 1
		Case "White"; Return 2
		Case "Yellow"; Return 3
		Case "Red"; Return 4
		Case "~n"; Return 10
		End Select	
	End Method
End Type

</textarea><br><br>Jesse, I'm sure yours has a lot more panash! :D <br><br></td></tr></table><br>
<a name="1023681"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> To go forward, I think I need to change the print routine to print character by character, insteal of full words.  Then the user could set a print speed and have it print more realistically.  Anyone have any comment on that?<br><br>(Ignore the fact that mine prints the same thing over and over again, as more lines are added... oops...  :D I'm fixing that.)<br><br>As far as the functioning of the {} (codes), I'm really sure this can be better as well.  Currently if you try to do {White}Hello.{Blue} (without a space before the {Blue} it will not work, my sucky parser is broken.<br><br>One last thing:  I've not much experience in actual graphics, but I'm quite sure that when the window is displayed, then hidden, what ever was behind it should be redrawn.  Is a simple image-rect-copy type thing the best approach?  And I haven't even addressed the issue of window depth, it would be nice, I guess, to be able to have multiple windows open and move them around. hmm...  I think I might be getting over my head. :D<br><br>Sorry, I can be a bit dense sometimes.<br><br>Well, back to work. <br><br></td></tr></table><br>
<a name="1023701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> actually a "word" in a sense could be a space or a character.<br><br>well, this is what I did. so you can get an idea:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict
Graphics 800,600,0,60

Local mywindow:windowbox=WindowBox.Create()
mywindow.setwindowfont("c:\windows\fonts\consola.ttf",18)
mywindow.setpos(100,200)
mywindow.setsize(60,10)
'mywindow.settexture("text_texture.png")

Cls
SetColor 255,255,255
SetBlend AlphaBlend

mywindow.show()
mywindow.CurX=0
mywindow.CurY=0
SetColor 255,0,0
mywindow.printwrap("Hello.")
Flip
Delay(100)
SetColor 0,255,0
mywindow.printwrap("This is a test of something.")
Flip
Delay(100)
SetColor 0,0,255
mywindow.printwrap("And something is nothing, but the nothing is something in the morning.")
Flip
Delay(100)
SetColor 255,255,0
mywindow.printwrap("Then the mountains came crashing To the shore.")
Flip
Delay(100)
SetColor 0,255,255
mywindow.printwrap("Sometimes when the clocks stop, the world stops with them.")
Flip
Delay(100)
SetColor 255,0,255
mywindow.printwrap("Even more printing that is fun.")
Flip
'Delay(100)
'mywindow.printwrap("And more printing.")
'Flip
'Delay(100)
'mywindow.printwrap("Things are not funny in the morning.")
'Flip

Repeat
Until KeyDown(KEY_ESCAPE) Or AppTerminate()
Type Tcolor
	Field Red:Int
	Field Green:Int
	Field Blue:Int
End Type


Type Tword
	Field Color:Tcolor
	Field OldColor:Tcolor
	Field Text:String
	Field length:Int 'characters across
	Field width:Int 'pixels across
	
	Method New()
		Color = New Tcolor
		GetColor(Color.red, Color.green, Color.blue)
		OldColor = New Tcolor
	End Method
	
	Function set:Tword(text:String)
		Local w:Tword = New Tword
		w.text = text
		w.length = Len(text)
		w.width = TextWidth(text)
		Return w
	End Function
	
	Method display(x:Int,y:Int)
		GetColor OldColor.Red,OldColor.Green,OldColor.Blue
		SetColor color.red,color.green,color.blue
		DrawText Text,x,y
		SetColor OldColor.Red,OldColor.Green,OldColor.Blue
	End Method
End Type

Type TTextLine
	Field list:TList ' saves the words
	Field width:Int ' total pixels across
	Field length:Int ' total characters across
	
	Method New()
		list = New TList
		width = 0
		length = 0
	End Method
	
	Method addWord(text:String)
		Local w:Tword = Tword.set(text)
		list.addlast(w)
		width = width + w.width
		length = length + w.length
	End Method
	
	Method display(x:Int,y:Int)
		For Local w:Tword = EachIn list
			w.display(x,y)
			x = x + w.width
		Next
	End Method
	
End Type
	
Type WindowBox
	'Global WindowBoxList:TList = New TList
	
	Field Font_Name:String
	Field Font_Size:Int
	Field FontMaxWidth:Int
	Field FontMaxHeight:Int
	Field ScreenWidth:Int
	Field ScreenHeight:Int
	Field WindowXPos:Int
	Field WindowYPos:Int
	Field WindowWidth:Int
	Field WindowHeight:Int
	Field TexturePath:String
	Field TextureImage:TImage = New TImage
	Field CurX:Int
	Field CurY:Int
	Field TexTTextLines:TTextLine[100]
	Field CurTexTTextLine:Int
	Field CurTopLine:Int
	
	Function Create:WindowBox()
		Local w:WindowBox = New WindowBox
		w.SetWindowFont(Null,8)
		w.ScreenWidth=GraphicsWidth()
		w.ScreenHeight=GraphicsHeight()
		w.SetPos(0,0)
		w.SetSize(10,10)
		w.CurX=0
		w.CurY=0
		For Local i:Int=0 To 99
			w.TexTTextLines[i]= New TTextLine
		Next
		w.CurTexTTextLine=0
		w.CurTopLine=0
		
'		WindowBoxList.addlast(w:WindowBox)
		Return w:WindowBox
	End Function

	Method SetWindowFont(Font_Namex:String,Font_Sizex:Int)
		Local font:timagefont=LoadImageFont(font_namex,font_sizex,SMOOTHFONT)
		SetImageFont(font)
		Font_Name=Font_Namex
		Font_Size=Font_Sizex
		FontMaxWidth=TextWidth(Chr(0))
		FontMaxHeight=TextHeight(Chr(0))
		For Local i:Int=1 To 255
			If TextWidth(Chr(i))&gt;FontMaxWidth Then FontMaxWidth=TextWidth(Chr(i))
			If TextHeight(Chr(i))&gt;FontMaxHeight Then FontMaxHeight=TextWidth(Chr(i))
		Next
	End Method
	
	Method SetPos(xpos:Int, ypos:Int)
		WindowXPos=xpos
		windowYPos=ypos
	End Method
	
	Method SetSize(xsize:Int, ysize:Int)
		WindowWidth=xsize
		WindowHeight=ysize
	End Method
	
	Method DrawBorder()
		SetColor 255,255,255
		Local x:Int=WindowXPos
		Local x1:Int=WindowXPos+(WindowWidth*FontMaxWidth)+FontMaxWidth
		Local y:Int=WindowYPos
		Local y1:Int=WindowYPos+(WindowHeight*FontMaxHeight)
		
		DrawLine(x-5,y-5,x1+5,y-5)
		DrawLine(x-5,y-5,x-5,y1+5)
		DrawLine(x1+5,y-5,x1+5,y1+5)
		DrawLine(x-5,y1+5,x1+5,y1+5)
	End Method
			
	Method Show()
		Local x1:Int=(WindowWidth*(FontMaxWidth))
		Local y1:Int=(WindowHeight*(FontMaxHeight))
		DrawBorder()
		'DrawImageRect(TextureImage,WindowXPos,WindowYPos,x1,y1)
	End Method
	
	Method SetTexture(TexturePathx:String)
		TextureImage = LoadImage(TexturePathx)
	End Method
	
	Method PrintWrap(Text:String)
		Local words:String[]
		Local soffx:Int=WindowXPos
		Local soffy:Int=WindowYPos
		words=Text.split(Chr(32))
		For Local t:String=EachIn words
			If Len(t)&lt;WindowWidth-TexTTextLines[CurTexTTextLine].length Then
				If TexTTextLines[CurTexTTextLine].length = 0 Then CurY = CurY + 1
				TexTTextLines[CurTexTTextLine].addWord(t)
			Else
				CurY=CurY+1
				If CurY &gt; WindowHeight Then
					CurTopLine=CurTopLine+1
				EndIf
				CurTexTTextLine=CurTexTTextLine+1
				TexTTextLines[CurTexTTextLine].addWord(t)
			End If
			If Instr(".?!",Right(t,1))&lt;&gt;0 Then
				TexTTextLines[CurTexTTextLine].addword("  ")
			Else
				TexTTextLines[CurTexTTextLine].addword(" ")
			EndIf

			If texTTextLines[CurTexTTextLine].length &gt; WindowWidth Then
				CurY=CurY+1
				If CurY &gt; WindowHeight Then
					CurTopLine=CurTopLine+1
				EndIf
				CurTexTTextLine = CurTexTTextLine + 1
			EndIf
		Next
		SetColor 0,0,50
		DrawRect(WindowXPos,WindowYPos,WindowWidth*FontMaxWidth+10,(WindowHeight)*FontMaxHeight)
		For Local i:Int=CurTopLine To WindowHeight+CurTopLine-1
			TexTTextLines[i].display(soffx+FontMaxWidth,soffy+((i-CurTopLine)*FontMaxHeight))
		Next
	End Method
	 
End Type
</textarea> <br><br></td></tr></table><br>
<a name="1023722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> base on what you last post there are several steps you need to follow in order to produce in a kind of a time line effect.<br>I usually separate my code in to three and sometime four steps:<br>1. creation process<br>2. initialization process(this process sometimes integrated in the creation process)<br>3. update process<br>4. display process<br><br>that is how I do all of my code that is for games and is interactive.<br>anyway. All I had to do is separate the processes in your code and added the different function needed for it to work in a time line. I had a timer function which I did a while ago and was easy to incorporate. You can use it as you like, just don't share it as yours. It is not that big of a deal so don't need or expect to get credit for it and yes, use at your own risk.<br>anyway this is what I got:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict
Graphics 800,600,0,60

Local mywindow:windowbox=WindowBox.Create()
mywindow.setwindowfont("c:\windows\fonts\consola.ttf",18)
mywindow.setpos(100,200)
mywindow.setsize(23,10)
'mywindow.settexture("text_texture.png")

Cls
SetColor 255,255,255
SetBlend AlphaBlend

mywindow.CurX=0
mywindow.CurY=0
SetColor 255,0,0
mywindow.printwrap("Hello.")
SetColor 0,255,0
mywindow.printwrap("This is a test of something.")
SetColor 0,0,255
mywindow.printwrap("And something is nothing, but the nothing is something in the morning.")
SetColor 255,255,0
mywindow.printwrap("Then the mountains came crashing To the shore.")
SetColor 0,255,255
mywindow.printwrap("Sometimes when the clocks stop, the world stops with them.")
SetColor 255,0,255
mywindow.printwrap("Even more printing that is fun.")

Repeat
	Cls
	mywindow.update()
	mywindow.display()
	Flip()
Until KeyDown(KEY_ESCAPE) Or AppTerminate()
Type Tcolor
	Field Red:Int
	Field Green:Int
	Field Blue:Int
End Type


Type Tword
	Field Color:Tcolor
	Field OldColor:Tcolor
	Field Text:String
	Field length:Int 'characters across
	Field width:Int 'pixels across
	Field Textout:String
	Field timer:TtimeLimit
	Field index:Int
	
	Method New()
		Color = New Tcolor
		GetColor(Color.red, Color.green, Color.blue)
		OldColor = New Tcolor
		timer = TtimeLimit.Create(50)
		index = 0
	End Method
	
	Function set:Tword(text:String)
		Local w:Tword = New Tword
		w.text = text
		w.length = Len(text)
		w.width = TextWidth(text)
		Return w
	End Function
	
	Method update:Int()
		If index &lt; text.length
			If timer.expired()
				textout :+ Chr(text[index])
				index :+ 1
			EndIf
			Return True
		EndIf
		Return False
	End Method
	
	Method display(x:Int,y:Int,Char:Int = False)
		GetColor OldColor.Red,OldColor.Green,OldColor.Blue
		SetColor color.red,color.green,color.blue
		DrawText TextOut,x,y
		SetColor OldColor.Red,OldColor.Green,OldColor.Blue
	End Method
End Type

Type TTextLine
	Field list:TList ' saves the words
	Field width:Int ' total pixels across
	Field length:Int ' total characters across
	Field Nxt:TLink
	Field first:TLink
	Field last:TLink
	Method New()
		list = New TList
		width = 0
		length = 0
	End Method
	
	Method addWord(text:String)
		Local w:Tword = Tword.set(text)
		list.addlast(w)
		If first = Null
			first = list.firstLink()
			Nxt = First
		EndIf
		last = list.lastlink()
		width = width + w.width
		length = length + w.length
	End Method
	
	Method update()
		If Nxt = Null Return False
		Local w:Tword = Tword(nxt.value())
		If w.update() = False
			If Nxt &lt;&gt; Last
				nxt = nxt.nextLink()
				Tword(nxt.value()).timer.reset()
				Return True
			EndIf
			Return False
		EndIf
		Return True
	End Method
		 
	
	Method display(x:Int,y:Int)
		For Local w:Tword = EachIn list
			w.display(x,y)
			x = x + w.width
		Next
	End Method
	
End Type
	
Type WindowBox
	'Global WindowBoxList:TList = New TList
	
	Field Font_Name:String
	Field Font_Size:Int
	Field FontMaxWidth:Int
	Field FontMaxHeight:Int
	Field ScreenWidth:Int
	Field ScreenHeight:Int
	Field WindowXPos:Int
	Field WindowYPos:Int
	Field WindowWidth:Int
	Field WindowHeight:Int
	Field TexturePath:String
	Field TextureImage:TImage = New TImage
	Field CurX:Int
	Field CurY:Int
	Field TexTTextLines:TTextLine[100]
	Field CurTexTTextLine:Int
	Field CurTopLine:Int
	Field index:Int
	
	Function Create:WindowBox()
		Local w:WindowBox = New WindowBox
		w.SetWindowFont(Null,8)
		w.ScreenWidth=GraphicsWidth()
		w.ScreenHeight=GraphicsHeight()
		w.SetPos(0,0)
		w.SetSize(10,10)
		w.CurX=0
		w.CurY=0
		For Local i:Int=0 To 99
			w.TexTTextLines[i]= New TTextLine
		Next
		w.CurTexTTextLine=0
		w.CurTopLine=0
		w.index = 0
'		WindowBoxList.addlast(w:WindowBox)
		Return w:WindowBox
	End Function

	Method SetWindowFont(Font_Namex:String,Font_Sizex:Int)
		Local font:timagefont=LoadImageFont(font_namex,font_sizex,SMOOTHFONT)
		SetImageFont(font)
		Font_Name=Font_Namex
		Font_Size=Font_Sizex
		FontMaxWidth=TextWidth(Chr(0))
		FontMaxHeight=TextHeight(Chr(0))
		For Local i:Int=1 To 255
			If TextWidth(Chr(i))&gt;FontMaxWidth Then FontMaxWidth=TextWidth(Chr(i))
			If TextHeight(Chr(i))&gt;FontMaxHeight Then FontMaxHeight=TextWidth(Chr(i))
		Next
	End Method
	
	Method SetPos(xpos:Int, ypos:Int)
		WindowXPos=xpos
		windowYPos=ypos
	End Method
	
	Method SetSize(xsize:Int, ysize:Int)
		WindowWidth=xsize
		WindowHeight=ysize
	End Method
	
	Method DrawBorder()
		SetColor 255,255,255
		Local x:Int=WindowXPos
		Local x1:Int=WindowXPos+(WindowWidth*FontMaxWidth)+FontMaxWidth
		Local y:Int=WindowYPos
		Local y1:Int=WindowYPos+(WindowHeight*FontMaxHeight)
		
		DrawLine(x-5,y-5,x1+5,y-5)
		DrawLine(x-5,y-5,x-5,y1+5)
		DrawLine(x1+5,y-5,x1+5,y1+5)
		DrawLine(x-5,y1+5,x1+5,y1+5)
	End Method
			
	Method Show()
		Local x1:Int=(WindowWidth*(FontMaxWidth))
		Local y1:Int=(WindowHeight*(FontMaxHeight))
		DrawBorder()
		'DrawImageRect(TextureImage,WindowXPos,WindowYPos,x1,y1)
	End Method
	
	Method SetTexture(TexturePathx:String)
		TextureImage = LoadImage(TexturePathx)
	End Method
	
	Method PrintWrap(Text:String)
		Local words:String[]
		words=Text.split(Chr(32))
		For Local t:String=EachIn words
			If Len(t)&lt;WindowWidth-TexTTextLines[CurTexTTextLine].length Then
				If TexTTextLines[CurTexTTextLine].length = 0 Then CurY = CurY + 1
				TexTTextLines[CurTexTTextLine].addWord(t)
			Else
				CurY=CurY+1
				CurTexTTextLine=CurTexTTextLine+1
				TexTTextLines[CurTexTTextLine].addWord(t)
			End If
			If Instr(".?!",Right(t,1))&lt;&gt;0 Then
				TexTTextLines[CurTexTTextLine].addword("  ")
			Else
				TexTTextLines[CurTexTTextLine].addword(" ")
			EndIf

			If texTTextLines[CurTexTTextLine].length &gt; WindowWidth Then
				CurY=CurY+1
				CurTexTTextLine = CurTexTTextLine + 1
			EndIf
		Next
	End Method
	
	Method update()
		Local notNext:Int,i:Int
		For i=CurTopLine To (CurTopLine+ index)
			notNext = TexTTextLines[i].update()
		Next
		If notNext = False
			If index &lt; (WindowHeight-1) Then 
				index = index +1
			ElseIf index =  windowHeight-1 
				If CurTopLine &lt; (curY-windowHeight-1) Then CurTopLine :+ 1
			EndIf
		EndIf 
	End Method
	
	Method display()
		show()
		Local soffx:Int=WindowXPos
		Local soffy:Int=WindowYPos
		SetColor 0,0,50
		DrawRect(WindowXPos,WindowYPos,WindowWidth*FontMaxWidth+10,(WindowHeight)*FontMaxHeight)
		For Local i:Int=CurTopLine To (CurTopLine + index)
			TexTTextLines[i].display(soffx+FontMaxWidth,soffy+((i-CurTopLine)*FontMaxHeight))
		Next
	End Method
	 
End Type

Type TtimeLimit
	Field time:Long
	Field secs:Long
	Field limit:Long
	Field state:Int
	
	Function Create:TtimeLimit(l:Int)
		Local t:TtimeLimit = New TTimeLimit
		t.limit = l
		t.time = MilliSecs()
		Return t
	End Function

' initialize timer in millisecs	

	Method init(l:Int)
		limit = l
		time = MilliSecs()
	End Method

' resets the timer		

	Method reset()
		time = MilliSecs()
	End Method

' gets limit	

	Method getLimit:Int()
		Return limit
	End Method

	Method randomize()
		time :- Rand(0,limit)
	End Method

' return remining millisecs 
' if the number returned is negative 
' the value has expired that number 
' of millisecs.	

	Method GetRemaining:Long()
		Return (time+limit) - MilliSecs()
	End Method

' returns the number of millisecs consumed.
	
	Method getLapsed:Int()
		Return (MilliSecs() - time)   
	End Method

' returns true if the time has expired
' resets after the method call when time has 
' expired.

	Method expired:Int()
		If MilliSecs() &lt; secs
			secs = MilliSecs()
			time = secs
		EndIf
		secs = MilliSecs()
		state = False
		
		If time+limit &lt; secs
			time = secs
			state = True
		EndIf	
		 
		If time &gt; secs time = secs
		Return state
	End Method

End Type

</textarea><br>I hope it helps <br><br></td></tr></table><br>
<a name="1023917"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jesse, very elegant approach.  Thanks for posting the updated code.  You have created very clean and easy to follow (understand) methods for exactly what I was attempting to produce in the first place.  You've given me some clearer insight as to how BlitzMax TLists and TTimer should work.  It is fully obvious that my shoddy second code post illustrates the following:<br><br>First, a incomplete understanding of the BlitzMax language and syntax.<br><br>Second, my reliance on "intelligent" IDE's.  They have instilled a lazyness in me.  I've gotten so used to typeing a command then the dot and getting a list of that types elements and procedures, and a wealth of documentation.  I guess that I have neglected, and in a way, been "trained", to not memorize, and thus, fully understand the underlying fundamentals of some of the built in commands and types.  (I use the standard IDE right now, precisely because I'm trying to retrain myself, and because it's a new language to me.)<br><br>Third, it shows how my brain works when approaching a new problem.  My original post, though I thought it was pretty decent, did not come from a first, or second, or even third revision.  As you can see from the second code I posted, it takes me some time to get a "working" set of procedures into a well formed, nice looking, and easy to use, "final", set.  A good friend of mine was a professional programmer (database expert, among other things) for over thirty years.  I have to laugh everytime I write some new code, because he would get so pissed at me for getting bogged down in always "trying" to produce the most perfect and efficient code.  It almost never failed.  I'd create a new procedure, work on it for a month, think it was perfect, then show it to him for approval.  Of course you already can guess the result. :D<br><br>I guess what I'm trying to say is I really do appreciate your help and advice.  Your approach is much the same as my friends.  He would also give me some advice first, then make me work on the code to see what I can produce,  before ripping me a new one for being silly. :D  I guess I miss that.  And it just caught me off guard when you approached this problem in the same manner.  Maybe I'm too sentimental, sorry.  I just miss my friend.<br><br>Anyway, I'm babbling.<br><br>Great work.  I believe I'm going to reapproach my Codes type and procedures and take them out of the actual text input.  Your approach seems, first, simpler, and second I can see greater potiental for my Codes type and procedures.  I see where I can create greater control, in a more simplified manner, over how the text is presented.<br><br>Thanks again,<br>Laters! :D <br><br></td></tr></table><br>
<a name="1023979"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you. I am glad I was able to help you out. <br>about Tlist, It has been only little over a year ago that I learned to use it somewhat efficiently and I have been programming in Bmax for years. I posted code in the code Archives in which I wrote a linked list from scratch not knowing that that's exactly what Tlist is. Funny thing is that sense we don't have a manual for Bmax, the best way to get information here is by posting our code here, good or bad, and sharing what we know and getting answers from someone that know something we don't.<br><br>One of the things I try to do when coding is to brake down what I am trying to do in to simpler more manageable pieces but one of the problems I run into from doing that is that sometimes the code becomes too inefficient as far as speed is concerned. The good thing is that once you have it working it is easy to optimize. <br><br>good luck with your project. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
