<!DOCTYPE html><html lang="en" ><head ><title >Ideas for a new top-down adventure, need advice</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Ideas for a new top-down adventure, need advice</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >Ideas for a new top-down adventure, need advice</a><br><br>
<a name="1032603"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Recently I just finished a simple, side-scrolling, arcade-style game as a jumping-off point for my new found BlitzMax obsession.  I went at it thinking that I would code everything on my own and fix all of my own problems (of course I occasionally came here for help when I was just banging my head against a wall), and that resulted in some really nasty code overall, but gave me some insight into what to do and what not to do in future projects.<br><br>I am ready to start my new project, and I'd like to do an adventure game with a bird's eye view, much like the mechanics of the NES Legend of Zelda.  I have sat and thought long about how to go about creating a framework for the game, and I have a couple ideas that I would like people to comment on.  There is one route, which is using a map editor (like Universal Map Editor) to quickly create tile maps for my 'world'.  <br><br>The other route, which to me would be much more fulfilling, is programming everything entirely by myself, which I think would involve creating my own tileset, and then loading tiles to specific locations on the screen when on a particular screen.  I could store the information for the screen maybe in a Type so we could treat each screen as an individual place (like Legend of Zelda, in which you can't just freely scroll into the next screen, but rather load an entirely new screen when you reach the edge ).  Then as a field in the main character Type, use the field to store a number that determines what screen in the world should be loaded.  The problem I see is that using a high number of tiles on a screen would be complicated to store and then load and draw onto the screen methodically so it is all displayed quickly.<br><br>My solution to this was to use solid colors for the backgrounds (so this could maybe represent the ground, and gets rid of having to have a ground tile) and then create types for specific objects that appear in tiles (bushes, staircases, rocks, etc.).  Then I can use collision detection in each individual type of objects and give them their own characteristics (burning a bush eliminates it, where as bombing a rock destroys it, etc.).  This would cut down the number of tiles by only loading in tiles that the character directly interacts with and doesn't just "walk over."  Then, in the screen Type, I can define a Method that checks what screen the character is on, which in turn would call a function that loads all of the tiles and draws them that needs to be on that particular screen (creates the objects, loads them to certain coordinates, draws them).  <br><br>I would like to know from all of you what makes more sense, what you think is viable, and if you have any suggestions.  I want to reiterate that doing it myself would be much more fulfilling because using a map editor would just feel like cheating.  In my first game, none of the graphics I used were created by myself, but instead borrowed from various video games that were available on sprite websites.  As such I can't legally sell or exchange my game for money, which is fine since my intent was to make it freeware.  While I intend to make my next game free, I would also want to do draw everything myself, and I am TERRIBLE at drawing.  I will release my first game here on the forums, along with the source code, once my friend finishes the music and sound effects for the game. <br><br></td></tr></table><br>
<a name="1032604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Really, if you can, try and keep in mind the Legend of Zelda game as you go through my description.  Here is a video to give you an idea of what the gameplay is like, what I mean by having each screen be a certain place, etc.<br><br><br><a href="http://www.youtube.com/watch?v=c4bvZZa5Mtg" target="_blank">Legend of Zelda gameplay</a> <br><br></td></tr></table><br>
<a name="1032617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> call a function that loads all of the tiles and draws them that needs to be on that particular screen (creates the objects, loads them to certain coordinates, draws them).  <br></div> Creating objects is slow. It will be better to store your map as a big grid ie 2d array, and work out which cells of the grid are visible.<br><br>The grid would be made of TCell which has two fields, TFloor and TFeature (for example). The TFloor contains the colour (or tile) of the background, and whether it is passible. TFeature is an Abstract type for all your rocks and bushes. When you draw a TCell, draw the TFloor first and then TFeature.<br><br>Extend from TFeature your bushes and rocks, but call them things like TPassableFeature or TDestroyable Feature. You might have pillars which work like rocks too etc. It's a good idea to keep type names generic rather than tie them down to a specific physical item.<br><br>When checking if the character can enter a particular cell, you'll need to check both the TFloor and TFeature for passability. So both would have a passable:Int() method which returns either true or false. And so on. <br><br></td></tr></table><br>
<a name="1032620"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> That makes sense, and I hadn't thought of that.  This is just the type of feedback I need :)<br><br>I think the big hurdle for me here will be creating the big 2D array and how to decide what is visible.  I had not really considered doing it that way, and I'm not sure how to implement that. <br><br>What I'm imagining is loading this huge 2D array into memory, and then only drawing certain portions of it if it is say, in the 1024x768 window of view.  To me that sounds like it would be a drain on system resources, but I also don't know much about what is happening there.  Could you explain the idea of this array in a little more detail?  I just haven't worked a lot with arrays.  My current understanding of them is that they are kind of like a matrix (if we're talking 2D arrays) in which each entry is indexed by its row and column.  Other than that...not sure how to use them in a programming environment.  I'm going for a masters in Math  so I at least understand the abstract ideas, its the programming implementation that is new to me. <br><br></td></tr></table><br>
<a name="1032623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >shinkiro1</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think you should use a map-editor because it will reduce the time<br>to create maps significantly. It's not cheating, just funnier and not so time consuming. Mathematicians are also not cheating when using a calculator, are they ^^<br><br>Have you thought about integrating a scripting language? because hardcoding such a game isn't a good idea.<br><br>EDIT:<br>An array is like a variable, but it can hold more than one value at a time.<br>For instance:<br><pre class=code>Local array:Int[] = [23,56,32,53,22,67]</pre><br>The above code initializes an array with 6 values. Then you get the value by it's index:<br><pre class=code>
Print array[2] 'prints out 32
Print array[0] 'prints out 23
</pre><br>An arrays index is starting at 0 and not one, you have to remember that.<br>So you can store all your map data in an array<br>I think there are tutorials which explain them further and show there use (like in a tilemap). <br><br></td></tr></table><br>
<a name="1032641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a bunch of code in no particular order. I haven't tested it but hopefully will give you ideas.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Strict
Const offset = 32 'an empty border on the left and top of the screen
Const size = 64 'the size of each tile
Const x_number = 50 'the size of the map
Const y_number = 50
Const xres = 1024 - offset*2 'the visible area
Const yres = 768 - offset*2

Global scroll_x = 0, scroll_y = 0 'the current pixel at the top left corner of the screen, for scrolling

Global map:TCell[,] = New TCell[x_number, y_number] 'the map array

'takes a cell number and turns it into the pixel at the top left corner
Function cell_to_pixel_x(cell)
	Return offset + size * cell - scroll_x
End Function

Function cell_to_pixel_y(cell)
	Return offset + size * cell - scroll_y
End Function

'takes a pixel and reports the cell that is there. good for clicking on a cell tests
Function pixel_to_cell_x(pixel)
	Return (pixel - offset + scroll_x) / size
End Function

Function pixel_to_cell_y(pixel)
	Return (pixel - offset + scroll_y) / size
End Function

'put in your main game loop

'a temp list to remember the cells that are visible
'there is a more efficient method but this is fast enough and easier
Local draw_list:TList = New TList

'for each cell
For Local y = 0 To y_number-1
	For Local x = 0 To x_number-1
		'update the cell
		map[x, y].update()
		'if the cell is visible, remember it for later
		'add it to the end of the list so cells in the foreground are drawn last
		If visible(x, y) Then draw_list.AddLast(map[x, y])
	Next
Next

'now draw each visible cell
For Local cell:TCell = EachIn draw_list
	cell.draw()
Next

'checks if cell at x, y is visible or not
Function visible:Int(x, y)
	Local x_pixel = cell_to_pixel_x(x)
	Local y_pixel = cell_to_pixel_y(y)
	Return x_pixel &gt;= offset And x_pixel &lt;= xres And y_pixel &gt;= offset And y_pixel &lt;= yres
End Function

Type TCell
	Field x, y 'what map coordinates i am on
	Field occupants:TList = New TList 'a list of things on the cell, such as a rock or a character
	Field r, g, b 'colours for your solid background
		
	Method draw()
		SetColor r, g, b
		'draw the background
		DrawRect cell_to_pixel_x(x), cell_to_pixel_y(y), size, size
		SetColor 255, 255, 255
		'draw every object on the tile
		For Local entity:TEntity = EachIn occupants
			entity.draw()
		Next
	End Method
End Type</textarea> <br><br></td></tr></table><br>
<a name="1032660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Espada: I appreciate the advice but to me it just wouldn't feel like I did it myself because the majority of the work was done for me.  Plus, I do the type of maths that doesn't require a calculator ;) (I'm into algebraic topology).  Plus, I know nothing about scripting :[<br><br>@Czar Flavius: I appreciate the code, and for the most part I understand what you're trying to achieve, but I honestly cannot follow the idea of turning cells into pixels...I'm not sure what that accomplishes.  What especially threw me off was that the pixel_to_cell function wasn't utilized.  Could you expand on that more? <br><br></td></tr></table><br>
<a name="1032662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's so each cell knows where to draw itself on the screen. If you have a cell at row 6, column 5, where does that draw itself on the screen? cell_to_pixel gives you the position on the screen to join it. I noticed a mistake - I forgot to take account of the current scroll position, so I'll update that.<br><br>Pixel to cell is useful is the player clicks on a tile, perhaps to aim a weapon? You take the pixel clicked by the mouse and -bam- you got the row and column (x and y) of the cell he clicked on! <br><br></td></tr></table><br>
<a name="1032678"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, alright.  It's beginning to make more sense.  So just to be sure we're on the same page:<br><br>(For this I'm referring to cells as tiles)<br><br>There should be a black border that are 32 pixels wide around the perimeter of the screen.  This black space could be used for displaying inventory, etc., but primarily acts as a buffer zone for the tiles.<br><br>The screen resolution is 1024x768, but what will actually be composed of tiles is a rectangle in the middle of the screen, and so the visible map in the middle of the screen will be 960 x 704 pixels, and with tiles that are 64 x 64 pixels, the visible map will then be of dimensions 15 tiles-by-11 tiles.  The entire map, however, is 50 tiles-by-50 tiles (as it stands in your code).  <br><br>Now the bit of code in the main loop of the game runs through the 2D map array, tile by tile, updates each tile, and if it is visible, draws it.  The visibility function determines this by taking the x,y position in the map array, and calls the tile_to_pixel functions, which determine the x and y coordinates of the tile depending on how much we have moved in the x, y directions causing the tiles to be scrolled.  <br><br>In this sense, if we had a character move to the top of the screen and hit the top of the screen and continue to try to move, we would then have to increment the scroll_y variable so the map moves down, giving the illusion the character is moving "north."  Likewise, if we had the character press against the left side of the screen, we have to increment scroll_x to move the map right, giving the illusion the character is moving "west."  Additionally, this scrolling is happening in real time, so as long as I'm pressing against a side of the screen, the map is going to continue to be scrolled.  <br><br>Assuming I have all of this correct, my main concerns are:<br><br>- I am using AutoMidHandle, so I would imagine that your code is assuming the image handles for the tiles are in the upper left corners of each tile?  Or will it still work?<br><br>- I am still unsure as to how I am loading objects or colors into each tile.  Do I load each individual tile upon loading the game?  This method of displaying the map seems to lend itself to pre-loading everything and then only drawing it if it falls within our "window of view."  Is this the only way to go about it, or is there a way to dynamically create and destroy tiles depending on what we can see? <br><br></td></tr></table><br>
<a name="1032683"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes that's right! You've got it! :D<br><br>The numbers I used are just for example purposes. You can change the size of the map etc<br><br>I looked at the video you posted and it seems that the game is a collection of smaller maps (each the size of the screen) and you move between them and no action takes place in maps you cannot yet see.<br><br>The code I posted is more for a generic tile-based game, where you move fluidly around a large map rather than preset increments and action is updated everywhere.<br><br>Which of the two do you most want to do? If you want it more like the game you posted, some tweaking will be required.<br><br>I'm not sure how mid handle will affect the outcome. I think you can selectively enable and disable it for individual images.<br><br>For the way I posted, you load the entire map. Let's say each cell uses 1kb of memory each (and this is a very HIGH estimate) then a 100x100 map will use up 10MB or memory. Even a very poor computer these days will have 128MB or memory or more. You shouldn't worry in the slightest about memory usage. (0.2kb would be a more reasonable estimate but it depends entirely what you store on each tile) Creating and destroying tiles requires reallocation of memory. It is faster to allocate/reserve the maximum amount of memory required (so long as it is reasonable and it is in this case) and leave 'idle' what is not required (yet...) In a game, speed is important.<br><br><br>Have an array of floor types and give each a unique id starting from 0. So if you have floors:TFloor[10] (assuming 10 floor types) then grass could have id 0 and so would be stored at floors[0], water 1, wall 2 and so on. When you create a new map, set each tile to grass. Then in the map editor press a number to select a tile type eg 1 for water, and then click on a tile (using pixel_to_tile) to change its floor to that type. This way you can directly alter the map!<br><br>to change a tile's floor at x, y map[x, y].floor = floors[id_num]<br><br>you can store the colour values r g b (or image) to draw in floor eg<br>DrawImage floor.image, cell_to_pixel_x(x), cell_to_pixel_y(y)<br>in the draw method now<br><br>Have a save function which spews out the data of your map into a text file. You can write the id numbers of the floors in sequence into the text file. Then load from the text file in the same order and put the id numbers back into the tile map. The first 2 numbers of the save file should be the size of the map, so you can create the map array to the right size. Saving positions of characters, items and stats is a little bit trickier but worry about it later when you have mastered this.<br><br>At the start of your game you should pre-load the TYPES of floors, but not the whole map. So set up the floors array and put in grass into [0] and so on and load the grass image file if you are using one. Then ask the user to pick a map (http://en.wikibooks.org/wiki/BlitzMax/Modules/System/System#RequestFile that's a very quick and handy way) and load the map array and place the tiles in. Then your game is ready.<br><br>OK that's a lot to take in but you look like a quick learner and once you've got your head around it you're well on the way to a comprehensive tile engine! <br><br></td></tr></table><br>
<a name="1032685"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's some old code I dug up which might interest you. I had an obsession with semi-colons back then, please ignore :D<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
'grid-array example

Framework brl.GLMax2D
Import BRL.Timer

Const Xnum:Int = 5, Ynum:Int = 5; 'the number of cells
Const Xsize:Int = 32, Ysize:Int = 32; 'size of cells in pixels
Const Xoffset:Int = 32, Yoffset:Int = 64; 'pixels by which the board is offset

'used for glow effect
Const minFlow:Int = 32, maxFlow:Int = 230, flowRate:Int = 1;

'id constants
Const containNum:Int = 3
Const nothing:Int = 0, aThing:Int = 1, aWall:Int = 2;

Const speed:Float = 0.1; 'speed of the player

Type TPlayer
	Field x:Int, y:Int, dirX:Int, dirY:Int 'the current location of the player and if it is moving, the dir is which way. ie dirX=1 means moving right 1 celll
	Field progressX:Float, progressY:Float 'what percentage of the progress to the next cell has been completed
	Field score:Int
	
	Method draw()
		'draws the player at its current location
		SetColor 255, 0, 0;
		DrawOval getX(x) + progressX * dirX * Xsize, getY(y) + progressY * dirY * Ysize, Xsize, Ysize;
		SetColor 255, 255, 255;
		DrawText score, 10, 10;
	End Method
	
	Method updateProgress:Int()
		'if the player is moving between cells, update its progress. returns true if player has completed movement
		Local check:Int = False;
		If dirX
			progressX :+ speed;
		End If
		If dirY
			progressY :+ speed;
		End If
		If progressX &gt; 1.0
			progressX = 0;
			x :+ dirX;
			dirX = 0;
			check = True;
		End If
		If progressY &gt; 1.0
			progressY = 0;
			y :+ dirY;
			dirY = 0;
			check = True;
		End If
		Return check;
	End Method
	
	Method checkMove:Int(xx:Int, yy:Int)
		'can the player move there? or is it off the board
		Return (xx + x &gt;= 0 And xx + x &lt; Xnum) And (yy + y &gt;= 0 And yy + y &lt; Ynum);
	End Method
	
	Method move(directionX:Int, directionY:Int)
		'make a move, unless the player is already moving
		If Not dirX And Not dirY
				dirX = directionX; dirY = directionY;
		End If
	End Method
End Type

'colours
Type TColour
	Field red:Int, green:Int, blue:Int
	
	Method set()
		SetColor red, green, blue;
	End Method
End Type

Function getX:Int(x:Int)
	'gets a cell, returns a pixel
	Return x * Xsize + Xoffset;
End Function

Function getY:Int(y:Int)
	'gets a cell, returns a pixel
	Return y * Ysize + Yoffset;
End Function

Function toX:Int(x:Int)
	'gets a pixel, returns a cell
	Return (x - Xoffset) / Xsize;
End Function

Function toY:Int(y:Int)
	'gets a pixel, returns a cell
	Return (y - Yoffset) / Ysize;
End Function

'each grid cell contains a block
Type TBlock
	Field contains:Int 'nothing, an item, a wall
	Field hasPlayer:Int
	Field mouseOver:Int
	Global flow:Int, flowDirection:Int 'used for flow effect
	Global colour:TColour[] = New TColour[containNum]
	
	Method New()
		'set up the colours for the different types of block
		For Local i:Int = 0 Until containNum
			TBlock.colour[i] = New TColour;
		Next
		
		TBlock.colour[nothing].red = 0; TBlock.colour[nothing].green = 0; TBlock.colour[nothing].blue = 0;
		TBlock.colour[aThing].red = 0; TBlock.colour[aThing].green = 255; TBlock.colour[aThing].blue = 0;
		TBlock.colour[aWall].red = 0; TBlock.colour[aWall].green = 0; TBlock.colour[aWall].blue = 255;
		
		'flow glow
		flow = minFlow; flowDirection = flowRate;
	End Method
	
	Method draw(x:Int, y:Int)
		'draws the cell, with a glowing border if mouse is over
		If mouseOver
			SetColor 255, flow, flow;
		Else
			SetColor 255, 255, 255;
		End If
		updateflow();
		DrawRect x, y, Xsize, Ysize;
		colour[contains].set();
		DrawRect x+1, y+1, Xsize-2, Ysize-2;
	End Method
	
	Method updateflow()
		'updates the glowing effect
		flow :+ flowDirection;
		If flow &gt;= maxFlow
			flowDirection = -flowDirection;
		ElseIf flow &lt;= minFlow
			flowDirection = -flowDirection;
		End If
	End Method
	
	Method isPassable:Int()
		'returns true if this cell can be traversed
		Select contains
			Case nothing
				Return True;
			Case aThing
				Return True;
			Case aWall
				Return False;
			Default
				Return False;
		End Select
	End Method
	
	Method click()
		'change the contents of the cell if clicked
		contains :+ 1;
		If contains =&gt; containNum
			contains = 0;
		End If
	End Method
	
	Method pickUp:Int()
		'if the player moves into this cell, and it contains a thing, remove it and increase score
		Select contains
			Case aThing
				contains = nothing;
				Return 1;
			Default
				Return 0;
		End Select
	End Method
End Type



'now for our main game
Type TGame
	Field moving:Int 'is the player currently moving
	Field keypress:Int 'the key pressed by the user
	Field grid:TBlock[,] = New TBlock[Xnum, Ynum] 'the game grid
	Field player:TPlayer = New TPlayer
	Field timer:TTimer = CreateTimer(20) 'fps
	
	Method New()
		'setup the grid
		For Local x:Int = 0 Until Xnum
			For Local y:Int = 0 Until Ynum
				grid[x, y] = New TBlock;
				grid[x, y].contains = nothing;
			Next
		Next
		'setup some starting walls and player
		grid[0, 0].contains = aWall;
		grid[Xnum-1, Ynum-1].contains = aWall;
		grid[0, Ynum-1].contains = aThing;
		grid[Xnum-1, 0].contains = aThing;
		player.x = Floor((Xnum-1)/2); player.y = Floor((Ynum-1)/2);
		grid[player.x, player.y].hasPlayer = True; 'put the player in the middle
	End Method
	
	Method drawGrid()
		'draws the map
		For Local x:Int = 0 Until Xnum
			For Local y:Int = 0 Until Ynum
				grid[x, y].draw(getX(x), getY(y));
			Next
		Next
	End Method
	
	Method drawPlayer()
		'draw the player
		player.draw();
	End Method
	
	Method update()
		'update the player's progress in movement
		If player.updateProgress()
			'if the player has completed movement, check for pickups in this cell
			player.score :+ grid[player.x, player.y].pickUp();
		End If
	End Method
	
	Method move(x:Int, y:Int)
		'attempt to move the player. x y are relative
		If player.checkMove(x, y)
			'if the movement is on the board
			If grid[player.x + x, player.y + y].isPassable()
				'if the cell is passable, make the move
				player.move(x, y);
			End If
		End If
	End Method
	
	Method checkmouse(x:Int, y:Int)
		'scan each cell for the mouse
		x = toX(x); y = toY(y); 'conver the mouse's pixel to a grid coordinate
		For Local xx:Int = 0 Until Xnum
			For Local yy:Int = 0 Until Ynum
				'if the mouse coordinates equal this cells, ergo the condition returns TRUE, set the mouseOver to true
				grid[xx, yy].mouseOver = (x = xx And y = yy);
			Next
		Next
	End Method
	
	Method click()
		'if clicked, look for the cell with the mouse over and click. probably not the best way to do it
		For Local xx:Int = 0 Until Xnum
			For Local yy:Int = 0 Until Ynum
				If grid[xx, yy].mouseOver
					grid[xx, yy].click();
				End If
			Next
		Next
	End Method
End Type

'actual game
Graphics 640, 480;
Notify "Simple grid-based game by Czar Flavius. Use the arrow keys to move and click on a cell to change it. Escape to end.";
Local game:TGame = New TGame;
While Not KeyDown(KEY_ESCAPE)
	Cls;
	game.drawGrid();
	game.drawPlayer();
	Flip;
	game.timer.Wait();
	
	If KeyDown(KEY_UP)
		game.move(0, -1);
	ElseIf KeyDown(KEY_DOWN)
		game.move(0, 1);
	ElseIf KeyDown(KEY_LEFT)
		game.move(-1, 0);
	ElseIf KeyDown(KEY_RIGHT)
		game.move(1, 0);
	End If
	
	game.checkMouse(MouseX(), MouseY());
	
	If MouseHit(1)
		game.click();
	End If
	
	game.update();
	
	If AppTerminate()
		Exit;
	End If
	
Wend
End;</textarea> <br><br></td></tr></table><br>
<a name="1032724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> So it sounds like what you had in mind was for me to create my own map editing utility so that I could crank out new maps whenever I wanted, and therefore it would be easier in later games to make an entirely new game with a different map.  Really what I had in mind was having a "world" where the maps didn't change...more of a situation where I just make the entire map and that is just how it is for the game.  I do like the possibility of having a map editing utility, so I will create a separate project just for that so I could implement it in a future game, but for now I'm trying to keep things relatively simple so I can tackle one thing at a time.  I suppose that still begs the question of how to load an entire map's worth of tiles and information even when the map is pre-determined.  I still don't quite understand what to do there. <br><br></td></tr></table><br>
<a name="1032784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Upon further contemplation it would seem that creating a text file with the 2D map array information stored in it would be the best way to go about this.  At the start-up of the game, I could have the game read that file into the array, thus initializing the map.  Ooh boy, you're right, creating a save game in which it recalls all of the player information will be quite interesting. <br><br></td></tr></table><br>
<a name="1032788"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> So I will post my code below...currently I am getting an "Unhandled Exception:Attempt to access field or method of Null object" error at the line that says "map[x,y].r = 255".  I really can't figure out what is going wrong...basically I'm trying to draw a bunch of tiles all of one color so I know this is working.  I feel really bad that I can't debug this on my own, so any help I can get is appreciated :[  <br><br>Thanks Czar for all the help so far!  You've been great!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem

The idea is to have a 'window' through which the player can see, and a map
underneath the window whose only visible region is what is shown in the 
window.  For example, moving the character up will cause the map to scroll down,
creating the illusion the character is traveling north.  Moving the character
left will scroll the map in to the right, creating the illusion the character
is traveling west.  There will be a buffer zone in the visual window where if 
the player hits that barrier, the scrolling will begin in order to prevent the 
character from running into unseen enemies. 

IDEAS:
Use SetAlpha to fade in graphics


TO DO:
Write storyline
Create characters/objects
Create character animations
Create object animations
Create screens
Create an inventory system
Collision detection
Input
Save files
Music
Sound effects

EndRem

SuperStrict

'Initialize graphics mode
Graphics(1024,768)

'Center image handle
AutoMidHandle True

'Seed the timer
SeedRnd(MilliSecs())


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'MUSIC &amp; SOUND FILES
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'IMAGES
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Character Images
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Background Images
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Object Images
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Load Fonts
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GLOBAL VARIABLES / CONSTANTS
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Const tileSize:Int = 64		'The size of each tile
Const screenOffset:Int = 32	'A screen offset to provide space for inventory
Const xMap:Int = 50			'Number of tiles horizontally
Const yMap:Int = 50			'Number of tiles vertically
Const xRes:Int = 1024 - (screenOffset*2)	'The visible length of the map horizontally
Const yRes:Int = 768 - (screenOffset*2)		'The visible length of the map vertically

Global xScroll:Int = 0		'x coordinate of pixel for scrolling
Global yScroll:Int = 0		'y coordinate of pixel for scrolling

Global map:TTile[,] = New TTile[xMap, yMap]	'The 2-dimensional map array

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'TYPES
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Character Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TCharacter
			Field x:Int		'x coordinate of character
			Field y:Int 	'y coordinate of character
			Field vx:Int	'velocity x component of character
			Field vy:Int	'velocity y component of character
			Field frame:Int	'animation frame of character
			Field health:Int'character health
			Field damage:Int'damage dealt by character
			
			Global CharacterList:TList = CreateList()	'Create a list of characters
			
			Method CheckInput:Int()
			End Method
			
			Method UpdateFrame:Int()
			End Method
			
			Method UpdateX:Int()
			End Method
			
			Method UpdateY:Int()
			End Method
			
			Method CheckCollisions:Int()
			End Method
			
			Function CreateCharacter:TCharacter()
			End Function
			
		End Type
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Object Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TObject
			Field x:Int		'x coordinate of object
			Field y:Int		'y coordinate of object
			Field frame:Int	'animation frame of object
			
			Global ObjectList:TList = CreateList()	'Create a list of objects
			
			Method Draw()
			End Method
			
			Function CreateObject:TObject()
			End Function
			
		End Type
		

		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Tile Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TTile
			Field tFloor:Int[]	'an array of floor tiles (e.g. grass, snow, etc.)
			Field tFeature:Int[]'an array of non-floor tiles (e.g. rocks, trees, pillars, etc.)
			Field x:Int		'x coordinate of tile in the array
			Field y:Int		'y coordinate of tile in the array
			Field occupants:TList = CreateList()	'A list of objects on the tile
			Field r:Int		'red value for RGB tile
			Field g:Int		'green value for RGB tile
			Field b:Int		'blue value for RGB tile
			
			Method Draw()
				SetColor(r,g,b)		'Set the solid color of the tile
				DrawRect(tile_to_pixel_x(x), tile_to_pixel_y(y), tileSize, tileSize)	'Draw the tile at the specified x,y coordinates of fixed size tileSize
				SetColor(255,255,255)	'Set the color back to white
				
				For Local tObject:TObject = EachIn occupants:TList	'Draw all objects on that particular tile
					tObject.Draw()
				Next
				
			End Method
			
			Method Update()
			End Method
		End Type

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'MAIN LOOP
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


While Not KeyDown(KEY_ESCAPE)	'Press Esc to exit

Cls 						'Clear the screen


'Here's a temporary list that remembers what tiles are visible
Local drawList:TList = CreateList()
For Local y:Int = 0 To (yMap:Int - 1)		'For every tile
	For Local x:Int = 0 To (xMap:Int - 1)
		map[x,y].r = 255
		map[x,y].g = 160
		map[x,y].b = 100
		'map[x,y].Update()	'Update the tile
		If visible(x,y)		'If the tile is visible, then add it to the end of the list so the tiles in the foreground are drawn last
			ListAddLast(drawList:TList, map[x,y])
		EndIf
	Next
Next

'Draw the tiles
For Local tile:TTile = EachIn drawList:TList
	tile.Draw()
Next



Delay 100		'Wait 1/10 of a second


Flip			'Flip the buffers


Wend			'END OF MAIN LOOP





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'FUNCTIONS
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function tile_to_pixel_x
		'Parameters: x is the horizontal coordinate of tile in map array
		'Returns: The x coordinate of the pixel where the tile will be placed
		'Takes x location in array and returns its x coordinate (pixel)
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function tile_to_pixel_x:Int(x:Int)
			Return screenOffset:Int + (tileSize:Int*x:Int) - xScroll:Int
		End Function
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function tile_to_pixel_y
		'Parameters: y is the vertical coordinate of tile in map array
		'Returns: The x coordinate of the pixel where the tile will be placed
		'Takes y location in array and returns its y coordinate (pixel)
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function tile_to_pixel_y:Int(y:Int)
			Return screenOffset:Int + (tileSize:Int*y:Int) - yScroll:Int
		End Function
		
		
		
	
		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function visible
		'Parameters: The tile's x, y coordinates
		'Returns: 0 if false, 1 if true
		'Checks if the tile at x, y is visible or not
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function visible:Int(x:Int, y:Int)
			Local x_pixel:Int = tile_to_pixel_x(x:Int)
			Local y_pixel:Int = tile_to_pixel_y(y:Int)
			Return x_pixel:Int &gt;= screenOffset:Int And x_pixel:Int &lt;= xRes:Int And y_pixel:Int &gt;= screenOffset:Int And y_pixel:Int &lt;= yRes:Int
		End Function
</textarea> <br><br></td></tr></table><br>
<a name="1032790"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> you need to create an instance of the TTile before you can use it:<br><pre class=code>
map[x,y] = new TTile
</pre> <br><br></td></tr></table><br>
<a name="1032825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes that's right. You've put the floors and features as fields but they should be globals. You want to store the "library" of floor types only once, and each tile simply points to the one floor it contains.<br><br>It's handy to give each type a Create function that sets up the object with its starting values. It's also a good idea to put updating and drawing code into function to keep code tidy. The draw_list has been made global so it can be remembererd from the update function to the draw function.<br><br>I've got to dash so can't explain any further but here is some idea code for you to look at.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Const grass_id = 0, water_id = 1, forest_id = 2
Const floor_num = 3
Global floors:TFloor[] = New TFloor[floor_num]
Global draw_list:TList = New TList

Type TTile
	Field x, y
	Field my_floor:TFloor
	Field my_feature:TFeature
	Field occupants:TList = New TList
	
	Method draw()
		my_floor.draw(x, y)
		my_feature.draw(x, y)
		For Local entity:TEntity = EachIn occupants
			entity.draw(x, y)
		Next
	End Method
	
	Function update_all()
		draw_list.Clear() 'reset the drawing list
		For Local y:Int = 0 To (yMap:Int - 1)		'For every tile
			For Local x:Int = 0 To (xMap:Int - 1)
				map[x,y].Update()	'Update the tile
				If visible(x,y)		'If the tile is visible, then add it to the end of the list so the tiles in the foreground are drawn last
					ListAddLast(drawList:TList, map[x,y])
				End If
			Next
		Next
	End Function

	Function draw_all()
		'Draw the tiles
		For Local tile:TTile = EachIn drawList:TList
			tile.Draw()
		Next
	End Function

	
	Function Create:TTile(x, y, floor_id)
		Local tile:TTile = New TTile
		tile.x = x
		tile.y = y
		tile.my_floor = floors[floor_id]
		Return tile
	End Function
End Type

Type TFloor
	Field r, g, b
	Field name:String
	Field passable
	
	Method draw(x, y)
		SetColor r, g, b
		DrawRect cell_to_pixel_x(x), cell_to_pixel_y(y), tilesize, tilesize
	End Method
	
	Function Create:TFloor(r, g, b, name:String, passable)
		Local a_floor:TFloor = New TFloor
		a_floor.r = r
		a_floor.g = g
		a_floor.b = b
		a_floor.name = name
		a_floor.passable = passable
		Return a_floor
	End Function
End Type

'run near the beginning of your program
Function Load()
	floors[grass_id] = TFloor.Create(0, 255, 0, "Grass", True)
	floors[water_id] = TFloor.Create(0, 0, 255, "Water", False)
	floors[forest_id] = TFloor.Create(100, 255, 100, "Forest", False)
	
	For Local x = 0 To xmap-1
		For Local y = 0 To ymap-1
			'give each tile a random floor
			map[x, y] = TTile.Create(x, y, Rand(0, floor_num))
		Next
	Next
End Function</textarea> <br><br></td></tr></table><br>
<a name="1032842"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> With a bit of tweaking of your code to fit to what I have so far (i.e., in the Load() function, changing floor_num to floor_num - 1 so as not to index beyond the array length), and integrating your ideas into my code, I have successfully made it display random tiles!  I think from here I should be able to integrate pre-defined maps.  Thank you so much for your time and help, Czar Flavius.  It truly is appreciated.  I will post periodic updates in my worklog (linked in my signature) if you're curious to see how the project is progressing :)  I'm not sure what is considered protocol, but should I credit you in the source code?  You certainly gave me a significant amount of help and workable code to get me started on this project. <br><br></td></tr></table><br>
<a name="1032888"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you! You're welcome. No I don't need to be credited but thanks for asking :) A good deed is its own reward! <br><br></td></tr></table><br>
<a name="1033024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've had a look at your worklog code and it's coming along nicely, but there is a slight issue with the code I gave you.<br><br>First of all, add this into your main game loop <br><br><pre class=code>	If KeyDown(KEY_LEFT) Then xScroll :- 5
	If KeyDown(KEY_RIGHT) Then xScroll :+ 5
	If KeyDown(KEY_UP) Then yScroll :- 5 
	If KeyDown(KEY_DOWN) Then yScroll :+ 5</pre>It will allow you to scroll around the map using the arrow keys, just for testing purposes for the time being. You'll notice the edge tiles display an undesirable effect when scrolling.<br><br>To fix this we need to - draw an extra layer of tiles on the screen than that which would be normally visable, and then place a black border around the screen that is the size of the offset. This will push the graphical effect off the main viewing area and then hide it under a black border, which you can place your interface graphics over later.<br><br>The amended code looks like this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Rem
WORKING TITLE: FRED'S EGG HUNT
AUTHOR: Daniel Allen

The idea is to have a 'window' through which the player can see, and a map
underneath the window whose only visible region is what is shown in the 
window.  For example, moving the character up will cause the map to scroll down,
creating the illusion the character is traveling north.  Moving the character
left will scroll the map in to the right, creating the illusion the character
is traveling west.  There will be a buffer zone in the visual window where if 
the player hits that barrier, the scrolling will begin in order to prevent the 
character from running into unseen enemies. 

IDEAS:
Use SetAlpha to fade in graphics

TO DO:
Write storyline
Create characters/objects
Create character animations
Create object animations
Create screens
Create an inventory system
Collision detection
Input
Save files
Music
Sound effects

EndRem

SuperStrict

'Initialize graphics mode
Graphics(1024,768)

'Center image handle
AutoMidHandle True

'Seed the timer
SeedRnd(MilliSecs())


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'MUSIC &amp; SOUND FILES
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'IMAGES
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Character Images
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Background Images
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Global titlescreen:TImage = LoadImage("titlescreen.bmp")
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Object Images
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Load Fonts
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		
		
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'GLOBAL VARIABLES / CONSTANTS
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'MAP VARIABLES
Const tileSize:Int = 64		'The size of each tile
Const screenOffset:Int = 32	'A screen offset to provide space for inventory
Const xMap:Int = 50			'Number of tiles horizontally
Const yMap:Int = 50			'Number of tiles vertically
Const xRes:Int = 1024 - (screenOffset*2)	'The visible length of the map horizontally
Const yRes:Int = 768 - (screenOffset*2)		'The visible length of the map vertically

'TILE TYPE VARIABLES

'The id numbers for the different types of floors
Const grass_id:Int = 0
Const water_id:Int = 1
Const forest_id:Int = 2		

Const floor_num:Int = 3									'The total number of types of floors
Global floors:TFloor[] = New TFloor[floor_num]		'An array that holds the different types of floors
Global draw_list:TList = CreateList()				'A list that holds every tile to be drawn

'SCROLLING VARIABLES
Global xScroll:Int = 0		'x coordinate of pixel for scrolling
Global yScroll:Int = 0		'y coordinate of pixel for scrolling

Global map:TTile[,] = New TTile[xMap, yMap]	'The 2-dimensional map array

'GAME FLOW VARIABLES
Global title:Int = 1		'If TRUE, display the title screen
Global play:Int = 0			'If TRUE, execute main game code

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'TYPES
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Character Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TCharacter
			
			Field x:Int		'x coordinate of character
			Field y:Int 	'y coordinate of character
			Field vx:Int	'velocity x component of character
			Field vy:Int	'velocity y component of character
			Field frame:Int	'animation frame of character
			Field health:Int'character health
			Field damage:Int'damage dealt by character
			
			Global CharacterList:TList = CreateList()	'Create a list of characters
			
			Method CheckInput:Int()
			End Method
			
			Method UpdateFrame:Int()
			End Method
			
			Method UpdateX:Int()
			End Method
			
			Method UpdateY:Int()
			End Method
			
			Method CheckCollisions:Int()
			End Method
			
			Function CreateCharacter:TCharacter()
			End Function
			
		End Type
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Object Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TObject
			
			Field x:Int		'x coordinate of object
			Field y:Int		'y coordinate of object
			Field frame:Int	'animation frame of object
			
			Global ObjectList:TList = CreateList()	'Create a list of objects
			
			Method Draw()
			End Method
			
			Function CreateObject:TObject()
			End Function
			
		End Type
		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Tile Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TTile
			
			Field my_floor:TFloor	 'the floor on a particular tile (e.g. grass, snow, etc.)
			'Field my_feature:TFeature'the feature on a particular tile (e.g. rocks, trees, pillars, etc.)
			Field x:Int		'x coordinate of tile in the array
			Field y:Int		'y coordinate of tile in the array
			Field occupants:TList = CreateList()	'A list of objects on the tile
			
			
			'This method will draw an individual tile, starting with the floor of the tile, and then placing any features on the tile
			Method Draw()
				
				my_floor.Draw(x, y)		'Draw the floor on this tile
				'my_feature.Draw(x, y)	'Draw the features on this tile
				
				For Local tObject:TObject = EachIn occupants:TList	'Draw all objects on that particular tile
					tObject.Draw()
				Next
				
			End Method
			
			
			'This function will clear the drawing queue, cycle through the map array and determine what tiles are currently visible,
			'and then add the visible tiles to the drawing queue
			Function UpdateTiles()
				
				draw_list.Clear() 'reset the drawing list
				For Local y:Int = 0 To (yMap:Int - 1)		'For every tile
					For Local x:Int = 0 To (xMap:Int - 1)
						'map[x,y].Update()	'Update the tile
						If visible(x,y)		'If the tile is visible, then add it to the end of the list so the tiles in the foreground are drawn last
							ListAddLast(draw_list:TList, map[x,y])
						End If
					Next
				Next
				
			End Function
			
			
			
			'This function will take all tiles in the drawing queue and draw them
			Function DrawTiles()
				
				'Draw the tiles
				For Local tile:TTile = EachIn draw_list:TList
					tile.Draw()
				Next
				
				'draw a black border around the tiles
				SetColor 0, 0, 0
				DrawRect 0, 0, xres+screenOffset*2, screenOffset
				DrawRect 0, 0, ScreenOffset, yres+screenOffset*2
				DrawRect xres+screenOffset, screenOffset, screenOffset, yres+screenOffset
				DrawRect screenOffset, yres+screenOffset, xres+screenOffset, screenOffset
				
			End Function
			
			
			'This function will create a tile at the specified coordinates, initialize it, give it a floor, and return the tile
			Function Create:TTile(x:Int, y:Int, floor_id:Int)
			
				Local tile:TTile = New TTile
				tile.x = x
				tile.y = y
				tile.my_floor = floors[floor_id]
				
				Return tile
				
			End Function
					
		End Type
		
		
		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Floor Type
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Type TFloor
			
			Field r:Int		'red value for RGB tile
			Field g:Int		'green value for RGB tile
			Field b:Int		'blue value for RGB tile
			Field name:String 'The name of the type of floor
			Field passable:Int 'True if characters can go through it (i.e. grass, stairs, etc.), False if characters cannot pass through it (i.e. pillars, rocks, etc.)
			
			
			'This method will draw a rectangle of the specified size and give it a color (RGB value)
			Method Draw(x:Int, y:Int)
				
				SetColor(r, g, b)
				DrawRect (tile_to_pixel_x(x), tile_to_pixel_y(y), tileSize, tileSize)
				
			End Method
			
			
			'This function will create a floor with the specified RGB value, a name, and whether or not it is passable
			Function Create:TFloor(r:Int, g:Int, b:Int, name:String, passable:Int)
				
				Local a_floor:TFloor = New TFloor
				a_floor.r = r
				a_floor.g = g
				a_floor.b = b
				a_floor.name = name
				a_floor.passable = passable
				
				Return a_floor
				
			End Function
			
		End Type

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'MAIN LOOP
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

LoadMap()						'Loads the map initially


While Not KeyDown(KEY_ESCAPE)	'Press Esc to exit

Cls 						'Clear the scree


If title:Int
	'DrawImage(titlescreen, 512, 384)
	If KeyHit(KEY_ENTER)
		title:Int = 0
		play:Int = 1
	EndIf
EndIf

If play:Int
	If KeyDown(KEY_LEFT) Then xScroll :- 5
	If KeyDown(KEY_RIGHT) Then xScroll :+ 5
	If KeyDown(KEY_UP) Then yScroll :- 5 
	If KeyDown(KEY_DOWN) Then yScroll :+ 5
	
	TTile.UpdateTiles()
	TTile.DrawTiles()



	
EndIf

Delay 10		'Wait 1/10 of a second




Flip			'Flip the buffef)

Wend			'END OF MAIN LOOP





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'FUNCTIONS
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function LoadMap()
		'Parameters: None
		'Returns: Nothing
		'Function should be run at start-up of program.  It loads 
		'the floors array with floor types, and then places the floors
		'in the appropriate locations in the map.
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		Function LoadMap()
			
			floors[grass_id] = TFloor.Create(0, 255, 0, "Grass", True)
			floors[water_id] = TFloor.Create(0, 0, 255, "Water", False)
			floors[forest_id] = TFloor.Create(100, 255, 100, "Forest", False)
			
			
			'Cycle through 2D map array and assign floors to each tile
			For Local x:Int = 0 To (xMap:Int - 1) 
				For Local y:Int = 0 To (yMap:Int - 1)
					'give each tile a random floor
					map[x, y] = TTile.Create(x:Int, y:Int, Rand(0, floor_num:Int - 1))
				Next
			Next
			
		End Function
		
		
		
		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function tile_to_pixel_x
		'Parameters: x is the horizontal coordinate of tile in map array
		'Returns: The x coordinate of the pixel where the tile will be placed
		'Takes x location in array and returns its x coordinate (pixel)
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function tile_to_pixel_x:Int(x:Int)
			Return screenOffset:Int + (tileSize:Int*x:Int) - xScroll:Int
		End Function
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function tile_to_pixel_y
		'Parameters: y is the vertical coordinate of tile in map array
		'Returns: The x coordinate of the pixel where the tile will be placed
		'Takes y location in array and returns its y coordinate (pixel)
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function tile_to_pixel_y:Int(y:Int)
			Return screenOffset:Int + (tileSize:Int*y:Int) - yScroll:Int
		End Function
		
		
		
		Rem
		
		THESE CAN BE USED FOR A TILE EDITOR
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function pixel_to_tile_x
		'Parameters: A pixel x coordinate
		'Returns: The tile number at that x coordinate
		'Takes a pixel and reports that the tile is there.
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function pixel_to_tile_x:Int(pixel:Int)
			Return (pixel:Int - screenOffset:Int + xScroll:Int) / tileSize:Int
		End Function
		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function pixel_to_tile_y
		'Parameters: A pixel y coordinate
		'Returns: The tile number at that y coordinate
		'Takes a pixel and reports that the tile is there.
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function pixel_to_tile_y:Int(pixel:Int)
			Return (pixel:Int - screenOffset:Int + yScroll:Int) / tileSize:Int
		End Function
		
		
		End Rem
		
		
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		'Function visible
		'Parameters: The tile's x, y coordinates
		'Returns: 0 if false, 1 if true
		'Checks if the tile at x, y is visible or not
		''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		Function visible:Int(x:Int, y:Int)
			Local x_pixel:Int = tile_to_pixel_x(x:Int)
			Local y_pixel:Int = tile_to_pixel_y(y:Int)
			Return (x_pixel:Int+tileSize) &gt;= screenOffset:Int And (x_pixel:Int-tileSize) &lt;= xRes:Int And (y_pixel:Int+tileSize) &gt;= screenOffset:Int And (y_pixel:Int-tileSize) &lt;= yRes:Int
		End Function</textarea><br><br>There are changes in the main game loop, the drawtiles function and the visible function. I had to change the delay to a lower number otherwise scrolling was not smooth. I also commented out the titlescreen as I don't have that graphic on my computer :D<br><br>One more thing, it is usually not standard practice to specify a variables type after you have declared it. So when you use Local or Global, put :Int but when you simply use the variable later on, it's not usual to put :Int after it. <br><br></td></tr></table><br>
<a name="1033035"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, yes.  That first bit of code I actually did add in, except under the main character's input because I drew up the animations for the main character yesterday and implemented them, so he was able to walk around the map.  <br><br>I just compiled and ran the amended code, and I must say it is much smoother.  I did notice that delay in displaying a tile when I had implemented the main character that could walk around and scroll in the screen by controlling him, but I thought it was just a limitation I would have to live with.  I do like this smoother scrolling though, it's great.  It will also be really useful when I go to make the map generator.<br><br>On your last comment, I'm glad you said something because this is my first time using SuperStrict (I didn't use SuperStrict or even Strict on my last project...and the code didn't look good), so I didn't really know what it expected.  I more or less just tried to compile what I thought looked good, and then waited for the compiler to yell at me so I could fix any identifier problems.  I see now that in using the variables you don't need the identifiers...they're just expected at declarations of variables, methods, and functions, as well as the parameters to methods and functions.  Thanks for the tip!  And thanks again for looking back at that code and suggesting those fixes, it looks much better now :)<br><br>-muffins <br><br></td></tr></table><br>
<a name="1033040"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >abelian_grape</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> As a matter of fact, I think it might behoove me to just work on the map editor now, finish it, and that way I can quickly throw together some levels.<br><br>-muffins <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
