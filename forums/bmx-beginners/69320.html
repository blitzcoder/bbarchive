<!DOCTYPE html><html lang="en" ><head ><title >recursive array loop?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >recursive array loop?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >recursive array loop?</a><br><br>
<a name="775214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi,<br>i am trying to make a recursive function that loops through a multidimensional array, i've found this PHP code<br><pre class=code>
Function  loop($array,  $parent=''){ 
 
     foreach(  $array  as  $option  =&gt;  $value  ){ 
         If(  $parent  !=  ''  ){ 
             $option  =  $parent  .  '['  .  $option  .  ']'; 
         } 
         If(  is_array($value)  ){ 
             loop($value,  $option); 
         }  Else  { 
             ?&gt; 
     &lt;div&gt;&lt;?php  echo  $option;  ?&gt;  =  &lt;?php  echo  $value;  ?&gt;&lt;/div&gt; 
             &lt;?php 
         } 
     } 

 } 

loop  (  $names  );
</pre><br><br>i am still learning the blitzmax syntax and do not know php very well, so i am struggling with porting the php idea to blitzmax...is it even possible? or is the array handling in blitzmax too different? <br><br></td></tr></table><br>
<a name="775402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why do you need recursion? Don't you know how many dimensiosn your array has, so you can just use nested for-next loops? <br><br></td></tr></table><br>
<a name="775412"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> A problem I can see is that BMax requires you to know the type of array, the arrays in PHP can hold variable values.<br><br>You *could* do it with objects I suppose, but I've no doubt there'll be problems doing it. <br><br></td></tr></table><br>
<a name="775419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> "or is the array handling in blitzmax too different?"<br><br>Short answer: yes. If you describe exactly what it is you're trying to do, there might be alternative methods. <br><br></td></tr></table><br>
<a name="775601"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> in short, what i am trying to achieve is to copy a xml structure to a treeview, and use the treeview to draw objects from attributes in the xml. <br><br></td></tr></table><br>
<a name="777131"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> i got it working, but the code is nasty, i was thinking that if i could nail that recursive loop, i'd learn some ways of array handling that would clean up my code a bit...<br><br>my code at the moment populating a level 5 array:<br><pre class=code>
TL.level[levelCnt].obj[objCnt].subObj1[subObj1Cnt].subObj2[subObj2Cnt].xObj = TL.level[levelCnt].obj[objCnt].subObj1[subObj1Cnt].subObj2[subObj2Cnt].xObj[..xObjCnt+1]
TL.level[levelCnt].obj[objCnt].subObj1[subObj1Cnt].subObj2[subObj2Cnt].xObj[xObjCnt] = node
</pre><br><br>...please let me know if anyone has any alternative methods? <br><br></td></tr></table><br>
<a name="777135"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >QuietBloke</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> funny enough Im doing something similar.<br><br>Im not at my home PC right now so its from memory but in a nutshell I have all my data in a TMap<br><br>a TMap has two parameters so the key is the field name and the value is the value stored as a string value OR another TMap.<br><br>In the procedure to read the TMap<br><br>Procedure processData(inData:TMap)<br><br>it cycles through the keys in inData. <br><br>For readkey:string = eachin inData.keys<br><br>You can then see if the value if the key is another TMap.<br><br> If TMap(getvaluefromkey(inData,readkey)) Then<br>    ' Call myself passing the TMap value<br>    processData(TMap(getvaluefromkey(inData,readkey)))<br>  Else<br>    print inkey + " = " + String(getvaluefromkey(inData,readkey)<br><br>The actual code syntax is probably all wrong Im working from memory but thats roughly it.<br><br>When I get time I was going to change it to just use some sort of TList as a stack so instead of recursive calling I push/pop my state using the stack. <br><br></td></tr></table><br>
<a name="777973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> ah, the TMap returns. i had a feeling it would.<br>Thanks for the TMap info, i think i get where you are going.<br><br>will read up on hashtables and see if can understand better the difference between TLists and TMaps... <br><br></td></tr></table><br>
<a name="777988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> umm, ok, if i can assume that a TMap works like a hash table, TMaps sounds like a better idea than TLists as they like arrays, use a direct lookup thereby being faster.<br><br>is this correct, or am i completely off the rail here? <br><br></td></tr></table><br>
<a name="777997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think It is much more efficient to implement complex tree structures (like xml structures) using your own object design. something like:<br><pre class=code>
Type MyNode
    Field Childs:TList = New TList
    Method AddChild(Node:MyNode)
        if node &lt;&gt; null then
            childs.addlast(Node)
        else
            throw "Null nodes are not allowed"
        endif
    End Method
End Type

Local Root:MyNode = New MyNode
</pre><br><br>You can get all the nodes in the root. You can get any subnode of any node. the same as a tree control. Obviously you may have to implement the CountNodes, GetNodeAtIndex, RemoveNode, etc... but it should be very easy. <br><br></td></tr></table><br>
<a name="778026"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> mmhm, that is not too far from what i've got already...<br>so many ways to achieve this - don't know which one to go for...<br><br>my newbie head is also thinking of a single TList/TMap of types with parentID fields, so that i could retrieve data with matching parentID? sounds like an easy, but maybe not very efficient way....<br><pre class=code>
for local node:myNode = eachin nodelist
    if (node.parentID = 20)
        print node.name
    endif
next
</pre> <br><br></td></tr></table><br>
<a name="778028"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> You will have to deal with some 'seek Id' 'comapre ID' etc for every node. why don't you think of nodes as real objects? I mean, store any child node in its parent node.<br><br>you can do:<br><pre class=code>
Type MyNode
    Field Childs:TList = New TList
    Field Name:String
    Method AddNode:MyNode(Node:MyNode)
        if node &lt;&gt; null then
            childs.addlast(Node)
            return Node
        else
            throw "Null nodes are not allowed"
        endif
    End Method
    Method CountNodes:int()
        return Childs.Count()
    End Method
    Method NodeAtIndex:MyNode(index:int)
         return childs.valueAtIndex(index)
    End Method
End Type

'Create the root node:
Local Root:MyNode = New MyNode

'Create tree nodes in the root:
Local AuxNode:MyNode 
AuxNode = New MyNode
AuxNode.Name = "First Child Node"
Root.AddNode(AuxNode)

AuxNode = New MyNode
AuxNode.Name = "Second Child Node"
Root.AddNode(AuxNode)

AuxNode = New MyNode
AuxNode.Name = "Third Child Node"
Root.AddNode(AuxNode)

'Now we add a subnode to the second node in the root.
AuxNode = root.NodeAtIndex(1)  'We get the second node of the root (the first one is index 0)
AuxNode.AddNode(New MyNode)  'We add it a child node
AuxNode.NodeAtIndex(0).Name = "This is a subnode!"  'We set the child node a name
</pre><br><br>this is a very fast and flexible way to create a complex tree.<br><br>I haven't tested it, becouse I'm not at my computer now, so it can be buggy. <br><br></td></tr></table><br>
<a name="778036"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have a better example, it also produces recursive execution.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type MyNode
	Global PathSeparator:String = "/"
	Field Childs:TList = New TList
	Field Name:String
	Field Parent:MyNode
	Method AddNode:MyNode(Node:MyNode)
		If node &lt;&gt; Null Then
			childs.addlast(Node)
			Node.Parent = Self
			Return Node
		Else
			Throw "Null nodes are not allowed"
		EndIf
	End Method
	Method CountNodes:Int()
		Return Childs.Count()
	End Method
	Method NodeAtIndex:MyNode(index:Int)
		Return MyNode(childs.valueAtIndex(index))
	End Method
	Method RemoveNode(Node:MyNode)
		Node.Parent = Null
		Self.childs.Remove(Node)
	End Method
	
	Method NodePath:String()
		If parent = Null Then Return Name
		Return parent.NodePath() + Self.PathSeparator + Self.name
	End Method
	
	'Summary: This method takes a function and calls that function with every existing node as a parameter.&lt;br&gt;The function has to have the same signature (param1:MyNode)
	Method RecursiveCall(functionnode(node:MyNode))
		functionnode(Self)
		For Local node:MyNode = EachIn childs
			Node.RecursiveCall(functionnode)
		Next
	End Method
End Type

'Create the root node:
Local Root:MyNode = New MyNode
root.Name = "RootNode"
'Create tree nodes in the root:
Local AuxNode:MyNode 
AuxNode = New MyNode
AuxNode.Name = "First Child Node"
Root.AddNode(AuxNode)

AuxNode = New MyNode
AuxNode.Name = "Second Child Node"
Root.AddNode(AuxNode)

AuxNode = New MyNode
AuxNode.Name = "Third Child Node"
Root.AddNode(AuxNode)

'Now we add a subnode to the second node in the root.
AuxNode = root.NodeAtIndex(1)  'We get the second node of the root (the first one is index 0)
AuxNode.AddNode(New MyNode)  'We add it a child node
AuxNode.NodeAtIndex(0).Name = "This is a subnode!"  'We set the child node a name

'now we make a recursove call
Root.recursiveCall PrintPath 'We send the function PrintPath as a parameter. This function will be called recursivelly for every node.

Function PrintPath(Node:MyNode)
	Print "Node path: " + node.NodePath()
End Function
</textarea><br>This example generates a little cross-referencing issue, so be sure to call RemoveNode if you need to delete a node from its parent childs list. If you don't do this, the object will remain in memory, ignored by the GC <br><br></td></tr></table><br>
<a name="778038"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> putting a addNode method in the type, seems like a good idea - i think that will clean up my code a lot.<br><br>and now if i can find a clever way to jump backwards as my recursive leafs are dying i think i am all set.<br>maybe if i keep the level history in a array or something, i'll be able to jump from an outer leaf all the way back to root, hmmm <br><br></td></tr></table><br>
<a name="778042"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kimgar</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> ah, beautiful ziggy! i just saw your last post - recursive execution, that sounds like exactly what i need!<br><br>thanks a lot ziggy, i have to rush off now, but i will have a look at your code in the morning, and see what i can make out of it - it looks very promising, thanks! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
