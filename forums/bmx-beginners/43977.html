<!DOCTYPE html><html lang="en" ><head ><title >how fast to 1 Billion ?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >how fast to 1 Billion ?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >how fast to 1 Billion ?</a><br><br>
<a name="490520"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> How fast does your BMAX system count to 1 billion?<br><br>sample code:<br>[code box]<br>Strict<br><br> Global a:Int = 0<br>  <br> Global start:Int = MilliSecs(),finish:Int<br><br> While( a &lt; 1000000000)<br><br>    a = a + 1<br>    <br> Wend<br><br> finish = MilliSecs()<br><br> Print "0 to 1 Billion in  " + (finish - start) + " milliseconds"<br><br>[/code box] <br><br></td></tr></table><br>
<a name="490523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> see if I can do this code bos thing right <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict 

Global a:Int = 0 

Global start:Int = MilliSecs(),finish:Int 

While( a &lt; 1000000000) 

a = a + 1 

Wend 

finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds" 
</textarea> <br><br></td></tr></table><br>
<a name="490524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is the result with my system <br><br>Process complete<br>C:/BlitzMax/BlitzMaxCore104/tmp/untitled1.exe<br>0 to 1 Billion in 5875 milliseconds<br><br>Process complete<br><br>This is great ... and old c++ compiler (borland ver 4.52)<br>I compilied a test for was running 7 seconds. <br><br>Ran a C++ compiled program at work on a linux system <br>we have which are dual 3.2Gig Xeon processors that <br>cranked out 0 - 1.0e+9 in .6 seconds <br><br></td></tr></table><br>
<a name="490527"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoJo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> With my slow system it took:<br>0 to 1 Billion in 125833 milliseconds<br><br>PII 400mhz/256mb ram/geforce4 mmx 460 <br><br></td></tr></table><br>
<a name="490528"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got<br><br>0 to 1 Billion in 18543 milliseconds<br><br>DEBUG ON<br><br>AthlonXP3000(@...) 512ram<br>Radeon9600 256meg <br><br></td></tr></table><br>
<a name="490538"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Booticus</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got<br><br>Process complete<br>C:/BlitzMax/tmp/untitled1.exe<br>0 to 1 Billion in 1723 milliseconds<br><br>Process complete<br><br>P4 2.4 ghz<br>512ram <br><br></td></tr></table><br>
<a name="490540"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1 Billion in 2368 milliseconds (normal)<br><br>0 to 1 Billion in 19334 milliseconds (debug, what a difference!)<br><br>p4 HT 3ghz, 512mb<br>(office pc, so maybe there are some less-than-optimal components alltough the proc is quite cool... i'm at work now) <br><br></td></tr></table><br>
<a name="490543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1 Billion in 2952 milliseconds on Athlon 2800+ <br><br></td></tr></table><br>
<a name="490546"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> jojo... I would think you must have been in debug mode with that slow of time,  Turn off debug and see if you get a better time, I would be interested in what you get with debug off too Col :) <br><br></td></tr></table><br>
<a name="490548"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Muttley</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're slowing yourself down there using Globals when they're not needed.  ;)<br><br>Try this:<br><pre class=code>Strict 

Local a:Int = 0 

Local start:Int = MilliSecs(),finish:Int 

While( a &lt; 1000000000) 

a = a + 1 

Wend 

finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds" </pre><br>My machine: Dell Latitude C840, Windows XP SP2, 1.8GHz P4, 768MB Mem<br><br>Original version:<br>Debug mode: 33132ms<br>NoDebug mode: 2340ms<br><br>Local variable version:<br>Debug mode: 34155ms<br>NoDebug mode: 876ms<br><br>Muttley <br><br></td></tr></table><br>
<a name="490550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anybody think they can beat those dual Xeon processors <br>that cranked out (C++ code) a blistering 680 milliseconds <br><br>... ah technology today -- think about it ... counting to <br> <br>1 billion before you could say the word 'one' <br><br></td></tr></table><br>
<a name="490553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Local did drop me another 2.5 seconds on my 1Ghz Athlon <br><br>Process complete<br>C:/BlitzMax/BlitzMaxCore104/tmp/untitled1.exe<br>0 to 1 Billion in 3114 milliseconds<br><br>Process complete<br><br>Thanks, <br><br></td></tr></table><br>
<a name="490555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> what I dont understand is why my old borland C++ compilier <br>is taking 7 seconds ... I have all the optimized settings set as far as I know and her is the code. <br><br>[codebox}<br>#include &lt;iostream.h&gt;<br>#include &lt;time.h&gt;<br><br>int main()<br>{<br>	long a = 0;<br>	int seconds = 0;<br>	time_t  start,end;<br>	cout &lt;&lt; "Staring my count to 1 billion\n";<br>	start = time(NULL);<br><br>	do<br>	{<br>	a++;<br>	} while (a &lt; 1000000000);<br><br>	end = time(NULL);<br>	seconds = end - start;<br>	cout &lt;&lt; "0 to 1 billion is complete in " &lt;&lt; seconds &lt;&lt; " seconds\n";<br>	return 0;<br>}<br>[/codebox]<br><br>anyway from the looks of it ... BMAX is great :) <br><br></td></tr></table><br>
<a name="490565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skn3</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> btw, you can edit your posts. See the top right of each posting, there is an "edit" link.<br><br>Here is my result<br><div class="quote"> 0 to 1 Billion in 602 milliseconds <br></div> <br><br></td></tr></table><br>
<a name="490609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GameKing</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Strict adds overhead<br>compiler defaults to int<br>for/next faster then while/wend<br>calculate before print<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
 
Local start = MilliSecs(), a = 0, finish

For a = 0 To 1000000000 ; Next

finish = (MilliSecs() - start)

Print "0 to 1 Billion in " + finish + " milliseconds"
</textarea><br><br>Enjoy <br><br></td></tr></table><br>
<a name="490610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jkrankie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compiling:untitled1.bmx<br>Linking:untitled1<br>Executing:untitled1<br>0 to 1 Billion in 5092 milliseconds<br>Done.<br><br>on a 700mhz g4 imac <br><br></td></tr></table><br>
<a name="490622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks to the suggestion of using GLOBAL variables instead of LOCAL ones I got the idea of optimizing this loop a little further. I read somewhere that FOR .. = .. UNTIL .. would be faster than using FOR .. = .. TO .., so I figured this might apply to other loops as well. Also we can do x:+1 instead of x = x + 1. I put it all togehter in a (rather dirty, I admit) program, and the results were quite interesting.<br><br>I will refer to FOR .. = .. TO .. / NEXT as FOR-TO and to FOR .. = .. UNTIL .. / NEXT as FOR-UNTIL from here on.<br><br>Here are the GLOBAL vs LOCAL results:<br><br>WHILE loop and x = x + 1...<br> LOCAL: 548 milliseconds<br> GLOBAL: 2374 milliseconds<br><br>REPEAT loop and x = x + 1...<br> LOCAL: 545 milliseconds<br> GLOBAL: 2365 milliseconds<br><br>WHILE loop and x :+ 1...<br> LOCAL: 514 milliseconds<br> GLOBAL: 2032 milliseconds<br><br>REPEAT loop and x :+ 1...<br> LOCAL: 816 milliseconds<br> GLOBAL: 2034 milliseconds<br><br>FOR-TO loop<br> LOCAL: 524 milliseconds<br> GLOBAL: 2023 milliseconds<br><br>FOR-UNTIL loop...<br> LOCAL: 512 milliseconds<br> GLOBAL: 2039 milliseconds<br><br>As it was already stated GLOBAL variables are *very much* slower than LOCAL ones. <br><br><br>I will now compare the different aspects in the WHILE and REPEAT loops.<br>These are the same results as before (exept FOR/NEXT loops), but grouped otherwise to make it easy to compare the difference between x = x + 1 and x:=1<br><br>Using LOCAL, WHILE loop<br> x=x+1: 548 milliseconds<br> x:+1: 514 milliseconds<br><br>Using GLOBAL, WHILE loop<br> x=x+1: 2374 milliseconds<br> x:+1: 2032 milliseconds<br><br>Using LOCAL, REPEAT loop<br> x=x+1: 545 milliseconds<br> x:+1: 816 milliseconds<br><br>Using GLOBAL, REPEAT loop<br> x=x+1: 2365 milliseconds<br> x:+1: 2034 milliseconds<br><br>You can see that using the shortcut (x:+1) is a bit faster than the old way, except for the LOCAL, REPEAT-loop thingy. This is a bit weird, but of course anything may be influenced by other processes. There were no programs active when I ran this test, but windows keeps a lot of background processes. It might be a nice thing to run this test several times to get a better avarage.<br><br>The first time I ran this thing I had one process taking up 100% of one virtual processor (p4 HT) and then the x:+1 was more than twice as fast! Don't know what exactly causes this.<br><br><br>Next thing up is the comparisation between WHILE and REPEAT loops. Of couse I'm using the same results.<br><br>Using LOCAL and x = x + 1...<br> WHILE: 548 milliseconds<br> REPEAT: 545 milliseconds<br><br>Using GLOBAL and x = x + 1...<br> WHILE: 2374 milliseconds<br> REPEAT: 2365 milliseconds<br><br>Using LOCAL and x :+ 1...<br> WHILE: 514 milliseconds<br> REPEAT: 816 milliseconds<br><br>Using GLOBAL and x :+ 1...<br> WHILE: 2032 milliseconds<br> REPEAT: 2034 milliseconds<br><br>As you see there is not much difference, exept for the LOCAL and x:+1. This result showed odd earlier.<br><br>Now we got the WHILE and REPEAT loops finished, let's see how the FOR loops behave!<br><br>Since we've already seen the difference between GLOBAL and LOCAL variables the only thing left to compare is FOR-TO and FOR-UNTIL. Behold:<br><br>Using LOCAL variables<br> FOR-TO: 524 milliseconds<br> FOR-UNTIL: 512 milliseconds<br><br>Using GLOBAL variables<br> FOR-TO: 2023 milliseconds<br> FOR-UNTIL: 2039 milliseconds<br><br>There is no clear difference between these two, but the difference that there is is rather small.<br><br><br>As a last thing to compare I have for you are all the results, ordered by speed.<br><br>Using LOCAL, FOR-UNTIL loop: 512 milliseconds<br>Using LOCAL, WHILE loop and x :+ 1: 514 milliseconds<br>Using LOCAL, FOR-TO loop: 524 milliseconds<br>Using LOCAL, REPEAT loop and x = x + 1: 545 milliseconds<br>Using LOCAL, WHILE loop and x = x + 1: 548 milliseconds<br>Using LOCAL, REPEAT loop and x :+ 1: 816 milliseconds<br>Using GLOBAL, FOR-TO loop:  2023 milliseconds<br>Using GLOBAL, WHILE loop and x :+ 1: 2032 milliseconds<br>Using GLOBAL, REPEAT loop and x :+ 1: 2034 milliseconds<br>Using GLOBAL, FOR-TO loop: 2039 milliseconds<br>Using GLOBAL, REPEAT loop and x = x + 1: 2365 milliseconds<br>Using GLOBAL, WHILE loop and x = x + 1: 2374 milliseconds<br><br>The conclusion so-far is rather easy: use FOR-UNTIL where possible ;)<br><br>These results are, however, statistically of not-so-much use, because it was just one test I ran. If I can find some time tonight (now I really need to get back to my database since I don't suppose my boss would like to see me toying with blitz all day ;) ) to do this more properly.<br><br>Of couse I won't let you go home without some source. It's a bit dirty and hastly-done, but clear.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Rem

	this is a rather dumb but interresting example to benchmark various ways to do loops 
	the loops differ on the following subjects:
	
	- the use of LOCAL and GLOBAL variables
	- WHILE .. / WEND or REPEAT / UNTIL .. loops
	-  in case of WHILE / WEND or REPEAT / UNTIL loops the use of
	   the old-fashioned x = x + 1 or the new shortcut x:+ 1
	- FOR .. = .. TO .. / NEXT or FOR .. = .. UNTIL .. / NEXT loops
	
	it is of course based on the benchmark that this topic started with and
	a few suggestions that were made.

EndRem

Strict 

Local l:Int = 0 					'l for local loop
Global g:Int = 0					'g for global loop
Local finish:Int					'moved finish declaration up so it won't consume any ticks while benchmarking
Local start:Int					'split declaration and the assigning of millisecs() so it looks a bit cleaner


'local variable, while loop, x = x + 1
Print "Using LOCAL, WHILE loop and x = x + 1..."

start = MilliSecs()
While (l &lt; 1000000000) 
 l = l + 1 
Wend 
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'global variable, while loop, x = x + 1
Print "Using GLOBAL, WHILE loop and x = x + 1..."

start = MilliSecs()
While (g &lt; 1000000000) 
 g = g + 1 
Wend 
finish = MilliSecs()

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"
Print


l = 0	'reset variables
g = 0


'local variable, repeat loop, x = x + 1
Print "Using LOCAL, REPEAT loop and x = x + 1..."

start = MilliSecs()
Repeat 
 l = l + 1 
Until (l = 1000000000)
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'global variable, repeat loop, x = x + 1
Print "Using GLOBAL, REPEAT loop and x = x + 1..."

start = MilliSecs()
Repeat 
 g = g + 1 
Until (g = 1000000000) 
finish = MilliSecs()

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"
Print


l = 0	'reset variables
g = 0


'local variable, while loop, x :+ 1
Print "Using LOCAL, WHILE loop and x :+ 1..."

start = MilliSecs()
While (l &lt; 1000000000) 
 l:+ 1 
Wend 
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'global variable, while loop, x :+ 1
Print "Using GLOBAL, WHILE loop and x :+ 1..."

start = MilliSecs()
While (g &lt; 1000000000) 
 g:+ 1 
Wend 
finish = MilliSecs()

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"
Print


l = 0	'reset variables
g = 0


'local variable, repeat loop, x :+ 1

Print "Using LOCAL, REPEAT loop and x :+ 1..."

start = MilliSecs()
Repeat 
 l :+ 1 
Until (l = 1000000000)
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'global variable, repeat loop, x :+ 1

Print "Using GLOBAL, REPEAT loop and x :+ 1..."

start = MilliSecs()
Repeat 
 g :+ 1 
Until (g = 1000000000)
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'start for/next loops


'local variable, for-to loop
Print "Using LOCAL, FOR-TO loop"

start = MilliSecs()
For l = 0 To 1000000000
Next
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'global variable, for-to loop

Print "Using GLOBAL, FOR-TO loop..."

start = MilliSecs()
For g = 0 To 1000000000
Next
finish = MilliSecs()

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"
Print


'local variable, for-until loop
'because this is an until-loop, we need to loop until 1000000000 + 1 to be precise

Print "Using LOCAL, FOR-UNTIL loop..."

start = MilliSecs()
For l = 0 Until 1000000001
Next
finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
Print


'global variable, for-until loop, x = x + 1
'because this is an until-loop, we need to loop until 1000000000 + 1 to be precise

Print "Using GLOBAL, FOR-TO loop..."

start = MilliSecs()
For g = 0 Until 1000000001
Next
finish = MilliSecs()

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"
Print

</textarea><br><br>gameking: thanks for your suggestions, I will use them when I continue testing, alltough calculating before print and the declaration won't influence these benchmarks of course, because they happen 'outside' the time-tested code.<br>If 'strict' add overhead while executing I can't tell, but it's worth a try :) <br><br></td></tr></table><br>
<a name="490658"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Takuan</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting, didnt know Local vs. Global does make such a difference.<br>What about do the same but in a function and call that function a billion times.<br>Local is then generated and killed every function call?<br>If so, maybe its slower using locals?<br>Just a dumb question.. <br><br></td></tr></table><br>
<a name="490684"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Takuan: of course that is slower, because there is much overhead. first you call a function, which creates a new local variable and then distroys it and then must return to the main program.<br>I wonder however how you would implement this test which actually does the same thing but requires such a function to do it's job..<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
local l:int

while(l&lt;1000000000)
  l = update(l)
wend

function update(i:int)
  local j = 1
  return i + j
endfunction
</textarea><br><br>that doesnt compare to the other way people tried before in this topic<br><br>however, of course we can benchmark this whole variable construction/destruction thing:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Local start:Int
Local finish:Int
Local i:Int


start = MilliSecs()
For i = 0 To 1000000000
  func_with_var
Next
finish = MilliSecs()

Print finish-start

start = MilliSecs()
For i = 0 To 1000000000
  func_without_var
Next
finish = MilliSecs()

Print finish-start

Function func_with_var()
  Local dummy = 1
EndFunction

Function func_without_var()
EndFunction

</textarea><br><br>This actually gives some odd results to me, the left column is the time of calling the function with the variable, the right column is the time of calling the other (empty) function. And I'm really not mistaken... anyone can shine any light on this?<br><br>6031 - 6731<br>6211 - 7305<br>6119 - 7256<br>6026 - 6817<br>6029 - 6992<br><br>edit: maybe I misunderstood you and were you wondering how a function which creates a local variable would compare with another function which calls a global variable. Got these results:<br><br>left = local var, mid = global var, right = no var<br><br>6059 - 6856 - 6789<br>6614 - 6689 - 6677<br>6002 - 6699 - 6830<br>6625 - 6779 - 6736<br>6000 - 7277 - 6665<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Local start:Int
Local finish:Int
Local i:Int

Global g:Int

For cnt = 1 To 5

start = MilliSecs()
For i = 0 To 1000000000
  func_with_l_var
Next
finish = MilliSecs()

Print finish-start

start = MilliSecs()
For i = 0 To 1000000000
  func_with_g_var
Next
finish = MilliSecs()

Print finish-start

start = MilliSecs()
For i = 0 To 1000000000
  func_without_var
Next
finish = MilliSecs()

Print finish-start

Print 
Next
End

Function func_with_l_var()
  Local dummy = 1
EndFunction

Function func_with_g_var()
  g = 1
EndFunction

Function func_without_var()
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="490709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks on the note on how to edit... not sure why but I <br>wasn't seeing the edit link but now I am.. I definitiely need it because my fat fingers always get in the way and my brain obviously doen't know how to control them. <br><br></td></tr></table><br>
<a name="490720"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I get 1288 ms<br>Using Muttley's version I get 492 ms.<br><br>Pentium 4 HT, 3.2Ghz 1024Mb RAM <br><br></td></tr></table><br>
<a name="490727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Curtastic</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> To make it more accurate, you should put a delay at the beginning.<br><br><pre class=code>
Strict 

Local a:Int = 0 

Local start:Int 
Local finish:Int 

Delay 500

start = MilliSecs()

While( a &lt; 1000000000) 

a = a + 1 

Wend 

finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
</pre> <br><br></td></tr></table><br>
<a name="490731"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pongo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Curious as to whether or not blitzmax does this any faster than Blitz3d. <br><br>I do not have blitzmax, but I get 1778 with blitz3d<br><br>Work machine: (wish it was home machine)<br>Dual 3.4 Xeon<br>4Gig Ram <br><br></td></tr></table><br>
<a name="490732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> and what did you get with bmx then? would be way easier to compare if you posted that as well :) <br><br></td></tr></table><br>
<a name="490743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdrianT</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> I gert between 0 to 1 Billion in 2713 and 2834 milliseconds without debug in the various versions of code I tried. That was on a 4 year old Athlon 1200 <br><br></td></tr></table><br>
<a name="490811"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rod49:<br><br>Using the first program in this thread, I got-<br>0 to 1 Billion in 1514 milliseconds<br><br>with DEBUG OFF. Blimey!!<br><br>And using the program by GameKing:<br>0 to 1 Billion in 995 milliseconds<br>DEBUG OFF<br>Nice.<br><br>And the code by Coorrae:<br>0 to 1 Billion in 974 milliseconds<br>DEBUG OFF <br><br></td></tr></table><br>
<a name="490868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> using coorea's which is the most accurate I get 918 on my new comp i built last week &lt;:-)<br><br>AMD Athalon64 3500+<br>1GB HyperX RAM<br>Radeon X700 Pro 256mb <br><br></td></tr></table><br>
<a name="490874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Najdorf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> how fast to a billion? Gimme a few years and I'll make it... $:-)$ <br><br></td></tr></table><br>
<a name="490896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoJo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, did it with debug off.<br>0 to 1 Billion in 18151 milliseconds<br><br>PII 400mhz 128mb ram <br><br></td></tr></table><br>
<a name="490936"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Panno</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Building untitled1<br>Compiling:untitled1.bmx<br>flat assembler  version 1.51<br>3 passes, 2332 bytes.<br>Linking:untitled1.exe<br><br>Process complete<br>K:/BMAX/tmp/untitled1.exe<br>0 to 1 Billion in 3959 milliseconds<br><br>Process complete <br><br></td></tr></table><br>
<a name="490969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  how fast to a billion? Gimme a few years and I'll make it... $:-)$  <br></div><br>Of course you will then remember how I've always been your very best friend and such, right? =P <br><br></td></tr></table><br>
<a name="490981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Najdorf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Of course, my friend, now get back working! <br><br></td></tr></table><br>
<a name="491567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> work means cash... see if I get there first $-) <br><br></td></tr></table><br>
<a name="494478"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Will</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1bil in 1015 millesecs (normal)<br>0 to 1bil in 18476 millesecs (debug)<br><br>wow what a difference!<br><br>Dual 2ghz G5 <br><br></td></tr></table><br>
<a name="494500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoJo</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> From Coorrea code:<br><br>Debug off<br>0 to 1 Billion in 5189 milliseconds<br><br>Debug on<br>0 to 1 Billion in 118419 milliseconds<br><br>PII 400 mhz 256mb ram <br><br></td></tr></table><br>
<a name="494501"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rod54</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well this turned out to be an interesting link to see all the difference in times by machines etc... <br><br>thanks for all the input. <br><br></td></tr></table><br>
<a name="494510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MattVonFat</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thought my computer was really slow at first but the 2nd modification ran at 623millisecs! <br><br></td></tr></table><br>
<a name="494691"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rdodson41</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Macintosh duel G4<br><br>3065 secs in Bmx with this prog:<br><br><pre class=code>
start=MilliSecs()
For i=0 To 1000000000
Next
finish=MilliSecs()-start
Print finish
End
</pre> <br><br></td></tr></table><br>
<a name="494704"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Uber Lieutenant</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1 Billion in 3708 milliseconds<br><br>I didn't expect a good result like that from my laptop.<br><br>Windows XP Sp1 (Sp2 is annoying)<br>Intel Pentium 4m 1.3GHz<br>256MB SDRAM<br>ATi Mobility Radeon 9000 (64MB VRAM) <br><br></td></tr></table><br>
<a name="494862"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gavin Beard</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1 Billion in 4073 milliseconds (norm)<br>0 to 1 Billion in 28799 milliseconds (debug) <br><br></td></tr></table><br>
<a name="494893"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rich your system is cool *rofl*<br><br>1454 ms norm<br>5112 ms debug<br><br>Pentium - M ( 1.5 Ghz, old P-M with 1MB 2nd lvl cache ) <br><br></td></tr></table><br>
<a name="494945"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using Coorrae's code:<br><br>0 to 1 Billion with debug ON: 26165 milliseconds<br>0 to 1 Billion with debog OFF: 725 milliseconds <br><br></td></tr></table><br>
<a name="495100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Punksmurf</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did this test on a friends' computer lateley and he wrote the same thing in c++. I don't remember the exact details of what we did but I think it was a for-to loop and using local integers. He turned on al optimization options for his compiler (don't know which) (of course he did, it'd be stupid to leave them off right?) and c++ turned out to be 10-20 millisecs faster than bmx. total time was about 2500ms. <br><br></td></tr></table><br>
<a name="495430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LeisureSuitLurie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> 'Original code<br>0 to 1 Billion in 15162 milliseconds<br>'With locals<br>0 to 1 Billion in 5034 milliseconds<br>'With locals and a for-next loop<br>0 to 1 Billion in 5409 milliseconds<br>'With locals and a repeat-until a=1000000000<br>0 to 1 Billion in 5208 milliseconds<br><br>Gave up on debug mode, as it was easily taking over a minute (?!?!?)<br><br>700mhz G4 iMac<br><br>I wonder why while wend is faster than the other loops...<br><br><br><br>@Rich A Dual G4 what? <br><br></td></tr></table><br>
<a name="496458"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gandalfisgeordie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using Coorrae's code: <br><br>Building untitled2<br>Executing:untitled2.exe<br>0 to 1 Billion in 462 milliseconds<br><br>Process complete<br><br>P4/ 3.4Ghz <br><br></td></tr></table><br>
<a name="498069"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sarge</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got 550 with Muttley's code <br><br></td></tr></table><br>
<a name="547052"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sensenwerk</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1 Billion in 793 milliseconds <br><br>System: XP 2.09 GHz, 1 GB Ram<br><br>using this code:<br><br><br>Strict <br><br>Local start:Int = MilliSecs(),finish:Int <br><br>For Local a:Int = 0 Until 1000000000<br>a:+1 <br>Next<br><br>finish = MilliSecs() <br><br>Print "0 to 1 Billion in " + (finish - start) + " milliseconds" <br><br></td></tr></table><br>
<a name="547129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Snarkbait</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0 to 1 Billion in 548 milliseconds<br><br>Looks like p4 of 3ghz and above are very,very fast. ;)<br><br>p4, 3.2Ghz, 1GB dual channel RAM <br><br></td></tr></table><br>
<a name="547143"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arcadenut</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I've optimized the code....<br><br><pre class=code>
Strict 

Local start:Int = MilliSecs(),finish:Int 

For Local a:Int = 0 Until 1000000000
a:+1000000000 
Next

finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds" 
</pre><br><br>Does it in 0 Milliseconds... <br><br></td></tr></table><br>
<a name="547284"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Original code, 10467 millisecs. Mac osX panther 1GHz G4 256mb ram<br><br><br>I also got 3498 millisecs with muttley's version<br><br>With arcadenut's version, adding 1 each loop not a billion, I get 1734 millisecs. <br><br></td></tr></table><br>
<a name="547455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AarbronBeast</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> With Rod49s original code, I get:<br><br>0 to 1 Billion in 39684 milliseconds (Debug)<br>0 to 1 Billion in 17584 milliseconds (Release)<br><br>Using Muttley's "Local Variable" version, I get:<br><br>0 to 1 Billion in 39262 milliseconds (Debug)<br>0 to 1 Billion in 1308 milliseconds (Release)<br><br>Are these numbers correct?  They seem weird compared to the others on here.<br><br>Mac OS X 10.4<br>PowerMac G5 Dual 2.3 GHz, 1Gb Ram <br><br></td></tr></table><br>
<a name="547511"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >taumel</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>i get 193ms on a p4 2.8gig with this...<br><br><pre class=code>
Local a=0,timAkt=0,timAnf=MilliSecs()

While(a&lt;1000000000) 
	a:+1;a:+1;a:+1;a:+1;a:+1;a:+1;a:+1;a:+1
Wend 

timAkt=MilliSecs()-timAnf
Print "From 0 to "+a+" (a Billion) in "+timAkt+" milliseconds." 
</pre><br>The interesting part was to compare this to other tools. Some of them took ages.<br><br><br>Greetings,<br><br>taumel <br><br></td></tr></table><br>
<a name="559169"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ibmurai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got:<br><br>0 to 1 Billion in 8530 milliseconds<br><br>With my iBook G4 1.2GHz<br><br>(YAY! First post ever! Bought BlitzMax yesterday) <br><br></td></tr></table><br>
<a name="559186"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RiK</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1492 ms with locals, about ten times slower with globals!<br><br>1492 - wasn't that the year that Columbus bumped into the US whilst out looking for the east indies? <br><br></td></tr></table><br>
<a name="559372"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oldtimefun</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using rod49's code:<br>0 to 1 Billion in 3606 milliseconds<br>0 to 1 Billion in 36192 milliseconds(debug)<br><br>Using Coorrae's code:<br><br>0 to 1 Billion in 2100 milliseconds<br>0 to 1 Billion in 35404 milliseconds(debug)<br><br>Using taumel 's code:<br><br>0 to 1 Billion in 794 milliseconds<br>0 to 1 Billion in 5942 milliseconds(debug)<br><br>with athlon xp2500 <br><br></td></tr></table><br>
<a name="559872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tom</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1446 with Coorraes code<br><br>Specs below <br><br></td></tr></table><br>
<a name="559954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nawi</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> I get 2 seconds on Blitzmax and 3 seconds on c++ <br><br></td></tr></table><br>
<a name="560044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TeraBit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> 1737 with Coorraes code <br><br></td></tr></table><br>
<a name="560158"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiering</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Coorrae's code becomes about 10% faster if you declare <b>a</b> right before the loop. Looking at the assembly, this compiles to <b>add eax,1</b> instead of <b>add esi,1</b>. I would have expected <b>a :+ 1</b> to be faster too, but it compiles to the same <b>add eax,1</b> (instead of <b>inc eax</b>, which I think would be faster).<br><br><pre class=code>
Strict 

Local start: Int 
Local finish: Int 

Delay 500

start = MilliSecs()

Local a: Int = 0
While (a &lt; 1000000000) 
  a = a + 1 
Wend 

finish = MilliSecs() 

Print "0 to 1 Billion in " + (finish - start) + " milliseconds"  
</pre> <br><br></td></tr></table><br>
<a name="560255"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WendellM</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> With Wiering's code, on my Athlon 3000+ under Win XP Pro SP2:<br><br><div class="quote"> 1465 BlitzMax 1.10 <br></div><br><br>With the required, minor adjustments:<br><br><div class="quote"> 2061 Blitz3D 1.90 <br></div><br><br>In both BlitzMax and Blitz3D, it makes no difference using While/Wend or For/Next, or whether the program was run in the IDE or as an Exe (both with no debug).<br><br><br>Curious, I tried my older, Microsoft Basics (code adjusted as needed).  With them, there are differences between running in their IDE or as a compiled Exe, as well as using a While/Wend loop or a For/Next one.  <br><br>I was surprised to see that compiled VB 5 (1997) is slightly faster than Blitz3D (though not as fast as BlitzMax):<br><br><div class="quote"> In IDE:<br>67343 Visual Basic 5.0 SP3 (While/Wend)<br>12343 Visual Basic 5.0 SP3 (For/Next)<br><br>Compiled as Exe:<br>1921 Visual Basic 5.0 SP3 (While/Wend)<br>1734 Visual Basic 5.0 SP3 (For/Next) <br></div><br><br>And then there's good ol' QuickBASIC from 1988 &lt;g&gt;:<br><br><div class="quote"> In IDE:<br>109296 QuickBASIC 4.5 (While/Wend)<br>51132 QuickBASIC 4.5 (For/Next)<br><br>Stand-alone Exe (no debug):<br>33007 QuickBASIC 4.5 (While/Wend)<br>32507 QuickBASIC 4.5 (For/Next) <br></div> <br><br></td></tr></table><br>
<a name="561080"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rdodson41</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> 3037 with duel G4's <br><br></td></tr></table><br>
<a name="561107"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WendellM</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> On my newly-acquired 933 MHz G4 with OS 10.3.9, I get 3330 with Wiering's code (though I didn't observe moving a's declaration to have any effect either on Mac or PC). <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
