<!DOCTYPE html><html lang="en" ><head ><title >deleting objects from lists</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >deleting objects from lists</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >deleting objects from lists</a><br><br>
<a name="995819"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >yzzm</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> how would you go about deleting an object from a list that may represent an enemy that has been destroyed? <br><br></td></tr></table><br>
<a name="995823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> tlist.remove <br><br></td></tr></table><br>
<a name="995827"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Or keep the TLink which is returned when you add it to the list in the first instance. Then it's<br><br>Link.Remove() <br><br></td></tr></table><br>
<a name="995865"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't seem to get the tlist.remove method to work, what am I doing wrong?<br><pre class=code>
Type point
Global _list:TList=New TList
	
	Method New()
		Add(_list)
	End Method

	Method Add(t:TList)
		t.Addlast(Self)
	End Method

	Field x:Int,  y:Int	'the point's coordinates
	Field selected:Int	'if the point is part of the current selection
	
End Type

</pre><br><br>this is the part of the code where points are deleted<br><pre class=code>
Function Delete_Selection()
	For p:point=EachIn p._list
		If p.selected=1
			p._list.remove(p)
		EndIf
	Next
End Function
</pre> <br><br></td></tr></table><br>
<a name="995867"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  this is the part of the code where points are deleted <br></div><br>It's probably not a good idea to remove from a list while you are iterating through it.<br><br>FYI <br><br></td></tr></table><br>
<a name="995868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It's probably not a good idea to remove from a list while you are iterating through it. <br></div><br>=\ Hrm, I'm at a loss for how else I could do it. Maybe I could make another list... this is getting complicated.<br><br>EDIT: This is what I came up with, I'm still failing.<br><pre class=code>
Function Delete_Selection()
Local selection:TList=New TList
	For p:point=EachIn p._list
		If p.selected=1
			p.Add(selection)
		EndIf
	Next
	For p:point=EachIn selection
		p._list.remove(p)
	Next
	selection.Clear()
End Function
</pre> <br><br></td></tr></table><br>
<a name="995872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> in post #4 the for line should be like this:<br><pre class=code>
	For p:point=EachIn point._list
</pre><br><br>although, I thing your problem is where you set the "selected". it might be what is failing to set the object for removal. <br><br></td></tr></table><br>
<a name="995873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, I'll try that. <br><br></td></tr></table><br>
<a name="995875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I recommend you start using strict or superstrict it will help you solve a lot of problems in the future. <br><br></td></tr></table><br>
<a name="995877"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jkrankie</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> i usually remove things when iterating through TBH. Unless your objects are changing things outside of the list in some meaningful way you shouldn't have too much of a problem. I don't tend to use static fields in types though...<br><br>Cheers<br>Charlie <br><br></td></tr></table><br>
<a name="995878"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I recommend you start using strict or superstrict it will help you solve a lot of problems in the future. <br></div><br><br>You mean like this?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
'=============================
Graphics 800, 600

'=========CONSTANTS==========
Const OVERDIS:Float=20
Const divisions:Int=16				'how many parts 360 degrees is divided up into ()
Const toolamount:Int=3
Global tips$[]=["Select and delete.","Add a point to a line.","Draw a line."]
'=============================


'==========TOOL ID's==========
Const SELECTTOOL:Int=0, POINTTOOL:Int=1, DRAWTOOL:Int=2
'=============================


'===========GLOBALS===========
Global mx:Int,  my:Int			'the mouse's position
Global cx:Float,  cy:Float		'stores the output of the Lines_Cross() function
Global tool:Int=2				'which tool is selected
Global mindis:Float
'=============================
Global precedence:Int			'whether or not the mouse is over a point (points take precedence over guide segments)
'=============================
Global shift:Int				'whether or not shift is held down
'=============================
Global mode:Int				'only used for Draw tool
Global startpoint:point		'...
Global endpoint:point=New point			'...
'=============================



'============TYPES============
Type guide				'guides are lines on which points and line segments lie
Global _list:TList=New TList
Field _link:TLink

	Method New()
		_link=_list.Addlast(Self)
	End Method
	
	
	Method Define(ang:Int,  gm:Float,  gb:Int,  gv:Int)
		angle=ang
		m=gm
		b=gb
		v=gv
		p_list=New TList
	End Method


	Field angle:Int	
	Field m:Float, b:Float		'y=mx+b	(b functions as the line's x-value when it is vertical)
	Field v:Int				'vertical y/n
	Field p_list:TList		'each guide contains a list of which points are on it,  ordered from left to right, or top to bottom
	Field p:point[99]			'the same list,  in array form (necessary for segment management)
	Field amt:Int			'length of the array
	Field seg:Int[98]			'whether or not the drawline exists for a given segment
	Field dis:Float			'distance to the mouse cursor
	Field over:Int			'whether the mouse is over a segment of this guide
	Field sov:Int			'which segment of the guide the mouse is over
	Field sx:Int,sy:Int		'nearest point to the mouse
	Field selected:Int[98]		'if a given segment is part of the current selection

	
End Type
'=============================
Type point
Global _list:TList=New TList
	
	Method New()
		Add(_list)
		g_list=New TList
	End Method

	
	Method Add(t:TList)
		t.Addlast(Self)
	End Method
	
	
	Method Define(px:Int, py:Int)
		x=px
		y=py
		size=2
	End Method
	
	Method Destroy()
		_list.Remove(Self)
	End Method
	
	
	Method Compare:Int(otherobject:Object)
	Local p:point
		p:point=point(otherobject)
		If x=p.x				'if the  line is vertical...
			If y&gt;p.y			'order by y-coordinate.
				Return 1
			Else
				Return -1
			EndIf
		Else					'if the line isn't vertical...
			If x&gt;p.x			'order by x-coordinate.
				Return 1
			Else
				Return -1
			EndIf
		EndIf
	End Method
	

	Field x:Int,  y:Int	'the point's coordinates
	Field size:Int		'size of the dot
	Field dis:Float		'distance from the point to the mouse cursor
	Field over:Int		'whether the mouse cursor is near the point
	Field selected:Int	'if the point is part of the current selection
	Field g_list:TList	'each point contains a list of what guides it is on
	
End Type
'=============================

'=============================
Global slope:Float[divisions/2]
Global unit_angle:Float=360.0/divisions
Global angle:Float, angle2:Float
Global n:Int, n2:Int, p:point, g:guide, g2:guide, x1:Int, y1:Int, x2:Int, y2:Int, px:Int, py:Int, nn:Int
For n=0 To divisions/2-1
	angle=n*unit_angle
	If angle&lt;&gt;90
		slope[n]=Tan(angle)
	EndIf
Next
'=============================





'==========MAIN LOOP==========
While Not KeyHit(KEY_ESCAPE)
	Update_Mouse()
	Check_Click()
	Check_Keys()
	
	SetColor 255, 255, 255
	Draw_Lines()
	Draw_Points()
	DrawLine mx, my, mx+30, my+30
	Draw_Overlay()
Flip
Cls
Wend
'=============================





'==========FUNCTIONS==========
Function Update_Mouse()
	mx=MouseX()
	my=MouseY()
	precedence=0			'points take precedence over guides
	mindis=Update_Distances()
	Determine_Over()
End Function
'=============================
Function Update_Distances:Float()
	mindis=1000
	For p:point=EachIn p._list
		p.dis=Distance(p.x, p.y, mx, my)			'updates the points distance from the mouse
		If p.dis&lt;mindis And p.dis&lt;OVERDIS
			precedence=1
			mindis=p.dis
		EndIf
	Next
	If precedence=0
		For g:guide=EachIn g._list
			g.dis=Normal_Dis(mx, my, g)
			If g.dis&lt;mindis
				mindis=g.dis
			EndIf
		Next
	EndIf
	Return mindis
End Function
'=============================
Function Determine_Over()
		For p:point=EachIn p._list
			If p.dis=mindis And p.dis&lt;OVERDIS
				p.over=1
			Else
				p.over=0
			EndIf
		Next
		For g:guide=EachIn g._list
			If g.dis=mindis And g.dis&lt;OVERDIS And precedence=0
				g.over=1
			Else
				g.over=0
			EndIf
		Next	
End Function
'=============================
Function Distance:Float(x1:Float, y1:Float, x2:Float, y2:Float)
	Return Sqr((y1-y2)^2+(x1-x2)^2)
End Function
'=============================
Function Normal_Dis:Float(x:Float, y:Float, g:guide)			'finds the distance from a point to a guide
Local temp_m2:Float, temp_b2:Float
	If g.v=1					'if the guide is vertical
		If YBounds(y, g)&gt;0
			g.sx=g.b
			g.sy=y
			Return Abs(x-g.b)
		Else
			Return 1000
		EndIf
	ElseIf g.m=0				'if the guide is horizontal
		If XBounds(x, g)&gt;0
			g.sx=x
			g.sy=g.b	
			Return Abs(y-g.b)	
		Else
			Return 1000
		EndIf
	Else						'if the guide is oblique
		temp_m2=-1/(g.m)
		temp_b2=my-temp_m2*mx
		Lines_Cross(g.m, g.b, temp_m2, temp_b2)
		n=XBounds(cx, g)
		If n&gt;0
			g.sov=n-1
			g.sx=cx
			g.sy=cy
			Return Distance(mx, my, cx, cy)
		Else
			Return 1000
		EndIf
	EndIf
End Function
'=============================
'XBounds and YBounds determine whether a given point is within the left/right or top/bottom limits of any of a guide's active segments
'=============================
Function XBounds:Int(x#, g:guide)			'returns the negative of the upper bound's id if false,  positive if true
	If g.amt&gt;1
		For n=1 To g.amt-1
			If x&gt;=g.p[n-1].x And x&lt;g.p[n].x
				If g.seg[n-1]=1
					Return n
				Else
					Return -n
				EndIf
			EndIf
		Next
	Else
		Return 0
	EndIf
End Function
'=============================
Function YBounds:Int(y#, g:guide)
	If g.amt&gt;1
		For n=1 To g.amt-1
			If y&gt;g.p[n-1].y And y&lt;g.p[n].y
				If g.seg[n-1]=1
					Return n
				Else
					Return -n
				EndIf
			EndIf
		Next
	Else
		Return 0
	EndIf
End Function
'=============================
Function Check_Click()
	Select True
		Case MouseHit(1)
			Left_Click()
		Case MouseHit(2)
			Right_Click()
		Default
	End Select
End Function
'=============================
Function Left_Click()
Local angle:Float, dis:Float, temp_m:Float, temp_b:Float
	Select tool
		Case SELECTTOOL
			If Not shift						'if shift isn't held down,  deselect everything
				Deselect()						'(if it IS,  this allows multiple selections)
			EndIf
			For p:point=EachIn p._list			
				If p.over=1						'if the mouse is over a point,  add it to the selection
					p.selected=1-p.selected				
				EndIf				
			Next				
			For g:guide=EachIn g._list				
				If g.over=1								
					g.selected[g.sov]=1-g.selected[g.sov]		'if the mouse is over a guide segment,  add that segment to the selection			
				EndIf				
			Next
		Case POINTTOOL
			If precedence=0							'if the mouse is over a guide...
				For g:guide=EachIn g._list				'...
					If g.over=1						'...
						p:point=New point				'create a new point on that guide
						p.Define(g.sx, g.sy)			'...	
						Add_Point(p, g)				'...
					EndIf	
				Next
			EndIf
		Case DRAWTOOL
			Select mode
				Case 0
					If precedence=1					'If the mouse is over an existing point...
						For	p:point=EachIn p._list		'...
							If p.over=1				'...
								endpoint=p			'set that point as the startpoint...
							EndIf					'...
						Next						'...
					Else							'otherwise create a new one at the mouse's current position.
						startpoint=New point			'...
						startpoint.Define(mx, my)		'...
					EndIf
					mode=1
				Case 1
					'If precedence=1					'If the mouse is over an existing point...
					'	For	p:point=EachIn p._list		'...
					'		If p.over=1				'...
					'			endpoint=p			'set that point as the endpoint...
					'		EndIf					'...
					'	Next						'...
					'Else							'otherwise create a new one around the mouse's current position.
						'endpoint=New point			'...
						angle=ATan2(my-startpoint.y, mx-startpoint.x)
						If angle&lt;0
							angle=angle+360
						EndIf
						n=Int((angle+unit_angle/2)/unit_angle)
						angle2=n*unit_angle
						dis=Distance(startpoint.x, startpoint.y, mx, my)
						Local px:Int, py:Int
						px=startpoint.x+Cos(angle2)*dis
						py=startpoint.y+Sin(angle2)*dis
						endpoint.Define(px, py)		'...
					'EndIf
					g:guide=New guide					'create a new guide
					n2=n Mod (divisions/2)
					'If n&gt;divisions/2-1
					'	n2=n-divisions/2
					'EndIf
					'Print n+":"+n2+" ("+(divisions/2)+") "
					temp_m=slope[n2]
					temp_b=startpoint.y-startpoint.x*temp_m
					g.Define(n2, temp_m, temp_b, 0)
					Add_Point(startpoint, g)			'add the start- and end-points to that guide
					Add_Point(endpoint, g)				'...
					endpoint=New point
					g.seg[0]=1
					For g2:guide=EachIn g2._list
						If g2&lt;&gt;g
							If Intersection(g, g2)&gt;0
								p:point=New point
								p.Define(cx, cy)
								Add_Point(p, g)
								Add_Point(p, g2)	
							EndIf	
						EndIf
					Next
					mode=0
			End Select	
		Default
	End Select
End Function
'=============================
Function Right_Click()
	Select tool
		Case SELECTTOOL
			Deselect()
		Case DRAWTOOL
			mode=0
		Default
	End Select
End Function
'=============================
Function Deselect()				
	For p:point=EachIn p._list
		p.selected=0
	Next
	For g:guide=EachIn g._list
		If g.amt&gt;1
			For n=1 To g.amt-1
			g.selected[n-1]=0
			Next
		EndIf
	Next
End Function
'=============================
Function Check_Keys()
	shift=KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
	If KeyHit(KEY_DELETE)
		Delete_Selection()
	EndIf
	If KeyHit(KEY_TAB)
		tool=(tool+1) Mod toolamount
	EndIf
End Function
'=============================
Function Delete_Selection()
Local selection:TList=New TList
	For p:point=EachIn p._list
		If p.selected=1
			p.Add(selection)
		EndIf
	Next
	For p:point=EachIn selection
		p._list.remove(p)
	Next
	selection.Clear()
End Function
'=============================
Function Draw_Lines()
	For g:guide=EachIn g._list
		If g.amt&gt;1
			For n=1 To g.amt-1
				If g.seg[n-1]=1
					If g.over=1 And g.sov=n-1
						SetColor 0,255,255
					EndIf
					If g.selected[n-1]=1
						SetColor 255,255,0
					EndIf
						DrawLine g.p[n-1].x, g.p[n-1].y, g.p[n].x, g.p[n].y
					SetColor 255,255,255
				EndIf
			Next
		EndIf
	Next
End Function
'=============================
Function Draw_Points()
	For p:point=EachIn p._list
		If p&lt;&gt;endpoint
			If p.over=1
				SetColor 0,255,255
			EndIf
			If p.selected=1
				SetColor 255,255,0
			EndIf
			DrawOval p.x-p.size, p.y-p.size, p.size*2+1, p.size*2+1
			SetColor 255,255,255
		EndIf
	Next
End Function
'=============================
Function Lines_Cross(m1#, b1#, m2#, b2#)
	cx=(b2-b1)/(m1-m2)
	cy=m1*cx+b1
End Function
'=============================
Function Draw_Overlay()
	DrawText tips[tool], 400, 12
	DrawText "Tab to change tool", 200, 12

	SetColor 255, 255, 0
	Select tool
		Case SELECTTOOL

		Case DRAWTOOL
			Select mode
				Case 0

				Case 1
					Local dis:Int=100
					If my&lt;startpoint.y
						x1=mx; x2=startpoint.x
						y1=my; y2=startpoint.y
					Else
						x1=startpoint.x; x2=mx
						y1=startpoint.y; y2=my
					EndIf
						x1=startpoint.x; x2=mx
						y1=startpoint.y; y2=my
					angle=ATan2(y2-y1, x2-x1)
					'angle=ATan2(my-startpoint.y, mx-startpoint.x)
					If angle&lt;0 
						angle=angle+360
					EndIf
					n=Int((angle+unit_angle/2)/unit_angle)
					angle2=n*unit_angle
					'dis=Distance(startpoint.x, startpoint.y, mx, my)
					'px=startpoint.x+Cos(angle2)*dis
					'py=startpoint.y+Sin(angle2)*dis
					dis=Distance(x1, y1, x2, y2)
					px=x1+Cos(angle2)*dis
					py=y1+Sin(angle2)*dis
					DrawLine startpoint.x, startpoint.y, px, py
				Default
			End Select
		Default
	End Select
End Function
'=============================
Function Add_Point(p:point, g:guide)
Local alreadyadded:Int=0
	If alreadyadded=0
		p.Add(g.p_list)
		SortList(g.p_list)
		g.p=point[](ListToArray(g.p_list))
		g.amt=g.p.length
		For n=0 To g.amt-1
			If g.p[n]=p
				If n&gt;0
				For nn=g.amt-1 To n Step -1
					g.seg[nn]=g.seg[nn-1]
				Next
				EndIf
			EndIf
		Next
	EndIf
End Function
'=============================
Function Intersection:Int(g1:guide, g2:guide)		'assigns the point of intersection to cx and cy, returns the segment
	If g1.v=1			'if the first guide is vertical...
		cx=g1.b
		cy=cx*g2.m+g2.b
	ElseIf g2.v=1		'if the second guide is vertical...
		cx=g2.b
		cy=cx*g1.m+g1.b
	Else				'if neither guide is vertical
		Lines_Cross(g1.m, g1.b, g2.m, g2.b)
	EndIf
	
	If g2.v=1
		Return YBounds(cy, g2)
	Else
		Return XBounds(cx, g2)
	EndIf
End Function
'=============================
</textarea><br>The program runs fine, just doesn't delete points when I tell it to. <br><br></td></tr></table><br>
<a name="995880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes, exactly what I meant. I didn't suspected you were using so many globals(yak!) that is why I assumed. I see what I can figure out for you no guarantee. Others code is always so hard for me to figure out, specially procedural. <br><br></td></tr></table><br>
<a name="995881"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> The important bits are what I posted before, the code is a bit messy overall 'cause it began life in B+ and has since been converted. I figured I'd post the whole thing though, because running it once to see what it does should clear up a lot.<br><br>(this version doesn't quite work with vertical lines yet, but that's a minor edit) <br><br></td></tr></table><br>
<a name="995887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I kind of went through your code and tested your delete function like this:<br><pre class=code>
Function Delete_Selection()
	Local c:Int = 0
	For p:point=EachIn p._list
		c:+1
		If p.selected=1
			Print "removed a point"
			p._list.remove(p)
		EndIf
	Next
	Print c
End Function
</pre><br>I found out that p.selected is never set to 1(or set for deletion) hance the reason for not removing the point. when I create a line with two points it stores three points in the list which makes sense to me that only two points be stored in the list but you might have other reasons for storing three. Look somewhere else for the problem. <br><br>I know you changed your function because what Brucey said but it works fine the way you had it even though it is not the best way of doing it so I changed it back. <br><br></td></tr></table><br>
<a name="995899"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hrm, I get the "removed a point" message, but the point doesn't go away.<br>The reason there is always +1 point then there appears is because of endpoint:point, which is used in drawing new lines.<br><br><a href="http://blitzbasic.pastebin.com/m71abe3" target="_blank">http://blitzbasic.pastebin.com/m71abe3</a> <br><br></td></tr></table><br>
<a name="995903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I normally do something like this:<br><br><pre class=code>
Type TSprite
  Global list:TList

  Function Create:TSprite()
    local s:TSprite = new TSprite
    if list = Null list = CreateList()
    list.addlast s
    return s
  End Function

  Method Kill()
    If Not list Return
    list.Remove(self)
  End Method

  Function KillAll()
    if Not list Return
    For Local s:TSprite = EachIn list
      s.Kill()
    Next
  End Function
</pre> <br><br></td></tr></table><br>
<a name="995908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I found out that the list is getting corrupted by something. it might be the sorting in the "add_point" function but it is just a guess. <br>reason:<br>I was unable to remove any items from the list that were accessed by the for/eachin loop. However, I was able to remove it by creating Tlinks and removing it that way but even after removing the object, the list give an incorrect item count plus it gave another error. Anyway, here it is so you can try it:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict
'=============================
Graphics 800, 600

'=========CONSTANTS==========
Const OVERDIS:Float=20
Const divisions:Int=16				'how many parts 360 degrees is divided up into ()
Const toolamount:Int=3
Global tips$[]=["Select and delete.","Add a point to a line.","Draw a line."]
'=============================


'==========TOOL ID's==========
Const SELECTTOOL:Int=0, POINTTOOL:Int=1, DRAWTOOL:Int=2
'=============================


'===========GLOBALS===========
Global mx:Int,  my:Int			'the mouse's position
Global cx:Float,  cy:Float		'stores the output of the Lines_Cross() function
Global lower_bound:Int			'stores the output of the In_Common function
Global upper_bound:Int			'...
Global tool:Int=2				'which tool is selected
Global mindis:Float
'=============================
Global precedence:Int			'whether or not the mouse is over a point (points take precedence over guide segments)
'=============================
Global shift:Int				'whether or not shift is held down
'=============================
Global mode:Int				'only used for Draw tool
Global startpoint:point		'...
Global endpoint:point=New point			'...
'=============================



'============TYPES============
Type guide				'guides are lines on which points and line segments lie
Global _list:TList=New TList

	Method New()
		_link = _list.Addlast(Self)'*******************************
	End Method
	
	
	Method Define(ang:Int,  gm:Float,  gb:Int,  gv:Int)
		angle=ang
		m=gm
		b=gb
		v=gv
		p_list=New TList
	End Method

	Field _link:TLink              '***********************************
	Field angle:Int	
	Field m:Float, b:Float		'y=mx+b	(b functions as the line's x-value when it is vertical)
	Field v:Int				'vertical y/n
	Field p_list:TList		'each guide contains a list of which points are on it,  ordered from left to right, or top to bottom
	Field p:point[99]			'the same list,  in array form (necessary for segment management)
	Field amt:Int			'length of the array
	Field seg:Int[98]			'whether or not the drawline exists for a given segment
	Field dis:Float			'distance to the mouse cursor
	Field over:Int			'whether the mouse is over a segment of this guide
	Field sov:Int			'which segment of the guide the mouse is over
	Field sx:Int,sy:Int		'nearest point to the mouse
	Field selected:Int[98]		'if a given segment is part of the current selection

	
End Type
'=============================
Type point
Global _list:TList=New TList
	
	Method New()
		Add(_list)
		g_lst=New TList
	End Method
	
	Method Add(t:TList)
		_link = t.Addlast(Self) '******************************************
	End Method
	
	Method Define(px:Int, py:Int)
		x=px
		y=py
		size=2
	End Method
	
	Method Destroy()
		_link.remove() '_list.Remove(Self) '*******************************************
	End Method
	
	
	Method Compare:Int(otherobject:Object)
	Local p:point
		p:point=point(otherobject)
		If x=p.x				'if the  line is vertical...
			If y&gt;p.y			'order by y-coordinate.
				Return 1
			Else
				Return -1
			EndIf
		Else					'if the line isn't vertical...
			If x&gt;p.x			'order by x-coordinate.
				Return 1
			Else
				Return -1
			EndIf
		EndIf
	End Method
	
	Field _link:TLink       '*************************************
	Field x:Int,  y:Int	'the point's coordinates
	Field size:Int		'size of the dot
	Field dis:Float		'distance from the point to the mouse cursor
	Field over:Int		'whether the mouse cursor is near the point
	Field selected:Int	'if the point is part of the current selection
	Field g_lst:TList	'each point contains a list of what guides it is on
	Field g:guide[divisions]
	
End Type
'=============================

'=============================
Global slope:Float[divisions/2]
Global unit_angle:Float=360.0/divisions
Local n:Int, angle:Float
For n=0 To divisions/2-1
	angle=n*unit_angle
	If angle&lt;&gt;90
		slope[n]=Tan(angle)
	EndIf
Next
'=============================





'==========MAIN LOOP==========
While Not KeyHit(KEY_ESCAPE)
	Update_Mouse()
	Check_Click()
	Check_Keys()
	
	SetColor 255, 255, 255
	Draw_Lines()
	Draw_Points()
	DrawLine mx, my, mx+30, my+30
	Draw_Overlay()
Flip
Cls
Wend
'=============================





'==========FUNCTIONS==========
Function Update_Mouse()
	mx=MouseX()
	my=MouseY()
	precedence=0			'points take precedence over guides
	mindis=Update_Distances()
	Determine_Over()
End Function
'=============================
Function Update_Distances:Float()
Local p:point, g:guide
	mindis=1000
	For p:point=EachIn point._list
		p.dis=Distance(p.x, p.y, mx, my)			'updates the points distance from the mouse
		If p.dis&lt;mindis And p.dis&lt;OVERDIS
			precedence=1
			mindis=p.dis
		EndIf
	Next
	If precedence=0
		For g:guide=EachIn guide._list
			g.dis=Normal_Dis(mx, my, g)
			If g.dis&lt;mindis
				mindis=g.dis
			EndIf
		Next
	EndIf
	Return mindis
End Function
'=============================
Function Determine_Over()
Local p:point, g:guide
		For p:point=EachIn point._list
			If p.dis=mindis And p.dis&lt;OVERDIS
				p.over=1
			Else
				p.over=0
			EndIf
		Next
		For g:guide=EachIn guide._list
			If g.dis=mindis And g.dis&lt;OVERDIS And precedence=0
				g.over=1
			Else
				g.over=0
			EndIf
		Next	
End Function
'=============================
Function Distance:Float(x1:Float, y1:Float, x2:Float, y2:Float)
	Return Sqr((y1-y2)^2+(x1-x2)^2)
End Function
'=============================
Function Normal_Dis:Float(x:Float, y:Float, g:guide)			'finds the distance from a point to a guide
Local temp_m2:Float, temp_b2:Float, n:Int
	If g.v=1					'if the guide is vertical
		n=YBounds(y, g)
		If n&gt;0
			g.sx=g.b
			g.sy=y
			g.sov=n-1
			Return Abs(x-g.b)
		Else
			Return 1000
		EndIf
	ElseIf g.m=0				'if the guide is horizontal
		n=XBounds(x, g)
		If n&gt;0
			g.sov=n-1
			g.sx=x
			g.sy=g.b	
			Return Abs(y-g.b)	
		Else
			Return 1000
		EndIf
	Else						'if the guide is oblique
		temp_m2=-1/(g.m)
		temp_b2=my-temp_m2*mx
		Lines_Cross(g.m, g.b, temp_m2, temp_b2)
		n=XBounds(cx, g)
		If n&gt;0
			g.sov=n-1
			g.sx=cx
			g.sy=cy
			Return Distance(mx, my, cx, cy)
		Else
			Return 1000
		EndIf
	EndIf
End Function
'=============================
'XBounds and YBounds determine whether a given point is within the left/right or top/bottom limits of any of a guide's active segments
'=============================
Function XBounds:Int(x:Float, g:guide)			'returns the negative of the upper bound's id if false,  positive if true
Local n:Int
	If g.amt&gt;1
		For n=1 To g.amt-1
			If x&gt;=g.p[n-1].x And x&lt;g.p[n].x
				If g.seg[n-1]=1
					Return n
				Else
					Return -n
				EndIf
			EndIf
		Next
	Else
		Return 0
	EndIf
End Function
'=============================
Function YBounds:Int(y:Float, g:guide)
Local n:Int
	If g.amt&gt;1
		For n=1 To g.amt-1
			If (y&gt;g.p[n-1].y And y&lt;g.p[n].y) Or (y&lt;g.p[n-1].y And y&gt;g.p[n].y)
				If g.seg[n-1]=1
					Return n
				Else
					Return -n
				EndIf
			EndIf
		Next
	Else
		Return 0
	EndIf
End Function
'=============================
Function Lines_Cross(m1#, b1#, m2#, b2#)
	cx=(b2-b1)/(m1-m2)
	cy=m1*cx+b1
End Function
'=============================
Function Check_Click()
	Select True
		Case MouseHit(1)
			Left_Click()
		Case MouseHit(2)
			Right_Click()
		Default
	End Select
End Function
'=============================
Function Left_Click()
Local p:point, g:guide
Local angle:Float, dis:Float, temp_m:Float, temp_b:Float
	Select tool
		Case SELECTTOOL
			Update_Selection()
		Case POINTTOOL
			If precedence=0							'if the mouse is over a guide...
				For g:guide=EachIn guide._list				'...
					If g.over=1						'...
						p:point=New point				'create a new point on that guide
						p.Define(g.sx, g.sy)			'...	
						Add_Point(p, g)				'...
					EndIf	
				Next
			EndIf
		Case DRAWTOOL
			Select mode
				Case 0
					If precedence=1					'If the mouse is over an existing point...
						For	p:point=EachIn point._list		'...
							If p.over=1				'...
								startpoint=p			'set that point as the startpoint...
							EndIf					'...
						Next						'...
					Else							'otherwise create a new one at the mouse's current position.
						startpoint=New point			'...
						startpoint.Define(mx, my)		'...
					EndIf
					mode=1
				Case 1
					Create_Guide()
					mode=0
			End Select	
		Default
	End Select
End Function
'=============================
Function Update_Selection()
Local p:point, g:guide, n:Int, nn:Int
	If Not shift						'if shift isn't held down,  deselect everything
		Deselect()						'(if it IS,  this allows multiple selections)
	EndIf
	For p:point=EachIn point._list			
		If p.over=1						'if the mouse is over a point,  add it to the selection
			p.selected=1-p.selected				
		EndIf				
	Next
	For g:guide=EachIn guide._list
		If g.p[0].selected=1					'first point
			g.selected[0]=g.seg[0]	
		EndIf
		For n=1 To g.amt-2					'middle points
			If g.p[n].selected=1
				For nn=0 To 1
					If g.seg[n-nn]=1 And g.seg[n-1+nn]=0
						g.selected[n-nn]=1
					EndIf
				Next
			EndIf
		Next
		If g.p[g.amt-1].selected=1				'last point
			g.selected[g.amt-2]=g.seg[g.amt-2]	
		EndIf
	Next
			
	For g:guide=EachIn guide._list				
		If g.over=1								
			g.selected[g.sov]=1-g.selected[g.sov]		'if the mouse is over a guide segment,  add that segment to the selection			
		EndIf				
	Next
End Function
'=============================
Function Add_Point(p:point, g:guide)
Local alreadyadded:Int=0, n:Int, nn:Int
	If alreadyadded=0
		p.g[g.angle]=g
		p.Add(g.p_list)
		SortList(g.p_list)
		g.p=point[](ListToArray(g.p_list))
		g.amt=g.p.length
		For n=0 To g.amt-1
			If g.p[n]=p
				If n&gt;0
				For nn=g.amt-1 To n Step -1
					g.seg[nn]=g.seg[nn-1]
				Next
				EndIf
			EndIf
		Next
	EndIf
End Function
'=============================
Function Create_Guide()
Local angle:Float, n:Int, endx:Int, endy:Int, dis:Float
Local p:point, g:guide, g2:guide
Local temp_m:Float, temp_b:Float, temp_v:Int
	If precedence=1					'If the mouse is over an existing point...
		For	p:point=EachIn point._list	'...
			If p.over=1				'...
				endpoint=p			'set that point as the endpoint...
			EndIf					'...
		Next						'...
	Else							'otherwise create a new one around the mouse's current position.
		angle=ATan2(my-startpoint.y, mx-startpoint.x)
		If angle&lt;0
			angle=angle+360
		EndIf
		n=Int((angle+unit_angle/2)/unit_angle)
		angle=n*unit_angle
		dis=Distance(startpoint.x, startpoint.y, mx, my)
		endx=startpoint.x+Cos(angle)*dis
		endy=startpoint.y+Sin(angle)*dis
		endpoint.Define(endx, endy)		'...
	EndIf
	g:guide=In_Common(startpoint,endpoint)
	If g&lt;&gt;Null
		For n=lower_bound+1 To upper_bound
			g.seg[n-1]=1
		Next
		endpoint=New point	
	Else
		g:guide=New guide					'create a new guide
		n=n Mod (divisions/2)
		temp_m=slope[n]
		temp_b=startpoint.y-startpoint.x*temp_m
		If angle=90
			temp_v=1
			Notify "vertical"
		EndIf
		g.Define(n, temp_m, temp_b, temp_v)
		Add_Point(startpoint, g)			'add the start- and end-points to that guide
		Add_Point(endpoint, g)				'...
		g.seg[0]=1
		For g2:guide=EachIn guide._list
			If g2&lt;&gt;g
				If Intersection(g, g2)&gt;0
					p:point=New point
					p.Define(cx, cy)
					Add_Point(p, g)
					Add_Point(p, g2)	
				EndIf	
			EndIf
		Next
	EndIf
	endpoint=New point				'reset the endpoint
End Function
'=============================
Function Intersection:Int(g1:guide, g2:guide)		'assigns the point of intersection to cx and cy, returns the segment
	If g1.v=1			'if the first guide is vertical...
		cx=g1.b
		cy=cx*g2.m+g2.b
	ElseIf g2.v=1		'if the second guide is vertical...
		cx=g2.b
		cy=cx*g1.m+g1.b
	Else				'if neither guide is vertical
		Lines_Cross(g1.m, g1.b, g2.m, g2.b)
	EndIf
		
	If g1.v=1 
		Return XBounds(cx, g2)&lt;&gt;0 And Ybounds(cy, g1)&lt;&gt;0
	ElseIf g2.v=1
		Return YBounds(cy, g2)&gt;0 And Xbounds(cx, g1)&gt;0
	Else 
		Return XBounds(cx, g2)&gt;0 And Xbounds(cx, g1)&gt;0
	EndIf
End Function
'=============================
Function In_Common:guide(p1:point, p2:point)
Local g:guide, p:point, contains1:Int, contains2:Int, n:Int, out:Int[2]
	For g:guide=EachIn guide._list
		contains1=-1; contains2=-1
		For n=0 To g.amt-1
			If g.p[n]=p1 Then contains1=n
			If g.p[n]=p2 Then contains2=n
		Next
		If contains1&gt;-1 And contains2&gt;-1
			lower_bound=Min(contains1, contains2)
			upper_bound=Max(contains1, contains2)
			Return g
		EndIf
	Next
	Return Null
End Function
'=============================
Function Right_Click()
	Select tool
		Case SELECTTOOL
			Deselect()
		Case DRAWTOOL
			mode=0
		Default
	End Select
End Function
'=============================
Function Deselect()
Local p:point, g:guide, n:Int
	For p:point=EachIn point._list
		p.selected=0
	Next
	For g:guide=EachIn guide._list
		If g.amt&gt;1
			For n=1 To g.amt-1
			g.selected[n-1]=0
			Next
		EndIf
	Next
End Function
'=============================
Function Check_Keys()
	shift=KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
	If KeyHit(KEY_DELETE)
		Delete_Selection()
	EndIf
	If KeyHit(KEY_TAB)
		tool=(tool+1) Mod toolamount
	EndIf
End Function
'=============================
Function Delete_Selection()
	Local p:point, g:guide, n:Int
	Print point._list.count()'**********
	For p:point=EachIn point._list
		If p.selected=1
			Print "removed a point"
			p.Destroy()
		EndIf
	Next
	Print point._list.count()'***********
	For g:guide=EachIn guide._list
		For p:point=EachIn g.p_list
			If p.selected=1
				g.p_list.Remove(p)
			EndIf
		Next
		g.p=point[](ListToArray(g.p_list))
		
		For n=0 To g.amt-1
			If g.selected[n]=1
				g.seg[n]=0	
				g.selected[n]=0
			EndIf
		Next
	Next
End Function

'=============================
Function Draw_Lines()
Local g:guide, n:Int
	For g:guide=EachIn guide._list
		If g.amt&gt;1
			For n=1 To g.amt-1
				If g.seg[n-1]=1
					If g.over=1 And g.sov=n-1
						SetColor 0,255,255
					EndIf
					If g.selected[n-1]=1
						SetColor 255,255,0
					EndIf
						DrawLine g.p[n-1].x, g.p[n-1].y, g.p[n].x, g.p[n].y
					SetColor 255,255,255
				EndIf
			Next
		EndIf
	Next
End Function
'=============================
Function Draw_Points()
Local p:point
	For p:point=EachIn point._list
		If p&lt;&gt;endpoint
			If p.over=1
				SetColor 0,255,255
			EndIf
			If p.selected=1
				SetColor 255,255,0
			EndIf
			DrawOval p.x-p.size, p.y-p.size, p.size*2+1, p.size*2+1
			SetColor 255,255,255
		EndIf
	Next
End Function
'=============================
Function Draw_Overlay()
Local x1:Int, y1:Int, x2:Int, y2:Int, angle:Float, n:Int, dis:Float
	

	DrawText tips[tool], 400, 12
	DrawText "Tab to change tool", 200, 12

	SetColor 255, 255, 0
	Select tool
		Case SELECTTOOL

		Case DRAWTOOL
			Select mode
				Case 0

				Case 1
					x2=mx; y2=my; x1=startpoint.x; y1=startpoint.y
					angle=ATan2(y2-y1, x2-x1)
					If angle&lt;0 
						angle=angle+360
					EndIf
					n=Int((angle+unit_angle/2)/unit_angle)
					angle=n*unit_angle
					dis=Distance(x1, y1, x2, y2)
					x2=x1+Cos(angle)*dis
					y2=y1+Sin(angle)*dis
					DrawLine startpoint.x, startpoint.y, x2, y2

				Default
			End Select
		Default
	End Select
End Function
'=============================

	SetColor 255,0,0
	DrawOval cx-2, cy-2, 5, 5
</textarea><br><br><br>edit :<br>I added asterisks to show what I modified. <br><br></td></tr></table><br>
<a name="995923"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>Type TSomething
	Field me:TLink

	Method New()
		me = somelist.AddLast(Self)
	End Method

	Method Kill()
		me.Remove()
	End Method
End Type</pre><br><br>This is the BEST and FASTEST way to delete things from a list. :D:D:D<br>A TLink removes it from the list immediately (in the way linked lists are meant to work), no need to search through the whole list to find a single object. <br><br></td></tr></table><br>
<a name="995946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Found the problem, TList.Remove() uses the overrided Compare() method. <br><br></td></tr></table><br>
<a name="995948"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> what? <br><br></td></tr></table><br>
<a name="995964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TaskMaster</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, TList.Remove() uses Compare to find the item to remove.<br><br>A better thing to do is not to override the Compare method.  When calling sort, you can pass a function to use for the comparing while sorting. <br><br></td></tr></table><br>
<a name="995968"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zakk</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> A better thing to do is not to override the Compare method. When calling sort, you can pass a function to use for the comparing while sorting. <br></div><br><br>Yup, that's what I did. And thank you for the TLink code, I will be sure to use that method more frequently. <br><br></td></tr></table><br>
<a name="995978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I never used the build in function for sorting that was what confused me. I knew it was there just never bothered to use it. <br><br></td></tr></table><br>
<a name="995988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Muttley</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, that bit me a while back as well: <a href="http://www.blitzbasic.com/Community/posts.php?topic=87418" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=87418</a> <br><br></td></tr></table><br>
<a name="1018925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Snixx</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> just doing a bit of thread resurrection but thanks for the kill hint. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
