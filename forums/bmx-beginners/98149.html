<!DOCTYPE html><html lang="en" ><head ><title >LAN search</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >LAN search</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >LAN search</a><br><br>
<a name="1144469"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all,<br><br>I want to test some networking stuff using BMax.<br><br>I can get the server and client running if the server's IP is known by the client program, like hardcoding it into the code of the client.<br><br>But, I want the client to search for the server itself in a LAN.<br>It's certainly possible if I would give my game to someone else, that his server won't run on the exact same IP as mine.<br>Or if me and my son play the game, he would want to host the server and I cannot connect to it, because the IP of the server is hardcoded to the computer which I'm playing on.<br><br>We play the game "C&amp;C Generals" quite often, it has some sort of lobby that lists all servers and players on the network.<br>I want to have such a system as well, or just that it scans the network for servers on a specific port and just accepts the first one it finds.<br><br>I've also looked into BNet, GNet, TNet, ..., but I prefer to not use any of those libs.<br>GNet seems to add the server to some list on the internet, from which it retreives data like the name of the game, name of server, ... (correct me if I'm wrong).<br>I want to have my server private, so it cannot be found outside the LAN.<br><br>I've got this already:<br>Server:<br><pre class=code>
SuperStrict

Graphics 400, 300, 0



Global Players:Int



Type TServer
	Field Port:Int = 9876
	Field Socket:TSocket
	Field SocketStream:TSocketStream
	Field Stream:TStream

	Method New()
		' Try to create a new network socket
		Socket = CreateTCPSocket()
		' Check if it was successfull
		If Socket = Null Then RuntimeError "Failed to create socket"
		' Check if the port can be bound to the socket
		If Not BindSocket(Socket, Port) Then RuntimeError "Failed to bind port 10001 to socket"
		' Start listening on the socket for new connections (maximum new connections simultanously at any time = 8, since there are maximum 8 monopoly players)
		SocketListen(Socket, 8)
	End Method

	Method Process()
		If SocketAccept(Socket) &lt;&gt; Null Then
			Print "New connection detected"
			Players = Players + 1
		EndIf
	End Method

	Method CleanUp()
		CloseSocket(Socket)
	End Method
End Type

' Create a new TServer and setup the socket for listening
Global Server:TServer = New TServer



' Main loop
While Not KeyHit(KEY_ESCAPE)
	Cls

	Server.Process()

	DrawText "Connections detected: " + Players, 10, 10

	Flip
Wend

Server.CleanUp()

End
</pre><br><br>Client:<br><pre class=code>
SuperStrict

Graphics 400, 300, 0



Type TClient
	Field IP:Int = (192*256*256*256) + (168*256*256) + (123*256) + 7
	Field Port:Int = 9876
	Field Socket:TSocket
	Field Stream:TStream

	Method New()
		' Try to create a new network socket
		Socket = CreateTCPSocket()
		' Check if it was successfull
		If Socket = Null Then RuntimeError "Failed to create socket"
		' Try to connect to the server using broadcasting
		If ConnectSocket(Socket, IP, Port) Then Print "Server found" Else End
	End Method

	Method CleanUp()
		CloseSocket(Socket)
	End Method
End Type

' Create a new TClient
Global Client:TClient = New TClient

While Not KeyHit(KEY_ESCAPE)
	DrawText "Server found...", 10, 10
	Flip
Wend

Client.CleanUp()

End
</pre><br><br>The IP is the client is hardcoded here to 192.168.123.7, this is the IP of my laptop.<br>If I would run this code on my other computer, it will fail as the IP's don't match.<br><br>I also tried to use a For-Next loop to cycle through all IP's (last digit ranging from 0 to 254), using ConnectSocket, but it freezes the client if no computer is found with any of those IP's.<br>As soon as it starts connecting to 192.168.123.0 (or any other IP, except 192.168.123.7), it just freezes and I have to kill the client's process using taskmanager.<br><br>I also tried creating a stream on the client, but it didn't detect the server, and the server didn't see the incoming stream from the client.<br><br>I'm already searching throughout the forum and using google without success for over 3 hours now. <br><br></td></tr></table><br>
<a name="1144522"></a>

<a name="1144524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have to broadcast to your lan.<br><br>In your case: 192.168.123.<b>255</b><br><br>It may be required to enable broadcast-mode.<br>If using GNET (which you don't) as base you will have to make some tweaks which I have circumvented with some parts BNetEx.<br><br>Your "Announce packet" which you send to your broadcast-address (which can differ from x.x.x.255 but most times will be that *.255) should contain your magic header and the game information:<br>- server ip<br>- game title<br>- free/occupied slots<br>- ...<br><br> <br>The most important comes at the end:<br>As you already found out: the PC freezes if sending packets to x.x.x.0-x.x.x.254.<br>That is because you send by "TCP/IP" - a protocol needing responses from the remote host ("did you receive my package?" ... waiting ...waiting ... "yes"/timeout) <br><br>Send your packets by using "UDP".<br>So in your case (if TCP is needed that much - instead of developing reliable/ordered udp-thingies) make something like an "info channel" in UDP and your "game channel" in TCP.<br>The first can then be used for update notifications, game announcements, lobby chats ...<br><br><br>bye<br>Ron<br><br>edit: to clearify something: you can send to .0-.254 instead of broadcasting to .255. But then you have to take care of not blocking the sockets.<br>- I had some problems with an older BNetEx-Implementation here on linux and had to delay the announcepackets every 20 IPs (0-19,100ms delay, 20-39, 100ms ...) else they did not get received by virtual-box-windows-clients.<br>To come along with that problem: only delete old "announcements" after a "maximum looptime" * factorBiggerThanOne.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144552"></a>

<a name="1144555"></a>

<a name="1144556"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Many people are struggling with this, as I found out by searching the forums.<br><br>I also tried using the broadcast address (192.168.123.255), I forgot to mention that.<br>Using the above code, the client just ends instead of waiting and crashing on ConnectSocket.<br>Also, the server didn't see the connection coming in.<br><br>I tried searching my router-settings for some broadcast-enable option, but all I found was enabling the SSID broadcast of the router itself.<br>There seems to be no option to allow broadcast messages in the LAN.<br><br>I just tried UDP (I just modified CreateTCPSocket into CreateUDPSocket), but now I didn't get any response, not even with the correct address.<br><br>I find this stuff to be confusing.<br>You can do this for example:<br><pre class=code>
' Try to create a new network socket
Socket = CreateTCPSocket()
' Turn the socket into a stream
Stream = CreateSocketStream(Socket)
' Send data over the stream
Stream.Send( xxxxx )
</pre><br><br>But where would it be sent? The target IP and port haven't been specified yet and I see no option to do this, other than using ConnectSocket, where you can specify the IP and port.<br>So I don't know how to send "announce packets", as not even the broadcast address can be set anywhere.<br><br>It was way easier using Blitz3D's system. I got a server-client system setup there in less than an hour or so (just using a fixed address, not searching the server as I want to do here).<br><br>The game I'm trying to create is "Monopoly" in 3D with a maximum of 4 players for now.<br>One player creates a network game (this option sets up the server, which runs in the game itself, like C&amp;C Generals, and connects the client immediately to the server), the other computers could just run the game and detect the server, which will allow them to connect to the server.<br>So, there won't be a separate server.exe file to be started or whatever.<br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144561"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> That is why I mentioned BnetEx (blitzmax udp wrapper thingy).<br><br>With Blitzmax-original UDP-functions I wasn't able to make it work how I'd liked it to work.<br><br>With UDP you declare the target-port but not the one you are using (sender Port).<br>So to get your sending port you have to send that port back from the client (may be in the answer to the announce packet).<br>To see what things are send/receives - install Wireshark (you can even write a LUA-Packet-Analyzer for YOUR application - so wireshark can log "Login Attempt" instead of "packet data XYZ").<br>Install it on both computers - so you see on which side the problem occours. Tip: filter the log by your local IPs ... so you don't log the http/.../-traffic. <br><br>Your router is not responsible for broadcasting. The NIC of your "server" has to be configured right (will be in most cases).<br>Prior to new firewalls in windows/linux-systems you were able to "ping -b x.x.x.255" and get responses from all connected systems.<br><br>Another thing to take into consideration:<br>Server is on LAN ... connected to Router<br>Client is on WLAN ... connected wireless to WLAN-AP which is connected to the Router<br>Client B is on LAN ... connected to WLAN-AP<br><br>Problems which can occour: different Subnet-Masks, different Subs (x.x.1.0/255 and x.x.2.0/255) - if this is the case, broadcasting will not work without additional work or nice AP/routers which cascade that things).<br><br>Another problem occours if IPv4 gets abandoned from your OS ... IPv6 has no broadcast-mode (but that will take some years from now).<br><br><br>As the code I use is a bit more complex (event driven, package management) I'm not able to give complete sources now:<br><br>So it is modified, untested, shortened (some parts missing).<br>The "TNetworkPacket"-Type is something to make the packet-data better manageable (contains flags for reliability, order, eventType, ...).<br><br>[bbcode]<br>import "external/bnetex.bmx" 'Version: 1.70 Beta<br><br>Type TGameNetwork<br>	Global localPort:int			= 4544					' for normal ingame packets<br>	Global infoPort:int				= 4543					' only for lan (up to now) - announcements<br>...<br>	'to interact with clients/host<br>	field infoStream:TUDPStream		= Null<br>...<br>	Field announceEnabled:int		= 0<br>	Field announceTitle:string		= "unknown"				' title used when announcing<br>	Field announceTime:Int			= -1					' Main Announcement Timer<br>	Field announceTimer:Int			= 750					' Main Announcement Timer<br>	Field announceToLan:int			= 1<br><br><br>	Method InitInfoStream()<br>		if infoStream then return<br>		If infoStream = Null Then infoStream = new TUDPStream<br>		if infoStream = null then RuntimeError "Couldn't create UDP stream for LAN game announcements"<br>		infoStream.Init()<br>		infoStream.SetLocalPort(self.infoPort)<br>		infoStream.SetRemotePort(self.infoPort)<br>	End Method<br><br>	Method StartAnnouncing(title:string, toLan:int = 1)<br>		self.InitInfoStream()<br>		self.announceEnabled= true<br>		self.announceTitle	= title<br>		self.announceTime	= Millisecs()<br>		self.announceToLan	= toLan<br>	End Method<br><br>	Method FindGames()<br>		'if inGame then return<br>		if not infoStream then print "init stream";self.InitInfoStream()<br><br>		'custom implementation...you will have to take care yourself<br>		local packet:TNetworkPacket = self.ReceiveInfoPackets()<br>		if packet &lt;&gt; null<br>			local obj:TNetworkObject = TNetworkObject.FromPacket(packet)<br>			if obj and callbackInfoChannel then callbackInfoChannel(obj)<br>		endif<br>	End Method<br><br>	Method Update:int()<br>		if self.isServer then self.SendGameAnnouncement()<br>		self.FindGames()<br><br><br>		if self.server then self.server.Update()<br>		if self.client<br>			if self.pingTime &lt; Millisecs()<br>				self.client.Ping()<br>				self.pingTime = Millisecs()+self.pingTimer<br>			endif<br>			self.client.Update()<br>		endif<br>	End Method<br><br>	Method SendGameAnnouncement()<br>		if not self.announceEnabled then return<br>		if self.announceTime &gt; Millisecs() then return<br>		if self.GetFreeSlot() = 0 then return<br><br>		self.announceTime = Millisecs() + self.announceTimer<br>		local obj:TNetworkObject = TNetworkObject.Create(NET_ANNOUNCEGAME)<br>		If self.announceToLan<br>			'Print "NET: announcing a LAN game to " +GetBroadcastIP(self.GetMyIP())<br>			obj.setInt(1, self.GetFreeSlot())<br>			obj.setString(2, self.announceTitle)<br>			obj.setInt(3, self.GetMyIP())<br>			obj.setInt(4, self.localPort)<br>			self.SendInfoPacket(obj.toPacket(), GetBroadcastIP(self.GetMyIP()), self.infoPort)<br>		Else<br>rem<br><br>			Print "NET: announcing a ONLINE game "<br>			Local Onlinestream:TStream = ReadStream("http::www.youronlinewebsite.xx/lobby.php?action=AddGame&amp;Titel="+UrlEncode(Game.title)+"&amp;IP="+OnlineIP+"&amp;Port="+host.port+"&amp;Spieler="+Self.getFreeSlot()+"&amp;Hashcode="+LastOnlineHashCode)<br>			Local timeouttimer:Int = MilliSecs()+5000 '5 seconds okay?<br>			Local timeout:Byte = False<br>			If Not Onlinestream Then Throw ("Not Online?")<br><br>			While Not Eof(Onlinestream) Or timeout<br>				If timeouttimer &lt; MilliSecs() Then timeout = True<br>				Local responsestring:String = ReadLine(Onlinestream)<br>				If responsestring &lt;&gt; Null AND responsestring &lt;&gt; "UPDATEDGAME" Then LastOnlineHashCode = responsestring<br>			Wend<br>			CloseStream Onlinestream<br>endrem<br>		EndIf<br>  End Method<br><br>	Method ReceiveInfoPackets:TNetworkPacket()<br>		if infoStream.RecvAvail()<br>			While infoStream.RecvMsg() ; Wend<br>			Local size:Int = infoStream.Size()<br>			If size<br>				Local data:Byte[size]<br>				local packet:TNetworkPacket = New TNetworkPacket<br>				packet._bank.resize(size)<br>				MemCopy(packet._bank.buf(),infoStream.RecvBuffer,size)<br>				infoStream.Flush()<br>				packet.ip	= infoStream.MessageIP<br>				packet.port	= infoStream.MessagePort<br>				return packet<br>			EndIf<br>		endif<br>		return null<br>	End Method<br><br>	Method SendInfoPacket:int(packet:TNetworkPacket, ip:string, port:int)<br>		'set broadcast (for linux)<br>		infoStream.SetBroadcast(true)<br><br>		if packet and packet._bank.size()<br>			Local length:int	= packet._bank.size()<br>			if length &gt; 0 and not infoStream.write(packet._bank.buf(), length) then throw "Net: Error writing to Networkmessage buffer " + length<br>			if not infoStream.SendUDPMsg( HostIP(ip), port ) then throw "Net: Error sending udp message to " + ip+ " :" + port<br>		endif<br>		return true<br>	End Method<br><br>...<br><br>End Type<br>[/bbcode]<br><br>Maybe some parts of the code above will help.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1144562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zeke</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can use RakNet:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import zeke.raknet

Global state:Int
Global client:TRKRakPeerInterface
Global server:TRKRakPeerInterface
Global socket_desc:TRKSocketDescriptor

Const server_port:Int = 60001
Const client_port:Int = 60000

Graphics 800, 600

While Not(KeyHit(KEY_ESCAPE) Or AppTerminate())
	Cls
	If state = 0
		DrawText "(C)lient or (S)erver, ESC=Exit", 0, 0
		If KeyHit(KEY_C) Then
			client = TRKRakNetworkFactory.GetRakPeerInterface()
			socket_desc = New TRKSocketDescriptor.Create(client_port)
			If Not client.Startup(1, 30, socket_desc)
				Notify "Client failed to start."
				End
			End If
			client.Pinghost("255.255.255.255", server_port, True) 'Lan Broadcast
			state = 1
		ElseIf KeyHit(KEY_S)
			server = TRKRakNetworkFactory.GetRakPeerInterface()
			socket_desc = New TRKSocketDescriptor.Create(server_port)
			Local result:Int = server.Startup(2, 30, socket_desc)
			server.SetMaximumIncomingConnections(2)
			If Not result
				Notify "Server failed to start. Terminating."
				End
			End If
			state = 1
		End If
	Else
		DrawText "Waiting for packet...", 0, 0
		Local p:TRKPacket
		If client
			p = client.Receive()
		Else
			p = server.Receive()
		EndIf
		
		If p Then
			If client
				Select p.GetPacketIdentifier()
					Case ID_PONG
						DrawText "Got Pong from: " + p.GetSystemAddress().ToString(), 0, 20
						DrawText "Press any key to exit.", 0, 40
						Flip
						WaitKey
						End
				End Select
			
				client.DeallocatePacket(p)
			Else
				server.DeallocatePacket(p)
			End If
		EndIf
	EndIf
	Flip
	Delay 10
Wend</textarea><br><br><a href="http://www.byrathon.com/omat/lan.zip" target="_blank">http://www.byrathon.com/omat/lan.zip</a> <br><br></td></tr></table><br>
<a name="1144713"></a>

<a name="1144722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I searched some more and found this:<br><a href="http://www.blitzmax.com/Community/posts.php?topic=75694" target="_blank">http://www.blitzmax.com/Community/posts.php?topic=75694</a><br>The source-code of Ghislain (post 8) got me started.<br>His code was in one exe, but I've succesfully split it up into a separate server and client exe.<br><br><br><br>I've got something working already, using UDP.<br><br>The server broadcasts a message every second to 192.168.123.255.<br>The client already picks it up and displays the message on-screen.<br><br>But using SocketRemoteIP doesn't return the server's IP.<br>This is not directly a problem, because I can add the server's IP in the message itself as text (or just the last digits of the server's IP will do fine as well).<br><br>Right now, the server can already broadcast the game-name (Monopoly3D) as a byte array (I've written a function to convert a string to a byte array, I found no built-in function or method that does this) and the client reads it and displays it on-screen.<br><br>By using the IP in the message (I'm still writing code to get that out of it), I can probably create a new TCP-stream to connect to the server.<br><br>So, I'm using an UDP broadcast message to send the IP of the server as text throughout the entire network, so every client in the network will know the IP of the server by analyzing the broadcast-message.<br>In turn, the client will need to use that info to setup a TCP-connection to the server.<br><br>When it's fully functional, I can post the code.<br><br><br><br>EDIT: After testing a bit more, I've finally made it working completely, but the code still needs some refining.<br><br>When the server is started, the broadcast message is constructed (Game-name and server-ip are stored) and sent over the network once every second using UDP to address 192.168.123.255.<br><br>The client scans it and extracts the game-name and the server-ip.<br>If the game-name isn't correct, there might be another application using the same port, so skip it.<br>If the game-name is correct, use the server-ip from the message to establish a connection to the server using TCP.<br>Also send the player's name to the server, using the new TCP connection.<br><br>The server checks for new TCP connections, sees a new player and creates a new TPlayer instance, in which the Socket is stored.<br><br>The server also loops through all players and checks if that player sent some data.<br>Currently, the sent data is stored as the name of the player.<br><br>The name of every player is also printed onscreen on the server's window.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144880"></a>

<a name="1144884"></a>

<a name="1144885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is my current code:<br><br>Server:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Graphics 500, 300, 0






Type TServer
	Field Broadcasting:Int = True ' Set server in broadcast-mode when the server is started
	Field PortUDP:Int = 49000 ' Setup the UDP-port to use for sending the broadcast message
	Field SocketUDP:TSocket ' The socket to use for the UDP broadcast message
	Field BroadcastLastTime:Int ' Holds the last time when the broadcast message was sent (used to send the broadcast message once every second)
	Field BroadcastMsg:Byte[] ' Holds the broadcast message itself

	Field PortTCP:Int = 49500 ' Setup the TCP port to use for communicating with the connected clients
	Field SocketTCP:TSocket ' The socket to use for establishing the connection with new clients

	Field Players:TPlayer[8] ' Setup an array which will hold all players

	' Initialize the TServer instance
	Method New()
		' Store the current time for the broadcast-timer
		BroadcastLastTime = MilliSecs()

		' Setup UDP socket for broadcasting
		SocketUDP = CreateUDPSocket()
		' Check if it was successfull
		If SocketUDP = Null Then RuntimeError "Failed to create UDP socket"
		' Connect the UDP socket to the broadcast address and port
		ConnectSocket(SocketUDP, HostIp("192.168.123.255"), PortUDP)
		' Setup broadcast message (holds the game-name and the server's IP)
		BroadcastMsg = TextToArray("Monopoly3D " + SocketLocalIP(SocketUDP))

		' Also setup the TCP socket and start listening for new connections
		SocketTCP = CreateTCPSocket()
		' Check if it was successfull
		If SocketTCP = Null Then RuntimeError "Failed to create TCP socket"
		' Try to bind the PortTCP to the TCP Socket
		If Not BindSocket(SocketTCP, PortTCP) Then RuntimeError "Could not bind PortTCP to TCP Socket"
		' Start listening on the socket for new connections (maximum new connections simultanously at any time = 8, since there are maximum 8 monopoly players)
		SocketListen(SocketTCP, 8)
	End Method

	' Process the server
	Method Process()
		Self.Broadcast()
		Self.AcceptPlayers()
		Self.ProcessPlayers()
	End Method

	' Send the broadcast message (game-name and server-ip) over the entire network
	Method Broadcast()
		If Broadcasting = True Then
			' Get the current time
			Local Time:Int = MilliSecs()

			' Only broadcast every second
			If Time &gt; (BroadcastLastTime + 1000) Then
				' Send the broadcast message
				SocketUDP.Send(Varptr BroadcastMsg[0], BroadcastMsg.length)

				' Update the timer
				BroadcastLastTime = BroadcastLastTime + 1000
			EndIf
		EndIf
	End Method

	Method AcceptPlayers()
		' Check for a new TCP connection coming from clients that already read the broadcast message
		Local NewPlayerSocket:TSocket = SocketAccept(SocketTCP)

		' Check if there was a new connection
		If NewPlayerSocket &lt;&gt; Null Then
			' Create a new TPlayer instance
			Local p:TPlayer = New TPlayer
			' Store the socket for that player
			p.Socket = NewPlayerSocket
			' Also create a new TCP SocketStream and store it
			p.Socketstream = CreateSocketStream(P.Socket)
			' Store the IP of the client
			p.ClientIP = SocketRemoteIP(p.Socket)
			p.ClientIPString = DottedIP(p.ClientIP)

			' Loop through the Players-array
			For Local Index:Int = 0 To (Players.length - 1)
				' Check if this index is empty
				If Players[Index] = Null Then
					' Store the new player's instance in this index
					Players[Index] = p
					' Stop searching the array for an empty index, as the player has been added to it already
					Exit
				EndIf
			Next
		EndIf
	End Method

	' This method processes each player
	Method ProcessPlayers()
		' Temporary variable for displaying player-names onscreen
		Local Counter:Int
		Local p:TPlayer, Size:Int, Index:Int

		For Index = 0 To (Players.length - 1)
			' Increase the counter
			Counter = Counter + 1

			' Check if this index holds a player instance
			If Players[Index] &lt;&gt; Null Then
				' Reference the current player with variable "p"
				p = Players[Index]

				' Check if this player is still connected
				If SocketConnected(p.Socket) Then
					' Get the size of the message in the player's socket
					Size = SocketReadAvail(p.Socket)

					' If there is a message present
					If Size &gt; 0 Then
						' Process the message from the player
						Self.ProcessMessageFromPlayer(p, ReadLine(p.SocketStream))
					EndIf

					DrawText "Player connected: " + p.Name + " at IP: " + p.ClientIPString, 10, 10 + (Counter * 15)
				Else
					' The player lost connection, so delete the player instance
					Players[Index] = Null
				EndIf
			EndIf
		Next
	End Method

	' This method processes messages from a pleyer
	Method ProcessMessageFromPlayer(p:TPlayer, Msg:String)
		' Extract the command from the message (the first 3 characters)
		Select Mid(Msg, 1, 3)
			' PlayerName command -&gt; store the name of the player
			Case "Nam"
				p.Name = Mid(Msg, 5)
		End Select
	End Method

	Method Cleanup()
		If SocketUDP Then SocketUDP.Close()
		If SocketTCP Then SocketTCP.Close()
	End Method
End Type



Type TPlayer
	Field Name:String
	Field Socket:TSocket
	Field SocketStream:TSocketstream
	Field ClientIP:Int, ClientIPString:String
End Type



' Create a new TServer and setup the socket for listening
Global Server:TServer = New TServer



' Main loop
While Not KeyHit(KEY_ESCAPE)
	Cls

	Server.Process()

	Flip
Wend

Server.Cleanup()

End



' Converts a string to a byte array, ready to be sent through the network (only used for UDP)
Function TextToArray:Byte[](DataString:String)
	' Get the length of the string
	Local StrLen:Int = DataString.length
	' Create a byte array with the same size as the given string
	Local DataArray:Byte[StrLen]

	' Loop through the entire string
	For Local i:Int = 0 To (StrLen - 1)
		' Store the ASCII value of each character as a byte in the byte-array
		DataArray[i] = Asc(Mid(DataString, i + 1, 1))
	Next

	' Return the byte array
	Return DataArray
End Function
</textarea><br><br>Client:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Graphics 400, 300, 0



Type TClient
	Field PortUDP:Int = 49000 ' Setup the port to use for UDP broadcast message reading
	Field SocketUDP:TSocket ' The socket to use for reading the UDP broadcast message
	Field ServerIP:Int ' Holds the server-ip for setting up the TCP-connection
	Field ServerIPString:String ' Holds the server's ip as a string
	Field LastMsg:String

	Field PortTCP:Int = 49500 ' Setup the TCP port to use for communicating with the connected server
	Field SocketTCP:TSocket ' The socket which holds the connection to the server
	Field SocketStream:TSocketstream ' The stream of the TCP socket

	Method New()
		' Setup UDP socket for reading broadcast messages from the server
		SocketUDP = CreateUDPSocket()
		BindSocket (SocketUDP, PortUDP)
	End Method

	Method Process()
		If ServerIP = 0 Then
			' If the server was not found yet, keep scanning for a broadcast message from the server
			ReadBroadcast()
		Else
			If SocketConnected(SocketTCP) Then
				DrawText "Connection to server established", 10, 50
			EndIf
		EndIf

		' Draw the broadcast message onscreen
		DrawText LastMsg, 10, 10
		DrawText ServerIP + " = " + ServerIPString, 10, 25
	End Method

	' This method scans the UDP-port for a broadcasted message from the server
	' As soon as the message is found, a TCP-connection is made to the server
	Method ReadBroadcast()
		Local Size:Int

		' Get the size of the message in the UDP-buffer
		Size = SocketReadAvail(SocketUDP)

		' Check if there was a message (try to pickup the broadcast message from the server)
		If Size &lt;&gt; 0 Then
			' Create a byte-array to store the broadcast message
			Local buffer:Byte[] = New Byte[Size]
			' Store the message in the byte-array
			SocketUDP.Recv(buffer, Size)
			' Reconstruct the broadcast-message sent by the server as a string
			LastMsg = String.FromBytes(buffer, Size)
		EndIf

		' Process the message and extract the server's IP
		' Also setup the TCP-connection to the server
		If Mid(LastMsg, 1, 10) = "Monopoly3D" Then
			' Extract the ServerIP as integer and convert to DottedIP as well
			ServerIP = Int(Mid(LastMsg, 12))
			ServerIPString = DottedIP(ServerIP)

			' Try to establish connection to the server
			SocketTCP = CreateTCPSocket()
			If Not ConnectSocket(SocketTCP, ServerIP, PortTCP) Then RuntimeError "Failed to establish connection to the server"
			' Also setup a socketstream to the server
			SocketStream = CreateSocketStream(SocketTCP)

			' Send the name of the player to the server ("Nam" is command for storing the player's name)
			WriteLine(SocketStream, "Nam PowerPC603")
		EndIf
	End Method

	Method Cleanup()
		If SocketUDP Then SocketUDP.Close()
		If SocketTCP Then SocketTCP.Close()
	End Method
End Type

' Create a new TClient
Global Client:TClient = New TClient

While Not KeyHit(KEY_ESCAPE)
	Cls

	Client.Process()

	Flip
Wend

Client.Cleanup()

End



' Converts a string to a byte array, ready to be sent through the network (only used for UDP)
Function TextToArray:Byte[](DataString:String)
	' Get the length of the string
	Local StrLen:Int = DataString.length
	' Create a byte array with the same size as the given string
	Local DataArray:Byte[StrLen]

	' Loop through the entire string
	For Local i:Int = 0 To (StrLen - 1)
		' Store the ASCII value of each character as a byte in the byte-array
		DataArray[i] = Asc(Mid(DataString, i + 1, 1))
	Next

	' Return the byte array
	Return DataArray
End Function
</textarea><br><br>This works perfectly and I just tested it with both computers at home.<br>The server broadcasts a message throughout the entire network and runs on my laptop.<br><br>The clients run on both the laptop and desktop pc.<br>They listen for a broadcast message.<br>As soon as the message is found, the client creates a TCP connection to the server after analyzing the broadcast message, which holds the IP of the server.<br>Also, the client sends the name of the player to the server as a command ("Nam PowerPC603" =&gt; command = "Nam", playername = "PowerPC603").<br>As soon as the client established the connection, the client stops scanning for the broadcast message, as the server has been found already.<br><br>The server accepts the connection and creates a new TPlayer instance.<br>The server also loops through all players and prints their name on the screen.<br>When looping through all players, it checks if any player has sent data to the server.<br>If there is data, the message is analyzed and processed.<br>There is only one command built-in right now ("Nam").<br>When the first 3 characters of the player's message equals "Nam", the rest of the message is stored in the player's account as his name.<br><br>The server also checks if a client disconnects.<br>In such a case, the player's instance will be deleted and will no longer be processed.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144906"></a>

<a name="1144907"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
			' Only broadcast every second
			If Time &gt; (BroadcastLastTime + 1000) Then
				' Send the broadcast message
				SocketUDP.Send(Varptr BroadcastMsg[0], BroadcastMsg.length)

				' Update the timer
				BroadcastLastTime = BroadcastLastTime + 1000
			EndIf
</pre><br><br>means: first broadcast is not done at 0 seconds, but 1 second (time &gt; broad... + 1000)<br><br>means: If time since last processing is &gt; 1000, decrease "lastTime" by 1000 and check again next time.<br><br>means: if your app hangs for 20 seconds, it broadcasts 20 times (each time "Broadcast()" is run).<br><br>Better is to use (except you intented it that way)<br><br><pre class=code>
			' Only broadcast every second
			' first broadcast is done on first "Broadcast()"-call
			' to add a delay - .. &gt; BroadcastLastTime + delay
			If Time &gt; BroadcastLastTime Then
				' Send the broadcast message
				SocketUDP.Send(Varptr BroadcastMsg[0], BroadcastMsg.length)

				' Update the timer and add 1000 ms to wait
				BroadcastLastTime = Millisecs() + 1000
			EndIf
</pre><br><br>bye<br>Ron<br><br><br>edit:<br>to make your code more manageable:<br>- make a type like "TConnection" with fields both (client and server) share<br>- extend both of them from it<br>- move the helper-function TextToBytes/BytesToText ... to that TConnection<br>- within TClient.new and TServer.new use "super.new()" - so your TConnection.new can handle some of the initialization.<br><br>What can also be a nice thing to have: in my application each Network"client" has fields for server and client. Each of them can get chosen to handle as new server (maybe server drops out - internetgames ...)<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144913"></a>

<a name="1144915"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm still revising the code, but I'll look into your suggestions.<br>I'm still new to network code, but I grasp the basic concepts about it.<br>I'm also creating new methods to enable/disable broadcasting, getting the server'sip to calculate the broadcast ip (bitwise or the serverip with 255), and much more.<br><br>This code is currently the minimum code required to broadcast a message and allow clients to find the server on their own, without the need to preset the server's ip in the client code.<br>And it should be easy to follow for other people as well to start with something like this.<br><br><br><br>The broadcasting will stop when the game is actually started.<br>Since it's a monopoly game, all players need to connect to the server before the game is started.<br>As soon as the game starts, no new connections will be allowed (since such a game won't allow new players to join in the middle of the game).<br>Broadcasting won't be needed then, as well as AcceptPlayers.<br><br>Broadcasting 20 times in a row won't be a problem as well.<br>The client will change later to hold a list of servers, instead of connecting to the first monopoly server it finds.<br><br>Once the list is created, new broadcast messages will still be processed by the client, and it will update the server-list when there is a change (new server or server gone).<br>Otherwise, the list won't be updated.<br>But that will change later when I have the basic interface of the game working to allow players to create a game or to join one (the lobby of the game).<br><br><br><br>In case of drop-out of the server:<br>You mean that every client should start his own server?<br>And all players connect to one server, which will be the master-server?<br>And the master-server transmits his status (in case of monoply: the owner of each property and the money of each player and who's turn it is) every few seconds to all other servers?<br><br>So in case the master-server drops out, another server can take over where the master-server dropped out? And of course, the new master-server needs to contact each player to re-connect to him?<br><br>This would get quite complex I guess.<br><br><br><br>I guess I'll make one server program which can process several "games" of monopoly.<br>All players connect to this server and choose a game to join.<br>So one player will have to start the server application and the client as well.<br><br>In case of MMO's: there is also only one server. If it drops out, all players are disconnected and have to wait for the server to come back online before they can continue playing.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> In normal "games" you don't have to start a server.exe<br><br>If the "Master-Server" (aka "host") is dropping out, there should be an algorithm (or just "second joined client" - as first was the host) which decides who is hosting next - all clients should come to the same conclusion who is hosting. Then they just "swap" the currently used server to the new ones.<br>Then all of them await the "please welcome our new host - me :D"-packet, ACKnowledge it and then game processing can continue.<br>From then all data the new host has is used as master data.<br><br>There should not be information loss as all clients store data of the board-properties, bought/sell-logs and so on.<br>What might be a bit out of synchronicity is "movement data" (data each client calculates by itself but gets "overwritten" by data from the master/host).<br><br><br>I know that an mmporpg does not do it that way - but they use that for a) being able to charge money :D and b) for holding additional / dynamic data.<br><br>I also admin that older games did not allow for changing host (I remember WarCraft 3 ...there additional .exe-tools added methods of reconnection ingame if some lost the connection).<br>Which reminds me to: if you plan to allow "play over internet" - also allow for reconnect within XX seconds.<br>For doing so - each game should get a unique hash - and each client should get a "game+client"-hash.<br>So a person with a different IP is able to authentificate and send a "join"-message to the host (even if he was the host and is now only a client connecting to the new host).<br><br>I know that this sounds complicated - and you are not forced to use the suggestions - some of them will certainly be of use if you intend to make it available to a broad mass of customers/gamers/players...<br><br><pre class=code>
I'm also creating new methods to enable/disable broadcasting, getting the server'sip to calculate the broadcast ip (bitwise or the serverip with 255), and much more.
</pre><br><br>As I mentioned "BnetEx" - it does already include functions for doing it. Think GNet also uses some methods.<br>The problem here is: it is not x.x.x.255 everytime - so you have to ask the OS/system what broadcast-ip is used.<br><br>Another problem which can occour is: Notebooks are having LAN and WLAN most of the time. If both are enabled you could end up having more than one NIC your game could use.<br>Which one to take?<br>- for that case you could<br>a) make a option-dropdownbox with selectability<br>b) make a config-file with a "useIP=XXXX" or "useNIC=1/2/..."<br>c) listen on both for announcements (get ready for potential trouble)<br>d) own ideas?<br><br>For myself I use option b) for being the easiest one.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1144928"></a>

<a name="1144929"></a>

<a name="1144930"></a>

<a name="1144931"></a>

<a name="1144932"></a>

<a name="1144933"></a>

<a name="1144934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> The game won't be sold, as it's just a learning project to combine networking and 3D stuff all together for myself.<br><br>The game will mostly run at home.<br><br>I could make the project open-source and upload the entire game WITH source-code to the internet for anyone to use. Then they can make moifications for themselves if needed.<br><br><br><br>In case of server-dropouts: if one player hosts the game and his game crashes, the server will crash as well.<br>Or it may happen that the player just leaves the game.<br><br>Either way, that player is disconnected from the game.<br>Another player's game could take over the hosting of the game, but without the player that left.<br><br>Monopoly games usually don't allow players to join mid-game, so reconnecting him (if this version would allow it) would give several difficulties:<br><br>1) Reserve the disconnected player's properties to give it back if he re-connects.<br>Doing this would disallow the other players to buy those properties again, since they are reserved for the disconnected player, so the server can give them back if he reconnects.<br><br>This option is not good, as the disconnected player might just leave the game and do something else, ruining the game for the other players who can't buy the properties anymore.<br><br><br><br>2) Replace the disconnected player by a computer player and transfer the disconnected player's properties to the computer player.<br>This isn't good as well, because the disconnected player might want to rejoin (in case his game just crashed).<br>So he cannot play anymore, as he lost his properties, money, ...<br><br><br><br>3) Just give all properties of the disconnected player back to the bank, so the other players can buy them again.<br><br>Not good either, as the disconnected player might want to rejoin the game.<br>Since his properties were given back to the bank, he would start with a blank account and would go bankrupt in no-time anyway if the game is near the end.<br>This option could also be exploited by players who are facing bankruptcy.<br>They would just disconnect, rejoin and they start with a blank account with the default amount of money.<br><br><br>So, either option I choose isn't good anyway.<br><br><br><br>I think I'll just allow one player to host the game, and let others to connect to his server.<br><br>In case a player drops out, his properties are given back to the bank and the player cannot rejoin the game.<br>If the hosting player drops out, it's game over for everyone, as they all lose their connection.<br><br><br><br>It's my first BIG game project (I created a few smaller ones without networking stuff and were never quite finished), so I don't want to start writing backup-servers, doing anything weird with the rules, ...<br><br>It's only a project to learn something about networking, multiple player handling, 3D stuff with animations, creating an interface, AI players, ...<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1144949"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> About the reconnection thing:<br><br>if a connection drops ... give that client (or the server) XX seconds time to settle / reconnect. If no reconnect attempt : drop him from the game.<br><br>Why do I say this?<br>Do you handle 100% CPU usage?<br>Do you handle Alt-Tab ?<br><br>And the one I was frightened the most:<br>Dragging a windowed application (so: not in fullscreen) in Windows (i run it in Windows XP). The problem here: the app is halted then if you are not running your logic loop within another thread.<br>This means: if one of your players is moving the window around: no networkpackets will get received meanwhile also no updates will be done during that period.<br><br>For me that problem was reason enough to dive a bit into threading (and looking for help here on the forums :D).<br><br>If all of your clients are running linux you will be fine as I did not have such problems with dragged windows :D.<br><br><br>I did not test TCP a long time - but as TCP needs ACKs for all packets they send - each "disturbance" on receivers side will let the sender "halt/wait" until they timeout or send. There you see another reason for threading network things.<br>Please care for such problems BEFORE running occasional into them (like I did) as it makes planning of your code easier and the code later manageable.<br><br>Test the above things by moving the window of one of your connected clients (move it for some seconds). Test what happens if you (ungracefully) crash an app (so connections are not getting closed nicely). ...<br><br><br>I would be pleased to see pictures of the progress you are doing (except you would then violate some copyrights).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1144981"></a>

<a name="1144982"></a>

<a name="1144993"></a>

<a name="1145021"></a>

<a name="1145023"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Currently, the only code I have is the code posted above.<br>I have no interface yet, no 3D models, no other code for the game, nothing (except the network code above).<br><br>I'll look into threads. I didn't think about that yet.<br>When we would run the game at home, we would always run it fullscreen.<br><br>I'll be using the Xors3D engine for the 3D stuff, as well as the interface.<br>It still supports ImageBuffers, on which you can draw your stuff in an update-function, then draw the entire image at once, without having to draw everything separately each frame, which would run slower I guess.<br>Drawing an image which has already 20 lines of text printed on it, will draw faster than drawing the rectangle first, then all the lines of text separately.<br><br>I guess I could post some screenshots later on when I have the 3D scene up and running.<br>All the 3D models, textures and such will be created by myself.<br><br>The only copyright violation would be the layout of the board and the names of the properties.<br>But then again, all other monopoly clones use the same layout and property-names.<br>So I don't really know if it would violate copyrights or not.<br><br><br><br>EDIT:<br>I've checked out threading and how it basically works.<br>The main graphics display should run in the main thread.<br>These things need threading:<br>- the entire server-part of the host<br>- the entire game-logic<br><br>The server-part will process each player and check for new messages.<br>These messages will be processed in the server, which takes actions based on the message from every client.<br>The server will also send data back to every client to let each player know if there is a change in state (property bought, player x is moving, ...)<br><br>The client will receive those messages and process them as well.<br>The threaded client-part would need to set some variables to allow the graphics display to change based on the value of those variables.<br>So, even if the window gets dragged, both server and client parts of the game run in separate threads and won't freeze.<br>Also the game-logic won't freeze, only the display will freeze.<br>But the display (3D graphics onscreen) will get updated automatically when the window is not longer dragged, if the variables are used properly.<br><br><br><br>I think a thread can be seen as a separate program without a window, but has access to the variables and other data of the main program.<br>So, every thread could use a main loop which never ends.<br>Using global variables, you could control the threads by setting data into them from within the main thread and letting the thread use those variables to do something.<br><br>So, in fact, I could write a function with a main loop that never ends and run that function in a thread.<br>That way, the thread will never end as well.<br>Inside that loop, i could put the broadcast code to broadcast a message throughout the entire network every second.<br><br>Then, even if the player moves his window around (which freezes the main thread), or if something else happens which causes the main thread to "hang" for 20 seconds as you mentioned earlier, the broadcast message is still sent every second throughout the network.<br><br>Is this correct?<br><br><br><br>EDIT:<br>I've just tested my server and client app by moving the windows around.<br>I've added a line of text to the clients window that displays the current time (millisecs).<br><br>When moving the server window around, nothing happens to the client. The client just keeps updating his graphics display as usual.<br>When moving the client window around, only the graphics display freezes.<br>I get no crash whatsoever.<br>Neither the server or client crashes.<br><br>But currently, no data is being sent after connection has been established. Maybe that's the reason why the client keeps updating his graphics display when moving the server around.<br>I'll test this when more of the game is ready and data is actively being sent and received regularly.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1145030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've knocked up some threading code myself.<br><br>First I started with a un-threaded build to print the millisecs to the BMax IDE's output tab (using Print).<br>When moving the window around, the output stopped printing the millisecs.<br>But, somewhere in the background, sending the printed text still happened.<br>Because when I stopped moving the window around, the output didn't continue where it left off (leaving a gap in the values), but also displayed all millisecs in between while I was moving the window.<br><br>Then I created this code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Global Printing:Int = True
Global ExitThread:Int = False

' Create a graphics window
Graphics 400, 300, 0

' Start the function "PrintData" as a separate thread
Local T:TThread = CreateThread(PrintData, Null)

' Main thread's main loop
While Not KeyHit(KEY_ESCAPE)
	' Clear the screen
	Cls

	' Toggle Printing on/off by pressing spacebar
	If KeyHit(KEY_SPACE) Then
		If Printing = True Then
			Printing = False
		Else
			Printing = True
		EndIf
	EndIf

	' Allow the thread to end by pressing "X"
	If KeyHit(KEY_X) Then
		ExitThread = True
	EndIf

	Flip
Wend

' When the app is closed, also stop the thread (don't know if this is required, but better safe than sorry)
ExitThread = True
End



' This function starts the LoadData function in a separate thread and draws something to the screen while the thread is doing it's work separately
Function PrintData:Object(Data:Object)
	' Allow the thread to run forever
	Repeat
		' If the thread should be exited (variable set by the main thread)
		If ExitThread = True Then
			Print "Thread exited"
			Exit
		EndIf

		' Keep printing the millisecs if told to do so
		If Printing = True Then Print MilliSecs()

		' Don't let this thread use up all processor power
		Delay(1)
	Forever
End Function
</textarea><br><br>In here, the function "PrintData" is executed a a separate thread.<br>The thread is also controlled using 2 variables ("Printing" and "ExitThread") by the main thread.<br>The "Printing" variable allows the thread to print it's data (or blocks it).<br>"Exitthread" allows the thread's main loop to end.<br>When I moved the window around, the thread kept printing the millisecs to the output tab of BMax. <br><br></td></tr></table><br>
<a name="1145912"></a>

<a name="1145913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I would be pleased to see pictures of the progress you are doing (except you would then violate some copyrights).<br> <br></div><br>I've got a screenshot already from some parts of the board.<br>It's not yet finished, as not all squares are implemented yet.<br><br>Right now, it only uses 4 different meshes and 2 textures.<br>2 meshes are textured, the other 2 only have a color on them.<br>All properties (the ones which you can buy and put houses on) are all merged into one mesh and use only 1 texture.<br>The corner squares (Go, jail, free parking and the cop) are also merged into one mesh and use the other texture.<br>The center square of the board only has a color applied to it, as well as the sides of the board.<br><br>The textures are not finished yet either, as the corners still need actual pictures instead of plain text.<br>The center of the board will change as well, it will get an actual texture.<br><br>Rendering full-screen (1440x900 resolution) gives me about 1000fps using Xors3D.<br><br><img src="http://users.telenet.be/vge/Monopoly3D.jpg"><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1146128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> The 1000fps should be gone if you implement some kind of lighting, shadowing... and more complex objects (pegs/player figures, buildings).<br><br>2D-Interface will also swallow some performance.<br><br><br>Keep up the work.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1146477"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Scaremonger</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Applications that locate their hosts using broadcast addresses are not a good idea. The traffic is broadcast to all hosts on the network and with a lot of nodes doing this, it can create a lot of traffic. Also simply using a 255 in the last octet of an address will not work in all situations!<br><br>There are various technologies that clients use to identify a server; SLP (RFC2165/2608) was the standards-track answer to the problem, but many applications simply query a specific DNS record and this is certainly the easiest to implement and does not restrict the application to working on a single subnet based network.<br><br>For example: Your client is on 192.168.111.1 and your server on 10.10.10.10 with a router in-between. The broadcast method would not work.<br><br>In your DNS (or hostfile on the client if you wish), your define a record called 'myapp' which returns address 10.10.10.10. <br><br>Your blitzmax application simply does this to identify the server:<br><br><pre class=code>
local address% = hostip( "myapp" )
</pre> <br><br></td></tr></table><br>
<a name="1146497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> There are various technologies that clients use to identify a server; SLP (RFC2165/2608) was the standards-track answer to the problem <br></div><br><br>I have been playing around with networking as well... what exactly is SLP and how would I use it?<br><br><div class="quote"> <br>For example: Your client is on 192.168.111.1 and your server on 10.10.10.10 with a router in-between. The broadcast method would not work.<br><br>In your DNS (or hostfile on the client if you wish), your define a record called 'myapp' which returns address 10.10.10.10.  <br></div><br><br>If you have to create a record, wouldn't that require some sort of hard coding for the server IP?  I don't understand this very well. <br><br></td></tr></table><br>
<a name="1146502"></a>

<a name="1146504"></a>

<a name="1146506"></a>

<a name="1146507"></a>

<a name="1146509"></a>

<a name="1146512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> You would still need to know and hardcode the server's IP into the client.<br>That's not what I'm after.<br><br>The client also has the server built-in, like many games that allow playing over a LAN.<br><br>If I would play on my own computer (laptop), the IP is 192.168.123.7.<br>The IP of the desktop computer is 192.168.123.1, where my son plays the game.<br><br>In one scenario, I could host the game on the laptop and my son joins me.<br>So he needs to know the server will be located on 192.168.123.7.<br>And my client needs to connect to this server as well (or use 127.0.0.1).<br><br>In another scenario, my son hosts the game, so my laptop needs to connect to his IP, which is 192.168.123.1.<br><br>So hardcoding the IP isn't an option, as the server may run on any IP in the network.<br>Also running a local DNS won't work, as the game could be hosted by anyone on the LAN.<br>The game could also be hosted by several players on a big LAN, so hardcoding one IP won't work.<br>The client should list all hosted servers on the LAN to allow the client to connect to a specific host, selected by the player.<br><br>The server also won't be registered on the internet, so I won't have a DNS to the server.<br>And it won't run 24/7, as the server only runs when the hosting player starts a new game.<br><br><br><br>If this would be an MMORPG, it would be alot easier like you say.<br>Then the server needs to be hosted somewhere and run 24/7 on a static IP or an address that can be resolved by a DNS.<br>Such a server has a big database to hold all information of every player, item, skill, ...<br>Moving such a database around isn't simple and requires the server to be located always on the same address.<br><br>Then it would simply be a matter of hardcoding the IP or DNS name to the server and broadcasting would not be needed, as every client knows that the server is on a static address.<br><br>Checking if the server is running could simply be done by sending a connection-message to the server and let the server respond by a acknowledge-message using UDP.<br>TCP could crash the game if the server is down as the client would never stop trying to connect to the server.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
