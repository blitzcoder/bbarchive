<!DOCTYPE html><html lang="en" ><head ><title >Pixel perfect bouncing</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Pixel perfect bouncing</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >Pixel perfect bouncing</a><br><br>
<a name="820944"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >spacerat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> In the game I am making, I need to have objects which bounce off other objects accurately, and I have everything sorted, apart from one thing.<br><br>I have the collision detection done, and I can return the object collided with. And I also know the algorithm for finding the angle to bounce at, provided I know the direction the bouncing object is travelling at, and the angle of the surface.<br><br>And there is the problem, I don't know how to accurately find the angle of a surface on any particular point on a sprite. If you don't get what I mean yet, here is a diagram accidentally saved in JPG then converted to PNG.<br><br><img src="http://xs120.xs.to/xs120/07434/sprite.png"> <br><br></td></tr></table><br>
<a name="820954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> you can not pixel perfect bounce.<br><br>you need to use polygons to calculate a surface normal which is needed to calculate the new direction vector, sorry. <br><br></td></tr></table><br>
<a name="821082"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >spacerat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh right. Then, is there a way of automatically creating these polygons? I'm sure there must be because I've seen bouncing done in other game creating tools without the need to stick in your own polygons. <br><br></td></tr></table><br>
<a name="821086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you say which tools as people might know how those tools manage to do it? I know some tools come with a manual shape editor and that there are algos (convex hull? Giftwrap?) which can do it. <br><br></td></tr></table><br>
<a name="821102"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You do not necessarily have to use polygons, but that is an increasingly popular method.<br><br>What you need to do ultimately is find an angle, ie interpret the edge of the object in such a way to make it look like there is a single flat `face` where the other object strikes.<br><br>You could sample/read a small area of say 3x3 pixels at the point of impact and based on the contents of those pixels ie based on alpha values perhaps, create a straight or curved line which marks the edge of the shape, and then find the angle of that line. <br><br></td></tr></table><br>
<a name="821107"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >spacerat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> tonyg: the tool I mean is Game Maker, the program I used when introduced to programming. It managed collisions and bouncing for you entirely; you quite literally called "move_bounce_solid()" in the event of a collision, and that was it. You didn't have to edit polygons or anything like that. Obviously I'm not looking for someone to provide that level of ease in blitz.<br><br>As for Convex hull algorithms, if someone else can implement them that would be cool, personally, I would have _no_ idea where to start.<br><br>ImaginaryHuman: That is an awesome idea, I think I'll look into it. <br><br></td></tr></table><br>
<a name="821109"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't think GameMaker checked the point of contact and calculated the return angle though. I think it just reversed the direction. I could be wrong as GameMaker got quite powerful.<br>Anyway, <a href="http://www.softsurfer.com/Archive/algorithm_0109/algorithm_0109.htm" target="_blank"> this </a> is good for creating hulls. <br><br></td></tr></table><br>
<a name="821117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >spacerat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Game Maker did get very powerful; it doesn't just reverse the direction, it checks the point of contact as you said.<br><br>I have a feeling Game Maker probably uses a Convex Hull algorithm, or something similar to do with polygons. The thing is, everything on that page just flies straight over my head. I did notice that the C implementation seems to take an array of points as an argument... I'm not sure how well that would work out. Also, the thing is with convex hull, is that it seems to reduce the complexity of the shape, so although you end up with a set of points to use, you don't get very accurate collision. (correct me if I'm wrong there)<br><br>As for your suggestion ImaginaryHuman, I have an idea of how it would work, but I haven't tried to implement it yet.<br><br>It would work like this:<br><img src="http://xs320.xs.to/xs320/07435/collisionz.png"><br><br>1) _Somehow_ find the point of collision, then _somehow_ extract a small square around it, making sure you differentiate between the pixels of the sprite, and of the background.<br><br>2) Find all pixels which are not adjacent to a pixel in the background, and 'disregard' them<br><br>3) Of the remaining pixels, find all the ones which do not touch the side of the small square, and 'disregard' them.<br><br>4) Figure out the angle from one remaining pixel to the other. In the whole plan, this is the only step I DO know how do do in Blitz.<br><br>This looks like the easier plan, and possibly more accurate than using hulls. Even still, I'm relatively new to Blitz, so I'd need some pointers on which direction to take. <br><br></td></tr></table><br>
<a name="821131"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Curtastic</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats exactly what I'm going to do to improve my ball bouncing game game PinkEyes <a href="http://www.freegame.cz/en/game.php?id=4829" target="_blank">http://www.freegame.cz/en/game.php?id=4829</a><br><br><br>To code it you just need a circle algorithm and use readpixel from the background's imagebuffer to get those 2 points. <br><br></td></tr></table><br>
<a name="821135"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes that algorithm would be more accurate than a collusion hull because usually the hull is hugely approximated and not very close-fitting, so you could sometimes get collusions where there aren't collisions depending on how tightly the hull fits and thus how many points the polygon has.<br><br>With the above method - and you're understanding my idea pretty well - instead of having to store and figure out parts of a highly details hull polygon, you're basically creating one facet of the polygon in the location needed on the fly.<br><br>One drawback is if the edge of your sprite has pits or holes or is highly variegated, and if those features are smaller in detail than the size of your square sample, you might get confusing results as to exactly where the surface line should be. So you really need to sample as small an area as possible. Looks like your demo image is about 12x12 which is probably way too big. Probably 3x3 or 4x4 would be enough to get a good range of angles.<br><br>I was also thinking that some kind of averaging/smoothing should be involved. The angle of the line should approximately float through the middle of the contour. In your example you chose end pixels which are approximately in line with the rest of the edge, but that might not always be the case. I was thinking to either calculate the average line or to use the midpoint of a spline using the edge pixels for the two end points and then one or two additional control points near the middle of the contour.<br><br>It would be probably faster to read copies of your sprite data in main memory and figure out the collision than to try to read from the backbuffer lots of times. <br><br></td></tr></table><br>
<a name="821189"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >spacerat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yea, 12x12 is too big. I would say 5x5 is probably the best, 3x3 and 4x4 would be a bit too inaccurate for my liking. I'm not so sure about averaging though, it might seem like a good idea, but consider this blown up diagram small part of a sprite with holes in (or just a small sprite)<br><img src="http://xs320.xs.to/xs320/07435/pixzelz2.png"><br><br>The black lines in the first square try to justify averaging the pixels, but the thing is, all of them seem to fit, so which one do you use? (and, how do you even find this average?)<br><br>Then you have an extension of what I started before. You disregard all the pixels which aren't touching the background or next to the border, then pick the closest two  to the colliding object and use them to create the angle. Of course there's room for error, but as long as the sprite is constructed correctly, there's shouldn't be too much to worry about.<br><br>I'll start trying to program this soon, but I don't know if I'll be busy so it could be a couple of days before I get to work on it.<br><br>EDIT: I just remembered, there's also the question of how exactly you find the point of collision. Can you do it using Max2D's collision functions, or do you have to write your own pixel collision functions which can return the point of collision? <br><br></td></tr></table><br>
<a name="821309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> In the past I just made a 2d array which represented pixels in the object and then just calculated where in the array to look and then it would contain a direction I could then manipulate. Cheating, but it worked fine. <br><br></td></tr></table><br>
<a name="821428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's not a bad idea actually JGOware. Maybe you can have a linked list or some kind of tree which looks kind of like a `perimeter`, with one entry per pixel on the perimeter, and then each of those entries stores the angle of the surface at that pixel. Then it's just a matter of figuring out which pixels in the source and destination objects `hit` each other, or overlap. I guess even with your method, Spacerat, we'd have to consider how to do that efficiently too.<br><br>Regarding averaging I think I'd go with a 3-point bezier curve. You've already found the two end points so then you just search along a perpendicular line towards the center until you hit a solid pixel and thats the midpoint. Then you can use the bezier math to figure out the exact angle at any point on the curve.<br><br>When I was talking about averaging I was talking about looking at the contour of the edge of the sprite which is being hit and finding the angle for each adjacent set of 2 pixels and then taking the overall average of those sub-angles. <br><br></td></tr></table><br>
<a name="821483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gnasher</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> JGOware@ its newer cheating its problemsolving, "if it behaves   <br>and looks good, then use it" .. famous words from Carmac Id software :) <br><br>people that play games are often to busy on the task you have given them to solve, so there is room "for creative thinking" we as creators/artist tend to focus to much on details that we only see :)<br><br>a good example is Blizzards - World of warcraft, check out their textures, they have created illusions of 3d details on their textures by playing around with lights and shadows while pixlating em :) <br><br>//Gnasher <br><br></td></tr></table><br>
<a name="821874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BadJim</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have my own cunning little hack that works to some extent.  Say you are testing sprite 1 against sprite 2. Do say sixteen collision checks, with sprite 1 offset by a different angle each time. Add up the vectors of the offsets that didn't produce a collision and you generally have the angle the two objects collided at or a good approximation thereof<br><br>BTW the blitzmax collision detection is not nearly fast enough so you must roll your own collision code. Collision detection between sprites that aren't scaled or rotated can be really fast. Unfortunately because blitzmax handles scaled/rotated sprites it is slow. If you need to handle scaling and rotation too, you can create scaled/rotated collision masks and test them quickly.<br><br>Or you could just move on to vectors <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
