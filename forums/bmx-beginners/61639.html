<!DOCTYPE html><html lang="en" ><head ><title >Type Byte</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Type Byte</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >Type Byte</a><br><br>
<a name="688966"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Has there always been a type BYTE?<br><br>I could have sworn that there wasnt a type Byte. Yet there is. Why would I think that there wasnt a type byte? <br><br></td></tr></table><br>
<a name="688990"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Has there always been a type BYTE? <br></div>Yes. Just don't use it. <br><br></td></tr></table><br>
<a name="688996"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Azathoth</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about in user types or arrays? <br><br></td></tr></table><br>
<a name="689011"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> You might be able to get away with it in arrays, but in general, unless it's for some sort of interoperability with legacy software that you simply must use, I'd advise against it. <br><br></td></tr></table><br>
<a name="689020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> The only time I use Byte is with the word Ptr on the end - Byte Ptr.<br>But then that is something altogether entirely different.<br><br>Are there any "good" reasons why one might *want* to use a Byte type? <br><br></td></tr></table><br>
<a name="689024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm using bytes all over the place in my tile engine. No need to waste 3 extra bytes on an int when I need to store 6 draw flags.<br><br>Considering the number of tiles and the size of my map, I need to save every byte I can. <br><br></td></tr></table><br>
<a name="689026"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> No there is no reason to use byte.<br>While it might sound nice from the ram waste point of view, Byte are significantly slower than Int.<br>So you should really only use them if it is in a speed uncritical part or for interfacing with C <br><br></td></tr></table><br>
<a name="689027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can somebody provide some example code showing how much slower bytes are than ints? I agree that they're slower but is it really by that much? Isn't it another trade-off between space used vs performance? <br><br></td></tr></table><br>
<a name="689033"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why are they slower? <br><br></td></tr></table><br>
<a name="689037"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CS_TBL</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Internally they're uplifted to INT for the calculations. So if you're directly using an INT then you save this byte-&gt;int conversion.. <br><br></td></tr></table><br>
<a name="689044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> If Byte is just a cutdown Int, then I probably read about it and promptly ignored its existance.<br><br>Still it was a bit weird. <br><br></td></tr></table><br>
<a name="689045"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Regular OS today are 32Bit<br>For that reason all operations (especially in GCC) are optimised in 32Bit which is the reason Int / Float are the prefered data type for anything speed critical.<br>With 512MB+ of RAM, 3 Byte more or less don't make a difference, not even with 1000 or 10000 objects of the type <br><br></td></tr></table><br>
<a name="689056"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm sure it is impossible to quantify an exact amount, but does anyone know approximately how much slower using a byte or short would be, in general, in real world applications.<br><br>If there's a noticeable difference I'll just convert my current byte fields (which only need a range of 0-255) to ints, but write them to disk as a byte. <br><br>It's not the RAM usage that I'm worried about in my game, it's disk space. I mean, there's a big difference between requiring 1gb of disk space, or 4gb (or more). <br><br></td></tr></table><br>
<a name="689071"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I'm sure it is impossible to quantify an exact amount, but does anyone know approximately how much slower using a byte or short would be, in general, in real world applications. <br></div>It is unlikely there is any real difference since bytes are most likely zero padded to be 32-bit address aligned anyway.<pre class=code>Type aType
	Field a:Int
	Field b:Byte
	Field c:Int
EndType

Print SizeOf( New aType)</pre>Oh look. It prints 12. <br><br></td></tr></table><br>
<a name="689072"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats what I said, but I said "Cut down Int" ;)<br><br>However...... <br><br>Question: The compiler must deal with overflow on some level. So there must be some sort of bounds checking added to byte. (Or am i missing something here). And if there is, that must be a speed overhead. No?<br><br>Iv just checked<br><pre class=code>Type aType
	Field a:Int 
	Field b:Byte 
	Field b1:Byte
	
	Field c:Int
EndType

Print SizeOf( New aType)</pre>Is also 12<br><br>So it might have ror and rol in there as well. <br><br></td></tr></table><br>
<a name="689074"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why would it need a bound checking?<br>Its handled the same as on it -&gt; overflow is handled with "entering the lowest posible number" -&gt; 255+1 = 0<br><br>Here is a little benchmark code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Rem
	Small benchmarking of byte, short vs int on access and operation
End Rem

Strict


Local bVal:Byte	= 0
Local sVal:Short = 0
Local iVal:Int = 0


Local t1:Int,t2:Int,t3:Int

' Byte test
t1 = MilliSecs()
For Local i:Int = 1 To 100000
	For Local k:Int = 1 To 100
		bVal = (bVal + Rand(1, 1000)) Mod 256
	Next
	For Local k:Int = 1 To 100
		bVal = (bVal * Rand(1, 100)) Mod 256
	Next
	For Local k:Int = 1 To 100
		bVal = (bVal Shl 1) Mod 256
	Next
Next
t1 = MilliSecs() - t1
Print "Byte Operations took: " + t1 + " milliseconds."

' Short test
t2= MilliSecs()
For Local i:Int = 1 To 100000
	For Local k:Int = 1 To 100
		sVal = (sVal + Rand(1, 1000)) Mod 256
	Next
	For Local k:Int = 1 To 100
		sVal = (sVal * Rand(1, 100)) Mod 256
	Next
	For Local k:Int = 1 To 100
		sVal = (sVal Shl 1) Mod 256
	Next
Next
t2 = MilliSecs() - t2
Print "Short Operations took: " + t2 + " milliseconds."

' Int test
t3 = MilliSecs()
For Local i:Int = 1 To 100000
	For Local k:Int = 1 To 100
		iVal = (iVal + Rand(1, 1000)) Mod 256
	Next
	For Local k:Int = 1 To 100
		iVal = (iVal * Rand(1, 100)) Mod 256
	Next
	For Local k:Int = 1 To 100
		iVal = (iVal Shl 1) Mod 256
	Next
Next
t3 = MilliSecs() - t3
Print "Integer Operations took: " + t3 + " milliseconds."
</textarea><br><br>My results:<br><div class="quote"> <br>Byte Operations took: 2545 milliseconds.<br>Short Operations took: 2616 milliseconds.<br>Integer Operations took: 2553 milliseconds. <br></div><br><br><br>Thing to mention:<br><br>I'm working on a Core Duo T2500 @ 2Ghz with fully rebuild modules on most actual GCC version (not the one used with BM originally). So could someone on a regular system (single core, perhaps P4 3ghz or the like without rebuilt modules) test that as well? <br><br></td></tr></table><br>
<a name="689078"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>If</b> it was a padded INT it would need bounds checking.<br>As I dont think it <i>is</i> a padded int, it doesnt. (It was a badly delevered NOR example)<br><br>I was pointing out that it didnt need bounds checking, because of its size. Which it would have needed if Flames suggestion about the padded ints was right.<br><br>A single byte needs the same space as an Int, two btyes need the same space as an int etc<br><br>Edit: What was sudgested was that there wouldnt be a significant increase in size. And that Bytes would be stored as INTs. <i>If</i> this was so there would need to be some bounds checking placed ontop of the int. As <i>both</i> you and I proved, this was not so. <br><br></td></tr></table><br>
<a name="689080"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> What was said is that it could be used as padded int on operations (makes sense as BM only has 3 arithmetic levels: Int, float and double). <br><br></td></tr></table><br>
<a name="689084"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Byteemoz</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> The compiler will propably clamp the value to one byte, so<pre class=code>MyByte:Byte = 2000</pre>becomes<pre class=code>MyByte:Int = 2000 &amp; $FF</pre><br>The benchmark (PC):<div class="quote"> Byte Operations took: 4511 milliseconds.<br>Short Operations took: 4569 milliseconds.<br>Integer Operations took: 4488 milliseconds. <br></div><br>(Mac)<div class="quote"> Byte Operations took: 3626 milliseconds.<br>Short Operations took: 3569 milliseconds.<br>Integer Operations took: 3419 milliseconds. <br></div><br>-- Byteemoz <br><br></td></tr></table><br>
<a name="689091"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> My results...<br>   Byte Operations took: 4019 milliseconds.<br>   Short Operations took: 4158 milliseconds.<br>   Integer Operations took: 4004 milliseconds.<br>It suggests that bytes are not 'significantly' slower but, if they take the same to store no need to use them. <br>Is that right? <br><br></td></tr></table><br>
<a name="689109"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Byte Operations took: 9073 milliseconds.<br>Short Operations took: 9086 milliseconds.<br>Integer Operations took: 9029 milliseconds.<br><br><br>Yeah, my system is showing it's age. <br><br></td></tr></table><br>
<a name="689112"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> My results:<br>Byte Operations took: 6047 milliseconds.<br>Short Operations took: 6282 milliseconds.<br>Integer Operations took: 6048 milliseconds. <br><br></td></tr></table><br>
<a name="689117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> So GCC has some quite intelligent way of using them.<br>Good to know ... so short is the "slowest" type beside long and double naturally <br><br></td></tr></table><br>
<a name="689144"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CS_TBL</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> AMD XP2.0 win98se 256MB, lotsa crap in mem prolly, like emule and such.. :P<br><br>debugmode:<br>Byte Operations took: 10734 milliseconds.<br>Short Operations took: 10757 milliseconds.<br>Integer Operations took: 10691 milliseconds.<br><br>releasemode:<br>Byte Operations took: 5344 milliseconds.<br>Short Operations took: 5355 milliseconds.<br>Integer Operations took: 5297 milliseconds.<br><br>So, in the end, speed does differ a bit, but is the minor difference a reason to avoid bytes for using large maps etc. to save on disk/mem-space? <br><br></td></tr></table><br>
<a name="689256"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Abomination</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Most computers restrict shorts and integer accesses to be “aligned”. A short must start at an even address and a integer must start at an address that is a multiple of 4.<br>so:<pre class=code>Type aType
	Field a:Int
	Field b1:Byte
	Field b2:Byte
	Field b3:Byte
	Field b4:Byte
	Field c:Int
EndType

Print SizeOf( New aType)</pre>It's still 12<pre class=code>Type aType
	Field b1:Byte
	Field a:Int
	Field b2:Byte
	Field c:Int
	Field b3:Byte
	Field b4:Byte
EndType

Print SizeOf( New aType)</pre>It's 18<br>So if you cluster your bytes, 4 of them take as much space as 1 integer. <br><br></td></tr></table><br>
<a name="689600"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> One example where you might want to use byte POINTERS at least is for manually manipulating 8-bit-per-component pixel data. However, in that case, you can read in a whole integer and then separate out the bytes using extra instructions - probably faster than doing 4 memory reads. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
