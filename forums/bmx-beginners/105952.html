<!DOCTYPE html><html lang="en" ><head ><title >Arrow Error</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Arrow Error</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >Arrow Error</a><br><br>
<a name="1298898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is not so much an error as what I believe to be an incorrect way of handling an infinite number of objects on any tiled surface.<br><br>The problem I have always had is - once I select an object and the script, if it moves from where it is, I must flag it so it is not chosen again when doing a scan.<br><br>I'm posting this in the hopes that someone can show me a smaller code example which does not require me to reset the objects each time.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' example of controlling every item on a grid
Strict
SeedRnd MilliSecs() ' ensure random results each time

Global img_tile:TImage[8],tileno
inittiles "081c3e7f1c1c1c00,468,080c7e7f7e0c0800,648,08183f7f3f180800,486,1c1c1c7f3e1c0800,864"

Global scrn[31,23] ' full screen size of 31x23 tiles at 32x32 pixels, 8x8 zoomed 4x

Local i,j,c,ok

SetGraphicsDriver GLMax2DDriver(),0
Graphics 1024,768
SetScale 4,4

For i=0 Until 23
  For j=0 Until 31
    If fnr(32)=0 And j Mod 2=0 Then scrn[j,i]=1
    If fnr(32)=0 And j Mod 2 Then scrn[j,i]=4
    If fnr(32)=0 And i Mod 2=0 Then scrn[j,i]=2
    If fnr(32)=0 And i Mod 2 Then scrn[j,i]=3
  Next
Next

Repeat ' {* MAIN *}

For i=0 Until 23
  For j=0 Until 31
    c=getscrn(j,i) ' read in each tile
    ok=0
    If c=1 And getscrn(j,i-1)=0 Then scrn[j,i-1]=-1 ; ok=1 ' Move arrow in designated direction IF area is free
    If c=2 And getscrn(j-1,i)=0 Then scrn[j-1,i]=-2 ; ok=1 ' negative is necessary so the tile is not reselected
    If c=3 And getscrn(j+1,i)=0 Then scrn[j+1,i]=-3 ; ok=1 ' in this one pass. Would be interested in a smaller
    If c=4 And getscrn(j,i+1)=0 Then scrn[j,i+1]=-4 ; ok=1 ' coding method
    If ok Then scrn[j,i]=0
  Next
Next

' There should be a smaller code solution for this
For i=0 Until 23
  For j=0 Until 31
    scrn[j,i]=Abs(scrn[j,i]) ' mark so tiles can be scanned again
  Next
Next

update

If WaitChar()=27 Then End ' wait key and exit on ESCAPE key

Forever ' {* END OF MAIN *}

' &gt;&gt; UPDATE SCREEN WITH TILES
Function update()
Local i,j,n
  Cls
  For i=0 Until 23
    For j=0 Until 31
      SetColor 32,64,96
      DrawRect j*32+16,i*32,7,7 ' draw a tile to see edges
      n=scrn[j,i]
      If n
        SetColor 255,255,255 ' always reset color when plotting any tiles
        DrawImage img_tile[n-1],j*32+16,i*32 ' draw arrow images
      EndIf
    Next
  Next
  Flip 0 ' show our work
EndFunction

' &gt;&gt; CONVERT ONE LONG STRING TO LITTLE 8x8 IMAGES
Function inittiles(t$)
Local i,j,v,n,a,p$,r,g,b,c$
Local pic:TPixmap=CreatePixmap(8,8,pf_rgb888) ' work image
  While t$&gt;""
    p$=yank$(t$) ' image (16-characters, 8-bytes)
    c$=yank$(t$) ' color (3-characters)
    r=c$[0..1].toint()*32 ; g=c$[1..2].toint()*32 ; b=c$[2..3].toint()*32 ' set color
    If r=256 Then r=255 ' make sure it doesn't wrap
    If g=256 Then g=255
    If b=256 Then b=255
    a=b|g Shl 8|r Shl 16 ' calculate color
    ClearPixels pic,0 ' erase each time
    For i=0 Until 8
      v=("$"+p$[i*2..i*2+2]).toint() ' get full pixels across in one number
      For j=7 To 0 Step -1 ' reverse order to extract highest value bits first
        n=1 Shl j ' extract out bit pixels
        If v&gt;=n
          v:-n
          WritePixel pic,j,i,a ' write out single pixel
        EndIf
      Next
    Next
    img_tile[tileno]=LoadImage(MaskPixmap(pic,0,0,0),0) ' record and make it transparent all in one line
    tileno:+1 ' total tile numbers used
  Wend
EndFunction

' &gt;&gt; RETRIEVE SCREEN TILE EVEN IF OFF EDGES
Function getscrn(x,y)
Local r=-1
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then r=scrn[x,y]
  Return r
EndFunction

' &gt;&gt; RETURN COMMA DELIMITED TEXT FROM A$
Function yank$(a$ Var)
Local b=Instr(a$+",",","),c$=Left$(a$,b-1)
  a$=Mid$(a$,b+1) ' also remove it from input string
  Return c$
EndFunction

' &gt;&gt; QUICK RETRIEVE RANDOM 0 to A-1
Function fnr(a)
  Return Rand(a)-1
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="1299058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Without reading any of your code and only basing this on this sentence:<br><div class="quote"> The problem I have always had is - once I select an object and the script, if it moves from where it is, I must flag it so it is not chosen again when doing a scan. <br></div><br><br>This might be a case where you'll need to use a custom Type, giving it a field "flagged". E.g.<br><br><pre class=code>
SuperStrict

Local ScreenWidth:Int = 1024
Local ScreenHeight:Int = 768

Graphics ScreenWidth, ScreenHeight

Type TTile
	
	Field x:Int
	Field y:Int
	Field color:Int[3]
	Field flagged:Int = 0
	Field size:Int

	Function Create:TTile(x:Int, y:Int, size:Int)
		Local tile:TTile = New TTile
		tile.x = x
		tile.y = y
		tile.size = size
		tile.color = [Rand(0, 255), Rand(0, 255), Rand(0, 255)]

		Return tile
	End Function

	Method Draw()

		If flagged Return 'do not draw a flagged tile!

		SetColor(color[0], color[1], color[2])
		DrawOval(x * size, y * size, size, size)

	End Method

End Type

Local xTiles:Int = ScreenWidth / 22 ' nr of horizontal tiles
Local yTiles:Int = ScreenHeight / 22 ' nr of vertical tiles

Local tiles:TTile[xTiles * yTiles]
Local counter:Int = 0
For Local x:Int = 0 To xTiles - 1
	For Local y:Int = 0 To yTiles - 1
		tiles[counter] = TTile.Create(x, y, 20)
		counter:+1
	Next
Next

counter = 0
While Not KeyDown(KEY_ESCAPE)

	Cls

	counter:+1
	For Local t:TTile = EachIn tiles
		t.Draw()
	Next

	If counter Mod 30 = 0
		tiles[Rand(0, tiles.Length - 1)].flagged = 1
	EndIf
	
	Flip()
	
Wend
</pre><br><br>I can not look at it too long though - it's pretty trippy :) <br><br></td></tr></table><br>
<a name="1299096"></a>

<a name="1299097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have updated the code, I call it "Traffic" now, Cocopino.<br><br>Yet your code is still using an additional For/Next loop. What I want to do is write this, preferably without TYPE variables, and definitely using only =1= For/Next set.<br><br>For I vertical, For J horizontal, and no other loops outside repeating the process.<br><br>So no For/Next loop where I have to reset flags. There should be a way to do this all in smaller code.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'     ________________________________________
'    //                                     //
'   // "T R A F F I C"                     //
'  // Version: "Infinite Highway"         //
' // Written by David W (dw817) 03/09/16 //
'//_____________________________________//
'
' What's up ??
' Set it so there is more traffic and when it reaches the
' end, it does not stop but instead vanish - allowing more
' traffic to cross.

Strict
SeedRnd MilliSecs() ' ensure random results each time

Global img_tile:TImage[8],tileno
inittiles "081c3e7f1c1c1c00,468,080c7e7f7e0c0800,648,08183f7f3f180800,486,1c1c1c7f3e1c0800,864"
' ^ pack in 4 8x8 pixeled images, in this case arrows

Global scrn[31,23] ' full screen size of 31x23 tiles at 32x32 pixels, 8x8 pixels zoomed 4x

Local i,j,c,ok,x,y,r

SetGraphicsDriver GLMax2DDriver(),0
Graphics 1024,768
SetScale 4,4

Repeat ' {* MAIN *}

r=fnr(4)
If r=0
  scrn[fnr(15)*2,22]=1
ElseIf r=1
  scrn[30,fnr(11)*2]=2
ElseIf r=2
  scrn[0,fnr(11)*2+1]=3
ElseIf r=3
  scrn[fnr(15)*2+1,0]=4
EndIf

update

For i=0 Until 23
  For j=0 Until 31
    c=getscrn(j,i) ' read in each tile on the playfield
    ok=0
    If c=1 And getscrn(j,i-1)=0 Then scrn[j,i-1]=-1 ; ok=1 ' Move arrow in designated direction IF area is free
    If c=2 And getscrn(j-1,i)=0 Then scrn[j-1,i]=-2 ; ok=1 ' negative is necessary so the tile is not reselected
    If c=3 And getscrn(j+1,i)=0 Then scrn[j+1,i]=-3 ; ok=1 ' in this one pass. I would be interested in a smaller
    If c=4 And getscrn(j,i+1)=0 Then scrn[j,i+1]=-4 ; ok=1 ' coding method to get around this.
    If ok Then scrn[j,i]=0
    If i=0 And scrn[j,i]=1 Then scrn[j,i]=0
    If j=0 And scrn[j,i]=2 Then scrn[j,i]=0
    If j=30 And scrn[j,i]=3 Then scrn[j,i]=0
    If i=22 And scrn[j,i]=4 Then scrn[j,i]=0
  Next
Next

' There should be a code solution that uses only =1= For/Next set
For i=0 Until 23
  For j=0 Until 31
    scrn[j,i]=Abs(scrn[j,i]) ' mark so tiles can be scanned again
  Next
Next

Delay 150
If KeyDown(27) Then End ' wait key and exit on ESCAPE key

Forever ' {* END OF MAIN *}

' &gt;&gt; UPDATE SCREEN WITH TILES
Function update()
Local i,j,n
  Cls
  For i=0 Until 23
    For j=0 Until 31
      SetColor 32,64,96
      DrawRect j*32+16,i*32,7,7 ' draw a square to see edges
      n=scrn[j,i]
      If n
        SetColor 255,255,255 ' always reset color when plotting any tiles
        DrawImage img_tile[n-1],j*32+16,i*32 ' draw arrow images
      EndIf
    Next
  Next
  Flip 0 ' show our work
EndFunction

' &gt;&gt; CONVERT ONE LONG STRING TO LITTLE 8x8 IMAGES
Function inittiles(t$)
Local i,j,v,n,a,p$,r,g,b,c$
Local pic:TPixmap=CreatePixmap(8,8,pf_rgb888) ' work image
  While t$&gt;""
    p$=yank$(t$) ' image (16-characters, 8-bytes)
    c$=yank$(t$) ' color (3-characters)
    r=c$[0..1].toint()*32 ; g=c$[1..2].toint()*32 ; b=c$[2..3].toint()*32 ' set color
    If r=256 Then r=255 ' make sure it doesn't wrap
    If g=256 Then g=255
    If b=256 Then b=255
    a=b|g Shl 8|r Shl 16 ' calculate color
    ClearPixels pic,0 ' erase each time
    For i=0 Until 8
      v=("$"+p$[i*2..i*2+2]).toint() ' get full pixels across in one number
      For j=7 To 0 Step -1 ' reverse order to extract highest value bits first
        n=1 Shl j ' extract out bit pixels
        If v&gt;=n
          v:-n
          WritePixel pic,j,i,a ' write out single pixel
        EndIf
      Next
    Next
    img_tile[tileno]=LoadImage(MaskPixmap(pic,0,0,0),0) ' record and make it transparent all in one line
    tileno:+1 ' total tile numbers used
  Wend
EndFunction

' &gt;&gt; RETRIEVE SCREEN TILE EVEN IF OFF EDGES
Function getscrn(x,y)
Local r=-1
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then r=scrn[x,y]
  Return r
EndFunction

' &gt;&gt; RETURN COMMA DELIMITED TEXT FROM A$
Function yank$(a$ Var)
Local b=Instr(a$+",",","),c$=Left$(a$,b-1)
  a$=Mid$(a$,b+1) ' also remove it from input string
  Return c$
EndFunction

' &gt;&gt; QUICK RETRIEVE RANDOM 0 to A-1
Function fnr(a)
  Return Rand(a)-1
EndFunction
</textarea><br><br>Despite this, it is STILL possible to have a traffic pileup, can you see how ? <br><br></td></tr></table><br>
<a name="1299110"></a>

<a name="1299111"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Yet your code is still using an additional For/Next loop <br></div><br><br>It's only using a single, not nested, draw/update loop. The other loop is just there for initialization. Yours is using 2 nested loops in main, so I'm not sure what you mean there?<br><br>I just wanted to show an example of how you could use a custom Type to store information about the object: x value, y value, direction, flagged, whatever. The more information you need to store per object, the harder it becomes to circumvent using a Type.<br><br>Running your code, I think you could try having the "cars" wait for each other if moving in the same direction, always leaving at least one open space. <br><br></td></tr></table><br>
<a name="1299116"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Cocopino.<br><br>Here is a solution to this problem, albeit not an entirely elegant one.<br><br>I can look for the inverse of the set. That is, once I find an arrow and it needs to move, mark it with the negative value of what it is. If it's already negative, make the marker positive, if it's already positive, make it negative.<br><br>Outside the loop flip the switch to make it look for positive and write for negative and vice-versa.<br><br>But I still think there should be an easier way to do this, using only =2= For/Next loops in toto.<br><br>Having the cars with one space between them will still not prevent collisions coming from other directions.<br><br>If you hadn't solved it, and it was a tricky question, :) it is possible to create a traffic jam by 4 of them going in each of 4-directions colliding into each other at once.<br><br>A simple solution would be to see if one or more arrows has not moved for 3- or more turns, and if so, vanish from the map. <br><br></td></tr></table><br>
<a name="1299165"></a>

<a name="1299166"></a>

<a name="1299167"></a>

<a name="1299168"></a>

<a name="1299169"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> d1817 I looked at the arrows and had an epiphany, two cars going opposite direction of course has no way to avoid a crash despite how much they wait. But apposite dimensions could coordinate themselves in speed when they see eachother.<br><br>The epipany was; if both slows down equally much there would be still a crash (if they where in for a crash with their current speeds). <br>Avoidance all boils down to just ONE thing - to change their relative speeds. They have to balance those.<br><br>It might be good or not continue full speed and then one of them goes full stop and wait just the tile before. But It's hard to predict which one should wait and which one should continue.<br>I Get this problem all the time even when walking downtown haha.<br>The best option would be to see predict what they see, and when they see approaching objects they use their speeds as a communication with eachother. <br>You slowdown (maybe speedup abit even), to coordinate a non-crash.<br><br>I like that example. It's a very interesting problem. <br><br></td></tr></table><br>
<a name="1299170"></a>

<a name="1299171"></a>

<a name="1299172"></a>

<a name="1299173"></a>

<a name="1299174"></a>

<a name="1299175"></a>

<a name="1299176"></a>

<a name="1299177"></a>

<a name="1299178"></a>

<a name="1299179"></a>

<a name="1299180"></a>

<a name="1299181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> d1817 I looked at the arrows and had an epiphany, two cars going opposite direction of course has no way to avoid a crash despite how much they wait. But apposite dimensions could coordinate themselves in speed when they see eachother.<br><br>The epipany was; if both slows down equally much there would be still a crash (if they where in for a crash with their current speeds). <br>Avoidance all boils down to just ONE thing - to change their relative speeds. They have to balance those.<br><br>It might be good or not to continue full speed and then one of them goes full stop and wait just the tile before. But It's hard to predict which one should wait and which one should continue.<br>I Get this problem all the time even when walking downtown haha.<br>The best option would be to predict what they see  and when they see approaching objects they should use their speeds as a communication with eachother. <br>You slowdown (maybe speedup abit even), to coordinate a non-crash.<br><br>I like that example. It's a very interesting problem.<br><br>EDIT<br><br>I guess the hard bit is that it can be more than one collision acoming so it would not be a perfect solution to have that, <br>it could create a deadlock if too many (or few with in a weird situation).<br>Also.. as changing their own speed also change all their new potential crashes,<br>each one should take in their near environment and predict to try minimise the number of upcoming crashes using their speed.<br><br>I think consistency is key, you should never jump around with different speeds, that would make everyone else <br>uneasy as you get very hard to predict. So the responsibility each one would have is to be pretty predictiable and smooth <br>in every change of their speed.<br><br>Doing a full stop one or a few tiles before potential crashes would be the extreme case of it. So it all makes sense.<br><br>I´m thinking about how to read the speeds of others programmatically. Perhaps something like redlight flags before a slowdown. That others can see. <br>I guess it's about showing "Hey I AM ABOUT TO CHANGE me speed here the next second, please adjust yours accordingly".<br><br>Those where just a few ideas I had. I havn't tried any of them in code yet I think it should be possible with very few <br>lines as this solution feels very natural and true to me I would give that a shot.<br><br>EDIT2<br>I guess the problem if you only had two speeds (perfect still and, and..  moving in some direction) Then you have another side of the problem. "Binary traffic".<br>If you did this then you convert speed into time.(like a switch on / off) Move or no move. And you use redlight flags to tell them if they are moving alot or not as much. So that would bridge into that.<br><br>Some kind of communication need to happen within the close area. Using others and your own position and speed and maybe flags that everyone closeby can see. <br><br></td></tr></table><br>
<a name="1299195"></a>

<a name="1299196"></a>

<a name="1299198"></a>

<a name="1299199"></a>

<a name="1299200"></a>

<a name="1299201"></a>

<a name="1299208"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Casaber, that's a real brainweave you have there. :)<br><br>The point of games like this is that all objects run at the same speed. They work on a tight grid and one update is equivalent to moving one grid square. That's about as old-school as you can get and many MANY games that could handle an infinite number of objects in one screen used this method.<br><br>I already set it so head-on collisions are impossible by releasing cars from opposite sides in modulos based on their direction. Same for perpendicular parallels.<br><br>No, the easy solution would be the double inverse I was talking about earlier. Here, let me see if I can code that:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'     ________________________________________
'    //                                     //
'   // "T R A F F I C"                     //
'  // Version: "Negative Solution"        //
' // Written by David W (dw817) 03/09/16 //
'//_____________________________________//
'
' What's up ??
' Set it so there is more traffic and when it reaches the
' end, it does not stop but instead vanish - allowing more
' traffic to cross.
'
' Developed a method of handling whether or not I am
' READING or WRITING to the map by using a single
' variable called NEG.

Strict
SeedRnd MilliSecs() ' ensure random results each time

Global img_tile:TImage[8],tileno
inittiles "081c3e7f1c1c1c00,468,080c7e7f7e0c0800,648,08183f7f3f180800,486,1c1c1c7f3e1c0800,864"
' ^ pack in 4 8x8 pixeled images, in this case arrows

Global scrn[31,23] ' full screen size of 31x23 tiles at 32x32 pixels, 8x8 pixels zoomed 4x

Local i,j,c,ok,x,y,r,neg=1

SetGraphicsDriver GLMax2DDriver(),0
Graphics 1024,768
SetScale 4,4

Repeat ' {* MAIN *}

r=(r+1)Mod 4 ' everyone gets equal traffic time
If r=0
  scrn[fnr(16)*2,22]=1*neg ' appears at bottom
ElseIf r=1
  scrn[30,fnr(11)*2]=2*neg ' appears at right
ElseIf r=2
  scrn[0,fnr(11)*2+1]=3*neg ' appears at left
Else ' no need to compare for 3
  scrn[fnr(15)*2+1,0]=4*neg ' appears at top
EndIf

update

For i=0 Until 23
  For j=0 Until 31
    c=getscrn(j,i) ' read in each tile on the playfield
    ok=0
    If c=1*neg And getscrn(j,i-1)=0 Then scrn[j,i-1]=-1*neg ; ok=1 ' Move arrow in designated direction IF area is free.
    If c=2*neg And getscrn(j-1,i)=0 Then scrn[j-1,i]=-2*neg ; ok=1 ' Negative is necessary so the tile is not reselected
    If c=3*neg And getscrn(j+1,i)=0 Then scrn[j+1,i]=-3*neg ; ok=1 ' in this one pass or it fills the board needlessly.
    If c=4*neg And getscrn(j,i+1)=0 Then scrn[j,i+1]=-4*neg ; ok=1
    If ok Then scrn[j,i]=0 ' erase last position where they were
    If i=0 And scrn[j,i]=1*neg Then scrn[j,i]=0 ' clear out any that have successfully
    If j=0 And scrn[j,i]=2*neg Then scrn[j,i]=0 ' traveled the length of the screen
    If j=30 And scrn[j,i]=3*neg Then scrn[j,i]=0
    If i=22 And scrn[j,i]=4*neg Then scrn[j,i]=0
  Next
Next

neg=-neg ' BAM ! This resets all positions so they can be read again

If KeyDown(32)=0 Then Delay 150
If KeyDown(27) Then End ' wait key and exit on ESCAPE key

Forever ' {* END OF MAIN *}

' &gt;&gt; UPDATE SCREEN WITH TILES
Function update()
Local i,j,n
  Cls
  For i=0 Until 23
    For j=0 Until 31
      SetColor 32,64,96
      DrawRect j*32+16,i*32,7,7 ' draw a square to see edges
      n=scrn[j,i]
      If n
        SetColor 255,255,255 ' always reset color when plotting any tiles
        DrawImage img_tile[Abs(n)-1],j*32+16,i*32 ' draw arrow images, NOTICE it is the absolute value !
      EndIf
    Next
  Next
  Flip 0 ' show our work
EndFunction

' &gt;&gt; CONVERT ONE LONG STRING TO LITTLE 8x8 IMAGES
Function inittiles(t$)
Local i,j,v,n,a,p$,r,g,b,c$
Local pic:TPixmap=CreatePixmap(8,8,pf_rgb888) ' work image
  While t$&gt;""
    p$=yank$(t$) ' image (16-characters, 8-bytes)
    c$=yank$(t$) ' color (3-characters)
    r=c$[0..1].toint()*32 ; g=c$[1..2].toint()*32 ; b=c$[2..3].toint()*32 ' set color
    If r=256 Then r=255 ' make sure it doesn't wrap
    If g=256 Then g=255
    If b=256 Then b=255
    a=b|g Shl 8|r Shl 16 ' calculate color
    ClearPixels pic,0 ' erase each time
    For i=0 Until 8
      v=("$"+p$[i*2..i*2+2]).toint() ' get full pixels across in one number
      For j=7 To 0 Step -1 ' reverse order to extract highest value bits first
        n=1 Shl j ' extract out bit pixels
        If v&gt;=n
          v:-n
          WritePixel pic,j,i,a ' write out single pixel
        EndIf
      Next
    Next
    img_tile[tileno]=LoadImage(MaskPixmap(pic,0,0,0),0) ' record and make it transparent all in one line
    tileno:+1 ' total tile numbers used
  Wend
EndFunction

' &gt;&gt; RETRIEVE SCREEN TILE EVEN IF OFF EDGES
Function getscrn(x,y)
Local r=-1
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then r=scrn[x,y]
  Return r
EndFunction

' &gt;&gt; RETURN COMMA DELIMITED TEXT FROM A$
Function yank$(a$ Var)
Local b=Instr(a$+",",","),c$=Left$(a$,b-1)
  a$=Mid$(a$,b+1) ' also remove it from input string
  Return c$
EndFunction

' &gt;&gt; QUICK RETRIEVE RANDOM 0 to A-1
Function fnr(a)
  Return Rand(a)-1
EndFunction
</textarea><br><br><b>Updated 03-09-16 10:26pm</b><br><br>Success ! There is only the main 2-level FOR/NEXT loop being done now. By using the variable NEG and negating it only after the entire area has been updated, I can easily swap out the READ &amp; WRITE state of the map.<br><br>BTW, hold down space to speed it up and try to create a 4-level traffic jam.<br><br>This will only occur when a North traveling car hits a West traveling car which also hits a South traveling car and it in turn hits an East traveling car, locking all 4-cars down.<br><br>This is the only way to create a traffic jam, so it's pretty rare when it happens.<br><br>Also changed it so everyone gets equal traffic time. It's no longer random from which direction a car is added. <br><br></td></tr></table><br>
<a name="1299202"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whow I havn't seen a single deadlock or crash yet in your example even if it has zero communication. That last code had great flow.<br>Nice solution !!<br><br>What kind of game are you doing anyways? <br><br></td></tr></table><br>
<a name="1299203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got pile up now, but it's really rare. I honestly thought it was impossible for a long time. <br><br></td></tr></table><br>
<a name="1299227"></a>

<a name="1299228"></a>

<a name="1299230"></a>

<a name="1299231"></a>

<a name="1299240"></a>

<a name="1299241"></a>

<a name="1299242"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like this problem :)<br>Here's my take on it. Sorry dw817 but I have too much trouble not using Types.<br>I implemented a failedToMove counter and a Cheat() method loosely based on Casabers speed up suggestion:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Graphics 1024,768

Global maxX:Int = 32
Global maxY:Int = 24
Global size:Int = 34

Global Map:Int[maxX + 6, maxY + 6]

Type TCar

	Field direction:Int '1=north, 2=east, 3=south, 4=west
	Field x:Int
	Field y:Int
	Field alive:Int = 1
	Field color:Int[3]
	Field failedToMove:Int = 0

	Method New()

		direction = Rand(1, 4)

		Select direction
			Case 1
				x = GetStartPosition(1, 4, 32) ; y = maxY + 1;color = [255, 0, 0]
			Case 2
				x = 1; y = GetStartPosition(1, 4, 24) ;color = [0, 255, 0]
			Case 3
				x = GetStartPosition(0, 4, 32) ; y = 1;color = [0, 0, 255]
			Case 4
				x = maxX + 1; y = GetStartPosition(0, 4, 24) ;color = [255, 0, 255]
		End Select
		
		If Map[x, y] &lt;&gt; 0
			KillMe()
			Return
		EndIf

		Map[x, y] = direction

	End Method

	Method GetStartPosition:Int(odd:Int, RangeMin:Int, RangeMax:Int)

		Local pos:Int = Rand(RangeMin, RangeMax)
		While pos Mod 2 &lt;&gt; odd
			pos = Rand(RangeMin, RangeMax)
		Wend
		Return pos

	End Method
	
	Method Update()

		Select direction
			Case 1
				Move(0, -1)
			Case 2
				Move(1, 0)
			Case 3
				Move(0, 1)
			Case 4
				Move(-1, 0)
		End Select

	End Method

	Method Move(xDir:Int, yDir:Int)

		If failedToMove &gt; 9 Cheat()

		If Not alive Return
		
		If xDir &gt; 0 And x &gt; maxX - 2 Then KillMe
		If xDir &lt; 0 And x &lt; 2 Then KillMe
		If yDir &gt; 0 And y &gt; maxY - 2 Then KillMe
		If yDir &lt; 0 And y &lt; 2 Then KillMe
		
		If Map[x + xDir, y + yDir] &lt;&gt; 0 Then
			failedToMove:+1
			Return
		EndIf

		Map[x, y] = 0
		Map[x + xDir, y + yDir] = direction
		x = x + xDir
		y = y + yDir
		
		failedToMove = 0

	End Method

	Method MoveTo(newX:Int, newY:Int)

		If Not alive Return

		Map[x, y] = 0
		Map[newX, newY] = direction
		x = newX
		y = newY

	End Method

	Method Cheat()

		Local foundNewSpot:Int = 0, i:Int
		Select direction
			Case 1 'going up
				For i = y To 1 Step - 1
					If Map[x, i] = 0 MoveTo(x, i) ;foundNewSpot = 1; Exit;
				Next
			Case 2 'going right
				For i = x To maxX
					If Map[x, i] = 0 MoveTo(x, i) ;foundNewSpot = 1;Exit;
				Next
			Case 3 'going left
				For i = x To 1 Step - 1
					If Map[x, i] = 0 MoveTo(x, i) ;foundNewSpot = 1;Exit;
				Next
		End Select
		If Not foundNewSpot KillMe()

	End Method

	Method KillMe()
		alive = 0
		Map[x, y] = 0
	End Method

	Method Draw()
		If alive
			SetColor(color[0], color[1], color[2])
			DrawOval(x * size, y * size, size, size)
		EndIf
	End Method
	
End Type

Local list:TList = New TList

SeedRnd(MilliSecs())

While Not KeyDown(KEY_ESCAPE)

	Cls

	Local car:TCar = New TCar
	If car.alive list.AddLast(car)

	For Local i:Int = list.Count() - 1 To 0 Step - 1
		Local c:TCar = TCar(list.ValueAtIndex(i))
		c.update()
		If c.alive Then
			c.Draw()
		Else
			List.Remove(c)
		EndIf
	Next

	Flip()

Wend
</textarea> <br><br></td></tr></table><br>
<a name="1299246"></a>

<a name="1299247"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah - me not wanting types is just a preference. I just don't think it's any faster or smaller than regular coding.<br><br>Your program crashes in DEBUG mode, Casaber. Always check your variables.<br><br><b>Unhandled Exception:Attempt to index array element beyond array length. Line 119.<br><br>If Map[x, i] = 0 MoveTo(x, i) ;foundNewSpot = 1;Exit;</b><br><br>I can tell you right now what the problem is. You need to create a function like I'm using:<pre class=code>' &gt;&gt; RETRIEVE SCREEN TILE EVEN IF OFF EDGES
Function getscrn(x,y)
Local r=-1
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then r=scrn[x,y]
  Return r
EndFunction</pre>Also you don't need a trailing semi-color (;) at the end of any line.<br><br>Trying out your code otherwise looks pretty good. I see you created a function called CHEAT() to handle stuck elements. I could do that in this, but I'd be curious to know if there is a simple and logical bit of code to avoid a traffic jam altogether, however. <br><br></td></tr></table><br>
<a name="1299248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  Ah - me not wanting types is just a preference. I just don't think it's any faster or smaller than regular coding. <br></div><br><br>No, they are indeed not. They are used to create more readable, extensible and reusable code.<br><br><div class="quote"> Your program crashes in DEBUG mode, Casaber. <br></div><br><br>Yeah, sorry about that. Made an edit to my post without checking it first. A bit of a rushed job altogether, more like a proof of concept.<br>I am not Casaber though ;)<br><br><div class="quote"> I'd be curious to know if there is a simple and logical bit of code to avoid a traffic jam altogether <br></div><br><br>I think that would be pretty hard to avoid if you're creating a random car on every single update with these kind of "roads". In real life though, there could never be intersections on every single part of the road, plus we invented a traffic light for this specific reason of course. <br>Even if it's very crowded, a green traffic light would then move (e.g.) 3 east/west moving cars to the next part of the road IN BETWEEN intersections and then turn red. 3 north/south cars now get the green light and they would also move IN BETWEEN intersections.<br><br>If you need roads like this, I think it can only be achieved by releasing the cars in set intervals instead of randomly. <br><br></td></tr></table><br>
<a name="1299250"></a>

<a name="1299251"></a>

<a name="1299252"></a>

<a name="1299253"></a>

<a name="1299254"></a>

<a name="1299257"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry, getting the two of you mixed up - you both seem equally interested in this puzzle of mine. :)<br><br>Here is my solution, if you take too long in traffic, you won't receive a traffic ticket, no, you will be <b>DEREZZED</b>. :D Traffic will then resume flow as normal minus the interfering vehicle.<br><br><a href="http://tron.wikia.com/wiki/Derez" target="_blank">http://tron.wikia.com/wiki/Derez</a><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'     ________________________________________
'    //                                     //
'   // "T R A F F I C"                     //
'  // Version: "You Will Be Derezzed"     //
' // Written by David W (dw817) 03/10/16 //
'//_____________________________________//
'
' What's up ??
' Set it so there is more traffic and when it reaches the
' end, it does not stop but instead vanish - allowing more
' traffic to cross.
'
' Developed a clever method of handling whether or not I
' am READING or WRITING to the map by using a single
' variable called NEG.
'
' Handling 4-car pileup by REMOVING the car. Not the most
' elegant solution but it does work. When a pileup occurs,
' all traffic will freeze and wait for you to hit a key.
' Don't hit SPACEBAR though or you'll miss it. Hit a key
' like ENTER and you can clearly see the offending car
' removed then.

Strict
SeedRnd MilliSecs() ' ensure random results each time

Global img_tile:TImage[8],tileno
inittiles "081c3e7f1c1c1c00,468,080c7e7f7e0c0800,648,08183f7f3f180800,486,1c1c1c7f3e1c0800,864"
' ^ pack in 4 8x8 pixeled images, in this case arrows

Global scrn[31,23] ' full screen size of 31x23 tiles at 32x32 pixels, 8x8 pixels zoomed 4x
Global scrncount[31,23] ' prevent traffic jams by taking out a car if stationary for 16 turns

Local i,j,c,ok,x,y,r,neg=1

SetGraphicsDriver GLMax2DDriver(),0
Graphics 1024,768
SetScale 4,4

Repeat ' {* MAIN *}

r=(r+1)Mod 4 ' everyone gets equal traffic time
If r=0
  scrn[fnr(16)*2,22]=1*neg ' new car appears at bottom
ElseIf r=1
  scrn[30,fnr(11)*2]=2*neg ' new car appears at right
ElseIf r=2
  scrn[0,fnr(11)*2+1]=3*neg ' new car appears at left
Else ' no need to compare for 3
  scrn[fnr(15)*2+1,0]=4*neg ' new car appears at top
EndIf

update ' show our work

For i=0 Until 23 ' scan entire playfield
  For j=0 Until 31
    c=getscrn(j,i) ' read in each tile of the playfield
    ok=0 ' flag to tell if we erase a found car
    If c=1*neg And getscrn(j,i-1)=0 Then scrn[j,i-1]=-1*neg ; ok=1 ' Move arrow in designated direction IF area is free.
    If c=2*neg And getscrn(j-1,i)=0 Then scrn[j-1,i]=-2*neg ; ok=1 ' Negative is necessary so the tile is not reselected
    If c=3*neg And getscrn(j+1,i)=0 Then scrn[j+1,i]=-3*neg ; ok=1 ' in this one pass or it won't work correctly.
    If c=4*neg And getscrn(j,i+1)=0 Then scrn[j,i+1]=-4*neg ; ok=1
    If ok=1 Or scrncount[j,i]&gt;15
      scrn[j,i]=0 ' erase last position where they were if moved or not moving 16 times
      scrncount[j,i]=0 ' erase count for not moving
    ElseIf c ' car is here but it can't move, there is an obstacle in the way
      scrncount[j,i]:+1
      If scrncount[j,i]=15 Then WaitKey ' we're ready to DEREZ, pause to show it
    Else
      scrncount[j,i]=0
    EndIf
    If i=0 And scrn[j,i]=1*neg Then scrn[j,i]=0 ' clear out any cars that have successfully
    If j=0 And scrn[j,i]=2*neg Then scrn[j,i]=0 ' traveled the full length of the screen across
    If j=30 And scrn[j,i]=3*neg Then scrn[j,i]=0
    If i=22 And scrn[j,i]=4*neg Then scrn[j,i]=0
  Next
Next

neg=-neg ' BAM ! This resets all positions so they can be read again

If KeyDown(32)=0 Then Delay 150 ' hold down SPACEBAR for TURBO
If KeyDown(27) Then End ' exit on ESCAPE key

Forever ' {* END OF MAIN *}

' &gt;&gt; UPDATE SCREEN WITH TILES
Function update()
Local i,j,n
  Cls
  For i=0 Until 23
    For j=0 Until 31
      SetColor 32,64,96
      DrawRect j*32+16,i*32,7,7 ' draw a square to see edges
      n=scrn[j,i]
      If n ' with no comparitive number it means &lt;&gt;0 (zero)
        SetColor 255,255,255 ' always reset color when plotting any tiles
        DrawImage img_tile[Abs(n)-1],j*32+16,i*32 ' draw arrow images, NOTICE it is the absolute value !
      EndIf
    Next
  Next
  Flip 0 ' show our work
EndFunction

' &gt;&gt; CONVERT ONE LONG STRING TO LITTLE 8x8 IMAGES
Function inittiles(t$)
Local i,j,v,n,a,p$,r,g,b,c$
Local pic:TPixmap=CreatePixmap(8,8,pf_rgb888) ' work image
  While t$&gt;""
    p$=yank$(t$) ' image (16-characters, 8-bytes)
    c$=yank$(t$) ' color (3-characters)
    r=c$[0..1].toint()*32 ; g=c$[1..2].toint()*32 ; b=c$[2..3].toint()*32 ' set color
    If r=256 Then r=255 ' make sure it doesn't wrap
    If g=256 Then g=255
    If b=256 Then b=255
    a=b|g Shl 8|r Shl 16 ' calculate color
    ClearPixels pic,0 ' erase each time
    For i=0 Until 8
      v=("$"+p$[i*2..i*2+2]).toint() ' get full pixels across in one number
      For j=7 To 0 Step -1 ' reverse order to extract highest value bits first
        n=1 Shl j ' extract out bit pixels
        If v&gt;=n
          v:-n
          WritePixel pic,j,i,a ' write out single pixel
        EndIf
      Next
    Next
    img_tile[tileno]=LoadImage(MaskPixmap(pic,0,0,0),0) ' record and make it transparent all in one line
    tileno:+1 ' total tile numbers used
  Wend
EndFunction

' &gt;&gt; RETRIEVE SCREEN TILE EVEN IF OFF EDGES
Function getscrn(x,y)
Local r=-1
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then r=scrn[x,y]
  Return r
EndFunction

' &gt;&gt; RETURN COMMA DELIMITED TEXT FROM A$
Function yank$(a$ Var)
Local b=Instr(a$+",",","),c$=Left$(a$,b-1)
  a$=Mid$(a$,b+1) ' also remove it from input string
  Return c$
EndFunction

' &gt;&gt; QUICK RETRIEVE RANDOM 0 to A-1
Function fnr(a)
  Return Rand(a)-1
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="1299285"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> You know, a more elegant solution would be for the offending vehicle to back up one step and let the other guys go. I'll work on this. <br><br></td></tr></table><br>
<a name="1299309"></a>

<a name="1299318"></a>

<a name="1299428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here it is. Chivalry on the road ! :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'     ________________________________________
'    //                                     //
'   // "T R A F F I C"                     //
'  // Version: "Chivalry On The Road"     //
' // Written by David W (dw817) 03/11/16 //
'//_____________________________________//
'
' What's up ??
' Set it so there is more traffic and when it reaches the
' end, it does not stop but instead vanish - allowing more
' traffic to cross.
'
' Developed a clever method of handling whether or not I
' am READING or WRITING to the map by using a single
' variable called NEG.
'
' Handling 4-car pileup by backing up the car that's been
' waiting the longest. Now to my knowledge, this is a
' PERFECT solution.

' When a pileup does occur and you are holding down
' SPACEBAR for TURBO, it will be disabled so you can see how
' everyone helps to clear out the traffic jam.

' Once the jam is clear, you can enter TURBO mode again to
' try and find another problem.

Strict
SeedRnd MilliSecs() ' ensure random results each time

SetMaskColor 0,0,0
Global img_tile:TImage=LoadAnimImage(LoadBank("http::www.writerscafe.org/uploads/rte/0a3c15c2943abe552357bc7d46840e8c.png"),8,8,0,5,maskedimage)
' ^ load in 5 image tiles. Quicker than DefData.

Global scrn[31,23] ' full screen size of 31x23 tiles at 32x32 pixels, 8x8 pixels zoomed 4x
Global scrncount[31,23] ' prevent traffic jams by taking out a car if stationary for 5 turns

Local i,j,k,m,c,x,y,s,r,jam,neg=1

SetGraphicsDriver GLMax2DDriver(),0
Graphics 1024,768
SetScale 4,4

Repeat ' {* MAIN *}

r=(r+1)Mod 4 ' everyone gets equal traffic time
If jam&lt;5 ' only add cars if there is no traffic jam
  If r=0
    setscrn fnr(16)*2,22,1*neg ' add a car IF the place is empty
  ElseIf r=1
    setscrn 30,fnr(11)*2,2*neg
  ElseIf r=2
    setscrn 0,fnr(11)*2+1,3*neg
  Else ' no need to compare for 3
    setscrn fnr(15)*2+1,0,4*neg
  EndIf
EndIf

update ' show our work
If jam Then jam:-1
For i=0 Until 23 ' scan entire playfield
  For j=0 Until 31
    c=getscrn(j,i) ' read in each tile of the playfield
    x=0 ; y=0 ' if changed means we are moving a vehicle
    If c=1*neg Then y=-1 ' Move arrow in designated direction IF area is free.
    If c=2*neg Then x=-1 ' Negative is necessary so the tile is not reselected
    If c=3*neg Then x=1 ' in this one pass or it won't work correctly.
    If c=4*neg Then y=1
    s=scrncount[j,i] ' how long has this vehicle been idle ?
    If x&lt;&gt;0 Or y&lt;&gt;0 Or s&gt;4 ' car can move or is stalled
      If s&gt;4 And getscrn(j-x,i-y)=0 ' qualifies as jammed
        If s&gt;4 Then jam=8 ' 8 cycles will pass where you cannot use TURBO
        scrn[j,i]=0 ' erase position of car
        setscrn j-x,i-y,-c ' back up vehicle one step if possible
        setscrncount j-x,i-y,Rand(0,5) ' critical ! Car waits a specific time before backing up again
        scrncount[j,i]=Rand(0,5)
      ElseIf getscrn(j+x,i+y)=0 ' path is free
        scrn[j,i]=0 ' erase position of car
        scrn[j+x,i+y]=-c ' move car forward one step
        scrncount[j,i]=0 ' reset any stalled status
      EndIf
    ElseIf c ' car is here but it can't move, there is an obstacle in the way
      scrncount[j,i]:+1 ' increase stalled time
    Else
      scrncount[j,i]=0 ' always reset stalled time on empty space
    EndIf
    If i=0 And scrn[j,i]=1*neg Then scrn[j,i]=0 ' clear out any cars that have successfully
    If j=0 And scrn[j,i]=2*neg Then scrn[j,i]=0 ' traveled the full length of the screen across
    If j=30 And scrn[j,i]=3*neg Then scrn[j,i]=0
    If i=22 And scrn[j,i]=4*neg Then scrn[j,i]=0
  Next
Next

neg=-neg ' BAM ! This resets all positions so they can be read again

If KeyDown(32)=0 Or jam Then Delay 150 ' hold down SPACEBAR for TURBO, disabled if there is a traffic jam
If KeyDown(27) Then End ' exit on ESCAPE key

Forever ' {* END OF MAIN *}

' &gt;&gt; UPDATE SCREEN WITH TILES
Function update()
Local i,j,n,x,y
  Cls
  For i=0 Until 23
    For j=0 Until 31
      x=j*32+16 ; y=i*32
      DrawImage img_tile,x,y,0
      n=scrn[j,i]
      If n ' with no comparitive number it means &lt;&gt;0 (zero)
        SetColor 255,255,255 ' always reset color when plotting any tiles
        DrawImage img_tile,x,y,Abs(n) ' draw arrow images, NOTICE it is the absolute value !
      EndIf
    Next
  Next
  Flip 0 ' show our work
EndFunction

' &gt;&gt; RETRIEVE SCREEN TILE EVEN IF OFF EDGES
Function getscrn(x,y)
Local r=-1
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then r=scrn[x,y]
  Return r
EndFunction

' &gt;&gt; PLOT A VEHICLE IF SPACE IS CLEAR
Function setscrn(x,y,z)
  If getscrn(x,y)=0 Then scrn[x,y]=z
EndFunction

' &gt;&gt; MARK A TILE WITH STALL TIME EVEN IF OFF EDGES
Function setscrncount(x,y,z)
  If x&gt;=0 And y&gt;=0 And x&lt;=30 And y&lt;=22 Then scrncount[x,y]=z
EndFunction

' &gt;&gt; RETURN COMMA DELIMITED TEXT FROM A$
Function yank$(a$ Var)
Local b=Instr(a$+",",","),c$=Left$(a$,b-1)
  a$=Mid$(a$,b+1) ' also remove it from input string
  Return c$
EndFunction

' &gt;&gt; QUICK RETRIEVE RANDOM 0 to A-1
Function fnr(a)
  Return Rand(a)-1
EndFunction
</textarea><br><br>My Dad was really fascinated by this sort of stuff. He developed a method years ago for businesses called GUTS which stood for Grand Unified Theory of Systems.<br><br>It could also be applied to a computer program. He wrote one where little dots mizzled around each other but if one couldn't move for a long time because of traffic, he got mad and started pushing the others around.<br><br>Then they too would get mad and push others. Eventually the others backed up while those angry worked out their frustration (for all the frustration a pixel could have) :), and then "traffic" resumed normally.<br><br>He wrote it in Turbo Pascal and was supposed to simulate crowding situations to see what would happen. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
