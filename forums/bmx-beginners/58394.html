<!DOCTYPE html><html lang="en" ><head ><title >polygon collision</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >polygon collision</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >polygon collision</a><br><br>
<a name="649523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bremer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can anyone point me in the right direction as far as something that will show me how to check if two polygons overlap. I have the transformed x and y values in two arrays and the polygons is drawn correctly, but I can't seem to figure out how to get the collision working. Or if someone would be as kind as to show me an easy to follow example of how its done using two sets of pixel coordinates, I would be extremely grateful. Its the only thing missing before I can release my sprite module for bmax.<br><br>The vertex data is held in two arrays of variable size depending on how many points the polygon consist of, but at a minimum of three.<br><br>Field vx:Int[]<br>Field vy:Int[]<br><br>The points are in clockwise order.<br><br>If someone helps me solve this, I will provide them with the sprite module free of charge. Its probably going to be sold at around 25 euros.<br><br>[edit] Let me know if more info is needed. <br><br></td></tr></table><br>
<a name="649547"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've just, about 5 mins ago, finished the poly2poly collisions for my game. I broke my polys up into triangles and then did tri2tri collision. Not sure if this is the best way but it works. <br><br></td></tr></table><br>
<a name="649553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> The fastest way might be SAT (projects to different axis' and if there is only 1 axis where they don't overlap, then they are not colliding. Axis = each side of the first or the second polygon, depending on which one has fewer sides) <br><br></td></tr></table><br>
<a name="649618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bremer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://zac-interactive.dk/temp/frames.png"><br><br>It will have to be able to check for collision between two polygon frames like those in the above image and similar shapes. I would like to avoid having to try and make triangles out of the frames.<br><br>I am not great at math myself, which is why I am asking for someone to help me out with this problem. I think that I have a good and useful sprite module going, but without polygon frame collision, its probably a lot less useful.<br><br>Info on the sprite module, for those interested in knowing more, can be found here: <br><br><a href="http://zac-interactive.dk/tools/zsprite/zsprite.htm" target="_blank">http://zac-interactive.dk/tools/zsprite/zsprite.htm</a> <br><br></td></tr></table><br>
<a name="649716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> For shape like that, SAT is definitely the easiest way to go. The cross ensures, that you only have 2 things to test:<br><br>xmin - xmax  as well as ymin - ymax. This then would show that they intersect on y but not on x thus they don't intersect.<br><br>Would suggest you look for deeper informations on SAT and especially how to implement. Should be too hard on math, only a little vector and vector projection math ... thats game programming base knowledge, so no problem :-) <br><br></td></tr></table><br>
<a name="649871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bremer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did some searching on "Separating Axis Theorem" and found this page, which seems to cover the basics of it.<br><br><a href="http://www.harveycartel.org/metanet/tutorials/tutorialA.html" target="_blank">http://www.harveycartel.org/metanet/tutorials/tutorialA.html</a><br><br>It could be useful to others, so I figured that I post it here. I am going to have a read through and see if I can understand it.<br><br>If someone have ideas and possibly example code on how this works then that would still be highly appreciated :) <br><br></td></tr></table><br>
<a name="650263"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Diablo</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got some BMax code for you:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

' Vector type ( A VERY SIMPLE VECTOR TYPE )
Type TVector
	
	Field x#, y#
	
	Function Create:TVector(_x#, _y#)
		Local v:TVector = New TVector
		v.x = _x
		v.y = _y
		Return v
	End Function
	
	Method DivEq(_scale#)
		x:/ _scale
		y:/ _scale
	End Method
	
	Method MulEq(_scale#)
		x:* _scale
		y:* _scale
	End Method
	
	Method AddEq(v:TVector)
		x:+ v.x
		y:+ v.y
	End Method
	
	Method MinEq(v:TVector)
		x:- v.x
		y:- v.y
	End Method
	
	Method CrossProduct#(v:TVector)
		Return x * v.y - y * v.x
	End Method
	
	Method Dot#(v:TVector)
		Return x * v.x + y * v.y
	End Method
	
	Method Mul:TVector(_scale#)
		Return TVector.Create(x * _scale, y * _scale)
	End Method
	
	Method Div:TVector(_scale#)
		Return TVector.Create(x / _scale, y / _scale)
	End Method
	
	Method Add:TVector(v:TVector)
		Return TVector.Create(x + v.x, y + v.y)
	End Method
	
	Method Sub:TVector(v:TVector)
		Return TVector.Create(x - v.x, y - v.y)
	End Method
	
	Method Leng#()
		Return Sqr(x * x + y * y)
	End Method

	rem
		Do two vectors intersect along a given axis
	endrem
	Function Intersect@(a:TVector[], b:TVector[], xa:TVector, _offset:TVector)
	
		Local min0#, max0#
		Local min1#, max1#
		
		min0 = IntervalMin(a, xa)
		max0 = IntervalMax(a, xa)
		min1 = IntervalMin(b, xa)
		max1 = IntervalMax(b, xa)
		
		Local h# = _offset.Dot(xa)
		min0:+ h
		max0:+ h
		
		Local d0# = min0 - max1
		Local d1# = min1 - max0
		
		If d0 &gt; 0.0 or d1 &gt; 0.0 Then
			Return False
		Else
			Return True
		End If
	
	End Function
	
	rem
		Min / Max functions
		nothing sepcial
	endrem
	Function IntervalMin#(verts:TVector[], xa:TVector)
		Local m# = verts[0].Dot(xa)
		
		For Local i% = 0 To verts.length - 1
			Local d# = verts[i].Dot(xa)
			If d &lt; m Then m = d
		Next
		
		Return m
	End Function
	
	Function IntervalMax#(verts:TVector[], xa:TVector)
		Local m# = verts[0].Dot(xa)
		
		For Local i% = 0 To verts.length - 1
			Local d# = verts[i].Dot(xa)
			If d &gt; m Then m = d
		Next
		
		Return m
	End Function
	
End Type

' A simple polygon type
Type TPolygon
	
	Field x#, y# 	' Draw offset
	Field vx#[]		' Zero Based
	Field vy#[]		' Zero based
	Field vc#		' Vertex Count
	
	' Just to help
	Function CreateByVectorList:TPolygon(_v:TList)
		Local p:TPolygon = New TPolygon
		p.vx = New Float[_v.count()]
		p.vy = New Float[_v.count()]
		p.vc = _v.count()
		
		Local i% = 0
		For Local v:TVector = EachIn _v
			
			p.vx[i] = v.x
			p.vy[i] = v.y

			i:+ 1
		Next
		Return p
	End Function
	
	' Draw it
	Method Render()
		SetColor 255, 0, 0
		
		Local _vx#[2], _vy#[2]
		For Local i% = 0 To vc - 2
			_vx[0] = vx[i] + x
			_vy[0] = vy[i] + y
			_vx[1] = vx[i + 1] + x
			_vy[1] = vy[i + 1] + y
			DrawLine _vx[0], _vy[0], _vx[1], _vy[1]
		Next
		
		_vx[0] = vx[vc - 1] + x
		_vy[0] = vy[vc - 1] + y
		_vx[1] = vx[0] + x
		_vy[1] = vy[0] + y
		DrawLine _vx[0], _vy[0], _vx[1], _vy[1]
		SetColor 0, 0, 0
	End Method
	
	' Set position
	Method SetPos(_x%, _y%)
		x = _x
		y = _y
	End Method
	
	' Test Collide _offset you shouldnt need to worry about but just incase...
	Method Collide@(p:TPolygon, _offset:TVector = Null)
		
		SetColor 0, 255, 0
		If _offset = Null Then
			_offset = TVector.Create(x, y).Sub(TVector.Create(p.x, p.y))
		End If
		
		Local a:TVector[], b:TVector[]
		Local i%
		
		a = New TVector[vc]
		For i = 0 To vc - 1
			a[i] = New TVector
			a[i].x = vx[i]
			a[i].y = vy[i]
		Next
		
		b = New TVector[p.vc]
		For i = 0 To p.vc - 1
			b[i] = New TVector
			b[i].x = p.vx[i]
			b[i].y = p.vy[i]
		Next
		
		Local xv:TVector[64]
		Local ai% = 0
		
		Local j% = vc - 1
		For Local i% = 0 To vc - 1
			Local e0:TVector = a[j]
			Local e1:TVector = a[i]
			Local e:TVector = e1.Sub(e0)
			xv[ai] = TVector.Create(-e.y, e.x)
			
			If not TVector.Intersect(a, b, xv[ai], _offset)
				Return False
			EndIf
			
			j = i
			ai:+ 1
		Next
		
		j% = p.vc - 1
		For Local i% = 0 To p.vc - 1
			Local e0:TVector = b[j]
			Local e1:TVector = b[i]
			Local e:TVector = e1.Sub(e0)
			xv[ai] = TVector.Create(-e.y, e.x)
			
			If not TVector.Intersect(a, b, xv[ai], _offset)
				Return False
			EndIf
			
			j = i
			ai:+ 1
		Next
		
		Return True
		
	End Method
	
End Type

Local Box:TList = CreateList()
Box.AddLast(TVector.Create(0, 0))
Box.AddLast(TVector.Create(100, 0))
Box.AddLast(TVector.Create(100, 100))
Box.AddLast(TVector.Create(0, 100))
Local Shape:TList = CreateList()
Shape.AddLast(TVector.Create(25, 0))
Shape.AddLast(TVector.Create(50, 0))
Shape.AddLast(TVector.Create(75, 25))
Shape.AddLast(TVector.Create(50, 50))
Shape.AddLast(TVector.Create(25, 50))
Shape.AddLast(TVector.Create(0, 25))
Global ap1:TPolygon = TPolygon.CreateByVectorList(Box)
ap1.SetPos(200, 200)
Global ap2:TPolygon = TPolygon.CreateByVectorList(Shape)
ap2.SetPos(100, 100)

Graphics 800, 600

While not KeyHit(KEY_ESCAPE)
	
	Cls
	
	ap2.SetPos(MouseX(), MouseY())
	ap1.Render()
	ap2.Render()
	
	SetColor 255, 255, 255
	If ap2.Collide(ap1) Then DrawText "COLLIDED!!!", 10, 10
	
	Flip 0
	
Wend</textarea><br><br>The code is a quick ripp from <a href="http://www.gamedev.net/community/forums/topic.asp?topic_id=251638" target="_blank"><b> This Good Chap </b></a><br><br>Edit: It dosent always work the way you might want it to but i'll leave you to experiment. The above link has got a link to download a .zip with some code in it. (cpp source) <br><br></td></tr></table><br>
<a name="650287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SillyPutty</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> very nice <br><br></td></tr></table><br>
<a name="651341"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bremer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Had a look at that tutorial I found, understood most of it. Then took another look at my code, and found out that I had been using a wrong array for one set of vertices. Once I corrected that, my current code actually worked. Go figure. Its bugs like that, which is hardest to track down, especially when you have staired yourself blind looking at the same code for hours on end.<br><br>Thanks for everyones input so far. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
