<!DOCTYPE html><html lang="en" ><head ><title >360 shooter.... scrolling background</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >360 shooter.... scrolling background</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=101" >BlitzMax Beginners Area</a>/<a href="#bottom" >360 shooter.... scrolling background</a><br><br>
<a name="870735"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I want to get a seemless image that I can create a 'endless' feel to the background<br><br>2 questions on this:<br><br>1. Is there any easy way to make a image seemless in all 4 directions? Any freewere programs out there?<br><br>2. The obvious way to do this would be to lock the player in place while instead, moving the background and objects in the oposite direction. But how would you detect when to draw another background image(when the end of the first one enters view) and where would you draw it?<br><br>The image would probably be 1600 x 1200 (double the size of the 800x600 screen)<br><br>Thanks for any help! <br><br></td></tr></table><br>
<a name="870742"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Gimp has a MakeSeamless function. <br><a href="/toolbox/toolbox.php?tool=139" target="_blank"> Texture Studio 1.14 </a> might be what you're looking for. <br><br></td></tr></table><br>
<a name="870760"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> It depends on the size of your background image compared to the size of the screen. If your screen resolution is the exact same size as your seamless image, or is smaller than your seamless image but no less than half its size, then you need to draw your seamless image four times. You just draw it in a grid of 2x2. ie four images in two rows of two.<br><br>Now to do the scrolling you'll need to think about how big your game world will be. If your game world is less or equal to twice the width or height of the seamless image then it's easy - you just use SetOrigin for scrolling and draw your seamless image at 0,0 and 0,ScreenHeight and ScreenWidth,0 and ScreenWidth,ScreenHeight.<br><br>But if you want your game world to be bigger than twice the size of the seamless texture then you need to now implement two For loops (nested) to draw a grid of seamless images. You'll also then need to use WorldX Mod TextureWidth to find the coordinate at which to start drawing horizontally, and WorldY Mod TextureHeight to find the coordinate at which to start drawing vertically. Then you need to either keep a counter of your horizontal/vertical position so that you keep drawing another image until you get PAST the edge of the screen, or know how many textures fit into the screen size and only do that many loops to draw the grid. You may need to then use modulo's on the SetOrigin too. Otherwise you could omit all the Mod's and just use SetOrigin with absolute world coordinates and figure out which coords to use for drawing. <br><br></td></tr></table><br>
<a name="870775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JazzieB</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> You just need to use TileImage at co-ordinates based on your player's position.  For example, just use something like <b>TileImage imgBackground,-playerX,-playerY</b>.<br><br>The only consideration for size is whether your target market/specification can support images larger than the screen - if you're using them, that is. <br><br></td></tr></table><br>
<a name="870839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the replies, and the link to the seemless texture generator.<br><br>I'll try some of these suggestions. <br><br></td></tr></table><br>
<a name="870848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jazzie's method works well, here's an example:<br><br><pre class=code>

SuperStrict

Graphics 800,600

Local img:TImage = LoadImage("bg.png")
Local player:TImage = LoadImage("player.png")

Local px:Int = 380, py:Int = 280



While Not KeyHit(KEY_ESCAPE)
	Cls
	TileImage img,-px,-py
	
	If KeyDown(KEY_UP) py:-3
	If KeyDown(KEY_DOWN) py:+3
	If KeyDown(KEY_LEFT) px:-3
	If KeyDown(KEY_RIGHT) px:+3
	
	DrawImage player,380,280
	Flip 1
Wend
End
</pre><br><br>and the images:<br><br><br>bg.png<br><img src="http://img404.imageshack.us/img404/9486/bgtq6.png"><br><br>player.png<br><img src="http://img159.imageshack.us/img159/3268/playerlw9.png"> <br><br></td></tr></table><br>
<a name="870861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now to guess the next question... rotation of the player ;-)<br><br><pre class=code>

SuperStrict

Graphics 800,600,0

AutoMidHandle 1

Local img:TImage = LoadImage("bg.png")
Local player:TImage = LoadImage("player.png")

Local px:Float = 380, py:Float = 280
Local pdx:Float, pdy:Float
Local protation:Float
Local pspeed:Float = 0


While Not KeyHit(KEY_ESCAPE)
	Cls
	TileImage img,-px,-py
	
	If KeyDown(KEY_UP)	
		pspeed:+0.1
	End If
	
	If KeyDown(KEY_DOWN)	
		pspeed:-0.1
	End If

		
	If KeyDown(KEY_LEFT)
		protation:-1
	End If
	
	If KeyDown(KEY_RIGHT)
		protation:+1	
	End If


	pdx=Sin(protation)*pspeed
	pdy=-Cos(protation)*pspeed

	px :+ pdx
	py :+ pdy	


	SetRotation protation
	DrawImage player,380,280
	SetRotation 0
	Flip 1
Wend
End


</pre> <br><br></td></tr></table><br>
<a name="870868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bah, I've made like 10 asteroids clones, I figured that one out a while ago :) <br><br></td></tr></table><br>
<a name="870870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here's some more "Space" like movement with a neat effect(layers of tiles moving different speeds with different alphas):<br><br><pre class=code>
SuperStrict

Graphics 800,600,0
SetBlend ALPHABLEND


Local img:TImage = LoadImage("bg.png")
AutoMidHandle True
Local player:TImage = LoadImage("player.png")
AutoMidHandle False

Local px:Float = 400, py:Float = 300
Local pdx:Float, pdy:Float
Local protation:Float
Const ACCELERATION:Float = 0.1


While Not KeyHit(KEY_ESCAPE)
	Cls
	TileImage img,-(px/4),-(py/4)
	SetAlpha .7
	TileImage img,-(px/2),-(py/2)
	SetAlpha .4
	TileImage img,-px,-py
	SetAlpha 1
	
	If KeyDown(KEY_UP)	
		pdx:+Sin(protation)*ACCELERATION
		pdy:+-Cos(protation)*ACCELERATION
	End If
		
	If KeyDown(KEY_LEFT)
		protation:-4
	End If
	
	If KeyDown(KEY_RIGHT)
		protation:+4	
	End If


	px :+ pdx
	py :+ pdy	


	SetRotation protation
	DrawImage player,400,300
	SetRotation 0
	Flip 1
Wend
End
</pre><br><br>Now for a question:<br><br>In gameplay I want enemys chasing down the player, is there an easy way to do this? <br>My shot in the dark would be to compare the px/py to the enemy's x/y, and try to find a path.<br><br>How would you find the angle (for later use of dx and dy) between 2 points? <br><br></td></tr></table><br>
<a name="870885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ryan Burnside</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here are two functions<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function point_distance#(x1#,y1#,x2#,y2#)
	Return Sqr(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
End Function


Function point_direction#(x1#,y1#,x2#,y2#)
Local direction#= ATan2(y1-y2,x1-x2)+180

While direction &gt; 360
	direction:-180
Wend

While direction&lt;0
	direction:+180
Wend

Return direction

EndFunction
</textarea><br><br><br>Also if you first find the angle you can move towards that target using the following formula:<br><br>x:+cos(angle)*step_size<br>y:+sin(angle)*step_size <br><br></td></tr></table><br>
<a name="870887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the segment -&gt; angle function, thats what i'm looking for, I'll see what I can do <br><br></td></tr></table><br>
<a name="870889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about if you want the enemy's to orbit you? More cos/sin hattery? <br><br></td></tr></table><br>
<a name="870893"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hows about this:<br><br><pre class=code>
SuperStrict

Graphics 800,600,0
SetBlend ALPHABLEND
SeedRnd MilliSecs()


Global img:TImage = LoadImage("bg.png")
AutoMidHandle True
Global playerImg:TImage = LoadImage("player.png")
Global alienImg:TImage = LoadImage("player.png")
AutoMidHandle False


Global player:TPlayer = New TPlayer
player.image = playerImg
player.cx = 400
player.cy = 300

Global alien:TAlien = New TAlien
alien.image = alienImg
alien.x = Rand (0,800)
alien.y = Rand (0,600)
alien.acceleration = 0.3


While Not KeyHit(KEY_ESCAPE)
	drawBackground()
	player.update()
	alien.update()
	player.draw()
	alien.draw()	
	Flip 1
Wend

End

Type TEntity
	Field x:Float, y:Float
	Field dx:Float, dy:Float
	Field rotation:Float
	Field acceleration:Float = 0
	Field image:TImage	
End Type

Type TPlayer Extends TEntity		
	Field cx:Float, cy:Float
	
	Const ACCELERATION:Float = 0.1

	
	Method draw()
		SetRotation rotation
		DrawImage image,cx,cy
		SetRotation 0		
	End Method
	
	Method controls()
		If KeyDown(KEY_UP)	
			dx:+Sin(rotation)*ACCELERATION
			dy:+-Cos(rotation)*ACCELERATION
		End If

		If KeyDown(KEY_DOWN)	
			dx:-Sin(rotation)*ACCELERATION
			dy:+Cos(rotation)*ACCELERATION
		End If		
			
		If KeyDown(KEY_LEFT)
			rotation:-4
		End If
		
		If KeyDown(KEY_RIGHT)
			rotation:+4	
		End If		
	End Method

	
	Method update()
		controls()
		
		x :+ dx
		y :+ dy			
	End Method
End Type

Type TAlien Extends TEntity
	Field n:Int 

	Method draw()
		SetRotation rotation
		DrawImage image,x,y
		SetRotation 0
	End Method
	
	Method trackPlayer()
		Local radius:Float = 100
		
		dx = (player.cx - x) 
		dy = (player.cy - y) 
		Local dist:Float = Sqr(dx * dx + dy * dy) 
		
		If dist &gt;= radius			
			dx:/dist * acceleration 
			dy:/dist * acceleration 				
			n = rotation + 90
		Else
			dx = dx+Cos(n)*(radius - 2)			
			dy = dy+Sin(n)*(radius - 2)			
			n :+1			
		EndIf
		rotation = point_direction#(x,y,player.cx,player.cy)
	End Method

	Method update()
		trackPlayer()
		x :+ dx -player.dx
		y :+ dy -player.dy				
	End Method
	
End Type

Function point_direction#(x1#,y1#,x2#,y2#)
	Local direction#= ATan2(y1-y2,x1-x2)+180

	While direction &gt; 360
		direction:-180
	Wend

	While direction&lt;0
		direction:+180
	Wend

	Return direction + 90

EndFunction


Function drawBackground()
	TileImage img,-(player.x/4),-(player.y/4)
	SetAlpha .7
	TileImage img,-(player.x/2),-(player.y/2)
	SetAlpha .4
	TileImage img,-player.x,-player.y
	SetAlpha 1
End Function
</pre><br><br>Its not great, but its a start... <br><br></td></tr></table><br>
<a name="870894"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hehe, you didnt need to draw up a whole program, I just needed the tracking/orbiting code if to close, (I already have the game under developement), thanks though, i'll see what I can do with it <br><br></td></tr></table><br>
<a name="870896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Hehe, you didnt need to draw up a whole program <br></div><br><br>LOL... I needed a break from my own game and it was fun - I havent programmed a 360 shooter before - havent even done an Asteroids clone.<br><br><div class="quote"> thanks though <br></div><br><br>No problem <br><br></td></tr></table><br>
<a name="870897"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Alright, this is making him chase just fine, but when he orbits he circles the player alright but he violently shakes back and forth... why?<br><br><br><pre class=code>
		If PointsToDistance(x,y,400,300) &gt; 70 'chase
			angle = PointsToAngle(x,y,400,300)+90
			dx = AngleToDX(angle)*SPEED
			dy = AngleToDY(angle)*SPEED
		Else 'orbit
			dx:+Cos(orbit)*(70 - 2)			
			dy:+-Sin(orbit)*(70 - 2)
			orbit:+4
		End If
</pre> <br><br></td></tr></table><br>
<a name="870899"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your enemy must be going outside the radius, try changing the -2 to something greater.<br><br>Also I found that I needed to set orbit in the chase bit too:<br><br><pre class=code>
If dist &gt;= radius			
	dx:/dist * acceleration
	dy:/dist * acceleration
	orbit = rotation + 90
Else
	dx = dx+Cos(n)*(radius - 2)
	dy = dy+Sin(n)*(radius - 2)
	orbit :+1		
EndIf
</pre> <br><br></td></tr></table><br>
<a name="870901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> still not working properly... odd..<br><br>here's my whole tenemy...<br><pre class=code>

Type TEnemy
	Field x:Float,y:Float
	Field dx:Float,dy:Float
	Field angle:Int
	Field shoottimer:Int
	
	
	Const SPEED:Int = 15
	Method Create:TEnemy()
		ListAddLast(EnemyList,Self)
		x = 50
		y = 50
	End Method
	
	Method Update()
		DrawText PointsToDistance(x,y,400,300),0,20
		If PointsToDistance(x,y,400,300) &gt;= 100
			angle = PointsToAngle(x,y,400,300)+90
			dx = AngleToDX(angle)*SPEED
			dy = AngleToDY(angle)*SPEED
		Else
			angle:+1
			dx:+AngleToDX(angle) * 5
			dy:+AngleToDY(angle) * 5
		End If
		
		x:+dx
		y:+dy
		
		x:+ -pdx
		y:+ -pdy
			
		If shoottimer &gt; 20
			PlaySound shoot_sound
			Local bul:TBullet = New TBullet.Create(x,y,angle)
			shoottimer = 0
		End If
	
		SetRotation angle
		DrawImage player_img,x,y
		SetRotation 0
		
		shoottimer:+1
	End Method

End Type
</pre> <br><br></td></tr></table><br>
<a name="870903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> what are your methods/functions for:<br><br>PointsToDistance<br><br>PointsToAngle<br><br>AngleToDX<br><br>? <br><br></td></tr></table><br>
<a name="870913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess the functions are:<br><br><pre class=code>

Function AngleToDX:Float(angle:Float)
	Return Cos(angle)
End Function

Function AngleToDY:Float(angle:Float)
	Return 	Sin(angle)
End Function

Function PointsToDistance#(x1#,y1#,x2#,y2#)
	Return Sqr(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
End Function


Function PointsToAngle#(x1#,y1#,x2#,y2#)
	Local direction#= ATan2(y1-y2,x1-x2)+180

	While direction &gt; 360
		direction:-180
	Wend

	While direction&lt;0
		direction:+180
	Wend

	Return direction

EndFunction

</pre><br><br>Okay... so try this:<br><br><pre class=code>
SuperStrict

Graphics 800,600,0
SetBlend ALPHABLEND
SeedRnd MilliSecs()


Global img:TImage = LoadImage("bg.png")
AutoMidHandle True
Global playerImg:TImage = LoadImage("player.png")
AutoMidHandle False


Global player:TPlayer = New TPlayer
player.image = playerImg
player.cx = 400
player.cy = 300

Global alien:TAlien = New TAlien
alien.image = playerImg
alien.x = Rand (0,800)
alien.y = Rand (0,600)
alien.acceleration = 0.3

Global en:TEnemy = New TEnemy
en.x = 50
en.y = 50


While Not KeyHit(KEY_ESCAPE)
	drawBackground()
	player.update()
	alien.update()
	en.update()
	player.draw()
	alien.draw()	
	Flip 1
Wend

End

Type TEntity
	Field x:Float, y:Float
	Field dx:Float, dy:Float
	Field rotation:Float
	Field acceleration:Float = 0
	Field image:TImage	
End Type

Type TPlayer Extends TEntity		
	Field cx:Float, cy:Float
	
	Const ACCELERATION:Float = 0.1

	
	Method draw()
		SetRotation rotation
		DrawImage image,cx,cy
		SetRotation 0		
	End Method
	
	Method controls()
		If KeyDown(KEY_UP)	
			dx:+Sin(rotation)*ACCELERATION
			dy:+-Cos(rotation)*ACCELERATION
		End If

		If KeyDown(KEY_DOWN)	
			dx:-Sin(rotation)*ACCELERATION
			dy:+Cos(rotation)*ACCELERATION
		End If		
			
		If KeyDown(KEY_LEFT)
			rotation:-4
		End If
		
		If KeyDown(KEY_RIGHT)
			rotation:+4	
		End If		
	End Method

	
	Method update()
		controls()
		
		x :+ dx
		y :+ dy			
	End Method
End Type

Type TAlien Extends TEntity
	Field n:Int 

	Method draw()
		SetRotation rotation
		SetColor 0,255,0
		DrawImage image,x,y
		SetColor 255,255,255		
		SetRotation 0
	End Method
	
	Method trackPlayer()
		Local radius:Float = 100
		
		dx = (player.cx - x) 
		dy = (player.cy - y) 
		Local dist:Float = Sqr(dx * dx + dy * dy) 
		
		If dist &gt;= radius			
			dx:/dist * acceleration 
			dy:/dist * acceleration 				
			n = rotation + 90
		Else
			dx = dx+Cos(n)*(radius - 2)			
			dy = dy+Sin(n)*(radius - 2)			
			n :+1			
		EndIf
		rotation = point_direction#(x,y,player.cx,player.cy)
	End Method

	Method update()
		trackPlayer()
		x :+ dx -player.dx
		y :+ dy -player.dy				
	End Method
	
End Type



Type TEnemy
	Field x:Float,y:Float
	Field dx:Float,dy:Float
	Field angle:Int
	Field shoottimer:Int
	
	Field radius:Float = 100
	
	Const SPEED:Float = 5
	
	Method Create:TEnemy()
	'	ListAddLast(EnemyList,Self)
		x = 50
		y = 50
	End Method
	
	Method Update()
		DrawText PointsToDistance(x,y,400,300),0,20
		dx = (player.cx - x) 
		dy = (player.cy - y)
		Local dist:Float = Sqr(dx * dx + dy * dy)
		If PointsToDistance(x,y,400,300) &gt;= radius
			angle = PointsToAngle(x,y,400,300)
			dx = AngleToDX(angle)*SPEED
			dy = AngleToDY(angle)*SPEED
			angle:+180
		Else
			angle:+4
			dx:+AngleToDX(angle) * (radius- 2)
			dy:+AngleToDY(angle) * (radius- 2)
		End If
		
		x:+dx
		y:+dy
		
		x:+ -player.dx

		y:+ -player.dy	
			
		If shoottimer &gt; 20
	'		PlaySound shoot_sound
		'	Local bul:TBullet = New TBullet.Create(x,y,angle)
			shoottimer = 0
		End If
	
		SetRotation angle - 90
		SetColor 0,255,255
		DrawImage playerImg,x,y
		SetColor 255,255,255
		SetRotation 0
		
		shoottimer:+1
	End Method

End Type

Function AngleToDX:Float(angle:Float)
	Return Cos(angle)
End Function

Function AngleToDY:Float(angle:Float)
	Return 	Sin(angle)
End Function


Function point_direction#(x1#,y1#,x2#,y2#)
	Local direction#= ATan2(y1-y2,x1-x2)+180

	While direction &gt; 360
		direction:-180
	Wend

	While direction&lt;0
		direction:+180
	Wend

	Return direction + 90

EndFunction

Function PointsToDistance#(x1#,y1#,x2#,y2#)
	Return Sqr(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
End Function


Function PointsToAngle#(x1#,y1#,x2#,y2#)
	Local direction#= ATan2(y1-y2,x1-x2)+180

	While direction &gt; 360
		direction:-180
	Wend

	While direction&lt;0
		direction:+180
	Wend

	Return direction

EndFunction


Function drawBackground()
	TileImage img,-(player.x/4),-(player.y/4)
	SetAlpha .7
	TileImage img,-(player.x/2),-(player.y/2)
	SetAlpha .4
	TileImage img,-player.x,-player.y
	SetAlpha 1
End Function
</pre><br><br>Using the same images you supplied... <br><br>red = player<br>green = my alien<br>blue = your type<br><br>So your type is now:<br><br><pre class=code>

Type TEnemy
	Field x:Float,y:Float
	Field dx:Float,dy:Float
	Field angle:Int
	Field shoottimer:Int
	
	Field radius:Float = 100
	
	Const SPEED:Float = 5
	
	Method Create:TEnemy()
		ListAddLast(EnemyList,Self)
		x = 50
		y = 50
	End Method
	
	Method Update()
		DrawText PointsToDistance(x,y,400,300),0,20
		dx = (player.cx - x) 
		dy = (player.cy - y)
		Local dist:Float = Sqr(dx * dx + dy * dy)
		If PointsToDistance(x,y,400,300) &gt;= radius
			angle = PointsToAngle(x,y,400,300)
			dx = AngleToDX(angle)*SPEED
			dy = AngleToDY(angle)*SPEED
			angle:+180
		Else
			angle:+4
			dx:+AngleToDX(angle) * (radius- 2)
			dy:+AngleToDY(angle) * (radius- 2)
		End If
		
		x:+dx
		y:+dy
		
		x:+ -pdx
		y:+ -pdy	
			
		If shoottimer &gt; 20
			PlaySound shoot_sound
			Local bul:TBullet = New TBullet.Create(x,y,angle)
			shoottimer = 0
		End If
	
		SetRotation angle - 90
		DrawImage player_img,x,y
		SetRotation 0
		
		shoottimer:+1
	End Method

End Type

</pre><br><br>You may have to do this in your bullet code:<br><br><pre class=code>
Local bul:TBullet = New TBullet.Create(x,y,angle-180)
</pre> <br><br></td></tr></table><br>
<a name="870967"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> You were right with the functions except AngleToDY returns the oposite of that return.<br><br><br>Also tis would be very hard to implement as I don't have a player type. But i'll see what I can do.<br><br>here's my complete init.bmx:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'------------------------
'GLOBAL
'------------------------

'Background
Global bg_img:TImage = LoadImage("Media/bg.png")

'Player
AutoMidHandle True
Global player_img:TImage = LoadImage("Media/player.png")
Global firepart:TImage = LoadImage("Media/fire.png")
AutoMidHandle False
Global px:Float = 400, py:Float = 300
Global pdx:Float, pdy:Float
Global protation:Int
Global burning:Int

'Bullet
AutoMidHandle True
Global bullet_img:TImage = LoadImage("Media/bullet.png")
AutoMidHandle False
Global shoot_sound:TSound = LoadSound("Media/shooting.wav")


'------------------------
'CONSTANT
'------------------------

Const ACCELERATION:Float = 0.1
Const BULLET_SPEED:Int = 20

'------------------------
'TYPE/CLASS
'------------------------
Global BulletList:TList = CreateList()
Global EnemyList:TList = CreateList()


Type TBullet
	Field x:Float,y:Float
	Field dx:Float,dy:Float
	Field angle:Int
	Field a:Float = 1

	Const da:Float = 1.0 / 50

	Method Create:TBullet(_x:Float,_y:Float,_ang:Int)
		ListAddLast(BulletList,Self)
		x = _x
		y = _y
		angle = _ang
		dx = AngleToDX(_ang)
		dy = AngleToDY(_ang)
	End Method
	
	Method Update()
		x:+dx*BULLET_SPEED
		y:+dy*BULLET_SPEED
		x:+ -pdx
		y:+ -pdy
		
		a:-da
		If a &lt;= 0 BulletList.Remove(Self)
		
		SetAlpha a
		SetRotation angle
		DrawImage bullet_img,x,y
		SetRotation 0
		SetAlpha 1
	End Method

End Type


Type TEnemy
	Field x:Float,y:Float
	Field dx:Float,dy:Float
	Field angle:Int
	Field shoottimer:Int
	
	
	Const SPEED:Int = 15
	Method Create:TEnemy()
		ListAddLast(EnemyList,Self)
		x = Rand(50,500)
		y = 50
	End Method
	
	Method Update()
		If PointsToDistance(x,y,400,300) &gt;= 100
			angle = PointsToAngle(x,y,400,300)+90
			'dx = AngleToDX(angle)*SPEED
			'dy = AngleToDY(angle)*SPEED
			dx:+AngleToDX(angle)* 0.01
			dy:+AngleToDY(angle)* 0.01
			If dx &gt; 15 dx = 15
			If dx &lt; -15 dx = -15
			If dy &gt; 15 dy = 15
			If dy &lt; -15 dy = -15
	Rem
		Else
			angle:+1
			dx:+AngleToDX(angle) * 5
			dy:+AngleToDY(angle) * 5
	End Rem
		End If
		
		x:+dx
		y:+dy
		
		x:+ -pdx
		y:+ -pdy
			
		If shoottimer &gt; Rand(20,35)
			PlaySound shoot_sound
			Local bul:TBullet = New TBullet.Create(x,y,angle)
			shoottimer = 0
		End If
	
		SetRotation angle
		DrawImage player_img,x,y
		SetRotation 0
		
		shoottimer:+1
	End Method

End Type

'------------------------
'FUNCTION
'------------------------

Function UpdateBG()

	TileImage bg_img,-(px/4),-(py/4)
	SetAlpha .7
	TileImage bg_img,-(px/2),-(py/2)
	SetAlpha .4
	TileImage bg_img,-px,-py
	SetAlpha 1

End Function

Function UpdateBullets()
	For Local b:TBullet = EachIn BulletList
		b.Update()
	Next
End Function

Function UpdatePlayer()

	If KeyDown(KEY_UP)	
		If burning = False burning = True
		pdx:+AngleToDX(protation)*ACCELERATION
		pdy:+AngleToDY(protation)*ACCELERATION
	Else
		If burning = True burning = False
	End If
		
	If KeyDown(KEY_LEFT)
		protation:-3
	End If
	
	If KeyDown(KEY_RIGHT)
		protation:+3	
	End If
	
	If KeyHit(KEY_SPACE)
		PlaySound shoot_sound
		Local bul:TBullet = New TBullet.Create(400,300,protation)
	End If
	
	If burning
		EmitParticle(Cos(protation-90) * -5 + 400-2, Sin(protation-90) * -5 + 300, firepart, 10, True, Rand(protation+120, protation+240), 3)
		EmitParticle(Cos(protation-90) * -5 + 400-2, Sin(protation-90) * -5 + 300, firepart, 10, True, Rand(protation+120, protation+240), 3)
		EmitParticle(Cos(protation-90) * -5 + 400-2, Sin(protation-90) * -5 + 300, firepart, 10, True, Rand(protation+120, protation+240), 3)
	End If
	
	If pdx &gt; 15 pdx = 15
	If pdx &lt; -15 pdx = -15
	If pdy &gt; 15 pdy = 15
	If pdy &lt; -15 pdy = -15

	If protation &gt; 360 protation = protation - 360
	If protation &lt; 0 protation = protation + 360
	
	px :+ pdx
	py :+ pdy	


	SetRotation protation
	DrawImage player_img,400,300
	SetRotation 0
End Function

Function UpdateEnemys()
	For Local e:TEnemy = EachIn EnemyList
		e.Update()
	Next
End Function
</textarea> <br><br></td></tr></table><br>
<a name="870978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> also why is this so dog slow? (its not the particles)<br><br>reason why I ask is because I use a similar routine for astroids clones for checking if the bullet hit the asteriod...<br><br>It keeps droping the FPS, it steadly drops like 4 fps every 3 seconds.<br><br>this is under TBullet.update<br><br><pre class=code>
		If a &lt; .7
			If ImagesCollide(bullet_img, x, y, 0, player_img, 400, 300, 0)
				BulletList.Remove(Self)
				ParticleExplosion(x, y, playerpart, 10, 40,,True)
				ParticleExplosion(x, y, firepart2, 10, 40)
			End If
			
			For Local e:TEnemy = EachIn EnemyList
				If ImagesCollide(bullet_img, x, y, 0, player_img, e.x, e.y, 0)
					BulletList.Remove(Self)
					ParticleExplosion(e.x, e.y, playerpart, 10, 40,,True)
					ParticleExplosion(e.x, e.y, firepart2, 10, 40)
					EnemyList.Remove(e)
				End If
			Next
		End If
</pre> <br><br></td></tr></table><br>
<a name="871037"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> How many bullets in your bullet list?<br>List.remove(object) will scan through everything in the list until it finds the one to remove.<br>With your checks and loops that might be a lot of checking. <br><br></td></tr></table><br>
<a name="871094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> except AngleToDY returns the oposite of that return <br></div><br><br>Do you mean this?:<br><br><pre class=code>
Function AngleToDY:Float(angle:Float)
	Return 	-Sin(angle)
End Function
</pre><br><br><div class="quote"> Also tis would be very hard to implement as I don't have a player type. But i'll see what I can do <br></div><br><br>Have you tried just replacing your code (TEnemy) with the code I posted (the "So your type is now" bit)? <br><br></td></tr></table><br>
<a name="871109"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Have you tried....<br><br>Actually I just did that(I had to remove the player.cx/player.cy for 400/300 though) but it worked.<br><br>Anyways it seems to be constantly orbiting rather than to chase after it gets out of radius...<br><br>Heres the code:<br><br><pre class=code>
	Method Update()
		DrawText PointsToDistance(x,y,400,300),0,20
		dx = (400 - x) 
		dy = (300 - y)
		Local dist:Float = Sqr(dx * dx + dy * dy)
		If PointsToDistance(x,y,400,300) &gt;= radius
			angle = PointsToAngle(x,y,400,300)
			dx = AngleToDX(angle)*SPEED
			dy = AngleToDY(angle)*SPEED
			angle:+180
		Else
			angle:+4
			dx:+AngleToDX(angle) * (radius- 2)
			dy:+AngleToDY(angle) * (radius- 2)
		End If
		
		x:+dx
		y:+dy
		
		x:+ -pdx
		y:+ -pdy	
			
		If shoottimer &gt; 20
			PlaySound shoot_sound
			Local bul:TBullet = New TBullet.Create(x,y,angle-90,2)
			shoottimer = 0
		End If
	
		SetRotation angle - 90
		DrawImage player_img,x,y
		SetRotation 0
		
		shoottimer:+1
	End Method
</pre><br><br><br>&gt;How many bullets in your bullet list?<br>List.remove(object) will scan through everything in the list until it finds the one to remove.<br>With your checks and loops that might be a lot of checking. <br><br>I figured as much, I'm using a rects overlap function, and it's not lagging now, but the problem is, I'd like to figure out a rects dimensions based on its angle... So if its pointing up or down(the bullet) create a 7x15 rect for checking(the dimension of the image).<br><br>But since they go at all angles how would you make a rectanlge to cover the whole thing. like at 45 deg, make a 11x11 (or whatever it may be?) rect to cover the whole image.<br><br>You'd probably create the rect's dimensions when creating the bullet based on angle, and store it with the bullet type to be called on with a collision check (fastest way?) But how do you get those dimensions?<br><br>how would you do this? <br><br></td></tr></table><br>
<a name="871123"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I had to remove the player.cx/player.cy for 400/300 though <br></div><br><br>Sorry about that, thought I took out all my code...<br><br><div class="quote"> Anyways it seems to be constantly orbiting rather than to chase after it gets out of radius... <br></div><br><br>Thats why I said it was a start... ;-) On mine it looks like its a magnet kind of effect and you need to go pretty fast to get them to chase again... <br><br></td></tr></table><br>
<a name="871161"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see, well, it will do for now. Now I need to figure out the bullet collision AND try to make my particles stick to the background, my particle system is odd, but I think I can rewrite it to stick to the background.<br><br><br>Another thing, is when the player dies, I want him to spawn back at point one, but the problem is, the enemys stick to the screen. I want them to stay back where the death happened and have to fly back to the player.<br><br>How would you do this? <br><br></td></tr></table><br>
<a name="871208"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >The r0nin</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Another thing, is when the player dies, I want him to spawn back at point one, but the problem is, the enemys stick to the screen. I want them to stay back where the death happened and have to fly back to the player. <br></div><br><br>You'll need to keep track of the offset (the number of times the screen has scrolled, and by how much for x and y).  Then you simply add that offset to anything you want to "stay in place" (putting most of them off-screen most likely).  That way the player re-appears at your origin and the enemies have to fly back to him. <br><br></td></tr></table><br>
<a name="871257"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> cool, i'll try that, What about the angle -&gt; size of rectangle thing? <br><br></td></tr></table><br>
<a name="871364"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Odd, this is proving difficult,<br><br><pre class=code>
Local angles:Int[] = [0,45,90,135,180]

Print "Angle   -   Width   -   Height"
For Local i:Int = 0 To 4
	Print angles[i]+"   -   "+(Sin(angles[i])*7+7)+"   -   "+(Cos(angles[i])*15)
Next
</pre><br>produces some random results.<br><br>This is what i'm trying to accomplish:<br><br>*Bullet image is 7x15<br>*The bullet type has a coll_w and a coll_h field<br><br>1. When a bullet is created I check it's angle<br>2. I then use some math to fill the coll_w and coll_h fields, I need to create a rectangular dimensions to fully cover the bullet image no matter what angle it's pointing to.<br>3. Use these dimensions to create a collision checking rectangle, and use as needed<br><br><br>See above for my progress, remember the bullet image's width is 7px, and it's height is 15px. <br><br></td></tr></table><br>
<a name="871636"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Eh, just checking on the center of the bullet will work for now.<br><br>New question:<br><br>How do I create a radar? (you know like a little green circle in the HUD that has a brighter green line go in circles around it and lights up little green dots that would be enemies)<br><br>I'm searching the code archives but cant find any radar code... <br><br></td></tr></table><br>
<a name="871665"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, This is what I have so far on the radar, but it's waaaaay off.<br><br>1. The player dot is suppost to be centered<br>2. The Enemies arent suppost to go off the radar<br><br>But it's a good start, anyone know what i'm doing wrong?<br><br><pre class=code>
	SetColor 0,150,0
	DrawOval 100,100,200,200
	SetColor 255,255,255
	For Local e:TEnemy = EachIn EnemyList
		RadPx = (e.x/8000)*200 + (100*2)
		RadPy = (e.y/8000)*200 + (100*2)
		Plot(RadPx,RadPy)
	Next
	RadPx = (px/8000)*200 + (100*2)
	RadPy = (py/8000)*200 + (100*2)
	DrawOval RadPx-5,RadPy-5,10,10
</pre> <br><br></td></tr></table><br>
<a name="872402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your not offsetting the enemies from the players central position..<br><br><pre class=code>
' Some constants to control the radar

Const radarScale = 40 '8000/200
Const radarOffset = 200 '100*2
Const radarWidth = radarOffset*2

'Calculate radar position as an offset from the player

RadPx = ((e.x-px)/radarScale)
RadPy = ((e.y-py)/radarScale)

'ensure radar wraps around player - only use if game arena wraps around player 

RadPx = wrap(-radarOffset,radarOffset,RadPx)
RadPy = wrap(-radarOffset,radarOffset,RadPy)

'wrap function ensures radar image wraps around game arena

Function wrap(min,max,value)
 local width:int = max-min
  if value &gt; max then 
    value:-width
  else if value &lt; 0 then 
    value:+width
  endif
end function
</pre><br><br>Hope this helps <br><br></td></tr></table><br>
<a name="872419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> the wrap function doesnt return anything? <br><br></td></tr></table><br>
<a name="872426"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> alright this is what I have now... getting close, but there's still a blob of dots running around on the screen, not vanishing when they get to the boundries of the radar... <br><br><br>here's the wrap function:<br><br><pre class=code>
Function RadarWrap:Int(_Min:Float,_Max:Float,value:Float)
 Local width:Int = _Max-_Min
  If value &gt; _Max Then 
    value:-width
  Else If value &lt; 0 Then 
    value:+width
  EndIf

Return value
End Function
</pre><br> here's the constants(what's this offset thing?):<br><pre class=code>
Const radarScale:Int = 40 '8000/200
Const radarOffset:Int = 50 'What's this?
Const radarWidth:Int = radarOffset*2
</pre><br>Here's the radar code:<br><pre class=code>
	'Radar(replace w/ image later)
	SetColor 0,150,0
	DrawOval 824,568,200,200
	SetColor 255,255,255

	'plot a pixel at the enemies locations on the radar
	For Local e:TEnemy = EachIn EnemyList
		RadPx = ((e.x-px)/radarScale)
		RadPy = ((e.y-py)/radarScale)

		RadPx = RadarWrap(-radarOffset,radarOffset,RadPx) + 824 ' radar's x location
		RadPy = RadarWrap(-radarOffset,radarOffset,RadPy) + 568 ' radar's y location
		Plot(RadPx,RadPy)
	Next
	
	'draw a white oval at the center of the radar, this represents the player.
	DrawOval 919, 663, 5, 5
</pre> <br><br></td></tr></table><br>
<a name="872483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks good,<br><br>Oops the radarOffset is the radius of the radar, radarRadius would indeed be a better name for the variable!<br><br>Regards <br><br></td></tr></table><br>
<a name="872528"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmm, still doesnt explain why the dots travel around the screen <br><br></td></tr></table><br>
<a name="873466"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops, well the Radar Offset should be 100 as your example radar has a width of 200.<br><br>And the wrap should be based &lt; _Min not &lt; 0<br><br><pre class=code>
	Const radarScale:Int = 40 '8000/200
	Const radarOffset:Int = 100 'Radius of Radar
	Const radarWidth:Int = radarOffset*2

Function RadarWrap:Int(_Min:Float,_Max:Float,value:Float)
 Local width:Int = _Max-_Min
  If value &gt; _Max Then 
    value:-width
  Else If value &lt; _Min Then 
    value:+width
  EndIf

Return value
End Function
</pre><br><br>Then there is the fact that your actual game space does not seem to have a limit so maybe you should just have a min and max for the radar.<br><br>Or you could use a distorted radar where it displays the square or cube-root of the distance from the player? <br><br></td></tr></table><br>
<a name="874948"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry for the late reply, but this still isn't working properly, I've tried a different approach:<br><br><pre class=code>

Const radarScale:Int = 40 '8000/200
Const radarRadius:Int = 100 'Radius of Radar

Function PointsToDistance#(x1#,y1#,x2#,y2#)
	Return Sqr(((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2)))
End Function

	'Radar(replace w/ image later)
	SetColor 0,150,0
	DrawOval 824,568,200,200
	SetColor 255,255,255

	'plot a pixel at the enemies locations on the radar
	For Local e:TEnemy = EachIn EnemyList
		RadPx = ((e.x-px)/radarScale+(px/radarScale)) + 919
		RadPy = ((e.y-py)/radarScale+(py/radarScale)) + 663
		If PointsToDistance(919,663,RadPx,RadPy) &lt; radarOffset
			Plot(RadPx,RadPy)
		End If
	Next
	
	'draw a white oval at the center of the radar, this represents the player.
	DrawOval 919, 663, 5, 5
</pre><br><br>When you first start the game it works perfectly, until you move the player, then the place where the dots close in on the big dot(the player) moves off a bit.. <br><br></td></tr></table><br>
<a name="875495"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Digital Anime</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> I created the following code to handle positions easier with a function<br><br>here is the source of my zrm.bmx file I include in games in which I want to use rotate, shake or zoom everything drawn with the new functions<br><br>I draw tiles on an x and y position for example with the zrm drawcommands and let tell how many degrees all should be rotated, moved out of position or even in wich scale it should be drawn realtime.<br><br>I wonder if this is usefull for your task :<br><br><pre class=code>
'########################################
'### Zoom Rotate And Move Version 1.0 ###
'########################################
'
' This file is used to zoom, rotate and move everything that you want by using the ZRM functions
' and can be implemented in your project even when you are almost done
'
' I needed only the rotate function at first to rotate all stuff 180 on the display, so I only need
' ZRM_Rotate (180) to determine how every ZRM draw function should be rotated
'
' DrawImage will be replaced by ZRM_DrawImage
'
' include this file in your Blitzmax application with :
' 
' include "ZRM.bmx"
'
' This needs to be done after the setgraphics command
'
' Functions :
'
' - ZRM_Zoom (x:Float, y:Float)                                : Zooms everything on the screen drawn with ZRM_Draw functions
'                                                                Is used the same as SetScale
'
' - ZRM_Rotate (angle:Float)                                   : Rotates everything on the screen drawn with ZRM_Draw functions
'                                                                Is used the same as SetRotation
'
' - ZRM_Move (x:Float, y:Float)                                : Moves everything from the middle of the screen drawn with ZRM_Draw functions
'                                                                X stands for - or + amount of pixels to go left or right
'                                                                Y stands for - or + amount of pixels to go up or down
'
' - ZRM_SetScale (x:Float, y:Float)                            : Replacement for SetScale
'
' - ZRM_SetRotation (angle:Float)                              : Replacement for SetRotation
' 
' - ZRM_DrawText (Text:String, x:Float, y:Float)               : Replacement for DrawText
'
' - ZRM_DrawImage (Image:TImage, x:Float, y:Float)             : Replacement for DrawImage (Works the same, but won't work with more frames)
'
' - ZRM_DrawRect (x:Float, y:Float, Width:Float, Heigth:Float) : Replacement for DrawRect
'
' - ZRM_DrawRect (x:Float, y:Float, Width:Float, Heigth:Float) : Replacement for DrawOval
'
' - ZRM_DrawLine (x1:Float, y1:Float, x2:Float, y2:Float)      : Replacement for DrawLine
'
' - More functions will be added
'
'Written by Mark Gerritsen

Global ZRM_Zoom_X:Float = 1
Global ZRM_Zoom_Y:Float = 1
Global ZRM_Rotate_Angle:Float = 0
Global ZRM_Move_X:Float = 0
Global ZRM_Move_Y:Float = 0
Global ZRM_SetScale_X:Float = 1
Global ZRM_SetScale_Y:Float = 1
Global ZRM_SetRotation_Angle:Float = 0
Global ZRM_Width:Int
Global ZRM_Height:Int
Global ZRM_Temp_X_X:Float
Global ZRM_Temp_X_Y:Float
Global ZRM_Temp_Y_X:Float
Global ZRM_Temp_Y_Y:Float

ZRM_Width  = GraphicsWidth()
ZRM_Height = GraphicsHeight()

Function ZRM_Zoom (X:Float, Y:Float)
	ZRM_Zoom_X = X
	ZRM_Zoom_Y = Y
End Function

Function ZRM_Rotate (Angle:Float)
	ZRM_Rotate_Angle = Angle
End Function

Function ZRM_Move (X:Float, Y:Float)
	ZRM_Move_X = X
	ZRM_Move_Y = Y
End Function

Function ZRM_SetScale (X:Float, Y:Float)
	ZRM_SetScale_X = X
	ZRM_SetScale_Y = Y
End Function

Function ZRM_SetRotation (Angle:Float)
	ZRM_SetRotation_Angle = Angle
End Function

Function ZRM_Drawtext (Text:String, X:Float, Y:Float)
		
	ZRM_Calculate (X, Y)
	DrawText Text, ((ZRM_Width / 2) + ZRM_Temp_X_X - ZRM_Temp_X_Y + ZRM_Move_X), ((ZRM_Height / 2) + ZRM_Temp_Y_X + ZRM_Temp_Y_Y + ZRM_Move_Y)

End Function

Function ZRM_DrawImage (Image:TImage, X:Float, Y:Float)

	ZRM_Calculate (X, Y)
	DrawImage Image, ((ZRM_Width / 2) + ZRM_Temp_X_X - ZRM_Temp_X_Y + ZRM_Move_X), ((ZRM_Height / 2) + ZRM_Temp_Y_X + ZRM_Temp_Y_Y + ZRM_Move_Y)

End Function

Function ZRM_DrawRect (X:Float, Y:Float, Width:Float, Height:Float)

	ZRM_Calculate (X, Y)
	DrawRect ((ZRM_Width / 2) + ZRM_Temp_X_X - ZRM_Temp_X_Y + ZRM_Move_X), ((ZRM_Height / 2) + ZRM_Temp_Y_X + ZRM_Temp_Y_Y + ZRM_Move_Y), Width, Height

End Function

Function ZRM_DrawOval (X:Float, Y:Float, Width:Float, Height:Float)

	ZRM_Calculate (X, Y)
	DrawOval ((ZRM_Width / 2) + ZRM_Temp_X_X - ZRM_Temp_X_Y + ZRM_Move_X), ((ZRM_Height / 2) + ZRM_Temp_Y_X + ZRM_Temp_Y_Y + ZRM_Move_Y), Width, Height

End Function 

Function ZRM_DrawLine (X1:Float, Y1:Float, X2:Float, Y2:Float)

	ZRM_Calculate (X1, Y1)
	Local X1_New:Float = ((ZRM_Width / 2) + ZRM_Temp_X_X - ZRM_Temp_X_Y + ZRM_Move_X)
	Local Y1_New:Float = ((ZRM_Height / 2) + ZRM_Temp_Y_X + ZRM_Temp_Y_Y + ZRM_Move_Y)
	ZRM_Calculate (X2, Y2)
	Local X2_New:Float = ((ZRM_Width / 2) + ZRM_Temp_X_X - ZRM_Temp_X_Y + ZRM_Move_X)
	Local Y2_New:Float = ((ZRM_Height / 2) + ZRM_Temp_Y_X + ZRM_Temp_Y_Y + ZRM_Move_Y)
	SetScale (1, 1)
	SetRotation (0)
	DrawLine X1_New, Y1_New, X2_New, Y2_New 

End Function 

Function ZRM_Calculate(X:Float, Y:Float)

	SetRotation (ZRM_SetRotation_Angle + ZRM_Rotate_Angle)
	SetScale (ZRM_SetScale_X * ZRM_Zoom_X), (ZRM_SetScale_Y * ZRM_Zoom_Y)
	ZRM_Temp_X_X = ((Cos(ZRM_Rotate_Angle) * (X - (ZRM_Width / 2)) * (ZRM_Zoom_X)))
	ZRM_Temp_X_Y = ((Sin(ZRM_Rotate_Angle) * (Y - (ZRM_Height / 2)) * (ZRM_Zoom_Y)))
	ZRM_Temp_Y_X = ((Sin(ZRM_Rotate_Angle) * (X - (ZRM_Width / 2)) * (ZRM_Zoom_X)))
	ZRM_Temp_Y_Y = ((Cos(ZRM_Rotate_Angle) * (Y - (ZRM_Height / 2)) * (ZRM_Zoom_Y)))

End Function
</pre> <br><br></td></tr></table><br>
<a name="875611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks for sharing, however, I don't think this is what i'm looking for exactly.<br><br>Basicly:<br><br>My game level is infinite, the radar is based off of what is around the player for a 8000px radius, the plan is to plot a pixel on the radar if the enemy is within 8000px of the player.<br><br>This is what i'm having trouble with, any help appriciated! <br><br></td></tr></table><br>
<a name="875953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> see if this gives you an idea<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Const RADARRADIUS:Float = 50.0
Const COVERRADIUS:Float = 800.0
Const DIAMETER:Float = COVERRADIUS*2
Const RATIO:Float = RADARRADIUS / COVERRADIUS


Type tpoint
	Field 	x:Float
	Field 	y:Float
End Type

Type Tradar
	Field	x		:Float , ..
			y		:Float
			
	Field 	Asquare	:Float
	Field	diameter	:Float
	Field	origin	:tpoint
	Field 	lt		:tpoint
	Field	rt		:tpoint
	Field	lb		:tpoint
	Field	rb		:tpoint
	Field	pointlist :TList		

	Method Create(x:Float , y:Float)
		Self.x = x
		Self.y = y
		Self.Asquare = COVERRADIUS ^ 2
		Self.diameter = COVERRADIUS*2
		origin = New tpoint
		pointlist = CreateList() 
		lt = New tpoint
		rt = New tpoint
		lb = New tpoint
		rb = New tpoint
		Local dx:Float = (DIAMETER - GraphicsWidth())/2 
		Local dy:Float = (DIAMETER - GraphicsHeight())/2
		lt.x = dx * RATIO
		lt.y = dy * RATIO		
		lb.x = lt.x
		rt.y = lt.y
		dx = dx + GraphicsWidth()   
		dy = dy + GraphicsHeight() 
		rb.x = dx * RATIO
		rb.y = dy * RATIO
		rt.x = rb.x
		lb.y = rb.y
	End Method
	
	Method set(x:Float , y:Float) 
		origin.x = x
		origin.y = y
	End Method
	
	Method addpoint:Int(x:Float , y:Float) 
		x:- 320
		y:- 240
		Local dx:Float = x 
		Local dy:Float = y
		If (dx^2+dy^2) &lt;= Asquare  
			Local point:tpoint = New tpoint
			point.x = dx*RATIO
			point.y = dy*RATIO
			pointlist.addlast(point) 
			Return True 
		Else
			Return False
		EndIf 
	End Method
	
	Method clear() 
		pointlist.clear()
	End Method
	
	Method draw() 
		SetColor 200,200,0 
		SetAlpha .2
		DrawOval x - RADARRADIUS , y - RADARRADIUS , RADARRADIUS * 2 , RADARRADIUS * 2
		SetColor 0 , 255 , 0
		DrawLine  lt.x ,  lt.y , rt.x ,  rt.y
		DrawLine  lt.x ,  lt.y , lb.x ,  lb.y
		DrawLine  lb.x ,  lb.y , rb.x ,  rb.y
		DrawLine  rt.x ,  rt.y , rb.x ,  rb.y
		
		SetAlpha 1.0
		SetColor 200,0,0
		For Local p:tpoint = EachIn pointlist
			Plot x+p.x , y+p.y
		Next
		
		SetColor 255,255,255
	End Method
End Type

Type Tenemy
	
	Field x# , y#
	Field dx# , dy#

	Method Create ()

		x = Rand(GraphicsWidth()) 
		y = Rand(GraphicsHeight())
		dx = Cos(Rand(360.0)) *.2
		dy = Sin(Rand(360.0) )*.2
	End Method
	
	Method move() 
		x :+ dx
		y :+ dy
	End Method
			
	Method draw( )
		DrawRect x - 2 , y - 2 , 4 , 4
	End Method
End Type


Graphics 640,480,32
SetBlend alphablend
Local radar:Tradar = New Tradar
radar.Create(50 , 50) 
radar.set(400 ,400) 

Local enemy:Tenemy[5]
Local index:Int
For index = 0 Until enemy.length
	enemy[index] = New Tenemy
	enemy[index].Create() 
Next
Local x:Int = 0
Local y:Int = 0
Repeat
	Cls
	radar.clear() 
	DrawText enemy.length, 500,80
	For index = 0 Until enemy.length
		enemy[index].move() 
		If radar.addpoint(enemy[index].x , enemy[index].y) 
			enemy[index].draw() 
		EndIf
		enemy[index].x :+ x
		enemy[index].y :+ y 
	Next
	radar.draw() 
	If KeyDown(key_left)
		x = -3 
	ElseIf KeyDown(key_right) 
		x = 3
	Else
		x = 0
	EndIf
	If KeyDown(key_up) 
		y = -3 
	ElseIf KeyDown(key_down) 
		y = 3
	Else
		y = 0
	endif
	radar.set(x,y) 
	DrawText x+" "+y,500,50 
	Flip() 
Until KeyDown(key_escape)
</textarea> <br><br></td></tr></table><br>
<a name="876189"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got it, thanks for all the help, the problem was me not adding the center of the screen into account.. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
