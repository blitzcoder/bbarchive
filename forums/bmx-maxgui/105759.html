<!DOCTYPE html><html lang="en" ><head ><title >Demand for a macos/linux test</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Demand for a macos/linux test</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=117" >MaxGUI Module</a>/<a href="#bottom" >Demand for a macos/linux test</a><br><br>
<a name="1293519"></a>

<a name="1293520"></a>

<a name="1293618"></a>

<a name="1293620"></a>

<a name="1293622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a code I posted on archive section "as is", but I wish someone which owns both windows and Linus/Macos can test this and tell me if it works the same (and if it works at least)<br><br><br>I'm going to instal linux on and old hardware machine, but currently I only have windows installed.<br><br>I have never put a hand on a mac ... so I absolutely don't know how it looks and/or how it's supposed to behave on this environment and as it's part of some extra stuff I use for my modelisation software, I hope it can works on all platforms the same way.<br><br>You probably will tell me.<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import maxgui.drivers


Const COLLAPSEITEM_RIGHT:Int	=	8192

Type TCollapserItem Extends TProxyGadget
	
	Field core:TGadget;
		Field bt:TGadget;
		Field title:TGadget;
		Field realheight:Int;
	Field client:TGadget;
	
	Field _style:Int;
	Field title_height:Int;
	Field _pix:TPixmap[];
	Field _state:Byte;
	Field _on:Byte;
	
	'#region private (internal) stuff
	Method CleanUp :Int ()
		If Self.getCollapser()&lt;&gt;Null Then Self.getCollapser().RemoveGadget(Self);
		Return Self.proxy.CleanUp();
	End Method
	
	' update the pixmap icon of the top button
	Method updatePixmap()
		Self.bt		.SetPixmap		( Self._pix[Self._on*2+Self._state], PANELPIXMAP_STRETCH );
	End Method
	
	' when mouse enter the button
	Method onEnter()
		Self._on = 1;
		Self.updatePixmap	( );
	End Method
	
	' when mouse leave the button
	Method onLeave()
		Self._on = 0;
		Self.updatePixmap	( );
	End Method
	
	Method updateShape()
		If Self._state
			Self.core.SetShape(Self.xpos,Self.ypos,Self.width,Self.realheight);
			Self.client.SetShape(1,Self.title_height,Self.width-2,Self.realheight-Self.title_height-1);
			Self.client.SetShow(True);
		Else
			Self.core.SetShape(Self.xpos,Self.ypos,Self.width,Self.title_height);
			Self.client.SetShape(1,Self.title_height,Self.width-2,Self.realheight-Self.title_height-1);
			Self.client.SetShow(False);
		EndIf;
		If ( (Self._style &amp; COLLAPSEITEM_RIGHT) &gt; 0 )
			' title is left / button is right
			Self.title	.SetShape	( 1, 1, Self.width-Self.title_height-1, Self.title_height-2 );
			Self.bt		.SetShape	( Self.width-Self.title_height+1, 1, Self.title_height-2, Self.title_height-2 );
		Else
			' default : button is left
			Self.bt		.SetShape	( 1,1,Self.title_height-2,Self.title_height-2 );
			Self.title	.SetShape	( Self.title_height, 1, Self.width-Self.title_height-1, Self.title_height-2 );
		EndIf
	End Method
	'#end region
	
	'#region create
	Method Create:TCollapserItem ( pTitle:String, pX:Int, pY:Int, pW:Int,pH:Int, pCollapser:TCollapser, pStyle:Int=0)
		
		' only add items to a Collapser gadget !
			If pCollapser = Null Then Return Null;
			Self.title_height=	Int(Floor(pCollapser.title_height*0.5))*2+1;
			Self.realheight	=	pH;
			
			Self._state		=	True;
			Self._style		=	pStyle;
			Self.parent		=	pCollapser;
			Self._on		=	0;
			
		' generate pixmaps
			Local l_th:Int	=	Self.title_height;
			Local pix_h:Int	=	(l_th-2);
			Self._pix		=	[	CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888)];
									
				Self._pix[0]		.ClearPixels($808080);
				Self._pix[1]		.ClearPixels($808080);
				Self._pix[2]		.ClearPixels($A0A0A0);
				Self._pix[3]		.ClearPixels($A0A0A0);
				
				Local pix_x:Int;
				Local pix_m:Int = Floor(pix_h*0.5);
				For pix_x = 3 Until pix_h-3
					Self._pix[0].WritePixel(pix_x, pix_m, $010101);
					Self._pix[0].WritePixel(pix_m, pix_x, $010101);
					Self._pix[1].WritePixel(pix_x, pix_m, $010101);
					Self._pix[2].WritePixel(pix_x, pix_m, $010101);
					Self._pix[2].WritePixel(pix_m, pix_x, $010101);
					Self._pix[3].WritePixel(pix_x, pix_m, $010101);
				Next
				
		' title panel
			Self.core	=	CreatePanel		( pX,pY,pW,ph, pCollapser.getClient(), pStyle );
				Self.core	.SetColor		( $01,$01,$01 );
				Self.core	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, 0 );
				
		' button + title
			If ( (pStyle &amp; COLLAPSEITEM_RIGHT) &gt; 0 )
				' title is left / button is right
				Self.title=	CreateLabel		( " "+pTitle+" ", 1, 1, pw-l_th-1, l_th-2, Self.core, pStyle );
				Self.bt	=	CreatePanel		( pw-l_th+1, 1, l_th-2, l_th-2, Self.core, PANEL_ACTIVE );
				Self.bt		.SetLayout		( 0, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
			Else
				' default : button is left
				Self.bt	=	CreatePanel		( 1,1,l_th-2,l_th-2, Self.core, PANEL_ACTIVE );
				Self.bt		.SetLayout		( EDGE_ALIGNED, 0, EDGE_ALIGNED, EDGE_ALIGNED );
				Self.title=	CreateLabel		( " "+pTitle+" ", l_th, 1, pw-l_th-1, l_th-2, Self.core, pStyle );
			EndIf
				Self.bt		.SetColor		( $80,$80,$80 );
				Self.title	.SetColor		( $60,$60,$60 );
				Self.title	.SetTextColor	( $FF,$80,$20 );
				Self.title	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
				
				Self		.updatePixmap	( );
				Self.bt.extra = Self;
				
		' client panel
			Self.client	=	CreatePanel		( 1, l_th, pw-2, ph-l_th-1, Self.core );
				Self.client	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
				Self.client	.SetColor		( $40,$40,$40 );
				
		' set proxy
			Self.proxy	=	Self.core;
			
		' Update layout (by Default : stick Left And Right)
			' we align on top, not bottom, but whatever we set, top and bottom will be forced after collapser update
			' ( and collapser update is called by addItem, so it's updated immediatly after setlayout. )
			Self.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,0);
			
			pCollapser.addItem(Self);
			
		Return Self;
		
	End Method
	'#end region
	
	'#region text
	' text is sent to the title gadget
	Method SetText(text:String)
		Self.title.SetText(text);
	End Method
	
	Method GetText:String()
		Return Self.title.GetText();
	End Method
	'#end region
	
	'#region fold/unfold
	' returns true if gadget is expanded else returns false.
	Method State:Int()
		Return Self._state;
	End Method
	
	' alternates the collapsed/expanded state relatives to the previous state
	Method SwitchState()
		Self.setState(Not(Self._state));
	End Method
	
	' collapse (0) or expand (1) the gadget
	Method SetState(bool:Byte)
		If bool
			Self.Expand();
		Else
			Self.Collapse();
		EndIf
	End Method
	
	' collapse the gadget
	Method Collapse()
		If ( Self._state = False )	Then Return;
		Self._state				=	0;
		Self						.updatePixmap	( )
		Self						.updateShape	( );
		Self.getCollapser()			.Update			( );
		EmitEvent					( CreateEvent	( EVENT_GADGETACTION, Self, 0 ) );
	End Method
	
	' expand the gadget
	Method Expand()
		If ( Self._state = True )	Then Return;
		Self._state				=	1;
		Self						.updatePixmap	( );
		Self						.updateShape	( );
		Self.getCollapser()			.Update			( );
		EmitEvent					( CreateEvent	( EVENT_GADGETACTION, Self, 1 ) );
	End Method
	
	' fold the gadget (alias for collapse)
	Method fold()
		Self.Collapse();
	End Method
	
	' unfold the gadget (alias for expand)
	Method unfold()
		Self.Expand();
	End Method
	'#end region
	
	'#region shape
	' returns the real Height the item is supposed To be (Not the collapsed Height)
	Method GetHeight:Int()
		Return Self.realheight;
	End Method
	
	' the client gadget.
	Method getClient:TGadget()
		Return Self.client;
	End Method
	
	' client size
	Method ClientWidth:Int()
		Return Self.client.ClientWidth()
	End Method
	
	Method ClientHeight:Int()
		Return Self.client.ClientHeight()
	End Method
	
	Method SetShape(pX:Int,pY:Int,pW:Int,pH:Int)
		' copy shape pos and size
		Self.xpos = px;
		Self.ypos = py;
		Self.width = pw;
		Self.Height = ph;
		Self.realheight = ph; ' get real size of the gadget (whatever it is collapsed or not)
		
		' the core gadget is updated after this
		Self.updateShape();
	End Method
	
	Method SetLayout( lft:Int,rht:Int,top:Int,bot:Int )
		Self.proxy.SetLayout(lft,rht,top,bot);
		' copy core layout to self
		Self.lockl = Self.proxy.lockl;
		Self.lockr = Self.proxy.lockr;
		Self.lockt = Self.proxy.lockt;
		Self.lockb = Self.proxy.lockb;
		Self.lockx = Self.proxy.lockx;
		Self.locky = Self.proxy.locky;
		Self.lockw = Self.proxy.lockw;
		Self.lockh = Self.proxy.lockh;
		Self.lockcw = Self.proxy.lockcw;
		Self.lockch = Self.proxy.lockch;
	End Method
	'#end region
	
	
	' the Collapser object that owns this item
	Method getCollapser:TCollapser()
		Return TCollapser(Self.parent);
	End Method
	
	Function gadgetCollapserItem:TCollapserItem(gad:TGadget)
		If gad=Null Then Return Null;
		If gad.GetGroup() = Null Then Return Null; ' button.parent = core
		Return TCollapserItem(gad.extra);
	End Function
	
End Type


Const COLLAPSER_AUTORESIZE:Int	=	512;	' set collapser client height to match kids
Const COLLAPSER_AUTOSCROLL:Int	=	1024;	' add scrollbar if required

Type TCollapser Extends TProxyGadget
	
	Global collapsedTime:Int;
	?MacOs
	Global DEFAULT_SCROLLWIDTH:Int	=	16;
	?Not MacOs
	Global DEFAULT_SCROLLWIDTH:Int	=	13;
	?
	
	Field title_height:Int;
	Field scroll_size:Int;
	Field client:TGadget;
	
	Field scrollbarY:TGadget;
	
	Field paddingy:Int;
	
	Field items:TList;
	
	Method Create:TCollapser(pX:Int, pY:Int, pW:Int, pH:Int, pGroup:TGadget, pStyle:Int)
		
		collapsedTime = MilliSecs()-101;
		
		Self.items		=	New TList;
		
		Self.title_height=	17;
		Self.scroll_size=	DEFAULT_SCROLLWIDTH;
		Self.paddingy	=	5;
		
		Self.SetProxy		( CreatePanel(pX,pY,pW,pH,pGroup,pStyle) );
		
		' not implemented yet
		Self.scrollbarY	=	CreateSlider	( pw-Self.scroll_size,0,Self.scroll_size,ph, Self.proxy, SLIDER_VERTICAL | SLIDER_SCROLLBAR );
		Self.scrollbarY		.SetLayout		( 0,EDGE_ALIGNED, EDGE_ALIGNED,EDGE_ALIGNED );
		Self.scrollbarY		.SetShow		( False );
		
		Self.client		=	CreatePanel		( Self.scroll_size/2,Self.title_height,pw-Self.scroll_size,ph, Self.proxy );
		Self.client			.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED, EDGE_ALIGNED,EDGE_ALIGNED);
		
		AddHook				( EmitEventHook, EventHook, Self );
		
		Return Self;
		
	End Method
	
	Method Rethink()
		Self.Update();
		Super.Rethink();
	End Method
	
	Function EventHook:Object(id:Int, data:Object, context:Object)
		If TEvent(data) = Null Then Return data;
		Local ev:TEvent = TEvent(data);
		
		Local col:TCollapser
		Local itm:TCollapserItem;
		
		Select ev.id
			
			Case EVENT_WINDOWSIZE
				
				col = TCollapser(context); If col&lt;&gt;Null Then col.Rethink();
				Return data;
				
			Case EVENT_MOUSEENTER
				
				If TGadget(ev.source)&lt;&gt;Null
					itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
					If (itm&lt;&gt;Null) Then If itm.getCollapser()=context Then itm.onEnter(); Return data;
				EndIf;
				Return data;
				
			Case EVENT_MOUSELEAVE
				
				If TGadget(ev.source)&lt;&gt;Null
					itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
					If (itm&lt;&gt;Null) Then If itm.getCollapser()=context Then itm.onLeave(); Return data;
				EndIf;
				Return data;
				
			Case EVENT_MOUSEUP
				
				If (ev.data = 1)
					If TGadget(ev.source)&lt;&gt;Null
						itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
						If (itm&lt;&gt;Null)
							If (itm.getCollapser()=context)
								If (ev.x&gt;=0 And ev.x&lt;itm.bt.GetWidth())
									If (ev.y&gt;=0 And ev.y&lt;itm.bt.GetHeight())
										If Abs(MilliSecs()-TCollapser.collapsedTime)&gt;100
											itm.SwitchState();
											TCollapser.collapsedTime = MilliSecs();
										EndIf;
									EndIf;
								EndIf;
								Return Null;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
				
			Case EVENT_GADGETACTION
				If TCollapser(context)&lt;&gt;Null
					col = TCollapser(context);
					If ( ev.source = col.scrollbarY )
						col.client.SetShape(0,-SliderValue(col.scrollbarY), col.proxy.width-col.scroll_size, col.client.Height);
						RedrawGadget col;
					EndIf;
				EndIf;
				
		End Select;
		Return data;
	End Function
	
	Method CleanUp :Int ()
		Self.proxy.CleanUp();
		RemoveHook(EmitEventHook, EventHook, Null);
		Return Super.CleanUp();
	End Method
	
	Method AddItem(item:TGadget)
		' Always layout stuff with &lt;ALIGN TOP&gt; and &lt;NOT ALIGNED BOTTOM&gt; !
		item.SetLayout(item.lockl,item.lockr, EDGE_ALIGNED,0);
		Self.items.AddLast(item);
		Self.Update();
	End Method
	
	Method RemoveItem(index:Int)
		If index&lt;0 Or index&gt;=Self.items.Count() Then Return;
		Self.items.Remove(Self.items.ValueAtIndex(index));
		Self.Update();
	End Method
	
	Method RemoveGadget:Int(gad:TGadget)
		Self.items.Remove(gad);
		Self.Update();
	End Method
	
	Method GetItem:TGadget(index:Int)
		Return TGadget(Self.items.ValueAtIndex(index));
	End Method
	
	Method GetClient:TGadget()
		Return Self.client;
	End Method
	
	Method ClientWidth:Int()
		Return Self.client.ClientWidth();
	End Method
	
	Method ClientHeight:Int()
		Return Self.client.ClientHeight();
	End Method
	
	Method Update()
		
		' resize/repos clients
		Self.items.Sort(True, compareGadgetY)
		Local item:TGadget;
		Local posy:Int = Self.paddingy;
		Local gadh:Int = 0;
		
		For item = EachIn Self.items
			If ( TCollapserItem(item)&lt;&gt;Null )
				If TCollapserItem(item)._state
					gadh = TCollapserItem(item).GetHeight();
				Else
					gadh = TCollapserItem(item).title_height;
				EndIf;
			Else
				gadh = item.GetHeight();
			EndIf;
			item.SetShape ( item.GetXPos(), posy, item.GetWidth(), item.GetHeight() );
			posy :+ gadh + Self.paddingy;
		Next;
		
		gadh = posy;
		Local clh:Int = Self.proxy.Height-Self.title_height;
		
		If ( gadh &gt; clh )
			Self.scrollbarY.SetShow(True)
			Self.client.SetShape(0,Self.title_height,Self.proxy.width-Self.scroll_size, gadh);
			Self.scrollbarY.SetRange(clh, gadh);
		Else
			Self.scrollbarY.SetShow(False);
			Self.client.SetShape(Self.scroll_size/2,Self.title_height,Self.proxy.width-Self.scroll_size, clh);
		'	Self.client.SetShape(0,Self.title_height,Self.client.width, gadh);
		EndIf;
		
		RedrawGadget Self;
		
	End Method
	
	Function compareGadgetY:Int(o1:Object, o2:Object)
		Return -1+2*(TGadget(o1).GetYPos()&gt;TGadget(o2).GetYPos());
	End Function
	
End Type


Function CreateCollapser:TCollapser ( pX:Int, pY:Int, pW:Int,pH:Int, pGroup:TGadget, pStyle:Int=0 )
	Return New TCollapser.Create(pX,pY,pW,pH,pGroup,pStyle);
End Function
Function CreateCollapsable:TCollapserItem ( pTitle:String, pX:Int, pY:Int, pW:Int, pH:Int, pCollapser:TGadget, pStyle:Int=0 )
	If TCollapser(pCollapser)=Null Then Return Null;
	Return New TCollapserItem.Create(pTitle, pX,pY,pW,pH, TCollapser(pCollapser), pStyle);
End Function
Function CollapserItem:TGadget(pCollapser:TGadget, index:Int)
	If TCollapser(pCollapser) = Null Then Return Null;
	Return TCollapser(pCollapser).GetItem(index);
End Function

Function CollapserAddItem(pCollapser:TGadget, item:TGadget)
	If TCollapser(pCollapser) = Null Then Return;
	TCollapser(pCollapser).AddItem(item);
End Function


Function CollapserClient:TGadget(pCollapser:TGadget)
	If TCollapser(pCollapser) = Null Then Return Null;
	Return TCollapser(pCollapser).getClient();
End Function

Function CollapsableClient:TGadget(pCollapsable:TGadget)
	If TCollapserItem(pCollapsable) = Null Then Return Null;
	Return TCollapserItem(pCollapsable).getClient();
End Function







Function TCollapserDemo()
	
	Local Win:TGadget = CreateWindow("window", 10,10,800,600,, WINDOW_TITLEBAR | WINDOW_CLIENTCOORDS | WINDOW_CENTER | WINDOW_RESIZABLE | WINDOW_STATUS );
	SetMinWindowSize(Win, 640,400)
	
	Local body:TGadget[2]
	Local a:Int;
	Local panI:TGadget[2];
	Local killMe:TGadget[2];
	For a = 0 To 1
		
		body[a] = CreatePanel(a*ClientWidth(Win)/2+5,5,ClientWidth(Win)/2-10, ClientHeight(Win)-10,Win)
		body[a].SetColor($90,$90,$90);
		If a=0
			body[a].SetLayout(EDGE_ALIGNED,EDGE_RELATIVE,EDGE_ALIGNED,EDGE_ALIGNED);
		Else
			body[a].SetLayout(EDGE_RELATIVE,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
		EndIf;
		
		' create a collapser
			Local col:TCollapser = CreateCollapser( 5,5, ClientWidth(body[a])-10, ClientHeight(body[a])-10, body[a] );
			col.SetColor($20,$20,$20);
			col.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
			
		' create collapsable region in the collapser
			CreateCollapsable	( "Buttons"				, 005,005,ClientWidth(col)-10, 100, col );
			CreateCollapsable	( "Radio Buttons"		, 005,110,ClientWidth(col)-10, 100, col );
			CreateCollapsable	( "it's really tight"	, 005,215,ClientWidth(col)-10, 200, col );
			
		' get collapsables from collapser
			Local pan0:TGadget = TCollapserItem(col.getitem(0)).getClient(); ' &gt; Add stuff to the client !
			Local pan1:TGadget = TCollapserItem(col.getitem(1)).getClient();
			Local pan2:TGadget = TCollapserItem(col.getitem(2)).getClient();
			Local colI:TCollapser = CreateCollapser( 5,5,ClientWidth(pan2)-10, ClientHeight(pan2)-10, pan2 );
				colI.SetColor($30,$30,$30);
				colI.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
				' you can use "Y" position at the creation to specify order of gadgets.
				' gadgets, when collapser updates, are sorted by their "Y" position.
				' for example, here the "btKill" is created on top of the two regions.
			CreateCollapsable("let me get out i'm locked :'(", 5, 1,ClientWidth(colI)-10, 100, colI);
			CreateCollapsable("speak for you bro ...", 5, 2,ClientWidth(colI)-10, 100, colI);
			Local btKill:TGadget = CreateButton("Kill Me Please", 5, 0, 100,20, colI.GetClient() );
				btKill.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
			ColI.additem ( btKill );
			
			panI[a] = colI;
			
			' as mentioned, items are sorted, so, the collapsable regions are at index 1 and 2
			Local panI0:TGadget = TCollapserItem(colI.getitem(1)).getClient();
			Local panI1:TGadget = TCollapserItem(colI.getitem(2)).getClient();
			' and the button is at index 0
			killMe[a] = colI.getitem(0);
			
		' fill regions with some buttons
			
			Local i:Int, j:Int;
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("button "+i+"-"+j,5+85*i,5+25*j,80,20,pan0, BUTTON_OK);
					b.SetLayout(1,0,1,0);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("radio "+i+"-"+j,5+85*i,5+25*j,80,20,pan1, BUTTON_RADIO);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("check "+i+"-"+j,5+85*i,5+25*j,80,20,panI0, BUTTON_CHECKBOX);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateLabel("label "+i+"-"+j,5+85*i,5+25*j,80,20,panI1, LABEL_CENTER);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			
		' add a button in the collapser (outside collapsable regions)
		Local button:TGadget = CreateButton("click", 5,320, 90, 20, col.getClient() );
				button.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
				
		col.AddItem(button);
	Next;
	
	Repeat
		
		WaitEvent()
		Select EventID()
			Case EVENT_WINDOWCLOSE
				Exit;
			Case EVENT_GADGETACTION
				SetStatusText (Win, "Hit a button '"+TGadget(EventSource()).GetText()+"' state='"+TGadget(EventSource()).State()+"'")
				For a = 0 To 1
					If killMe[a]&lt;&gt;Null
						If EventSource()=killMe[a]
							FreeGadget(panI[a])
							killMe[a] = Null;
							panI[a] = Null;
						EndIf;
					EndIf;
				Next;
			'	If EventSource() = panI1
			'		
			'	EndIf;
		End Select
		
	Forever
	
	End
	
End Function



TCollapserDemo()
</textarea> <br><br></td></tr></table><br>
<a name="1293521"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also, if possible, this requires a cross-platform test too.<br><br>It's a numeric only textfield with some features <br>+ buttons up/down with support for mouse wheel<br>+ a checkbox (visible or not) to enable exponential increase/decrease value<br>+ can work as an Integer textfield if TEXTFIELDK_INT is provided in the parameter<br>+ clamps the result if TEXTFIELDK_CLAMP is provided in the style parameter.<br>+ Page Up/page Down increase/Decrease stepper by 5<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import maxgui.drivers


'#region TextField K
Const TEXTFIELDK_INT:Int	=	512;
Const TEXTFIELDK_CLAMP:Int	=	1024;
Const TEXTFIELDK_EXPONENT:Int = 2048;

Type TTextFieldK Extends TProxyGadget
	
	Global _textFieldK_symbol_pixmap:TPixmap;
	
	Global _arrows_width:Int = 15;
	Global _arrows_height:Int = 19;
	
	Field core:TGadget;
	Field exponent:TGadget;
	Field textField:TGadget;
	Field arrows:TGadget;
	Field btUp:TGadget;
	Field btDn:TGadget;
	
	Field _style:Int;
	Field _autoExponentialIncrement:Byte = False;
	Field _autoExponentialIncrementValue:Float=0.1;
	Field _increment:Float;
	Field _value:Float;
	Field _valueI:Int;
	Field _valueMin:Float;
	Field _valueMax:Float;
	Field _nbDigits:Int;
	
	Function InTriangle2:Byte ( x0:Float,y0:Float, x1:Float,y1:Float, x2:Float,y2:Float, x3:Float,y3:Float )
		If ( (x2-x1) * (y3-y1) - (x3-x1) * (y2-y1) &gt; 0 )
			If ( ( (x2-x0) * (y3-y0) - (x3-x0) * (y2-y0) ) &lt; 0) Then Return False;
			If ( ( (x3-x0) * (y1-y0) - (x1-x0) * (y3-y0) ) &lt; 0) Then Return False;
			Return ( ( (x1-x0) * (y2-y0) - (x2-x0) * (y1-y0) ) &gt;= 0)
		EndIf;
		If ( ( ((x2-x0) * (y3-y0) - (x3-x0) * (y2-y0)) ) &gt; 0) Then Return False;
		If ( ( ((x3-x0) * (y1-y0) - (x1-x0) * (y3-y0)) ) &gt; 0) Then Return False;
		Return ( ( ((x1-x0) * (y2-y0) - (x2-x0) * (y1-y0)) ) &lt;= 0)
	End Function
	
	Function WritePixmapTriangle(pix:TPixmap, x0:Int,y0:Int,x1:Int,y1:Int,x2:Int,y2:Int, rgba:Int)
		Local l_w:Int = pix.width;
		Local l_h:Int = pix.Height;
		Local l_x:Int, l_y:Int
		For l_y = 0 Until l_h
			For l_x = 0 Until l_w
				If InTriangle2(l_x,l_y, x0,y0,x1,y1,x2,y2)
					pix.WritePixel(l_x,l_y, rgba);
				End If
			Next;
		Next;
	End Function
	
	Method Init:TTextFieldK(pX:Int,pY:Int,pW:Int,pH:Int,pGroup:TGadget,pStyle:Int=0)
		
		If _textFieldK_symbol_pixmap = Null
			
			Local pix_w:Int = _arrows_width;
			Local pix_h:Int = _arrows_height;
			
			Local pix:TPixmap=	CreatePixmap(pix_w,pix_h, PF_RGB888)
			pix.ClearPixels($FF707070);
			
			Local l_x0:Int = Floor(pix_w*0.5);
			Local l_x1:Int = 2;
			Local l_x2:Int = pix_w-3;
			
			Local l_ym:Int = Floor(pix_h*0.5);
			Local l_y0:Int = 2;
			Local l_y1:Int = l_ym-2;
			Local l_y2:Int = l_ym+2;
			Local l_y3:Int = pix_h-3;
			
			Local pix_i:Int
			For pix_i = 0 Until pix_w
				pix.WritePixel(pix_i,0,$FF010101);
				pix.WritePixel(pix_i,pix_h-1,$FF010101);
				pix.WritePixel(pix_i,l_ym   ,$FF010101);
			Next;
			
			WritePixmapTriangle(pix, l_x0, l_y0 , l_x1, l_y1 , l_x2, l_y1 ,$FF010101);
			WritePixmapTriangle(pix, l_x1, l_y2 , l_x2, l_y2 , l_x0, l_y3 ,$FF010101);
			For pix_i = 1 Until pix_h-1
				pix.WritePixel(0,pix_i,$FF010101);
				pix.WritePixel(pix_w-1,pix_i,$FF010101);
			Next;
			_textFieldK_symbol_pixmap = pix;
		EndIf;
		
		Self._value		=	0.0;
		Self._increment	=	1.0;
		Self._autoExponentialIncrement	=	False;
		Self._autoExponentialIncrementValue = 0.1;
		Self._nbDigits	=	12;
		
		pH = max(pH,_arrows_height);
		Self.core		=	CreatePanel						( pX,pY,pW, pH, pGroup, 0);
		Self._style		=	pStyle;
		
		Self.exponent=	CreateButton					( "", 2,2, 12, 16, Self.core, BUTTON_CHECKBOX );
		Self.exponent.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
		If ( (pStyle &amp; TEXTFIELDK_EXPONENT) &gt; 0 )
			Self.textField=	CreateTextField					( 16,0,pW-_arrows_width-1-16,pH, Self.core, pStyle);
		Else
			HideGadget(Self.exponent);
			Self.textField=	CreateTextField					( 0,0,pW-_arrows_width-1,pH, Self.core, pStyle);
		EndIf;
		
							Self.textField	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
		Self.arrows		=	CreatePanel						( pW-_arrows_width, 0, _arrows_width,_arrows_height, Self.core, PANEL_ACTIVE );
							
							Self.arrows		.SetLayout		( 0, EDGE_ALIGNED, EDGE_ALIGNED, 0 );
							Self.arrows		.SetPixmap		( _textFieldK_symbol_pixmap, PANELPIXMAP_CENTER );
							Self.arrows		.SetSensitivity	( SENSITIZE_ALL );
							Self.textField	.SetSensitivity ( SENSITIZE_ALL );
							
		SetGadgetFilter		( Self.textField	, TTextFieldK.filterNum, Self );
		
		AddHook				( EmitEventHook, hook, Self );
		
		Self.enableExpIncrement(Self._autoExponentialIncrement);
		
		Self.SetProxy		( Self.core );
		
		Return Self;
	End Method
	
	Method enableClamp:TTextFieldK(pEnable:Byte=True)
		If pEnable
			Self._style = Self._style | TEXTFIELDK_CLAMP;
		Else
			If ( (Self._style &amp; TEXTFIELDK_CLAMP) &gt; 0 )
				Self._style = Self._style - TEXTFIELDK_CLAMP;
			EndIf;
		EndIf;
		Return Self;
	End Method
	
	Method setClamp:TTextFieldK(pMinValue:Float, pMaxValue:Float, pEnableClamp:Int=-1)
		Self._valueMin = min(pMinValue, pMaxValue);
		Self._valueMax = max(pMinValue, pMaxValue);
		If (pEnableClamp=1)
			Self.enableClamp(True);
		ElseIf (pEnableClamp=0)
			Self.enableClamp(False);
		EndIf;
		Return Self;
	End Method
	
	Method enableExpIncrement:TTextFieldK(pEnable:Byte=True)
		Self._autoExponentialIncrement = pEnable;
		If (Self.exponent&lt;&gt;Null) Then SetButtonState(Self.exponent, pEnable);
		Return Self;
	End Method
	
	Method setExpIncrement:TTextFieldK(pIncrement:Float)
		Self._autoExponentialIncrementValue = pIncrement;
		Return Self;
	End Method
	
	Function setTextFormatFloat:String(f:Float, pDigits:Int)
		Local l_sgn:String="" ; If (f&lt;0) Then  l_sgn="-"; f = Abs(f);
		Local v:String = String.FromFloat(f);
		Local locate:Int = Instr(v, "e",1);
		If locate
			Local locateDot:Int = Instr(v,".")
			Local pow:Int = Right(v, v.length-locate).ToInt()
			Local num:String;
			If locateDot
				num = Left(v,locateDot-1)
				num :+ Mid(v, locateDot+1, locate-locateDot-1);
			Else
				num = Left(v,locate-1)
			EndIf;
			Local val:String = "0."+RSet( num, Abs(pow)+num.length-1 ).Replace(" ","0");
			v = l_sgn+val;
		Else
			v = l_sgn+v;
		EndIf
		If v.length&gt;pDigits
			Local v2:String = Left(v,pDigits); If Abs(v2.ToFloat()-v.ToFloat())&lt;0.1 Then Return v2;
		EndIf;
		Return v;
	End Function
	
	Method setDigits:TTextFieldK(pDigits:Int)
		Self._nbDigits = pDigits;
		Self.SetValue(Self._value);
		Return Self;
	End Method
	
	Method getDigits:Int()
		Return Self._nbDigits;
	End Method
	
	Method Increment:TTextFieldK(pValue:Int)
		
		If ( pValue = 0 ) Then Return Self;
		
		Self._checkNumString();
		
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			
			Local inc:Int = max(Self._increment,1);
			pValue :* inc;
			
			If Self._autoExponentialIncrement
				
				If Self._valueI = 0
					
					Self.SetValueI( pValue );
					
				Else
					
					If ( pValue&gt;0 )
						
						' increment Up -&gt; increment |Self._valueI|
						If ( Self._valueI &gt; 10 )
							Self.SetValueI( Self._valueI * (1 + Self._autoExponentialIncrementValue * pValue) );
						ElseIf ( Self._valueI&gt;-10 )
							Self.SetValueI( Self._valueI + pValue );
						Else
							Self.SetValueI( Self._valueI / (1 + Self._autoExponentialIncrementValue * pValue) );
						EndIf;
						
					Else
						' increment Down -&gt; Decrement |self._valueI|
						If ( Self._valueI &gt; 10 )
							Self.SetValueI( Self._valueI / (1 + Self._autoExponentialIncrementValue * Abs(pValue)) );
						ElseIf ( Self._valueI&gt;-10 )
							Self.SetValueI( Self._valueI + pValue );
						Else
							Self.SetValueI( Self._valueI * (1 + Self._autoExponentialIncrementValue * Abs(pValue)) );
						EndIf;

					EndIf;
					
				EndIf;
			Else
				
				Self.SetValueI( Self._valueI + pValue );
				
			EndIf;
			
		Else
			
			If Self._autoExponentialIncrement
				If pValue&gt;0
					Self.SetValue(Self._value * (1 + (Self._autoExponentialIncrementValue * pValue)) );
				Else
					Self.SetValue(Self._value / (1 + (Self._autoExponentialIncrementValue * Abs(pValue) )) );
				EndIf;
			Else
				Self.SetValue(Self._value + pValue);
			EndIf;
			
		EndIf;
		
		Return Self;
		
	End Method
	
	Method SetValueI:TTextFieldK(pValue:Int)
		
		If ( (Self._style &amp; TEXTFIELDK_CLAMP) &gt; 0 )
			If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
				pValue = min(max(pValue, Self._valueMin),Self._valueMax);
			Else
				pValue = min(max(pValue, Self._valueMin),Self._valueMax);
			EndIf;
		EndIf
		
		Self._checkNumString();
		
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			Self._valueI = pValue;
			Self.textField.SetText(Self._valueI);
		Else
			Self._value = pValue;
			'If Self._autoExponentialIncrement Then Self._increment = Abs(Self._value)*Self._autoExponentialIncrementValue;
			Self.textField.SetText(setTextFormatFloat(Self._value,Self._nbDigits));
		EndIf;
		
		Self._checkNumString();
		
		Return Self;
		
	End Method
	
	Method SetValue (pValue:Float)
		
		If ( (Self._style &amp; TEXTFIELDK_CLAMP) &gt; 0 )
			If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
				pValue = min(max(pValue, Self._valueMin),Self._valueMax);
			Else
				pValue = min(max(pValue, Self._valueMin),Self._valueMax);
			EndIf;
		EndIf
		
		Self._checkNumString();
		
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			Self._valueI = pValue;
			Self.textField.SetText(Self._valueI);
		Else
			Self._value = pValue;
			'If Self._autoExponentialIncrement Then Self._increment = Abs(Self._value)*Self._autoExponentialIncrementValue;
			Self.textField.SetText(setTextFormatFloat(Self._value,Self._nbDigits));
		EndIf;
		
		Self._checkNumString();
		
	End Method
	
	Method _readValue()
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			Self._valueI = Self.textField.GetText().ToInt();
			If ( (Self._style &amp; TEXTFIELDK_CLAMP) &gt; 0 )
				Local l_valI:Int = Self._valueI;
				Self._valueI = min(max(l_valI, Self._valueMin),Self._valueMax);
				If l_valI&lt;&gt;Self._valueI Then Self.textField.SetText(String.FromInt(Self._valueI));
			EndIf;
		Else
			Self._value = Self.textField.GetText().ToFloat();
			If ( (Self._style &amp; TEXTFIELDK_CLAMP) &gt; 0 )
				Local l_valF:Float = Self._value;
				Self._value = min(max(l_valF, Self._valueMin),Self._valueMax);
				If Abs(l_valF-Self._value)&gt;0.0001 Then Self.textField.SetText(String.FromFloat(Self._value)); Self._checkNumString()
			EndIf;
		EndIf
	End Method
	
	Method GetValue:Float()
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			Return Self._valueI;
		Else
			Return Self._value;
		EndIf;
	End Method
	
	Method GetValueI:Int()
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			Return Self._valueI;
		Else
			Return Self._value;
		EndIf;
	End Method
	
	Method SetLayout( lft:Int, rht:Int, top:Int, bot:Int )
		Self.core.SetLayout(lft,rht,top,bot);
	End Method
	
	Method _checkNumString()
		Local l_s:String = Self.textField.GetText();
		Local l_Len:Int = l_s.length;
		Local c:Int;
		Local out:String="";
		Local countDots:Int = 0; If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 ) Then countDots=1;
		For c = 0 Until l_Len
			Select l_s[c]
				Case "-"[0],"+"[0]
					If c=0
						out :+ Chr(l_s[c]);
					EndIf;
				Case "."[0]
					If countDots=0
						out :+ Chr(l_s[c]);
						countDots :+ 1;
					EndIf;
				Case "0"[0],"1"[0],"2"[0],"3"[0],"4"[0],"5"[0],"6"[0],"7"[0],"8"[0],"9"[0]
					out :+ Chr(l_s[c]);
				Default
			End Select
		Next;
		
		If out&lt;&gt;l_s Then Self.textField.SetText(out);
		
		Self._readValue();
		
	End Method
	
	Method postEv(pX:Int, pY:Int)
		Self._readValue();
		If ( (Self._style &amp; TEXTFIELDK_INT) &gt; 0 )
			EmitEvent ( CreateEvent ( EVENT_GADGETACTION, Self, KEY_ENTER,0, pX,pY, String.FromInt(Self._value) ) );
		Else
			EmitEvent ( CreateEvent ( EVENT_GADGETACTION, Self, KEY_ENTER,0, pX,pY, String.FromFloat(Self._value) ) );
		EndIf
	End Method
	
	Method GetText:String()
		Return String.FromFloat(Self.GetValue());
	End Method
	
	Method SetText(text:String)
		Self.SetValue(text.ToFloat());
	End Method
	
	Global last_ev_y:Int=0;
	Function hook:Object (id:Int,data:Object,context:Object)
		
		Local ev:TEvent = TEvent(data);
		If ev = Null Then Return data;
		
		Local tf:TTextFieldK = TTextFieldK(context);
		If (tf&lt;&gt;Null)
			
			If ev.id=EVENT_MOUSEENTER
				Select ev.source
					Case tf.arrows
						Select ActiveGadget()
							Case tf.textfield, tf.exponent
								ActivateGadget(tf.arrows)
								Return Null;
						End Select
					Case tf.textfield
						Select ActiveGadget()
							Case tf.arrows, tf.exponent
								ActivateGadget(tf.textfield)
								Return Null;
						End Select
				End Select
				Return data;
			EndIf;
			
			Select ev.source
				
				Case tf.arrows
					
					Select ev.id
						
						Case EVENT_MOUSEDOWN
							If ev.data=1
								tf.Increment( 1 - 2 * (ev.y&gt;_arrows_height/2) );
								tf.postEv(ev.x,ev.y);
							EndIf;
							
						Case EVENT_MOUSEWHEEL
							tf.Increment( ev.data );
							tf.postEv(ev.x,ev.y);
							
						Case EVENT_KEYDOWN
							Select ev.data
								Case KEY_UP		; tf.Increment( +1 ); tf.postEv(ev.x,ev.y);
								Case KEY_DOWN	; tf.Increment( -1 ); tf.postEv(ev.x,ev.y);
								Case KEY_PAGEUP	; tf.Increment( +5 ); tf.postEv(ev.x,ev.y);
								Case KEY_PAGEDOWN;tf.Increment( -5 ); tf.postEv(ev.x,ev.y);
							End Select
					End Select
					
					Return Null;
					
				Case tf.exponent
					If ev.id=EVENT_GADGETACTION
						tf.enableExpIncrement(ButtonState(tf.exponent));
					EndIf;
					Return Null;
					
				Case tf.textField
					
					Select ev.id
						
						Case EVENT_KEYCHAR
							Select ev.data
								Case KEY_0,KEY_1,KEY_2,KEY_3,KEY_4,KEY_5,KEY_6,KEY_7,KEY_8,KEY_9,"."[0], KEY_BACKSPACE
									Return data;
								Default
									Return Null;
							End Select;
							
						Case EVENT_GADGETLOSTFOCUS
							
							tf._checkNumString();
							tf.postEv(ev.x,ev.y);
							
						Case EVENT_GADGETACTION
							
							tf._checkNumString();
							
					End Select;
					
					Return Null;
					
			End Select;
			
		EndIf;
		
		Return data;
		
	End Function
	
	Function filterNum:Int(event:TEvent, context:Object)
		
		Local tf:TTextFieldK = TTextFieldK(context); If (tf = Null) Then Return 1;
		If (event.source &lt;&gt; tf.textField) Then Return 1;
		
		Select event.id
			
			Case EVENT_KEYCHAR
				
				If (tf.Style  &amp; TEXTFIELDK_INT)
					Select event.data
						Case "-"[0], "+"[0], KEY_0,KEY_1,KEY_2,KEY_3,KEY_4,KEY_5,KEY_6,KEY_7,KEY_8,KEY_9, KEY_BACKSPACE
						'	tf._checkNumString();
							Return 1;
					End Select
				Else
					Select event.data
						Case "-"[0], "+"[0], KEY_0,KEY_1,KEY_2,KEY_3,KEY_4,KEY_5,KEY_6,KEY_7,KEY_8,KEY_9,"."[0], KEY_BACKSPACE
						'	tf._checkNumString();
							Return 1;
					End Select
				EndIf
				
				Return 0;
				
			Case EVENT_KEYDOWN
				
				Select event.data
					Case KEY_UP		; tf.Increment( +1 ); Return 0;
					Case KEY_DOWN	; tf.Increment( -1 ); Return 0;
					Case KEY_PAGEUP	; tf.Increment( +5 ); Return 0;
					Case KEY_PAGEDOWN;tf.Increment( -5 ); Return 0;
				End Select;
				Return 1;
				
			Case EVENT_GADGETACTION
				
				tf._checkNumString();
				Return 1;
				
			Case EVENT_GADGETLOSTFOCUS
				
				tf._checkNumString();
				Return 1;
				
		End Select
		
		Return 1;
		
	End Function
	
End Type

Function CreateTextFieldK:TTextFieldK(pX:Int,pY:Int,pW:Int,pH:Int,pGroup:TGadget=Null,pStyle:Int=0)
	Return New TTextFieldK.Init(pX,pY,pW,pH,pGroup,pStyle);
End Function
'#end region




Local Win:TGadget = CreateWindow("window", 10,10,400,200,, WINDOW_TITLEBAR | WINDOW_RESIZABLE | WINDOW_CLIENTCOORDS | WINDOW_CENTER );
Local backpan:TGadget = CreatePanel(0,0,ClientWidth(Win), ClientHeight(Win), Win);
					backpan.SetLayout(EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
					backpan.SetColor($10,$10,$10);
					
Local txt1:TTextFieldK=CreateTextFieldK(10,10,100,20, backpan, TEXTFIELDK_EXPONENT | TEXTFIELDK_INT | TEXTFIELDK_CLAMP);
					txt1.SetLayout(EDGE_ALIGNED, 0, EDGE_ALIGNED, 0 )
					txt1.SetColor($50,$50,$50);
					txt1.setClamp(1,255);
					
Local txt2:TTextFieldK=CreateTextFieldK(120,10,130,20, backpan, TEXTFIELDK_EXPONENT | TEXTFIELDK_CLAMP);
					txt2.SetLayout(EDGE_ALIGNED, 0, EDGE_ALIGNED, 0 )
					txt2.SetColor($50,$50,$50);
					txt2.setClamp(-50,50000);
					
Local txt3:TTextFieldK=CreateTextFieldK(260,10,130,20, backpan);
					txt3.SetLayout(EDGE_ALIGNED, 0, EDGE_ALIGNED, 0 )
					txt3.SetColor($50,$50,$50);
					
Repeat
	
	While PollEvent()
		Select EventID()
			Case EVENT_WINDOWCLOSE
				End
			Case EVENT_GADGETACTION
				Select EventSource()
					Case txt1, txt2, txt3
						Print "data="+EventData()
						Print CurrentEvent.ToString()
			End Select
		End Select
	Wend
	
Forever
</textarea> <br><br></td></tr></table><br>
<a name="1293586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't find any issues with either program on MacOS. Both layout and operation seem to work well. <br><br></td></tr></table><br>
<a name="1293589"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for testing !<br><br>I hope the 3D engine will work perfectly cross-platform too :) <br><br></td></tr></table><br>
<a name="1293590"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Same here, Windows and MacOS works perfectly. No problems what I can see.<br>Love those 3DMax like boxes. <br><br></td></tr></table><br>
<a name="1293600"></a>

<a name="1293602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> update for the collapser gadget<br>-&gt; add an automatic scroll bar if the height doesn't fit the kids.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import maxgui.drivers


Const COLLAPSEITEM_RIGHT:Int	=	8192

Type TCollapserItem Extends TProxyGadget
	
	Field core:TGadget;
		Field bt:TGadget;
		Field title:TGadget;
		Field realheight:Int;
	Field client:TGadget;
	
	Field _style:Int;
	Field title_height:Int;
	Field _pix:TPixmap[];
	Field _state:Byte;
	Field _on:Byte;
	
	'#region private (internal) stuff
	Method CleanUp :Int ()
		If Self.getCollapser()&lt;&gt;Null Then Self.getCollapser().RemoveGadget(Self);
		Return Self.proxy.CleanUp();
	End Method
	
	' update the pixmap icon of the top button
	Method updatePixmap()
		Self.bt		.SetPixmap		( Self._pix[Self._on*2+Self._state], PANELPIXMAP_STRETCH );
	End Method
	
	' when mouse enter the button
	Method onEnter()
		Self._on = 1;
		Self.updatePixmap	( );
	End Method
	
	' when mouse leave the button
	Method onLeave()
		Self._on = 0;
		Self.updatePixmap	( );
	End Method
	
	Method updateShape()
		If Self._state
			Self.core.SetShape(Self.xpos,Self.ypos,Self.width,Self.realheight);
			Self.client.SetShape(1,Self.title_height,Self.width-2,Self.realheight-Self.title_height-1);
			Self.client.SetShow(True);
		Else
			Self.core.SetShape(Self.xpos,Self.ypos,Self.width,Self.title_height);
			Self.client.SetShape(1,Self.title_height,Self.width-2,Self.realheight-Self.title_height-1);
			Self.client.SetShow(False);
		EndIf;
		If ( (Self._style &amp; COLLAPSEITEM_RIGHT) &gt; 0 )
			' title is left / button is right
			Self.title	.SetShape	( 1, 1, Self.width-Self.title_height-1, Self.title_height-2 );
			Self.bt		.SetShape	( Self.width-Self.title_height+1, 1, Self.title_height-2, Self.title_height-2 );
		Else
			' default : button is left
			Self.bt		.SetShape	( 1,1,Self.title_height-2,Self.title_height-2 );
			Self.title	.SetShape	( Self.title_height, 1, Self.width-Self.title_height-1, Self.title_height-2 );
		EndIf
	End Method
	'#end region
	
	'#region create
	Method Create:TCollapserItem ( pTitle:String, pX:Int, pY:Int, pW:Int,pH:Int, pCollapser:TCollapser, pStyle:Int=0)
		
		' only add items to a Collapser gadget !
			If pCollapser = Null Then Return Null;
			Self.title_height=	Int(Floor(pCollapser.title_height*0.5))*2+1;
			Self.realheight	=	pH;
			
			Self._state		=	True;
			Self._style		=	pStyle;
			Self.parent		=	pCollapser;
			Self._on		=	0;
			
		' generate pixmaps
			Local l_th:Int	=	Self.title_height;
			Local pix_h:Int	=	(l_th-2);
			Self._pix		=	[	CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888)];
									
				Self._pix[0]		.ClearPixels($808080);
				Self._pix[1]		.ClearPixels($808080);
				Self._pix[2]		.ClearPixels($A0A0A0);
				Self._pix[3]		.ClearPixels($A0A0A0);
				
				Local pix_x:Int;
				Local pix_m:Int = Floor(pix_h*0.5);
				For pix_x = 3 Until pix_h-3
					Self._pix[0].WritePixel(pix_x, pix_m, $010101);
					Self._pix[0].WritePixel(pix_m, pix_x, $010101);
					Self._pix[1].WritePixel(pix_x, pix_m, $010101);
					Self._pix[2].WritePixel(pix_x, pix_m, $010101);
					Self._pix[2].WritePixel(pix_m, pix_x, $010101);
					Self._pix[3].WritePixel(pix_x, pix_m, $010101);
				Next
				
		' title panel
			Self.core	=	CreatePanel		( pX,pY,pW,ph, pCollapser.getClient(), pStyle );
				Self.core	.SetColor		( $01,$01,$01 );
				Self.core	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, 0 );
				
		' button + title
			If ( (pStyle &amp; COLLAPSEITEM_RIGHT) &gt; 0 )
				' title is left / button is right
				Self.title=	CreateLabel		( " "+pTitle+" ", 1, 1, pw-l_th-1, l_th-2, Self.core, pStyle );
				Self.bt	=	CreatePanel		( pw-l_th+1, 1, l_th-2, l_th-2, Self.core, PANEL_ACTIVE );
				Self.bt		.SetLayout		( 0, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
			Else
				' default : button is left
				Self.bt	=	CreatePanel		( 1,1,l_th-2,l_th-2, Self.core, PANEL_ACTIVE );
				Self.bt		.SetLayout		( EDGE_ALIGNED, 0, EDGE_ALIGNED, EDGE_ALIGNED );
				Self.title=	CreateLabel		( " "+pTitle+" ", l_th, 1, pw-l_th-1, l_th-2, Self.core, pStyle );
			EndIf
				Self.bt		.SetColor		( $80,$80,$80 );
				Self.title	.SetColor		( $60,$60,$60 );
				Self.title	.SetTextColor	( $FF,$80,$20 );
				Self.title	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
				
				Self		.updatePixmap	( );
				Self.bt.extra = Self;
				
		' client panel
			Self.client	=	CreatePanel		( 1, l_th, pw-2, ph-l_th-1, Self.core );
				Self.client	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
				Self.client	.SetColor		( $40,$40,$40 );
				
		' set proxy
			Self.proxy	=	Self.core;
			
		' Update layout (by Default : stick Left And Right)
			' we align on top, not bottom, but whatever we set, top and bottom will be forced after collapser update
			' ( and collapser update is called by addItem, so it's updated immediatly after setlayout. )
			Self.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,0);
			
			pCollapser.addItem(Self);
			
		Return Self;
		
	End Method
	'#end region
	
	'#region text
	' text is sent to the title gadget
	Method SetText(text:String)
		Self.title.SetText(text);
	End Method
	
	Method GetText:String()
		Return Self.title.GetText();
	End Method
	'#end region
	
	'#region fold/unfold
	' returns true if gadget is expanded else returns false.
	Method State:Int()
		Return Self._state;
	End Method
	
	' alternates the collapsed/expanded state relatives to the previous state
	Method SwitchState()
		Self.setState(Not(Self._state));
	End Method
	
	' collapse (0) or expand (1) the gadget
	Method SetState(bool:Byte)
		If bool
			Self.Expand();
		Else
			Self.Collapse();
		EndIf
	End Method
	
	' collapse the gadget
	Method Collapse()
		If ( Self._state = False )	Then Return;
		Self._state				=	0;
		Self						.updatePixmap	( )
		Self						.updateShape	( );
		Self.getCollapser()			.Update			( );
		EmitEvent					( CreateEvent	( EVENT_GADGETACTION, Self, 0 ) );
	End Method
	
	' expand the gadget
	Method Expand()
		If ( Self._state = True )	Then Return;
		Self._state				=	1;
		Self						.updatePixmap	( );
		Self						.updateShape	( );
		Self.getCollapser()			.Update			( );
		EmitEvent					( CreateEvent	( EVENT_GADGETACTION, Self, 1 ) );
	End Method
	
	' fold the gadget (alias for collapse)
	Method fold()
		Self.Collapse();
	End Method
	
	' unfold the gadget (alias for expand)
	Method unfold()
		Self.Expand();
	End Method
	'#end region
	
	'#region shape
	' returns the real Height the item is supposed To be (Not the collapsed Height)
	Method GetHeight:Int()
		Return Self.realheight;
	End Method
	
	' the client gadget.
	Method getClient:TGadget()
		Return Self.client;
	End Method
	
	' client size
	Method ClientWidth:Int()
		Return Self.client.ClientWidth()
	End Method
	
	Method ClientHeight:Int()
		Return Self.client.ClientHeight()
	End Method
	
	Method SetShape(pX:Int,pY:Int,pW:Int,pH:Int)
		' copy shape pos and size
		Self.xpos = px;
		Self.ypos = py;
		Self.width = pw;
		Self.Height = ph;
		Self.realheight = ph; ' get real size of the gadget (whatever it is collapsed or not)
		
		' the core gadget is updated after this
		Self.updateShape();
	End Method
	
	Method SetLayout( lft:Int,rht:Int,top:Int,bot:Int )
		Self.proxy.SetLayout(lft,rht,top,bot);
		' copy core layout to self
		Self.lockl = Self.proxy.lockl;
		Self.lockr = Self.proxy.lockr;
		Self.lockt = Self.proxy.lockt;
		Self.lockb = Self.proxy.lockb;
		Self.lockx = Self.proxy.lockx;
		Self.locky = Self.proxy.locky;
		Self.lockw = Self.proxy.lockw;
		Self.lockh = Self.proxy.lockh;
		Self.lockcw = Self.proxy.lockcw;
		Self.lockch = Self.proxy.lockch;
	End Method
	'#end region
	
	
	' the Collapser object that owns this item
	Method getCollapser:TCollapser()
		Return TCollapser(Self.parent);
	End Method
	
	Function gadgetCollapserItem:TCollapserItem(gad:TGadget)
		If gad=Null Then Return Null;
		If gad.GetGroup() = Null Then Return Null; ' button.parent = core
		Return TCollapserItem(gad.extra);
	End Function
	
End Type


Const COLLAPSER_AUTORESIZE:Int	=	512;	' set collapser client height to match kids
Const COLLAPSER_AUTOSCROLL:Int	=	1024;	' add scrollbar if required

Type TCollapser Extends TProxyGadget
	
	Global collapsedTime:Int;
	
	Field title_height:Int;
	Field scroll_size:Int;
	Field client:TGadget;
	
	' TODO &gt; add sliders to scroll client gadgets
		Field scrollbarX:TGadget;
		Field scrollbarY:TGadget;
	
	Field paddingy:Int;
	
	Field items:TList;
	
	Method Create:TCollapser(pX:Int, pY:Int, pW:Int, pH:Int, pGroup:TGadget, pStyle:Int)
		
		collapsedTime = MilliSecs()-101;
		
		Self.items		=	New TList;
		
		Self.title_height=	17;
		Self.scroll_size=	12;
		Self.paddingy	=	5;
		
		Self.SetProxy		( CreatePanel(pX,pY,pW,pH,pGroup,pStyle) );
		
		' not implemented yet
		Self.scrollbarY	=	CreateSlider	( pw-Self.scroll_size,0,Self.scroll_size,ph, Self.proxy, SLIDER_VERTICAL );
		Self.scrollbarY		.SetLayout		( 0,EDGE_ALIGNED, EDGE_ALIGNED,EDGE_ALIGNED );
		Self.scrollbarY		.SetShow		( False );
		
		Self.scrollbarX	=	CreateSlider	( 0,ph-Self.scroll_size,pw-Self.scroll_size,Self.scroll_size, Self.proxy, SLIDER_VERTICAL );
		Self.scrollbarX		.SetLayout		( EDGE_ALIGNED,EDGE_ALIGNED, 0,EDGE_ALIGNED );
		Self.scrollbarX		.SetShow		( False );
		
		Self.client		=	CreatePanel		( Self.scroll_size/2,Self.title_height,pw-Self.scroll_size,ph, Self.proxy );
		Self.client			.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED, EDGE_ALIGNED,EDGE_ALIGNED);
		
		AddHook				( EmitEventHook, EventHook, Self );
		
		Return Self;
		
	End Method
	
	Method Rethink()
		Self.Update();
		Super.Rethink();
	End Method
	
	Function EventHook:Object(id:Int, data:Object, context:Object)
		If TEvent(data) = Null Then Return data;
		Local ev:TEvent = TEvent(data);
		
		Local col:TCollapser
		Local itm:TCollapserItem;
		
		Select ev.id
			
			Case EVENT_WINDOWSIZE
				
				col = TCollapser(context); If col&lt;&gt;Null Then col.Rethink();
				Return data;
				
			Case EVENT_MOUSEENTER
				
				If TGadget(ev.source)&lt;&gt;Null
					itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
					If (itm&lt;&gt;Null) Then If itm.getCollapser()=context Then itm.onEnter(); Return data;
				EndIf;
				Return data;
				
			Case EVENT_MOUSELEAVE
				
				If TGadget(ev.source)&lt;&gt;Null
					itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
					If (itm&lt;&gt;Null) Then If itm.getCollapser()=context Then itm.onLeave(); Return data;
				EndIf;
				Return data;
				
			Case EVENT_MOUSEUP
				
				If (ev.data = 1)
					If TGadget(ev.source)&lt;&gt;Null
						itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
						If (itm&lt;&gt;Null)
							If (itm.getCollapser()=context)
								If (ev.x&gt;=0 And ev.x&lt;itm.bt.GetWidth())
									If (ev.y&gt;=0 And ev.y&lt;itm.bt.GetHeight())
										If Abs(MilliSecs()-TCollapser.collapsedTime)&gt;100
											itm.SwitchState();
											TCollapser.collapsedTime = MilliSecs();
										EndIf;
									EndIf;
								EndIf;
								Return Null;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
				
			Case EVENT_GADGETACTION
				If TCollapser(context)&lt;&gt;Null
					col = TCollapser(context);
					If ( ev.source = col.scrollbarY )
						col.client.SetShape(0,-SliderValue(col.scrollbarY), col.proxy.width-col.scroll_size, col.client.Height);
					EndIf;
				EndIf;
				
		End Select;
		Return data;
	End Function
	
	Method CleanUp :Int ()
		Self.proxy.CleanUp();
		RemoveHook(EmitEventHook, EventHook, Null);
		Return Super.CleanUp();
	End Method
	
	Method AddItem(item:TGadget)
		' Always layout stuff with &lt;ALIGN TOP&gt; and &lt;NOT ALIGNED BOTTOM&gt; !
		item.SetLayout(item.lockl,item.lockr, EDGE_ALIGNED,0);
		Self.items.AddLast(item);
		Self.Update();
	End Method
	
	Method RemoveItem(index:Int)
		If index&lt;0 Or index&gt;=Self.items.Count() Then Return;
		Self.items.Remove(Self.items.ValueAtIndex(index));
		Self.Update();
	End Method
	
	Method RemoveGadget:Int(gad:TGadget)
		Self.items.Remove(gad);
		Self.Update();
	End Method
	
	Method GetItem:TGadget(index:Int)
		Return TGadget(Self.items.ValueAtIndex(index));
	End Method
	
	Method GetClient:TGadget()
		Return Self.client;
	End Method
	
	Method ClientWidth:Int()
		Return Self.client.ClientWidth();
	End Method
	
	Method ClientHeight:Int()
		Return Self.client.ClientHeight();
	End Method
	
	Method Update()
		
		' resize/repos clients
		Self.items.Sort(True, compareGadgetY)
		Local item:TGadget;
		Local posy:Int = Self.paddingy;
		Local gadh:Int = 0;
		
		For item = EachIn Self.items
			If ( TCollapserItem(item)&lt;&gt;Null )
				If TCollapserItem(item)._state
					gadh = TCollapserItem(item).GetHeight();
				Else
					gadh = TCollapserItem(item).title_height;
				EndIf;
			Else
				gadh = item.GetHeight();
			EndIf;
			item.SetShape ( item.GetXPos(), posy, item.GetWidth(), item.GetHeight() );
			posy :+ gadh + Self.paddingy;
		Next;
		
		gadh = posy;
		Local clh:Int = Self.proxy.Height-Self.title_height;
		
		If ( gadh &gt; clh )
			Self.scrollbarY.SetShow(True)
			Self.client.SetShape(0,Self.title_height,Self.proxy.width-Self.scroll_size, gadh);
			Self.scrollbarY.SetRange(0,gadh-clh);
		Else
			Self.scrollbarY.SetShow(False);
			Self.client.SetShape(Self.scroll_size/2,Self.title_height,Self.proxy.width-Self.scroll_size, clh);
		'	Self.client.SetShape(0,Self.title_height,Self.client.width, gadh);
		EndIf;
		
		RedrawGadget Self;
		
	End Method
	
	Function compareGadgetY:Int(o1:Object, o2:Object)
		Return -1+2*(TGadget(o1).GetYPos()&gt;TGadget(o2).GetYPos());
	End Function
	
End Type


Function CreateCollapser:TCollapser ( pX:Int, pY:Int, pW:Int,pH:Int, pGroup:TGadget, pStyle:Int=0 )
	Return New TCollapser.Create(pX,pY,pW,pH,pGroup,pStyle);
End Function
Function CreateCollapsable:TGadget ( pTitle:String, pX:Int, pY:Int, pW:Int, pH:Int, pCollapser:TGadget, pStyle:Int=0 )
	If TCollapser(pCollapser)=Null Then Return Null;
	Return New TCollapserItem.Create(pTitle, pX,pY,pW,pH, TCollapser(pCollapser), pStyle);
End Function
Function CollapserItem:TGadget(pCollapser:TGadget, index:Int)
	If TCollapser(pCollapser) = Null Then Return Null;
	Return TCollapser(pCollapser).GetItem(index);
End Function

Function CollapserAddItem(pCollapser:TGadget, item:TGadget)
	If TCollapser(pCollapser) = Null Then Return;
	TCollapser(pCollapser).AddItem(item);
End Function








Function TCollapserDemo()
	
	Local Win:TGadget = CreateWindow("window", 10,10,800,600,, WINDOW_TITLEBAR | WINDOW_CLIENTCOORDS | WINDOW_CENTER | WINDOW_RESIZABLE | WINDOW_STATUS );
	SetMinWindowSize(Win, 640,400)
	
	Local body:TGadget[2]
	Local a:Int;
	Local panI:TGadget[2];
	Local killMe:TGadget[2];
	For a = 0 To 1
		
		body[a] = CreatePanel(a*ClientWidth(Win)/2+5,5,ClientWidth(Win)/2-10, ClientHeight(Win)-10,Win)
		body[a].SetColor($90,$90,$90);
		If a=0
			body[a].SetLayout(EDGE_ALIGNED,EDGE_RELATIVE,EDGE_ALIGNED,EDGE_ALIGNED);
		Else
			body[a].SetLayout(EDGE_RELATIVE,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
		EndIf;
		
		' create a collapser
			Local col:TCollapser = CreateCollapser( 5,5, ClientWidth(body[a])-10, ClientHeight(body[a])-10, body[a] );
			col.SetColor($20,$20,$20);
			col.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
			
		' create collapsable region in the collapser
			CreateCollapsable	( "Buttons"				, 005,005,ClientWidth(col)-10, 100, col );
			CreateCollapsable	( "Radio Buttons"		, 005,110,ClientWidth(col)-10, 100, col );
			CreateCollapsable	( "it's really tight"	, 005,215,ClientWidth(col)-10, 200, col );
			
		' get collapsables from collapser
			Local pan0:TGadget = TCollapserItem(col.getitem(0)).getClient(); ' &gt; Add stuff to the client !
			Local pan1:TGadget = TCollapserItem(col.getitem(1)).getClient();
			Local pan2:TGadget = TCollapserItem(col.getitem(2)).getClient();
			Local colI:TCollapser = CreateCollapser( 5,5,ClientWidth(pan2)-10, ClientHeight(pan2)-10, pan2 );
				colI.SetColor($30,$30,$30);
				colI.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
				' you can use "Y" position at the creation to specify order of gadgets.
				' gadgets, when collapser updates, are sorted by their "Y" position.
				' for example, here the "btKill" is created on top of the two regions.
			CreateCollapsable("let me get out i'm locked :'(", 5, 1,ClientWidth(colI)-10, 100, colI);
			CreateCollapsable("speak for you bro ...", 5, 2,ClientWidth(colI)-10, 100, colI);
			Local btKill:TGadget = CreateButton("Kill Me Please", 5, 0, 100,20, colI.GetClient() );
				btKill.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
			ColI.additem ( btKill );
			
			panI[a] = colI;
			
			' as mentioned, items are sorted, so, the collapsable regions are at index 1 and 2
			Local panI0:TGadget = TCollapserItem(colI.getitem(1)).getClient();
			Local panI1:TGadget = TCollapserItem(colI.getitem(2)).getClient();
			' and the button is at index 0
			killMe[a] = colI.getitem(0);
			
		' fill regions with some buttons
			
			Local i:Int, j:Int;
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("button "+i+"-"+j,5+85*i,5+25*j,80,20,pan0, BUTTON_OK);
					b.SetLayout(1,0,1,0);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("radio "+i+"-"+j,5+85*i,5+25*j,80,20,pan1, BUTTON_RADIO);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("check "+i+"-"+j,5+85*i,5+25*j,80,20,panI0, BUTTON_CHECKBOX);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateLabel("label "+i+"-"+j,5+85*i,5+25*j,80,20,panI1, LABEL_CENTER);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			
		' add a button in the collapser (outside collapsable regions)
		Local button:TGadget = CreateButton("click", 5,320, 90, 20, col.getClient() );
				button.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
				
		col.AddItem(button);
	Next;
	
	Repeat
		
		WaitEvent()
		Select EventID()
			Case EVENT_WINDOWCLOSE
				Exit;
			Case EVENT_GADGETACTION
				SetStatusText (Win, "Hit a button '"+TGadget(EventSource()).GetText()+"' state='"+TGadget(EventSource()).State()+"'")
				For a = 0 To 1
					If killMe[a]&lt;&gt;Null
						If EventSource()=killMe[a]
							FreeGadget(panI[a])
							killMe[a] = Null;
							panI[a] = Null;
						EndIf;
					EndIf;
				Next;
			'	If EventSource() = panI1
			'		
			'	EndIf;
		End Select
		
	Forever
	
	End
	
End Function



TCollapserDemo()
</textarea> <br><br></td></tr></table><br>
<a name="1293603"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> On my linux box the buttons are a bit "too small" (top of the label is truncated)<br><img src="https://abload.de/img/gtk_collapser7quf8.png"><br><br>The box itself seems to work at intended.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm still here so I thought I'll help out checking Mac's<br>Looking good but the scrollbars gets offset.<br><br><img src="http://s29.postimg.org/bm8dzacef/screen.png"> <br><br></td></tr></table><br>
<a name="1293606"></a>

<a name="1293607"></a>

<a name="1293609"></a>

<a name="1293610"></a>

<a name="1293611"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Derron : The buttons are just simple maxgui buttons, I just made them too small<br>So it's just a "sample" issue.<br><br>Anyway, thanks for the image !<br>It showed me a strange behavior with panel colors I didn't know about.<br>-&gt; While the windows panels (I mean : panels on win32 gui) automatically use the parent color if no color is specified, on linux, a panel without color specified use the default color.<br><br>I'll have to take care of this ^^<br><br>[edit]<br><br>@Casaber :<br>Do macos scrollbars use a minimal width ?<br>try to increase it and see what happens<br>on line 300 -&gt; Self.scroll_size=	12; <br>change this to maybe 14 or more ...<br><br><br>[edit2]<br>or try this<br>(on windows, I want the scrollbar to remain the smallest possible)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import maxgui.drivers


Const COLLAPSEITEM_RIGHT:Int	=	8192

Type TCollapserItem Extends TProxyGadget
	
	Field core:TGadget;
		Field bt:TGadget;
		Field title:TGadget;
		Field realheight:Int;
	Field client:TGadget;
	
	Field _style:Int;
	Field title_height:Int;
	Field _pix:TPixmap[];
	Field _state:Byte;
	Field _on:Byte;
	
	'#region private (internal) stuff
	Method CleanUp :Int ()
		If Self.getCollapser()&lt;&gt;Null Then Self.getCollapser().RemoveGadget(Self);
		Return Self.proxy.CleanUp();
	End Method
	
	' update the pixmap icon of the top button
	Method updatePixmap()
		Self.bt		.SetPixmap		( Self._pix[Self._on*2+Self._state], PANELPIXMAP_STRETCH );
	End Method
	
	' when mouse enter the button
	Method onEnter()
		Self._on = 1;
		Self.updatePixmap	( );
	End Method
	
	' when mouse leave the button
	Method onLeave()
		Self._on = 0;
		Self.updatePixmap	( );
	End Method
	
	Method updateShape()
		If Self._state
			Self.core.SetShape(Self.xpos,Self.ypos,Self.width,Self.realheight);
			Self.client.SetShape(1,Self.title_height,Self.width-2,Self.realheight-Self.title_height-1);
			Self.client.SetShow(True);
		Else
			Self.core.SetShape(Self.xpos,Self.ypos,Self.width,Self.title_height);
			Self.client.SetShape(1,Self.title_height,Self.width-2,Self.realheight-Self.title_height-1);
			Self.client.SetShow(False);
		EndIf;
		If ( (Self._style &amp; COLLAPSEITEM_RIGHT) &gt; 0 )
			' title is left / button is right
			Self.title	.SetShape	( 1, 1, Self.width-Self.title_height-1, Self.title_height-2 );
			Self.bt		.SetShape	( Self.width-Self.title_height+1, 1, Self.title_height-2, Self.title_height-2 );
		Else
			' default : button is left
			Self.bt		.SetShape	( 1,1,Self.title_height-2,Self.title_height-2 );
			Self.title	.SetShape	( Self.title_height, 1, Self.width-Self.title_height-1, Self.title_height-2 );
		EndIf
	End Method
	'#end region
	
	'#region create
	Method Create:TCollapserItem ( pTitle:String, pX:Int, pY:Int, pW:Int,pH:Int, pCollapser:TCollapser, pStyle:Int=0)
		
		' only add items to a Collapser gadget !
			If pCollapser = Null Then Return Null;
			Self.title_height=	Int(Floor(pCollapser.title_height*0.5))*2+1;
			Self.realheight	=	pH;
			
			Self._state		=	True;
			Self._style		=	pStyle;
			Self.parent		=	pCollapser;
			Self._on		=	0;
			
		' generate pixmaps
			Local l_th:Int	=	Self.title_height;
			Local pix_h:Int	=	(l_th-2);
			Self._pix		=	[	CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888), ..
									CreatePixmap(pix_h,pix_h, PF_RGB888)];
									
				Self._pix[0]		.ClearPixels($808080);
				Self._pix[1]		.ClearPixels($808080);
				Self._pix[2]		.ClearPixels($A0A0A0);
				Self._pix[3]		.ClearPixels($A0A0A0);
				
				Local pix_x:Int;
				Local pix_m:Int = Floor(pix_h*0.5);
				For pix_x = 3 Until pix_h-3
					Self._pix[0].WritePixel(pix_x, pix_m, $010101);
					Self._pix[0].WritePixel(pix_m, pix_x, $010101);
					Self._pix[1].WritePixel(pix_x, pix_m, $010101);
					Self._pix[2].WritePixel(pix_x, pix_m, $010101);
					Self._pix[2].WritePixel(pix_m, pix_x, $010101);
					Self._pix[3].WritePixel(pix_x, pix_m, $010101);
				Next
				
		' title panel
			Self.core	=	CreatePanel		( pX,pY,pW,ph, pCollapser.getClient(), pStyle );
				Self.core	.SetColor		( $01,$01,$01 );
				Self.core	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, 0 );
				
		' button + title
			If ( (pStyle &amp; COLLAPSEITEM_RIGHT) &gt; 0 )
				' title is left / button is right
				Self.title=	CreateLabel		( " "+pTitle+" ", 1, 1, pw-l_th-1, l_th-2, Self.core, pStyle );
				Self.bt	=	CreatePanel		( pw-l_th+1, 1, l_th-2, l_th-2, Self.core, PANEL_ACTIVE );
				Self.bt		.SetLayout		( 0, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
			Else
				' default : button is left
				Self.bt	=	CreatePanel		( 1,1,l_th-2,l_th-2, Self.core, PANEL_ACTIVE );
				Self.bt		.SetLayout		( EDGE_ALIGNED, 0, EDGE_ALIGNED, EDGE_ALIGNED );
				Self.title=	CreateLabel		( " "+pTitle+" ", l_th, 1, pw-l_th-1, l_th-2, Self.core, pStyle );
			EndIf
				Self.bt		.SetColor		( $80,$80,$80 );
				Self.title	.SetColor		( $60,$60,$60 );
				Self.title	.SetTextColor	( $FF,$80,$20 );
				Self.title	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
				
				Self		.updatePixmap	( );
				Self.bt.extra = Self;
				
		' client panel
			Self.client	=	CreatePanel		( 1, l_th, pw-2, ph-l_th-1, Self.core );
				Self.client	.SetLayout		( EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED );
				Self.client	.SetColor		( $40,$40,$40 );
				
		' set proxy
			Self.proxy	=	Self.core;
			
		' Update layout (by Default : stick Left And Right)
			' we align on top, not bottom, but whatever we set, top and bottom will be forced after collapser update
			' ( and collapser update is called by addItem, so it's updated immediatly after setlayout. )
			Self.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,0);
			
			pCollapser.addItem(Self);
			
		Return Self;
		
	End Method
	'#end region
	
	'#region text
	' text is sent to the title gadget
	Method SetText(text:String)
		Self.title.SetText(text);
	End Method
	
	Method GetText:String()
		Return Self.title.GetText();
	End Method
	'#end region
	
	'#region fold/unfold
	' returns true if gadget is expanded else returns false.
	Method State:Int()
		Return Self._state;
	End Method
	
	' alternates the collapsed/expanded state relatives to the previous state
	Method SwitchState()
		Self.setState(Not(Self._state));
	End Method
	
	' collapse (0) or expand (1) the gadget
	Method SetState(bool:Byte)
		If bool
			Self.Expand();
		Else
			Self.Collapse();
		EndIf
	End Method
	
	' collapse the gadget
	Method Collapse()
		If ( Self._state = False )	Then Return;
		Self._state				=	0;
		Self						.updatePixmap	( )
		Self						.updateShape	( );
		Self.getCollapser()			.Update			( );
		EmitEvent					( CreateEvent	( EVENT_GADGETACTION, Self, 0 ) );
	End Method
	
	' expand the gadget
	Method Expand()
		If ( Self._state = True )	Then Return;
		Self._state				=	1;
		Self						.updatePixmap	( );
		Self						.updateShape	( );
		Self.getCollapser()			.Update			( );
		EmitEvent					( CreateEvent	( EVENT_GADGETACTION, Self, 1 ) );
	End Method
	
	' fold the gadget (alias for collapse)
	Method fold()
		Self.Collapse();
	End Method
	
	' unfold the gadget (alias for expand)
	Method unfold()
		Self.Expand();
	End Method
	'#end region
	
	'#region shape
	' returns the real Height the item is supposed To be (Not the collapsed Height)
	Method GetHeight:Int()
		Return Self.realheight;
	End Method
	
	' the client gadget.
	Method getClient:TGadget()
		Return Self.client;
	End Method
	
	' client size
	Method ClientWidth:Int()
		Return Self.client.ClientWidth()
	End Method
	
	Method ClientHeight:Int()
		Return Self.client.ClientHeight()
	End Method
	
	Method SetShape(pX:Int,pY:Int,pW:Int,pH:Int)
		' copy shape pos and size
		Self.xpos = px;
		Self.ypos = py;
		Self.width = pw;
		Self.Height = ph;
		Self.realheight = ph; ' get real size of the gadget (whatever it is collapsed or not)
		
		' the core gadget is updated after this
		Self.updateShape();
	End Method
	
	Method SetLayout( lft:Int,rht:Int,top:Int,bot:Int )
		Self.proxy.SetLayout(lft,rht,top,bot);
		' copy core layout to self
		Self.lockl = Self.proxy.lockl;
		Self.lockr = Self.proxy.lockr;
		Self.lockt = Self.proxy.lockt;
		Self.lockb = Self.proxy.lockb;
		Self.lockx = Self.proxy.lockx;
		Self.locky = Self.proxy.locky;
		Self.lockw = Self.proxy.lockw;
		Self.lockh = Self.proxy.lockh;
		Self.lockcw = Self.proxy.lockcw;
		Self.lockch = Self.proxy.lockch;
	End Method
	'#end region
	
	
	' the Collapser object that owns this item
	Method getCollapser:TCollapser()
		Return TCollapser(Self.parent);
	End Method
	
	Function gadgetCollapserItem:TCollapserItem(gad:TGadget)
		If gad=Null Then Return Null;
		If gad.GetGroup() = Null Then Return Null; ' button.parent = core
		Return TCollapserItem(gad.extra);
	End Function
	
End Type


Const COLLAPSER_AUTORESIZE:Int	=	512;	' set collapser client height to match kids
Const COLLAPSER_AUTOSCROLL:Int	=	1024;	' add scrollbar if required

Type TCollapser Extends TProxyGadget
	
	Global collapsedTime:Int;
	?MacOs
	Global DEFAULT_SCROLLWIDTH:Int	=	16;
	?Not MacOs
	Global DEFAULT_SCROLLWIDTH:Int	=	13;
	?
	
	Field title_height:Int;
	Field scroll_size:Int;
	Field client:TGadget;
	
	' TODO &gt; add sliders to scroll client gadgets
		Field scrollbarX:TGadget;
		Field scrollbarY:TGadget;
	
	Field paddingy:Int;
	
	Field items:TList;
	
	Method Create:TCollapser(pX:Int, pY:Int, pW:Int, pH:Int, pGroup:TGadget, pStyle:Int)
		
		collapsedTime = MilliSecs()-101;
		
		Self.items		=	New TList;
		
		Self.title_height=	17;
		Self.scroll_size=	DEFAULT_SCROLLWIDTH;
		Self.paddingy	=	5;
		
		Self.SetProxy		( CreatePanel(pX,pY,pW,pH,pGroup,pStyle) );
		
		' not implemented yet
		Self.scrollbarY	=	CreateSlider	( pw-Self.scroll_size,0,Self.scroll_size,ph, Self.proxy, SLIDER_VERTICAL );
		Self.scrollbarY		.SetLayout		( 0,EDGE_ALIGNED, EDGE_ALIGNED,EDGE_ALIGNED );
		Self.scrollbarY		.SetShow		( False );
		
		Self.scrollbarX	=	CreateSlider	( 0,ph-Self.scroll_size,pw-Self.scroll_size,Self.scroll_size, Self.proxy, SLIDER_VERTICAL );
		Self.scrollbarX		.SetLayout		( EDGE_ALIGNED,EDGE_ALIGNED, 0,EDGE_ALIGNED );
		Self.scrollbarX		.SetShow		( False );
		
		Self.client		=	CreatePanel		( Self.scroll_size/2,Self.title_height,pw-Self.scroll_size,ph, Self.proxy );
		Self.client			.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED, EDGE_ALIGNED,EDGE_ALIGNED);
		
		AddHook				( EmitEventHook, EventHook, Self );
		
		Return Self;
		
	End Method
	
	Method Rethink()
		Self.Update();
		Super.Rethink();
	End Method
	
	Function EventHook:Object(id:Int, data:Object, context:Object)
		If TEvent(data) = Null Then Return data;
		Local ev:TEvent = TEvent(data);
		
		Local col:TCollapser
		Local itm:TCollapserItem;
		
		Select ev.id
			
			Case EVENT_WINDOWSIZE
				
				col = TCollapser(context); If col&lt;&gt;Null Then col.Rethink();
				Return data;
				
			Case EVENT_MOUSEENTER
				
				If TGadget(ev.source)&lt;&gt;Null
					itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
					If (itm&lt;&gt;Null) Then If itm.getCollapser()=context Then itm.onEnter(); Return data;
				EndIf;
				Return data;
				
			Case EVENT_MOUSELEAVE
				
				If TGadget(ev.source)&lt;&gt;Null
					itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
					If (itm&lt;&gt;Null) Then If itm.getCollapser()=context Then itm.onLeave(); Return data;
				EndIf;
				Return data;
				
			Case EVENT_MOUSEUP
				
				If (ev.data = 1)
					If TGadget(ev.source)&lt;&gt;Null
						itm = TCollapserItem.gadgetCollapserItem(TGadget(ev.source));
						If (itm&lt;&gt;Null)
							If (itm.getCollapser()=context)
								If (ev.x&gt;=0 And ev.x&lt;itm.bt.GetWidth())
									If (ev.y&gt;=0 And ev.y&lt;itm.bt.GetHeight())
										If Abs(MilliSecs()-TCollapser.collapsedTime)&gt;100
											itm.SwitchState();
											TCollapser.collapsedTime = MilliSecs();
										EndIf;
									EndIf;
								EndIf;
								Return Null;
							EndIf;
						EndIf;
					EndIf;
				EndIf;
				
			Case EVENT_GADGETACTION
				If TCollapser(context)&lt;&gt;Null
					col = TCollapser(context);
					If ( ev.source = col.scrollbarY )
						col.client.SetShape(0,-SliderValue(col.scrollbarY), col.proxy.width-col.scroll_size, col.client.Height);
					EndIf;
				EndIf;
				
		End Select;
		Return data;
	End Function
	
	Method CleanUp :Int ()
		Self.proxy.CleanUp();
		RemoveHook(EmitEventHook, EventHook, Null);
		Return Super.CleanUp();
	End Method
	
	Method AddItem(item:TGadget)
		' Always layout stuff with &lt;ALIGN TOP&gt; and &lt;NOT ALIGNED BOTTOM&gt; !
		item.SetLayout(item.lockl,item.lockr, EDGE_ALIGNED,0);
		Self.items.AddLast(item);
		Self.Update();
	End Method
	
	Method RemoveItem(index:Int)
		If index&lt;0 Or index&gt;=Self.items.Count() Then Return;
		Self.items.Remove(Self.items.ValueAtIndex(index));
		Self.Update();
	End Method
	
	Method RemoveGadget:Int(gad:TGadget)
		Self.items.Remove(gad);
		Self.Update();
	End Method
	
	Method GetItem:TGadget(index:Int)
		Return TGadget(Self.items.ValueAtIndex(index));
	End Method
	
	Method GetClient:TGadget()
		Return Self.client;
	End Method
	
	Method ClientWidth:Int()
		Return Self.client.ClientWidth();
	End Method
	
	Method ClientHeight:Int()
		Return Self.client.ClientHeight();
	End Method
	
	Method Update()
		
		' resize/repos clients
		Self.items.Sort(True, compareGadgetY)
		Local item:TGadget;
		Local posy:Int = Self.paddingy;
		Local gadh:Int = 0;
		
		For item = EachIn Self.items
			If ( TCollapserItem(item)&lt;&gt;Null )
				If TCollapserItem(item)._state
					gadh = TCollapserItem(item).GetHeight();
				Else
					gadh = TCollapserItem(item).title_height;
				EndIf;
			Else
				gadh = item.GetHeight();
			EndIf;
			item.SetShape ( item.GetXPos(), posy, item.GetWidth(), item.GetHeight() );
			posy :+ gadh + Self.paddingy;
		Next;
		
		gadh = posy;
		Local clh:Int = Self.proxy.Height-Self.title_height;
		
		If ( gadh &gt; clh )
			Self.scrollbarY.SetShow(True)
			Self.client.SetShape(0,Self.title_height,Self.proxy.width-Self.scroll_size, gadh);
			Self.scrollbarY.SetRange(0,gadh-clh);
		Else
			Self.scrollbarY.SetShow(False);
			Self.client.SetShape(Self.scroll_size/2,Self.title_height,Self.proxy.width-Self.scroll_size, clh);
		'	Self.client.SetShape(0,Self.title_height,Self.client.width, gadh);
		EndIf;
		
		RedrawGadget Self;
		
	End Method
	
	Function compareGadgetY:Int(o1:Object, o2:Object)
		Return -1+2*(TGadget(o1).GetYPos()&gt;TGadget(o2).GetYPos());
	End Function
	
End Type


Function CreateCollapser:TCollapser ( pX:Int, pY:Int, pW:Int,pH:Int, pGroup:TGadget, pStyle:Int=0 )
	Return New TCollapser.Create(pX,pY,pW,pH,pGroup,pStyle);
End Function
Function CreateCollapsable:TGadget ( pTitle:String, pX:Int, pY:Int, pW:Int, pH:Int, pCollapser:TGadget, pStyle:Int=0 )
	If TCollapser(pCollapser)=Null Then Return Null;
	Return New TCollapserItem.Create(pTitle, pX,pY,pW,pH, TCollapser(pCollapser), pStyle);
End Function
Function CollapserItem:TGadget(pCollapser:TGadget, index:Int)
	If TCollapser(pCollapser) = Null Then Return Null;
	Return TCollapser(pCollapser).GetItem(index);
End Function

Function CollapserAddItem(pCollapser:TGadget, item:TGadget)
	If TCollapser(pCollapser) = Null Then Return;
	TCollapser(pCollapser).AddItem(item);
End Function








Function TCollapserDemo()
	
	Local Win:TGadget = CreateWindow("window", 10,10,800,600,, WINDOW_TITLEBAR | WINDOW_CLIENTCOORDS | WINDOW_CENTER | WINDOW_RESIZABLE | WINDOW_STATUS );
	SetMinWindowSize(Win, 640,400)
	
	Local body:TGadget[2]
	Local a:Int;
	Local panI:TGadget[2];
	Local killMe:TGadget[2];
	For a = 0 To 1
		
		body[a] = CreatePanel(a*ClientWidth(Win)/2+5,5,ClientWidth(Win)/2-10, ClientHeight(Win)-10,Win)
		body[a].SetColor($90,$90,$90);
		If a=0
			body[a].SetLayout(EDGE_ALIGNED,EDGE_RELATIVE,EDGE_ALIGNED,EDGE_ALIGNED);
		Else
			body[a].SetLayout(EDGE_RELATIVE,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
		EndIf;
		
		' create a collapser
			Local col:TCollapser = CreateCollapser( 5,5, ClientWidth(body[a])-10, ClientHeight(body[a])-10, body[a] );
			col.SetColor($20,$20,$20);
			col.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
			
		' create collapsable region in the collapser
			CreateCollapsable	( "Buttons"				, 005,005,ClientWidth(col)-10, 100, col );
			CreateCollapsable	( "Radio Buttons"		, 005,110,ClientWidth(col)-10, 100, col );
			CreateCollapsable	( "it's really tight"	, 005,215,ClientWidth(col)-10, 200, col );
			
		' get collapsables from collapser
			Local pan0:TGadget = TCollapserItem(col.getitem(0)).getClient(); ' &gt; Add stuff to the client !
			Local pan1:TGadget = TCollapserItem(col.getitem(1)).getClient();
			Local pan2:TGadget = TCollapserItem(col.getitem(2)).getClient();
			Local colI:TCollapser = CreateCollapser( 5,5,ClientWidth(pan2)-10, ClientHeight(pan2)-10, pan2 );
				colI.SetColor($30,$30,$30);
				colI.SetLayout(EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED,EDGE_ALIGNED);
				' you can use "Y" position at the creation to specify order of gadgets.
				' gadgets, when collapser updates, are sorted by their "Y" position.
				' for example, here the "btKill" is created on top of the two regions.
			CreateCollapsable("let me get out i'm locked :'(", 5, 1,ClientWidth(colI)-10, 100, colI);
			CreateCollapsable("speak for you bro ...", 5, 2,ClientWidth(colI)-10, 100, colI);
			Local btKill:TGadget = CreateButton("Kill Me Please", 5, 0, 100,20, colI.GetClient() );
				btKill.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
			ColI.additem ( btKill );
			
			panI[a] = colI;
			
			' as mentioned, items are sorted, so, the collapsable regions are at index 1 and 2
			Local panI0:TGadget = TCollapserItem(colI.getitem(1)).getClient();
			Local panI1:TGadget = TCollapserItem(colI.getitem(2)).getClient();
			' and the button is at index 0
			killMe[a] = colI.getitem(0);
			
		' fill regions with some buttons
			
			Local i:Int, j:Int;
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("button "+i+"-"+j,5+85*i,5+25*j,80,20,pan0, BUTTON_OK);
					b.SetLayout(1,0,1,0);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("radio "+i+"-"+j,5+85*i,5+25*j,80,20,pan1, BUTTON_RADIO);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateButton("check "+i+"-"+j,5+85*i,5+25*j,80,20,panI0, BUTTON_CHECKBOX);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			For j = 0 To 2
				For i = 0 To 2
					Local b:TGadget = CreateLabel("label "+i+"-"+j,5+85*i,5+25*j,80,20,panI1, LABEL_CENTER);
					b.SetLayout(1,0,1,0);
					b.SetColor($50,$50,$50);
					b.SetTextColor($FF,$70,$00);
				Next
			Next
			
		' add a button in the collapser (outside collapsable regions)
		Local button:TGadget = CreateButton("click", 5,320, 90, 20, col.getClient() );
				button.SetLayout(EDGE_ALIGNED,0,EDGE_ALIGNED,0);
				
		col.AddItem(button);
	Next;
	
	Repeat
		
		WaitEvent()
		Select EventID()
			Case EVENT_WINDOWCLOSE
				Exit;
			Case EVENT_GADGETACTION
				SetStatusText (Win, "Hit a button '"+TGadget(EventSource()).GetText()+"' state='"+TGadget(EventSource()).State()+"'")
				For a = 0 To 1
					If killMe[a]&lt;&gt;Null
						If EventSource()=killMe[a]
							FreeGadget(panI[a])
							killMe[a] = Null;
							panI[a] = Null;
						EndIf;
					EndIf;
				Next;
			'	If EventSource() = panI1
			'		
			'	EndIf;
		End Select
		
	Forever
	
	End
	
End Function



TCollapserDemo()
</textarea> <br><br></td></tr></table><br>
<a name="1293612"></a>

<a name="1293613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is what I see on windows 8.1<br><br><img src="http://mdt.bigbang.free.fr/sources/collapser/images/tcollapser.png"><br><br>I just noticed on Derron's screen, there is no "+" or "-" on the TCollapserItem's button.<br>Does SetPanelPixmap work on linux ? (maybe it requires a PF_RGBA8888 instead of PF_RGB888 format) <br><br></td></tr></table><br>
<a name="1293614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> 16 - 17 Got it right, increasing it more did'nt change the size. But 16 looked great. 17 I think was the same. So one of those. <br><br></td></tr></table><br>
<a name="1293616"></a>

<a name="1293617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> so let's go for 16 :)<br><br>Actually, I'm trying to understand the first value of SetSliderRange<br>(from the maxgui doc)<br><div class="quote"> <br>For the default SLIDER_SCROLLBAR style the range0,range1 parameters are treated as a visible / total ratio which dictates both the size of the knob and it's maximum value. The default value is 1,10 which displays a Slider with a knob that occupies 1/10th the area and with a SliderValue range of 0..9. <br> <br></div><br><br>I'like to have scrollbar with wider knobs ... but increasing the size (using the first range value) makes it unabled to reach to end of the client panel<br><br>[EDIT]<br>I've got it !<br>Self.scrollbarY.SetRange(clh, gadh);<br>this makes the knob the perfect size according to what's required to reach bottom of the client. <br><br></td></tr></table><br>
<a name="1293619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <i>Bobysait:</i><br><div class="quote"> (maybe it requires a PF_RGBA8888 instead of PF_RGB888 format)  <br></div><br>Nope, that doesn't fix it.<br><br><br>I do not use the Linux-default-maxgui (FLTK) as this just errors out with some memory addresses, so I use<br><br><pre class=code>
'Import maxgui.drivers
Import bah.gtkmaxgui
</pre><br><br>Which means, it might be something in connection to the gtk wrapper.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I do not use the Linux-default-maxgui (FLTK) as this just errors out with some memory addresses, so I use<br> <br></div><br><br>Are those errors related to the code I posted ? or just general issues with FLTK ?<br><br>I don't own the bah module (as I don't have a linux installed yet)<br>So, if anyone with the original maxgui module could test it, it would be greatfull. <br><br></td></tr></table><br>
<a name="1293623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Bobysait. Maybe I'm the odd man out, however - your code works fine here too. Lots of shiny buttons. :) <br><br></td></tr></table><br>
<a name="1293840"></a>

<a name="1293844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry no images but using ubuntu 14 and Gtkmaxgui I get the  "+" or "-" symbols on the TCollapserItem button and it also works fine with Fltk in fact Fltk works better as it has no errors. <br><br>In Gtk if I click "Kill me" and then close the window I get this:<br><div class="quote"> ** (maxguitest.debug:4078): CRITICAL **: os_bar_hide: assertion 'OS_IS_BAR (bar)' failed<br>(maxguitest.debug:4078): Gtk-CRITICAL **: IA__gtk_widget_hide: assertion 'GTK_IS_WIDGET (widget)' failed <br></div><br>And if I click a collapser button and then close the window I get this:<br><div class="quote"> (maxguitest4.debug:4092): GdkPixbuf-CRITICAL **: gdk_pixbuf_scale_simple: assertion 'dest_height &gt; 0' failed <br></div><br>Not big problems but worth mentioning.<br><br>I could not find a SetPanelPixmap in your code so not sure what you're talking about there.<br><br>Edit: also I was going to say, since only geeks use Linux (and it accounts for 2% of users, others 3%, Mac 6%) it may not be worth your while supporting it. I use Linux but only for development and because my project is open source. <br><br></td></tr></table><br>
<a name="1293853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> @memory addresses<br>Has not to do with your code - it is just something with the fltkmaxgui.mod ... <br><br>brl.mod and pub.mod are the ones provides by Brucey's maxmod-collection (enhanced brl.mod/pub.mod). Maybe something is not working nicely together.<br><br><br>@FLTK<br>It just looks alien when run in an GTK/QT environment (other widget skin, other colors, other font sizes...).<br><br><br><br>Just continue your work, varying "appearance" could be taken care of in a later stage.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1293856"></a>

<a name="1293857"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> At least it is working on mac whithout carying about anything.<br>For Linux, that's true there is not really a lot of users ...<br>But you know, a customer is a customer (or not actually ... "You use Linux, you won't pay for softwares anyway")<br><br><div class="quote"> <br>I could not find a SetPanelPixmap in your code so not sure what you're talking about there.<br> <br></div><br>I don't use the "full command", but the method on the gadget &gt; gadget.SetPixmap(pixmap, PANELPIXMAP_FIT) which is the same :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
