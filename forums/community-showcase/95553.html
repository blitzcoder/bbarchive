<!DOCTYPE html><html lang="en" ><head ><title >2D Global Illumination</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >2D Global Illumination</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=61" >Showcase</a>/<a href="#bottom" >2D Global Illumination</a><br><br>
<a name="1101298"></a>

<a name="1101299"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Since I needed a lighting solution for a 2D sidescrolling project, I experimented a bit with global illumination in 2D to bake lightmaps for later use in-game.<br><br>The principle it uses, light tracing, is very simple: Shoot rays from each light source and scatter them at intersection points until the rays terminate. Getting it to work non-biased though was a whole different question.<br>Ultimately I had to come up with a 2.5D-ish kind of concept to make it look good, which made generating light directions a bit more messy (I you take a look at the code you'll see what I mean), but it seems to work quite nicely.<br><br>Another issue were efficient intersection tests. Since I didn't want to put any restriction on the kind of environment used (e.g. it doesn't have to consist of straight lines), I implemented a sparse voxel quadtree to ensure fast intersection detection. Interestingly, even though the code is a lot more complex, the test scene renders a lot faster using the SVQ compared to naive line-line intersections.<br><br><br>Screenshot:<br><br><img src="http://noobody.org/Data/GlobalIllum-4.png"><br><br><br>Youtube video:<br><br><a href="http://www.youtube.com/watch?v=CPBdiV0JvRo" target="_blank"><img src="http://noobody.org/Data/GlobalIllum-YT.png"></a><br><br><b>Watch in HD!</b><br><br><br><br>The end result is, albeit slow, not too bad and may find its use in games using a topdown view or mostly indoors. For my purpose it is sadly not applicable, since I was going more for a sideview perspective, so I'll have to take a different approach for this.<br><br><b>Download the demo (*.exe + BMax code):</b> <a href="http://noobody.org/Data/2D-Global-Illumination.zip" target="_blank">Link</a><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Totally kick ass man, thanks for sharing. <br><br></td></tr></table><br>
<a name="1101351"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MCP</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very clever stuff Noobody! <br><br></td></tr></table><br>
<a name="1101358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very nifty! Thanks for sharing, really. Inspiring, too. I'm really curious about your game then. Looking forward to it! :) <br><br></td></tr></table><br>
<a name="1101361"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, good stuff, many thanks. <br><br></td></tr></table><br>
<a name="1101368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very good. Many thanks for sharing. <br><br></td></tr></table><br>
<a name="1101380"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ross C</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's super sweet! <br><br></td></tr></table><br>
<a name="1101419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just a small test to see how it could look ingame (due to lack of actual levels, just a bit of concept art from one of the artists):<br><br><img src="http://noobody.org/Data/MLP-EOD-BarnLighting.png"><br><br>Light enters through the door, the window and cracks in the ceiling. <br><br></td></tr></table><br>
<a name="1101430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Are the light sources painted in a mask-like bitmap, or are they edited another way? <br><br></td></tr></table><br>
<a name="1101445"></a>

<a name="1101446"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> hey, looks awesome in the video but im not sure whats wrong with it when i run the exe or the code it just draws sparse pixels randomly and doesnt really do anything, is it not for real time or is something wrong with my graphics card/computer?<br><br>Looks very cool by the way!<br><br>also if it is not real time, is there a real time lighting mod out for blitz max?<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101509"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Andres</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> i don't get why it traces the rays randomly? or did i miss something? <br><br></td></tr></table><br>
<a name="1101541"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks nice :) You should keep the pencil drawn style :) <br><br></td></tr></table><br>
<a name="1101542"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> You know, I'm sure, too, that there are alternatives that could yield a brilliant result without stochastic sampling or what that's called. Certainly a cool challenge to think those up! :)<br> <br>I still like what you've done there, though. And your game design idea up there looks very, very interesting indeed! <br><br></td></tr></table><br>
<a name="1101546"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Are the light sources painted in a mask-like bitmap, or are they edited another way? <br></div><br>The light sources are being painted into a separate lightmap, which is then being overlayed over the tilemap.<br><br><br><div class="quote"> is it not for real time or is something wrong with my graphics card/computer? <br></div><br>Don't worry, your computer is fine ;) Global illumination is just very very expensive computational wise. While it is a bit faster in 2D than in 3D (where rendering a single frame can take days), it's still not ready for real-time usage (leaving GPGPU aside).<br><br>Also, to keep the demo application from freezing when it's calculating (which gives a bad impression), I lowered the number of rays cast per frame to a reasonable number. Unfortunately, this way the rendering of the image actually takes a lot longer than the lighting calculation itself, so the lighting takes a lot more time to converge. If you increase the number of rays cast per frame though (to, say, one million), you should get a noise-free image after 30-60 seconds.<br><br><br><div class="quote"> i don't get why it traces the rays randomly? or did i miss something? <br></div><br>The reason for this is that calculating the lighting directly is impossible. What the program is doing is essentially evaluating the <a href="http://en.wikipedia.org/wiki/Rendering_equation" target="_blank">rendering equation</a>. Solving that integral directly is only possible for very simple cases, but for the more general case other means of integration are needed. In visual computing, <a href="http://en.wikipedia.org/wiki/Monte_Carlo_Integration" target="_blank">Monte Carlo integration</a> is a frequently used algorithm because it is well understood, efficient to implement and gives good results (which is why I've been using it here).<br><br>How it works is basically choosing random sample points inside the domain of the integral, evaluating the function at these points and summing the corresponding values up to approximate the total value of the integral. The tricky part here is to calculate the probability of a sample to weight it properly, which is usually very counter-intuitive and even subtle errors can have huge effects on the final image.<br><br><br><div class="quote"> Certainly a cool challenge to think those up! :) <br></div><br>If someone's actually able to do that, he'd probably suffocate under the mountains of money the movie industry would throw at him :D <br><br></td></tr></table><br>
<a name="1101637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uh, is that a promiss? :D<br><br>Nah, I think as long as you're in a 2d domain, even if you go 2.5d by using depth information, you can accept to use assumptions that don't require sampling and can rely on calculation instead. You have a whole dimension of unknowns less than in fully 3d situations.<br><br>I've written the "ZbornToy", which is a 2.5d filter for After Effects, which does a good deal of that, except that I only hooked in a very simplistic ambient occlusion and didn't go into radiosity. I've written all important basic shading features for it, including subsurfacescattering or rather "volumetric translucency" with some adjustable diffusion. Lightsources can be direct light and point light with soft shadows, if desired, but also environmental illumination based on various mapping methods. I've hooked up refraction in and forward, meaning it refracts background and can project refracted lightsources onto the background. So, yeah, I've been in the general realm already and it's almost realtime, while it could be optimized for that purpose, too.<br><br>Did that throw any money at me? Nah, not really. Not bad for a few weeks of development, but then... I wasn't really asking for it either.<br><br>However, I like this challenge and might have a look and go at it! :} <br><br></td></tr></table><br>
<a name="1101675"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kittomer</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Even though I don't know very much about the domain of programing raytracing, I am sure you could combine a simple shadow casting engine with a GI solution that has very sparse sampling and then simply interpolates based on the shadow and "geometry" data.<br>If done cleverly, it probably would reach comparable image quality as this brute force approach.<br><br>This STILL is very impressive, wouldn't have thought BlitzMax would be able to handle something like this respectably. <br><br></td></tr></table><br>
<a name="1101680"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Nah, I think as long as you're in a 2d domain, even if you go 2.5d by using depth information, you can accept to use assumptions that don't require sampling and can rely on calculation instead. <br></div><br>That depends on what you mean by 'calculation'. Evaluating the integral directly (e.g. finding a perfect solution that runs in bounded time) is not possible for the general case, but there <i>are</i> different methods of integration other than stochastic sampling. Monte Carlo integration is just one method (one that finds a lot of uses, though), but there are also iterative algorithms available, such as radiosity (which you mentioned). All of them though only yield approximative solutions that get better the longer the program is running (unbounded time).<br><br>I would prefer stochastic sampling over radiosity in the 2D case though, since radiosity essentially only calculates light exiting surfaces of geometry. While this works well in 3D (since all visible geometry is essentially a surface), in 2D it would only be able to calculate the lighting conditions on surfaces of obstacles, not on the 'floor' (which comprises the main part of the image) since it's not an actual 2D surface.<br>Also, while radiosity works well for low-variance diffuse lighting, it performs poorly on sharp shadows, which I'd like to preserve in the final image (there are variants of radiosity solving this by calculating shadows separately, though).<br><br>I had a look at ZbornToy and I must say, I'm very impressed. It's pretty!<br>Also, while Ambient Occlusion is usually done with stochastic sampling adjacent geometry, it *can* be approximated with techniques such as SSAO, which I'm guessing you used. It suffers from a few drawbacks though (with it being an approximation of an approximation and all).<br><br>I'm intrigued by the caustics though - did you trace a light ray to each pixel, refract it by the normal at that pixel and then light the point on the background where it ends up after refracting? That's what I'd do, and it probably yields enough samples to compute smooth caustics.<br><br><div class="quote"> So, yeah, I've been in the general realm already and it's almost realtime, while it could be optimized for that purpose, too. <br></div><br>True, caustics, soft shadows and AO are some of the focus points of global illumination. Basically, if you'd apply AO again and again and again, you'd ultimately end up with GI (since that's basically what radiosity does). Also, nice work on the performance - my code really sucks in that regard. I didn't really care since it's just intended for precomputing lightmaps, where a few minutes of computation time won't hurt, but seeing it in real-time would make an interesting game mechanic.<br><br><div class="quote"> However, I like this challenge and might have a look and go at it! :} <br></div><br>Please do! I'd be very excited if you found something.<br><br><br><div class="quote"> This STILL is very impressive, wouldn't have thought BlitzMax would be able to handle something like this respectably.  <br></div><br>Don't underestimate BMax! :) If you only consider raw computations, it is only slightly slower than C/++. The problem is that for one, most C/++ compilers do excessive optimization unmatched by the BMax compiler in more complex pieces of code (though the ASM compiler might help a bit with that), and for the other that BMax has a garbage collector tearing on the performance. While this isn't much noticable in sequential mode, once you enable multi-threaded build, it becomes painfully obvious. I tried to speed it up with multi-threading, but just enabling threaded build already has such an impact on the performance that I didn't really bother with that option. <br><br></td></tr></table><br>
<a name="1101711"></a>

<a name="1101712"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm thinking about an interesting solution, but it's rather...eh...magical, hahaha. In the ZbornToy I've written a bunch of solutions in there, whereby the shadow casting light is the key element and sets the philosophy. It simply traverses the height image from the lights origin and responds to obstacles in respect to the angle by which the light comes in depth wise. Really simple stuff, but very fast and actually proper. The softness is a bit simplified beyond correctness, but not bad either as it responds to the distance of the last obstacle.<br>The caustics are the most magical trick, whereby Philipp Spoeth had the brilliant spark to use polygons and we wrote a very fast anti-aliased rasterization routine together. I won't disclose too much in that regard to respect his stakes, too, but you may be able to figure out what the idea is. However, the new after effects versions cause a few small troubles with them, which we had removed completely in the old version. That's a little annoying, but it's still nothing too serious and we'll fix it up, too.<br><br>Anyway, the magic idea I have for the calculations of bouncing lights has to do with fluid dynamics and light volumes. I'm not too sure, yet, but I think there's something very brilliant waiting to happen. Think about this for a moment. You might have some fun with it, too.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101777"></a>

<a name="1101778"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not hijacking the thread or anything, but heres a cool little real time lighting demo i came up with while trying to understand some different methods behind 2d lighting<br><br>I hesitate to call it real time because with more polygons/lights it becomes useless and slow<br>click two places to make a line segment<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

SetGraphicsDriver GLMax2DDriver()

Graphics 800,600

Global Intersection_X#,Intersection_Y#

SetBlend alphablend

Global mouseox%,mouseoy%,hold%

Global lite:tlight = tlight.Create(100,100,10,255,255,255)

Global lightarray:Int[400,300,3]


While Not KeyDown(key_escape)
	Cls
		If MouseHit(1) Then
			If hold Then
				tline.Create(mouseox,mouseoy,MouseX(),MouseY(),255,255,255,0,1)
				hold = False
			Else
				hold = True
				mouseox = MouseX()
				mouseoy = MouseY()
			EndIf
		EndIf
		lite.x = MouseX()
		lite.y = MouseY()
		tlight.render()
	
		glEnable GL_POINT_SPRITE
		'glEnable GL_POINT_SMOOTH
		glTexEnvi GL_POINT_SPRITE, GL_COORD_REPLACE, GL_TRUE 
		glPointSize 2
		glBegin GL_POINTS
		Local x:Int,y:Int
		For x = 0 To 399
			For y = 0 To 299
				glColor3f(lightarray[x,y,0]/255.0,lightarray[x,y,1]/255.0,lightarray[x,y,2]/255.0)
				glVertex2f(x*2,y*2)
			Next
		Next
		glDisable GL_POINT_SPRITE
		glEnd()
		tline.draw()
	Flip
Wend



Type TLight
	Global list:TList = New TList
	Field X#,Y#
	Field R%,G%,B%
	Field Intensity#
	'Field image:TImage
	
	Function Create:tlight(x#,y#,I#,r%,g%,b%)
		Local t:tlight = New tlight
		t.x = x
		t.y = y
		t.r = r
		t.g = g
		t.b = b
		't.image = CreateImage(800,600)
		t.intensity = i
		list.addlast(t:tlight)
		Return t
	End Function
	
	Function render()
		
		Local x%,y%,t:tlight,l:tline,dx#,dy#,d#,flag:Byte
		For x = 0 Until 400
			For y = 0 Until 300
				lightarray[x,y,0] = 0
				lightarray[x,y,1] = 0
				lightarray[x,y,2] = 0
			Next
		Next
		For x = 0 Until 400
			For y = 0 Until 300
				For t = EachIn tlight.list
					flag = False
					For l = EachIn tline.list
						If lines_intersect(x*2,y*2,t.x,t.y,l.x1,l.y1,l.x2,l.y2) Then
							flag = True
						EndIf
					Next
					If Not flag
						dx = t.x-x*2
						dy = t.y-y*2
						d = t.intensity/(dx*dx + dy*dy)^.5
						
						lightarray[x,y,0] :+ t.r*d
						lightarray[x,y,1] :+ t.g*d
						lightarray[x,y,2] :+ t.b*d
					EndIf
				Next
			Next
		Next
	End Function
End Type

Type TLine
	Global list:TList = New TList
	Field x1#,y1#,x2#,y2#
	Field r%,g%,b%
	Field Reflect#	'Number 0.0-1.0 1.0 = light 100% reflected
	Field Scatter#	'Number 0.0-1.0 1.0 = light 100% scattered
	
	Function Create:tline(x1#,y1#,x2#,y2#,r%,g%,b%,Reflect#,Scatter#)
		Local l:tline = New tline
		l.x1 = x1
		l.y1 = y1
		l.x2 = x2
		l.y2 = y2
		l.r = r
		l.g = g
		l.b = b
		l.reflect = reflect
		l.scatter = scatter
		list.addlast(l:tline)
		Return l
	End Function
	
	Function draw()
		For Local l:tline = EachIn list
			SetColor l.r,l.g,l.b
			DrawLine l.x1,l.y1,l.x2,l.y2
		Next
	End Function
End Type


'Not sure where i got this but its awesome and it works
Function Lines_Intersect:Int(Ax#, Ay#, Bx#, By#, Cx#, Cy#, Dx#, Dy#)	'finds the line intersections...
	Local dymcy# = dy - cy
	Local dxmcx# = dx - cx
	
	Local Rn# = (Ay#-Cy#)*(DxmCx#) - (Ax#-Cx#)*(DymCy#)
	Local Rd# = (Bx#-Ax#)*(DymCy#) - (By#-Ay#)*(DxmCx#)
	
	Local Intersection_AB#
	Local Intersection_CD#
	If Rd# = 0 
		
		' Lines are parralel.
		' If Rn# is also 0 Then lines are coincident.  All points intersect. 
		' Otherwise, there is no intersection point.
		Return False
	Else
		' The lines intersect at some point.  Calculate the intersection point.
	Local Sn# = (Ay#-Cy#)*(Bx#-Ax#) - (Ax#-Cx#)*(By#-Ay#)
		Intersection_AB# = Rn# / Rd#
		Intersection_CD# = Sn# / Rd#
		Intersection_X# = Ax# + Intersection_AB#*(Bx#-Ax#)
		Intersection_Y# = Ay# + Intersection_AB#*(By#-Ay#)	
		
	EndIf
		
	If Intersection_AB#&gt;0 And Intersection_AB#&lt;1 And Intersection_CD#&gt;0 And Intersection_cd#&lt;1
			Return True	
		Else
			Return False
	EndIf


End Function
</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >taumel</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, i don't get it, it's too slow for realtime purposes and for the rest there do exist solutions which bake lightmaps already, is it for tweaking certain factors you otherwise can't or storing the result in a different way?<br><br>@Nate the Great<br>Cool! <br><br></td></tr></table><br>
<a name="1101865"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Hmm, i don't get it, it's too slow for realtime purposes and for the rest there do exist solutions which bake lightmaps already <br></div><br>There exist 2D lightmapping tools? Do you have a link to that? Because that's exactly what I need. The sole reason I wrote this is because I couldn't find something else that already does what I want.<br><br><br><br>@NateTheGreat: If you want to go into the realtime realm, a good choice is directly using polygons and letting the graphics card do the work. One way to do this is tracking which side of the object is facing away from the light and then appending a shadow volume to that side and extending it away from the light beyond the viewport. I implemented this a while back in B3D:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Const GWIDTH = 800
Const GHEIGHT = 600

Graphics3D GWIDTH, GHEIGHT, 0, 2
SetBuffer BackBuffer()

Global PolygonSurf, ShadowSurf

Type TPolygon
   Field VertexCount
   Field Vertex.TVertex[ 128 ]
   
   Field CenterX#
   Field CenterY#
End Type

Type TVertex
   Field Polygon.TPolygon
   
   Field X#
   Field Y#
   
   Field Prev.TVertex
   Field Succ.TVertex
   
   Field VertIndex
End Type

Init()

CreatePolygon( 100, 100, 50, 50, 45 )
CreatePolygon( 250, 100, 50, 80, 90 )
CreatePolygon( 400, 500, 200, 50, 45 )
CreatePolygon( 400, 300, 10, 10, 36 )

Local Timer = CreateTimer( 60 )

While Not KeyHit( 1 )
   LightX# = 400 + Cos( ( MilliSecs() Mod 3600 )/10. )*100
   LightY# = 300 - Sin( ( MilliSecs() Mod 3600 )/10. )*100
   CalculateShadows( LightX#, LightY# )
   
   Wireframe MouseDown( 1 )
   
   RenderWorld
   
   Color 255, 255, 0
   Oval LightX# - 10, LightY# - 10, 20, 20
   
   ClearSurface ShadowSurf
   
   Flip 0
   WaitTimer Timer
Wend
End

Function Init()
   DrawCam = CreateCamera()
   CameraProjMode DrawCam, 2
   CameraZoom DrawCam, 2.0/Float( GWIDTH )
   CameraClsColor DrawCam, 64, 64, 64
   
   DrawPivot = CreatePivot( DrawCam )
   TurnEntity DrawPivot, 180, 0, 0
   PositionEntity DrawPivot, -GWIDTH/2., GHEIGHT/2., 100, True
   
   PolygonMesh = CreateMesh( DrawPivot )
   PolygonSurf = CreateSurface( PolygonMesh )
   EntityFX PolygonMesh, 1 + 2
   
   ShadowMesh = CreateMesh( DrawPivot )
   ShadowSurf = CreateSurface( ShadowMesh )
   EntityFX ShadowMesh, 1 + 2
End Function

Function CalculateShadows( LightX#, LightY# )
   For Polygon.TPolygon = Each TPolygon
      For i = 0 To Polygon\VertexCount*2
         Local Vertex.TVertex = Polygon\Vertex[ i Mod Polygon\VertexCount ]
         
         EdgeDP# = ( Vertex\Y# - Vertex\Succ\Y# )*( Vertex\X# - LightX# ) + ( Vertex\Succ\X# - Vertex\X# )*( Vertex\Y# - LightY# )
         
         If Triangulate Then
            V1 = AddVertex( ShadowSurf, Vertex\X#, Vertex\Y#, 0, 0.6, 0.9 )
            V2 = AddVertex( ShadowSurf, Vertex\X# + ( Vertex\X# - LightX# )*100, Vertex\Y# + ( Vertex\Y# - LightY# )*100, 0, 0.6, 0.9 )
            
            VertexColor ShadowSurf, V1, 0, 0, 0
            VertexColor ShadowSurf, V2, 0, 0, 0
            
            AddTriangle ShadowSurf, OldV1, V1, OldV2
            AddTriangle ShadowSurf, V1, V2, OldV2
         EndIf
         
         If i &gt; 0 Then
            If EdgeDP# &gt; 0 And OldEdgeDP# &lt; 0 Then
               V1 = AddVertex( ShadowSurf, Vertex\X#, Vertex\Y#, 0, 0.6, 0.9 )
               V2 = AddVertex( ShadowSurf, Vertex\X# + ( Vertex\X# - LightX# )*100, Vertex\Y# + ( Vertex\Y# - LightY# )*100, 0, 0.6, 0.9 )
               
               VertexColor ShadowSurf, V1, 0, 0, 0
               VertexColor ShadowSurf, V2, 0, 0, 0
               
               Triangulate = True
            ElseIf EdgeDP# &lt; 0 And OldEdgeDP# &gt; 0 And Triangulate Then
               Triangulate = False
               Exit
            EndIf
         EndIf
         
         OldEdgeDP# = EdgeDP#
         OldV1 = V1
         OldV2 = V2
      Next
   Next
End Function

Function CreatePolygon( X#, Y#, Width#, Height#, StepSize = 10, R = 255, G = 255, B = 255 )
   Polygon.TPolygon = New TPolygon
      Polygon\CenterX# = X#
      Polygon\CenterY# = Y#
   
   For i = 0 To 360 - StepSize
      CreateVertex( Polygon, X# + Cos( i )*Width#, Y# - Sin( i )*Height# )
      
      i = i + StepSize - 1
   Next
   
   Polygon\Vertex[ Polygon\VertexCount - 1 ]\Succ = Polygon\Vertex[ 0 ]
   
   For i = 0 To Polygon\VertexCount - 1
      Polygon\Vertex[ i ]\VertIndex = AddVertex( PolygonSurf, Polygon\Vertex[ i ]\X#, Polygon\Vertex[ i ]\Y#, 0 )
      VertexColor PolygonSurf, Polygon\Vertex[ i ]\VertIndex, R, G, B
      
      If i &gt;= 2 Then AddTriangle PolygonSurf, Polygon\Vertex[ i ]\VertIndex, Polygon\Vertex[ i - 1 ]\VertIndex, Polygon\Vertex[ 0 ]\VertIndex
   Next
End Function

Function CreateVertex( Polygon.TPolygon, X#, Y# )
   Polygon\Vertex[ Polygon\VertexCount ] = New TVertex
      Polygon\Vertex[ Polygon\VertexCount ]\X# = X#
      Polygon\Vertex[ Polygon\VertexCount ]\Y# = Y#
   
   If Polygon\VertexCount &gt; 0 Then
      Polygon\Vertex[ Polygon\VertexCount ]\Prev = Polygon\Vertex[ Polygon\VertexCount - 1 ]
      Polygon\Vertex[ Polygon\VertexCount - 1 ]\Succ = Polygon\Vertex[ Polygon\VertexCount ]
   EndIf
   
   Polygon\VertexCount = Polygon\VertexCount + 1
End Function</textarea><br><br>The problem here is that rendering of the lights themselves (and not just the shadows) is not as easy to do without an additional buffer. Since rendering to a buffer other than the backbuffer is really slow in B3D, this isn't really possible to do there, but you should be able to do it in BMax.<br><br>What you do is basically set the alpha buffer as the render target and then render all the lights by drawing a circle around the light with a color gradient going from opaque in the center to fully transparent on the outer edge. Then you render the shadow volumes like in the B3D code above. After that you set the render target back to normal, render your normal scene and you should have realtime lighting :)<br>There was a good article on this on Gamedev, but unfortunately, it seems to have 404'd. It was called "2D dynamic soft shadows", I think, so maybe you can find it elsewhere.<br><br>So yeah, if you're interested, go for it! I'd love to see this implemented in BMax. <br><br></td></tr></table><br>
<a name="1101870"></a>

<a name="1101871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >taumel</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not a pure 2D solution i'm aware of but why don't you just build/approximate the 2D geometry and extrude it in the y-axis?<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I considered that, but writing a model exporter, a 2D-to-3D mesh builder (that possibly even has to assign UVs), finding a good 3D lightmapper that supports CLI etc. just seemed like a lot of effort compared to just writing a quick 2D lightmapper myself (I mean, in total this only took about 6-8 hours <i>and</i> was fun to make :) ).<br><br>While I'm all against duplicated effort and prefer to use existing tools instead of writing my own, in this case I think adapting an existing solution would have been quite a hassle. <br><br></td></tr></table><br>
<a name="1101889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >taumel</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't get me wrong, keep on posting such things. I find such tests very interesting and beside of that it's a lot of fun you learn a lot as well but my first idea was that i would try out a lightmapper as i expect you also have to prepare at least a Photoshoplayer in order to define a scene.  Btw did you try out Beast in Unity already? <br><br></td></tr></table><br>
<a name="1102697"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AvestheFox</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> This looks amazing!<br><br>...<br><br>wait, is that Applejack from FiM in the test sketch? o.0 <br><br></td></tr></table><br>
<a name="1102776"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Noobody</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, it is. Well spotted. <br><br></td></tr></table><br>
<a name="1104264"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xcessive</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is beautiful! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
