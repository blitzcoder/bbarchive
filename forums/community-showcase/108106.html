<!DOCTYPE html><html lang="en" ><head ><title >Legend of Faerghail Remake</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Legend of Faerghail Remake</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=61" >Showcase</a>/<a href="#bottom" >Legend of Faerghail Remake</a><br><br>
<a name="1342103"></a>

<a name="1342104"></a>

<a name="1342105"></a>

<a name="1342106"></a>

<a name="1342107"></a>

<a name="1342108"></a>

<a name="1342109"></a>

<a name="1342414"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="http://www.christianhart.de/bmax/lof/loflogo.jpg"><br><br><iframe width="560" height="345" src="http://www.youtube.com/embed/Fdxv3kRQDkQ" frameborder="0" allowfullscreen></iframe><br><br>My current project beside Extrasolar is a old one - I started 8 years ago with simple Blitz3D tests and now it's becoming better and better. A remake of the old Amiga RPG "<a href="http://crpgaddict.blogspot.de/2013/11/reboot-legend-of-faerghail.html" target="_blank">Legend of Faerghail</a>" from 1990. Well, I'm getting very familar with OpenB3D now, got my shaders running and I'm still optimizing the BSP loader. At the moment I only have a few screenshots to show the progress, it's still not optimized enough to post a running demo (click images for high resolution). But a demo will follow later when I think its ok, promised.<br><br>The torchlight is actually a type 3 spotlight which looks much better than a type 2, all textures use normalmaps and I have a lot of alpha brush models and additional custom B3D models loaded in this level (the knights and the chandliers are plain B3D models (with a shader, too) while the piano and the table are precalculated in the BSP map with a lightmap assigned). I'm not using any dynamic lights except the player torch and a "ambient light torch" to lighten up very dark areas with a decent dark blue tone. The candles, the torches and the fireplaces are simple sprites, not optimized in a single surface mesh yet. The level is absolutely dark except where your "torch" lights it up or the lightmap exists, hard to describe but looks very realistic.<br> <br>The demo currently runs at 2560x1440 with 280 FPS and has been created using Microsoft Excel ;-) for the basic 2D level structure, a highly sophisticated CSV to MAP tool I wrote myself and the detailed work / compile has been done with a Netradiant fork and Q3MAP2. I'm using 105 different shaded surfaces right now but hope to decrease this number implementing a better shader cache for the BSP meshes like I already did with the B3D models. See some statistics below the screenshots.<br><br>Oh and compare the screenshots with <a href="/posts.php?topic=103075" target="_blank">my old Blitzmax Demo using DOT3 lights</a> I made two years ago, which was too colorful and limited to vertex lighting.<br><br><a href="http://www.christianhart.de/bmax/lof/openb3d_lof1.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof1t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof2.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof2t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof3.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof3t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof4.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof4t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof5.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof5t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof6.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof6t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof7.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof7t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof8.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof8t.jpg"></a> <a href="http://www.christianhart.de/bmax/lof/openb3d_lof9.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/lof/openb3d_lof9t.jpg"></a><br><br>Excel view of the level (just basic infos and height information are set)<br><a href="http://www.christianhart.de/bmax/lof/lof_excel.png" target="_blank"><img src="http://www.christianhart.de/bmax/lof/lof_excelt.png"></a><br><br>Output of my CSV2MAP tool (starting a the green square at the top, looking south). All Walls, Doors, Event fields, treasure chests and lights are places automatically by just parsing the CSV file<br><img src="http://www.christianhart.de/bmax/lof/castle1.png"><br><br>If you're interested how it's done here is the Blitz3D source of it (still hadn't time to convert this to BMAX)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Const gridsize%				= 64	; lightmap grid size
Const doorlightmapscale#	= 1.0	; lightmap map (scale)
Const doorinset%			= 48	; how many units doors are inset
Const doorframeinset%		= 32	; how many units doorframes are inset
Const secretdoorinset#		= 1.0	; how many units secret doors are inset
Const doorframesize%		= 32	; doorframe size in units (left, right, top)
Const wallscale%			= 128	; scale of a wall block in units
Const floorheight%			= 128	; scale of a floor block in units
Const ceilheight%			= 128	; scale of a ceiling block in units
Const previewscale#			= 16	; multiplicator of map preview block
Const doorlightrange%       = 64    ; lightrange of doorlights
Const doorlighty%			= 112   ; Y position of doorlight
Const doorlightmodely%		= 80    ; Y position of doorlight model
Const doorlightoffset%      = 32    ; horizontal distance from doorlight to doorlight model (in front of, away from the door)
Const doorlightoffcenter%   = 48    ; horizontal distance from doorlight to door center
Const doorlightoffheight%   = 20    ; vertical distance from doorlight to doorlight model (upwards)
Const torchlightrange%      = 64    ; lightrange of torchlights
Const torchmodely%          = 96    ; Y position of the torch model

Global factor#=previewscale*1.0/wallscale

Global minlight%,minvertexlight%,lightmapscale#
Global startx,starty,startd%,outdoor%
Global walltex$,floortex$,ceiltex$,doortex$,caulk$
Global lightmodelsource$,torchmodelsource$

Global entity%=1                    ; entity counter

Const map$="castle1"

Select map
		
	Case "castle1"
		walltex="wall/wall 0 0 0 0.125 0.125 0 0 0"
		floortex="floor/floor 0 0 0 0.125 0.125 0 0 0"
		ceiltex="ceiling/ceiling 0 0 0 0.125 0.125 0 0 0"
		doortex$="alpha/door 256 0 0 0.125 0.09375 0 0 0"
		caulk$="common/caulk 0 0 0 0.5 0.5 0 0 0"
		minlight=0
		minvertexlight=0
		lightmapscale=1.0
		outdoor=False
		startx=17
		starty=4
		startd=270
		lightmodelsource="models/light/candlewall.md3"
		torchmodelsource="models/light/torch1.md3"
		
End Select

Global csv$[9999],gold$[256],items$[256]
Global textblock$[256]

Dim LevelMatrix$(36,36)
Dim HeightMatrix%(36,36)

Type chest
	
	Field x#,y#,z#
	Field angle#
	Field id%
	
End Type

Type tree
	
	Field x#,y#,z#
	Field angle#
	Field shadow%
	
End Type

Type inn
	
	Field x#,y#,z#
	Field angle#
	
End Type

Type door
	
	Field x#,y#,z#
	Field angle#
	Field texture$
	Field spawnflags%
	Field id%
	Field targetname$
	Field v0%,v1%,v2%,v3%
	Field inset#
	Field frameinset#
	
End Type

Type event
	
	Field x#,y#,z#
	Field id%
	
End Type

Type vortex
	
	Field x#,y#,z#
	Field id%
	
End Type

Type darkness
	
	Field x#,y#,z#
	Field id%
	
End Type

Type stair
	
	Field x#,y#,z#
	Field id%
	Field targetlevel$
	Field targetposition$
	Field spawnflags%
	
End Type

Type trap
	
	Field x#,y#,z#
	Field id%
	Field spawnflags%
	
End Type

Type light
	
	Field x#,y#,z#
	Field r%,g%,b%
	Field radius#
	Field spawnflags%
	
End Type

Type lightmodel
	
	Field x#,y#,z#
	Field angle#
	Field offx#,offy#,offz#
	Field spawnflags%
	
End Type

Type torchmodel
	
	Field x#,y#,z#
	Field angle#
	Field offx#,offy#,offz#
	Field spawnflags%
	
End Type

Global LevelScale%,LevelTitle$

ms=MilliSecs()
LoadCSVLevel(map)

AppTitle LevelTitle$+" ["+LevelScale+"x"+LevelScale+"]: "+(MilliSecs()-ms)+"ms"

SaveBuffer FrontBuffer(),map$+".bmp"

WaitKey

End

Function LoadCSVLevel(file$)
	
	Local zeile$,x%,y%,cell$
	Local brush%=0,v0%,v1%,v2%,v3%
	
	; read CSV level
	Local level%=ReadFile(file+".csv")
	
	; read title line and determine Level Scale
	zeile=ReadLine(level)
	
	LevelScale=36;1+SplitCSV(zeile,";")
	LevelTitle=csv[0]
	
	; skip author line
	ReadLine(level)
	
	; read level matrix
	For y=0 To LevelScale
		
		zeile=ReadLine(level)
		
		SplitCSV(zeile,";")
		
		For x=0 To LevelScale
			
			LevelMatrix(x,y)=csv[x+1]
			HeightMatrix(x,y)=Int(csv[x+38])
			
		Next
		
	Next
	
	; write mapfile
	Local map%=WriteFile(file+".map")
	
	; worldspawn start
	WriteLine map,""
	WriteLine map,"// entity 0"
	WriteLine map,"{"
	WriteLine map,Chr$(34)+"classname"+Chr$(34)+" "+Chr$(34)+"worldspawn"+Chr$(34)
	WriteLine map,Chr$(34)+"_minlight"+Chr$(34)+" "+Chr$(34)+minlight+Chr$(34)
	WriteLine map,Chr$(34)+"_lightmapscale"+Chr$(34)+" "+Chr$(34)+lightmapscale+Chr$(34)
	WriteLine map,Chr$(34)+"_keeplights"+Chr$(34)+" "+Chr$(34)+"1"+Chr$(34)
	WriteLine map,Chr$(34)+"gridsize"+Chr$(34)+" "+Chr$(34)+gridsize+" "+gridsize+" "+gridsize+Chr$(34)
	
	Graphics LevelScale*previewscale,LevelScale*previewscale,32,2
	
	ClsColor 128,128,128 : Cls
	
	; read level matrix
	For y=0 To LevelScale-1
		
		zeile=ReadLine(level)
		SplitCSV(zeile,";")
		
		For x=0 To LevelScale-1
			
			cell=LevelMatrix(x,y)
			
			v0=(x+1)*wallscale
			v1=x*wallscale
			v2=(-y-1)*wallscale
			v3=-y*wallscale
			
			
			; ceiling and floor, caulked to non-visible sides
			If cell&lt;&gt;"W" And cell&lt;&gt;"-" And Left(cell,1)&lt;&gt;"S" Then
				
				h%=HeightMatrix(x,y)-1
				
				; ceiling
				If cell&lt;&gt;"D"  Then
					
					WriteBrush(map,brush,v0,v1,v2,v3,(wallscale+ceilheight)+(128*h),(wallscale)+(128*h),ceiltex,0,0,0,1,0,0)
					brush=brush+1
					
				EndIf
				
				; Floor
				WriteBrush(map,brush,v0,v1,v2,v3,(0),(-floorheight),floortex,1,0,0,0,0,0) : brush=brush+1
				
			EndIf
			
			; wall? build worldspawn, caulked to non-visible sides
			If cell="W" Then
				
				s1=0	; top
				s2=0	; front
				s3=0	; right
				s4=0	; bottom
				s5=0	; back
				s6=0	; left
				
				fr$="-" : If y&gt;0 Then fr=LevelMatrix(x,y-1)
				ba$="-" : If y&lt;36 Then ba=LevelMatrix(x,y+1)
				le$="-" : If x&gt;0 Then le=LevelMatrix(x-1,y)
				ri$="-" : If x&lt;36 Then ri=LevelMatrix(x+1,y)
				
				If fr&lt;&gt;"W" And fr&lt;&gt;"-" Then s2=1		; front
				If ba&lt;&gt;"W" And ba&lt;&gt;"-" Then s5=1		; back
				If ri&lt;&gt;"W" And ri&lt;&gt;"-" Then s3=1		; right
				If le&lt;&gt;"W" And le&lt;&gt;"-" Then s6=1		; left
				
				hfr%=1 : If y&gt;0 Then hfr=HeightMatrix(x,y-1)
				hba%=1 : If y&lt;36 Then hba=HeightMatrix(x,y+1)
				hle%=1 : If x&gt;0 Then hle=HeightMatrix(x-1,y)
				hri%=1 : If x&lt;36 Then hri=HeightMatrix(x+1,y)
				
				h%=HeightMatrix(x,y)
				
				For i=0 To h-1
					
					If hfr&lt;(i+1) Then s2=0
					If hba&lt;(i+1) Then s5=0
					If hri&lt;(i+1) Then s3=0
					If hle&lt;(i+1) Then s6=0
					
					WriteBrush(map,brush,v0,v1,v2,v3,wallscale*(i+1),(i*128),walltex,s1,s2,s3,s4,s5,s6) : brush=brush+1
					
				Next
				
			EndIf
			
			; create a ceiling for ground level doors
			If cell="D" And HeightMatrix(x,y)=1 Then
				
				WriteBrush(map,brush,v0,v1,v2,v3,wallscale*(1+1),(1*128),walltex,0,0,0,1,0,0) : brush=brush+1
				
			EndIf
			
			; chest
			If Left(cell,1)="X" Then
				c.chest = New chest
				c\x=(x+1)*wallscale
				c\y=-y*wallscale
				c\z=0
				c\angle=0
				c\id=Mid(cell,2,Len(cell))
				
				Select Right(cell,1)
						
					Case "D":	c\angle=0
					Case "R":	c\angle=90
					Case "U":	c\angle=180
					Case "L":	c\angle=270
						
				End Select
				
			EndIf
			
			; tree
			If Left(cell,1)="F" Then
				
				f.tree = New tree
				f\x=(x+1)*wallscale
				f\y=-y*wallscale
				f\z=0
				f\angle=0
				
				If x&gt;0 And y&gt;0 Then 
					If LevelMatrix(x-1,y-1)="W" Then f\shadow=1
				EndIf
				
				If y&gt;0 Then 
					If LevelMatrix(x  ,y-1)="W" Then f\shadow=1
					If LevelMatrix(x+1,y-1)="W" Then f\shadow=1
				EndIf
				
				If x&gt;0 Then
					If LevelMatrix(x-1,y  )="W" Then f\shadow=1
					If LevelMatrix(x-1,y+1)="W" Then f\shadow=1
				EndIf
				
				If LevelMatrix(x+1,y  )="W" Then f\shadow=1
				If LevelMatrix(x  ,y+1)="W" Then f\shadow=1
				If LevelMatrix(x+1,y+1)="W" Then f\shadow=1
				
			EndIf
			
			; inn
			If Left(cell,1)="I" Then
				
				j.inn = New inn
				j\x=(x+1)*wallscale
				j\y=-y*wallscale
				j\z=0
				j\angle=0
				
			EndIf
			
			; door or secret door
			If Left(cell,1)="D" Then
				
				d.door = New door
				d\x=(x+1)*wallscale
				d\y=-y*wallscale
				d\z=64
				d\spawnflags=1
				d\angle=0 : If LevelMatrix(x-1,y)="W" Or LevelMatrix(x+1,y)="W" Then d\angle=90
				
				angle=d\angle
				
				d\v0=v0
				d\v1=v1
				d\v2=v2
				d\v3=v3
				d\texture=doortex
				
				d\inset=doorinset
				d\frameinset=doorframeinset
				
				; secret door
				If cell="DS" Then
					
					d\spawnflags=32
					d\texture=walltex
					target=target+1
					d\targetname="secretdoor"+target
					d\inset=secretdoorinset
					d\frameinset=0
					
				EndIf
				
				; standard door
				If cell="D" Then
					
					d\targetname="door"+door
					door=door+1
					
				EndIf
				
				; doorframe
				If d\angle=0 Then
					
					WriteBrush(map,brush,v0-d\frameinset,v1+d\frameinset,v2,v3-wallscale+doorframesize,wallscale-doorframesize,0,walltex,0,1,1,0,0,1) : brush=brush+1
					WriteBrush(map,brush,v0-d\frameinset,v1+d\frameinset,v2+wallscale-doorframesize,v3,wallscale-doorframesize,0,walltex,0,0,1,0,1,1) : brush=brush+1
					WriteBrush(map,brush,v0-d\frameinset,v1+d\frameinset,v2,v3,wallscale,wallscale-doorframesize,walltex,0,0,1,1,0,1) : brush=brush+1	
					
				Else
					
					WriteBrush(map,brush,v0-wallscale+doorframesize,v1,v2+d\frameinset,v3-d\frameinset,wallscale-doorframesize,0,walltex,0,1,1,0,1,0) : brush=brush+1
					WriteBrush(map,brush,v0,v1+wallscale-doorframesize,v2+d\frameinset,v3-d\frameinset,wallscale-doorframesize,0,walltex,0,1,0,0,1,1) : brush=brush+1
					WriteBrush(map,brush,v0,v1,v2+d\frameinset,v3-d\frameinset,wallscale,wallscale-doorframesize,walltex,0,1,0,1,1,0) : brush=brush+1
					
				EndIf
				
				; wall height
				If HeightMatrix(x,y)&gt;1 Then
					
					s1=0	; top
					s2=0	; front
					s3=0	; right
					s4=1	; bottom
					s5=0	; back
					s6=0	; left
					
					fr$="-" : If y&gt;0 Then fr=LevelMatrix(x,y-1)
					ba$="-" : If y&lt;36 Then ba=LevelMatrix(x,y+1)
					le$="-" : If x&gt;0 Then le=LevelMatrix(x-1,y)
					ri$="-" : If x&lt;36Then ri=LevelMatrix(x+1,y)
					
					If fr&lt;&gt;"W" And fr&lt;&gt;"-" Then s2=1		; front
					If ba&lt;&gt;"W" And ba&lt;&gt;"-" Then s5=1		; back
					If ri&lt;&gt;"W" And ri&lt;&gt;"-" Then s3=1		; right
					If le&lt;&gt;"W" And le&lt;&gt;"-" Then s6=1		; left
					
					hfr%=1 : If y&gt;0 Then hfr=HeightMatrix(x,y-1)
					hba%=1 : If y&lt;36Then hba=HeightMatrix(x,y+1)
					hle%=1 : If x&gt;0 Then hle=HeightMatrix(x-1,y)
					hri%=1 : If x&lt;36 Then hri=HeightMatrix(x+1,y)
					
					For i=0 To HeightMatrix(x,y)-2
						
						If hfr&lt;(i+2) Then s2=0
						If hba&lt;(i+2) Then s5=0
						If hri&lt;(i+2) Then s3=0
						If hle&lt;(i+2) Then s6=0
						
						WriteBrush(map,brush,v0,v1,v2,v3,(wallscale+ceilheight)+(128*i),wallscale+(128*i),walltex,s1,s2,s3,s4,s5,s6) : brush=brush+1
						
					Next
					
				EndIf
				
			EndIf
			
            ; event field
			If Left(cell,1)="E" Then
				
				e.event = New event
				e\x=(x+1)*wallscale
				e\y=-y*wallscale
				e\z=0
				e\id=Mid(cell,2,Len(cell))
				
			End If
			
            ; darkness field
			If Left(cell,1)="L" Then
				
				ld.darkness = New darkness
				ld\x=(x+1)*wallscale
				ld\y=-y*wallscale
				ld\z=0
				ld\id=Mid(cell,2,Len(cell))
				
			End If
			
            ; vortex field
			If Left(cell,1)="Q" Then
				
				v.vortex = New vortex
				v\x=(x+1)*wallscale
				v\y=-y*wallscale
				v\z=0
				
			End If
			
            ; trap field
			If Left(cell,1)="P" Then
				
				p.trap = New trap
				p\x=(x+1)*wallscale
				p\y=-y*wallscale
				p\z=0
				p\id=Mid(cell,2,Len(cell))
				p\spawnflags=1
				
			End If
			
			; stair field
			If Left(cell,1)="S" Then
				
				s.stair = New stair
				s\x=(x+1)*wallscale
				s\y=-y*wallscale
				s\z=0
				s\id=Mid(cell,2,Len(cell))
				s\targetlevel=""
				s\targetposition=""
				
				If Right(cell,1)="U" Then s\spawnflags=1
				If Right(cell,1)="D" Then s\spawnflags=2
				
			End If
			
			; output on screen
			If cell&lt;&gt;"-" Then
				
				Color 144,144,144
				
				If cell="W" Or cell="S" Then Color 0,0,0
				
				Rect x*previewscale,y*previewscale,previewscale,previewscale,1
				
				If cell="D" Then
					
					Color 128,96,0
					
					If cell="S" Then Color 64,64,64
					
					If angle=0 Then Rect x*previewscale+(previewscale*0.3),y*previewscale,previewscale*0.4,previewscale,1
					If angle=90 Then Rect x*previewscale,y*previewscale+(previewscale*0.3),previewscale,previewscale*0.4,1
					
				EndIf
				
				If cell="DS" Then
					
					Color 0,255,255
					
					If angle=0 Then Rect x*previewscale+(previewscale*0.3),y*previewscale,previewscale*0.4,previewscale,1
					If angle=90 Then Rect x*previewscale,y*previewscale+(previewscale*0.3),previewscale,previewscale*0.4,1
					
				EndIf
				
				
				If Left(cell,1)="E" Then
					
					Color 0,64,128
					Rect x*previewscale,y*previewscale,previewscale,previewscale,1
					
				EndIf
				
				If Left(cell,1)="P" Then
					
					Color 255,0,0
					Rect x*previewscale,y*previewscale,previewscale,previewscale,1
					
				EndIf
				
				If Left(cell,1)="L" Then
					
					Color 255,51,163
					Rect x*previewscale,y*previewscale,previewscale,previewscale,1
					
				EndIf
				
				If Left(cell,1)="Q" Then
					
					Color 184,24,161
					Rect x*previewscale,y*previewscale,previewscale,previewscale,1
					
				EndIf
				
				If Left(cell,1)="S" Then
					
					Color 255,255,0
					Rect x*previewscale,y*previewscale,previewscale,previewscale,1
					
				EndIf
				
				If Left(cell,1)="I" Then
					
					Color 192,0,0
					Rect x*previewscale,y*previewscale,previewscale,previewscale,1
					
				EndIf
				
				If Left(cell,1)="F" Then
					
					Color 0,128,0
					Oval x*previewscale+(previewscale*0.1),y*previewscale+(previewscale*0.1),previewscale*0.8,previewscale*0.8,1
					
				EndIf
				
				If Left(cell,1)="X" Then
					
					Color 255,255,0
					Oval x*previewscale+(previewscale*0.25),y*previewscale+(previewscale*0.25),previewscale*0.5,previewscale*0.5,1
					
				EndIf
				
			Else
				
				Color 0,0,0
				
				Rect x*previewscale,y*previewscale,previewscale,previewscale,1
				
			EndIf
            
        Next
		
	Next
	
	If outdoor=True Then
		
		v0=wallscale*48
		v1=0
		v2=-wallscale*48
		v3=0
		
		WriteBrush(map,brush,v0,v1,v2,v3,(wallscale+ceilheight)+(128*8),(wallscale)+(128*8),ceiltex,0,0,0,1,0,0) : brush=brush+1
		
	EndIf
    
    For y=1 To LevelScale-1
		
        For x=1 To LevelScale-1
            
            cell=LevelMatrix(x,y)
			
			xm$=LevelMatrix(x-1,y)
			xp$=LevelMatrix(x+1,y)
			ym$=LevelMatrix(x,y-1)
			yp$=LevelMatrix(x,y+1)
			xd1$=LevelMatrix(x-1,y-1)
			xd2$=LevelMatrix(x+1,y-1)
			xd3$=LevelMatrix(x-1,y+1)
			xd4$=LevelMatrix(x+1,y+1)
			
			hm%=HeightMatrix(x,y)
			
			; single column with torches
			If hm&gt;1 And cell="W" And xm&lt;&gt;"W" And xp&lt;&gt;"W" And ym&lt;&gt;"W" And yp&lt;&gt;"W" And xd1&lt;&gt;"W" And xd2&lt;&gt;"W" And xd3&lt;&gt;"W" And xd4&lt;&gt;"W" Then
				
				; West
				t.torchmodel = New torchmodel
				t\x=((x+0.5)*wallscale)
				t\y=-y*wallscale
				t\z=(hm*wallscale)/2.0
				t\angle=270
				t\offx=-32-8
				t\offz=20
				
				; East
				t.torchmodel = New torchmodel
				t\x=((x+1.5)*wallscale)
				t\y=-y*wallscale
				t\z=(hm*wallscale)/2.0
				t\angle=90
				t\offx=32+8
				t\offz=20
				
				; South
				t.torchmodel = New torchmodel
				t\x=(x+1)*wallscale
				t\y=-(y+0.5)*wallscale
				t\z=(hm*wallscale)/2.0
				t\angle=0
				t\offy=-32-8
				t\offz=20
				
				; North
				t.torchmodel = New torchmodel
				t\x=(x+1)*wallscale
				t\y=-(y-0.5)*wallscale
				t\z=(hm*wallscale)/2.0
				t\angle=180
				t\offy=32+8
				t\offz=20
				
			EndIf
            
			; doorlights
			If cell="D" Then
				
				; Door X-Axis
				If xm&lt;&gt;"W" And xp&lt;&gt;"W" Then
						
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)-doorframeinset-4
					m\y=-y*wallscale-doorlightoffcenter
					m\z=doorlightmodely
					m\angle=90
					m\offx=-doorlightoffset
					m\offy=0
					m\offz=doorlightoffheight
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)-doorframeinset-4
					m\y=-y*wallscale+doorlightoffcenter
					m\z=doorlightmodely
					m\angle=90
					m\offx=-doorlightoffset
					m\offy=0
					m\offz=doorlightoffheight
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)+doorframeinset+4
					m\y=-y*wallscale-doorlightoffcenter
					m\z=doorlightmodely
					m\angle=270
					m\offx=doorlightoffset
					m\offy=0
					m\offz=doorlightoffheight
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)+doorframeinset+4
					m\y=-y*wallscale+doorlightoffcenter
					m\z=doorlightmodely
					m\angle=270
					m\offx=doorlightoffset
					m\offy=0
					m\offz=doorlightoffheight
					
				EndIf
				
				; Door Y-Axis
				If ym&lt;&gt;"W" And yp&lt;&gt;"W" Then
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)-doorlightoffcenter
					m\y=-y*wallscale+doorframeinset+4
					m\z=doorlightmodely
					m\angle=0
					m\offx=0
					m\offy=doorlightoffset
					m\offz=doorlightoffheight
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)+doorlightoffcenter
					m\y=-y*wallscale+doorframeinset+4
					m\z=doorlightmodely
					m\angle=0
					m\offx=0
					m\offy=doorlightoffset
					m\offz=doorlightoffheight
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)-doorlightoffcenter
					m\y=-y*wallscale-doorframeinset-4
					m\z=doorlightmodely
					m\angle=180
					m\offx=0
					m\offy=-doorlightoffset
					m\offz=doorlightoffheight
					
					m.lightmodel = New lightmodel
					m\x=((x+1)*wallscale)+doorlightoffcenter
					m\y=-y*wallscale-doorframeinset-4
					m\z=doorlightmodely
					m\angle=180
					m\offx=0
					m\offy=-doorlightoffset
					m\offz=doorlightoffheight
					
				EndIf
				
			EndIf
            
        Next
        
    Next
	
	; worldspawn end
	WriteLine map,"}"
	
	; write chest entities
	For c.chest = Each chest
		
		WriteEntity(map,entity,"misc_gamemodel",c\x,c\y,c\z,c\angle,"model","models/chest/chest.md3","modelscale",1,"spawnflags",16)
		entity=entity+1
		
	Next
	
	; write tree entities
	For f.tree = Each tree
		
		If f\shadow=0 Then
			WriteEntity(map,entity,"misc_gamemodel",f\x,f\y,f\z,0,"model","models/tree/tree.md3","modelscale",256)
		Else
			WriteEntity(map,entity,"misc_gamemodel",f\x,f\y,f\z,0,"model","models/tree/tree.md3","modelscale",256,"_cs",1)
		EndIf
		entity=entity+1
		
	Next
	
	; write inn entities
	For j.inn = Each inn
		
		WriteEntity(map,entity,"misc_gamemodel",j\x,j\y,j\z,0,"model","models/haus/haus.md3","modelscale",256,"_cs",1,"spawnflags",8)
		entity=entity+1
		
	Next
	
	For d.door = Each door
		
		WriteDoorEntity(map,entity,d\spawnflags,d\texture,d\inset,d\x,d\y,d\z,d\angle,d\v0,d\v1,d\v2,d\v3,d\angle,"spawnflags",d\spawnflags,"targetname",d\targetname)
		entity=entity+1
		
	Next
	
	For e.event = Each event
		
		WriteEntity(map,entity,"info_event",e\x,e\y,e\z,0,"id",Int(e\id))
		entity=entity+1
		
	Next
	
	For ld.darkness = Each darkness
		
		WriteEntity(map,entity,"info_darkness",ld\x,ld\y,ld\z,0)
		entity=entity+1
		
	Next
	
	For v.vortex = Each vortex
		
		WriteEntity(map,entity,"info_vortex",v\x,v\y,v\z,0)
		entity=entity+1
		
	Next
	
	For p.trap = Each trap
		
		WriteEntity(map,entity,"info_trap",p\x,p\y,p\z,0,"id",Int(p\id),"spawnflags",p\spawnflags)
		entity=entity+1
		
	Next
	
	For s.stair = Each stair
		
		WriteEntity(map,entity,"info_stair",s\x,s\y,s\z,0,"id",Int(s\id),"spawnflags",s\spawnflags,"targetlevel",s\targetlevel,"targetposition",s\targetposition)
		entity=entity+1
		
	Next
	
	For m.lightmodel = Each lightmodel
		
		WriteEntity(map,entity,"misc_gamemodel",m\x,m\y,m\z,m\angle,"model",lightmodelsource,"spawnflags",1)
		entity=entity+1
		
		r=255 * 1.0
		g=255 * 0.8
		b=255 * 0.6
		sf=0
		
		WriteEntity(map,entity,"light",m\x+m\offx,m\y+m\offy,m\z+m\offz,0,"_color",(r/255.0)+" "+(g/255.0)+" "+(b/255.0),"spawnflags",sf,"light",doorlightrange)
		entity=entity+1
		
		Color r,g,b
		Oval ((m\x-64-doorlightrange/2.0)/128.0)*previewscale,((-m\y+64-doorlightrange/2.0)/128.0)*previewscale,doorlightrange*factor,doorlightrange*factor,0
		
	Next
	
	For t.torchmodel = Each torchmodel
		
		WriteEntity(map,entity,"misc_gamemodel",t\x,t\y,t\z,t\angle,"model",torchmodelsource,"spawnflags",1)
		entity=entity+1
		
		r=255 * 1.0
		g=255 * 0.8
		b=255 * 0.6
		sf=0
		
		WriteEntity(map,entity,"light",t\x+t\offx,t\y+t\offy,t\z+t\offz,0,"_color",(r/255.0)+" "+(g/255.0)+" "+(b/255.0),"spawnflags",sf,"light",torchlightrange)
		entity=entity+1
		
		Color r,g,b
		Oval ((t\x-64-torchlightrange/2.0)/128.0)*previewscale,((-t\y+64-torchlightrange/2.0)/128.0)*previewscale,torchlightrange*factor,torchlightrange*factor,0
		
	Next
	
	xx=startx
	yy=starty
	zz=36
	rr=startd
	
	WriteEntity(map,entity,"info_player_start",(xx+1)*wallscale,-(yy*wallscale),zz,rr)
	
	Color 0,255,0
	Rect xx*previewscale+(previewscale/4),yy*previewscale+(previewscale/4),previewscale/2,previewscale/2,1
	
	CloseFile map
	
End Function

Function WriteDoorEntity(stream%,entity%,flags$=0,texture$,inset#,x#,y#,z#,a#,v0%,v1%,v2%,v3%,rotation%=0,opt1$="",val1$="",opt2$="",val2$="",opt3$="",val3$="",opt4$="",val4$="")
	
	Local q1$=Chr$(34)
	Local q2$=Chr$(34)+" "+Chr$(34)
	Local sd%
	
	Local x1$=FILLZERO(x-(wallscale/2.0),6)
	Local y1$=FILLZERO(y-(wallscale/2.0),6)
	Local z1$=FILLZERO(z,6)
	Local a1$=FILLZERO(a,6)
	
	WriteLine stream,"// entity "+entity
	WriteLine stream,"{"
	WriteLine stream,q1+"classname"+q2+"func_door"+q1
	WriteLine stream,q1+"position"+q2+x1+" "+y1+" "+z1+q1
	WriteLine stream,q1+"rotation"+q2+a1+q1
	;WriteLine stream,q1+"_lightmapscale"+q2+doorlightmapscale+q1
	If opt1&lt;&gt;"" Then WriteLine stream,q1+opt1+q2+val1+q1
	If opt2&lt;&gt;"" Then WriteLine stream,q1+opt2+q2+val2+q1
	If opt3&lt;&gt;"" Then WriteLine stream,q1+opt3+q2+val3+q1
	If opt4&lt;&gt;"" Then WriteLine stream,q1+opt4+q2+val4+q1
	
	; 1=top
	; 2=front
	; 3=right
	; 4=bottom
	; 5=back
	; 6=left
	
	If Int(flags) And 32 Then sd=1 Else sd=0
	
	If rotation=0 Then
		
		WriteBrush(stream,0,v0-inset,v1+inset,v2+doorframesize,v3-doorframesize,wallscale-doorframesize,0,texture,0,0,1,sd,0,1)
		
	Else
		
		WriteBrush(stream,0,v0-doorframesize,v1+doorframesize,v2+inset,v3-inset,wallscale-doorframesize,0,texture,0,1,0,sd,1,0)
		
	EndIf
	
	WriteLine stream,"}"
	
End Function

Function WriteBrush(stream%,brush%,v0#,v1#,v2#,v3#,v4#,v5#,suf$,s1%=1,s2%=1,s3%=1,s4%=1,s5%=1,s6%=1)
	
	Local i%,suffix$[6]
	
	For i=1 To 6 : suffix[i]=caulk : Next
	
	If s1=1 Then suffix[1]=suf		; top
	If s2=1 Then suffix[2]=suf		; front
	If s3=1 Then suffix[3]=suf		; right
	If s4=1 Then suffix[4]=suf		; bottom
	If s5=1 Then suffix[5]=suf		; back
	If s6=1 Then suffix[6]=suf		; left
	
	WriteLine stream,"// brush "+brush
	WriteLine stream,"{"
	WriteLine stream,"( "+v0+" "+v3+" "+v4+" ) ( "+v0+" "+v2+" "+v4+" ) ( "+v1+" "+v3+" "+v4+" ) "+suffix[1]
	WriteLine stream,"( "+v0+" "+v3+" "+v4+" ) ( "+v1+" "+v3+" "+v4+" ) ( "+v0+" "+v3+" "+v5+" ) "+suffix[2]
	WriteLine stream,"( "+v0+" "+v3+" "+v4+" ) ( "+v0+" "+v3+" "+v5+" ) ( "+v0+" "+v2+" "+v4+" ) "+suffix[3]
	WriteLine stream,"( "+v1+" "+v2+" "+v5+" ) ( "+v0+" "+v2+" "+v5+" ) ( "+v1+" "+v3+" "+v5+" ) "+suffix[4]
	WriteLine stream,"( "+v1+" "+v2+" "+v5+" ) ( "+v1+" "+v2+" "+v4+" ) ( "+v0+" "+v2+" "+v5+" ) "+suffix[5]
	WriteLine stream,"( "+v1+" "+v2+" "+v5+" ) ( "+v1+" "+v3+" "+v5+" ) ( "+v1+" "+v2+" "+v4+" ) "+suffix[6]
	WriteLine stream,"}"
	
End Function

Function WriteEntity(stream%,entity%,classname$,x#,y#,z#,angle=0,opt1$="",val1$="",opt2$="",val2$="",opt3$="",val3$="",opt4$="",val4$="",opt5$="",val5$="",opt6$="",val6$="")
	
	Local q1$=Chr$(34)
	Local q2$=Chr$(34)+" "+Chr$(34)
	
	Local x1$=FILLZERO(x-(wallscale/2.0),6)
	Local y1$=FILLZERO(y-(wallscale/2.0),6)
	Local z1$=FILLZERO(z,6)
	Local a1$=FILLZERO(angle,6)
	
	WriteLine stream,"// entity "+entity
	WriteLine stream,"{"
	WriteLine stream,q1+"classname"+q2+classname+q1
	WriteLine stream,q1+"origin"+q2+x1+" "+y1+" "+z1+q1
	WriteLine stream,q1+"angle"+q2+a1+q1
	If opt1&lt;&gt;"" And val1&lt;&gt;"" Then WriteLine stream,q1+opt1+q2+val1+q1
	If opt2&lt;&gt;"" And val2&lt;&gt;"" Then WriteLine stream,q1+opt2+q2+val2+q1
	If opt3&lt;&gt;"" And val3&lt;&gt;"" Then WriteLine stream,q1+opt3+q2+val3+q1
	If opt4&lt;&gt;"" And val4&lt;&gt;"" Then WriteLine stream,q1+opt4+q2+val4+q1
	If opt5&lt;&gt;"" And val5&lt;&gt;"" Then WriteLine stream,q1+opt5+q2+val5+q1
	If opt6&lt;&gt;"" And val6&lt;&gt;"" Then WriteLine stream,q1+opt6+q2+val6+q1
	WriteLine stream,"}"
	
End Function

Function FILLZERO$(number#,aft%=0,pre%=0)
	
	Local i%,f#,rf$,ri$,lf%,li%,j%,l%
	
	; split to int and float value
	i=Int(Float(number))
	ri=Str(i)
	f=Float(number-i)
	
	; check if negative value
	If i&lt;0 Then l=4 Else l=3
	
	; grab float value
	rf=Mid(Str(f),l,Len(f))
	lf=aft-Len(rf)
	li=pre-Len(Str(i))
	
	; add zeros
	For j=0 To lf-1 : rf=rf+"0" : Next
	For j=0 To li-1 : ri=ri+"0" : Next
	
	If aft&gt;0 Then
		
		; return int/float strings
		Return ri+"."+rf
		
	Else
		
		Return ri
		
	EndIf
	
End Function

; splits a string using a delimiter into a blitzarray
Function SplitCSV%(txt$,delimiter$)
	
	Local p%=0,i%,part$
	
	csv[p]=""
	
	txt=Replace(txt,Chr$(34),"")
	
	
	For i=1 To Len(txt)
		
		part=Mid$(txt,i,1)
		If part=delimiter$ Then p=p+1 : csv[p]="" Else csv[p]=csv[p]+part
		
	Next
	
	Return p
	
End Function</textarea><br>You can download the <a href="http://www.christianhart.de/bmax/lof/castle1.xlsx" target="_blank">Excel Map</a> and the <a href="http://www.christianhart.de/bmax/lof/castle1.csv" target="_blank">CSV Output</a>.<br><br>Netradiant view of the level<br><a href="http://www.christianhart.de/bmax/lof/lof_netradiant.png" target="_blank"><img src="http://www.christianhart.de/bmax/lof/lof_netradiantt.png"></a><br><br>BSP Size: 6.820.596 Bytes<br><br>Parsing BSP Entities...<br>   1 worldspawn<br> 249 misc_gamemodel<br>  46 func_door<br>  67 info_event<br>   3 info_darkness<br>   3 info_vortex<br>   3 info_trap<br>   4 info_stair<br> 266 light<br>   1 info_player_start<br>   3 fireplace<br>   9 info_candle<br>  10 func_brush<br> 665 Entities found.<br><br>Final Map statistics:<br>Total BSP Surfaces: 94<br>Total BSP Vertices: 136149<br>Total BSP Triangles: 45383<br>Total BSP Models: 57<br>Solid BSP Level Meshes: 7<br>Alpha BSP Level Meshes: 50<br>Level Shaders: 94<br>Ingame Models (unique): 8<br>Ingame Models (reused): 241 in Instances<br>Model Shaders (unique): 11<br>Model Shaders (reused): 274<br>Torch Sprites: 16<br>Candle Sprites: 257<br>Fireplace Sprites: 3<br>Parse Time: 831ms<br>Assemble Time: 189ms<br>Total Build Time: 1020ms <br><br></td></tr></table><br>
<a name="1342114"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can't wait to see a demo(you know I love your work) ;-) <br><br></td></tr></table><br>
<a name="1342119"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ian Thompson</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Look great Krischan, very atmospheric! <br><br></td></tr></table><br>
<a name="1342152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fantastic <br><br></td></tr></table><br>
<a name="1342173"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow!<br><br>Is OpenB3D a version of MiniB3D for BMax? <br><br></td></tr></table><br>
<a name="1342197"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like it, it reminds me of Thief 1/2 ambiance (with better graphics) <br><br></td></tr></table><br>
<a name="1342208"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking good :) <br><br></td></tr></table><br>
<a name="1342213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chalky</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Incredible - looks amazing! <br><br></td></tr></table><br>
<a name="1342214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> looking forward to seeing this :) <br><br></td></tr></table><br>
<a name="1342237"></a>

<a name="1342238"></a>

<a name="1342241"></a>

<a name="1342244"></a>

<a name="1342245"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @therevills: well, at least it shares the same syntax. If you know miniB3D you can get into OpenB3D very quick, too.<br><br>Thanks for the comments, I really appreciate your feedback. But currently I'm desperate because I can only use one lightmap using shaders. To speed things up I implemented a shadercache and it works really good but see yourself:<br><br>Brushtexture Lightmap<br><img src="http://www.christianhart.de/bmax/lof/lof_lightmap_ok.jpg"><br><br>Shader Lightmap<br><img src="http://www.christianhart.de/bmax/lof/lof_lightmap_broken.jpg"><br><br>With the "classic" brush to surface method the lightmap (which consists of two separate textures stored in the BSP_LightmapHandle[BSP_FaceLightmap[i], 0] handle) aligns perfect. BSP_FaceLightmap[i] stores the index [0...x] of the lightmap and the BSP_LightmapHandle[] stores the corresponding texture loaded. If I uncomment the last line with "ShadeSurface" command the lightmap is broken, it looks like only Lightmap index 0 is applied while there are 0 and 1.<br><br>The problem can be "bypassed" increasing the lightmapsize so that only one lightmap exists but this is only a temporary workaround and no solution I'd prefer.<br><br>I really don't get it where the problem is, do you have an idea what I've missed here? I don't understand why the brush works and the shader doesn't even they are both using the same variables set before.<br><br>I've added the BSP shaders, too. There, the "lmCoords" variable holds the Texture Coordinates (Set 1) and the "lightMap" variable in the fragment shader the lightmap texture set in the shader. I'm not sure if I implemented this correct, I couldn't find any example in the OpenB3D package so I had to perform try and error until it worked.<br><br>The Mesh Assemble Method from my BSP loader<br><pre class=code>	' --------------------------------------------------------------------------------
	' assemble map submodel
	' --------------------------------------------------------------------------------
	Method Q3BSP_AssembleModel:Int(num:Int)
	
		Local i:Int, t:Int, surf:TSurface, e:Int, newsurf:Int, texname:String
		Local index:Int, indexb:Int, indexc:Int, indexd:Int
		Local V0:Int, V1:Int, V2:Int
		Local sx:Float, sy:Float, sz:Float
		Local texture:TTexture
		Local normalmap:TTexture
		Local lightmap:TTexture
		
		Local brush:TBrush
		
		Local Class:Int = Null
	
		BSP_Model[num] = CreateMesh()
								
		For i = BSP_ModelFacestart[num] To BSP_ModelFaceend[num]
		
			texname = BSP_TextureName[BSP_FaceTexture[i]]
			
			' Flag for Alpha Models
			If Instr(texname, "alpha") Then Class = 1
		
			' skip skybox
			If (Not Instr(texname, "sky")) Then
			
				' always create a new surface
				newsurf = 1
				
				lightmap = BSP_LightmapHandle[BSP_FaceLightmap[i], 0]
							
				' or recycle available surfaces
				For t = 1 To BSP_SurfaceCount[num]
								
					' Texture and Lightmap match? recycle!
					If BSP_SurfaceTexture[t] = BSP_FaceTexture[i] And BSP_SurfaceLightmap[t] = BSP_FaceLightmap[i] Then
					
						surf = GetSurface(BSP_model[num], t)						
						newsurf = 0
						Exit
					
					EndIf
				
				Next
								
				' still new surface?
				If newsurf Then
				
					brush = CreateBrush()
				
					' create a new surface
					surf = CreateSurface(BSP_Model[num], brush)
					BSP_SurfaceCount[num] = BSP_SurfaceCount[num] + 1
					BSP_SurfaceTexture[BSP_SurfaceCount[num]] = BSP_FaceTexture[i]
					BSP_SurfaceLightmap[BSP_SurfaceCount[num]] = BSP_FaceLightmap[i]
				
				EndIf

				' set faceindex start
				index = BSP_FaceVertex[i]
			
				' build the mesh
				For e = BSP_FaceMeshVertex[i] To BSP_FaceMeshVertex[i] + BSP_FaceMeshNumber[i] - 1 Step 3
				
					indexb = index + BSP_MeshVertexOffset[e + 0]
					indexc = index + BSP_MeshVertexOffset[e + 1]
					indexd = index + BSP_MeshVertexOffset[e + 2]
				
					' position correction
					sx = -BSP_ModelBoxXstart[num] - (BSP_ModelScaleX[num] / 2.0)
					sy = -BSP_ModelBoxYstart[num] - (BSP_ModelScaleY[num] / 2.0)
					sz = -BSP_ModelBoxZstart[num] - (BSP_ModelScaleZ[num] / 2.0)
				
					' vertices
					V0 = AddVertex(surf, BSP_VertexCoordX[indexb] + sx, BSP_VertexCoordZ[indexb] + sy, BSP_VertexCoordY[indexb] + sz, BSP_VertexTexCoordU[indexb], BSP_VertexTexCoordV[indexb])
					V1 = AddVertex(surf, BSP_VertexCoordX[indexc] + sx, BSP_VertexCoordZ[indexc] + sy, BSP_VertexCoordY[indexc] + sz, BSP_VertexTexCoordU[indexc], BSP_VertexTexCoordV[indexc])
					V2 = AddVertex(surf, BSP_VertexCoordX[indexd] + sx, BSP_VertexCoordZ[indexd] + sy, BSP_VertexCoordY[indexd] + sz, BSP_VertexTexCoordU[indexd], BSP_VertexTexCoordV[indexd])
				
					' vertex colors
					VertexColor surf, V0, BSP_VertexRed[indexb], BSP_VertexGreen[indexb], BSP_VertexBlue[indexb]
					VertexColor surf, V1, BSP_VertexRed[indexc], BSP_VertexGreen[indexc], BSP_VertexBlue[indexc]
					VertexColor surf, V2, BSP_VertexRed[indexd], BSP_VertexGreen[indexd], BSP_VertexBlue[indexd]

					' vertex normals
					VertexNormal surf, V0, BSP_VertexNX[indexb], BSP_VertexNZ[indexb], BSP_VertexNY[indexb]
					VertexNormal surf, V1, BSP_VertexNX[indexc], BSP_VertexNZ[indexc], BSP_VertexNY[indexc]
					VertexNormal surf, V2, BSP_VertexNX[indexd], BSP_VertexNZ[indexd], BSP_VertexNY[indexd]

					' second coordinate set (lightmap)
					VertexTexCoords surf, V0, BSP_VertexLightmapCoordU[indexb], BSP_VertexLightmapCoordV[indexb], 1, 1
					VertexTexCoords surf, V1, BSP_VertexLightmapCoordU[indexc], BSP_VertexLightmapCoordV[indexc], 1, 1
					VertexTexCoords surf, V2, BSP_VertexLightmapCoordU[indexd], BSP_VertexLightmapCoordV[indexd], 1, 1
					
					' combine vertices to triangles				
					AddTriangle(surf, V0, V1, V2)
			
				Next

				' set second UV set for lightmap texture coordinates
				TextureCoords lightmap, 1

				' check for texture
				For Local tx:TBSPTexture = EachIn TBSPTexture.list

					' texture found?
					If tx.Name = texname Then
															
						' prepare for shader use
						texture = tx.id
						normalmap = tx.nm

						' has the shader already been used before?
						If MapValueForKey(ShaderCache, tx.id) Then
												
							sc = TBSPshadercache(MapValueForKey(ShaderCache, tx.id))
							ShaderCacheReused:+1
						
						Else
						
							sc = New TBSPshadercache
					
							' Create the Shader from the preloaded files to speed this up
							sc.shader = CreateShader("", BSP_VertShader, BSP_FragShader)
							SetFloat4(sc.shader, "tangent", 1.0, 1.0, 1.0, 1.0)
							SetFloat3(sc.shader, "emission", 0.015, 0.015, 0.015)
							SetFloat(sc.shader, "attspec", 0.0025)
							SetFloat3(sc.shader, "fogColor", FogColor[0], FogColor[1], FogColor[2])
					
							' different specularity for alpha models
							If Class = 1 Then SetFloat(sc.shader, "attspec", 0.005)

							' Apply Level Shader
							ShaderTexture(sc.shader, texture, "diffuseMap", 0)
							ShaderTexture(sc.shader, normalmap, "normalMap", 1)
							ShaderTexture(sc.shader, lightmap, "lightMap", 2)
																	
							' count shaders
							ShaderCacheUnique:+1
							
							' store Type for shader recycling
							MapInsert(ShaderCache, tx.id, sc)
						
						EndIf
						
					EndIf

				Next
				
				' old method to paint the surface with a brush (works)
				BrushTexture brush, lightmap
				PaintSurface surf, brush
				
				' new method to paint the surface with a shader (broken)
				ShadeSurface(surf, sc.shader)

			EndIf
					
		Next
						
		Return Class
	
	End Method</pre><br><br>The Vertex Shader<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">// en.wikibooks.org/wiki/GLSL_Programming/Blender/Lighting_of_Bumpy_Surfaces
// by Ferret

uniform vec4 tangent;
varying mat3 localSurface2View;
varying vec4 texCoords;
varying vec4 lmCoords;
varying vec4 position;

void main()
{
		
	localSurface2View[0] = normalize(vec3(gl_ModelViewMatrix * vec4(vec3(tangent), 0.0)));
	localSurface2View[2] = normalize(gl_NormalMatrix * gl_Normal);
	localSurface2View[1] = normalize(cross(localSurface2View[2], localSurface2View[0]));

	texCoords = gl_MultiTexCoord0;
	lmCoords = gl_MultiTexCoord2;
	position = gl_ModelViewMatrix * gl_Vertex;
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
	
}</textarea><br><br>The Fragment Shader<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">// en.wikibooks.org/wiki/GLSL_Programming/Blender/Lighting_of_Bumpy_Surfaces
// by Ferret

#define NUM_LIGHTS 2
varying mat3 localSurface2View;
varying vec4 texCoords;
varying vec4 lmCoords;
varying vec4 position;
uniform vec3 emission;
uniform float attspec;
uniform sampler2D colorMap;
uniform sampler2D normalMap;
uniform sampler2D lightMap;
uniform vec3 fogColor;

uniform float lightningshaderintensity;
uniform float torchintensity;

void main()
{

	vec4 encodedNormal = texture2D(normalMap, vec2(texCoords)); 
	vec4 base = texture2D(colorMap, vec2(texCoords));
	vec4 lm = texture2D(lightMap, vec2(lmCoords));
	
	//lm *= 2.0;
			
	vec3 localCoords = normalize(vec3(2.0, 2.0, 1.0) * vec3(encodedNormal) - vec3(1.0, 1.0, 0.0)); 
	vec3 normalDirection = normalize(localSurface2View * localCoords);

	vec3 viewDirection = -normalize(vec3(position)); 
	vec3 lightDirection;
	float attenuation;
	
	vec3 totalLighting = (vec3(gl_LightModel.ambient) * emission);
	
	for (int i = 0;i &lt; NUM_LIGHTS;i++)
	{
		if (0.0 == gl_LightSource[i].position.w)
		{
			attenuation = 1.0;
			lightDirection = normalize(vec3(gl_LightSource[i].position));
		} 
		else // point light or spotlight (or other kind of light) 
		{
			vec3 positionToLightSource = vec3(gl_LightSource[i].position - position);
			float distance = length(positionToLightSource);
			float lightdist = gl_LightSource[i].constantAttenuation
				+ (gl_LightSource[i].linearAttenuation * distance)
				+ (gl_LightSource[i].quadraticAttenuation * sqrt(distance));

			attenuation = 1.0 / lightdist;
			lightDirection = normalize(positionToLightSource);

			if (gl_LightSource[i].spotCutoff &lt;= 100.0)
			{
				float clampedCosine = max(0.0, dot(-lightDirection, gl_LightSource[i].spotDirection));
				
				if (clampedCosine &lt; gl_LightSource[i].spotCosCutoff)
				{
					attenuation = 0.0;
				}
				else
				{
					attenuation = attenuation * pow(clampedCosine, gl_LightSource[i].spotExponent);   
				}
			}
		}

		vec3 ambientLighting = ((vec3(gl_LightModel.ambient) * emission) + lm);

		vec3 diffuseReflection = attenuation
			* vec3(gl_LightSource[i].diffuse)
			* emission
			* max(0.0, dot(normalDirection, lightDirection));
 
		vec3 specularReflection;
		if (dot(normalDirection, lightDirection) &lt; 0.0)
		{
			specularReflection = vec3(0.0, 0.0, 0.0); 
		}
		else
		{
			specularReflection = vec3(attenuation * attspec)
				* vec3(gl_LightSource[i].specular)
				* vec3(gl_FrontMaterial.specular)
				* pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)),
				gl_FrontMaterial.shininess);
		}

		totalLighting += (ambientLighting * vec3(base) + diffuseReflection * vec3(base) + specularReflection) * (1.0 / NUM_LIGHTS);
	}

	// fog
	float dist = distance(position, vec4(0.0, 0.0, 0.0, 1.0));
	float density = (dist / 500.0) * 0.5;
	const float e = 2.71828;
	float fogFactor = (density * gl_FragCoord.z);
	fogFactor *= fogFactor;
	fogFactor = clamp(pow(e, -fogFactor), 0.0, 1.0);
	totalLighting = mix(fogColor, totalLighting, fogFactor);

	totalLighting = vec3(lm.r, lm.g, lm.b);
		
	// lightning strike
	if (lightningshaderintensity &gt; 0.0)
	{		
		float luminance = 0.2126 * totalLighting.r + 0.7152 * totalLighting.g + 0.0722 * totalLighting.b;
		totalLighting.r = max(totalLighting.r, luminance * lightningshaderintensity*(2.0*fogFactor));
		totalLighting.g = max(totalLighting.g, luminance * lightningshaderintensity*(2.0*fogFactor));
		totalLighting.b = max(totalLighting.b, luminance * lightningshaderintensity*(2.0*fogFactor));
	}

	gl_FragColor = vec4(totalLighting*torchintensity, base.a);
}</textarea> <br><br></td></tr></table><br>
<a name="1342250"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks great!<br><br>Would a transition to BMX help to speed things up a bit? <br><br></td></tr></table><br>
<a name="1342252"></a>

<a name="1342253"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ehm Grisu, this IS already done in BMX :-p <br><br></td></tr></table><br>
<a name="1342254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh... so you already support DirectX11 as well? <br><br></td></tr></table><br>
<a name="1342272"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> No, OpenB3D is based on OpenGL. As you can read here: <a href="https://sourceforge.net/projects/minib3d/" target="_blank">https://sourceforge.net/projects/minib3d/</a><br><br>"OpenB3d is a library that allows easy access to 3d features of OpenGL, and quick game development" <br><br></td></tr></table><br>
<a name="1342320"></a>

<a name="1342321"></a>

<a name="1342375"></a>

<a name="1342376"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work Krischan! <br><br>I'm not really familiar with BSP but did you consider using something like distance to determine which lightmap is used for each area?<br><br>I'm not sure how far on Kfprimm is with it now but MaxB3d has both DX and GL drivers. <br><br></td></tr></table><br>
<a name="1342401"></a>

<a name="1342402"></a>

<a name="1342403"></a>

<a name="1342405"></a>

<a name="1342407"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mark, I don't understand what you mean with the "lightmap distance". I think it is either a logical problem I've overseen in the Method I've posted how to apply the lightmap to the shader or a problem within the shader itself. As I wrote, the BrushTexture/Paintsurface stuff works fine, so I guess the Method is ok.<br><br>BSP is a very simple file format, the faces are indexed with a lightmap index ID and the lightmap UVs are stored together with the vertices using the second texture coordinate set, nothing special here. It could be the call of the Texturecoordinates in the vertex shader but I'm not very experienced in GLSL shader programming yet to debug this on my own. I've already read tons of tutorials and documentation but couldn't really find a solution for this problem.<br><br>Oh by the way - walking through the level looks much better than the screenshots can show :-D I still need to add some features, embed everything in my MaxGUI Framework and add other props but anyway I made a short sneak preview clip running through a part of the level (I hope you don't get dizzy of the unoptimized camera movement and the 115 FOV :-) The video is limited to 30FPS while the demo could run up to 280FPS currently. I didn't implement any timing yet, so this is plain spaghetti code :-D But in this video you should clearly see all Shader effects done with OpenB3D (the Torchlight / Bumpmapping and the Lightning strikes and even the fireplace animation is a spritesheet passed to a shader). The hardest part are good normal maps like the floor texture while I'm not very happy with the wall and the ceiling but that's the best I found so far.<br><br>Legend of Faerghail Sneak Preview (the demo looks much better than this video, I don't know why my youtube uploads always look messy compared to the original)<br><iframe width="560" height="345" src="http://www.youtube.com/embed/Fdxv3kRQDkQ" frameborder="0" allowfullscreen></iframe><br><br>For the engine I think I'll stay with OpenGL as it is a open standard and works on Linux and MacOS, too. And so I would really appreciate if OpenB3D gets developed further. IMHO it is a real successor of miniB3D and the first easy to use 3D engine for Blitzmax since then :-) <br><br></td></tr></table><br>
<a name="1342406"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work !!! <br><br></td></tr></table><br>
<a name="1342409"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome video! - The footsteps sound a bit strange though. <br><br></td></tr></table><br>
<a name="1342410"></a>

<a name="1342415"></a>

<a name="1342418"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> By the way - here is an example how I upscaled the Amiga "texture" to use it in my engine. I want the original art of the game but more polished without losing the original texture character. So I experimented a long time and came up with this 6-step process. I started with a rip of the original image from WinUAE:<br><br>1. Original "Texture" 120x119 Pixel<br><img src="http://www.christianhart.de/bmax/lof/1_wall_source.png"><br><br>2. Upscaled using <a href="https://forums.rpgmakerweb.com/index.php?threads/image-resizer-specially-for-upscaling-pixel-art.45856/" target="_blank">ImageResizer</a> and its XBR 4x filter applied (2x) and downsized it from 1920x1920 to 1024x1024 Pixel<br><img src="http://www.christianhart.de/bmax/lof/2_wall_xbr.png"><br><br>3. Running my 1st Photoshop Action script to improve it further<br><img src="http://www.christianhart.de/bmax/lof/3_wall_1stpass.png"><br><br>4. Running my 2nd Photoshop Action script to add more details<br><img src="http://www.christianhart.de/bmax/lof/4_wall_2ndpass.png"><br><br>5. Adding details / ageing using <a href="http://spiralgraphics.biz" target="_blank">Genetica 4.0 (Basic Edition)</a> and some trim textures from <a href="http://www.textures.com" target="_blank">textures.com</a> (this is the final Diffusemap). I'm sure you can achieve similar effects using the free <a href="https://sourceforge.net/projects/neotextureedit/?source=typ_redirect" target="_blank">Neo Texture Edit</a> tool.<br><img src="http://www.christianhart.de/bmax/lof/5_wall_diffusemap.png"><br><br>6. Creating a Normalmap from this Diffusemap with the free <a href="http://cpetry.github.io/NormalMap-Online/" target="_blank">NormalMap-Online</a> tool<br><img src="http://www.christianhart.de/bmax/lof/6_wall_normalmap.png"><br><br>Easy, huh? ;-) <br><br></td></tr></table><br>
<a name="1342411"></a>

<a name="1342412"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> The footstep is a mix of the original footstep sound from the Amiga remastered in Stereo. I think it sounds strange to you because of the 30 FPS recording (the timing code playing the sample doesn't match the movement correctly below 60 FPS). I think in a final game you could choose between the Retro sounds and optimized sounds :-D <br><br></td></tr></table><br>
<a name="1342421"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh sorry, I am a bit rusty with GL currently having been away from coding for many months, so please ignore my lightmap distance suggestion!<br><br>I've never looked at ShadeSurface, so don't have anything to say, perhaps you should define texcoords 1 in the shader? It could also be a bug, as I remember there are some.<br><br>Have you been using the version by DruggedBunny or Spinduluz? I will probably take a month or two to get round to an update.<br><br>Thanks for the video, the bumpmap is looking good! I wish you success for it. Also thanks for the how-to information! <br><br></td></tr></table><br>
<a name="1342441"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >degac</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, impressive! <br><br></td></tr></table><br>
<a name="1342446"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm using your latest wrapper (including the OpenB3D source included in it) from <a href="https://github.com/markcwm/openb3d.mod" target="_blank">here</a> only. <br><br></td></tr></table><br>
<a name="1342447"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I want the original art of the game but more polished without losing the original texture character. So I experimented a long time and came up with this 6-step process.<br> <br></div><br><br>Very impressive.  Character not lost, and no artwork to be produced! :) <br><br></td></tr></table><br>
<a name="1342448"></a>

<a name="1342449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, the downside is that this HQ wall texture uses more diskspace than the whole Amiga game occupied on three SD floppy disks (a 24bit uncompressed TGA uses 3.145.746 Bytes and one ADF floppy image has 901.120 x 3 = 2.703.360 Bytes for the whole game) :-p And we have to multiplicate the TGA size x 2 because there is a normal map, too!<br><br>But hey, it really looks better than 120x119 Pixels with 4 colors ;-) <br><br></td></tr></table><br>
<a name="1342724"></a>

<a name="1342725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great graphics and atmosphere! Very creapy. Especially in the darker sections it feels like you can expect something to jump at you any second. <br>All I missed was a thunder and wind blowing sfx hehehe. <br><br></td></tr></table><br>
<a name="1342729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Umm Rick, did you watch the video? There are lightnings, thunder, wind blowing and rain SFX :-) <br><br></td></tr></table><br>
<a name="1342768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> So true. In beginning of video I hear the thunder sound indeed, at which point I previously had the audio muted, but further down the video there's no thunder/weather sound anymore so missed that before - silly me. <br><br></td></tr></table><br>
<a name="1342818"></a>

<a name="1342820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Unfortunately the sound quality of the video is very bad, I used Fraps here and the stereo grab of the windows sound card sounds different compared to the demo (in the video it sounds like you are inside a large metal tank). <br><br></td></tr></table><br>
<a name="1342850"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, that's a pity then. <br><br></td></tr></table><br>
<a name="1342864"></a>

<a name="1342865"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Badicam It is faster than fraps.<br>is Free. <br><a href="https://www.bandicam.com/" target="_blank">https://www.bandicam.com/</a> <br><br></td></tr></table><br>
<a name="1342885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> FWIW, Windows 10 has (game) screen recording built-in if your graphics card is good enough. <br><br></td></tr></table><br>
<a name="1342916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah you mean the XBOX app - I tried it but it sounds similar. I really don't know why - perhaps I'm using too many channels at the same time (currently 9, with the brl.DirectSoundAudio import) but the demo sounds normal.<br><br>Which sound driver do you prefer? <br><br></td></tr></table><br>
<a name="1342926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted June)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> great.. stuff.. impressed.. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
