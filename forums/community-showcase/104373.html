<!DOCTYPE html><html lang="en" ><head ><title >Mars Rover</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Mars Rover</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=61" >Showcase</a>/<a href="#bottom" >Mars Rover</a><br><br>
<a name="1264031"></a>

<a name="1264032"></a>

<a name="1264033"></a>

<a name="1264034"></a>

<a name="1264035"></a>

<a name="1264039"></a>

<a name="1264842"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a small demo of a rover on Mars I made just for fun. It demonstrates the use of Improved and Ridged Perlin Noise to create a realistic looking meshterrain on the fly, infinite rock placement, gravity, a minimap, player to terrain alignment and a chase cam. Nothing special, I just enjoyed driving around. It is not perfect but I'm happy with it. The Mars Exploration Rover Model ist from <a href="http://3dlenta.com/en/catalog.html?page=shop.product_details&amp;flypage=flypage.tpl&amp;product_id=14&amp;category_id=16" target="_blank">3dlenta.com</a>.<br><br>Oh, and the blue dot keeps a secret / surprise on the map.<br><br>Download (First Version) Demo+Source+Media: <a href="http://www.christianhart.de/bb/marsrover/MarsRoverDemo.zip" target="_blank">MarsRoverDemo.zip</a> [3.5MB]<br><br>Download (Current Version) Demo+Source+Media: <a href="http://www.christianhart.de/bb/marsrover/MarsRoverUpdate3.zip" target="_blank">MarsRoverUpdate3.zip</a> [3.5MB]<br><br>Inputs:<br>WASD+Arrows = Moving<br>Q/E or LMB/RMB = Zoom<br>ENTER = new Landscape<br>SPACE = Wireframe<br><br><img src="http://www.christianhart.de/bb/marsrover/Infiniterocks4.jpg"><br><br>And the full source in vanilla Blitz3D:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Infinite Rockfield by Krischan"

Dim P%(512),GRAYD#(512)

InitNoise(1.0)

Graphics3D 1024,600,32,2

Global SCALEX#		= 32.0				   ; rockfield scale X
Global SCALEY#		= 0.0			       ; rockfield scale Y
Global SCALEZ#		= 32.0				   ; rockfield scale Z
Global FARDIST#		= 32.0				   ; fade out distance
Global DENSITY#		= 100.0				   ; 100% density

Global rotspeed#	= 1.0				   ; player turn speed
Global moveSpeed#	= 0.05				   ; player move speed

Global WIDTH%		= GraphicsWidth()	   ; grab screen width
Global HEIGHT%		= GraphicsHeight()   	; grab screen height
Global TIMER%		= CreateTimer(60)	   ; timer

Global MAXrockS%	= 5000
Global terraintype$ = "mars"               ; terrain type: mars, valley, hills, plain
Global octaves      = 7                    ; noise octaves 1...99 (more = rugged)
Global factor#      = 32.0                 ; vertical height multiplicator
Global terrsize     = 128                  ; mesh resolution 32...128
Global seed%        = 46                   ; terrain seed

Global playmodel$   = "models/mer.3ds"     ; player model
Global rockmodel$   = "models/rock.b3d"    ; player model
Global specmodel$   = "models/pyramid.b3d" ; special model
Global detailtex1$  = "textures/earth.png"
Global detailtex2$  = "textures/sprinkles.png"
Global rockstex$    = "textures/earth.png"

Global specialx#    = -20
Global specialy#    = 12
Global specialz#    = 40

SeedRnd seed

Global visible%,rocks%
Global cameray#,test#

Global imagesize%=128
Global image=CreateImage(imagesize,imagesize)
Global buff=ImageBuffer(image)

Global FreeLookRotXS#, FreeLookRotYS#
;Global cameray#

Type rock
	
	Field entity%
	Field x#,y#,z#
	Field r%,g%,b%
	Field pitch#,yaw#,roll#
	Field scale#
	Field visible%
	Field update%
	
End Type

; player
Global player=LoadAnimMesh(playmodel)
PositionEntity player,0,0,0-terrsize*0.9
EntityFX player,2
EntityType player,1
EntityRadius player,0

; simple playershadow
Global playershadow=LoadMesh(playmodel)
ScaleEntity playershadow,1,0.0000001,1
EntityColor playershadow,0,255,0
EntityFX playershadow,1
EntityColor playershadow,0,0,0
EntityAlpha playershadow,0.25

; camera
Global camerapivot=CreatePivot(player)
Global camera=CreateCamera(camerapivot)
CameraRange camera,0.01,terrsize*2
CameraClsColor camera,255,200,150
CameraFogColor camera,255,200,150
CameraFogMode camera,True
CameraFogRange camera,0,terrsize*0.9
EntityType camera,1
EntityRadius camera,0.25

; light
Global light=CreateLight(1)
LightColor light,255,160,128
AmbientLight 128,100,75

; terrain
Global terrain=CreateMeshTerrain(terrsize,terrsize)
Global terrsurf=GetSurface(terrain,1)
Global terrtex1=LoadTexture(detailtex1,1)
Global terrtex2=LoadTexture(detailtex2,1)
ScaleTexture terrtex1,1.0/4,1.0/4
ScaleTexture terrtex2,1.0/32,1.0/32
ScaleEntity terrain,2,1,2
EntityTexture terrain,terrtex1,0,0
EntityTexture terrain,terrtex2,0,1
TextureBlend terrtex1,5
TextureBlend terrtex2,5
EntityFX terrain,2
EntityPickMode terrain,2
EntityType terrain,2
UpdateNormals terrain

; single rock mesh
Global rock=LoadMesh(rockmodel)
Global rocktex=LoadTexture(rockstex,1)
EntityTexture rock,rocktex,0,0
EntityFX rock,1
EntityType rock,2
UpdateNormals rock
HideEntity rock

; add rocks to rockfield
Addrocks(MAXrockS,0.02,0.5,180,90,48)

; survey map
Global map=CreateSurveyMap()

; surprise!
Global special=LoadMesh(specmodel)
FitMesh special,-0.5,-0.5,-0.5,1,1,1,1
ScaleEntity special,40,40*0.63,40
PositionEntity special,specialx,specialy,specialz
RotateEntity special,0,30,0
EntityColor special,180,90,48
EntityPickMode special,2
EntityType special,2
EntityFX special,2

; center mouse, prepare collisions
MoveMouse WIDTH/2,HEIGHT/2
Collisions 1,2,2,3
PlacePlayer()

; main loop
While Not KeyHit(1)
	
	; player movement
	Movement(player)
	
	DENSITY=Normalize(Perlin3D(EntityX(player),0,EntityZ(player),8,1,0,3),0,1,0,100)
	
	If DENSITY&gt;100 Then DENSITY=100 Else If DENSITY&lt;5 Then DENSITY=5
	
	; player stays at ground using linepick
	Local px#=EntityX(player,1)
	Local py#=EntityY(player,1)
	Local pz#=EntityZ(player,1)
	
	; use linepick to calculate player alignment to the ground
	Local l = LinePick(px,py+100,pz,0,-200,0,1)
	If l=terrain Or l=special Then
		
		; align player to ground
		AlignToVector(player,PickedNX(),PickedNY(),PickedNZ(),2,1.0/8)
		
		; align shadow to ground
		AlignToVector(playershadow,PickedNX(),PickedNY(),PickedNZ(),2,1.0/8)
		
	EndIf
	
	; gravity!
	TranslateEntity player,0,-0.01,0
	
	; camera chases player
	PositionEntity camera,0,0,0
	TranslateEntity camera,0,0.25,-3+cameray
	
	PositionEntity playershadow,px,py+0.01,pz
	
	UpdateWorld()
	RenderWorld()
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf
	WireFrame wf
	
	; ENTER = New Map
	If KeyHit(28) Then ReInit()
	
	; rock radar
	Color 0,0,0
	Rect(0,0,imagesize,imagesize,1)
	DrawImage image,0,0
	
	; survey map
	DrawImage map,WIDTH-(terrsize*2),0
	
	; text outputs
	Color 0,255,0
	Text 0,imagesize+ 0,"Density: "+DENSITY+"%"
	Text 0,imagesize+14,"Visible: "+visible
	Text 0,imagesize+28,"Rocks..: "+rocks
	Text 0,imagesize+42,"Seed...: "+seed
	
	; player position on survay map
	If MilliSecs()&gt;blink+250 Then
		
		blink=MilliSecs()
		blinkmode=1-blinkmode
		
	EndIf
	
	; special destination
	If blinkmode Then
		
		Color 0,255,255
		Oval(sx-px+specialx,sy+pz-specialz,5,5,1)
		
	EndIf
	
	; player position on survey map
	sx=WIDTH-terrsize+px
	sy=terrsize-pz
	
	; view direction vector
	ax# = Cos(-EntityYaw(player)+270)*10
	ay# = Sin(-EntityYaw(player)+270)*10
	
	; draw view direction pole and player blip
	Color 0,255,0
	Line(sx+2, sy+2, sx+2+ax, sy+2+ay)
	Oval(sx,sy,5,5,1)
	
	Delay 1
	
	; update rocks
	Updaterockfield(player,True)
	
	Flip False
	
	WaitTimer TIMER
	
Wend

End

Function PlacePlayer()
	
	Local l = LinePick(EntityX(player),1000,EntityZ(player),0,-2000,0,1)
	If l=terrain Or l=special Then
		
		PositionEntity player,EntityX(player),PickedY()+0.1,EntityZ(player)
		
	EndIf
	
	test=PickedY()
		
	
End Function

; rebuild rockfield mesh
Function Updaterockfield(parent%,fader%=False)
	
	Local r.rock,px#,py#,pz#,d#,a#,rgb%,x%,y%,rr#
	
	Local cx#=EntityX(parent)
	Local cy#=EntityY(parent)
	Local cz#=EntityZ(parent)
	
	visible=0
	rocks=0
	
	SetBuffer buff
	Color 0,0,0
	Rect 0,0,imagesize,imagesize,1
	LockBuffer buff
	
	For r.rock = Each rock
		
		rocks=rocks+1
		
		; calc rock position
		px=cx-r\x
		py=cy-r\y
		pz=cz-r\z
		
		rr#=Rnd(0.9,1.1)
		
		; check if rock must be moved, if yes: rock is invisible and must be updated
		If px&lt;-SCALEX Then r\x=(r\x-(SCALEX*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		If px&gt;+SCALEX Then r\x=(r\x+(SCALEX*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		If pz&lt;-SCALEZ Then r\z=(r\z-(SCALEZ*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		If pz&gt;+SCALEZ Then r\z=(r\z+(SCALEZ*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		
		; always hide all rocks
		HideEntity r\entity
		
		; check only visible
		If r\visible Then
			
			; new XY position
			x=Int(Normalize(px,-SCALEX,SCALEX,imagesize/2,-imagesize/2))
			y=Int(Normalize(pz,-SCALEZ,SCALEZ,-imagesize/2,imagesize/2))
			
			; rock is grey on radar
			rgb=64*$10000+64*$100+64
			
			; reposition rock And get distance 
			PositionEntity rock,r\x,r\y,r\z
			d=EntityDistance(rock,parent)
			
			; check if not to far away
			If d&lt;FARDIST Then
				
				; rock is visible?
				If EntityInView(rock,camera) Then
					
					; rock is green on radar
					rgb=255*$100
					
					; add alpha
					a=1.0 : If fader Then a=Normalize(d,FARDIST*0.7,FARDIST*0.9,1,0)
					
					; rock must be updated? do a linepick for new height position
					If r\update Then 
						
						Local l = LinePick(r\x,r\y+1000,r\z,0,-10000,0)
						
						If l=terrain Then
							
							r\y = PickedY()-r\scale/8.0
							AlignToVector(r\entity,PickedNX(),PickedNY(),PickedNZ(),2)
							
						Else
							
							r\y=-2^32
							r\visible=False
							
						EndIf
						
						r\update=False
						
						; set entity properties
						ScaleEntity r\entity,r\scale,r\scale,r\scale
						RotateEntity r\entity,r\pitch,r\yaw,r\roll
						PositionEntity r\entity,r\x,r\y,r\z
						
					EndIf
					
					; update mesh color and alpha
					EntityColor r\entity,r\r,r\g,r\b
					EntityAlpha r\entity,a
					
					; show it!
					ShowEntity r\entity
					If r\scale&lt;0.4 Then rgb=192*$10000
					
					visible=visible+1
					
				EndIf
				
			EndIf
			
			x=((imagesize/2)+x)
			y=((imagesize/2)+y)
			
			If x&lt;imagesize And y&lt;imagesize Then WritePixelFast x,y,rgb,buff
			
		EndIf
		
	Next
	
	UnlockBuffer buff
	
	SetBuffer BackBuffer()
	
	Return DENSITY
	
End Function

; add rocks to rockfield mesh
Function Addrocks(amount%=1,min#=0.01,max#=0.02,red%=255,green%=128,blue%=0)
	
	Local i%,r.rock
	
	For i=1 To amount
		
		rn#=Rnd(0.9,1.1)
		
		r.rock = New rock
		
		r\r=red*rn
		r\g=green*rn
		r\b=blue*rn
		r\x=Rnd(-SCALEX,SCALEX)
		r\y=0.0
		r\z=Rnd(-SCALEZ,SCALEZ)
		r\scale=Rnd(min,max)
		r\pitch=Rnd(360)
		r\yaw=Rnd(360)
		r\roll=Rnd(360)
		r\entity=CopyEntity(rock)
		r\update=True
		
		If Rnd(1)&gt;0.9 Then r\scale=r\scale*Rnd(1,3)
		If Rnd(1)&gt;0.99 Then r\scale=r\scale*Rnd(3,6)
		
		; small rocks don't collide!
		If r\scale&lt;0.4 Then EntityType r\entity,0; : r\r=255 : r\g=0 : r\b=0
		
		If Distance3D(0,0,0,r\x,r\y,r\z)&lt;=FARDIST Then
			
			If Rand(100)&lt;DENSITY Then r\visible=True
			
		Else
			
			If Rand(100)&lt;DENSITY Then r\visible=True
			
		EndIf
		
	Next
	
End Function

; simple 3D distance calculation
Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Local x#=x1-x2
	Local y#=y1-y2
	Local z#=z1-z2
	
	Return Sqr(x*x+y*y+z*z)
	
End Function

; simple movement
Function Movement(player%)
	
	Local cx#,cy#,cz#,tx#,ty#,multi%=1
	
	cx=((KeyDown(203)-KeyDown(205)) Or (KeyDown(30)-KeyDown(32)))*rotspeed
	cy=((KeyDown(18)-KeyDown(16)) Or (MouseDown(1)-MouseDown(2)))*moveSpeed
	cz=((KeyDown(200)-KeyDown(208)) Or (KeyDown(17)-KeyDown(31)))*moveSpeed
	If KeyDown(42) Or KeyDown(54) Then multi=3
	
	MoveEntity player,0,0,cz*multi
	cameray=cameray+cy
	
	TurnEntity player,0,cx,0
	TurnEntity playershadow,0,cx,0
	
	RotateEntity camerapivot,Normalize(MouseY(),0,HEIGHT-1,45,0),EntityYaw(player)+Normalize(MouseX(),0,WIDTH-1,-90,90),0,1
	
End Function

; normalize a value
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value-value_min)/(value_max-value_min))*(norm_max-norm_min)+norm_min
	
End Function


Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

Function CreateMeshTerrain(tilesx = 128, tilesy = 128, parent=0)
	
	Local mesh = CreateMesh(parent)
	Local surf = CreateSurface(mesh)
	Local x, y, u#,v#,h1#,h2#,h3#,c
	Local v0, v1, v2, v3
	Local r,g,b
	
	For x = 0 To tilesx - 1
		
		For y = 0 To tilesy - 1
			
			u = x * 1.0 / tilesx
			v = y * 1.0 / tilesy
			
			h1=Perlin3D(x,y,0,64,seed,0,octaves)
			h2=Perlin3D(x,y,0,64,seed+1,0,octaves)
			h3=Perlin3D(x,0,y,64,seed,0,octaves)
			
			If h1&lt;0 Then h1=-h1
			h1=1-h1
			h1=h1*h1
			
			If h2&lt;0 Then h2=-h2
			h2=1-h2
			h2=h2*h2
			
			Select terraintype
					
				Case "mars":	h1=Log(1+h1)*h2
				Case "valley":	h1=h1+(Sin(h1*90)*Cos(h1*360)/8.0)
				Case "hills":	h1=h1+(Sin(h2*90))
				Case "plain":	h1=(h1+h2)/2.0
					
				Default:
					
			End Select
			
			v0 = AddVertex(surf, x - (tilesx / 2.0), h1*factor,y - (tilesy / 2.0), u, v)
			
			c=Normalize(h1,-1,1,0,255)
			r=c*1.0
			g=c*0.5
			b=c*0.25
			
			VertexColor surf,v0,r,g,b
			
		Next
		
	Next
	
	For x = 0 To tilesx - 2
		
		For y = 0 To tilesy - 2
			
			v0 = x * tilesy + y
			v1 = v0 + 1
			v2 = v1 + tilesy
			v3 = v0 + tilesy
			
			AddTriangle(surf,v0,v1,v2)
			AddTriangle(surf,v0,v2,v3)
			
		Next
		
	Next
	
	Return mesh
	
End Function

Function CreateSurveyMap()
	
	Local image=CreateImage(terrsize,terrsize)
	Local buffer=ImageBuffer(image)
	Local surf=GetSurface(terrain,1)
	
	LockBuffer buffer
	
	For x = 0 To terrsize - 1
		
		For y = 0 To terrsize - 1
			
			e=Normalize((VertexNX(surf,v)+VertexNY(surf,v))/2.0,1,-1,0,255)*1.5
			If e&gt;255 Then e=255
			If e&lt;0 Then e=0
			
			r=Overlay(VertexRed(surf,v),e)
			g=Overlay(VertexGreen(surf,v),e)
			b=Overlay(VertexBlue(surf,v),e)
			
			WritePixelFast(x,terrsize-1-y,r*$10000+g*$100+b,buffer)
			
			v=v+1
			
		Next
		
	Next
	UnlockBuffer buffer
	
	ResizeImage(image,terrsize*2,terrsize*2)
	
	Return image
	
End Function

Function Overlay(a,b)
	
	If a &lt; 128 Then Return (a * b) Shr 7 Else Return 255 - ((255 - a) * (255 - b) Shr 7)
	
End Function

Function ReInit()
	
	seed=seed+1
	SeedRnd seed
	
	FreeEntity terrain
	
	terrain=CreateMeshTerrain(terrsize,terrsize)
	ScaleEntity terrain,2,1,2
	PositionEntity player,EntityX(player),100,EntityZ(player)
	
	EntityTexture terrain,terrtex1,0,0
	EntityTexture terrain,terrtex2,0,1
	TextureBlend terrtex1,5
	TextureBlend terrtex2,5
	EntityFX terrain,2
	EntityPickMode terrain,2
	EntityType terrain,2
	UpdateNormals terrain
	
	map=CreateSurveyMap()
	
	For r.rock = Each rock
		
		r\update=True
		
	Next
	
	PlacePlayer()
	
End Function

.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea> <br><br></td></tr></table><br>
<a name="1264045"></a>

<a name="1264048"></a>

<a name="1264050"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> And a quick update: for more realism, the rover leaves marks now - best seen on darker ground. Up to 2500 surface-aligned sprites are used to keep track of the rovers trail - a nice demonstration of types. If there are more than 2500, the first tracks are deleted and there are always 2500 track sprites to keep the FPS low.<br><br>Just overwrite the existing files with this ZIP archiv:<br><a href="http://www.christianhart.de/bb/marsrover/MarsRoverUpdate1.zip" target="_blank">MarsRoverUpdate1.zip</a> [1.0MB]<br><br><img src="http://www.christianhart.de/bb/marsrover/Infiniterocks5.jpg"> <br><br></td></tr></table><br>
<a name="1264054"></a>

<a name="1264056"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Power Full. :)<br><br>Any suggestions for leaving footprints in the sand tire?<br><br><img src="http://blog.stuttgarter-zeitung.de/wp-content/opportunity-mars-sonde.jpg"> <br><br></td></tr></table><br>
<a name="1264099"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I do not understand the question? My update already shows a concept how to "leave footprints" even if they are not 100% correct. I've experimented with exact footprints like in your screenshot but the maths were too complex for me so I kept the current solution.<br><br>Oh and I've updated the update as I forgot to delete the tracks when you create a new map ;-) <br><br></td></tr></table><br>
<a name="1264518"></a>

<a name="1264519"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another update: now the collision check is only done against the NEAREST rock close to the player's position. A second bright green dummy rock twin is placed and rotated at the same position like the "real" rock and should be made invisible, here only scaled twice as large and visible to show the effect:<br><br><img src="http://www.christianhart.de/bb/marsrover/Infiniterocks6.jpg"><br><br>And the updated code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">AppTitle "Infinite Rockfield by Krischan"

Dim P%(512),GRAYD#(512)

InitNoise(1.0)

Graphics3D 1024,600,32,2

Global SCALEX#		= 32.0				   ; rockfield scale X
Global SCALEY#		= 0.0			       ; rockfield scale Y
Global SCALEZ#		= 32.0				   ; rockfield scale Z
Global FARDIST#		= 32.0				   ; fade out distance
Global DENSITY#		= 100.0				   ; 100% density

Global rotspeed#	= 1.0				   ; player turn speed
Global moveSpeed#	= 0.05				   ; player move speed

Global WIDTH%		= GraphicsWidth()	   ; grab screen width
Global HEIGHT%		= GraphicsHeight()     ; grab screen height
Global TIMER%		= CreateTimer(60)	   ; timer

Global MAXrockS%	= 5000
Global terraintype$ = "valley"             ; terrain type: mars, valley, hills, plain
Global octaves      = 7                    ; noise octaves 1...99 (more = rugged)
Global factor#      = 16.0                  ; vertical height multiplicator
Global terrsize%    = 128                  ; mesh resolution 32...128
Global seed%        = 46                   ; terrain seed
Global maxtracks%   = 2500                 ; how many track sprites until deletion?

Global playmodel$   = "models/mer.3ds"     ; player model
Global rockmodel$   = "models/rock.b3d"    ; player model
Global specmodel$   = "models/pyramid.b3d" ; special model
Global detailtex1$  = "textures/earth.png"
Global detailtex2$  = "textures/sprinkles.png"
Global rockstex$    = "textures/earth.png"

Global specialx#    = -20
Global specialy#    = 12
Global specialz#    = 40

Global tracks

Global cx#,cy#,cz#

SeedRnd seed

Global visible%,rocks%
Global cameray#,test#

Global imagesize%=128
Global image=CreateImage(imagesize,imagesize)
Global buff=ImageBuffer(image)

Global FreeLookRotXS#, FreeLookRotYS#
;Global cameray#

Type rock
	
	Field entity%
	Field x#,y#,z#
	Field r%,g%,b%
	Field pitch#,yaw#,roll#
	Field scale#
	Field visible%
	Field update%
	
End Type

Type track
	
	Field entity%
	Field x#,y#,z#
	Field r%,g%,b%,a#
	Field scale#
	
	
End Type

; player
Global player=LoadAnimMesh(playmodel)
PositionEntity player,0,0,0-terrsize*0.9
EntityFX player,2
EntityType player,1
EntityRadius player,0.125

; simple playershadow
Global playershadow=LoadMesh(playmodel)
ScaleEntity playershadow,1,0.0000001,1
EntityColor playershadow,0,255,0
EntityFX playershadow,1
EntityColor playershadow,0,0,0
EntityAlpha playershadow,0.25

; camera
Global camerapivot=CreatePivot(player)
Global camera=CreateCamera(camerapivot)
CameraRange camera,0.01,terrsize*2
CameraClsColor camera,255,200,150
CameraFogColor camera,255,200,150
CameraFogMode camera,True
CameraFogRange camera,0,terrsize*0.9
EntityType camera,1
EntityRadius camera,0.25

; light
Global light=CreateLight(1)
LightColor light,255,160,128
AmbientLight 128,100,75

; terrain
Global terrain=CreateMeshTerrain(terrsize,terrsize)
Global terrsurf=GetSurface(terrain,1)
Global terrtex1=LoadTexture(detailtex1,1)
Global terrtex2=LoadTexture(detailtex2,1)
ScaleTexture terrtex1,1.0/4,1.0/4
ScaleTexture terrtex2,1.0/32,1.0/32
ScaleEntity terrain,2,1,2
EntityTexture terrain,terrtex1,0,0
EntityTexture terrain,terrtex2,0,1
TextureBlend terrtex1,5
TextureBlend terrtex2,5
EntityFX terrain,2
EntityPickMode terrain,2
EntityType terrain,2
UpdateNormals terrain

; single rock mesh
Global rock=LoadMesh(rockmodel)
Global rocktex=LoadTexture(rockstex,1)
EntityTexture rock,rocktex,0,0
EntityFX rock,1
;EntityType rock,2
UpdateNormals rock
HideEntity rock

; add rocks to rockfield
Addrocks(MAXrockS,0.02,0.5,180,90,48)

; survey map
Global map=CreateSurveyMap()

; surprise!
Global special=LoadMesh(specmodel)
FitMesh special,-0.5,-0.5,-0.5,1,1,1,1
ScaleEntity special,40,40*0.63,40
PositionEntity special,specialx,specialy,specialz
RotateEntity special,0,30,0
EntityColor special,180,90,48
EntityPickMode special,2
EntityType special,2
EntityFX special,2

; tracks
Global track=CreateSprite()
Global tracktex=LoadTexture("textures/track.tga",2)
TextureBlend tracktex,5
HideEntity track

; find nearest rock only collision mesh
Global nearms
Global near=LoadMesh(rockmodel)
EntityTexture near,rocktex,0,0
UpdateNormals near
EntityFX near,1
EntityColor near,0,255,0
EntityBlend near,3
EntityType near,2

Local pv = CreatePivot()
Local oldpv = CreatePivot()
PositionEntity oldpv, -2 ^ 32, 0, 0


; center mouse, prepare collisions
MoveMouse WIDTH/2,HEIGHT/2
Collisions 1,2,2,3
PlacePlayer()

; main loop
While Not KeyHit(1)
	
	; player movement
	Movement(player)
	
	DENSITY=Normalize(Perlin3D(EntityX(player),0,EntityZ(player),8,1,0,3),0,1,0,100)
	
	If DENSITY&gt;100 Then DENSITY=100 Else If DENSITY&lt;5 Then DENSITY=5
	
	; player stays at ground using linepick
	Local px#=EntityX(player,1)
	Local py#=EntityY(player,1)
	Local pz#=EntityZ(player,1)
	
	; use linepick to calculate player alignment to the ground
	Local l = LinePick(px,py+100,pz,0,-200,0,1)
	If l=terrain Or l=special Then
		
		; align player to ground
		AlignToVector(player,PickedNX(),PickedNY(),PickedNZ(),2,1.0/8)
		
		; align shadow to ground
		AlignToVector(playershadow,PickedNX(),PickedNY(),PickedNZ(),2,1.0/8)
		
		; add tracks
		PositionEntity pv, px, PickedY(), pz
		
		Local t.track
		
		If EntityDistance(pv, oldpv) &gt; 0.25 And cz&lt;&gt;0 Then
			
			If tracks&gt;=maxtracks Then
				
				t.track = First track
				FreeEntity t\entity
				Delete First track
				
				tracks=tracks-1
				
			EndIf
			
			PositionEntity oldpv, px, PickedY(), pz
			
			t = New track
			
			t\x=px
			t\y=PickedY()+0.0001
			t\z=pz
			t\scale=0.5
			t\r=90
			t\g=45
			t\b=24
			t\a=0.4
			
			t\entity=CopyEntity(track)
			PositionEntity t\entity,t\x,t\y,t\z
			AlignToVector(t\entity,PickedNX(),PickedNY(),PickedNZ(),3,1.0/1)
			ScaleSprite t\entity,t\scale,t\scale
			EntityColor t\entity,t\r,t\g,t\b
			EntityAlpha t\entity,t\a
			RotateEntity t\entity,90,0,0
			
			SpriteViewMode t\entity,2
			EntityFX t\entity,1+16
			EntityTexture t\entity,tracktex
			
			tracks=tracks+1
			
			
		End If
		
	EndIf
	
	; gravity!
	TranslateEntity player,0,-0.01,0
	
	; camera chases player
	PositionEntity camera,0,0,0
	TranslateEntity camera,0,0.25,-3+cameray
	
	PositionEntity playershadow,px,py+0.01,pz
	
	UpdateWorld()
	RenderWorld()
	
	; SPACE = Wireframe
	If KeyHit(57) Then wf=1-wf
	WireFrame wf
	
	; ENTER = New Map
	If KeyHit(28) Then ReInit()
	
	; rock radar
	Color 0,0,0
	Rect(0,0,imagesize,imagesize,1)
	DrawImage image,0,0
	
	; survey map
	DrawImage map,WIDTH-(terrsize*2),0
	
	; text outputs
	Color 0,255,0
	Text 0,imagesize+ 0,"Density.: "+DENSITY+"%"
	Text 0,imagesize+14,"Visible.: "+visible
	Text 0,imagesize+28,"Rocks...: "+rocks
	Text 0,imagesize+42,"Seed....: "+seed
	Text 0,imagesize+56,"Tracks..: "+tracks
	Text 0,imagesize+70,"Nearcalc: "+nearms
	
	; player position on survay map
	If MilliSecs()&gt;blink+250 Then
		
		blink=MilliSecs()
		blinkmode=1-blinkmode
		
	EndIf
	
	; special destination
	If blinkmode Then
		
		Color 0,255,255
		Oval(sx-px+specialx,sy+pz-specialz,5,5,1)
		
	EndIf
	
	; player position on survey map
	sx=WIDTH-terrsize+px
	sy=terrsize-pz
	
	; view direction vector
	ax# = Cos(-EntityYaw(player)+270)*10
	ay# = Sin(-EntityYaw(player)+270)*10
	
	; draw view direction pole and player blip
	Color 0,255,0
	Line(sx+2, sy+2, sx+2+ax, sy+2+ay)
	Oval(sx,sy,5,5,1)
	
	Delay 1
	
	; update rocks
	Updaterockfield(player,True)
	
	Flip False
	
	WaitTimer TIMER
	
Wend

End

Function PlacePlayer()
	
	Local l = LinePick(EntityX(player),1000,EntityZ(player),0,-2000,0,1)
	If l=terrain Or l=special Then
		
		PositionEntity player,EntityX(player),PickedY()+0.25,EntityZ(player)
		
	EndIf
	
	test=PickedY()
		
	
End Function

; rebuild rockfield mesh
Function Updaterockfield(parent%,fader%=False)
	
	Local r.rock,px#,py#,pz#,d#,a#,rgb%,x%,y%,rr#
	
	Local cx#=EntityX(parent)
	Local cy#=EntityY(parent)
	Local cz#=EntityZ(parent)
	
	visible=0
	rocks=0
	
	SetBuffer buff
	Color 0,0,0
	Rect 0,0,imagesize,imagesize,1
	LockBuffer buff
	
	; reset nearest calculation
	Local n#=0.0
	Local n0# = 100000000.0
	Local nearest.rock
	
	For r.rock = Each rock
		
		rocks=rocks+1
		
		; calc rock position
		px=cx-r\x
		py=cy-r\y
		pz=cz-r\z
		
		rr#=Rnd(0.9,1.1)
		
		; check if rock must be moved, if yes: rock is invisible and must be updated
		If px&lt;-SCALEX Then r\x=(r\x-(SCALEX*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		If px&gt;+SCALEX Then r\x=(r\x+(SCALEX*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		If pz&lt;-SCALEZ Then r\z=(r\z-(SCALEZ*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		If pz&gt;+SCALEZ Then r\z=(r\z+(SCALEZ*2)*rr) : r\visible=False : r\update=True : If Rnd(100)&lt;DENSITY Then r\visible=True
		
		; always hide all rocks
		HideEntity r\entity
		
		; check only visible
		If r\visible Then
			
			; new XY position
			x=Int(Normalize(px,-SCALEX,SCALEX,imagesize/2,-imagesize/2))
			y=Int(Normalize(pz,-SCALEZ,SCALEZ,-imagesize/2,imagesize/2))
			
			; rock is grey on radar
			rgb=64*$10000+64*$100+64
			
			; reposition rock And get distance 
			PositionEntity rock,r\x,r\y,r\z
			d=EntityDistance(rock,parent)
			
			; check if not to far away
			If d&lt;FARDIST Then
				
				; rock is visible?
				If EntityInView(rock,camera) Then
					
					; rock is green on radar
					rgb=255*$100
					
					; add alpha
					a=1.0 : If fader Then a=Normalize(d,FARDIST*0.7,FARDIST*0.9,1,0)
					
					; rock must be updated? do a linepick for new height position
					If r\update Then 
						
						Local l = LinePick(r\x,r\y+1000,r\z,0,-10000,0)
						
						If l=terrain Then
							
							r\y = PickedY()-r\scale/8.0
							AlignToVector(r\entity,PickedNX(),PickedNY(),PickedNZ(),2)
							
						Else
							
							r\y=-2^32
							r\visible=False
							
						EndIf
						
						r\update=False
						
						; set entity properties
						ScaleEntity r\entity,r\scale,r\scale,r\scale
						RotateEntity r\entity,r\pitch,r\yaw,r\roll
						PositionEntity r\entity,r\x,r\y,r\z
						
					EndIf
					
					; update mesh color and alpha
					EntityColor r\entity,r\r,r\g,r\b
					EntityAlpha r\entity,a
					
					; show it!
					ShowEntity r\entity
					If r\scale&lt;0.4 Then rgb=192*$10000
					
					visible=visible+1
					
				EndIf
				
			EndIf
			
			x=((imagesize/2)+x)
			y=((imagesize/2)+y)
			
			If x&lt;imagesize And y&lt;imagesize Then WritePixelFast x,y,rgb,buff
			
			nearms=MilliSecs()
			
			; X
			n=(r\x-cx)*(r\x-cx)
			
			If n&lt;n0 Then
				
				; Y
				n=n+((r\y-cy)*(r\y-cy))
				
				If n&lt;n0 Then
					
					; Z
					n=n+((r\z-cz)*(r\z-cz))
					If n&lt;n0 Then
						
						n0=n
						nearest=r
						PositionEntity near,nearest\x,nearest\y,nearest\z
						ScaleEntity near,nearest\scale*2,nearest\scale*2,nearest\scale*2
						RotateEntity near,nearest\pitch,nearest\yaw,nearest\roll
						
					EndIf
					
				End If
				
			End If
			
			nearms=MilliSecs()-nearms
			
		EndIf
		
	Next
	
	UnlockBuffer buff
	
	SetBuffer BackBuffer()
	
	Return DENSITY
	
End Function

; add rocks to rockfield mesh
Function Addrocks(amount%=1,min#=0.01,max#=0.02,red%=255,green%=128,blue%=0)
	
	Local i%,r.rock
	
	For i=1 To amount
		
		rn#=Rnd(0.9,1.1)
		
		r.rock = New rock
		
		r\r=red*rn
		r\g=green*rn
		r\b=blue*rn
		r\x=Rnd(-SCALEX,SCALEX)
		r\y=0.0
		r\z=Rnd(-SCALEZ,SCALEZ)
		r\scale=Rnd(min,max)
		r\pitch=Rnd(360)
		r\yaw=Rnd(360)
		r\roll=Rnd(360)
		r\entity=CopyEntity(rock)
		r\update=True
		
		If Rnd(1)&gt;0.9 Then r\scale=r\scale*Rnd(1,3)
		If Rnd(1)&gt;0.99 Then r\scale=r\scale*Rnd(3,6)
		
		If Distance3D(0,0,0,r\x,r\y,r\z)&lt;=FARDIST Then
			
			If Rand(100)&lt;DENSITY Then r\visible=True
			
		Else
			
			If Rand(100)&lt;DENSITY Then r\visible=True
			
		EndIf
		
	Next
	
End Function

; simple 3D distance calculation
Function Distance3D#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Local x#=x1-x2
	Local y#=y1-y2
	Local z#=z1-z2
	
	Return Sqr(x*x+y*y+z*z)
	
End Function

; simple movement
Function Movement(player%)
	
	Local multi%=1
	
	cx=((KeyDown(203)-KeyDown(205)) Or (KeyDown(30)-KeyDown(32)))*rotspeed
	cy=((KeyDown(18)-KeyDown(16)) Or (MouseDown(1)-MouseDown(2)))*moveSpeed
	cz=((KeyDown(200)-KeyDown(208)) Or (KeyDown(17)-KeyDown(31)))*moveSpeed
	If KeyDown(42) Or KeyDown(54) Then multi=3
	
	MoveEntity player,0,0,cz*multi
	cameray=cameray+cy
	
	TurnEntity player,0,cx,0
	TurnEntity playershadow,0,cx,0
	
	RotateEntity camerapivot,Normalize(MouseY(),0,HEIGHT-1,45,0),EntityYaw(player)+Normalize(MouseX(),0,WIDTH-1,-90,90),0,1
	
End Function

; normalize a value
Function Normalize#(value#=128.0,value_min#=0.0,value_max#=255.0,norm_min#=0.0,norm_max#=1.0)
	
	Return ((value-value_min)/(value_max-value_min))*(norm_max-norm_min)+norm_min
	
End Function


Function InitNoise(range#=0.7)
	
	Local i%,perm%
	
	Restore permutation
	
	For i=0 To 256-1
		
		Read perm
		
		P(i)=perm
		P(256+i)=perm
		
		GRAYD#(i)=Rnd(-range,range)
		GRAYD#(256+i)=Rnd(-range,range)
		
	Next
	
End Function

Function Perlin3D#(x#,y#,z#,size#=64,seed%=0,MinOctaves=0,MaxOctaves=9999) 
	
	Local value#,initialSize#,i%
	
	If seed=0 Then seed=MilliSecs()
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	value=0.0
	initialSize=size
	
	For i = 1 To MinOctaves : size=size/2 : Next
	
	While(size&gt;=1.0) And MaxOctaves&gt;MinOctaves
		
		value=value+SmoothNoise(x/size,y/size,z/size,seed)*size
		size=size/2.0
		MaxOctaves=MaxOctaves-1
		
	Wend
	
	Return (value/Float(initialSize))
	
End Function

Function SmoothNoise#(x#,y#,z#,seed%=0)
	
	Local x1#,y1#,z1#,u#,v#,w#,a#,aa#,ab#,b#,ba#,bb#
	Local g1#,g2#,g3#,g4#,g5#,g6#,g7#,g8#
	Local l1#,l2#,l3#,l4#,l5#,l6#,l7#
	
	x=x+seed
	y=y+seed
	z=z+seed
	
	x1=(Floor(x) And 255)
	y1=(Floor(y) And 255)
	z1=(Floor(z) And 255)
	
	x=x-Floor(x)
	y=y-Floor(y)
	z=z-Floor(z)
	
	u=Fade(x)
	v=Fade(y)
	w=Fade(z)
	
	a=P(x1)+y1
	aa=P(a)+z1
	ab=P(a+1)+z1
	
	b=P(x1+1)+y1
	ba=P(b)+z1
	bb=P(b+1)+z1
	
	g1=GRAYD(bb+1)
	g2=GRAYD(ab+1)
	g3=GRAYD(ba+1)
	g4=GRAYD(aa+1)
	g5=GRAYD(bb)
	g6=GRAYD(ab)
	g7=GRAYD(ba)
	g8=GRAYD(aa)
	
	l1=Lerp(u,g2,g1)
	l2=Lerp(u,g4,g3)
	l3=Lerp(v,l2,l1)
	l4=Lerp(u,g6,g5)
	l5=Lerp(u,g8,g7)
	l6=Lerp(v,l5,l4)
	l7=Lerp(w,l6,l3)
	
	Return l7
	
End Function

Function Fade#(t#)
	
	Return t*t*t*(t*(t*6-15)+10)
	
End Function

Function Lerp#(t#,a#,b#)
	
	Return a+t*(b-a)
	
End Function

Function CreateMeshTerrain(tilesx = 128, tilesy = 128, parent=0)
	
	Local mesh = CreateMesh(parent)
	Local surf = CreateSurface(mesh)
	Local x, y, u#,v#,h1#,h2#,h3#,c
	Local v0, v1, v2, v3
	Local r,g,b
	
	For x = 0 To tilesx - 1
		
		For y = 0 To tilesy - 1
			
			u = x * 1.0 / tilesx
			v = y * 1.0 / tilesy
			
			h1=Perlin3D(x,y,0,64,seed,0,octaves)
			h2=Perlin3D(x,y,0,64,seed+1,0,octaves)
			h3=Perlin3D(x,0,y,64,seed,0,octaves)
			
			If h1&lt;0 Then h1=-h1
			h1=1-h1
			h1=h1*h1
			
			If h2&lt;0 Then h2=-h2
			h2=1-h2
			h2=h2*h2
			
			Select terraintype
					
				Case "mars":	h1=Log(1+h1)*h2
				Case "valley":	h1=h1+(Sin(h1*90)*Cos(h1*360)/8.0)
				Case "hills":	h1=h1+(Sin(h2*90))
				Case "plain":	h1=(h1+h2)/2.0
					
				Default:
					
			End Select
			
			v0 = AddVertex(surf, x - (tilesx / 2.0), h1*factor,y - (tilesy / 2.0), u, v)
			
			c=Normalize(h1,-1,1,0,255)
			r=c*1.0
			g=c*0.5
			b=c*0.25
			
			VertexColor surf,v0,r,g,b
			
		Next
		
	Next
	
	For x = 0 To tilesx - 2
		
		For y = 0 To tilesy - 2
			
			v0 = x * tilesy + y
			v1 = v0 + 1
			v2 = v1 + tilesy
			v3 = v0 + tilesy
			
			AddTriangle(surf,v0,v1,v2)
			AddTriangle(surf,v0,v2,v3)
			
		Next
		
	Next
	
	Return mesh
	
End Function

Function CreateSurveyMap()
	
	Local image=CreateImage(terrsize,terrsize)
	Local buffer=ImageBuffer(image)
	Local surf=GetSurface(terrain,1)
	
	LockBuffer buffer
	
	For x = 0 To terrsize - 1
		
		For y = 0 To terrsize - 1
			
			e=Normalize((VertexNX(surf,v)+VertexNY(surf,v))/2.0,1,-1,0,255)*1.5
			If e&gt;255 Then e=255
			If e&lt;0 Then e=0
			
			r=Overlay(VertexRed(surf,v),e)
			g=Overlay(VertexGreen(surf,v),e)
			b=Overlay(VertexBlue(surf,v),e)
			
			WritePixelFast(x,terrsize-1-y,r*$10000+g*$100+b,buffer)
			
			v=v+1
			
		Next
		
	Next
	UnlockBuffer buffer
	
	ResizeImage(image,terrsize*2,terrsize*2)
	
	Return image
	
End Function

Function Overlay(a,b)
	
	If a &lt; 128 Then Return (a * b) Shr 7 Else Return 255 - ((255 - a) * (255 - b) Shr 7)
	
End Function

Function ReInit()
	
	seed=seed+1
	SeedRnd seed
	
	FreeEntity terrain
	
	terrain=CreateMeshTerrain(terrsize,terrsize)
	ScaleEntity terrain,2,1,2
	PositionEntity player,EntityX(player),100,EntityZ(player)
	
	EntityTexture terrain,terrtex1,0,0
	EntityTexture terrain,terrtex2,0,1
	TextureBlend terrtex1,5
	TextureBlend terrtex2,5
	EntityFX terrain,2
	EntityPickMode terrain,2
	EntityType terrain,2
	UpdateNormals terrain
	
	map=CreateSurveyMap()
	
	For r.rock = Each rock
		
		r\update=True
		
	Next
	
	For t.track = Each track
		
		FreeEntity t\entity
		Delete First track
		
		tracks=tracks-1
		
	Next
	
	PlacePlayer()
	
End Function

.permutation 
Data 151,160,137,91,90,15
Data 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23
Data 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33
Data 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166
Data 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244
Data 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196
Data 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123
Data 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42
Data 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9
Data 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228
Data 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107
Data 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254
Data 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</textarea><br><br>Here is a small demo to show the effect and a second algorithm which is not so fast like the one I've used before:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Graphics3D 800,600,32,2

ms=MilliSecs()

movespeed#=0.01          ; movespeed camera
stars%=100000            ; number of stars
range#=10.0             ; sector range XYZ
sun=0                   ; flag for first start
d#=0.0                  ; help variable dot connection

Type point
	
    Field entity%
	Field x#,y#,z#
	
End Type

timer=CreateTimer(60)

; camera
cam=CreateCamera()
CameraRange cam,0.01,range/5
PositionEntity cam,0,0,-2

; pivot
dummy=CreatePivot()

; star template
star=CreateCube()
ScaleEntity star,0.01,0.01,0.01
EntityFX star,1
EntityColor star,255,128,0

; generate stars
For s=1 To stars
	
	newrange#=range
	
    point.point = New point
	
    point\x=Rnd(-newrange,newrange)
	point\y=Rnd(-newrange,newrange)
	point\z=Rnd(-newrange,newrange)
	
    ; center first star
    If sun=0 Then point\x=0 : point\y=0 : point\z=0 : sun=1
	
    point\entity=CopyEntity(star)
    PositionEntity point\entity,point\x,point\y,point\z
	
	EntityAutoFade point\entity,range/10,range/5
	
    NameEntity point\entity,s
	
Next

MoveMouse GraphicsWidth()/2,GraphicsHeight()/2

Color 0,255,0

time=MilliSecs()-ms

; main loop
While Not KeyHit(1)
	
    ; FPS
    FPS_C=FPS_C+1
    If ms&lt;MilliSecs()
        ms=MilliSecs()+1000
        FPS=FPS_C
        FPS_C=0
    EndIf
	
	; movement
    mxs#=MouseXSpeed() : mys#=MouseYSpeed() : pitch#=EntityPitch(cam)+(mys#/5)
    If pitch&gt;89 Then pitch=89 Else If pitch&lt;-89 Then pitch=-89
    RotateEntity cam,pitch,EntityYaw(cam)-(mxs#/5),0
	MoveMouse GraphicsWidth()/2,GraphicsHeight()/2
	
	If KeyDown(200) Or KeyDown(17) Then MoveEntity cam,0,0,movespeed
	If KeyDown(208) Or KeyDown(31) Then MoveEntity cam,0,0,-movespeed
	If KeyDown(205) Or KeyDown(30) Then MoveEntity cam,movespeed,0,0
	If KeyDown(203) Or KeyDown(32) Then MoveEntity cam,-movespeed,0,0
    If KeyHit(57) Then method=1-method
	
	If method=0 Then methodstring$="Krischan's Algorithm" Else methodstring="Distance Sort"
	
   ; Render solid objects.
    RenderWorld
	
    ; Textausgabe
	Text 0, 0,"Build time.......: "+time+"ms"
	Text 0,15,"FPS..............: "+FPS
    Text 0,30,"Stars total......: "+stars
    Text 0,45,"Next Starn.......: "+close+" ["+name+"]"
	Text 0,60,"Method uses......: "+methodstring+method
    Text 0,75,"Time per loop....: "+loops+"ms"
	
    ; find next star and output its name
    msloops=MilliSecs()
	
	If method=0 Then
		
		close=CalcNearest(EntityX(cam),EntityY(cam),EntityZ(cam))
		
	Else
		
		close=FindNearest(EntityX(cam),EntityY(cam),EntityZ(cam))
		
	EndIf
	
    If close Then
		
		PositionEntity dummy,EntityX(close),EntityY(close),EntityZ(close)
		
		If EntityInView(dummy,cam) Then
			
			name=EntityName(close)
			CameraProject cam,EntityX(close),EntityY(close),EntityZ(close)
			
			px%=ProjectedX()
			py%=ProjectedY()
			
			If px&gt;=0 And px&lt;799 And py&gt;=0 And py&lt;=599 Then Text px,py,name
			
		EndIf
		
	EndIf
	
	loops=MilliSecs()-msloops
	
	WaitTimer timer
	
    Flip
	
Wend

End

Function FindNearest(x#,y#,z#)
	
	min#=100000000.0
	
	For point.point = Each point
		
		d#=Distance(x,y,z,point\x,point\y,point\z)
		If d&lt;min Then min=d : current%=point\entity
		
	Next
	
	Return current
	
End Function

Function Distance#(x1#,y1#,z1#,x2#,y2#,z2#)
	
	Return Sqr((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2))
	
End Function

Function CalcNearest(x#,y#,z#)
	
    Local d#
    Local d0# = 100000000.0
	np.point = Null
	
    ; cycle through all points
    For point.point = Each point
		
        ; X
        d=(point\x-x)*(point\x-x)
		
        If d&lt;d0 Then
			
            ; Y
            d=d+((point\y-y)*(point\y-y))
			
            If d&lt;d0 Then
				
                ; Z
                d=d+((point\z-z)*(point\z-z))
                If d&lt;d0 Then d0=d : np=point
				
            End If
			
        End If
		
    Next
	
    Return np\entity
	
End Function</textarea> <br><br></td></tr></table><br>
<a name="1264549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmm, looking pretty interesting but not bug free yet I guess: it didn't work on the largest rocks I came across up the mountain. It runs right through it. <br><br></td></tr></table><br>
<a name="1264550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's because of the small collision range of the rover, again it's just a simple example how to do it: KISS keep it silly simple. I'd suggest to increase the collision rock size and the collision box of the rover (which is currently a sphere only). Feel free to fine-tune it. <br><br></td></tr></table><br>
<a name="1264673"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, that explains it. Well the how to do it bit certainly succeeded. Will check it out. <br><br></td></tr></table><br>
<a name="1264724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yue</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, There A Possibility of Putting a distance no Models rocks , If no Lod sprites ?<br><br><img src="http://i58.tinypic.com/124x9ch.jpg"> <br><br></td></tr></table><br>
<a name="1264800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very good idea. If rockdestance&lt;threshold then position sprite at location of prev rock, but instead of sprites probably better to use quad billboards, which holds a masked image(instead of using alpha to avoid the z-order issue). Can't remember exactly why but I remember this to be a re-occurring advice: use quads instead of sprites. <br><br>Also, depending on possibilities of the code currently used, I would add a rock map, to determine where rocks should be positioned and where not. I once did a grass map routine which was fairly easy to implement.<br><br>Some lines of the grass map routine, to give you a bit of an idea.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
;====== LOAD GRASSMAP ==========
grassmap=LoadImage("grassmap.png");	 
flip_vertical(grassmap) ; is needed, cos is loaded in reverse order, if you don't, locations won't match your terrain height map.
gmpw=ImageWidth(grassmap) ; always  handy 
gmph=ImageHeight(grassmap)
Height# = LH# / LandscapeHeight#  ;current height devided by heightscale(=200) so getting to use with %&lt;&lt; only for my routines.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;=== From grassmap reading &amp; grass plot routines ====
	
GrassMapZ=Z*GrassGridCellSize / LandscapeSizeScale ;  you would of course need to adjust this depending on how it is organized in your rock plotting routines
GrassMapX=X*GrassGridCellSize / LandscapeSizeScale ;

SetBuffer(ImageBuffer(grassmap)) ; so we are going to use the grassmap.
LockBuffer(ImageBuffer(grassmap)) ; need to lock the buffer.
rgb=ReadPixelFast(GrassMapX,GrassMapZ,ImageBuffer(grassmap)) ; read pixel color from map x,z coords.
UnlockBuffer(ImageBuffer(grassmap)) ; set free the buffer.

; now a simple "if.. then.." should suffice, such as:
if rgb=-16711936 Then  ;if map color=green1 

;of course my original line was bit more complex cos I use a range of parameters to prevent misprints if map is painted not accurate, so no grass in water 
;and I also have different colors on map to depict different grass or bush types.
;If Height# &gt; BushesThreshold#+0.013  And Height# &lt; MaxBushesThreshold# And rgb=-16711936 Then  ;And mapcolor=green1  Then put bushtype1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</textarea><br><br>Now I don't know how easy it is to implement, as you are using blitz tiles which is quite a bit of code. <br><br></td></tr></table><br>
<a name="1264809"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> An alternative is to do 2 renders :<br>one render each mainloop for the nearest entities<br>one render each xms to render the far away entities and put the resulting textures on a kind of "skybox", what i call a "farawaythingsbox" (only for sides : at front, at back, at left, at right), the difficult thing is to manage to make each texture tile with the others which share an edge... <br><br></td></tr></table><br>
<a name="1264820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> @RemiD: Wouldn't 2 renders eat up just as much time as a full single render pass then, or more even? Nevertheless interesting idea. Do you have any examples to of different methods to compare speed wise? <br><br></td></tr></table><br>
<a name="1264822"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Guy Fawkes</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Missing: "Textures/Track.tga" <br><br></td></tr></table><br>
<a name="1264838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RemiD</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Rick&gt;&gt;reread my explanation and notice the "one render each mainloop" "one render each xms", the far away entities would be rendered only xms or only when the camera/player changes too much orientation/position <br><br></td></tr></table><br>
<a name="1264844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rick Nasher</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah get it now. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
