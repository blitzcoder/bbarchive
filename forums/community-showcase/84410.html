<!DOCTYPE html><html lang="en" ><head ><title >Very retro style 3D maze game</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Very retro style 3D maze game</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=61" >Showcase</a>/<a href="#bottom" >Very retro style 3D maze game</a><br><br>
<a name="953642"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Lindsay</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you remember playing a 3D maze game on a Commodore PET (among others), here's a slice of nostalgia for you :)  I've written it to get myself started with BlitzMax, but I've been programming for almost 30 years as explained in my <a href="/posts.php?topic=84387" target="_blank">intro post</a>.<br><br><img src="http://www.lpbaker.com/LPBaker/images/3dmaze1-1.png"><br><br>Here's a Windows version: <a href="http://www.lpbaker.com/LPBaker/Games_files/3dmaze1_windows.zip" target="_blank">http://www.lpbaker.com/LPBaker/Games_files/3dmaze1_windows.zip</a><br><br>Here's an Intel Mac version: <a href="http://www.lpbaker.com/LPBaker/Games_files/3dmaze1_osx.zip" target="_blank">http://www.lpbaker.com/LPBaker/Games_files/3dmaze1_osx.zip</a><br><br>The game should be pretty self-explanatory.  Pick a maze size (the mazes are randomly generated each time), try to get to the exit point (you always start at the top left, the exit point is the bottom right).  The more moves you make, the lower the score you end up with.  You can look at a 2D map view if you need help, but get a bonus added to your score if you don't use it.  You can also turn on a "breadcrumb trail" that shows you where you've been, but again, you get a bonus for not using it.<br><br>As I'm new to Blitz, if there's anything I'm doing in the code that's bad, or could be done a lot more easily, I'm all ears :)  The code is heavily documented but if you have any questions, I'm happy to help.<br><br>Enjoy!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem

	Simple "3D" maze game
	Using a "Depth First" Maze Generation Routine
	Started 24th April 2009
	Last Revision 27th April 2009
	
	Written by Lindsay Baker
	<a href="http://www.lpbaker.com" target="_blank">http://www.lpbaker.com</a>
	
	The maze is held in an array, with each cell (room) of the array holding a number.
	
	The number is made up from the binary bits - 1, 2, 4, 8 and 16 - that flag various things;
		1 = North Wall
		2 = South Wall
		4 = East Wall
		8 = West Wall
		16 = Breadcrumb
		
End Rem



Strict

' Program Version
Global CurrentVersion:String="Version 1.00, 27th April 2009"

' Maximum size of the maze - note, it does not have to be square :)
Global Maze[60,40]

' The actual size of the maze
Global SizeX=60, SizeY=40

' Scoring things
Global Score=0
Global UsedBreadcrumbs=0, UsedMap=0, MoveValue=0

' Size and position of the 2D and 3D map displays and the status line
Global TopLeftX2D, TopLeftY2D, DisplayWidth2D, DisplayHeight2D
Global TopLeftX3D, TopLeftY3D, DisplayWidth3D, DisplayHeight3D
Global StatusX, StatusY

' Segment positions and number
Global MaxSegments=60, DisplaySegments=10, VisibleSegments=10  ' 3D view size can't have any more segments than this
Global xpos#[MaxSegments,2], ypos#[MaxSegments,2]
	
' What graphics mode we'll set
Global ScreenWidth, ScreenHeight 

' Where we are and which way we're Facing, and if breadcrumbs are on
Global StartX, StartY, GoalX, GoalY, moves, PlayerX, PlayerY, Facing, ShowBreadcrumbs=0

' Consts for the walls - it's important that these correspond to the values of the binary bits!
Const wNorth=1, wSouth=2, wEast=4, wWest=8, AllWalls=wNorth+wSouth+wEast+wWest

' This is used to keep a 'breadcrumb trail' - that is, mark each cell the player has visited
Const Breadcrumb=16



Rem ------------- FUNCTION TO GENERATE THE MAZE ------------------------------------------------

	In essence, the routine works by randomly walking around, only going To cells it has Not seen before,
	And backtracking where necessary To find unvisited cells, Until all cells have been visited.

	The process in detail;
	1. All cells are intialised with all four walls
	2. A starting cell is chosen at random (but you could just specify it If you wish)
	3. Check If we've visited all cells, and if so, exit
	4. From the Current cell, determine which cells around it have Not been "visited" yet
	5. If there are no cells around we haven't visited, we're at a dead end, so go to step 9
	6. Choose one of the non-visited cells at random, And remove the wall between this cell And that one.  Note 
		this involves two steps; For example If we're moving North, we need to delete the North wall from this 
		cell And the South wall from the cell we're going to.  This might seem redundant, but when you're using
		the maze later it's very convenient for each cell to know all its exits.
	7. Add this New cell To our history of visited cells (this is like a breadcrumb trail of where we've been)
	8. Make the New cell our Current cell, And Return To Step 3
	9. We're at a dead end, so go back to the last room we came from using the history, and return to step 3
	
End Rem

Function GenerateMaze()

	' Number of cells in the maze
	Local NumCells=SizeX*SizeY
	
	' Our current and destination locations
	Local PlayerX, PlayerY, DestX, DestY
	
	' The "history" remembers the path to the current cell, so we can backtrack when we reach a dead end.
	' It almost certainly doesn't need to be so large, but I can't think of a way to come up with an absolute
	' upper limit.
	Local History[NumCells,2], HistoryLen=1
	
	' This keeps track of how many rooms we've visited - when it reaches the total count of rooms in the maze, stop!
	Local VisitCount=0
	
	' These are booleans to tell us which cells are unvisited
	Local N, S, E, W
	
	' Used to randomly select a direction
	Local dir
	
	' Loop variables
	Local x, y
	

	' Initialise the random number generator
	SeedRnd MilliSecs()

	' Make sure the maze is big enough to be functional
	If (SizeX &lt; 3) Or (SizeY &lt; 3) Then
		DebugLog("GenerateClosedMaze: Maze can't be generated that small!")
		Return 0
	EndIf
	
	' Put all walls in place to start with
	For x=0 To SizeX-1
		For y=0 To SizeY-1
			Maze[x,y]=AllWalls
		Next
	Next
	
	' Determine the starting cell at random
	PlayerX = Rand(SizeX)-1
	PlayerY = Rand(SizeY)-1
	VisitCount=1
	
	' Here's where all the work gets done!
	While VisitCount&lt;NumCells
	
		' Determine which cells are unvisited
		N=0; S=0; E=0; W=0
		If PlayerY&gt;0 Then If Maze[PlayerX,PlayerY-1]=AllWalls Then N=1
		If PlayerY&lt;SizeY-1 Then If Maze[PlayerX,PlayerY+1]=AllWalls Then S=1
		If PlayerX&gt;0 Then If Maze[PlayerX-1,PlayerY]=AllWalls Then W=1
		If PlayerX&lt;SizeX-1 Then If Maze[PlayerX+1,PlayerY]=AllWalls Then E=1
	
		' Are we at a dead end?  If so, go back to the room we came from and try again
		If (N+S+E+W)=0 Then 
			HistoryLen=HistoryLen-1
			PlayerX=History[HistoryLen,0]; PlayerY=History[HistoryLen,1]
			Continue
		EndIf
		
		' Choose a random direction until we get one we can actually use, then knock down the wall in that direction.
		DestX=-1
		Repeat
			dir=Rand(4)
			Select dir
				Case 1
					If N Then DestX=PlayerX; DestY=PlayerY-1; Maze[PlayerX,PlayerY]:-wNorth; Maze[DestX,DestY]:-wSouth
				Case 2
					If S Then DestX=PlayerX; DestY=PlayerY+1; Maze[PlayerX,PlayerY]:-wSouth; Maze[DestX,DestY]:-wNorth
				Case 3
					If E Then DestX=PlayerX+1; DestY=PlayerY; Maze[PlayerX,PlayerY]:-wEast; Maze[DestX,DestY]:-wWest
				Case 4
					If W Then DestX=PlayerX-1; DestY=PlayerY; Maze[PlayerX,PlayerY]:-wWest; Maze[DestX,DestY]:-wEast
			End Select
		Until DestX&lt;&gt;-1
		
		' Our new cell is (DestX,DestY).  Increment our 'visited' counter, update the history, and start over from the new cell
		VisitCount:+1
		HistoryLen:+1
		History[HistoryLen,0]=DestX; History[HistoryLen,1]=DestY
		PlayerX=DestX; PlayerY=DestY
	Wend
	
	' If we get here, we've finished generating the map
	Return 1;  
	
End Function


Rem ---------- FUNCTION TO DRAW THE ENTIRE MAZE ON THE SCREEN, TOP DOWN -----------------------------------

	Pretty straightforward; go through each cell and use DrawLine to draw any walls the cell has.
	By setting TopLeftX2D, TopLeftY2D and maxsize, we can fit the maze into any section of the screen.
	
	If Showplayer is set, it will display a yellow triangle showing the player's location and Facing
	
End Rem

Function DrawMaze2D(showplayer)
	
	' We'll use these to calculate the co-ordinates of the four corners
	Local cx1, cy1, cx2, cy2
	
	' Booleans to decide which walls to draw
	Local N, S, E, W
	
	' Loop variables
	Local x, y
	
	' These decide how big we're drawing the maze based on the current graphics mode
	Local csx, csy, CellSize
	
	' Used to show the player
	Local topx#, topy#, tri#[]
	
	' Map is drawn in light green
	SetColor(128,128,0)

	' Figure out how big we can draw each cell while retaining a square aspect ratio.  Since the dimensions
	' don't actually change, we could do this in an external routine but it's so little calculation
	' I haven't bothered
	csx=Floor(DisplayWidth2D/SizeX);
	csy=Floor(DisplayHeight2D/SizeY);
	If csx&lt;csy Then CellSize=csx Else CellSize=csy
	
	' Breadcrumb size
	Local bcs=cellsize/3
	
	' And now draw them
	For y=0 To SizeY-1
		For x=0 To SizeX-1
			' Work out which walls are in place
			N=Maze[x,y] &amp; wNorth
			S=Maze[x,y] &amp; wSouth
			E=Maze[x,y] &amp; wEast
			W=Maze[x,y] &amp; wWest
			
			'Calculate the corners
			cx1=x*CellSize
			cx2=cx1+CellSize-1
			cy1=y*CellSize
			cy2=cy1+CellSize-1
			
			'Now draw the standing walls
			If N Then DrawLine(TopLeftX2D+cx1,TopLeftY2D+cy1,TopLeftX2D+cx2,TopLeftY2D+cy1)
			If S Then DrawLine(TopLeftX2D+cx1,TopLeftY2D+cy2,TopLeftX2D+cx2,TopLeftY2D+cy2)
			If E Then DrawLine(TopLeftX2D+cx2,TopLeftY2D+cy1,TopLeftX2D+cx2,TopLeftY2D+cy2)
			If W Then DrawLine(TopLeftX2D+cx1,TopLeftY2D+cy1,TopLeftX2D+cx1,TopLeftY2D+cy2)
			
			' If we're displaying breadcrumbs
			If ShowBreadcrumbs Then
				If Maze[x,y]&amp;BreadCrumb Then DrawOval(TopLeftX2D+cx1+bcs,TopLeftY2D+cy1+bcs,bcs,bcs)
			EndIf
			
		Next
	Next
	
	' Draw a triangle in the player's location, pointing in the direction the player is Facing
	If showplayer Then
		topx=TopLeftX2D+(PlayerX*cellsize)
		topy=TopLeftY2D+(PlayerY*cellsize)
		Select Facing
			Case wNorth
				tri=[topx+2,topy+cellsize-1,topx+cellsize-3,topy+cellsize-1,topx+(cellsize/2),topy]
			Case wSouth
				tri=[topx+2,topy,topx+cellsize-3,topy,topx+(cellsize/2),topy+cellsize-1]
			Case wEast
				tri=[topx,topy+2,topx,topy+cellsize-3,topx+cellsize-1,topy+(cellsize/2)]
			Case wWest
				tri=[topx+cellsize-1,topy+2,topx+cellsize-1,topy+cellsize-3,topx,topy+(cellsize/2)]
		End Select
		SetColor 255,255,0
		DrawPoly(tri)
	EndIf
	
	' Draw the goal square as a green checkerboard
	SetColor 0,255,0
	topx=TopLeftX2D+(GoalX*cellsize)
	topy=TopLeftY2D+(GoalY*cellsize)
	
	' Reuse these variables to calculate a quarter and half of a cellsize
	cx1=cellsize/4
	cx2=cellsize/2

	' Could do this in a loop, but for such a small checkerboard, this is just as efficient
	DrawRect(topx,topy,cx1,cx1)
	DrawRect(topx+cx2,topy,cx1,cx1)
	DrawRect(topx,topy+cx2,cx1,cx1)
	DrawRect(topx+cx2,topy+cx2,cx1,cx1)
	DrawRect(topx+cx1,topy+cx1,cx1,cx1)
	DrawRect(topx+cx1+cx2,topy+cx1,cx1,cx1)
	DrawRect(topx+cx1,topy+cx1+cx2,cx1,cx1)
	DrawRect(topx+cx1+cx2,topy+cx1+cx2,cx1,cx1)

End Function



Rem ---------- FUNCTION TO INITIALISE FREQUENTLY USED VARIABLES -------------------------------

	In other words, everything we need to calculate when we first start a maze

End Rem

Function InitialiseVars()

	' Used to figure out the size of the segments
	Local csx, csy, remainingwidth, remainingheight, segnum

	' What fraction (1/divisor) of screen space to use for each segment.  Actually, it's what fraction of
	' half the screen space, as the screen is considered to be a left half and a right half
	Local divisor:Double=2

	' Work out where the corners of each display segment are	
	remainingwidth=Floor(DisplayWidth3D/2)
	remainingheight=Floor(DisplayHeight3D/2)

	csx=Floor(remainingwidth/divisor)
	csy=Floor(remainingheight/divisor)
	segnum=0
	
	xpos[0,0]=TopLeftX3D
	ypos[0,0]=TopLeftY3D
	xpos[0,1]=TopLeftX3D+DisplayWidth3D-1
	ypos[0,1]=TopLeftY3D+DisplayHeight3D-1

	segnum=1	
	While segnum&lt;=DisplaySegments
		' top left
		xpos[segnum,0]=xpos[segnum-1,0]+Floor(remainingwidth/divisor)
		ypos[segnum,0]=ypos[segnum-1,0]+Floor(remainingheight/divisor)
		
		' bottom right
		xpos[segnum,1]=xpos[segnum-1,1]-Floor(remainingwidth/divisor)
		ypos[segnum,1]=ypos[segnum-1,1]-Floor(remainingheight/divisor)

		remainingwidth:-Floor(remainingwidth/divisor)
		remainingheight:-Floor(remainingheight/divisor)
		segnum:+1
	Wend

End Function


Rem  ---------- FUNCTION TO DRAW A 3D VIEW OF THE MAZE FROM A GIVEN POSITION AND A GIVEN FACING ------------

	segments is how many cells ahead we could plot in total visibility
	visibility is how many cells ahead we actually plot - must be &lt;= segments
	
	This routine will only work with a 'closed' maze - that is, where every cell has at least one wall.
	
	It divides the left and right halves of the screen into segments.  The first segment (closest to us)
	takes 1/divisor the space - so if our display area is 600 pixels wide, that's 300 for the left side and
	300 for the right side, so the first segment will be 1/divisor of that (eg, divisor=2, first segment=150 pixels)
	Each segment further away is 1/divisor of the remaining space.  Exactly the same is done for the height.
	
	To draw the map is fairly straightforward.  Starting in the current cell, we look left, right and front.
	If there's a wall to the left, we draw a polygon from the top and bottom edge of this segment to the 
	top and bottom edge of the next segment - which will look like it's sloping away from us in perspective.
	If there's NOT a wall to the left, we draw a box instead - the left and right x coordinates are still
	the edge of this segment and the edge of the next segment respectively - but its top and bottom y coordinates
	both come from the segment in front of us so it looks straight and further away.  The right wall is then drawn 
	the same way.
	
	Then if there's a wall in front of us, we draw it and then exit (as we can't see anything beyond the wall).
	Otherwise, we move one cell forwards and go back to drawing the L and R again.  We repeat this until we either
	hit a wall in front of us, or we reach the specified 'visibility' limit.
	
End Rem

Function DrawMaze3D()

	' Firstly, work out the corner co-ordinates for each segment as an offset from the left and top - we simply
	' mirror the offsets to get the right and bottom
	
	' Used to move through the view
	Local incr_x, incr_y, draw_x, draw_y, drawsize_x, drawsize_y, cell, segnum
	
	' Booleans to tell if there are walls in these directions
	Local wFront, wLeft, wRight
	
	' An array to store the polygon coordinates for drawing
	Local poly#[]
	
	' What colour to draw the walls, and how much darker to make them as they move away from us
	Local wallcolor, colordec
	
	' Breadcrumb size
	Local bcs=32
	
	' Error checking first
	If PlayerX&lt;0 Or PlayerX&gt;=SizeX Then DebugLog("DrawMaze3D: invalid x position specified"); Return 0
	If PlayerY&lt;0 Or PlayerY&gt;=SizeY Then DebugLog("DrawMaze3D: invalid y position specified"); Return 0

	' Start with whitish walls, and for each segment get darker.
	wallcolor=200
	colordec=Floor(wallcolor/VisibleSegments)
	
	' Work out how to move forwards in the view based on the specified Facing	
	Select Facing
		Case wNorth
			incr_x=0; incr_y=-1
		Case WSouth
			incr_x=0; incr_y=1
		Case wEast
			incr_x=1; incr_y=0
		Case wWest
			incr_x=-1; incr_y=0
		Default DebugLog("DrawMaze3D: invalid Facing specified"); Return 0
	End Select
	
	' Our current co-ordinates start with the starting position
	draw_x=PlayerX
	draw_y=PlayerY

	' Draw a brown floor
	SetBlend(SOLIDBLEND)
	SetColor(100,100,50)
	DrawRect(TopLeftX3D,TopLeftY3D+DisplayHeight3D/2,DisplayWidth3D,DisplayHeight3D/2)
	
	' And a blue sky
	SetColor(100,100,255)
	DrawRect(TopLeftX3D,TopLeftY3D,DisplayWidth3D,DisplayHeight3D/2)
	
	' And here we go
	segnum=0
	While segnum&lt;VisibleSegments
		SetColor(WallColor,WallColor,WallColor)
		
		' Which cells we consider to be "front", "left" and "right" depend on which way we're Facing
		cell=Maze[draw_x,draw_y]
		Select Facing
			Case wNorth
				wFront=cell&amp;wNorth
				wLeft=cell&amp;wWest
				wRight=cell&amp;wEast
			Case wSouth
				wFront=cell&amp;wSouth
				wLeft=cell&amp;wEast
				wRight=cell&amp;wWest
			Case wEast
				wFront=cell&amp;wEast
				wLeft=cell&amp;wNorth
				wRight=cell&amp;wSouth
			Case wWest
				wFront=cell&amp;wWest
				wLeft=cell&amp;wSouth
				wRight=cell&amp;wNorth
		End Select
	
		' Draw breadcrumb?
		If ShowBreadcrumbs Then
			If (cell&amp;BreadCrumb) Then DrawOval(ScreenWidth/2,ypos[segnum,1],bcs,bcs)
		EndIf

		' If we're displaying the destination cell, make the walls green and draw a darker green floor
		If (draw_x=GoalX) And (draw_y=GoalY) Then
			SetColor(0,WallColor/2,0)
			poly=[xpos[segnum+1,0],ypos[segnum+1,1], xpos[segnum+1,1],ypos[segnum+1,1], xpos[segnum,1],ypos[segnum,1], xpos[segnum,0],ypos[segnum,1]]
			DrawPoly(poly)
			SetColor(0,WallColor,0)
		Else
			SetColor(WallColor,WallColor,WallColor)
			WallColor:-ColorDec
		EndIf
	
		' If there's a wall to the left, draw a polygon to display it, otherwise draw a rectangle
		If wLeft Then
			poly=[xpos[segnum,0],ypos[segnum,0],xpos[segnum+1,0],ypos[segnum+1,0],xpos[segnum+1,0],ypos[segnum+1,1],xpos[segnum,0],ypos[segnum,1]]
		Else
			poly=[xpos[segnum,0],ypos[segnum+1,0],xpos[segnum+1,0],ypos[segnum+1,0],xpos[segnum+1,0],ypos[segnum+1,1],xpos[segnum,0],ypos[segnum+1,1]]
		EndIf
		DrawPoly(poly)

		' Ditto for the right		
		If wRight Then
			poly=[xpos[segnum,1],ypos[segnum,0], xpos[segnum+1,1],ypos[segnum+1,0], xpos[segnum+1,1],ypos[segnum+1,1], xpos[segnum,1],ypos[segnum,1]]
		Else
			poly=[xpos[segnum+1,1],ypos[segnum+1,0], xpos[segnum,1],ypos[segnum+1,0], xpos[segnum,1],ypos[segnum+1,1], xpos[segnum+1,1],ypos[segnum+1,1]]
		EndIf
		DrawPoly(poly)
		
		' if there's a wall directly in front, draw it and get out, nothing else to do
		If wFront Then  
			DrawRect(xpos[segnum+1,0],ypos[segnum+1,0],xpos[segnum+1,1]-xpos[segnum+1,0],ypos[segnum+1,1]-ypos[segnum+1,0])
			Exit
		EndIf

		' Move forwards in the view and start over
		segnum:+1
		draw_x:+incr_x
		draw_y:+incr_y
		
		bcs=bcs/2
	Wend

End Function


Rem ---------- MOVE FORWARDS -----------------------------------
	
	Depending on which way we're Facing, see if there's a wall in front of us (or an edge), and
	if not, then move to it
	
End Rem

Function MoveForwards()
	Select Facing
		Case wNorth
			If PlayerY&gt;0 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wNorth) Then
					PlayerY:-1
					Return 1
				EndIf
			EndIf
		Case wSouth
			If PlayerY&lt;SizeY-1 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wSouth) Then
					PlayerY:+1
					Return 1
				EndIf
			EndIf
		Case wEast
			If PlayerX&lt;SizeX-1 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wEast) Then
					PlayerX:+1
					Return 1
				EndIf
			EndIf
		Case wWest
			If PlayerX&gt;0 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wWest) Then
					PlayerX:-1
					Return 1
				EndIf
			EndIf
	End Select
	Return 0
End Function



Rem ---------- MOVE BACKWARDS -----------------------------------

	Exactly as for MoveForwards, except the directions are reversed
	
End Rem

Function MoveBackwards()
	Select Facing
		Case wNorth
			If PlayerY&lt;SizeY-1 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wSouth) Then
					PlayerY:+1
					Return 1
				EndIf
			EndIf
		Case wSouth
			If PlayerY&gt;0 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wNorth) Then
					PlayerY:-1
					Return 1
				EndIf
			EndIf
		Case wEast
			If PlayerX&gt;0 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wWest) Then
					PlayerX:-1
					Return 1
				EndIf
			EndIf
		Case wWest
			If PlayerX&lt;SizeX-1 Then
				If Not(Maze[PlayerX,PlayerY]&amp;wEast) Then
					PlayerX:+1
					Return 1
				EndIf
			EndIf
	End Select
	Return 0
End Function



Rem ---------- TURN LEFT -----------------------------------

	Rotate the player to turn left
	
End Rem

Function TurnLeft()
	Select Facing
		Case wNorth
			Facing=wWest
			Return 1
		Case wSouth
			Facing=wEast
			Return 1
		Case wEast
			Facing=wNorth
			Return 1
		Case wWest
			Facing=wSouth
			Return 1
	End Select
	Return 0
End Function


Rem ---------- TURN RIGHT -----------------------------------

	Rotate the player to turn right
	
End Rem

Function TurnRight()
	Select Facing
		Case wNorth
			Facing=wEast
			Return 1
		Case wSouth
			Facing=wWest
			Return 1
		Case wEast
			Facing=wSouth
			Return 1
		Case wWest
			Facing=wNorth
			Return 1
	End Select
	Return 0
End Function


Rem --------- DISPLAY STATUS BAR ---------------------------

	Display the player's location and Facing in text form
	
End Rem

Function DrawStatus(x,y)
	Local status:String = "You're at ("+(PlayerX+1)+","+(PlayerY+1)+") Facing "
	Select Facing
		Case wNorth status:+"North"
		Case wSouth status:+"South"
		Case wEast status:+"East"
		Case wWest status:+"West"
	End Select
	status:+".  You've made "+moves+" moves so far."
	DrawCenteredText(status,ScreenHeight-20,1,255,255,0,0)
	Return 1
End Function


Rem ------------ DISPLAY CENTERED AND SCALED TEXT ------------------------

	Takes the string, scales it, works out how to put it in the center of the screen and does so

End Rem

Function DrawCenteredText(message:String,y,scale:Double,r,g,b,shadowoffset)

	Local width=TextWidth(message)
	Local xpos=(ScreenWidth-(width*scale))/2

	SetScale(scale,scale)
	SetBlend(ALPHABLEND)
	If shadowoffset&gt;0
		SetColor(0,0,0)
		DrawText(message,xpos+shadowoffset,y+shadowoffset)
	EndIf
	SetColor(r,g,b)
	DrawText(message,xpos,y)
	SetBlend(SOLIDBLEND)
	SetScale(1,1)

End Function


Rem -------- DISPLAY THE TITLE SCREEN AND GAME OPTIONS ---------------------------
	
	Display the Title screen and get the player to select a game

End Rem

Function DisplayTitleScreen()
	
	Cls
	DrawCenteredText("Maze-3D",20,6,255,255,0,0)
	DrawCenteredText("Written By Lindsay Baker",120,3,0,255,0,0)
	DrawCenteredText("http://www.lpbaker.com",160,2,0,255,0,0)
	DrawCenteredText("Select the maze size:",250,2,127,127,127,0)
	DrawCenteredText("(W)impy! 15x10",300,3,127,127,127,0)
	DrawCenteredText("(N)ormal 30x20",350,3,127,127,127,0)
	DrawCenteredText("(H)ard 60x40",400,3,127,127,127,0)
	DrawCenteredText("... or press ESCAPE to run away like a coward!",500,2,127,127,127,0)
	DrawCenteredText(CurrentVersion,580,1,200,200,200,0)
	Flip
	Cls
	
	While (1)
		If KeyHit(KEY_W) Then
			SizeX=15
			SizeY=10
			Return 1
		EndIf
		If KeyHit(KEY_N) Then
			SizeX=30
			SizeY=20
			Return 1
		EndIf
		If KeyHit(KEY_H) Then
			SizeX=60
			SizeY=40
			Return 1
		EndIf
		If KeyHit(KEY_ESCAPE) Then
			Return 0
		EndIf
	Wend
	
	' Can't actually get here, but for tidyness;
	Return 0

End Function


Rem ------------ DISPLAY INSTRUCTIONS ----------------------------------------

	Display instructions.  They will automatically disappear when the player moves

End Rem

Function DisplayInstructions()

	'Red text, scale 2
	Local r=255,g=255,b=255,o=2

	DrawCenteredText("Instructions",50,4,r,g,b,o)

	DrawCenteredText("Press UP ARROW to move forwards",150,2,r,g,b,o)
	DrawCenteredText("Press DOWN ARROW to move backwards",190,2,r,g,b,o)

	DrawCenteredText("Press LEFT ARROW to turn left",250,2,r,g,b,o)
	DrawCenteredText("Press RIGHT ARROW to turn right",290,2,r,g,b,o)
	
	DrawCenteredText("Press M to switch between Map and 3D view",350,2,r,g,b,o)
	DrawCenteredText("Press B to turn the breadcrumbs on/off",390,2,r,g,b,o)
	DrawCenteredText("Press I to see these instructions again",430,2,r,g,b,o)
	
	DrawCenteredText("Press ESCAPE to run away like a coward!",500,2,r,g,b,o)

End Function


Rem ----------- DISPLAY WINNING SCREEN -------------------------------------
	
	Player has won, so calculate and display their score
	
End Rem


Function DisplayWinningScreen()

	Local bonus=0, y=200, r=255, g=255, b=255, o=2, maxscore#=(SizeX*SizeY*movevalue)+5000, pc#, rating:String
	
	DrawCenteredText("Congratulations, you made it!",100,3,r,g,b,o)
	DrawCenteredText("Press SPACE to play again",ScreenHeight-100,2,r,g,b,o)
	
	DrawCenteredText("Score: "+score,y,2,r,g,b,o); y:+50
	If Not UsedMap Then bonus:+2500; DrawCenteredText("Map Bonus: 2500",y,2,r,g,b,o); y:+50
	If Not UsedBreadcrumbs Then bonus:+2500; DrawCenteredText("Breadcrumb Bonus: 2500",y,2,r,g,b,o); y:+50
	If bonus Then DrawCenteredText("TOTAL SCORE: "+(score+bonus),y,2,r,g,b,o); y:+50
	
	' Work out the percentage of possible maximum score, and rate player accordingly
	pc#=100*(Float(score+bonus)/maxscore)
	rating="Your rating is "+String(Int(Floor(pc#)))+"%"
	DrawCenteredText(rating,y,2,r,g,b,o)
	y:+50
	
	If pc&lt;10 Then
		DrawCenteredText("You should stay out of mazes!",y,2,r,g,b,o)
	Else If pc&lt;30 Then
		DrawCenteredText("You need a lot more practice!",y,2,r,g,b,o)
	Else If pc&lt;50 Then
		DrawCenteredText("Not bad, but you could do better!",y,2,r,g,b,o)
	Else If pc&lt;75 Then
		DrawCenteredText("Pretty good!",y,2,r,g,b,o)
	Else If pc&lt;90 Then
		DrawCenteredText("Impressive!",y,2,r,g,b,o)
	Else
		DrawCenteredText("You are a mighty maze solver!",y,2,r,g,b,o)
	EndIf

	Flip
	Cls
	While Not KeyHit(KEY_SPACE)
		' wait
	Wend
	FlushKeys()
	
	Return 1
	
End Function



Rem ---------- CHECK IF PLAYER REALLY WANTS TO QUIT ------------------------

	While in the game itself, if the player presses ESCAPE, make sure they actually wanted to
	
End Rem

Function CheckQuit()
	
	Local rv=-1
	FlushKeys()

	Cls
	DrawCenteredText("Oh I see, running away eh?",200,3,255,255,255,2)
	DrawCenteredText("Press Y to confirm, or N to keep trying",300,2,255,255,255,2)
	Flip
	Cls
	
	While(rv=-1)
		If KeyHit(KEY_Y) Then rv=1
		If KeyHit(KEY_N) Then rv=0
	Wend
	
	FlushKeys()
	Return rv

End Function


' ---------- MAIN PROGRAM -------------------------------------------------

' A flag to display instructions
Local dispinst=1

' A flag to indicate we need to redraw the screen
Local redraw

' Initially display the 3D view, not the map.  If we turn the map on, the 3D view goes away, and vice-versa
Local display_map=0

' What screen size to use
ScreenWidth=800
ScreenHeight=600

' Size and position of the 2D map
TopLeftX2D=10; TopLeftY2D=10
DisplayWidth2D=ScreenWidth-(2*TopLeftX2D)
DisplayHeight2D=ScreenHeight-(2*TopLeftY2D)-20  ' the -20 allows room for the status line

' Size and position of the 3D map
TopLeftX3D=10; TopLeftY3D=10
DisplayWidth3D=ScreenWidth-(2*TopLeftX3D)
DisplayHeight3D=ScreenHeight-(2*TopLeftY3D)-20  ' the -20 allows room for the status line

' Initialise graphics
AppTitle="3D Maze"
Graphics(ScreenWidth,ScreenHeight)

' Here's where the game starts

While (1)

	' Display title screen, and if we get a return of zero, quit the game
	If Not DisplayTitleScreen() Then Exit
	FlushKeys()
	
	' Set up our starting and goal positions - the top left and bottom right are good choices
	StartX=0
	StartY=0
	GoalX=SizeX-1
	GoalY=SizeY-1
	moves=-1  ' when the map is drawn the first time, this will increment to zero
	
	InitialiseVars()
	GenerateMaze()
	redraw=1
	
	MoveValue=20 ' you lose 20 points every time you move!
	UsedMap=0	 ' did you use the map?  if not, you get a score bonus at the end
	UsedBreadcrumbs=0  ' did you use the breadcrumbs?  ditto
	Score=SizeX*SizeY*MoveValue   ' you start with full score and it decreases from there
	
	' Always start in 3D mode
	display_map=0
	
	' Always start with breadcrumbs off
	ShowBreadcrumbs=0

	' Starting position and Facing, which is automatically chosen to ensure we don't start out Facing a wall
	PlayerX=StartX
	PlayerY=StartY
	If Not(maze[PlayerX,PlayerY]&amp;wNorth) Then
		Facing=wNorth
	Else If Not(maze[PlayerX,PlayerY]&amp;wSouth) Then
		Facing=wSouth
	Else If Not(maze[PlayerX,PlayerY]&amp;wEast) Then
		Facing=wEast
	Else If Not(maze[PlayerX,PlayerY]&amp;wWest) Then
		Facing=wWest
	EndIf
	
	
	' Main program loop
	While (1)
		' Player movement
		If KeyHit(KEY_UP) Then redraw=MoveForwards()
		If KeyHit(KEY_DOWN) Then redraw=MoveBackwards()
		
		' A bit of a kludge, but effective - if either 'move' routine returns 1, we've actually moved, so
		' increment our 'moves' counter and decrease the score
		If redraw Then 
			moves:+1
			
			' Player loses score every time they move - if they move over a breadcrumb, they lose more!
			If Maze[Playerx,PlayerY]&amp;BreadCrumb Then
				score:-MoveValue
			Else
				score:-(MoveValue/2)
			EndIf
		EndIf

		If KeyHit(KEY_ESCAPE) Then 
			If CheckQuit() Then Exit Else redraw=1
		EndIf
		
		If KeyHit(KEY_LEFT) Then redraw=TurnLeft()
		If KeyHit(KEY_RIGHT) Then redraw=TurnRight()
		
		' Switch between top-down or 3D view mode
		If KeyHit(KEY_M) Then UsedMap=1; display_map=Not display_map; redraw=1
		
		' Instructions
		If KeyHit(KEY_I) Then dispinst=1; redraw=1
		
		' Breadcrumbs
		If KeyHit(KEY_B) Then UsedBreadcrumbs=1; ShowBreadcrumbs=Not ShowBreadcrumbs; redraw=1
		
		' Turn the breadcrumb on in the current cell
		If Not (Maze[PlayerX,PlayerY]&amp;BreadCrumb) Then Maze[PlayerX,PlayerY]:+BreadCrumb
		
		' If we need to redraw the map, then do so
		If redraw Then
			Cls
			If display_map Then
				DrawMaze2D(1)
			Else
				DrawMaze3D()
			EndIf

			If dispinst Then
				DisplayInstructions()
				dispinst=0
			EndIf

			' Have we reached our goal?
			If (PlayerX=GoalX) And (PlayerY=GoalY) Then
				DisplayWinningScreen()
				Exit
			Else
				DrawStatus(StatusX,StatusY)
			EndIf
			Flip
			redraw=0
		EndIf
	Wend

Wend
</textarea> <br><br></td></tr></table><br>
<a name="953664"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting and nice retro feel but I think it would look better with a compas image some where. A real walkable version would be really nice. :)<br><br>I have that similar maze generator function in my signature link. I messed with it but I've never really done anything with it. I guess it served to show me how to do a breadh first search engine and have it incase I ever need it.<br>your code is really profesionally organize. do you know OO? one of the advantages of bmax is basically that. It is so easy to work with objects and makes you so much more productive. If you don't, I recomend the OO tutorials in the tutorials section of Blitzmax, really easy to follow. <br><br></td></tr></table><br>
<a name="953667"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Lindsay</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I think it would look better with a compas image some where <br></div><br>Probably :)  I did consider that, actually, and may still put it in, but then again I may leave this alone in its retro goodness and move on to something a little more modern ...<br><br><div class="quote"> A real walkable version would be really nice. :) <br></div><br>... Like that, for example!<br><br><div class="quote"> your code is really profesionally organize. do you know OO? <br></div><br>Thanks!  Yes, I know OO although I'm out of practice and I'm still getting my head around all the new features of Blitz's version of Basic - it's sure not the Basic I used on my Vic-20!<br><br>Thanks, <br><br></td></tr></table><br>
<a name="953728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Reminds me of the Amiga's attempts to do 3d :-D <br><br></td></tr></table><br>
<a name="953752"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah yes I remember these type of games. Some were in wireframe. <br><br></td></tr></table><br>
<a name="953760"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sultans Maze on the Amstrad CPC, well, thats what it looks like to me! :)<br><br>Pretty cool that! :)<br><br>Dabz <br><br></td></tr></table><br>
<a name="953799"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Add some monsters and call it dungeon master... ;) <br><br></td></tr></table><br>
<a name="953825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DavidDC</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow it's hard if you try 3d with no helpers! I'm actually being reminded of a graphic adventure called "Asylum".<br><br>Maybe the top-down arrow could be smaller but overall I like it.<br><br>Very nice to see all those comments in the code. My very first thought when looking at the code was that it's nicely set out, but I still wouldn't want to do a big project like that. But I guess that's more a stylistic comment and I'm coming from a very OO mindset.<br><br>For just a few days coding and especially for someone new to the language I think it's a really great effort. Thanks for sharing. <br><br></td></tr></table><br>
<a name="953856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Lindsay</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the feedback everyone :)  This one was just to get me back into programming so very little planning went into it.  For my next one, I'm thinking of doing something along the lines of Rally-X so I try out a tiling engine :) <br><br></td></tr></table><br>
<a name="953913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tobo</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am so envious.<br><br>That little program is so neat and tidy, and the code so well commented.<br><br>A classic example to inspire us noobs everywhere.<br><br>T <br><br></td></tr></table><br>
<a name="953933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ginger Tea</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> i remember 3D bat attack on the speccy, all it was was pacman but in wireframe 3D<br>ghosts bats<br>pills gold bars<br>powerpill garlic<br>althoguh not content with just ending the level after collecting the last bar you had to reach an exit marker too, but pacman none the less <br><br></td></tr></table><br>
<a name="953944"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> You really need to switch to OO in BlitzMax. Also use SuperStrict. It will all pay off in the long run. <br><br></td></tr></table><br>
<a name="954000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Agree with Beaker :-) <br><br></td></tr></table><br>
<a name="954005"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Couple of more tips Lindsay,<br><br>Use "Framework" to cut down on the final complied binary size. It allows you to import only the modules the game needs. I have a tool to help ... <a href="http://homepage.ntlworld.com/config/fa" target="_blank">Framework Assistant</a><br><br><br><br>Instead of<br><pre class=code>	For y=0 To SizeY-1
		For x=0 To SizeX-1
</pre><br>you can do:<br><pre class=code>	For y=0 Until SizeY
		For x=0 Until SizeX
</pre><br><br><br>It's worth sticky a Delay in loops like this one to free up the system (preventing 100% CPU usage):<br><pre class=code>
	While Not KeyHit(KEY_SPACE)
	     Delay 5
	Wend
</pre> <br><br></td></tr></table><br>
<a name="954067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Lindsay</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the tips Jim!<br><br>Beaker, I'm switching to OO for the next project.  I just needed to get my brain back in programming mode :) <br><br></td></tr></table><br>
<a name="954132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I really like this ! :) And yes, your coding style is nice. Now go OO damnit :) <br><br></td></tr></table><br>
<a name="954746"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zenith</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very cool Lindsay!!! :) <br><br></td></tr></table><br>
<a name="954762"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> bit like xybots or was it zybots?<br><br>found it:<br><br><a href="http://www.lemonamiga.com/?game_id=1156" target="_blank">http://www.lemonamiga.com/?game_id=1156</a> <br><br></td></tr></table><br>
<a name="954792"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >B</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> very cool!<br><br>amusing game to play when youre just trying to kill time, glad someone else is using mac! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
