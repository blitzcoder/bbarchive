<!DOCTYPE html><html lang="en" ><head ><title >Fractal Abortion</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Fractal Abortion</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=61" >Showcase</a>/<a href="#bottom" >Fractal Abortion</a><br><br>
<a name="1254592"></a>

<a name="1254594"></a>

<a name="1254693"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zethrax</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been playing around with my 'CreateFractalHeightmapTileable' function (code archive link below) trying to extend it to work in three dimensions so that I can generate 3D tileable animated images for billowing clouds, water, etc. The code below is an early incomplete attempt that didn't quite go to plan. We are not yet in the 'success' space.<br><br>The fun thing about working with fractals though is that even the mutant abortions often look pretty, so I thought I'd share.<br><br>Create a heightmap using the Diamond-Square algorithm (code archive code that the below code is based on) (Blitz3D code)<br><a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=3172" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=3172</a><br><br>Fractal Abortion code (Blitz3D code)<br>(This code is in the public domain. Feel free to experiment with it.)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; The 'CreateFractalHeightmapTileable' function creates a fractal heightmap image that can be used as a terrain heightmap or a cloud texture.
; You can also perturb this heightmap algorithm and data in various ways to achieve some interesting and useful results (see the 'filter' option for one example).
; The function uses the Diamond-Square algorithm to create the heightmap data.

; Note that the heightmap data produced by this code is tileable on both axiis.

; REFERENCES:-
;	<a href="http://en.wikipedia.org/wiki/Diamond-square_algorithm" target="_blank">http://en.wikipedia.org/wiki/Diamond-square_algorithm</a>
;	<a href="http://www.playfuljs.com/realistic-terrain-in-130-lines/" target="_blank">http://www.playfuljs.com/realistic-terrain-in-130-lines/</a>
;	<a href="http://www.gameprogrammer.com/fractal.html" target="_blank">http://www.gameprogrammer.com/fractal.html</a>
;	<a href="http://srchea.com/terrain-generation-the-diamond-square-algorithm-and-three-js" target="_blank">http://srchea.com/terrain-generation-the-diamond-square-algorithm-and-three-js</a>
;	<a href="https://danielbeard.wordpress.com/2010/08/07/terrain-generation-and-smoothing/" target="_blank">https://danielbeard.wordpress.com/2010/08/07/terrain-generation-and-smoothing/</a>


; Declare the array used to store the heightmap data.
Dim A_heightmap#( 0, 0, 0 )


Function CreateFractalHeightmapTileable( size = 512, num_layers = 10, seed = 0, roughness# = 0.5, filter# = 0.0 )
; PARAMETERS:-
;	size% - (Int) Sets the number of squares on each side of the heightmap. Must be a power of 2 integer number greater than 3 (4, 8, 16, 32, etc). Defaults to 512.
;	seed% - (Int) Sets the seed used with the random number generator. Defaults to grabbing the seed value from the millisecs system clock timer.
;	- Using the same seed value will produce the same heightmap.
;	roughness# - (Float) (Range: 0.0 - 1.0) Sets the roughness# of the resulting fractal terrain. 0.0 = Smooth. 1.0 = Rough. Defaults to 0.5.
;	filter# - (Float) A quickie filter option I added to show what can be done with some fiddling and diddling. Value can be whatever you want.
;	- 10.0 to 30.0 is recommended for some interesting results. 0.0 (the default) = no filtering.

; RETURNS:-
;	The function returns an image handle. The image uses the heightmap data for the red, green, blue, and alpha values.
;	- The alpha values in the returned image use the heightmap data, so they will be more transparent in darker areas of the image and less transparent in lighter areas.
;	- This makes the alpha data useful for tranparent clouds.
;	The 'A_heightmap' array is also available after the function has finished. This array contains all the heightmap data. The values it stores will be within the range 0.0 to 1.0 (inclusive).
;	- Note that since the algorithm is actually working with the cornerpoint data the array will have an extra row and column. Either grab the first 'size' number of rows
;	- (0 To size-1) or blend the data (using bilinear filtering or whatever).


; REQUIRES:-
;	The 'SetSquareMidpoint' and 'SetDiamondMidpoint' functions below are required by this function.

; Note that the heightmap data produced by this code is tileable on both axiis.


Local squaresize, half, endpoint, x, y, scale#, v#
Local max_layer = num_layers - 1, l
Local layerscale# = 1.0 / max_layer

; - Generate the seed value used for random numbers.
If seed ; If seed is non-zero (True)...
	SeedRnd seed ; Seed the random number generator with the specified seed value.
Else ; If seed is zero (False)...
	SeedRnd MilliSecs() ; Seed the random number generator from the millisecs system clock timer.
EndIf
;---

Dim A_heightmap( size, size, max_layer ) ; Creates size+1 number of slots as required by the algorithm.
For l = 0 To max_layer

	;randscale# = 1.0 / max_layer
	;prevscale# = 1.0 - randscale#

	; - Create the 4 initial height values for the corner points of the starting square.
	; Seed the corners with the same values for each corner (values must be the same for the data to tile).
	If l = 0 ; The starting layer.
		v# = Rnd( 0.0, 1.0 )
	Else ; The layers following the starting layer.
		; Note that as all corners will have the same value it's only necessary to get the previous layer value from one corner.
		v# = Rnd( 0.0, layerscale# ) + ( A_heightmap( 0, 0, l - 1 ) * ( 1.0 - layerscale# ) )
	EndIf
	A_heightmap( 0, 0, l ) = v# ; Top-left point.
	A_heightmap( size, 0, l ) = v# ; Top-right point.
	A_heightmap( 0, size, l ) = v# ; Bottom-left point.
	A_heightmap( size, size, l ) = v# ; Bottom-right point.
	;---

	scale# = 1.0
	squaresize = size

	; The division loop.
	; This loop progressively divides the array squares into four sub-squares until the current array square only contains one actual square
	While squaresize &gt; 1
	
		endpoint = size - squaresize ; This will evaluate to zero on the first pass, so it will only loop once on that pass.
		half = squaresize / 2
	
		; Note that in the tutorials I looked at there seems to be some confusion about which of the steps below is called the square step, and which is called the diamond step.
		; I've chosen to call the first step the square step and the second step the diamond step due to the shapes created by the points that the data is read from.
	
		; Also note that the step value used with the 'For To Step' commands in Blitz3D needs to be a constant, so I can't use 'For' here
		; (as I need to halve the step value for each pass through the division loop. I've used 'While' loops instead.
	
		; - The square step.
		; This step needs to be run first so that the diamond step can make use of the values generated here for the midpoints.
		y = 0
		While y &lt;= endpoint
			x = 0
			While x &lt;= endpoint
	
				SetSquareMidpoint( x, y, l, squaresize, scale# )
				
				x = x + squaresize
			Wend
			y = y + squaresize
		Wend
		; ---
	
		; - The diamond step.
		; This step needs to be run second so that the midpoint values generated in the square step are available.
		y = 0
		While y &lt;= endpoint
			x = 0
			While x &lt;= endpoint
	
				SetDiamondMidpoint( x + half, y, l, size, half, scale# ) ; Top
				SetDiamondMidpoint( x + squaresize, y + half, l, size, half, scale# ) ; Right			
				SetDiamondMidpoint( x + half, y + squaresize, l, size, half, scale# ) ; Bottom
				SetDiamondMidpoint( x, y + half, l, size, half, scale# ) ; Left
				
				x = x + squaresize
			Wend
			y = y + squaresize
		Wend
		; ---
		
		scale# = scale# * roughness#
		squaresize = squaresize / 2
		
	Wend

Next

; == If you just want the heightmap data in the 'A_heightmap' array then comment out or remove this section ==
; Creates an image of the specified size using the heightmap data (can be used as a terrain heightmap or cloud texture).
; You can save this image using the 'SaveImage' and 'SaveBuffer' commands.
; Note that the right column and bottom row of data in the array are not used.
Local blue, green, red
Local media = CreateImage( size, size, num_layers )
Local bank = CreateBank( 4 )
endpoint = size - 1
For l = 0 To max_layer
	SetBuffer ImageBuffer( media, l )
	For y = 0 To endpoint
		For x = 0 To endpoint
			v# = A_heightmap( x, y, l )
	
			; - Applies a basic filter to the data. One of many ways you can fiddle with it if you're a bit cunning.
			If filter# &gt; 0.0
				v# = Floor( v# * filter# ) / filter# ; Diddle the data.
			EndIf
			;---
	
			; Another rough filtering option that will result in areas with sharp drop-offs.
	;		If v# &lt; 0.5 Then v# = v# * 0.5
	
			; This option will let you blend the heightmap image with a background color (probably could be improved on).
			; Sky blue color: Blue = 255, Green = 197, Red = 138
	;		blue = ( ( v# * 255 ) + ( ( 1.0 - v# ) * 255 ) )
	;		green = ( ( v# * 255 ) + ( ( 1.0 - v# ) * 197 ) )
	;		red = ( ( v# * 255 ) + ( ( 1.0 - v# ) * 138 ) )
	
			; This option creates a standard unfiltered heightmap image.
			blue = v# * 255
			green = v# * 255
			red = v# * 255
			
			PokeByte bank, 0, blue ; Blue.
			PokeByte bank, 1, green ; Green.
			PokeByte bank, 2, red ; Red.
			PokeByte bank, 3, v# * 255 ; Alpha. 0 = fully transparent. 255 = fully opaque.
			c = PeekInt( bank, 0 )
			WritePixel x, y, c
		Next
	Next
Next
FreeBank bank
Return media
;======

End Function



Function SetSquareMidpoint( x, y, l, squaresize, scale# )
	; PARAMETERS:-
	; The x, y coordinates should be pointing to the array slot at the top-left corner of the square.
	; l - The current vertical layer.
	; squaresize - The width of the current square being worked on.
	; scale# - The scale value to apply to the random number used to add noise to the midpoint value.

	; This function does not return anything.

	
	; Add the corner points from the current layer.
	Local v# = A_heightmap( x, y, l ) ; Top-left point.
	v# = v# + A_heightmap( x + squaresize, y, l ) ; Top-right point.
	v# = v# + A_heightmap( x, y + squaresize, l ) ; Bottom-left point.
	v# = v# + A_heightmap( x + squaresize, y + squaresize, l ) ; Bottom-right point.
	
	If l = 0 ; The starting layer.		
		; Average all four points of the square and then add the random modifier.
		v = ( v# / 4.0 ) + Rnd( -scale#, scale# )
		
	Else ; The layers following the starting layer.
		; Add the corner points from the previous layer.
		v# = v# + A_heightmap( x, y, l - 1 ) ; Top-left point.
		v# = v# + A_heightmap( x + squaresize, y, l - 1 ) ; Top-right point.
		v# = v# + A_heightmap( x, y + squaresize, l - 1 ) ; Bottom-left point.
		v# = v# + A_heightmap( x + squaresize, y + squaresize, l - 1 ) ; Bottom-right point.
		; Average all eight points of the cube and then add the random modifier.
		v = ( v# / 8.0 ) + Rnd( -scale#, scale# )
	EndIf
	

	; Clip the value to be in the range 0.0 to 1.0.
	; This should result in the overall data trending into this range (and not exceeding it) without abrupt cutoffs.
	If v &lt; 0.0 Then v = 0.0
	If v &gt; 1.0 Then v = 1.0

	; Store the resulting value in the midpoint array slot.
	A_heightmap( x + squaresize / 2, y + squaresize / 2, l ) = v#
End Function



Function SetDiamondMidpoint( x, y, l, max, half, scale# )
	; PARAMETERS:-
	; The x, y coordinates should be pointing to the array slot at the centerpoint of the diamond (the slot being written to).
	; l - The current vertical layer.
	; max - The index of the highest numbered array slot in either dimension.
	; half - Half the width of the current square being worked on.
	; scale# - The scale value to apply to the random number used to add noise to the midpoint value.

	; This function does not return anything.
	
	; Note that in the diamond step one of the four array read operations used to read the point values has the potential to be out of the bounds of the array if the diamond centerpoint
	; is butting up against a side of the array.
	; To deal with this issue we check each point of the diamond to see if is out of bounds and cull the read operation for that point and set an out of bounds flag if so. This results in
	; only three of the point values being available to work with, so we just use those instead of the normal four values.
	; Since the four major cornerpoints of the array are not accessed in the diamond step we never have a situation where more than one point
	; of a diamond can be out of bounds for this step though.

	; Abort if the bottom row or right column is being accessed. The data for those is populated when filling in the top row and left column respectively.
	If ( x = max ) Or ( y = max ) Then Return	
	
	Local outofbounds = 0 ; Used to flag if one of the points on the diamond is outside the bounds of the array.
	Local v# = 0.0

	; Note that when working on the top row or left column we need to grab the out of bounds point value from its corresponding position on the other side of the array.
	
	; Get top point.
	If y = 0
		outofbounds = 1
		v = v + A_heightmap( x, max - half, l ) ; Grab the out of bounds point data from the other side of the array.
	Else
		v = v + A_heightmap( x, y - half, l )
	EndIf
	
	; Get right point.
	v = v + A_heightmap( x + half, y, l )
	
	; Get bottom point.
	v = v + A_heightmap( x, y + half, l )
	
	; Get left point.
	If x = 0
		outofbounds = 2		
		v = v + A_heightmap( max - half, y, l ) ; Grab the out of bounds point data from the other side of the array.
	Else
		v = v + A_heightmap( x - half, y, l )
	EndIf
	
	;--		
	
	If l = 0 ; The starting layer.		
		; Average the point value and add the random modifier.
		v = ( v / 4.0 ) + Rnd( -scale#, scale# )		
	Else ; The layers following the starting layer.
		; Add the centerpoint from the previous layer.
		v = v + A_heightmap( x, y, l - 1 )		
		; Average all six points of the diamond prism and then add the random modifier.
		v = ( v# / 6.0 ) + Rnd( -scale#, scale# )

		; Add the corner points from the previous layer.
;		v = v + A_heightmap( x, y - half, l - 1 ) ; Get top point.
;		v = v + A_heightmap( x + half, y, l - 1 ) ; Get right point.
;		v = v + A_heightmap( x, y + half, l - 1 ) ; Get bottom point.
;		v = v + A_heightmap( x - half, y, l - 1 ) ; Get left point.		
;		; Average all eight points of the diamond prism and then add the random modifier.
;		v = ( v# / 8.0 ) + Rnd( -scale#, scale# )
	EndIf

	; Clip the value to be in the range 0.0 to 1.0.
	; This should result in the overall data trending into this range (and not exceeding it) without abrupt cutoffs.
	If v &lt; 0.0 Then v = 0.0
	If v &gt; 1.0 Then v = 1.0

	; Note that the top-left cornerpoint of the array isn't touched by the diamond step, so we don't have to worry about handling more than one point at a time here.
	Select outofbounds
		Case 0 ; Not an edge point.
			A_heightmap( x, y, l ) = v ; Set all points that aren't on an edge of the array.
		Case 1 ; Top point.
			A_heightmap( x, y, l ) = v ; Set top point.
			A_heightmap( x, max, l ) = v ; Set corresponding bottom point.
		Case 2 ; Left point.
			A_heightmap( x, y, l ) = v; Set left point.
			A_heightmap( max, y, l ) = v ; Set corresponding right point.			
	End Select
End Function



; -- Helper and demo functions --



;Function RGB( red, green, blue )
;	; This function takes the specified red, green, and blue colors and returns them as an integer that can be used with WritePixel and similar commands.
;	
;	Local c, bank = CreateBank( 4 )
;	PokeByte bank, 0, blue ; Blue.
;	PokeByte bank, 1, green ; Green.
;	PokeByte bank, 2, red ; Red.
;	PokeByte bank, 3, 0 ; Alpha.
;	c = PeekInt( bank, 0 )
;	FreeBank bank
;	Return c
;End Function



Function BlendColor( media, num_layers, foreground_red, foreground_green, foreground_blue, background_red, background_green, background_blue )
; This function will colorize the image's grayscale, blending from the foreground color (light) to the background color (dark).

Local blue, green, red, v#, x, y, l
Local bank = CreateBank( 4 )
Local endpoint = ImageWidth( media ) - 1
For l = 0 To num_layers - 1	
	SetBuffer ImageBuffer( media, l )
	For y = 0 To endpoint
		For x = 0 To endpoint
			v# = A_heightmap( x, y, l )
	
			; This option will let you blend the heightmap image with a background color (probably could be improved on).
			; Sky blue color: Blue = 255, Green = 197, Red = 138
			blue = ( ( v# * foreground_blue ) + ( ( 1.0 - v# ) * background_blue ) )
			green = ( ( v# * foreground_green ) + ( ( 1.0 - v# ) * background_green ) )
			red = ( ( v# * foreground_red ) + ( ( 1.0 - v# ) * background_red ) )
			
			PokeByte bank, 0, blue ; Blue.
			PokeByte bank, 1, green ; Green.
			PokeByte bank, 2, red ; Red.
			PokeByte bank, 3, v# * 255 ; Alpha. 0 = fully transparent. 255 = fully opaque.
			c = PeekInt( bank, 0 )
			WritePixel x, y, c
		Next
	Next
Next
FreeBank bank
SetBuffer BackBuffer()
End Function



Function ChangeColor( media, num_layers, color_red, color_green, color_blue )
; This function will color the image.

Local blue, green, red, v#, x, y, l
Local bank = CreateBank( 4 )
Local endpoint = ImageWidth( media ) - 1
For l = 0 To num_layers - 1	
	SetBuffer ImageBuffer( media, l )
	For y = 0 To endpoint
		For x = 0 To endpoint
			v# = A_heightmap( x, y, l )
	
			blue = v# * color_blue
			green = v# * color_green
			red = v# * color_red
			
			PokeByte bank, 0, blue ; Blue.
			PokeByte bank, 1, green ; Green.
			PokeByte bank, 2, red ; Red.
			PokeByte bank, 3, v# * 255 ; Alpha. 0 = fully transparent. 255 = fully opaque.
			c = PeekInt( bank, 0 )
			WritePixel x, y, c
		Next
	Next
Next
FreeBank bank
SetBuffer BackBuffer()
End Function



; === DEMO ===



Graphics 512 + 140, 670, 0, 2

timer = CreateTimer( 60 )

size = 512
num_layers = 10
l = 0
d = 1
animtimeout = 10
anim_time = animtimeout

Print "Generating heightmap."
Print "This can take a while."
Repeat
	pos = 0
	seed = MilliSecs()
	
	media = CreateFractalHeightmapTileable( size, num_layers, seed, 0.5, 0.0 ) ; size, seed, roughness#, filter#
	
	SetBuffer BackBuffer()

	Repeat				
		Cls
		Viewport 0, 0, size, size
		Select d
			Case 0
				DrawBlock media, 0, 0, l
			Case 1
				DrawBlock media, pos, 0, l
				DrawBlock media, pos + size, 0, l
			Case -1
				DrawBlock media, 0, pos, l
				DrawBlock media, 0, pos + size, l
		End Select
		anim_time = anim_time - 1
		If anim_time = 0
			anim_time = animtimeout
			l = l + 1
			If l = num_layers Then l = 0
		EndIf
		Viewport 0, 0, GraphicsWidth(), GraphicsHeight()
		txtpos = size + 10
		Text 10, txtpos, "Random Seed: " + seed : txtpos = txtpos + 20
		Text 10, txtpos, "Click the screen to generate a new heightmap." : txtpos = txtpos + 20
		Text 10, txtpos, "Press the SPACEBAR to reset and change scroll direction." : txtpos = txtpos + 20
		Text 10, txtpos, "Press the END key to reset and toggle scroll on/off." : txtpos = txtpos + 20
		Text 10, txtpos, "Press the +/- keys to adjust the animation speed." : txtpos = txtpos + 20
		Text 10, txtpos, "Press the ENTER key to save the image to a file." : txtpos = txtpos + 20
		Text 10, txtpos, "Use the close button or ESCAPE key to exit." : txtpos = txtpos + 20
		; Colors
		txtpos = 10
		Text size + 10, txtpos, "CHANGE COLOR" : txtpos = txtpos + 20
		Text size + 10, txtpos, "0 - Grayscale" : txtpos = txtpos + 20
		Text size + 10, txtpos, "1 - Purple" : txtpos = txtpos + 20
		Text size + 10, txtpos, "2 - Red" : txtpos = txtpos + 20
		Text size + 10, txtpos, "3 - Green" : txtpos = txtpos + 20
		Text size + 10, txtpos, "4 - Orange" : txtpos = txtpos + 20
		Text size + 10, txtpos, "5 - Blue" : txtpos = txtpos + 20
		Text size + 10, txtpos, "6 - Yellow" : txtpos = txtpos + 20
		Text size + 10, txtpos, "7 - Pink" : txtpos = txtpos + 20
		Text size + 10, txtpos, "8 - Dark Red" : txtpos = txtpos + 20
		Text size + 10, txtpos, "9 - Light Pink" : txtpos = txtpos + 20
		
		Flip
		WaitTimer( timer )
		pos = pos - 1
		If pos = -size Then pos = 0
		If KeyHit( 57 ) Then If d Then d = -d : pos = 0
		If KeyHit( 207 )
			If d
				d = 0
			Else
				d = 1
			EndIf
			pos = 0
		EndIf
		If KeyHit( 11 ) Then ChangeColor( media, num_layers, 255, 255, 255 ) ; Grayscale
		If KeyHit( 2 ) Then ChangeColor( media, num_layers, 128,0,255 ) ; Purple
		If KeyHit( 3 ) Then ChangeColor( media, num_layers, 255,0,0 ) ; Red
		If KeyHit( 4 ) Then ChangeColor( media, num_layers, 0,255,0 ) ; Green
		If KeyHit( 5 ) Then ChangeColor( media, num_layers, 255,128,0 ) ; Orange
		If KeyHit( 6 ) Then ChangeColor( media, num_layers, 0,0,255 ) ; Blue
		If KeyHit( 7 ) Then ChangeColor( media, num_layers, 255,255,0 ) ; Yellow
		If KeyHit( 8 ) Then ChangeColor( media, num_layers, 255,0,128 ) ; Pink
		If KeyHit( 9 ) Then ChangeColor( media, num_layers, 128,0,0 ) ; Dark Red
		If KeyHit( 10 ) Then ChangeColor( media, num_layers, 255,128,255 ) ; Light Pink
		
		If KeyHit( 28 )
			; - Save image.
			Cls
			If SaveImage( media, seed + ".bmp" )
				Print "File saved."
			Else
				Print "File could not be saved."
			EndIf
			Print "Click the screen to continue."
			FlushMouse : WaitMouse : Delay( 100 ) : FlushMouse
			;---
		EndIf
		If KeyHit( 13 ) ; + key. Increase animation speed.
			animtimeout = animtimeout - 3
			If animtimeout &lt; 2 Then animtimeout = 2
		EndIf
		If KeyHit( 12 ) ; - key. Decrease animation speed.
			animtimeout = animtimeout + 3
		EndIf
		
		If KeyHit( 1 ) Then End
	Until MouseHit( 1 )
	FlushMouse
Forever
</textarea><br><br>EDIT: Still not fixed but I did catch a few bugs and change a few things which show the morphing effect better. Instead of using my time to find the remaining bugs and work on blending the animation frames back to the starting layer I instead spent the time more wisely adding hyperlinked text to the demo.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
; The 'CreateFractalHeightmapTileable' function creates a fractal heightmap image that can be used as a terrain heightmap or a cloud texture.
; You can also perturb this heightmap algorithm and data in various ways to achieve some interesting and useful results (see the 'filter' option for one example).
; The function uses the Diamond-Square algorithm to create the heightmap data.

; Note that the heightmap data produced by this code is tileable on both axiis.

; REFERENCES:-
;	<a href="http://en.wikipedia.org/wiki/Diamond-square_algorithm" target="_blank">http://en.wikipedia.org/wiki/Diamond-square_algorithm</a>
;	<a href="http://www.playfuljs.com/realistic-terrain-in-130-lines/" target="_blank">http://www.playfuljs.com/realistic-terrain-in-130-lines/</a>
;	<a href="http://www.gameprogrammer.com/fractal.html" target="_blank">http://www.gameprogrammer.com/fractal.html</a>
;	<a href="http://srchea.com/terrain-generation-the-diamond-square-algorithm-and-three-js" target="_blank">http://srchea.com/terrain-generation-the-diamond-square-algorithm-and-three-js</a>
;	<a href="https://danielbeard.wordpress.com/2010/08/07/terrain-generation-and-smoothing/" target="_blank">https://danielbeard.wordpress.com/2010/08/07/terrain-generation-and-smoothing/</a>


; Declare the array used to store the heightmap data.
Dim A_heightmap#( 0, 0, 0 )


Function CreateFractalHeightmapTileable( size = 512, num_layers = 10, seed = 0, roughness# = 0.5, filter# = 0.0 )
; PARAMETERS:-
;	size% - (Int) Sets the number of squares on each side of the heightmap. Must be a power of 2 integer number greater than 3 (4, 8, 16, 32, etc). Defaults to 512.
;	seed% - (Int) Sets the seed used with the random number generator. Defaults to grabbing the seed value from the millisecs system clock timer.
;	- Using the same seed value will produce the same heightmap.
;	roughness# - (Float) (Range: 0.0 - 1.0) Sets the roughness# of the resulting fractal terrain. 0.0 = Smooth. 1.0 = Rough. Defaults to 0.5.
;	filter# - (Float) A quickie filter option I added to show what can be done with some fiddling and diddling. Value can be whatever you want.
;	- 10.0 to 30.0 is recommended for some interesting results. 0.0 (the default) = no filtering.

; RETURNS:-
;	The function returns an image handle. The image uses the heightmap data for the red, green, blue, and alpha values.
;	- The alpha values in the returned image use the heightmap data, so they will be more transparent in darker areas of the image and less transparent in lighter areas.
;	- This makes the alpha data useful for tranparent clouds.
;	The 'A_heightmap' array is also available after the function has finished. This array contains all the heightmap data. The values it stores will be within the range 0.0 to 1.0 (inclusive).
;	- Note that since the algorithm is actually working with the cornerpoint data the array will have an extra row and column. Either grab the first 'size' number of rows
;	- (0 To size-1) or blend the data (using bilinear filtering or whatever).


; REQUIRES:-
;	The 'SetSquareMidpoint' and 'SetDiamondMidpoint' functions below are required by this function.

; Note that the heightmap data produced by this code is tileable on both axiis.


Local squaresize, half, endpoint, x, y, scale#, v#
Local max_layer = num_layers - 1, l
Local layerscale# = 1.0 / max_layer

; - Generate the seed value used for random numbers.
If seed ; If seed is non-zero (True)...
	SeedRnd seed ; Seed the random number generator with the specified seed value.
Else ; If seed is zero (False)...
	SeedRnd MilliSecs() ; Seed the random number generator from the millisecs system clock timer.
EndIf
;---

Dim A_heightmap( size, size, max_layer ) ; Creates size+1 number of slots as required by the algorithm.
For l = 0 To max_layer

	;randscale# = 1.0 / max_layer
	;prevscale# = 1.0 - randscale#

	; - Create the 4 initial height values for the corner points of the starting square.
	; Seed the corners with the same values for each corner (values must be the same for the data to tile).
	If l = 0 ; The starting layer.
		v# = Rnd( 0.0, 1.0 )
	Else ; The layers following the starting layer.
		; Note that as all corners will have the same value it's only necessary to get the previous layer value from one corner.
		;v# = Rnd( 0.0, layerscale# ) + ( A_heightmap( 0, 0, l - 1 ) * ( 1.0 - layerscale# ) )
		v# = A_heightmap( 1, 1, l - 1 ) ; Top left
		v# = v# + A_heightmap( size - 2, 1, l - 1 ) ; Top right
		v# = v# + A_heightmap( 1, size - 2, l - 1 ); Bottom left
		v# = v# + A_heightmap( size - 2, size - 2, l - 1 ) ; Bottom right
		v# = ( v# / 4.0 ) + Rnd( 0.0, layerscale# )		
		If v# &lt; 0.0 Then v# = 0.0
		If v# &gt; 1.0 Then v# = 1.0

	EndIf
	A_heightmap( 0, 0, l ) = v# ; Top-left point.
	A_heightmap( size, 0, l ) = v# ; Top-right point.
	A_heightmap( 0, size, l ) = v# ; Bottom-left point.
	A_heightmap( size, size, l ) = v# ; Bottom-right point.
	;---

	scale# = 1.0
	squaresize = size

	; The division loop.
	; This loop progressively divides the array squares into four sub-squares until the current array square only contains one actual square
	While squaresize &gt; 1
	
		endpoint = size - squaresize ; This will evaluate to zero on the first pass, so it will only loop once on that pass.
		half = squaresize / 2
	
		; Note that in the tutorials I looked at there seems to be some confusion about which of the steps below is called the square step, and which is called the diamond step.
		; I've chosen to call the first step the square step and the second step the diamond step due to the shapes created by the points that the data is read from.
	
		; Also note that the step value used with the 'For To Step' commands in Blitz3D needs to be a constant, so I can't use 'For' here
		; (as I need to halve the step value for each pass through the division loop. I've used 'While' loops instead.
	
		; - The square step.
		; This step needs to be run first so that the diamond step can make use of the values generated here for the midpoints.
		y = 0
		While y &lt;= endpoint
			x = 0
			While x &lt;= endpoint
	
				SetSquareMidpoint( x, y, l, squaresize, scale# )
				
				x = x + squaresize
			Wend
			y = y + squaresize
		Wend
		; ---
	
		; - The diamond step.
		; This step needs to be run second so that the midpoint values generated in the square step are available.
		y = 0
		While y &lt;= endpoint
			x = 0
			While x &lt;= endpoint
	
				SetDiamondMidpoint( x + half, y, l, size, half, scale# ) ; Top
				SetDiamondMidpoint( x + squaresize, y + half, l, size, half, scale# ) ; Right			
				SetDiamondMidpoint( x + half, y + squaresize, l, size, half, scale# ) ; Bottom
				SetDiamondMidpoint( x, y + half, l, size, half, scale# ) ; Left
				
				x = x + squaresize
			Wend
			y = y + squaresize
		Wend
		; ---
		
		scale# = scale# * roughness#
		squaresize = squaresize / 2
		
	Wend

Next

; == If you just want the heightmap data in the 'A_heightmap' array then comment out or remove this section ==
; Creates an image of the specified size using the heightmap data (can be used as a terrain heightmap or cloud texture).
; You can save this image using the 'SaveImage' and 'SaveBuffer' commands.
; Note that the right column and bottom row of data in the array are not used.
Local blue, green, red
Local media = CreateImage( size, size, num_layers )
Local bank = CreateBank( 4 )
endpoint = size - 1
For l = 0 To max_layer
	SetBuffer ImageBuffer( media, l )
	For y = 0 To endpoint
		For x = 0 To endpoint
			v# = A_heightmap( x, y, l )
	
			; - Applies a basic filter to the data. One of many ways you can fiddle with it if you're a bit cunning.
			If filter# &gt; 0.0
				v# = Floor( v# * filter# ) / filter# ; Diddle the data.
			EndIf
			;---
	
			; Another rough filtering option that will result in areas with sharp drop-offs.
	;		If v# &lt; 0.5 Then v# = v# * 0.5
	
			; This option will let you blend the heightmap image with a background color (probably could be improved on).
			; Sky blue color: Blue = 255, Green = 197, Red = 138
	;		blue = ( ( v# * 255 ) + ( ( 1.0 - v# ) * 255 ) )
	;		green = ( ( v# * 255 ) + ( ( 1.0 - v# ) * 197 ) )
	;		red = ( ( v# * 255 ) + ( ( 1.0 - v# ) * 138 ) )
	
			; This option creates a standard unfiltered heightmap image.
			blue = v# * 255
			green = v# * 255
			red = v# * 255
			
			PokeByte bank, 0, blue ; Blue.
			PokeByte bank, 1, green ; Green.
			PokeByte bank, 2, red ; Red.
			PokeByte bank, 3, v# * 255 ; Alpha. 0 = fully transparent. 255 = fully opaque.
			c = PeekInt( bank, 0 )
			WritePixel x, y, c
		Next
	Next
Next
FreeBank bank
Return media
;======

End Function



Function SetSquareMidpoint( x, y, l, squaresize, scale# )
	; PARAMETERS:-
	; The x, y coordinates should be pointing to the array slot at the top-left corner of the square.
	; l - The current vertical layer.
	; squaresize - The width of the current square being worked on.
	; scale# - The scale value to apply to the random number used to add noise to the midpoint value.

	; This function does not return anything.

	
	; Add the corner points from the current layer.
	Local v# = A_heightmap( x, y, l ) ; Top-left point.
	v# = v# + A_heightmap( x + squaresize, y, l ) ; Top-right point.
	v# = v# + A_heightmap( x, y + squaresize, l ) ; Bottom-left point.
	v# = v# + A_heightmap( x + squaresize, y + squaresize, l ) ; Bottom-right point.
	
	If l = 0 ; The starting layer.		
		; Average all four points of the square and then add the random modifier.
		v# = ( v# / 4.0 ) + Rnd( -scale#, scale# )		
	Else ; The layers following the starting layer.
		; Add the corner points from the previous layer.
		v# = v# + A_heightmap( x, y, l - 1 ) ; Top-left point.
		v# = v# + A_heightmap( x + squaresize, y, l - 1 ) ; Top-right point.
		v# = v# + A_heightmap( x, y + squaresize, l - 1 ) ; Bottom-left point.
		v# = v# + A_heightmap( x + squaresize, y + squaresize, l - 1 ) ; Bottom-right point.
		; Average all eight points of the cube and then add the random modifier.
		v# = ( v# / 8.0 ) + Rnd( -scale#, scale# )
	EndIf
	

	; Clip the value to be in the range 0.0 to 1.0.
	; This should result in the overall data trending into this range (and not exceeding it) without abrupt cutoffs.
	If v &lt; 0.0 Then v = 0.0
	If v &gt; 1.0 Then v = 1.0

	; Store the resulting value in the midpoint array slot.
	A_heightmap( x + squaresize / 2, y + squaresize / 2, l ) = v#
End Function



Function SetDiamondMidpoint( x, y, l, max, half, scale# )
	; PARAMETERS:-
	; The x, y coordinates should be pointing to the array slot at the centerpoint of the diamond (the slot being written to).
	; l - The current vertical layer.
	; max - The index of the highest numbered array slot in either dimension.
	; half - Half the width of the current square being worked on.
	; scale# - The scale value to apply to the random number used to add noise to the midpoint value.

	; This function does not return anything.
	

	; Abort if the bottom row or right column is being accessed. The data for those is populated when filling in the top row and left column respectively.
	If ( x = max ) Or ( y = max ) Then Return	
	
	Local outofbounds = 0 ; Used to flag if one of the points on the diamond is outside the bounds of the array.
	Local v# = 0.0

	; Note that when working on the top row or left column we need to grab the out of bounds point value from its corresponding position on the other side of the array.

	; -- Get the diamond corner values from the current layer.
	; Get top point.
	If y = 0
		outofbounds = 1
		v = v + A_heightmap( x, max - half, l ) ; Grab the out of bounds point data from the other side of the array.
	Else
		v = v + A_heightmap( x, y - half, l )
	EndIf
	
	; Get right point.
	v = v + A_heightmap( x + half, y, l )
	
	; Get bottom point.
	v = v + A_heightmap( x, y + half, l )
	
	; Get left point.
	If x = 0
		outofbounds = 2		
		v = v + A_heightmap( max - half, y, l ) ; Grab the out of bounds point data from the other side of the array.
	Else
		v = v + A_heightmap( x - half, y, l )
	EndIf
	;---
	
	;-
	
	If l = 0 ; The starting layer.
	
		; Average the point value and add the random modifier.
		v = ( v / 4.0 ) + Rnd( -scale#, scale# )
		
	Else ; The layers following the starting layer.

		; -- Get the diamond corner values from the previous layer.
		; Get top point.
		If y = 0
			outofbounds = 1
			v = v + A_heightmap( x, max - half, l - 1 ) ; Grab the out of bounds point data from the other side of the array.
		Else
			v = v + A_heightmap( x, y - half, l - 1 )
		EndIf
		
		; Get right point.
		v = v + A_heightmap( x + half, y, l - 1 )
		
		; Get bottom point.
		v = v + A_heightmap( x, y + half, l - 1 )
		
		; Get left point.
		If x = 0
			outofbounds = 2		
			v = v + A_heightmap( max - half, y, l - 1 ) ; Grab the out of bounds point data from the other side of the array.
		Else
			v = v + A_heightmap( x - half, y, l - 1 )
		EndIf
		;---
	
		; Add the centerpoint from the previous layer.
		;v = v + A_heightmap( x, y, l - 1 )		
		; Average all five points of the diamond prism and then add the random modifier.
		;v = ( v# / 5.0 ) + Rnd( -scale#, scale# )

		; Add the corner points from the previous layer.
;		v = v + A_heightmap( x, y - half, l - 1 ) ; Get top point.
;		v = v + A_heightmap( x + half, y, l - 1 ) ; Get right point.
;		v = v + A_heightmap( x, y + half, l - 1 ) ; Get bottom point.
;		v = v + A_heightmap( x - half, y, l - 1 ) ; Get left point.

		; Average all eight points of the diamond prism and then add the random modifier.
		v = ( v# / 8.0 ) + Rnd( -scale#, scale# )
	EndIf

	; Clip the value to be in the range 0.0 to 1.0.
	; This should result in the overall data trending into this range (and not exceeding it) without abrupt cutoffs.
	If v &lt; 0.0 Then v = 0.0
	If v &gt; 1.0 Then v = 1.0

	; Note that the top-left cornerpoint of the array isn't touched by the diamond step, so we don't have to worry about handling more than one point at a time here.
	Select outofbounds
		Case 0 ; Not an edge point.
			A_heightmap( x, y, l ) = v ; Set all points that aren't on an edge of the array.
		Case 1 ; Top point.
			A_heightmap( x, y, l ) = v ; Set top point.
			A_heightmap( x, max, l ) = v ; Set corresponding bottom point.
		Case 2 ; Left point.
			A_heightmap( x, y, l ) = v; Set left point.
			A_heightmap( max, y, l ) = v ; Set corresponding right point.			
	End Select
End Function



; -- Helper and demo functions --



;Function RGB( red, green, blue )
;	; This function takes the specified red, green, and blue colors and returns them as an integer that can be used with WritePixel and similar commands.
;	
;	Local c, bank = CreateBank( 4 )
;	PokeByte bank, 0, blue ; Blue.
;	PokeByte bank, 1, green ; Green.
;	PokeByte bank, 2, red ; Red.
;	PokeByte bank, 3, 0 ; Alpha.
;	c = PeekInt( bank, 0 )
;	FreeBank bank
;	Return c
;End Function



Function BlendColor( media, num_layers, foreground_red, foreground_green, foreground_blue, background_red, background_green, background_blue )
; This function will colorize the image's grayscale, blending from the foreground color (light) to the background color (dark).

Local blue, green, red, v#, x, y, l
Local bank = CreateBank( 4 )
Local endpoint = ImageWidth( media ) - 1
For l = 0 To num_layers - 1	
	SetBuffer ImageBuffer( media, l )
	For y = 0 To endpoint
		For x = 0 To endpoint
			v# = A_heightmap( x, y, l )
	
			; This option will let you blend the heightmap image with a background color (probably could be improved on).
			; Sky blue color: Blue = 255, Green = 197, Red = 138
			blue = ( ( v# * foreground_blue ) + ( ( 1.0 - v# ) * background_blue ) )
			green = ( ( v# * foreground_green ) + ( ( 1.0 - v# ) * background_green ) )
			red = ( ( v# * foreground_red ) + ( ( 1.0 - v# ) * background_red ) )
			
			PokeByte bank, 0, blue ; Blue.
			PokeByte bank, 1, green ; Green.
			PokeByte bank, 2, red ; Red.
			PokeByte bank, 3, v# * 255 ; Alpha. 0 = fully transparent. 255 = fully opaque.
			c = PeekInt( bank, 0 )
			WritePixel x, y, c
		Next
	Next
Next
FreeBank bank
SetBuffer BackBuffer()
End Function



Function ChangeColor( media, num_layers, color_red, color_green, color_blue )
; This function will color the image.

Local blue, green, red, v#, x, y, l
Local bank = CreateBank( 4 )
Local endpoint = ImageWidth( media ) - 1
For l = 0 To num_layers - 1	
	SetBuffer ImageBuffer( media, l )
	For y = 0 To endpoint
		For x = 0 To endpoint
			v# = A_heightmap( x, y, l )
	
			blue = v# * color_blue
			green = v# * color_green
			red = v# * color_red
			
			PokeByte bank, 0, blue ; Blue.
			PokeByte bank, 1, green ; Green.
			PokeByte bank, 2, red ; Red.
			PokeByte bank, 3, v# * 255 ; Alpha. 0 = fully transparent. 255 = fully opaque.
			c = PeekInt( bank, 0 )
			WritePixel x, y, c
		Next
	Next
Next
FreeBank bank
SetBuffer BackBuffer()
End Function



Function DrawHyperlink( x, y, linktext$, item )
	SetFont G_font_underlined
	
	Local width = StringWidth( linktext$ )
	Local height = FontHeight()
	
	Local mx = MouseX()
	Local my = MouseY()

	Local over_item = False
	
	If ( mx &gt;= x ) And ( mx &lt; ( x + width ) )
		If ( my &gt;= y ) And ( my &lt; ( y + height ) )
			G_mouseover_item = item
			over_item = True			
		EndIf
	EndIf
	If over_item ; If the mouse pointer is over the hyperlink...
		Color 0,128,0 ; Use the mouseover hyperlink color.
	Else
		Color 62,158,255 ; Use the normal hyperlink color.
	EndIf
	Text x, y, linktext$
	SetFont G_font
	Color 255, 255, 255
End Function



; === DEMO ===



; - Declare action constants.
Const C_GENERATE_NEW_HEIGHTMAP = 1
Const C_CHANGE_SCROLL_DIRECTION = 2
Const C_TOGGLE_SCROLL_ON_OFF = 3
Const C_INCREASE_ANIM_SPEED = 4
Const C_DECREASE_ANIM_SPEED = 5
Const C_SAVE_IMAGE_TO_FILE = 6
Const C_COLOR_GRAYSCALE = 100
Const C_COLOR_PURPLE = 101
Const C_COLOR_RED = 102
Const C_COLOR_GREEN = 103
Const C_COLOR_ORANGE = 104
Const C_COLOR_BLUE = 105
Const C_COLOR_YELLOW = 106
Const C_COLOR_PINK = 107
Const C_COLOR_DARK_RED = 108
Const C_COLOR_LIGHT_PINK = 109

Graphics 512 + 140, 700, 0, 2

; -- Load and set fonts.
; Note that 'LoadFont' will always return a non-zero handle even if it can't find the font. It seems to default to 'arial' in this case.
Global G_font_underlined = LoadFont( "arial", 16, True, False, True )
Global G_font = LoadFont( "arial", 16, True, False, False )
SetFont G_font
;---

Global G_mouseover_item, G_action

timer = CreateTimer( 60 )

size = 512
num_layers = 10
l = 0
d = 1
animtimeout = 10
anim_time = animtimeout

Print "Generating heightmap."
Print "This can take a while."
Repeat
	pos = 0
	seed = MilliSecs()
	
	media = CreateFractalHeightmapTileable( size, num_layers, seed, 0.5, 0.0 ) ; size, seed, roughness#, filter#
	
	SetBuffer BackBuffer()

	Repeat
		G_mouseover_item = 0
		G_action = 0
		Cls
		Viewport 0, 0, size, size
		Select d
			Case 0
				DrawBlock media, 0, 0, l
			Case 1
				DrawBlock media, pos, 0, l
				DrawBlock media, pos + size, 0, l
			Case -1
				DrawBlock media, 0, pos, l
				DrawBlock media, 0, pos + size, l
		End Select
		anim_time = anim_time - 1
		If anim_time = 0
			anim_time = animtimeout
			l = l + 1
			If l = num_layers Then l = 0
		EndIf
		Viewport 0, 0, GraphicsWidth(), GraphicsHeight()
		txtpos = size + 10
		Text 10, txtpos, "Random Seed: " + seed : txtpos = txtpos + 20
		Text 10, txtpos, "(To make a change either press the indicated key or click the hyperlinked text.)" : txtpos = txtpos + 20
		DrawHyperlink( 10, txtpos, "Press the SPACEBAR to generate a new heightmap.", C_GENERATE_NEW_HEIGHTMAP ) : txtpos = txtpos + 20
		DrawHyperlink( 10, txtpos, "Press the HOME key to reset and change scroll direction.", C_CHANGE_SCROLL_DIRECTION ) : txtpos = txtpos + 20 ; Text 10, txtpos, "Press the HOME key to reset and change scroll direction." : txtpos = txtpos + 20
		DrawHyperlink( 10, txtpos, "Press the END key to reset and toggle scroll on/off.", C_TOGGLE_SCROLL_ON_OFF ) : txtpos = txtpos + 20
		DrawHyperlink( 10, txtpos, "Press the + key to increase the animation speed.", C_INCREASE_ANIM_SPEED  ) : txtpos = txtpos + 20
		DrawHyperlink( 10, txtpos, "Press the - key to decrease the animation speed.", C_DECREASE_ANIM_SPEED ) : txtpos = txtpos + 20
		DrawHyperlink( 10, txtpos, "Press the ENTER key to save the image to a file.", C_SAVE_IMAGE_TO_FILE ) : txtpos = txtpos + 20
		Text 10, txtpos, "Use the close button or ESCAPE key to exit." : txtpos = txtpos + 20
		; Colors
		txtpos = 10
		Text size + 10, txtpos, "CHANGE COLOR" : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "0 - Grayscale", C_COLOR_GRAYSCALE ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "1 - Purple", C_COLOR_PURPLE ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "2 - Red", C_COLOR_RED ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "3 - Green", C_COLOR_GREEN ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "4 - Orange", C_COLOR_ORANGE ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "5 - Blue", C_COLOR_BLUE ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "6 - Yellow", C_COLOR_YELLOW ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "7 - Pink", C_COLOR_PINK ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "8 - Dark Red", C_COLOR_DARK_RED ) : txtpos = txtpos + 20
		DrawHyperlink( size + 10, txtpos, "9 - Light Pink", C_COLOR_LIGHT_PINK  ) : txtpos = txtpos + 20
		
		Flip
		WaitTimer( timer )		
		If MouseHit( 1 ) Then G_action = G_mouseover_item ; Update hyperlink click actions.
		pos = pos - 1 : If pos = -size Then pos = 0
		
		If KeyHit( 199 ) Or ( G_action = C_CHANGE_SCROLL_DIRECTION ) Then If d Then d = -d : pos = 0 ; HOME key - Change image scroll direction and reset position.
		
		If KeyHit( 207 ) Or ( G_action = C_TOGGLE_SCROLL_ON_OFF ) ; END key - Toggle image scrolling on/off and reset position.
			If d
				d = 0
			Else
				d = 1
			EndIf
			pos = 0
		EndIf
		
		If KeyHit( 11 ) Or ( G_action = C_COLOR_GRAYSCALE ) Then ChangeColor( media, num_layers, 255, 255, 255 ) ; Grayscale
		If KeyHit( 2 ) Or ( G_action = C_COLOR_PURPLE ) Then ChangeColor( media, num_layers, 128,0,255 ) ; Purple
		If KeyHit( 3 ) Or ( G_action = C_COLOR_RED ) Then ChangeColor( media, num_layers, 255,0,0 ) ; Red
		If KeyHit( 4 ) Or ( G_action = C_COLOR_GREEN ) Then ChangeColor( media, num_layers, 0,255,0 ) ; Green
		If KeyHit( 5 ) Or ( G_action = C_COLOR_ORANGE ) Then ChangeColor( media, num_layers, 255,128,0 ) ; Orange
		If KeyHit( 6 ) Or ( G_action = C_COLOR_BLUE ) Then ChangeColor( media, num_layers, 0,0,255 ) ; Blue
		If KeyHit( 7 ) Or ( G_action = C_COLOR_YELLOW ) Then ChangeColor( media, num_layers, 255,255,0 ) ; Yellow
		If KeyHit( 8 ) Or ( G_action = C_COLOR_PINK ) Then ChangeColor( media, num_layers, 255,0,128 ) ; Pink
		If KeyHit( 9 ) Or ( G_action = C_COLOR_DARK_RED ) Then ChangeColor( media, num_layers, 128,0,0 ) ; Dark Red
		If KeyHit( 10 ) Or ( G_action = C_COLOR_LIGHT_PINK ) Then ChangeColor( media, num_layers, 255,128,255 ) ; Light Pink
		
		If KeyHit( 28 ) Or ( G_action = C_SAVE_IMAGE_TO_FILE ) ; ENTER key - Save image.
			; - Save image.
			Cls
			If SaveImage( media, seed + ".bmp" )
				Print "File saved."
			Else
				Print "File could not be saved."
			EndIf
			Print "Click the screen to continue."
			FlushMouse : WaitMouse : Delay( 100 ) : FlushMouse
			;---
		EndIf
		
		If KeyHit( 13 ) Or ( G_action = C_INCREASE_ANIM_SPEED ) ; Plus key. Increase animation speed.
			animtimeout = animtimeout - 3
			If animtimeout &lt; 2 Then animtimeout = 2
		EndIf
		
		If KeyHit( 12 ) Or ( G_action = C_DECREASE_ANIM_SPEED ) ; Minus key. Decrease animation speed.
			animtimeout = animtimeout + 3
		EndIf
		
		If KeyHit( 1 ) Then End
		
	Until KeyHit( 57 ) Or ( G_action = C_GENERATE_NEW_HEIGHTMAP ) ; SPACEBAR key - Generate new heightmap.
	FlushMouse
Forever
</textarea> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
