<!DOCTYPE html><html lang="en" ><head ><title >ETlaunch</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >ETlaunch</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=61" >Showcase</a>/<a href="#bottom" >ETlaunch</a><br><br>
<a name="1284803"></a>

<a name="1284804"></a>

<a name="1284805"></a>

<a name="1284806"></a>

<a name="1284807"></a>

<a name="1284810"></a>

<a name="1284811"></a>

<a name="1284812"></a>

<a name="1284813"></a>

<a name="1284814"></a>

<a name="1284815"></a>

<a name="1284816"></a>

<a name="1284817"></a>

<a name="1284818"></a>

<a name="1284819"></a>

<a name="1284820"></a>

<a name="1284821"></a>

<a name="1284822"></a>

<a name="1284823"></a>

<a name="1284850"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> My new project is a Launcher for the old, free game <a href="http://www.splashdamage.com/content/download-wolfenstein-enemy-territory" target="_blank">Return to Castle Wolfenstein: Enemy Territory</a> (2003) which is still the best multiplayer egoshooter game I know. One could think it is dead but there are current projects ongoing like the superb <a href="http://www.etlegacy.com" target="_blank">ET: Legacy</a> which is a fully compatible 2.60b Client and Server with purified code base, but still has some nasty bugs. But i'm watching this project.<br><br>I'm currently working on a Special Edition of the standard W:ET 2.60 game which includes a fully configured <a href="http://www.shitstorm.org/noquarter/wiki/index.php" target="_blank">NoQuarter 1.2.9</a> + <a href="http://omni-bot.invisionzone.com" target="_blank">OmniBot</a> 0.85 environment. I'm able to play together with up to 63 bots like in the good old times with real humans like the Marketgarden Map on the jolt.co.uk servers, ahh the good old times. It's not the same but it really makes fun. What has it to do with Blitzbasic?<br><br>Well, starting with a single Batch file to launch multiplayer maps I was very disappointed with its handling and started to code a very simple launcher in Blitzmax+MaxGUI. And now, after two weeks with no sunshine it has grown to a larger project including miniB3D and full of features I wanted to include.<br><br>The new launcher called "ETlaunch" is capable of<br><br>- parsing a separate maps collection folder with hundreds of custom maps<br>- read the map information and briefing from the arena files<br>- nice GUI with new designed, bloody Campaign map, Levelshot and Commandmap<br>- show the location on the Campaing map<br>- show the time limit of the map<br>- comfortable list selection<br>- filter maps by 20 (!) categories - want to invade a beach? no problem<br>- database with manual preset filter categories for over 200 maps<br>- displays if the map is being supported by the current Omnibot version<br>- rendered preview of the selected map<br>- rendered preview of spawn locations, objectives, cabinets and tank/truck splines<br>- select resolution / graphics mode<br>- select number of Bots to play with<br>- included (!) etkey generator<br>- and of course: launch the map!<br><br>The launcher copies a single PK3 map from your map collection repository in the etmain folder to keep the PK3 data low there (to have only one custom map there prevents the evil MAX_GAMESTATE_CHARS exceeded error when playing with 63 bots on maps with many entities), launches the game with the NQ+OB mods and deletes the file again from the etmain folder. Simple but effective.<br><br>Screenshot:<br><a href="http://www.christianhart.de/bmax/ETlaunch/ETlaunch.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/ETlaunch/ETlaunch_thumb.jpg"></a><br><br>I wrote it mainly for myself but I think it became so good that I should share it with all, the source could be interesting too as it is a fully documented Blitzmax+MaxGUI+miniB3D project with some miniB3D/OpenGL hacks I had to find out. It works quite good but I have to cleanup some messy code first and include a Config file handling to customize the interface before I'll release a final 1.0 version, ideally together with my Special Edition. The goal is that everything needed is put in a single ZIP file and you just copy the large (300MB) PAK0.PK3 from the original game in the etmain folder and everything runs fine even from a USB stick.<br><br>But I still have some problems with the BSP preview renderer and could need some help here. I'm able to parse the mesh geometry and the model geometry (Type 1 and 3) but I'm stuck with the curved bezier patches (Type 2). I've separated the Loader in a demo you can play with. I've included a C source which is able to parse and convert a BSP to a VRML file but I don't understand it. Perhaps somebody here can spend some time and complete my source. It's not important but it's not complete without curved surfaces :-(<br><br>The function where the curved surfaces should be processed is the method "Q3BSP_AssembleModel()". There is a Select...End Select section with the types 1+3. Included is the original Goldrush map from ET but feel free to experiment with all other BSPs from Quake 3, RTCW and ET - they should work fine.<br><br>Screenshot ETloader: the famous Goldrush map of ET in X-Ray style<br><a href="http://www.christianhart.de/bmax/ETlaunch/ETloader.jpg" target="_blank"><img src="http://www.christianhart.de/bmax/ETlaunch/ETloader_thumb.jpg"></a><br><br>Here's the download for the ETloader: <a href="http://www.christianhart.de/bmax/ETlaunch/ETloader.zip" target="_blank">ETloader.zip</a><br><br>Use mouse buttons to speed up and switch between 3 render modes. Keys 1-9 zoom. Additional, here is the source of the loader:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Framework sidesign.minib3d
Import brl.eventqueue
Import brl.timer

Graphics3D 1920, 1200, 32, 2

' setting variables
Const mapname:String = "maps/goldrush.bsp"          ' mapname.bsp
Local CamMode:Int = 2
Local CamZoom:Float = 1.0
Local Rotation:Int = 1
Local XrayColors:Int[] = [128, 144, 160]

' other Variables
Local MapSize:Float
Local RotationX:Float = 0
Local RotationZ:Float = 0
Local RotAddX:Float
Local RotAddZ:Float

' Flip Timer
Global FlipTimer:TTimer = CreateTimer(60)

' 3D Objects
Local Camera:TCamera
Local Lightsource:TLight
Local Pivot:TPivot

' Load the BSP file and assemble a new Mesh from it
Global bsp:TBSP = New TBSP
bsp.BSP_TextureExcludes = ["sky", "common", "skies", "haze", "siwa_water", "sun"]
bsp.LoadBSP(mapname)

' Central Pivot
pivot = CreatePivot()
PositionEntity pivot, 0, 0, 0

' Determine MapSize for Rotation
MapSize = Min(bsp.BSP_MapSizeX, bsp.BSP_MapSizeY) / 2.0

' Camera
Camera = CreateCamera(Pivot)

' directional light
Lightsource = CreateLight(1)
RotateEntity Lightsource, 45, 45, 45
AmbientLight 80, 96, 128

' add entities
AddEntityMarkers()



' --------------------------------------------------------------------------------
' Main loop
' --------------------------------------------------------------------------------
While Not AppTerminate()

	Local Muliplicator:Int = 1

	If KeyHit(KEY_ESCAPE) Then End

	' wait for timer
	Select WaitEvent()
	
		Case EVENT_TIMERTICK
		
		Select EventSource()
								
			Case FlipTimer
					
				' LMB = speedup movement
				If MouseDown(1) Then Muliplicator = 5
				
				' RMB = view mode
				If MouseHit(2) Then
				
					CamMode:+1
					CamMode:Mod 3
										
				EndIf
				
				' SPACE = control rotation
				If KeyHit(KEY_SPACE) Then Rotation = 1 - Rotation
				
				' KEYS 1-9 = distance
				If KeyHit(KEY_1) Then CamZoom = 1.0
				If KeyHit(KEY_2) Then CamZoom = 2.0
				If KeyHit(KEY_3) Then CamZoom = 3.0
				If KeyHit(KEY_4) Then CamZoom = 4.0
				If KeyHit(KEY_5) Then CamZoom = 5.0
				If KeyHit(KEY_6) Then CamZoom = 6.0
				If KeyHit(KEY_7) Then CamZoom = 7.0
				If KeyHit(KEY_8) Then CamZoom = 8.0
				If KeyHit(KEY_9) Then CamZoom = 9.0
					
				' calculate camera movement
				If Rotation Or MouseDown(1) Then
				
					RotAddX = 0.2 * Muliplicator
					RotAddZ = 0.2 * Muliplicator
					RotationX:-RotAddX
					RotationZ:+RotAddZ
					
				EndIf
				
				' move camera
				Local CamDist:Float = EntityDistance(Camera, pivot)
				CameraRange Camera, CamDist * 0.125, CamDist * 4
				CameraZoom Camera, CamZoom

				PositionEntity Camera, Sin(RotationX) * 1.5 * MapSize * bsp.BSP_MapsizeX * 1.0 / bsp.BSP_MapSizeY, MapSize, Cos(RotationZ) * 1.5 * MapSize * bsp.BSP_MapsizeY * 1.0 / bsp.BSP_MapSizeX
				PointEntity Camera, Pivot
												
				' Render Mode
				Select CamMode
			
					' colored only
					Case 0
			
						CameraClsColor Camera, 0, 0, 0
							
						ShowEntity bsp.BSP_Color
						HideEntity bsp.BSP_Model
						
						EntityAlpha bsp.BSP_Color, 1
						EntityAlpha bsp.BSP_Model, 1
						
						Wireframe 0
						RenderWorld
				
					' X-Ray wireframe colored
					Case 1
					
						CameraClsColor Camera, 0, 0, 0
			
						ShowEntity bsp.BSP_Color
						HideEntity bsp.BSP_Model
						
						Wireframe 1
						RenderWorld
						
					' X-Ray wireframe green
					Case 2
				
						CameraClsColor Camera, 0, 0, 0
				
						' X-Ray wireframe
						EntityColor bsp.BSP_Model, XrayColors[0], XrayColors[1], XrayColors[2]
						EntityBlend bsp.BSP_Model, 1
				
						HideEntity bsp.BSP_Color
						ShowEntity bsp.BSP_Model
						
						EntityAlpha bsp.BSP_Color, 0.1
						EntityAlpha bsp.BSP_Model, 0.1

						CameraClsMode Camera, 1, 0
						Wireframe 0
						RenderWorld
				
						HideEntity bsp.BSP_Color
						ShowEntity bsp.BSP_Model
						
						CameraClsMode Camera, 0, 1
						Wireframe 1
						RenderWorld
						
						CameraClsMode Camera, 1, 1
											
				End Select
								
				Flip True
			
		End Select
		
	End Select
	
Wend

End



' --------------------------------------------------------------------------------
' add special entities for strategic visualization
' --------------------------------------------------------------------------------
Function AddEntityMarkers()

	' add spawns and train splines
	Local temp:TMesh, flag:TMesh
	For Local e:TBSPentity = EachIn TBSPentity.List
		
		' Axis spawn
		If e.ClassName = "team_CTF_redspawn" Then
					
			temp = CreateCube(Pivot)
			ScaleEntity temp, 36, 72, 36
			EntityColor temp, 255, 0, 0
			EntityFX temp, 1
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y, e.z + bsp.BSP_OffZ
			
		EndIf
		
		' Allied spawn
		If e.ClassName = "team_CTF_bluespawn" Then
				
			temp = CreateCube(pivot)
			ScaleEntity temp, 36, 72, 36
			EntityColor temp, 0, 0, 255
			EntityFX temp, 1
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y, e.z + bsp.BSP_OffZ
			
		EndIf
		
		' Objective
		If e.ClassName = "team_WOLF_objective" Or e.ClassName = "team_CTF_blueflag" Or e.ClassName = "team_CTF_redflag" Or e.ClassName = "func_constructible" Then
				
			temp = CreateCube(pivot)
			ScaleEntity temp, 72, 72, 72
			EntityColor temp, 255, 0, 255
			EntityFX temp, 1
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y, e.z + bsp.BSP_OffZ
			
		EndIf
		
		' capture the flag
		If e.ClassName = "team_WOLF_checkpoint" Then
					
			temp = CreateCube(pivot)
			ScaleEntity temp, 8, 256, 8
			EntityColor temp, 255, 0, 255
			EntityFX temp, 1
			
			flag = CreateCube()
			ScaleEntity flag, 8, 64, 96
			EntityColor flag, 255, 0, 255
			EntityFX flag, 1
			
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y + 256, e.z + bsp.BSP_OffZ
			PositionEntity flag, e.x + bsp.BSP_OffX, e.y + 512 - 64, e.z + bsp.BSP_OffZ - 96
			
		EndIf
				
		' health/ammo cabinets
		If e.ClassName = "misc_cabinet_supply" Or e.ClassName = "misc_cabinet_health" Then
				
			temp = CreateCube(pivot)
			ScaleEntity temp, 36, 72, 36
			EntityColor temp, 255, 255, 0
			EntityFX temp, 1
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y, e.z + bsp.BSP_OffZ
			
		EndIf
		
		' train splines
		If e.ClassName = "info_train_spline_main" Then
				
			temp = CreateCube(pivot)
			ScaleEntity temp, 8, 2, 8
			EntityColor temp, 255, 255, 0
			EntityFX temp, 1
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y, e.z + bsp.BSP_OffZ
			
		EndIf
	
		' train splines control marker
		If e.ClassName = "info_train_spline_control" Then
				
			temp = CreateCube(Pivot)
			ScaleEntity temp, 8, 2, 8
			EntityColor temp, 255, 0, 255
			EntityFX temp, 1
			PositionEntity temp, e.x + bsp.BSP_OffX, e.y, e.z + bsp.BSP_OffZ
			
		EndIf
		
	Next	

End Function



' --------------------------------------------------------------------------------
' 2D Distance calculation
' --------------------------------------------------------------------------------
Function Distance2D:Float(x1:Float, y1:Float, x2:Float, y2:Float)
	
	Local x:Float=x1-x2
	Local y:Float=y1-y2
	
	Return Sqr(x * x + y * y)
	
End Function



' ----------------------------------------------------------------------------
' Normalizes a value to given range
' ----------------------------------------------------------------------------
Function Normalize:Float(value:Float = 128.0, value_min:Float = 0.0, value_max:Float = 255.0, norm_min:Float = 0.0, norm_max:Float = 1.0, limit:Int = False)

	' normalize	
	Local result:Float=((value-value_min)/(value_max-value_min))*(norm_max-norm_min)+norm_min

	' limit	
	If value&gt;norm_max Then value=norm_max Else If value&lt;norm_min Then value=norm_min

	Return result
	
End Function



' --------------------------------------------------------------------------------
' Returns the maximum value of an array
' --------------------------------------------------------------------------------
Function MinMax:Int(nums:Int[], order:Int = 0)

	Local tmp:Int[] = nums[..]
	tmp.Sort()
	
	If order = 0 Then Return tmp[0] Else Return tmp[tmp.length - 1]
	
End Function



' --------------------------------------------------------------------------------
' Simple digit formatting output of a number
' --------------------------------------------------------------------------------
Function DigOut:String(in:String, delimiter:String = ".")

	Local l:Int = Len(in)
	Local j:Int
	Local negative:Int
	Local out:String
	
	If Int(in) &lt; 0 Then negative = 1
	
	For j = l To 0 Step - 1

		out:+Mid(in, l - j, 1)

		If (j Mod 3) = 0 And j &gt; 0 And (j &lt; l - negative) Then out:+"."

	Next
	
	Return out

End Function



' --------------------------------------------------------------------------------
' Simple leading spaces for nice number formatting output
' --------------------------------------------------------------------------------
Function FormOut:String(in:String, spaces:Int = 2, prefix:String = " ")

	Local i:Int
	Local l:Int = Len(in)
	Local out:String
		
	If l &lt; spaces Then
	
		For i = 0 To spaces - l - 1
		
			out:+prefix
		
		Next
	
	End If
	
	Return out + in
	
End Function




' --------------------------------------------------------------------------------
' Simple spacing for nice string formatting output
' --------------------------------------------------------------------------------
Function FormStr:String(in:String, spaces:Int = 2, suffix:String = " ")

	Local i:Int
	Local l:Int = Len(in)
	Local out:String
		
	If l &lt; spaces Then
	
		For i = 0 To spaces - l - 1
		
			out:+suffix
		
		Next
	
	End If
	
	Return in + out
	
End Function


' --------------------------------------------------------------------------------
' BSP Library
' --------------------------------------------------------------------------------
Type TBSP

	' Constants
	Const BSP_MAX_LUMPS:Int = 16
	Const BSP_MAX_TEXTURES:Int = 255 * 4
	Const BSP_MAX_VERTS:Int = 65535 * 4
	Const BSP_MAX_FACES:Int = 65535 * 4
	Const BSP_MAX_LMAPS:Int = 1023 * 4
	Const BSP_MAX_SURFS:Int = 255 * 4
	Const BSP_MAX_MODELS:Int = 1023 * 4

	' Map Data
	Field BSP_EntityCount:Int
	Field BSP_TextureCount:Int
	Field BSP_ModelCount:Int
	Field BSP_VertexCount:Int
	Field BSP_FaceCount:Int
	Field BSP_CalcTime:Int
	Field BSP_Header:String
	Field BSP_Version:Int
	Field BSP_TextureExcludes:String[]
	
	' Map boundaries #1
	Field BSP_MinX:Float = 0.0
	Field BSP_MinY:Float = 0.0
	Field BSP_MinZ:Float = 0.0
	Field BSP_MaxX:Float = 0.0
	Field BSP_MaxY:Float = 0.0
	Field BSP_MaxZ:Float = 0.0
	
	' Map boundaries #2
	Field BSP_X1:Int
	Field BSP_X2:Int
	Field BSP_Y1:Int
	Field BSP_Y2:Int
	
	' Mapsize
	Field BSP_MapSizeX:Int
	Field BSP_MapSizeY:Int
	
	' Offsets
	Field BSP_OffX:Int
	Field BSP_OffZ:Int
	
	' Meshes
	Global BSP_Model:TMesh
	Global BSP_Color:TMesh
	
	' BSP
	Global BSP_Split:String[99]
	Global BSP_LumpOffset:Int[BSP_MAX_LUMPS + 1]
	Global BSP_LumpLenght:Int[BSP_MAX_LUMPS + 1]
	
	' Texture
	Global BSP_TextureName:String[BSP_MAX_TEXTURES + 1]
	Global BSP_TextureFlags:Int[BSP_MAX_TEXTURES + 1]
	Global BSP_TextureContent:Int[BSP_MAX_TEXTURES + 1]
	Global BSP_TextureHandle:TTexture[BSP_MAX_TEXTURES + 1]
	
	' Vertex
	Global BSP_VertexCoordX:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexCoordY:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexCoordZ:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexTexCoordU:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexLightmapCoordU:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexTexCoordV:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexLightmapCoordV:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexNX:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexNY:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexNZ:Float[BSP_MAX_VERTS + 1]
	Global BSP_VertexRed:Int[BSP_MAX_VERTS + 1]
	Global BSP_VertexGreen:Int[BSP_MAX_VERTS + 1]
	Global BSP_VertexBlue:Int[BSP_MAX_VERTS + 1]
	Global BSP_VertexAlpha:Float[BSP_MAX_VERTS + 1]
	
	' Mesh
	Global BSP_MeshVertexOffset:Int[BSP_MAX_VERTS + 1]
	
	' Face
	Global BSP_FaceTexture:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceVertex:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceNormal:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceMeshVertex:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceMeshNumber:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceType:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceLightmap:Int[BSP_MAX_FACES + 1]
	Global BSP_FaceNormalmap:Int[BSP_MAX_FACES + 1]
	Global BSP_FacePatchDimsX:Int[BSP_MAX_FACES + 1]
	Global BSP_FacePatchDimsY:Int[BSP_MAX_FACES + 1]
	
	' Model
	Global BSP_ModelBoxXstart:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelBoxYstart:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelBoxZstart:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelBoxXend:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelBoxYend:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelBoxZend:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelCenterX:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelCenterY:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelCenterZ:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelScaleX:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelScaleY:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelScaleZ:Float[BSP_MAX_MODELS + 1]
	Global BSP_ModelFacestart:Int[BSP_MAX_MODELS + 1]
	Global BSP_ModelFaceend:Int[BSP_MAX_MODELS + 1]
	
	' Lightmap
	Global BSP_LightmapHandle:TTexture[BSP_MAX_LMAPS, 2]
	
	' Surface
	Global BSP_SurfaceCount:Int[BSP_MAX_MODELS + 1]
	Global BSP_SurfaceTexture:Int[BSP_MAX_SURFS + 1]
	Global BSP_SurfaceLightmap:Int[BSP_MAX_SURFS + 1]
	Global BSP_SurfaceNormalmap:Int[BSP_MAX_SURFS + 1]

	
	
	' --------------------------------------------------------------------------------
	' BSP Main loader
	' --------------------------------------------------------------------------------
	Method LoadBSP(mapname:String)
	
		Local i:Int
		Local stream:TStream
		Local bank:TBank
		Local TotalCalcTime:Int = MilliSecs()
		Local header:String

		BSP_CalcTime = MilliSecs()
		
		Print "Parsing " + mapname

		stream = ReadFile(mapname)
		'If Not stream Then RuntimeError "Couldn't find BSP file!"
		BSP_Header = ReadChar(stream, 4)
		BSP_Version = ReadInt(stream)
				
		'If Not BSP_Header = "IBSP" Then RuntimeError "This is not a valid Q3BSP file!"
		
		Select BSP_Version
			
			Case $2E header = "Quake 3"
			Case $2F header = "RTCW/ET"
			
			Default header = "Unknown"
			
		End Select
		
		Print
		Print FormStr("Header:", 16) + FormOut(header, 8)

		For i = 0 To BSP_MAX_LUMPS - 1

			BSP_LumpOffset[i] = ReadInt(stream)
			BSP_LumpLenght[i] = ReadInt(stream)

		Next

		Print FormStr("Lumps:", 16) + FormOut(DigOut(BSP_MAX_LUMPS), 8)
		
		stream.seek(BSP_LumpOffset[0])
		bank = CreateBank(BSP_LumpLenght[0])
		
		For i = 0 To BankSize(bank) - 3
		
			PokeByte(bank, i, ReadByte(stream))

		Next
				
		For i = 0 To BankSize(bank) - 3
			
			' search for "{"
			If PeekByte(bank, i) = $7B Then
						
				' search for a following CR and "?" -&gt; Entity found!
				If PeekByte(bank, i + 1) = $0A And PeekByte(bank, i + 2) = $22 Then ParseEntity(bank, i + 2)

			EndIf
		
		Next
		
		bank = Null

		Print FormStr("Entities:", 16) + FormOut(DigOut(BSP_EntityCount), 8)

		stream.seek(BSP_LumpOffset[1])

		For i = 0 To (BSP_LumpLenght[1] - 72) / 72
		
			BSP_TextureName[i] = ReadChar(stream, 64)
			BSP_TextureFlags[i] = ReadInt(stream)
			BSP_TextureContent[i] = ReadInt(stream)
			LoadTextures()

			Local t:TBSPtexture = New TBSPtexture

			BSP_TextureCount = BSP_TextureCount + 1
			t.Name = BSP_TextureName[i]
					
		Next
		
		Print FormStr("Textures:", 16) + FormOut(DigOut(BSP_TextureCount), 8)

		stream.seek(BSP_LumpOffset[7])

		For i = 0 To (BSP_LumpLenght[7] - 40) / 40
		
			BSP_ModelBoxXstart[BSP_ModelCount] = ReadFloat(stream)
			BSP_ModelBoxZstart[BSP_ModelCount] = ReadFloat(stream)
			BSP_ModelBoxYstart[BSP_ModelCount] = ReadFloat(stream)
		
			BSP_ModelBoxXend[BSP_ModelCount] = ReadFloat(stream)
			BSP_ModelBoxZend[BSP_ModelCount] = ReadFloat(stream)
			BSP_ModelBoxYend[BSP_ModelCount] = ReadFloat(stream)
		
			BSP_ModelScaleX[BSP_ModelCount] = BSP_ModelBoxXend[BSP_ModelCount] - BSP_ModelBoxXstart[BSP_ModelCount]
			BSP_ModelScaleY[BSP_ModelCount] = BSP_ModelBoxYend[BSP_ModelCount] - BSP_ModelBoxYstart[BSP_ModelCount]
			BSP_ModelScaleZ[BSP_ModelCount] = BSP_ModelBoxZend[BSP_ModelCount] - BSP_ModelBoxZstart[BSP_ModelCount]
		
			BSP_ModelCenterX[BSP_ModelCount] = BSP_ModelBoxXstart[BSP_ModelCount] + (BSP_ModelScaleX[BSP_ModelCount] / 2.0)
			BSP_ModelCenterY[BSP_ModelCount] = BSP_ModelBoxYstart[BSP_ModelCount] + (BSP_ModelScaleY[BSP_ModelCount] / 2.0)
			BSP_ModelCenterZ[BSP_ModelCount] = BSP_ModelBoxZstart[BSP_ModelCount] + (BSP_ModelScaleZ[BSP_ModelCount] / 2.0)
		
			BSP_ModelFacestart[BSP_ModelCount] = ReadInt(stream)
			BSP_ModelFaceend[BSP_ModelCount] = BSP_ModelFacestart[BSP_ModelCount] + ReadInt(stream) - 1
		
			ReadInt(stream)
			ReadInt(stream)
		
			BSP_ModelCount = BSP_ModelCount + 1
		
		Next
		
		Print FormStr("Models:", 16) + FormOut(DigOut(BSP_ModelCount), 8)

		stream.seek(BSP_LumpOffset[10])

		For i = 0 To (BSP_LumpLenght[10] - 1) / 44
		
			BSP_VertexCoordX[i] = ReadFloat(stream)
			BSP_VertexCoordY[i] = ReadFloat(stream)
			BSP_VertexCoordZ[i] = ReadFloat(stream)
		
			BSP_VertexTexCoordU[i] = ReadFloat(stream)
			BSP_VertexTexCoordV[i] = ReadFloat(stream)
			BSP_VertexLightmapCoordU[i] = ReadFloat(stream)
			BSP_VertexLightmapCoordV[i] = ReadFloat(stream)
		
			BSP_VertexNX[i] = ReadFloat(stream)
			BSP_VertexNY[i] = ReadFloat(stream)
			BSP_VertexNZ[i] = ReadFloat(stream)
		
			BSP_VertexRed[i] = ReadByte(stream)
			BSP_VertexGreen[i] = ReadByte(stream)
			BSP_VertexBlue[i] = ReadByte(stream)
			BSP_VertexAlpha[i] = ReadByte(stream) / 255.0
		
			BSP_VertexCount = BSP_VertexCount + 1
			'If BSP_VertexCount &gt; BSP_MAX_VERTS Then RuntimeError "Maximum Vertices reached! Stopping Program!"
		
		Next
		
		stream.seek(BSP_LumpOffset[11])
		
		For i = 0 To (BSP_LumpLenght[11] - 1) / 4

			BSP_MeshVertexOffset[i] = ReadInt(stream)

		Next
		
		Print FormStr("Vertices:", 16) + FormOut(DigOut(BSP_VertexCount), 8)

		stream.seek(BSP_LumpOffset[13])

		For i = 0 To (BSP_LumpLenght[13] - 104) / 104
		
			BSP_FaceTexture[i] = ReadInt(stream)
			ReadInt(stream)

			BSP_FaceType[i] = ReadInt(stream)
			BSP_FaceVertex[i] = ReadInt(stream)
			BSP_FaceNormal[i] = ReadInt(stream)
			BSP_FaceMeshVertex[i] = ReadInt(stream)
			BSP_FaceMeshNumber[i] = ReadInt(stream)
			BSP_FaceLightmap[i] = ReadInt(stream)
			BSP_FaceNormalmap[i] = BSP_FaceLightmap[i]

			If BSP_FaceLightmap[i] &lt; 0 Then BSP_FaceLightmap[i] = 0
			If BSP_FaceNormalmap[i] &lt; 0 Then BSP_FaceNormalmap[i] = 0

			stream.seek(StreamPos(stream) + 64)

			BSP_FacePatchDimsX[i] = ReadInt(stream)
			BSP_FacePatchDimsY[i] = ReadInt(stream)

			BSP_FaceCount = BSP_FaceCount + 1
		
		Next
		
		Print FormStr("Faces:", 16) + FormOut(DigOut(BSP_FaceCount), 8)

		BSP_CalcTime = MilliSecs() - BSP_CalcTime

		Print
		Print "Parsing done in " + BSP_CalcTime + "ms"

		BSP_CalcTime = MilliSecs()

		Print
		Print "Assembling Map:"

		Q3BSP_AssembleModel()
		BSP_CalcTime = MilliSecs() - BSP_CalcTime

		Print
		Print "Assembling done in " + BSP_CalcTime + "ms"
		Print
		Print "Map built in " + (MilliSecs() - TotalCalcTime) + "ms"
		Print

		CloseFile(stream)
	
	End Method



	' --------------------------------------------------------------------------------
	' assemble map
	' --------------------------------------------------------------------------------
	Method Q3BSP_AssembleModel()
	
		Local m:Int, i:Int, surf1:TSurface, surf2:TSurface, texname:String
		Local index:Int, indexb:Int, indexc:Int, indexd:Int
		Local V0:Int, V1:Int, V2:Int
		Local tex:Int
		Local tris:Int, vert:Int
		Local ex:Int = 0
		Local s:Int, v:Int
		Local r:Int, g:Int, b:Int
		Local nx:Float, ny:Float, nz:Float, d:Float
			
		BSP_Model = CreateMesh(pivot)
		BSP_Color = CreateMesh(pivot)
		
		EntityFX BSP_Model, 1 + 16
		EntityFX BSP_Color, 2 + 16
		
		surf1 = CreateSurface(BSP_Model)
		surf2 = CreateSurface(BSP_Color)
						
		For m = 0 To BSP_Modelcount
				
			For i = BSP_ModelFacestart[m] To BSP_ModelFaceend[m]
									
				Select BSP_FaceType[i]
									
					' Standard &amp; Models
					Case 1, 3
							
							If CountVertices(surf1) &gt; 65000 Then
								surf1 = CreateSurface(BSP_Model)
								surf2 = CreateSurface(BSP_Color)
							EndIf
														
							texname = BSP_TextureName[BSP_FaceTexture[i]]
											
							tex = True
							For e = 0 To BSP_TextureExcludes.length - 1
							
								If Instr(texname, BSP_TextureExcludes[e]) Then
								
									tex = False
									ex:+1
									
								EndIf
				
							Next
											
							If tex Then
							
								r = 128
								g = 128
								b = 128
											
								' terrains
								If Instr(texname, "terrain") Then r = 128 ; g = 96 ; b = 64
								If Instr(texname, "sand") Then r = 128 ; g = 96 ; b = 64
								If Instr(texname, "cliff") Then r = 128 ; g = 96 ; b = 64
								If Instr(texname, "moss") Then r = 128 ; g = 96 ; b = 64
								
								' liquids
								If Instr(texname, "water") Then r = 0 ; g = 64 ; b = 128
								If Instr(texname, "river") Then r = 0 ; g = 64 ; b = 128
								If Instr(texname, "sea") Then r = 0 ; g = 64; b = 128
								If Instr(texname, "ice") Then r = 0 ; g = 64; b = 128
								
								' plants
								If Instr(texname, "tree") Then r = 64 ; g = 128 ; b = 64
			
								' roofs
								If Instr(texname, "roof") Then r = 128 ; g = 0 ; b = 0
								
								' roads
								If Instr(texname, "road") Then r = 0 ; g = 0 ; b = 0
													
								index = BSP_FaceVertex[i]
									
								For e = BSP_FaceMeshVertex[i] To BSP_FaceMeshVertex[i] + BSP_FaceMeshNumber[i] - 1 Step 3
								
									indexb = index + BSP_MeshVertexOffset[e + 0]
									indexc = index + BSP_MeshVertexOffset[e + 1]
									indexd = index + BSP_MeshVertexOffset[e + 2]
														
									' find X boundaries
									If BSP_VertexCoordX(indexb) &lt; BSP_MinX Then BSP_MinX = BSP_VertexCoordX(indexb)
									If BSP_VertexCoordX(indexc) &lt; BSP_MinX Then BSP_MinX = BSP_VertexCoordX(indexc)
									If BSP_VertexCoordX(indexd) &lt; BSP_MinX Then BSP_MinX = BSP_VertexCoordX(indexd)
									If BSP_VertexCoordX(indexc) &gt; BSP_MaxX Then BSP_MaxX = BSP_VertexCoordX(indexc)
									If BSP_VertexCoordX(indexb) &gt; BSP_MaxX Then BSP_MaxX = BSP_VertexCoordX(indexb)
									If BSP_VertexCoordX(indexd) &gt; BSP_MaxX Then BSP_MaxX = BSP_VertexCoordX(indexd)
									
									' find Y boundaries
									If BSP_VertexCoordY(indexb) &lt; BSP_MinY Then BSP_MinY = BSP_VertexCoordY(indexb)
									If BSP_VertexCoordY(indexc) &lt; BSP_MinY Then BSP_MinY = BSP_VertexCoordY(indexc)
									If BSP_VertexCoordY(indexd) &lt; BSP_MinY Then BSP_MinY = BSP_VertexCoordY(indexd)
									If BSP_VertexCoordY(indexb) &gt; BSP_MaxY Then BSP_MaxY = BSP_VertexCoordY(indexb)
									If BSP_VertexCoordY(indexc) &gt; BSP_MaxY Then BSP_MaxY = BSP_VertexCoordY(indexc)
									If BSP_VertexCoordY(indexd) &gt; BSP_MaxY Then BSP_MaxY = BSP_VertexCoordY(indexd)
									
									' find Z boundaries
									If BSP_VertexCoordZ(indexb) &lt; BSP_MinZ Then BSP_MinZ = BSP_VertexCoordZ(indexb)
									If BSP_VertexCoordZ(indexc) &lt; BSP_MinZ Then BSP_MinZ = BSP_VertexCoordZ(indexc)
									If BSP_VertexCoordZ(indexd) &lt; BSP_MinZ Then BSP_MinZ = BSP_VertexCoordZ(indexd)
									If BSP_VertexCoordZ(indexb) &gt; BSP_MaxZ Then BSP_MaxZ = BSP_VertexCoordZ(indexb)
									If BSP_VertexCoordZ(indexc) &gt; BSP_MaxZ Then BSP_MaxZ = BSP_VertexCoordZ(indexc)
									If BSP_VertexCoordZ(indexd) &gt; BSP_MaxZ Then BSP_MaxZ = BSP_VertexCoordZ(indexd)
														
									' vertices mesh
									V0 = AddVertex(surf1, BSP_VertexCoordX[indexb], BSP_VertexCoordZ[indexb], BSP_VertexCoordY[indexb] + mz, BSP_VertexTexCoordU[indexb], BSP_VertexTexCoordV[indexb])
									V1 = AddVertex(surf1, BSP_VertexCoordX[indexc], BSP_VertexCoordZ[indexc], BSP_VertexCoordY[indexc] + mz, BSP_VertexTexCoordU[indexc], BSP_VertexTexCoordV[indexc])
									V2 = AddVertex(surf1, BSP_VertexCoordX[indexd], BSP_VertexCoordZ[indexd], BSP_VertexCoordY[indexd] + mz, BSP_VertexTexCoordU[indexd], BSP_VertexTexCoordV[indexd])
												
									' vertex normals mesh
									VertexNormal surf1, V0, BSP_VertexNX[indexb], BSP_VertexNZ[indexb], BSP_VertexNY[indexb]
									VertexNormal surf1, V1, BSP_VertexNX[indexc], BSP_VertexNZ[indexc], BSP_VertexNY[indexc]
									VertexNormal surf1, V2, BSP_VertexNX[indexd], BSP_VertexNZ[indexd], BSP_VertexNY[indexd]
					
									' combine vertices to triangles
									AddTriangle(surf1, V0, V1, V2)
			
									' vertices mesh
									V0 = AddVertex(surf2, BSP_VertexCoordX[indexb] + sx, BSP_VertexCoordZ[indexb] + sy, BSP_VertexCoordY[indexb] + sz, BSP_VertexTexCoordU[indexb], BSP_VertexTexCoordV[indexb])
									V1 = AddVertex(surf2, BSP_VertexCoordX[indexc] + sx, BSP_VertexCoordZ[indexc] + sy, BSP_VertexCoordY[indexc] + sz, BSP_VertexTexCoordU[indexc], BSP_VertexTexCoordV[indexc])
									V2 = AddVertex(surf2, BSP_VertexCoordX[indexd] + sx, BSP_VertexCoordZ[indexd] + sy, BSP_VertexCoordY[indexd] + sz, BSP_VertexTexCoordU[indexd], BSP_VertexTexCoordV[indexd])
									
									' vertexx colors
									VertexColor surf2, V0, r, g, b
									VertexColor surf2, V1, r, g, b
									VertexColor surf2, V2, r, g, b
							
									' vertex normals mesh
									VertexNormal surf2, V0, BSP_VertexNX[indexb], BSP_VertexNZ[indexb], BSP_VertexNY[indexb]
									VertexNormal surf2, V1, BSP_VertexNX[indexc], BSP_VertexNZ[indexc], BSP_VertexNY[indexc]
									VertexNormal surf2, V2, BSP_VertexNX[indexd], BSP_VertexNZ[indexd], BSP_VertexNY[indexd]
					
									' combine vertices to triangles
									AddTriangle(surf2, V0, V1, V2)
															
								Next
						
							EndIf
							
					' Bezier Patches
					Case 2
							' tdb
			
				End Select
								
			Next
					
		Next
				
		' recalculate (normalize) normals
		For s = 1 To CountSurfaces(BSP_Model)
			
			surf1 = GetSurface(BSP_Model, s)
			surf2 = GetSurface(BSP_Color, s)
			
			For v = 0 To CountVertices(surf1) - 1
				
				nx = VertexNX(surf1, v)
				ny = VertexNY(surf1, v)
				nz = VertexNZ(surf1, v)
				d = 1.0 / Sqr(nx * nx + ny * ny + nz * nz)
				
				VertexNormal surf1, v, nx * d, ny * d, nz * d
				VertexNormal surf2, v, nx * d, ny * d, nz * d
				
			Next
			
			tris:+CountTriangles(surf1)
			vert:+CountVertices(surf1)
			
		Next
								
		' determine level boundaries
		BSP_X1 = Int(BSP_MinX)
		BSP_X2 = Int(BSP_MaxX)
		BSP_Y1 = Int(BSP_MinY)
		BSP_Y2 = Int(BSP_MaxY)
				
		' calculate mapsize	
		BSP_MapsizeX = (Abs(BSP_X1) + Abs(BSP_X2))
		BSP_MapsizeY = (Abs(BSP_Y1) + Abs(BSP_Y2))
		
		' calculate offset	
		BSP_OffX = (BSP_MapsizeX / 2) - BSP_X2
		BSP_OffZ = (BSP_MapsizeY / 2) - BSP_Y2
								
		' reposition meshes		
		PositionEntity BSP_Model, BSP_OffX, 0, BSP_OffZ
		PositionEntity BSP_Color, BSP_OffX, 0, BSP_OffZ
						
		Print FormStr("Surfaces:", 14) + FormOut(DigOut(CountSurfaces(BSP_Model)), 12)
		Print FormStr("Triangles:", 14) + FormOut(DigOut(tris), 12)
		Print FormStr("Vertices:", 14) + FormOut(DigOut(vert), 12)
		Print FormStr("Exclusions:", 14) + FormOut(DigOut(ex), 12)
		Print FormStr("Dimensions X:", 14) + FormOut(BSP_X1 + "," + BSP_X2, 12)
		Print FormStr("Dimensions Y:", 14) + FormOut(BSP_Y1 + "," + BSP_Y2, 12)
						
	End Method
	

	
	' --------------------------------------------------------------------------------
	' add missing zeros to a string
	' --------------------------------------------------------------------------------
	Method BSP_ZERO:String(number:String, lenght:Int = 4)
	
		Local i:Int
		Local r:String
	
		For i = 0 To lenght - Len(number) - 1

			r = r + "0"

		Next

		Return r + number
	
	End Method


	' --------------------------------------------------------------------------------
	' reads the textures from the BSP
	' --------------------------------------------------------------------------------
	Method LoadTextures()
	
		Local i:Int

		For i = 0 To BSP_MAX_TEXTURES
		
			BSP_TextureName[i] = Mid(BSP_TextureName[i], 1, Instr(BSP_TextureName[i], "*") - 1)

		Next

	End Method


	' --------------------------------------------------------------------------------
	' Reads a single character
	' --------------------------------------------------------------------------------
	Method ReadChar:String(stream:TStream, lenght:Int)
	
		Local char:String
		Local c:Int
		Local i:Int
	
		For i = 1 To lenght

			c = ReadByte(stream)
		
			If c = 0 Then

				char = char + "*"

			Else If c &gt; 31 Then

				char = char + Chr(c)

			EndIf

		Next

		Return char

	End Method


	' --------------------------------------------------------------------------------
	' Parses a single BSP Entity
	' --------------------------------------------------------------------------------
	Method ParseEntity(bsp:TBank, index:Int)

		Local content:String
	
		' Create a new entity and store index as start position
		Local e:TBSPentity = New TBSPentity
	
		' as Long as there is no "}"
		While PeekByte(bsp, index) &lt;&gt; $7D
		
			' add bytes To String
			content = content + Chr(PeekByte(bsp, index))
			index = index + 1
		
		Wend
	
		' shorten string, replace " " with "=", replace spaces with commas, replace " and ; with nothing
		content = Mid(content, 1, Len(content) - 2)
		content = Replace(content, Chr(34) + Chr(32) + Chr(34), "=")
		content = Replace(content, Chr(32), "*")
		content = Replace(content, Chr(34), "")
		content = Replace(content, ";", "")
	
		' parse values of the entity
		GetEntityValues(e, content)

	End Method


	' --------------------------------------------------------------------------------
	' Patches a string's special characters
	' --------------------------------------------------------------------------------
	Method PatchUTF:String(t:String)
	
		t = Replace(t, Chr(195) + Chr(164), "ä")
		t = Replace(t, Chr(195) + Chr(132), "Ä")
		t = Replace(t, Chr(195) + Chr(182), "ö")
		t = Replace(t, Chr(195) + Chr(150), "ö")
		t = Replace(t, Chr(195) + Chr(188), "ü")
		t = Replace(t, Chr(195) + Chr(156), "Ü")
		t = Replace(t, Chr(195) + Chr(159), "ß")
	
		Return t
	
	End Method


	' --------------------------------------------------------------------------------
	' parses a single value
	' --------------------------------------------------------------------------------
	Method GetSingleValue:String(value:String, content:String)
	
		If Instr(content, value) Then Return SearchBetween(content, value, Chr(10))
	
	End Method


	' --------------------------------------------------------------------------------
	' returns text between two strings
	' --------------------------------------------------------------------------------
	Method SearchBetween:String(txt:String, txtbefore:String, txtbehind:String, fl:Int = 1)
	
		Local F:Int
		Local l:Int
		Local r:String
		
		F = Instr(txt, txtbefore, fl) + Len(txtbefore)
		l = Instr(txt, txtbehind, F)
		r = Mid(txt, F, l - F)
	
		Return r
	
	End Method


	' --------------------------------------------------------------------------------
	' returns text
	' --------------------------------------------------------------------------------
	Method GetSingleText:String(value:String, content:String)
	
		content = Replace(content, "*", " ")
		content = Replace(content, "'", Chr(34))

		If Instr(content, value) Then Return Trim(SearchBetween(content, value, Chr(10)))
	
	End Method


	' --------------------------------------------------------------------------------
	' rounds a value up or down
	' --------------------------------------------------------------------------------
	Method RoundValue:Float(x:Float)
	
		If x &gt;= 0 Then Return Floor(x) Else Return Ceil(x)
	
	End Method


	' --------------------------------------------------------------------------------
	' parses all entity values
	' --------------------------------------------------------------------------------
	Method GetEntityValues(e:TBSPentity, content:String)
	
		e.angle = False
	
		content = PatchUTF(content)
	
		e.ClassName = GetSingleValue("classname=", content)
		e.Scale = GetSingleValue("modelscale=", content).toFloat()
		e.model = GetSingleText("model=", content)
		e.targetname = GetSingleValue("targetname=", content)
		e.target = GetSingleValue("target=", content)
		e.spawnflags = GetSingleValue("spawnflags=", content).toInt()
		e.angle = GetSingleValue("angle=", content).toFloat() - 90 Mod 360.0
	
		BSP_EntityCount = BSP_EntityCount + 1
	
		If Instr(content, "rotation=") Then

			e.angle = GetSingleValue("rotation=", content).toFloat() - 90 Mod 360.0

		EndIf
	
		' parse origin
		If Instr(content, "origin=") Then
		
			' split positions
			SplitString(SearchBetween(content, "origin=", Chr(10)), "*")
		
			' store position To Type (switch values to match Blitz 3D space)
			e.x = Floor(BSP_Split[0].toFloat())
			e.y = Floor(BSP_Split[2].toFloat())
			e.z = Floor(BSP_Split[1].toFloat())
			
			If e.x = 0 And e.y = 0 And e.z = 0 Then e.Remove()
		
		EndIf
	
		' parse position
		If Instr(content, "position=") Then
		
			' split positions
			SplitString(SearchBetween(content, "position=", Chr(10)), "*")
		
			' store position To Type (switch values To match Blitz 3D space)
			e.x = Floor(BSP_Split[0].toFloat())
			e.y = Floor(BSP_Split[2].toFloat())
			e.z = Floor(BSP_Split[1].toFloat())
		
		EndIf
	
		' parse color
		If Instr(content, "_color=") Then
		
			' split colors
			SplitString(SearchBetween(content, "_color=", Chr(10)), "*")
		
			' store RGB color values To Type
			e.r = Int(RoundValue(Float(BSP_Split[0]) * 255))
			e.g = Int(RoundValue(Float(BSP_Split[1]) * 255))
			e.b = Int(RoundValue(Float(BSP_Split[2]) * 255))
		
		EndIf
	
		' parse XYZ angles for models
		If Instr(content, "angles=") Then
		
			SplitString(SearchBetween(content, "angles=", Chr(10)), "*")
		
			e.pitch = (360 - Float(BSP_Split[2])) Mod 360.0
			e.yaw = Float(BSP_Split[1])
			e.roll = Float(BSP_Split[0]) * -1
		
		EndIf
	
	End Method

	' --------------------------------------------------------------------------------
	' splits a string using a delimiter into a blitzarray
	' --------------------------------------------------------------------------------
	Method SplitString:Int(txt:String, delimiter:String)
	
		Local P:Int
		Local i:Int
		Local part:String
	
		BSP_Split[P] = ""
	
		For i = 1 To Len(txt)
		
			part = Mid:String(txt, i, 1)
			If part = delimiter:String Then
				P = P + 1
				BSP_Split[P] = ""
			Else
				BSP_Split[P] = BSP_Split[P] + part
			EndIf
		
		Next
	
		Return P
	
	End Method

End Type



' --------------------------------------------------------------------------------
' Library Extension for Textures
' --------------------------------------------------------------------------------
Type TBSPTexture Extends TBSP

	Global List:TList = CreateList()

	Method New()

		ListAddLast(List, Self)

	End Method

	Field id:TTexture
	Field nm:TTexture
	Field Name:String

End Type



' --------------------------------------------------------------------------------
' Library Extension for Surfaces
' --------------------------------------------------------------------------------
Type TBSPSurface Extends TBSP
	
	Field id:TSurface
	Field texture:String
	
End Type



' --------------------------------------------------------------------------------
' Library Extension for Entities
' --------------------------------------------------------------------------------
Type TBSPentity Extends TBSP

	Global List:TList = CreateList()

	Method New()

		ListAddLast(List, Self)

	End Method
	
	Method Remove()

		ListRemove(List, Self)

	End Method

	Field ClassName:String
	Field target:String
	Field targetname:String
	Field spawnflags:Int
	Field model:String
	Field Scale:Float
	Field angle:Float
	Field pitch:Float
	Field yaw:Float
	Field roll:Float
	Field x:Float
	Field y:Float
	Field z:Float
	Field r:Int
	Field g:Int
	Field b:Int

End Type</textarea> <br><br></td></tr></table><br>
<a name="1284830"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >stayne</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is cool...but Christian maybe you could make a game?  You have an amazing talent.  I don't understand why you are not working on a game. <br><br></td></tr></table><br>
<a name="1284851"></a>

<a name="1284852"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would like to create a game but either I'm always too busy with other work or I want to work further on my game project in my vacation like in the past two weeks (which is still in design/research stage which is a boring stage of a game project as you don't see any progress) and then - well you see here how a tiny "disappointment solution" grows and grows and then I can't stop working on it until it is really good.<br><br>And it is not even finished after two weeks and I've been working on it every single minute I could free. It takes an enormous amount of time to create a whole game, this is only a small app. My game design document has only 5 pages right now, and that's only a rough survey. <br><br></td></tr></table><br>
<a name="1284859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >wmaass</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey I lived in Wurzburg for a time! <br><br></td></tr></table><br>
<a name="1284861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> :-) But "Würzburg Radar" is here at the wrong position, it should be slightly above the "B" of "Bavaria". But that's the level designer's fault - it only shows how exact my position algorithm works ;-) <br><br></td></tr></table><br>
<a name="1284866"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >stayne</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I lived in Bitburg 1995-2000.  K-town was fun! <br><br></td></tr></table><br>
<a name="1285664"></a>

<a name="1285667"></a>

<a name="1285668"></a>

<a name="1285669"></a>

<a name="1285671"></a>

<a name="1285682"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey nice work!<br>But what's really exciting here is the BSP loading.<br>I've been on here whining about no good way to make levels, and here you've got BSP map loading working.<br>So many questions...<br>Do you think you'll ever complete this?<br>Why not make the BSP loading an open-source module?<br><br>I've managed to get texture loading working.<br>And fixed a few random bugs and typos.<br>It's also been converted into SuperStrict code.<br><br><img src="http://puu.sh/m1xom/072f4afeb3.jpg"><br><br>Is there a reason that texture names don't have a file extension?<br>Seems like a waste of time having to guess if it's a TGA, PNG or JPG.<br><br>Thanks for sharing anyways!<br>Really interesting stuff. <br><br></td></tr></table><br>
<a name="1285731"></a>

<a name="1285732"></a>

<a name="1285733"></a>

<a name="1285734"></a>

<a name="1285735"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I'll complete this. Currently I'm adding maps to my local database and finetune the textures of the Special Edition, the ETlaunch application itself is finished and works like expected (excluding the curved surfaces, see my initial post). But anyway, here is a sneak preview demo, just fill the maps folder with your PK3 collection of Q3/RTCW/ET maps (or just copy the pak0.pk3 of ET there) and you can see alle the maps in Xray style as long as the BSP name inside the PK3 matches the PK3 file name! Launching doesn't make sense in this preview without my NQ+Omnibot Special Edition installation which is not finished yet and too large to upload for a preview:<br><br><a href="http://www.christianhart.de/bmax/ETlaunch/ETlaunch_preview.zip" target="_blank">ETlaunch_preview.zip</a><br><br>Start "ETlaunch.exe"<br>RMB on filters resets filters<br>RMB in BSP preview style switches render modes<br>SPACE stops/starts autorotation<br>click on star or double click on mapname on the right side would start the game<br><br>And if you're interested in a complete "Superstrict" BSP parsing Type, here is my extended BSP loader which I've created a year ago for <a href="/posts.php?topic=103075" target="_blank">my own RPG level test</a> based on a map built with NETradiant. It has some additions regarding the entities but you can modify it for your own needs very easy. This one has full texture/lightmap support including DOT3 normal maps (beware: external lightmap support only!) and I only rewrote and deleted some parts for my ET BSP map preview loader. The demo there comes with full source.<br><br>And for BSP it is important to check which file extension a texture has as you never know in Q3/RTCW/ET maps if it is TGA or JPG extension (the extension is never stored in the BSP as it could be a shader, too). If you use your own level format/parsing you can skip this if they are all TGA, JPG or PNG.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type TBSP

	' Constants
	Const BSP_MAX_LUMPS:Int      = 16
	Const BSP_MAX_TEXTURES:Int   = 255
	Const BSP_MAX_VERTS:Int      = 65535*2
	Const BSP_MAX_FACES:Int      = 65535*2
	Const BSP_MAX_LMAPS:Int      = 1023
	Const BSP_MAX_SURFS:Int      = 255
	Const BSP_MAX_MODELS:Int     = 1023
	Const BSP_NOTEXTURE:String   = "textures/common/notex.png"

	Const Blendmode:Int = 5
	Const BSP_MinLight:Int = 116

	' Fields
	Field BSP_EntityCount:Int
	Field BSP_TextureCount:Int
	Field BSP_ModelCount:Int
	Field BSP_VertexCount:Int
	Field BSP_FaceCount:Int
	Field BSP_CalcTime:Int
	Field BSP_Header:String
	Field BSP_Version:Int

	' Globals
	Global BSP_Split:String[3]
	Global BSP_LumpOffset:Int[BSP_MAX_LUMPS+1]
	Global BSP_LumpLenght:Int[BSP_MAX_LUMPS+1]
	Global BSP_TextureName:String[BSP_MAX_TEXTURES+1]
	Global BSP_TextureFlags:Int[BSP_MAX_TEXTURES+1]
	Global BSP_TextureContent:Int[BSP_MAX_TEXTURES+1]
	Global BSP_TextureHandle:TTexture[BSP_MAX_TEXTURES+1]
	Global BSP_VertexCoordX:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexCoordY:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexCoordZ:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexTexCoordU:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexLightmapCoordU:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexTexCoordV:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexLightmapCoordV:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexNX:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexNY:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexNZ:Float[BSP_MAX_VERTS+1]
	Global BSP_VertexRed:Int[BSP_MAX_VERTS+1]
	Global BSP_VertexGreen:Int[BSP_MAX_VERTS+1]
	Global BSP_VertexBlue:Int[BSP_MAX_VERTS+1]
	Global BSP_VertexAlpha:Float[BSP_MAX_VERTS+1]
	Global BSP_MeshVertexOffset:Int[BSP_MAX_VERTS+1]
	Global BSP_FaceTexture:Int[BSP_MAX_FACES+1]
	Global BSP_FaceVertex:Int[BSP_MAX_FACES+1]
	Global BSP_FaceNormal:Int[BSP_MAX_FACES+1]
	Global BSP_FaceMeshVertex:Int[BSP_MAX_FACES+1]
	Global BSP_FaceMeshNumber:Int[BSP_MAX_FACES+1]
	Global BSP_FaceType:Int[BSP_MAX_FACES+1]
	Global BSP_FaceLightmap:Int[BSP_MAX_FACES+1]
	Global BSP_FaceNormalmap:Int[BSP_MAX_FACES+1]
	Global BSP_FacePatchDimsX:Int[BSP_MAX_FACES+1]
	Global BSP_FacePatchDimsY:Int[BSP_MAX_FACES+1]
	Global BSP_Model:TMesh[BSP_MAX_MODELS + 1]
	Global BSP_ModelAlpha:Int[BSP_MAX_MODELS + 1]
	Global BSP_ModelBoxXstart:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelBoxYstart:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelBoxZstart:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelBoxXend:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelBoxYend:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelBoxZend:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelCenterX:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelCenterY:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelCenterZ:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelScaleX:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelScaleY:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelScaleZ:Float[BSP_MAX_MODELS+1]
	Global BSP_ModelFacestart:Int[BSP_MAX_MODELS+1]
	Global BSP_ModelFaceend:Int[BSP_MAX_MODELS+1]
	Global BSP_LightmapHandle:TTexture[BSP_MAX_LMAPS,2]
	Global BSP_SurfaceCount:Int[BSP_MAX_MODELS + 1]
	Global BSP_SurfaceTexture:Int[BSP_MAX_SURFS+1]
	Global BSP_SurfaceLightmap:Int[BSP_MAX_SURFS+1]
	Global BSP_SurfaceNormalmap:Int[BSP_MAX_SURFS+1]

	' --------------------------------------------------------------------------------
	' BSP Main loader
	' --------------------------------------------------------------------------------
	Method LoadBSP:TPivot(mapname:String)
	
		Local i:Int
		Local stream:TStream
		Local bank:TBank
		Local pivot:TPivot
		Local TotalCalcTime:Int=MilliSecs()

		BSP_CalcTime=MilliSecs()
		
		Print
		Print "Start parsing maps/" + mapname + "/" + mapname + ".bsp"

		stream = ReadFile("maps/" + mapname + "/" + mapname + ".bsp")
		If Not stream Then RuntimeError "Couldn't find BSP file!"
		BSP_Header=ReadChar(stream,4)
		BSP_Version=ReadInt(stream)
		If Not BSP_Header="IBSP" Then RuntimeError "This is not a valid Q3BSP file!"
		If Not BSP_Version=$2E Then RuntimeError "BSP has wrong version number (should be 46, but is "+BSP_Version+")"

		Print "Header is "+BSP_Header+", Version "+BSP_Version

		For i=0 To BSP_MAX_LUMPS-1

			BSP_LumpOffset[i]=ReadInt(stream)
			BSP_LumpLenght[i]=ReadInt(stream)

			Print "Found Lump #"+i+" at "+BSP_LumpOffset[i]+" ["+BSP_LumpLenght[i]+" Bytes]"

		Next

		Print
		Print "Parsing Entities..."

		stream.seek(BSP_LumpOffset[0])
		bank=CreateBank(BSP_LumpLenght[0])

		For i=0 To BankSize(bank)-3

			PokeByte(bank,i,ReadByte(stream))

		Next
	
		For i=0 To BankSize(bank)-3
		
			' search for "{"
			If PeekByte(bank,i)=$7B Then
			
				' search for a following CR and "?" -&gt; Entity found!
				If PeekByte(bank,i+1)=$0A And PeekByte(bank,i+2)=$22 Then ParseEntity(bank,i+2)

			EndIf
		
		Next

		bank=Null

		Print "Found "+BSP_EntityCount+" Entities."

		Print
		Print "Parsing Textures..."

		stream.seek(BSP_LumpOffset[1])

		For i=0 To (BSP_LumpLenght[1]-72)/72
		
			BSP_TextureName[i]=ReadChar(stream,64)
			BSP_TextureFlags[i]=ReadInt(stream)
			BSP_TextureContent[i]=ReadInt(stream)
			LoadTextures()

			If Not Instr(BSP_TextureName[i],"caulk") And Not Instr(BSP_TextureName[i],"sky") Then

				Local t:TBSPtexture = New TBSPtexture

				BSP_TextureCount=BSP_TextureCount+1

				Local checkjpg:TStream=OpenStream(BSP_TextureName[i]+".jpg")
				Local checktga:TStream=OpenStream(BSP_TextureName[i]+".tga")

				If checkjpg Then

					t.nm=LoadTexture(BSP_TextureName[i]+"_nrm.jpg")
					BSP_TextureName[i]=BSP_TextureName[i]+".jpg"

				Else If checktga Then

					t.nm=LoadTexture(BSP_TextureName[i]+"_nrm.tga")
					BSP_TextureName[i]=BSP_TextureName[i]+".tga"

				Else

					BSP_TextureName[i]=BSP_NOTEXTURE
					t.nm=Null

				EndIf
				
				If Instr(BSP_TextureName[i], "alpha") Then t.id = LoadTexture(BSP_TextureName[i], 2) Else t.id = LoadTexture(BSP_TextureName[i], 1)
				
				t.name=BSP_TextureName[i]
				'Print t.name

			EndIf
		
		Next

		Print "Found "+BSP_TextureCount+" Textures."

		Print
		Print "Parsing Models..."

		stream.seek(BSP_LumpOffset[7])

		For i=0 To (BSP_LumpLenght[7]-40) / 40 
		
			BSP_ModelBoxXstart[BSP_ModelCount]=ReadFloat(stream)
			BSP_ModelBoxZstart[BSP_ModelCount]=ReadFloat(stream)
			BSP_ModelBoxYstart[BSP_ModelCount]=ReadFloat(stream)
		
			BSP_ModelBoxXend[BSP_ModelCount]=ReadFloat(stream)
			BSP_ModelBoxZend[BSP_ModelCount]=ReadFloat(stream)
			BSP_ModelBoxYend[BSP_ModelCount]=ReadFloat(stream)
		
			BSP_ModelScaleX[BSP_ModelCount]=BSP_ModelBoxXend[BSP_ModelCount]-BSP_ModelBoxXstart[BSP_ModelCount]
			BSP_ModelScaleY[BSP_ModelCount]=BSP_ModelBoxYend[BSP_ModelCount]-BSP_ModelBoxYstart[BSP_ModelCount]
			BSP_ModelScaleZ[BSP_ModelCount]=BSP_ModelBoxZend[BSP_ModelCount]-BSP_ModelBoxZstart[BSP_ModelCount]
		
			BSP_ModelCenterX[BSP_ModelCount]=BSP_ModelBoxXstart[BSP_ModelCount]+(BSP_ModelScaleX[BSP_ModelCount]/2.0)
			BSP_ModelCenterY[BSP_ModelCount]=BSP_ModelBoxYstart[BSP_ModelCount]+(BSP_ModelScaleY[BSP_ModelCount]/2.0)
			BSP_ModelCenterZ[BSP_ModelCount]=BSP_ModelBoxZstart[BSP_ModelCount]+(BSP_ModelScaleZ[BSP_ModelCount]/2.0)
		
			BSP_ModelFacestart[BSP_ModelCount]=ReadInt(stream)
			BSP_ModelFaceend[BSP_ModelCount]=BSP_ModelFacestart[BSP_ModelCount]+ReadInt(stream)-1
		
			ReadInt(stream)
			ReadInt(stream)
		
			BSP_ModelCount=BSP_ModelCount+1
		
		Next

		Print "Found "+BSP_ModelCount+" Models."

		Print "-------------------------------------------------------------------------------"
		Print "Parsing Vertices..."

		stream.seek(BSP_LumpOffset[10])

		For i=0 To (BSP_LumpLenght[10]-1)/44
		
			BSP_VertexCoordX[i]=ReadFloat(stream)
			BSP_VertexCoordY[i]=ReadFloat(stream)
			BSP_VertexCoordZ[i]=ReadFloat(stream)
		
			BSP_VertexTexCoordU[i]=ReadFloat(stream)
			BSP_VertexTexCoordV[i]=ReadFloat(stream)
			BSP_VertexLightmapCoordU[i]=ReadFloat(stream)
			BSP_VertexLightmapCoordV[i]=ReadFloat(stream)
		
			BSP_VertexNX[i]=ReadFloat(stream)
			BSP_VertexNY[i]=ReadFloat(stream)
			BSP_VertexNZ[i]=ReadFloat(stream)
		
			BSP_VertexRed[i]=ReadByte(stream)
			BSP_VertexGreen[i]=ReadByte(stream)
			BSP_VertexBlue[i]=ReadByte(stream)
			BSP_VertexAlpha[i]=ReadByte(stream)/255.0
		
			BSP_VertexCount=BSP_VertexCount+1
			If BSP_VertexCount&gt;BSP_MAX_VERTS Then RuntimeError "Maximum Vertices reached! Stopping Program!"
		
		Next		

		stream.seek(BSP_LumpOffset[11])
		
		For i=0 To (BSP_LumpLenght[11]-1) / 4

			BSP_MeshVertexOffset[i]=ReadInt(stream)

		Next

		Print "Found "+BSP_VertexCount+" Vertices."

		Print
		Print "Parsing Faces..."

		stream.seek(BSP_LumpOffset[13])

		For i=0 To (BSP_LumpLenght[13]-104) / 104
		
			BSP_FaceTexture[i]=ReadInt(stream)
			ReadInt(stream)

			BSP_FaceType[i]=ReadInt(stream)
			BSP_FaceVertex[i]=ReadInt(stream)
			BSP_FaceNormal[i]=ReadInt(stream)
			BSP_FaceMeshVertex[i]=ReadInt(stream)
			BSP_FaceMeshNumber[i]=ReadInt(stream)
			BSP_FaceLightmap[i]=ReadInt(stream)
			BSP_FaceNormalmap[i]=BSP_FaceLightmap[i]

			If BSP_FaceLightmap[i]&lt;0 Then BSP_FaceLightmap[i]=0
			If BSP_FaceNormalmap[i]&lt;0 Then BSP_FaceNormalmap[i]=0

			stream.seek(StreamPos(stream)+64)

			BSP_FacePatchDimsX[i]=ReadInt(stream)
			BSP_FacePatchDimsY[i]=ReadInt(stream)

			BSP_FaceCount=BSP_FaceCount+1
		
		Next

		Print "Found "+BSP_FaceCount+" Faces."

		BSP_CalcTime=MilliSecs()-BSP_CalcTime

		Print
		Print "Parsing done in "+BSP_CalcTime+"ms"
		Print
		Print "Loading Lightmaps..."

		BSP_CalcTime=MilliSecs()

		LoadLightmaps(mapname)

		Print "Assembling Map..."	

		pivot=AssembleMap()
		BSP_CalcTime=MilliSecs()-BSP_CalcTime

		Print "Assembling done in "+BSP_CalcTime+"ms"
		Print
		Print "Map built in "+(MilliSecs()-TotalCalcTime)+"ms"
		Print

		CloseFile(stream)
	
		Return pivot

	End Method


	' --------------------------------------------------------------------------------
	' assemble map
	' --------------------------------------------------------------------------------
	Method AssembleMap:TPivot()

		Local i:Int
		Local pivot:TPivot = CreatePivot()
			
		For i=0 To BSP_ModelCount
		
			BSP_ModelAlpha[i] = Q3BSP_AssembleModel(i)
			EntityParent BSP_Model[i],pivot
			PositionEntity BSP_Model[i],BSP_ModelBoxXstart[i]+(BSP_ModelScaleX[i]/2.0),BSP_ModelBoxYstart[i]+(BSP_ModelScaleY[i]/2.0),BSP_ModelBoxZstart[i]+(BSP_ModelScaleZ[i]/2.0)
			EntityPickMode BSP_Model[i],2
			EntityFX BSP_Model[i], 1 + 2
			EntityType BSP_Model[i], 2
			EntityColor BSP_Model[i], 128, 128, 255
			'UpdateNormals BSP_Model[i]
			
			If BSP_ModelAlpha[i] And i &gt; 0 Then EntityFX BSP_Model[i], 1 + 2 + 32
					
		Next

		Return pivot

	End Method


	' --------------------------------------------------------------------------------
	' assemble map submodel
	' --------------------------------------------------------------------------------
	Method Q3BSP_AssembleModel:Int(num:Int)
	
		Local i:Int,t:Int,surf:TSurface,e:Int,brush:TBrush,newsurf:Int,texname:String
		Local index:Int,indexb:Int,indexc:Int,indexd:Int
		Local V0:Int,V1:Int,V2:Int
		Local sx:Float,sy:Float,sz:Float
		Local texture:TTexture
		Local normalmap:TTexture
		
		Local Class:Int = 0

		Local s:TBSPSurface
	
		BSP_Model[num]=CreateMesh()

		For i=BSP_ModelFacestart[num] To BSP_ModelFaceend[num]
		
			texname = BSP_TextureName[BSP_FaceTexture[i]]
			
			If Instr(texname, "alpha") Then Class = 1
		
			' skip skybox
			If (Not Instr(texname,"sky")) Then
			
				newsurf = 1
							
				' recycle surfaces
				For t=1 To BSP_SurfaceCount[num]
				
					If BSP_SurfaceTexture[t]=BSP_FaceTexture[i] And BSP_SurfaceLightmap[t]=BSP_FaceLightmap[i] Then
					
						surf=GetSurface(BSP_model[num],t)
						brush=GetSurfaceBrush(surf)
						newsurf=0
						Exit
					
					EndIf
				
				Next
				
				' Create New surfaces
				If newsurf Or (CountVertices(surf) + BSP_FaceMeshNumber[i]) &gt; 32000 Then
				
					brush=CreateBrush()
					surf=CreateSurface(BSP_Model[num],brush)
					BSP_SurfaceCount[num]=BSP_SurfaceCount[num]+1
					BSP_SurfaceTexture[BSP_SurfaceCount[num]]=BSP_FaceTexture[i]
					BSP_SurfaceLightmap[BSP_SurfaceCount[num]]=BSP_FaceLightmap[i]
					BSP_SurfaceNormalmap[BSP_SurfaceCount[num]]=BSP_FaceNormalmap[i]
				
					s:TBSPSurface = New TBSPSurface
					s.texture=texname
					s.id=surf
				
				EndIf

				index=BSP_FaceVertex[i]
			
				For e=BSP_FaceMeshVertex[i] To BSP_FaceMeshVertex[i]+BSP_FaceMeshNumber[i]-1 Step 3
				
					indexb=index+BSP_MeshVertexOffset[e+0]
					indexc=index+BSP_MeshVertexOffset[e+1]
					indexd=index+BSP_MeshVertexOffset[e+2]
				
					sx=-BSP_ModelBoxXstart[num]-(BSP_ModelScaleX[num]/2.0)
					sy=-BSP_ModelBoxYstart[num]-(BSP_ModelScaleY[num]/2.0)
					sz=-BSP_ModelBoxZstart[num]-(BSP_ModelScaleZ[num]/2.0)
				
					' vertices
					V0=AddVertex(surf,BSP_VertexCoordX[indexb]+sx,BSP_VertexCoordZ[indexb]+sy,BSP_VertexCoordY[indexb]+sz,BSP_VertexTexCoordU[indexb],BSP_VertexTexCoordV[indexb])
					V1=AddVertex(surf,BSP_VertexCoordX[indexc]+sx,BSP_VertexCoordZ[indexc]+sy,BSP_VertexCoordY[indexc]+sz,BSP_VertexTexCoordU[indexc],BSP_VertexTexCoordV[indexc])
					V2=AddVertex(surf,BSP_VertexCoordX[indexd]+sx,BSP_VertexCoordZ[indexd]+sy,BSP_VertexCoordY[indexd]+sz,BSP_VertexTexCoordU[indexd],BSP_VertexTexCoordV[indexd])

					' vertex colors
					VertexColor surf, V0, BSP_MinLight, BSP_MinLight, BSP_MinLight
					VertexColor surf, V1, BSP_MinLight, BSP_MinLight, BSP_MinLight
					VertexColor surf, V2, BSP_MinLight, BSP_MinLight, BSP_MinLight

					' vertex normals
					VertexNormal surf, V0, BSP_VertexNX[indexb], BSP_VertexNZ[indexb], BSP_VertexNY[indexb]
					VertexNormal surf, V1, BSP_VertexNX[indexc], BSP_VertexNZ[indexc], BSP_VertexNY[indexc]
					VertexNormal surf, V2, BSP_VertexNX[indexd], BSP_VertexNZ[indexd], BSP_VertexNY[indexd]

					' second coordinate set (lightmap)
					VertexTexCoords surf, V0, BSP_VertexLightmapCoordU[indexb], BSP_VertexLightmapCoordV[indexb], 1, 1
					VertexTexCoords surf,V1,BSP_VertexLightmapCoordU[indexc],BSP_VertexLightmapCoordV[indexc],1,1
					VertexTexCoords surf,V2,BSP_VertexLightmapCoordU[indexd],BSP_VertexLightmapCoordV[indexd],1,1

					' combine vertices to triangles				
					AddTriangle(surf,V0,V1,V2)
			
				Next

				For Local tx:TBSPtexture = EachIn TBSPtexture.List

					If tx.name=texname Then
						texture=tx.id
						normalmap=tx.nm
					EndIf

				Next

				TextureCoords BSP_LightmapHandle[BSP_FaceLightmap[i], 1], 1
				TextureCoords BSP_LightmapHandle[BSP_FaceLightmap[i],0],1
				
				TextureBlend BSP_LightmapHandle[BSP_FaceLightmap[i], 0], 5
				TextureBlend normalmap, 4
				TextureBlend texture, Blendmode
				TextureBlend BSP_LightmapHandle[BSP_FaceLightmap[i], 1], 3

				' set new brush textures
				BrushTexture brush, BSP_LightmapHandle[BSP_FaceLightmap[i], 1], 0, 0
				BrushTexture brush, normalmap, 0, 1
				BrushTexture brush, texture, 0, 2
				BrushTexture brush, BSP_LightmapHandle[BSP_FaceLightmap[i], 0], 0, 3
				PaintSurface surf, brush

				FreeBrush brush

			EndIf
					
		Next
		
		Return Class
	
	End Method

	Method MinVertexLight:Int(v1:Int,v2:Int)
	
		If v2&lt;v1 Then Return v1 Else Return v2
	
	End Method

	' --------------------------------------------------------------------------------
	' load and pimp external lightmaps
	' --------------------------------------------------------------------------------
	Method LoadLightmaps(mapname:String)

		Local i:Int=0
		Local x:Int,y:Int
		Local c:Int
		Local R:Int, G:Int, B:Int
		Local R1:Int, G1:Int, B1:Int
		Local RGB:Int
		Local lm:TStream
		Local width:Int, Height:Int
		Local ltex:TPixmap
		Local pixmap1:TPixmap,pixmap2:TPixmap
		Local lightmaptexname:String
	
		Repeat

			lightmaptexname="textures/lightmaps/"+mapname+"/lm_"+BSP_ZERO(i,4)+".tga"
			
			lm = OpenStream(lightmaptexname)
		
			If lm Then
			
				ltex=LoadPixmap(lightmaptexname)
			
				width = ltex.width
				height=ltex.height
		
				pixmap1=CreatePixmap(width,height,PF_RGB888)
				pixmap2 = CreatePixmap(width, Height, PF_RGB888)

				For y = 0 To Height - 1
				
					For x=0 To width-1
				
						' read original lightmap colors
						RGB = ReadPixel(ltex, x, y)
						R = GetR(RGB)
						G = GetG(RGB)
						B = GetB(RGB)

						' #2 greyscale averaged lightmap
											
						c = HardLight(HardLight(R, G), B)
						If c &lt; 32 Then c = 32

						WritePixel(pixmap2, x, y, CombineARGB(255, c, c, c))
						
						' #1 new lightmap
						Local m:Int = 32
						Local n:Int = 255
											
						If DotMode = "Test" Then
						
							R1 = Screen(R, R)
							G1 = Screen(G, G)
							B1 = Screen(B, B)
							
							R = Average(R, R1)
							G = Average(G, G1)
							B = Average(B, B1)
						
						EndIf
						
						If R &lt; m Then R = m Else If R &gt; n Then R = n
						If G &lt; m Then G = m Else If G &gt; n Then G = n
						If B &lt; m Then B = m Else If B &gt; n Then B = n
										
						' create new lightmap pixmaps
						WritePixel(pixmap1, x, y, CombineARGB(255, R, G, B))
						
					Next
					
				Next

				BSP_LightmapHandle[i,0] = LoadTexturePixmap(pixmap1)
				BSP_LightmapHandle[i,1] = LoadTexturePixmap(pixmap2)
			
				SavePixmapPNG(pixmap1,"pixmap1.png",0)
				SavePixmapPNG(pixmap2,"pixmap2.png",0)
			
				ltex=Null
				pixmap1=Null
				pixmap2=Null
			
				i=i+1

			EndIf
		
		Until Not lm

	End Method


	' --------------------------------------------------------------------------------
	' add missing zeros to a string
	' --------------------------------------------------------------------------------
	Method BSP_ZERO:String(number:String,lenght:Int=4)
	
		Local i:Int
		Local r:String
	
		For i=0 To lenght-Len(number)-1

			r=r+"0"

		Next

		Return r+number
	
	End Method


	' --------------------------------------------------------------------------------
	' reads the textures from the BSP
	' --------------------------------------------------------------------------------
	Method LoadTextures()
	
		Local i:Int

		For i=0 To BSP_MAX_TEXTURES
		
			BSP_TextureName[i]=Mid(BSP_TextureName[i],1,Instr(BSP_TextureName[i],"*")-1)

		Next

	End Method


	' --------------------------------------------------------------------------------
	' Reads a single character
	' --------------------------------------------------------------------------------
	Method ReadChar:String(stream:TStream,lenght:Int)
	
		Local char:String
		Local c:Int
		Local i:Int
	
		For i=1 To lenght

			c=ReadByte(stream)
		
			If c=0 Then

				char=char+"*"

			Else If c&gt;31 Then

				char=char+Chr(c)

			EndIf

		Next

		Return char

	End Method


	' --------------------------------------------------------------------------------
	' Parses a single BSP Entity
	' --------------------------------------------------------------------------------
	Method ParseEntity(bsp:TBank,index:Int)

		Local content:String
	
		' Create a new entity and store index as start position
		Local e:TBSPentity = New TBSPentity
	
		' as Long as there is no "}"
		While PeekByte(bsp,index)&lt;&gt;$7D
		
			' add bytes To String
			content=content+Chr(PeekByte(bsp,index))
			index=index+1
		
		Wend
	
		' shorten string, replace " " with "=", replace spaces with commas, replace " and ; with nothing
		content=Mid(content,1,Len(content)-2)
		content=Replace(content,Chr(34)+Chr(32)+Chr(34),"=")
		content=Replace(content,Chr(32),"*")
		content=Replace(content,Chr(34),"")
		content=Replace(content,";","")
	
		' parse values of the entity
		GetEntityValues(e,content)

	End Method


	' --------------------------------------------------------------------------------
	' Patches a string's special characters
	' --------------------------------------------------------------------------------
	Method PatchUTF:String(t:String)
	
		t=Replace(t,Chr(195)+Chr(164),"ä")
		t=Replace(t,Chr(195)+Chr(132),"Ä")
		t=Replace(t,Chr(195)+Chr(182),"ö")
		t=Replace(t,Chr(195)+Chr(150),"ö")
		t=Replace(t,Chr(195)+Chr(188),"ü")
		t=Replace(t,Chr(195)+Chr(156),"Ü")
		t=Replace(t,Chr(195)+Chr(159),"ß")
	
		Return t
	
	End Method


	' --------------------------------------------------------------------------------
	' parses a single value
	' --------------------------------------------------------------------------------
	Method GetSingleValue:String(value:String,content:String)
	
		If Instr(content,value) Then Return SearchBetween(content,value,Chr(10))
	
	End Method 


	' --------------------------------------------------------------------------------
	' returns text between two strings
	' --------------------------------------------------------------------------------
	Method SearchBetween:String(txt:String,txtbefore:String,txtbehind:String,fl:Int=1)
	
		Local f:Int
		Local l:Int
		Local r:String
		
		f=Instr(txt,txtbefore,fl)+Len(txtbefore)
		l=Instr(txt,txtbehind,f)
		r=Mid(txt,f,l-f)
	
		Return r
	
	End Method


	' --------------------------------------------------------------------------------
	' returns text
	' --------------------------------------------------------------------------------
	Method GetSingleText:String(value:String,content:String)
	
		content=Replace(content,"*"," ")
		content=Replace(content,"'",Chr(34))

		If Instr(content,value) Then Return Trim(SearchBetween(content,value,Chr(10)))
	
	End Method 


	' --------------------------------------------------------------------------------
	' rounds a value up or down
	' --------------------------------------------------------------------------------
	Method RoundValue:Float(x:Float)
	
		If x&gt;=0 Then Return Floor(x) Else Return Ceil(x)
	
	End Method


	' --------------------------------------------------------------------------------
	' parses all entity values
	' --------------------------------------------------------------------------------
	Method GetEntityValues(e:TBSPentity,content:String)
	
		e.angle=False
	
		content=PatchUTF(content)
	
		e.classname	= GetSingleValue("classname=",content)
		e.scale		= GetSingleValue("modelscale=",content).toFloat()
		e.model		= GetSingleText("model=",content)
		e.targetname	= GetSingleValue("targetname=",content)
		e.target		= GetSingleValue("target=",content)
		e.targetmap	= GetSingleValue("targetmap=",content)
		e.pressed		= GetSingleValue("pressed=",content).toInt()
		e.spawnflags	= GetSingleValue("spawnflags=",content).toInt()
		e.angle		= GetSingleValue("angle=",content).toFloat()-90 Mod 360.0
		e.gold		= GetSingleValue("gold=",content).toFloat()
		e.items		= GetSingleText("items=",content)
		e.health		= GetSingleValue("health=",content).toFloat()
		e.textmessage	= GetSingleText("text=",content)
		e.questiontext	= GetSingleText("questiontext=",content)
		e.questionyes	= GetSingleText("questionyes=",content)
		e.questionno	= GetSingleText("questionno=",content)
		e.lightradius	= GetSingleValue("light=",content).toInt()
		e.shadow		= GetSingleValue("_cs=",content).toInt()
	
		BSP_EntityCount=BSP_EntityCount+1
	
		If Instr(content,"rotation=") Then

			e.angle=GetSingleValue("rotation=",content).toFloat()-90 Mod 360.0

		EndIf
	
		' parse origin
		If Instr(content,"origin=") Then
		
			' split positions
			SplitString(SearchBetween(content,"origin=",Chr(10)),"*")
		
			' store position To Type (switch values to match Blitz 3D space)
			e.x=Floor(BSP_Split[0].toFloat())
			e.y=Floor(BSP_Split[2].toFloat())
			e.z=Floor(BSP_Split[1].toFloat())
		
		EndIf
	
		' parse position
		If Instr(content,"position=") Then
		
			' split positions
			SplitString(SearchBetween(content,"position=",Chr(10)),"*")
		
			' store position To Type (switch values To match Blitz 3D space)
			e.x=Floor(BSP_Split[0].toFloat())
			e.y=Floor(BSP_Split[2].toFloat())
			e.z=Floor(BSP_Split[1].toFloat())
		
		EndIf
	
		' parse color
		If Instr(content,"_color=") Then
		
			' split colors
			SplitString(SearchBetween(content,"_color=",Chr(10)),"*")
		
			' store RGB color values To Type
			e.r=Int(RoundValue(Float(BSP_Split[0])*255))
			e.g=Int(RoundValue(Float(BSP_Split[1])*255))
			e.b=Int(RoundValue(Float(BSP_Split[2])*255))
		
		EndIf
	
		' parse XYZ angles for models
		If Instr(content,"angles=") Then
		
			SplitString(SearchBetween(content,"angles=",Chr(10)),"*")
		
			e.pitch=(360-Float(BSP_Split[2])) Mod 360.0
			e.yaw=Float(BSP_Split[1])
			e.roll=Float(BSP_Split[0])*-1
		
		EndIf

		'DebugLog "Classname..........: " + e.ClassName
		'DebugLog "Scale..............: " + e.Scale
		'DebugLog "Model..............: " + e.model
		'DebugLog "Targetname.........: " + e.targetname
		'DebugLog "Target.............: " + e.target
		'DebugLog "Targetmap..........: "+e.targetmap
		'DebugLog "Pressed............: "+e.pressed
		'DebugLog "Spawnflags.........: "+e.spawnflags
		'DebugLog "Angle..............: "+e.angle
		'DebugLog "Gold...............: "+e.gold
		'DebugLog "Items..............: "+e.items
		'DebugLog "Health.............: "+e.health
		'DebugLog "Textmessage........: "+e.textmessage
		'DebugLog "Questiontext.......: "+e.questiontext
		'DebugLog "QuestionYes........: "+e.questionyes
		'DebugLog "QuestionNo.........: "+e.questionno
		'DebugLog "Lightradius........: "+e.lightradius
		'DebugLog "Shadow.............: "+e.shadow
	
	End Method

	' --------------------------------------------------------------------------------
	' splits a string using a delimiter into a blitzarray
	' --------------------------------------------------------------------------------
	Method SplitString:Int(txt:String,delimiter:String)
	
		Local p:Int
		Local i:Int
		Local part:String
	
		BSP_Split[p]=""
	
		For i=1 To Len(txt)
		
			part=Mid$(txt,i,1)
			If part=delimiter$ Then
				p=p+1
				BSP_Split[p]=""
			Else
				BSP_Split[p]=BSP_Split[p]+part
			EndIf
		
		Next
	
		Return p
	
	End Method

End Type

Type TBSPTexture Extends TBSP

	Global List:TList = CreateList()

	Method New()

		ListAddLast(List, Self)

	End Method

	Field id:TTexture
	Field nm:TTexture
	Field name:String

End Type

Type TBSPSurface Extends TBSP
	
	Field id:TSurface
	Field texture:String
	Field sound:String
	
End Type

Type TBSPentity Extends TBSP

	Global List:TList = CreateList()

	Method New()

		ListAddLast(List, Self)

	End Method

	Field classname:String
	Field targetname:String
	Field pressed:Int
	Field target:String
	Field targetmap:String
	Field spawnflags:Int
	Field angle:Float
	Field pitch:Float
	Field yaw:Float
	Field roll:Float
	Field x:Float
	Field y:Float
	Field z:Float
	Field r:Int
	Field g:Int
	Field b:Int
	Field category:String
	Field entity:Int
	Field model:String
	Field scale:Float
	Field flare:Int
	Field flarescale:Float
	Field flaresize:Int
	Field alpha:Float
	Field gold:Float
	Field opened:Int
	Field looted:Int
	Field items:String
	Field health:Float
	Field textmessage:String
	Field questiontext:String
	Field questionyes:String
	Field questionno:String
	Field modelswitch:Int
	Field light:Int
	Field lightradius:Int
	Field lms:Float
	Field l1:Float
	Field l2:Float
	Field l3:Float
	Field moving:Int
	Field shadow:Int
	Field animframe:Int
	Field animtimer:Int

End Type</textarea> <br><br></td></tr></table><br>
<a name="1285736"></a>

<a name="1285737"></a>

<a name="1285738"></a>

<a name="1285740"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Seems like there are some missing functions in the last BSP loader.<br>Like HardLight() GetR() CombineARGB LoadTexturePixmap() etc.<br><br>UPDATE: Found them in the ORCS demo. <br><br></td></tr></table><br>
<a name="1285783"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Krischan</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I only copied it from the ORCS demo, these are only filters for my own lightmap postprocessing. Did you solve the processing of curved surfaces in your own work? If yes please share it :-) By the way, here is a technical information about how to render BSP maps and the BSP format:<br><br><a href="http://graphics.cs.brown.edu/games/quake/quake3.html" target="_blank">Rendering Quake 3 Maps</a><br><a href="http://www.mralligator.com/q3/" target="_blank">Unofficial Quake 3 Map Specs</a> <br><br></td></tr></table><br>
<a name="1285785"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sadly I'm no good with 3D in general.<br>But I'm trying to make a clean demo (from ORCS source) showing the problem, which I'll pass along to a friend of mine who I think might be able to help.<br>I'll of course share whatever comes out of this. <br><br></td></tr></table><br>
<a name="1285795"></a>

<a name="1285798"></a>

<a name="1285799"></a>

<a name="1285800"></a>

<a name="1285801"></a>

<a name="1285802"></a>

<a name="1285803"></a>

<a name="1285804"></a>

<a name="1285810"></a>

<a name="1285814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> The ORCS source seems to be different in a few ways to the other BSP loader.<br>With the ETlauncher one I could for example load huge levels without much problems, but I keep getting "Maximum Vertices reached! Stopping Program!" with the ORCS one.<br>Infact only 1 out of the 15 or so custom maps I've tried has worked.<br>While all 15 worked with the ETlauncher BSP loader.<br><br>UPDATE: I've managed to get it working. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
