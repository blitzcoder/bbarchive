<!DOCTYPE html><html lang="en" ><head ><title >OpenGL Optimization</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >OpenGL Optimization</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >OpenGL Optimization</a><br><br>
<a name="835003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tachyon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Greetings-<br><br>I was just contacted by a guy who profiled my game using OpenGL profiler, and he claims that I am hugely unoptimized  with my rendering pipeline. The thing is, I am of course not communicating directly with the OpenGL layer so it's not really "my" pipeline- I load sprites (.png pixmaps) then DrawImage them to the screen in my UpdateScreen() function every loop, then flip it just like everyone else does. So, according to him, this is obscenely slow. Here is his message:<br><br><div class="quote"> I have simply profiled your engine using OpenGL profiler, and I am a bit horrified. At first glance, it is a pretty obvious why everything is going so slow. You are using immediate mode to render every object in the game... i.e. glBegin...glEnd blocks of code. This is incredibly slow, this is obvious problem.<br><br>You need to optimise the rendering path of your code... using vertex array. glBegin...glEnd style code is about 1000 times slower than appropriate vertex array. If you don't believe me benchmark rendering 100,000 triangles with immediate mode and then using retained mode.<br><br>The kind of configuration the above user has should be enough to render a few hundred thousand fully textured and blended triangles, so actually your explanation is not really acceptable..<br><br>Even just using display list would be advisable as a bandage for the this gushing wound...<br><br>Don't think of this as a problem, think of it as a task to increase the size of your customer base.<br><br>Immediate mode vs Retained mode:<br><a href="http://www.cs.utk.edu/~huangj/CS594S06/oglPerfGraphicsArc.ppt" target="_blank">http://www.cs.utk.edu/~huangj/CS594S06/oglPerfGraphicsArc.ppt</a><br><br>Vertex Arrays:<br><a href="http://www.opengl.org/documentation/specs/version1.1/glspec1.1/node21.html" target="_blank">http://www.opengl.org/documentation/specs/version1.1/glspec1.1/node21.html</a><br><br>Every frame you are making approximately 15,000 OpenGL calls.<br><br>Sample of the trace:<br>0.05 ¬µs glColor4ubv({0, 40, 0, 255});<br>0.27 ¬µs glBegin(GL_QUADS);<br>0.05 ¬µs glTexCoord2f(0, 0);<br>0.05 ¬µs glVertex2f(442, 533);<br>0.05 ¬µs glTexCoord2f(0.8125, 0);<br>0.05 ¬µs glVertex2f(494, 533);<br>0.05 ¬µs glTexCoord2f(0.8125, 0.8125);<br>0.05 ¬µs glVertex2f(494, 559);<br>0.05 ¬µs glTexCoord2f(0, 0.8125);<br>0.05 ¬µs glVertex2f(442, 559);<br>0.33 ¬µs glEnd();<br>0.05 ¬µs glColor4ubv({0, 40, 0, 255});<br>0.22 ¬µs glBegin(GL_QUADS);<br>0.05 ¬µs glTexCoord2f(0, 0);<br>0.05 ¬µs glVertex2f(494, 533);<br>0.05 ¬µs glTexCoord2f(0.8125, 0);<br>0.05 ¬µs glVertex2f(546, 533);<br>0.00 ¬µs glTexCoord2f(0.8125, 0.8125);<br>0.05 ¬µs glVertex2f(546, 559);<br>0.00 ¬µs glTexCoord2f(0, 0.8125);<br>0.05 ¬µs glVertex2f(494, 559);<br>0.22 ¬µs glEnd();<br>0.05 ¬µs glColor4ubv({0, 40, 0, 255});<br>2.17 ¬µs glBindTexture(GL_TEXTURE_2D, 83);<br>54.31 ¬µs glBegin(GL_QUADS);<br>0.22 ¬µs glTexCoord2f(0, 0);<br>0.22 ¬µs glVertex2f(546, 533);<br>0.00 ¬µs glTexCoord2f(0.8125, 0);<br>0.05 ¬µs glVertex2f(598, 533);<br>0.00 ¬µs glTexCoord2f(0.8125, 0.8125);<br>0.05 ¬µs glVertex2f(598, 559);<br>0.05 ¬µs glTexCoord2f(0, 0.8125);<br>0.05 ¬µs glVertex2f(546, 559);<br>0.76 ¬µs glEnd();<br>0.16 ¬µs glColor4ubv({0, 40, 0, 255});<br>0.27 ¬µs glBegin(GL_QUADS);<br>0.05 ¬µs glTexCoord2f(0, 0);<br>0.05 ¬µs glVertex2f(598, 533);<br>0.05 ¬µs glTexCoord2f(0.8125, 0);<br>0.05 ¬µs glVertex2f(650, 533);<br>0.05 ¬µs glTexCoord2f(0.8125, 0.8125);<br>0.05 ¬µs glVertex2f(650, 559);<br>0.05 ¬µs glTexCoord2f(0, 0.8125);<br>0.05 ¬µs glVertex2f(598, 559);<br>0.22 ¬µs glEnd();<br><br>You could probably replace this with about 20-30 calls using deferred rendering APIs... it would be soooo much faster. Even changing to 16-bit color shouldn't be needed - actually I was surprised to see this.. it won't make much different on modern hardware as it is all geared for 32-bit data anyway. <br></div><br><br>My question would be- is there anything I could or should be doing to improve this? Is this a BRL issue, or even an issue at all? <br><br></td></tr></table><br>
<a name="835024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its no issue at all.<br>You are not creating a high end 3D game, so a few micro seconds make no difference.<br><br>There have been attempts and benchmarks of glbegin - glend against batched rendering and the result is that is isn't faster due to the nature of the 2D single plane of BM<br><br>if you really wanted to opt it, you would need to write your own 2D driver which has true depth (z value), then it is possible to get away with vertex arrays<br><br><br>If I wouldn't know it better I would say a unix geek contacted you as nobody else would have nothing more stupid to do than profiling other users apps ;-) <br><br></td></tr></table><br>
<a name="835133"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think immediate mode is slow when you get past a certain threshold. I found that you need to be drawing about 20 quads in immediate mode before a  display list becomes a faster method - mainly to do with the overhead from function calls.<br><br>I have heard of increases of about 2-3 times throughput from switching to a vertex array, but the idea of it being thousands of times faster is totally impossible. <br><br></td></tr></table><br>
<a name="835154"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Snixx</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> blitzmax as default uses a really bad way of "drawing", it basically just throws each "primative" to the card one by one, <br><br>Im using a 2D system i made for c++ that uses a blitzmax like syntax but i wrote a new renderer (d3d9 and gl drivers) that gives a huge increase (3x + on my hardware) using batching (primative and texture batching). And is how bmax should have been done in the first place. <br><br></td></tr></table><br>
<a name="835160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fetze</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Batching requires sorting by texture respectively sorting by primitive type - if BlitzMax had to do this for you and still keep the order of your draw commands resulting in the same order on screen it'd have a lot more to do. Batching is, I think, something that shouldn't be implemented *generally* - but that should be possible to implement in certain situations.<br><br>DrawTexturedPolygon with an optional parameter for the primitive mode would do the job - you could do manual batching on both textures and primitives: Create your own "software Vertex Array", pass it to the function and it will simply set your texture, glBegin your primitive type and put all the vertices. Would be very useful implementing single surface particle systems for example. <br><br></td></tr></table><br>
<a name="835182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> funny is, that does not make a difference.<br><br>I've created an extended driver as I assumed it would make a difference as well, if you could "lock" the drawing texture and just add geometry to one glBegin call.<br><br>But it didn't<br>Even on my crappy GMA900 the difference were only 2 FPS ...<br><br>Do not ask me why it does not make a real difference. perhaps I did something wrong, although I'm quite sure that I am capable of looping through an array and call the correct glbegin / end stuff.<br><br>Thats why I came to the conclusion that it only makes sense if we introduced real depth and could just create "1 mesh" per texture and use that one ... <br><br></td></tr></table><br>
<a name="835234"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jake L.</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dreamora is right, I did those tests as well and found no real difference, with a few exceptions:<br><br>Keeping surfacecount (Images) low and drawing only portions of a texture instead (by messing with the UVs) DOES make a difference.<br><br>Also, Vertexbuffers are faster if you don't update them very often, say for backdrops or static text. <br><br></td></tr></table><br>
<a name="835265"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jupp the "DrawImageArea" approach is far supperior to the approach of using VertexArrays and the like for dynamic things.<br><br>The only real usage of the "glBegin - glEnd" would be when you use a tilemap system combined with the DrawImageArea approach. In that case it would seriously boost the whole thing, I'm sure (make the vertex data visible tiles + 2 on all borders and you can keep it for quite some time)<br><br>But not for those things where single surface / batching normally is used like particle systems etc <br><br></td></tr></table><br>
<a name="835324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> he claims that I am hugely unoptimized with my rendering pipeline. <br></div>He is correct.<br><br><div class="quote"> if BlitzMax had to do this for you and still keep the order of your draw commands resulting in the same order on screen it'd have a lot more to do. <br></div>Not really. You just need a insertion ordered map (like the LinkedHashMap in Java).<br><br><div class="quote"> Even on my crappy GMA900 the difference were only 2 FPS ... <br></div>That's odd, because on my crappy GeForce 6800 Go I got more than a factor 2 improvement on a similar test. <br><br></td></tr></table><br>
<a name="835328"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your rendering pipeline is unoptimized- it could be worse, but in order for that to be true you would have to intentionally make it worse.  You're pretty much at the bottom of the ladder here in performance.  This is not necessarily your fault, however, seeing as how you didn't write the 2D code (I assume you didn't, anyway, since I'm doubtful that you wrote your own 2D renderer or Max2D implementation).<br><br>BRL are the ones who wrote the 2D code for BMax, and for some reason they neglected to think about any form of optimization.  Writing a decent and basic 2D renderer (right now you just have basic, to point out the difference) is not difficult, and that BRL hasn't done it is really just laziness on their part, not because it's troublesome. <br><br></td></tr></table><br>
<a name="835388"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bye Noel. /wave <br><br></td></tr></table><br>
<a name="835394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Noel: I'm not sure if it really was lazyness and not just the attempt to make sure its real OGL 1.2 compliant and works even on the OGL 1.1 emulation on XP (which it in fact does!)<br><br>Opting it further would only have made sense if it added features that really benefited from it. But that would mean that things like Render to texture, tilemaps, chunked texture etc would have been needed to really make use of it (similar to TGB)<br><br>Not with the pure Blitz 2D wrap it is. <br><br></td></tr></table><br>
<a name="835485"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> They could have done better even with GL1.1 compatibility, like at least tracking of textures and state and batch rendering and vertex arrays. <br><br></td></tr></table><br>
<a name="835504"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Noel: I'm not sure if it really was lazyness and not just the attempt to make sure its real OGL 1.2 compliant and works even on the OGL 1.1 emulation on XP (which it in fact does!)<br><br>Opting it further would only have made sense if it added features that really benefited from it. But that would mean that things like Render to texture, tilemaps, chunked texture etc would have been needed to really make use of it (similar to TGB)<br><br>Not with the pure Blitz 2D wrap it is.  <br></div>Optimizing it further and maintaining even 1.1 compatibility would be incredibly easy.  This is laziness, don't mistake it for something akin to a wise design decision that benefits you. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
