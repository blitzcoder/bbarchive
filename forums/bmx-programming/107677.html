<!DOCTYPE html><html lang="en" ><head ><title >[Windows] Layered windows with per-pixel alpha + Max2D</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >[Windows] Layered windows with per-pixel alpha + Max2D</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >[Windows] Layered windows with per-pixel alpha + Max2D</a><br><br>
<a name="1334759"></a>

<a name="1334762"></a>

<a name="1334763"></a>

<a name="1334805"></a>

<a name="1334810"></a>

<a name="1334863"></a>

<a name="1334867"></a>

<a name="1334894"></a>

<a name="1334900"></a>

<a name="1334902"></a>

<a name="1334903"></a>

<a name="1334904"></a>

<a name="1334905"></a>

<a name="1334909"></a>

<a name="1334910"></a>

<a name="1334911"></a>

<a name="1334912"></a>

<a name="1334914"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2017)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Building on the previous sample <a href="/post.php?topic=107676&amp;post=1334908" target="_blank">Layered windows with per-pixel alpha</a>, this uses Max2D for rendering.<br><br>This sample uses UpdateLayeredWindow and the result from Max2D+D3D9/GL rendering to only show what is drawn on screen.<br>For D3D9, it copies from the render target into a surface, then copies that into a bitmap and then it draws the image to the screen with proper transparency.<br>For GL it copies it directly to a buffer and then to a bitmap, and finally to the screen.<br><br>The bitmap is needed by UpdateLayeredWindow for per-pixel transparency.<br><br>This sample uses a Desktop sized window, which isnt really needed unless you need to draw all over the screen.<br>If all you need is some movable region to draw to, a smaller window will be faster.<br><br>I use MaxGUI for this, but it should work with Graphics windows too.<br><br>D3D9:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Import MaxGUI.Drivers

SetGraphicsDriver D3D9Max2DDriver()

Local window:TGadget = CreateWindow( "LayeredWindow", 0,0, 256,256, Null, WINDOW_HIDDEN)
ResizeGadgetToDesktop(window)

Local canvas:TGadget = CreateCanvas( 0,0, window.Width,window.Height, window)

' get d3d9 device and create temp surface for copying from render-target
Local g:TGraphics = CanvasGraphics(canvas)
Local d3ddev:IDirect3DDevice9 = TD3D9Graphics(TMax2DGraphics(g)._graphics).GetDirect3DDevice()
Local d3dsurf:IDirect3DSurface9
d3dDev.CreateOffscreenPlainSurface( window.Width,window.Height, D3DFMT_X8R8G8B8, D3DPOOL_SYSTEMMEM, d3dsurf, Null)

' create test image (may flicker on screen on startup)
SetGraphics CanvasGraphics(canvas)
Local img:TImage = CreateTestImage( 256, 256)
SetImageHandle img, 128,128

' prepare for layered updates
Local hwnd:Int = window.Query(QUERY_HWND)
Local screendc:Int = GetDC(0)

' create temp bitmap to hold copy of screen
Local bmp:Int = CreateCompatibleBitmap( screendc, window.Width,window.Height)
Local bmpdc:Int = CreateCompatibleDC(screendc)
SelectObject( bmpdc, bmp)

' init layered effect
Local zero:Int[2]
Local size:Int[] = [ window.Width, window.Height]

Local blend:TBlendFunction = New TBlendFunction
blend.BlendOp = AC_SRC_OVER
blend.SourceConstantAlpha = 255
blend.AlphaFormat = AC_SRC_ALPHA

SetWindowLayered hwnd, True
UpdateLayeredWindow hwnd, screendc, zero, size, bmpdc, zero, 0, blend, ULW_ALPHA



' GO!
Local mousepos:Int[2]

ShowGadget window
ActivateGadget canvas

CreateTimer(60)
While WaitEvent()
	Select CurrentEvent.ID	
		Case EVENT_KEYDOWN
			If CurrentEvent.Data = KEY_ESCAPE Then Exit
		
		Case EVENT_GADGETPAINT
			SetGraphics CanvasGraphics(canvas)
			
			If ActiveGadget() = canvas Then
				GetCursorPos(mousepos)
			EndIf
			
			Global angle:Int
			angle :+ 2
			If angle &gt;= 360 Then angle = 0
			SetRotation angle
			
			SetColor 255,255,255
			DrawImage img, mousepos[0], mousepos[1]		
			
			UpdateBitmapFromDeviceSurface bmpdc, bmp, d3ddev, d3dsurf, window.Width,window.Height
			
			Flip
			Cls
		
		Case EVENT_TIMERTICK
			If Not UpdateLayeredWindow( hwnd, screendc, zero, size, bmpdc, zero, 0, blend, ULW_ALPHA) Then
				PrintLastError("UpdateLayeredWindow")
			EndIf
			RedrawGadget canvas
			
		Case EVENT_WINDOWCLOSE
			Exit			
	EndSelect
Wend
' release resources!
d3dsurf.Release_()
ReleaseDC( 0, screendc)
DeleteObject(bmp)
DeleteDC( bmpdc)
End



Function ResizeGadgetToDesktop( gadget:TGadget)
	Extern "Win32"
		Const SPI_GETWORKAREA:Int = $30
		
		Function SystemParametersInfoW:Int( action:Int, param1:Int, param2:Byte Ptr, winini:Int)
	EndExtern

	' get size of desktop minus taskbar/toolbars
	Local rect:Int[4]
	SystemParametersInfoW( SPI_GETWORKAREA, 0, rect, 0)
	SetGadgetShape gadget, rect[0],rect[1], rect[2], rect[3]
EndFunction

Function CreateTestImage:TImage( width:Int, height:Int)
	Local image:TImage = CreateImage( width, height)
	
	SetColor 255,255,255
	DrawRect 0,0, width,height

	SetColor 0,0,255
	DrawOval 32,32, width-64,height-64
	SetColor 255,255,255
	DrawText "B", (width/2)-10,(height/2)-64
	DrawText "B", (width/2)-10,(height)-64
		
	SetColor 0,0,0
	SetLineWidth	32
	DrawLine 0,0, width,height
	DrawLine 0,height, width,0
	
	SetColor 255,0,0
	DrawRect 32,32,32,32
	SetColor 255,255,255
	DrawText "R", 32+10,32+10

	SetColor 0,255,0
	DrawRect width-64,height-64,32,32
	SetColor 255,255,255
	DrawText "G", width-64+10,height-64+10

	GrabImage( image, 0,0)
	Return image
EndFunction

' inspired by GrabPixmap()
Function UpdateBitmapFromDeviceSurface( dc:Int, bmp:Int, dev:IDirect3DDevice9, surf:IDirect3DSurface9, width:Int, height:Int)
	Local srcsurf:IDirect3DSurface9
	If dev.GetRenderTarget( 0, srcsurf) &lt; 0 Then Throw "GetRednderTarget failed"
	
'** SLOW ON WINDOWS 7 **
'	Local src:Byte Ptr, dst:Byte Ptr
'	If srcsurf.GetDC(src) &lt; 0 Then Throw "srcsurf.GetDC() failed"
'	If surf.GetDC(dst) &lt; 0 Then Throw "surf.GetDC() failed"
'	
'	If Not BitBlt( Int(dst), 0,0, width,height, Int(src), 0,0, SRCCOPY) Then
'		PrintLastError("BitBlt")
'	EndIf
'	
'	surf.ReleaseDC(dst)
'	srcsurf.ReleaseDC(src)
'	srcsurf.Release_()

' fast on Windows 7+
	If dev.GetRenderTargetData( srcsurf, surf) &lt; 0 Then Throw "GetRenderTargetData failed"
	srcsurf.Release_()

	
	Local bi:BITMAPINFOHEADER = New BITMAPINFOHEADER
	bi.biSize = SizeOf(bi)
	bi.biWidth = width
	bi.biHeight = -height
	bi.biPlanes = 1
	bi.biBitCount = 32
	bi.biCompression = BI_RGB

	Local lockedrect:D3DLOCKED_RECT = New D3DLOCKED_RECT
	If surf.LockRect( lockedrect, Null, D3DLOCK_DISCARD) &lt; 0 Then Throw "dstsurf.LockRect failed"
	
	Local bits:Byte Ptr = lockedrect.pBits
	For Local y:Int = 0 Until height
		Local scan:Int Ptr = Int Ptr(bits)
		For Local x:Int = 0 Until width
			If scan[x] = $FF000000 Then
				scan[x] = $00000000
			EndIf
		Next
		bits :+ lockedrect.Pitch
	Next

	If Not SetDIBits( dc, bmp, 0,height, lockedrect.pBits, bi, DIB_RGB_COLORS) Then
		PrintLastError("SetDIBits")
	EndIf
	
	surf.UnlockRect()
EndFunction



Type TBlendFunction
	Field BlendOp:Byte
	Field BlendFlags:Byte
	Field SourceConstantAlpha:Byte
	Field AlphaFormat:Byte
EndType

Extern "Win32"
	Const GWL_EXSTYLE:Int = -20
	Const GWL_STYLE:Int = -16
	
	Const WS_EX_TRANSPARENT:Int = $20
	Const WS_EX_LAYERED:Int = $80000
	
	Const LWA_COLORKEY:Int = $1
	Const LWA_ALPHA:Int = $2
	
	Const ULW_ALPHA:Int = $2
	Const ULW_COLORKEY:Int = $1
	Const ULW_OPAQUE:Int = $4
	Const ULW_EX_NORESIZE:Int = $8
	
	Const AC_SRC_ALPHA:Int = $1
	Const AC_SRC_OVER:Int = $0
	
	Const SRCCOPY:Int = $00CC0020
	
	Function GetWindowLong:Int( hwnd:Int, index:Int) = "GetWindowLongA@8"
	Function SetWindowLong:Int( hwnd:Int, index:Int, value:Int) = "SetWindowLongA@12"

	Function UpdateLayeredWindow:Int( hwnd:Int, destdc:Int, destpoint:Byte Ptr, size:Byte Ptr, srcdc:Int, srcpoint:Byte Ptr, ckey:Int, blendfunc:Byte Ptr, flags:Int)

	Function UpdateLayeredWindowIndirect:Int( hwnd:Int, info:Byte Ptr)
	Function ReleaseDC:Int( hwnd:Int, dc:Int)
	
	Function CreateBitmap:Int( width:Int, height:Int, planes:Int, bitsperpel:Int, pixels:Byte Ptr)
	Function GetCursorPos:Int( p:Byte Ptr)
		
	Function GetDIBits:Int( dc:Int, bmp:Int, startscan:Int, scanlines:Int, bits:Byte Ptr, bi:Byte Ptr, usage:Int)
EndExtern


Function SetWindowLayered( hwnd:Int, layered:Int, transparent:Int = False)
	Local style:Int = GetWindowLong( hwnd, GWL_EXSTYLE)
	If layered Then 
		style :| WS_EX_LAYERED
	Else
		style :&amp; ~WS_EX_LAYERED
	EndIf
	If transparent  Then 
		style:| WS_EX_TRANSPARENT
	Else
		style :&amp; ~WS_EX_TRANSPARENT
	EndIf
	SetWindowLong( hwnd, GWL_EXSTYLE, style)
EndFunction

Function PrintLastError( funcname:String)
	Const FORMAT_MESSAGE_ALLOCATE_BUFFER:Int = $00000100
	Const FORMAT_MESSAGE_IGNORE_INSERTS:Int = $00000200
	Const FORMAT_MESSAGE_FROM_SYSTEM:Int = $00001000
	
	Const LMEM_ZEROINIT:Int = $40
	
	Extern "C"
		Function wcslen:Int( s:Short Ptr)
		Function fputws( s:Short Ptr, stream:Int)
		Function StringCchPrintfW( dst:Short Ptr, sz:Int, fmt$w, a$w, b:Int, c:Short Ptr)
	EndExtern
	
	Extern "Win32"
		Function LocalAlloc:Byte Ptr( flags:Int, sz:Int)
		Function LocalFree:Int( p:Byte Ptr)
		Function LocalSize:Int( p:Byte Ptr)
		Function GetLastError:Int()
		Function FormatMessageW:Int( flags:Int, source:Short Ptr, msg:Int, lang:Int, buf:Short Ptr Var, size:Int, valist:Byte Ptr)
	EndExtern

	Local msgbuf:Short Ptr
	Local err:Int = GetLastError()
	
	FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, ..
							Null, err, $400, msgbuf, 0, Null)
	
	Local sz:Int = (wcslen(msgbuf) + funcname.Length + 40) * 2
	Local dispbuf:Short Ptr = Short Ptr LocalAlloc( LMEM_ZEROINIT, sz)
	StringCchPrintfW( dispbuf, LocalSize(dispbuf) / 2, "%s failed with error %d: %s", funcname, err, msgbuf)
	fputws( dispbuf, stdout_)
	
	LocalFree(msgbuf)
	LocalFree(dispbuf)
EndFunction

</textarea><br>GL:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Import MaxGUI.Drivers

SetGraphicsDriver GLMax2DDriver()

Local window:TGadget = CreateWindow( "LayeredWindow", 0,0, 256,256, Null, WINDOW_HIDDEN)
ResizeGadgetToDesktop(window)

Local canvas:TGadget = CreateCanvas( 0,0, window.Width,window.Height, window)

' create temp buffer for copying pixel data
Local glpixels:Byte Ptr = MemAlloc( window.Width * window.Height * 4)

' create test image (may flicker on screen on startup)
SetGraphics CanvasGraphics(canvas)
Local img:TImage = CreateTestImage( 256, 256)
SetImageHandle img, 128,128

' prepare for layered updates
Local hwnd:Int = window.Query(QUERY_HWND)
Local screendc:Int = GetDC(0)

' create temp bitmap to hold copy of screen
Local bmp:Int = CreateCompatibleBitmap( screendc, window.Width,window.Height)
Local bmpdc:Int = CreateCompatibleDC(screendc)
SelectObject( bmpdc, bmp)

' init layered effect
Local zero:Int[2]
Local size:Int[] = [ window.Width, window.Height]

Local blend:TBlendFunction = New TBlendFunction
blend.BlendOp = AC_SRC_OVER
blend.SourceConstantAlpha = 255
blend.AlphaFormat = AC_SRC_ALPHA

SetWindowLayered hwnd, True
UpdateLayeredWindow hwnd, screendc, zero, size, bmpdc, zero, 0, blend, ULW_ALPHA



' GO!
Local mousepos:Int[2]

ShowGadget window
ActivateGadget canvas

CreateTimer(60)
While WaitEvent()
	Select CurrentEvent.ID	
		Case EVENT_KEYDOWN
			If CurrentEvent.Data = KEY_ESCAPE Then Exit
		
		Case EVENT_GADGETPAINT
			SetGraphics CanvasGraphics(canvas)
			
			If ActiveGadget() = canvas Then
				GetCursorPos(mousepos)
			EndIf
			
			Global angle:Int
			angle :+ 2
			If angle &gt;= 360 Then angle = 0
			SetRotation angle
			
			SetColor 255,255,255
			DrawImage img, mousepos[0], mousepos[1]		
			
			UpdateBitmapFromGL bmpdc, bmp, glpixels, window.Width,window.Height
			
			Flip
			Cls
		
		Case EVENT_TIMERTICK
			If Not UpdateLayeredWindow( hwnd, screendc, zero, size, bmpdc, zero, 0, blend, ULW_ALPHA) Then
				PrintLastError("UpdateLayeredWindow")
			EndIf
			RedrawGadget canvas
			
		Case EVENT_WINDOWCLOSE
			Exit			
	EndSelect
Wend
' release resources!
MemFree glpixels
ReleaseDC( 0, screendc)
DeleteObject(bmp)
DeleteDC( bmpdc)
End



Function ResizeGadgetToDesktop( gadget:TGadget)
	Extern "Win32"
		Const SPI_GETWORKAREA:Int = $30
		
		Function SystemParametersInfoW:Int( action:Int, param1:Int, param2:Byte Ptr, winini:Int)
	EndExtern

	' get size of desktop minus taskbar/toolbars
	Local rect:Int[4]
	SystemParametersInfoW( SPI_GETWORKAREA, 0, rect, 0)
	SetGadgetShape gadget, rect[0],rect[1], rect[2], rect[3]
EndFunction


Function CreateTestImage:TImage( width:Int, height:Int)
	Local image:TImage = CreateImage( width, height)
	
	SetColor 255,255,255
	DrawRect 0,0, width,height

	SetColor 0,0,255
	DrawOval 32,32, width-64,height-64
	SetColor 255,255,255
	DrawText "B", (width/2)-10,(height/2)-64
	DrawText "B", (width/2)-10,(height)-64
		
	SetColor 0,0,0
	SetLineWidth	32
	DrawLine 0,0, width,height
	DrawLine 0,height, width,0
	
	SetColor 255,0,0
	DrawRect 32,32,32,32
	SetColor 255,255,255
	DrawText "R", 32+10,32+10

	SetColor 0,255,0
	DrawRect width-64,height-64,32,32
	SetColor 255,255,255
	DrawText "G", width-64+10,height-64+10

	GrabImage( image, 0,0)
	Return image
EndFunction

' inspired by GrabPixmap()
Function UpdateBitmapFromGL( dc:Int, bmp:Int, pixels:Byte Ptr, width:Int, height:Int)
	glReadPixels( 0,0, width,height, GL_BGRA, GL_UNSIGNED_BYTE, pixels)
	
	Local bi:BITMAPINFOHEADER = New BITMAPINFOHEADER
	bi.biSize = SizeOf(bi)
	bi.biWidth = width
	bi.biHeight = height
	bi.biPlanes = 1
	bi.biBitCount = 32
	bi.biCompression = BI_RGB

	Local bits:Byte Ptr = pixels
	Local pitch:Int = width * 4
	For Local y:Int = 0 Until height
		Local scan:Int Ptr = Int Ptr(bits)
		For Local x:Int = 0 Until width
			Local p:Int = scan[x]
			If p = $FF000000 Then
				scan[x] = $00000000
			EndIf
		Next
		bits :+ pitch
	Next

	If Not SetDIBits( dc, bmp, 0,height, pixels, bi, DIB_RGB_COLORS) Then
		PrintLastError("SetDIBits")
	EndIf
EndFunction



Type TBlendFunction
	Field BlendOp:Byte
	Field BlendFlags:Byte
	Field SourceConstantAlpha:Byte
	Field AlphaFormat:Byte
EndType

Extern "Win32"
	Const GWL_EXSTYLE:Int = -20
	Const GWL_STYLE:Int = -16
	
	Const WS_EX_TRANSPARENT:Int = $20
	Const WS_EX_LAYERED:Int = $80000
	
	Const LWA_COLORKEY:Int = $1
	Const LWA_ALPHA:Int = $2
	
	Const ULW_ALPHA:Int = $2
	Const ULW_COLORKEY:Int = $1
	Const ULW_OPAQUE:Int = $4
	Const ULW_EX_NORESIZE:Int = $8
	
	Const AC_SRC_ALPHA:Int = $1
	Const AC_SRC_OVER:Int = $0
	
	Const SRCCOPY:Int = $00CC0020
	
	Function GetWindowLong:Int( hwnd:Int, index:Int) = "GetWindowLongA@8"
	Function SetWindowLong:Int( hwnd:Int, index:Int, value:Int) = "SetWindowLongA@12"

	Function UpdateLayeredWindow:Int( hwnd:Int, destdc:Int, destpoint:Byte Ptr, size:Byte Ptr, srcdc:Int, srcpoint:Byte Ptr, ckey:Int, blendfunc:Byte Ptr, flags:Int)

	Function UpdateLayeredWindowIndirect:Int( hwnd:Int, info:Byte Ptr)
	Function ReleaseDC:Int( hwnd:Int, dc:Int)
	
	Function CreateBitmap:Int( width:Int, height:Int, planes:Int, bitsperpel:Int, pixels:Byte Ptr)
	Function GetCursorPos:Int( p:Byte Ptr)
		
	Function GetDIBits:Int( dc:Int, bmp:Int, startscan:Int, scanlines:Int, bits:Byte Ptr, bi:Byte Ptr, usage:Int)
EndExtern


Function SetWindowLayered( hwnd:Int, layered:Int, transparent:Int = False)
	Local style:Int = GetWindowLong( hwnd, GWL_EXSTYLE)
	If layered Then 
		style :| WS_EX_LAYERED
	Else
		style :&amp; ~WS_EX_LAYERED
	EndIf
	If transparent  Then 
		style:| WS_EX_TRANSPARENT
	Else
		style :&amp; ~WS_EX_TRANSPARENT
	EndIf
	SetWindowLong( hwnd, GWL_EXSTYLE, style)
EndFunction

Function PrintLastError( funcname:String)
	Const FORMAT_MESSAGE_ALLOCATE_BUFFER:Int = $00000100
	Const FORMAT_MESSAGE_IGNORE_INSERTS:Int = $00000200
	Const FORMAT_MESSAGE_FROM_SYSTEM:Int = $00001000
	
	Const LMEM_ZEROINIT:Int = $40
	
	Extern "C"
		Function wcslen:Int( s:Short Ptr)
		Function fputws( s:Short Ptr, stream:Int)
		Function StringCchPrintfW( dst:Short Ptr, sz:Int, fmt$w, a$w, b:Int, c:Short Ptr)
	EndExtern
	
	Extern "Win32"
		Function LocalAlloc:Byte Ptr( flags:Int, sz:Int)
		Function LocalFree:Int( p:Byte Ptr)
		Function LocalSize:Int( p:Byte Ptr)
		Function GetLastError:Int()
		Function FormatMessageW:Int( flags:Int, source:Short Ptr, msg:Int, lang:Int, buf:Short Ptr Var, size:Int, valist:Byte Ptr)
	EndExtern

	Local msgbuf:Short Ptr
	Local err:Int = GetLastError()
	
	FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, ..
							Null, err, $400, msgbuf, 0, Null)
	
	Local sz:Int = (wcslen(msgbuf) + funcname.Length + 40) * 2
	Local dispbuf:Short Ptr = Short Ptr LocalAlloc( LMEM_ZEROINIT, sz)
	StringCchPrintfW( dispbuf, LocalSize(dispbuf) / 2, "%s failed with error %d: %s", funcname, err, msgbuf)
	fputws( dispbuf, stdout_)
	
	LocalFree(msgbuf)
	LocalFree(dispbuf)
EndFunction

</textarea> <br><br></td></tr></table><br>
<a name="1334775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted 2017)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I'm getting some really bad fps on Windows 7. I'll test again when I'm home.<br><br>-Henri <br><br></td></tr></table><br>
<a name="1334803"></a>

<a name="1334806"></a>

<a name="1334812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats weird, i get 60+ with Windows 10. This was the fastest method i found of grabbing the rendered output.<br>But i do grab the entire screen though, so depending on screen resolution and cpu power it probably eats a lot.<br>The grabbing uses practically the same technique as GrabPixmap() so shouldt be THAT slow.<br><br>Maybe Windows 7 just sucks with UpdateLayeredWindow, or the window is too big for it...<br><br>EDIT: I added some error checking, it should print an error if any of the APIs complain. <br><br></td></tr></table><br>
<a name="1334818"></a>

<a name="1334819"></a>

<a name="1334822"></a>

<a name="1334823"></a>

<a name="1334826"></a>

<a name="1334827"></a>

<a name="1334861"></a>

<a name="1334895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Heres a version with performance monitoring of various parts of the source.<br>If anyone wants to check why its so slow on Windows 7, run it and see what it spits out on exit.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Import MaxGUI.Drivers

SetGraphicsDriver D3D9Max2DDriver()

Local window:TGadget = CreateWindow( "LayeredWindow", 0,0, 256,256, Null, WINDOW_HIDDEN)
ResizeGadgetToDesktop(window)
Print "~nDesktop Size = " + window.Width + "," + window.Height

Local canvas:TGadget = CreateCanvas( 0,0, window.Width,window.Height, window)

' get d3d9 device and create temp surface for copying from render-target
Local g:TGraphics = CanvasGraphics(canvas)
Local d3ddev:IDirect3DDevice9 = TD3D9Graphics(TMax2DGraphics(g)._graphics).GetDirect3DDevice()
Local d3dsurf:IDirect3DSurface9
d3dDev.CreateOffscreenPlainSurface( window.Width,window.Height, D3DFMT_X8R8G8B8, D3DPOOL_SYSTEMMEM, d3dsurf, Null)

' create test image (may flicker on screen on startup)
SetGraphics CanvasGraphics(canvas)
Local img:TImage = CreateTestImage( 256, 256)
SetImageHandle img, 128,128

' prepare for layered updates
Local hwnd:Int = window.Query(QUERY_HWND)
Local screendc:Int = GetDC(0)

' create temp bitmap to hold copy of screen
Local bmp:Int = CreateCompatibleBitmap( screendc, window.Width,window.Height)
Local bmpdc:Int = CreateCompatibleDC(screendc)
SelectObject( bmpdc, bmp)

' init layered effect
Local zero:Int[2]
Local size:Int[] = [ window.Width, window.Height]

Local blend:TBlendFunction = New TBlendFunction
blend.BlendOp = AC_SRC_OVER
blend.SourceConstantAlpha = 255
blend.AlphaFormat = AC_SRC_ALPHA

SetWindowLayered hwnd, True
UpdateLayeredWindow hwnd, screendc, zero, size, bmpdc, zero, 0, blend, ULW_ALPHA

' create performance monitors
Global perf:TPerfTimer = New TPerfTimer
Global _gp:TPerfItem = perf.AddItem("EVENT_GADGETPAINT")
Global _fp:TPerfItem = perf.AddItem("Flip;Cls")
Global _ubfds:TPerfItem = perf.AddItem("UpdateBitmapFromDeviceSurface")
Global _grt:TPerfItem = perf.AddItem("GetRenderTarget")
Global _blt:TPerfItem = perf.AddItem("BitBlt")
Global _lck:TPerfItem = perf.AddItem("LockRect")
Global _tfa:TPerfItem = perf.AddItem("Transform Alpha")
Global _sdb:TPerfItem = perf.AddItem("SetDIBits")
Global _ulw:TPerfItem = perf.AddItem("UpdateLayeredWindow")
perf.Begin()

' print some device caps
PrintDeviceCaps "Screen", screendc
PrintDeviceCaps "Bitmap", bmpdc
Local tmpdc:Byte Ptr
If d3dsurf.GetDC(tmpdc) &lt; 0 Then Throw "d3dsurf.GetDC() failed"
PrintDeviceCaps "Surface", Int(tmpdc)
d3dsurf.ReleaseDC(tmpdc)
Local tmpsurf:IDirect3DSurface9
If d3ddev.GetRenderTarget( 0, tmpsurf) &lt; 0 Then Throw "GetRenderTarget failed"
If tmpsurf.GetDC(tmpdc) &lt; 0 Then Throw "d3dsurf.GetDC() failed"
PrintDeviceCaps "RenderTarget", Int(tmpdc)
tmpsurf.ReleaseDC(tmpdc)
tmpsurf.Release_()

' print some surface caps
PrintSurfaceCaps( "Surface", d3dsurf)
If d3ddev.GetRenderTarget( 0, tmpsurf) &lt; 0 Then Throw "GetRenderTarget failed"
PrintSurfaceCaps( "RenderTarget", tmpsurf)
tmpsurf.Release_()


' GO!
Local mousepos:Int[2]

ShowGadget window
ActivateGadget canvas

CreateTimer(60)
While WaitEvent()
	Select CurrentEvent.ID	
		Case EVENT_KEYDOWN
			If CurrentEvent.Data = KEY_ESCAPE Then Exit
		
		Case EVENT_GADGETPAINT
			_gp.Start()
			SetGraphics CanvasGraphics(canvas)
			
			If ActiveGadget() = canvas Then
				GetCursorPos(mousepos)
			EndIf
			
			Global angle:Int
			angle :+ 2
			If angle &gt;= 360 Then angle = 0
			SetRotation angle
			
			SetColor 255,255,255
			DrawImage img, mousepos[0], mousepos[1]		
			
			_ubfds.Start()			
			UpdateBitmapFromDeviceSurface bmpdc, bmp, d3ddev, d3dsurf, window.Width,window.Height
			_ubfds.Stop()
			
			_fp.Start()
			Flip
			Cls
			_fp.Stop()			
			_gp.Stop()
		
		Case EVENT_TIMERTICK
			_ulw.Start()
			If Not UpdateLayeredWindow( hwnd, screendc, zero, size, bmpdc, zero, 0, blend, ULW_ALPHA) Then
				PrintLastError("UpdateLayeredWindow")
			EndIf
			_ulw.Stop()
			RedrawGadget canvas
			
		Case EVENT_WINDOWCLOSE
			Exit			
	EndSelect
Wend
perf.Done()
perf.Display()
' release resources!
d3dsurf.Release_()
ReleaseDC( 0, screendc)
DeleteObject(bmp)
DeleteDC( bmpdc)
End



Function ResizeGadgetToDesktop( gadget:TGadget)
	Extern "Win32"
		Const SPI_GETWORKAREA:Int = $30
		
		Function SystemParametersInfoW:Int( action:Int, param1:Int, param2:Byte Ptr, winini:Int)
	EndExtern

	' get size of desktop minus taskbar/toolbars
	Local rect:Int[4]
	SystemParametersInfoW( SPI_GETWORKAREA, 0, rect, 0)
	SetGadgetShape gadget, rect[0],rect[1], rect[2], rect[3]
EndFunction

Function CreateTestImage:TImage( width:Int, height:Int)
	Local image:TImage = CreateImage( width, height)
	
	SetColor 255,255,255
	DrawRect 0,0, width,height

	SetColor 0,0,255
	DrawOval 32,32, width-64,height-64
	SetColor 255,255,255
	DrawText "B", (width/2)-10,(height/2)-64
	DrawText "B", (width/2)-10,(height)-64
		
	SetColor 0,0,0
	SetLineWidth	32
	DrawLine 0,0, width,height
	DrawLine 0,height, width,0
	
	SetColor 255,0,0
	DrawRect 32,32,32,32
	SetColor 255,255,255
	DrawText "R", 32+10,32+10

	SetColor 0,255,0
	DrawRect width-64,height-64,32,32
	SetColor 255,255,255
	DrawText "G", width-64+10,height-64+10

	GrabImage( image, 0,0)
	Return image
EndFunction

' inspired by GrabPixmap()
Function UpdateBitmapFromDeviceSurface( dc:Int, bmp:Int, dev:IDirect3DDevice9, surf:IDirect3DSurface9, width:Int, height:Int)
	Local srcsurf:IDirect3DSurface9
	
	_grt.Start()
	If dev.GetRenderTarget( 0, srcsurf) &lt; 0 Then Throw "GetRenderTarget failed"
	_grt.Stop()
	
'	_blt.Start()
'	Local src:Byte Ptr, dst:Byte Ptr
'	If srcsurf.GetDC(src) &lt; 0 Then Throw "srcsurf.GetDC() failed"
'	If surf.GetDC(dst) &lt; 0 Then Throw "surf.GetDC() failed"
'	
'	If Not BitBlt( Int(dst), 0,0, width,height, Int(src), 0,0, SRCCOPY) Then
'		PrintLastError("BitBlt")
'	EndIf
'	
'	surf.ReleaseDC(dst)
'	srcsurf.ReleaseDC(src)
'	srcsurf.Release_()
'	_blt.Stop()
	_blt.Start()
	If dev.GetRenderTargetData( srcsurf, surf) &lt; 0 Then Throw "GetRenderTargetData failed"
	srcsurf.Release_()
	_blt.Stop()


	Local bi:BITMAPINFOHEADER = New BITMAPINFOHEADER
	bi.biSize = SizeOf(bi)
	bi.biWidth = width
	bi.biHeight = -height
	bi.biPlanes = 1
	bi.biBitCount = 32
	bi.biCompression = BI_RGB

	_lck.Start()
	Local lockedrect:D3DLOCKED_RECT = New D3DLOCKED_RECT
	If surf.LockRect( lockedrect, Null, D3DLOCK_DISCARD) &lt; 0 Then Throw "dstsurf.LockRect failed"
	_lck.Stop()
		
	_tfa.Start()
	Local bits:Byte Ptr = lockedrect.pBits
	For Local y:Int = 0 Until height
		Local scan:Int Ptr = Int Ptr(bits)
		For Local x:Int = 0 Until width
			If scan[x] = $FF000000 Then
				scan[x] = $00000000
			EndIf
		Next
		bits :+ lockedrect.Pitch
	Next
	_tfa.Stop()

	_sdb.Start()
	If Not SetDIBits( dc, bmp, 0,height, lockedrect.pBits, bi, DIB_RGB_COLORS) Then
		PrintLastError("SetDIBits")
	EndIf
	_sdb.Stop()
		
	surf.UnlockRect()
EndFunction



Type TBlendFunction
	Field BlendOp:Byte
	Field BlendFlags:Byte
	Field SourceConstantAlpha:Byte
	Field AlphaFormat:Byte
EndType

Extern "Win32"
	Const GWL_EXSTYLE:Int = -20
	Const GWL_STYLE:Int = -16
	
	Const WS_EX_TRANSPARENT:Int = $20
	Const WS_EX_LAYERED:Int = $80000
	
	Const LWA_COLORKEY:Int = $1
	Const LWA_ALPHA:Int = $2
	
	Const ULW_ALPHA:Int = $2
	Const ULW_COLORKEY:Int = $1
	Const ULW_OPAQUE:Int = $4
	Const ULW_EX_NORESIZE:Int = $8
	
	Const AC_SRC_ALPHA:Int = $1
	Const AC_SRC_OVER:Int = $0
	
	Const SRCCOPY:Int = $00CC0020
	
	Function GetWindowLong:Int( hwnd:Int, index:Int) = "GetWindowLongA@8"
	Function SetWindowLong:Int( hwnd:Int, index:Int, value:Int) = "SetWindowLongA@12"

	Function UpdateLayeredWindow:Int( hwnd:Int, destdc:Int, destpoint:Byte Ptr, size:Byte Ptr, srcdc:Int, srcpoint:Byte Ptr, ckey:Int, blendfunc:Byte Ptr, flags:Int)

	Function UpdateLayeredWindowIndirect:Int( hwnd:Int, info:Byte Ptr)
	Function ReleaseDC:Int( hwnd:Int, dc:Int)
	
	Function CreateBitmap:Int( width:Int, height:Int, planes:Int, bitsperpel:Int, pixels:Byte Ptr)
	Function GetCursorPos:Int( p:Byte Ptr)
		
	Function GetDIBits:Int( dc:Int, bmp:Int, startscan:Int, scanlines:Int, bits:Byte Ptr, bi:Byte Ptr, usage:Int)
EndExtern


Function SetWindowLayered( hwnd:Int, layered:Int, transparent:Int = False)
	Local style:Int = GetWindowLong( hwnd, GWL_EXSTYLE)
	If layered Then 
		style :| WS_EX_LAYERED
	Else
		style :&amp; ~WS_EX_LAYERED
	EndIf
	If transparent  Then 
		style:| WS_EX_TRANSPARENT
	Else
		style :&amp; ~WS_EX_TRANSPARENT
	EndIf
	SetWindowLong( hwnd, GWL_EXSTYLE, style)
EndFunction

Function PrintLastError( funcname:String)
	Const FORMAT_MESSAGE_ALLOCATE_BUFFER:Int = $00000100
	Const FORMAT_MESSAGE_IGNORE_INSERTS:Int = $00000200
	Const FORMAT_MESSAGE_FROM_SYSTEM:Int = $00001000
	
	Const LMEM_ZEROINIT:Int = $40
	
	Extern "C"
		Function wcslen:Int( s:Short Ptr)
		Function fputws( s:Short Ptr, stream:Int)
		Function StringCchPrintfW( dst:Short Ptr, sz:Int, fmt$w, a$w, b:Int, c:Short Ptr)
	EndExtern
	
	Extern "Win32"
		Function LocalAlloc:Byte Ptr( flags:Int, sz:Int)
		Function LocalFree:Int( p:Byte Ptr)
		Function LocalSize:Int( p:Byte Ptr)
		Function GetLastError:Int()
		Function FormatMessageW:Int( flags:Int, source:Short Ptr, msg:Int, lang:Int, buf:Short Ptr Var, size:Int, valist:Byte Ptr)
	EndExtern

	Local msgbuf:Short Ptr
	Local err:Int = GetLastError()
	
	FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, ..
							Null, err, $400, msgbuf, 0, Null)
	
	Local sz:Int = (wcslen(msgbuf) + funcname.Length + 40) * 2
	Local dispbuf:Short Ptr = Short Ptr LocalAlloc( LMEM_ZEROINIT, sz)
	StringCchPrintfW( dispbuf, LocalSize(dispbuf) / 2, "%s failed with error %d: %s", funcname, err, msgbuf)
	fputws( dispbuf, stdout_)
	
	LocalFree(msgbuf)
	LocalFree(dispbuf)
EndFunction




Type TPerfItem
	Field Name:String
	Field Timer:Int
	Field Time:Int
	Field Count:Int
	Field AverageTime:Int
	
	Method Begin()
		Time = 0
		Count = 0
		AverageTime = 0
	EndMethod
	
	Method Start()
		Timer = MilliSecs()
		Count :+ 1
	EndMethod
	
	Method Stop()
		Time = MilliSecs() - Timer 
		AverageTime :+ Time
	EndMethod
	
	Method Done()
		AverageTime :/ Count
	EndMethod
	
	Method Display()
		Print Name + ": time=" + Time + "  avg=" + AverageTime + "  count=" + Count
	EndMethod
EndType

Type TPerfTimer
	Field Items:TPerfItem[]
	
	Method AddItem:TPerfItem( name:String)
		Local item:TPerfItem = New TPerfItem
		item.Name = name
		Items :+ [ item ]
		Return item
	EndMethod
	
	Method Begin()
		For Local item:TPerfItem = EachIn Items
			item.Begin()
		Next
	EndMethod
	
	Method Done()
		For Local item:TPerfItem = EachIn Items
			item.Done()
		Next
	EndMethod
	
	Method Display()
		Print ""
		For Local item:TPerfItem = EachIn Items
			item.Display()
		Next
	EndMethod
EndType


Extern "Win32"
	Const DRIVERVERSION:Int = 0
	Const TECHNOLOGY:Int = 2
	Const HORZSIZE:Int = 4
	Const VERTSIZE:Int = 6
	Const HORZRES:Int = 8
	Const VERTRES:Int = 10
	Const BITSPIXEL:Int = 12
	Const PLANES:Int = 14
	Const NUMBRUSHES:Int = 16
	Const NUMPENS:Int = 18
	Const NUMMARKERS:Int = 20
	Const NUMFONTS:Int = 22
	Const NUMCOLORS:Int = 24
	Const PDEVICESIZE:Int = 26
	Const CURVECAPS:Int = 28
	Const LINECAPS:Int = 30
	Const POLYGONALCAPS:Int = 32
	Const TEXTCAPS:Int = 34
	Const CLIPCAPS:Int = 36
	Const RASTERCAPS:Int = 38
	Const ASPECTX:Int = 40
	Const ASPECTY:Int = 42
	Const ASPECTXY:Int = 44
	Const LOGPIXELSX:Int = 88
	Const LOGPIXELSY:Int = 90
	Const SIZEPALETTE:Int = 104
	Const NUMRESERVED:Int = 106
	Const COLORRES:Int = 108
	Const PHYSICALWIDTH:Int = 110
	Const PHYSICALHEIGHT:Int = 111
	Const PHYSICALOFFSETX:Int = 112
	Const PHYSICALOFFSETY:Int = 113
	Const SCALINGFACTORX:Int = 114
	Const SCALINGFACTORY:Int = 115
	Const VREFRESH:Int = 116
	Const DESKTOPVERTRES:Int = 117
	Const DESKTOPHORZRES:Int = 118
	Const BLTALIGNMENT:Int = 119
	Const SHADEBLENDCAPS:Int = 120
	Const COLORMGMTCAPS:Int = 121
	
	Const SB_NONE:Int = $00000000
	Const SB_CONST_ALPHA:Int = $00000001
	Const SB_PIXEL_ALPHA:Int = $00000002
	Const SB_PREMULT_ALPHA:Int = $00000004	
	Const SB_GRAD_RECT:Int = $00000010
	Const SB_GRAD_TRI:Int = $00000020
	
	Const RC_NONE:Int = 0
	Const RC_BITBLT:Int = 1
	Const RC_BANDING:Int = 2
	Const RC_SCALING:Int = 4
	Const RC_BITMAP64:Int = 8
	Const RC_GDI20_OUTPUT:Int = $0010
	Const RC_GDI20_STATE:Int = $0020
	Const RC_SAVEBITMAP:Int = $0040
	Const RC_DI_BITMAP:Int = $0080
	Const RC_PALETTE:Int = $0100
	Const RC_DIBTODEV:Int = $0200
	Const RC_BIGFONT:Int = $0400
	Const RC_STRETCHBLT:Int = $0800
	Const RC_FLOODFILL:Int = $1000
	Const RC_STRETCHDIB:Int = $2000
	Const RC_OP_DX_OUTPUT:Int = $4000
	Const RC_DEVBITS:Int = $8000
	
	Const CC_CIRCLES:Int = 1
	Const CC_PIE:Int = 2
	Const CC_CHORD:Int = 4
	Const CC_ELLIPSES:Int = 8
	Const CC_WIDE:Int = 16
	Const CC_STYLED:Int = 32
	Const CC_WIDESTYLED:Int = 64
	Const CC_INTERIORS:Int = 128
	Const CC_ROUNDRECT:Int = 256
	
	Const LC_NONE:Int = 0
	Const LC_POLYLINE:Int = 2
	Const LC_MARKER:Int = 4
	Const LC_POLYMARKER:Int = 8
	Const LC_WIDE:Int = 16
	Const LC_STYLED:Int = 32
	Const LC_WIDESTYLED:Int = 64
	Const LC_INTERIORS:Int = 128
	
	Const PC_NONE:Int = 0
	Const PC_POLYGON:Int = 1
	Const PC_RECTANGLE:Int = 2
	Const PC_WINDPOLYGON:Int = 4
	Const PC_TRAPEZOID:Int = 4
	Const PC_SCANLINE:Int = 8
	Const PC_WIDE:Int = 16
	Const PC_STYLED:Int = 32
	Const PC_WIDESTYLED:Int = 64
	Const PC_INTERIORS:Int = 128
	Const PC_POLYPOLYGON:Int = 256
	Const PC_PATHS:Int = 512
	
	Const TC_OP_CHARACTER:Int = $00000001
	Const TC_OP_STROKE:Int = $00000002
	Const TC_CP_STROKE:Int = $00000004
	Const TC_CR_90:Int = $00000008
	Const TC_CR_ANY:Int = $00000010
	Const TC_SF_X_YINDEP:Int = $00000020
	Const TC_SA_DOUBLE:Int = 00000040
	Const TC_SA_INTEGER:Int = $00000080
	Const TC_SA_CONTIN:Int = $00000100
	Const TC_EA_DOUBLE:Int = $00000200
	Const TC_IA_ABLE:Int = $00000400
	Const TC_UA_ABLE:Int = $00000800
	Const TC_SO_ABLE:Int = $00001000
	Const TC_RA_ABLE:Int = $00002000
	Const TC_VA_ABLE:Int = $00004000
	Const TC_RESERVED:Int = $00008000
	Const TC_SCROLLBLT:Int = $00010000
	
	Const CM_NONE:Int = $00000000
	Const CM_DEVICE_ICM:Int = $00000001
	Const CM_GAMMA_RAMP:Int = $00000002
	Const CM_CMYK_COLOR:Int = $00000004

	Function GetDeviceCaps:Int( dc:Int, index:Int)
EndExtern

Function PrintDeviceCaps( name:String, dc:Int)
	Function _TECHNOLOGY:String( cap:Int)
		Global names:String[] = [ "Plotter", "Raster Display", "Raster Printer", "Raster Camera", "Character Stream", "Meta File", "Display File" ]
		If cap &lt; 0 Or cap &gt;= names.Length Then Return "** Unknown ** (" + cap + ")"
		Return names[cap]
	EndFunction
	
	Function _SHADERBLENDCAPS:String( cap:Int)
		Local s:String
		If cap &amp; SB_CONST_ALPHA Then s :+ "SB_CONST_ALPHA "
		If cap &amp; SB_PIXEL_ALPHA Then s :+ "SB_CONST_ALPHA "
		If cap &amp; SB_PREMULT_ALPHA Then s :+ "SB_CONST_ALPHA "
		If cap &amp; SB_GRAD_RECT Then s :+ "SB_CONST_ALPHA "
		If cap &amp; SB_GRAD_TRI Then s :+ "SB_CONST_ALPHA "
		If Not s Then Return "NONE"
		Return s
	EndFunction
	
	Function _RASTERCAPS:String( cap:Int)
		Local s:String
		If cap &amp; RC_BITBLT Then s :+ "RC_BITBLT "
		If cap &amp; RC_BANDING Then s :+ "RC_BANDING "
		If cap &amp; RC_SCALING Then s :+ "RC_SCALING "
		If cap &amp; RC_BITMAP64 Then s :+ "RC_BITMAP64 "
		If cap &amp; RC_GDI20_OUTPUT Then s :+ "RC_GDI20_OUTPUT "
		If cap &amp; RC_GDI20_STATE Then s :+ "RC_GDI20_STATE "
		If cap &amp; RC_SAVEBITMAP Then s :+ "RC_SAVEBITMAP "
		If cap &amp; RC_DI_BITMAP Then s :+ "RC_DI_BITMAP "
		If cap &amp; RC_PALETTE Then s :+ "RC_PALETTE "
		If cap &amp; RC_DIBTODEV Then s :+ "RC_DIBTODEV "
		If cap &amp; RC_BIGFONT Then s :+ "RC_BIGFONT "
		If cap &amp; RC_STRETCHBLT Then s :+ "RC_STRETCHBLT "
		If cap &amp; RC_FLOODFILL Then s :+ "RC_FLOODFILL "
		If cap &amp; RC_STRETCHDIB Then s :+ "RC_STRETCHDIB "
		If cap &amp; RC_OP_DX_OUTPUT Then s :+ "RC_OP_DX_OUTPUT "
		If cap &amp; RC_DEVBITS Then s :+ "RC_DEVBITS "
		If Not s Then Return "NONE"
		Return s
	EndFunction
	
	Function _CURVECAPS:String( cap:Int)
		Local s:String
		If cap &amp; CC_CIRCLES Then s :+ "CC_CIRCLES "
		If cap &amp; CC_PIE Then s :+ "CC_PIE "
		If cap &amp; CC_CHORD Then s :+ "CC_CHORD "
		If cap &amp; CC_ELLIPSES Then s :+ "CC_ELLIPSES "
		If cap &amp; CC_WIDE Then s :+ "CC_WIDE "
		If cap &amp; CC_STYLED Then s :+ "CC_STYLED "
		If cap &amp; CC_WIDESTYLED Then s :+ "CC_WIDESTYLED "
		If cap &amp; CC_INTERIORS Then s :+ "CC_INTERIORS "
		If cap &amp; CC_ROUNDRECT Then s :+ "CC_ROUNDRECT "
		If Not s Then Return "NONE"
		Return s
	EndFunction
	
	Function _LINECAPS:String( cap:Int)
		Local s:String
		If cap &amp; LC_POLYLINE Then s :+ "LC_POLYLINE "
		If cap &amp; LC_MARKER Then s :+ "LC_MARKER "
		If cap &amp; LC_POLYMARKER Then s :+ "LC_POLYMARKER "
		If cap &amp; LC_WIDE Then s :+ "LC_WIDE "
		If cap &amp; LC_STYLED Then s :+ "LC_STYLED "
		If cap &amp; LC_WIDESTYLED Then s :+ "LC_WIDESTYLED "
		If cap &amp; LC_INTERIORS Then s :+ "LC_INTERIORS "
		If Not s Then Return "NONE"
		Return s
	EndFunction

	Function _POLYGONALCAPS:String( cap:Int)
		Local s:String
		If cap &amp; PC_POLYGON Then s :+ "PC_POLYGON "
		If cap &amp; PC_RECTANGLE Then s :+ "PC_RECTANGLE "
		If cap &amp; PC_WINDPOLYGON Then s :+ "PC_WINDPOLYGON "
		If cap &amp; PC_TRAPEZOID Then s :+ "PC_TRAPEZOID "
		If cap &amp; PC_SCANLINE Then s :+ "PC_SCANLINE "
		If cap &amp; PC_WIDE Then s :+ "PC_WIDE "
		If cap &amp; PC_STYLED Then s :+ "PC_STYLED "
		If cap &amp; PC_WIDESTYLED Then s :+ "PC_WIDESTYLED "
		If cap &amp; PC_INTERIORS Then s :+ "PC_INTERIORS "
		If cap &amp; PC_POLYPOLYGON Then s :+ "PC_POLYPOLYGON "
		If cap &amp; PC_PATHS Then s :+ "PC_PATHS "
		If Not s Then Return "NONE"
		Return s
	EndFunction

	Function _TEXTCAPS:String( cap:Int)
		Local s:String
		If cap &amp; TC_OP_CHARACTER Then s :+ "TC_OP_CHARACTER "
		If cap &amp; TC_OP_STROKE Then s :+ "TC_OP_STROKE "
		If cap &amp; TC_CP_STROKE Then s :+ "TC_CP_STROKE "
		If cap &amp; TC_CR_90 Then s:+ "TC_CR_90 "
		If cap &amp; TC_CR_ANY Then s :+ "TC_CR_ANY "
		If cap &amp; TC_SF_X_YINDEP Then s :+ "TC_SF_X_YINDEP "
		If cap &amp; TC_SA_DOUBLE Then s :+ "TC_SA_DOUBLE "
		If cap &amp; TC_SA_INTEGER Then s :+ "TC_SA_INTEGER "
		If cap &amp; TC_SA_CONTIN Then s :+ "TC_SA_CONTIN "
		If cap &amp; TC_EA_DOUBLE Then s :+ "TC_EA_DOUBLE "
		If cap &amp; TC_IA_ABLE Then s :+ "TC_IA_ABLE "
		If cap &amp; TC_UA_ABLE Then s :+ "TC_UA_ABLE "
		If cap &amp; TC_SO_ABLE Then s :+ "TC_SO_ABLE "
		If cap &amp; TC_RA_ABLE Then s :+ "TC_RA_ABLE "
		If cap &amp; TC_VA_ABLE Then s :+ "TC_VA_ABLE "
		If cap &amp; TC_RESERVED Then s :+ "TC_RESERVED "
		If cap &amp; TC_SCROLLBLT Then s :+ "TC_SCROLLBLT "
		If Not s Then Return "NONE"
		Return s
	EndFunction
	
	Function _COLORMGMTCAPS:String( cap:Int)
		Local s:String
		If cap &amp; CM_DEVICE_ICM Then s :+ "CM_DEVICE_ICM "
		If cap &amp; CM_GAMMA_RAMP Then s :+ "CM_GAMMA_RAMP "
		If cap &amp; CM_CMYK_COLOR Then s :+ "CM_CMYK_COLOR "
		If Not s Then Return "NONE"
		Return s
	EndFunction

	Print "~n" + name + ":"
	
	Print "~tDRIVERVERSION = " + GetDeviceCaps( dc, DRIVERVERSION)
	Print "~tTECHNOLOGY = " + _TECHNOLOGY( GetDeviceCaps( dc, TECHNOLOGY))
	Print "~tHORZSIZE = " + GetDeviceCaps( dc, HORZSIZE)
	Print "~tVERTSIZE = " + GetDeviceCaps( dc, VERTSIZE)
	Print "~tHORZRES = " + GetDeviceCaps( dc, HORZRES)
	Print "~tVERTRES = " + GetDeviceCaps( dc, VERTRES)
	Print "~tBITSPIXEL = " + GetDeviceCaps( dc, BITSPIXEL)
	Print "~tPLANES = " + GetDeviceCaps( dc, PLANES)
	Print "~tNUMBRUSHES = " + GetDeviceCaps( dc, NUMBRUSHES)
	Print "~tNUMPENS = " + GetDeviceCaps( dc, NUMPENS)
	Print "~tNUMMARKERS = " + GetDeviceCaps( dc, NUMMARKERS)
	Print "~tNUMFONTS = " + GetDeviceCaps( dc, NUMFONTS)
	Print "~tNUMCOLORS = " + GetDeviceCaps( dc, NUMCOLORS)
	Print "~tPDEVICESIZE = " + GetDeviceCaps( dc, PDEVICESIZE)
	Print "~tCURVECAPS = " + _CURVECAPS( GetDeviceCaps( dc, CURVECAPS))
	Print "~tLINECAPS = " + _LINECAPS( GetDeviceCaps( dc, LINECAPS))
	Print "~tPOLYGONALCAPS = " + _POLYGONALCAPS( GetDeviceCaps( dc, POLYGONALCAPS))
	Print "~tTEXTCAPS = " + _TEXTCAPS( GetDeviceCaps( dc, TEXTCAPS))
	Print "~tCLIPCAPS = " + GetDeviceCaps( dc, CLIPCAPS)
	Print "~tRASTERCAPS = " + _RASTERCAPS( GetDeviceCaps( dc, RASTERCAPS))
	Print "~tASPECTX = " + GetDeviceCaps( dc, ASPECTX)
	Print "~tASPECTY = " + GetDeviceCaps( dc, ASPECTY)
	Print "~tASPECTXY = " + GetDeviceCaps( dc, ASPECTXY)
	Print "~tLOGPIXELSX = " + GetDeviceCaps( dc, LOGPIXELSX)
	Print "~tLOGPIXELSY = " + GetDeviceCaps( dc, LOGPIXELSY)
	Print "~tSIZEPALETTE = " + GetDeviceCaps( dc, SIZEPALETTE)
	Print "~tNUMRESERVED = " + GetDeviceCaps( dc, NUMRESERVED)
	Print "~tCOLORRES = " + GetDeviceCaps( dc, COLORRES)
	Print "~tPHYSICALWIDTH = " + GetDeviceCaps( dc, PHYSICALWIDTH)
	Print "~tPHYSICALHEIGHT = " + GetDeviceCaps( dc, PHYSICALHEIGHT)
	Print "~tPHYSICALOFFSETX = " + GetDeviceCaps( dc, PHYSICALOFFSETX)
	Print "~tPHYSICALOFFSETY = " + GetDeviceCaps( dc, PHYSICALOFFSETY)
	Print "~tSCALINGFACTORX = " + GetDeviceCaps( dc, SCALINGFACTORX)
	Print "~tSCALINGFACTORY = " + GetDeviceCaps( dc, SCALINGFACTORY)
	Print "~tVREFRESH = " + GetDeviceCaps( dc, VREFRESH)
	Print "~tDESKTOPVERTRES = " + GetDeviceCaps( dc, DESKTOPVERTRES)
	Print "~tDESKTOPHORZRES = " + GetDeviceCaps( dc, DESKTOPHORZRES)
	Print "~tBLTALIGNMENT = " + GetDeviceCaps( dc, BLTALIGNMENT)
	Print "~tSHADEBLENDCAPS = " + _SHADERBLENDCAPS( GetDeviceCaps( dc, SHADEBLENDCAPS))
	Print "~tCOLORMGMTCAPS = " + _COLORMGMTCAPS( GetDeviceCaps( dc, COLORMGMTCAPS))
EndFunction



Const D3DRTYPE_FORCE_DWORD:Int = $7FFFFFFF
Const D3DPOOL_FORCE_DWORD:Int = $7FFFFFFF
Const D3DMULTISAMPLE_FORCE_DWORD:Int = $7FFFFFFF

Function PrintSurfaceCaps( name:String, surf:IDirect3DSurface9)
	Function _Type:String( cap:Int)
		Global names:String[] = [ "NONE", "D3DRTYPE_SURFACE", "D3DRTYPE_VOLUME", "D3DRTYPE_TEXTURE", "D3DRTYPE_VOLUMETEXTURE", "D3DRTYPE_CubeTexture", "D3DRTYPE_VERTEXBUFFER", "D3DRTYPE_INDEXBUFFER" ]
		If cap &lt; 0 Or cap &gt;= names.Length Then
			If cap = D3DRTYPE_FORCE_DWORD Then Return "D3DRTYPE_FORCE_DWORD"
			Return "** Unknown ** (" + cap + ")"
		EndIf
		Return names[cap]
	EndFunction
	
	Function _Pool:String( cap:Int)
		Global names:String[] = [ "D3DPOOL_DEFAULT", "D3DPOOL_MANAGED", "D3DPOOL_SYSTEMMEM", "D3DPOOL_SCRATCH" ]
		If cap &lt; 0 Or cap &gt;= names.Length Then
			If cap = D3DPOOL_FORCE_DWORD Then Return "D3DPOOL_FORCE_DWORD"
			Return "** Unknown ** (" + cap + ")"
		EndIf
		Return names[cap]
	EndFunction
	
	Function _MultiSampleType:String( cap:Int)
		If cap = 0 Then Return "D3DMULTISAMPLE_NONE"
		If cap = 1 Then Return "D3DMULTISAMPLE_NONMASKABLE"
		If cap = D3DMULTISAMPLE_FORCE_DWORD Then Return "D3DMULTISAMPLE_FORCE_DWORD"
		If cap &gt;= 2 And cap &lt;= 16 Then Return "D3DMULTISAMPLE_" + cap + "_SAMPLES"
		Return "** unknown ** (" + cap + ")"
	EndFunction
	
	Function _Usage:String( cap:Int)
		Local s:String
		If cap &amp; D3DUSAGE_RENDERTARGET Then s :+ "D3DUSAGE_RENDERTARGET "
		If cap &amp; D3DUSAGE_DEPTHSTENCIL Then s :+ "D3DUSAGE_DEPTHSTENCIL "
		If cap &amp; D3DUSAGE_DYNAMIC Then s :+ "D3DUSAGE_DYNAMIC "
		If cap &amp; D3DUSAGE_AUTOGENMIPMAP Then s :+ "D3DUSAGE_AUTOGENMIPMAP "
		If cap &amp; D3DUSAGE_DMAP Then s :+ "D3DUSAGE_DMAP "
		If cap &amp; D3DUSAGE_QUERY_LEGACYBUMPMAP Then s :+ "D3DUSAGE_QUERY_LEGACYBUMPMAP "
		If cap &amp; D3DUSAGE_QUERY_SRGBREAD Then s :+ "D3DUSAGE_QUERY_SRGBREAD "
		If cap &amp; D3DUSAGE_QUERY_FILTER Then s :+ "D3DUSAGE_QUERY_FILTER "
		If cap &amp; D3DUSAGE_QUERY_SRGBWRITE Then s :+ "D3DUSAGE_QUERY_SRGBWRITE "
		If cap &amp; D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING Then s :+ "D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING "
		If cap &amp; D3DUSAGE_QUERY_VERTEXTEXTURE Then s :+ "D3DUSAGE_QUERY_VERTEXTEXTURE "
		If cap &amp; D3DUSAGE_WRITEONLY Then s :+ "D3DUSAGE_WRITEONLY "
		If cap &amp; D3DUSAGE_SOFTWAREPROCESSING Then s :+ "D3DUSAGE_SOFTWAREPROCESSING "
		If cap &amp; D3DUSAGE_DONOTCLIP Then s :+ "D3DUSAGE_DONOTCLIP "
		If cap &amp; D3DUSAGE_POINTS Then s :+ "D3DUSAGE_POINTS "
		If cap &amp; D3DUSAGE_RTPATCHES Then s :+ "D3DUSAGE_RTPATCHES "
		If cap &amp; D3DUSAGE_NPATCHES Then s :+ "D3DUSAGE_NPATCHES "
		If Not s Then Return "NONE"
		Return s
	EndFunction	
	
	Local desc:D3DSURFACE_DESC = New D3DSURFACE_DESC
	If surf.GetDesc(desc) &lt; 0 Then	Throw "GetDesc() failed"
	
	Print "~n" + name + ":"
	
	Print "~tFormat = " + desc.Format
	Print "~tType = " + _Type(desc.Type_)
	Print "~tUsage = " + desc.Usage
	Print "~tPool = " + _Pool(desc.Pool)
	Print "~tMultiSampleType = " + _MultiSampleType(desc.MultiSampleType)
	Print "~tMultiSampleQuality = " + desc.MultiSampleQuality
	Print "~tWidth = " + desc.Width
	Print "~tHeight = " + desc.Height
EndFunction

</textarea><br><br>EDIT: Heres the numbers i get, Windows 10 64-bit, Skylake 6700K 4Ghz, AMD R390 8GB.<br><pre class=code>
EVENT_GADGETPAINT: time=15  avg=15  count=1499
Flip;Cls: time=7  avg=7  count=1499
UpdateBitmapFromDeviceSurface: time=8  avg=7  count=1499
GetRenderTarget: time=0  avg=0  count=1499
BitBlt: time=6  avg=5  count=1499
LockRect: time=0  avg=0  count=1499
Transform Alpha: time=1  avg=0  count=1499
SetDIBits: time=1  avg=1  count=1499
UpdateLayeredWindow: time=2  avg=1  count=1501
</pre><br>EDIT2: Lowering the timer frequency to 30 should help too btw. Seeing as i get roughly 16ms per frame i can keep it at 60fps. <br><br></td></tr></table><br>
<a name="1334825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dan</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool, thanks grable. <br><br></td></tr></table><br>
<a name="1334830"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Some dedicated debugging there :-)<br><br>Here are the results:<br><pre class=code>
EVENT_GADGETPAINT: time=905  avg=684  count=14
Flip;Cls: time=0  avg=0  count=14
UpdateBitmapFromDeviceSurface: time=905  avg=684  count=14
GetRenderTarget: time=0  avg=0  count=14
BitBlt: time=902  avg=681  count=14
LockRect: time=0  avg=0  count=14
Transform Alpha: time=2  avg=1  count=14
SetDIBits: time=1  avg=1  count=14
UpdateLayeredWindow: time=1  avg=1  count=15
</pre><br><br>Frequency isn't the issue, it almost seems like it's not hardware excelerated.<br><br>-Henri <br><br></td></tr></table><br>
<a name="1334833"></a>

<a name="1334834"></a>

<a name="1334860"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Dan<br>Hope you find a use for it, most of what i see are crap bloatware and mmo launchers using this lol<br><br>Hmmm.. BitBlt is not supposed to be that slow, its one of the fastest blitting functions in windows!<br><br>Thanks for checking it out for me :) <br><br></td></tr></table><br>
<a name="1334835"></a>

<a name="1334836"></a>

<a name="1334837"></a>

<a name="1334838"></a>

<a name="1334839"></a>

<a name="1334849"></a>

<a name="1334859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> . <br><br></td></tr></table><br>
<a name="1334866"></a>

<a name="1334873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> After lots of testing the fix was embarrassingly simple :(<br>It would seem that BitBlt does not have an optimized path involving D3D9 Surfaces on Windows 7.<br><br>The fix was using another primitive, GetRenderTargetData which copies between surfaces instead.<br>This was the same speed on Windows 10, and fast enough on Windows 7 that im using that one instead now.<br><br>All posts updated, im leaving the performance monitored version up if anyone encounters similar trouble in the future (XP maybe? :p)<br><br>This makes me want to see if changing GrabPixmap() is possible as well, since it also uses BitBlt. <br><br></td></tr></table><br>
<a name="1334901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Added OpenGL version to top post, even using glReadPixels is fast enough it seems :) <br><br></td></tr></table><br>
<a name="1334918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nicely catched. I have a feeling that I've heard people say GrapPixmap is slow so maybe you got something there.<br><br>One final thing. Not sure if it's a bug, but the image stops following after you press left mouse button.<br><br>Anyway, cool stuff :-)<br><br>-Henri <br><br></td></tr></table><br>
<a name="1334932"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted February)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> One final thing. Not sure if it's a bug, but the image stops following after you press left mouse button. <br></div>Thats because it loses focus. Since the mouse is not over the window, whatever is behind gets focus instead. So not a bug ;)<br><br><div class="quote"> I have a feeling that I've heard people say GrapPixmap is slow so maybe you got something there <br></div>I looked at GrabPixmap some more. But it cant use GetRenderTargetData, since it requires the surfaces have specific types and only copies the whole surface :/<br>But there are optimization opportunities though, i think it would help to not allocate a new surface and pixmap every time for one.<br><br>Thanks. I have no idea what im gonna use it for, but it is cool :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
