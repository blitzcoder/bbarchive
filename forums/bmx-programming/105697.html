<!DOCTYPE html><html lang="en" ><head ><title >GLSL Shaders in BlitzMAX</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >GLSL Shaders in BlitzMAX</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >GLSL Shaders in BlitzMAX</a><br><br>
<a name="1291623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Been trying to learn shaders and incorporate them into Max2D.  Been learning a lot about them.  Came up with a type to help with them.  The type is <i>far</i> from complete.  I'll add to it as I learn more.<br><br>Shader Type.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type TShader
	Global init:Int = False 'Set to true if glew is initialized
	
	Field ProgramObject:Int 'Store the program object
	Field Name:String 'the name of this shader

	'this function will create the shader.  
	'VertexSource is the GLSL source of the vertex shader
	'PixelSource is the GLSL source of the Pixel (Fragment) Shader
	'Name is the name you wish to give this shader	
	Function Create:TShader(VertexSource:String, PixelSource:String, Name:String = "")
		Local Shader:TShader = New TShader 'Create the shader type
		
		If Name = ""
			Local id:TTypeId = TTypeId.ForObject(Shader)
			Name = id.Name()
		End If
		Shader.Name = Name 'copy the name
		
		If Not init 'Check if glew is initialized
			glewInit
			init = True
		End If
		
		Local VS:Byte Ptr = VertexSource.ToCString() 'CString of Vertex shader source
		Local VL:Int = VertexSource.Length
		Local PS:Byte Ptr = PixelSource.ToCString() 'CString of Pixel Shader Source
		Local PL:Int = PixelSource.Length
		
		Shader.ProgramObject = glCreateProgramObjectARB() 'Create the Shader Program Object
		Local VertexShaderObject:Int = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB) 'Create the Vertex Shader Object
		Local PixelShaderObject:Int = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB) 'Create The Pixel Shader Object
		
		glShaderSourceARB(VertexShaderObject,1,Varptr VS, Varptr VL) 'Upload the Vertex Shader source to the compiler
		MemFree VS 'No longer need the CString, free the memory
		glCompileShaderARB(VertexShaderObject) 'Now compile the source
?debug
		LogInfo(VertexShaderObject,name+": Vertex Shader Log~n-----------------") 'Print out the logs
?

		glShaderSourceARB(PixelShaderObject,1,Varptr PS, Varptr PL) 'Same thing as before, but for the Pixel Shader Source
		MemFree PS
		glCompileShaderARB(PixelShaderObject)
?debug
		LogInfo(PixelShaderObject,name+": Pixel Shader Log~n--------------------")
?
		glAttachObjectARB(Shader.ProgramObject,VertexShaderObject) 'Now we will attach the shaders to the Program Object
		glAttachObjectARB(Shader.ProgramObject,PixelShaderObject)
		glLinkProgramARB(Shader.ProgramObject) 'And link everything together
?debug
		LogInfo(Shader.ProgramObject,name+": Program Object Log~n------------------")
?
		glDeleteObjectARB(VertexShaderObject) 'No longer need these objects
		glDeleteObjectARB(PixelShaderObject)
		Return Shader
	End Function
	
	'This will start the shader program running
	Method Start()
		glUseProgramObjectARB(ProgramObject)
	End Method
	
	'Get the location of a shader uniform type
	Method GetUniform:Int(UniformName:String)
		Local CString:Byte Ptr = UniformName.ToCString()
		Local Uniform:Int = glGetUniformLocationARB(ProgramObject,CString)
		MemFree CString
		Return Uniform
	End Method
	
	'Will set a uniform float to specified value
	Method SetUniform1f(Uniform:Int,Value:Float)
		glUniform1fARB(Uniform,Value)
	End Method
	
	'This will stop all shader programs from running
	Function Stop()
		gluseProgramObjectARB(0)
	End Function

	
?debug
	Function LogInfo(Obj:Int, Tag:String)
		Local InfoLogLength:Int = 0
		Local charsWritten:Int = 0
		Local InfoLog:Byte[]
		Print "~n"+Tag
		glGetObjectParameterivARB(Obj, GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr infologLength);

		If InfoLogLength &gt; 0
			InfoLog = New Byte[InfoLogLength]
			glGetInfoLogARB(obj, InfoLogLength, Varptr charsWritten, InfoLog )
			Print String.FromBytes(InfoLog,charsWritten)
		End If
	End Function
?

End Type



</textarea><br>Demo<br>Circles.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Include "Shader Type.bmx"
' ****************************************************************
'
' Bouncy Bullseye Shader Demo Thingy
'
' ****************************************************************

Local xres:Int = DesktopWidth(), yres:Int = DesktopHeight()
SetGraphicsDriver GLMax2DDriver()

Graphics xres,yres,32; 
HideMouse

' CREATE LINE SHADER
Local LineVertexShaderSource:String = "void main(void) { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex ; gl_TexCoord[0] = gl_MultiTexCoord0 ; }"
Local LinePixelShaderSource:String = ..
"uniform float Timer; void main(void) { vec4 coord = gl_TexCoord[0]  ;                                  ~n" + ..
"float alpha, distance, x, y; x = coord.x - .5; y = coord.y - .5; distance = sqrt(x * x + y * y); if(distance &gt; .5) alpha = 0.0; else alpha = 1.0; " + ..
"float p1 = sin(( Timer + coord.x *360.0 * 4.0)*3.14159/180.0) ; float p2 = sin(( Timer + coord.y *360.0 * 4.0)*3.14159/180.0) ;" + ..
"gl_FragColor = vec4(p1,p2,0.0,alpha) ; }"

Local LineShader:TShader = TShader.Create(LineVertexShaderSource,LinePixelShaderSource)


' CREATE CIRCLE SHADER
Local CircleVertexShaderSource:String = "void main(void) { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex ; gl_TexCoord[0] = gl_MultiTexCoord0 ; }"
Local CirclePixelShaderSource:String = "uniform float Timer; void main(void) { vec4 coord = gl_TexCoord[0]  ;                                  ~n" + ..
"float x = coord.x - .5; float y = coord.y - .5; float d = sqrt(x * x + y * y); " + ..
"float red = sin((d*360.0*2.0+Timer)*3.14159/180.0); float green = sin((d*360.0*3.0+Timer)*3.14159/180.0); float blue = sin((d*360.0*4.0+Timer)*3.14159/180.0);" + ..
"gl_FragColor = vec4(red,green,blue,1.0) ; }"

Local CircleShader:TShader = TShader.Create(CircleVertexShaderSource,CirclePixelShaderSource)

' PROGRAM BEGINS
Const Speed:Int = 4

Local Image:TImage = CreateImage(64,64)
MidHandleImage Image
Local Timer:Float = 0.0
Local x:Int = 0, y:Int = 0, xd:Int = Speed, yd:Int = Speed
Local TimerLocation:String = "Timer"
Local Location:Int

Repeat
	Cls ; 
	CircleShader.Start()
	Location = CircleShader.GetUniform(TimerLocation)
	CircleShader.SetUniform1f(Location,Timer)
	SetRotation Sin(Timer)*120
	TileImage Image,0,0
	SetScale 8,8
	DrawImage image,xres/2,yres/2
	SetScale 1,1
	
	LineShader.Start()
	Location = LineShader.GetUniform(TimerLocation)
	LineShader.SetUniform1f(Location,Timer)
	SetRotation Timer
	DrawImage Image,x,y; 
	SetRotation 0
	TShader.Stop
	Delay 1 ; Flip 1
	
	Timer :+ 4
	If Timer &gt;= 360 Then Timer :- 360
	x :+ xd
	If x &gt; xres-32 Then xd = -Speed
	If x &lt; 32 Then xd = Speed
	y :+ yd
	If y &gt; yres - 32 Then yd = -Speed
	If y &lt; 32 Then yd = Speed
Until KeyHit(KEY_ESCAPE)
End
</textarea><br><br>Usage is simple.  First you must set BM to use OpenGL with<br><b>SetGraphicsDriver GLMax2DDriver()</b><br><br>Then set your graphics mode as usual.<br><b>Graphics Width, Height</b><br><br>Then you need to create your shader with TShader.Create()<br><b>Local Shader:TShader = TShader(VertexShaderSource,PixelShaderSource,Name)</b><br>VertexShaderSource and PixelShaderSource are strings containing the GLSL source of your shaders.  Name is a name you give to this shader for the debug logging.<br><br>Now to use the shader, you just use<br><b>Shader.Start()</b><br><br>To stop shader processing, just use <br><b>TShader.Stop()</b><br><br>If you need to send data to the shader from BMax, use<br><b>Local Location:Int = Shader.GetUniform(UniformName)<br>Shader.SetUniform1f(Location,Value)</b><br><br>UniformName is the name of the variable in the shader.  Currently, I have only implemented sending 1 float value at a time.  Other types will be added over time.<br><br>That's about it.  Look at my demo for an example of how to use the methods. :)<br><br>This post will be updated as I learn more and implement more into the Type. <br><br></td></tr></table><br>
<a name="1291636"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's pretty f-ing awesome, nice work! <br><br></td></tr></table><br>
<a name="1291646"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Getting textures to work.  A fluttering flag example.  Don't forget to copy the "Shader Type.bmx" file to the directory containing this source (or just Copy/Paste the whole thing where Include "Shader Type.bmx" is located).<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Include "Shader Type.bmx"

SetGraphicsDriver GLMax2DDriver()

Global Width:Int = DesktopWidth()
Global Height:Int = DesktopHeight()

Graphics Width,Height,32
HideMouse

Local VertexSource:String = "void main(void) { gl_Position = ftransform() ; gl_TexCoord[0] = gl_MultiTexCoord0 ; }"
Local PixelSource:String = "uniform float Timer; uniform sampler2D tex; void main(void) { vec4 coord = gl_TexCoord[0]; ~n"+ ..
"float space = sin((coord.x+Timer) * 3.14159 * 10.0)*0.01; ~n"+ ..
"coord.y += space; gl_FragColor = texture2D(tex, coord.xy); }"

Local FlagShader:TShader = TShader.Create(VertexSource, PixelSource, "FlagShader")

Local Flag:TImage = CreateImage(256,256)

Cls
SetColor 255,255,255
DrawRect 0,64,256,128
SetColor 255,0,0
DrawRect 120,72,16,112
DrawRect 72,120,112,16
SetColor 255,255,255
GrabImage Flag,0,0

Local Timer:Float = 0.0
FlagShader.Start()
Local TimerUniform:Int = FlagShader.GetUniform("Timer")
While Not KeyHit(KEY_ESCAPE)
	FlagShader.SetUniform1f(TimerUniform,Timer)
	Cls
	DrawImage Flag,10,10
	Flip
	
	Timer :+ .01
	If Timer &gt; 1.0 Then Timer :- 1.0
Wend
</textarea> <br><br></td></tr></table><br>
<a name="1291651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Works well here. I realise it's very early days, but do you think it might be possible to do any of:<br><br>1) Apply shader to TImage or TPixel;<br>2) Apply to backbuffer (or copy of same)?<br>3) Include checks for necessary GL version?<br><br>That'd be my little wishlist anyway! <br><br></td></tr></table><br>
<a name="1291661"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Tried adding Klepto's RendertoTexture routine from here <a href="/codearcs/codearcs.php?code=2222" >OpenGL Render2Texture (FBOs)</a> to apply a shader to an entire rendered scene, but it seems to only render to half the frame.  Any ideas?<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Include "Shader Type.bmx"
Type TImageBuffer
	Field Image:TImage
	Field rb:Int[1]
	Field fb:Int[1]
	Field Imageframe:TGLImageframe
	Field Frame:Int = 0
	Field OrigX:Int
	Field OrigY:Int
	Field OrigW:Int
	Field OrigH:Int

	Function SetBuffer:TImageBuffer(Image:TImage,Frame:Int = 0 )
		Local IB:TImageBuffer = New TImageBuffer
		IB.Image = Image
		IB.Frame = Frame
		IB.GenerateFBO()
		IB.BindBuffer()
		Return IB
	End Function
	
	Function Init(Width:Int,Height:Int,Bit:Int=0,Mode:Int=60)
		SetGraphicsDriver(GLMax2DDriver())
		Graphics Width , Height,bit,Mode
		glewInit()
	End Function
	
	Method GenerateFBO()
		ImageFrame = TGLImageFrame(Image.frame(Frame) )
			
		imageframe.v0 = imageframe.v1
		imageframe.v1 = 0.0
	
		Local W:Int = Image.width
		Local H:Int = Image.Height
		
		AdjustTexSize(W , H) 

		
		glGenFramebuffersEXT(1, fb )
	    glGenRenderbuffersEXT(1 , rb) 
	   
	    glBindTexture(GL_TEXTURE_2D, Imageframe.name);
	    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fb[0]) ; 
	   
	   
	 	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D,  Imageframe.name, 0);
	    glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rb[0]);
	    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, W, H);
	    glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT , GL_DEPTH_ATTACHMENT_EXT , GL_RENDERBUFFER_EXT , rb[0])
	   
	    Local status:Int =  glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT)
	   
	    Select status
	       Case GL_FRAMEBUFFER_COMPLETE_EXT 
	          Print "all right" + " : " + Status
	       Case GL_FRAMEBUFFER_UNSUPPORTED_EXT
	          Print "choose different formats"
	       Default
	          End 
	    EndSelect 
   
	End Method
	
	Method BindBuffer()
		GetViewport(OrigX,OrigY,OrigW,OrigH)
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , fb[0])
		glMatrixMode GL_PROJECTION
		glLoadIdentity
		glOrtho 0,Image.Width,Image.Width,0,-1,1
		glMatrixMode GL_MODELVIEW 
		glViewport(0 , 0 , Image.Width , Image.Height)
		glScissor 0,0, Image.Width , Image.Height
	End Method
	
	Method UnBindBuffer()
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT , 0)
		glMatrixMode GL_PROJECTION
		glLoadIdentity
		glOrtho 0,OrigW ,Origh,0,-1,1
		glMatrixMode GL_MODELVIEW 
		glViewport(0 , 0 , OrigW, OrigH)
		glScissor 0,0, OrigW ,OrigH
	End Method
	
	Method Cls(r#=0.0,g#=0.0,b#=0.0,a#=1.0)
		glClearColor r,g,b,a
		glClear GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT
	End Method
	
	Method BufferWidth:Int()
		Return Image.Width
	End Method
	
	Method BufferHeight:Int()
		Return Image.Height
	End Method

End Type


Function AdjustTexSize( width:Int Var,height:Int Var )
	'calc texture size
	width=Pow2Size( width )
	height=Pow2Size( height )
	Repeat
		Local t:Int
		glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
		glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
		If t Return
		If width=1 And height=1 RuntimeError "Unable to calculate tex size"
		If width&gt;1 width:/2
		If height&gt;1 height:/2
	Forever
End Function

Function Pow2Size:Int( n:Int )
	Local t:Int=1
	While t&lt;n
		t:*2
	Wend
	Return t
End Function


Local Width:Int = DesktopWidth(), Height:Int = DesktopHeight()
TImageBuffer.Init(Width,Height,32)
Local image:TImage = CreateImage(Width,Height)

Local IB:TImagebuffer = TIMageBuffer.Setbuffer(image)

Local VertexSource:String = "void main(void) { gl_Position = ftransform() ; gl_TexCoord[0] = gl_MultiTexCoord0 ; }"
Local PixelSource:String = "uniform float Timer; uniform sampler2D tex; void main(void) { vec4 coord = gl_TexCoord[0]; ~n"+ ..
"float space = sin((coord.x+Timer) * 3.14159 * 10.0)*0.01; ~n"+ ..
"coord.y += space; gl_FragColor = texture2D(tex, coord.xy); }"

Local SineScreenShader:TShader = TShader.Create(VertexSource,PixelSource,"SineScreenShader")

Type TCircle 
	Field x:Float, y:Float, diam:Float, red:Int, green:Int, blue:Int, xd:Int, yd:Int
End Type
Local List:TList = CreateList()

For Local i:Int = 1 To 50
	Local Circle:TCircle = New TCircle
	Circle.diam = Rnd(20,100)
	Circle.x = Rnd(0,Width-Circle.diam)
	Circle.y = Rnd(0,Height - Circle.diam)
	Circle.red = Rand(20,255)
	Circle.green = Rand(20,255)
	Circle.blue = Rand(20,255)
	Local d:Int = Rand(0,1)
	If d
		Circle.xd = 4
	Else
		Circle.xd = -4
	End If
	d = Rand(0,1)
	If d
		Circle.yd = 4
	Else
		Circle.yd = -4
	End If
	List.AddLast(Circle)
Next

Local Time:Float = 0.0
While Not KeyHit(KEY_ESCAPE) And Not AppTerminate()
	IB.BindBuffer()
	IB.Cls()
	For Local Circle:TCircle = EachIn List
		SetColor Circle.Red, Circle.Green, Circle.Blue
		DrawOval Circle.x, Circle.y, Circle.diam, Circle.diam
		Circle.x :+ Circle.xd
		If Circle.x &gt; Width - Circle.diam Then Circle.xd = -4
		If Circle.x &lt; 0 Then Circle.xd = 4
		Circle.y :+ Circle.yd
		If Circle.y &gt; Height - Circle.diam Then Circle.yd = -4
		If Circle.y &lt; 0 Then Circle.yd = 4
	Next
	SetColor 255,255,255
	IB.UnbindBuffer()
	SetViewport 0,0,Width,Height
	SineScreenShader.Start()
	Local Uniform:Int = SineScreenShader.GetUniform("Timer")
	SineScreenShader.SetUniform1f(Uniform,Time)
	DrawImage Image,0,0
	TShader.Stop()
	Flip
	Time :+ .01
	If Time &gt; 1.0 Then Time :- 1.0
Wend
</textarea> <br><br></td></tr></table><br>
<a name="1291662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, if I change line 71 from<br>		glOrtho 0,Image.Width,Image.Width,0,-1,1<br>to<br>		glOrtho 0,Image.Width,Image.Height,0,-1,1<br><br>then it renders as expected.  A bug in the Render2Texture routine? <br><br></td></tr></table><br>
<a name="1291664"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, also had to add the glScalef(1,-1,1) and the glScalfef(1,1,1) in the BindBuffer and UnbindBuffer methods respectively to avoid flipping the texture as per reply in the line above. <br><br></td></tr></table><br>
<a name="1291705"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Endive</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is just wonderful. <br><br></td></tr></table><br>
<a name="1291709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @bug<br>Yes this is a bug in the routine, I had added the fix to the r2t-examples I gave to dw' in one of his threads (including a bit more "oop" for the types).<br><br>I think at least the glscalef-thing was appended to the codearchive-entry of klepto2.<br><br><br>Hope you enjoy the tinker time.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1291712"></a>

<a name="1291713"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice screensaver kinda thing :)<br>Decided to C&amp;P the TShader type into the source, that way if I change the Type in post #1, I won't risk making all these samples unrunnable.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">'*******************************************************
'
' Nice Screensaver Kinda Thing
'    by TomToad
'
'*****************************************************
SuperStrict
Type TShader
	Global init:Int = False 'Set to true if glew is initialized
	
	Field ProgramObject:Int 'Store the program object
	Field Name:String 'the name of this shader

	'this function will create the shader.  
	'VertexSource is the GLSL source of the vertex shader
	'PixelSource is the GLSL source of the Pixel (Fragment) Shader
	'Name is the name you wish to give this shader	
	Function Create:TShader(VertexSource:String, PixelSource:String, Name:String = "")
		Local Shader:TShader = New TShader 'Create the shader type
		
		If Name = ""
			Local id:TTypeId = TTypeId.ForObject(Shader)
			Name = id.Name()
		End If
		Shader.Name = Name 'copy the name
		
		If Not init 'Check if glew is initialized
			glewInit
			init = True
		End If
		
		Local VS:Byte Ptr = VertexSource.ToCString() 'CString of Vertex shader source
		Local VL:Int = VertexSource.Length
		Local PS:Byte Ptr = PixelSource.ToCString() 'CString of Pixel Shader Source
		Local PL:Int = PixelSource.Length
		
		Shader.ProgramObject = glCreateProgramObjectARB() 'Create the Shader Program Object
		Local VertexShaderObject:Int = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB) 'Create the Vertex Shader Object
		Local PixelShaderObject:Int = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB) 'Create The Pixel Shader Object
		
		glShaderSourceARB(VertexShaderObject,1,Varptr VS, Varptr VL) 'Upload the Vertex Shader source to the compiler
		MemFree VS 'No longer need the CString, free the memory
		glCompileShaderARB(VertexShaderObject) 'Now compile the source
?debug
		LogInfo(VertexShaderObject,name+": Vertex Shader Log~n-----------------") 'Print out the logs
?

		glShaderSourceARB(PixelShaderObject,1,Varptr PS, Varptr PL) 'Same thing as before, but for the Pixel Shader Source
		MemFree PS
		glCompileShaderARB(PixelShaderObject)
?debug
		LogInfo(PixelShaderObject,name+": Pixel Shader Log~n--------------------")
?
		glAttachObjectARB(Shader.ProgramObject,VertexShaderObject) 'Now we will attach the shaders to the Program Object
		glAttachObjectARB(Shader.ProgramObject,PixelShaderObject)
		glLinkProgramARB(Shader.ProgramObject) 'And link everything together
?debug
		LogInfo(Shader.ProgramObject,name+": Program Object Log~n------------------")
?
		glDeleteObjectARB(VertexShaderObject) 'No longer need these objects
		glDeleteObjectARB(PixelShaderObject)
		Return Shader
	End Function
	
	'This will start the shader program running
	Method Start()
		glUseProgramObjectARB(ProgramObject)
	End Method
	
	'Get the location of a shader uniform type
	Method GetUniform:Int(UniformName:String)
		Local CString:Byte Ptr = UniformName.ToCString()
		Local Uniform:Int = glGetUniformLocationARB(ProgramObject,CString)
		MemFree CString
		Return Uniform
	End Method
	
	'Will set a uniform float to specified value
	Method SetUniform1f(Uniform:Int,Value:Float)
		glUniform1fARB(Uniform,Value)
	End Method
	
	'This will stop all shader programs from running
	Function Stop()
		gluseProgramObjectARB(0)
	End Function

	
?debug
	Function LogInfo(Obj:Int, Tag:String)
		Local InfoLogLength:Int = 0
		Local charsWritten:Int = 0
		Local InfoLog:Byte[]
		Print "~n"+Tag
		glGetObjectParameterivARB(Obj, GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr infologLength);

		If InfoLogLength &gt; 0
			InfoLog = New Byte[InfoLogLength]
			glGetInfoLogARB(obj, InfoLogLength, Varptr charsWritten, InfoLog )
			Print String.FromBytes(InfoLog,charsWritten)
		End If
	End Function
?

End Type



Local Width:Int = DesktopWidth(), Height:Int = DesktopHeight()
SetGraphicsDriver GLMax2DDriver()
Graphics Width,Height,32
HideMouse()

Local VertexSource:String = "void main(void) { gl_Position = ftransform() ; gl_TexCoord[0] = gl_MultiTexCoord0 ; }"
Local PixelSource:String = "uniform float Timer; uniform sampler2D tex; void main(void) { vec4 coord = gl_TexCoord[0]; ~n"+ ..
"float spacex = sin((coord.x+Timer) * 3.14159 * 20.0)*0.05; ~n"+ ..
"float spacey = sin((coord.y+Timer) * 3.14159 * 20.0)*0.05; ~n"+ ..
"coord.x += spacex; coord.y += spacey; ~n"+ ..
"gl_FragColor = texture2D(tex, coord.xy); }"

Local SineScreenShader:TShader = TShader.Create(VertexSource,PixelSource,"SineScreenShader")

Local Picture:TImage = CreateImage(512,512)
Cls
For Local y:Int = 0 To 511 Step 64
	For Local x:Int = 0 To 511 Step 64
		SetColor Rand(128,255),Rand(128,255),Rand(128,255)
		DrawOval x,y,64,64
		SetColor 0,0,0
		DrawOval x+8,y+8,48,48
	Next
Next
GrabImage Picture,0,0
SetColor 255,255,255
	SineScreenShader.Start()
	Local Uniform:Int = SineScreenShader.GetUniform("Timer")

Local scalex:Float = Float(Width)/512.0
Local Scaley:Float = Float(Height)/512.0
Local Time:Float = 0.0
SetScale scalex,scaley
While Not KeyHit(KEY_ESCAPE) And Not AppTerminate()
	Cls
	SineScreenShader.SetUniform1f(Uniform,Time)
	DrawImage Picture,0,0
	Flip
	Time :+ .001
	If Time &gt; 1.0 Then Time :- 1.0
Wend
</textarea> <br><br></td></tr></table><br>
<a name="1291714"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great swimmers, TomToad ! This VertexSource and PixelSource is very new to me though.<br><br>I'm still waiting for full-screen random pixels with this new GL stuff. I might be able to understand it. <br><br></td></tr></table><br>
<a name="1291733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> full-screen random pixels<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Type TShader
	Global init:Int = False 'Set to true if glew is initialized
	
	Field ProgramObject:Int 'Store the program object
	Field Name:String 'the name of this shader

	'this function will create the shader.  
	'VertexSource is the GLSL source of the vertex shader
	'PixelSource is the GLSL source of the Pixel (Fragment) Shader
	'Name is the name you wish to give this shader	
	Function Create:TShader(VertexSource:String, PixelSource:String, Name:String = "")
		Local Shader:TShader = New TShader 'Create the shader type
		
		If Name = ""
			Local id:TTypeId = TTypeId.ForObject(Shader)
			Name = id.Name()
		End If
		Shader.Name = Name 'copy the name
		
		If Not init 'Check if glew is initialized
			glewInit
			init = True
		End If
		
		Local VS:Byte Ptr = VertexSource.ToCString() 'CString of Vertex shader source
		Local VL:Int = VertexSource.Length
		Local PS:Byte Ptr = PixelSource.ToCString() 'CString of Pixel Shader Source
		Local PL:Int = PixelSource.Length
		
		Shader.ProgramObject = glCreateProgramObjectARB() 'Create the Shader Program Object
		Local VertexShaderObject:Int = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB) 'Create the Vertex Shader Object
		Local PixelShaderObject:Int = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB) 'Create The Pixel Shader Object
		
		glShaderSourceARB(VertexShaderObject,1,Varptr VS, Varptr VL) 'Upload the Vertex Shader source to the compiler
		MemFree VS 'No longer need the CString, free the memory
		glCompileShaderARB(VertexShaderObject) 'Now compile the source
?debug
		LogInfo(VertexShaderObject,name+": Vertex Shader Log~n-----------------") 'Print out the logs
?

		glShaderSourceARB(PixelShaderObject,1,Varptr PS, Varptr PL) 'Same thing as before, but for the Pixel Shader Source
		MemFree PS
		glCompileShaderARB(PixelShaderObject)
?debug
		LogInfo(PixelShaderObject,name+": Pixel Shader Log~n--------------------")
?
		glAttachObjectARB(Shader.ProgramObject,VertexShaderObject) 'Now we will attach the shaders to the Program Object
		glAttachObjectARB(Shader.ProgramObject,PixelShaderObject)
		glLinkProgramARB(Shader.ProgramObject) 'And link everything together
?debug
		LogInfo(Shader.ProgramObject,name+": Program Object Log~n------------------")
?
		glDeleteObjectARB(VertexShaderObject) 'No longer need these objects
		glDeleteObjectARB(PixelShaderObject)
		Return Shader
	End Function
	
	'This will start the shader program running
	Method Start()
		glUseProgramObjectARB(ProgramObject)
	End Method
	
	'Get the location of a shader uniform type
	Method GetUniform:Int(UniformName:String)
		Local CString:Byte Ptr = UniformName.ToCString()
		Local Uniform:Int = glGetUniformLocationARB(ProgramObject,CString)
		MemFree CString
		Return Uniform
	End Method
	
	'Will set a uniform float to specified value
	Method SetUniform1f(Uniform:Int,Value:Float)
		glUniform1fARB(Uniform,Value)
	End Method
	
	'This will stop all shader programs from running
	Function Stop()
		gluseProgramObjectARB(0)
	End Function

	
?debug
	Function LogInfo(Obj:Int, Tag:String)
		Local InfoLogLength:Int = 0
		Local charsWritten:Int = 0
		Local InfoLog:Byte[]
		Print "~n"+Tag
		glGetObjectParameterivARB(Obj, GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr infologLength);

		If InfoLogLength &gt; 0
			InfoLog = New Byte[InfoLogLength]
			glGetInfoLogARB(obj, InfoLogLength, Varptr charsWritten, InfoLog )
			Print String.FromBytes(InfoLog,charsWritten)
		End If
	End Function
?

End Type


SetGraphicsDriver GLMax2DDriver()
Local Width:Int = DesktopWidth(), Height:Int = DesktopHeight()

Graphics Width,Height,32
HideMouse

Local VertexSource:String = "void main(void) { gl_Position = ftransform() ; gl_TexCoord[0] = gl_MultiTexCoord0 ; }"
Local PixelSource:String = ..
"uniform float seed;~n" + ..
"float rand(vec2 co){~n" + ..
"	co.x += seed;~n" + ..
"  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);~n" + ..
"}~n" + ..
"~n" + ..
"void main(void) {~n" + ..
"	vec4 coord = gl_TexCoord[0];~n" + ..
"	gl_FragColor = vec4(rand(coord.xy),rand(coord.xy),rand(coord.xy),1.0);~n" + ..
"	~n" + ..
"}~n"

Local Image:TImage = CreateImage(1,1)
Local Shader:TShader = TShader.Create(VertexSource,PixelSource,"NoiseShader")

Shader.Start()
Local Random:Float = Rnd(0,1)
Local Uniform:Int = Shader.GetUniform("seed")
SetScale Width,Height
While Not KeyHit(KEY_ESCAPE) And Not AppTerminate()
	Shader.SetUniform1f(Uniform,Random)
	DrawImage Image,0,0
	Flip
	Random = Rnd(0,1)
Wend	
</textarea> <br><br></td></tr></table><br>
<a name="1291757"></a>

<a name="1291758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, thank you ! Can you make them colored please ? R G B (0-255). Do that and I'll get my magnifying glass out and try to see what's going on there.<br><br>Oh, and before you get too busy, is this the fastest way to stuff colored pixels on the screen ? (Benchmarks ?) <br><br></td></tr></table><br>
<a name="1291962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pingus</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome stuff there. Is it doable in Dx ? <br><br></td></tr></table><br>
<a name="1292003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Okay, thank you ! Can you make them colored please ? R G B (0-255). Do that and I'll get my magnifying glass out and try to see what's going on there. <br></div><br>Yeah, a little bug in my program.  GLSL doesn't allow for a static type.  Globals are reinitialized every frame.  So a proper Rnd() function cannot be created on GLSL.  I did find one online, but you must provide the seed for every call.  I just use the x,y coordinates added to a randomly generated float passed on the CPU side.  That is the reason for the Random = Rnd(0,1) in the above code.<br><br>The bug comes in to the fact that I pass the exact same seed for red, green, blue components creating various shades of grey.  If you replace<br><b>"	gl_FragColor = vec4(rand(coord.xy),rand(coord.xy),rand(coord.xy),1.0);~n" + ..<br></b><br>with<br><b>"	gl_FragColor = vec4(rand(coord.xy),rand(coord.xy+.01),rand(coord.xy+.02),1.0);~n" + ..</b><br>Then you will get a nice random color screen.<br><br><br><div class="quote"> Oh, and before you get too busy, is this the fastest way to stuff colored pixels on the screen ? (Benchmarks ?) <br></div> <br>Yes and No.  As shown in many examples here, and examples in your Lights Fantastic thread, Doing per pixel calculations and pushing them to the screen can be quite fast.  Unfortunately, there is no way to store a pixel table in the shader so pixels can be manipulated on CPU side.  You could use a texture for a table, but as a texture is already a type of table anyway, updating them would be no faster than other, non shader versions.  Problably some render2Texture code would be your best bet.<br><br>I did have an idea to just push a pixel queue (an array full of pixel data) to the shader, so if you are manipulating only a few pixels, there would be no need to push the entire texture across the graphics bus.  It theoretically should be at least 2X faster even when changing all pixels in a texture as the transfer would be only one way.  Unfortunately, GLSL 1,2 has no way of rendering to the texture directly that I can find.  Maybe a higher version of GLSL will allow it, still reading and learning. <br><br></td></tr></table><br>
<a name="1292135"></a>

<a name="1292136"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> The more I am hearing about pushing pixels in a queue, Tom, it sounds very familiar to getting HAM graphics on the Commodore Amiga.<br><br><a href="https://en.wikipedia.org/wiki/Hold-And-Modify" target="_blank">https://en.wikipedia.org/wiki/Hold-And-Modify</a><br><br>Gosh I hope it doesn't get this complex ! :/ <br><br></td></tr></table><br>
<a name="1292205"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ultimately with pushing pixels they have to cross the cpu gpu barrier somewhere....unless you do all or most processing on the gpu itself with minimal instructions sent across. <br><br></td></tr></table><br>
<a name="1292227"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pete Rigz</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is really interesting, I've often wanted to dive into shaders, what are your reading/learning sources? <br><br></td></tr></table><br>
<a name="1292244"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> [quoteThis is really interesting, I've often wanted to dive into shaders, what are your reading/learning sources? <br>[/quote]<br><a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/" target="_blank">http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/</a><br><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/" target="_blank">http://nehe.gamedev.net/article/glsl_an_introduction/25007/</a><br><br>And a bit of googling. <br><br></td></tr></table><br>
<a name="1292552"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now messing with the vertex shaders.  Made a nice sine scroller.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Type TShader
	Global init:Int = False 'Set to true if glew is initialized
	
	Field ProgramObject:Int 'Store the program object
	Field Name:String 'the name of this shader

	'this function will create the shader.  
	'VertexSource is the GLSL source of the vertex shader
	'PixelSource is the GLSL source of the Pixel (Fragment) Shader
	'Name is the name you wish to give this shader	
	Function Create:TShader(VertexSource:String, PixelSource:String, Name:String = "")
		Local Shader:TShader = New TShader 'Create the shader type
		
		If Name = ""
			Local id:TTypeId = TTypeId.ForObject(Shader)
			Name = id.Name()
		End If
		Shader.Name = Name 'copy the name
		
		If Not init 'Check if glew is initialized
			glewInit
			init = True
		End If
		
		Local VS:Byte Ptr = VertexSource.ToCString() 'CString of Vertex shader source
		Local VL:Int = VertexSource.Length
		Local PS:Byte Ptr = PixelSource.ToCString() 'CString of Pixel Shader Source
		Local PL:Int = PixelSource.Length
		
		Shader.ProgramObject = glCreateProgramObjectARB() 'Create the Shader Program Object
		Local VertexShaderObject:Int = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB) 'Create the Vertex Shader Object
		Local PixelShaderObject:Int = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB) 'Create The Pixel Shader Object
		
		glShaderSourceARB(VertexShaderObject,1,Varptr VS, Varptr VL) 'Upload the Vertex Shader source to the compiler
		MemFree VS 'No longer need the CString, free the memory
		glCompileShaderARB(VertexShaderObject) 'Now compile the source
?debug
		LogInfo(VertexShaderObject,name+": Vertex Shader Log~n-----------------") 'Print out the logs
?

		glShaderSourceARB(PixelShaderObject,1,Varptr PS, Varptr PL) 'Same thing as before, but for the Pixel Shader Source
		MemFree PS
		glCompileShaderARB(PixelShaderObject)
?debug
		LogInfo(PixelShaderObject,name+": Pixel Shader Log~n--------------------")
?
		glAttachObjectARB(Shader.ProgramObject,VertexShaderObject) 'Now we will attach the shaders to the Program Object
		glAttachObjectARB(Shader.ProgramObject,PixelShaderObject)
		glLinkProgramARB(Shader.ProgramObject) 'And link everything together
?debug
		LogInfo(Shader.ProgramObject,name+": Program Object Log~n------------------")
?
		glDeleteObjectARB(VertexShaderObject) 'No longer need these objects
		glDeleteObjectARB(PixelShaderObject)
		Return Shader
	End Function
	
	'This will start the shader program running
	Method Start()
		glUseProgramObjectARB(ProgramObject)
	End Method
	
	'Get the location of a shader uniform type
	Method GetUniform:Int(UniformName:String)
		Local CString:Byte Ptr = UniformName.ToCString()
		Local Uniform:Int = glGetUniformLocationARB(ProgramObject,CString)
		MemFree CString
		Return Uniform
	End Method
	
	'Will set a uniform float to specified value
	Method SetUniform1f(Uniform:Int,Value:Float)
		glUniform1fARB(Uniform,Value)
	End Method
	
	'This will stop all shader programs from running
	Function Stop()
		gluseProgramObjectARB(0)
	End Function

	
?debug
	Function LogInfo(Obj:Int, Tag:String)
		Local InfoLogLength:Int = 0
		Local charsWritten:Int = 0
		Local InfoLog:Byte[]
		Print "~n"+Tag
		glGetObjectParameterivARB(Obj, GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr infologLength);

		If InfoLogLength &gt; 0
			InfoLog = New Byte[InfoLogLength]
			glGetInfoLogARB(obj, InfoLogLength, Varptr charsWritten, InfoLog )
			Print String.FromBytes(InfoLog,charsWritten)
		End If
	End Function
?

End Type



Local VertexShader:String = "void main (void) {~n" + ..
"	vec4 VPosition = gl_Vertex;~n" + ..
"	VPosition.y += sin(VPosition.x*0.02)*50.0;~n" + ..
"	gl_Position = gl_ModelViewProjectionMatrix * VPosition;~n" + ..
"	gl_TexCoord[0] = gl_MultiTexCoord0 ;~n" + ..
"}~n"
Local FragShader:String = "uniform sampler2D tex;~n" + ..
"void main (void) {~n" + ..
"   vec4 color = texture2D(tex,gl_TexCoord[0].xy);" + ..
"	color.r = sin(gl_TexCoord[0].y*5.0*3.14159)*0.5+0.5;" + ..
"	gl_FragColor = color.rrba;" + ..
"}~n"

SetGraphicsDriver GLMax2DDriver()
Graphics 800,600
Local Shader:TShader = TShader.Create(VertexShader,FragShader,"Vertex Stuff")
Shader.Start()
Local x:Int = 800
SetScale 3,3
While Not KeyHit(KEY_ESCAPE) And Not AppTerminate()
	Cls
	DrawText "Hello World!  Have a bright day!",X,200
	Flip
	x = x - 2
	If x &lt; -800 Then End
Wend</textarea> <br><br></td></tr></table><br>
<a name="1292558"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Trying out your code. ?? HOW are you doing this,Tom ? I see DrawText() and no other code in the main.<br><br>All I can figure is you somehow managed to reposition all the pixels on the screen to a wave pattern so anything that is plotted will be skewed from its original, meaning of course no straight lines via drawline().<br><br>Oddly enough trying to add any graphics around the DrawText() does not appear. Lines, rectangle, or ovals.<br><br>Tricky stuff. I remember in S2 I had an icon a picture of a fish and when you used it in your command set, the screen and sprites would become all wavy like that like you were underwater. :) <br><br></td></tr></table><br>
<a name="1292563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> In the Nice Screensaver Kinda Thing above, go to lines 116 and 117 and change the *20.0 in both strings to *2.0.  Go to line 147 and change the Time :+ .001 to Time :+ .01.<br><br>Now you have a wavy underwater thing. :)<br><br>Reason why you don't see anything in the main program is because the code to modify the text is actually being run on the graphics card itself. When a shader is created, you effectively bypass the rendering pipeline.  This gives you opportunity to modify the vertices and pixels before they actually reach the screen.<br><br>for the wavy text, the shader is moving the corners of each letter up and down on the y axis depending on its position on the x axis.  The blue and white stripes are created by modifying the pixels based on its y position on the letter.<br><br>Reason why circles and lines are not showing up is because the shaders operate on 3D objects.  Since TImages are simply 3D rectangles that are always facing the camera to appear 2D, shaders will work on them.  Circles and lines are 2D constructs which shaders don't support (at least I have found none in the research I have done so far).  In order to draw the 2D primitives, you must disable the running shaders to allow the normal pipeline to render them.  A few small modifications to the main function will do.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Type TShader
	Global init:Int = False 'Set to true if glew is initialized
	
	Field ProgramObject:Int 'Store the program object
	Field Name:String 'the name of this shader

	'this function will create the shader.  
	'VertexSource is the GLSL source of the vertex shader
	'PixelSource is the GLSL source of the Pixel (Fragment) Shader
	'Name is the name you wish to give this shader	
	Function Create:TShader(VertexSource:String, PixelSource:String, Name:String = "")
		Local Shader:TShader = New TShader 'Create the shader type
		
		If Name = ""
			Local id:TTypeId = TTypeId.ForObject(Shader)
			Name = id.Name()
		End If
		Shader.Name = Name 'copy the name
		
		If Not init 'Check if glew is initialized
			glewInit
			init = True
		End If
		
		Local VS:Byte Ptr = VertexSource.ToCString() 'CString of Vertex shader source
		Local VL:Int = VertexSource.Length
		Local PS:Byte Ptr = PixelSource.ToCString() 'CString of Pixel Shader Source
		Local PL:Int = PixelSource.Length
		
		Shader.ProgramObject = glCreateProgramObjectARB() 'Create the Shader Program Object
		Local VertexShaderObject:Int = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB) 'Create the Vertex Shader Object
		Local PixelShaderObject:Int = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB) 'Create The Pixel Shader Object
		
		glShaderSourceARB(VertexShaderObject,1,Varptr VS, Varptr VL) 'Upload the Vertex Shader source to the compiler
		MemFree VS 'No longer need the CString, free the memory
		glCompileShaderARB(VertexShaderObject) 'Now compile the source
?debug
		LogInfo(VertexShaderObject,name+": Vertex Shader Log~n-----------------") 'Print out the logs
?

		glShaderSourceARB(PixelShaderObject,1,Varptr PS, Varptr PL) 'Same thing as before, but for the Pixel Shader Source
		MemFree PS
		glCompileShaderARB(PixelShaderObject)
?debug
		LogInfo(PixelShaderObject,name+": Pixel Shader Log~n--------------------")
?
		glAttachObjectARB(Shader.ProgramObject,VertexShaderObject) 'Now we will attach the shaders to the Program Object
		glAttachObjectARB(Shader.ProgramObject,PixelShaderObject)
		glLinkProgramARB(Shader.ProgramObject) 'And link everything together
?debug
		LogInfo(Shader.ProgramObject,name+": Program Object Log~n------------------")
?
		glDeleteObjectARB(VertexShaderObject) 'No longer need these objects
		glDeleteObjectARB(PixelShaderObject)
		Return Shader
	End Function
	
	'This will start the shader program running
	Method Start()
		glUseProgramObjectARB(ProgramObject)
	End Method
	
	'Get the location of a shader uniform type
	Method GetUniform:Int(UniformName:String)
		Local CString:Byte Ptr = UniformName.ToCString()
		Local Uniform:Int = glGetUniformLocationARB(ProgramObject,CString)
		MemFree CString
		Return Uniform
	End Method
	
	'Will set a uniform float to specified value
	Method SetUniform1f(Uniform:Int,Value:Float)
		glUniform1fARB(Uniform,Value)
	End Method
	
	'This will stop all shader programs from running
	Function Stop()
		gluseProgramObjectARB(0)
	End Function

	
?debug
	Function LogInfo(Obj:Int, Tag:String)
		Local InfoLogLength:Int = 0
		Local charsWritten:Int = 0
		Local InfoLog:Byte[]
		Print "~n"+Tag
		glGetObjectParameterivARB(Obj, GL_OBJECT_INFO_LOG_LENGTH_ARB, Varptr infologLength);

		If InfoLogLength &gt; 0
			InfoLog = New Byte[InfoLogLength]
			glGetInfoLogARB(obj, InfoLogLength, Varptr charsWritten, InfoLog )
			Print String.FromBytes(InfoLog,charsWritten)
		End If
	End Function
?

End Type



Local VertexShader:String = "void main (void) {~n" + ..
"	vec4 VPosition = gl_Vertex;~n" + ..
"	VPosition.y += sin(VPosition.x*0.02)*50.0;~n" + ..
"	gl_Position = gl_ModelViewProjectionMatrix * VPosition;~n" + ..
"	gl_TexCoord[0] = gl_MultiTexCoord0 ;~n" + ..
"}~n"
Local FragShader:String = "uniform sampler2D tex;~n" + ..
"void main (void) {~n" + ..
"   vec4 color = texture2D(tex,gl_TexCoord[0].xy);" + ..
"	color.r = sin(gl_TexCoord[0].y*5.0*3.14159)*0.5+0.5;" + ..
"	gl_FragColor = color.rrba;" + ..
"}~n"

SetGraphicsDriver GLMax2DDriver()
Graphics 800,600
Local Shader:TShader = TShader.Create(VertexShader,FragShader,"Vertex Stuff")
Local x:Int = 800
While Not KeyHit(KEY_ESCAPE) And Not AppTerminate()
	Cls
	'Stuff not affected by the shader
	SetColor 255,0,0
	DrawOval 50,50,200,200
	SetColor 0,255,0
	DrawOval 250,50,200,200
	SetColor 255,255,255
	DrawLine 5,5,795,5
	DrawLine 5,5,5,595
	DrawLine 795,5,795,595
	DrawLine 5,595,795,595
	Shader.Start() 'Enable shader processing
	SetScale 3,3
	DrawText "Hello World!  Have a bright day!",X,200
	SetScale 1,1
	Shader.Stop() 'Stop shader processing
	SetColor 0,0,255 'some more non shader rendering
	DrawOval 450,50,200,200
	Flip
	x = x - 2
	If x &lt; -800 Then End
Wend</textarea> <br><br></td></tr></table><br>
<a name="1292567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well now that you are mentioned it, Tom. Is there a simple way to take a TIMAGE or PIXMAP and display it as a parallelogram.<br><br>Where it appears something like this:<br><br><a href="https://vt-s3-files.s3.amazonaws.com/uploads/problem_question_image/image/2353/Q_12_2.png" target="_blank"><b>[IMAGE]</b></a><br><br>And would appear as if it were 3-dimensionally tilted away from the camera ? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
