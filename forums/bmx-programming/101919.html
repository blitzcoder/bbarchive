<!DOCTYPE html><html lang="en" ><head ><title >Multiple clients on the same IP?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Multiple clients on the same IP?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Multiple clients on the same IP?</a><br><br>
<a name="1213422"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Richard Betson</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I am using Bnetex for my networking library and I am wondering how I can have several clients work over the same IP address. I was thinking that I could send packets from the server with a client ID and a client with that ID would accept the incoming packet but I am not sure this will work. Is this a viable way to support multiple client on the same IP address? Is there a better way?<br><br>Thanks,<br>- Rich - <br><br></td></tr></table><br>
<a name="1213427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe accept packets on different IP ports? <br><br></td></tr></table><br>
<a name="1213428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, I also think you'd need multiple ports for this. <br><br></td></tr></table><br>
<a name="1213437"></a>

<a name="1213438"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Richard Betson</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>OK.. I guess that will work and is easier to address code wise for me. I'll have to look at the cost of doing this resource wise on BnetEX but it is possible to listen on a range of ports. It just might be a little costly CPU resource wise on the server.<br><br>Thanks for the help.<br>- Rich - <br><br></td></tr></table><br>
<a name="1213439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> As far as I am aware, your server will listen on a given port, say 25000.<br>Along comes client1, and attempts a connection to the server on port 25000. Server responds and the two agree on a free port number over which they can communicate (well, the server says, "let's move our communication to port 18559")<br>Another client attempts to connect on port 25000. Server responds again, and assigns port 21558 for that connection...<br><br>... and so on.<br><br>This is certainly what goes on in my day job - on big servers with 1000's of simultaneous client connections.<br>I assume it works the same way in a game? <br><br></td></tr></table><br>
<a name="1213455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Scaremonger</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are a lot of application that do this and they are a nightmare for Firewall administrators. When you open a port on a firewall you do so for the direction of the initial conversation but using this type of port-factory means that you have to open additional ports and by opening them you may be opening the door for a hacker utilising a vulnerability.<br><br>However; If you are going to employ this mechanism, make sure that the "working" port is opened from the server TO the client and not the other way around. This means that once your client receives the port to use from the server, it should then listen for the server to call-back. <br><br>By implementing it this way the firewall protecting your server will have outbound ports open rather than lots of inbound ones and this should help to protect it.<br><br>Alternatively, as you initially suggested; Keep a connection ID. You can also use socket.remoteip() and socket.remoteport() to identify the client.<br><br>Si... <br><br></td></tr></table><br>
<a name="1213471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> You do not need to support multiple Ports.<br><br>You can - but mostly you just run into the firewall trap (force your users to do port mapping).<br><br>Port Mapping is only needed for "central servers". All other use hole punching (client sends "i wanna join" to server, client2 sends "i host" to server - server now knows client and client2's ips/used ports - and voila... they can connect to each other without port forwarding &lt;-- description was the easy way).<br><br>Like Brucey already said:<br>If you use UDP (with bnetex) you do not know what port you are using for sending. You only know what port you are targeting.<br>That is why eg. for the old Warcraft III you needed portmapping to your setup client-port as soon as you wanted to host on Battle.net.<br><br>So with UDP you open a connection to IP1:Port123 and then just wait for a timeout (locally measured, not line wise) or a packet. The packet then could contain your sender port (this is how I do it). Using this method, you can run 2 clients on one PC - both use a different communication / outgoing port but the same target-port.<br><br>Means - Brucey already told what happens: multiple outgoing ports (the clients), one incoming port (server side). The server does not need to have one "port" for each connection, he can separate them by their IP:port-combination.<br><br>But - as you already mentioned - you could send your "clientID" in each packet (I do this in some packets too) but it should not be needed. I just do it during "lobby action" (setting up players of a game, spreading around their data using broadcast-adresses, ...).<br><br>For easyness: use a "server port" (there a server listens to incoming connections), the clients will setup the ports on their own. Using this method, you only need to do router-port-forwarding as soon as you want to host. Using that method, your home could host multiple games (with differing ports). If you want to host 2 games on one port you will run into trouble (exception is a "host/server"-app which can host multiple games at once). If you have 2 computers in a LAN connected to WAN, they must use different ports for hosting. Your router wont know which packet for "wanIP:port" is targeting host1 or host2). In that case you use hole punching to a "lobby server". You host a game on host1 - it announces to lobbyserver (and gets the senderPort), now host2 hosts a game and announces (senderPort2). With that information the lobbyserver can spread around a list of hosted games:<br>wanIP:senderPort1<br>wanIP:senderPort2<br><br>People would be able to connect their clients to that Port.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1213496"></a>

<a name="1213497"></a>

<a name="1213498"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Richard Betson</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> All good stuff,<br><br>As Brucey suggests it's best to have one port set to listen on and then assign a client a port that it will use. This works great for the resource end as the server is listening on one port and perhaps sending game data on a second default port for single client/IP setups. This I like and I do not see a problem with assigning multiple clients to a port from the same or other IP addresses and as suggested the clients can send data on a default port and receive data on another.<br><br>I had intended to go with a dedicated headless Linux server and I still will probably do that but I think I may start out with a dual server/client application that can be used on a home setup. It will support a lesser number of clients (only limited by upstream bandwidth) but will also be easier for those less technically able. My game ( www.phoenixusc.com ) is already coded to support this as it uses an authoritative server so both the client and server use the same game engine/framework.  <br><br>Another hurdle will be assigning firewall policies to Windows, MAC and Linux which I'm not sure how to do but I suspect that a proper install application might be able to help. The port forwarding end of things is a bit sticky but I suspect that those running servers will have experience with this and can easily assign a rang of ports for the server. The clients will not need to do this and just needs a firewall policy.<br><br>So, all good and very helpful.<br><br>Thanks, <br><br></td></tr></table><br>
<a name="1213502"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just wrote a longer post - but fglrx.so crashed and with it the whole desktop ... think Mint16 was released way to buggy.<br><br><br>Ok in short: use hole punching if you want to avoid manual port forwarding (with a lobby in the middle of the "meeting each other" process).<br><br>As an "outgoing" port cannot be used by multiple processes you can identify a user by the "ip:senderPort"-combination.<br><br>If a game is starting, give that game an identifier - together with some "client specific" parts you can create a code on each players client which identifies it properly.<br>If you now get disconnected from that game - you can (you still know the hosts "IP:hostPort"-combination) knock again and beg for reentering the game. Using this approach you can rid of games which get useless if a gamers connection drops somehow (or routing gone bad - so timeouts kick the player).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1213578"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> For EdzupNetworkSystem i used a client id basically the client connected and verified his account then the server sent its ID after that all communications on packets was using the id.<br><br>its on the code archives if ha want to pull it apart and take a look <br><br></td></tr></table><br>
<a name="1213581"></a>

<a name="1213582"></a>

<a name="1213583"></a>

<a name="1213584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Richard Betson</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Waz up EdzUp[GD],<br><br>I believe I am using some of your int/float to string code form that and will credit you for sure. ;) I will take another look at that as it was pure gold as I recall.<br><br>So you are not assigning an incoming port to the client and are still able to handle multiple clients on the same IP (aside from a default incoming port)? <br><br>- Rich - <br><br></td></tr></table><br>
<a name="1213647"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> What i do is get the port requested on the connection iirc, after that its then validated passively (ie the user has to provide the username and password) if its ok the server then sends ok or fail. After that is sorted it validates the user assigns a id and sends that to the client then all communication is with the id. My network system waits for the client to acknowledge the id as well :) <br><br></td></tr></table><br>
<a name="1213648"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> You do not need to assign clientIDs ... except you want other clients to be able to take over a connection (this could be wanted).<br><br>Like said: each port on a computer can only be assigned one time. So if 192.168.0.1:1000 is connected, you cannot connect again with 192.168.0.1:1000. If you try to connect you will use another free port - maybe 1001.<br><br><br>For cheaters both ways are not secure enough (you can fake the "senderIP/port" and manipulate the clientID). For them you need to use things like userspecific hashes. If you use inter-client-communication (clientA directly sends packets to clientB) you should avoid sending him that hash. You could do individual connection-pair-hashes. But they should be salted then (for each client another salt) so that another client could not recalculate the bases from the hash he got from the other client receiving messages from the other client.<br><br>Most important thing is: make it the way it is "easy" for you to implement. Cheaters will find their way or holes in your code.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1213650"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> My system stopped some of the hacking by checking the server port the client is attached to this in some ways stops fake packets. <br><br></td></tr></table><br>
<a name="1213657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> The packet already can contain a faked header (sender ip and port) ... so this just stops hacking in some other clientIDs into a clients .exe.<br><br>Albeit better than nothing it could make the programme feel more secure than it is in reality.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1213658"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah true but it stops the casual hacker, nothing stops the determined hacker as the recent years IT news has proven :) <br><br></td></tr></table><br>
<a name="1213732"></a>

<a name="1213733"></a>

<a name="1213734"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Richard Betson</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I have designed I guess what I would call an hybrid authoritative server. In a twitch style game like mine there are some problems in using a 100% authoritative server namely the 'snap back' effect of having a client replay moves that it may have missed. Totally unacceptable in a top down shooter as the clients display view is linked to the ships position and it's nearly impossible to smooth that out enough so that it is not noticeable. Add in that working across different platforms the client and server are never going to run in completely congruent state.<br><br>In my case the server keeps a complete state of the game using the same exact map, physics and frameworks on both the server and client. So the server always knows where every client actor is and what they are doing and can monitor all clients at once. I do rely on the clients updating their position periodically and this and other data is sent encrypted (RC4). Typically you do not want the client reporting position data but since the server maintains a complete game state the position data is checked against the servers game state letting the server make the call on weather or not the new position update is valid. If it is not the client is sent a position update. If a client is cheating it is really only cheating itself as the server will not accept erroneous data. Typically this works very well for fast action games and coupled with steaming move (left, right, thrust, fire) data is reliable and handles latency well. Since the server has a complete state of the game it can make the call on kills, player or bullet position, energy levels and more. The only data that it needs from the client is the sequence of moves and a periodic position update.  <br><br>Guarding against spoofing the server by man in the middle, IP or port is a problem and I think the solution is to keep to an authoritative server model as it's hard to fool the server. The IP and port can be faked but limiting clients by account can help here as only one account per client can be used. In a free to play model a person can have potenially several accounts but even so I can not see to many ways to beat an authoritative server.<br><br>At any rate the solution for multiple clients on the same IP as I see it is to have a common outgoing port and assigning a incoming port. My server will sort out the clients by ID and know what ports to use. If a client tries to spoof the ID the server will know by an encrypted key unique to each client and assigned on connection. Not fool proof but pretty good. <br><br>- Rich - <br><br></td></tr></table><br>
<a name="1213775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I dont know how to say without repeating myself: It should not be possible to have multiple clients on the same host using the same port for outgoing connections simultaneously.<br><br>@hybrid authoritative server<br>As soon as a game is deterministic, this should not be needed. All the server has to know is the input of the clients:<br>left,right,left is still "left" - for all clients. So as soon as "replay" is possible, you know that your game runs in a deterministic way - and therefor does not need that much "powerful servers".<br><br>That is why "damageDone = attack + Rnd(1,5)" isn't the best idea (as you then have to sync the randomizer value of the client in this state - aka mersenne twister or another pseudo-randomizer.<br><br><br>But like said: as long as it works - do not pay that much attention to it except you want to have millions of players.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1215377"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wings</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> if you use ordinary tcpip no problem running on same host... with tcp udp you are in trubble :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
