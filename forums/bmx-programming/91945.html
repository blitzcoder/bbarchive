<!DOCTYPE html><html lang="en" ><head ><title >Even or Odd Number</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Even or Odd Number</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Even or Odd Number</a><br><br>
<a name="1046469"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BLaBZ</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> What's the quickest way to determine whether a number is even or odd? <br><br></td></tr></table><br>
<a name="1046470"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Check the first bit in binary...i.e. logically AND it with 1<br><br>Odd AND 1 = 1<br><br>Even AND 1 = 0 <br><br></td></tr></table><br>
<a name="1046472"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tommo</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  logically AND it with 1  <br></div><br>Use bitwise AND, not logic AND.<br>odd &amp; 1 = 1<br>even &amp; 1 = 0 <br><br></td></tr></table><br>
<a name="1046474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shambler</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Been working with logic chips a lot recently and there is only logic AND...my mistake &gt;.&lt; . <br><br></td></tr></table><br>
<a name="1046481"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> That depends on how the number is stored internally. A more generic way is to use the Mod operator, which returns the remainder after a division. Any number divided by 2 will give a remainder of 0 if it is even, yes?<br><br><pre class=code>Function IsEven:Int(number:Int)
	Return (number Mod 2) = 0
End Function</pre> <br><br></td></tr></table><br>
<a name="1046483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> mod is a lot slower than the bitwise operation on any computer. The processor divides and returns the remainder. <br><br></td></tr></table><br>
<a name="1046504"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's true but I find it highly unlikely that "Mod" is going to be the bottleneck in a real-world non-number-crunching program. <br><br></td></tr></table><br>
<a name="1046512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am sure you know its very likely to help in contributing to the bottleneck and knowing that will definitely help. <br><br></td></tr></table><br>
<a name="1046518"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's not my understanding of a bottleneck. A bottleneck is where one thing is slowing down the whole program. When one thing is slowing down everything else, it doesn't matter how fast or slow the other things are - it makes no difference. If using Mod to determine if a number is odd or even is the bottleneck in your program, there is something very wrong in your code. <br><br></td></tr></table><br>
<a name="1046535"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> if you say so. <br><br></td></tr></table><br>
<a name="1046540"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> After bringing my program from 5 frames a second to more than a hundred on several occasions, I do say so. These are due to powerful optimizations to very specific parts of code - the parts that cause the bottle neck. My game went from supporting a few dozen simultanious units to now supporting several hundred smoothly.<br><br>The reason it went so slowly is because I am using deterministic calculations which are always the same on every computer - something floats do not guarantee. The first method was woefully inefficient, but after several attempts it is now very efficient. The saying goes, your program spends 80% of its time in 20% of the code. Optimize only what you have to or you will be doing it all year.<br><br>For scientific number crunchers every millisecond counts but consider a game. Humans cannot perceive more than about 30 frames per second of updating (that's generous, even 20 is still smooth). That gives 33 milliseconds per frame to update the logic. A big complicated function that updates lots of things and takes up 10 milliseconds is something that could definately become a bottleneck. But using Mod instead of the bit check? In a game I'd say that uses up considerably LESS than 1 millisecond of time, virtually immeasurable, unless you were doing something really out of the ordinary. It just doesn't matter so long as your frame is completed within 33 milliseconds - 31 milliseconds or 5 milliseconds a frame, both are the same. If it goes over 33, then just optimise the slowest part of your code to bring it under 33 again. Getting your game finished is more important than a 200fps demo. <br><br></td></tr></table><br>
<a name="1046549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with everything Czar said. Apart from the conclusion, Im afraid Im with Jesse here.<br><br>Whats the point in using a method you know to be slower? ATM you are not going to be the only app/game using the system and making any part of your code less than optimal seems pointless.<br><br>Having said that I know ppl who thing ease of following the program to be more important than speed, I dont think that would apply here tho. <br><br></td></tr></table><br>
<a name="1046577"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> My dislike of the bitwise method is that it depends on the computer's architecture. It might work fine on your computer, or most people's computers, but one day you might be programming on a new architecture and it doesn't work and you don't know why. The Mod method will always work. <br><br></td></tr></table><br>
<a name="1046591"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> "Might" ? Dud mod is Implemented by the compiler "SHR/SAR" and "SHL/SAL" are implemented in to the processor architecture. who is to say that either one wont be discontinued or eliminated from either or both. from day one that I program and every language I know of has a type of mod and bit shift operation implemented and I have been programming for probably as long as you have been alive. I believe it's a lot more likely that a compiler won't have a mod "function" than the processor not have a bit shift operator.Bit shifts are part of and heavily used in low level programming. I believe that to be the worst excuse I have ever read. No disrespect intended. <br><br></td></tr></table><br>
<a name="1046594"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think by not "work" Czar means that it might not give you the expected result. e.g. on a PPC and 68k based systems where the data is stored in reverse order from an x86 architecture (this is one historical reason why PC apps were hard to port to Macs back in the day, as there was also a lot more ASM level code and other things that were highly architecture dependent due to speed). And I don't know the storage order for ARM but if you're developing for anything other than desktop these days you're going to likely run into that...<br><br>If you want your code to be as portable as possible keep it in the language and off the hardware. If the language magically misses the feature you can code around it, or find an alternative. If the hardware doesn't behave as expected you're going to tear your hair out until you remember "oh yea! that's byte order dependent!"<br><br>However if you're not planning on supporting other base architectures with the same code down the road then the closer to the hardware you get the better for both optimization and code simplicity (imo).<br><br>I have times where I would use both. e.g.<br>Writing an app that is likely to jump languages and probably platforms as well and it's not speed dependent such as loading, I would go with a compiler level approach.<br>Something that's going to stick to one platform or for code that will make a difference from a millisecond boost in speed due to looping etc. I would go bitwise.<br>If I was unsure I would go the fast route and leave a comment in the code that it's byte order dependent to same myself correction time later if needed.<br><br>my 2c <br><br></td></tr></table><br>
<a name="1046596"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Probably I'm being too cautious, but like ima says I was refering to the way that an integer might be stored on the computer, not whether bitwise operations themselves will change. Mod will always work in the same way as it's defined by the language to return the remainder after a division, regardless of binary representation.<br><br>Bitwise tricks might not always work the way you expect however, if the way an integer is represented in the computer changes. Bitwise tricks are highly addictive, so be careful you don't become dependant on them, because it might bite you in the backside when you suddenly find yourself on a different architecture. <br><br></td></tr></table><br>
<a name="1046626"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Please correct me if I'm wrong, but since when do bitwise operators in BlitzMax or C matter when dealing with normal datatypes, like Integer, regardless of how they are stored internally by the CPU system?  Isn't this the responsibility of the compiler?  What I can find of the current ANSI standard defines that the bitwise AND operator will AND each prealigned bit between to like operators.  Which I interpret to mean that no matter how the CPU stores the binary representation of a integer any AND operator will result in the same answer no matter where the code is compiled.<br>---------------------------------------------------------<br>Brucey is one of the experts on this subject, he'd know the real answer straight off!!!! :D  Mark would be able to answer this pretty quickly as well.  Hahah.<br>---------------------------------------------------------<br>Now, if the compiler is NOT taking care of the this then the following code will result in different values depending on what system it is compiled and ran on:<br><br><pre class=code>
SuperStrict

Function ReadBit:Long(x:Long, bit:Long) 'Return(0/1) of specific bit(0-63) in value(x)
	Return (x Shr bit) &amp; 1
End Function

Local a:Long=1152921504606846977:Long

Print a

Print readbit(a,0)
Print readbit(a,60)
</pre><br><br>Can someone with access to PPC MAC compile this code and post if they find any difference in the output from a standard 32-bit x86?<br><br>(Output should be:<br>1152921504606846977<br>1<br>1<br><br>--------------------------------------------------------------------------------------<br><br>Ok, enough of the sillyness, here is simple code that can very easily be modified to work in probably any programming language regardless of CPU architecture.<br><br><pre class=code>
Local a:Int=23  'Some Number to test for Odd/Even.

For Local i:Int=a To 2 Step -2
	a=a-2
Next

If a=1 Then Print "Odd."
If a=0 Then Print "Even."
</pre><br><br>HA!<br><br>[Edit]<br>P.S.  LOL, ok, I realize it only works for positive numbers.  Oops.<br><br><pre class=code>
Local a:Int=-23

If a=0 Then Print "Zero."

If a&lt;0 Then a=a*-1


For Local i:Int=a To 2 Step -2
	a=a-2
Next

If a=1 Then Print "Odd."
If a=0 Then Print "Even."
</pre> <br><br></td></tr></table><br>
<a name="1046649"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Probably I'm being too cautious, but like ima says I was refering to the way that an integer might be stored on the computer...<br> <br></div><br>I think Shortwind got it wright.<br>True. It is the job of the compiler to deal with differences as such. Again, who is to say that the maker of the compiler will implement either one or both. we can't predict the future and to be worried about something that has been standard sense day 1, about becoming obsolete, is just pure panic in my opinion. nothing is forever but if we become so concern with stuff like these, well... <br><br></td></tr></table><br>
<a name="1046654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm talking about the way numbers are represented in binary, not whether bitwise operations and/or mod will or will not be available on some theoretical compiler. For this particular example, it's not much of a concern, but here is another example.<br><br><a href="http://en.wikipedia.org/wiki/Signed_number_representations" target="_blank">http://en.wikipedia.org/wiki/Signed_number_representations</a><br><br>Here are FOUR different ways you can represent negative 6 in 5 different and real representations (although most of these are probably obscure representations, that's not the point).<br><br>6 	1110 	1001 	1010 	0001<br><br>A bitwise trick to determine if a number is negative, for example, might work on one computer but fail miserably on another which represents numbers in a different way. That's why it's usually better to use a more generic method, in this case (x &lt; 0), even if it's slower. In this case &lt; is a fast comparison, but even if it weren't, I would still endorse its use. That's because &lt; is defined to work the same way with the "mathematical" value of the number on every computer, ignoring super obscure languages which might not have &lt; for some reason. You don't need to depend upon or even know how integers are stored on a computer. If you can use &lt;, you can detect a negative number.<br><br>Likewise, with Mod, you don't need to know or even care how numbers might be stored internally on that computer. Your test will ALWAYS work, if a language provides a Mod operator. Of course maybe some obscure language X won't provide a Mod operator, but so what? This is a Blitz forum, a question about Blitz code, and Blitz has Mod.<br><br>You should only use bitwise checks when speed of a particular operation is critical. Truely critical. And if you do use bitwise checks, you should always bear in mind that numbers might be represented differently on different computers. Even if there is a 99% chance it will be the same and you don't account for that 1%, it's still good karma to at least even be aware of that. But that's something a beginner might not appreciate or even care about until he's more experienced.<br><br>In any case, the OP did ask for the quickest method, which is the bitwise one. <br><br></td></tr></table><br>
<a name="1046659"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOL! <br><br></td></tr></table><br>
<a name="1046701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's what your mum said too. <br><br></td></tr></table><br>
<a name="1046732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> very mature. <br><br></td></tr></table><br>
<a name="1046770"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> You smell, smelly! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
