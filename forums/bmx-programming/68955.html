<!DOCTYPE html><html lang="en" ><head ><title >Function pointer wont compile</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Function pointer wont compile</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Function pointer wont compile</a><br><br>
<a name="770793"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm having some difficulty with function pointers, and quite possibly this might be a limitation of BlitzMax as a language/compiler.<br><br>I have an array of Objects in which I will be storing custom types of various kinds. Obviously this means that once the objects are in the array, you do not know what type of object they really are.<br><br>I have an array of Kinds, which is just an integer value referring to what kind of object it originally was.<br><br>The simple (but inefficient) solution for getting the right type of object out of the array is to do a Select-Case based on the Kind[Offset] for Objects[Offset].<br>This of course works. Also *if I know* the situation in which a given object type is to be used, such as that I need a TPixmap object, I can of course just cast it like TPixmap(Objects[Offset]). Becauase I am explicitly casting it within the sourcecode, the compiler knows that I can then call any functions or methods within TPixmap and it will be valid, e.g. TPixmap(Objects[Offset]).ReadPixel(10,5). Because the compiler knows the allowed methods of TPixmap objects, and knows I am casting it to a TPixmap, it lets it be compiled.<br><br>On the other hand, there are situations where I do not know the type of object and want to just, for example, go through all the objects stored and call a method that they all share. For example each of my custom types has a PrintSelf() method that prints details about its fields. I want to be able to run through the objects array, *not* using the kinds array, and call the PrintSelf() method of each object. To do this, what I am trying to do is have a Function Pointer for each object. This function pointer points to a Convert() function within the custom type. So all I should have to do is go through the objects and call, for example, ConversionFunctions[Offset](Objects[Offset]).PrintSelf()<br><br>However, the compiler will not compile the sourcecode. It says the PrintSelf() is not defined. I think that this is because it doesn't know what type of object it is dealing with and so is either looking in the Object() type and not finding that method, or it knows that it just can't tell what the type will be so it can't verify that it's a valid method. Is that what's happening?<br><br>Is there some way I can call the ConversionFunction (which would simply =Convert() function within a given type, to which you pass an object), and get it to convert to a specific object type, and then also call the method within that type, and have the compiler say it's ok?<br><br>I am wondering if it's because the array of Conversion Functions is defined as Converters:Object(Obj:Object)[], which means that no matter what type is returned from Convert() it will change it into just an Object and so won't return the actual type of object? How could I store the functions in one array even though they each return different types?<br><br>e.g. A Convert() function might look like:<br>[code]<br>Function Convert:MyType(Obj:Object)<br>   Return MyType(Obj)<br>End Function<br>[Code]<br><br>Am I right in thinking that storing this in an array of function pointers that return Objects, cancells out the type conversion?<br><br>How can I make this work, so I can call Converters[Offset](Objects[Offset]).PrintSelf()<br>??? <br><br></td></tr></table><br>
<a name="770795"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could create a base type which has abstract methods for all the shared methods, have all the other types extend that type, and then make the array an array of your basetype instead of an array of objects. <br><br></td></tr></table><br>
<a name="770813"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's a good idea, except that it means I can only store custom types. I wouldn't be able to also store, for example, a TPixmap. Right?<br><br>Also there are no shared methods as such, each custom type would have different code for PrintSelf(), for example.<br><br>What is an abstract method? <br><br></td></tr></table><br>
<a name="770814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I dissagree with Gabs "Could"<br>If <b>all</b> your objects have a printself(), then that should really be a member of the base class.<br>The rest of what he said I agree with, extend Object (which is like the norm), with abstract mehtods of <b>all</b> the things that you want in all your dirived types, then extend the current base types from MyObject.<br><br>I know this is just opinion, but in mine (opinion), it shows a lack of planning not to have the common methods/fields in the base type. (Im not having a go, just saying that when I run into problems like this, its normaly becase of lack of planning on my part)<br><br>Edit, just read your post. Would TPixmap have a Printself?<br>An abstract method is one you declare, but dont define.<br><div class="quote"> Abstract and Final<br>User defined types and methods can also be declared abstract or final by adding Abstract or Final to the appropriate declaration:<br><br>Type AbstractType Abstract<br>	Method AbstractMethod() Abstract<br>End Type<br><br>Type FinalType Final<br>	Method FinalMethod() Final<br>		Print "FinalType.FinalMethod"<br>	End Method<br>End Type<br><br>Declaring a user defined type abstract means that you can not create instances of it using New. However, it is still possible to extend such types and create instances of these derived types. Declaring a method abstract means that the method has no implementation and must be implemented by a derived type. Any user defined type with at least one abstract method is itself abstract.<br><br>Declaring a user defined type final means that it can not be extended. Declaring a method final means that derived types can not override the method. All methods of a final user defined type are themselves final.<br><br>Abstract types and methods are mostly used to create 'template' types and methods that leave implementation details up to derived types.<br><br>Final types and methods are mostly used to prevent modification to a type's behaviour. <br></div> <br><br></td></tr></table><br>
<a name="770817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Also there are no shared methods as such, each custom type would have different code for PrintSelf(), for example. <br></div><br>As long as they have the some number and type of parameters, that'll be fine. As H&amp;K's description explains, it's really just a template. It's saying all objects will be able to do this, but they'll all do it differently.<br><br>With regard to storing a TPixmap, no you wouldn't. In that instance, you would have to store objects in the list, and then cast the object to your basetype before you call printself on it. So instead of casting to a type, you'd be casting to a group of types. <br><br></td></tr></table><br>
<a name="770825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wowza. Well, it does indeed work. Thanks guys!<br><br>I set up an abastract base type with the methods and functions that would be the same name in each type (and yes they have the same parameters), also as abstract. Then I made the custom types extended from the base type, and Final. I noticed in the documentation about custom types, under language, that it says to just put Final to make a type final, but it doesn't say to put the Extends AND the Final together on the same line. ie<br><br>Type MyType Extends BaseType Final<br><br>So the documentation is a bit unclear. It makes it seem like you just put Final and don't need to define what it extends from.<br><br>But anyway, I did this and implemented the conversion functions array, which is an array of BaseType. I have the Convert() function returning a specific type which derives from the base type. Then to my delight I find that I can simply do:<br><br>Objects[Count].PrintFull()<br><br>and it will actually recognize that it's a legal function, and will call it, regardless of whether it looks like it would know what custom type it is inside of. Very cool! THEN I realized I don't even need the conversion functions (or array of them) at all, really. I don't have to initially convert the type and then call PrintFull(). But for now I think I will leave those in there in case I need them later.<br><br>Thanks again. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
