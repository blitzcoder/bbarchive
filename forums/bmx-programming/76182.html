<!DOCTYPE html><html lang="en" ><head ><title >Raycaster Competition</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Raycaster Competition</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Raycaster Competition</a><br><br>
<a name="851767"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >daaan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Who wants to have a raycaster competition? I've never written one before and would like to. This could be a great excuse to write an old school game.<br><br>What should the requirements be?<br><br>-Walls<br>-Floor &amp; Ceiling<br>-? <br><br></td></tr></table><br>
<a name="851854"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Schragnasher</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> nazis? <br><br></td></tr></table><br>
<a name="851869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOL! <br><br></td></tr></table><br>
<a name="851871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >z80jim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> question: what's a raycaster competition? <br><br></td></tr></table><br>
<a name="851874"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CS_TBL</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> could be:<br><br>smallest raycast code (only walking/walls, no enemies) <br><br></td></tr></table><br>
<a name="851876"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> @z80jim : <a href="http://en.wikipedia.org/wiki/Ray_casting" target="_blank">http://en.wikipedia.org/wiki/Ray_casting</a> <br><br></td></tr></table><br>
<a name="851913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Raycasting is an old way of drawing 3D scenes, which was used by pseudo-3D games on older computers.  Like this:<br><br><img src="http://www.dosgamesarchive.com/download/wolf3d.gif"><br><br>Back then, the game drew the world by casting one ray per vertical line of the screen, to find out how far it was to the nearest wall, which were aligned to a grid in the case of Wolf3D in order to make it fast enough.  Then it drew a scaled vertical segment of the appropriate texture, which could be done fast because no divisions needed to be done per pixel to adjust for perspective, because all pixels in that vertical segment were the same distance from the camera.<br><br>Nowadays, computers are fast enough that you don't have to reprent the level with a grid or a 2D map of line segments.  You can use polygons.  And you can cast one ray per pixel on the screen.<br><br>But nowadays 3D cards can draw a polygon much faster than it could be calculated by the CPU, so you might be limited in the resolution, and unless you support mipmaps you're gonna see a lot of aliasing. <br><br></td></tr></table><br>
<a name="851933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> OH MAN I have just had an amazing idea. <br><br></td></tr></table><br>
<a name="851966"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do tell! <br><br></td></tr></table><br>
<a name="851999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >daaan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> So what'll it be? Smallest code? Best looking? <br><br></td></tr></table><br>
<a name="852700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >remz</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I already have a working raycaster test in Blitzmax so I would surely participate depending on the competition goal.<br><br>sSwift:<br><div class="quote"> Nowadays, computers are fast enough that you don't have to reprent the level with a grid or a 2D map of line segments. You can use polygons. And you can cast one ray per pixel on the screen. <br></div><br>This would actually be 'Ray tracing' no? Although this would be an interesting idea for the competition. I am very unsure about the performance of a realtime raytracer even on today's machine. Intriguing.. <br><br></td></tr></table><br>
<a name="852761"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did one in C years ago, just never got rid of the fish-eye-lens problem :) <br><br></td></tr></table><br>
<a name="852792"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Funny you should say that, I was going to say earlier today that I think I'll just sit back and wait for the first people to start asking how to get rid of the fish eye. :-)<br><br><br>Since I remember how frustrating that problem was, I offer this hint to those who might try to implement one of these:<br><br>The back of your eye is curved.  To remove the fish eye effect, you must adjust the distance you calculate for each wall by taking this curvature into account.  In other words you'll need to incorporate some sort of multiplication of the distance by sin or cos to cancel out the curvature that you would see if your retina were flat like the sensor of a camera. <br><br></td></tr></table><br>
<a name="852793"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Remz:<br>Realtime raytracing is possible, and I saw demos years and years ago which did it at low resolution.  But those were with simple environments.  Obviously the more detailed the environment the more costly it will be to raytrace, and I don't know what the state of the art in that area is right now. <br><br></td></tr></table><br>
<a name="852808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey you need some sort of fish-eye powrup it would look quite cool. <br><br></td></tr></table><br>
<a name="852868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Schragnasher</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> sswift<br><br><a href="http://www.openrt.de/" target="_blank">http://www.openrt.de/</a>  I saw this a while back, havent checked it out in a while. <br><br></td></tr></table><br>
<a name="852871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Schragnasher</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="http://blogs.intel.com/research/2007/10/real_time_raytracing_the_end_o.php" target="_blank">http://blogs.intel.com/research/2007/10/real_time_raytracing_the_end_o.php</a><br><br><br>nice article on the benefits of raytracing in case anyone was actually interested. <br><br></td></tr></table><br>
<a name="852883"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >remz</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can explain how to remove the fish eye effect.<br>In fact, the Fish-eye effect is caused when your raycasting algorithm is not correct:<br>In a tradionnal fish-eye raycaster, you basically setup a field-of-view (FOV), say 90 degrees, and you then cast one ray per screen column, say 320, with a calculated delta degree, 90 / 320 = 0.28125 degree per column.<br><br>That's not the right way: it will always give a 'fish eye' effect, more visible if the FOV is large. You can try to do a 'fish eye correction' with some acos() stuff but it doesn't work.<br><br>I might sketch up something to demonstrate the right way I'm talking about.. <br><br></td></tr></table><br>
<a name="853039"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >remz</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> There we go, I wiped up some pics, hope that helps!<br>This is the traditional 'fish eye' raytracing:<br><img src="http://rveilleux.googlepages.com/raycast1.png"><br><br>and here's the correct way to do it:<br><img src="http://rveilleux.googlepages.com/raycast2.png"> <br><br></td></tr></table><br>
<a name="853163"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nawi</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not entering the competition, but this is a snippet I came up with a while ago. It uses 'cheating math' because I was too bored to actually read a tutorial, so I came up with my own ways. It is a 3d raycaster not a 2.5d.<br><br><pre class=code>
SuperStrict; AppTitle = "Raytracer"
Const GfxWidth:Int = 200,GfxHeight:Int = 200,PlanetCount:Int = 3,CameraSize:Float=10
Const CameraWidth:Float = Float(GfxWidth)/Float(GfxHeight)*CameraSize; Const CameraHeight:Float = CameraSize
Const CameraMax:Float = 5.0,RayStep:Float=0.25; Const Spheres:Int=5
Graphics GfxWidth,GfxHeight,0
Type Point
	Field X:Float,Y:Float,Z:Float
End Type
Type Sphere Extends Point
	Field Radius:Float
	Field R:Int,G:Int,B:Int
	Global List:TList
	Method New()
		ListAddLast(List,Self)
	End Method
End Type
Sphere.List = CreateList()

Local Buffer:TPixmap = CreatePixmap(GfxWidth,GfxHeight,PF_RGBA8888); Buffer.ClearPixels(0)
Local DrawFPS:Int,FPSCounter:Int,FPSTimer:Int,Camera:Point = New Point; Camera.Z = -10

For Local t:Int = 1 To Spheres
	Local S:Sphere = New Sphere
	S.X = Rnd(-10,10); S.Y = Rnd(-10,10); S.Z = Rnd(-10,10); S.Radius = Rnd(1,5); S.R = Rand(0,255); S.G = Rand(0,255); S.B = Rand(0,255)
Next

Repeat
	If KeyDown(KEY_LEFT) Then Camera.X:-3
	If KeyDown(KEY_RIGHT) Then Camera.X:+3
	If KeyDown(KEY_UP) Then Camera.Z:+1
	If KeyDown(KEY_DOWN) Then Camera.Z:-1

	Buffer.ClearPixels(0)
	For Local y:Int = 0 To GfxHeight-1
		For Local x:Int = 0 To GfxWidth-1
			Local Ray:Point = New Point
			Ray.X = Camera.X+((x-GfxWidth*0.5)/GfxWidth)*CameraWidth
			Ray.Y = Camera.Y+((y-GfxHeight*0.5)/GfxHeight)*CameraHeight
			Ray.Z = Camera.Z
			Local S:Sphere
			Local StepX:Float = ((x-GfxWidth*0.5)/GfxWidth)*CameraWidth*0.05
			Local StepY:Float = ((y-GfxHeight*0.5)/GfxHeight)*CameraHeight*0.05
			Local X1:Float,Y1:Float,Z1:Float,FoundS:Sphere,StartZ:Float=Ray.Z
			S = Null
			Repeat
				Ray.X:+StepX
				Ray.Y:+StepY
				Ray.Z = Ray.Z+RayStep
				For Local FS:Sphere = EachIn Sphere.List
					X1 = Ray.X-FS.X; Y1 = Ray.Y-FS.Y; Z1 = Ray.Z-FS.Z
					If Sqr(X1*X1+Y1*Y1+Z1*Z1) &lt;= FS.Radius Then
						S = FS
						Exit
					EndIf
				Next
			Until S&lt;&gt;Null Or Ray.Z&gt;CameraMax
			Local R:Int = S.R-10*(Ray.Z-StartZ); If R&lt;0 Then R=0
			Local G:Int = S.G-10*(Ray.Z-StartZ); If G&lt;0 Then G=0
			Local B:Int = S.B-10*(Ray.Z-StartZ); If B&lt;0 Then B=0
			If S&lt;&gt;Null Then Buffer.WritePixel(x,y,(R Shl 16) | (G Shl 8) | B)
		Next
	Next	

	DrawPixmap Buffer,0,0; FPSCounter:+1
	If MilliSecs()&gt;FPSTimer+999 Then
		FPSTimer = MilliSecs(); DrawFPS = FPSCounter; FPSCounter = 0
	EndIf
	DrawText "FPS: "+DrawFPS,0,0
	Flip
	'Cls
Until KeyHit(KEY_ESCAPE)
</pre> <br><br></td></tr></table><br>
<a name="853295"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vilu</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nawi, I get a whopping 2 FPS on my 4-year-old 1.5 GHz laptop :)<br><br>And for some reason I get a runtime error for accessing a null object when compiling in debug mode. <br><br></td></tr></table><br>
<a name="853300"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Allow me to restate what Remz said in an easier to grasp manner:<br><br>If your screen is 640 pixels wide, and your FOV is 90, instead of casting one ray every 0.140625 degrees, what you need to do is imagine that the screen is suspended in front of the player, and cast the rays through the individual pixels in that screen.<br><br>If you do that, then the change in angle from one ray to the next will be greatest near the middle of the screen, and less towards the edges.<br><br><br>----<br><br>Now that you understand that...<br><br><br>Calculating the correct angle for each pixel is fairly simple if you know the rules dealing with how the lengths of the sides of a right triangle (a triangle with one corner that is 90 degrees) relates to the angles.<br><br>And those rules are:<br><br>SohCahToa <br><br>or <br><br>Sine = Opposite/Hypoteneuse<br>Cosine = Adjacent/Hypotenuse<br>Tangent = Opposite/Adjacent<br><br>Let's use the first equation as an example:<br><br>Sine = Opposite/Hypoteneuse<br><br>This means that the Sine of an angle (Which is a number you can convert into an angle) equals the length of the side across from it, divided by the hypoteneuse, which is the side across from the 90 degree corner.<br><br>(The adjacent side in the other equations is the side touching the corner you're trying to find the angle of.)<br><br>In other words:<br><br>|\<br>|_\<br><br>The side at an angle is the hypoteneuse.  The side on the left and the side on the bottom could either be the opposite or the adjacent, depending on which corner you're trying to find the angle of.<br><br><br>Now let's flip that triangle over and get to calculating our angle:<br><br>``/<br>|/<br>P<br><br>P is our player.  That corner there is the one we're trying to find the angle of.<br>  <br>H is the length of our hypoteneuse on the right.  We don't know H.<br><br>A is the length of our adjacent side.  For this example, that would be the left side.  It is the side which is not the hypoteneuese which is touching the angle that we want to find.  We do know the length of this side.  Here, it is 1.<br><br>O is the length of our opposite side.  This is the length of the top side, which is opposite the corner at the bottom of the triangle.  We also know the length of this.  Here it is 2, but this length will vary.  It will be 0.5 for the centers of the first two columns of the screen to the left and right of the center of the screen which is between two pixels.  And it will increase by 1 each pixel away from the center two pixels.  <br><br>So, which of the three euqations will let us compute our angle with opposite and adjacent?<br><br>This one!<br><br>Tangent = Opposite/Adjacent<br><br>So we could just plug in our values into this and get the tangent of our angle, but we want an actual angle.  To get that, you pass that value into a function called ArcTan.<br><br>So: <br>Angle = ArcTan(Opposite/Adjacent)<br><br>You can also use the ArcTan2 function, like so:<br><br>Angle = ArcTan2(Opposite, Adjacent)<br><br>ArcTan2 exists beccause adjacent approaches 0 as the angle approaches 90 degrees, and ArcTan2 can use the two values it is passed to compensate for this.  (An adjacent approaching 0 causes the value passed to the ArcTan function to approach infinity if you just do the division method.)  <br><br>You won't be going more than 45 degrees in either direction from center, and your adjacent length will always be 1, so this won't be an issue for you, but if you ever need to calculate the angle an object is at in relation to another object, ArcTan2 is your function.  <br><br>I don't know which is faster, but I personally always use ArcTan2.<br><br>And so that's it.  Now you have your angle, and you can use that to cast your ray.<br><br><br>Now, you might think "I don't need to do any of that angle stuff!  I've gone as far as calculating the opposite and adjacent for a specific pixel, and I therefore know the X and Y of that pixel.  And that means I know the endpoint of a very short vector that travels in exactly the same direction that I want my ray to go in.  And that's all I need for my infinite ray!"<br><br><br>But that will only work if you can't turn in place at all.  <br><br>So you do need the angles.  You need to calculate the angle for each column, and store that in an array at the start of your program for quick access.  Then at runtime, you add the current view angle to the angle for each column, and calculate your vector for your ray like so:<br><br>X = Radius * Cos(Angle)<br>Y = Radius * Sin(Angle)<br><br>You can just assume a radius of 1 and exclude that from the equations.<br><br>And that gives you your ray vectors, with no fisheye effect.  <br><br>Ta da! <br><br></td></tr></table><br>
<a name="853445"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >QuietBloke</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> found this article on tinternet<br><br><a href="http://student.kuleuven.be/~m0216922/CG/raycasting.html" target="_blank">http://student.kuleuven.be/~m0216922/CG/raycasting.html</a><br><br>and to help me make sense of it I blitzified it.. and added a topdown map view. Its quite messy code still and I have only taken the first part where the walls are just plain colors but it works.<br>Now I need to mess around to get my head around exactly what it does !<br>Anyway. some might find it useful. Not really all my code so I cant really enter it into the <br><br>Keys: cursor to move,q to quit<br><br>Edit : This version calcs the xpos (0-1) on the cell that the ray has hit. The 2d view draws all the rays now.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

' Based on code by Lode Vandevenne
' Original totorial and source code
'can be found at : <a href="http://student.kuleuven.be/~m0216922/CG/raycasting.html" target="_blank">http://student.kuleuven.be/~m0216922/CG/raycasting.html</a>

Global world:TWorld

main()
End

Function main()
	Local player:TPlayer

	world = New TWorld
	player = New TPlayer

	Graphics 640,400,0

	While Not KeyHit(KEY_Q)
		Cls
		player.Update()
		SetOrigin 0,0
		SetColor 100,100,100
		DrawLine 320,0,320,400
		DrawLine 0,200,320,200
		world.Draw()
		player.Draw()

		Local x:Int
		Local cameraX:Double
		Local rayPosX:Double
		Local rayPosY:Double
		Local rayDirX:Double
		Local rayDirY:Double

		For x=0 To 320

			' calculate ray position And direction 
			cameraX = -2.0 * Double(x) / 320.0 + 1.0 ' x-coordinate in camera space
			rayPosX = player.xPos
			rayPosY = player.yPos
			rayDirX = player.direction.x + player.camera.x * cameraX
			rayDirY = player.direction.y + player.camera.y * cameraX

			' which box of the map we're in  
			Local  mapX:Int = rayPosX
			Local mapY:Int = rayPosY

			' length of ray from current position To Next x Or y-side
			Local sideDistX:Double
			Local sideDistY:Double

			' length of ray from one x Or y-side To Next x Or y-side
			Local deltaDistX:Double = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
			Local  deltaDistY:Double = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
			Local perpWallDist:Double
       
			' what direction To Step in x Or y-direction (either +1 Or -1)
			Local stepX:Int
			Local stepY:Int

			Local hit:Int = 0 ' was there a wall hit?
			Local side:Int ' was a NS Or a EW wall hit?

			' calculate Step And initial sideDist
			If rayDirX &lt; 0 Then
				stepX = -1
				sideDistX = (rayPosX - mapX) * deltaDistX
			Else
				stepX = 1
				sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
			End If

			If rayDirY &lt; 0 Then
				stepY = -1
				sideDistY = (rayPosY - mapY) * deltaDistY;
			Else
				stepY = 1;
				sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY;
			End If

			' perform DDA
			While hit = 0

				' jump To Next map square, Or in x-direction, Or in y-direction
				If sideDistX &lt; sideDistY Then
					sideDistX :+ deltaDistX
					mapX :+ stepX
					side = 0
				Else
					sideDistY :+ deltaDistY
					mapY :+ stepY
					side = 1
				End If

				' Check If ray has hit a wall
				If world.cell[mapX,mapY] &gt; 0 Then
					hit = 1
				End If
			Wend
			SetColor 255,255,0
			SetOrigin 320+12,0+12

			' calculate value of wallX
			Local wallX:Double  ' where exactly the wall was hit
			If side = 1 Then 
				wallX = rayPosX + ((mapY - rayPosY + (1.0 - stepY) / 2.0) / rayDirY) * rayDirX
			Else
				wallX = rayPosY + ((mapX - rayPosX + (1.0 - stepX) / 2.0) / rayDirX) * rayDirY
			End If

			wallX :- Floor((wallX));

			' Draw the ray for each screen column we are drawing
			Local drawMapX:Double
			Local drawMapY:Double

			drawMapX = mapX
			drawMapY = mapy
			SetColor 255,255,0
			If side = 1 Then
				If player.yPos &gt; drawMapY Then
					drawMapY :+ 1
				End If			
				drawMapX = drawMapX + wallX
			Else
				If player.xPos &gt; drawMapX Then
					drawMapX :+ 1
				End If
				drawMapY = drawMapY + wallX
			End If
			SetColor 0,255,255
			DrawLine player.xPos*12.0,player.yPos*12.0,drawMapX*12.0,drawMapY*12.0

			SetOrigin 0,0

			' Calculate distance projected on camera direction (oblique distance will give fisheye effect!)
			If side = 0
				perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
			Else
				perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
      		End If

			'Calculate height of line To draw on screen
			Local lineHeight:Int  = Abs(Int(200 / perpWallDist))
       
			' calculate lowest And highest pixel To fill in current stripe
			Local drawStart:Int = -lineHeight / 2 + 200 / 2

			If drawStart &lt; 0 Then
				drawStart = 0
			End If

			Local drawEnd:Int = lineHeight / 2 + 200 / 2;
			If drawEnd &gt;= 200 Then 
				drawEnd = 200 - 1
			End If
        
			' choose wall color
			Local colR:Int
			Local colG:Int
			Local colB:Int
			
			Select world.cell[mapX,mapY]
					Case world.CELL_OUTER_WALL
						colR = 200
						colG = 200
						colB = 200
					Case world.CELL_INNER_WALL1
						colR = 200
						colG = 100
						colB = 100
					Case world.CELL_OUTER_COLUMN
						colR = 200
						colG = 0
						colB = 200 
					Case world.CELL_INNER_WALL2
						colR = 100
						colG = 100
						colB = 200
					Case world.CELL_EXIT
						colR = 100
						colG = 200
						colB = 100
			End Select
       
			' give x And y sides different brightness
			If side = 1 Then 
				colR :/ 2
				colG :/ 2
				colB :/ 2
			End If

			SetColor colR, colG, colB

'      //draw the pixels of the stripe as a vertical line
      DrawLine x, drawStart, x, drawEnd
 

		Next

		Flip
	Wend
End Function

Type TVector
	Field x:Float
	Field y:Float
End Type

Type Tplayer
	Field xPos:Float
	Field yPos:Float
	Field direction:TVector
	Field camera:TVector
	Const moveSpeed:Float= 5.0/30.0
	Const rotSpeed:Float = 60.0 / 30.0
	
	Method New()
		direction = New TVector
		camera = New TVector
		xPos = 22
		yPos = 12
		direction.x = -1
		direction.y = 0
		camera.x = 0
		camera.y = .66
	End Method

	Method Draw()
		' draw player
		SetColor 255,0,0
		DrawLine xPos*12-6,yPos*12-6,xPos*12+6,yPos*12+6
		DrawLine xPos*12-6,yPos*12+6,xPos*12+6,yPos*12-6
		' draw direction
		SetColor 255,255,255
		DrawLine xPos*12,yPos*12,xPos*12+direction.x*12,yPos*12+direction.y*12
		' drawcamera
		DrawLine xPos*12+direction.x*12, ..
			yPos*12+direction.y*12, ..
			xPos*12+direction.x*12 + camera.x*12, ..		
			yPos*12+direction.y*12 + camera.y*12		
		DrawLine xPos*12+direction.x*12, ..
			yPos*12+direction.y*12, ..
			xPos*12+direction.x*12 - camera.x*12, ..		
			yPos*12+direction.y*12 - camera.y*12
		' draw end rays
'		SetColor 0,200,0
'		Local endX:Float
'		Local endY:Float
'
'		endX = (direction.x + camera.x) * 25
'		endY = (direction.y + camera.y) * 25
'		DrawLine xPos*12,yPos*12,xPos*12+endX*12, yPos*12+endY * 12		
'		endX = (direction.x - camera.x) * 25
'		endY = (direction.y - camera.y) * 25
'		DrawLine xPos*12,yPos*12,xPos*12+endX*12, yPos*12+endY * 12		
	End Method

	Method Update()
		' move Forwards
		If KeyDown(Key_UP)
			If world.cell[(xPos + direction.x * moveSpeed),Int(yPos)] = 0 Then
				xPos :+ direction.x * moveSpeed
			End If
			If world.cell[(xPos),Int(yPos + direction.y * moveSpeed)] = 0 Then 
				yPos :+ direction.y * moveSpeed
			End If
		End If

		' move Backwards
		If KeyDown(Key_DOWN)
			If world.cell[(xPos - direction.x * moveSpeed),Int(yPos)] = 0 Then
				xPos :- direction.x * moveSpeed
			End If
			If world.cell[(xPos),Int(yPos - direction.y * moveSpeed)] = 0 Then 
				yPos :- direction.y * moveSpeed
			End If
		End If

		' rotate left
		If KeyDown(KEY_LEFT)
			Local temp:Float
		
			temp = direction.x
			direction.x = direction.x * Cos(-rotSpeed) - direction.y * Sin(-rotSpeed)
			direction.y = temp*Sin(-rotSpeed) + direction.y * Cos(-rotSpeed)
			temp = camera.x
			camera.x = camera.x * Cos(-rotSpeed) - camera.y * Sin(-rotSpeed)
			camera.y = temp*Sin(-rotSpeed) + camera.y * Cos(-rotSpeed)
		End If

		' rotate right
		If KeyDown(KEY_RIGHT)
			Local temp:Float
		
			temp = direction.x
			direction.x = direction.x * Cos(rotSpeed) - direction.y * Sin(rotSpeed)
			direction.y = temp*Sin(rotSpeed) + direction.y * Cos(rotSpeed)
			temp = camera.x
			camera.x = camera.x * Cos(rotSpeed) - camera.y * Sin(rotSpeed)
			camera.y = temp*Sin(rotSpeed) + camera.y * Cos(rotSpeed)
		End If

	End Method

End Type

Type TWorld
	Field width:Int
	Field height:Int
	Field cell:Int[,]

	Const CELL_EMPTY:Int = 0
	Const CELL_OUTER_WALL:Int = 1
	Const CELL_INNER_WALL1:Int = 2
	Const CELL_OUTER_COLUMN:Int = 3
	Const CELL_INNER_WALL2:Int = 4
	Const CELL_EXIT:Int = 5

	Method New()
		RestoreData WorldData

		ReadData width,height
		cell = New Int[width,height]

		Local x:Int
		Local y:Int

		For y = 0 Until height
			For x = 0 Until width
				ReadData cell[x,y]
			Next
		Next
	End Method

	Method Draw()
		Local x:Int
		Local y:Int
		
		SetOrigin 320+12,0+12

		For y = 0 Until height
			For x = 0 Until width
				Select cell[x,y]
					Case CELL_EMPTY
						SetColor 0,0,0
					Case CELL_OUTER_WALL
						SetColor 200,200,200
					Case CELL_INNER_WALL1
						SetColor 200,100,100
					Case CELL_OUTER_COLUMN
						SetColor 200,0,200 
					Case CELL_INNER_WALL2
						SetColor 100,100,200
					Case CELL_EXIT
						SetColor 100,200,100
				End Select

				DrawRect x*12,y*12,11,11
			Next
		Next
	End Method
End Type

#WorldData
DefData 24,24
DefData 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,2,2,2,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1
DefData 1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1
DefData 1,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
DefData 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
</textarea> <br><br></td></tr></table><br>
<a name="853473"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >daaan</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> @QuietBloke - Good find. That's a pretty fast raycaster. If it had textured walls with floor and ceiling it would stellar.<br><br>It would be impressive to add HDR lighting and depth of field to a raycaster. We'll seeeee :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
