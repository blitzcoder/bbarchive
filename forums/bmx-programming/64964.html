<!DOCTYPE html><html lang="en" ><head ><title >MemCopy() faster than slice.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >MemCopy() faster than slice.</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >MemCopy() faster than slice.</a><br><br>
<a name="725167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Early tests have shown memcopy() to be faster than slice when downsizing an array. <br><br>In the test code I create an array large enough to hold the max # of elements of a list. Then I loop through the list and add objects that meet a pre-defined condition (in this case it's a hash table and only objects with the given entry name are inserted into the array). Given that there may be empty elements at the end of the array (if one or more of the condition tests failed), I keep track of the actual insertions into the array and then downsize the array to that number. <br><br>These are the two approaches I tested to handle resizing the array.<br><pre class=code>
'approach 1
MemCopy( retarray, retarray, SizeOf(retarray[0]) * objectcount)

'approach 2
retarray = retarray[..objectcount]
</pre><br><br>retarray is an array of objects. It is initialized to a size &gt;= objectcount.<br><br>objectcount tracks the # of actual, filled elements in the array. <br><br>In my code there's no way to know beforehand how many elements will actually get filled. So the array might be initialized as "new object[500]", but then only get filled with 300 entries. <br><br>The test shows that the MemCopy() approach is indeed faster. Not significantly faster, mind you. I'm getting approx 100-200 ms difference per 10,000 iterations of the above code. <br><br>As I mentioned, this example was tested with a hash table, and in my MUD server code I'll be accessing hash tables often enough that, despite the speed difference being small, it'll make a difference in the long run.<br><br>Just thought you might like to know. <br><br>(if anyone wants some code to run/test I can supply it.) <br><br></td></tr></table><br>
<a name="725193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Surely MemCopy is faster because it misses one of the most elemental points in BM:<br><br>Slice tells the GC which objects are not needed anymore if there are any in the sliced area.<br>MemCopy does not comunicate with the GC it is for unmanaged (the alloc commands or CStrings / WStrings) operations on memory blocks only.<br><br>So what you create in the end is a memory leak if you didn't clean the array before sizing it down. <br><br></td></tr></table><br>
<a name="725196"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, good point. :)<br><br>Okay, so I guess the fact that MemCopy is faster is relatively moot except for rare cases where you're downsizing an array and only removing elements that you *know* are empty.<br><br>Lucky for me, that's exactly what I'm doing. ;) It's actually (potentially, depending on my hash table size) a lot faster than looping through the table to get the correct # of elements and initiating the array to the 'correct' size. I kill an unnecessary loop and replace it with a fast MemCopy. <br><br></td></tr></table><br>
<a name="725224"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fabian.</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> MemCopy( retarray, retarray, SizeOf(retarray[0]) * objectcount) <br></div>If you copy from retarray to retarray, it will do nothing;-) <br><br></td></tr></table><br>
<a name="725227"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, all I was using it for really was to update the internal "length" field of the array. Come to think of it though, my tests weren't actually testing to see if it worked since the only time the array would be a smaller size than it's initialization size was during a hash collision with different names (multiple hash entries of the same name are no problem).<br><br>Come to think of it, I doubt that the length field is being updated anyways. Hmm, I'll have to tweak things a bit.<br><br>[edit] It'd be nice if I could just tweak the length parameter myself, although I understand why that's not possible ;). Maybe I'll just make a wrapper class that stores the length. <br><br></td></tr></table><br>
<a name="725232"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> If your only problem is the length, it isn't a problem.<br>Just keep a variable aside with your hash array and use that instead of the arrays length :) Or a HashTable class, which holds the array and the length used currently ^^ <br><br></td></tr></table><br>
<a name="725238"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, I can't really do that because what I'm doing is...well, in this particular hash table class I'm allowing multiple entries with the same name. So there might be 20 different calls to hash like so<br>Hash( "reusable key", rand(20 ))<br><br>The problem is in my lookup function that returns multiple entries for a given hash key. It returns all entries that have the name specified, so ReturnEntries( "reusable key" ) returns an array of objects that match that key. I can't simply assume that every entry in the same bucket that "reusable key" gets put in though, actually has a hash key of "reusable key." If there was a hash collision, some other entry or entries may be residing in the same bucket. <br><br>So in my ReturnEntries( key:string)  function I create an array of objects = to the # of items in the bucket, and then loop through an insert every entry that matches the key parameter. If there were any hash collisions though, the # of objects that gets inserted into the return array is going to be less than the actual array, hence my need to downsize the array.<br><br>I've been doing some more speed tests and the wrapper method is the fastest when there are few collisions and relatively few duplicate key entries per bucket. The slice method is almost as fast and is actually faster when there are a lot of duplicate key entries. The third method I've tested is to scan the list of entries for a given key, keep track of the count and then initialize the array to the proper size, and then re-scan the list and insert all the matching entries. The double "for each-in" loop though makes this the slowest method by far. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
