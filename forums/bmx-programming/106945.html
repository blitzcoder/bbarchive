<!DOCTYPE html><html lang="en" ><head ><title >Quake 1 BSP loading</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Quake 1 BSP loading</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Quake 1 BSP loading</a><br><br>
<a name="1320517"></a>

<a name="1320518"></a>

<a name="1320519"></a>

<a name="1320520"></a>

<a name="1320521"></a>

<a name="1320523"></a>

<a name="1320524"></a>

<a name="1320525"></a>

<a name="1320526"></a>

<a name="1320574"></a>

<a name="1320577"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Seeing as how loading Quake .MAP files turned out to be really hard: <a href="http://www.blitzbasic.com/Community/posts.php?topic=106944" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=106944</a><br>I decided to instead load the .BSP files.<br><br>I'm having some problems generating the vertices though.<br>The information seems to read correctly from the BSP but generating a mesh based on vertex data just gives me messed up mesh.<br>I'm guessing it's because the Vertex list order isn't correct and I'm supposed to use "Edges" and "Faces" but I'm having trouble understanding it...<br>This is what I've got so far:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict
Framework sidesign.minib3d

Graphics3D(DesktopWidth() * 0.7, DesktopHeight() * 0.7, 2)

Local camera:TCamera = CreateCamera()
MoveEntity(camera, 0, 0, -10)

AmbientLight(255, 255, 255)

Local testCube:TMesh = CreateCube()

Local myBSP:TQBSP = TQBSP.LoadFile("DM1.BSP")

'Debug make a mesh
Local mesh:TMesh = CreateMesh()
Local surf:TSurface = CreateSurface(mesh, Null)
Local nr:Int
Local vertNr:Int

For Local v:TQVertex = EachIn myBSP.Vertices
	surf.AddVertex(v.X, v.Y, v.Z)
	nr:+1
	
	If nr &gt;= 3 Then
		surf.AddTriangle(vertNr, vertNr + 1, vertNr + 2)
		vertNr:+nr
		nr = 0
	EndIf
Next

While Not AppTerminate() And Not KeyDown(KEY_ESCAPE)
	Cls()
	
	If KeyDown(KEY_LEFT) Then TurnEntity(camera, 0, 2, 0)
	If KeyDown(KEY_RIGHT) Then TurnEntity(camera, 0, -2, 0)
	If KeyDown(KEY_UP) Then TurnEntity(camera, -2, 0, 0)
	If KeyDown(KEY_DOWN) Then TurnEntity(camera, 2, 0, 0)
	
	If KeyDown(KEY_W) Then MoveEntity(camera, 0, 0, 1.5)
	If KeyDown(KEY_S) Then MoveEntity(camera, 0, 0, -1.5)
	If KeyDown(KEY_A) Then MoveEntity(camera, -1.5, 0, 0)
	If KeyDown(KEY_D) Then MoveEntity(camera, 1.5, 0, 0)
	
	If KeyDown(KEY_SPACE) Then MoveEntity(camera, 0, 1, 0)
	If KeyDown(KEY_LCONTROL) Then MoveEntity(camera, 0, -1, 0)
	
	RenderWorld()
	Flip(1)
Wend
End

Type TQBSP
	Field File:String
	Field Stream:TStream
	
	Field Header:TQHeader
	
	Field Vertices:TList = CreateList()
	
	Function LoadFile:TQBSP(url:String)
		Local nB:TQBSP = New TQBSP
		nB.File = url
		
		If nB.Process() Then
			Return nB
		Else
			nB.StreamError("Map ~q" + nB.file + "~q NOT loaded")
			Return Null
		EndIf
	EndFunction
	
	Method StreamError(MSG:String)
		If Stream Then CloseStream(Stream)
		Print "Read error: " + MSG
	EndMethod
	
	Method Process:Int()
		Stream = OpenStream(File)
		If Not Stream Then
			StreamError("Unable to read file ~q" + file + "~q")
			Return False
		EndIf
		
		'Read header
		Self.Header = TQHeader.Read(Stream)
		
		Local num:Int
		'Try reading vertices
		num = Self.Header.Vertices.Count(SizeOf(TQVertex)) 'First we count how many there are
		Print "Vertices: " + num 'Output
		Self.Header.Vertices.JumpTo(Stream) 'Then we jump to the correct position
		For Local i:Int = 0 Until num 'Add them all to our list
			ListAddLast(Self.Vertices, TQVertex.Read(Stream))
		Next
		
		CloseStream(Stream)
		Return True
	EndMethod
EndType

'http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm
'char 8bit = negative byte
'u_char 8bit = byte
'short 16bit = negative short
'u_short 16bit = short
'long 32bit = int
'u_long 32bit = longer int
'float 32bit = float
'scalar_t 32bit = float

Type TQHeader
	Field Version:Int
	Field Entities:TQEntry
	Field PLANES:TQEntry
	Field MipTex:TQEntry
	Field Vertices:TQEntry
	Field VisiList:TQEntry
	Field Nodes:TQEntry
	Field TexInfo:TQEntry
	Field Faces:TQEntry
	Field LightMaps:TQEntry
	Field ClipNodes:TQEntry
	Field Leaves:TQEntry
	Field LFace:TQEntry
	Field Edges:TQEntry
	Field Ledges:TQEntry
	Field Models:TQEntry
	
	Function Read:TQHeader(Stream:TStream)
		Local nH:TQHeader = New TQHeader
		
		nH.Version = Stream.ReadInt()
		If nH.Version = "29" Then
			Print "Correct BSP version (" + nH.Version + ")"
		Else
			Print "Warning: Wrong BSP version (" + nH.Version + ")"
		EndIf
		
		nH.Entities = TQEntry.Read(Stream)
		nH.PLANES = TQEntry.Read(Stream)
		
		nH.MipTex = TQEntry.Read(Stream)
		nH.Vertices = TQEntry.Read(Stream)
		
		nH.VisiList = TQEntry.Read(Stream)
		nH.Nodes = TQEntry.Read(Stream)
		
		nH.TexInfo = TQEntry.Read(Stream)
		
		nH.Faces = TQEntry.Read(Stream)
		
		nH.LightMaps = TQEntry.Read(Stream)
		nH.ClipNodes = TQEntry.Read(Stream)
		
		nH.Leaves = TQEntry.Read(Stream)
		
		nH.LFace = TQEntry.Read(Stream)
		nH.Edges = TQEntry.Read(Stream)
		
		nH.Ledges = TQEntry.Read(Stream)
		nH.Models = TQEntry.Read(Stream)
		
		Return nH
	EndFunction
EndType

Type TQModel
	Field Bound:TQBoundBox
	Field Origin:TQVec3
	Field Node_ID0:Int
	Field Node_ID1:Int
	Field Node_ID2:Int
	Field Node_ID3:Int
	Field NumLeafs:Int
	Field Face_ID:Int
	Field Face_Num:Int
	
	Function Read:TQModel(Stream:TStream)
		Local nM:TQModel = New TQModel
		nM.Bound = TQBoundBox.Read(Stream)
		nM.Origin = TQVec3.Read(Stream)
		nM.Node_ID0 = ReadInt(Stream)
		nM.Node_ID1 = ReadInt(Stream)
		nM.Node_ID2 = ReadInt(Stream)
		nM.Node_ID3 = ReadInt(Stream)
		nM.NumLeafs = ReadInt(Stream)
		nM.Face_ID = ReadInt(Stream)
		nM.Face_Num = ReadInt(Stream)
		Return nM
	EndFunction
EndType

Type TQVertex
	Field X:Float
	Field Y:Float
	Field Z:Float
	
	Function Read:TQVertex(Stream:TStream)
		Local nV:TQVertex = New TQVertex
		nV.Z = ReadFloat(Stream)
		nV.X = ReadFloat(Stream)
		nV.Y = ReadFloat(Stream)
		
		Return nV
	EndFunction
EndType

Type TQSurface
	Field VectorS:TQVec3
	Field DistS:Float
	Field VectorT:TQVec3
	Field DistT:Float
	Field Texture_ID:Int
	
	Field Animated:Int
	
	Function Read:TQSurface(Stream:TStream)
		Local nS:TQSurface = New TQSurface
		nS.VectorS = TQVec3.Read(Stream)
		nS.DistS = ReadFloat(Stream)
		nS.VectorT = TQVec3.Read(Stream)
		nS.DistT = ReadFloat(Stream)
		nS.Texture_ID = ReadInt(Stream)
		nS.Animated = ReadInt(Stream)
		Return nS
	EndFunction
EndType

Type TQEdge
	Field Vertex0:Short
	Field Vertex1:Short
	
	Function Read:TQEdge(Stream:TStream)
		Local nE:TQEdge = New TQEdge
		nE.Vertex0 = ReadShort(Stream)
		nE.Vertex1 = ReadShort(Stream)
		Return nE
	EndFunction
EndType

Type TQFace
	Field Plane_ID:Short
	
	Field Side:Short
	Field Ledge_ID:Int
	
	Field Ledge_Num:Short
	Field TexInfo_ID:Short
	
	Field TypeLight:Byte
	Field BaseLight:Byte
	Field Light:Byte[2]
	Field LightMap:Int
	
	Function Read:TQFace(Stream:TStream)
		Local nF:TQFace = New TQFace
		nF.Plane_ID = ReadShort(Stream)
		nF.Side = ReadShort(Stream)
		nF.Ledge_ID = ReadInt(Stream)
		nF.Ledge_Num = ReadShort(Stream)
		nF.TexInfo_ID = ReadShort(Stream)
		nF.TypeLight = ReadByte(Stream)
		nF.BaseLight = ReadByte(Stream)
		nF.Light[0] = ReadByte(Stream)
		nF.Light[1] = ReadByte(Stream)
		nF.LightMap = ReadInt(Stream)
		Return nF
	EndFunction
EndType

Type TQMipHeader
	Field NumTex:Int
	Field Offset:Int[]
	
	Function Read:TQMipHeader(Stream:TStream)
		Local nM:TQMipHeader = New TQMipHeader
		nM.NumTex = ReadInt(Stream)
		nM.Offset = New Int[nM.NumTex]
		'Not sure about reading the Offset...
		
		Return nM
	EndFunction
EndType

Type TQMipTex
	'Field Name:Byte[16]
	Field Name:String
	Field width:Int
	Field Height:Int
	Field Offset1:Int
	Field Offset2:Int
	Field Offset4:Int
	Field Offset8:Int
	
	Function Read:TQMipTex(Stream:TStream)
		Local nM:TQMipTex = New TQMipTex
		'nM.Name = ReadInt(Stream)
		nM.Name = ReadString(Stream, 16)
		nM.width = ReadInt(Stream)
		nM.Height = ReadInt(Stream)
		nM.Offset1 = ReadInt(Stream)
		nM.Offset2 = ReadInt(Stream)
		nM.Offset4 = ReadInt(Stream)
		nM.Offset8 = ReadInt(Stream)
		Return nM
	EndFunction
EndType

Type TQEntry
	Field Offset:Int
	Field Size:Int
	
	Function Read:TQEntry(Stream:TStream)
		Local nE:TQEntry = New TQEntry
		nE.Offset = ReadInt(Stream)
		nE.Size = ReadInt(Stream)
		Return nE
	EndFunction
	
	Method Count:Int(typeSize:Int)
		Return Size / typeSize
	EndMethod
	
	Method JumpTo(Stream:TStream)
		Stream.Seek(Self.Offset)
	EndMethod
EndType

Type TQNode
	Field Plane_ID:Int
	
	Field Front:Short
	
	Field Back:Short
	
	Field Box:TQBBoxShort
	Field Face_ID:Short
	Field Face_Num:Short
	
	Function Read:TQNode(Stream:TStream)
		Local nN:TQNode = New TQNode
		nN.Plane_ID = ReadInt(Stream)
		nN.Front = ReadShort(Stream)
		nN.Back = ReadShort(Stream)
		nN.Box = TQBBoxShort.Read(Stream)
		nN.Face_ID = ReadShort(Stream)
		nN.Face_Num = ReadShort(Stream)
		Return nN
	EndFunction
EndType

Type TQDLeaf
	Field Typ:Int
	Field VisList:Int
	
	Field Bound:TQBBoxShort
	Field LFace_ID:Short
	
	Field LFace_Num:Short
	Field SndWater:Byte
	Field SndSky:Byte
	Field SndSlime:Byte
	Field SndLava:Byte
	
	Function Read:TQDLeaf(Stream:TStream)
		Local nD:TQDLeaf = New TQDLeaf
		nD.Typ = ReadInt(Stream)
		nD.VisList = ReadInt(Stream)
		
		nD.Bound = TQBBoxShort.Read(Stream)
		nD.LFace_ID = ReadShort(Stream)
		
		nD.LFace_Num = ReadShort(Stream)
		nD.SndWater = ReadByte(Stream)
		nD.SndSky = ReadByte(Stream)
		nD.SndSlime = ReadByte(Stream)
		nD.SndLava = ReadByte(Stream)
		Return nD
	EndFunction
EndType

Type TQPlane
	Field Normal:TQVec3
	
	Field Dist:Float
	
	Field Typ:Int
	
	Function Read:TQPlane(Stream:TStream)
		Local nP:TQPlane = New TQPlane
		nP.Normal = TQVec3.Read(Stream)
		nP.Dist = ReadFloat(Stream)
		nP.Typ = ReadInt(Stream)
		Return nP
	EndFunction
EndType

Type TQClipNode
	Field PlaneNum:Int
	Field Front:Short
	
	Field Back:Short
	
	Function Read:TQClipNode(Stream:TStream)
		Local nC:TQClipNode = New TQClipNode
		nC.PlaneNum = ReadInt(Stream)
		nC.Front = ReadShort(Stream)
		nC.Back = ReadShort(Stream)
		Return nC
	EndFunction
EndType

'Basic types
Type TQVec3
	Field X:Float
	Field Y:Float
	Field Z:Float
	
	Function Read:TQVec3(Stream:TStream)
		Local nV:TQVec3 = New TQVec3
		nV.X = ReadFloat(Stream)
		nV.Y = ReadFloat(Stream)
		nV.Z = ReadFloat(Stream)
		Return nV
	EndFunction
EndType

Type TQBoundBox
	Field Minimum:TQVec3
	Field Maximum:TQVec3
	
	Function Read:TQBoundBox(Stream:TStream)
		Local nB:TQBoundBox = New TQBoundBox
		nB.Minimum = TQVec3.Read(Stream)
		nB.Maximum = TQVec3.Read(Stream)
		Return nB
	EndFunction
EndType

Type TQBBoxShort
	Field Minimum:TQVec3
	Field Maximum:TQVec3
	
	Function Read:TQBBoxShort(Stream:TStream)
		Local nB:TQBBoxShort = New TQBBoxShort
		nB.Minimum = TQVec3.Read(Stream)
		nB.Maximum = TQVec3.Read(Stream)
		Return nB
	EndFunction
EndType</textarea><br><br>If you look to the right you'll see this mess<br><img src="https://dl.dropboxusercontent.com/u/2842751/weird_mesh.jpg"><br><br>The specs can be found at: <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm" target="_blank">http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm</a><br>BSP file from Quake 1: <a href="https://dl.dropboxusercontent.com/u/2842751/DM1.BSP" target="_blank">https://dl.dropboxusercontent.com/u/2842751/DM1.BSP</a> <br><br></td></tr></table><br>
<a name="1320537"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> That particular map format uses plane equations.  I think it provides three vertices you construct a plane from.  You then have to calculate the convex volume defined by that list of planes.  It's complicated and prone to errors, which is why maps can sometimes become messed up in the original tools. <br><br></td></tr></table><br>
<a name="1320545"></a>

<a name="1320546"></a>

<a name="1320550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Hekzore, this is where looking at previous work can help.<br>I searched for "BSP loader github" on Google and found this:<br><a href="https://github.com/mikezila/uQuake1" target="_blank">https://github.com/mikezila/uQuake1</a><br><br>According to the specification, vertices form edges, the edges form faces.<br>To associate a face with its vertices you need to look at the edges. Some faces may use the same edge index (meaning, they have an edge in common), so the order of the vertices in an edge is given by <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm#BLD" target="_blank">the sign of the edge index</a> in the global edge list.<br><br>Interesting points in that importer:<br>- <a href="https://github.com/mikezila/uQuake1/blob/master/Assets/Scripts/uQuake1/BSP29map.cs#L21" target="_blank">https://github.com/mikezila/uQuake1/blob/master/Assets/Scripts/uQuake1/BSP29map.cs#L21</a> (Loading data)<br>- <a href="https://github.com/mikezila/uQuake1/blob/master/Assets/Scripts/uQuake1/GenerateMap.cs#L65" target="_blank">https://github.com/mikezila/uQuake1/blob/master/Assets/Scripts/uQuake1/GenerateMap.cs#L65</a> (Making the mesh) <br><br></td></tr></table><br>
<a name="1320568"></a>

<a name="1320569"></a>

<a name="1320570"></a>

<a name="1320571"></a>

<a name="1320572"></a>

<a name="1320573"></a>

<a name="1320575"></a>

<a name="1320576"></a>

<a name="1320578"></a>

<a name="1320579"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah thanks Kyrzon, that helped a bit.<br><br>Right now the problem is that I don't understand how Faces specifies the Edges it uses.<br>My understanding (based on this: <a href="http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm" target="_blank">qkspec_4.htm</a>) is that Faces uses its ledge_id to specify the starting Edge I should read and then continue forward to ledge_id + ledge_num.<br>But there are a total of 5688 Edges in the BSP I posted above, and if I go through the Faces that way they request Edges as high as 11370!<br>Here's an example (Run in debug mode and check console)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict
Framework sidesign.minib3d 'https://github.com/si-design/minib3d

'Data sizes
Const B_BYTE:Int = 1
Const B_SHORT:Int = 2
Const B_INT:Int = 4
Const B_FLOAT:Int = 4

Graphics3D(DesktopWidth() * 0.7, DesktopHeight() * 0.7, 2)

Local camera:TCamera = CreateCamera()
MoveEntity(camera, 0, 0, -10)

AmbientLight(255, 255, 255)

Local testCube:TMesh = CreateCube()

Local myBSP:TQBSP = TQBSP.LoadFile("DM1.BSP")

'Debug make a mesh
'Local mesh:TMesh = CreateMesh()
'Local surf:TSurface = CreateSurface(mesh, Null)

Local highRequestID:Int

For Local m:TQModel = EachIn myBSP.Models
	Local face:TQFace
	For Local fNr:Int = m.Face_ID Until m.Face_ID + m.Face_Num
		face = TQFace(myBSP.Faces.ValueAtIndex(fNr))
		If face.Ledge_ID &gt; highRequestID Then highRequestID = face.Ledge_ID
	Next
Next
Print "Highest requested Edge ID: " + highRequestID

While Not AppTerminate() And Not KeyDown(KEY_ESCAPE)
	Cls()
	
	If KeyDown(KEY_LEFT) Then TurnEntity(camera, 0, 2, 0)
	If KeyDown(KEY_RIGHT) Then TurnEntity(camera, 0, -2, 0)
	If KeyDown(KEY_UP) Then TurnEntity(camera, -2, 0, 0)
	If KeyDown(KEY_DOWN) Then TurnEntity(camera, 2, 0, 0)
	
	If KeyDown(KEY_W) Then MoveEntity(camera, 0, 0, 1.5)
	If KeyDown(KEY_S) Then MoveEntity(camera, 0, 0, -1.5)
	If KeyDown(KEY_A) Then MoveEntity(camera, -1.5, 0, 0)
	If KeyDown(KEY_D) Then MoveEntity(camera, 1.5, 0, 0)
	
	If KeyDown(KEY_SPACE) Then MoveEntity(camera, 0, 1, 0)
	If KeyDown(KEY_LCONTROL) Then MoveEntity(camera, 0, -1, 0)
	
	RenderWorld()
	Flip(1)
Wend
End

Type TQBSP
	Field File:String
	Field Stream:TStream
	
	Field Header:TQHeader
	
	Field PLANES:TList = CreateList()
	Field Vertices:TList = CreateList()
	Field Nodes:TList = CreateList()
	Field TexInfo:TList = CreateList()
	Field Faces:TList = CreateList()
	Field ClipNodes:TList = CreateList()
	Field Leaves:TList = CreateList()
	Field Edges:TList = CreateList()
	Field Models:TList = CreateList()
	
	Function LoadFile:TQBSP(url:String)
		Local nB:TQBSP = New TQBSP
		nB.File = url
		
		If nB.Process() Then
			Return nB
		Else
			nB.StreamError("Map ~q" + nB.file + "~q NOT loaded")
			Return Null
		EndIf
	EndFunction
	
	Method StreamError(MSG:String)
		If Stream Then CloseStream(Stream)
		Print "Read error: " + MSG
	EndMethod
	
	Method Process:Int()
		Stream = OpenStream(File)
		If Not Stream Then
			StreamError("Unable to read file ~q" + file + "~q")
			Return False
		EndIf
		
		Local num:Int 'For counting stuff
		Local i:Int 'For loops
		
		'Read header
		Self.Header = TQHeader.Read(Stream)
		
		'Read planes
		'num = Self.Header.PLANES.Count(TQPlane.Size())
		'DebugLog "Planes: " + num
		'Self.Header.PLANES.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.PLANES, TQPlane.Read(Stream))
		'Next
		
		'Read vertices
		num = Self.Header.Vertices.Count(TQVertex.Size())
		DebugLog "Vertices: " + num
		Self.Header.Vertices.JumpTo(Stream)
		For i = 0 Until num
			ListAddLast(Self.Vertices, TQVertex.Read(Stream))
		Next
		
		'Read nodes
		'num = Self.Header.Nodes.Count(TQNode.Size())
		'DebugLog "Nodes: " + num
		'Self.Header.Nodes.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.Nodes, TQNode.Read(Stream))
		'Next
		
		'Read texture info
		num = Self.Header.TexInfo.Count(TQSurface.Size())
		DebugLog "TexInfos: " + num
		Self.Header.TexInfo.JumpTo(Stream)
		For i = 0 Until num
			ListAddLast(Self.TexInfo, TQSurface.Read(Stream))
		Next
		
		'Read faces
		num = Self.Header.Faces.Count(TQFace.Size())
		DebugLog "Faces: " + num
		Self.Header.Faces.JumpTo(Stream)
		For i = 0 Until num
			ListAddLast(Self.Faces, TQFace.Read(Stream))
		Next
		
		'Read clipnodes
		'num = Self.Header.ClipNodes.Count(TQClipNode.Size())
		'DebugLog "ClipNodes: " + num
		'Self.Header.ClipNodes.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.ClipNodes, TQClipNode.Read(Stream))
		'Next
		
		'Read leaves
		'num = Self.Header.Leaves.Count(TQDLeaf.Size())
		'DebugLog "Leaves: " + num
		'Self.Header.Leaves.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.Leaves, TQDLeaf.Read(Stream))
		'Next
		
		'Read edges
		num = Self.Header.Edges.Count(TQEdge.Size())
		DebugLog "Edges: " + num
		Self.Header.Edges.JumpTo(Stream)
		For i = 0 Until num
			ListAddLast(Self.Edges, TQEdge.Read(Stream))
		Next
		
		'Read models
		num = Self.Header.Models.Count(TQModel.Size())
		DebugLog "Models: " + num
		Self.Header.Models.JumpTo(Stream)
		For i = 0 Until num
			ListAddLast(Self.Models, TQModel.Read(Stream))
		Next
		
		CloseStream(Stream)
		Return True
	EndMethod
EndType

'http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm
'char 8bit = negative byte
'u_char 8bit = byte
'short 16bit = negative short
'u_short 16bit = short
'long 32bit = int
'u_long 32bit = longer int
'float 32bit = float
'scalar_t 32bit = float

Type TQHeader
	Field Version:Int
	Field Entities:TQEntry
	Field PLANES:TQEntry
	Field MipTex:TQEntry
	Field Vertices:TQEntry
	Field VisiList:TQEntry
	Field Nodes:TQEntry
	Field TexInfo:TQEntry
	Field Faces:TQEntry
	Field LightMaps:TQEntry
	Field ClipNodes:TQEntry
	Field Leaves:TQEntry
	Field LFace:TQEntry
	Field Edges:TQEntry
	Field Ledges:TQEntry
	Field Models:TQEntry
	
	Function Read:TQHeader(Stream:TStream)
		Local nH:TQHeader = New TQHeader
		
		nH.Version = ReadInt(Stream)
		If nH.Version = "29" Then
			Print "Correct BSP version (" + nH.Version + ")"
		Else
			Print "Warning: Wrong BSP version (" + nH.Version + ")"
		EndIf
		
		nH.Entities = TQEntry.Read(Stream)
		nH.PLANES = TQEntry.Read(Stream)
		
		nH.MipTex = TQEntry.Read(Stream)
		nH.Vertices = TQEntry.Read(Stream)
		
		nH.VisiList = TQEntry.Read(Stream)
		nH.Nodes = TQEntry.Read(Stream)
		
		nH.TexInfo = TQEntry.Read(Stream)
		
		nH.Faces = TQEntry.Read(Stream)
		
		nH.LightMaps = TQEntry.Read(Stream)
		nH.ClipNodes = TQEntry.Read(Stream)
		
		nH.Leaves = TQEntry.Read(Stream)
		
		nH.LFace = TQEntry.Read(Stream)
		nH.Edges = TQEntry.Read(Stream)
		
		nH.Ledges = TQEntry.Read(Stream)
		nH.Models = TQEntry.Read(Stream)
		
		Return nH
	EndFunction
EndType

Type TQModel
	Field Bound:TQBoundBox
	Field Origin:TQVec3
	Field Node_ID0:Int
	Field Node_ID1:Int
	Field Node_ID2:Int
	Field Node_ID3:Int
	Field NumLeafs:Int
	Field Face_ID:Int
	Field Face_Num:Int
	
	Function Read:TQModel(Stream:TStream)
		Local nM:TQModel = New TQModel
		nM.Bound = TQBoundBox.Read(Stream)
		nM.Origin = TQVec3.Read(Stream)
		nM.Node_ID0 = ReadInt(Stream)
		nM.Node_ID1 = ReadInt(Stream)
		nM.Node_ID2 = ReadInt(Stream)
		nM.Node_ID3 = ReadInt(Stream)
		nM.NumLeafs = ReadInt(Stream)
		nM.Face_ID = ReadInt(Stream)
		nM.Face_Num = ReadInt(Stream)
		Return nM
	EndFunction
	
	Function Size:Int()
		Return (B_INT * 7) + TQBoundBox.Size() + TQVec3.Size()
	EndFunction
EndType

Type TQVertex
	Field X:Float
	Field Y:Float
	Field Z:Float
	
	Function Read:TQVertex(Stream:TStream)
		Local nV:TQVertex = New TQVertex
		nV.Z = ReadFloat(Stream)
		nV.X = ReadFloat(Stream)
		nV.Y = ReadFloat(Stream)
		
		Return nV
	EndFunction
	
	Function Size:Int()
		Return B_FLOAT * 3
	EndFunction
EndType

Type TQSurface
	Field VectorS:TQVec3
	Field DistS:Float
	Field VectorT:TQVec3
	Field DistT:Float
	Field Texture_ID:Int
	
	Field Animated:Int
	
	Function Read:TQSurface(Stream:TStream)
		Local nS:TQSurface = New TQSurface
		nS.VectorS = TQVec3.Read(Stream)
		nS.DistS = ReadFloat(Stream)
		nS.VectorT = TQVec3.Read(Stream)
		nS.DistT = ReadFloat(Stream)
		nS.Texture_ID = ReadInt(Stream)
		nS.Animated = ReadInt(Stream)
		Return nS
	EndFunction
	
	Function Size:Int()
		Return (B_FLOAT * 2) + (B_INT * 2) + (TQVec3.Size() * 2)
	EndFunction
EndType

Type TQEdge
	Field Vertex0:Short
	Field Vertex1:Short
	
	Function Read:TQEdge(Stream:TStream)
		Local nE:TQEdge = New TQEdge
		nE.Vertex0 = ReadShort(Stream)
		nE.Vertex1 = ReadShort(Stream)
		Return nE
	EndFunction
	
	Function Size:Int()
		Return B_SHORT * 2
	EndFunction
EndType

Type TQFace
	Field Plane_ID:Short
	
	Field Side:Short
	Field Ledge_ID:Int
	
	Field Ledge_Num:Short
	Field TexInfo_ID:Short
	
	Field TypeLight:Byte
	Field BaseLight:Byte
	Field Light:Byte[2]
	Field LightMap:Int
	
	Function Read:TQFace(Stream:TStream)
		Local nF:TQFace = New TQFace
		nF.Plane_ID = ReadShort(Stream)
		nF.Side = ReadShort(Stream)
		nF.Ledge_ID = ReadInt(Stream)
		nF.Ledge_Num = ReadShort(Stream)
		nF.TexInfo_ID = ReadShort(Stream)
		nF.TypeLight = ReadByte(Stream)
		nF.BaseLight = ReadByte(Stream)
		nF.Light[0] = ReadByte(Stream)
		nF.Light[1] = ReadByte(Stream)
		nF.LightMap = ReadInt(Stream)
		Return nF
	EndFunction
	
	Function Size:Int()
		Return (B_SHORT * 4) + (B_INT * 2) + (B_BYTE * 4)
	EndFunction
EndType

Type TQMipHeader
	Field NumTex:Int
	Field Offset:Int[]
	
	Function Read:TQMipHeader(Stream:TStream)
		Local nM:TQMipHeader = New TQMipHeader
		nM.NumTex = ReadInt(Stream)
		
		'Should I even read this?
		nM.Offset = New Int[nM.NumTex]
		For Local i:Int = 0 Until nM.NumTex
			nM.Offset[i] = ReadInt(Stream)
		Next
		Return nM
	EndFunction
EndType

Type TQMipTex
	Field Name:String
	Field width:Int
	Field Height:Int
	Field Offset1:Int
	Field Offset2:Int
	Field Offset4:Int
	Field Offset8:Int
	
	Function Read:TQMipTex(Stream:TStream)
		Local nM:TQMipTex = New TQMipTex
		For Local i:Int = 0 Until 16
			nM.Name:+Chr(ReadByte(Stream))
		Next
		nM.width = ReadInt(Stream)
		nM.Height = ReadInt(Stream)
		nM.Offset1 = ReadInt(Stream)
		nM.Offset2 = ReadInt(Stream)
		nM.Offset4 = ReadInt(Stream)
		nM.Offset8 = ReadInt(Stream)
		Return nM
	EndFunction
	
	Function Size:Int()
		Return (B_BYTE * 16) + (B_INT * 6)
	EndFunction
EndType

Type TQEntry
	Field Offset:Int
	Field Size:Int
	
	Function Read:TQEntry(Stream:TStream)
		Local nE:TQEntry = New TQEntry
		nE.Offset = ReadInt(Stream)
		nE.Size = ReadInt(Stream)
		Return nE
	EndFunction
	
	Method Count:Int(typeSize:Int)
		Return Size / typeSize
	EndMethod
	
	Method JumpTo(Stream:TStream)
		Stream.Seek(Self.Offset)
	EndMethod
EndType

Type TQNode
	Field Plane_ID:Int
	
	Field Front:Short
	
	Field Back:Short
	
	Field Box:TQBBoxShort
	Field Face_ID:Short
	Field Face_Num:Short
	
	Function Read:TQNode(Stream:TStream)
		Local nN:TQNode = New TQNode
		nN.Plane_ID = ReadInt(Stream)
		nN.Front = ReadShort(Stream)
		nN.Back = ReadShort(Stream)
		nN.Box = TQBBoxShort.Read(Stream)
		nN.Face_ID = ReadShort(Stream)
		nN.Face_Num = ReadShort(Stream)
		Return nN
	EndFunction
EndType

Type TQDLeaf
	Field Typ:Int
	Field VisList:Int
	
	Field Bound:TQBBoxShort
	Field LFace_ID:Short
	
	Field LFace_Num:Short
	Field SndWater:Byte
	Field SndSky:Byte
	Field SndSlime:Byte
	Field SndLava:Byte
	
	Function Read:TQDLeaf(Stream:TStream)
		Local nD:TQDLeaf = New TQDLeaf
		nD.Typ = ReadInt(Stream)
		nD.VisList = ReadInt(Stream)
		
		nD.Bound = TQBBoxShort.Read(Stream)
		nD.LFace_ID = ReadShort(Stream)
		
		nD.LFace_Num = ReadShort(Stream)
		nD.SndWater = ReadByte(Stream)
		nD.SndSky = ReadByte(Stream)
		nD.SndSlime = ReadByte(Stream)
		nD.SndLava = ReadByte(Stream)
		Return nD
	EndFunction
EndType

Type TQPlane
	Field Normal:TQVec3
	
	Field Dist:Float
	
	Field Typ:Int
	
	Function Read:TQPlane(Stream:TStream)
		Local nP:TQPlane = New TQPlane
		nP.Normal = TQVec3.Read(Stream)
		nP.Dist = ReadFloat(Stream)
		nP.Typ = ReadInt(Stream)
		Return nP
	EndFunction
EndType

Type TQClipNode
	Field PlaneNum:Int
	Field Front:Short
	
	Field Back:Short
	
	Function Read:TQClipNode(Stream:TStream)
		Local nC:TQClipNode = New TQClipNode
		nC.PlaneNum = ReadInt(Stream)
		nC.Front = ReadShort(Stream)
		nC.Back = ReadShort(Stream)
		Return nC
	EndFunction
EndType

'Basic types
Type TQVec3
	Field X:Float
	Field Y:Float
	Field Z:Float
	
	Function Read:TQVec3(Stream:TStream)
		Local nV:TQVec3 = New TQVec3
		nV.X = ReadFloat(Stream)
		nV.Y = ReadFloat(Stream)
		nV.Z = ReadFloat(Stream)
		Return nV
	EndFunction
	
	Function Size:Int()
		Return B_FLOAT * 3
	EndFunction
EndType

Type TQBoundBox
	Field Minimum:TQVec3
	Field Maximum:TQVec3
	
	Function Read:TQBoundBox(Stream:TStream)
		Local nB:TQBoundBox = New TQBoundBox
		nB.Minimum = TQVec3.Read(Stream)
		nB.Maximum = TQVec3.Read(Stream)
		Return nB
	EndFunction
	
	Function Size:Int()
			Return TQVec3.Size() * 2
	EndFunction
EndType

Type TQBBoxShort
	Field Minimum:Short
	Field Maximum:Short
	
	Function Read:TQBBoxShort(Stream:TStream)
		Local nB:TQBBoxShort = New TQBBoxShort
		nB.Minimum = ReadShort(Stream)
		nB.Maximum = ReadShort(Stream)
		Return nB
	EndFunction
	
	Function Size:Int()
		Return B_SHORT * 2
	EndFunction
EndType</textarea><br><br>Here's a version that doesn't use MiniB3D so you can try it without any extra modules.<br>Just paste this into BMax and run in debug: <a href="http://pastebin.com/raw/5fTsHxvi" target="_blank">http://pastebin.com/raw/5fTsHxvi</a><br><br>BSP file from Quake 1: <a href="https://dl.dropboxusercontent.com/u/2842751/DM1.BSP" target="_blank">https://dl.dropboxusercontent.com/u/2842751/DM1.BSP</a> <br><br></td></tr></table><br>
<a name="1320581"></a>

<a name="1320582"></a>

<a name="1320583"></a>

<a name="1320584"></a>

<a name="1320585"></a>

<a name="1320586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay I've had some progress!<br>I figured out that there's a LEdge type too that tells me what Edge to use.<br>I've gotten to the point where I can actually read Vertex data now, but I'm still really confused as to why there's two Vertices in an Edge and how to generate the mesh.<br><br>Here's the new code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict
Framework sidesign.minib3d 'https://github.com/si-design/minib3d
Import brl.Stream
Import brl.linkedlist
Import brl.standardio

'Data sizes
Const B_BYTE:Int = 1
Const B_SHORT:Int = 2
Const B_INT:Int = 4
Const B_FLOAT:Int = 4

Graphics3D(DesktopWidth() * 0.7, DesktopHeight() * 0.7, 0, 2)

Local camera:TCamera = CreateCamera()
MoveEntity(camera, 0, 0, -10)

AmbientLight(255, 255, 255)

Local myBSP:TQBSP = TQBSP.LoadFile("DM1.BSP")

'Debug make a mesh
Local mesh:TMesh = CreateMesh()
Local surf:TSurface[8]

Local face:TQFace
Local ledge:TQLedge
Local edge:TQEdge
Local vert:TQVertex
Local fNr:Int
Local vNr:Int
Local surfNr:Int
Local vertCount:Int
Local newVertCount:Int

For Local model:TQModel = EachIn myBSP.Models 'Go through models
	For fNr = model.Face_ID Until model.Face_ID + model.Face_Num 'Go through faces
		'Debug progress
		'If fNr Mod 100 &lt;= 0 Then Print "Generating: " + fNr + "/" + model.Face_Num
		face = myBSP.Faces[fNr] 'Get current face
		
        'Move to next surface if we're using too many vertices
        If surf[surfNr] And surf[surfNr].CountVertices() &gt; (10000 * 3) - 1 Then surfNr:+1
		
        'If we don't have a surface to work with, create one
        If Not surf[surfNr] Then surf[surfNr] = CreateSurface(mesh, Null)
		
		'Get verts
		newVertCount = 0
		For vNr = face.Ledge_ID Until face.Ledge_ID + face.Ledge_Num 'Go through edges
			ledge = myBSP.Ledges[vNr] 'Get ledge
			edge = myBSP.Edges[Abs(ledge.edge)] 'Get edge via ledge
			
			If ledge.edge &lt; 0 Then
				vert = myBSP.Vertices[edge.Vertex0]
			Else
				vert = myBSP.Vertices[edge.Vertex1]
			EndIf
			
			AddVertex(surf[surfNr], vert.X * 0.1, vert.Y * 0.1, vert.Z * 0.1)
			vertCount:+1
			newVertCount:+1
		Next
		
		'Make Tris
		For Local i:Int = vertCount - newVertCount Until vertCount
			AddTriangle(surf[surfNr], i, i + 1, i + 2)
		Next
		
	Next
Next

'Main loop
While Not AppTerminate() And Not KeyDown(KEY_ESCAPE)
	'Cls()
	If KeyHit(KEY_O) Then Wireframe(False)
	If KeyHit(KEY_P) Then Wireframe(True)
	
	If KeyDown(KEY_LEFT) Then TurnEntity(camera, 0, 2, 0)
	If KeyDown(KEY_RIGHT) Then TurnEntity(camera, 0, -2, 0)
	If KeyDown(KEY_UP) Then TurnEntity(camera, -2, 0, 0)
	If KeyDown(KEY_DOWN) Then TurnEntity(camera, 2, 0, 0)
	
	If KeyDown(KEY_W) Then MoveEntity(camera, 0, 0, 1.5)
	If KeyDown(KEY_S) Then MoveEntity(camera, 0, 0, -1.5)
	If KeyDown(KEY_A) Then MoveEntity(camera, -1.5, 0, 0)
	If KeyDown(KEY_D) Then MoveEntity(camera, 1.5, 0, 0)
	
	If KeyDown(KEY_SPACE) Then MoveEntity(camera, 0, 1, 0)
	If KeyDown(KEY_LCONTROL) Then MoveEntity(camera, 0, -1, 0)
	
	RenderWorld()
	Flip(1)
Wend
End

Type TQBSP
	Field File:String
	Field Stream:TStream
	
	Field Header:TQHeader
	
	Field PLANES:TList = CreateList()
	Field Vertices:TQVertex[]
	Field Nodes:TList = CreateList()
	Field TexInfo:TList = CreateList()
	Field Faces:TQFace[]
	Field ClipNodes:TList = CreateList()
	Field Leaves:TList = CreateList()
	Field Edges:TQEdge[]
	Field Ledges:TQLedge[]
	Field Models:TQModel[]
	
	Function LoadFile:TQBSP(url:String)
		Local nB:TQBSP = New TQBSP
		nB.File = url
		
		If nB.Process() Then
			Return nB
		Else
			nB.StreamError("Map ~q" + nB.file + "~q NOT loaded")
			Return Null
		EndIf
	EndFunction
	
	Method StreamError(MSG:String)
		If Stream Then CloseStream(Stream)
		DebugLog "Read error: " + MSG
	EndMethod
	
	Method Process:Int()
		Stream = OpenStream(File)
		If Not Stream Then
			StreamError("Unable to read file ~q" + file + "~q")
			Return False
		EndIf
		
		Local num:Int 'For counting stuff
		Local i:Int 'For loops
		
		'Read header
		Self.Header = TQHeader.Read(Stream)
		
		'Read planes
		'num = Self.Header.PLANES.Count(TQPlane.Size())
		'DebugLog "Planes: " + num
		'Self.Header.PLANES.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.PLANES, TQPlane.Read(Stream))
		'Next
		
		'Read vertices
		num = Self.Header.Vertices.Count(TQVertex.Size())
		DebugLog "Vertices: " + num
		Self.Vertices = New TQVertex[num]
		Self.Header.Vertices.JumpTo(Stream)
		For i = 0 Until num
			'ListAddLast(Self.Vertices, TQVertex.Read(Stream))
			Self.Vertices[i] = TQVertex.Read(Stream)
		Next
		
		'Read nodes
		'num = Self.Header.Nodes.Count(TQNode.Size())
		'DebugLog "Nodes: " + num
		'Self.Header.Nodes.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.Nodes, TQNode.Read(Stream))
		'Next
		
		'Read texture info
		'num = Self.Header.TexInfo.Count(TQSurface.Size())
		'DebugLog "TexInfos: " + num
		'Self.Header.TexInfo.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.TexInfo, TQSurface.Read(Stream))
		'Next
		
		'Read faces
		num = Self.Header.Faces.Count(TQFace.Size())
		DebugLog "Faces: " + num
		Self.Faces = New TQFace[num]
		Self.Header.Faces.JumpTo(Stream)
		For i = 0 Until num
			'ListAddLast(Self.Faces, TQFace.Read(Stream))
			Self.Faces[i] = TQFace.Read(Stream)
		Next
		
		'Read clipnodes
		'num = Self.Header.ClipNodes.Count(TQClipNode.Size())
		'DebugLog "ClipNodes: " + num
		'Self.Header.ClipNodes.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.ClipNodes, TQClipNode.Read(Stream))
		'Next
		
		'Read leaves
		'num = Self.Header.Leaves.Count(TQDLeaf.Size())
		'DebugLog "Leaves: " + num
		'Self.Header.Leaves.JumpTo(Stream)
		'For i = 0 Until num
		'	ListAddLast(Self.Leaves, TQDLeaf.Read(Stream))
		'Next
		
		'Read edges
		num = Self.Header.Edges.Count(TQEdge.Size())
		DebugLog "Edges: " + num
		Self.Edges = New TQEdge[num]
		Self.Header.Edges.JumpTo(Stream)
		For i = 0 Until num
			'ListAddLast(Self.Edges, TQEdge.Read(Stream))
			Self.Edges[i] = TQEdge.Read(Stream)
		Next
		
		'Read ledges
		num = Self.Header.Ledges.Count(TQLedge.Size())
		DebugLog "Ledges: " + num
		Self.Ledges = New TQLedge[num]
		Self.Header.Ledges.JumpTo(Stream)
		For i = 0 Until num
			'ListAddLast(Self.Ledges, TQLedge.Read(Stream))
			Self.Ledges[i] = TQLedge.Read(Stream)
		Next
		
		'Read models
		num = Self.Header.Models.Count(TQModel.Size())
		DebugLog "Models: " + num
		Self.Models = New TQModel[num]
		Self.Header.Models.JumpTo(Stream)
		For i = 0 Until num
			'ListAddLast(Self.Models, TQModel.Read(Stream))
			Self.Models[i] = TQModel.Read(Stream)
		Next
		
		CloseStream(Stream)
		Return True
	EndMethod
EndType

'http://www.gamers.org/dEngine/quake/spec/quake-spec34/qkspec_4.htm
'char 8bit = negative byte
'u_char 8bit = byte
'short 16bit = negative short
'u_short 16bit = short
'long 32bit = int
'u_long 32bit = longer int
'float 32bit = float
'scalar_t 32bit = float

Type TQHeader
	Field Version:Int
	Field Entities:TQEntry
	Field PLANES:TQEntry
	Field MipTex:TQEntry
	Field Vertices:TQEntry
	Field VisiList:TQEntry
	Field Nodes:TQEntry
	Field TexInfo:TQEntry
	Field Faces:TQEntry
	Field LightMaps:TQEntry
	Field ClipNodes:TQEntry
	Field Leaves:TQEntry
	Field LFace:TQEntry
	Field Edges:TQEntry
	Field Ledges:TQEntry
	Field Models:TQEntry
	
	Function Read:TQHeader(Stream:TStream)
		Local nH:TQHeader = New TQHeader
		
		nH.Version = ReadInt(Stream)
		If nH.Version = "29" Then
			DebugLog "Correct BSP version (" + nH.Version + ")"
		Else
			DebugLog "Warning: Wrong BSP version (" + nH.Version + ")"
		EndIf
		
		nH.Entities = TQEntry.Read(Stream)
		nH.PLANES = TQEntry.Read(Stream)
		
		nH.MipTex = TQEntry.Read(Stream)
		nH.Vertices = TQEntry.Read(Stream)
		
		nH.VisiList = TQEntry.Read(Stream)
		nH.Nodes = TQEntry.Read(Stream)
		
		nH.TexInfo = TQEntry.Read(Stream)
		
		nH.Faces = TQEntry.Read(Stream)
		
		nH.LightMaps = TQEntry.Read(Stream)
		nH.ClipNodes = TQEntry.Read(Stream)
		
		nH.Leaves = TQEntry.Read(Stream)
		
		nH.LFace = TQEntry.Read(Stream)
		nH.Edges = TQEntry.Read(Stream)
		
		nH.Ledges = TQEntry.Read(Stream)
		nH.Models = TQEntry.Read(Stream)
		
		Return nH
	EndFunction
EndType

Type TQModel
	Field Bound:TQBoundBox
	Field Origin:TQVec3
	Field Node_ID0:Int
	Field Node_ID1:Int
	Field Node_ID2:Int
	Field Node_ID3:Int
	Field NumLeafs:Int
	Field Face_ID:Int
	Field Face_Num:Int
	
	Function Read:TQModel(Stream:TStream)
		Local nM:TQModel = New TQModel
		nM.Bound = TQBoundBox.Read(Stream)
		nM.Origin = TQVec3.Read(Stream)
		nM.Node_ID0 = ReadInt(Stream)
		nM.Node_ID1 = ReadInt(Stream)
		nM.Node_ID2 = ReadInt(Stream)
		nM.Node_ID3 = ReadInt(Stream)
		nM.NumLeafs = ReadInt(Stream)
		nM.Face_ID = ReadInt(Stream)
		nM.Face_Num = ReadInt(Stream)
		Return nM
	EndFunction
	
	Function Size:Int()
		Return (B_INT * 7) + TQBoundBox.Size() + TQVec3.Size()
	EndFunction
EndType

Type TQVertex
	Field X:Float
	Field Y:Float
	Field Z:Float
	
	Function Read:TQVertex(Stream:TStream)
		Local nV:TQVertex = New TQVertex
		nV.Z = ReadFloat(Stream)
		nV.X = ReadFloat(Stream)
		nV.Y = ReadFloat(Stream)
		
		Return nV
	EndFunction
	
	Function Size:Int()
		Return B_FLOAT * 3
	EndFunction
EndType

Type TQSurface
	Field VectorS:TQVec3
	Field DistS:Float
	Field VectorT:TQVec3
	Field DistT:Float
	Field Texture_ID:Int
	
	Field Animated:Int
	
	Function Read:TQSurface(Stream:TStream)
		Local nS:TQSurface = New TQSurface
		nS.VectorS = TQVec3.Read(Stream)
		nS.DistS = ReadFloat(Stream)
		nS.VectorT = TQVec3.Read(Stream)
		nS.DistT = ReadFloat(Stream)
		nS.Texture_ID = ReadInt(Stream)
		nS.Animated = ReadInt(Stream)
		Return nS
	EndFunction
	
	Function Size:Int()
		Return (B_FLOAT * 2) + (B_INT * 2) + (TQVec3.Size() * 2)
	EndFunction
EndType

Type TQEdge
	Field Vertex0:Short
	Field Vertex1:Short
	
	Function Read:TQEdge(Stream:TStream)
		Local nE:TQEdge = New TQEdge
		nE.Vertex0 = ReadShort(Stream)
		nE.Vertex1 = ReadShort(Stream)
		Return nE
	EndFunction
	
	Function Size:Int()
		Return B_SHORT * 2
	EndFunction
EndType

Type TQLedge
	Field Edge:Int
	
	Function Read:TQLedge(Stream:TStream)
		Local nL:TQLedge = New TQLedge
		nL.Edge = ReadInt(Stream)
		Return nL
	EndFunction
	
	Function Size:Int()
		Return B_INT
	EndFunction
EndType

Type TQFace
	Field Plane_ID:Short
	
	Field Side:Short
	Field Ledge_ID:Int
	
	Field Ledge_Num:Short
	Field TexInfo_ID:Short
	
	Field TypeLight:Byte
	Field BaseLight:Byte
	Field Light:Byte[2]
	Field LightMap:Int
	
	Function Read:TQFace(Stream:TStream)
		Local nF:TQFace = New TQFace
		nF.Plane_ID = ReadShort(Stream)
		nF.Side = ReadShort(Stream)
		nF.Ledge_ID = ReadInt(Stream)
		nF.Ledge_Num = ReadShort(Stream)
		nF.TexInfo_ID = ReadShort(Stream)
		nF.TypeLight = ReadByte(Stream)
		nF.BaseLight = ReadByte(Stream)
		nF.Light[0] = ReadByte(Stream)
		nF.Light[1] = ReadByte(Stream)
		nF.LightMap = ReadInt(Stream)
		Return nF
	EndFunction
	
	Function Size:Int()
		Return (B_SHORT * 4) + (B_INT * 2) + (B_BYTE * 4)
	EndFunction
EndType

Type TQMipHeader
	Field NumTex:Int
	Field Offset:Int[]
	
	Function Read:TQMipHeader(Stream:TStream)
		Local nM:TQMipHeader = New TQMipHeader
		nM.NumTex = ReadInt(Stream)
		
		'Should I even read this?
		nM.Offset = New Int[nM.NumTex]
		For Local i:Int = 0 Until nM.NumTex
			nM.Offset[i] = ReadInt(Stream)
		Next
		Return nM
	EndFunction
EndType

Type TQMipTex
	Field Name:String
	Field width:Int
	Field Height:Int
	Field Offset1:Int
	Field Offset2:Int
	Field Offset4:Int
	Field Offset8:Int
	
	Function Read:TQMipTex(Stream:TStream)
		Local nM:TQMipTex = New TQMipTex
		For Local i:Int = 0 Until 16
			nM.Name:+Chr(ReadByte(Stream))
		Next
		nM.width = ReadInt(Stream)
		nM.Height = ReadInt(Stream)
		nM.Offset1 = ReadInt(Stream)
		nM.Offset2 = ReadInt(Stream)
		nM.Offset4 = ReadInt(Stream)
		nM.Offset8 = ReadInt(Stream)
		Return nM
	EndFunction
	
	Function Size:Int()
		Return (B_BYTE * 16) + (B_INT * 6)
	EndFunction
EndType

Type TQEntry
	Field Offset:Int
	Field Size:Int
	
	Function Read:TQEntry(Stream:TStream)
		Local nE:TQEntry = New TQEntry
		nE.Offset = ReadInt(Stream)
		nE.Size = ReadInt(Stream)
		Return nE
	EndFunction
	
	Method Count:Int(typeSize:Int)
		Return Size / typeSize
	EndMethod
	
	Method JumpTo(Stream:TStream)
		Stream.Seek(Self.Offset)
	EndMethod
EndType

Type TQNode
	Field Plane_ID:Int
	
	Field Front:Short
	
	Field Back:Short
	
	Field Box:TQBBoxShort
	Field Face_ID:Short
	Field Face_Num:Short
	
	Function Read:TQNode(Stream:TStream)
		Local nN:TQNode = New TQNode
		nN.Plane_ID = ReadInt(Stream)
		nN.Front = ReadShort(Stream)
		nN.Back = ReadShort(Stream)
		nN.Box = TQBBoxShort.Read(Stream)
		nN.Face_ID = ReadShort(Stream)
		nN.Face_Num = ReadShort(Stream)
		Return nN
	EndFunction
EndType

Type TQDLeaf
	Field Typ:Int
	Field VisList:Int
	
	Field Bound:TQBBoxShort
	Field LFace_ID:Short
	
	Field LFace_Num:Short
	Field SndWater:Byte
	Field SndSky:Byte
	Field SndSlime:Byte
	Field SndLava:Byte
	
	Function Read:TQDLeaf(Stream:TStream)
		Local nD:TQDLeaf = New TQDLeaf
		nD.Typ = ReadInt(Stream)
		nD.VisList = ReadInt(Stream)
		
		nD.Bound = TQBBoxShort.Read(Stream)
		nD.LFace_ID = ReadShort(Stream)
		
		nD.LFace_Num = ReadShort(Stream)
		nD.SndWater = ReadByte(Stream)
		nD.SndSky = ReadByte(Stream)
		nD.SndSlime = ReadByte(Stream)
		nD.SndLava = ReadByte(Stream)
		Return nD
	EndFunction
EndType

Type TQPlane
	Field Normal:TQVec3
	
	Field Dist:Float
	
	Field Typ:Int
	
	Function Read:TQPlane(Stream:TStream)
		Local nP:TQPlane = New TQPlane
		nP.Normal = TQVec3.Read(Stream)
		nP.Dist = ReadFloat(Stream)
		nP.Typ = ReadInt(Stream)
		Return nP
	EndFunction
EndType

Type TQClipNode
	Field PlaneNum:Int
	Field Front:Short
	
	Field Back:Short
	
	Function Read:TQClipNode(Stream:TStream)
		Local nC:TQClipNode = New TQClipNode
		nC.PlaneNum = ReadInt(Stream)
		nC.Front = ReadShort(Stream)
		nC.Back = ReadShort(Stream)
		Return nC
	EndFunction
EndType

'Basic types
Type TQVec3
	Field X:Float
	Field Y:Float
	Field Z:Float
	
	Function Read:TQVec3(Stream:TStream)
		Local nV:TQVec3 = New TQVec3
		nV.X = ReadFloat(Stream)
		nV.Y = ReadFloat(Stream)
		nV.Z = ReadFloat(Stream)
		Return nV
	EndFunction
	
	Function Size:Int()
		Return B_FLOAT * 3
	EndFunction
EndType

Type TQBoundBox
	Field Minimum:TQVec3
	Field Maximum:TQVec3
	
	Function Read:TQBoundBox(Stream:TStream)
		Local nB:TQBoundBox = New TQBoundBox
		nB.Minimum = TQVec3.Read(Stream)
		nB.Maximum = TQVec3.Read(Stream)
		Return nB
	EndFunction
	
	Function Size:Int()
			Return TQVec3.Size() * 2
	EndFunction
EndType

Type TQBBoxShort
	Field Minimum:Short
	Field Maximum:Short
	
	Function Read:TQBBoxShort(Stream:TStream)
		Local nB:TQBBoxShort = New TQBBoxShort
		nB.Minimum = ReadShort(Stream)
		nB.Maximum = ReadShort(Stream)
		Return nB
	EndFunction
	
	Function Size:Int()
		Return B_SHORT * 2
	EndFunction
EndType</textarea><br><br>The interesting part is at "'Debug make a mesh" <br><br></td></tr></table><br>
<a name="1320613"></a>

<a name="1320614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> An edge is a segment of a 3D line. That segment is formed by two distinct 3D points, the vertices. All edges have two vertices.<br><br>There are two lists of edges in that BSP file:<br>- One list, "edge", defines all unique edges in the scene.<br>- Another list, "ledge", defines all faces by specifying consecutive edge indexes from the "edge" list that form each face (a face can be a triangle, a quadrilateral, a pentagon etc.).<br><br>I didn't run this, but maybe this helps (EDIT: corrected something):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">For Local model:TQModel = EachIn myBSP.Models 'Go through models
	For fNr:Int = model.Face_ID Until model.Face_ID + model.Face_Num 'Go through faces
		
		face = myBSP.Faces[fNr] 'Get current face
		
        'surf[surfNr] sanitisation
		'(...)
		
		'Collect the vertices that form face 'face'.
		Local faceVertices:Int[] = New Int[face.Ledge_Num * 2]
		Local newVertices:Int = 0
		
		For eNr = face.Ledge_ID Until face.Ledge_ID + face.Ledge_Num 'Go through edges
			ledge = myBSP.Ledges[eNr] 'Get ledge
			edge = myBSP.Edges[Abs(ledge.edge)] 'Get edge via ledge
			
			If ledge.edge &lt; 0 Then
				faceVertices[ newVertices ]			= myBSP.Vertices[edge.Vertex1]
				faceVertices[ newVertices + 1 ]	= myBSP.Vertices[edge.Vertex0]
			Else
				faceVertices[ newVertices ]			= myBSP.Vertices[edge.Vertex0]
				faceVertices[ newVertices + 1 ]	= myBSP.Vertices[edge.Vertex1]
			EndIf
			
			newVertices :+ 2 'Add these 'vertex0' and 'vertex1' from the edge to the face vertex count.
		Next
		
		'Make the triangles for 'face'.
		For Local v:Int = 0 Until newVertices Step 3 'Go 3 by 3.
		
			Local lastVertex:Int = surf[surfNr].CountVertices()
			
			For Local triangleVerts:Int = 0 To 2
				Local vert:TQVertex = faceVertices[ v + triangleVerts ]
				AddVertex(surf[surfNr], vert.X, vert.Y, vert.Z ) 'Don't scale the vertex coordinates here, do it later with ScaleMesh for more control.
			Next
			
			AddTriangle( surf[surfNr], lastVertex + 1, lastVertex + 2, lastvertex + 3 )
		Next
		
	Next
Next</textarea><br><br>This all falls apart when you add in texturing though. This BSP format is supposed to work with that WAD pack that contains all textures.<br>How do you plan on doing that?<br>Maybe working with DeleD CE should be better, it exports to B3D format directly with texturing and it's a map editor similar to TrenchBroom. The model would come cut up into surfaces and ready for use. <br><br></td></tr></table><br>
<a name="1320615"></a>

<a name="1320616"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I managed to make some good progress.<br>I've gotten the geometry pretty much perfect.<br>I can load the palettes from Quake 1 (I'll just include one in the module by default).<br>I can also get the textures and apply them to the geometry!<br>But there are some problems with the way I'm drawing the textures, so some are still a bit wrong.<br>I'm going to work on lightmaps next.<br><br>@Kryzon Actually the WAD files are only for editors!<br>The textures are stored directly in the BSP for each map (what a waste)<br>Which means I only had to read the Quake 1 LMP palette file to get the colors correct.<br><br>Anyways, here's a screenshot of the progress so far:<br><img src="https://puu.sh/rtE4M/ac6cd3c412.png"> <br><br></td></tr></table><br>
<a name="1320617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Naughtical</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Impressive! Can't wait to see more! <br><br></td></tr></table><br>
<a name="1320619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Are u making a map editor? <br><br></td></tr></table><br>
<a name="1320621"></a>

<a name="1320622"></a>

<a name="1320850"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @adiaden Thanks!<br>I've got the textures fixed now so they're all correctly aligned.<br>Liquid textures such as water and teleporters sort of work now, not as fancy as in Quake but they move!<br>Transparent parts also works, not sure if original Quake really supported that, but I feel like water and lava should be a little transparent.<br>I'll tackle Lightmaps next, should do a lot to the overall atmosphere.<br><br>@Hardcoal Nah.<br>I'm only loading .BSP files, which Quake 1, 2 and 3 uses.<br>It won't load the Quake 3 .BSP files but it does load Quake 1 ones, not sure about Quake 2 but I doubt it.<br>There are already plenty of editors for Quake 1!<br>I personally love how <a href="http://kristianduske.com/trenchbroom/" target="_blank">TrenchBroom 2</a> works, it's super easy and fun. <br><br></td></tr></table><br>
<a name="1320624"></a>

<a name="1320625"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I remember that location, level 1.<br>I love the steampunk, grungy gothic art-direction in Quake, but I also remember hating to have to kill the dogs; would avoid doing that when I could. <br><br></td></tr></table><br>
<a name="1320673"></a>

<a name="1320674"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> You still didn't say why you are loading them or did i miss that.<br><br>I used to make maps with quark army knife <br><br></td></tr></table><br>
<a name="1320686"></a>

<a name="1320687"></a>

<a name="1320688"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Hardcoal No I guess I never said why heh.<br>No reason really, I just figured it'd be good to have.<br>As I said, I love TrenchBroom 2.x (and Quake!) and if I ever decide to make a 3D game I could easily make maps with it and load them with this code.<br>I'm planning on releasing this as a module for everyone to use and modify.<br><br>@Kryzon Yeah I love the style too!<br>The lightmaps aren't the best in Quake 1, so I think a lot of the style comes from its limitations heh. <br><br></td></tr></table><br>
<a name="1320699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> thats genius ... I actually might need it sir..<br>I have the same ISsue.. <br>I can make great quake 2 maps.. /quake1<br>and I can use it on my Game Editor. <br><br></td></tr></table><br>
<a name="1320723"></a>

<a name="1320725"></a>

<a name="1320726"></a>

<a name="1320727"></a>

<a name="1320728"></a>

<a name="1320729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've managed to get some lightmaps loaded.<br>The UV for them is still a bit wonky which creates some ugly seams and odd parts.<br>I'm hoping to solve that once I merge all the tiny lightmap images Quake uses, into one big lightmap image that I can throw onto the entire mesh.<br>Having all of these small lightmap images means lots of surfaces too which means it runs at a terrible speed right now heh.<br><br><img src="https://puu.sh/ruNga/53693d1cba.png"> <br><br></td></tr></table><br>
<a name="1320730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great job mr..<br>You are very fast and productive.. <br><br></td></tr></table><br>
<a name="1320845"></a>

<a name="1320846"></a>

<a name="1320847"></a>

<a name="1320848"></a>

<a name="1320849"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Alright so I've managed to get basic scrolling skybox support in.<br>Animated textures now also works correctly.<br>Lightmaps.. sort of works, it's kicking my ass actually.<br>At some places it looks great, but other, seemingly random parts are weird.<br>I'm guessing it's the UV coords, but the documents aren't even near correct when it comes to the lightmaps.<br>I've had a friend look over the Quake and QBSP code and we've gotten some extra information from that, but they're still not perfect.<br>Lightmaps at least one poorly put together image now, instead of many tiny pictures.<br>So performance is back.<br><br><img src="https://dl.dropboxusercontent.com/u/2842751/q1lightmap.png"><br><br><img src="https://dl.dropboxusercontent.com/u/2842751/q1lightmap2.png"> <br><br></td></tr></table><br>
<a name="1320853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Naughtical</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks great! <br><br></td></tr></table><br>
<a name="1320868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep. it really looks good <br><br></td></tr></table><br>
<a name="1320869"></a>

<a name="1320870"></a>

<a name="1320871"></a>

<a name="1320872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks everyone!<br><br>I'm still trying to optimize and load everything from the BSP.<br>Just got entities working, so now it's possible to get information such as weapon and player spawns, triggers, doors, buttons etc.<br>It doesn't mean that stuff moves around in the level, it just means we can read the data for such things and possibly add support for stuff like that later.<br>Though that's more of a "game" thing and not something the BSP loader should really handle.<br><br>I've also added support for some Quake 1 community tricks and modern stuff.<br>For example it's possible to have textures with transparent parts (masked) which original Quake 1 doesn't support.<br>Also, some REALLY huge maps are possible to load, much bigger than Quake 1 normally loads.<br><br>I could do lots more if BlitzMax had a proper 3D engine.<br>MiniB3D is very limited.<br><br>If someone knows how to load MDL files with animations (Basically the same as MD2 files) I could get those into the map too.<br><br>Here's a random screenshot from when I was testing GL_NEAREST on textures.<br>Notice the vines are transparent with lightmaps.<br><br><img src="https://dl.dropboxusercontent.com/u/2842751/q1_test1.png"> <br><br></td></tr></table><br>
<a name="1320873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> BlitzMax-Assimp has most of the work done for you. It can load MDL and several other formats, but you need to add animation support:<br><a href="https://github.com/Difference/blitzmax-assimp" target="_blank">https://github.com/Difference/blitzmax-assimp</a><br><br>It has some code to convert from an assimp mesh to MiniB3D, but the module did not implement the animation features. It seems abandoned. <br><br></td></tr></table><br>
<a name="1320883"></a>

<a name="1320884"></a>

<a name="1320885"></a>

<a name="1320886"></a>

<a name="1320887"></a>

<a name="1320888"></a>

<a name="1320889"></a>

<a name="1320890"></a>

<a name="1320891"></a>

<a name="1320892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hezkore</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Kryzon Yeah I've attempted to use Assimp before but it's such a mess.<br>I know MiniB3D Extended has animated MD2 support, maybe I can modify that.<br><br><br>Anyways, I've put the code on BitBucket along with a test BSP and example:<br><a href="https://bitbucket.org/Hezkore/bsp-loader" target="_blank">https://bitbucket.org/Hezkore/bsp-loader</a><br><br>The lightmap UV is still wrong.<br>And skyboxes don't work like in Quake 1.<br>So don't expect things to look right.<br><br>MiniB3D is, as I've said, very limited.<br>I'd like to use the stencil buffer and stencil in the sky, but I can't with MiniB3D.<br>I've already had to hack MiniB3D to get GL_NEAREST filtering on the textures.<br>That means that you guys will get some blurry textures.<br>If you want to use GL_NEAREST for sharp textures you can apply this "fix/hack" to MiniB3D.mod/Inc/TMesh.bmx at line 1796.<br>It uses texture flag 512 (which isn't used anyways) as a way to get GL_NEAREST filtering.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' mipmapping texture flag
If tex_flags &amp; 8 &lt;&gt; 0
	If tex_flags &amp; 512 &lt;&gt; 0 then
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_LINEAR)
	Else
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR)
	EndIf
Else
	If tex_flags &amp; 512 &lt;&gt; 0
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
	Else
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
	EndIf
EndIf</textarea><br><br><br>And it's not a module yet either, just a file you import.<br>I'll turn it into a module once I'm happy with it.<br><br>Oh, and don't forget that you'll need MiniB3D to use it. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
