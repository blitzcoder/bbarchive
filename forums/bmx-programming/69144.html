<!DOCTYPE html><html lang="en" ><head ><title >Is there any way to do this?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Is there any way to do this?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Is there any way to do this?</a><br><br>
<a name="772933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sonic</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> What I'm doing at the moment is writing a simplified GUI system for my level editor.  I have textboxes, buttons etc...<br><br>What I'd like to be able to do is this:<br><br>Let the contents of (for example) a text box point to an actual memory address, the one that is used in fields of my real objects.  This is so that when I alter the contents of the text box, it will automatically change the contents of a string field within an object.  At the moment I'm having to read the object's field into the textbox every frame, then get user input, then read back into the object's field.  As far as I'm concerned this is a really ugly way to go about it.  I'd like to operate on the field's directly.<br><br>I think I could do this with ints using Varptr etc, but for strings I can't seem to get the actual memory addresss, as they are a kind of object I suppose.  Using the .ToCString() method just returns the address of a new copy of the string in memory...  So no use.<br><br>Is this just the downside to a managed-memory environment?  If so, I miss C!<br><br>[edit: typo] <br><br></td></tr></table><br>
<a name="772993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could, instead of using an array, use a memory bank and pass the BankPtr as the address.? <br><br></td></tr></table><br>
<a name="772999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't understand AngelDaniel's suggestion, so he may have offered you just what you need, but I wanted to do exactly what you're trying to do with Car Jockey, and found as you did that since strings are objects, you can't use VarPtr as you can with values. What I ended up doing was passing a function pointer instead and having the function the pointer points to put the data in the right variable. It's not ideal because it means you're hardcoding a function for every variable, but it does still give you the clean method of operating. <br><br></td></tr></table><br>
<a name="773000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOL<br>Well, I dont understand Sonics question, so Ill also assume angel has answered it. Surly Atpye.Field <b>is</b> a pointer to a memory address? <br><br></td></tr></table><br>
<a name="773015"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >smilertoo</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> why dont you just check to see if the text box has changed? if it hasnt theres no need to update anything else. <br><br></td></tr></table><br>
<a name="773327"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sonic</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Smilertoo, I do this actually, but that's not the issue really... I'd just like to do away with the reading in and out of the texbox altogether by having its contents refer to the same address in memory of the field it refers to.<br><br>I'm basically using Gabriel's solution, but I find it ugly, and there's all sorts of dependencies issues, as for example changing the object I'm editing the fields of should then update all the texboxes...  Kind of difficult to explain but I hope you get my drift.<br><br>Angel, I think you might just have something there, I'm just thinking of the implications of what you said, it might just work...  Hmmm... <br><br></td></tr></table><br>
<a name="774503"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sonic</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, so this system (AngelDaniel's system) is working for the moment...  The only problem is I have to allocate far more memory than I should because the data within strings can change at any point.  <br><br>Is there cleaner way to go about it?  I'll try to give an example of what I"m doing...<br><br>Say we have a type 'Hotspot' with fields 'name' and 'description' - both Byte pointers to somewhere within a data bank.<br><br>During the update() method of the textbox, the contents is read from the Byte pointer referring to the property being edited (eg name_ptr).  Then read back at the end of the update loop.  This is nice as I only have to assign the pointer once, when I change which 'hotspot' is being edited.<br><br>For now, I allocate the potential maximum length of name and description within the bank...  However in an application that requires hundreds, nay, thousands of these strings, memory soon creeps upwards.<br><br>Better would be some kind of dynamic allocation - all strings are placed head-to-tail within the memory bank, and when a string increases in length, a new place in the bank would need to be found.<br><br>This would require some clever memory management tricks that I'm struggling to design.<br><br>Can anyone give me some pointers as to how I would organise this?  I've tried searching for tutorials in C - but of course in C there's a much simpler way of doing it, because strings are not Objects, merely arrays of Char, so I've come up empty-handed.<br><br>Thanks in advance...<br><br>Jasper<br><br>[edit: typo] <br><br></td></tr></table><br>
<a name="774627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> VarPtr is a good idea. You can make even an Int variable and varptr to it. <br><br></td></tr></table><br>
<a name="774644"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sonic</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Angel could you elaborate on that?  How exactly should I use Varptr?  I take it you get what I'm trying to do?  <br><br>I've spent all day writing a dynamic memory management system which does its job...<br><br>But then pointers which are passed to the textbox may be altered when a string is enlarged, which doesn't alter the original 'hotspot' field... So I'm kind back to square one.. with a really cool dynamic memory thing.<br><br>Here's the code I'm using at the moment - any way it could be modified?<br><br>[code<br><br>Strict<br><br>Const BY_SIZE=0,BY_OFFSET=1<br><br>Global bank:TBank=CreateBank(100)<br>Global bank_ptr:Byte Ptr=bank.Buf()<br>Global hotspot_offset:Int<br>Global free_space:TList=New TList<br>Global used_space:TList=New TList<br><br>Local m:memory=New memory<br><br>m.size=bank.Capacity()<br>m.offset=bank_ptr<br>ListAddLast free_space,m<br><br><br><br><br>memory.display_memory()<br><br>Local p:Byte Ptr<br><br>p=string_alloc("Hello World!")<br>Print srd(p)<br>memory.display_memory()<br>Print""<br><br>p=swr("Hello!",p)<br>Print srd(p)<br>memory.display_memory()<br>Print""<br><br><br>p=swr("Hello everyone!",p) <br>Print srd(p)<br>memory.display_memory()<br>Print""<br><br><br>p=swr("Hello!",p)<br>Print srd(p)<br>memory.display_memory()<br>Print""<br><br><br>' Here was can see the problem - imagine this is within the textbox...<br><br>Local p2:Byte Ptr=p   ' this is the pointer to the textbox's contents...<br><br>p2=swr("Hi!",p2)<br>Print srd(p)<br><br>' well that works fine... but what if the string gets bigger?<br><br><br>p2=swr("Hello everybody in the universe!",p2)<br>Print srd(p)          ' as we can see p no longer points to the same place!<br><br>Type memory<br>	Field offset:Byte Ptr<br>	Field size<br>	<br>	Global sort_method<br>	<br>	Function display_memory()<br>	<br>		Print "*FREE*"<br>		<br>		For Local m:memory=EachIn free_space<br>			Print "  &gt;&gt; "+m.ToString()<br>		Next<br>	<br>		Print "*USED*"<br>		<br>		For Local m:memory=EachIn used_space<br>			Print "  &gt;&gt; "+m.ToString()+" contains:"+srd(m.offset)<br>		Next<br>	End Function<br><br>	Function find_space:memory(space)<br>		free_space.Sort(True)<br>		For Local m:memory=EachIn free_space<br>			If m.size&gt;=space<br>				Return m<br>			EndIf<br>		Next<br>	EndFunction<br>	<br>	Function add_space:memory(in_memory:memory,space)<br>		Local m:memory=New memory<br>		m.offset=in_memory.offset<br>		m.size=space<br>		in_memory.offset:+space<br>		in_memory.size:-space<br>		If in_memory.size&lt;=0<br>			ListRemove free_space,in_memory<br>		EndIf<br>		Return m<br>	EndFunction<br>	<br>	Function join_free_space()<br>		<br>		sort_method=BY_OFFSET<br>		free_space.Sort(True)<br>		<br>		Local m1:memory=Memory(free_space.First())<br>		Local m2:memory<br>		<br>		Local new_list:TList=New TList<br>		<br>		Local dont_add_last<br>		<br>		For Local m:memory=EachIn free_space<br>			m2=m<br>	<br>			dont_add_last=False<br>			<br>			If m2&lt;&gt;free_space.First() <br>				If m2.offset=m1.offset+m1.size<br>					'Print "  &gt;&gt; Joining &gt;&gt; "+m1.ToString()+" + "+m2.ToString()<br>					m1.size:+m2.size<br>					ListAddLast new_list,m1<br>					dont_Add_last=True<br>				Else <br>					ListAddLast new_list,m1<br>					m1=m2<br>				EndIf<br>			Else<br>				m1=m2<br>			EndIf<br><br>		Next<br>		<br>		If Not dont_add_last Then ListAddLast new_list,m1<br>		<br>		free_space=new_list<br>		<br>		sort_method=BY_SIZE<br>		free_space.Sort(True)<br>	End Function<br>	<br>	Method ToString:String()<br>		Return "Location: "+(offset-bank_ptr)+"  Size: "+size<br>	EndMethod<br>		<br>	Method Compare(Obj:Object)<br>		Select sort_method<br>			Case BY_SIZE    If memory( Obj ).size &lt; size Return 1 Else Return -1<br>			Case BY_OFFSET  If (memory( Obj ).(offset)-bank_ptr) &lt; (offset-bank_ptr) Return 1 Else Return -1<br>		End Select<br>	EndMethod <br>		<br><br>End Type<br><br><br>Function string_alloc:Byte Ptr(a$)<br>	<br>	Local m:memory<br>	m=memory.find_space(Len(a$)+1)<br>	m=memory.add_space(m,Len(a$)+1)<br>	stringwrite(a$,m:memory)<br>	free_space.Sort(True)<br>	ListAddLast used_space,m<br>	<br>	Print "Allocated: "+a$<br><br>	Return m.offset<br>	<br>End Function<br><br>Function srd:String(m:Byte Ptr)       ' read string<br>	Return String.FromCString(m)<br>EndFunction<br><br><br><br>Function swr:Byte Ptr(a$,b:Byte Ptr)  ' write string<br><br><br>		Local m:memory<br>		<br>		For Local m2:memory=EachIn used_space<br>			If b=m2.offset<br>				m=m2 ; Print "position found -&gt; "+(m.offset-bank_ptr) ; Exit<br>			EndIf<br>		Next<br>		<br>		If Len(a$)+1&gt;m.size<br>		<br>			Print "++ enlarging -&gt; removing at: "+(m.offset-bank_ptr)<br>			<br>			' NOTE: For some crazy reason, Listremove is not working here - I have no idea why, so I put in this completely wasteful loop...<br><br>			ListRemove used_space,m<br>			<br>			Local new_used_space:TList=New TList<br>			<br>			For Local m2:memory=EachIn used_space<br>				If m2&lt;&gt;m Then ListAddLast new_used_space,m<br>			Next<br>			<br>			used_space=new_used_space<br>			<br>			ListAddLast free_space,m<br>			<br>			m=memory.find_space(Len(a$)+1)<br>			m=memory.add_space(m,Len(a$)+1)<br>			ListAddLast used_space,m<br>			Print "             -&gt;   adding at: "+(m.offset-bank_ptr)<br>			<br>		ElseIf Len(a$)+1&lt;m.size	<br>		<br>			Local new_free_size=m.size<br>			m.size=Len(a$)+1<br>			new_free_size:-m.size<br>			Local m2:memory=New memory<br>			m2.size=new_free_size<br>			m2.offset=m.offset+m.size<br>			ListAddLast free_space,m2<br>		EndIf<br><br>		m=stringwrite(a$,m)<br><br>		memory.join_free_space()<br><br>		Local new_offset=m.offset-b<br>		<br>		b:+new_offset<br>		<br>		Return b<br><br>End Function<br><br>Function stringwrite:memory(a$,m:memory)<br><br>		Local offset=m.offset-bank_ptr<br>		Local l=Len(a$)<br>		Local p:Byte Ptr = a$.ToCString()<br><br>		For Local c=0 To l<br>		<br>			bank.PokeByte(offset,p[c])<br>			offset:+1<br>	<br>		Next<br>		<br>		bank.PokeByte(offset,0)  ' null terminate<br>		offset:+1<br>		<br>		Return m<br>		<br>End Function<br><br><br>]<br><br>Sorry - call me brainless but I can't find for the life of me the codebox switch - anyone tell me and I'll update it... <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
