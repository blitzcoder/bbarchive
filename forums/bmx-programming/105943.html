<!DOCTYPE html><html lang="en" ><head ><title >Method overloading</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Method overloading</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Method overloading</a><br><br>
<a name="1298613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whilst I'm working on implementing it, what are peoples views on having Method overloading?<br><br>Here's a small example of overloading:<br><pre class=code>
SuperStrict

Framework brl.standardio


Local rect:TRect = New TRect

Local draw:TDraw = New TDraw

draw.DrawRect(1, 2, 3, 4)
draw.DrawRect(rect)


Type TRect
	Field x:Int
	Field y:Int
	Field w:Int
	Field h:Int
End Type

Type TDraw

	Method DrawRect(x:Int, y:Int, w:Int, h:Int)
		Print "Drawing with x, y, w, h"
	End Method
	
	Method DrawRect(rect:TRect)
		Print "Drawing with rect"
	End Method

End Type
</pre><br>The above code would produce the following output:<br><pre class=code>
Drawing with x, y, w, h
Drawing with rect
</pre><br><br>Normally in BlitzMax you would need to give a different name to one of the DrawRect() methods.<br>In some cases, you may end up with several methods with similar names performing the same functionality from different argument types.<br><br>With overloading, you can simplify your APIs.<br><br>Method overloading also opens up the potential to add operator overloading... <br><br></td></tr></table><br>
<a name="1298615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does this include constructors? <br>If there's no performance hit, i don't see it as a bad thing.<br>Although it will break Blide, I suppose its the price of progress. <br><br></td></tr></table><br>
<a name="1298636"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> OMG that would be fantastic! I'd be SUPER THRILLED! <br><br></td></tr></table><br>
<a name="1298678"></a>

<a name="1298679"></a>

<a name="1298680"></a>

<a name="1298681"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Does this include constructors?  <br></div><br>I don't see why not.<br><br>Perhaps something along the lines of :<br><pre class=code>

Local rect:TRect = New TRect(10, 10, 100, 100)

Type TRect
	Field x:Int
	Field y:Int
	Field w:Int
	Field h:Int

	Method New(x:Int, y:Int, w:Int, h:Int)
		Self.x = x
		Self.y = y
		Self.w = w
		Self.h = h
	End Method

End Type
</pre> <br><br></td></tr></table><br>
<a name="1298682"></a>

<a name="1298696"></a>

<a name="1298698"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> At first I thought no, you can't have same method name in one type, but after doing some research I think why not. So it's cool.<br><br>EDIT:   Of course it would give an error if there were 2 methods with a same name and same parameter types. <br><br>-Henri <br><br></td></tr></table><br>
<a name="1298699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Henri<br><br>Re edit. Why?<br><br>Are you saying I can not override earlier methods? <br><br></td></tr></table><br>
<a name="1298701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nope.<br><br>I'm saying this should not be allowed:<br><pre class=code>Type Test
	
	Method Do(this:Int)
		Print this
	EndMethod
	
	Method Do(that:Int)
		Print that
	EndMethod 

EndType</pre><br><br>-Henri <br><br></td></tr></table><br>
<a name="1298704"></a>

<a name="1298705"></a>

<a name="1298706"></a>

<a name="1298707"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hahaha, that's pretty funny, Henri! xD<br>I would almost allow such a silly stuff to "compile", just to mess with the person, who wants it! xD<br><br>Jokes aside, Function overloading should be in there, too, for consistency's sake. <br>A complete dream come true would be operator overloading!<br>With my vector classes my life would be infinitely more enjoyable to have that!!! 8D <br><br></td></tr></table><br>
<a name="1298739"></a>

<a name="1298741"></a>

<a name="1298742"></a>

<a name="1298745"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> While your on Brucey, and I know its only marzipan, but:-<br><br><pre class=code>
Type TRect
	Field x:Int
	Field y:Int
	
	
	Method Init(newX:Int,newY:Int)
		Self.x = newX
		Self.y = newY
	End Method
	
	'Overload + operator so we can add two types together
	Method Operator&lt;+&gt;:TRect(rect:TRect)
		Local tempRect:TRect = New TRect
		tempRect.x = Self.x + rect.x
		tempRect.y = Self.y + rect.y
		Return tempRect
	End Method
EndType

Local rect1:TRect = New TRect
rect1.Init(10,20)

Local rect2:TRect = New TRect
rect2.Init(100,200)

'Use the overloaded + operator for our types
Local rect3:TRect = rect1 + rect2

Print rect3.x 'Prints 110
Print rect3.y 'Prints 220
</pre><br><br>Cheers! :)<br><br>Dabz <br><br></td></tr></table><br>
<a name="1298747"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
Method Operator&lt;+&gt;:TRect(rect:TRect)
</pre><br>Yeah, I'm not sure about the syntax for that yet.<br><br>But while we're on the topic, do you want to make a list of all the operators under consideration? ;-) <br><br></td></tr></table><br>
<a name="1298751"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, arithmetic operators, modifying assignments operators(if pos)... I only generally use arithmetic ones and compound ones in C++, as I like the 'object = object + anotherObject' form of writing it over the more usual 'object = AddObjects(object, anotherObject)' setup!<br><br>Like I said, its marzipan really!<br><br>Dabz <br><br></td></tr></table><br>
<a name="1298754"></a>

<a name="1298756"></a>

<a name="1298763"></a>

<a name="1298764"></a>

<a name="1298765"></a>

<a name="1298766"></a>

<a name="1298767"></a>

<a name="1298768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> To voice an opinion way too late to make a difference, you should consider making operator polymorphism available before operator overloading. i.e.:<br><pre class=code>rect1 + rect2
' is identical to, and in fact just syntax sugar for:
rect1.__plus__(rect2)</pre><br>...which would otherwise follow the existing runtime-polymorphic rules.<br><br>Special-casing operators to go straight to overloading will result in a multi-tier language design with muddy semantics. There's also very little practical value to demanding operators be static while methods be dynamic without also introducing templates (i.e. turning your language into C++). And nobody sane wants that.<br><br><br>Personally I don't think overloading is a good idea, mainly because I don't buy the reasoning that it <i>does</i> simplify an API to have the same name refer to multiple things without any control over this on the language side (there's no easy way for the compiler to enforce that the two DrawRect methods are semantically related, meaning you open up more error-surface by allowing overloading).<br><br>If you implement generics (true generics, don't waste your time with templates), you can <i>completely</i> replace overloading with <a href="http://okmij.org/ftp/Computation/typeclass.html" target="_blank">Dictpassing</a> anyway, allowing for all of the same advantages of shorter/clearer code (i.e. two methods both named DrawRect) without any overloading machinery or linguistic complexity. (In general, generics - parametric polymorphism - make a language simpler, while overloading - ad-hoc polymorphism - makes it <i>massively</i> more complex.)<br><br>Dictpassing works best with an "open" or "using" directive to allow easy access to scoped names. Given such a directive, a dictpassing version of BlitzMax could hypothetically look like this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Type Ring &lt;E&gt;
    Function __plus__:E(x:E, y:E) Abstract
    Function __times__:E(x:E, y:E) Abstract
End Type

Type IntRing Extends Ring&lt;Int&gt;
    Function __plus__:Int(x:Int, y:Int)
        Return x + y
    End Function
    Function __times__:Int(x:Int, y:Int)
        Return x * y
    End Function
End Type

Type Vec3 Extends Ring&lt;Vec3&gt;
    Field x:Float, y:Float, z:Float

    Function __plus__:Vec3(l:Vec3, r:Vec3)
        Return New Self(l.x + r.x, l.y + r.y, l.z + r.z)  'pretend there's a constructor
    End Function
    Function __times__:Vec3(l:Vec3, r:Vec3)
        Return New Self(l.x * r.x, l.y * r.y, l.z * r.z)   'w/e
    End Function
End Type

Function MultiplyAndAdd&lt;T&gt;:T(x:T, y:T, z:T)
    Using &lt;T&gt;   'open it up, so T.__plus__ becomes __plus__ becomes +
    Local a:T = x * y
    Local b:T = a + z
    Return (a * b) + z
End Function

Function MultiplyAndAdd&lt;IntRing&gt;(1, 2, 3)
Function MultiplyAndAdd&lt;Vec3&gt; (New Vec3(1, 2, 3), New Vec3(4, 5, 6), New Vec3(7, 8, 9))</textarea><br>Notice that you trade off making your call externally explicit with the fact that a) both of the implementations of MultiplyAndAdd still get to use short names for operators that handle completely unrelated types; and b) a guarantee that all implementations of MultiplyAndAdd have exactly the same underlying structure (i.e. even though Int and Vec3 are unrelated and their +/* do different things, the enclosing function does the same thing <i>in the context of what it means for that type</i>). <br><br></td></tr></table><br>
<a name="1298780"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> First thought: great! Especially if this also implies the constructor/New Method.<br><br>But a concern of mine would be: will there be an IDE picking this up... I admit being spoiled by Visual Studio, but for me, it's too hard to go back to non IDE supported classes/methods. <br><br></td></tr></table><br>
<a name="1298831"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >seriouslee</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd see it as a big plus! Brucey you just keep making Max better and better. <br><br></td></tr></table><br>
<a name="1298834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <i>Henry:</i><br><div class="quote"> <br>I'm saying this should not be allowed:<br><pre class=code>
Type Test
	
	Method Do(this:Int)
		Print this
	EndMethod
	
	Method Do(that:Int)
		Print that
	EndMethod 

EndType
</pre><br> <br></div><br><br>How should the system know what kind of "Do()" you are using when passing an "int" ? Overloading needs to get different amount of params passed, or different types. What you are attempting could be done by using a different "Do()" in an extending type (a extends b).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1298841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Type Test<br>Method Do(this:Int)<br>		Print this<br>	EndMethod<br>	<br>	Method Do(that:Int)<br>		Print that<br>	EndMethod <br><br>EndType<br> <br></div><br><br>No, that should indeed not be allowed. C# raises two helpful errors:<br>Error: Type 'Test' already defines a member called 'Do' with the same parameter types<br>Error	: The call is ambiguous between the following methods or properties: 'Test.Do(int)' and 'Test.Do(int)' <br><br></td></tr></table><br>
<a name="1298855"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> bruce. is this publicly testable ;) <br><br></td></tr></table><br>
<a name="1298856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Let the man do his thing, Adam! We don't want him to get boxed in while setting it all up! ;) <br><br></td></tr></table><br>
<a name="1298859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> is this publicly testable ? <br></div><br>There's a "bcc_overload" branch in github ( <a href="https://github.com/bmx-ng/bcc/tree/bcc_overload" target="_blank">https://github.com/bmx-ng/bcc/tree/bcc_overload</a> ) with the initial work committed, which currently clean-builds against the latest NG brl and pub modules.<br>Doesn't yet support function/New() overloading, but it should work enough for having a play with.<br><br>I'd suggest creating a new "BlitzMax area" for testing this, as it uses method name mangling which is incompatible with the current bcc (or of course you can simply swap between the new and old bcc's and rebuild everything each time). <br><br></td></tr></table><br>
<a name="1298861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, no problem. I'll slowly get it all ready :) <br><br></td></tr></table><br>
<a name="1298866"></a>

<a name="1298868"></a>

<a name="1298869"></a>

<a name="1298889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
ar: creating /BlitzMaxNG_overload/mod/brl.mod/blitz.mod/blitz.debug.linux.x86.a
Compile Error: Unable to find overload for bbgcvalidate(Int). Argument #1 is "Int" but declaration is "Byte Ptr". 
[/BlitzMaxNG_overload/mod/brl.mod/appstub.mod/debugger_mt.stdio.bmx;627;0]
</pre><br><br>(EDIT: removed second error, as it was a userbased error - aka based on my faults :-))<br><br><br>Sample I wanted to compile:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Little "weighting" test: while TTerminator extends from TMachine, the
'second Construct() method should be more exact and be chosen from BCC.
SuperStrict
Framework Brl.StandardIO


Type TFactory
	Method Construct(obj:TMachine)
		Print "Constructing machine: "+obj.Name()
	End Method

	Method Construct(obj:TTerminator)
		Print "Constructing terminator: "+obj.Name()
	End Method
End Type

Type TMachine
	Function Name:String()
		Return "Machine"
	End Function
End Type

Type TTerminator Extends TMachine
	'override
	Function Name:String() 
		Return "Terminator"
	End Function
End Type


Local factory:TFactory = New TFactory
'should print: Constructing machine: Machine"
factory.Construct(New TMachine)
'should print: Constructing machine: Terminator"
factory.Construct(New TTerminator)
</textarea><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1298887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your first error is fixed in github.<br>The other one I cannot reproduce, either with my local copy or a clean clone from the repo :-)<br><br>Your example outputs:<br><pre class=code>
Constructing machine: Machine
Constructing terminator: Terminator
</pre><br><br>:o) <br><br></td></tr></table><br>
<a name="1298888"></a>

<a name="1298891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> The other error was based on a borked bcc.conf (pointing to another BlitzMax installation) ... <br><br><br>Question: If I append the following to the sample above:<br><pre class=code>
'should print: Constructing machine: Machine" ?
factory.Construct(TMachine(New TTerminator))
</pre><br>I pass the variable as "TMachine" - so should it still print "Terminator" (so use the "instance's type") or should it output "Machine" (use the "passed type")?<br><br> <br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1298892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> The cast to TMachine will cause it to choose Construct(obj:TMachine). It will print "Terminator" because the object is an instance of TTerminator.<br>Therefore the output in the third case would be :<br><pre class=code>
Constructing machine: Terminator
</pre> <br><br></td></tr></table><br>
<a name="1298895"></a>

<a name="1298896"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so it chooses by the "given" type, not the "original" type.<br><br>Seems to do what it should. Let's see with what others come up.<br><br>PS: recognized that my question wasn't that correct at all: should have asked what "construct()" is called then. Glad you answered it already.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299708"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's an example of constructor overloading from the latest commit:<br><pre class=code>
SuperStrict

Framework brl.standardio

Local b:TBase = New TBase
Print b.ToString()


b = New TBase(20)
Print b.ToString()

Local s:TSub = New TSub
Print s.ToString()

s = New TSub(60, 50, 10)
Print s.ToString()

Type TBase

	Field a:Int

	Method New()
		a = 99
		Print "~nTBase New()"
	End Method

	Method New(a:Int)
		Self.a = a
		Print "~nTBase New(int)"
	End Method

	Method ToString:String()
		Return "  TBase = " + a
	End Method
	
End Type


Type TSub Extends TBase

	Field b:Int
	Field c:Int

	Method New(a:Int, b:Int, c:Int)	
		Self.a = a
		Self.b = b
		Self.c = c
		Print "TSub New(int, int, int)"
	End Method

	Method ToString:String()
		Return "  TSub = " + a + ", " + b + ", " + c
	End Method
	
End Type
</pre><br>which outputs the following:<br><pre class=code>
TBase New()
  TBase = 99

TBase New(int)
  TBase = 20

TBase New()
  TSub = 99, 0, 0

TBase New()
TSub New(int, int, int)
  TSub = 60, 50, 10
</pre><br><br>Still a ways to go, but testing is going well so far. <br><br></td></tr></table><br>
<a name="1299722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Without testing: How would "TSub" call the "New"-function of TBase. Is this even possible / intended?<br><br>I mean, when using "Method Init:TTypeName()" you are able to override this in an extended type and then call "super.Init()" to also handle the stuff done there.<br><br>possibilities:<br><pre class=code>
Method New(a:int)
  super.New()
End Method

Method New(a:int)
  'parental "new" are already called - what happens to overloaded ones?
End Method
</pre><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> New() already calls its parents New() automatically.<br>This would simply be extended to overloaded New() as well, it would call its parents equivalent or default New() if none is defined.<br>This is how most other OO languages do it.<br><br>Another thing is if you want to allow calling a New() in the same type.<br><pre class=code>
Type Base
  Method New()
    ' lots of work
  EndMethod

  Method New(x:Int)
    New()
    ' .. little work
  EndMethod
EndType
</pre><br>To follow the semantics of New() it would be required to be the first call in the method. <br><br></td></tr></table><br>
<a name="1299777"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> New() already calls its parents New() automatically. <br></div><br><br>So the question then is: which one is called?<br><br>a: New()<br>a: New(i:int, j:int = 0)<br>a: New(i:int)<br><br>b extends a<br>b: New(i:int)<br><br>With "b" wanting to take over the "initialization" of a, which "new()" is called then. And how to call a specific "super.New()" ?<br><br>Instead of "New()" (which does not state another scope than the "local" one) I would really prefer ("Super.New()") as "super" is already the keyword to access the parental class definition.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299780"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> So the question then is: which one is called? <br></div>The one with the same prototype, just like with methods. Unless it hasent been overridden in which case vanilla New().<br><br>Yeah, if your gonna allow calling constructors of base classes, "Super.New()" is the only way really.<br><br>What i meant with my sample above is to call another constructor within the same type.<br>To limit the copy-pasta. <br><br></td></tr></table><br>
<a name="1299781"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >seriouslee</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with Derron. An extended class should have to explicitly call its parent constructor. Automatically calling a parents constructor could produce unwanted effects. Using Super.New(argument[s]) makes the most sense to me. <br><br></td></tr></table><br>
<a name="1299786"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> This would also allow to use other New()-variants then the one called for the extended type.<br><br>back to my sample:<br><pre class=code>
Type B extends A
  Method New(i:int)
    Super.New(i, 2) 'calling New(i:int, j:int = 0) of a
    'do something else
  End Method
End Type
</pre><br><br>Still in question: how does the compiler know that New(i:int) is meant instead of New(i:int, j:int = 0) when calling Super.New(10). <br>Isn't this possible at all as the New(i,j=0) variant isn't 100% distinguishable?<br>-&gt; for overloaded methods "default params" are not allowed - or are they?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Id rather not have to explicitly call Super.New() in every New().<br>Its already automatically called, why change the semantics? There is no ambiguity here.<br><br>Having the option of also calling Super.New() yourself is a good thing too, at which point the automatic calling is not done.<br><br>For default arguments, the same can be said of regular overloaded methods.<br>Pascal for example, treats this as an error.<br><br>If you are to allow such ambiguity, i would go with calling "New(x)" because of the number of arguments.<br>You gave it 1 argument, so you get the 1 argument version. Unless there only is the 2 argument version then that is what you get instead. <br><br></td></tr></table><br>
<a name="1299814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >seriouslee</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Grable:<br>After re-analyzing Brucey's example I see what you are referring to. I had it my head a New method with parameters passed to it (Example: New(int, float, int)) in which I would want to have to explicitly call from an extended object, but, yes, a default New constructor (without parameters) should automatically be called.<br><br>In short, I'm with you :) <br><br></td></tr></table><br>
<a name="1299817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> On the one hand:<br>Do not do "default New()" is called "parametrized New()" is not called.<br>This leads to "is super.new() called now?" thoughts which means: ambiguity.<br><br><br>On the other hand:<br>If "New(params)"-definition is the same for base and extended type, then the "super.New(params)" should be called - at least is this what I would expect to happen (because of "super.new()" being called implicitely in vanilla BMX) . <br>But: vanilla BMX does not contain overload, so expectations to how things behave are non-existent. As I expect "MyMethod(int)" to not call "Super.MyMethod(int)" on its own, I am not sure why I should expect "New()" to behave similar. <br>All in all even in vanilla this isn't consequently done then.<br><br><br>How do other languages tackle it?<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299819"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> @seriouslee<br>hehe, dont worry. Its all up to Brucey in the end anyway ;)<br><br>Id also like to know the semantics of the below:<br><pre class=code>
Type A
  Method New( x:Int)
EndType

Type B Extends A
  Method New( x:Int, y:Int)
EndType

Local t:A = New A    ' allowed?
Local b:B = New B(1) ' allowed?
</pre> <br><br></td></tr></table><br>
<a name="1299825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  Id also like to know the semantics of the below <br></div><br>t calls the default constructor for A<br>b calls the overloaded constructor for A<br><br>which is what you'd expect, I think? <br><br></td></tr></table><br>
<a name="1299826"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  vanilla BMX does not contain overload, so expectations to how things behave are non-existent <br></div><br>Only if you've never used other programming languages, I suppose? <br><br></td></tr></table><br>
<a name="1299829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
a: New(i:int, j:int = 0)
a: New(i:int)
</pre><br>Probably not a good idea, since you would not be able to call New a(i).<br>I suppose that could be considered applicable for a compilation error - since you are introducing ambiguity within a single type.<br><br>On the other hand,<br><pre class=code>
a: New(i:int, j:int = 0)
b: New(i:int)
</pre><br>is fine, as the scope separates ambiguity here.<br>If you call new b(i), it will call b's constructor - since the scope takes precedence. <br><br></td></tr></table><br>
<a name="1299830"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> I hadn't considered constructor chaining... I suppose it is a reasonable thing to implement, as with  Super.New() calling, all of which would need to be done as the first statement.<br><br>I'll look into that.<br><br>It gets somewhat complicated, I see ;-) <br><br></td></tr></table><br>
<a name="1299831"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Only if you've never used other programming languages, I suppose? <br></div><br><br>So BMX-NG is only for people being used to other programming languages?<br><br>When it comes to "oop" I never really used overloading (only a bit tinkering in java, but I avoided such "odd situations" - and "overloaded constructors").<br><br><br>What I wanted to express in the prior posts is: there should be some "rules" a coder could follow. "Method New()" is already breaking it (you would better have named it "__construct" or so - to _not_ name it like the keyword.<br><br>keyword type<br>new bla -&gt; (new instance of bla).__construct()<br>delete bla -&gt; bla.__delete()<br><br>Because now it seems as if methods could be called that way ("methodname type"). Of course this inconsistency is not your (bmx-ng's) fault but blitzmax'.<br><br><br>Again: do not set your expectations to be "what all others expect" - there is a reason to have me and other "amateurs" on your side: we tell what we expect, without the "genious knowledge" some of the more experienced coders have.<br>But also do not get that wrong, it is your decision how things will evolve or not. We are surely able to bend our minds accordingly until we get used to it.<br>Just want to "brainstorm" a bit while things are not settled yet.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> which is what you'd expect, I think? <br></div>Yeah, i expected as much on account of bmx default constructors (even if they are empty :p).<br>Though there are languages that do not have default constructors (like Pascal and C++) in which an object must use one of the defined ones.<br><br>I dont know which is better really. Objects in blitzmax always have zeroed out data, so they are technically initialized even without a constructor.<br>So not requiring to call a constructor does fit with prior conventions in regards to constructor functions/methods doing the initializing in vanilla bmx.<br>The only difference would be that you cant initialize an already created instance, unless calling New() on them would be allowed ;) <br><br></td></tr></table><br>
<a name="1299837"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Objects in blitzmax always have zeroed out data <br></div><br><br>They contain the "null"-equivalents. so <br>int = 0<br>string = ""<br>object = null<br><br>For me this means, they are _not_ initialized. <br>Exception is if your type already predefines things:<br><br><pre class=code>
type test
  field listA:TList = CreateList() ' not null on "new test"
  field listB:TList                ' null on "new test"
end type
</pre><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess it depends on where your coming from. In C initialized==0 or any other valid pointer/data, as everything not explicitly initialized is random garbage.<br>Which is why i used "technically" ;)  The main point is that they are in a defined state.<br><br>Still, whether to allow default constructors when there are other defined ones is a hard one. As doing so might be seen to create uninitialized objects with no hope of ever being initialized to the proper state.<br>Stay with convention or go for more correctness? :p <br><br></td></tr></table><br>
<a name="1299842"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got and understood that point about null/initialized.<br>(albeit I am not sure but think to remember that I also had "garbage" values in some field-properties - years ago - maybe that was changed some versions ago or so?)<br><br><br>@ New<br>Wouldn't it be easier to disallow that feature at all (if we would not come to a consense :-)) there is still "new bla.init()" (which could be overloaded without trouble then).<br>But like said: we will get used to whatever you will come up.<br><br>Of course "SendMessage()" and other built-in methods should be overloadable like normal methods.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> In BlitzMax, all fields are initialised to *something*, either their default "zero" state, or whatever was specified in the field declaration.<br><br>@ New<br><br>Well, GW wanted it, so I thought I may as well implement it :-p<br>The general direction I'm taking with the overloading is to work in a similar way to Java, whose rules are basic and fairly easy to implement - but of course, in the flavour of BlitzMax.<br><br>Whether or not I can get it right, is another matter entirely :-) <br><br></td></tr></table><br>
<a name="1299868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Overloaded constructors is the probably the only kind I would use. If it gets into swampy territory, then don't add it on my account. Backwards compatibility is what would effect me the most in my projects. <br><br></td></tr></table><br>
<a name="1299881"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Backwards compatibility is what would effect me the most in my projects. <br> <br></div><br><br>I also think this should be one of the most important factors, even for new users not having to port any code (code archives etc.) <br><br></td></tr></table><br>
<a name="1299882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you did not use overloading in your current projects (chances are high if you use vanilla BMX ...) backwards compatibility should be no issue.<br><br>Once you use overloading then, it of course wont work with vanilla BMX any longer. (If you wrote it in a way, vanilla ignored the new "functionality", at least your application logic would be broken).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1299905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Cocopino</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br> If you did not use overloading in your current projects (chances are high if you use vanilla BMX ...) backwards compatibility should be no issue.<br> <br></div><br><br>Well, it does once we start renaming New() to __construct() or similar changes...<br>And while I've grown fond of using PHP over the years, naming conventions should probably be copied from elsewhere ;) <br><br></td></tr></table><br>
<a name="1299906"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> The name New() isn't changing. <br><br></td></tr></table><br>
<a name="1299946"></a>

<a name="1299947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a small contrived example which shows constructor chaining :<br><pre class=code>
SuperStrict

Framework brl.standardio

Local s:TSub = New TSub(15)
Print s.i

Type TBase

	Field i:Int

	Method New()
		New(10)
		Print "TBase() : " + Self.i
	End Method
	
	Method New(i:Int)
		Print "TBase(int) : " + Self.i
		Self.i = i
	End Method

End Type


Type TSub Extends TBase

	Method New()
		Print "TSub()"
	End Method
	
	Method New(i:Int)
		Print "TSub(int) : " + Self.i
		Self.i = i
	End Method

End Type
</pre><br>which outputs the following:<br><pre class=code>
TBase(int) : 0
TBase() : 10
TSub(int) : 10
15
</pre><br>And now a description of what occurred :-)<br><br>Initially, TSub.New(i:Int) is called.<br>Since it doesn't call another constructor itself, the default is to call the Super type default constructor.<br>So, TBase.New() is called next.<br>This in turn calls TBase.New(i:Int).<br>Finally,  the Object default constructor is called.<br><br>:o) <br><br></td></tr></table><br>
<a name="1299977"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >seriouslee</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the info, Brucey. Question: Is New() required? Would the following be acceptable?<br><pre class=code>
Local a:TType = New TType(15)

Type TType
  Field value:int

  Method New(newValue:int)
    value = newValue
  End Method
End Type
</pre> <br><br></td></tr></table><br>
<a name="1299993"></a>

<a name="1300009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>your example contains New() ?<br><br>EDIT:   Oh, I thought you meant omitting New() totally.<br><br>-Henri <br><br></td></tr></table><br>
<a name="1300000"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Is New() required? <br></div><br>No. You don't need to override the default New constructor.<br><br>In your example, you can still call "New TType" to create a new instance of TType...<br><pre class=code>
SuperStrict

Framework brl.standardio

Local a:TType = New TType(15)
Print a.value

a = New TType
Print a.value

Type TType
  Field value:int

  Method New(newValue:int)
    value = newValue
  End Method
End Type
</pre><br>.. would output :<br><pre class=code>
15
0
</pre> <br><br></td></tr></table><br>
<a name="1300002"></a>

<a name="1300003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Since it doesn't call another constructor itself, the default is to call the Super type default constructor. <br></div><br><br>So if adding a "New()" to the overloaded New(int) of TSub would then call this instead of "Super.New()" ?<br><br>Also: "super.New()" is always called - except there is no parent?<br>So for a "base class" all "New(...)"-variants wont call New() too?<br><br><br>Edit: feel free to update the github repo - so I could answer above's questions on my own.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1300104"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> So if adding a "New()" to the overloaded New(int) of TSub would then call this instead of "Super.New()" ? <br></div><br>If your code looks like this :<br><pre class=code>
Type TSub Extends TBase
	Method New(i:Int)
		New()
		Print "TSub(int) : " + Self.i
		Self.i = i
	End Method
End Type
</pre><br>It would call New() in TBase (either the default or the overridden one). There is *always* at least a default New().<br><br>If your code looks like this :<br><pre class=code>
Type TSub Extends TBase
	Method New()
		Print "TSub() : " + Self.i
	End Method

	Method New(i:Int)
		New()
		Print "TSub(int) : " + Self.i
		Self.i = i
	End Method
End Type
</pre><br>calling New TSub(10) would result in a call to TSub New(). <br><br></td></tr></table><br>
<a name="1300279"></a>

<a name="1300280"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Tried the newest revision - works nicely.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework Brl.StandardIO


Type TBase
	Method New()
		Print "TBase.New()"
	End Method
	
	Method New(i:Int)
		Print "TBase.New(i:int)"
	End Method
End Type


Type TSub Extends TBase
	Method New()
		'calls "Super.New()" automatically
		Print "TSub.New()"
	End Method
	
	Method New(i:Int)
		'without this, "Super.New()" is called
		'with this line, it calls "Super.New(i:int)" automatically instead
		Super.New( 10 )
		Print "TSub.New(i:int)"
	End Method
End Type


Type TOtherSub Extends TBase
	Method New()
		Print "TOtherSub.New()"
	End Method
	
	Method New(i:Int)
		Print "TOtherSub.New(i:int)"
	End Method
End Type


New TBase
Print "----"
New TBase(1)
Print "----"
New TSub
Print "----"
New TSub(1)
Print "----"
New TOtherSub
Print "----"
New TOtherSub(1)
Print "----"
</textarea><br><br><br>outputs:<br><pre class=code>
TBase.New()
----
TBase.New(i:int)
----
TBase.New()
TSub.New()
----
TBase.New(i:int)
TSub.New(i:int)
----
TBase.New()
TOtherSub.New()
----
TBase.New()
TOtherSub.New(i:int)
----
</pre><br><br>So what is happening:<br>- if you extend a type the New-Methods will call the parental New()-method<br>- they call the non-overloaded-New()-method (without params)<br>- if you call a custom "Super.New(xyz)"-method, the default Super.New() is skipped<br><br>Is this the "expected" behaviour? or should it try to call the same overloaded New(xyz)-method of its parent (if available) instead?<br><br>In this case this should mean, that the last output lines would look like this:<br><pre class=code>
TBase.New(i:int) '&lt;---- with param now
TOtherSub.New(i:int)
</pre><br><br><br>Like said: I think I would go d'accord with both solutions, just asking what is "expected" there (by the other Blitzmax-users - interested in NG).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1300295"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Is this the "expected" behaviour? <br></div><br>Yes. Whenever you don't specifically call a Super constructor in New() it automatically calls the default  super constructor (i.e. the one with no parameters). This is also what happens with the legacy compiler. <br><br></td></tr></table><br>
<a name="1300296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's an example of a simple copy constructor :<br><pre class=code>
SuperStrict

Framework brl.standardio

Local rect:TRect = New TRect(10, 10, 100, 200)
Print rect.ToString()

Local r2:TRect = New TRect(rect)
Print rect.ToString()

Type TRect

	Field x:Int
	Field y:Int
	Field w:Int
	Field h:Int

	Method New(x:Int, y:Int, w:Int, h:Int)
		Self.x = x
		Self.y = y
		Self.w = w
		Self.h = h
	End Method
	
	Method New(rect:TRect) ' copy constructor ;-)
		New(rect.x, rect.y, rect.w, rect.h)
	End Method

	Method ToString:String()
		Return x + ", " + y + ", " + w + ", " + h
	End Method
	
End Type
</pre><br>:o) <br><br></td></tr></table><br>
<a name="1300297"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> This is also what happens with the legacy compiler. <br></div><br><br>This is a matter of interpretation.<br><br>For _me_ it calls the super.method of the one I am in at this moment.<br>So when in new(int) it should call super.new(int).<br><br>Your interpretation is: when you create a new object in vanilla bmx ...all new() methods "downwards" are getting called.<br><br>As new(int) is an equal creator to new() i do not see the need to make new()  a preferred method. Backwards compatibility isn't given in both scenarios.<br><br><br>But like said..just a personal thought ... no need to adjust the behaviour if I am alone with that :-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1300851"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> So far, the following appears to be working :<br><br>* Method overloading.<br>* Function/static overloading (in types).<br>* Constructor (New) overloading.<br>* ToString, Compare and SendMessage overloading.<br><br>which probably covers most things.<br><br>The system uses name mangling when generating source. You can optionally disable mangling of Functions using { nomangle } metadata - useful for publicly accessed type functions (often used when calling into BlitzMax from C/C++). <br><br></td></tr></table><br>
<a name="1300937"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool!<br>Will this be merged into the main branch? <br><br></td></tr></table><br>
<a name="1300959"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, at some point.<br><br>I'm tidying up my modules in the meantime, applying nomangle where appropriate - which "generally" is all that needs to be done. There are the occasional edge cases where a method argument will need to be specifically cast to a type. For example, if you are passing a Double arg into a Float param you will need to manually cast it down to Float, or you will get a compilation error which should tell you that you can't pass a Double into a Float.<br><br>Here's an example of what I mean :<br><pre class=code>
SuperStrict

Framework brl.standardio

Local t:TType = New TType

Local a:Int = 10
Local b:Int = 5
Print t.add(a, b) ' ok. widens int to float

Local c:Float = 6.8
Local d:Float = 9.1
Print t.add(c, d) ' ok. args match param types

Local e:Double = 20
Local f:Double = 6
'Print t.add(e, f) ' compile error. Cannot narrow double to float.
Print t.add(Float(e), Float(f)) ' ok. cast down to float.

Type TType

	Method add:Float(a:Float, b:Float)
		Return a + b
	End Method

End Type
</pre> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
