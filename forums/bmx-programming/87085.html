<!DOCTYPE html><html lang="en" ><head ><title >2D Car control ?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >2D Car control ?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >2D Car control ?</a><br><br>
<a name="986979"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> * EDIT - Example updated<br><br>Has anyone had a crack at 2D overhead car physics?<br>What I have below is a basic 2D car control concept<br>(No external media required)<br><br>The problem is, I don't know how to implement 'skidding' (if the car turns sharply at high speed for example)<br><br>The car needs to slide across the road until grip is re-gained (through a combination of loss of speed and user turning into the skid)<br><br><br>I have tried to get my head around various online tutorials but get lost in the maths<br><br><br>CONTROLS<br>=============== <br>Use CURSORS to control steering and speed<br>Use SPACE to act as handbrake<br><br>NOTES<br>================<br>The little white stick which moves indicated where the turn of the wheels<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' car 2D physics

SuperStrict
Framework BRL.GLMax2D
'Import "param.bmx"

Const SW%=640,SH%=440
Graphics SW,SH

Global SpeedResistance#=29.18
Global SpeedFric1#=0.965
Global SpeedFric2#=300.0
Global RoadFriction#=1.001
Global TurnSpeedResistance#=30.6
Global ReturnWheelToCenter#=1.03

' MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

Type cartype
	Field img:TImage
	Field carx#,cary#,speed#,maxspeed#
	Field wheelang#,faceang#,moveang#
	' CREATE
	Function Create:cartype(xpos#,ypos#,maxmph# , szW#=48,szH#=84)
		Local c:cartype=New cartype
		c.img=CreateImage(szW,szH)
		Cls ; SetColor 120,0,0 ; DrawRect 0,0,szW,szH
		SetColor 170,170,0 ; DrawRect 8,10,12,9 ; DrawRect szW-8-12,10,12,9
		SetColor 255,255,255 ; GrabImage c.img,0,0 ; Cls
		SetImageHandle c.img,c.img.width/2,c.img.height/16*12
		c.carx=xpos ; c.cary=ypos
		c.maxspeed=maxmph/10.0
		Return c
	End Function
	' UPDATE
	Method UpdateCar()
		' input for cars steering and motion
		Local movedir%=KeyDown(KEY_UP)-KeyDown(KEY_DOWN)
		If Int(speed)&gt;maxspeed Then movedir=0
		Local steerdir%=KeyDown(KEY_RIGHT)-KeyDown(KEY_LEFT)
		' steering
		wheelang:+steerdir*1.05
		If wheelang&lt;-90 Then wheelang=-90
		If wheelang&gt;90 Then wheelang=90
		' control speed
		speed:+Float(movedir)/SpeedResistance
		If speed&gt;0
			speed=speed-(((maxspeed*SpeedFric1)-speed)/SpeedFric2)
		Else
			speed=speed+(((maxspeed*SpeedFric1)+speed)/SpeedFric2)
		EndIf
		speed:/RoadFriction
		If speed&gt;10.5 speed=10.5
		If speed&lt;-6.5 speed=-6.5
		' brakes
		If KeyDown(KEY_SPACE) speed:/1.06
		' project where car will move to
		If Abs(speed)&gt;0.01
			wheelang:/ReturnWheelToCenter
			faceang:+wheelang*(speed/50.0)
			carx:+Sin(faceang)*speed
			cary:-Cos(faceang)*speed
		EndIf		
		' wrap car around screen
		If carx&lt;-30 carx=sw+30
		If carx&gt;sw+30 carx=-30
		If cary&lt;-50 cary=sh+50
		If cary&gt;sh+50 cary=-50
	End Method
	' RENDER
	Method RenderCar()
		SetRotation faceang ; SetBlend MASKBLEND
		SetColor $ff,$ff,$ff
		DrawImage img,carx,cary
		SetRotation 0.0
	End Method
End Type

Global car1:cartype=cartype.Create(sw/2,sh/3*2,35 ,48,96)
Global car2:cartype=cartype.Create(46,90,10)
Global car3:cartype=cartype.Create(48,380,35)

' ******************************************

Repeat
	' draw background
	SetRotation 0.0 ; SetBlend SOLIDBLEND
	Cls ; SetColor 100,100,100
	For Local v%=0 Until SW Step 26
		DrawLine v,0,v,SH ; DrawLine 0,v,SW,v
	Next
	'
	car1.UpdateCar
	car2.renderCar ; car3.renderCar ; car1.RenderCar
	' speedo
	SetColor $ff,$ff,$ff ; SetAlpha 1.0
	SetRotation 0.0
	' wheel angle indicator
	DrawLine 300,40 , 300+Sin(car1.wheelang)*24,40-Cos(car1.wheelang)*24
	DrawText "MPH="+Int(car1.speed*10),20,sh-26
	Flip
Until KeyHit(KEY_ESCAPE)
End
' ******************************************

Function Wrap#(v#,lo#,hi#)
	If v&gt;hi v:-hi
	If v&lt;lo v:+hi
	Return v
End Function

Function Dist#(x1#,y1#,x2#,y2#)
	Local dx#=Abs(x1-x2)
	Local dy#=Abs(y1-y2)
	Return Sqr(dx*dx + dy*dy)
End Function

</textarea> <br><br></td></tr></table><br>
<a name="986995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> CBA to write code but you basically need two vectors.  One for the direction the car is facing (vF), and one for the direction the car is moving (vM).  When the player turns, you turn the vector vF.  vM is constantly updated so it will gradually turn towards vF at rate tR, and this will give an inertia effect.<br><br>By varying the rate tR you can simulate different track conditions - a lower rate for ice, a medium rate for water/dirt and a high rate for tarmac/dry.<br><br>That's the gist of it.  It'll take some tweaking to get the parameters to 'feel' right. <br><br></td></tr></table><br>
<a name="987068"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >siread</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rob Farley posted some excellent fake physics here...<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=72826#813991" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=72826#813991</a><br><br>It's B3D but easy enough to implement in 2D. It was a big help for my game New Star GP. <br><br></td></tr></table><br>
<a name="987094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> there was a blitzmax physics mod with a car example,<br><br>physlite at gooeyblob.com <br><br></td></tr></table><br>
<a name="987721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks all so far<br>One part I cannot get my head around is how to calculate the turning circle of the car<br><br>Look at this for example. Imagine the wheels are turned say, 40 degrees clockwise. The car would pivot somewhere to the right of  its  back/right wheel<br>How do you calculate something like this?<br><br><img src="http://i289.photobucket.com/albums/ll234/syntax_photos/carturningcircle.png"> <br><br></td></tr></table><br>
<a name="987725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Look at this for example. Imagine the wheels are turned say, 40 degrees clockwise. The car would pivot somewhere to the right of its back/right wheel <br></div><br><br>Don't forget that the car is moving too -- It's really the front wheels that pull the car around the curve, not the rear. There is no sideways movement of the front wheels, after all. <br><br></td></tr></table><br>
<a name="987733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep. Its the actual pivot point location I don't know how to calculate<br>If the wheels were turned just 1 degree then the car would barely rotate during its course of movement<br><br>Equally, if the wheels were at full lock (clockwise in this example) the car would be rotating at a point pretty close to the rear right wheel<br><br>If the wheels were 90 degrees I imagine the pivot point would be directly under the rear/right wheel<br><br>The question is, how do you calculate the correct 'pivot point' (as indicated by the  RED circle in the photo below?<br><br>I think at least two things need taking into account:<br><br>1) the amount of turn on the front wheels<br>2) the distance from the rear to the front wheel<br><br><img src="http://i289.photobucket.com/albums/ll234/syntax_photos/carturningcircle2.png"> <br><br></td></tr></table><br>
<a name="987767"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think you can get the path of the car like this...<br><br><img src="http://nathansfiles.synthasite.com/resources/car%20physics.png"> <br><br></td></tr></table><br>
<a name="987778"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I posted a conversion of Marco Monster's car physics code in the archives years ago :<br><br><a href="http://blitzbasic.com/codearcs/codearcs.php?code=135" target="_blank">http://blitzbasic.com/codearcs/codearcs.php?code=135</a><br><br>It allows full sliding power oversteer, understeer, 2 and 4 wheel drive to the front or rear wheels etc...<br><br>I've got a massively tweaked version of this code in a few small projects at the moment and it does allow for some pretty impressive car physics, albeit only on a 2d plane (there is no height aspect involved, so no jumps and cars won't increase speed down hills etc..). <br><br></td></tr></table><br>
<a name="987801"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am just skimming through the code Vorderman. Do you know if the code handles reversing of the car? <br><br></td></tr></table><br>
<a name="987898"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't remember about that particular code but my current version certainly does, so it should be pretty easy to add to that older code.<br><br>IIRC I just limit the speed to a low negative and then reduce the effect of the steering so the car doesn't turn too fast. I've also put reverse onto a seperate button so you can brake to a stop without auto-reversing. <br><br></td></tr></table><br>
<a name="987901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Many thanks. I have a BlitzMax version running<br><br>Q1) Got any good parameter settings there?<br><br>To me, the defaults make the sliding way too sensitive<br>Even travelling in a straight line makes the car slip<br>Also, when the car slides around it seems to stop abruptly after 90 degrees or so<br><br>Are you still chipping away on your SCR remake? <br><br></td></tr></table><br>
<a name="987929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> there are a few bugs in the advanced. The simpler one works great though.<br>here is the simpler one in a OO:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Graphics 800,600

Local car:Tcar = Tcar.Create(400,300,90,1)
'Main loop
While ( Not KeyDown(key_escape) )

    Cls

    car.do_input()
    
    car.do_physicsSimple()
    car.draw()
        
    Flip
    
Wend

End

Type Tcar

	Field x#
	Field y#

	'physics variables
	Field delta_t#
	Field DRAG#
	Field RESISTANCE#
	Field rear#
	Field front#
	Field MAX_GRIP#  
	Field MULT#
	Field MULT2#
	
	Field cartype%
	Field type_b#
	Field type_c#
	Field wheelbase#
	Field h#
	Field mass#
	Field inertia#
	Field width#
	Field length#
	Field wheellength#
	Field wheelwidth#
	Field car_velocity_wc_x#
	Field car_velocity_wc_y#
	Field car_angle#
	Field car_angularvelocity#
	Field car_steerangle#
	Field car_throttle#
	Field car_brake#
	
	Field front_slip%
	Field rear_slip%
	
	Field velocity_x#
	Field velocity_y#
	Field yawspeed#
	Field sn#, cs#
	Field xpos#, ypos#
	Field rot_angle#
	Field sideslip#
	Field slipanglefront#
	Field slipanglerear#
	Field flatf_x#, flatf_y#
	Field flatr_x#, flatr_y#
	Field weight#
	Field ftraction_x#, ftraction_y# 
	Field resistance_x#, resistance_y#
	Field force_x#, force_y#
	Field torque#
	Field acceleration_x#, acceleration_y#, angular_acceleration# 
	Field acceleration_wc_x#, acceleration_wc_y#
	
	Function Create:Tcar(x:Float, y:Float, ang:Float,_type:Int)
		Local car:Tcar = New Tcar
		car.x# = x
		car.y# = y
		car.carType = _type
		car.delta_t# = 0.01
		car.DRAG# = 5.0
		car.RESISTANCE# = 30.0
		car.rear# = -5.20
		car.front# = -5.0
		car.MAX_GRIP# = 5.0    
		car.MULT# = 57
		car.MULT2# = 0.01745
		
		car.type_b# = 1.0
		car.type_c# = 1.0
		car.wheelbase# = car.type_b# + car.type_c#
		car.h# = 1.0
		car.mass# = 1500
		car.inertia# = 1500
		car.width# = 1.5
		car.length# = 3.0
		car.wheellength# = 0.7
		car.wheelwidth# = 0.3
		car.car_velocity_wc_x# = 0
		car.car_velocity_wc_y# = 0
		car.car_angle# = ang
		car.car_angularvelocity# = 0
		car.car_steerangle# = 0
		car.car_throttle# = 0
		car.car_brake# = 0
		
		car.front_slip% = 0
		car.rear_slip% = 0
		Return car
	
	End function	
	
	'Input routine from joystick.pad.wheel
	Method do_input()
	
	    If ( KeyDown(key_up)) car_throttle# = 2000.0
	    If ( KeyDown(key_down) ) car_throttle# = 0.0
	    If ( Not KeyDown(key_up) ) 
	        car_throttle# = 0.0
	        car_brake# = 100.0
	    Else
	        car_brake# = 0.0
	    EndIf
	
	    car_steerangle# = 0.0
	    If ( KeyDown(key_right) ) car_steerangle# = (-Pi / 4.0) * 0.15'* MULT2#
	    If ( KeyDown(key_left) ) car_steerangle# = (Pi / 4.0) * 0.15' MULT2#
	
	    rear_slip = 0.0'
	    If ( KeyDown(key_lcontrol) ) rear_slip = 1.0'
	    
	    'temp display of vars
	    DrawText String(x#),0,0
	    DrawText String(y#),0,12
	    DrawText String(car_steerangle#),0,24
	
	    xpos# = x#
	    ypos# = y#
	
	End Method
	
	
	Method draw()
			
	    Local renda1# =( -car_angle# * MULT# ) - 60
	    If (renda1#&lt;0.0) Then renda1#=360.0+renda1#
	    Local renda2# =( -car_angle# * MULT# ) + 60
	    If (renda2#&gt;359.0) Then renda2#=renda2#-360.0
	    Local renda3# =( -car_angle# * MULT# ) - 120
	    If (renda3#&lt;0.0) Then renda3#=360.0+renda3#
	    Local renda4# =( -car_angle# * MULT# ) + 120
	    If (renda4#&gt;359.0) Then renda4#=renda4#-360.0
	
	    Local rendx1#=25*Cos(renda1#) ; Local rendy1#=25*Sin(renda1#)
	    Local rendx2#=25*Cos(renda2#) ; Local rendy2#=25*Sin(renda2#)
	    Local rendx3#=25*Cos(renda3#) ; Local rendy3#=25*Sin(renda3#)
	    Local rendx4#=25*Cos(renda4#) ; Local rendy4#=25*Sin(renda4#)
	
	    SetColor 255,255,255
	    DrawLine rendx1#+xpos#,rendy1#+ypos#,rendx2#+xpos#,rendy2#+ypos#
	    DrawLine rendx2#+xpos#,rendy2#+ypos#,rendx4#+xpos#,rendy4#+ypos#
	    DrawLine rendx4#+xpos#,rendy4#+ypos#,rendx3#+xpos#,rendy3#+ypos#
	    DrawLine rendx3#+xpos#,rendy3#+ypos#,rendx1#+xpos#,rendy1#+ypos#
	
	End Method
	
	Method do_physicsSimple()
	
	    sn# = Sin(car_angle# * MULT#)' * MULT2#
	    cs# = Cos(car_angle# * MULT#) '* MULT2#
	
	    DrawText "sn="+String(sn#)+" cs="+String(cs#),400,0
	
	    ' SAE convention; x is To the front of the car, y is To the Right, z is down
	    ' transform velocity in world reference frame To velocity in car reference frame
	    velocity_x# = cs# * car_velocity_wc_y# + sn# * car_velocity_wc_x#
	    velocity_y# = -sn# * car_velocity_wc_y# + cs# * car_velocity_wc_x#
	
	    ' Lateral force on wheels
	    ' Resulting velocity of the wheels as result of the yaw rate of the car body
	    ' v = yawrate * r where r is distance of wheel To CG (approx. half wheel base)
	    ' yawrate (ang.velocity) must be in rad.s
	    yawspeed# = wheelbase# * 0.5 * car_angularvelocity#
	
	    If( velocity_x# = 0 )
	        rot_angle# = 0
	    Else 
	'        rot_angle# = ATan2( (yawspeed# * MULT#) , (velocity_x# * MULT#) )
	        rot_angle# = ATan2( (yawspeed# ) , (velocity_x#) ) * MULT2#
	    EndIf
	
	    ' Calculate the side slip angle of the car (a.k.a. beta)
	    If( velocity_x# = 0 )
	        sideslip# = 0.0
	    Else
	'        sideslip# = ATan2( (velocity_y# * MULT#) , (velocity_x# * MULT#) )        
	        sideslip# = ATan2( (velocity_y# ) , (velocity_x#) )    * MULT2#    
	    EndIf
	
	    ' Calculate slip angles For front And rear wheels (a.k.a. Alpha)
	    slipanglefront# = sideslip# + rot_angle# - car_steerangle#
	    slipanglerear# = sideslip# - rot_angle#
	
	    ' weight per axle = half car mass times 1G (=9.8m.s^2) 
	    weight# = mass# * 9.8 * 0.5
	    
	    ' lateral force on front wheels = (Ca * slip angle) capped To friction circle * Load
	    flatf_x# = 0.0
	    flatf_y# = front# * slipanglefront#
	
	'    If ( flatf_y# &gt; MAX_GRIP# ) flatf_y# = MAX_GRIP#
	'    If ( flatf_y# &lt; -MAX_GRIP# ) flatf_y# = -MAX_GRIP#
	
	    flatf_y# = flatf_y# * weight#
	    
	    ' allow front wheels To slip
	    If(front_slip=1) flatf_y# = flatf_y# * 0.5
	
	    ' lateral force on rear wheels
	    flatr_x# = 0.0
	    flatr_y# = rear# * slipanglerear#
	
	'    If ( flatr_y# &gt; MAX_GRIP# ) flatr_y# = MAX_GRIP#
	'    If ( flatr_y# &lt; -MAX_GRIP# ) flatr_y# = -MAX_GRIP#
	
	    flatr_y# = flatr_y# * weight#
	    
	    If(rear_slip = 1.0) flatr_y# = flatr_y# * 0.5
	
	    ' longtitudinal force on rear wheels - very simple traction model
	    ftraction_x# = 100.0 * (car_throttle# - car_brake# * Sgn(velocity_x#))
	    ftraction_y# = 0.0
	
	    If(rear_slip = 1.0) ftraction_x# = ftraction_x# * 0.5
	
	    ' Forces And torque on body
	    ' drag And rolling resistance
	    resistance_x# = -( RESISTANCE# * velocity_x# + DRAG# * velocity_x# * Abs( velocity_x# ) )
	    resistance_y# = -( RESISTANCE# * velocity_y# + DRAG# * velocity_y# * Abs( velocity_y# ) )
	
	    ' sum forces
	    force_x# = ftraction_x# + (Sin( car_steerangle# * MULT# )) * flatf_x# + flatr_x# + resistance_x#
	    force_y# = ftraction_y# + (Cos( car_steerangle# * MULT# )) * flatf_y# + flatr_y# + resistance_y#    
	
	    ' torque on body from lateral forces
	    torque# = type_b# * flatf_y# - type_c# * flatr_y#
	
	    ' Acceleration
	    ' Newton F = m.a, therefore a = F.m
	    acceleration_x# = force_x# / mass#
	    acceleration_y# = force_y# / mass#
	    
	    angular_acceleration# = torque# / inertia#
	
	    ' Velocity And position
	    ' transform acceleration from car reference frame To world reference frame
	    acceleration_wc_x# = cs# * acceleration_y# + sn# * acceleration_x#
	    acceleration_wc_y# = -sn# * acceleration_y# + cs# * acceleration_x#
	
	    ' velocity is integrated acceleration
	    car_velocity_wc_x# = car_velocity_wc_x# + (delta_t# * acceleration_wc_x#)
	    car_velocity_wc_y# = car_velocity_wc_y# + (delta_t# * acceleration_wc_y#)
	
	    ' position is integrated velocity
	    x# = x# + (delta_t# * car_velocity_wc_x#)
	    y# = y# + (delta_t# * car_velocity_wc_y#)
	
	    ' Angular velocity And heading
	    ' integrate angular acceleration To get angular velocity
	    car_angularvelocity# = car_angularvelocity# + (delta_t# * angular_acceleration#)
	
	    ' integrate angular velocity To get angular orientation
	    car_angle# = car_angle# + (delta_t# * car_angularvelocity#)
	
	    If ( x# &lt; 0.0 ) x# = 800.0
	    If ( x# &gt; 800.0 ) x# = 0.0
	    If ( y# &lt; 0.0 ) y# = 600.0
	    If ( y# &gt; 600.0 ) y# = 0.0
	    
	End Method
	
	
	
	
	'2. ADDITIONS . CHANGES For rear.front.4 wheel drive
	
	'Type of car - 1=rear 2=front 3=four
	
	

End Type


</textarea><br><br>on the advanced one these two variables are calculated but not used at all.<br><pre class=code>
car_COGx#
car_COGy#
</pre><br>it seems to me that there still needs something to be calculated. <br><br></td></tr></table><br>
<a name="987946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice Jesse. I was going to OOP it too<br>However, the example still seems to suffer the exact same issues as Vordermans<br><br>I have taken your example and applied a reference grid and "Parameter Editor" (so that you can goof around with the cars general parameters)<br><br>By default the car seems to be running on extremely smooth ice and I want to avoid this 'uncontrollable' feel<br>I do want the car to skid but under much harder force. I just don't know how to apply more grip to the car (or indeed make the road feel like tarmac)<br>MULTI2 is about the closest one for containing the skidding<br>The car gets a bit wobbly/shaky though after its stops depending on what the parameters are tweaked to<br><br>Also, as Vordermans, when you apply the handbrake (SPACEBAR in my example here) the car whips around quickly to 90 degrees or so with a sudden halt. This looks unrealistic to me<br><br><img src="http://i289.photobucket.com/albums/ll234/syntax_photos/CarParamEdit.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Car Physics - take 3

SuperStrict

Framework BRL.GLMax2D

Const SW%=640 , SH%=480
Graphics SW,SH

Local car:Tcar = Tcar.Create(400,300,90,1)
'
param.xpos=70 ; param.ypos=42
param.add Varptr(car.Delta_t),"Delta T",0.005,0.1
param.add Varptr(car.DRAG),"Drag",0.1,100
param.add Varptr(car.RESISTANCE),"Resist",10,500
param.add Varptr(car.MAX_GRIP),"Grip",1,50
param.add Varptr(car.mass),"Mass",100,5000
param.add Varptr(car.inertia),"Inertia",100,5000
param.add Varptr(car.MULT2),"Mult2",0.05,1.0
'


'Main loop
While ( Not KeyDown(key_escape) )
	' draw reference grid
	SetClsColor 40,110,40
	Cls ; SetColor 30,88,30
	For Local v%=0 Until SW Step 26
		DrawLine v,0,v,SH ; DrawLine 0,v,SW,v
	Next
	'
	If MouseHit(2) Param.ToggleEditor
	param.Update
	'
	SetColor $ff,$ff,$ff
    car.do_input()
    car.do_physicsSimple()
    car.draw()
    Flip
Wend

End

Type Tcar

	Field x#,y#

	'physics variables
	Field delta_t#=0.01, DRAG#=5.0 , RESISTANCE#=30.0
	Field rear# = -5.20 , front# = -5.0 , MAX_GRIP# =15.0
	Field MULT# = 57 , MULT2# = 0.01745
	
	Field cartype% , type_b# = 1.0 , type_c# = 1.0
	Field wheelbase# = 1.0+1.0 ' type_b+type_c
	Field h#=1.0 , mass#=1500, inertia#=1500
	Field width#=1.5 , length#=3.0
	Field wheellength#=0.7 , wheelwidth#=0.3

	Field car_velocity_wc_x# , car_velocity_wc_y#
	Field car_angle# , car_angularvelocity#
	Field car_steerangle# , car_throttle# , car_brake#
	Field front_slip% , rear_slip%
	
	Field velocity_x# , velocity_y#
	Field yawspeed# , sn#, cs# , xpos#, ypos#
	Field rot_angle# , sideslip# , slipanglefront#
	Field slipanglerear#
	Field flatf_x#, flatf_y# , flatr_x#, flatr_y#
	Field weight#
	Field ftraction_x#, ftraction_y# 
	Field resistance_x#, resistance_y#
	Field force_x#, force_y# , torque#
	Field acceleration_x#, acceleration_y#, angular_acceleration# 
	Field acceleration_wc_x#, acceleration_wc_y#
	
	Function Create:Tcar(x:Float, y:Float, ang:Float,_type:Int)
		Local car:Tcar = New Tcar
		car.x# = x ; car.y# = y
		car.carType = _type
		car.car_angle# = ang
		Return car	
	End Function	
	
	'Input routine from joystick.pad.wheel
	Method do_input()
		Local inputmove%=KeyDown(KEY_UP)-KeyDown(KEY_DOWN)
		Local inputsteer%=KeyDown(KEY_RIGHT)-KeyDown(KEY_LEFT)

	    If inputmove=1 Then car_throttle# = 2000.0
	    If inputmove=0 Then car_throttle# = 0.0
	    If inputmove=-1 
	        car_throttle# = 0.0
	        car_brake# = 1000.0
	    Else
	        car_brake# = 0.0
	    EndIf
	
	    car_steerangle# = 0.0
	    If inputsteer=+1 Then car_steerangle# = (-Pi / 4.0) * 0.15'* MULT2#
	    If inputsteer=-1 Then car_steerangle# = (Pi / 4.0) * 0.15' MULT2#
		' handbrake
	    rear_slip = 0.0
	    If KeyDown(KEY_SPACE) Then rear_slip = 1.0
	    
		DrawText "Press Mouse RMB to toggle parameter editor" , 10,SH-30
	  	'DrawText String(x#),0,
	   	'DrawText String(y#),0,12
	     'DrawText String(car_steerangle#),0,24
	
	    xpos# = x#
	    ypos# = y#
	
	End Method
	
	
	Method draw()
			
	    Local renda1# =( -car_angle# * MULT# ) - 60
	    If (renda1#&lt;0.0) Then renda1#=360.0+renda1#
	    Local renda2# =( -car_angle# * MULT# ) + 60
	    If (renda2#&gt;359.0) Then renda2#=renda2#-360.0
	    Local renda3# =( -car_angle# * MULT# ) - 120
	    If (renda3#&lt;0.0) Then renda3#=360.0+renda3#
	    Local renda4# =( -car_angle# * MULT# ) + 120
	    If (renda4#&gt;359.0) Then renda4#=renda4#-360.0
	
	    Local rendx1#=25*Cos(renda1#) ; Local rendy1#=25*Sin(renda1#)
	    Local rendx2#=25*Cos(renda2#) ; Local rendy2#=25*Sin(renda2#)
	    Local rendx3#=25*Cos(renda3#) ; Local rendy3#=25*Sin(renda3#)
	    Local rendx4#=25*Cos(renda4#) ; Local rendy4#=25*Sin(renda4#)
	
	    SetColor 155,255,155
	    DrawLine rendx1#+xpos#,rendy1#+ypos#,rendx2#+xpos#,rendy2#+ypos#
	    DrawLine rendx2#+xpos#,rendy2#+ypos#,rendx4#+xpos#,rendy4#+ypos#
	    DrawLine rendx4#+xpos#,rendy4#+ypos#,rendx3#+xpos#,rendy3#+ypos#
	    DrawLine rendx3#+xpos#,rendy3#+ypos#,rendx1#+xpos#,rendy1#+ypos#
		SetColor $ff,$ff,$ff
	End Method
	
	Method do_physicsSimple()
	
	    sn# = Sin(car_angle# * MULT#)' * MULT2#
	    cs# = Cos(car_angle# * MULT#) '* MULT2#
	
	    DrawText "sn="+String(sn#)+" cs="+String(cs#),400,0
	
	    ' SAE convention; x is To the front of the car, y is To the Right, z is down
	    ' transform velocity in world reference frame To velocity in car reference frame
	    velocity_x# = cs# * car_velocity_wc_y# + sn# * car_velocity_wc_x#
	    velocity_y# = -sn# * car_velocity_wc_y# + cs# * car_velocity_wc_x#
	
	    ' Lateral force on wheels
	    ' Resulting velocity of the wheels as result of the yaw rate of the car body
	    ' v = yawrate * r where r is distance of wheel To CG (approx. half wheel base)
	    ' yawrate (ang.velocity) must be in rad.s
	    yawspeed# = wheelbase# * 0.5 * car_angularvelocity#
	
	    If( velocity_x# = 0 )
	        rot_angle# = 0
	    Else 
	'        rot_angle# = ATan2( (yawspeed# * MULT#) , (velocity_x# * MULT#) )
	        rot_angle# = ATan2( (yawspeed# ) , (velocity_x#) ) * MULT2#
	    EndIf
	
	    ' Calculate the side slip angle of the car (a.k.a. beta)
	    If( velocity_x# = 0 )
	        sideslip# = 0.0
	    Else
	'        sideslip# = ATan2( (velocity_y# * MULT#) , (velocity_x# * MULT#) )        
	        sideslip# = ATan2( (velocity_y# ) , (velocity_x#) )    * MULT2#    
	    EndIf
	
	    ' Calculate slip angles For front And rear wheels (a.k.a. Alpha)
	    slipanglefront# = sideslip# + rot_angle# - car_steerangle#
	    slipanglerear# = sideslip# - rot_angle#
	
	    ' weight per axle = half car mass times 1G (=9.8m.s^2) 
	    weight# = mass# * 9.8 * 0.5
	    
	    ' lateral force on front wheels = (Ca * slip angle) capped To friction circle * Load
	    flatf_x# = 0.0
	    flatf_y# = front# * slipanglefront#
	
	'    If ( flatf_y# &gt; MAX_GRIP# ) flatf_y# = MAX_GRIP#
	'    If ( flatf_y# &lt; -MAX_GRIP# ) flatf_y# = -MAX_GRIP#
	
	    flatf_y# = flatf_y# * weight#
	    
	    ' allow front wheels To slip
	    If(front_slip=1) flatf_y# = flatf_y# * 0.5
	
	    ' lateral force on rear wheels
	    flatr_x# = 0.0
	    flatr_y# = rear# * slipanglerear#
	
	'    If ( flatr_y# &gt; MAX_GRIP# ) flatr_y# = MAX_GRIP#
	'    If ( flatr_y# &lt; -MAX_GRIP# ) flatr_y# = -MAX_GRIP#
	
	    flatr_y# = flatr_y# * weight#
	    
	    If(rear_slip = 1.0) flatr_y# = flatr_y# * 0.5
	
	    ' longtitudinal force on rear wheels - very simple traction model
	    ftraction_x# = 100.0 * (car_throttle# - car_brake# * Sgn(velocity_x#))
	    ftraction_y# = 0.0
	
	    If(rear_slip = 1.0) ftraction_x# = ftraction_x# * 0.5
	
	    ' Forces And torque on body
	    ' drag And rolling resistance
	    resistance_x# = -( RESISTANCE# * velocity_x# + DRAG# * velocity_x# * Abs( velocity_x# ) )
	    resistance_y# = -( RESISTANCE# * velocity_y# + DRAG# * velocity_y# * Abs( velocity_y# ) )
	
	    ' sum forces
	    force_x# = ftraction_x# + (Sin( car_steerangle# * MULT# )) * flatf_x# + flatr_x# + resistance_x#
	    force_y# = ftraction_y# + (Cos( car_steerangle# * MULT# )) * flatf_y# + flatr_y# + resistance_y#    
	
	    ' torque on body from lateral forces
	    torque# = type_b# * flatf_y# - type_c# * flatr_y#
	
	    ' Acceleration
	    ' Newton F = m.a, therefore a = F.m
	    acceleration_x# = force_x# / mass#
	    acceleration_y# = force_y# / mass#
	    
	    angular_acceleration# = torque# / inertia#
	
	    ' Velocity And position
	    ' transform acceleration from car reference frame To world reference frame
	    acceleration_wc_x# = cs# * acceleration_y# + sn# * acceleration_x#
	    acceleration_wc_y# = -sn# * acceleration_y# + cs# * acceleration_x#
	
	    ' velocity is integrated acceleration
	    car_velocity_wc_x# = car_velocity_wc_x# + (delta_t# * acceleration_wc_x#)
	    car_velocity_wc_y# = car_velocity_wc_y# + (delta_t# * acceleration_wc_y#)
	
	    ' position is integrated velocity
	    x# = x# + (delta_t# * car_velocity_wc_x#)
	    y# = y# + (delta_t# * car_velocity_wc_y#)
	
	    ' Angular velocity And heading
	    ' integrate angular acceleration To get angular velocity
	    car_angularvelocity# = car_angularvelocity# + (delta_t# * angular_acceleration#)
	
	    ' integrate angular velocity To get angular orientation
	    car_angle# = car_angle# + (delta_t# * car_angularvelocity#)
	
	    If ( x# &lt; 0.0 ) x# = SW
	    If ( x# &gt; SW ) x# = 0.0
	    If ( y# &lt; 0.0 ) y# = SH
	    If ( y# &gt; SH ) y# = 0.0
	    
	End Method
	

	'2. ADDITIONS . CHANGES For rear.front.4 wheel drive
	
	'Type of car - 1=rear 2=front 3=four

End Type



' PARMETER EDITOR

Type Param
	Global BarWidth%=400 , BarHeight%=16 , XPos%=160 , YPos%=4
	Global MX%,MY%,cY% , Current:Param
	Global list:TList=New TList
	Global EditMode% , MouseWheelValue%
	Global BackR%=$22,BackG%=$22,BackB%=$10
	Global ForeR%=$ff,ForeG%=$ff,ForeB%=$cc
	Global Alpha#=0.6
	Field name$,val:Float Ptr,lo#,hi#
	'
	Function Add(value:Float Ptr, pname$,loval#=0.0,hival#=100.0)
		Local p:Param=New Param
		Param.list.AddLast p
		p.name$=pname$ ; p.lo=loval ; p.hi=hival
		If p.lo&gt;=p.hi p.lo=p.hi-0.01
		p.val=value
		If p.val[0]&gt;p.hi p.val[0]=p.hi
		If p.val[0]&lt;p.lo p.val[0]=p.lo
	End Function
	'
	Method IsMouseOver%()
		If Param.MX&gt;=Param.XPos And Param.MX&lt;=Param.XPos+Param.BarWidth
			If Param.MY&gt;=Param.cY And Param.MY&lt;=Param.cY+Param.BarHeight
				Return True
			EndIf
		EndIf
	End Method
	'
	Function Update()
		Global percent%
		If Param.EditMode=False Return
		SetRotation 0.0 ; SetScale 1.0,1.0 ; SetBlend ALPHABLEND
		SetAlpha Param.Alpha
		Param.cY%=Param.YPos ; 
		If Param.MX&lt;&gt;MouseX() Or Param.MY&lt;&gt;MouseY() Param.MouseWheelValue=MouseZ()
		Param.MX=MouseX() ; Param.MY=MouseY()
		For Local p:param=EachIn Param.list
			' is mouse over bar when left button is down?
			If MouseZ()&lt;&gt;Param.MouseWheelValue
				If p.IsMouseOver()
					p.val[0]:+(Float(MouseZ()-Float(Param.MouseWheelValue)))/100.0
					Param.MouseWheelValue=MouseZ()
				EndIf
			EndIf
			If MouseDown(1)
				If Param.Current=p
						percent=(Param.MX-Param.XPos)/(Float(Param.BarWidth)/100.0)
						If percent&lt;0 percent=0
						If percent&gt;100 percent=100
						p.val[0]=((p.hi-p.lo)*(Float(percent)/100.0))+p.lo	
				Else
					If p.IsMouseOver()
						If Param.Current=Null	Param.Current=p
					EndIf
				EndIf
			EndIf
			If MouseDown(1)=0
				Param.Current=Null
			EndIf
			' render
			SetColor Param.BackR,Param.BackG,Param.BackB
			DrawRect Param.XPos-2 , Param.cY , Param.BarWidth+4 , Param.BarHeight
			SetColor Param.ForeR,Param.ForeG,Param.ForeB
			percent=Abs((p.val[0]-p.lo)/(p.hi-p.lo))*100.0
			DrawRect Param.XPos , Param.cY+1 , percent*(Float(Param.BarWidth)/100.0) , Param.BarHeight-2
			DrawText p.name,Param.XPos-TextWidth(p.name)-4,Param.cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			DrawText p.val[0],Param.XPos+Param.BarWidth+4,cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			Param.cY:+Param.BarHeight+2
		Next
		SetBlend SOLIDBLEND ; SetAlpha 1.0
	End Function
	'
	Function ShowEditor()
		Param.EditMode=True
	End Function
	Function HideEditor()
		Param.EditMode=False
	End Function
	Function ToggleEditor()
		Param.EditMode=Not Param.EditMode
	End Function
End Type
</textarea><br><br><br><br><br><br><br>The general "feel" I am after is that as demonstrated by my first simple example at the top of this thread <br><br></td></tr></table><br>
<a name="987975"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've no idea about parameters specific to this code, as I wrote it years ago and my current code is pretty well modified with most things having been tweaked and new parameters added, and I'd rather not hand that code out to everyone as it's taken a long time to develop.<br><br>Here are my current settings params, no idea how many of them the old code uses though -<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
            car.delta_T1 = 0.015;
            car.delta_T2 = (car.delta_T1 / 2.0);
            // friction values - -8.2 &amp; -12.0 seem OK for gravel, -12.2 &amp; -16.0 OK for tarmac
            car.CA_R = -8.2;       // -12.2
            car.CA_F = -12.0;       // -16.0
            car.front_grip_max = 0.5;
            car.rear_grip_max = 0.25;
            car.front_weight_bias = 2.0;
            car.rear_weight_bias = 2.5;
            car.steering_fade_with_speed = 100.0;
            car.max_grip = 3.0;
            car.c_angle = NEW_angle;
            car.ct_b = 1.0;
            car.ct_c = 1.0;
            car.ct_mass = 2000.0;
            car.ct_inertia = 1100.0;
            car.c_redline = 300.0;
            car.c_throttle_response = 15.0;
            car.c_steering_lock = Math.PI / 4.0;
            car.c_steering_centre = 0.1;
            car.steering_adjust_ratio = 1.0;
            //handbrake_on = false;
            car.base_CA_F = car.CA_F;
            car.base_CA_R = car.CA_R;
            car.reverse_speed = 0.0;
            car.gear = 1;
            car.c_velocity_wc_x = 0.0;
            car.c_velocity_wc_y = 0.0;
            car.c_angular_velocity = 0.0;
            car.ct_wheelbase = car.ct_b + car.ct_c;
            car.sideslip = 0.0;
            car.slip_angle_front = 0.0;
            car.slip_angle_rear = 0.0;
            car.c_steerangle = 0.0;
            car.frontslip = false;
            car.rearslip = false;
            car.c_throttle = 0.0;
            car.c_brake = 0.0;
            car.c_position_wc_x = NEW_position_x;
            car.c_position_wc_y = NEW_position_y;
            car.forward_speed = 0.0;
            car.steer_adjust = 0.0;

            car.base_resistance = 300.0;
            car.resistance = car.base_resistance;
            car.drag = 5.0;
</textarea><br><br>However with some tweaking you certainly should be able to achieve a solid nicely-handling car - as inspiration, have a look at this short (and poor-quality!) video of a drift car in my current test app :<br><br><a href="http://webspace.mypostoffice.co.uk/~james.kett/B3D_drift.flv" target="_blank">http://webspace.mypostoffice.co.uk/~james.kett/B3D_drift.flv</a> <br><br></td></tr></table><br>
<a name="988096"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great-looking car control in the video. Definitely the kind of control I'm aiming for<br><br>Things are starting to take shape although the car is suffering from the shivers when I brake to a complete stop<br>I am thinking this is down to floating point variables being divided into tiny fractions<br><br>BTW, +1 for the donut in the video! <br><br></td></tr></table><br>
<a name="988108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think the shivering is caused by the car's angle parameter being updated with fluctuating amounts when the speed is very low.<br><br>I use this piece of code in the physics routine to prevent it happening - note that this takes into account whether the player has lots of throttle on or not, so the player can still accelerate away if they want to.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	;prevent the car juddering when near staionary
	If (v\forward_speed# &lt; 2.0) And (v\forward_speed# =&gt; 0.0) 
		If (Abs(v\c_throttle#) &lt; (v\c_throttleresponse# * 4)) Or (v\gear=0)
			v\forward_speed# = 0.0
			v\c_angularvelocity# = 0.0
			v\c_velocity_wc_x# = 0.0
			v\c_velocity_wc_y# = 0.0
			v\slipanglerear# = 0.0
			v\slipanglefront# = 0.0
			v\sideslip# = 0.0
			acceleration_wc_x# = 0.0
			acceleration_wc_y# = 0.0
			angularacceleration# = 0.0
		EndIf
	EndIf
</textarea> <br><br></td></tr></table><br>
<a name="988221"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll take a look at that Vordeman. Thanks<br><br>Also, I spotted things like:<br><pre class=code>
        If( velocity_x# = 0 )
                   .....
</pre><br>Since the velocity_x# is a float it is very unlikely to equal '0'<br>I changed these occurrences to:<br><br><pre class=code>
        If Int(velocity_x) = 0
                   .....
</pre><br>Which seems to have stabilized the car completely when stopping<br><br><br><br>Nice working example<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Car Physics - take 4

SuperStrict

Framework BRL.GLMax2D

Const SW%=640 , SH%=480
Graphics SW,SH

Local car:Tcar = Tcar.Create(400,300,42)
'
param.xpos=70 ; param.ypos=42
param.add Varptr(car.Delta_t),"Delta T",0.005,0.1
param.add Varptr(car.DRAG),"Drag",0.1,100
param.add Varptr(car.RESISTANCE),"Resist",10,500
param.add Varptr(car.MAX_GRIP),"Grip",1,50
param.add Varptr(car.mass),"Mass",100,5000
param.add Varptr(car.inertia),"Inertia",100,5000
param.add Varptr(car.MULT2),"Mult2",0.005,1.0
param.add Varptr(car.rear),"Rear",-15,-1
param.add Varptr(car.front),"Front",-15,-1
param.add Varptr(car.steeramount),"Steer Am",0.05,0.8
'


'Main loop
While ( Not KeyDown(key_escape) )
	' draw reference grid
	SetClsColor 40,110,40
	Cls ; SetColor 30,88,30
	For Local v%=0 Until SW Step 26
		DrawLine v,0,v,SH ; DrawLine 0,v,SW,v
	Next
	'
	If MouseHit(2) Param.ToggleEditor
	param.Update
	'
	SetColor $ff,$ff,$ff
    car.do_input()
    car.do_physicsSimple()
    car.draw()
    Flip
Wend

End

Type Tcar
	Field x#,y#
	'physics variables
	Field delta_t#=0.02, DRAG#=5.0 , RESISTANCE#=39.4
	Field rear# = -7.3 , front# = -7.8 , MAX_GRIP# =29.3
	Field MULT# = 57 , MULT2# = 0.164
	
	Field cartype% , type_b# = 1.0 , type_c# = 1.0
	Field wheelbase# = 1.0+1.0 ' type_b+type_c
	Field h#=1.0 , mass#=1815, inertia#=2206
	Field width#=1.5 , length#=3.0
	Field wheellength#=0.7 , wheelwidth#=0.3 , steeramount#=0.24

	Field car_velocity_wc_x# , car_velocity_wc_y#
	Field car_angle# , car_angularvelocity#
	Field car_steerangle# , car_throttle# , car_brake#
	Field front_slip_Flag%=False , rear_slip%
	
	Field velocity_x# , velocity_y#
	Field yawspeed# , sn#, cs# , xpos#, ypos#
	Field rot_angle# , sideslip# , slipanglefront#
	Field slipanglerear#
	Field flatf_x#, flatf_y# , flatr_x#, flatr_y#
	Field weight#
	Field ftraction_x#, ftraction_y# 
	Field resistance_x#, resistance_y#
	Field force_x#, force_y# , torque#
	Field acceleration_x#, acceleration_y#, angular_acceleration# 
	Field acceleration_wc_x#, acceleration_wc_y#
	
	Function Create:Tcar(x:Float, y:Float, ang:Float)
		Local car:Tcar = New Tcar
		car.x# = x ; car.y# = y
		car.car_angle# = ang
		Return car	
	End Function	
	
	'Input routine from joystick.pad.wheel
	Method do_input()
		Local inputmove%=KeyDown(KEY_UP)-KeyDown(KEY_DOWN)
		Local inputsteer%=KeyDown(KEY_RIGHT)-KeyDown(KEY_LEFT)

	    If inputmove=1 Then car_throttle# = 1200.0
	    If inputmove=0 Then car_throttle# = 0.0
	    If inputmove=-1 
	        car_throttle# = 0.0
	        car_brake# = 800.0
	    Else
	        car_brake# = 0.0
	    EndIf
	
	    car_steerangle# = 0.0
	    If inputsteer=+1 Then car_steerangle# = (-Pi / 4.0) * steeramount
	    If inputsteer=-1 Then car_steerangle# = (Pi / 4.0) * steeramount
		' handbrake
	    rear_slip = 1.0
	    If KeyDown(KEY_SPACE) Then rear_slip = 1.4
	    
		DrawText "Press Mouse RMB to toggle parameter editor" , 10,SH-30
	  	'DrawText String(x#),0,
	   	'DrawText String(y#),0,12
	     'DrawText String(car_steerangle#),0,24
	
	    xpos# = x#
	    ypos# = y#
	
	End Method
	
	
	Method draw()
			
		Local renda1# =( -car_angle# * MULT# ) - 60
		If (renda1#&lt;0.0) Then renda1#=360.0+renda1#
		Local renda2# =( -car_angle# * MULT# ) + 60
		If (renda2#&gt;359.0) Then renda2#=renda2#-360.0
		Local renda3# =( -car_angle# * MULT# ) - 120
		If (renda3#&lt;0.0) Then renda3#=360.0+renda3#
		Local renda4# =( -car_angle# * MULT# ) + 120
		If (renda4#&gt;359.0) Then renda4#=renda4#-360.0
		
		Local rendx1#=25*Cos(renda1#) ; Local rendy1#=25*Sin(renda1#)
		Local rendx2#=25*Cos(renda2#) ; Local rendy2#=25*Sin(renda2#)
		Local rendx3#=25*Cos(renda3#) ; Local rendy3#=25*Sin(renda3#)
		Local rendx4#=25*Cos(renda4#) ; Local rendy4#=25*Sin(renda4#)
		
		SetColor 155,255,155
		DrawLine rendx1#+xpos#,rendy1#+ypos#,rendx2#+xpos#,rendy2#+ypos#
		DrawLine rendx2#+xpos#,rendy2#+ypos#,rendx4#+xpos#,rendy4#+ypos#
		DrawLine rendx4#+xpos#,rendy4#+ypos#,rendx3#+xpos#,rendy3#+ypos#
		DrawLine rendx3#+xpos#,rendy3#+ypos#,rendx1#+xpos#,rendy1#+ypos#
		SetColor $ff,$ff,$ff
	End Method
	
	Method do_physicsSimple()
	    sn# = Sin(car_angle# * MULT#)' * MULT2#
	    cs# = Cos(car_angle# * MULT#) '* MULT2#
	    ' SAE convention; x is to the front of the car, y is to the Right, z is down
	    ' transform velocity in world reference frame to velocity in car reference frame
	    velocity_x# = cs# * car_velocity_wc_y# + sn# * car_velocity_wc_x#
	    velocity_y# = -sn# * car_velocity_wc_y# + cs# * car_velocity_wc_x#
	    ' Lateral force on wheels
	    ' Resulting velocity of the wheels as result of the yaw rate of the car body
	    ' v = yawrate * r where r is distance of wheel to CG (approx. half wheel base)
	    ' yawrate (ang.velocity) must be in rad.s
	    yawspeed# = wheelbase# * 0.5 * car_angularvelocity#
		'
	    If Int(velocity_x)=0
	        rot_angle = 0
	    Else 
	        rot_angle = ATan2(yawspeed,velocity_x)*MULT2
	    EndIf	
	    ' Calculate the side slip angle of the car (a.k.a. beta)
	    If Int(velocity_x)=0
	        sideslip = 0.0
	    Else
	        sideslip = ATan2(velocity_y,velocity_x)*MULT2    
	    EndIf
	    ' Calculate slip angles for front nnd rear wheels (a.k.a. Alpha)
	    slipanglefront = sideslip + rot_angle - car_steerangle
	    slipanglerear = sideslip - rot_angle
	    ' weight per axle = half car mass times 1G (=9.8m.s^2) 
	    weight = mass * 9.8 * 0.5
	    ' lateral force on front wheels = (Ca * slip angle) capped to friction circle * load
	    flatf_x# = 0.0
	    flatf_y# = front * slipanglefront
	    If ( flatf_y# &gt; MAX_GRIP# ) flatf_y# = MAX_GRIP#
	    If ( flatf_y# &lt; -MAX_GRIP# ) flatf_y# = -MAX_GRIP#
		flatf_y# = flatf_y# * weight#
	    ' allow front wheels to slip
	    If front_slip_Flag=True Then flatf_y# = flatf_y# * 0.5	
	    ' lateral force on rear wheels
	    flatr_x# = 0.0
	    flatr_y# = rear# * slipanglerear#
	    flatr_y# = flatr_y# * weight#
	    flatr_y# = flatr_y# * rear_slip
	    ' longtitudinal force on rear wheels - very simple traction model
	    ftraction_x# = 100.0 * (car_throttle# - car_brake# * Sgn(velocity_x#))
	    ftraction_y# = 0.0
	    ftraction_x# = ftraction_x# * rear_slip	
	    ' Forces And torque on body
	    ' drag And rolling resistance
	    resistance_x# = -( RESISTANCE# * velocity_x# + DRAG# * velocity_x# * Abs( velocity_x# ) )
	    resistance_y# = -( RESISTANCE# * velocity_y# + DRAG# * velocity_y# * Abs( velocity_y# ) )
	    ' sum forces
	    force_x# = ftraction_x# + (Sin( car_steerangle# * MULT# )) * flatf_x# + flatr_x# + resistance_x#
	    force_y# = ftraction_y# + (Cos( car_steerangle# * MULT# )) * flatf_y# + flatr_y# + resistance_y#    
	    ' torque on body from lateral forces
	    torque# = type_b# * flatf_y# - type_c# * flatr_y#
	    ' Acceleration
	    ' Newton F = m.a, therefore a = F.m
	    acceleration_x# = force_x# / mass#
	    acceleration_y# = force_y# / mass#
	    angular_acceleration# = torque# / inertia#
	    ' Velocity And position
	    ' transform acceleration from car reference frame To world reference frame
	    acceleration_wc_x# = cs# * acceleration_y# + sn# * acceleration_x#
	    acceleration_wc_y# = -sn# * acceleration_y# + cs# * acceleration_x#
	    ' velocity is integrated acceleration
	    car_velocity_wc_x# = car_velocity_wc_x# + (delta_t# * acceleration_wc_x#)
	    car_velocity_wc_y# = car_velocity_wc_y# + (delta_t# * acceleration_wc_y#)
	    ' position is integrated velocity
	    x:+(delta_t*car_velocity_wc_x)
	    y:+(delta_t*car_velocity_wc_y)
	    ' Angular velocity And heading
	    ' integrate angular acceleration To get angular velocity
	    car_angularvelocity=car_angularvelocity+(delta_t*angular_acceleration)
	    ' integrate angular velocity To get angular orientation
	    car_angle=car_angle+(delta_t*car_angularvelocity)
		' wrap around screen
	    If x&lt;0 Then x=SW
	    If x&gt;SW Then x=0
	    If y&lt;0 Then y=SH
	    If y&gt; SH Then y=0
	End Method

End Type



' PARMETER EDITOR

Type Param
	Global BarWidth%=400 , BarHeight%=16 , XPos%=160 , YPos%=4
	Global MX%,MY%,cY% , Current:Param
	Global list:TList=New TList
	Global EditMode% , MouseWheelValue%
	Global BackR%=$22,BackG%=$22,BackB%=$10
	Global ForeR%=$ff,ForeG%=$ff,ForeB%=$cc
	Global Alpha#=0.6
	Field name$,val:Float Ptr,lo#,hi#
	'
	Function Add(value:Float Ptr, pname$,loval#=0.0,hival#=100.0)
		Local p:Param=New Param
		Param.list.AddLast p
		p.name$=pname$ ; p.lo=loval ; p.hi=hival
		If p.lo&gt;=p.hi p.lo=p.hi-0.01
		p.val=value
		If p.val[0]&gt;p.hi p.val[0]=p.hi
		If p.val[0]&lt;p.lo p.val[0]=p.lo
	End Function
	'
	Method IsMouseOver%()
		If Param.MX&gt;=Param.XPos And Param.MX&lt;=Param.XPos+Param.BarWidth
			If Param.MY&gt;=Param.cY And Param.MY&lt;=Param.cY+Param.BarHeight
				Return True
			EndIf
		EndIf
	End Method
	'
	Function Update()
		Global percent%
		If Param.EditMode=False Return
		SetRotation 0.0 ; SetScale 1.0,1.0 ; SetBlend ALPHABLEND
		SetAlpha Param.Alpha
		Param.cY%=Param.YPos ; 
		If Param.MX&lt;&gt;MouseX() Or Param.MY&lt;&gt;MouseY() Param.MouseWheelValue=MouseZ()
		Param.MX=MouseX() ; Param.MY=MouseY()
		For Local p:param=EachIn Param.list
			' is mouse over bar when left button is down?
			If MouseZ()&lt;&gt;Param.MouseWheelValue
				If p.IsMouseOver()
					p.val[0]:+(Float(MouseZ()-Float(Param.MouseWheelValue)))/100.0
					Param.MouseWheelValue=MouseZ()
				EndIf
			EndIf
			If MouseDown(1)
				If Param.Current=p
						percent=(Param.MX-Param.XPos)/(Float(Param.BarWidth)/100.0)
						If percent&lt;0 percent=0
						If percent&gt;100 percent=100
						p.val[0]=((p.hi-p.lo)*(Float(percent)/100.0))+p.lo	
				Else
					If p.IsMouseOver()
						If Param.Current=Null	Param.Current=p
					EndIf
				EndIf
			EndIf
			If MouseDown(1)=0
				Param.Current=Null
			EndIf
			' render
			SetColor Param.BackR,Param.BackG,Param.BackB
			DrawRect Param.XPos-2 , Param.cY , Param.BarWidth+4 , Param.BarHeight
			SetColor Param.ForeR,Param.ForeG,Param.ForeB
			percent=Abs((p.val[0]-p.lo)/(p.hi-p.lo))*100.0
			DrawRect Param.XPos , Param.cY+1 , percent*(Float(Param.BarWidth)/100.0) , Param.BarHeight-2
			DrawText p.name,Param.XPos-TextWidth(p.name)-4,Param.cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			DrawText p.val[0],Param.XPos+Param.BarWidth+4,cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			Param.cY:+Param.BarHeight+2
		Next
		SetBlend SOLIDBLEND ; SetAlpha 1.0
	End Function
	'
	Function ShowEditor()
		Param.EditMode=True
	End Function
	Function HideEditor()
		Param.EditMode=False
	End Function
	Function ToggleEditor()
		Param.EditMode=Not Param.EditMode
	End Function
End Type
</textarea> <br><br></td></tr></table><br>
<a name="988223"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I went looking for the original source code from: Marco Monster, and  I found it. Obviously it's in c and I tried to convert it to Bmax but I can't get it to work the same. Maybe it's because I can't get the delta to work the same way. if anyone wants to brain-storm it, here are the files(the converted blitzmax,the original c file, and the original executable):<br><a href="http://www.filefront.com/14674693/cardemo2.zip" target="_blank">http://www.filefront.com/14674693/cardemo2.zip</a> <br><br></td></tr></table><br>
<a name="988271"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Vorderman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's definately coming on Jim, I never tried a realtime parameter editor like that, it's pretty cool. I have always just altered the params in a text file then re-run the app to test them, which is very crude by comparison - I'm really tempted to add the param editor to my drift test program and see what else I can get it to do... <br><br></td></tr></table><br>
<a name="988278"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jim, I've tried the last code you posted and it controlls pretty decent.<br>but:<br><div class="quote"> <br>Which seems to have stabilized the car completely when stopping<br> <br></div><br><br>have you tried to turn left or right while stopped?, it goes crazy. <br><br></td></tr></table><br>
<a name="988281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vorderman,<br><br>Feel free to use my Parameter Editor<br>The current design is for floats only though.<br>I written it specifically to avoid constantly tweaking variables then re-compiling the code. A chore I always find a PITA<br><br>One nice thing, it can handle negative as well as positive ranges<br>All control is via the Left mouse button (when the editor is active)<br>you can even use the mouse wheel to fine tune values (roll wheel over slider)<br>I have also captured the Left mouse button so that the slider is still under control even when the mouse accidentally drifts out of the slider zone<br><br><br>The basics for using the parameter editor are:<br><br>Add the (float) variable to the editor in which you are interested in editing. This is done via<br><br><b>param.Add  VarPtr(myvar) , label$ , LowVal# , HighVal#</b><br><br>The parameters are:<br><pre class=code>
VarPtr(myvar)      ' the(float) variable which you want to change
label$                  ' an onscreen descriptive tag
LowVal#              ' lowest allowable value (can accept negatives) 
HiVal#                 ' highest allowable value
</pre><br><br><br>In the main loop, you need to update any LIVE changes via<br><pre class=code>
param.Update
</pre><br>By default, the editor is hidden. To show it (or toggle it on/off) I tend to use this in the main loop. Which, does exactly as it says on the tin (toggles the editor on or off):<br><pre class=code>
If MouseHit(2) then Param.ToggleEditor
</pre><br><br><br>Here is a simple example<br><br><pre class=code>
Global mycarspeed#=20

' Let's allow LIVE manipulation of  mycarspeed#
' The lowest value will be restricted to -10
' the highest value is restricted to +40

param.add VarPtr(mycarspeed) , "Car Speed" , -10 , 40

' main loop

While blahhblahhblah
  If MouseHit(2) then Param.ToggleEditor
   Param.Udate
  Flip
Wend
</pre><br><br><br><br>The SOURCE<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
 PARAMETER EDITOR
 Written by Jim Brown
 Add this code at the end of your source code
 
 USAGE
 To edit any previously defined variables (floats only)
     Param.Add Varptr(myFloat),label$,lowval#,highval#

 In the main loop update the LIVE editing via:
     Param.Update

  NOTES
  Updating does not take place unless the editor is visible
  Switch the editor on via Param.ShowEditor
  Hide the editor via Param.HideEditor
  Toggle the editor on or off via Param.ToggleEditor
End Rem

Type Param
	Global BarWidth%=400 , BarHeight%=16 , XPos%=160 , YPos%=4
	Global MX%,MY%,cY% , Current:Param
	Global list:TList=New TList
	Global EditMode% , MouseWheelValue%
	Global BackR%=$22,BackG%=$22,BackB%=$10
	Global ForeR%=$ff,ForeG%=$ff,ForeB%=$cc
	Global Alpha#=0.6
	Field name$,val:Float Ptr,lo#,hi#
	'
	Function Add(value:Float Ptr, pname$,loval#=0.0,hival#=100.0)
		Local p:Param=New Param
		Param.list.AddLast p
		p.name$=pname$ ; p.lo=loval ; p.hi=hival
		If p.lo&gt;=p.hi p.lo=p.hi-0.01
		p.val=value
		If p.val[0]&gt;p.hi p.val[0]=p.hi
		If p.val[0]&lt;p.lo p.val[0]=p.lo
	End Function
	'
	Method IsMouseOver%()
		If Param.MX&gt;=Param.XPos And Param.MX&lt;=Param.XPos+Param.BarWidth
			If Param.MY&gt;=Param.cY And Param.MY&lt;=Param.cY+Param.BarHeight
				Return True
			EndIf
		EndIf
	End Method
	'
	Function Update()
		Global percent%
		If Param.EditMode=False Return
		SetRotation 0.0 ; SetScale 1.0,1.0 ; SetBlend ALPHABLEND
		SetAlpha Param.Alpha
		Param.cY%=Param.YPos ; 
		If Param.MX&lt;&gt;MouseX() Or Param.MY&lt;&gt;MouseY() Param.MouseWheelValue=MouseZ()
		Param.MX=MouseX() ; Param.MY=MouseY()
		For Local p:param=EachIn Param.list
			' is mouse over bar when left button is down?
			If MouseZ()&lt;&gt;Param.MouseWheelValue
				If p.IsMouseOver()
					p.val[0]:+(Float(MouseZ()-Float(Param.MouseWheelValue)))/100.0
					Param.MouseWheelValue=MouseZ()
				EndIf
			EndIf
			If MouseDown(1)
				If Param.Current=p
						percent=(Param.MX-Param.XPos)/(Float(Param.BarWidth)/100.0)
						If percent&lt;0 percent=0
						If percent&gt;100 percent=100
						p.val[0]=((p.hi-p.lo)*(Float(percent)/100.0))+p.lo	
				Else
					If p.IsMouseOver()
						If Param.Current=Null	Param.Current=p
					EndIf
				EndIf
			EndIf
			If MouseDown(1)=0
				Param.Current=Null
			EndIf
			' render
			SetColor Param.BackR,Param.BackG,Param.BackB
			DrawRect Param.XPos-2 , Param.cY , Param.BarWidth+4 , Param.BarHeight
			SetColor Param.ForeR,Param.ForeG,Param.ForeB
			percent=Abs((p.val[0]-p.lo)/(p.hi-p.lo))*100.0
			DrawRect Param.XPos , Param.cY+1 , percent*(Float(Param.BarWidth)/100.0) , Param.BarHeight-2
			DrawText p.name,Param.XPos-TextWidth(p.name)-4,Param.cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			DrawText p.val[0],Param.XPos+Param.BarWidth+4,cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			Param.cY:+Param.BarHeight+2
		Next
		SetBlend SOLIDBLEND ; SetAlpha 1.0
	End Function
	'
	Function ShowEditor()
		Param.EditMode=True
	End Function
	Function HideEditor()
		Param.EditMode=False
	End Function
	Function ToggleEditor()
		Param.EditMode=Not Param.EditMode
	End Function
End Type
</textarea> <br><br></td></tr></table><br>
<a name="988283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Some how it seems like if it skids a lot easier. The original demo seems more realistic. It's practically a 1 to 1 conversion but some how I feel I might have screwed it up somewhere. <br><br></td></tr></table><br>
<a name="988284"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >EOF</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> ** EDIT<br><br>Separate post here (I think I broke the previous one with too much code)<br><br><br>Jesse,<br><div class="quote"> have you tried to turn left or right while stopped?, it goes crazy <br></div><br>Never spotted that. Thanks. Fixed below<br><br>I tried your new converted cardemo code and it seems pretty good although a lot faster than the SDL C demo<br><br><div class="quote"> Some how it seems like if it skids a lot easier. The original demo seems more realistic <br></div>Yep. I think it's a timing issue of sorts<br><br>Changing Flip(0) to plain old Flip looks a lot closer to the SDL version<br><br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' Car Physics - take 5
' Credits: Marco Monster, Vorderman, Jesse

SuperStrict

Framework BRL.GLMax2D

Const SW%=640 , SH%=480
Graphics SW,SH

Local car:Tcar = Tcar.Create(400,300,42)
'
param.xpos=70 ; param.ypos=42
param.add Varptr(car.Delta_t),"Delta T",0.005,0.1
param.add Varptr(car.DRAG),"Drag",0.1,100
param.add Varptr(car.RESISTANCE),"Resist",10,500
param.add Varptr(car.MAX_GRIP),"Grip",1,50
param.add Varptr(car.mass),"Mass",100,5000
param.add Varptr(car.inertia),"Inertia",100,5000
param.add Varptr(car.MULT2),"Mult2",0.005,1.0
param.add Varptr(car.rear),"Rear",-15,-1
param.add Varptr(car.front),"Front",-15,-1
param.add Varptr(car.steeramount),"Steer Am",0.05,0.8
'


'Main loop
While ( Not KeyDown(key_escape) )
	' draw reference grid
	SetClsColor 40,110,40
	Cls ; SetColor 30,88,30
	For Local v%=0 Until SW Step 26
		DrawLine v,0,v,SH ; DrawLine 0,v,SW,v
	Next
	'
	If MouseHit(2) Param.ToggleEditor
	param.Update
	'
	SetColor $ff,$ff,$ff
    car.do_input()
    car.do_physicsSimple()
    car.draw()
    Flip
Wend

End

Type Tcar
	Field x#,y#
	'physics variables
	Field delta_t#=0.02, DRAG#=5.0 , RESISTANCE#=39.4
	Field rear# = -7.3 , front# = -7.8 , MAX_GRIP# =29.3
	Field MULT# = 57 , MULT2# = 0.164
	
	Field cartype% , type_b# = 1.0 , type_c# = 1.0
	Field wheelbase# = 1.0+1.0 ' type_b+type_c
	Field h#=1.0 , mass#=1815, inertia#=2206
	Field width#=1.5 , length#=3.0
	Field wheellength#=0.7 , wheelwidth#=0.3 , steeramount#=0.24

	Field car_velocity_wc_x# , car_velocity_wc_y#
	Field car_angle# , car_angularvelocity#
	Field car_steerangle# , car_throttle# , car_brake#
	Field front_slip_Flag%=False , rear_slip%
	
	Field velocity_x# , velocity_y#
	Field yawspeed# , sn#, cs# , xpos#, ypos#
	Field rot_angle# , sideslip# , slipanglefront#
	Field slipanglerear#
	Field flatf_x#, flatf_y# , flatr_x#, flatr_y#
	Field weight#
	Field ftraction_x#, ftraction_y# 
	Field resistance_x#, resistance_y#
	Field force_x#, force_y# , torque#
	Field acceleration_x#, acceleration_y#, angular_acceleration# 
	Field acceleration_wc_x#, acceleration_wc_y#
	
	Function Create:Tcar(x:Float, y:Float, ang:Float)
		Local car:Tcar = New Tcar
		car.x# = x ; car.y# = y
		car.car_angle# = ang
		Return car	
	End Function	
	
	'Input routine from joystick.pad.wheel
	Method do_input()
		Local inputmove%=KeyDown(KEY_UP)-KeyDown(KEY_DOWN)
		Local inputsteer%=KeyDown(KEY_RIGHT)-KeyDown(KEY_LEFT)
		If Int(velocity_x)=0 Then inputsteer=0

	    If inputmove=1 Then car_throttle# = 1200.0
	    If inputmove=0 Then car_throttle# = 0.0
	    If inputmove=-1 
	        car_throttle# = 0.0
	        car_brake# = 800.0
	    Else
	        car_brake# = 0.0
	    EndIf
	
	    car_steerangle# = 0.0
	    If inputsteer=+1 Then car_steerangle# = (-Pi / 4.0) * steeramount
	    If inputsteer=-1 Then car_steerangle# = (Pi / 4.0) * steeramount
		' handbrake
	    rear_slip = 1.0
	    If KeyDown(KEY_SPACE) Then rear_slip = 1.4
	    
		DrawText "Press Mouse RMB to toggle parameter editor" , 10,SH-30
	  	'DrawText String(x#),0,
	   	'DrawText String(y#),0,12
	     'DrawText String(car_steerangle#),0,24
	
	    xpos# = x#
	    ypos# = y#
	
	End Method
	
	
	Method draw()
			
		Local renda1# =( -car_angle# * MULT# ) - 60
		If (renda1#&lt;0.0) Then renda1#=360.0+renda1#
		Local renda2# =( -car_angle# * MULT# ) + 60
		If (renda2#&gt;359.0) Then renda2#=renda2#-360.0
		Local renda3# =( -car_angle# * MULT# ) - 120
		If (renda3#&lt;0.0) Then renda3#=360.0+renda3#
		Local renda4# =( -car_angle# * MULT# ) + 120
		If (renda4#&gt;359.0) Then renda4#=renda4#-360.0
		
		Local rendx1#=25*Cos(renda1#) ; Local rendy1#=25*Sin(renda1#)
		Local rendx2#=25*Cos(renda2#) ; Local rendy2#=25*Sin(renda2#)
		Local rendx3#=25*Cos(renda3#) ; Local rendy3#=25*Sin(renda3#)
		Local rendx4#=25*Cos(renda4#) ; Local rendy4#=25*Sin(renda4#)
		
		SetColor 155,255,155
		DrawLine rendx1#+xpos#,rendy1#+ypos#,rendx2#+xpos#,rendy2#+ypos#
		DrawLine rendx2#+xpos#,rendy2#+ypos#,rendx4#+xpos#,rendy4#+ypos#
		DrawLine rendx4#+xpos#,rendy4#+ypos#,rendx3#+xpos#,rendy3#+ypos#
		DrawLine rendx3#+xpos#,rendy3#+ypos#,rendx1#+xpos#,rendy1#+ypos#
		SetColor $ff,$ff,$ff
	End Method
	
	Method do_physicsSimple()
	    sn# = Sin(car_angle# * MULT#)' * MULT2#
	    cs# = Cos(car_angle# * MULT#) '* MULT2#
	    ' SAE convention; x is to the front of the car, y is to the Right, z is down
	    ' transform velocity in world reference frame to velocity in car reference frame
	    velocity_x# = cs# * car_velocity_wc_y# + sn# * car_velocity_wc_x#
	    velocity_y# = -sn# * car_velocity_wc_y# + cs# * car_velocity_wc_x#
	    ' Lateral force on wheels
	    ' Resulting velocity of the wheels as result of the yaw rate of the car body
	    ' v = yawrate * r where r is distance of wheel to CG (approx. half wheel base)
	    ' yawrate (ang.velocity) must be in rad.s
	    yawspeed# = wheelbase# * 0.5 * car_angularvelocity#
		'
	    If Int(velocity_x)=0
	        rot_angle = 0 ; sideslip=0 ; car_steerangle=0
	    Else 
	        rot_angle = ATan2(yawspeed,velocity_x)*MULT2
			sideslip = ATan2(velocity_y,velocity_x)*MULT2
	    EndIf	
	    ' Calculate slip angles for front nnd rear wheels (a.k.a. Alpha)
	    slipanglefront = sideslip + rot_angle - car_steerangle
	    slipanglerear = sideslip - rot_angle
	    ' weight per axle = half car mass times 1G (=9.8m.s^2) 
	    weight = mass * 9.8 * 0.5
	    ' lateral force on front wheels = (Ca * slip angle) capped to friction circle * load
	    flatf_x# = 0.0
	    flatf_y# = front * slipanglefront
	    If ( flatf_y# &gt; MAX_GRIP# ) flatf_y# = MAX_GRIP#
	    If ( flatf_y# &lt; -MAX_GRIP# ) flatf_y# = -MAX_GRIP#
		flatf_y# = flatf_y# * weight#
	    ' allow front wheels to slip
	    If front_slip_Flag=True Then flatf_y# = flatf_y# * 0.5	
	    ' lateral force on rear wheels
	    flatr_x# = 0.0
	    flatr_y# = rear# * slipanglerear#
	    flatr_y# = flatr_y# * weight#
	    flatr_y# = flatr_y# * rear_slip
	    ' longtitudinal force on rear wheels - very simple traction model
	    ftraction_x# = 100.0 * (car_throttle# - car_brake# * Sgn(velocity_x#))
	    ftraction_y# = 0.0
	    ftraction_x# = ftraction_x# * rear_slip	
	    ' Forces And torque on body
	    ' drag And rolling resistance
	    resistance_x# = -( RESISTANCE# * velocity_x# + DRAG# * velocity_x# * Abs( velocity_x# ) )
	    resistance_y# = -( RESISTANCE# * velocity_y# + DRAG# * velocity_y# * Abs( velocity_y# ) )
	    ' sum forces
	    force_x# = ftraction_x# + (Sin( car_steerangle# * MULT# )) * flatf_x# + flatr_x# + resistance_x#
	    force_y# = ftraction_y# + (Cos( car_steerangle# * MULT# )) * flatf_y# + flatr_y# + resistance_y#    
	    ' torque on body from lateral forces
	    torque# = type_b# * flatf_y# - type_c# * flatr_y#
	    ' Acceleration
	    ' Newton F = m.a, therefore a = F.m
	    acceleration_x# = force_x# / mass#
	    acceleration_y# = force_y# / mass#
	    angular_acceleration# = torque# / inertia#
	    ' Velocity And position
	    ' transform acceleration from car reference frame To world reference frame
	    acceleration_wc_x# = cs# * acceleration_y# + sn# * acceleration_x#
	    acceleration_wc_y# = -sn# * acceleration_y# + cs# * acceleration_x#
	    ' velocity is integrated acceleration
	    car_velocity_wc_x# = car_velocity_wc_x# + (delta_t# * acceleration_wc_x#)
	    car_velocity_wc_y# = car_velocity_wc_y# + (delta_t# * acceleration_wc_y#)
	    ' position is integrated velocity
	    x:+(delta_t*car_velocity_wc_x)
	    y:+(delta_t*car_velocity_wc_y)
	    ' Angular velocity And heading
	    ' integrate angular acceleration To get angular velocity
	    car_angularvelocity=car_angularvelocity+(delta_t*angular_acceleration)
	    ' integrate angular velocity To get angular orientation
	    car_angle=car_angle+(delta_t*car_angularvelocity)
		' wrap around screen
	    If x&lt;0 Then x=SW
	    If x&gt;SW Then x=0
	    If y&lt;0 Then y=SH
	    If y&gt; SH Then y=0
	End Method

End Type


Rem
 PARAMETER EDITOR
 Written by Jim Brown
 Add this code at the end of your source code
 
 USAGE
 To edit any previously defined variables (floats only)
     Param.Add Varptr(myFloat),label$,lowval#,highval#

 In the main loop update the LIVE editing via:
     Param.Update

  NOTES
  Updating does not take place unless the editor is visible
  Switch the editor on via Param.ShowEditor
  Hide the editor via Param.HideEditor
  Toggle the editor on or off via Param.ToggleEditor
End Rem

Type Param
	Global BarWidth%=400 , BarHeight%=16 , XPos%=160 , YPos%=4
	Global MX%,MY%,cY% , Current:Param
	Global list:TList=New TList
	Global EditMode% , MouseWheelValue%
	Global BackR%=$22,BackG%=$22,BackB%=$10
	Global ForeR%=$ff,ForeG%=$ff,ForeB%=$cc
	Global Alpha#=0.6
	Field name$,val:Float Ptr,lo#,hi#
	'
	Function Add(value:Float Ptr, pname$,loval#=0.0,hival#=100.0)
		Local p:Param=New Param
		Param.list.AddLast p
		p.name$=pname$ ; p.lo=loval ; p.hi=hival
		If p.lo&gt;=p.hi p.lo=p.hi-0.01
		p.val=value
		If p.val[0]&gt;p.hi p.val[0]=p.hi
		If p.val[0]&lt;p.lo p.val[0]=p.lo
	End Function
	'
	Method IsMouseOver%()
		If Param.MX&gt;=Param.XPos And Param.MX&lt;=Param.XPos+Param.BarWidth
			If Param.MY&gt;=Param.cY And Param.MY&lt;=Param.cY+Param.BarHeight
				Return True
			EndIf
		EndIf
	End Method
	'
	Function Update()
		Global percent%
		If Param.EditMode=False Return
		SetRotation 0.0 ; SetScale 1.0,1.0 ; SetBlend ALPHABLEND
		SetAlpha Param.Alpha
		Param.cY%=Param.YPos ; 
		If Param.MX&lt;&gt;MouseX() Or Param.MY&lt;&gt;MouseY() Param.MouseWheelValue=MouseZ()
		Param.MX=MouseX() ; Param.MY=MouseY()
		For Local p:param=EachIn Param.list
			' is mouse over bar when left button is down?
			If MouseZ()&lt;&gt;Param.MouseWheelValue
				If p.IsMouseOver()
					p.val[0]:+(Float(MouseZ()-Float(Param.MouseWheelValue)))/100.0
					Param.MouseWheelValue=MouseZ()
				EndIf
			EndIf
			If MouseDown(1)
				If Param.Current=p
						percent=(Param.MX-Param.XPos)/(Float(Param.BarWidth)/100.0)
						If percent&lt;0 percent=0
						If percent&gt;100 percent=100
						p.val[0]=((p.hi-p.lo)*(Float(percent)/100.0))+p.lo	
				Else
					If p.IsMouseOver()
						If Param.Current=Null	Param.Current=p
					EndIf
				EndIf
			EndIf
			If MouseDown(1)=0
				Param.Current=Null
			EndIf
			' render
			SetColor Param.BackR,Param.BackG,Param.BackB
			DrawRect Param.XPos-2 , Param.cY , Param.BarWidth+4 , Param.BarHeight
			SetColor Param.ForeR,Param.ForeG,Param.ForeB
			percent=Abs((p.val[0]-p.lo)/(p.hi-p.lo))*100.0
			DrawRect Param.XPos , Param.cY+1 , percent*(Float(Param.BarWidth)/100.0) , Param.BarHeight-2
			DrawText p.name,Param.XPos-TextWidth(p.name)-4,Param.cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			DrawText p.val[0],Param.XPos+Param.BarWidth+4,cY+(Param.BarHeight/2)-TextHeight(p.name)/2
			Param.cY:+Param.BarHeight+2
		Next
		SetBlend SOLIDBLEND ; SetAlpha 1.0
	End Function
	'
	Function ShowEditor()
		Param.EditMode=True
	End Function
	Function HideEditor()
		Param.EditMode=False
	End Function
	Function ToggleEditor()
		Param.EditMode=Not Param.EditMode
	End Function
End Type
</textarea> <br><br></td></tr></table><br>
<a name="1156287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >iaqsuk</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Jim Brown,  on your very first script above, how hard would it be to convert it to BlitzPlus?  or is it possible.  I know more about plus then max.<br><br>Your script is what i've been looking for as examples to a realistic car going forward or reverse with brakes.  I was looking at your script and I see the maxspeed or speed input values.  Is there anyways we can add more speed values?  Like I'm trying to add key 1 0-10mph, key 2 11-20, key 3 21-30, etc... like gear shifter?  Thanks. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
