<!DOCTYPE html><html lang="en" ><head ><title >Hardware Mouse Cursor</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Hardware Mouse Cursor</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Hardware Mouse Cursor</a><br><br>
<a name="1121315"></a>

<a name="1121316"></a>

<a name="1121340"></a>

<a name="1121354"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's how to do it (currently only for Windows):<br><br>mouse.cpp:<br><pre class=code>
#include "windows.h"
#include "stdio.h"

HCURSOR cursors[15]; 

extern "C" __declspec( dllexport ) void InitializeCursor(int cursorId, char* standardPath)
{
	wchar_t newPath[1024];
	MultiByteToWideChar(CP_UTF8, 0, standardPath, -1, newPath, 1024);
	HCURSOR cursor = ::LoadCursorFromFileW(newPath);
	cursors[cursorId] = cursor;
}

extern "C" __declspec( dllexport ) void SetCurrentCursor(int cursorId)
{
	HWND result = GetForegroundWindow();
	SetClassLongA(result, -12, (long)cursors[cursorId]);
	SetCursor(cursors[cursorId]);
	InvalidateRect(result, NULL, TRUE);
}
</pre><br><br>mouse.bmx:<br><pre class=code>
SuperStrict

?win32
Import "mouse.cpp"

Extern
	Function InitializeCursor(cursorId:Int, path$z)
	Function SetCurrentCursor(cursorId:Int)
EndExtern
?

Graphics 800, 600

InitCursor(0, "pointer.cur")
SetCursor(0)

Repeat
	Cls
	Flip
Until AppTerminate()

Function InitCursor(id:Int, path:String)
	?win32
		InitializeCursor(id, path)
	?
End Function

Function SetCursor(id:Int)
	?win32
		SetCurrentCursor(id)
	?
End Function
</pre><br><br>Please note that Windows will impose a standard size of 32x32 for your mouse cursor, so if it is any larger than that Windows will resize it.<br><br><a href="http://support.microsoft.com/kb/307213" target="_blank">http://support.microsoft.com/kb/307213</a><br><br>Original code from here (which includes Mac code too):<br><a href="http://forum.unity3d.com/threads/70163-Hardware-Cursor-Plugin" target="_blank">http://forum.unity3d.com/threads/70163-Hardware-Cursor-Plugin</a><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121341"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Small update... I've found a way to get around the 32x32 limit.<br><br>Change the c++ InitializeCursor method:<br><br><pre class=code>
extern "C" __declspec( dllexport ) void InitializeCursor(int cursorId, char* standardPath)
{
	HCURSOR cursor = (HCURSOR)LoadImage(NULL, standardPath, IMAGE_CURSOR, 0, 0, LR_LOADFROMFILE|LR_SHARED);
	cursors[cursorId] = cursor;
}
</pre><br><br>Now my 64x64 mouse cursor is displayed fine :) <br><br></td></tr></table><br>
<a name="1121364"></a>

<a name="1121365"></a>

<a name="1121369"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, need to help with the Mac version...<br><br>CursorPlugin.h<br><pre class=code>
#import &lt;Cocoa/Cocoa.h&gt;
#include &lt;AppKit/AppKit.h&gt;
</pre><br><br>CursorPlugin.m<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
//
//  CursorPlugin.m
//  CursorPlugin
//
//  Created by Maciej Czerwonka (maciej.czerwonka@...) on 10-10-27.
//  Feel free to use and/or redistribute in any form.

#import "CursorPlugin.h"

void SetCurrentCursor(int cursorId);

NSImage* imagesArray[15];
NSCursor* cursorsArray[15];


NSView* view = nil;
NSCursor* currentCursor = nil;
int currentCursorId = 0;


@interface TrackingRectObject : NSResponder
{
}
- (void)mouseEntered:(NSEvent *)theEvent;
- (void)mouseExited:(NSEvent *)theEvent;
@end
@implementation TrackingRectObject

- (void)mouseEntered:(NSEvent *)theEvent
{
	SetCurrentCursor(currentCursorId);
}
- (void)mouseExited:(NSEvent *)theEvent	
{
	int cc = currentCursorId;
	SetCurrentCursor(-1);
	currentCursorId = cc;
}

@end


TrackingRectObject* pTrackMgr = nil;





void InitializeCursor(int cursorId, const char* standardPath)
{
	NSLog(@"InitializeCursor called");
	NSApplication* app = [NSApplication sharedApplication];	
	
	NSWindow* window = [app mainWindow];
	view = [window contentView];
	
	if (pTrackMgr == nil)
	{
		pTrackMgr = [TrackingRectObject alloc];
		[view addTrackingRect: [view visibleRect] owner:pTrackMgr userData:nil assumeInside:YES];
	}

	unsigned short cursorFile[20];
	
	NSFileHandle* file = [NSFileHandle fileHandleForReadingAtPath: [NSString stringWithUTF8String:standardPath]];
	NSData* data = [file readDataToEndOfFile];
	[data getBytes:cursorFile length: 40];
	
	//unsigned short cursorCount = cursorFile[2];
	unsigned short hotSpotX = cursorFile[5];
	unsigned short hotSpotY = cursorFile[6];
	
	[file closeFile];
	
	NSLog([NSString stringWithFormat:@"Cursor registered: id: %d, path: %@, x: %d, y: %d", cursorId, [NSString stringWithUTF8String:standardPath], (int)hotSpotX, (int)hotSpotY]);	
	
	imagesArray[cursorId] = [[NSImage alloc] initByReferencingFile: [NSString stringWithUTF8String:standardPath]];
	cursorsArray[cursorId] = [[NSCursor alloc] initWithImage: imagesArray[cursorId] hotSpot: NSMakePoint(hotSpotX, hotSpotY)];
	
}

void SetCurrentCursor(int cursorId)
{

	if (currentCursor != nil)
		[currentCursor pop];
	
	if (cursorId != -1)
		currentCursor = cursorsArray[cursorId];
	else {
		currentCursor = nil;
	}

	currentCursorId = cursorId;
	
	if (currentCursor != nil)
		[currentCursor push];
}

</textarea><br><br>And using it like this in BlitzMax:<br><br>mouse.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

?win32
Import "mouse.cpp"

Extern
	Function InitializeCursor(cursorId:Int, path:Byte Ptr)
	Function SetCurrentCursor(cursorId:Int)
EndExtern
?

?MacOs
Import "CursorPlugin.m"

Extern
	Function InitializeCursor(cursorId:Int, path:Byte Ptr)
	Function SetCurrentCursor(cursorId:Int)
EndExtern
?


Graphics 800, 600

InitCursor(0, "pointer.cur")
SetCursor(0)

Repeat
	SetClsColor 100,100,120
	Cls
	Flip
Until AppTerminate()

Function InitCursor(id:Int, path:String)
	Local strPtr:Byte Ptr = path$.ToCString()
	InitializeCursor(id, strPtr)
	MemFree strPtr
End Function

Function SetCursor(id:Int)
	SetCurrentCursor(id)
End Function
</textarea><br><br>But when I run it, the app works but I <strike>dont get my new cursor</strike> sometimes get my new cursor (its really buggy) and when it quits I get:<br><br><div class="quote"> <br>Compile Error<br>52.565 mouse.debug[1555:60b] InitialzeCursor called<br> <br></div><br><br>Does anyone have any ideas?<br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121604"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> What is the benefit of this over the standard mouse commands <br><br></td></tr></table><br>
<a name="1121607"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> No input mouse lag when using vsync and full screen ;)<br><br>Also instead of hiding the mouse and using DrawImage img, MouseX(), MouseY() for a custom mouse cursor, you can use this... <br><br></td></tr></table><br>
<a name="1121675"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> To clarify it fixes movement lag but not click lag or dragging stuff lag.  There's no way round that due to the nature of the problem being DX9 display lag (which means all input appears delayed).<br><br>Hope you get the Mac stuff sorted (is it needed, did you test?). <br><br></td></tr></table><br>
<a name="1121678"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Hope you get the Mac stuff sorted (is it needed, did you test?).  <br></div><br><br>Nope, I havent tested yet - I'm hoping its not needed as OpenGL lag is so much less than DirectXs. <br><br></td></tr></table><br>
<a name="1121688"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> You know when the lagfix dropped the FPS to 30 was that just with DX or GL too? <br><br></td></tr></table><br>
<a name="1121693"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just DX, GL was fine.<br><br>Ahhh... so I wonder if its worth doing the lagfix just for OpenGL... <br><br></td></tr></table><br>
<a name="1121697"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> could be! <br><br></td></tr></table><br>
<a name="1121803"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> why don't you guys just stop using vwait? <br><br></td></tr></table><br>
<a name="1121829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> just stop using vwait? <br></div><br><br>NEVER!! &gt;:D<br><br>Vsync is so much smoother overall and no tearing... but you get the input lag.<br><br>I've also been researching "triple buffering"/"render ahead" as a possible workaround (as we can't fix vsync and lag):<br><br><a href="http://www.anandtech.com/show/2794" target="_blank">http://www.anandtech.com/show/2794</a> <br><br></td></tr></table><br>
<a name="1121837"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> When I first made my framework the options page had a VSync on/off option and you know the framework totally supports it.  It's just that VSync looks so much smoother and it made my games stand out as looking polished compared to a) non vsynced casual games with jerky anims and b) just poor framerate games.  However I've yet to see a casual game with the VSync option on the options page.  Perhaps though I could add it again on future games so customers can at least turn it off if they are getting mouse lag. <br><br></td></tr></table><br>
<a name="1121839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Perhaps though I could add it again on future games so customers can at least turn it off if they are getting mouse lag.  <br></div><br><br>For an proper "indie" game yeah add it... but for a casual game do you think the user will actually know what it means? (Unless you rename from Vsync to Turn Mouse Lag Off) ;) <br><br></td></tr></table><br>
<a name="1121847"></a>

<a name="1121848"></a>

<a name="1121849"></a>

<a name="1121850"></a>

<a name="1121851"></a>

<a name="1121852"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah I know it practically needs some name like "If you feel the mouse is being slow or experience any problems, try clicking this".  Still lots of casual players probably never go into options when they get problems, they just quit out.  Gamers are more likely to explore and look for solutions.  This is why casual games need to work "straight out the box" as much as possible and have the most common settings that will work for most people and do a bit of auto-detection if need be.  (I know you know this).<br><br>It's a shame this is such a minefield.  When I first made the framework, half of it was creating common components, and the other half was working all this stuff out and getting BlitzMax bugs fixed and improvements made to make it suitable for commercial casual games.  It's pretty good now but I still hate to think of lost sales due to some system incompatibilities (and I don't mean like 128MB Win 98 systems, I mean with half-decent modern systems and netbooks etc).<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1121967"></a>

<a name="1121968"></a>

<a name="1121969"></a>

<a name="1121970"></a>

<a name="1121971"></a>

<a name="1121972"></a>

<a name="1121973"></a>

<a name="1121974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Vsync is so much smoother overall and no tearing...  <br></div>not in my experience... check out my <a href="http://ooeyug.com/rocks" target="_blank">Rocks game</a>... perfectly smooth and no lag.  not meaning to boast but all my stuff is that way and I've testing on a lot computers and have been doing it that way years.<br><br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2783" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2783</a><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1122017"></a>

<a name="1122018"></a>

<a name="1122021"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice game BTW :)<br><br>Thats a totally different way to handle the update, I will have to have a look at it more.<br><br>With your example (with the bouncing balls), how would you add a mouse cursor to the "world" without lag?<br><br>I've tried this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Graphics 640,480

Local fullscreen:Int
Local vwait:Int
Local rate:Int = 20
Local stage:TRL = New TRL
Local m:TMouse = New TMouse

stage.SetUpdateRate(rate)	' game login updates per second
stage.ResetCounters		' now, choose a frame at the start of your project and keep that one.
					' 30 or 60 are the best.... for a game with a whole lot of ai I'd go 30.
					' my games run at 60 though and do fine even on the slowest of machines.

SetBlend ALPHABLEND
' don't put too much in this main loop, all objects should be updated in the GameUpdate callback.
While Not KeyHit(KEY_ESCAPE) Or AppTerminate()
	If KeyHit(KEY_UP) Then rate :+ 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_DOWN) Then rate :- 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_V) Then vwait = 1-vwait
	If KeyHit(KEY_F) Then
		fullscreen = Not fullscreen
		If fullscreen
			Graphics 640, 480, 32, 60
		Else
			Graphics 640, 480, 0, 60
		EndIf
	EndIf


	' 2 functions will be called back to, one that capture the old position
	' and one that performs the game update logic.
	Local tween:Double = stage.Update( TObject.CaptureAll, GameUpdate )	
	
	' draw all object with a tween value
	TObject.DrawAll tween
	'DrawOval omx+ (MouseX()-omx)*tween, omy+ (MouseY()-omy)*tween, 20, 20 
	'	DrawOval MouseX(), MouseY(), 20, 20

	SetAlpha 1
	DrawText "balls: "+TObject.total,10,10
	DrawText "  fps: "+stage.GetFPS(),10,20
	DrawText "  ups: "+stage.GetUPS()+" [up/down]",10,30
	DrawText "vwait: "+vwait+" [v]",10,40
	DrawText "rate : "+rate, 10, 50
	DrawText "fullscreen: "+ fullscreen+ "[F]", 10, 60

	Flip vwait
	Cls
Wend

Type TMouse Extends TObject
	
	Method Draw(tween:Double )
		SetAlpha alpha
		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
	End Method

	Method New()
		link = list.AddLast(Self)
	End Method

	Method Update()
		x = MouseX()
		y = MouseY()
	End Method

End Type


Function GameUpdate()
	
	If TObject.total &lt; 100 Then New TObject
	TObject.UpdateAll

End Function


' your object(s)
Type TObject
	Const GRAVITY:Float = 0.2
	Const FRICTION:Float = 0.99
	
	Global list:TList = New TList
	Global total:Int
	
	Field link:TLink
	Field x:Float, ox:Float
	Field y:Float, oy:Float
	Field xvel:Float
	Field yvel:Float
	Field alpha:Float = 1		' I could tween things like alpha, size, rotataion and so on if needed.
	
	' this is a callback, that gets passed to obj:TRL.Update
	Function CaptureAll()
		For Local o:TObject = EachIn list
			o.Capture
		Next
	End Function
	
	' this of course is called by your GameUpdate function that is passed to obj:TRL.Update
	Function UpdateAll()
		For Local o:TObject = EachIn list
			o.Update
		Next
	End Function
	
	Function DrawAll( tween:Double )
		For Local o:TObject = EachIn list
			o.Draw tween
		Next
	End Function

	' ---------------------------------------------------------------------
	Method New()
		link = list.AddLast(Self)
		x = GraphicsWidth()/2
		y = 20
		xvel = Rnd(-8,8)
		Capture
		total :+ 1
	End Method

	Method remove()
		total :- 1
		link.Remove
	End Method

	' ---------------------------------------------------------------------

	' capture (record current value before update) whatever values you want to
	' tween.  generally x and y but you could do alpha, size, rotation.... and more
	Method Capture()
		ox = x
		oy = y		
	End Method
	
	' this update routine gets called a fixed number per second...  I like this
	' over delta time because you don't have to add weird numbers to all of your
	' values.
	Method Update()
		yvel :+ GRAVITY
		xvel :* FRICTION
		yvel :* FRICTION
		
		x :+ xvel
		y :+ yvel

		If x &lt; 0 Or x &gt; GraphicsWidth() Then xvel = -xvel ; x :+ xvel
		If y &lt; 0 Or y &gt; GraphicsHeight() Then yvel = -yvel ; y :+ yvel
		
		alpha :- .005
		If alpha &lt; 0 Then Remove
	End Method

	' render all tweened values.
	Method Draw( tween:Double )
		SetAlpha alpha
		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
	End Method

	' ---------------------------------------------------------------------
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween 
	End Method

End Type


Type TRL
	Field gameFPS			:Double	= 60.0:Double
	Field framePeriod		:Double	= 1000.0:Double / gameFPS
	Field frameTime		:Double	= MilliSecs() - framePeriod

	Field gamelogicframes	:Int
	Field catchUp		:Int = True

	Rem
	bbdoc: This goes in the main loop and should be called every graphic frame.
	about:
	2 functions will be called back to, one that capture the old position
	and one that performs the game update logic.
	returns: tween number that should be used for drawing.
	End Rem
	Method Update:Double( captureCallback(), updateCallback() )
		Global frameElapsed:Double

		Repeat
			frameElapsed = MilliSecs() - frameTime
		Until frameElapsed
		Local frameTicks:Int = frameElapsed / framePeriod
		Local frameTween:Double = Double(frameElapsed Mod framePeriod) / framePeriod

		' update game and world state
		If Not catchUp And frameTicks &gt; 1 Then frameTicks = 1
		For Local frameLimit:Int = 1 To frameTicks
			If frameLimit = frameTicks
				captureCallback()
			End If
			frameTime = frameTime + framePeriod

			updateCallback()
			gamelogicframes = GetGameLogicFrames()
		Next

		Return frameTween
	End Method


	Rem
	bbdoc: Set the rate at which your "update" function will be run.
	about:
	Choose a logic rate at the start of your project, 30 or 60 work the best. For a game with lots of AI I'd go 30.
	End Rem
	Method SetUpdateRate( gameFPS:Double )
		Self.gameFPS = gameFPS
		framePeriod = 1000.0:Double / Self.gameFPS
		'ResetCounters
	End Method



	Rem
	bbdoc: Get the number of logic updates being called per second.
	returns: Logic updates per second.
	End Rem
	Method GetUPS:Int()
		Return gamelogicframes
	End Method


	Rem
	bbdoc: Get the actual frames being draw per second.
	returns: Frames per second.
	End Rem
	Method GetFPS:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Method GetGameLogicFrames:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Rem
	bbdoc: Reset time counters.
	End Rem
	Method ResetCounters()
		framePeriod	= 1000 / gameFPS
		frameTime	= MilliSecs() - framePeriod
	End Method


	Rem
	bbdoc: Get the number inbetween the old and the new value.
	returns: The interpolated number.
	End Rem
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween
	End Method

End Type
</textarea><br><br>But the lag is still there...<br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1122023"></a>

<a name="1122024"></a>

<a name="1122025"></a>

<a name="1122026"></a>

<a name="1122027"></a>

<a name="1122030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thought you guys were talking about the DX -input- lag problem that was fixed ages ago and it somehow popped back up.   but know this is mouse pointer lag... ok... the mouse cursor has to be realtime to reduce pointer  lag...  <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 640,480

Local fullscreen:Int
Local vwait:Int
Local rate:Int = 20
Local stage:TRL = New TRL
Local m:TMouse = New TMouse

stage.SetUpdateRate(rate)	' game login updates per second
stage.ResetCounters		' now, choose a frame at the start of your project and keep that one.
					' 30 or 60 are the best.... for a game with a whole lot of ai I'd go 30.
					' my games run at 60 though and do fine even on the slowest of machines.

SetBlend ALPHABLEND
' don't put too much in this main loop, all objects should be updated in the GameUpdate callback.
While Not KeyHit(KEY_ESCAPE) Or AppTerminate()
	If KeyHit(KEY_UP) Then rate :+ 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_DOWN) Then rate :- 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_V) Then vwait = 1-vwait
	If KeyHit(KEY_F) Then
		fullscreen = Not fullscreen
		If fullscreen
			Graphics 640, 480, 32, 60
		Else
			Graphics 640, 480, 0, 60
		EndIf
	EndIf


	' 2 functions will be called back to, one that capture the old position
	' and one that performs the game update logic.
	Local tween:Double = stage.Update( TObject.CaptureAll, GameUpdate )	
	
	' draw all object with a tween value
	TObject.DrawAll tween
	'DrawOval omx+ (MouseX()-omx)*tween, omy+ (MouseY()-omy)*tween, 20, 20 
	'	DrawOval MouseX(), MouseY(), 20, 20

	SetAlpha 1
	DrawText "balls: "+TObject.total,10,10
	DrawText "  fps: "+stage.GetFPS(),10,20
	DrawText "  ups: "+stage.GetUPS()+" [up/down]",10,30
	DrawText "vwait: "+vwait+" [v]",10,40
	DrawText "rate : "+rate, 10, 50
	DrawText "fullscreen: "+ fullscreen+ "[F]", 10, 60

	Flip vwait
	Cls
Wend

Type TMouse Extends TObject
	
	Method Draw(tween:Double )
		SetAlpha alpha
'		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
		DrawOval MouseX(),MouseY(),10,10
	End Method

	Method New()
		link = list.AddLast(Self)
	End Method

	Method Update()
'		x = MouseX()
'		y = MouseY()
	End Method

End Type


Function GameUpdate()
	
	If TObject.total &lt; 100 Then New TObject
	TObject.UpdateAll

End Function


' your object(s)
Type TObject
	Const GRAVITY:Float = 0.2
	Const FRICTION:Float = 0.99
	
	Global list:TList = New TList
	Global total:Int
	
	Field link:TLink
	Field x:Float, ox:Float
	Field y:Float, oy:Float
	Field xvel:Float
	Field yvel:Float
	Field alpha:Float = 1		' I could tween things like alpha, size, rotataion and so on if needed.
	
	' this is a callback, that gets passed to obj:TRL.Update
	Function CaptureAll()
		For Local o:TObject = EachIn list
			o.Capture
		Next
	End Function
	
	' this of course is called by your GameUpdate function that is passed to obj:TRL.Update
	Function UpdateAll()
		For Local o:TObject = EachIn list
			o.Update
		Next
	End Function
	
	Function DrawAll( tween:Double )
		For Local o:TObject = EachIn list
			o.Draw tween
		Next
	End Function

	' ---------------------------------------------------------------------
	Method New()
		link = list.AddLast(Self)
		x = GraphicsWidth()/2
		y = 20
		xvel = Rnd(-8,8)
		Capture
		total :+ 1
	End Method

	Method remove()
		total :- 1
		link.Remove
	End Method

	' ---------------------------------------------------------------------

	' capture (record current value before update) whatever values you want to
	' tween.  generally x and y but you could do alpha, size, rotation.... and more
	Method Capture()
		ox = x
		oy = y		
	End Method
	
	' this update routine gets called a fixed number per second...  I like this
	' over delta time because you don't have to add weird numbers to all of your
	' values.
	Method Update()
		yvel :+ GRAVITY
		xvel :* FRICTION
		yvel :* FRICTION
		
		x :+ xvel
		y :+ yvel

		If x &lt; 0 Or x &gt; GraphicsWidth() Then xvel = -xvel ; x :+ xvel
		If y &lt; 0 Or y &gt; GraphicsHeight() Then yvel = -yvel ; y :+ yvel
		
		alpha :- .005
		If alpha &lt; 0 Then Remove
	End Method

	' render all tweened values.
	Method Draw( tween:Double )
		SetAlpha alpha
		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
	End Method

	' ---------------------------------------------------------------------
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween 
	End Method

End Type


Type TRL
	Field gameFPS			:Double	= 60.0:Double
	Field framePeriod		:Double	= 1000.0:Double / gameFPS
	Field frameTime		:Double	= MilliSecs() - framePeriod

	Field gamelogicframes	:Int
	Field catchUp		:Int = True

	Rem
	bbdoc: This goes in the main loop and should be called every graphic frame.
	about:
	2 functions will be called back to, one that capture the old position
	and one that performs the game update logic.
	returns: tween number that should be used for drawing.
	End Rem
	Method Update:Double( captureCallback(), updateCallback() )
		Global frameElapsed:Double

		Repeat
			frameElapsed = MilliSecs() - frameTime
		Until frameElapsed
		Local frameTicks:Int = frameElapsed / framePeriod
		Local frameTween:Double = Double(frameElapsed Mod framePeriod) / framePeriod

		' update game and world state
		If Not catchUp And frameTicks &gt; 1 Then frameTicks = 1
		For Local frameLimit:Int = 1 To frameTicks
			If frameLimit = frameTicks
				captureCallback()
			End If
			frameTime = frameTime + framePeriod

			updateCallback()
			gamelogicframes = GetGameLogicFrames()
		Next

		Return frameTween
	End Method


	Rem
	bbdoc: Set the rate at which your "update" function will be run.
	about:
	Choose a logic rate at the start of your project, 30 or 60 work the best. For a game with lots of AI I'd go 30.
	End Rem
	Method SetUpdateRate( gameFPS:Double )
		Self.gameFPS = gameFPS
		framePeriod = 1000.0:Double / Self.gameFPS
		'ResetCounters
	End Method



	Rem
	bbdoc: Get the number of logic updates being called per second.
	returns: Logic updates per second.
	End Rem
	Method GetUPS:Int()
		Return gamelogicframes
	End Method


	Rem
	bbdoc: Get the actual frames being draw per second.
	returns: Frames per second.
	End Rem
	Method GetFPS:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Method GetGameLogicFrames:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Rem
	bbdoc: Reset time counters.
	End Rem
	Method ResetCounters()
		framePeriod	= 1000 / gameFPS
		frameTime	= MilliSecs() - framePeriod
	End Method


	Rem
	bbdoc: Get the number inbetween the old and the new value.
	returns: The interpolated number.
	End Rem
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween
	End Method

End Type

</textarea><br><br><div class="quote"> Nice game BTW :) <br></div><br>thanks.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1122044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Over in the The Big BlitzMax Lag Test thread we are talking about DX9 or OpenGL input lag problem with vsync on.<br><br>This thread is about how to enable a hardware mouse cursor, which eliminates the mouse lag, but of course you will still have keyboard/joystick input lag.<br><br>I've just tried your update code and the input lag is still there with vsync :/ <br><br></td></tr></table><br>
<a name="1122051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> right but it wasn't there without vsync.   so it's perfectly smooth, there is no tearing and no real lag... that was my point for why not to use it...  just saying ;) <br><br></td></tr></table><br>
<a name="1122056"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Opps... yeah of course - D'oh!<br><br>I will have to create a more complete example to see about tearing though.<br><br>I've had a good look at your timing methods and it looks really good... do you have to add everything to TObject, is there away around that? I like objects to have their own lists etc. <br><br></td></tr></table><br>
<a name="1122075"></a>

<a name="1122076"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> you can have multiple lists or many base objects or whatever.  you just need to capture the old position of all the objects that you will be tweening.  so for stage.Update in my games I don't call TObject.CaptureAll, I call somthing like "GameCapture" which is a function that then calls a CaptureAll function for each object list that's in the game. sort of like the GameUpdate function in the example.<br><br>one note that's missed sometimes... on creation or if you are recycling objects or wrapping motion from one side to the other you need to set the old x/y to the current x/y.  this then won't perform any tween as there is nothing in be"tween".<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1122088"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skn3</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pssst: custom cursors in windows and osx<br><a href="http://blitzbasic.com/Community/posts.php?topic=96527" target="_blank">http://blitzbasic.com/Community/posts.php?topic=96527</a> <br><br></td></tr></table><br>
<a name="1122112"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> There will always be tearing with vsync off.  Just draw a tall vertical object and move it sideways and you'll see it.  Tearing doesn't show up as much on some game types, like with small sprites. <br><br></td></tr></table><br>
<a name="1122127"></a>

<a name="1122128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Jake, yep your right - quick example using dmaz's code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Global sw% = 1024
Global sh% = 768

Graphics sw,sh

Local fullscreen:Int
Local vwait:Int
Local rate:Int = 60
Local stage:TRL = New TRL
Local m:TMouse = New TMouse
Local p:TPlayer = New TPlayer

stage.SetUpdateRate(rate)	' game login updates per second
stage.ResetCounters		' now, choose a frame at the start of your project and keep that one.
					' 30 or 60 are the best.... for a game with a whole lot of ai I'd go 30.
					' my games run at 60 though and do fine even on the slowest of machines.

SetBlend ALPHABLEND
' don't put too much in this main loop, all objects should be updated in the GameUpdate callback.
While Not KeyHit(KEY_ESCAPE) Or AppTerminate()
	If KeyHit(KEY_UP) Then rate :+ 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_DOWN) Then rate :- 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_V) Then vwait = 1-vwait
	If KeyHit(KEY_F) Then
		fullscreen = Not fullscreen
		If fullscreen
			Graphics sw, sh, 32, 60
		Else
			Graphics sw, sh, 0, 60
		EndIf
	EndIf


	' 2 functions will be called back to, one that capture the old position
	' and one that performs the game update logic.
	Local tween:Double = stage.Update( TObject.CaptureAll, GameUpdate )	
	
	' draw all object with a tween value
	TObject.DrawAll tween
	'DrawOval omx+ (MouseX()-omx)*tween, omy+ (MouseY()-omy)*tween, 20, 20 
	'	DrawOval MouseX(), MouseY(), 20, 20

	SetAlpha 1
	DrawText "balls: "+TObject.total,10,10
	DrawText "  fps: "+stage.GetFPS(),10,20
	DrawText "  ups: "+stage.GetUPS()+" [up/down]",10,30
	DrawText "vwait: "+vwait+" [v]",10,40
	DrawText "rate : "+rate, 10, 50
	DrawText "fullscreen: "+ fullscreen+ "[F]", 10, 60

	Flip vwait
	Cls
Wend

Type TPlayer Extends TObject
	Method New()
		link = list.AddLast(Self)
		y = 0
		x = 0
	End Method
	
	Method Draw(tween:Double )
		SetAlpha alpha
		DrawRect x, y, 50, sh
	End Method
	
	Method Update()
		x = x + 4
		If x &gt; sw Then x = -50
	End Method
End Type

Type TMouse Extends TObject
	
	Method Draw(tween:Double )
		SetAlpha alpha
'		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
		DrawOval MouseX(),MouseY(),10,10
	End Method

	Method New()
		link = list.AddLast(Self)
	End Method

	Method Update()
		x = x + 4
	End Method

End Type


Function GameUpdate()
	
	If TObject.total &lt; 100 Then New TObject
	TObject.UpdateAll

End Function


' your object(s)
Type TObject
	Const GRAVITY:Float = 0.2
	Const FRICTION:Float = 0.99
	
	Global list:TList = New TList
	Global total:Int
	
	Field link:TLink
	Field x:Float, ox:Float
	Field y:Float, oy:Float
	Field xvel:Float
	Field yvel:Float
	Field alpha:Float = 1		' I could tween things like alpha, size, rotataion and so on if needed.
	
	' this is a callback, that gets passed to obj:TRL.Update
	Function CaptureAll()
		For Local o:TObject = EachIn list
			o.Capture
		Next
	End Function
	
	' this of course is called by your GameUpdate function that is passed to obj:TRL.Update
	Function UpdateAll()
		For Local o:TObject = EachIn list
			o.Update
		Next
	End Function
	
	Function DrawAll( tween:Double )
		For Local o:TObject = EachIn list
			o.Draw tween
		Next
	End Function

	' ---------------------------------------------------------------------
	Method New()
		link = list.AddLast(Self)
		x = GraphicsWidth()/2
		y = 20
		xvel = Rnd(-8,8)
		Capture
		total :+ 1
	End Method

	Method remove()
		total :- 1
		link.Remove
	End Method

	' ---------------------------------------------------------------------

	' capture (record current value before update) whatever values you want to
	' tween.  generally x and y but you could do alpha, size, rotation.... and more
	Method Capture()
		ox = x
		oy = y		
	End Method
	
	' this update routine gets called a fixed number per second...  I like this
	' over delta time because you don't have to add weird numbers to all of your
	' values.
	Method Update()
		yvel :+ GRAVITY
		xvel :* FRICTION
		yvel :* FRICTION
		
		x :+ xvel
		y :+ yvel

		If x &lt; 0 Or x &gt; GraphicsWidth() Then xvel = -xvel ; x :+ xvel
		If y &lt; 0 Or y &gt; GraphicsHeight() Then yvel = -yvel ; y :+ yvel
		
		alpha :- .005
		If alpha &lt; 0 Then Remove
	End Method

	' render all tweened values.
	Method Draw( tween:Double )
		SetAlpha alpha
		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
	End Method

	' ---------------------------------------------------------------------
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween 
	End Method

End Type


Type TRL
	Field gameFPS			:Double	= 60.0:Double
	Field framePeriod		:Double	= 1000.0:Double / gameFPS
	Field frameTime		:Double	= MilliSecs() - framePeriod

	Field gamelogicframes	:Int
	Field catchUp		:Int = True

	Rem
	bbdoc: This goes in the main loop and should be called every graphic frame.
	about:
	2 functions will be called back to, one that capture the old position
	and one that performs the game update logic.
	returns: tween number that should be used for drawing.
	End Rem
	Method Update:Double( captureCallback(), updateCallback() )
		Global frameElapsed:Double

		Repeat
			frameElapsed = MilliSecs() - frameTime
		Until frameElapsed
		Local frameTicks:Int = frameElapsed / framePeriod
		Local frameTween:Double = Double(frameElapsed Mod framePeriod) / framePeriod

		' update game and world state
		If Not catchUp And frameTicks &gt; 1 Then frameTicks = 1
		For Local frameLimit:Int = 1 To frameTicks
			If frameLimit = frameTicks
				captureCallback()
			End If
			frameTime = frameTime + framePeriod

			updateCallback()
			gamelogicframes = GetGameLogicFrames()
		Next

		Return frameTween
	End Method


	Rem
	bbdoc: Set the rate at which your "update" function will be run.
	about:
	Choose a logic rate at the start of your project, 30 or 60 work the best. For a game with lots of AI I'd go 30.
	End Rem
	Method SetUpdateRate( gameFPS:Double )
		Self.gameFPS = gameFPS
		framePeriod = 1000.0:Double / Self.gameFPS
		'ResetCounters
	End Method



	Rem
	bbdoc: Get the number of logic updates being called per second.
	returns: Logic updates per second.
	End Rem
	Method GetUPS:Int()
		Return gamelogicframes
	End Method


	Rem
	bbdoc: Get the actual frames being draw per second.
	returns: Frames per second.
	End Rem
	Method GetFPS:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Method GetGameLogicFrames:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Rem
	bbdoc: Reset time counters.
	End Rem
	Method ResetCounters()
		framePeriod	= 1000 / gameFPS
		frameTime	= MilliSecs() - framePeriod
	End Method


	Rem
	bbdoc: Get the number inbetween the old and the new value.
	returns: The interpolated number.
	End Rem
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween
	End Method

End Type
</textarea><br><br>Without vsync you can see tearing... :(<br><br>@skn3 - Thanks for that I'll have a proper look tonight :)<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1122146"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Me too, it's super obvious in full-screen mode. <br><br></td></tr></table><br>
<a name="1122151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rixarn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can the problem be solved using threads? One thread for the input, and the other thread for everything else (update &amp; render with vsync on)? <br><br>I dont't know much about threads in Bmax so forgive me if I'm suggesting nonesense.. <br><br></td></tr></table><br>
<a name="1122222"></a>

<a name="1122223"></a>

<a name="1122224"></a>

<a name="1122225"></a>

<a name="1122226"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Without vsync you can see tearing... :( <br></div> hmmm... well... you did not tween the player.  try this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Global sw% = 1024
Global sh% = 768

Graphics sw,sh

Local fullscreen:Int
Local vwait:Int
Local rate:Int = 60
Local stage:TRL = New TRL
Local m:TMouse = New TMouse
Local p:TPlayer = New TPlayer

stage.SetUpdateRate(rate)	' game login updates per second
stage.ResetCounters		' now, choose a frame at the start of your project and keep that one.
					' 30 or 60 are the best.... for a game with a whole lot of ai I'd go 30.
					' my games run at 60 though and do fine even on the slowest of machines.

SetBlend ALPHABLEND
' don't put too much in this main loop, all objects should be updated in the GameUpdate callback.
While Not KeyHit(KEY_ESCAPE) Or AppTerminate()
	If KeyHit(KEY_UP) Then rate :+ 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_DOWN) Then rate :- 1 ; stage.SetUpdateRate(rate)
	If KeyHit(KEY_V) Then vwait = 1-vwait
	If KeyHit(KEY_F) Then
		fullscreen = Not fullscreen
		If fullscreen
			Graphics sw, sh, 32, 60
		Else
			Graphics sw, sh, 0, 60
		EndIf
		SetBlend ALPHABLEND
	EndIf


	' 2 functions will be called back to, one that capture the old position
	' and one that performs the game update logic.
	Local tween:Double = stage.Update( TObject.CaptureAll, GameUpdate )	
	
	' draw all object with a tween value
	TObject.DrawAll tween
	'DrawOval omx+ (MouseX()-omx)*tween, omy+ (MouseY()-omy)*tween, 20, 20 
	'	DrawOval MouseX(), MouseY(), 20, 20

	SetAlpha 1
	DrawText "balls: "+TObject.total,10,10
	DrawText "  fps: "+stage.GetFPS(),10,20
	DrawText "  ups: "+stage.GetUPS()+" [up/down]",10,30
	DrawText "vwait: "+vwait+" [v]",10,40
	DrawText "rate : "+rate, 10, 50
	DrawText "fullscreen: "+ fullscreen+ "[F]", 10, 60

	Flip vwait
	Cls
Wend

Type TPlayer Extends TObject
	Method New()
		link = list.AddLast(Self)
		y = 0
		x = 0
	End Method
	
	Method Draw(tween:Double )
		SetAlpha alpha
'		DrawRect x, y, 50, sh
		DrawRect GetTween(ox,x,tween),GetTween(oy,y,tween),50,sh
	End Method
	
	Method Update()
		x = x + 4
		If x &gt; sw Then x = -50 ; ox = x
	End Method
End Type

Type TMouse Extends TObject
	
	Method Draw(tween:Double )
		SetAlpha alpha
'		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
		DrawOval MouseX(),MouseY(),10,10
	End Method

	Method New()
		link = list.AddLast(Self)
	End Method

	Method Update()
		x = x + 4
	End Method

End Type


Function GameUpdate()
	
	If TObject.total &lt; 100 Then New TObject
	TObject.UpdateAll

End Function


' your object(s)
Type TObject
	Const GRAVITY:Float = 0.2
	Const FRICTION:Float = 0.99
	
	Global list:TList = New TList
	Global total:Int
	
	Field link:TLink
	Field x:Float, ox:Float
	Field y:Float, oy:Float
	Field xvel:Float
	Field yvel:Float
	Field alpha:Float = 1		' I could tween things like alpha, size, rotataion and so on if needed.
	
	' this is a callback, that gets passed to obj:TRL.Update
	Function CaptureAll()
		For Local o:TObject = EachIn list
			o.Capture
		Next
	End Function
	
	' this of course is called by your GameUpdate function that is passed to obj:TRL.Update
	Function UpdateAll()
		For Local o:TObject = EachIn list
			o.Update
		Next
	End Function
	
	Function DrawAll( tween:Double )
		For Local o:TObject = EachIn list
			o.Draw tween
		Next
	End Function

	' ---------------------------------------------------------------------
	Method New()
		link = list.AddLast(Self)
		x = GraphicsWidth()/2
		y = 20
		xvel = Rnd(-8,8)
		Capture
		total :+ 1
	End Method

	Method remove()
		total :- 1
		link.Remove
	End Method

	' ---------------------------------------------------------------------

	' capture (record current value before update) whatever values you want to
	' tween.  generally x and y but you could do alpha, size, rotation.... and more
	Method Capture()
		ox = x
		oy = y		
	End Method
	
	' this update routine gets called a fixed number per second...  I like this
	' over delta time because you don't have to add weird numbers to all of your
	' values.
	Method Update()
		yvel :+ GRAVITY
		xvel :* FRICTION
		yvel :* FRICTION
		
		x :+ xvel
		y :+ yvel

		If x &lt; 0 Or x &gt; GraphicsWidth() Then xvel = -xvel ; x :+ xvel
		If y &lt; 0 Or y &gt; GraphicsHeight() Then yvel = -yvel ; y :+ yvel
		
		alpha :- .005
		If alpha &lt; 0 Then Remove
	End Method

	' render all tweened values.
	Method Draw( tween:Double )
		SetAlpha alpha
		DrawOval GetTween(ox,x,tween),GetTween(oy,y,tween),10,10
	End Method

	' ---------------------------------------------------------------------
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween 
	End Method

End Type


Type TRL
	Field gameFPS			:Double	= 60.0:Double
	Field framePeriod		:Double	= 1000.0:Double / gameFPS
	Field frameTime		:Double	= MilliSecs() - framePeriod

	Field gamelogicframes	:Int
	Field catchUp		:Int = True

	Rem
	bbdoc: This goes in the main loop and should be called every graphic frame.
	about:
	2 functions will be called back to, one that capture the old position
	and one that performs the game update logic.
	returns: tween number that should be used for drawing.
	End Rem
	Method Update:Double( captureCallback(), updateCallback() )
		Global frameElapsed:Double

		Repeat
			frameElapsed = MilliSecs() - frameTime
		Until frameElapsed
		Local frameTicks:Int = frameElapsed / framePeriod
		Local frameTween:Double = Double(frameElapsed Mod framePeriod) / framePeriod

		' update game and world state
		If Not catchUp And frameTicks &gt; 1 Then frameTicks = 1
		For Local frameLimit:Int = 1 To frameTicks
			If frameLimit = frameTicks
				captureCallback()
			End If
			frameTime = frameTime + framePeriod

			updateCallback()
			gamelogicframes = GetGameLogicFrames()
		Next

		Return frameTween
	End Method


	Rem
	bbdoc: Set the rate at which your "update" function will be run.
	about:
	Choose a logic rate at the start of your project, 30 or 60 work the best. For a game with lots of AI I'd go 30.
	End Rem
	Method SetUpdateRate( gameFPS:Double )
		Self.gameFPS = gameFPS
		framePeriod = 1000.0:Double / Self.gameFPS
		'ResetCounters
	End Method



	Rem
	bbdoc: Get the number of logic updates being called per second.
	returns: Logic updates per second.
	End Rem
	Method GetUPS:Int()
		Return gamelogicframes
	End Method


	Rem
	bbdoc: Get the actual frames being draw per second.
	returns: Frames per second.
	End Rem
	Method GetFPS:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Method GetGameLogicFrames:Int()
		Global counter:Int
		Global time:Int
		Global framerate:Int

	    counter=counter+1
	    If time=0 Then time=MilliSecs()
	    If time+1001&lt;MilliSecs() Then
	        framerate=counter
	           counter=0
	        time=MilliSecs()
	        EndIf

		Return framerate
	End Method


	Rem
	bbdoc: Reset time counters.
	End Rem
	Method ResetCounters()
		framePeriod	= 1000 / gameFPS
		frameTime	= MilliSecs() - framePeriod
	End Method


	Rem
	bbdoc: Get the number inbetween the old and the new value.
	returns: The interpolated number.
	End Rem
	Method GetTween:Double( oldValue:Double, value:Double, tween:Double )
		Return oldValue + (value-oldValue)*tween
	End Method

End Type
</textarea><br>this takes away the super obvious tear... there is still *very* slight tear but a full height white on black rect is the most extreme example.  do you see any tearing my game rocks?.. or here's another old more real <a href="http://ooeyug.com/files/Invaders3l.zip" target="_blank">example</a> ... no fullscreen though so maybe it's not the best but the point is smooth games right?<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1122282"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> D'oh... thanks again Dmaz... no I didn't see any tearing in your Rocks game, but in that game you don't use any big images. Yep tearing is most visible when using full screen. I've seen it when displaying a scrolling background image (or even a static image). <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
