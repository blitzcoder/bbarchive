<!DOCTYPE html><html lang="en" ><head ><title >Irrlicht and Newton</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Irrlicht and Newton</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Irrlicht and Newton</a><br><br>
<a name="570213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Today I was trying to use gg.irrBMax mod by gman with Newton mod by thierry-myke and I came to acomplish the first tutorial of newton(I hope so).<br>just copy paste the code and be sure to have properly installed gg.irrBMax and Newton.PUB<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Framework PUB.Newton
Import GG.IrrBMax

Local nWorld:Byte Ptr = NewtonCreate(Null , Null)
Local collision:Byte Ptr = NewtonCreateBox(nWorld , 1.0 , 1.0 , 1.0 , Null)
Local box:Byte Ptr = newtonCreateBody(nWorld , collision)
NewtonBodySetMassMatrix(box , 1.0 , 1.0 , 1.0 , 1.0)
Local device:T_irrIrrlichtDevice = T_irrIrrlichtDevice.create(EDT_OPENGL , T_irrDimension2d_s32.create(640 , 480) , 16 , False , False , False , 0)

Local driver:T_irrIVideoDriver = device.getVideoDriver()
Local smgr:T_IrrISceneManager = device.getSceneManager() 

Local node:T_irrISceneNode = smgr.addTestSceneNode(50)
'node.setPosition(T_irrVector3df.createFromVals(100 , 20 , 30))
'node.setRotation(T_irrVector3df.createFromVals(10 , 20 ,30))
Local mat:Float[16]
T_irrGetMatrix(node ,mat)

newtonBodySetMatrix(box , Varptr Mat[0])
Local Omega:Float[] = [5.0 , 5.0 , 5.0]
newtonBodySetOmega(box , Varptr Omega[0])
smgr.addLightSceneNode(0, T_irrVector3df.createFromVals(0 , 100 , 0))

Local camera:T_irrICameraSceneNode = smgr.addCameraSceneNodeFPS()
camera.setPosition(T_irrVector3df.createFromVals(0,0,-150))

While (device.run())
	NewtonUpdate(nWorld , MilliSecs())
	NewtonBodyGetMatrix(box , Varptr Mat[0])
	T_irrSetMatrix(node , Mat)
	driver.beginScene(True , True , T_irrSColor.createFromVals(0,200 , 200 , 200))

	smgr.drawAll()
	
	driver.endScene()
	
Wend

device.drop()

For Local i:Int = 0 To 15
	Print Mat[i]
Next

Function T_irrGetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float[])
	Local Euler:Float[3]
	Euler[0] = NSceneNode.getRotation().getX() * (Pi / 180.0)
	Euler[1] = NSceneNode.getRotation().getY() * (Pi / 180.0)
	Euler[2] = NSceneNode.getRotation().getZ() * (Pi / 180.0)
	NewtonSetEulerAngle(Varptr Euler[0] , Varptr newtonMat[0])
	
	NewtonMat[12] = NSceneNode.getPosition().getX()
	newtonMat[13] = NSceneNode.getPosition().getY()
	NewtonMat[14] = NSceneNode.getPosition().getZ()
End Function

Function T_irrSetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float[])
	Local Euler:Float[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0] , Varptr Euler[0])
	NSceneNode.setPosition(T_irrVector3df.createFromVals(NewtonMat[12] , NewtonMat[13] , NewtonMat[14]))
	NSceneNode.setRotation(T_irrVector3df.createfromVals(Euler[0] * (180 / Pi) , Euler[1]*(180/Pi) , Euler[2]*(180/Pi)))
End Function

</textarea> <br><br></td></tr></table><br>
<a name="570236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TMyke</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Super, I'like it. it's so good<br>I hope that that will give a speed to  the fan of Irrlicht <br><br></td></tr></table><br>
<a name="570303"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Myke if you have some more examples with newton and eliza  <br>and if it is not trouble for you to post them pls post them cos <br>I never programmed c++. and I cannot find my way in newton. <br><br></td></tr></table><br>
<a name="570400"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> the two modules can make and tutorial two. <br><br></td></tr></table><br>
<a name="570524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TMyke</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> several things, initially download the SDK Newton, you will have Doc,<br>with the explanation for each function what helps one can nevertheless.<br>In continuation you can go to see on:<br><a href="http://irrlicht.sourceforge.net/tutorials.html" target="_blank">http://irrlicht.sourceforge.net/tutorials.html</a><br>it's C++, but you should nevertheless find the broad outline to progress.<br>For others tutotials I will try,  but I am testing integer Newtow directly in Eliza, and is not easy.<br>if I arrive there, I would make Doc, with tutorials.<br>But that takes time to me. Goes on TMyke.fr from time to time, I will make an update very soon<br>:) <br><br></td></tr></table><br>
<a name="570565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> good to know that you still work on your two projects. <br><br></td></tr></table><br>
<a name="570895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok the second tutorial its almost ready.<br>Here is the code.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Framework PUB.Newton
Import GG.IrrBMax
Import BRL.PNGLoader


Local device:T_irrIrrlichtDevice = T_irrIrrlichtDevice.create(EDT_OPENGL , T_irrDimension2d_s32.create(640 , 480) , 16 , False , False , False , 0)
Global driver:T_irrIVideoDriver = device.getVideoDriver()
Global smgr:T_IrrISceneManager = device.getSceneManager() 
'Local Tex:T_irrITexture = driver.getTexture("brlLogo.png")

Local camera:T_irrICameraSceneNode = smgr.addCameraSceneNodeFPS()
camera.setPosition(T_irrVector3df.createFromVals(-20,0,0))
camera.setRotation(T_irrVector3df.createFromVals(0 , 90 , 0))



Global nWorld:Byte Ptr = newtonCreate(PhysicsAlloc , PhysicsFree)


initScene()
Local Timer:Int = MilliSecs()
While (device.run())
	Timer:+MilliSecs()
	newtonUpdate(nWorld , Timer)
	Timer = MilliSecs()
	'NewtonBodyGetMatrix(box , Varptr Mat[0])
	'T_irrSetMatrix(node , Mat)

	driver.beginScene(True , True , T_irrSColor.createFromVals(0,200 , 200 , 200))

	smgr.drawAll()
	
	driver.endScene()
	FlushMem
Wend



Rem '''''''''''''''''''''''''''''''''''/////////////////////////////////////   The Convertion Matrix Functions
		T_irrGetMatrix is the function to get the matrix from the Irrlecht SceneNode And pass it
	to an array to be used by Newton.
		T_irrSetMatrix is the function to pass the Matrix from Newton to the Irrlicht SceneNode
EndRem

Function T_irrGetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	Euler[0] = NSceneNode.getRotation().getX() * (Pi / 180.0)
	Euler[1] = NSceneNode.getRotation().getY() * (Pi / 180.0)
	Euler[2] = NSceneNode.getRotation().getZ() * (Pi / 180.0)
	NewtonSetEulerAngle(Varptr Euler[0] , Varptr newtonMat[0])
	Newtonmat[12] = NSceneNode.getPosition().getX()
	newtonMat[13] = NSceneNode.getPosition().getY()
	NewtonMat[14] = NSceneNode.getPosition().getZ()	
End Function

Function T_irrSetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0] , Varptr Euler[0])
	NSceneNode.setPosition(T_irrVector3df.createFromVals(NewtonMat[12] , NewtonMat[13] , NewtonMat[14]))
	NSceneNode.setRotation(T_irrVector3df.createfromVals(Euler[0] * (180 / Pi) , Euler[1] * (180 / Pi) , Euler[2] * (180 / Pi)))

End Function

Rem 
					THE FUNCTIONS FROM TUTORIAL 2
End Rem

Function	PhysicsAlloc:Byte Ptr(sizeInBytes:Int)
	Return MemAlloc(sizeInBytes)
End Function

Function    PhysicsFree( memptr:Byte Ptr, sizeInBytes:Int)
	MemFree (memptr, sizeInBytes)
End Function

' set the tranformation of a rigid body
Function  PhysicsApplyForceAndTorque (Body:Byte Ptr)
	Local mass:Float
	Local Ixx:Float
	Local Iyy:Float
	Local Izz:Float

	NewtonBodyGetMassMatrix (body,Varptr mass, Varptr Ixx, Varptr Iyy, Varptr Izz);
	Local force:Float[] =  [0.0, -10.0 , 0.0]
	NewtonBodySetForce (body, Varptr force[0])
End Function

Function  PhysicsSetTransform (body:Byte Ptr, NewtonMat:Float Ptr)
	Local primitive:T_irrISceneNode Ptr
	'// get the graphic Object form the rigid body
	primitive = T_irrISceneNode Ptr(newtonBodyGetUserData(body))
	
	'// set the transformation matrix For this rigid body
	newtonBodyGetMatrix(body , Varptr NewtonMat[0])
	T_irrSetMatrix(Var Primitive , Varptr NewtonMat[0])
	

End Function

Function PhysicsBodyDestructor(body:Byte Ptr)
	Local primitive:T_irrISceneNode

	'// get the graphic Object form the rigid body
	primitive = Var T_irrISceneNode Ptr (newtonBodyGetUserData(body))

	'// destroy the graphic Object
	primitive.remove()
	
End Function

Function CleanUp ()

	'// destroy the Newton world
	NewtonDestroy (nWorld);
	
End Function

Function InitScene()
	Global Texture:T_irrITexture = Driver.getTexture("brllogo.png") 
	Global box:T_irrISceneNode
	Global IFloor:T_irrISceneNode
	Global boxBody:Byte Ptr
	Global floorBody:Byte Ptr
	Global collision:Byte Ptr
	Global Mat:Float[16]
	'// create the newton world

	
	'// set the linear solver model For faster speed 
	NewtonSetSolverModel(nWorld, 8)

	'// set the adpative friction model For faster speed 
	NewtonSetFrictionModel(nWorld, 1)
	
	'// Set the termination Function
	'atexit(CleanUp);   '//// I Haven't Found The Apropriaty Function for Irrlicht
	
	'// create the the Floor graphic objects
	IFloor = smgr.addTestSceneNode(100 )
	IFloor.setPosition(T_irrVector3df.createFromVals(0,-100 , 0))
	collision = newtonCreateBox(nWorld , 100.0 , 100.0 , 100.0 , Null)
	FloorBody = newtonCreateBody(nWorld , collision)
	
	'// set the transformation For this rigid body
	T_irrGetMatrix(IFloor ,Varptr Mat[0])
	NewtonBodySetMatrix(floorBody,Varptr Mat[0])
	
	'// save the pointer To the graphic Object with the body.
	NewtonBodySetUserData(floorBody,Varptr IFloor)
	
	'// set a destrutor For this rigid body
	NewtonBodySetDestructorCallback(floorBody, PhysicsBodyDestructor);
	
	'// set the initial size
	'size = dVector(0.5f, 0.5f, 0.5f);    Not really nesesery(I think so)

	'// create the collision 
	collision = NewtonCreateBox(nWorld, 0.5 , 0.5, 0.5 , Null) 
	Local location:Float[] = [0.0 , 0.0 , 0.0]
	location[0] = -10.0   'FOR  X
	For Local k:Int = 0 To 9
		location[2] = 0.0	'For Z
		For Local J:Int = 0 To 9
			location[1] = 2.0	'For Y
			For Local i:Int = 0  To 9
				
				box = smgr.addTestSceneNode(0.5)
				box.SetMaterialTexture(0 , Texture)
				box.setPosition(T_irrVector3df.createFromVals(location[0] ,location[1] , location[2]))
				boxBody = newtonCreateBody(nWorld , collision)				
				newtonBodySetUserData(boxBody , Varptr box)		

				'// set a destrutor For this rigid body
				NewtonBodySetDestructorCallback(boxBody, PhysicsBodyDestructor)

				'// set the tranform call back Function
				NewtonBodySetTransformCallback(boxBody, PhysicsSetTransform)

				'// set the force And torque call back funtion
				NewtonBodySetForceAndTorqueCallback(boxBody, PhysicsApplyForceAndTorque)

				'// set the mass matrix
				'//NewtonBodySetMassMatrix (boxBody, 1.0f, 1.0f / 6.0f, 1.0f / 6.0f, 1.0f  / 6.0f);
				NewtonBodySetMassMatrix(boxBody, 1.0, 1.0, 1.0, 1.0)				

				'// set the matrix For tboth the rigid nody And the graphic body
				T_irrGetMatrix(box , Varptr Mat[0])
				NewtonBodySetMatrix(boxBody,Varptr Mat[0])
				PhysicsSetTransform(boxBody, Varptr Mat[0])

				Location[1] :+ 0.5 * 2.0
			Next
			Location[2] :- 0.5 * 4.0 	
		Next
		location[0] :- 0.5 * 4.0 
	Next

	'// Release the collsion geometry when Not need it
	NewtonReleaseCollision(nWorld, collision)
end function
</textarea><br><br>the proble that i have here and not working the tutorial right is that collisions are not working if not all Irrlicht Nodes have inique names.<br>plus the pointer PhysicsSetTransform function if the nodes have the same name(like the cubes in the tutorial) allways call the last added node.<br><br>If someone finds out what going wrong pls say. <br><br></td></tr></table><br>
<a name="570934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> greetings Haramanai :)  i will not be able to look at this until this evening (im -6 GMT) but i will see if i can see anything. <br><br></td></tr></table><br>
<a name="570946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks . I am going to wait for your answer <br><br></td></tr></table><br>
<a name="571656"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> went down with the flu sunday afternoon :(  i am feeling a bit better and will try to take a look at this tonight. <br><br></td></tr></table><br>
<a name="572060"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> sorry it took me so long.  my girls have the flu now too so we've been pretty busy at home.  i found your objects not moving issue.  essentially you were storing a reference to the BMAX box object in the newton userdata but this does not increment the BMAX reference counter and those variables were falling out of scope.  the better way to do it, would be to store the reference to the C++ object handle (remember  the Irrlicht mod is a wrapper and the C++ object handle is what the Irrlicht scene graph keeps a reference to) and rebuild the scenenode from the handle.  for some reason i had to tweak the mass calculation, but here is a modified version of your sample thats working.  all my changes have comments starting with "GG:".<br><pre class=code>
Strict
Framework PUB.Newton
Import GG.IrrBMax
Import BRL.PNGLoader

Local device:T_irrIrrlichtDevice = T_irrIrrlichtDevice.create(EDT_OPENGL , T_irrDimension2d_s32.create(640 , 480) , 16 , False , False , False , 0)
Global driver:T_irrIVideoDriver = device.getVideoDriver()
Global smgr:T_IrrISceneManager = device.getSceneManager() 
'Local Tex:T_irrITexture = driver.getTexture("brlLogo.png")
Local camera:T_irrICameraSceneNode = smgr.addCameraSceneNodeFPS()
camera.setPosition(T_irrVector3df.createFromVals(-20,0,0))
camera.setRotation(T_irrVector3df.createFromVals(0 , 90 , 0))

Global nWorld:Byte Ptr = newtonCreate(PhysicsAlloc , PhysicsFree)

initScene()
Local Timer:Int = MilliSecs()
While (device.run())
	Timer:+MilliSecs()
	newtonUpdate(nWorld , Timer)
	Timer = MilliSecs()
	'NewtonBodyGetMatrix(box , Varptr Mat[0])
	'T_irrSetMatrix(node , Mat)
	driver.beginScene(True , True , T_irrSColor.createFromVals(0,200 , 200 , 200))
	smgr.drawAll()
	
	driver.endScene()
	FlushMem
Wend

Rem '''''''''''''''''''''''''''''''''''/////////////////////////////////////   The Convertion Matrix Functions
		T_irrGetMatrix is the function to get the matrix from the Irrlecht SceneNode And pass it
	to an array to be used by Newton.
		T_irrSetMatrix is the function to pass the Matrix from Newton to the Irrlicht SceneNode
EndRem
Function T_irrGetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	Euler[0] = NSceneNode.getRotation().getX() * (Pi / 180.0)
	Euler[1] = NSceneNode.getRotation().getY() * (Pi / 180.0)
	Euler[2] = NSceneNode.getRotation().getZ() * (Pi / 180.0)
	NewtonSetEulerAngle(Varptr Euler[0] , Varptr newtonMat[0])
	Newtonmat[12] = NSceneNode.getPosition().getX()
	newtonMat[13] = NSceneNode.getPosition().getY()
	NewtonMat[14] = NSceneNode.getPosition().getZ()	
End Function
Function T_irrSetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0] , Varptr Euler[0])
	NSceneNode.setPosition(T_irrVector3df.createFromVals(NewtonMat[12] , NewtonMat[13] , NewtonMat[14]))
	NSceneNode.setRotation(T_irrVector3df.createfromVals(Euler[0] * (180 / Pi) , Euler[1] * (180 / Pi) , Euler[2] * (180 / Pi)))
End Function
Rem 
					THE FUNCTIONS FROM TUTORIAL 2
End Rem
Function	PhysicsAlloc:Byte Ptr(sizeInBytes:Int)
	Return MemAlloc(sizeInBytes)
End Function
Function    PhysicsFree( memptr:Byte Ptr, sizeInBytes:Int)
	MemFree (memptr, sizeInBytes)
End Function
' set the tranformation of a rigid body
Function  PhysicsApplyForceAndTorque (Body:Byte Ptr)
	Local mass:Float
	Local Ixx:Float
	Local Iyy:Float
	Local Izz:Float
	NewtonBodyGetMassMatrix (body,Varptr mass, Varptr Ixx, Varptr Iyy, Varptr Izz);
	'Local force:Float[] =  [0.0, -mass * 9.8 , 0.0]
	' GG: messed with the mass multiplier to make it look like the tutorial.  have no idea why this is different.
	Local force:Float[] =  [0.0, -mass * 410 , 0.0]
	NewtonBodySetForce (body, Varptr force[0])
End Function
Function  PhysicsSetTransform (body:Byte Ptr, NewtonMat:Float Ptr)
	Local primitive:T_irrISceneNode
	'// get the graphic Object form the rigid body
	' GG: changed to recreate the scenenode based on the C++ object handle
	primitive = T_irrISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	
	'// set the transformation matrix For this rigid body
	newtonBodyGetMatrix(body , Varptr NewtonMat[0])
	T_irrSetMatrix(Primitive , Varptr NewtonMat[0])
	
End Function
Function PhysicsBodyDestructor(body:Byte Ptr)
	Local primitive:T_irrISceneNode
	'// get the graphic Object form the rigid body
	' GG: changed to recreate the scenenode based on the C++ object handle
	primitive = T_irrISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	'// destroy the graphic Object
	primitive.remove()
	
End Function
Function CleanUp ()
	'// destroy the Newton world
	NewtonDestroy (nWorld);
	
End Function
Function InitScene()
	Global Texture:T_irrITexture = Driver.getTexture("brllogo.png") 
	Global box:T_irrISceneNode
	Global IFloor:T_irrISceneNode
	Global boxBody:Byte Ptr
	Global floorBody:Byte Ptr
	Global collision:Byte Ptr
	Global Mat:Float[16]
	'// create the newton world
	
	'// set the linear solver model For faster speed 
	NewtonSetSolverModel(nWorld, 8)
	'// set the adpative friction model For faster speed 
	NewtonSetFrictionModel(nWorld, 1)
	
	'// Set the termination Function
	'atexit(CleanUp);   '//// I Haven't Found The Apropriaty Function for Irrlicht
	
	'// create the the Floor graphic objects
	IFloor = smgr.addTestSceneNode(100 )
	IFloor.setPosition(T_irrVector3df.createFromVals(0,-100 , 0))
	collision = newtonCreateBox(nWorld , 100.0 , 100.0 , 100.0 , Null)
	FloorBody = newtonCreateBody(nWorld , collision)
	
	'// set the transformation For this rigid body
	T_irrGetMatrix(IFloor ,Varptr Mat[0])
	NewtonBodySetMatrix(floorBody,Varptr Mat[0])
	
	'// save the pointer To the graphic Object with the body.
	' GG: changed to store the scenenode C++ object handle instead of a reference to the BMAX object with falls out of scope
	NewtonBodySetUserData(floorBody,Byte Ptr(IFloor.handle))
	
	'// set a destrutor For this rigid body
	NewtonBodySetDestructorCallback(floorBody, PhysicsBodyDestructor);
	
	'// set the initial size
	'size = dVector(0.5f, 0.5f, 0.5f);    Not really nesesery(I think so)
	'// create the collision 
	collision = NewtonCreateBox(nWorld, 0.5 , 0.5, 0.5 , Null) 
	Local location:Float[] = [0.0 , 0.0 , 0.0]
	location[0] = -10.0   'FOR  X
	For Local k:Int = 0 To 9
		location[2] = 0.0	'For Z
		For Local J:Int = 0 To 9
			location[1] = 2.0	'For Y
			For Local i:Int = 0  To 9
				box = smgr.addTestSceneNode(0.5)
				box.SetMaterialTexture(0 , Texture)
				box.setPosition(T_irrVector3df.createFromVals(location[0] ,location[1] , location[2]))
				boxBody = newtonCreateBody(nWorld , collision)				
				' GG: changed to store the scenenode C++ object handle instead of a reference to the BMAX object with falls out of scope
				newtonBodySetUserData(boxBody ,Byte Ptr(box.handle))		
				'// set a destrutor For this rigid body
				NewtonBodySetDestructorCallback(boxBody, PhysicsBodyDestructor)
				'// set the tranform call back Function
				NewtonBodySetTransformCallback(boxBody, PhysicsSetTransform)
				'// set the force And torque call back funtion
				NewtonBodySetForceAndTorqueCallback(boxBody, PhysicsApplyForceAndTorque)
				'// set the mass matrix
				'//NewtonBodySetMassMatrix (boxBody, 1.0f, 1.0f / 6.0f, 1.0f / 6.0f, 1.0f  / 6.0f);
				NewtonBodySetMassMatrix(boxBody, 1.0, 1.0, 1.0, 1.0)				
				'// set the matrix For tboth the rigid nody And the graphic body
				T_irrGetMatrix(box , Varptr Mat[0])
				NewtonBodySetMatrix(boxBody,Varptr Mat[0])
				PhysicsSetTransform(boxBody, Varptr Mat[0])
				Location[1] :+ 0.5 * 2.0
			Next
			Location[2] :- 0.5 * 4.0 	
		Next
		location[0] :- 0.5 * 4.0 
	Next
	'// Release the collsion geometry when Not need it
	NewtonReleaseCollision(nWorld, collision)

EndFunction
</pre> <br><br></td></tr></table><br>
<a name="572106"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wise the best for your family.(sorry English it's not my first language and I don't know what to say in this situatuions)<br><br>Thanks for the clue. <br><br></td></tr></table><br>
<a name="572126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok here is the working Tutorial two with some changes so it will be more visual and with the forgoten line for collision.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Framework PUB.Newton
Import GG.IrrBMax
Import BRL.PNGLoader

Local device:T_irrIrrlichtDevice = T_irrIrrlichtDevice.create(EDT_OPENGL , T_irrDimension2d_s32.create(640 , 480) , 16 , False , False , False , 0)
Global driver:T_irrIVideoDriver = device.getVideoDriver()
Global smgr:T_IrrISceneManager = device.getSceneManager() 
'Local Tex:T_irrITexture = driver.getTexture("brlLogo.png")
Local camera:T_irrICameraSceneNode = smgr.addCameraSceneNodeFPS()
camera.setPosition(T_irrVector3df.createFromVals(-19,-49,-30))
camera.setRotation(T_irrVector3df.createFromVals(0 , 0 , 0))
Local light:T_irrILightSceneNode = smgr.addLightSceneNode( 0 , T_irrVector3df.createfromVals(-20 , -40 , -30) , 100)


Global nWorld:Byte Ptr = newtonCreate(PhysicsAlloc , PhysicsFree)

initScene()
Local Timer:Int = MilliSecs()
While (device.run())
	Timer:+MilliSecs()
	newtonUpdate(nWorld , 0.001)
	Timer = MilliSecs()
	'NewtonBodyGetMatrix(box , Varptr Mat[0])
	'T_irrSetMatrix(node , Mat)
	driver.beginScene(True , True , T_irrSColor.createFromVals(0,200 , 200 , 200))
	smgr.drawAll()
	
	driver.endScene()
	FlushMem
Wend

Rem '''''''''''''''''''''''''''''''''''/////////////////////////////////////   The Convertion Matrix Functions
		T_irrGetMatrix is the function to get the matrix from the Irrlecht SceneNode And pass it
	to an array to be used by Newton.
		T_irrSetMatrix is the function to pass the Matrix from Newton to the Irrlicht SceneNode
EndRem
Function T_irrGetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	Euler[0] = NSceneNode.getRotation().getX() * (Pi / 180.0)
	Euler[1] = NSceneNode.getRotation().getY() * (Pi / 180.0)
	Euler[2] = NSceneNode.getRotation().getZ() * (Pi / 180.0)
	NewtonSetEulerAngle(Varptr Euler[0] , Varptr newtonMat[0])
	Newtonmat[12] = NSceneNode.getPosition().getX()
	newtonMat[13] = NSceneNode.getPosition().getY()
	NewtonMat[14] = NSceneNode.getPosition().getZ()	
End Function
Function T_irrSetMatrix(NSceneNode:T_irrISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0] , Varptr Euler[0])
	NSceneNode.setPosition(T_irrVector3df.createFromVals(NewtonMat[12] , NewtonMat[13] , NewtonMat[14]))
	NSceneNode.setRotation(T_irrVector3df.createfromVals(Euler[0] * (180 / Pi) , Euler[1] * (180 / Pi) , Euler[2] * (180 / Pi)))
End Function
Rem 
					THE FUNCTIONS FROM TUTORIAL 2
End Rem
Function	PhysicsAlloc:Byte Ptr(sizeInBytes:Int)
	Return MemAlloc(sizeInBytes)
End Function
Function    PhysicsFree( memptr:Byte Ptr, sizeInBytes:Int)
	MemFree (memptr, sizeInBytes)
End Function
' set the tranformation of a rigid body
Function  PhysicsApplyForceAndTorque (Body:Byte Ptr)
	Local mass:Float
	Local Ixx:Float
	Local Iyy:Float
	Local Izz:Float
	NewtonBodyGetMassMatrix (body,Varptr mass, Varptr Ixx, Varptr Iyy, Varptr Izz);
	'Local force:Float[] =  [0.0, -mass * 9.8 , 0.0]
	' GG: messed with the mass multiplier to make it look like the tutorial.  have no idea why this is different.
	Local force:Float[] =  [0.0, -mass * 410 , 0.0]
	NewtonBodySetForce (body, Varptr force[0])
End Function
Function  PhysicsSetTransform (body:Byte Ptr, NewtonMat:Float Ptr)
	Local primitive:T_irrISceneNode
	'// get the graphic Object form the rigid body
	' GG: changed to recreate the scenenode based on the C++ object handle
	primitive = T_irrISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	
	'// set the transformation matrix For this rigid body
	newtonBodyGetMatrix(body , Varptr NewtonMat[0])
	T_irrSetMatrix(Primitive , Varptr NewtonMat[0])
	
End Function
Function PhysicsBodyDestructor(body:Byte Ptr)
	Local primitive:T_irrISceneNode
	'// get the graphic Object form the rigid body
	' GG: changed to recreate the scenenode based on the C++ object handle
	primitive = T_irrISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	'// destroy the graphic Object
	primitive.remove()
	
End Function
Function CleanUp ()
	'// destroy the Newton world
	NewtonDestroy (nWorld);
	
End Function
Function InitScene()
	Global Texture:T_irrITexture = Driver.getTexture("doc/brllogo.png") 
	Global box:T_irrISceneNode
	Global IFloor:T_irrISceneNode
	Global boxBody:Byte Ptr
	Global floorBody:Byte Ptr
	Global collision:Byte Ptr
	Global Mat:Float[16]
	'// create the newton world
	
	'// set the linear solver model For faster speed 
	NewtonSetSolverModel(nWorld, 8)
	'// set the adpative friction model For faster speed 
	NewtonSetFrictionModel(nWorld, 1)
	
	'// Set the termination Function
	'atexit(CleanUp);   '//// I Haven't Found The Apropriaty Function for Irrlicht
	
	'// create the the Floor graphic objects
	IFloor = smgr.addTestSceneNode(100 )
	'IFloor.setMaterialFlag(EMF_LIGHTING,True)
	IFloor.setMaterialTexture(0 , texture)
	IFloor.setPosition(T_irrVector3df.createFromVals(0,-100 , 0))
	collision = newtonCreateBox(nWorld , 100.0 , 100.0 , 100.0 , Null)
	FloorBody = newtonCreateBody(nWorld , collision)
	
	'// set the transformation For this rigid body
	T_irrGetMatrix(IFloor ,Varptr Mat[0])
	NewtonBodySetMatrix(floorBody,Varptr Mat[0])
	
	'// save the pointer To the graphic Object with the body.
	' GG: changed to store the scenenode C++ object handle instead of a reference to the BMAX object with falls out of scope
	NewtonBodySetUserData(floorBody,Byte Ptr(IFloor.handle))
	
	'// set a destrutor For this rigid body
	NewtonBodySetDestructorCallback(floorBody, PhysicsBodyDestructor);
	
	'// set the initial size
	'size = dVector(0.5f, 0.5f, 0.5f);    Not really nesesery(I think so)
	'// create the collision 
	newtonReleaseCollision(nWorld , collision)
	collision = NewtonCreateBox(nWorld, 0.5 , 0.5, 0.5 , Null) 
	Local location:Float[] = [0.0 , 0.0 , 0.0]
	location[0] = -10.0   'FOR  X
	For Local k:Int = 0 To 9
		location[2] = 0.0	'For Z
		For Local J:Int = 0 To 9
			location[1] = 2.0	'For Y
			For Local i:Int = 0  To 9
				box = smgr.addTestSceneNode(0.5)
				box.setMaterialFlag(EMF_LIGHTING,True)
				box.SetMaterialTexture(0 , Texture)
				box.setPosition(T_irrVector3df.createFromVals(location[0] ,location[1] , location[2]))
				boxBody = newtonCreateBody(nWorld , collision)				
				' GG: changed to store the scenenode C++ object handle instead of a reference to the BMAX object with falls out of scope
				newtonBodySetUserData(boxBody ,Byte Ptr(box.handle))		
				'// set a destrutor For this rigid body
				NewtonBodySetDestructorCallback(boxBody, PhysicsBodyDestructor)
				'// set the tranform call back Function
				NewtonBodySetTransformCallback(boxBody, PhysicsSetTransform)
				'// set the force And torque call back funtion
				NewtonBodySetForceAndTorqueCallback(boxBody, PhysicsApplyForceAndTorque)
				'// set the mass matrix
				'//NewtonBodySetMassMatrix (boxBody, 1.0f, 1.0f / 6.0f, 1.0f / 6.0f, 1.0f  / 6.0f);
				NewtonBodySetMassMatrix(boxBody, 1.0, 1.0, 1.0, 1.0)				
				'// set the matrix For tboth the rigid nody And the graphic body
				T_irrGetMatrix(box , Varptr Mat[0])
				NewtonBodySetMatrix(boxBody,Varptr Mat[0])
				PhysicsSetTransform(boxBody, Varptr Mat[0])
				Location[1] :+ 0.5 * 2.0
			Next
			Location[2] :- 0.5 * 4.0 	
		Next
		location[0] :- 0.5 * 4.0 
	Next
	'// Release the collsion geometry when Not need it
	NewtonReleaseCollision(nWorld, collision)

EndFunction

</textarea> <br><br></td></tr></table><br>
<a name="572140"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I wise the best for your family<br> <br></div><br>correct would be "I wish the best for your family" and thank you :) <br><br></td></tr></table><br>
<a name="572234"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks to gman all moves.<br>I have sniped the code from the tutorial of the Irrlicht web site and translated to fit gg.ibmax and newton.mod and created a function so to be able to use Maps with newton. <br>Here is the function:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function T_irrAnimateMeshToNewtonCollisionTree(nWorld:Byte Ptr , g_map:T_irrIAnimatedMesh , g_newtonMap:Byte Ptr)

	NewtonTreeCollisionBeginBuild(g_newtonmap)
	Local cMeshBuffer:Int, j:Int
	Local v1i:Int, v2i:Int, v3i:Int
	Local mb:T_irrIMeshBuffer

	Local vArray:Float[9]	'// vertex array (3*3 floats)

	Local tmpCount:Int = 0

	For cMeshBuffer=0 To g_map.getMesh(0).getMeshBufferCount() - 1
		
		mb = g_map.getMesh(0).getMeshBuffer(cMeshBuffer)

		'video::S3DVertex2TCoords* mb_vertices = (irr::video::S3DVertex2TCoords*)mb-&gt;getVertices();
		Local mb_vertices:T_irrArray_S3DVertex = mb.getVertices()
		'u16* mb_indices  = mb-&gt;getIndices();
		 Local mb_indices:T_irrArray_u16  = mb.getIndices()
		
		'// add each triangle from the mesh
		'For j=0 To j&lt;mb-&gt;getIndexCount(); j+=3)
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i = mb_indices.elementAt(j)
			v2i = mb_indices.elementAt(j+1)
			v3i = mb_indices.elementAt(j+2)
	
			vArray[0] = mb_vertices.elementAt(v1i).getPos().getX()
			vArray[1] = mb_vertices.elementAt(v1i).getPos().getY()
			vArray[2] = mb_vertices.elementAt(v1i).getPos().getZ()
			vArray[3] = mb_vertices.elementAt(v2i).getPos().getX()
			vArray[4] = mb_vertices.elementAt(v2i).getPos().getY()
			vArray[5] = mb_vertices.elementAt(v2i).getPos().getZ()
			vArray[6] = mb_vertices.elementAt(v3i).getPos().getX()
			vArray[7] = mb_vertices.elementAt(v3i).getPos().getY()
			vArray[8] = mb_vertices.elementAt(v3i).getPos().getZ()

			'NewtonTreeCollisionAddFace(g_newtonmap, 3, (Float*)vArray, 12, 1);
			NewtonTreeCollisionAddFace(g_newtonmap, 3,Varptr vArray[0], 12, 1)
		Next

	Next
	NewtonTreeCollisionEndBuild(g_newtonmap, 0);
	Local g_newtonmapbody:Byte Ptr = NewtonCreateBody(nWorld, g_newtonmap);

Rem
After loading the bsp mesh in irrlicht we must create a newton collision tree consisting of all the triangles
in the bsp mesh. To do this we loop through the indices list And add vertices 3 at a time into newton. I should
mention here that I was lazy when writing this And just used a straight cast To video::S3DVertex2TCoords - this is because
bsp meshes have lightmap textures on them. If you are using a mesh with only 1 set of texture co-ordinates (like
a landscape Or .x level) Then use (video::S3DVertex).
Newton requires 2 pointers For every Object - a NewtonBody* For the rigid body, And a NewtonCollision* that
describes the objects geometry. After creating the tree collision geometry, we create a body For the map And
assign it To the collision. Bodys which have a tree collision For their geometry are static And their mass
will be ignored by newton - so you can only use meshes For your scenery!
End Rem
	'// set the newton world size based on the bsp size
	Local boxP0:Float[3] 
	Local boxP1:Float[3] 
	Local matrix:Float[16] 
	NewtonBodyGetMatrix (g_newtonmapbody,Varptr matrix[0]) 
	NewtonCollisionCalculateAABB (g_newtonmap,Varptr matrix[0], Varptr boxP0[0], Varptr boxP1[0]) 
	'// you can pad the box here If you wish
	'//boxP0.y -= somevalue; 
	'//boxP1.y += somevaluef; 
	'NewtonSetWorldSize (nWorld, (Float*)boxP0, (Float*)boxP1);
	NewtonSetWorldSize (nWorld, Varptr boxP0[0], Varptr boxP1[0])
Rem
After loading the map, we can calculate the bounding box surrounding it And set the newton world size To
match. Newton should automatically disable anything which falls out of the map this way.
End Rem
End Function
</textarea><br><br>beware that if you move the map in irrlicht you lose all the compartibility. <br><br></td></tr></table><br>
<a name="664142"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DirtBikeDude</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Haramanai, I was experimenting with you code. I noticed if the frame rate drops the physics does'nt match the ammount of time elapsed. The physics syncronizes with the frames per second instead of the timescale. Is this how newton works or could the example be changed? <br><br></td></tr></table><br>
<a name="664397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know DirtBikeDude. My expirience with Newton was only this. After that I haven't touched newton with Irrlicht. I think that you will not have any problem by posting to Newton's or Irrlicht's forums about any problems you may have or search fo answers  as the wrappers are very well done. <br><br></td></tr></table><br>
<a name="751240"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, this thread could use some reviving.  So here's my newer irrlicht compatible version of the mesh to tree function.  And guess what?  I doesn't work.  Could someone tell me what I did wrong?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Function AnimatedMeshToNewtonCollisionTree(nWorld:Byte Ptr,g_map:IAnimatedMesh,g_newtonMap:Byte Ptr)
	NewtonTreeCollisionBeginBuild(g_newtonmap)
	Local cMeshBuffer:Int,j:Int
	Local v1i:Int,v2i:Int,v3i:Int
	Local mb:IMeshBuffer
	
	Local vArray:Float[9]	'vertex array (3*3 floats)
	
	Local tmpCount:Int = 0
	
	For cMeshBuffer=0 To g_map.getMesh(0).getMeshBufferCount() - 1
		
		mb = g_map.getMesh(0).getMeshBuffer(cMeshBuffer)
		
		Local mb_vertices:Array_S3DVertex=mb.getVertices()
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]
			
			vArray[0]=mb_vertices.elementAt(v1i).getPos().getX()
			vArray[1]=mb_vertices.elementAt(v1i).getPos().getY()
			vArray[2]=mb_vertices.elementAt(v1i).getPos().getZ()
			vArray[3]=mb_vertices.elementAt(v2i).getPos().getX()
			vArray[4]=mb_vertices.elementAt(v2i).getPos().getY()
			vArray[5]=mb_vertices.elementAt(v2i).getPos().getZ()
			vArray[6]=mb_vertices.elementAt(v3i).getPos().getX()
			vArray[7]=mb_vertices.elementAt(v3i).getPos().getY()
			vArray[8]=mb_vertices.elementAt(v3i).getPos().getZ()
			
			NewtonTreeCollisionAddFace(g_newtonmap, 3,Varptr vArray[0], 12, 1)
		Next
		
	Next
	NewtonTreeCollisionEndBuild(g_newtonmap,0);
	Local g_newtonmapbody:Byte Ptr=NewtonCreateBody(nWorld,g_newtonmap);
	
Rem
After loading the bsp mesh in irrlicht we must create a newton collision tree consisting of all the triangles
in the bsp mesh. To do this we loop through the indices list And add vertices 3 at a time into newton. I should
mention here that I was lazy when writing this And just used a straight cast To video::S3DVertex2TCoords - this is because
bsp meshes have lightmap textures on them. If you are using a mesh with only 1 set of texture co-ordinates (like
a landscape Or .x level) Then use (video::S3DVertex).
Newton requires 2 pointers For every Object - a NewtonBody* For the rigid body, And a NewtonCollision* that
describes the objects geometry. After creating the tree collision geometry, we create a body For the map And
assign it To the collision. Bodys which have a tree collision For their geometry are static And their mass
will be ignored by newton - so you can only use meshes For your scenery!
End Rem
	'set the newton world size based on the bsp size
	Local boxP0:Float[3] 
	Local boxP1:Float[3] 
	Local matrix:Float[16] 
	NewtonBodyGetMatrix g_newtonmapbody,Varptr matrix[0]
	NewtonCollisionCalculateAABB g_newtonmap,Varptr matrix[0],Varptr boxP0[0],Varptr boxP1[0]
	'pad the box
	boxP0[0]:-10
	boxP1[0]:+10
	boxP0[1]:-10
	boxP1[1]:+10
	boxP0[2]:-10
	boxP1[2]:+10
	NewtonSetWorldSize nWorld,Varptr boxP0[0],Varptr boxP1[0]
Rem
After loading the map, we can calculate the bounding box surrounding it And set the newton world size To
match. Newton should automatically disable anything which falls out of the map this way.
End Rem
End Function</textarea> <br><br></td></tr></table><br>
<a name="751242"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Function AnimatedMeshToNewtonCollisionTree:Byte Ptr(nWorld:Byte Ptr,g_map:IAnimatedMesh,g_newtonMap:Byte Ptr)
	NewtonTreeCollisionBeginBuild(g_newtonmap)
	Local cMeshBuffer:Int,j:Int
	Local v1i:Int,v2i:Int,v3i:Int
	Local mb:IMeshBuffer
	
	Local vArray:Float[9]	'vertex array (3*3 floats)
	
	Local tmpCount:Int = 0
	
	For cMeshBuffer=0 To g_map.getMesh(0).getMeshBufferCount() - 1
		
		mb = g_map.getMesh(0).getMeshBuffer(cMeshBuffer)
		
		Local mb_vertices:Array_S3DVertex=mb.getVertices()
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]
			
			vArray[0]=mb_vertices.elementAt(v1i).getPos().getX()
			vArray[1]=mb_vertices.elementAt(v1i).getPos().getY()
			vArray[2]=mb_vertices.elementAt(v1i).getPos().getZ()
			vArray[3]=mb_vertices.elementAt(v2i).getPos().getX()
			vArray[4]=mb_vertices.elementAt(v2i).getPos().getY()
			vArray[5]=mb_vertices.elementAt(v2i).getPos().getZ()
			vArray[6]=mb_vertices.elementAt(v3i).getPos().getX()
			vArray[7]=mb_vertices.elementAt(v3i).getPos().getY()
			vArray[8]=mb_vertices.elementAt(v3i).getPos().getZ()
			
			NewtonTreeCollisionAddFace(g_newtonmap, 3,Varptr vArray[0], 12, 1)
		Next
		
	Next
	NewtonTreeCollisionEndBuild(g_newtonmap,0);
	Local g_newtonmapbody:Byte Ptr=NewtonCreateBody(nWorld,g_newtonmap);
	
Rem
After loading the bsp mesh in irrlicht we must create a newton collision tree consisting of all the triangles
in the bsp mesh. To do this we loop through the indices list And add vertices 3 at a time into newton. I should
mention here that I was lazy when writing this And just used a straight cast To video::S3DVertex2TCoords - this is because
bsp meshes have lightmap textures on them. If you are using a mesh with only 1 set of texture co-ordinates (like
a landscape Or .x level) Then use (video::S3DVertex).
Newton requires 2 pointers For every Object - a NewtonBody* For the rigid body, And a NewtonCollision* that
describes the objects geometry. After creating the tree collision geometry, we create a body For the map And
assign it To the collision. Bodys which have a tree collision For their geometry are static And their mass
will be ignored by newton - so you can only use meshes For your scenery!
End Rem
	'set the newton world size based on the bsp size
	Local boxP0:Float[3] 
	Local boxP1:Float[3] 
	Local matrix:Float[16] 
	NewtonBodyGetMatrix g_newtonmapbody,Varptr matrix[0]
	NewtonCollisionCalculateAABB g_newtonmap,Varptr matrix[0],Varptr boxP0[0],Varptr boxP1[0]
	'pad the box
	boxP0[0]:-10
	boxP1[0]:+10
	boxP0[1]:-10
	boxP1[1]:+10
	boxP0[2]:-10
	boxP1[2]:+10
	NewtonSetWorldSize nWorld,Varptr boxP0[0],Varptr boxP1[0]
Rem
After loading the map, we can calculate the bounding box surrounding it And set the newton world size To
match. Newton should automatically disable anything which falls out of the map this way.
End Rem
	Return g_newtonmapbody
End Function</textarea><br><br>This one Returns the Body.  It still doesn't work, but at least it doesn't crash.  Still don't know why... <br><br></td></tr></table><br>
<a name="751543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could someone give me a hand with this? <br><br></td></tr></table><br>
<a name="751744"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> greetings :)  i will try to take a look at this this evening. <br><br></td></tr></table><br>
<a name="751814"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >René</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi there. Do you have any working links to a Newton wrapper for BMax? <br><br></td></tr></table><br>
<a name="751829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's quite a minimal wrapper actually.  It's why I like it.  Gets the job done without a lot of extra bullshit.  I'll just post it.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Module Pub.Newton
Import Pub.Win32
Extern
	Function FreeLibrary(hlib)="FreeLibrary@4"
End Extern

'================================================
' World Functions
'================================================
Global NewtonCreate:Byte Ptr( mallocFnt: Byte Ptr, mfreeFnt:Byte Ptr)
Global NewtonDestroy(nWorld: Byte Ptr)
Global NewtonUpdate(newtonWorld: Byte Ptr, time:Float)
Global NewtonDestroyAllBodies(newtonWorld: Byte Ptr)
Global NewtonSetSolverModel(newtonWorld:Byte Ptr, model:Int)
Global NewtonSetFrictionModel(newtonWorld:Byte Ptr, model:Int)
Global NewtonGetTimeStep:Float(newtonWorld:Byte Ptr)
Global NewtonSetMinimumFrameRate(newtonWorld:Byte Ptr, frameRate:Float)
Global NewtonSetBodyLeaveWorldEvent(newtonWorld:Byte Ptr, BodyLeaveWorld_callback:Byte Ptr)
Global NewtonSetWorldSize(newtonWorld: Byte Ptr, minPoint: Byte Ptr, maxPoint:Byte Ptr)
Global NewtonWorldFreezeBody(newtonWorld:Byte Ptr, body:Byte Ptr)
Global NewtonWorldUnFreezeBody(newtonWorld: Byte Ptr, body:Byte Ptr)
Global NewtonWorldForEachBodyDo(newtonWorld:Byte Ptr, BodyIterator_callback:Byte Ptr)
Global NewtonWorldSetUserData(newtonWorld:Byte Ptr, userData:Byte Ptr)
Global NewtonWorldGetUserData:Byte Ptr(newtonWorld:Byte Ptr)
Global NewtonWorldGetVersion:Int(newtonWorld:Byte Ptr)
Global NewtonWorldRayCast(newtonWorld:Byte Ptr, p0:Byte Ptr, p1:Byte Ptr, WorldRayFilterCallback:Byte Ptr, userData:Byte Ptr)
Global NewtonWorldCollide:Int(newtonWorld:Byte Ptr, maxSize:Int,collsionA:Byte Ptr, matrixA:Byte Ptr, collsionB:Byte Ptr, matrixB:Byte Ptr, contacts:Byte Ptr, normals:Byte Ptr, penetration:Byte Ptr)
Global NewtonMaterialGetDefaultGroupID:Int(newtonWorld:Byte Ptr)
Global NewtonMaterialCreateGroupID:Int(newtonWorld:Byte Ptr)
Global NewtonMaterialDestroyAllGroupID(newtonWorld:Byte Ptr)
Global NewtonMaterialSetDefaultSoftness(newtonWorld:Byte Ptr, id0:Int, id1:Int, value:Float)
Global NewtonMaterialSetDefaultElasticity(newtonWorld:Byte Ptr, id0:Int, id1:Int, elasticCoef:Float)
Global NewtonMaterialSetDefaultCollidable(newtonWorld:Byte Ptr, id0:Int, id1:Int, state:Int)
Global NewtonMaterialSetDefaultFriction(newtonWorld:Byte Ptr, id0:Int, id1:Int, staticFriction:Float, kineticFriction:Float)
Global NewtonMaterialSetCollisionCallback(newtonWorld:Byte Ptr, id0:Int, id1:Int, userData:Byte Ptr, begin:Byte Ptr, process:Byte Ptr, NEnd:Byte Ptr)
Global NewtonMaterialGetUserData:Byte Ptr(newtonWorld:Byte Ptr, id0:Int, id1:Int)
Global NewtonMaterialDisableContact (material:Byte Ptr)
Global NewtonMaterialGetCurrentTimestep:Float(material:Byte Ptr)
Global NewtonMaterialGetMaterialPairUserData:Byte Ptr(material:Byte Ptr)
Global NewtonMaterialGetContactFaceAttribute:Int(material: Byte Ptr)
Global NewtonMaterialGetBodyCollisionID:Int(material: Byte Ptr, body:Byte Ptr)
Global NewtonMaterialGetContactNormalSpeed:Float(material:Byte Ptr, contactlHandle:Byte Ptr)
Global NewtonMaterialGetContactForce(material: Byte Ptr, force:Byte Ptr)
Global NewtonMaterialGetContactPositionAndNormal(material:Byte Ptr, posit:Byte Ptr, normal:Byte Ptr)
Global NewtonMaterialGetContactTangentDirections(material:Byte Ptr, dir0:Byte Ptr, dir:Byte Ptr)
Global NewtonMaterialGetContactTangentSpeed:Float(material:Byte Ptr, NewtonContact:Byte Ptr, index:Int)

Global NewtonSetPlatformArchitecture(world:Byte Ptr,mode:Int)

Global NewtonMaterialSetContactSoftness(NewtonMaterial:Byte Ptr, softness:Float)
Global NewtonMaterialSetContactElasticity(NewtonMaterial:Byte Ptr, restitution:Float)
Global NewtonMaterialSetContactFrictionState(NewtonMaterial:Byte Ptr, state:Int, index:Int)
Global NewtonMaterialSetContactStaticFrictionCoef(NewtonMaterial:Byte Ptr, coef:Float, index:Int)
Global NewtonMaterialSetContactKineticFrictionCoef(NewtonMaterial:Byte Ptr, coef:Float, index:Int)
Global NewtonMaterialSetContactTangentAcceleration(NewtonMaterial:Byte Ptr, accel:Float, index:Int)

Global NewtonMaterialContactRotateTangentDirections(NewtonMaterial:Byte Ptr, directionVector:Byte Ptr)

'================================================
' convex collision primitives creation functions
'================================================
Global NewtonCreateNull:Byte Ptr(newtonWorld:Byte Ptr)	'NewtonCollision
Global NewtonCreateSphere:Byte Ptr(newtonWorld:Byte Ptr, radiusX:Float, radiusY:Float, radiusZ:Float, offsetMatrix:Byte Ptr)
Global NewtonCreateBox:Byte Ptr(newtonWorld:Byte Ptr, dx:Float, dy:Float, dz:Float, offsetMatrix:Byte Ptr)
Global NewtonCreateCone:Byte Ptr(newtonWorld:Byte Ptr, radius:Float, height:Float, offsetMatrix:Byte Ptr)
Global NewtonCreateCapsule:Byte Ptr(newtonWorld:Byte Ptr, radius:Float, height:Float, offsetMatrix:Byte Ptr)
Global NewtonCreateCylinder:Byte Ptr(newtonWorld:Byte Ptr, radius:Float, height:Float, offsetMatrix:Byte Ptr)
Global NewtonCreateChamferCylinder:Byte Ptr(newtonWorld:Byte Ptr, radius:Float, height:Float, offsetMatrix:Byte Ptr)
Global NewtonCreateConvexHull:Byte Ptr(newtonWorld:Byte Ptr, count:Int, vertexCloud:Byte Ptr, strideInBytes:Int, offsetMatrix:Byte Ptr)
Global NewtonCreateConvexHullModifier:Byte Ptr(newtonWorld:Byte Ptr, convexHullCollision:Byte Ptr)
Global NewtonConvexHullModifierGetMatrix(convexHullCollision:Byte Ptr, matrix:Byte Ptr)
Global NewtonConvexHullModifierSetMatrix(convexHullCollision:Byte Ptr, matrix:Byte Ptr)
	
Global NewtonConvexCollisionSetUserID(convexCollision:Byte Ptr, id:Int)
Global NewtonConvexCollisionGetUserID:Int(convexCollision:Byte Ptr)

'================================================
'complex collision primitives creation functions
'================================================
Global NewtonCreateCompoundCollision:Byte Ptr(newtonWorld:Byte Ptr, count:Int, collisionPrimitiveArray:Byte Ptr[])
Global NewtonCreateUserMeshCollision:Byte Ptr(newtonWorld:Byte Ptr, minBox:Byte Ptr, maxBox:Byte Ptr, userData:Byte Ptr, collideCallback:Byte Ptr, rayHitCallback:Byte Ptr, destroyCallback:Byte Ptr)

'================================================
' CollisionTree Utility functions
'================================================
Global NewtonCreateTreeCollision:Byte Ptr(newtonWorld:Byte Ptr, userCallback:Byte Ptr)
Global NewtonTreeCollisionBeginBuild(NewtonCollision: Byte Ptr)
Global NewtonTreeCollisionAddFace(NewtonCollision: Byte Ptr, vertexCount:Int, vertexPtr: Byte Ptr, strideInBytes:Int, faceAttribute:Int)
Global NewtonTreeCollisionEndBuild(NewtonCollision: Byte Ptr, optimize:Int)
'	NEWTON_API void NewtonTreeCollisionSerialize (Const NewtonCollision* treeCollision, NewtonSerialize serializeFunction, 
'		void* serializeHandle);
Global NewtonCreateTreeCollisionFromSerialization:Byte Ptr(newtonWorld:Byte Ptr, userCallback:Byte Ptr,deserializeFunction:Byte Ptr, serializeHandle:Byte Ptr)
Global NewtonTreeCollisionGetFaceAtribute:Int(NewtonCollision:Byte Ptr, faceIndexArray:Byte Ptr) 
Global NewtonTreeCollisionSetFaceAtribute(NewtonCollision: Byte Ptr, faceIndexArray: Byte Ptr, attribute:Int) 

'================================================
' Collision Miscelaneos Function
'================================================
Global NewtonReleaseCollision(newtonWorld:Byte Ptr, NewtonCollision:Byte Ptr)
Global NewtonCollisionCalculateAABB(NewtonCollision:Byte Ptr, matrix:Byte Ptr, p0:Byte Ptr, p1:Byte Ptr)
Global NewtonCollisionRayCast:Float(NewtonCollision:Byte Ptr, p0:Byte Ptr, p1:Byte Ptr, normals:Byte Ptr, attribute:Byte Ptr)

'================================================
' transforms utility functions
'================================================
Global NewtonGetEulerAngle(matrix:Byte Ptr, eulersAngles:Byte Ptr)
Global NewtonSetEulerAngle(eulersAngles:Byte Ptr, matrix:Byte Ptr)

'================================================
' body manipulation functions
'================================================
Global NewtonCreateBody:Byte Ptr(newtonWorld:Byte Ptr, NewtonCollision:Byte Ptr)
Global NewtonDestroyBody(newtonWorld:Byte Ptr, body:Byte Ptr)

Global NewtonBodyAddForce(body:Byte Ptr, force:Byte Ptr)
Global NewtonBodyAddTorque(body:Byte Ptr, torque:Byte Ptr)

Global NewtonBodySetMatrix(body:Byte Ptr, matrix:Byte Ptr)
Global NewtonBodySetMatrixRecursive(body:Byte Ptr, matrix:Byte Ptr)
Global NewtonBodySetMassMatrix(body:Byte Ptr, mass:Float, Ixx:Float, Iyy:Float, Izz:Float)
Global NewtonBodySetMaterialGroupID(body:Byte Ptr, id:Int)
Global NewtonBodySetContinuousCollisionMode(body:Byte Ptr, state:Int)
Global NewtonBodySetJointRecursiveCollision(body:Byte Ptr, state:Int)
Global NewtonBodySetOmega(body:Byte Ptr, omega:Byte Ptr)
Global NewtonBodySetVelocity(body:Byte Ptr, velocity:Byte Ptr)
Global NewtonBodySetForce (body:Byte Ptr, force:Byte Ptr)
Global NewtonBodySetTorque(body:Byte Ptr, torque:Byte Ptr)
Global NewtonBodySetLinearDamping(body:Byte Ptr, linearDamp:Float)
Global NewtonBodySetAngularDamping(body:Byte Ptr, angularDamp:Byte Ptr)
Global NewtonBodySetUserData(body:Byte Ptr, userData:Byte Ptr)
Global NewtonBodyCoriolisForcesMode(body:Byte Ptr, mode:Int)
Global NewtonBodySetCollision(body:Byte Ptr, collision:Byte Ptr)
Global NewtonBodySetAutoFreeze(body:Byte Ptr, state:Int)
Global NewtonBodySetFreezeTreshold(body:Byte Ptr, freezeSpeed2:Float, freezeOmega2:Float, framesCount:Int)
	
Global NewtonBodySetTransformCallback(body:Byte Ptr, SetTransform_callback:Byte Ptr)
Global NewtonBodySetDestructorCallback(body:Byte Ptr, BodyDest_callback:Byte Ptr)
Global NewtonBodySetAutoactiveCallback(body:Byte Ptr, BodyActState_callback:Byte Ptr)
Global NewtonBodySetForceAndTorqueCallback(body:Byte Ptr, ApplyForceTorque_callback:Byte Ptr)

Global NewtonBodyGetWorld:Byte Ptr(body:Byte Ptr)
Global NewtonBodyGetUserData:Byte Ptr(body:Byte Ptr)
Global NewtonBodyGetCollision:Byte Ptr(body:Byte Ptr)
Global NewtonBodyGetMaterialGroupID:Int(body:Byte Ptr)
Global NewtonBodyGetContinuousCollisionMode:Int(body:Byte Ptr)
Global NewtonBodyGetJointRecursiveCollision:Int(body:Byte Ptr)
Global NewtonBodyGetMatrix(body:Byte Ptr, matrix:Byte Ptr)
Global NewtonBodyGetMassMatrix(body:Byte Ptr, mass:Byte Ptr, Ixx:Byte Ptr, Iyy:Byte Ptr, Izz:Byte Ptr)
Global NewtonBodyGetInvMass(body:Byte Ptr, invMass:Byte Ptr, invIxx:Byte Ptr, invIyy:Byte Ptr, invIzz:Byte Ptr)
Global NewtonBodyGetOmega(body:Byte Ptr, vector:Byte Ptr)
Global NewtonBodyGetVelocity(body:Byte Ptr, vector:Byte Ptr)
Global NewtonBodyGetForce(body:Byte Ptr, vector:Byte Ptr)
Global NewtonBodyGetTorque(body:Byte Ptr, vector:Byte Ptr)
	
Global NewtonBodyGetSleepingState:Int(body:Byte Ptr)
Global NewtonBodyGetAutoFreeze:Int(body:Byte Ptr)
Global NewtonBodyGetLinearDamping:Float(body:Byte Ptr)
Global NewtonBodyGetAngularDamping (body:Byte Ptr, vector:Byte Ptr)
Global NewtonBodyGetAABB (body:Byte Ptr, p0:Byte Ptr, p1:Byte Ptr)	
Global NewtonBodyGetFreezeTreshold(body:Byte Ptr, freezeSpeed2:Byte Ptr, freezeOmega2:Byte Ptr)
Global NewtonBodyGetTotalVolume:Float(body:Byte Ptr)
Global NewtonBodyAddBuoyancyForce(body:Byte Ptr, fluidDensity:Float, fluidLinearViscosity:Float, fluidAngularViscosity:Float,gravityVector:Byte Ptr, buoyancyPlane:Byte Ptr, context:Byte Ptr)

Global NewtonBodyForEachPolygonDo (body:Byte Ptr, CollisionIterator_callback:Byte Ptr)
Global NewtonAddBodyImpulse(body:Byte Ptr, pointDeltaVeloc:Byte Ptr, pointPosit:Byte Ptr)

'================================================
' Common joint funtions
'================================================
Global NewtonJointGetUserData:Byte Ptr(joint:Byte Ptr)
Global NewtonJointSetUserData(joint:Byte Ptr, userData:Byte Ptr)

Global NewtonJointGetCollisionState:Int(joint:Byte Ptr)
Global NewtonJointSetCollisionState(joint:Byte Ptr, state:Int)

Global NewtonJointGetStiffness:Float(joint:Byte Ptr)
Global NewtonJointSetStiffness(joint:Byte Ptr, state:Float)

Global NewtonDestroyJoint(newtonWorld:Byte Ptr, joint:Byte Ptr)
Global NewtonJointSetDestructor(joint:Byte Ptr, destructor:Byte Ptr)

'================================================
' Ball And Socket joint functions
'================================================
Global NewtonConstraintCreateBall:Byte Ptr(newtonWorld:Byte Ptr, pivotPoint:Byte Ptr, childBody:Byte Ptr, parentBody:Byte Ptr)
Global NewtonBallSetUserCallback(ball:Byte Ptr, BallCallBack_callback:Byte Ptr)
Global NewtonBallGetJointAngle (ball:Byte Ptr, angle:Byte Ptr)
Global NewtonBallGetJointOmega (ball:Byte Ptr, omega:Byte Ptr)
Global NewtonBallGetJointForce (ball:Byte Ptr, force:Byte Ptr)
Global NewtonBallSetConeLimits (ball:Byte Ptr, pin:Byte Ptr, maxConeAngle:Float, maxTwistAngle:Float)

'================================================
' Hinge joint functions
'================================================
Global NewtonConstraintCreateHinge:Byte Ptr(newtonWorld:Byte Ptr, pivotPoint:Byte Ptr, pinDir:Byte Ptr, childBody:Byte Ptr, parentBody:Byte Ptr)

Global NewtonHingeSetUserCallback(hinge:Byte Ptr, HingeCallBack_callback:Byte Ptr)
Global NewtonHingeGetJointAngle:Float(hinge:Byte Ptr)
Global NewtonHingeGetJointOmega:Float(hinge:Byte Ptr)
Global NewtonHingeGetJointForce(hinge:Byte Ptr,  force:Byte Ptr)
Global NewtonHingeCalculateStopAlpha:Float(hinge:Byte Ptr, desc:Byte Ptr, angle:Float)


'================================================
' Slider joint functions
'================================================
Global NewtonConstraintCreateSlider:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Byte Ptr, pinDir:Byte Ptr, childBody:Byte Ptr, parentBody:Byte Ptr)
Global NewtonSliderSetUserCallback(slider:Byte Ptr, SliderCallBack_callback:Byte Ptr)
Global NewtonSliderGetJointPosit:Float(slider:Byte Ptr)
Global NewtonSliderGetJointVeloc:Float(slider:Byte Ptr)
Global NewtonSliderGetJointForce (slider:Byte Ptr,  force:Byte Ptr)
Global NewtonSliderCalculateStopAccel:Float(slider:Byte Ptr, desc:Byte Ptr, position:Float)


'================================================
' Corkscrew joint functions
'================================================
Global NewtonConstraintCreateCorkscrew:Byte Ptr(newtonWorld:Byte Ptr,pivotPoint:Byte Ptr, pinDir:Byte Ptr, childBody:Byte Ptr, parentBody:Byte Ptr)
Global NewtonCorkscrewSetUserCallback(corkscrew:Byte Ptr, CorkscrewCallBack_callback:Byte Ptr)
Global NewtonCorkscrewGetJointPosit:Float (corkscrew:Byte Ptr)
Global NewtonCorkscrewGetJointAngle:Float( corkscrew:Byte Ptr)
Global NewtonCorkscrewGetJointVeloc:Float(corkscrew:Byte Ptr)
Global NewtonCorkscrewGetJointOmega:Float( corkscrew:Byte Ptr)
Global NewtonCorkscrewGetJointForce(corkscrew:Byte Ptr, force:Byte Ptr)
Global NewtonCorkscrewCalculateStopAlpha:Float(corkscrew:Byte Ptr, desc:Byte Ptr, angle:Float)
Global NewtonCorkscrewCalculateStopAccel:Float(corkscrew:Byte Ptr, desc:Byte Ptr, position:Float)


'================================================
' Universal joint functions
'================================================
Global NewtonConstraintCreateUniversal:Byte Ptr(newtonWorld:Byte Ptr, pivotPoint:Byte Ptr, pinDir0:Byte Ptr, pinDir1:Byte Ptr, childBody:Byte Ptr, parentBody:Byte Ptr)
Global NewtonUniversalSetUserCallback(universal:Byte Ptr, UniversalCallBack_callback:Byte Ptr)
Global NewtonUniversalGetJointAngle0:Float( universal:Byte Ptr)
Global NewtonUniversalGetJointAngle1:Float(universal:Byte Ptr)
Global NewtonUniversalGetJointOmega0:Float( universal:Byte Ptr)
Global NewtonUniversalGetJointOmega1:Float (universal:Byte Ptr)
Global NewtonUniversalGetJointForce(universal:Byte Ptr, force:Byte Ptr)
Global NewtonUniversalCalculateStopAlpha0:Float(universal:Byte Ptr, desc:Byte Ptr, angle:Float)
Global NewtonUniversalCalculateStopAlpha1:Float(universal:Byte Ptr, desc:Byte Ptr, angle:Float)


'================================================
'Up vector joint functions
'================================================
Global NewtonConstraintCreateUpVector:Byte Ptr(newtonWorld:Byte Ptr, pinDir:Byte Ptr, body:Byte Ptr) 
Global NewtonUpVectorGetPin(upVector:Byte Ptr, pin:Byte Ptr)
Global NewtonUpVectorSetPin(upVector:Byte Ptr, pin:Byte Ptr)


'================================================
' User defined bilateral Joint
'================================================
Global NewtonConstraintCreateUserJoint:Byte Ptr(newtonWorld:Byte Ptr, maxDOF:Int, UserBilateralCallBack_callback:Byte Ptr, childBody:Byte Ptr, parentBody:Byte Ptr) 
Global NewtonUserJointAddLinearRow(joint:Byte Ptr, pivot0:Byte Ptr, pivot1:Byte Ptr, dir:Byte Ptr)
Global NewtonUserJointAddAngularRow(joint:Byte Ptr, relativeAngle:Float, dir:Byte Ptr)
Global NewtonUserJointSetRowMinimunFriction(joint:Byte Ptr,  friction:Float)
Global NewtonUserJointSetRowMaximunFriction( joint:Float, friction:Float)
Global NewtonUserJointSetRowAcceleration(joint:Byte Ptr,  acceleration:Float)
Global NewtonUserJointSetRowStiffness( joint:Float,stiffness:Float)
Global NewtonUserJointGetRowForce:Float(joint:Byte Ptr, row:Int)


'================================================
' Ragdoll joint contatiner funtion
'================================================
Global NewtonCreateRagDoll:Byte Ptr(newtonWorld:Byte Ptr)
Global NewtonDestroyRagDoll(newtonWorld:Byte Ptr, ragDoll:Byte Ptr)

Global NewtonRagDollBegin( ragDoll:Byte Ptr)
Global NewtonRagDollEnd( ragDoll:Byte Ptr)


Global NewtonRagDollFindBone:Byte Ptr( ragDoll:Byte Ptr, id:Int)
Global NewtonRagDollGetRootBone:Byte Ptr( ragDoll:Byte Ptr)

Global NewtonRagDollSetForceAndTorqueCallback( ragDoll:Byte Ptr, ApplyForceAndTorque_callback:Byte Ptr)
Global NewtonRagDollSetTransformCallback(ragDoll:Byte Ptr, SetRagDollTransform_callback:Byte Ptr)
Global NewtonRagDollAddBone:Byte Ptr(ragDoll:Byte Ptr, parent:Byte Ptr, userData:Byte Ptr, mass:Float, matrix:Byte Ptr, boneCollision:Byte Ptr, size:Byte Ptr)

Global NewtonRagDollBoneGetUserData:Byte Ptr( bone:Byte Ptr)
Global NewtonRagDollBoneGetBody:Byte Ptr( bone:Byte Ptr)
Global NewtonRagDollBoneSetID(bone:Byte Ptr, id:Int)


Global NewtonRagDollBoneSetLimits(bone:Byte Ptr, coneDir:Byte Ptr, minConeAngle:Float, maxConeAngle:Float, maxTwistAngle:Float, bilateralConeDir:Byte Ptr, negativeBilateralConeAngle:Float, positiveBilateralConeAngle:Float)
	

Global NewtonRagDollBoneGetLocalMatrix(bone:Byte Ptr,  matrix:Byte Ptr)
Global NewtonRagDollBoneGetGlobalMatrix( bone:Byte Ptr,  matrix:Byte Ptr)


'================================================
' Vehicle joint functions
'================================================
Global NewtonConstraintCreateVehicle:Byte Ptr(newtonWorld:Byte Ptr, upDir:Byte Ptr, body:Byte Ptr) 
Global NewtonVehicleReset(vehicle:Byte Ptr) 
Global NewtonVehicleSetTireCallback(vehicle:Byte Ptr, update:Byte Ptr)
Global NewtonVehicleAddTire:Int(vehicle:Byte Ptr, localMatrix:Byte Ptr, pin:Byte Ptr, mass:Float, width:Float, radius:Float, suspesionShock:Float, suspesionSpring:Float, suspesionLength:Float, userData:Byte Ptr, collisionID:Int)
Global NewtonVehicleRemoveTire(vehicle:Byte Ptr, tireIndex:Int)
Global NewtonVehicleBalanceTires(vehicle:Byte Ptr, gravityMag:Float)

Global NewtonVehicleGetFirstTireID:Int(vehicle:Byte Ptr)
Global NewtonVehicleGetNextTireID:Int(vehicle:Byte Ptr, tireId:Int)

Global NewtonVehicleTireIsAirBorne:Int (vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleTireLostSideGrip:Int(vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleTireLostTraction:Int(vehicle:Byte Ptr, tireId:Int)

Global NewtonVehicleGetTireUserData:Byte Ptr(vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleGetTireOmega:Float(vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleGetTireNormalLoad:Float(vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleGetTireSteerAngle:Float (vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleGetTireLateralSpeed:Float(vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleGetTireLongitudinalSpeed:Float(vehicle:Byte Ptr, tireId:Int)
Global hicleGetTireMatrix(vehicle:Byte Ptr, tireId:Int , matrix:Byte Ptr)


Global NewtonVehicleSetTireTorque(vehicle:Byte Ptr, tireId:Int, torque:Float)
Global NewtonVehicleSetTireSteerAngle(vehicle:Byte Ptr, tireId:Int,  angle:Float)
	
Global NewtonVehicleSetTireMaxSideSleepSpeed(vehicle:Byte Ptr, tireId:Int, speed:Float)
Global NewtonVehicleSetTireSideSleepCoeficient(vehicle:Byte Ptr, tireId:Int,  coeficient:Float)
Global NewtonVehicleSetTireMaxLongitudinalSlideSpeed(vehicle:Byte Ptr, tireId:Int, speed:Float)
Global NewtonVehicleSetTireLongitudinalSlideCoeficient(vehicle:Byte Ptr, tireId:Int, coeficient:Float)

Global NewtonVehicleTireCalculateMaxBrakeAcceleration:Float(vehicle:Byte Ptr, tireId:Int)
Global NewtonVehicleTireSetBrakeAcceleration(vehicle:Byte Ptr, tireId:Int,  accelaration:Float, torqueLimit:Float)

Global phBodyGetPitch:Float(body:Int)
Global phBodyGetYaw:Float(body:Int)
Global phBodyGetRoll:Float(body:Int)


Global HLIB_NEWTON

Function StartNewton()
	If HLIB_NEWTON Return True
	HLIB_NEWTON=LoadLibraryA("bin\Newton.dll")
	If Not HLIB_NEWTON HLIB_NEWTON=LoadLibraryA("dlls\Newton.dll")
	If Not HLIB_NEWTON HLIB_NEWTON=LoadLibraryA("Newton.dll")
	If Not HLIB_NEWTON Return

	'Retrieve function pointers
	NewtonSetPlatformArchitecture=getprocaddress(HLIB_NEWTON,"NewtonSetPlatformArchitecture")
	NewtonCreate=GetProcAddress(HLIB_NEWTON,"NewtonCreate")
	NewtonDestroy=GetProcAddress(HLIB_NEWTON,"NewtonDestroy")
	NewtonUpdate=GetProcAddress(HLIB_NEWTON,"NewtonUpdate")
	NewtonDestroyAllBodies=GetProcAddress(HLIB_NEWTON,"NewtonDestroyAllBodies")
	NewtonSetSolverModel=GetProcAddress(HLIB_NEWTON,"NewtonSetSolverModel")
	NewtonSetFrictionModel=GetProcAddress(HLIB_NEWTON,"NewtonSetFrictionModel")
	NewtonGetTimeStep=GetProcAddress(HLIB_NEWTON,"NewtonGetTimeStep")
	NewtonSetMinimumFrameRate=GetProcAddress(HLIB_NEWTON,"NewtonSetMinimumFrameRate")
	NewtonSetBodyLeaveWorldEvent=GetProcAddress(HLIB_NEWTON,"NewtonSetBodyLeaveWorldEvent")
	NewtonSetWorldSize=GetProcAddress(HLIB_NEWTON,"NewtonSetWorldSize")
	NewtonWorldFreezeBody=GetProcAddress(HLIB_NEWTON,"NewtonWorldFreezeBody")
	NewtonWorldUnFreezeBody=GetProcAddress(HLIB_NEWTON,"NewtonWorldUnfreezeBody")
	NewtonWorldForEachBodyDo=GetProcAddress(HLIB_NEWTON,"NewtonWorldForEachBodyDo")
	NewtonWorldSetUserData=GetProcAddress(HLIB_NEWTON,"NewtonWorldSetUserData")
	NewtonWorldGetUserData=GetProcAddress(HLIB_NEWTON,"NewtonWorldGetUserData")
	NewtonWorldGetVersion=GetProcAddress(HLIB_NEWTON,"NewtonWorldGetVersion")
	NewtonWorldRayCast=GetProcAddress(HLIB_NEWTON,"NewtonWorldRayCast")
	NewtonWorldCollide=GetProcAddress(HLIB_NEWTON,"NewtonWorldCollide")
	NewtonMaterialGetDefaultGroupID=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetDefaultGroupID")
	NewtonMaterialCreateGroupID=GetProcAddress(HLIB_NEWTON,"NewtonMaterialCreateGroupID")
	NewtonMaterialDestroyAllGroupID=GetProcAddress(HLIB_NEWTON,"NewtonMaterialDestroyAllGroupID")
	NewtonMaterialSetDefaultSoftness=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetDefaultSoftness")
	NewtonMaterialSetDefaultElasticity=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetDefaultElasticity")
	NewtonMaterialSetDefaultCollidable=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetDefaultCollidable")
	NewtonMaterialSetDefaultFriction=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetDefaultFriction")
	NewtonMaterialSetCollisionCallback=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetCollisionCallback")
	NewtonMaterialGetUserData=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetUserData")
	NewtonMaterialDisableContact=GetProcAddress(HLIB_NEWTON,"NewtonMaterialDisableContact")
	NewtonMaterialGetCurrentTimestep=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetCurrentTimestep")
	NewtonMaterialGetMaterialPairUserData=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetMaterialPairUserData")
	NewtonMaterialGetContactFaceAttribute=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetContactFaceAttribute")
	NewtonMaterialGetBodyCollisionID=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetBodyCollisionID")
	NewtonMaterialGetContactNormalSpeed=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetContactNormalSpeed")
	NewtonMaterialGetContactForce=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetContactForce")
	NewtonMaterialGetContactPositionAndNormal=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetContactPositionAndNormal")
	NewtonMaterialGetContactTangentDirections=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetContactTangentDirections")
	NewtonMaterialGetContactTangentSpeed=GetProcAddress(HLIB_NEWTON,"NewtonMaterialGetContactTangentSpeed")
	NewtonMaterialSetContactSoftness=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetContactSoftness")
	NewtonMaterialSetContactElasticity=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetContactElasticity")
	NewtonMaterialSetContactFrictionState=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetContactFrictionState")
	NewtonMaterialSetContactStaticFrictionCoef=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetContactStaticFrictionCoef")
	NewtonMaterialSetContactKineticFrictionCoef=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetContactKineticFrictionCoef")
	NewtonMaterialSetContactTangentAcceleration=GetProcAddress(HLIB_NEWTON,"NewtonMaterialSetContactTangentAcceleration")
	NewtonMaterialContactRotateTangentDirections=GetProcAddress(HLIB_NEWTON,"NewtonMaterialContactRotateTangentDirections")
	NewtonCreateNull=GetProcAddress(HLIB_NEWTON,"NewtonCreateNull")
	NewtonCreateSphere=GetProcAddress(HLIB_NEWTON,"NewtonCreateSphere")
	NewtonCreateBox=GetProcAddress(HLIB_NEWTON,"NewtonCreateBox")
	NewtonCreateCone=GetProcAddress(HLIB_NEWTON,"NewtonCreateCone")
	NewtonCreateCapsule=GetProcAddress(HLIB_NEWTON,"NewtonCreateCapsule")
	NewtonCreateCylinder=GetProcAddress(HLIB_NEWTON,"NewtonCreateCylinder")
	NewtonCreateChamferCylinder=GetProcAddress(HLIB_NEWTON,"NewtonCreateChamferCylinder")
	NewtonCreateConvexHull=GetProcAddress(HLIB_NEWTON,"NewtonCreateConvexHull")
	NewtonCreateConvexHullModifier=GetProcAddress(HLIB_NEWTON,"NewtonCreateConvexHullModifier")
	NewtonConvexHullModifierGetMatrix=GetProcAddress(HLIB_NEWTON,"NewtonConvexHullModifierGetMatrix")
	NewtonConvexHullModifierSetMatrix=GetProcAddress(HLIB_NEWTON,"NewtonConvexHullModifierSetMatrix")
	NewtonConvexCollisionSetUserID=GetProcAddress(HLIB_NEWTON,"NewtonConvexCollisionSetUserID")
	NewtonConvexCollisionGetUserID=GetProcAddress(HLIB_NEWTON,"NewtonConvexCollisionGetUserID")
	NewtonCreateCompoundCollision=GetProcAddress(HLIB_NEWTON,"NewtonCreateCompoundCollision")
	NewtonCreateUserMeshCollision=GetProcAddress(HLIB_NEWTON,"NewtonCreateUserMeshCollision")
	NewtonCreateTreeCollision=GetProcAddress(HLIB_NEWTON,"NewtonCreateTreeCollision")
	NewtonTreeCollisionBeginBuild=GetProcAddress(HLIB_NEWTON,"NewtonTreeCollisionBeginBuild")
	NewtonTreeCollisionAddFace=GetProcAddress(HLIB_NEWTON,"NewtonTreeCollisionAddFace")
	NewtonTreeCollisionEndBuild=GetProcAddress(HLIB_NEWTON,"NewtonTreeCollisionEndBuild")
	NewtonCreateTreeCollisionFromSerialization=GetProcAddress(HLIB_NEWTON,"NewtonCreateTreeCollisionFromSerialization")
	NewtonTreeCollisionGetFaceAtribute=GetProcAddress(HLIB_NEWTON,"NewtonTreeCollisionGetFaceAtribute")
	NewtonTreeCollisionSetFaceAtribute=GetProcAddress(HLIB_NEWTON,"NewtonTreeCollisionSetFaceAtribute")
	NewtonReleaseCollision=GetProcAddress(HLIB_NEWTON,"NewtonReleaseCollision")
	NewtonCollisionCalculateAABB=GetProcAddress(HLIB_NEWTON,"NewtonCollisionCalculateAABB")
	NewtonCollisionRayCast=GetProcAddress(HLIB_NEWTON,"NewtonCollisionRayCast")
	NewtonGetEulerAngle=GetProcAddress(HLIB_NEWTON,"NewtonGetEulerAngle")
	NewtonSetEulerAngle=GetProcAddress(HLIB_NEWTON,"NewtonSetEulerAngle")
	NewtonCreateBody=GetProcAddress(HLIB_NEWTON,"NewtonCreateBody")
	NewtonDestroyBody=GetProcAddress(HLIB_NEWTON,"NewtonDestroyBody")
	NewtonBodyAddForce=GetProcAddress(HLIB_NEWTON,"NewtonBodyAddForce")
	NewtonBodyAddTorque=GetProcAddress(HLIB_NEWTON,"NewtonBodyAddTorque")
	NewtonBodySetMatrix=GetProcAddress(HLIB_NEWTON,"NewtonBodySetMatrix")
	NewtonBodySetMatrixRecursive=GetProcAddress(HLIB_NEWTON,"NewtonBodySetMatrixRecursive")
	NewtonBodySetMassMatrix=GetProcAddress(HLIB_NEWTON,"NewtonBodySetMassMatrix")
	NewtonBodySetMaterialGroupID=GetProcAddress(HLIB_NEWTON,"NewtonBodySetMaterialGroupID")
	NewtonBodySetContinuousCollisionMode=GetProcAddress(HLIB_NEWTON,"NewtonBodySetContinuousCollisionMode")
	NewtonBodySetJointRecursiveCollision=GetProcAddress(HLIB_NEWTON,"NewtonBodySetJointRecursiveCollision")
	NewtonBodySetOmega=GetProcAddress(HLIB_NEWTON,"NewtonBodySetOmega")
	NewtonBodySetVelocity=GetProcAddress(HLIB_NEWTON,"NewtonBodySetVelocity")
	NewtonBodySetForce=GetProcAddress(HLIB_NEWTON,"NewtonBodySetForce")
	NewtonBodySetTorque=GetProcAddress(HLIB_NEWTON,"NewtonBodySetTorque")
	NewtonBodySetLinearDamping=GetProcAddress(HLIB_NEWTON,"NewtonBodySetLinearDamping")
	NewtonBodySetAngularDamping=GetProcAddress(HLIB_NEWTON,"NewtonBodySetAngularDamping")
	NewtonBodySetUserData=GetProcAddress(HLIB_NEWTON,"NewtonBodySetUserData")
	NewtonBodyCoriolisForcesMode=GetProcAddress(HLIB_NEWTON,"NewtonBodyCoriolisForcesMode")
	NewtonBodySetCollision=GetProcAddress(HLIB_NEWTON,"NewtonBodySetCollision")
	NewtonBodySetAutoFreeze=GetProcAddress(HLIB_NEWTON,"NewtonBodySetAutoFreeze")
	NewtonBodySetFreezeTreshold=GetProcAddress(HLIB_NEWTON,"NewtonBodySetFreezeTreshold")
	NewtonBodySetTransformCallback=GetProcAddress(HLIB_NEWTON,"NewtonBodySetTransformCallback")
	NewtonBodySetDestructorCallback=GetProcAddress(HLIB_NEWTON,"NewtonBodySetDestructorCallback")
	NewtonBodySetAutoactiveCallback=GetProcAddress(HLIB_NEWTON,"NewtonBodySetAutoactiveCallback")
	NewtonBodySetForceAndTorqueCallback=GetProcAddress(HLIB_NEWTON,"NewtonBodySetForceAndTorqueCallback")
	NewtonBodyGetWorld=GetProcAddress(HLIB_NEWTON,"	NewtonBodyGetWorld")
	NewtonBodyGetUserData=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetUserData")
	NewtonBodyGetCollision=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetCollision")
	NewtonBodyGetMaterialGroupID=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetMaterialGroupID")
	NewtonBodyGetContinuousCollisionMode=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetContinuousCollisionMode")
	NewtonBodyGetJointRecursiveCollision=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetJointRecursiveCollision")
	NewtonBodyGetMatrix=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetMatrix")
	NewtonBodyGetMassMatrix=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetMassMatrix")
	NewtonBodyGetInvMass=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetInvMass")
	NewtonBodyGetOmega=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetOmega")
	NewtonBodyGetVelocity=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetVelocity")
	NewtonBodyGetForce=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetForce")
	NewtonBodyGetTorque=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetTorque")
	NewtonBodyGetSleepingState=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetSleepingState")
	NewtonBodyGetAutoFreeze=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetAutoFreeze")
	NewtonBodyGetLinearDamping=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetLinearDamping")
	NewtonBodyGetAngularDamping=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetAngularDamping")
	NewtonBodyGetAABB=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetAABB")
	NewtonBodyGetFreezeTreshold=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetFreezeTreshold")
	NewtonBodyGetTotalVolume=GetProcAddress(HLIB_NEWTON,"NewtonBodyGetTotalVolume")
	NewtonBodyAddBuoyancyForce=GetProcAddress(HLIB_NEWTON,"NewtonBodyAddBuoyancyForce")
	NewtonBodyForEachPolygonDo=GetProcAddress(HLIB_NEWTON,"NewtonBodyForEachPolygonDo")
	NewtonAddBodyImpulse=GetProcAddress(HLIB_NEWTON,"NewtonAddBodyImpulse")
	NewtonJointGetUserData=GetProcAddress(HLIB_NEWTON,"NewtonJointGetUserData")
	NewtonJointSetUserData=GetProcAddress(HLIB_NEWTON,"NewtonJointSetUserData")
	NewtonJointGetCollisionState=GetProcAddress(HLIB_NEWTON,"NewtonJointGetCollisionState")
	NewtonJointSetCollisionState=GetProcAddress(HLIB_NEWTON,"NewtonJointSetCollisionState")
	NewtonJointGetStiffness=GetProcAddress(HLIB_NEWTON,"NewtonJointGetStiffness")
	NewtonJointSetStiffness=GetProcAddress(HLIB_NEWTON,"NewtonJointSetStiffness")
	NewtonDestroyJoint=GetProcAddress(HLIB_NEWTON,"NewtonDestroyJoint")
	NewtonJointSetDestructor=GetProcAddress(HLIB_NEWTON,"NewtonJointSetDestructor")
	NewtonConstraintCreateBall=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateBall")
	NewtonBallSetUserCallback=GetProcAddress(HLIB_NEWTON,"NewtonBallSetUserCallback")
	NewtonBallGetJointAngle=GetProcAddress(HLIB_NEWTON,"NewtonBallGetJointAngle")
	NewtonBallGetJointOmega=GetProcAddress(HLIB_NEWTON,"NewtonBallGetJointOmega")
	NewtonBallGetJointForce=GetProcAddress(HLIB_NEWTON,"NewtonBallGetJointForce")
	NewtonBallSetConeLimits=GetProcAddress(HLIB_NEWTON,"NewtonBallSetConeLimits")
	NewtonConstraintCreateHinge=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateHinge")
	NewtonHingeSetUserCallback=GetProcAddress(HLIB_NEWTON,"NewtonHingeSetUserCallback")
	NewtonHingeGetJointAngle=GetProcAddress(HLIB_NEWTON,"NewtonHingeGetJointAngle")
	NewtonHingeGetJointOmega=GetProcAddress(HLIB_NEWTON,"NewtonHingeGetJointOmega")
	NewtonHingeGetJointForce=GetProcAddress(HLIB_NEWTON,"NewtonHingeGetJointForce")
	NewtonHingeCalculateStopAlpha=GetProcAddress(HLIB_NEWTON,"NewtonHingeCalculateStopAlpha")
	NewtonConstraintCreateSlider=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateSlider")
	NewtonSliderSetUserCallback=GetProcAddress(HLIB_NEWTON,"NewtonSliderSetUserCallback")
	NewtonSliderGetJointPosit=GetProcAddress(HLIB_NEWTON,"NewtonSliderGetJointPosit")
	NewtonSliderGetJointVeloc=GetProcAddress(HLIB_NEWTON,"NewtonSliderGetJointVeloc")
	NewtonSliderGetJointForce=GetProcAddress(HLIB_NEWTON,"NewtonSliderGetJointForce")
	NewtonSliderCalculateStopAccel=GetProcAddress(HLIB_NEWTON,"NewtonSliderCalculateStopAccel")
	NewtonConstraintCreateCorkscrew=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateCorkscrew")
	NewtonCorkscrewSetUserCallback=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewSetUserCallback")
	NewtonCorkscrewGetJointPosit=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewGetJointPosit")
	NewtonCorkscrewGetJointAngle=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewGetJointAngle")
	NewtonCorkscrewGetJointVeloc=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewGetJointVeloc")
	NewtonCorkscrewGetJointOmega=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewGetJointOmega")
	NewtonCorkscrewGetJointForce=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewGetJointForce")
	NewtonCorkscrewCalculateStopAlpha=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewCalculateStopAlpha")
	NewtonCorkscrewCalculateStopAccel=GetProcAddress(HLIB_NEWTON,"NewtonCorkscrewCalculateStopAccel")
	NewtonConstraintCreateUniversal=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateUniversal")
	NewtonUniversalSetUserCallback=GetProcAddress(HLIB_NEWTON,"NewtonUniversalSetUserCallback")
	NewtonUniversalGetJointAngle0=GetProcAddress(HLIB_NEWTON,"NewtonUniversalGetJointAngle0")
	NewtonUniversalGetJointAngle1=GetProcAddress(HLIB_NEWTON,"NewtonUniversalGetJointAngle1")
	NewtonUniversalGetJointOmega0=GetProcAddress(HLIB_NEWTON,"NewtonUniversalGetJointOmega0")
	NewtonUniversalGetJointOmega1=GetProcAddress(HLIB_NEWTON,"NewtonUniversalGetJointOmega1")
	NewtonUniversalGetJointForce=GetProcAddress(HLIB_NEWTON,"NewtonUniversalGetJointForce")
	NewtonUniversalCalculateStopAlpha0=GetProcAddress(HLIB_NEWTON,"NewtonUniversalCalculateStopAlpha0")
	NewtonUniversalCalculateStopAlpha1=GetProcAddress(HLIB_NEWTON,"NewtonUniversalCalculateStopAlpha1")
	NewtonConstraintCreateUpVector=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateUpVector")
	NewtonUpVectorGetPin=GetProcAddress(HLIB_NEWTON,"NewtonUpVectorGetPin")
	NewtonUpVectorSetPin=GetProcAddress(HLIB_NEWTON,"NewtonUpVectorSetPin")
	NewtonConstraintCreateUserJoint=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateUserJoint")
	NewtonUserJointAddLinearRow=GetProcAddress(HLIB_NEWTON,"NewtonUserJointAddLinearRow")
	NewtonUserJointAddAngularRow=GetProcAddress(HLIB_NEWTON,"NewtonUserJointAddAngularRow")
	NewtonUserJointSetRowMinimunFriction=GetProcAddress(HLIB_NEWTON,"NewtonUserJointSetRowMinimunFriction")
	NewtonUserJointSetRowMaximunFriction=GetProcAddress(HLIB_NEWTON,"NewtonUserJointSetRowMaximunFriction")
	NewtonUserJointSetRowAcceleration=GetProcAddress(HLIB_NEWTON,"NewtonUserJointSetRowAcceleration")
	NewtonUserJointSetRowStiffness=GetProcAddress(HLIB_NEWTON,"NewtonUserJointSetRowStiffness")
	NewtonUserJointGetRowForce=GetProcAddress(HLIB_NEWTON,"NewtonUserJointGetRowForce")
	NewtonCreateRagDoll=GetProcAddress(HLIB_NEWTON,"NewtonCreateRagDoll")
	NewtonDestroyRagDoll=GetProcAddress(HLIB_NEWTON,"NewtonDestroyRagDoll")
	NewtonRagDollBegin=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBegin")
	NewtonRagDollEnd=GetProcAddress(HLIB_NEWTON,"NewtonRagDollEnd")
	NewtonRagDollFindBone=GetProcAddress(HLIB_NEWTON,"NewtonRagDollFindBone")
	NewtonRagDollGetRootBone=GetProcAddress(HLIB_NEWTON,"NewtonRagDollGetRootBone")
	NewtonRagDollSetForceAndTorqueCallback=GetProcAddress(HLIB_NEWTON,"NewtonRagDollSetForceAndTorqueCallback")
	NewtonRagDollSetTransformCallback=GetProcAddress(HLIB_NEWTON,"NewtonRagDollSetTransformCallback")
	NewtonRagDollAddBone=GetProcAddress(HLIB_NEWTON,"NewtonRagDollAddBone")
	NewtonRagDollBoneGetUserData=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBoneGetUserData")
	NewtonRagDollBoneGetBody=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBoneGetBody")
	NewtonRagDollBoneSetID=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBoneSetID")
	NewtonRagDollBoneSetLimits=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBoneSetLimits")
	NewtonRagDollBoneGetLocalMatrix=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBoneGetLocalMatrix")
	NewtonRagDollBoneGetGlobalMatrix=GetProcAddress(HLIB_NEWTON,"NewtonRagDollBoneGetGlobalMatrix")
	NewtonConstraintCreateVehicle=GetProcAddress(HLIB_NEWTON,"NewtonConstraintCreateVehicle")
	NewtonVehicleReset=GetProcAddress(HLIB_NEWTON,"NewtonVehicleReset")
	NewtonVehicleSetTireCallback=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireCallback")
	NewtonVehicleAddTire=GetProcAddress(HLIB_NEWTON,"NewtonVehicleAddTire")
	NewtonVehicleRemoveTire=GetProcAddress(HLIB_NEWTON,"NewtonVehicleRemoveTire")
	NewtonVehicleBalanceTires=GetProcAddress(HLIB_NEWTON,"NewtonVehicleBalanceTires")
	NewtonVehicleGetFirstTireID=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetFirstTireID")
	NewtonVehicleGetNextTireID=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetNextTireID")
	NewtonVehicleTireIsAirBorne=GetProcAddress(HLIB_NEWTON,"NewtonVehicleTireIsAirBorne")
	NewtonVehicleTireLostSideGrip=GetProcAddress(HLIB_NEWTON,"NewtonVehicleTireLostSideGrip")
	NewtonVehicleTireLostTraction=GetProcAddress(HLIB_NEWTON,"NewtonVehicleTireLostTraction")
	NewtonVehicleGetTireUserData=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetTireUserData")
	NewtonVehicleGetTireOmega=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetTireOmega")
	NewtonVehicleGetTireNormalLoad=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetTireNormalLoad")
	NewtonVehicleGetTireSteerAngle=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetTireSteerAngle")
	NewtonVehicleGetTireLateralSpeed=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetTireLateralSpeed")
	NewtonVehicleGetTireLongitudinalSpeed=GetProcAddress(HLIB_NEWTON,"NewtonVehicleGetTireLongitudinalSpeed")
	hicleGetTireMatrix=GetProcAddress(HLIB_NEWTON,"hicleGetTireMatrix")
	NewtonVehicleSetTireTorque=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireTorque")
	NewtonVehicleSetTireSteerAngle=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireSteerAngle")
	NewtonVehicleSetTireMaxSideSleepSpeed=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireMaxSideSleepSpeed")
	NewtonVehicleSetTireSideSleepCoeficient=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireSideSleepCoeficient")
	NewtonVehicleSetTireMaxLongitudinalSlideSpeed=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireMaxLongitudinalSlideSpeed")
	NewtonVehicleSetTireLongitudinalSlideCoeficient=GetProcAddress(HLIB_NEWTON,"NewtonVehicleSetTireLongitudinalSlideCoeficient")
	NewtonVehicleTireCalculateMaxBrakeAcceleration=GetProcAddress(HLIB_NEWTON,"NewtonVehicleTireCalculateMaxBrakeAcceleration")
	NewtonVehicleTireSetBrakeAcceleration=GetProcAddress(HLIB_NEWTON,"NewtonVehicleTireSetBrakeAcceleration")
	Return True
End Function

Function StopNewton()
	If HLIB_NEWTON
		'NewtonDestroy NP_WORLD
		'NP_WORLD=Null
		FreeLibrary HLIB_NEWTON
		HLIB_NEWTON=0
	End If
End Function</textarea><br><br>Just install as a module and you're ready to go!  I <i>think</i> it's by Leadwerks, but I could be mistaken. <br><br></td></tr></table><br>
<a name="751832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, hey, I forgot, you need the DLL/LIB. :P  You can find 'em at <a href="http://www.newtondynamics.com/" target="_blank">http://www.newtondynamics.com/</a> in the SDK download.  Glad to see someone else is showing an interest.  Have a good one. :) <br><br></td></tr></table><br>
<a name="751836"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> While I'm at it I'll just show you the module I'm working on; it gives what I showed you guys some context.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Rem
bbdoc: Irrlicht and Newton Integration Helper
End Rem
Module Pub.NewtonAndIrrlicht
ModuleInfo "Author: Bill Whitacre (ninjarat)"
ModuleInfo "History: Added functions used in Newton Examples and converted to Irrlicht graphics."

Import BRL.LinkedList
Import Pub.Newton
Import Irrlicht.Extended

Global nMemSize,nNodeDestroyList:TList=New TList
Global mat#[16]
Global omega#[3]

'Excellent Euler Matrix converter functions.  Not by me, and I would give credit where
'it was called for, except I honestly don't know who did this.
Function GetEulerMatrix(NSceneNode:ISceneNode,NewtonMat#[])
	Local Euler#[3]
	Euler[0]=NSceneNode.getRotation().getX()*(Pi/180#)
	Euler[1]=NSceneNode.getRotation().getY()*(Pi/180#)
	Euler[2]=NSceneNode.getRotation().getZ()*(Pi/180#)
	NewtonSetEulerAngle(Varptr Euler[0],Varptr NewtonMat[0])
	
	NewtonMat[12]=NSceneNode.getPosition().getX()
	NewtonMat[13]=NSceneNode.getPosition().getY()
	NewtonMat[14]=NSceneNode.getPosition().getZ()
End Function
Function SetEulerMatrix(NSceneNode:ISceneNode,NewtonMat#[])
	Local Euler#[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0],Varptr Euler[0])
	NSceneNode.setPosition _VECTOR3DF(NewtonMat[12],NewtonMat[13],NewtonMat[14])
	NSceneNode.setRotation _VECTOR3DF(Euler[0]*(180/Pi),Euler[1]*(180/Pi),Euler[2]*(180/Pi))
End Function
'pointer edition euler matrix functions
Function GetEulerMatrix2(NSceneNode:ISceneNode,NewtonMat:Float Ptr)
	Local Euler#[3]
	Euler[0]=NSceneNode.getRotation().getX()*(Pi/180)
	Euler[1]=NSceneNode.getRotation().getY()*(Pi/180)
	Euler[2]=NSceneNode.getRotation().getZ()*(Pi/180)
	NewtonSetEulerAngle Varptr Euler[0],Varptr newtonMat[0]
	Newtonmat[12]=NSceneNode.getPosition().getX()
	newtonMat[13]=NSceneNode.getPosition().getY()
	NewtonMat[14]=NSceneNode.getPosition().getZ()	
End Function
Function SetEulerMatrix2(NSceneNode:ISceneNode,NewtonMat:Float Ptr)
	Local Euler#[3]
	NewtonGetEulerAngle Varptr NewtonMat[0],Varptr Euler[0]
	NSceneNode.setPosition Vector3df.createFromVals(NewtonMat[12],NewtonMat[13],NewtonMat[14])
	NSceneNode.setRotation Vector3df.createfromVals(Euler[0]*(180/Pi),Euler[1]*(180/Pi),Euler[2]*(180/Pi))
End Function

'These override Newton's local memory functions with native function wrappers.
Function MemAllocate:Byte Ptr(size:Int)
	nMemSize:+size
	Return MemAlloc(size)
End Function
Function MemRelease(memptr:Byte Ptr,size:Int)
	nMemSize:-size
	MemClear memptr,size
	MemFree memptr
	GCCollect
End Function

'body event callbacks
Function  ApplyForceAndTorque(Body:Byte Ptr) 'gravity callback
	Local mass#,Ixx#,Iyy#,Izz#
	NewtonBodyGetMassMatrix(body,Varptr mass, Varptr Ixx, Varptr Iyy, Varptr Izz)
	Local force#[]=[0#,Iyy*mass*-550#,0#]
	NewtonBodySetForce body,Varptr force[0]
End Function
Function  NSetTransform(body:Byte Ptr,NewtonMat# Ptr) 'the N prefix is because the
                                           'set transform function is already used
                                             'by this language for something else.
	Local node:ISceneNode
	node=ISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	
	newtonBodyGetMatrix body,Varptr NewtonMat[0]
	SetEulerMatrix2 node,Varptr NewtonMat[0]
End Function
Function BodyLeftWorld(body:Byte Ptr) 'What do we do if we've gone off the edge of the
                                      'world?  Answer: We get dropped back in.
	Local node:ISceneNode=ISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	node.setPosition _VECTOR3DF(0,0,0)
	GetEulerMatrix node,mat
	
	NewtonBodySetMatrix body,Varptr mat[0]
End Function
Function BodyDestructor(body:Byte Ptr) 'if a physical body is destroyed, we add it's
                                       'graphics node to the destructor list.
	Local NodeHandle:Int
	
	NodeHandle=Int(newtonBodyGetUserData(body))
	nNodeDestroyList.AddLast NodeHandle
End Function

'Destructor for the released scene nodes.  Call every time any node(s) is destroyed.
Function NodeDestructor()
	If nNodeDestroyList.Count()&gt;0 Then
		Local tempNode:ISceneNode
		Local objarr:Object[]=ListToArray(nNodeDestroyList)
		Local intarr[objarr.length]
		For j=0 To objarr.length-1
			intarr[j]=objarr[j]
		Next
		For del=EachIn intarr
			tempNode=ISceneNode.CreateFromHandle(del,False)
			tempNode.remove
		Next
		nNodeDestroyList=New TList;tempNode=Null;objarr=Null;intarr=Null
		GCCollect
	End If
End Function

'this is where the trouble is.
Function AnimatedMeshToNewtonCollisionTree:Byte Ptr(nWorld:Byte Ptr,g_map:IAnimatedMesh,g_newtonMap:Byte Ptr)
	NewtonTreeCollisionBeginBuild(g_newtonmap)
	Local cMeshBuffer:Int,j:Int
	Local v1i:Int,v2i:Int,v3i:Int
	Local mb:IMeshBuffer
	
	Local vArray:Float[9]	'vertex array (3*3 floats)
	
	Local tmpCount:Int = 0
	
	For cMeshBuffer=0 To g_map.getMesh(0).getMeshBufferCount() - 1
		
		mb = g_map.getMesh(0).getMeshBuffer(cMeshBuffer)
		
		Local mb_vertices:Array_S3DVertex=mb.getVertices()
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]
			
			vArray[0]=mb_vertices.elementAt(v1i).getPos().getX()
			vArray[1]=mb_vertices.elementAt(v1i).getPos().getY()
			vArray[2]=mb_vertices.elementAt(v1i).getPos().getZ()
			vArray[3]=mb_vertices.elementAt(v2i).getPos().getX()
			vArray[4]=mb_vertices.elementAt(v2i).getPos().getY()
			vArray[5]=mb_vertices.elementAt(v2i).getPos().getZ()
			vArray[6]=mb_vertices.elementAt(v3i).getPos().getX()
			vArray[7]=mb_vertices.elementAt(v3i).getPos().getY()
			vArray[8]=mb_vertices.elementAt(v3i).getPos().getZ()
			
			NewtonTreeCollisionAddFace(g_newtonmap,3,Varptr vArray[0],12,1)
		Next
		
	Next
	NewtonTreeCollisionEndBuild(g_newtonmap,0);
	Local g_newtonmapbody:Byte Ptr=NewtonCreateBody(nWorld,g_newtonmap);
	
Rem
After loading the bsp mesh in irrlicht we must create a newton collision tree consisting of all the triangles
in the bsp mesh. To do this we loop through the indices list And add vertices 3 at a time into newton. I should
mention here that I was lazy when writing this And just used a straight cast To video::S3DVertex2TCoords - this is because
bsp meshes have lightmap textures on them. If you are using a mesh with only 1 set of texture co-ordinates (like
a landscape Or .x level) Then use (video::S3DVertex).
Newton requires 2 pointers For every Object - a NewtonBody* For the rigid body, And a NewtonCollision* that
describes the objects geometry. After creating the tree collision geometry, we create a body For the map And
assign it To the collision. Bodys which have a tree collision For their geometry are static And their mass
will be ignored by newton - so you can only use meshes For your scenery!
End Rem
	'set the newton world size based on the bsp size
	Local boxP0#[3] 
	Local boxP1#[3] 
	NewtonBodyGetMatrix g_newtonmapbody,Varptr mat[0]
	NewtonCollisionCalculateAABB g_newtonmap,Varptr mat[0],Varptr boxP0[0],Varptr boxP1[0]
	'pad the box
	boxP0[0]:-100
	boxP1[0]:+100
	boxP0[1]:-100
	boxP1[1]:+100
	boxP0[2]:-100
	boxP1[2]:+100
	NewtonSetWorldSize nWorld,Varptr boxP0[0],Varptr boxP1[0]
Rem
After loading the map, we can calculate the bounding box surrounding it And set the newton world size To
match. Newton should automatically disable anything which falls out of the map this way.
End Rem
	Return g_newtonmapbody
End Function</textarea> <br><br></td></tr></table><br>
<a name="751841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >klepto2</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, this one is by leadwerks and really nice. I currently use this in addition with minib3d and I have also added some functions to it which I have needed. I have also have made it crossplattform. <br><br>Get the crossplattform module here: <a href="http://www.blitzbasic.com/Community/posts.php?topic=67327" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=67327</a> <br><br></td></tr></table><br>
<a name="751968"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's my Irrlicht.Extended btw.  Nothing impressive.  Just a pair of convenience functions.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Module Irrlicht.Extended

Import Irrlicht.Core
Import BRL.System
Private
	OnEnd byebye
	Function byebye()
		Print "Goodbye."
	End Function
Public

Function DebugCreateIrrlicht(stencil,vsync,fullScn% Var,rAccel% Var,dvc:IrrlichtDevice Var,dvr:IVideoDriver Var,sne:ISceneManager Var)
	fsn=Confirm("Run in fullscreen?")
	rac=Confirm("Click OK to use HW Driven rendering acceleration.  If you~n~r"+..
	 "don't, a software renderer will be used instead.")
	If rAccel Then
		Select Confirm("Default driver is Direct3D (v8.x to v9.x).  Use OpenGL(1.x.x) instead?")
			Case True CreateIrrlicht EDT_OPENGL,800,600,32,fsn,stencil,vsync,dvc,dvr,sne
		Case False
			Select Confirm( ..
			 "Use Direct3D 9.0?  Cancel will default to older driver (Direct3D 8.1).~n~r"+..
			  "D3D 8.1 is not fully functional in the rendering techniques this program uses, so~n~r"+..
			   "rendering errors may occur.  Most commonly reported is the inexplicable failiure to~n~r"+..
			    "render seemingly random polygons on the sphere mesh primitives.  The physics~n~r"+..
			     "simulation is entirely independent of the renderer, so it should be the same regardless.")
				Case True CreateIrrlicht EDT_DIRECT3D9,800,600,16,fsn,stencil,vsync,dvc,dvr,sne
				Case False CreateIrrlicht EDT_DIRECT3D8,800,600,16,fsn,stencil,vsync,dvc,dvr,sne
			End Select
		End Select
	Else
		If Confirm("Use high quality software renderer?  WARNING: This will be VERY SLOW!") Then
			CreateIrrlicht EDT_SOFTWARE2,640,480,16,fsn,stencil,vsync,dvc,dvr,sne
		Else
			CreateIrrlicht EDT_SOFTWARE,640,480,16,fsn,stencil,vsync,dvc,dvr,sne
		End If
	End If
	fullScn=fsn
	rAccel=rac
End Function

Function CreateIrrlicht(renderer,rezx,rezy,bits,fullscrn,stencil,vsync,DVC:IrrlichtDevice Var,DVR:IVideoDriver Var,SCN:ISceneManager Var)
	DVC=IrrlichtDevice.create(..
	 renderer,_DIMENSION2DI(rezx,rezy),rezdepth,..
	  fullscrn,stencil,vsync)
	
	If DVC.handle=0 Then
		Print "Could not create 3D device!"
		Notify "Could not create 3D device!",True
		End
	Else
		Print "Created 3D device successfully!"
	End If
	
	DVR=DVC.getVideoDriver()
	SCN=DVC.getSceneManager()
End Function

Function ReleaseIrrlicht(DVC:IrrlichtDevice)
	DVC.drop()
	DVC=Null
	If DVC Then
		Print "3D device was not released successfully!"
		Notify "3D device was not released successfully!",True
		End
	Else
		Print "3D device was released successfully!"
	End If
End Function</textarea><br><br>EDIT:Added another function. <br><br></td></tr></table><br>
<a name="751971"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, and GMan, thanks for looking at it.  I sincerely appreciate it.<br><br>Incedentally, does the idea for your screen name come from Half Life? :P <br><br></td></tr></table><br>
<a name="751988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >René</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you ninjarat for the wrapper code! <br><br></td></tr></table><br>
<a name="752034"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're welcome :) <br><br></td></tr></table><br>
<a name="752182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone gotten anywhere with it?  I still can't do the level mesh collision tree properly. <br><br></td></tr></table><br>
<a name="752204"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ninjarat - unfortunately i didnt get the time last night.  i will look as soon as i can.  <br><div class="quote"> <br>Incedentally, does the idea for your screen name come from Half Life? :P<br> <br></div><br>nope :)  gman comes from my initials...  GG.  tends to be what everyone starts calling me wherever i go. <br><br></td></tr></table><br>
<a name="752392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh.  My initials are BW, or WW.  Either way it's bad.  Billium, Willard, Wet Willy... <br><br></td></tr></table><br>
<a name="752423"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> how are you calling the AnimatedMeshToNewtonCollisionTree function?  what are the parameters? <br><br></td></tr></table><br>
<a name="752430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Syntax: <pre class=code>AnimatedMeshToNewtonCollisionTree:Byte Ptr(nWorld:Byte Ptr,g_map:IAnimatedMesh,g_newtonMap:Byte Ptr)</pre><br><br>Arguments:<br> - nWorld is the current Newton world.<br> - g_map is the animated mesh to create the collision body from.<br> - g_newtonMap is the collision tree object pointer.<br><br>Returns: Pointer to the Newton collision body generated. <br><br></td></tr></table><br>
<a name="752432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> sorry should have been more clear :)  what model/type are you using for the IAnimatedMesh instance? <br><br></td></tr></table><br>
<a name="752433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also, I think I may be taking an entirely wrong approach to this.  Any chance you could show me how to do this?  You're the Irrlicht expert.  And I'm fairly certain you would know something about Newton. <br><br></td></tr></table><br>
<a name="752441"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh, yeah, I'm using a B3D mesh.  But I want it to work with all mesh formats. <br><br></td></tr></table><br>
<a name="752455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> here is the example using the sydney model with the AnimatedMeshToCollisionTree function.  you should be able to change the node at the top right before the initScene() function to test out other meshes.  i did comment out the set the world size part of the AnimatedMeshToCollisionTree function.  please note that different vertex types will cause problems with the function.  i will see if i can whip up a more compatible function sometime tomorrow.<br><pre class=code>
SuperStrict
Framework PUB.Newton
Import Irrlicht.Core
Import BRL.PNGLoader
StartNewton()

Local device:IrrlichtDevice = IrrlichtDevice.create(EDT_OPENGL , Dimension2di.create(640 , 480) , 16 , False , False , False , Null)
Global driver:IVideoDriver = device.getVideoDriver()
Global smgr:ISceneManager = device.getSceneManager() 
'Local Tex:ITexture = driver.getTexture("brlLogo.png")
Local camera:ICameraSceneNode = smgr.addCameraSceneNodeFPS()
camera.setPosition(Vector3df.createFromVals(-19,-49,-30))
camera.setRotation(Vector3df.createFromVals(0 , 0 , 0))
Local light:ILightSceneNode = smgr.addLightSceneNode( Null , Vector3df.createfromVals(-20 , -40 , -30))

Global nWorld:Byte Ptr = NewtonCreate(PhysicsAlloc , PhysicsFree)

' ------------------------------------
' new stuff
' ------------------------------------

' ------------------------------------
' TODO: edit this section for different meshes/nodes
' ------------------------------------
Global mesh:IAnimatedMesh=smgr.getMesh("sydney.md2")
Global node:IAnimatedMeshSceneNode=smgr.addAnimatedMeshSceneNode(mesh)
node.setAnimationSpeed(0)
node.setPosition(_VECTOR3DF(-25,-40,0))

' ------------------------------------
' setup node in newton
' ------------------------------------
Local meshcollision:Byte Ptr = NewtonCreateTreeCollision(nWorld, Null)
Local meshBody:Byte Ptr = AnimatedMeshToNewtonCollisionTree(nWorld, mesh, meshcollision)
Local MeshMat:Float[16]

NewtonBodySetUserData(meshBody,Byte Ptr(node.handle))
'// set a destrutor For this rigid body
NewtonBodySetDestructorCallback(meshBody, PhysicsBodyDestructor)
'// set the transformation For this rigid body
GetMatrix(node ,Varptr MeshMat[0])
NewtonBodySetMatrix(meshBody,Varptr MeshMat[0])
newtonReleaseCollision(nWorld , meshcollision)
' ------------------------------------
	
initScene()

' ------------------------------------

Local Timer:Int = MilliSecs()
While (device.run())
	Timer:+MilliSecs()
	NewtonUpdate(nWorld , 0.001)
	Timer = MilliSecs()
	'NewtonBodyGetMatrix(box , Varptr Mat[0])
	'SetMatrix(node , Mat)
	driver.beginScene(True , True , SColor.createFromVals(0,200 , 200 , 200))
	smgr.drawAll()
	
	driver.endScene()
Wend
StopNewton()

Rem '''''''''''''''''''''''''''''''''''/////////////////////////////////////   The Convertion Matrix Functions
		GetMatrix is the function to get the matrix from the Irrlecht SceneNode And pass it
	to an array to be used by Newton.
		SetMatrix is the function to pass the Matrix from Newton to the Irrlicht SceneNode
EndRem
Function GetMatrix(NSceneNode:ISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	Euler[0] = NSceneNode.getRotation().getX() * (Pi / 180.0)
	Euler[1] = NSceneNode.getRotation().getY() * (Pi / 180.0)
	Euler[2] = NSceneNode.getRotation().getZ() * (Pi / 180.0)
	NewtonSetEulerAngle(Varptr Euler[0] , Varptr newtonMat[0])
	Newtonmat[12] = NSceneNode.getPosition().getX()
	newtonMat[13] = NSceneNode.getPosition().getY()
	NewtonMat[14] = NSceneNode.getPosition().getZ()	
End Function
Function SetMatrix(NSceneNode:ISceneNode , NewtonMat:Float Ptr)
	Local Euler:Float[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0] , Varptr Euler[0])
	NSceneNode.setPosition(Vector3df.createFromVals(NewtonMat[12] , NewtonMat[13] , NewtonMat[14]))
	NSceneNode.setRotation(Vector3df.createfromVals(Euler[0] * (180 / Pi) , Euler[1] * (180 / Pi) , Euler[2] * (180 / Pi)))
End Function
Rem 
					THE FUNCTIONS FROM TUTORIAL 2
End Rem
Function	PhysicsAlloc:Byte Ptr(sizeInBytes:Int)
	Return MemAlloc(sizeInBytes)
End Function
Function    PhysicsFree( memptr:Byte Ptr, sizeInBytes:Int)
	MemFree (memptr)
End Function
' set the tranformation of a rigid body
Function  PhysicsApplyForceAndTorque (Body:Byte Ptr)
	Local mass:Float
	Local Ixx:Float
	Local Iyy:Float
	Local Izz:Float
	NewtonBodyGetMassMatrix (body,Varptr mass, Varptr Ixx, Varptr Iyy, Varptr Izz);
	'Local force:Float[] =  [0.0, -mass * 9.8 , 0.0]
	' GG: messed with the mass multiplier to make it look like the tutorial.  have no idea why this is different.
	Local force:Float[] =  [0.0, -mass * 410 , 0.0]
	NewtonBodySetForce (body, Varptr force[0])
End Function
Function  PhysicsSetTransform (body:Byte Ptr, NewtonMat:Float Ptr)
	Local primitive:ISceneNode
	'// get the graphic Object form the rigid body
	' GG: changed to recreate the scenenode based on the C++ object handle
	primitive = ISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
		
	'// set the transformation matrix For this rigid body
	newtonBodyGetMatrix(body , Varptr NewtonMat[0])
	SetMatrix(Primitive , Varptr NewtonMat[0])	
End Function
Function PhysicsBodyDestructor(body:Byte Ptr)
	Local primitive:ISceneNode
	'// get the graphic Object form the rigid body
	' GG: changed to recreate the scenenode based on the C++ object handle
	primitive = ISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	'// destroy the graphic Object
	primitive.remove()
	
End Function
Function CleanUp ()
	'// destroy the Newton world
	NewtonDestroy (nWorld);
	
End Function

Function InitScene()
	Global Texture:ITexture = Driver.getTexture("doc/brllogo.png") 
	Global box:ISceneNode
	Global IFloor:ISceneNode
	Global boxBody:Byte Ptr
	Global floorBody:Byte Ptr
	Global collision:Byte Ptr
	Global Mat:Float[16]
	'// create the newton world
	
	'// set the linear solver model For faster speed 
	NewtonSetSolverModel(nWorld, 8)
	'// set the adpative friction model For faster speed 
	NewtonSetFrictionModel(nWorld, 1)
	
	'// Set the termination Function
	'atexit(CleanUp);   '//// I Haven't Found The Apropriaty Function for Irrlicht
	
	' ------------------------------------
	' floor
	' ------------------------------------
	'// create the the Floor graphic objects
	IFloor = smgr.addCubeSceneNode(100 )
	'IFloor.setMaterialFlag(EMF_LIGHTING,True)
	IFloor.setMaterialTexture(0 , texture)
	IFloor.setPosition(Vector3df.createFromVals(0,-100 , 0))
	collision = newtonCreateBox(nWorld , 100.0 , 100.0 , 100.0 , Null)
	FloorBody = newtonCreateBody(nWorld , collision)
	
	'// set the transformation For this rigid body
	GetMatrix(IFloor ,Varptr Mat[0])
	NewtonBodySetMatrix(floorBody,Varptr Mat[0])
	
	'// save the pointer To the graphic Object with the body.
	' GG: changed to store the scenenode C++ object handle instead of a reference to the BMAX object with falls out of scope
	NewtonBodySetUserData(floorBody,Byte Ptr(IFloor.handle))
	
	'// set a destrutor For this rigid body
	NewtonBodySetDestructorCallback(floorBody, PhysicsBodyDestructor);
	' ------------------------------------
			
	' ------------------------------------
	' boxes
	' ------------------------------------
	'// set the initial size
	'size = dVector(0.5f, 0.5f, 0.5f);    Not really nesesery(I think so)
	'// create the collision 
	newtonReleaseCollision(nWorld , collision)
	collision = NewtonCreateBox(nWorld, 0.5 , 0.5, 0.5 , Null) 
	Local location:Float[] = [0.0 , 0.0 , 0.0]
	location[0] = -10.0   'FOR  X
	For Local k:Int = 0 To 9
		location[2] = 0.0	'For Z
		For Local J:Int = 0 To 9
			location[1] = 2.0	'For Y
			For Local i:Int = 0  To 9
				box = smgr.addCubeSceneNode(0.5)
				box.setMaterialFlag(EMF_LIGHTING,True)
				box.SetMaterialTexture(0 , Texture)
				box.setPosition(Vector3df.createFromVals(location[0] ,location[1] , location[2]))
				boxBody = newtonCreateBody(nWorld , collision)				
				' GG: changed to store the scenenode C++ object handle instead of a reference to the BMAX object with falls out of scope
				newtonBodySetUserData(boxBody ,Byte Ptr(box.handle))		
				'// set a destrutor For this rigid body
				NewtonBodySetDestructorCallback(boxBody, PhysicsBodyDestructor)
				'// set the tranform call back Function
				NewtonBodySetTransformCallback(boxBody, PhysicsSetTransform)
				'// set the force And torque call back funtion
				NewtonBodySetForceAndTorqueCallback(boxBody, PhysicsApplyForceAndTorque)
				'// set the mass matrix
				'//NewtonBodySetMassMatrix (boxBody, 1.0f, 1.0f / 6.0f, 1.0f / 6.0f, 1.0f  / 6.0f);
				NewtonBodySetMassMatrix(boxBody, 1.0, 1.0, 1.0, 1.0)				
				'// set the matrix For tboth the rigid nody And the graphic body
				GetMatrix(box , Varptr Mat[0])
				NewtonBodySetMatrix(boxBody,Varptr Mat[0])
				PhysicsSetTransform(boxBody, Varptr Mat[0])
				Location[1] :+ 0.5 * 2.0
			Next
			Location[2] :- 0.5 * 4.0 	
		Next
		location[0] :- 0.5 * 4.0 
	Next
	'// Release the collsion geometry when Not need it
	NewtonReleaseCollision(nWorld, collision)
	' ------------------------------------	
EndFunction

Function AnimatedMeshToNewtonCollisionTree:Byte Ptr(nWorld:Byte Ptr,g_map:IAnimatedMesh,g_newtonMap:Byte Ptr)
	NewtonTreeCollisionBeginBuild(g_newtonmap)
	Local cMeshBuffer:Int,j:Int
	Local v1i:Int,v2i:Int,v3i:Int
	Local mb:IMeshBuffer
	
	Local vArray:Float[9]	'vertex array (3*3 floats)
	
	Local tmpCount:Int = 0
	
	For cMeshBuffer=0 To g_map.getMesh(0).getMeshBufferCount() - 1
		
		mb = g_map.getMesh(0).getMeshBuffer(cMeshBuffer)
		
		Local mb_vertices:Array_S3DVertex=mb.getVertices()
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]
			
			vArray[0]=mb_vertices.elementAt(v1i).getPos().getX()
			vArray[1]=mb_vertices.elementAt(v1i).getPos().getY()
			vArray[2]=mb_vertices.elementAt(v1i).getPos().getZ()
			vArray[3]=mb_vertices.elementAt(v2i).getPos().getX()
			vArray[4]=mb_vertices.elementAt(v2i).getPos().getY()
			vArray[5]=mb_vertices.elementAt(v2i).getPos().getZ()
			vArray[6]=mb_vertices.elementAt(v3i).getPos().getX()
			vArray[7]=mb_vertices.elementAt(v3i).getPos().getY()
			vArray[8]=mb_vertices.elementAt(v3i).getPos().getZ()
			
			NewtonTreeCollisionAddFace(g_newtonmap, 3,Varptr vArray[0], 12, j)
		Next
		
	Next
	NewtonTreeCollisionEndBuild(g_newtonmap,0)
	Local g_newtonmapbody:Byte Ptr=NewtonCreateBody(nWorld,g_newtonmap)
	
Rem
After loading the bsp mesh in irrlicht we must create a newton collision tree consisting of all the triangles
in the bsp mesh. To do this we loop through the indices list And add vertices 3 at a time into newton. I should
mention here that I was lazy when writing this And just used a straight cast To video::S3DVertex2TCoords - this is because
bsp meshes have lightmap textures on them. If you are using a mesh with only 1 set of texture co-ordinates (like
a landscape Or .x level) Then use (video::S3DVertex).
Newton requires 2 pointers For every Object - a NewtonBody* For the rigid body, And a NewtonCollision* that
describes the objects geometry. After creating the tree collision geometry, we create a body For the map And
assign it To the collision. Bodys which have a tree collision For their geometry are static And their mass
will be ignored by newton - so you can only use meshes For your scenery!
End Rem
	Rem
	'set the newton world size based on the bsp size
	Local boxP0:Float[3] 
	Local boxP1:Float[3] 
	Local matrix:Float[16] 
	NewtonBodyGetMatrix g_newtonmapbody,Varptr matrix[0]
	NewtonCollisionCalculateAABB g_newtonmap,Varptr matrix[0],Varptr boxP0[0],Varptr boxP1[0]
	'pad the box
	boxP0[0]:-10
	boxP1[0]:+10
	boxP0[1]:-10
	boxP1[1]:+10
	boxP0[2]:-10
	boxP1[2]:+10
	NewtonSetWorldSize nWorld,Varptr boxP0[0],Varptr boxP1[0]
	EndRem
Rem
After loading the map, we can calculate the bounding box surrounding it And set the newton world size To
match. Newton should automatically disable anything which falls out of the map this way.
End Rem
	Return g_newtonmapbody
End Function
</pre> <br><br></td></tr></table><br>
<a name="752460"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU THANK YOU!!!!!!!!!!!!!!!!!!!!!!!!!!! :D :D :D :D<br><br><br>Sorry.  Excited.  Right.  Thanks, G.  (is it all right if I just call you G?) <br><br></td></tr></table><br>
<a name="752467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, for genral interest, here's my first Newton test using primitives.  All the textures may be found in the Irrlicht Examples media directory except for the skybox which is from Lugaru.<br><br>Ever played Lugaru?  It's by a guy called David, and it is WICKED for a freelance game.  It has the most innovative fighting system I've ever controlled in gameplay.  Lugaru 1 is pretty minimal otherwise, but he is working on Lugaru 2, and is definitely on to something big.  <a href="http://www.wolfire.com" target="_blank">http://www.wolfire.com</a>  And for the record, he didn't pay me to say that.  I just think it's cool.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">'my newton physics test

Framework BRL.Blitz          'core module
Import BRL.Random            'random number generator.
Import BRL.LinkedList        'linked list handler
Import Pub.NewtonAndIrrlicht 'Imports Newton, Irrlicht, and some
                             'nice interface functions


Print "HELLO WORLD!!!"

ms=MilliSecs()
SeedRnd ms 'randomize seed based on the system timer -- the best way to get
           'the most random results.
Print "Seeded random number generator with system clock. ("+ms+")"

'irrlicht pointers
Global dvc:IrrlichtDevice
Global dvr:IVideoDriver
Global sne:ISceneManager

'newton pointers and matricies
Global box:Byte Ptr[30]
Global ball:Byte Ptr[30]
Global collision:Byte Ptr

'create irrlicht context
DebugCreateIrrlicht False,False,fullScn,rAccel,dvc,dvr,sne
Print "Successfully created Irrlicht Device context."

dvc.SetResizeable True

Global font:IGUIFont=dvc.getGUIEnvironment().getFont("fontcourier.bmp")
Print "Successfully generated font."

dvr.beginScene True,True
	font.draw "LOADING...",_RECTI(3,3,300,50),_SCOLOR(255,255,255,255)
dvr.endScene()

'create skybox
If rAccel Then
	sne.addSkyBoxSceneNode( ..
	 dvr.getTexture("up.jpg"), ..
	  dvr.getTexture("down.jpg"), ..
	   dvr.getTexture("left.jpg"), ..
	    dvr.getTexture("right.jpg"), ..
	     dvr.getTexture("back.jpg"), ..
	      dvr.getTexture("front.jpg"))
End If
Print "Successfully added skybox."

'create scene camera (viewpoint)
Global cam:ICameraSceneNode=sne.addCameraSceneNodeMaya(Null,32,16,16)
cam.setPosition(_VECTOR3DF(0,-.4,-10))
Print "Successfully added camera."

'add a light source
sne.addLightSceneNode(Null,_VECTOR3DF(0,50,0))
Print "Successfully added light source."

'attach the newton api lib
If Not StartNewton() Then
	Print "Could not attach dynamics engine API."
	Notify "Could not attach dynamics engine API.",True
	End
End If
Print "Successfully attached dynamics engine API!"

'create a newton world using custom memory handlers by pointing
'to the functions; null argument selects standard memory handlers
Global world:Byte Ptr=NewtonCreate(MemAllocate,MemRelease)
NewtonSetMinimumFrameRate world,256

'set the world size to a cube that is [36,36,36]
Local wmn#[]=[-18#,-18#,-18#]
Local wmx#[]=[18#,18#,18#]
NewtonSetWorldSize world,Varptr wmn[0],Varptr wmx[0]

'Set the solver and friction models to perfect.  All calculations are resolved as
'many times as is neccessary to eliminate all drift errors before iterating.  Slower
'but much more accurate.
NewtonSetSolverModel world,0
NewtonSetFrictionModel world,0

'set an event callback for bodies leaving the world
NewtonSetBodyLeaveWorldEvent world,BodyLeftWorld

Print "Successfully generated dynamics world!"

'create a floor with a bump in the middle
Local afloor:ISceneNode=sne.addCubeSceneNode(6)
afloor.setMaterialFlag EMF_LIGHTING,True
If rAccel Then
	afloor.setMaterialTexture 0,dvr.getTexture("terraintex.jpg")
	afloor.setMaterialTexture 1,dvr.getTexture("terrain.jpg")
End If
afloor.setPosition _VECTOR3DF(0,-6,0)
collision=NewtonCreateBox(world,6#,6#,6#,Null)
Local floorbody:Byte Ptr=newtonCreateBody(world,collision)
NewtonReleaseCollision world,collision

Local rfloor:ISceneNode=sne.addSphereSceneNode(2)
rfloor.setMaterialFlag EMF_LIGHTING,True
If rAccel Then
	rfloor.setMaterialTexture 0,dvr.getTexture("terraintex.jpg")
	rfloor.setMaterialTexture 1,dvr.getTexture("terrain.jpg")
End If
rfloor.setPosition _VECTOR3DF(0,-3.5,0)
collision=NewtonCreateSphere(world,2#,2#,2#,Null)
Local rfloorbody:Byte Ptr=newtonCreateBody(world,collision)
NewtonReleaseCollision world,collision

'initialize floor
GetEulerMatrix afloor,Mat
NewtonBodySetMatrix floorbody,Varptr Mat[0]
NewtonBodySetUserData floorbody,Byte Ptr(afloor.handle)
NewtonBodySetDestructorCallback floorbody,BodyDestructor

GetEulerMatrix rfloor,Mat
NewtonBodySetMatrix rfloorbody,Varptr Mat[0]
NewtonBodySetUserData rfloorbody,Byte Ptr(rfloor.handle)
NewtonBodySetDestructorCallback rfloorbody,BodyDestructor
Print "Successfully added floor body."

'add some cubes
WriteStdout "Adding cube nodes..."
Global boxnode:ISceneNode[30]
For j=0 To 29
	boxnode[j]=sne.addCubeSceneNode(.8#)
	boxnode[j].setPosition(_VECTOR3DF(Rnd(-3#,3#),Rnd(9#),Rnd(-3#,3#)))
	boxnode[j].setMaterialFlag EMF_LIGHTING,True
	If rAccel Then
		boxnode[j].setMaterialTexture(0,dvr.getTexture("wall.jpg"))
		boxnode[j].setMaterialTexture(1,dvr.getTexture("wallheight.bmp"))
	End If
	GCCollect
Next
Print "done!"

collision=NewtonCreateBox(world,.8#,.8#,.8#,Null)
Print "Successfully generated cube collision object."

'put the cubes in the dynamics world
WriteStdout "Generating cube collision bodies..."
For j=0 To 29
	GetEulerMatrix boxnode[j],mat
	box[j]=NewtonCreateBody(world,collision)
	NewtonBodySetMassMatrix box[j],1#,1#,1#,1#
	NewtonBodySetMatrix box[j],Varptr mat[0]
	omega[0]=Rnd(-20#,20#)
	omega[1]=Rnd(-20#,20#)
	omega[2]=Rnd(-20#,20#)
	NewtonBodySetOmega box[j],Varptr omega[0]
	NewtonBodySetAutoFreeze box[j],1
	NewtonBodySetUserData box[j],Byte Ptr(boxnode[j].handle)
	NewtonBodySetDestructorCallback box[j],BodyDestructor
	NewtonBodySetTransformCallback box[j],NSetTransform
	NewtonBodySetForceAndTorqueCallback box[j],ApplyForceAndTorque
	GCCollect
Next
Print "done!"

NewtonReleaseCollision world,collision
Print "Successfully released cube collision object."

'add some balls
WriteStdout "Adding sphere nodes..."
Global ballnode:ISceneNode[30]
For j=0 To 29
	ballnode[j]=sne.addSphereSceneNode(.4#)
	ballnode[j].setPosition(_VECTOR3DF(Rnd(-3#,3#),Rnd(9#),Rnd(-3#,3#)))
	ballnode[j].setMaterialFlag EMF_LIGHTING,True
	If rAccel Then
		ballnode[j].setMaterialTexture(0,dvr.getTexture("wall.jpg"))
		ballnode[j].setMaterialTexture(1,dvr.getTexture("wallheight.bmp"))
	End If
	GCCollect
Next
Print "done!"

collision=NewtonCreateSphere(world,.4#,.4#,.4#,Null)
Print "Successfully generated sphere collision object."

'put the balls in the dynamics world
WriteStdout "Generating sphere collision bodies..."
For j=0 To 29
	GetEulerMatrix ballnode[j],mat
	ball[j]=NewtonCreateBody(world,collision)
	NewtonBodySetMassMatrix ball[j],1#,1#,1#,1#
	NewtonBodySetMatrix ball[j],Varptr mat[0]
	omega[0]=Rnd(-5#,5#)
	omega[1]=Rnd(-5#,5#)
	omega[2]=Rnd(-5#,5#)
	NewtonBodySetOmega ball[j],Varptr omega[0]
	NewtonBodySetAutoFreeze ball[j],1
	NewtonBodySetUserData ball[j],Byte Ptr(ballnode[j].handle)
	NewtonBodySetDestructorCallback ball[j],BodyDestructor
	NewtonBodySetTransformCallback ball[j],NSetTransform
	NewtonBodySetForceAndTorqueCallback ball[j],ApplyForceAndTorque
	GCCollect
Next
Print "done!"

NewtonReleaseCollision world,collision
Print "Successfully released sphere collision object."


'okay, here we go
WriteStdout "Begin simulation..."
fps=0
str$=""
timestep!=0
Local intMat[16]

Repeat
	'update world euler matrix
	timestep=NewtonGetTimeStep(world)*(fps/60)
	If timestep&gt;1 Then timestep=1
	NewtonUpdate world,timestep
	
	NodeDestructor 'destroy the deleted/released nodes
	
	dvr.beginScene(True,True)
		sne.drawAll() 'draw scene
		
		'draw general data
		fps=dvr.getFPS()
		str="renderer ~q"
		 str:+dvr.getName()+"~q   physics ~qNewton Dynamics v"
		  str:+NewtonWorldGetVersion(world)+"~q   "
		   str:+"FPS = "+fps+"   TimeStep = "+Float(timestep)
		font.draw str,_RECTI(5,5,300,50),_SCOLOR(255,0,0,0)
		str="renderer ~q"
		 str:+dvr.getName()+"~q   physics ~qNewton Dynamics v"
		  str:+NewtonWorldGetVersion(world)+"~q   "
		   str:+"FPS = "+fps+"   TimeStep = "+Float(timestep)
		font.draw str,_RECTI(3,3,300,50),_SCOLOR(255,255,255,64)
		
		'draw debug data
		curralloced=GCMemAlloced()
		font.draw "CoreMem="+(curralloced/1024)+"KB   "+..
		 "SimMem="+(nMemSize/1024)+..
		  "KB   TotalMem="+((curralloced+nMemSize)/1024)+..
		   "KB   Note: Irrlicht uses a seperate memory system.",..
		    _RECTI(5,21,300,50),_SCOLOR(255,0,0,0)
		font.draw "CoreMem="+(curralloced/1024)+"KB   "+..
		 "SimMem="+(nMemSize/1024)+..
		  "KB   TotalMem="+((curralloced+nMemSize)/1024)+..
		   "KB   Note: Irrlicht uses a seperate memory system.",..
		    _RECTI(3,19,300,50),_SCOLOR(255,255,255,64)
	dvr.endScene()
	
	GCCollect
Until Not dvc.run()
Print "ended properly."

'now we clean up
NewtonDestroyAllBodies world 'destroy all bodies in dynamics world
Print "Successfully destroyed all physical bodies."
NewtonDestroy world 'destroy dynamics world
Print "Successfully destroyed dynamics world."
NodeDestructor
Print "Successfully destroyed scene nodes."
ReleaseIrrlicht dvc 'release irrlicht context
Print "Successfully released Irrlicht Device context."
StopNewton 'drop newton api
Print "Successfully dropped dynamics engine API."

End</textarea> <br><br></td></tr></table><br>
<a name="752690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm having trouble with this... .x and .b3d don't work, but .md2 works fine.  Different vert formats, right?  How do I solve this? <br><br></td></tr></table><br>
<a name="752697"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> this one should be compatible with any mesh type:<br><pre class=code>
Function AnimatedMeshToNewtonCollisionTree:Byte Ptr(nWorld:Byte Ptr,g_map:IAnimatedMesh,g_newtonMap:Byte Ptr)
	NewtonTreeCollisionBeginBuild(g_newtonmap)
	Local cMeshBuffer:Int,j:Int
	Local v1i:Int,v2i:Int,v3i:Int
	Local mb:IMeshBuffer
	
	Local vArray:Float[9]	'vertex array (3*3 floats)
	
	Local tmpCount:Int = 0
	
	For cMeshBuffer=0 To g_map.getMesh(0).getMeshBufferCount() - 1
		
		mb = g_map.getMesh(0).getMeshBuffer(cMeshBuffer)

		Local vertType:Int=mb.getVertexType()
		
		Local arr_standardVerts:Array_S3DVertex=Null
		Local arr_2TCoordVerts:Array_S3DVertex2TCoords=Null
		Local arr_TangentVerts:Array_S3DVertexTangents=Null

		If vertType=EVT_STANDARD
			arr_standardVerts=mb.getVertices()
		Else If vertType=EVT_2TCOORDS
			arr_2TCoordVerts=mb.getVertices2TCoords()
		Else If vertType=EVT_TANGENTS
			arr_TangentVerts=mb.getVerticesTangents()
		EndIf
		
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]

			Local v1:Vertex=Null
			Local v2:Vertex=Null
			Local v3:Vertex=Null
			
			If vertType=EVT_STANDARD
				v1=Vertex(arr_standardVerts.elementAt(v1i))
				v2=Vertex(arr_standardVerts.elementAt(v2i))
				v3=Vertex(arr_standardVerts.elementAt(v3i))
			Else If vertType=EVT_2TCOORDS
				v1=Vertex(arr_2TCoordVerts.elementAt(v1i))
				v2=Vertex(arr_2TCoordVerts.elementAt(v2i))
				v3=Vertex(arr_2TCoordVerts.elementAt(v3i))
			Else If vertType=EVT_TANGENTS
				v1=Vertex(arr_tangentVerts.elementAt(v1i))
				v2=Vertex(arr_tangentVerts.elementAt(v2i))
				v3=Vertex(arr_tangentVerts.elementAt(v3i))
			EndIf
			
			vArray[0]=v1.getPos().getX()
			vArray[1]=v1.getPos().getY()
			vArray[2]=v1.getPos().getZ()
			vArray[3]=v2.getPos().getX()
			vArray[4]=v2.getPos().getY()
			vArray[5]=v2.getPos().getZ()
			vArray[6]=v3.getPos().getX()
			vArray[7]=v3.getPos().getY()
			vArray[8]=v3.getPos().getZ()
			
			NewtonTreeCollisionAddFace(g_newtonmap, 3,Varptr vArray[0], 12, j)
		Next
		
	Next
	NewtonTreeCollisionEndBuild(g_newtonmap,0)
	Local g_newtonmapbody:Byte Ptr=NewtonCreateBody(nWorld,g_newtonmap)
	
Rem
After loading the bsp mesh in irrlicht we must create a newton collision tree consisting of all the triangles
in the bsp mesh. To do this we loop through the indices list And add vertices 3 at a time into newton. I should
mention here that I was lazy when writing this And just used a straight cast To video::S3DVertex2TCoords - this is because
bsp meshes have lightmap textures on them. If you are using a mesh with only 1 set of texture co-ordinates (like
a landscape Or .x level) Then use (video::S3DVertex).
Newton requires 2 pointers For every Object - a NewtonBody* For the rigid body, And a NewtonCollision* that
describes the objects geometry. After creating the tree collision geometry, we create a body For the map And
assign it To the collision. Bodys which have a tree collision For their geometry are static And their mass
will be ignored by newton - so you can only use meshes For your scenery!
End Rem
	Rem
	'set the newton world size based on the bsp size
	Local boxP0:Float[3] 
	Local boxP1:Float[3] 
	Local matrix:Float[16] 
	NewtonBodyGetMatrix g_newtonmapbody,Varptr matrix[0]
	NewtonCollisionCalculateAABB g_newtonmap,Varptr matrix[0],Varptr boxP0[0],Varptr boxP1[0]
	'pad the box
	boxP0[0]:-10
	boxP1[0]:+10
	boxP0[1]:-10
	boxP1[1]:+10
	boxP0[2]:-10
	boxP1[2]:+10
	NewtonSetWorldSize nWorld,Varptr boxP0[0],Varptr boxP1[0]
	EndRem
Rem
After loading the map, we can calculate the bounding box surrounding it And set the newton world size To
match. Newton should automatically disable anything which falls out of the map this way.
End Rem
	Return g_newtonmapbody	
End Function
</pre> <br><br></td></tr></table><br>
<a name="752703"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also, transforming the mesh (even before I create the tree) doesn't seem to change anything (in terms of collision.) <br><br></td></tr></table><br>
<a name="752705"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> thx, G. <br><br></td></tr></table><br>
<a name="752745"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, here's mine!  It's strongly based on yours but it has an add-on.  :D  Kinda proud!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">'Fixed by gman.  That guy's showing up in the credits for sure.  Thank you G!
Function AnimatedMeshToNewtonCollisionTree:Byte Ptr(world:Byte Ptr,map:IAnimatedMesh,newtonMap:Byte Ptr,createbox=True)
	NewtonTreeCollisionBeginBuild(newtonmap)
	Local cMeshBuffer,j
	Local mb:IMeshBuffer
	
	Local vArray#[9]	'vertex array (3*3 floats)
	For cMeshBuffer=0 To map.getMesh(0).getMeshBufferCount() - 1
		mb = map.getMesh(0).getMeshBuffer(cMeshBuffer)
		Local vertType=mb.getVertexType()
		Local arr_standardVerts:Array_S3DVertex=Null
		Local arr_2TCoordVerts:Array_S3DVertex2TCoords=Null
		Local arr_TangentVerts:Array_S3DVertexTangents=Null

		If vertType=EVT_STANDARD
			arr_standardVerts=mb.getVertices()
		Else If vertType=EVT_2TCOORDS
			arr_2TCoordVerts=mb.getVertices2TCoords()
		Else If vertType=EVT_TANGENTS
			arr_TangentVerts=mb.getVerticesTangents()
		EndIf
		
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]

			Local v1:Vertex=Null
			Local v2:Vertex=Null
			Local v3:Vertex=Null
			
			If vertType=EVT_STANDARD Then
				v1=Vertex(arr_standardVerts.elementAt(v1i))
				v2=Vertex(arr_standardVerts.elementAt(v2i))
				v3=Vertex(arr_standardVerts.elementAt(v3i))
			Else If vertType=EVT_2TCOORDS Then
				v1=Vertex(arr_2TCoordVerts.elementAt(v1i))
				v2=Vertex(arr_2TCoordVerts.elementAt(v2i))
				v3=Vertex(arr_2TCoordVerts.elementAt(v3i))
			Else If vertType=EVT_TANGENTS Then
				v1=Vertex(arr_tangentVerts.elementAt(v1i))
				v2=Vertex(arr_tangentVerts.elementAt(v2i))
				v3=Vertex(arr_tangentVerts.elementAt(v3i))
			EndIf
			
			vArray[0]=v1.getPos().getX()
			vArray[1]=v1.getPos().getY()
			vArray[2]=v1.getPos().getZ()
			vArray[3]=v2.getPos().getX()
			vArray[4]=v2.getPos().getY()
			vArray[5]=v2.getPos().getZ()
			vArray[6]=v3.getPos().getX()
			vArray[7]=v3.getPos().getY()
			vArray[8]=v3.getPos().getZ()
			
			NewtonTreeCollisionAddFace(newtonmap, 3,Varptr vArray[0], 12, j)
		Next
	Next
	NewtonTreeCollisionEndBuild(newtonmap,0)
	Local newtonmapbody:Byte Ptr=NewtonCreateBody(world,newtonmap)
	
	If createbox Then
		'set the newton world size based on the mesh size
		Local boxP0#[3] 
		Local boxP1#[3] 
		NewtonBodyGetMatrix newtonmapbody,Varptr mat[0]
		NewtonCollisionCalculateAABB newtonmap,Varptr mat[0],Varptr boxP0[0],Varptr boxP1[0]
		'pad the box
		boxP0[0]:-60
		boxP1[0]:+60
		boxP0[1]:-60
		boxP1[1]:+60
		boxP0[2]:-60
		boxP1[2]:+60
		NewtonSetWorldSize world,Varptr boxP0[0],Varptr boxP1[0]
	End If
	
	Return newtonmapbody
End Function
Function MeshToNewtonCollisionTree:Byte Ptr(world:Byte Ptr,map:IMesh,newtonMap:Byte Ptr,createbox=True)
	NewtonTreeCollisionBeginBuild(newtonmap)
	Local cMeshBuffer,j
	Local mb:IMeshBuffer
	
	Local vArray#[9]	'vertex array (3*3 floats)
	For cMeshBuffer=0 To map.getMeshBufferCount() - 1
		mb = map.getMeshBuffer(cMeshBuffer)
		Local vertType=mb.getVertexType()
		Local arr_standardVerts:Array_S3DVertex=Null
		Local arr_2TCoordVerts:Array_S3DVertex2TCoords=Null
		Local arr_TangentVerts:Array_S3DVertexTangents=Null

		If vertType=EVT_STANDARD
			arr_standardVerts=mb.getVertices()
		Else If vertType=EVT_2TCOORDS
			arr_2TCoordVerts=mb.getVertices2TCoords()
		Else If vertType=EVT_TANGENTS
			arr_TangentVerts=mb.getVerticesTangents()
		EndIf
		
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]

			Local v1:Vertex=Null
			Local v2:Vertex=Null
			Local v3:Vertex=Null
			
			If vertType=EVT_STANDARD Then
				v1=Vertex(arr_standardVerts.elementAt(v1i))
				v2=Vertex(arr_standardVerts.elementAt(v2i))
				v3=Vertex(arr_standardVerts.elementAt(v3i))
			Else If vertType=EVT_2TCOORDS Then
				v1=Vertex(arr_2TCoordVerts.elementAt(v1i))
				v2=Vertex(arr_2TCoordVerts.elementAt(v2i))
				v3=Vertex(arr_2TCoordVerts.elementAt(v3i))
			Else If vertType=EVT_TANGENTS Then
				v1=Vertex(arr_tangentVerts.elementAt(v1i))
				v2=Vertex(arr_tangentVerts.elementAt(v2i))
				v3=Vertex(arr_tangentVerts.elementAt(v3i))
			EndIf
			
			vArray[0]=v1.getPos().getX()
			vArray[1]=v1.getPos().getY()
			vArray[2]=v1.getPos().getZ()
			vArray[3]=v2.getPos().getX()
			vArray[4]=v2.getPos().getY()
			vArray[5]=v2.getPos().getZ()
			vArray[6]=v3.getPos().getX()
			vArray[7]=v3.getPos().getY()
			vArray[8]=v3.getPos().getZ()
			
			NewtonTreeCollisionAddFace(newtonmap, 3,Varptr vArray[0], 12, j)
		Next
	Next
	NewtonTreeCollisionEndBuild(newtonmap,0)
	Local newtonmapbody:Byte Ptr=NewtonCreateBody(world,newtonmap)
	
	If createbox Then
		'set the newton world size based on the mesh size
		Local boxP0#[3] 
		Local boxP1#[3] 
		NewtonBodyGetMatrix newtonmapbody,Varptr mat[0]
		NewtonCollisionCalculateAABB newtonmap,Varptr mat[0],Varptr boxP0[0],Varptr boxP1[0]
		'pad the box
		boxP0[0]:-60
		boxP1[0]:+60
		boxP0[1]:-60
		boxP1[1]:+60
		boxP0[2]:-60
		boxP1[2]:+60
		NewtonSetWorldSize world,Varptr boxP0[0],Varptr boxP1[0]
	End If
	
	Return newtonmapbody
End Function</textarea><br><br>Added a still mesh function.<br><br>The way my test code works is that it takes an animated mesh, gets the first (and only) frame of it, and runs it through a mesh manipulator scale operation to fix the scale (needs to be about ten times bigger.)<br><br>Then creates a scene node for the still mesh, and also creates a collision tree.  Then drops the primitives just like in the first demo.<br><br>Just as soon as I get this working well, I'll show everyone the source.<br><br>Have a good one, and you'll DEFINITELY be in the credits of my next game, (that uses this) G!  :) <br><br></td></tr></table><br>
<a name="752989"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, G.  I'd like some help with ragdolls.  As in, how do you make one out of an Irrlicht skinned mesh (of any format?) <br><br></td></tr></table><br>
<a name="753055"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pretty neat, eh?<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">'my second newton physics test
'using newton collision trees

Framework BRL.Blitz          'core module
Import BRL.Random            'random number generator.
Import Pub.NewtonAndIrrlicht 'Imports Newton, Irrlicht, and some
                             'nice interface functions


Print "HELLO WORLD!!!"

ms=MilliSecs()
SeedRnd ms 'randomize seed based on the system timer -- the best way to get
           'the most random results.
Print "Seeded random number generator with system clock. ("+ms+")"

'irrlicht pointers
Global dvc:IrrlichtDevice      'the core irrlicht device class
Global dvr:IVideoDriver        'the video driver class
Global sne:ISceneManager       'the scene manager class
Global msm:IMeshManipulator    'the mesh manipulator class
Global csr:ICursorControl      'the cursor manipulator class
Global rcv:SmoothEventReceiver 'the input event receiver

'newton pointers and matricies
Global boxlist:TList
Global collision:Byte Ptr
Global boxcollision:Byte Ptr

'create irrlicht context
DebugCreateIrrlicht False,True,fullScn,rAccel,dvc,dvr,sne,rcv
msm=sne.getMeshManipulator()
csr=dvc.getCursorControl()
dvc.SetResizeable True
Print "Successfully created Irrlicht Device context."

Global font:IGUIFont=dvc.getGUIEnvironment().getFont("fontcourier.bmp")
Print "Successfully generated font."

dvr.beginScene True,True
	font.draw "LOADING...",_RECTI(3,3,300,50),_SCOLOR(255,255,255,255)
dvr.endScene()

'create skybox
If rAccel Then
	sne.addSkyBoxSceneNode( ..
	 dvr.getTexture("up.jpg"), ..
	  dvr.getTexture("down.jpg"), ..
	   dvr.getTexture("left.jpg"), ..
	    dvr.getTexture("right.jpg"), ..
	     dvr.getTexture("back.jpg"), ..
	      dvr.getTexture("front.jpg"))
End If
Print "Successfully added skybox."

'create scene camera (viewpoint)
Global cam:ICameraSceneNode=sne.addCameraSceneNodeFPS(Null,92,64,64)
cam.setPosition(_VECTOR3DF(0,20,-10))
Print "Successfully added camera."

'add a light source
sne.addLightSceneNode(Null,_VECTOR3DF(0,50,0))
Print "Successfully added light source."

'attach the newton api lib
If Not StartNewton() Then
	Print "Could not attach dynamics engine API."
	Notify "Could not attach dynamics engine API.",True
	End
End If
Print "Successfully attached dynamics engine API!"

'create a newton world using custom memory handlers by pointing
'to the functions; null argument selects standard memory handlers
Global world:Byte Ptr=NewtonCreate(MemAllocate,MemRelease)
NewtonSetMinimumFrameRate world,500
sim_gravity=9800 'scale up 1000 from 9.8 meter/sec^2

'Set the solver and friction models to perfect.  All calculations are resolved as
'many times as is neccessary to eliminate all drift errors before iterating.  Slower
'but much more accurate.
NewtonSetSolverModel world,0
NewtonSetFrictionModel world,0


Print "Successfully generated dynamics world!"

'load a mesh for the collision tree
Global amesh:IAnimatedMesh=sne.getMesh("testlevel.b3d")
Global mesh:IMesh=amesh.getMesh(0)
msm.ScaleMesh(mesh,_VECTOR3DF(10,10,10))
Global meshnode:ISceneNode=sne.addMeshSceneNode(mesh)
'meshnode.setScale _VECTOR3DF(10,10,10)

Local meshcollision:Byte Ptr=NewtonCreateTreeCollision(world,Null)
Local meshbody:Byte Ptr=MeshToNewtonCollisionTree(world,mesh,meshcollision,True)
Local meshmat#[16]

'Local wmn#[3]
'Local wmx#[3]
'NewtonBodyGetMatrix meshbody,Varptr mat[0]
'NewtonCollisionCalculateAABB meshcollision,Varptr mat[0],Varptr wmn[0],Varptr wmx[0]
'wmx[2]:+200
'NewtonSetWorldSize world,Varptr wmn[0],Varptr wmx[0]

NewtonBodySetUserData meshbody,Byte Ptr(meshnode.handle)
NewtonBodySetDestructorCallback meshbody,BodyDestructor
GetEulerMatrix meshnode,meshmat
NewtonBodySetMatrix meshbody,Varptr meshmat[0]
NewtonReleaseCollision world,meshcollision
Print "Successfully added geo-collision tree."

'Print "Successfully generated cube collision object."
Global boxmesh:IMesh=sne.getMesh("smallcube.3ds").getMesh(0)
msm.ScaleMesh(boxmesh,_VECTOR3DF(.1,.1,.1))
Global tex:ITexture=dvr.getTexture("wall.jpg")
'boxcollision=NewtonCreateTreeCollision(world,Null)
'MeshToNewtonCollisionTree world,boxmesh,boxcollision,False,False
boxcollision=NewtonCreateBox(world,4,4,4,Null)

csr.setVisible False
'okay, here we go
WriteStdout "Begin simulation..."
fps=0
str$=""
timestep!=0''Local intMat[16]
msdn=False

Repeat
	If rcv.IsMouseButtonDown(0) And Not msdn Then
		AddBox
		msdn=True
	Else If Not rcv.IsMouseButtonDown(0) And msdn=True
		msdn=False
	End If
	If rcv.IsKeyDownUp(EKEY_ESCAPE) Then dvc.closeDevice()
	
	'update world euler matrix
	timestep=NewtonGetTimeStep(world)
	NewtonUpdate world,timestep
	
	NodeDestructor 'destroy the deleted/released nodes
	
	dvr.beginScene True,True
		sne.drawAll() 'draw scene
		
		'draw general data
		fps=dvr.getFPS()
		str="renderer ~q"
		 str:+dvr.getName()+"~q   physics ~qNewton Dynamics v"
		  str:+NewtonWorldGetVersion(world)+"~q   "
		   str:+"FPS = "+fps+"   TimeStep = "+timestep
		font.draw str,_RECTI(5,5,300,50),_SCOLOR(255,0,0,0)
		str="renderer ~q"
		 str:+dvr.getName()+"~q   physics ~qNewton Dynamics v"
		  str:+NewtonWorldGetVersion(world)+"~q   "
		   str:+"FPS = "+fps+"   TimeStep = "+timestep
		font.draw str,_RECTI(3,3,300,50),_SCOLOR(255,255,255,64)
		
		'draw debug data
		curralloced=GCMemAlloced()
		font.draw "CoreMem="+(curralloced/1024)+"KB   "+..
		 "SimMem="+(nMemSize/1024)+..
		  "KB   TotalMem="+((curralloced+nMemSize)/1024)+..
		   "KB   Note: Irrlicht uses a seperate memory system.",..
		    _RECTI(5,21,300,50),_SCOLOR(255,0,0,0)
		font.draw "CoreMem="+(curralloced/1024)+"KB   "+..
		 "SimMem="+(nMemSize/1024)+..
		  "KB   TotalMem="+((curralloced+nMemSize)/1024)+..
		   "KB   Note: Irrlicht uses a seperate memory system.",..
		    _RECTI(3,19,300,50),_SCOLOR(255,255,255,64)
	dvr.endScene()
	
	GCCollect
Until Not dvc.run()
Print "ended properly."

'now we clean up
NewtonReleaseCollision world,boxcollision
NewtonDestroyAllBodies world 'destroy all bodies in dynamics world
Print "Successfully destroyed all physical bodies."
NewtonDestroy world 'destroy dynamics world
Print "Successfully destroyed dynamics world."
NodeDestructor
Print "Successfully destroyed scene nodes."
ReleaseIrrlicht dvc 'release irrlicht context
Print "Successfully released Irrlicht Device context."
StopNewton 'drop newton api
Print "Successfully dropped dynamics engine API."

End

Function AddBox:Byte Ptr()
	Local boxnode:ISceneNode
	Local box:Byte Ptr
	boxnode=sne.addMeshSceneNode(boxmesh)
	boxnode.setPosition(cam.getPosition())
	boxnode.setMaterialFlag EMF_LIGHTING,True
	boxnode.setMaterialTexture(0,tex)
	GCCollect
	
	GetEulerMatrix boxnode,mat
	box=NewtonCreateBody(world,boxcollision)
	NewtonBodySetMassMatrix box,1#,1#,1#,1#
	NewtonBodySetMatrix box,Varptr mat[0]
	omega=[Float(Rnd(-10,10)),Float(Rnd(-10,10)),Float(Rnd(-10,10))]
	NewtonBodySetOmega box,Varptr omega[0]
	NewtonBodySetAutoFreeze box,1
	NewtonBodySetUserData box,Byte Ptr(boxnode.handle)
	NewtonBodySetDestructorCallback box,BodyDestructor
	NewtonBodySetTransformCallback box,NSetTransform
	NewtonBodySetForceAndTorqueCallback box,ApplyForceAndTorque
	GCCollect
	
	Return box
End Function</textarea><br><br>Pub.NewtonAndIrrlicht:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Rem
bbdoc: Irrlicht and Newton Integration Helper
End Rem
Module Pub.NewtonAndIrrlicht
ModuleInfo "Author: Bill Whitacre (ninjarat), GMan"
ModuleInfo "History: Added functions used in Newton Examples and converted to Irrlicht graphics."

Import BRL.LinkedList
Import Pub.Newton
Import Irrlicht.Extended

Global nMemSize,nNodeDestroyList:TList=New TList
Global mat#[16]
Global omega#[3]
Global sim_gravity#=9.8

'Excellent Euler Matrix converter functions.  Not by me, and I would give credit where
'it was called for, except I honestly don't know who did this.
Function GetEulerMatrix(NSceneNode:ISceneNode,NewtonMat#[])
	Local Euler#[3]
	Euler[0]=NSceneNode.getRotation().getX()*(Pi/180#)
	Euler[1]=NSceneNode.getRotation().getY()*(Pi/180#)
	Euler[2]=NSceneNode.getRotation().getZ()*(Pi/180#)
	NewtonSetEulerAngle(Varptr Euler[0],Varptr NewtonMat[0])
	
	NewtonMat[12]=NSceneNode.getPosition().getX()
	NewtonMat[13]=NSceneNode.getPosition().getY()
	NewtonMat[14]=NSceneNode.getPosition().getZ()
End Function
Function SetEulerMatrix(NSceneNode:ISceneNode,NewtonMat#[])
	Local Euler#[3]
	NewtonGetEulerAngle(Varptr NewtonMat[0],Varptr Euler[0])
	NSceneNode.setPosition _VECTOR3DF(NewtonMat[12],NewtonMat[13],NewtonMat[14])
	NSceneNode.setRotation _VECTOR3DF(Euler[0]*(180/Pi),Euler[1]*(180/Pi),Euler[2]*(180/Pi))
End Function
'pointer edition euler matrix functions
Function GetEulerMatrix2(NSceneNode:ISceneNode,NewtonMat:Float Ptr)
	Local Euler#[3]
	Euler[0]=NSceneNode.getRotation().getX()*(Pi/180)
	Euler[1]=NSceneNode.getRotation().getY()*(Pi/180)
	Euler[2]=NSceneNode.getRotation().getZ()*(Pi/180)
	NewtonSetEulerAngle Varptr Euler[0],Varptr newtonMat[0]
	Newtonmat[12]=NSceneNode.getPosition().getX()
	newtonMat[13]=NSceneNode.getPosition().getY()
	NewtonMat[14]=NSceneNode.getPosition().getZ()	
End Function
Function SetEulerMatrix2(NSceneNode:ISceneNode,NewtonMat:Float Ptr)
	Local Euler#[3]
	NewtonGetEulerAngle Varptr NewtonMat[0],Varptr Euler[0]
	NSceneNode.setPosition _VECTOR3DF(NewtonMat[12],NewtonMat[13],NewtonMat[14])
	NSceneNode.setRotation _VECTOR3DF(Euler[0]*(180/Pi),Euler[1]*(180/Pi),Euler[2]*(180/Pi))
End Function

'These override Newton's local memory functions with native function wrappers.
Function MemAllocate:Byte Ptr(size:Int)
?Debug
	origMemSize=nMemSize
?
	nMemSize:+size
?Debug
	Print "Allocated "+size+"Bytes memory on top of "+origMemSize+" for sim.  nNewMemSize="+nMemSize
	origMemSize=Null
?
	GCCollect

	Return MemAlloc(size)
End Function
Function MemRelease(memptr:Byte Ptr,size:Int)
?Debug
	origMemSize=nMemSize
?
	nMemSize:-size
	MemClear memptr,size
	MemFree memptr
?Debug
	Print "Released "+size+"/"+origMemSize+"Bytes memory for sim.  nNewMemSize="+nMemSize
	origMemSize=Null
?
	GCCollect
End Function

'body event callbacks
Function  ApplyForceAndTorque(Body:Byte Ptr) 'gravity callback
	Local mass#,Ixx#,Iyy#,Izz#
	NewtonBodyGetMassMatrix(body,Varptr mass, Varptr Ixx, Varptr Iyy, Varptr Izz)
	Local force#[]=[0#,Iyy*mass*-sim_gravity,0#]
	NewtonBodySetForce body,Varptr force[0]
End Function
Function  NSetTransform(body:Byte Ptr,NewtonMat# Ptr) 'the N prefix is because the
                                           'set transform function is already used
                                             'by this language for something else.
	Local node:ISceneNode
	node=ISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	
	newtonBodyGetMatrix body,Varptr NewtonMat[0]
	SetEulerMatrix2 node,Varptr NewtonMat[0]
End Function
Function BodyLeftWorld(body:Byte Ptr) 'What do we do if we've gone off the edge of the
                                      'world?  Answer: We get dropped back in.
	Local node:ISceneNode=ISceneNode.CreateFromHandle(Int(newtonBodyGetUserData(body)),False)
	node.setPosition _VECTOR3DF(Rnd(-1#,1#),Rnd(9#,12#),Rnd(-1#,1#))
	GetEulerMatrix node,mat
	
	NewtonBodySetMatrix body,Varptr mat[0]
End Function
Function BodyDestructor(body:Byte Ptr) 'if a physical body is destroyed, we add it's
                                       'graphics node to the destructor list.
	Local NodeHandle:Int
	
	NodeHandle=Int(newtonBodyGetUserData(body))
	nNodeDestroyList.AddLast NodeHandle
End Function

'Destructor for the released scene nodes.  Call every time any node(s) is destroyed.
Function NodeDestructor()
	If nNodeDestroyList.Count()&gt;0 Then
		Local tempNode:ISceneNode
		Local objarr:Object[]=ListToArray(nNodeDestroyList)
		Local intarr[objarr.length]
		For j=0 To objarr.length-1
			intarr[j]=objarr[j]
		Next
		For del=EachIn intarr
			tempNode=ISceneNode.CreateFromHandle(del,False)
			tempNode.remove
		Next
		nNodeDestroyList=New TList;tempNode=Null;objarr=Null;intarr=Null
		GCCollect
	End If
End Function

'Fixed by gman.  That guy's showing up in the credits for sure.  Thank you G!
Function AnimatedMeshToNewtonCollisionTree:Byte Ptr(world:Byte Ptr,map:IAnimatedMesh,newtonMap:Byte Ptr,createbox=True,createbody=True)
	NewtonTreeCollisionBeginBuild(newtonmap)
	Local cMeshBuffer,j
	Local mb:IMeshBuffer
	
	Local vArray#[9]	'vertex array (3*3 floats)
	For cMeshBuffer=0 To map.getMesh(0).getMeshBufferCount() - 1
		mb = map.getMesh(0).getMeshBuffer(cMeshBuffer)
		Local vertType=mb.getVertexType()
		Local arr_standardVerts:Array_S3DVertex=Null
		Local arr_2TCoordVerts:Array_S3DVertex2TCoords=Null
		Local arr_TangentVerts:Array_S3DVertexTangents=Null

		If vertType=EVT_STANDARD
			arr_standardVerts=mb.getVertices()
		Else If vertType=EVT_2TCOORDS
			arr_2TCoordVerts=mb.getVertices2TCoords()
		Else If vertType=EVT_TANGENTS
			arr_TangentVerts=mb.getVerticesTangents()
		EndIf
		
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]

			Local v1:Vertex=Null
			Local v2:Vertex=Null
			Local v3:Vertex=Null
			
			If vertType=EVT_STANDARD Then
				v1=Vertex(arr_standardVerts.elementAt(v1i))
				v2=Vertex(arr_standardVerts.elementAt(v2i))
				v3=Vertex(arr_standardVerts.elementAt(v3i))
			Else If vertType=EVT_2TCOORDS Then
				v1=Vertex(arr_2TCoordVerts.elementAt(v1i))
				v2=Vertex(arr_2TCoordVerts.elementAt(v2i))
				v3=Vertex(arr_2TCoordVerts.elementAt(v3i))
			Else If vertType=EVT_TANGENTS Then
				v1=Vertex(arr_tangentVerts.elementAt(v1i))
				v2=Vertex(arr_tangentVerts.elementAt(v2i))
				v3=Vertex(arr_tangentVerts.elementAt(v3i))
			EndIf
			
			vArray[0]=v1.getPos().getX()
			vArray[1]=v1.getPos().getY()
			vArray[2]=v1.getPos().getZ()
			vArray[3]=v2.getPos().getX()
			vArray[4]=v2.getPos().getY()
			vArray[5]=v2.getPos().getZ()
			vArray[6]=v3.getPos().getX()
			vArray[7]=v3.getPos().getY()
			vArray[8]=v3.getPos().getZ()
			
			NewtonTreeCollisionAddFace(newtonmap, 3,Varptr vArray[0], 12, j)
		Next
	Next
	NewtonTreeCollisionEndBuild(newtonmap,0)
	If createbody Then
		Local newtonmapbody:Byte Ptr=NewtonCreateBody(world,newtonmap)
		If createbox Then
			'set the newton world size based on the mesh size
			Local boxP0#[3] 
			Local boxP1#[3] 
			NewtonBodyGetMatrix newtonmapbody,Varptr mat[0]
			NewtonCollisionCalculateAABB newtonmap,Varptr mat[0],Varptr boxP0[0],Varptr boxP1[0]
			'pad the box
			boxP0[0]:-60
			boxP1[0]:+60
			boxP0[1]:-60
			boxP1[1]:+60
			boxP0[2]:-60
			boxP1[2]:+60
			NewtonSetWorldSize world,Varptr boxP0[0],Varptr boxP1[0]
		End If
		Return newtonmapbody
	End If
	
	Return Null
End Function
Function MeshToNewtonCollisionTree:Byte Ptr(world:Byte Ptr,map:IMesh,newtonMap:Byte Ptr,createbox=True,createbody=True)
	NewtonTreeCollisionBeginBuild(newtonmap)
	Local cMeshBuffer,j
	Local mb:IMeshBuffer
	
	Local vArray#[9]	'vertex array (3*3 floats)
	For cMeshBuffer=0 To map.getMeshBufferCount() - 1
		mb = map.getMeshBuffer(cMeshBuffer)
		Local vertType=mb.getVertexType()
		Local arr_standardVerts:Array_S3DVertex=Null
		Local arr_2TCoordVerts:Array_S3DVertex2TCoords=Null
		Local arr_TangentVerts:Array_S3DVertexTangents=Null

		If vertType=EVT_STANDARD
			arr_standardVerts=mb.getVertices()
		Else If vertType=EVT_2TCOORDS
			arr_2TCoordVerts=mb.getVertices2TCoords()
		Else If vertType=EVT_TANGENTS
			arr_TangentVerts=mb.getVerticesTangents()
		EndIf
		
		Local mb_indices:Array_u16=mb.getIndices()
		
		'add each triangle from the mesh
		For j=0 To mb.getIndexCount() - 1 Step 3
			v1i=mb_indices.elementAt(j)[0]
			v2i=mb_indices.elementAt(j+1)[0]
			v3i=mb_indices.elementAt(j+2)[0]

			Local v1:Vertex=Null
			Local v2:Vertex=Null
			Local v3:Vertex=Null
			
			If vertType=EVT_STANDARD Then
				v1=Vertex(arr_standardVerts.elementAt(v1i))
				v2=Vertex(arr_standardVerts.elementAt(v2i))
				v3=Vertex(arr_standardVerts.elementAt(v3i))
			Else If vertType=EVT_2TCOORDS Then
				v1=Vertex(arr_2TCoordVerts.elementAt(v1i))
				v2=Vertex(arr_2TCoordVerts.elementAt(v2i))
				v3=Vertex(arr_2TCoordVerts.elementAt(v3i))
			Else If vertType=EVT_TANGENTS Then
				v1=Vertex(arr_tangentVerts.elementAt(v1i))
				v2=Vertex(arr_tangentVerts.elementAt(v2i))
				v3=Vertex(arr_tangentVerts.elementAt(v3i))
			EndIf
			
			vArray[0]=v1.getPos().getX()
			vArray[1]=v1.getPos().getY()
			vArray[2]=v1.getPos().getZ()
			vArray[3]=v2.getPos().getX()
			vArray[4]=v2.getPos().getY()
			vArray[5]=v2.getPos().getZ()
			vArray[6]=v3.getPos().getX()
			vArray[7]=v3.getPos().getY()
			vArray[8]=v3.getPos().getZ()
			
			NewtonTreeCollisionAddFace(newtonmap,3,Varptr vArray[0],12,j)
		Next
	Next
	NewtonTreeCollisionEndBuild(newtonmap,0)
	
	If createbody Then
		Local newtonmapbody:Byte Ptr=NewtonCreateBody(world,newtonmap)
		If createbox Then
			'set the newton world size based on the mesh size
			Local boxP0#[3] 
			Local boxP1#[3] 
			NewtonBodyGetMatrix newtonmapbody,Varptr mat[0]
			NewtonCollisionCalculateAABB newtonmap,Varptr mat[0],Varptr boxP0[0],Varptr boxP1[0]
			'pad the box
			boxP0[0]:-80
			boxP1[0]:+80
			boxP0[1]:-80
			boxP1[1]:+80
			boxP0[2]:-80
			boxP1[2]:+80
			NewtonSetWorldSize world,Varptr boxP0[0],Varptr boxP1[0]
		End If
		Return newtonmapbody
	End If
	
	Return Null
End Function</textarea><br><br>Irrlicht.Extended:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Module Irrlicht.Extended

Import Irrlicht.AddOns
Import BRL.System
Private
	OnEnd byebye
	Function byebye()
		Print "Goodbye."
	End Function
	
	Global eventrcv:SmoothEventReceiver=SmoothEventReceiver.createReceiver()
Public

Function DebugCreateIrrlicht(stencil,vsync,fullScn% Var,rAccel% Var,dvc:IrrlichtDevice Var,dvr:IVideoDriver Var,sne:ISceneManager Var,rcv:SmoothEventReceiver Var)
	fsn=Confirm("Run in fullscreen?")
	rac=Confirm("Click OK to use HW Driven rendering acceleration.  If you~n~r"+..
	 "don't, a software renderer will be used instead.")
	If rac Then
		Select Confirm("Default driver is Direct3D (v8.x to v9.x).  Use OpenGL(1.x.x) instead?")
			Case True CreateIrrlicht EDT_OPENGL,640,480,16,fsn,stencil,vsync,dvc,dvr,sne,eventrcv
		Case False
			Select Confirm( ..
			 "Use Direct3D 9.0?  Cancel will default to older driver (Direct3D 8.1).~n~r"+..
			  "D3D 8.1 is not fully functional in the rendering techniques this program uses, so~n~r"+..
			   "rendering errors may occur.  Most commonly reported is the inexplicable failiure to~n~r"+..
			    "render seemingly random polygons on the sphere mesh primitives.  The physics~n~r"+..
			     "simulation is entirely independent of the renderer, so it should be the same regardless.")
				Case True CreateIrrlicht EDT_DIRECT3D9,640,480,16,fsn,stencil,vsync,dvc,dvr,sne,eventrcv
				Case False CreateIrrlicht EDT_DIRECT3D8,640,480,16,fsn,stencil,vsync,dvc,dvr,sne,eventrcv
			End Select
		End Select
	Else
		If Confirm("Use high quality software renderer?  WARNING: This will be VERY SLOW!") Then
			CreateIrrlicht EDT_SOFTWARE2,640,480,16,fsn,stencil,vsync,dvc,dvr,sne,eventrcv
		Else
			CreateIrrlicht EDT_SOFTWARE,640,480,16,fsn,stencil,vsync,dvc,dvr,sne,eventrcv
		End If
	End If
	fullScn=fsn
	rAccel=rac
	rcv=eventrcv
End Function

Function CreateIrrlicht(renderer,rezx,rezy,bits,fullscrn,stencil,vsync,DVC:IrrlichtDevice Var,DVR:IVideoDriver Var,SCN:ISceneManager Var,RCV:SmoothEventReceiver Var)
	DVC=IrrlichtDevice.create(..
	 renderer,_DIMENSION2DI(rezx,rezy),rezdepth,..
	  fullscrn,stencil,vsync,eventrcv)
	
	If DVC.handle=0 Then
		Print "Could not create 3D device!"
		Notify "Could not create 3D device!",True
		End
	Else
		Print "Created 3D device successfully!"
	End If
	
	DVR=DVC.getVideoDriver()
	SCN=DVC.getSceneManager()
	RCV=eventrcv
End Function

Function ReleaseIrrlicht(DVC:IrrlichtDevice)
	DVC.drop()
	DVC=Null
	If DVC Then
		Print "3D device was not released successfully!"
		Notify "3D device was not released successfully!",True
		End
	Else
		Print "3D device was released successfully!"
	End If
End Function</textarea> <br><br></td></tr></table><br>
<a name="753130"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >gman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> greetings :)  lots of stuff going on in here...  glad i could help :)  do have have the media for download for your latest sample?<br><br>as for ragdoll, ive never done it before.  im probably way off but here are the steps i would think you need to take:<br><br>a) set animation speed to 0 to stop the animation at the current frame<br><br>b) for each joint, call the getJointNode() method for the model and use those nodes to build your newton ragdoll.  these are specific to the model type and are getXJointNode(), getMS3DJointNode(), getB3DJointNode().<br><br>c) run the ragdoll simulation<br><br>good luck :)  also you can search the Irrlicht forum for rag and doll and see if there is anything that can help you out in there. <br><br></td></tr></table><br>
<a name="753149"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll upload the media when I get some time on my Linux machine, the only (and very awkward) setup I have for uploading things.<br><br>Oh, and I'm also having trouble getting a collision tree to run callbacks.  Is there some reason that doesn't work? <br><br></td></tr></table><br>
<a name="754403"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uploaded full example (improved from the code given here) with binaries included.  Get it at <a href="HTTP://www.rattuscanisdev.g0dsoft.com/irrlicht/" target="_blank">HTTP://www.rattuscanisdev.g0dsoft.com/irrlicht/</a><br><br>TAR and BZIP2 unpacking tools required.  I reccomend ArK or 7zip <br><br></td></tr></table><br>
<a name="754713"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Currently uploading the same example in a .tar.gz format archive.  I do this because I know alot of people probably won't want to dig for a .bz2 compatible archiver (I just found out 7zip won't do .bz2) <br><br></td></tr></table><br>
<a name="754858"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see the newton wrapper code but how do I build it into a module? <br><br></td></tr></table><br>
<a name="755041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's how to build modules:<br><br>1) Save the the code in a file called:  [bmax install dir]/mod/pub.mod/newton.mod/newton.bmx<br><br>2) Open a console window and navigate to [bmax install dir]/bin/<br><br>3) Type: bmk makemods pub.newton<br><br>Hope this helps! :) <br><br></td></tr></table><br>
<a name="755077"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chroma</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> The newton.mod, is that just a regular folder I make and then rename it to that?<br><br>EDIT: nm I got it thanks. <br><br></td></tr></table><br>
<a name="755294"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> How's the physics stuff going, Chroma? <br><br></td></tr></table><br>
<a name="774622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >verfum</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this the only thread on this subject, it's been a while before anyone has posted here, just curious if this continued elsewhere.<br><br>Is it possible yet to animate the character and use the collisions, it only works on frame 1. <br><br></td></tr></table><br>
<a name="774981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ninjarat</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmm.  I suppose if you tweaked it to run collisions on every frame, for now it uses a still mesh, so maybe just try to run it on every frame? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
