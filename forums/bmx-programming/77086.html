<!DOCTYPE html><html lang="en" ><head ><title >Bass Module?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Bass Module?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Bass Module?</a><br><br>
<a name="862430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is there a complete Bass (audio) module? I remember trying a couple, but they were both missing a few functions which were tricky to wrap, and if that's the case, I might just as well write my own and be positive I haven't missed anything I'll need. <br><br></td></tr></table><br>
<a name="862805"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so assuming there isn't one, does anyone want one? Seems like there isn't much interest, so I don't want to make my module very fancy or complete unless there's actually anyone who's going to use it apart from me. <br><br></td></tr></table><br>
<a name="862868"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> What features do you need in a bass module? <br><br></td></tr></table><br>
<a name="862891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >CGV</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think a lot of people would use it but the blitz forums are crawling with FMOD fanboys so you won't get many responses here.<br><br>I've never understood the preference for FMOD, Bass is just as good, it's now cross platform and it requires just a one time fee to use it in all your projects.<br><br>So why keep paying FMOD over and over again for each project? <br><br></td></tr></table><br>
<a name="862892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Streaming audio. <br><br></td></tr></table><br>
<a name="862893"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> What features do you need in a bass module?  <br></div><br>3D sound and streaming audio.<br><br>CGV: You're probably right. I couldn't agree more about the licensing. The FMod licenses is very restrictive, whereas the Bass license seems to have been rewritten recently, and is certainly very attractive now.<br><br>Well we'll see where I get. I've started converting the C headers over.<br><br>BTW: If anyone can help me convert this to BlitzMax constant definitions, it would be very handy.<br><br>#define BASS_SPEAKER_N(n)	((n)&lt;&lt;24)	// n'th pair of speakers (max 15)<br><br>I'm thinking Const BASS_SPEAKER_1:Int = 1 Shl 24, etc, but I'm not sure if that's right, or if I'm right to ignore the zero index. <br><br></td></tr></table><br>
<a name="862895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice EAX effects? <br><br></td></tr></table><br>
<a name="862901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I used this to design my own simple bass wrapper. I don't know if it would be compatible with the latest versions.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Const BassDllName:String = "bass.dll"
Global BassDllHandle = LoadLibraryA(BassDllName)
Rem
Bass.dll Version 2.1 Blitz Max Portierung von Suco-X
Sollten Fehler gefunden werden, bitte bei mir im BlitzForum Melden(PN oder im bass Thread)
Version 1.1
Mfg Suco
End Rem

' Error codes returned by BASS_ErrorGetCode
Const BASS_OK            = 0   ' all is OK
Const BASS_ERROR_MEM      =1   ' memory error
Const BASS_ERROR_FILEOPEN   =2   ' can't open the file
Const BASS_ERROR_DRIVER   =3   ' can't find a free/valid driver
Const BASS_ERROR_BUFLOST   =4   ' the sample buffer was lost
Const BASS_ERROR_HANDLE   =5   ' invalid handle
Const BASS_ERROR_FORMAT   =6   ' unsupported sample format
Const BASS_ERROR_POSITION   =7   ' invalid playback position
Const BASS_ERROR_INIT      =8   ' BASS_Init has Not been successfully called
Const BASS_ERROR_START   =9   ' BASS_Start has Not been successfully called
Const BASS_ERROR_ALREADY   =14   ' already initialized/paused/whatever
Const BASS_ERROR_NOPAUSE   =16   ' Not paused
Const BASS_ERROR_NOCHAN   =18   ' can't get a free channel
Const BASS_ERROR_ILLTYPE   =19   ' an illegal Type was specified
Const BASS_ERROR_ILLPARAM   =20   ' an illegal parameter was specified
Const BASS_ERROR_NO3D      =21   ' no 3D support
Const BASS_ERROR_NOEAX   =22   ' no EAX support
Const BASS_ERROR_DEVICE   =23   ' illegal device number
Const BASS_ERROR_NOPLAY   =24   ' Not playing
Const BASS_ERROR_FREQ      =25   ' illegal sample rate
Const BASS_ERROR_NOTFILE   =27   ' the stream is Not a file stream
Const BASS_ERROR_NOHW      =29   ' no hardware voices available
Const BASS_ERROR_EMPTY   =31   ' the Mod music has no sequence data
Const BASS_ERROR_NONET   =32   ' no internet connection could be opened
Const BASS_ERROR_CREATE   =33   ' couldn't create the file
Const BASS_ERROR_NOFX      =34   ' effects are Not available
Const BASS_ERROR_PLAYING   =35   ' the channel is playing
Const BASS_ERROR_NOTAVAIL   =37   ' requested data is Not available
Const BASS_ERROR_DECODE   =38   ' the channel is a "decoding channel"
Const BASS_ERROR_DX      =39   ' a sufficient DirectX version is Not installed
Const BASS_ERROR_TIMEOUT   =40   ' connection timedout
Const BASS_ERROR_FILEFORM   =41   ' unsupported file format
Const BASS_ERROR_SPEAKER   =42   ' unavailable speaker
Const BASS_ERROR_UNKNOWN   =-1   ' some other mystery error

' Initialization flags
Const BASS_DEVICE_8BITS    = 1   ' use 8 bit resolution, Else 16 bit
Const BASS_DEVICE_MONO    = 2   ' use mono, Else stereo
Const BASS_DEVICE_3D    =   4   ' enable 3D functionality

Rem
If the BASS_DEVICE_3D flag is Not specified when initilizing BASS,
Then the 3D flags (BASS_SAMPLE_3D And BASS_MUSIC_3D) are ignored when
loading/creating a sample/stream/music.
End Rem

Const BASS_DEVICE_LATENCY   = 256   ' calculate device latency (BASS_INFO struct)
Const BASS_DEVICE_SPEAKERS = 2048   ' force enabling of speaker assignment

' DirectSound interfaces (For use with BASS_GetDSoundObject)
Const BASS_OBJECT_DS   =   1   ' IDirectSound
Const BASS_OBJECT_DS3DL   =   2   ' IDirectSound3DListener

Type BASS_INFO
   Field size:Int      ' size of this struct (set this before calling the Function)
   Field flags:Int   ' device capabilities (DSCAPS_xxx flags)
   Field hwsize:Int   ' size of total device hardware memory
   Field hwfree:Int   ' size of free device hardware memory
   Field freesam:Int   ' number of free sample slots in the hardware
   Field free3d:Int   ' number of free 3D sample slots in the hardware
   Field minrate:Int   ' Min sample rate supported by the hardware
   Field maxrate:Int   ' Max sample rate supported by the hardware
   Field eax:Byte      ' device supports EAX? (always False If BASS_DEVICE_3D was Not used)
   Field minbuf:Int   ' recommended minimum buffer length in ms (requires BASS_DEVICE_LATENCY)
   Field dsver:Int   ' DirectSound version
   Field latency:Int   ' Delay (in ms) before start of playback (requires BASS_DEVICE_LATENCY)
   Field initflags:Int ' "flags" parameter of BASS_Init call
   Field speakers:Int ' number of speakers available
   Field driver:Byte Ptr   ' driver
End Type


' BASS_INFO flags (from DSOUND.H)
Const DSCAPS_CONTINUOUSRATE   = $00000010
Rem
supports all sample rates between Min/maxrate
End Rem
Const DSCAPS_EMULDRIVER      =$00000020
Rem
device does Not have hardware DirectSound support
End Rem
Const DSCAPS_CERTIFIED   =   $00000040
Rem
device driver has been certified by Microsoft
End Rem
Rem
The following flags tell what Type of samples are supported by HARDWARE
mixing, all these formats are supported by SOFTWARE mixing
End Rem
Const DSCAPS_SECONDARYMONO   =$00000100   ' mono
Const DSCAPS_SECONDARYSTEREO   =$00000200   ' stereo
Const DSCAPS_SECONDARY8BIT   =$00000400   ' 8 bit
Const DSCAPS_SECONDARY16BIT=   $00000800   ' 16 bit

Type BASS_RECORDINFO
   Field size:Int      ' size of this struct (set this before calling the Function)
   Field flags:Int   ' device capabilities (DSCCAPS_xxx flags)
   Field formats:Int   ' supported standard formats (WAVE_FORMAT_xxx flags)
   Field inputs:Int   ' number of inputs
   Field singlein:Byte   ' True = only 1 Input can be set at a time
   Field driver:Byte Ptr   ' driver
End Type


' BASS_RECORDINFO flags (from DSOUND.H)
Const DSCCAPS_EMULDRIVER   = DSCAPS_EMULDRIVER
Rem
device does Not have hardware DirectSound recording support
End Rem
Const DSCCAPS_CERTIFIED =    DSCAPS_CERTIFIED
Rem
device driver has been certified by Microsoft
End Rem

' defines For formats Field of BASS_RECORDINFO (from MMSYSTEM.H)

Const WAVE_FORMAT_1M08   =    $00000001       ' 11.025 kHz, Mono,   8-bit 
Const WAVE_FORMAT_1S08   =    $00000002       ' 11.025 kHz, Stereo, 8-bit 
Const WAVE_FORMAT_1M16   =    $00000004       ' 11.025 kHz, Mono,   16-bit
Const WAVE_FORMAT_1S16    =   $00000008       ' 11.025 kHz, Stereo, 16-bit
Const WAVE_FORMAT_2M08   =    $00000010       ' 22.05  kHz, Mono,   8-bit   
Const WAVE_FORMAT_2S08  =     $00000020       ' 22.05  kHz, Stereo, 8-bit 
Const WAVE_FORMAT_2M16   =    $00000040       ' 22.05  kHz, Mono,   16-bit
Const WAVE_FORMAT_2S16   =    $00000080       ' 22.05  kHz, Stereo, 16-bit
Const WAVE_FORMAT_4M08   =    $00000100       ' 44.1   kHz, Mono,   8-bit
Const WAVE_FORMAT_4S08   =    $00000200       ' 44.1   kHz, Stereo, 8-bit   
Const WAVE_FORMAT_4M16   =    $00000400       ' 44.1   kHz, Mono,   16-bit 
Const WAVE_FORMAT_4S16   =    $00000800       ' 44.1   kHz, Stereo, 16-bit 


' Sample info structure &amp; flags

Type BASS_SAMPLE
   Field freq:Int      ' Default playback rate
   Field volume:Int   ' Default volume (0-100)
   Field Pan:Int      ' Default pan (-100=Left, 0=middle, 100=Right)
   Field flags:Int   ' BASS_SAMPLE_xxx flags
   Field length:Int   ' length (in samples, Not bytes)
   Field Max_:Int      ' maximum simultaneous playbacks
   Field origres:Int   ' original resolution bits
Rem
The following are the sample's default 3D attributes (if the sample
is 3D, BASS_SAMPLE_3D is in flags) see BASS_ChannelSet3DAttributes
End Rem
   Field mode3d:Int   ' BASS_3DMODE_xxx mode
   Field mindist:Float   ' minimum distance
   Field maxdist:Float   ' maximum distance
   Field iangle:Int   ' angle of inside projection cone
   Field oangle:Int   ' angle of outside projection cone
   Field outvol:Int   ' delta-volume outside the projection cone
Rem
The following are the defaults used If the sample uses the DirectX 7
voice allocation/management features.
End Rem
   Field vam:Int      ' voice allocation/management flags (BASS_VAM_xxx)
   Field priority:Int   ' priority (0=lowest, $ffffffff=highest)
End Type


Const BASS_SAMPLE_8BITS    =   1   ' 8 bit
Const BASS_SAMPLE_FLOAT   =   256   ' 32-bit floating-point
Const BASS_SAMPLE_MONO   =   2   ' mono, Else stereo
Const BASS_SAMPLE_LOOP   =   4   ' looped
Const BASS_SAMPLE_3D      =   8   ' 3D functionality enabled
Const BASS_SAMPLE_SOFTWARE   =16   ' it's NOT using hardware mixing
Const BASS_SAMPLE_MUTEMAX   =   32   ' muted at Max distance (3D only)
Const BASS_SAMPLE_VAM      =   64   ' uses the DX7 voice allocation &amp; management
Const BASS_SAMPLE_FX      =   128   ' old implementation of DX8 effects are enabled
Const BASS_SAMPLE_OVER_VOL =   $10000   ' override lowest volume
Const BASS_SAMPLE_OVER_POS   = $20000   ' override longest playing
Const BASS_SAMPLE_OVER_DIST =   $30000 ' override furthest from listener (3D only)

Const BASS_MP3_SETPOS      =   $20000 ' enable pin-point seeking on the MP3/MP2/MP1

Const BASS_STREAM_AUTOFREE   =$40000   ' automatically free the stream when it stop/ends
Const BASS_STREAM_RESTRATE   =$80000   ' restrict the download rate of internet file streams
Const BASS_STREAM_BLOCK      =$100000' download/play internet file stream in small blocks
Const BASS_STREAM_DECODE   =   $200000' don't play the stream, only decode (BASS_ChannelGetData)
Const BASS_STREAM_META      =$400000' request metadata from a Shoutcast stream
Const BASS_STREAM_STATUS      =$800000' give server status info (HTTP/ICY tags) in DOWNLOADPROC

Const BASS_MUSIC_FLOAT   =   BASS_SAMPLE_FLOAT ' 32-bit floating-point
Const BASS_MUSIC_MONO      =   BASS_SAMPLE_MONO ' force mono mixing (less CPU usage)
Const BASS_MUSIC_LOOP      =   BASS_SAMPLE_LOOP ' loop music
Const BASS_MUSIC_3D      =   BASS_SAMPLE_3D ' enable 3D functionality
Const BASS_MUSIC_FX      =   BASS_SAMPLE_FX ' enable old implementation of DX8 effects
Const BASS_MUSIC_AUTOFREE   =   BASS_STREAM_AUTOFREE ' automatically free the music when it stop/ends
Const BASS_MUSIC_DECODE      =BASS_STREAM_DECODE ' don't play the music, only decode (BASS_ChannelGetData)
Const BASS_MUSIC_RAMP      =   $200   ' normal ramping
Const BASS_MUSIC_RAMPS      =$400   ' sensitive ramping
Const BASS_MUSIC_SURROUND   =   $800   ' surround sound
Const BASS_MUSIC_SURROUND2=   $1000   ' surround sound (mode 2)
Const BASS_MUSIC_FT2MOD      =$2000   ' play .Mod as FastTracker 2 does
Const BASS_MUSIC_PT1MOD      =$4000   ' play .Mod as ProTracker 1 does
Const BASS_MUSIC_CALCLEN   =   $8000   ' calculate playback length
Const BASS_MUSIC_NONINTER      =$10000   ' non-interpolated mixing
Const BASS_MUSIC_POSRESET      =$20000   ' stop all notes when moving position
Const BASS_MUSIC_POSRESETEX   =$400000' stop all notes And reset bmp/etc when moving position
Const BASS_MUSIC_STOPBACK   =   $80000   ' stop the music on a backwards jump effect
Const BASS_MUSIC_NOSAMPLE      =$100000' don't load the samples

' Speaker assignment flags
Const BASS_SPEAKER_FRONT   =$1000000   ' front speakers
Const BASS_SPEAKER_REAR   =$2000000   ' rear/side speakers
Const BASS_SPEAKER_CENLFE   =$3000000   ' center &amp; LFE speakers (5.1)
Const BASS_SPEAKER_REAR2   =$4000000   ' rear center speakers (7.1)
'Const BASS_SPEAKER_N(n)   ((n)&lt;&lt;24)   ' n'th pair of speakers (max 15)
Const BASS_SPEAKER_LEFT   =$10000000   ' modifier: Left
Const BASS_SPEAKER_RIGHT   =$20000000   ' modifier: Right
Const BASS_SPEAKER_FRONTLEFT   =BASS_SPEAKER_FRONT|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_FRONTRIGHT   =BASS_SPEAKER_FRONT|BASS_SPEAKER_RIGHT
Const BASS_SPEAKER_REARLEFT   =BASS_SPEAKER_REAR|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_REARRIGHT   =BASS_SPEAKER_REAR|BASS_SPEAKER_RIGHT
Const BASS_SPEAKER_CENTER      =BASS_SPEAKER_CENLFE|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_LFE      =BASS_SPEAKER_CENLFE|BASS_SPEAKER_RIGHT
Const BASS_SPEAKER_REAR2LEFT   =BASS_SPEAKER_REAR2|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_REAR2RIGHT   =BASS_SPEAKER_REAR2|BASS_SPEAKER_RIGHT

Const BASS_UNICODE         =$80000000

Const BASS_RECORD_PAUSE      =$8000   ' start recording paused

' DX7 voice allocation flags
Const BASS_VAM_HARDWARE   =   1
Rem
Play the sample in hardware. If no hardware voices are available Then
the "play" call will fail
End Rem
Const BASS_VAM_SOFTWARE      =2
Rem
Play the sample in software (ie. non-accelerated). No other VAM flags
may be used together with this flag.
End Rem

' DX7 voice management flags
Rem
These flags enable hardware resource stealing... If the hardware has no
available voices, a currently playing buffer will be stopped To make room For
the New buffer. NOTE: only samples loaded/created with the BASS_SAMPLE_VAM
flag are considered For termination by the DX7 voice management.
End Rem
Const BASS_VAM_TERM_TIME   =   4
Rem
If there are no free hardware voices, the buffer To be terminated will be
the one with the least time Left To play.
End Rem
Const BASS_VAM_TERM_DIST   =   8
Rem
If there are no free hardware voices, the buffer To be terminated will be
one that was loaded/created with the BASS_SAMPLE_MUTEMAX flag And is beyond
it's max distance. If there are no buffers that match this criteria, then the
"play" call will fail.
End Rem
Const BASS_VAM_TERM_PRIO   =   16
Rem
If there are no free hardware voices, the buffer To be terminated will be

the one with the lowest priority.
End Rem

Type BASS_CHANNELINFO
   Field freq:Int      ' Default playback rate
   Field chans:Int   ' channels
   Field flags:Int   ' BASS_SAMPLE/STREAM/MUSIC/SPEAKER flags
   Field ctype:Int   ' Type of channel
   Field origres:Int   ' original resolution
End Type

' BASS_CHANNELINFO types
Const BASS_CTYPE_SAMPLE    =   1
Const BASS_CTYPE_RECORD   =   2
Const BASS_CTYPE_STREAM      =$10000
Const BASS_CTYPE_STREAM_WAV   =$10001
Const BASS_CTYPE_STREAM_OGG   =$10002
Const BASS_CTYPE_STREAM_MP1   =$10003
Const BASS_CTYPE_STREAM_MP2   =$10004
Const BASS_CTYPE_STREAM_MP3=   $10005
Const BASS_CTYPE_MUSIC_MOD   =$20000
Const BASS_CTYPE_MUSIC_MTM   =$20001
Const BASS_CTYPE_MUSIC_S3M   =$20002
Const BASS_CTYPE_MUSIC_XM      =$20003
Const BASS_CTYPE_MUSIC_IT      =$20004
Const BASS_CTYPE_MUSIC_MO3   =$00100 ' mo3 flag

' 3D vector (For 3D positions/velocities/orientations)
Type BASS_3DVECTOR
   Field x:Float   ' +=Right, -=Left
   Field y:Float   ' +=up, -=down
   Field z:Float   ' +=front, -=behind
End Type


' 3D channel modes
Const BASS_3DMODE_NORMAL   =   0
Rem
normal 3D processing end rem
Const BASS_3DMODE_RELATIVE   1
rem The channel's 3D position (position/velocity/orientation) are relative to
the listener. When the listener's position/velocity/orientation is changed
with BASS_Set3DPosition, the channel's position relative to the listener does
Not change.
End Rem
Const BASS_3DMODE_OFF      =   2
Rem
Turn off 3D processing on the channel, the sound will be played
in the center.
End Rem


Rem
' EAX environments, use with BASS_SetEAXParameters
enum
{
    EAX_ENVIRONMENT_GENERIC,
    EAX_ENVIRONMENT_PADDEDCELL,
    EAX_ENVIRONMENT_ROOM,
    EAX_ENVIRONMENT_BATHROOM,
    EAX_ENVIRONMENT_LIVINGROOM,
    EAX_ENVIRONMENT_STONEROOM,
    EAX_ENVIRONMENT_AUDITORIUM,
    EAX_ENVIRONMENT_CONCERTHALL,
    EAX_ENVIRONMENT_CAVE,
    EAX_ENVIRONMENT_ARENA,
    EAX_ENVIRONMENT_HANGAR,
    EAX_ENVIRONMENT_CARPETEDHALLWAY,
    EAX_ENVIRONMENT_HALLWAY,
    EAX_ENVIRONMENT_STONECORRIDOR,
    EAX_ENVIRONMENT_ALLEY,
    EAX_ENVIRONMENT_FOREST,
    EAX_ENVIRONMENT_CITY,
    EAX_ENVIRONMENT_MOUNTAINS,
    EAX_ENVIRONMENT_QUARRY,
    EAX_ENVIRONMENT_PLAIN,
    EAX_ENVIRONMENT_PARKINGLOT,
    EAX_ENVIRONMENT_SEWERPIPE,
    EAX_ENVIRONMENT_UNDERWATER,
    EAX_ENVIRONMENT_DRUGGED,
    EAX_ENVIRONMENT_DIZZY,
    EAX_ENVIRONMENT_PSYCHOTIC,

    EAX_ENVIRONMENT_COUNT         ' total number of environments
};

End Rem


Const     EAX_ENVIRONMENT_GENERIC = 0
Const     EAX_ENVIRONMENT_PADDEDCELL = 1
Const     EAX_ENVIRONMENT_ROOM = 2
Const     EAX_ENVIRONMENT_BATHROOM = 3
Const     EAX_ENVIRONMENT_LIVINGROOM = 4
Const     EAX_ENVIRONMENT_STONEROOM = 5
Const     EAX_ENVIRONMENT_AUDITORIUM = 6
Const     EAX_ENVIRONMENT_CONCERTHALL = 7
Const     EAX_ENVIRONMENT_CAVE = 8
Const     EAX_ENVIRONMENT_ARENA = 9
Const     EAX_ENVIRONMENT_HANGAR = 10
Const     EAX_ENVIRONMENT_CARPETEDHALLWAY = 11
Const     EAX_ENVIRONMENT_HALLWAY = 12
Const     EAX_ENVIRONMENT_STONECORRIDOR = 13
Const     EAX_ENVIRONMENT_ALLEY = 14
Const     EAX_ENVIRONMENT_FOREST = 15
Const     EAX_ENVIRONMENT_CITY = 16
Const     EAX_ENVIRONMENT_MOUNTAINS = 17
Const     EAX_ENVIRONMENT_QUARRY = 18
Const     EAX_ENVIRONMENT_PLAIN = 19
Const     EAX_ENVIRONMENT_PARKINGLOT = 20
Const     EAX_ENVIRONMENT_SEWERPIPE = 21
Const     EAX_ENVIRONMENT_UNDERWATER = 22
Const     EAX_ENVIRONMENT_DRUGGED = 23
Const     EAX_ENVIRONMENT_DIZZY = 24
Const     EAX_ENVIRONMENT_PSYCHOTIC = 25

Const     EAX_ENVIRONMENT_COUNT    = 26      ' total number of environments


Rem

' EAX presets, usage: BASS_SetEAXParameters(EAX_PRESET_xxx)
Const EAX_PRESET_GENERIC         EAX_ENVIRONMENT_GENERIC,0.5F,1.493F,0.5F
Const EAX_PRESET_PADDEDCELL      EAX_ENVIRONMENT_PADDEDCELL,0.25F,0.1F,0.0F
Const EAX_PRESET_ROOM            EAX_ENVIRONMENT_ROOM,0.417F,0.4F,0.666F
Const EAX_PRESET_BATHROOM        EAX_ENVIRONMENT_BATHROOM,0.653F,1.499F,0.166F
Const EAX_PRESET_LIVINGROOM      EAX_ENVIRONMENT_LIVINGROOM,0.208F,0.478F,0.0F
Const EAX_PRESET_STONEROOM       EAX_ENVIRONMENT_STONEROOM,0.5F,2.309F,0.888F
Const EAX_PRESET_AUDITORIUM      EAX_ENVIRONMENT_AUDITORIUM,0.403F,4.279F,0.5F
Const EAX_PRESET_CONCERTHALL     EAX_ENVIRONMENT_CONCERTHALL,0.5F,3.961F,0.5F
Const EAX_PRESET_CAVE            EAX_ENVIRONMENT_CAVE,0.5F,2.886F,1.304F
Const EAX_PRESET_ARENA           EAX_ENVIRONMENT_ARENA,0.361F,7.284F,0.332F
Const EAX_PRESET_HANGAR          EAX_ENVIRONMENT_HANGAR,0.5F,10.0F,0.3F
Const EAX_PRESET_CARPETEDHALLWAY EAX_ENVIRONMENT_CARPETEDHALLWAY,0.153F,0.259F,2.0F
Const EAX_PRESET_HALLWAY         EAX_ENVIRONMENT_HALLWAY,0.361F,1.493F,0.0F
Const EAX_PRESET_STONECORRIDOR   EAX_ENVIRONMENT_STONECORRIDOR,0.444F,2.697F,0.638F
Const EAX_PRESET_ALLEY           EAX_ENVIRONMENT_ALLEY,0.25F,1.752F,0.776F
Const EAX_PRESET_FOREST          EAX_ENVIRONMENT_FOREST,0.111F,3.145F,0.472F
Const EAX_PRESET_CITY            EAX_ENVIRONMENT_CITY,0.111F,2.767F,0.224F
Const EAX_PRESET_MOUNTAINS       EAX_ENVIRONMENT_MOUNTAINS,0.194F,7.841F,0.472F
Const EAX_PRESET_QUARRY          EAX_ENVIRONMENT_QUARRY,1.0F,1.499F,0.5F
Const EAX_PRESET_PLAIN           EAX_ENVIRONMENT_PLAIN,0.097F,2.767F,0.224F
Const EAX_PRESET_PARKINGLOT      EAX_ENVIRONMENT_PARKINGLOT,0.208F,1.652F,1.5F
Const EAX_PRESET_SEWERPIPE       EAX_ENVIRONMENT_SEWERPIPE,0.652F,2.886F,0.25F
Const EAX_PRESET_UNDERWATER      EAX_ENVIRONMENT_UNDERWATER,1.0F,1.499F,0.0F
Const EAX_PRESET_DRUGGED         EAX_ENVIRONMENT_DRUGGED,0.875F,8.392F,1.388F
Const EAX_PRESET_DIZZY           EAX_ENVIRONMENT_DIZZY,0.139F,17.234F,0.666F
Const EAX_PRESET_PSYCHOTIC       EAX_ENVIRONMENT_PSYCHOTIC,0.486F,7.563F,0.806F
End Rem
' software 3D mixing algorithm modes (used with BASS_Set3DAlgorithm)
Const BASS_3DALG_DEFAULT   = 0

Rem

Default algorithm (currently translates To BASS_3DALG_OFF)
End Rem

Const BASS_3DALG_OFF   =   1
Rem
Uses normal Left And Right panning. The vertical axis is ignored except For
scaling of volume due To distance. Doppler shift And volume scaling are still
applied, but the 3D filtering is Not performed. This is the most CPU efficient
software implementation, but provides no virtual 3D audio effect. Head Related
Transfer Function processing will Not be done. Since only normal stereo panning
is used, a channel using this algorithm may be accelerated by a 2D hardware
voice If no free 3D hardware voices are available.
End Rem
Const BASS_3DALG_FULL   =   2
Rem
This algorithm gives the highest quality 3D audio effect, but uses more CPU.
Requires Windows 98 2nd Edition Or Windows 2000 that uses WDM drivers, If this
mode is Not available Then BASS_3DALG_OFF will be used instead.
End Rem
Const BASS_3DALG_LIGHT =   3
Rem
This algorithm gives a good 3D audio effect, And uses less CPU than the FULL
mode. Requires Windows 98 2nd Edition Or Windows 2000 that uses WDM drivers, If
this mode is Not available Then BASS_3DALG_OFF will be used instead.
End Rem

'typedef DWORD (CALLBACK STREAMPROC)(HSTREAM handle, void *buffer, DWORD length, DWORD user)

Rem
User stream callback function. NOTE: A stream Function should obviously be as quick
as possible, other streams (And Mod musics) can't be mixed until it's finished.
handle : The stream that needs writing
buffer : Buffer To write the samples in
length : Number of bytes To write
user   : The 'user' parameter value given when calling BASS_StreamCreate
Return : Number of bytes written. Set the BASS_STREAMPROC_END flag To End
         the stream.
 End Rem

Const BASS_STREAMPROC_END   =   $80000000   ' End of user stream flag

' BASS_StreamGetFilePosition modes
Const BASS_FILEPOS_DECODE   =   0
Const BASS_FILEPOS_DOWNLOAD=   1
Const BASS_FILEPOS_END      =2
Const BASS_FILEPOS_START      =3

' STREAMFILEPROC actions
Const BASS_FILE_CLOSE   =   0
Const BASS_FILE_READ      =1
Const BASS_FILE_QUERY      =2
Const BASS_FILE_LEN      =3
Const BASS_FILE_SEEK      =4

'typedef DWORD (CALLBACK STREAMFILEPROC)(DWORD action, DWORD param1, DWORD param2, DWORD user);
Rem
User file stream callback function.
action : The action To perform, one of BASS_FILE_xxx values.
param1 : Depends on "action"
param2 : Depends on "action"
user   : The 'user' parameter value given when calling BASS_StreamCreate
Return : Depends on "action"
End Rem

'typedef void (CALLBACK DOWNLOADPROC)(void *buffer, DWORD length, DWORD user);
Rem
Internet stream download callback function.
buffer : Buffer containing the downloaded data... Null=End of download
length : Number of bytes in the buffer
user   : The 'user' parameter value given when calling BASS_StreamCreateURL
End Rem

Rem
Sync types (with BASS_ChannelSetSync "param" And SYNCPROC "data"
definitions) &amp; flags.
End Rem
Const BASS_SYNC_MUSICPOS =   0
Const BASS_SYNC_POS    =   0
Rem
Sync when a channel reaches a position.
If HMUSIC...
param: LOWORD=order (0=first, -1=all) HIWORD=row (0=first, -1=all)
data : LOWORD=order HIWORD=row
If HSTREAM...
param: position in bytes
data : Not used
End Rem
Const BASS_SYNC_MUSICINST   =1
Rem
Sync when an instrument (sample For the non-instrument based formats)
is played in a music (Not including retrigs).
param: LOWORD=instrument (1=first) HIWORD=note (0=c0...119=b9, -1=all)
data : LOWORD=note HIWORD=volume (0-64)
End Rem
Const BASS_SYNC_END      =2
Rem
Sync when a channel reaches the end.
param: Not used
data : 1 = the sync is triggered by a backward jump in a Mod music, otherwise Not used
End Rem
Const BASS_SYNC_MUSICFX   =3
Rem
Sync when the "sync" effect (XM/MTM/Mod: E8x/Wxx, IT/S3M: S2x) is used.
param: 0:data=pos, 1:data="x" value
data : param=0: LOWORD=order HIWORD=row, param=1: "x" value
End Rem
Const BASS_SYNC_META   =   4
Rem
Sync when metadata is received in a Shoutcast stream.
param: Not used
data : pointer To the metadata
End Rem
Const BASS_SYNC_SLIDE   =   5
Rem
Sync when an attribute slide is completed.
param: Not used
data : the Type of slide completed (one of the BASS_SLIDE_xxx values)
End Rem
Const BASS_SYNC_STALL   =   6
Rem
Sync when playback has stalled.
param: Not used
data : 0=stalled, 1=resumed
End Rem
Const BASS_SYNC_DOWNLOAD   =7
Rem
Sync when downloading of an internet (Or "buffered" user file) stream has ended.
param: Not used
data : Not used
End Rem
Const BASS_SYNC_FREE =   8
Rem
Sync when a channel is freed.
param: Not used
data : Not used
End Rem
Const BASS_SYNC_MESSAGE   =$20000000   ' FLAG: post a Windows message (instead of callback)
Rem
When using a window message "callback", the message To post is given in the "proc"
parameter of BASS_ChannelSetSync, And is posted To the window specified in the BASS_Init
call. The message parameters are: WPARAM = data, LPARAM = user.
 End Rem
Const BASS_SYNC_MIXTIME   =$40000000   ' FLAG: sync at mixtime, Else at playtime
Const BASS_SYNC_ONETIME   =$80000000   ' FLAG: sync only once, Else continuously

'typedef void (CALLBACK SYNCPROC)(HSYNC handle, DWORD channel, DWORD data, DWORD user);
Rem
Sync callback function. NOTE: a sync callback Function should be very
quick as other syncs can't be processed until it has finished. If the sync
is a "mixtime" sync, Then other streams And Mod musics can't be mixed until
it's finished either.
handle : The sync that has occured
channel: Channel that the sync occured in
data   : Additional data associated with the sync's occurance
user   : The 'user' parameter given when calling BASS_ChannelSetSync
End Rem

'typedef void (CALLBACK DSPPROC)(HDSP handle, DWORD channel, void *buffer, DWORD length, DWORD user);
Rem
DSP callback function. NOTE: A DSP Function should obviously be as quick as
possible... other DSP functions, streams And Mod musics can Not be processed
Until it's finished.
handle : The DSP handle
channel: Channel that the DSP is being applied To
buffer : Buffer To apply the DSP To
length : Number of bytes in the buffer
user   : The 'user' parameter given when calling BASS_ChannelSetDSP
End Rem

'typedef BOOL (CALLBACK RECORDPROC)(HRECORD handle, void *buffer, DWORD length, DWORD user);
Rem
Recording callback function.
handle : The recording handle
buffer : Buffer containing the recorded sample data
length : Number of bytes
user   : The 'user' parameter value given when calling BASS_RecordStart
Return : True = Continue recording, False = stop
End Rem

' BASS_ChannelGetData flags
Const BASS_DATA_AVAILABLE   =0         ' query how much data is buffered
Const BASS_DATA_FFT512   =$80000000   ' 512 sample FFT
Const BASS_DATA_FFT1024   =$80000001   ' 1024 FFT
Const BASS_DATA_FFT2048   =$80000002   ' 2048 FFT
Const BASS_DATA_FFT4096 =   $80000003   ' 4096 FFT
Const BASS_DATA_FFT_INDIVIDUAL =$10   ' FFT flag: FFT For each channel, Else all combined
Const BASS_DATA_FFT_NOWINDOW   =$20   ' FFT flag: no Hanning window

' BASS_StreamGetTags types : what's returned
Const BASS_TAG_ID3      =0   ' ID3v1 tags : 128 Byte block
Const BASS_TAG_ID3V2      =1   ' ID3v2 tags : variable length block
Const BASS_TAG_OGG      =2   ' OGG comments : array of Null-terminated strings
Const BASS_TAG_HTTP      =3   ' HTTP headers : array of Null-terminated strings
Const BASS_TAG_ICY      =4   ' ICY headers : array of Null-terminated strings
Const BASS_TAG_META      =5   ' ICY metadata : Null-terminated String

' BASS_MusicSet/GetAttribute options
Const BASS_MUSIC_ATTRIB_AMPLIFY=   0
Const BASS_MUSIC_ATTRIB_PANSEP   =1
Const BASS_MUSIC_ATTRIB_PSCALER   =2
Const BASS_MUSIC_ATTRIB_BPM      =3
Const BASS_MUSIC_ATTRIB_SPEED   =   4
Const BASS_MUSIC_ATTRIB_VOL_GLOBAL =5
Const BASS_MUSIC_ATTRIB_VOL_CHAN   =$100 ' + channel #
Const BASS_MUSIC_ATTRIB_VOL_INST   =$200 ' + instrument #


Rem
' DX8 effect types, use with BASS_ChannelSetFX
enum
{
   BASS_FX_CHORUS,         ' GUID_DSFX_STANDARD_CHORUS
   BASS_FX_COMPRESSOR,      ' GUID_DSFX_STANDARD_COMPRESSOR
   BASS_FX_DISTORTION,      ' GUID_DSFX_STANDARD_DISTORTION
   BASS_FX_ECHO,         ' GUID_DSFX_STANDARD_ECHO
   BASS_FX_FLANGER,      ' GUID_DSFX_STANDARD_FLANGER
   BASS_FX_GARGLE,         ' GUID_DSFX_STANDARD_GARGLE
   BASS_FX_I3DL2REVERB,   ' GUID_DSFX_STANDARD_I3DL2REVERB
   BASS_FX_PARAMEQ,      ' GUID_DSFX_STANDARD_PARAMEQ
   BASS_FX_REVERB         ' GUID_DSFX_WAVES_REVERB
};
End Rem


Const    BASS_FX_CHORUS = 0         ' GUID_DSFX_STANDARD_CHORUS
Const   BASS_FX_COMPRESSOR = 1      ' GUID_DSFX_STANDARD_COMPRESSOR
Const   BASS_FX_DISTORTION = 2      ' GUID_DSFX_STANDARD_DISTORTION
Const   BASS_FX_ECHO = 3         ' GUID_DSFX_STANDARD_ECHO
Const   BASS_FX_FLANGER = 4      ' GUID_DSFX_STANDARD_FLANGER
Const   BASS_FX_GARGLE = 5         ' GUID_DSFX_STANDARD_GARGLE
Const   BASS_FX_I3DL2REVERB = 6   ' GUID_DSFX_STANDARD_I3DL2REVERB
Const   BASS_FX_PARAMEQ = 7      ' GUID_DSFX_STANDARD_PARAMEQ
Const   BASS_FX_REVERB = 8         ' GUID_DSFX_WAVES_REVERB


Type BASS_FXCHORUS
    Field      fWetDryMix:Float
    Field      fDepth:Float
    Field      fFeedback:Float
    Field      fFrequency:Float
    Field      lWaveform:Int   ' 0=triangle, 1=sine
    Field      fDelay:Float
    Field      lPhase:Int      ' BASS_FX_PHASE_xxx
End Type

Type BASS_FXCOMPRESSOR
    Field    fGain:Float
    Field    fAttack:Float
    Field    fRelease:Float
    Field    fThreshold:Float
    Field    fRatio:Float
    Field    fPredelay:Float
End Type

Type BASS_FXDISTORTION
    Field    fGain:Float
    Field    fEdge:Float
    Field    fPostEQCenterFrequency:Float
    Field    fPostEQBandwidth:Float
    Field    fPreLowpassCutoff:Float
End Type



Type BASS_FXECHO
    Field   fWetDryMix:Float
    Field   fFeedback:Float
    Field   fLeftDelay:Float
    Field   fRightDelay:Float
    Field   lPanDelay:Byte
End Type

Type BASS_FXFLANGER
    Field      fWetDryMix:Float
    Field       fDepth:Float
    Field       fFeedback:Float
    Field       fFrequency:Float
    Field       lWaveform:Int   ' 0=triangle, 1=sine
    Field       fDelay:Float
    Field      lPhase:Int      ' BASS_FX_PHASE_xxx
End Type


Type BASS_FXGARGLE
    Field       dwRateHz:Int               ' Rate of modulation in hz
    Field       dwWaveShape:Int            ' 0=triangle, 1=square
End Type   ' DSFXGargle

Type BASS_FXI3DL2REVERB
    Field     lRoom:Int                  ' [-10000, 0]      Default: -1000 mB
    Field     lRoomHF:Int               ' [-10000, 0]      Default: 0 mB
    Field   flRoomRolloffFactor:Float    ' [0.0, 10.0]      Default: 0.0
    Field   flDecayTime:Float            ' [0.1, 20.0]      Default: 1.49s
    Field   flDecayHFRatio:Float         ' [0.1, 2.0]       Default: 0.83
    Field     lReflections:Int           ' [-10000, 1000]   Default: -2602 mB
    Field   flReflectionsDelay:Float     ' [0.0, 0.3]       Default: 0.007 s
    Field     lReverb:Int                ' [-10000, 2000]   Default: 200 mB
    Field   flReverbDelay:Float          ' [0.0, 0.1]       Default: 0.011 s
    Field   flDiffusion:Float            ' [0.0, 100.0]     Default: 100.0 %
    Field   flDensity:Float              ' [0.0, 100.0]     Default: 100.0 %
    Field   flHFReference:Float          ' [20.0, 20000.0]  Default: 5000.0 Hz
End Type    ' DSFXI3DL2Reverb

Type BASS_FXPARAMEQ
    Field   fCenter:Float
    Field   fBandwidth:Float
    Field   fGain:Float
End Type       ' DSFXParamEq

Type BASS_FXREVERB
    Field   fInGain:Float                ' [-96.0,0.0]            Default: 0.0 dB
    Field   fReverbMix:Float             ' [-96.0,0.0]            Default: 0.0 db
    Field   fReverbTime:Float            ' [0.001,3000.0]         Default: 1000.0 ms
    Field   fHighFreqRTRatio:Float       ' [0.001,0.999]          Default: 0.001
End Type       ' DSFXWavesReverb

Const BASS_FX_PHASE_NEG_180      =  0
Const BASS_FX_PHASE_NEG_90       =  1
Const BASS_FX_PHASE_ZERO         =  2
Const BASS_FX_PHASE_90           =  3
Const BASS_FX_PHASE_180          =  4

' BASS_ChannelIsActive Return values
Const BASS_ACTIVE_STOPPED   =0
Const BASS_ACTIVE_PLAYING   =1
Const BASS_ACTIVE_STALLED   =2
Const BASS_ACTIVE_PAUSED   =3

' BASS_ChannelIsSliding Return flags
Const BASS_SLIDE_FREQ   =1
Const BASS_SLIDE_VOL   =2
Const BASS_SLIDE_PAN   =4

' BASS_RecordSetInput flags
Const BASS_INPUT_OFF   =   $10000
Const BASS_INPUT_ON      =$20000
Const BASS_INPUT_LEVEL   =$40000

Const BASS_INPUT_TYPE_MASK      =$ff000000
Const BASS_INPUT_TYPE_UNDEF      =$00000000
Const BASS_INPUT_TYPE_DIGITAL   =   $01000000
Const BASS_INPUT_TYPE_LINE      =$02000000
Const BASS_INPUT_TYPE_MIC      =   $03000000
Const BASS_INPUT_TYPE_SYNTH      =$04000000
Const BASS_INPUT_TYPE_CD      =   $05000000
Const BASS_INPUT_TYPE_PHONE      =$06000000
Const BASS_INPUT_TYPE_SPEAKER   =   $07000000
Const BASS_INPUT_TYPE_WAVE      =$08000000
Const BASS_INPUT_TYPE_AUX      =   $09000000
Const BASS_INPUT_TYPE_ANALOG      =$0a000000

' BASS_Set/GetConfig options
Const BASS_CONFIG_BUFFER      =   0
Const BASS_CONFIG_UPDATEPERIOD   =1
Const BASS_CONFIG_MAXVOL      =   3
Const BASS_CONFIG_GVOL_SAMPLE      =4
Const BASS_CONFIG_GVOL_STREAM      =5
Const BASS_CONFIG_GVOL_MUSIC      =6
Const BASS_CONFIG_CURVE_VOL      =7
Const BASS_CONFIG_CURVE_PAN      =8
Const BASS_CONFIG_FLOATDSP      =9
Const BASS_CONFIG_3DALGORITHM      =10
Const BASS_CONFIG_NET_TIMEOUT      =11
Const BASS_CONFIG_NET_BUFFER      =12
Const BASS_CONFIG_PAUSE_NOPLAY   =13
Const BASS_CONFIG_NET_NOPROXY      =14
Const BASS_CONFIG_NET_PREBUF      =15

Rem
'
Const BassDllName:String = "bass.dll"
Local BassDllHandle = LoadLibraryA(BassDllName)
If BassDllHandle = 0
   Assert BassDllHandle, "BASS.DLL konnte nicht geladen werden"
EndIf
'
End Rem
'
Global BASS_SetConfig(option:Int, value:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SetConfig")

'DWORD BASSDEF(BASS_SetConfig)(DWORD option, DWORD value);

Global BASS_GetConfig(option:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_GetConfig")

'DWORD BASSDEF(BASS_GetConfig)(DWORD option);

Global BASS_GetVersion()"Win32" = GetProcAddress(BassDllHandle,"BASS_GetVersion")

'DWORD BASSDEF(BASS_GetVersion)();


Global BASS_GetDeviceDescription:Byte Ptr(device:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_GetDeviceDescription")

'char *BASSDEF(BASS_GetDeviceDescription)(DWORD device);


Global BASS_ErrorGetCode()"Win32" = GetProcAddress(BassDllHandle,"BASS_ErrorGetCode")

'DWORD BASSDEF(BASS_ErrorGetCode)();



Global BASS_Init(device:Int, freq:Int, flags:Int, hwnd:Int, dsguid:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_Init")
Global BASS_Init2(device:Int, freq:Int, flags:Int, hwnd:Int, void:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_Init")

'BOOL BASSDEF(BASS_Init)(DWORD device, DWORD freq, DWORD flags, HWND win, Const GUID *dsguid);

Global BASS_SetDevice(device:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SetDevice")

'BOOL BASSDEF(BASS_SetDevice)(DWORD device);


Global BASS_GetDevice()"Win32" = GetProcAddress(BassDllHandle,"BASS_GetDevice")

'DWORD BASSDEF(BASS_GetDevice)();


Global BASS_Free()"Win32" = GetProcAddress(BassDllHandle,"BASS_Free")

'BOOL BASSDEF(BASS_Free)();



Global BASS_GetDSoundObject:Byte Ptr(obj:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_GetDSoundObject")

'void *BASSDEF(BASS_GetDSoundObject)(DWORD Object);




Global BASS_GetInfo(BASS_INFO_Info:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_GetInfo")

'BOOL BASSDEF(BASS_GetInfo)(BASS_INFO *info);


Global BASS_Update()"Win32" = GetProcAddress(BassDllHandle,"BASS_Update")

'BOOL BASSDEF(BASS_Update)();




Global BASS_GetCPU:Float()"Win32" = GetProcAddress(BassDllHandle,"BASS_GetCPU")

'Float BASSDEF(BASS_GetCPU)();



Global BASS_Start()"Win32" = GetProcAddress(BassDllHandle,"BASS_Start")

'BOOL BASSDEF(BASS_Start)();



Global BASS_Stop()"Win32" = GetProcAddress(BassDllHandle,"BASS_Stop")

'BOOL BASSDEF(BASS_Stop)();



Global BASS_Pause()"Win32" = GetProcAddress(BassDllHandle,"BASS_Pause")

'BOOL BASSDEF(BASS_Pause)();


Global BASS_SetVolume(volume:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SetVolume")

'BOOL BASSDEF(BASS_SetVolume)(DWORD volume);


Global BASS_GetVolume()"Win32" = GetProcAddress(BassDllHandle,"BASS_GetVolume")

'DWORD BASSDEF(BASS_GetVolume)();


Global BASS_Set3DFactors(distf:Float,rollf:Float, doppf:Float)"Win32" = GetProcAddress(BassDllHandle,"BASS_Set3DFactors")

'BOOL BASSDEF(BASS_Set3DFactors)(Float distf, Float rollf, Float doppf);



Global BASS_Get3DFactors(distf:Float Ptr, rollf:Float Ptr, doppf:Float Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_Get3DFactors")

'BOOL BASSDEF(BASS_Get3DFactors)(Float *distf, Float *rollf, Float *doppf);



Global BASS_Set3DPosition(BASS_3DVECTOR_Pos:Byte Ptr , BASS_3DVECTOR_Vel:Byte Ptr,  BASS_3DVECTOR_Front:Byte Ptr, BASS_3DVECTOR_Top:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_Set3DPosition")

'BOOL BASSDEF(BASS_Set3DPosition)(Const BASS_3DVECTOR *pos, Const BASS_3DVECTOR *vel, Const BASS_3DVECTOR *front, Const BASS_3DVECTOR *top);





Global BASS_Get3DPosition(BASS_3DVECTOR_Pos:Byte Ptr , BASS_3DVECTOR_Vel:Byte Ptr,  BASS_3DVECTOR_Front:Byte Ptr, BASS_3DVECTOR_Top:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_Get3DPosition")


'BOOL BASSDEF(BASS_Get3DPosition)(BASS_3DVECTOR *pos, BASS_3DVECTOR *vel, BASS_3DVECTOR *front, BASS_3DVECTOR *top);




Global BASS_Apply3D()"Win32" = GetProcAddress(BassDllHandle,"BASS_Apply3D")

'void BASSDEF(BASS_Apply3D)();



Global BASS_SetEAXParameters(env:Int, vol:Float, decay:Float, damp:Float)"Win32" = GetProcAddress(BassDllHandle,"BASS_SetEAXParameters")

'BOOL BASSDEF(BASS_SetEAXParameters)(Int env, Float vol, Float decay, Float damp);




Global BASS_GetEAXParameters(env:Int Ptr, vol:Float Ptr, decay:Float Ptr, damp:Float Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_GetEAXParameters")

'BOOL BASSDEF(BASS_GetEAXParameters)(DWORD *env, Float *vol, Float *decay, Float *damp);






Global BASS_MusicLoad(mem:Int, file:Byte Ptr, offset:Int, length:Int, flags:Int, freq:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_MusicLoad")

'HMUSIC BASSDEF(BASS_MusicLoad)(BOOL mem, Const void *file, DWORD offset, DWORD length, DWORD flags, DWORD freq);



Global BASS_MusicFree(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_MusicFree")

'BOOL BASSDEF(BASS_MusicFree)(HMUSIC handle);




Global BASS_MusicGetName:Byte Ptr(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_MusicGetName")

'char *BASSDEF(BASS_MusicGetName)(HMUSIC handle);



Global BASS_MusicGetLength(handle:Int, playlen:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_MusicGetLength")

'DWORD BASSDEF(BASS_MusicGetLength)(HMUSIC handle, BOOL playlen);



Global BASS_MusicSetAttribute(handle:Int, attrib:Int, value:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_MusicSetAttribute")


'DWORD BASSDEF(BASS_MusicSetAttribute)(HMUSIC handle, DWORD attrib, DWORD value);




Global BASS_MusicGetAttribute(handle:Int, attrib:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_MusicGetAttribute")

'DWORD BASSDEF(BASS_MusicGetAttribute)(HMUSIC handle, DWORD attrib);





Global BASS_SampleLoad(mem:Int, file:Byte Ptr, offset:Int, length:Int, Max_:Int, flags:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleLoad")

'HSAMPLE BASSDEF(BASS_SampleLoad)(BOOL mem, Const void *file, DWORD offset, DWORD length, DWORD Max, DWORD flags);




Global BASS_SampleCreate:Byte Ptr(length:Int, freq:Int, Max_:Int, flags:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleCreate")

'void* BASSDEF(BASS_SampleCreate)(DWORD length, DWORD freq, DWORD Max, DWORD flags);



Global BASS_SampleCreateDone()"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleCreateDone")

'HSAMPLE BASSDEF(BASS_SampleCreateDone)();




Global BASS_SampleFree(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleFree")

'BOOL BASSDEF(BASS_SampleFree)(HSAMPLE handle);





Global BASS_SampleGetInfo(handle:Int, BASS_SAMPLE_Info:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleGetInfo")

'BOOL BASSDEF(BASS_SampleGetInfo)(HSAMPLE handle, BASS_SAMPLE *info);





Global BASS_SampleSetInfo(handle:Int, BASS_SAMPLE_Info:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleSetInfo")

'BOOL BASSDEF(BASS_SampleSetInfo)(HSAMPLE handle, Const BASS_SAMPLE *info);



Global BASS_SampleGetChannel(handle:Int, onlynew:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleGetChannel")

'HCHANNEL BASSDEF(BASS_SampleGetChannel)(HSAMPLE handle, BOOL onlynew);




Global BASS_SampleStop(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_SampleStop")

'BOOL BASSDEF(BASS_SampleStop)(HSAMPLE handle);





Global BASS_StreamCreate(freq:Int, chans:Int, flags:Int, proc:Byte Ptr, user:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamCreate")

'HSTREAM BASSDEF(BASS_StreamCreate)(DWORD freq, DWORD chans, DWORD flags, STREAMPROC *proc, DWORD user);




Global BASS_StreamCreateFile(mem:Int, file:Byte Ptr, offset:Int, length:Int, flags:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamCreateFile")

'HSTREAM BASSDEF(BASS_StreamCreateFile)(BOOL mem, Const void *file, DWORD offset, DWORD length, DWORD flags);




Global BASS_StreamCreateURL(url$z, offset:Int, flags:Int, proc:Byte Ptr, user:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamCreateURL")

'HSTREAM BASSDEF(BASS_StreamCreateURL)(Const char *url, DWORD offset, DWORD flags, DOWNLOADPROC *proc, DWORD user);




Global BASS_StreamCreateFileUser(buffered:Int, flags:Int, proc:Byte Ptr, user:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamCreateFileUser")

'HSTREAM BASSDEF(BASS_StreamCreateFileUser)(BOOL buffered, DWORD flags, STREAMFILEPROC *proc, DWORD user);





Global BASS_StreamFree(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamFree")

'BOOL BASSDEF(BASS_StreamFree)(HSTREAM handle);






Global BASS_StreamGetLength:Long(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamGetLength")

'QWORD BASSDEF(BASS_StreamGetLength)(HSTREAM handle);




Global BASS_StreamGetTags:Byte Ptr(handle:Int, tags:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamGetTags")

'char *BASSDEF(BASS_StreamGetTags)(HSTREAM handle, DWORD tags);



Global BASS_StreamGetFilePosition(handle:Int, mode:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_StreamGetFilePosition")

'DWORD BASSDEF(BASS_StreamGetFilePosition)(HSTREAM handle, DWORD mode);




Global BASS_RecordGetDeviceDescription:Byte Ptr(device:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordGetDeviceDescription")

'char *BASSDEF(BASS_RecordGetDeviceDescription)(DWORD device);




Global BASS_RecordInit(device:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordInit")

'BOOL BASSDEF(BASS_RecordInit)(DWORD device);






Global BASS_RecordSetDevice(device:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordSetDevice")

'BOOL BASSDEF(BASS_RecordSetDevice)(DWORD device);





Global BASS_RecordGetDevice()"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordGetDevice")

'DWORD BASSDEF(BASS_RecordGetDevice)();



Global BASS_RecordFree()"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordFree")

'BOOL BASSDEF(BASS_RecordFree)();




Global BASS_RecordGetInfo(BASS_RECORDINFO_Info:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordGetInfo")

'BOOL BASSDEF(BASS_RecordGetInfo)(BASS_RECORDINFO *info);





Global BASS_RecordGetInputName:Byte Ptr(Input_:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordGetInputName")

'char *BASSDEF(BASS_RecordGetInputName)(DWORD Input);





Global BASS_RecordSetInput(Input_:Int, setting:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordSetInput")


'BOOL BASSDEF(BASS_RecordSetInput)(DWORD Input, DWORD setting);






Global BASS_RecordGetInput(Input_:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordGetInput")

'DWORD BASSDEF(BASS_RecordGetInput)(DWORD Input);




Global BASS_RecordStart(freq:Int, chans:Int, flags:Int, proc:Byte Ptr, user:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_RecordStart")

'HRECORD BASSDEF(BASS_RecordStart)(DWORD freq, DWORD chans, DWORD flags, RECORDPROC *proc, DWORD user);






Global BASS_ChannelBytes2Seconds:Float(handle:Int, pos:Long)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelBytes2Seconds")

'Float BASSDEF(BASS_ChannelBytes2Seconds)(DWORD handle, QWORD pos);





Global BASS_ChannelSeconds2Bytes:Long(handle:Int, pos:Float)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSeconds2Bytes")

'QWORD BASSDEF(BASS_ChannelSeconds2Bytes)(DWORD handle, Float pos);






Global BASS_ChannelGetDevice(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetDevice")

'DWORD BASSDEF(BASS_ChannelGetDevice)(DWORD handle);






Global BASS_ChannelIsActive(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelIsActive")

'DWORD BASSDEF(BASS_ChannelIsActive)(DWORD handle);




Global BASS_ChannelGetInfo(handle:Int, BASS_CHANNELINFO_Info:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetInfo")

'BOOL BASSDEF(BASS_ChannelGetInfo)(DWORD handle, BASS_CHANNELINFO *info);






Global BASS_ChannelSetFlags(handle:Int, flags:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetFlags")

'BOOL BASSDEF(BASS_ChannelSetFlags)(DWORD handle, DWORD flags);




Global BASS_ChannelPreBuf(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelPreBuf")

'BOOL BASSDEF(BASS_ChannelPreBuf)(DWORD handle);




Global BASS_ChannelPlay(handle:Int, restart:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelPlay")


'BOOL BASSDEF(BASS_ChannelPlay)(DWORD handle, BOOL restart);





Global BASS_ChannelStop(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelStop")

'BOOL BASSDEF(BASS_ChannelStop)(DWORD handle);





Global BASS_ChannelPause(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelPause")

'BOOL BASSDEF(BASS_ChannelPause)(DWORD handle);






Global BASS_ChannelSetAttributes(handle:Int, freq:Int, volume:Int, pan:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetAttributes")

'BOOL BASSDEF(BASS_ChannelSetAttributes)(DWORD handle, Int freq, Int volume, Int pan);






Global BASS_ChannelGetAttributes(handle:Int, freq:Int Ptr, volume:Int Ptr, pan:Int Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetAttributes")

'BOOL BASSDEF(BASS_ChannelGetAttributes)(DWORD handle, DWORD *freq, DWORD *volume, Int *pan);






Global BASS_ChannelSlideAttributes(handle:Int, freq:Int, volume:Int , pan:Int, time:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSlideAttributes")

'BOOL BASSDEF(BASS_ChannelSlideAttributes)(DWORD handle, Int freq, Int volume, Int pan, DWORD time);




Global BASS_ChannelIsSliding(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelIsSliding")

'DWORD BASSDEF(BASS_ChannelIsSliding)(DWORD handle);






Global BASS_ChannelSet3DAttributes(handle:Int, mode:Int, Min_:Float, Max_:Float, iangle:Int, oangle:Int, outvol:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSet3DAttributes")

'BOOL BASSDEF(BASS_ChannelSet3DAttributes)(DWORD handle, Int mode, Float Min, Float Max, Int iangle, Int oangle, Int outvol);






Global BASS_ChannelGet3DAttributes(handle:Int, mode:Int Ptr, Min_:Float Ptr, Max_:Float Ptr, iangle:Int Ptr, oangle:Int Ptr, outvol:Int Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGet3DAttributes")

'BOOL BASSDEF(BASS_ChannelGet3DAttributes)(DWORD handle, DWORD *mode, Float *Min, Float *Max, DWORD *iangle, DWORD *oangle, DWORD *outvol);





Global BASS_ChannelSet3DPosition(handle:Int, BASS_3DVECTOR_Pos:Byte Ptr, BASS_3DVECTOR_Orient:Byte Ptr, BASS_3DVECTOR_Vel:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSet3DPosition")

'BOOL BASSDEF(BASS_ChannelSet3DPosition)(DWORD handle, Const BASS_3DVECTOR *pos, Const BASS_3DVECTOR *orient, Const BASS_3DVECTOR *vel);



Global BASS_ChannelGet3DPosition(handle:Int, BASS_3DVECTOR_Pos:Byte Ptr, BASS_3DVECTOR_Orient:Byte Ptr, BASS_3DVECTOR_Vel:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGet3DPosition")

'BOOL BASSDEF(BASS_ChannelGet3DPosition)(DWORD handle, BASS_3DVECTOR *pos, BASS_3DVECTOR *orient, BASS_3DVECTOR *vel);




Global BASS_ChannelSetPosition(handle:Int, pos:Long)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetPosition")

'BOOL BASSDEF(BASS_ChannelSetPosition)(DWORD handle, QWORD pos);



Global BASS_ChannelGetPosition:Long(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetPosition")

'QWORD BASSDEF(BASS_ChannelGetPosition)(DWORD handle);





Global BASS_ChannelGetLevel(handle:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetLevel")

'DWORD BASSDEF(BASS_ChannelGetLevel)(DWORD handle);




Global BASS_ChannelGetData(handle:Int, buffer:Byte Ptr, length:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetData")

'DWORD BASSDEF(BASS_ChannelGetData)(DWORD handle, void *buffer, DWORD length);





Global BASS_ChannelSetSync(handle:Int, Type_:Int, param:Long, proc:Byte Ptr, user:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetSync")

'HSYNC BASSDEF(BASS_ChannelSetSync)(DWORD handle, DWORD Type, QWORD param, SYNCPROC *proc, DWORD user);




Global BASS_ChannelRemoveSync(handle:Int, sync:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelRemoveSync")

'BOOL BASSDEF(BASS_ChannelRemoveSync)(DWORD handle, HSYNC sync);




Global BASS_ChannelSetDSP(handle:Int, proc:Byte Ptr, user:Int, priority:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetDSP")

'HDSP BASSDEF(BASS_ChannelSetDSP)(DWORD handle, DSPPROC *proc, DWORD user, Int priority);




Global BASS_ChannelRemoveDSP(handle:Int, dsp:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelRemoveDSP")

'BOOL BASSDEF(BASS_ChannelRemoveDSP)(DWORD handle, HDSP dsp);




Global BASS_ChannelSetFX(handle:Int, type_:Int, priority:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetFX")

'HFX BASSDEF(BASS_ChannelSetFX)(DWORD handle, DWORD Type, DWORD priority);






Global BASS_ChannelRemoveFX(handle:Int, fx:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelRemoveFX")

'BOOL BASSDEF(BASS_ChannelRemoveFX)(DWORD handle, HFX fx);



Global BASS_ChannelSetEAXMix(handle:Int, mix:Float)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetEAXMix")

'BOOL BASSDEF(BASS_ChannelSetEAXMix)(DWORD handle, Float mix);




Global BASS_ChannelGetEAXMix(handle:Int, mix:Float Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelGetEAXMix")

'BOOL BASSDEF(BASS_ChannelGetEAXMix)(DWORD handle, Float *mix);




Global BASS_ChannelSetLink(handle:Int, chan:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelSetLink")

'BOOL BASSDEF(BASS_ChannelSetLink)(DWORD handle, DWORD chan);



Global BASS_ChannelRemoveLink(handle:Int, chan:Int)"Win32" = GetProcAddress(BassDllHandle,"BASS_ChannelRemoveLink")

'BOOL BASSDEF(BASS_ChannelRemoveLink)(DWORD handle, DWORD chan);



Global BASS_FXSetParameters(handle:Int, par:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_FXSetParameters")

'BOOL BASSDEF(BASS_FXSetParameters)(HFX handle, Const void *par);



Global BASS_FXGetParameters(handle:Int, par:Byte Ptr)"Win32" = GetProcAddress(BassDllHandle,"BASS_FXGetParameters")

'BOOL BASSDEF(BASS_FXGetParameters)(HFX handle, void *par);





Function LoWord:Short(Value:Int)
   Return Value &amp; $0000FFFF
End Function


Function HiWord:Short(Value:Int)
   Return (Value &amp; $FFFF0000) Shr 16
End Function



Function StripTags:String[](Data:Byte Ptr)
   
   Local TempArray:String[]
   Local TempChar
   Local NewString:String
   
   For Local i:Int = 0 Until 128
   
      If Data[i] = 0
         Continue
      EndIf
      
      NewString = ""
      
      Repeat
         TempChar = Data[i]
      
         If TempChar = 0
            Exit
         EndIf
         
         NewString:+Chr(TempChar)
         
         i:+1
      Forever TempChar=0
      
      NewString = Trim(NewString)
      
      If NewString.length&gt;0
         TempArray = TempArray[..TempArray.length+1]
         TempArray[TempArray.length-1] = NewString
      EndIf
      
   Next
   
   Return TempArray
End Function</textarea> <br><br></td></tr></table><br>
<a name="863017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MrTAToad</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> The problem is BASS is that there isn't a Linux version (hence the reason why FMOD is used).<br><br>My FightTune originally used BASS, and thus I created the following interface code:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">/*
 *  BASS.c
 *  BASS
 *
 *  Created by Nicholas Kingsley on 20/07/2007.
 *  Copyright 2007 __MyCompanyName__. All rights reserved.
 *
 */

//#define WIN32

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "math.h"

#ifdef WIN32
	// Windows
	#define BASSDEF(f) (WINAPI *f) // define the functions as pointers
	#include "c:\program files\BASS\c\bass.h"
	HINSTANCE bass=NULL;
#else
	// OSX Version
	#include "/Developer/bass23-osx/bass.h"
#endif

BASS_CHANNELINFO	channelInfo;
int specpos;
int diff[4];

//----------System
extern DWORD BASSGetVersion(void)
{
	return BASSVERSION;
}

extern char BASSInitialise(int device,int freq,int flags,DWORD windowHandle)
{
	memset(&amp;channelInfo,(char) 0,sizeof(channelInfo));
	specpos=0;
	memset(&amp;diff,(char) 0,sizeof(diff));

#ifdef WIN32
	bass=LoadLibrary("BASS.DLL"); // load BASS
	if (bass)
	{
		BASS_Init=GetProcAddress(bass,"BASS_Init"); // get BASS_Init
		if (BASS_Init)
		{
			BASS_Free=GetProcAddress(bass,"BASS_Free");
			//BASS_GetVersion=GetProcAddress(bass,"BASS_GetVersion");
			BASS_Start=GetProcAddress(bass,"BASS_Start");
			BASS_ErrorGetCode=GetProcAddress(bass,"BASS_ErrorGetCode");
			BASS_SampleLoad=GetProcAddress(bass,"BASS_SampleLoad");
			BASS_SampleGetChannel=GetProcAddress(bass,"BASS_SampleGetChannel");
			BASS_SampleStop=GetProcAddress(bass,"BASS_SampleStop");
			BASS_StreamCreateFile=GetProcAddress(bass,"BASS_StreamCreateFile");
			BASS_ChannelPlay=GetProcAddress(bass,"BASS_ChannelPlay");
			BASS_ChannelPause=GetProcAddress(bass,"BASS_ChannelPause");
			BASS_ChannelGetPosition=GetProcAddress(bass,"BASS_ChannelGetPosition");
			BASS_ChannelPreBuf=GetProcAddress(bass,"BASS_ChannelPreBuf");
			BASS_StreamFree=GetProcAddress(bass,"BASS_StreamFree");
			BASS_ChannelGetLength=GetProcAddress(bass,"BASS_ChannelGetLength");
			BASS_ChannelGetInfo=GetProcAddress(bass,"BASS_ChannelGetInfo");
			BASS_ChannelGetData=GetProcAddress(bass,"BASS_ChannelGetData");
			BASS_ChannelIsActive=GetProcAddress(bass,"BASS_ChannelIsActive");
			BASS_ChannelStop=GetProcAddress(bass,"BASS_ChannelStop");
			BASS_ChannelSetPosition=GetProcAddress(bass,"BASS_ChannelSetPosition");
			BASS_ChannelSetAttributes=GetProcAddress(bass,"BASS_ChannelSetAttributes");
			BASS_ChannelBytes2Seconds=GetProcAddress(bass,"BASS_ChannelBytes2Seconds");
			BASS_ChannelGetTags=GetProcAddress(bass,"BASS_ChannelGetTags");
			return BASS_Init(device,freq,flags,(HWND) windowHandle,NULL);
		}
		else
		{
			BASS_Free=NULL;
			BASS_ErrorGetCode=NULL;
		}
	}
	
	return -1;
#else
	return BASS_Init(device,freq,flags,0,NULL);
#endif
}

extern char BASSStart()
{
	return BASS_Start();
}

extern int BASSErrorGetCode(void)
{
	if (BASS_ErrorGetCode)
	{
		return BASS_ErrorGetCode();
	}
	else
	{
		return -1;
	}
}

extern char BASSFree(void)
{
BOOL result;

	if (BASS_Free)
	{
		result=BASS_Free();
	}
	else
	{
		result=-1;
	}

#ifdef WIN32
	FreeLibrary(bass);
	bass=NULL;
#endif
	return (char) result;
}

extern char *BASSGetDeviceDescription(DWORD device)
{
	return (char *) BASS_GetDeviceDescription(device);
}

//------------Samples
extern DWORD BASSSampleLoad(char *fileName,DWORD offset,DWORD length,DWORD max,DWORD flags)
{
	return (DWORD) BASS_SampleLoad(0,fileName,offset,length,max,flags);
}

//------------Streams
extern DWORD BASSStreamCreateFile(char *fileName,DWORD offset,DWORD length,DWORD flags)
{
	return ((DWORD) BASS_StreamCreateFile(0,fileName,offset,length,flags));
}

extern char BASSStreamFree(DWORD handle)
{
	return BASS_StreamFree((HSTREAM) handle);
}

extern DWORD BASSSampleGetChannel(DWORD handle,char onlyNew)
{
	return (DWORD) BASS_SampleGetChannel((HSAMPLE) handle,(BOOL) onlyNew);
}

extern char BASSSampleStop(DWORD handle)
{
	return BASS_SampleStop(handle);
}

//------------Channels
extern char BASSChannelPlay(DWORD handle,char restart)
{
	return BASS_ChannelPlay(handle,restart);
}

extern char BASSChannelPause(DWORD handle)
{
	return BASS_ChannelPause(handle);
}

extern QWORD BASSChannelGetPosition(DWORD handle)
{
	return BASS_ChannelGetPosition(handle);
}

extern char BASSChannelSetPosition(DWORD handle,QWORD position)
{
	return BASS_ChannelSetPosition(handle,position);
}

extern QWORD BASSChannelGetLength(DWORD handle)
{
	return BASS_ChannelGetLength(handle);
}

extern char BASSGetChannelInfo(DWORD handle)
{
	return BASS_ChannelGetInfo(handle,&amp;channelInfo);
}

extern char BASSChannelGetData(DWORD handle,char *buffer,DWORD length)
{
	return BASS_ChannelGetData(handle,buffer,length);
}

extern DWORD BASSChannelIsActive(DWORD handle)
{
	return BASS_ChannelIsActive(handle);
}

extern char BASSChannelStop(DWORD handle)
{
	return BASS_ChannelStop(handle);
}

extern char BASSChannelSetAttributes(DWORD handle,int freq,int volume,int pan)
{
	return BASS_ChannelSetAttributes(handle,freq,volume,pan);
}

extern DWORD BASSChannelBytes2Seconds(DWORD handle,QWORD pos)
{
float length;

	// Cant return a float for some reason to BlitzMax
	length=BASS_ChannelBytes2Seconds(handle,pos);
	return (DWORD) length;
}

extern char *BASSChannelGetTags(DWORD handle,DWORD tags)
{
	return BASS_ChannelGetTags(handle,tags);
}

extern char BASSChannelPreBuf(DWORD handle,DWORD length)
{
	return BASS_ChannelPreBuf(handle,length);
}

//-----------Get information from structures
extern DWORD BASS_ReturnNumberOfChannels(void)
{
	return channelInfo.chans;
}

extern DWORD BASS_ReturnPlaybackFreq(void)
{
	return channelInfo.freq;
}

extern DWORD BASS_ReturnFlags(void)
{
	return channelInfo.flags;
}

extern DWORD BASS_ReturnCType(void)
{
	return channelInfo.ctype;
}

extern DWORD BASS_ReturnOriginalResolution(void)
{
	return channelInfo.origres;
}

extern void BASS_ClearDiff(void)
{
	memset(&amp;diff,(char) 0,sizeof(diff));
}

extern DWORD BASS_Spectrograph5(DWORD handle,DWORD diffValue,char *storeSpec,DWORD SPECHEIGHT,DWORD BANDS)
{
register int b0,x,sc,b1,y;
float fft[1024];
float sum;
DWORD	result;

	result=0;
	if (BASS_ChannelGetData(handle,fft,BASS_DATA_FFT2048))
	{
		b0=0;
		for (x=0;x&lt;BANDS;x++) 
		{
			sum=0.0;
			
			b1=pow(2,x*10.0/(BANDS-1));
			if (b1&gt;1023) 
			{
				b1=1023;
			}
			
			if (b1&lt;=b0) 
			{
				b1=b0+1; // make sure it uses at least 1 FFT bin
			}
			
			sc=10+b1-b0;
			for (;b0&lt;b1;b0++) 
			{
				sum+=fft[1+b0];
			}
			
			y=(int) ((sqrt(sum/log10(sc))*1.7*SPECHEIGHT)-4.0); // scale it
			y=(y&gt;SPECHEIGHT ? SPECHEIGHT : \
				y&lt;0 ? 0 : y); 
			
			*(storeSpec+x)=(char) y;
				
			if (labs(diff[x]-y)&gt;diffValue)
			{
				diff[x]=y;
				result=(x==0 ? result | 1 : \
						x==1 ? result | 2 : \
						x==2 ? result | 4 : result | 8);
			}
		}
	}

	return result;
}

extern void BASS_Spectrograph4(DWORD handle,DWORD SPECWIDTH,DWORD SPECHEIGHT,char *specBuff)
{
float fft[1024];
register int x,y;

	if (specBuff==NULL)	return;
	
	BASS_ChannelGetData(handle,fft,BASS_DATA_FFT2048); // get the FFT data
		
	for (x=0;x&lt;SPECHEIGHT;x++) 
	{
		y=sqrt(fft[x+1])*3*127; // scale it (sqrt to make low values more visible)
		if (y&gt;127) 
		{
			y=127; // cap it
		}
		
		specBuff[x*SPECWIDTH+specpos]=128+y; // plot it
	}
	
	// move marker onto next position
	specpos=(specpos+1)%SPECWIDTH;
	for (x=0;x&lt;SPECHEIGHT;x++) 
	{
		specBuff[x*SPECWIDTH+specpos]=255;
	}
}

extern void BASS_Spectrograph3(DWORD handle,DWORD SPECWIDTH,DWORD SPECHEIGHT,char *specBuff,DWORD BANDS)
{
register int b0,x,sc,b1,y;
float fft[1024];
float sum;

	if (specBuff==NULL)	return;
	
	BASS_ChannelGetData(handle,fft,BASS_DATA_FFT2048); // get the FFT data
	
	b0=0;
	memset(specBuff,0,SPECWIDTH*SPECHEIGHT);
	for (x=0;x&lt;BANDS;x++) 
	{
		sum=0.0;
		
		b1=pow(2,x*10.0/(BANDS-1));
		if (b1&gt;1023) 
		{
			b1=1023;
		}
		
		if (b1&lt;=b0) 
		{
			b1=b0+1; // make sure it uses at least 1 FFT bin
		}
		
		sc=10+b1-b0;
		for (;b0&lt;b1;b0++) 
		{
			sum+=fft[1+b0];
		}
		
		y=(sqrt(sum/log10(sc))*1.7*SPECHEIGHT)-4; // scale it
		if (y&gt;SPECHEIGHT) 
		{
			y=SPECHEIGHT; // cap it
		}
		
		while (--y&gt;=0)
		{
			memset(specBuff+y*SPECWIDTH+x*(SPECWIDTH/BANDS),y+1,SPECWIDTH/BANDS-2); // draw bar
		}
	}
}

extern void BASS_Spectrograph2(DWORD handle,DWORD SPECWIDTH,DWORD SPECHEIGHT,char *specBuff)
{
float fft[1024];
register int x,y,y1;

	if (specBuff==NULL)	return;
	
	BASS_ChannelGetData(handle,fft,BASS_DATA_FFT2048); // get the FFT data

	memset(specBuff,0,SPECWIDTH*SPECHEIGHT);
	for (x=0;x&lt;SPECWIDTH/2;x++) 
	{
		y=sqrt(fft[x+1])*3*SPECHEIGHT-4; // scale it (sqrt to make low values more visible)
//#else
//				y=fft[x+1]*10*SPECHEIGHT; // scale it (linearly)
//#endif
		if (y&gt;SPECHEIGHT) 
		{
			y=SPECHEIGHT; // cap it
		}
		
		if (x &amp;&amp; (y1=(y+y1)/2))
		{
			// interpolate from previous to make the display smoother
			while (--y1&gt;=0) 
			{
				specBuff[y1*SPECWIDTH+x*2-1]=y1+1;
			}
		}
		
		y1=y;
		while (--y&gt;=0)
		{
			specBuff[y*SPECWIDTH+x*2]=y+1; // draw level
		}
	}
}

extern void BASS_Spectrograph1(DWORD handle,DWORD SPECWIDTH,DWORD SPECHEIGHT,char *specBuff)
{
register int c,x,v,y;
float *buf;

	if (specBuff==NULL)	return;
	
	BASS_ChannelGetInfo(handle,&amp;channelInfo); 
	buf=alloca(channelInfo.chans*SPECWIDTH*sizeof(float)); // allocate buffer for data
	if (buf==NULL)
	{
		return;
	}
	
	BASS_ChannelGetData(handle,buf,(channelInfo.chans*SPECWIDTH*sizeof(float))|BASS_DATA_FLOAT);
	memset(specBuff,(char) 0,SPECWIDTH*SPECHEIGHT);
	y=0;
	for (c=0; c&lt;channelInfo.chans; c++) 
	{
		for (x=0;x&lt;SPECWIDTH;x++) 
		{
			v=(1-buf[x*channelInfo.chans+c])*SPECHEIGHT/2; // invert and scale to fit display
			if (v&lt;0) 
			{
				v=0;
			}
			else 
			if (v&gt;=SPECHEIGHT) 
			{
				v=SPECHEIGHT-1;
			}
			
			if (!x) 
			{
				y=v;
			}
			
			do { // draw line from previous sample...
				if (y&lt;v) 
				{
					y++;
				}
				else 
				if (y&gt;v) 
				{
					y--;
				}
					
				specBuff[y*SPECWIDTH+x]=c&amp;1?127:1; // left=green, right=red (could add more colours to palette for more chans)
			} while (y!=v);
		}
	}
}
</textarea><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' Bass constants
' Bass error messages
Const BASS_OK:Int=				0	' all is OK
Const BASS_ERROR_MEM:Int=		1	' memory error
Const BASS_ERROR_FILEOPEN:Int=	2	' can't open the file
Const BASS_ERROR_DRIVER:Int=	3	' can't find a free/valid driver
Const BASS_ERROR_BUFLOST:Int=	4	' the sample buffer was lost
Const BASS_ERROR_HANDLE:Int=	5	' invalid handle
Const BASS_ERROR_FORMAT:Int=	6	' unsupported sample format
Const BASS_ERROR_POSITION:Int=	7	' invalid playback position
Const BASS_ERROR_INIT:Int=		8	' BASS_Init has Not been successfully called
Const BASS_ERROR_START:Int=		9	' BASS_Start has Not been successfully called
Const BASS_ERROR_ALREADY:Int=	14	' already initialized/paused/whatever
Const BASS_ERROR_NOPAUSE:Int=	16	' Not paused
Const BASS_ERROR_NOCHAN:Int=	18	' can't get a free channel
Const BASS_ERROR_ILLTYPE:Int=	19	' an illegal Type was specified
Const BASS_ERROR_ILLPARAM:Int=	20	' an illegal parameter was specified
Const BASS_ERROR_NO3D:Int=		21	' no 3D support
Const BASS_ERROR_NOEAX:Int=		22	' no EAX support
Const BASS_ERROR_DEVICE:Int=	23	' illegal device number
Const BASS_ERROR_NOPLAY:Int=	24	' Not playing
Const BASS_ERROR_FREQ:Int=		25	' illegal sample rate
Const BASS_ERROR_NOTFILE:Int=	27	' the stream is Not a file stream
Const BASS_ERROR_NOHW:Int=		29	' no hardware voices available
Const BASS_ERROR_EMPTY:Int=		31	' the Mod music has no sequence data
Const BASS_ERROR_NONET:Int=		32	' no internet connection could be opened
Const BASS_ERROR_CREATE:Int=	33	' couldn't create the file
Const BASS_ERROR_NOFX:Int=		34	' effects are Not available
Const BASS_ERROR_PLAYING:Int=	35	' the channel is playing
Const BASS_ERROR_NOTAVAIL:Int=	37	' requested data is Not available
Const BASS_ERROR_DECODE:Int=	38	' the channel is a "decoding channel"
Const BASS_ERROR_DX:Int=		39	' a sufficient DirectX version is Not installed
Const BASS_ERROR_TIMEOUT:Int=	40	' connection timedout
Const BASS_ERROR_FILEFORM:Int=	41	' unsupported file format
Const BASS_ERROR_SPEAKER:Int=	42	' unavailable speaker
Const BASS_ERROR_VERSION:Int=	43	' invalid BASS version (used by add-ons)
Const BASS_ERROR_CODEC:Int=		44  ' codec is Not available/supported
Const BASS_ERROR_UNKNOWN:Int=	-1	' some other mystery error

' Initialisation variables
Const BASS_DEVICE_8BITS:Int=	1	' use 8 bit resolution, Else 16 bit
Const BASS_DEVICE_MONO:Int=		2	' use mono, Else stereo
Const BASS_DEVICE_3D:Int=		4	' enable 3D functionality

' If the BASS_DEVICE_3D flag is Not specified when initilizing BASS,

' Then the 3D flags (BASS_SAMPLE_3D And BASS_MUSIC_3D) are ignored when

' loading/creating a sample/stream/music.

Const BASS_DEVICE_LATENCY:Int=	256	' calculate device latency (BASS_INFO struct)
Const BASS_DEVICE_SPEAKERS:Int=	2048	' force enabling of speaker assignment
Const BASS_DEVICE_NOSPEAKER:Int=4096	' ignore speaker arrangement
Const BASS_SAMPLE_8BITS:Int=		1	' 8 bit
Const BASS_SAMPLE_FLOAT:Int=		256	' 32-bit floating-point
Const BASS_SAMPLE_MONO:Int=			2	' mono
Const BASS_SAMPLE_LOOP:Int=			4	' looped
Const BASS_SAMPLE_3D:Int=			8	' 3D functionality enabled
Const BASS_SAMPLE_SOFTWARE:Int=		16	' it's NOT using hardware mixing
Const BASS_SAMPLE_MUTEMAX:Int=		32	' muted at Max distance (3D only)
Const BASS_SAMPLE_VAM:Int=			64	' uses the DX7 voice allocation &amp; management
Const BASS_SAMPLE_FX:Int=			128	' old implementation of DX8 effects are enabled

Const BASS_SAMPLE_OVER_VOL:Int=		$10000	' override lowest volume
Const BASS_SAMPLE_OVER_POS:Int=		$20000	' override longest playing
Const BASS_SAMPLE_OVER_DIST:Int=	$30000 ' override furthest from listener (3D only)

Const BASS_STREAM_PRESCAN:Int=		$20000 ' enable pin-point seeking (MP3/MP2/MP1)
Const BASS_MP3_SETPOS:Int=			BASS_STREAM_PRESCAN
Const BASS_STREAM_AUTOFREE:Int=		$40000	' automatically free the stream when it stop/ends
Const BASS_STREAM_RESTRATE:Int=		$80000	' restrict the download rate of internet file streams
Const BASS_STREAM_BLOCK:Int=		$100000' download/play internet file stream in small blocks
Const BASS_STREAM_DECODE:Int=		$200000' don't play the stream, only decode (BASS_ChannelGetData)
Const BASS_STREAM_STATUS:Int=		$800000' give server status info (HTTP/ICY tags) in DOWNLOADPROC
Const BASS_MUSIC_FLOAT:Int=			BASS_SAMPLE_FLOAT ' 32-bit floating-point
Const BASS_MUSIC_MONO:Int=			BASS_SAMPLE_MONO ' force mono mixing (less CPU usage)
Const BASS_MUSIC_LOOP:Int=			BASS_SAMPLE_LOOP ' loop music
Const BASS_MUSIC_3D:Int=			BASS_SAMPLE_3D ' enable 3D functionality
Const BASS_MUSIC_FX:Int=			BASS_SAMPLE_FX ' enable old implementation of DX8 effects
Const BASS_MUSIC_AUTOFREE:Int=		BASS_STREAM_AUTOFREE ' automatically free the music when it stop/ends
Const BASS_MUSIC_DECODE:Int=		BASS_STREAM_DECODE ' don't play the music, only decode (BASS_ChannelGetData)
Const BASS_MUSIC_PRESCAN:Int=		BASS_STREAM_PRESCAN	' calculate playback length
Const BASS_MUSIC_CALCLEN:Int=		BASS_MUSIC_PRESCAN
Const BASS_MUSIC_RAMP:Int=			$200	' normal ramping
Const BASS_MUSIC_RAMPS:Int=			$400	' sensitive ramping
Const BASS_MUSIC_SURROUND:Int=		$800	' surround sound
Const BASS_MUSIC_SURROUND2:Int=		$1000	' surround sound (mode 2)
Const BASS_MUSIC_FT2MOD:Int=		$2000	' play .Mod as FastTracker 2 does
Const BASS_MUSIC_PT1MOD:Int=		$4000	' play .Mod as ProTracker 1 does
Const BASS_MUSIC_NONINTER:Int=		$10000	' non-interpolated mixing
Const BASS_MUSIC_POSRESET:Int=		$8000	' stop all notes when moving position
Const BASS_MUSIC_POSRESETEX	:Int=	$400000' stop all notes And reset bmp/etc when moving position
Const BASS_MUSIC_STOPBACK:Int=		$80000	' stop the music on a backwards jump effect
Const BASS_MUSIC_NOSAMPLE:Int=		$100000' don't load the samples

' Speaker assignment flags

Const BASS_SPEAKER_FRONT:Int=		$1000000	' front speakers
Const BASS_SPEAKER_REAR:Int=		$2000000	' rear/side speakers
Const BASS_SPEAKER_CENLFE:Int=		$3000000	' center &amp; LFE speakers (5.1)
Const BASS_SPEAKER_REAR2:Int=		$4000000	' rear center speakers (7.1)
'Const BASS_SPEAKER_N(n)	((n)&lt;&lt;24)	' n'th pair of speakers (max 15)

Const BASS_SPEAKER_LEFT:Int=		$10000000	' modifier: Left
Const BASS_SPEAKER_RIGHT:Int=		$20000000	' modifier: Right
Const BASS_SPEAKER_FRONTLEFT:Int=	BASS_SPEAKER_FRONT|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_FRONTRIGHT:Int=	BASS_SPEAKER_FRONT|BASS_SPEAKER_RIGHT
Const BASS_SPEAKER_REARLEFT	:Int=	BASS_SPEAKER_REAR|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_REARRIGHT:Int=	BASS_SPEAKER_REAR|BASS_SPEAKER_RIGHT
Const BASS_SPEAKER_CENTER:Int=		BASS_SPEAKER_CENLFE|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_LFE:Int=			BASS_SPEAKER_CENLFE|BASS_SPEAKER_RIGHT
Const BASS_SPEAKER_REAR2LEFT:Int=	BASS_SPEAKER_REAR2|BASS_SPEAKER_LEFT
Const BASS_SPEAKER_REAR2RIGHT:Int=	BASS_SPEAKER_REAR2|BASS_SPEAKER_RIGHT

Const BASS_UNICODE:Int=			$80000000
Const BASS_RECORD_PAUSE:Int=		$8000	' start recording paused
Const BASS_DATA_FLOAT:Int=			$40000000

Const BASS_ACTIVE_STOPPED:Int=	0
Const BASS_ACTIVE_PLAYING:Int=	1
Const BASS_ACTIVE_STALLED:Int=	2
Const BASS_ACTIVE_PAUSED:Int=	3


' Bass error messages
Const BASS_OK:Int=				0	' all is OK

Const BASS_ERROR_MEM:Int=		1	' memory error

Const BASS_ERROR_FILEOPEN:Int=	2	' can't open the file

Const BASS_ERROR_DRIVER:Int=	3	' can't find a free/valid driver

Const BASS_ERROR_BUFLOST:Int=	4	' the sample buffer was lost

Const BASS_ERROR_HANDLE:Int=	5	' invalid handle

Const BASS_ERROR_FORMAT:Int=	6	' unsupported sample format

Const BASS_ERROR_POSITION:Int=	7	' invalid playback position

Const BASS_ERROR_INIT:Int=		8	' BASS_Init has Not been successfully called

Const BASS_ERROR_START:Int=		9	' BASS_Start has Not been successfully called

Const BASS_ERROR_ALREADY:Int=	14	' already initialized/paused/whatever

Const BASS_ERROR_NOPAUSE:Int=	16	' Not paused

Const BASS_ERROR_NOCHAN:Int=	18	' can't get a free channel

Const BASS_ERROR_ILLTYPE:Int=	19	' an illegal Type was specified

Const BASS_ERROR_ILLPARAM:Int=	20	' an illegal parameter was specified

Const BASS_ERROR_NO3D:Int=		21	' no 3D support

Const BASS_ERROR_NOEAX:Int=		22	' no EAX support

Const BASS_ERROR_DEVICE:Int=	23	' illegal device number

Const BASS_ERROR_NOPLAY:Int=	24	' Not playing

Const BASS_ERROR_FREQ:Int=		25	' illegal sample rate

Const BASS_ERROR_NOTFILE:Int=	27	' the stream is Not a file stream

Const BASS_ERROR_NOHW:Int=		29	' no hardware voices available

Const BASS_ERROR_EMPTY:Int=		31	' the Mod music has no sequence data

Const BASS_ERROR_NONET:Int=		32	' no internet connection could be opened

Const BASS_ERROR_CREATE:Int=	33	' couldn't create the file

Const BASS_ERROR_NOFX:Int=		34	' effects are Not available

Const BASS_ERROR_PLAYING:Int=	35	' the channel is playing

Const BASS_ERROR_NOTAVAIL:Int=	37	' requested data is Not available

Const BASS_ERROR_DECODE:Int=	38	' the channel is a "decoding channel"

Const BASS_ERROR_DX:Int=		39	' a sufficient DirectX version is Not installed

Const BASS_ERROR_TIMEOUT:Int=	40	' connection timedout

Const BASS_ERROR_FILEFORM:Int=	41	' unsupported file format

Const BASS_ERROR_SPEAKER:Int=	42	' unavailable speaker

Const BASS_ERROR_VERSION:Int=	43	' invalid BASS version (used by add-ons)

Const BASS_ERROR_CODEC:Int=		44  ' codec is Not available/supported

Const BASS_ERROR_UNKNOWN:Int=	-1	' some other mystery error

' Initialisation variables
Const BASS_DEVICE_8BITS:Int=	1	' use 8 bit resolution, Else 16 bit

Const BASS_DEVICE_MONO:Int=		2	' use mono, Else stereo

Const BASS_DEVICE_3D:Int=		4	' enable 3D functionality

' If the BASS_DEVICE_3D flag is Not specified when initilizing BASS,

' Then the 3D flags (BASS_SAMPLE_3D And BASS_MUSIC_3D) are ignored when

' loading/creating a sample/stream/music.

Const BASS_DEVICE_LATENCY:Int=	256	' calculate device latency (BASS_INFO struct)

Const BASS_DEVICE_SPEAKERS:Int=	2048	' force enabling of speaker assignment

Const BASS_DEVICE_NOSPEAKER:Int=4096	' ignore speaker arrangement

Const BASS_SAMPLE_8BITS:Int=		1	' 8 bit

Const BASS_SAMPLE_FLOAT:Int=		256	' 32-bit floating-point

Const BASS_SAMPLE_MONO:Int=			2	' mono

Const BASS_SAMPLE_LOOP:Int=			4	' looped

Const BASS_SAMPLE_3D:Int=			8	' 3D functionality enabled

Const BASS_SAMPLE_SOFTWARE:Int=		16	' it's NOT using hardware mixing

Const BASS_SAMPLE_MUTEMAX:Int=		32	' muted at Max distance (3D only)

Const BASS_SAMPLE_VAM:Int=			64	' uses the DX7 voice allocation &amp; management

Const BASS_SAMPLE_FX:Int=			128	' old implementation of DX8 effects are enabled

Const BASS_SAMPLE_OVER_VOL:Int=		$10000	' override lowest volume

Const BASS_SAMPLE_OVER_POS:Int=		$20000	' override longest playing

Const BASS_SAMPLE_OVER_DIST:Int=	$30000 ' override furthest from listener (3D only)



Const BASS_STREAM_PRESCAN:Int=		$20000 ' enable pin-point seeking (MP3/MP2/MP1)

Const BASS_MP3_SETPOS:Int=			BASS_STREAM_PRESCAN

Const BASS_STREAM_AUTOFREE:Int=		$40000	' automatically free the stream when it stop/ends

Const BASS_STREAM_RESTRATE:Int=		$80000	' restrict the download rate of internet file streams

Const BASS_STREAM_BLOCK:Int=		$100000' download/play internet file stream in small blocks

Const BASS_STREAM_DECODE:Int=		$200000' don't play the stream, only decode (BASS_ChannelGetData)

Const BASS_STREAM_STATUS:Int=		$800000' give server status info (HTTP/ICY tags) in DOWNLOADPROC



Const BASS_MUSIC_FLOAT:Int=			BASS_SAMPLE_FLOAT ' 32-bit floating-point

Const BASS_MUSIC_MONO:Int=			BASS_SAMPLE_MONO ' force mono mixing (less CPU usage)

Const BASS_MUSIC_LOOP:Int=			BASS_SAMPLE_LOOP ' loop music

Const BASS_MUSIC_3D:Int=			BASS_SAMPLE_3D ' enable 3D functionality

Const BASS_MUSIC_FX:Int=			BASS_SAMPLE_FX ' enable old implementation of DX8 effects

Const BASS_MUSIC_AUTOFREE:Int=		BASS_STREAM_AUTOFREE ' automatically free the music when it stop/ends

Const BASS_MUSIC_DECODE:Int=		BASS_STREAM_DECODE ' don't play the music, only decode (BASS_ChannelGetData)

Const BASS_MUSIC_PRESCAN:Int=		BASS_STREAM_PRESCAN	' calculate playback length

Const BASS_MUSIC_CALCLEN:Int=		BASS_MUSIC_PRESCAN

Const BASS_MUSIC_RAMP:Int=			$200	' normal ramping

Const BASS_MUSIC_RAMPS:Int=			$400	' sensitive ramping

Const BASS_MUSIC_SURROUND:Int=		$800	' surround sound

Const BASS_MUSIC_SURROUND2:Int=		$1000	' surround sound (mode 2)

Const BASS_MUSIC_FT2MOD:Int=		$2000	' play .Mod as FastTracker 2 does

Const BASS_MUSIC_PT1MOD:Int=		$4000	' play .Mod as ProTracker 1 does

Const BASS_MUSIC_NONINTER:Int=		$10000	' non-interpolated mixing

Const BASS_MUSIC_POSRESET:Int=		$8000	' stop all notes when moving position

Const BASS_MUSIC_POSRESETEX	:Int=	$400000' stop all notes And reset bmp/etc when moving position

Const BASS_MUSIC_STOPBACK:Int=		$80000	' stop the music on a backwards jump effect

Const BASS_MUSIC_NOSAMPLE:Int=		$100000' don't load the samples



' Speaker assignment flags

Const BASS_SPEAKER_FRONT:Int=		$1000000	' front speakers

Const BASS_SPEAKER_REAR:Int=		$2000000	' rear/side speakers

Const BASS_SPEAKER_CENLFE:Int=		$3000000	' center &amp; LFE speakers (5.1)

Const BASS_SPEAKER_REAR2:Int=		$4000000	' rear center speakers (7.1)

'Const BASS_SPEAKER_N(n)	((n)&lt;&lt;24)	' n'th pair of speakers (max 15)

Const BASS_SPEAKER_LEFT:Int=		$10000000	' modifier: Left

Const BASS_SPEAKER_RIGHT:Int=		$20000000	' modifier: Right

Const BASS_SPEAKER_FRONTLEFT:Int=	BASS_SPEAKER_FRONT|BASS_SPEAKER_LEFT

Const BASS_SPEAKER_FRONTRIGHT:Int=	BASS_SPEAKER_FRONT|BASS_SPEAKER_RIGHT

Const BASS_SPEAKER_REARLEFT	:Int=	BASS_SPEAKER_REAR|BASS_SPEAKER_LEFT

Const BASS_SPEAKER_REARRIGHT:Int=	BASS_SPEAKER_REAR|BASS_SPEAKER_RIGHT

Const BASS_SPEAKER_CENTER:Int=		BASS_SPEAKER_CENLFE|BASS_SPEAKER_LEFT

Const BASS_SPEAKER_LFE:Int=			BASS_SPEAKER_CENLFE|BASS_SPEAKER_RIGHT

Const BASS_SPEAKER_REAR2LEFT:Int=	BASS_SPEAKER_REAR2|BASS_SPEAKER_LEFT

Const BASS_SPEAKER_REAR2RIGHT:Int=	BASS_SPEAKER_REAR2|BASS_SPEAKER_RIGHT



Const  BASS_UNICODE:Int=			$80000000



Const  BASS_RECORD_PAUSE:Int=		$8000	' start recording paused

Const BASS_DATA_FLOAT:Int=			$40000000
</textarea><br><br>The interface code isn't complete, but the rest should be. <br><br></td></tr></table><br>
<a name="863026"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for both of those, but they both seem to suffer from what I mentioned in the first post. They both just leave out the stuff which looks tricky to wrap, and although I don't personally need any of that stuff either, I don't really want to release a module which isn't complete. People will start using it and then feel let down when they try to do something and find it's not supported, and I don't want to do that.<br><br>Anyway, I wrapped the basics myself last night and I'll write up a quick BlitzMax class to automatically handle a few things ( like string&lt;&gt;char ptr conversions ) and hopefully release a very basic version in a few hours. It would have been earlier, but there was the small matter of an FA Cup semi final. <br><br>BTW, I'm only doing the Windows version, so if anyone wants a Mac build, they'll have to make any changes which are required. I'll be releasing under a Creative Commons  Non-Derivative license but if someone makes a Mac version, I'm happy bundle it up with my own and host it, if they want that. <br><br></td></tr></table><br>
<a name="863055"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> This BASS stuff is rather fun, isn't it?<br>I like all this "add-on" functionality you can get too, which makes for an interesting module structure.... I was considering dumping it all in a single module, but I've found it works quite well as separate mods which you Import as required.<br>Now, if only the Mac IDE included a facility per project to allow you to specify files to include in your App Bundle, it would make running apps with the shared libs a tad less finicky. <br><br></td></tr></table><br>
<a name="863112"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> .. <br><br></td></tr></table><br>
<a name="863118"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I've got something together that's good enough to have a play with. It comes with two examples - nothing fancy - one that plays a loaded song and one that streams a song. Feel free to dabble with fancier stuff though, as everything except recording has been wrapped, and I'll do recording shortly.<br><br>This is for the latest version of Bass (2.04) so don't try and get it to work with any older versions.<br><br><a href="http://www.glimmergames.com/modules/bass/bass.zip" target="_blank">http://www.glimmergames.com/modules/bass/bass.zip</a><br><br>Any bugs or whatnot, please report it and I'll take a look.<br><br>I don't plan to wrap any of the add-on modules at this time, but we'll see. <br><br></td></tr></table><br>
<a name="863840"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> It looks like Brucey is working on a Bass module too -- appeared on his SVN. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
