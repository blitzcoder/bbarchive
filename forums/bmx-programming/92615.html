<!DOCTYPE html><html lang="en" ><head ><title >1,000,000 primes in 6.9 seconds!</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >1,000,000 primes in 6.9 seconds!</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >1,000,000 primes in 6.9 seconds!</a><br><br>
<a name="1056209"></a>

<a name="1056210"></a>

<a name="1056308"></a>

<a name="1056309"></a>

<a name="1056321"></a>

<a name="1056514"></a>

<a name="1056515"></a>

<a name="1056517"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> so I was reading some wiki articles on number theory and prime numbers and I had an idea for a faster prime number program.  This one finds the first 1,000,000 prime numbers in <strike>6.9 2.3</strike> <b>0.4</b> seconds on my computer which is not much faster than average.  Don't be fooled, it finishes calculating the numbers before it displays them.  My IDE freezes when bmax is printing the numbers and then unfreezes several seconds later after it has printed all the numbers so I have left the thing that displays the numbers out but you can just uncomment it if you want to see them.<br><br>edit: new faster method<br><pre class=code>Global num:Int = 15485864
Global sqrnum:Int = Sqr(num)+1
Global PrimeFlags:Byte[num]
Global Primes:Int[num]
Local tim:Int
Local mill:Int = MilliSecs()
For Local x:Int = 2 Until sqrnum
	If primeflags[x] = 0 Then
		tim = x
		Repeat
			tim:+x
			primeflags[tim] = True
		Until x+tim =&gt; num
	EndIf
Next 
Local count:Int
For Local y:Int = 2 Until num
	If primeflags[y] = False Then
		primes[count] = y
		count:+1
		
	EndIf
Next
mill = MilliSecs()-mill
Print mill/1000.0 +" seconds"
Rem
For Local i:Int = 0 Until count
	Print primes[i]
Next
EndRem
Print count + " primes found!"</pre><br><br><br><br>heres the old code:<br><br><pre class=code>
Local PR:Int = 3
Local primelist:Int[1000001]
Local prcnt:Int = 1
primelist[0] = 2

Local n:Int = 0
Local flag:Byte = False

Local c:Int = MilliSecs()
Repeat
	n = 0
	flag = False
	While primelist[n]*primelist[n] &lt;= PR
		If ((pr Mod primelist[n])=0) Then
			flag = True
			Exit
		EndIf
		n:+1
	Wend
	If Not flag
		primelist[prcnt] = pr
		prcnt:+1
	EndIf
	pr:+2
Until prcnt = 1000000
c = MilliSecs()-c

'For i:Int = 0 Until 1000000
'	Print primelist[i]
'Next

Print "First 1,000,000 primes in "+c/1000.0+" seconds!"
</pre><br><br>UPDATED<br><br>if you want to see the numbers without risking freezing your computer, you could just display the first 1000 or the last 1000<br><br>be sure NOT to run in DEBUG MODE<br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just out of curiosity, what processor do you have in your PC?<br>It takes 12.91 seconds on my computer (Core 2 Duo E6600 @ 2.4GHz, windows 7 x64) <br><br></td></tr></table><br>
<a name="1056216"></a>

<a name="1056217"></a>

<a name="1056218"></a>

<a name="1056219"></a>

<a name="1056220"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> core 2 duo t8300 @ 2.4 ghz &amp; 2.4 ghz<br>this is what my control panel says... although I thought it was 2.6 ghz until now...<br><br>and its win vista 32 bit<br><br>make sure you are not in debug and you have no other programs running... i consistently get 6.9 something, never more or less than that for the first 2 digits<br><br>ok just did it in debug and got 14.5 seconds.. maybe thats youre problem?<br><br>youre processor <a href="http://ark.intel.com/Product.aspx?id=27250" target="_blank">http://ark.intel.com/Product.aspx?id=27250</a><br>mine <a href="http://ark.intel.com/Product.aspx?id=33099" target="_blank">http://ark.intel.com/Product.aspx?id=33099</a><br><br>they look almost identicle to my untrained eye<br><br>edit: looks like the time it takes to do this is more affected by read/write speeds for your ram considering it reads a ton of prime numbers off of your ram for every number it tests.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056228"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>First 1,000,000 primes in 5.90299988 seconds!<br> <br></div><br><br>On bootcamped XP!<br><br>Intel i3 CPU 550@...<br><br>Dabz <br><br></td></tr></table><br>
<a name="1056233"></a>

<a name="1056234"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got 15.5 seconds by running this code on my laptop. (non-debug mode)<br>With debug mode on, I got 23.97 seconds.<br><br>Win Vista 32 bit, processor: Core 2 Duo T7200 @ 2GHz.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056235"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pengwin</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just for comparison, I ran this on my iMac (2.66 GHz Intel Core 2 Duo) with OSX 10.5.8<br><br>I got 6.339 seconds for non-debug and 15.796 seconds for debug mode. <br><br></td></tr></table><br>
<a name="1056236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you want a challenge make a multithreaded one! <br><br></td></tr></table><br>
<a name="1056237"></a>

<a name="1056238"></a>

<a name="1056239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> The oiginal code ran in 8.71700001 seconds on a Core 2 Duo T6400. Changing the line <br><pre class=code>
If (pr/(primelist[n]*1.0)) = Int(pr/primelist[n]) Then
</pre><br>to<br><pre class=code>
If ((pr Mod primelist[n])=0) Then
</pre><br>made it run in 2.86400008 seconds instead :p<br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056241"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arabia</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> It took 2hrs and 23minutes on my Vic 20 :( <br><br></td></tr></table><br>
<a name="1056307"></a>

<a name="1056310"></a>

<a name="1056311"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @zzz thanks!  I cant believe I overlooked that! thanks<br><br>edit: updated!<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056312"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hummelpups</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> :D<br><br>First 1,000,000 primes in 1.79700005 seconds! <br><br></td></tr></table><br>
<a name="1056322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> hmmm translated it to ti-basic and it takes at least several hours if not days on my calculator.  I didnt want to run my batteries down! <br><br></td></tr></table><br>
<a name="1056336"></a>

<a name="1056359"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> :D<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056343"></a>

<a name="1056348"></a>

<a name="1056354"></a>

<a name="1056356"></a>

<a name="1056360"></a>

<a name="1056362"></a>

<a name="1056363"></a>

<a name="1056364"></a>

<a name="1056365"></a>

<a name="1056371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Me.32</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> translated to <b>C</b>:<br><b>&lt;5.809s&gt;</b> on my Slow <b>2GHz Core 2 Duo</b> iMac :D<br><br>BMax:<br>&lt;5.918s&gt; on the same machine<br><br>iMac, Intel Core 2 Dou 2.0 GHZ<br><br>&lt;update&gt;<br> <b>C</b>:<br><b>&lt;5.726s&gt;</b> with LLVM 1.5 on same Machine :D<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056353"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess my computer sucks.  I've got a (dual) 2.5ghz cpu, and in both win 7 (32bit) and ubuntu (32bit) it runs in 10 seconds, over and over again.  hmm, time to upgrade I guess.<br><br>;( <br><br></td></tr></table><br>
<a name="1056370"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> After the code-change (suggested by zzz), it now runs in 5.97 seconds instead of 15.5 seconds on my laptop. <br><br></td></tr></table><br>
<a name="1056398"></a>

<a name="1056399"></a>

<a name="1056400"></a>

<a name="1056401"></a>

<a name="1056402"></a>

<a name="1056409"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nate, or someone else, here is the sieve of eratosthene.  Super fast.<br><br>Done in 0.962000012 seconds.<br>Total primes generated: 1000000<br><br><br>This is the time on my computer.<br><br>Can someone help me clean up the code.  It's needs to be better able to find a specific number of primes.<br><br>But I think you'll agree this is much faster.<br>After the prime arrary is built, it could be turned into a bit table and take up far less ram.<br><br>The end for loop is to print sections of the prime array to verify the numbers are actually primes.<br><br>Have fun.<br><br>P.S.  Don't program when your drunk! ha ha<br><br><pre class=code>
SuperStrict

Const stopme:Int=100000000
Local flags:Int[stopme+1]
Local i:Int
Local theprimes:Int[1000000]

For i=0 To stopme
	flags[i]=-1
Next

Local z:Int=0
Local endprime:Int=15485863
Local test:Int=2
Local x:Int=0
Local count:Int=0

z=MilliSecs()

For Local test:Int=2 To endprime

	If flags[test]&lt;&gt;-1 Then
		Continue
	EndIf
	
	x=test
	If flags[test]=-1 Then
		theprimes[count]=test
		count=count+1
		flags[test]=test
	EndIf

	Repeat
		flags[test+x]=test
		x=x+test
	Until x&gt;=endprime

Next

z=MilliSecs()-z

Print "Done in "+z/1000.0+" seconds."
Print "Total primes generated: "+count


For i=25 To 50
	Print theprimes[i]
Next

</pre><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056404"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm.  my bit array for the first 1,000,000 primes is still 125,000 bytes long.... :) <br><br></td></tr></table><br>
<a name="1056410"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> thats interesting, I dont see how using that method would be twice as fast as mine...  but i get 1.17 seconds with yours which is twice as fast as mine and 7 times as fast as the original! :p  I wonder what the fastest way ever though of is to find primes...  I cant seem to find many methods for finding prime numbers. <br><br></td></tr></table><br>
<a name="1056411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Isn't there something called the "Sieve of Eratosthenes " or something - very quick to find primes....<br><br><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank">http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a> <br><br></td></tr></table><br>
<a name="1056422"></a>

<a name="1056425"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Um, LOL, Matty, that's what I programmed.  Not very well, but it does work.<br><br>Nate:<br><br>The sieve is super fast because it's doing what the computer does best:<br>count... (no division, just simple memory copying and very simple condition loops...)<br><br><br>Using elipitical curves is the fastest method for large numbers, but not small numbers.<br><br>Sieve of Eratosthenes is the fastest for most primes, but of course you have to have the memory to build the array.<br><br>For my program (badly written) it only needs:<br>Total Loops: 47,086,551<br><br>Your program needs:<br>Total Loops: 504,508,950<br><br>The only real fast way, is to create a table (bit database) of precalculated primes and just do a lookup.  That is really the fastest way if your program is going to need to access primes very frequently.  (Factoring for example.)<br><br>If your interested start here:<br><a href="http://primes.utm.edu/prove/" target="_blank">http://primes.utm.edu/prove/</a><br><br>And if you want to make your head hurt go here:<br><a href="http://polymathprojects.org/category/finding-primes/" target="_blank">http://polymathprojects.org/category/finding-primes/</a><br><br>And of course you could also start with the obvious:<br><a href="http://en.wikipedia.org/wiki/Integer_factorization" target="_blank">http://en.wikipedia.org/wiki/Integer_factorization</a><br><br>:D<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Shortwind, I didn't read all the posts (my bad...) <br><br></td></tr></table><br>
<a name="1056427"></a>

<a name="1056428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I doubt this will make much difference to anyone here as everyone seem to have pretty fast computers but by removing the second if statement in the for loop and removing one unnecessary calculation in the last demo, I was able to reduce the time on my wife's ancient imac 1.2ghz from 13 secs to 7.5 secs. I tried it in my netbook and it was prety much unchanged.<br><pre class=code>
SuperStrict

Const stopme:Int=100000000
Local flags:Int[stopme+1]
Local i:Int
Local theprimes:Int[1000000]

For i=0 To stopme
	flags[i]=-1
Next

Local z:Int=0
Local endprime:Int=15485863
Local test:Int=2
Local x:Int=0
Local count:Int=0

z=MilliSecs()

For Local test:Int=2 To endprime

	If flags[test]&lt;&gt;-1 Then
		Continue
	EndIf
	
	x=test
	theprimes[count]=test
	count=count+1
	flags[test]=test

	Repeat
		x:+test
		flags[x]=test
	Until x&gt;=endprime

Next

z=MilliSecs()-z

Print "Done in "+z/1000.0+" seconds."
Print "Total primes generated: "+count


For i=25 To 50
	Print theprimes[i]
Next
</pre><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056429"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> LOL, thanks Jesse.  I didn't see that until you pointed it out. :D<br><br>It's better now, but I still code for crap on the fly. Ha! Ha!<br><br>:D <br><br></td></tr></table><br>
<a name="1056456"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats nice :p Feels a little weird that 10x more iterations only doubles the time taken. Also, theres a sieve of atkin (sp?) around, which, if i dont remember wrong uses some clever way to calculate prime candidates instead of just working through the entire 2..n range like we are doing here. <br><br></td></tr></table><br>
<a name="1056483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wrote a simple sieve of atkin based on the wikipedia pseudocode;<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.standardio
Import brl.math

Const LIMIT:Int=15500000
Local isprime:Int[LIMIT]

'timer
Local time:Int=MilliSecs()

Rem
########################################################
sieve of atkin starts here :P
End Rem
For Local i:Int=5 To isprime.length-1
	isprime[i]=False
Next
For Local x:Int=1 To Sqr(LIMIT)
	For Local y:Int=1 To Sqr(LIMIT)
	
		Local n:Int
		
		n=(4*x*x)+(y*y)
		If (n&lt;=LIMIT) And ((n Mod 12 = 1) Or (n Mod 12 = 5)) Then
			isprime[n]=1-isprime[n]
		EndIf
		
		n=3*x*x+(y*y)
		If (n&lt;=LIMIT) And (n Mod 12 = 7) Then
			isprime[n]=1-isprime[n]
		EndIf
		
		n=3*x*x-(y*y)
		If (x&gt;y) And (n&lt;=LIMIT) And (n Mod 12 = 11) Then
			isprime[n]=1-isprime[n]
		EndIf
	
	Next
Next
Rem
sieve out false primes
End Rem
For Local i:Int=5 To Sqr(LIMIT)
	If (isprime[i]) Then
		Local k:Int=i*i
		Repeat
			isprime[k]=False
			k:+(i*i)
		Until (k&gt;LIMIT)
	EndIf
Next
Rem
done, put primes in a separate array
End Rem
Local primes:Int[LIMIT]
Local prime_index:Int=2
primes[0]=2
primes[1]=3
For Local i:Int=5 To isprime.length-1
	If (isprime[i]) Then
		primes[prime_index]=i
		prime_index:+1
	EndIf
Next
Rem
########################################################
DONE, write result
End Rem
time=MilliSecs()-time
Print time/1000.0+" seconds.."+prime_index+" primes.."
Rem
validate result against the original function
End Rem
Print "validating.."
Local ref_primes:Int[]=primes_01(prime_index)
For Local i:Int=0 To prime_index-1
	If (ref_primes[i]&lt;&gt;primes[i]) Then
		Print "mismatch.."
		Print ref_primes[i]+":"+primes[i]+":"+i
		Exit
	EndIf
Next
Print "Done!"
End
Rem
########################################################
original code by nate the great for reference
End Rem
Function primes_01:Int[](primes_count:Int)
	Local PR:Int=3
	Local primelist:Int[primes_count]
	Local prcnt:Int=1
	primelist[0]=2
	Local n:Int=0
	Local flag:Byte=False
	Repeat
		n=0
		flag=False
		While primelist[n]*primelist[n]&lt;=PR
			If (PR/(primelist[n]*1.0))=Int(PR/primelist[n]) Then
				flag=True
				Exit
			EndIf
			n:+1
		Wend
		If Not flag
			primelist[prcnt]=pr
			prcnt:+1
		EndIf
		PR:+2
	Until prcnt=primes_count
	Return primelist
End Function
</textarea><br><br>The original function runs in about 2,9 seconds, the "other sieve" :o takes about 1,4 seconds on average and this one does the work in just under 0,8 for me :D<br><br>Supposedly this one can be optimized dramatically also. <br><br></td></tr></table><br>
<a name="1056502"></a>

<a name="1056530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> I completely forgot about this one.  This sieve only needs 16,911,909 loops to find 1,000,862 primes.  Nice!  And doesn't require the all the extra memory that sieve of Eratosthenes.  Cool.<br><br>On one final note it should be known that all primes greater than 6 are of the form:<br><br>6k + or - 1<br><br><br>:D<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056503"></a>

<a name="1056513"></a>

<a name="1056520"></a>

<a name="1056525"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0.4 seconds!<br><br>I cant believe how much faster its gotten.  This is kind of a mix of the 4 ideas presented above by zzz, jessie and shortwind and me.  I don't know what you would call it since I just combined ideas but its a sieve I guess.<br><br><pre class=code>Global num:Int = 15485864
Global sqrnum:Int = Sqr(num)+1
Global PrimeFlags:Byte[num]
Global Primes:Int[num]
Local tim:Int
Local mill:Int = MilliSecs()
For Local x:Int = 2 Until sqrnum
	If primeflags[x] = 0 Then
		tim = x
		Repeat
			tim:+x
			primeflags[tim] = True
		Until x+tim =&gt; num
	EndIf
Next 
Local count:Int
For Local y:Int = 2 Until num
	If primeflags[y] = False Then
		primes[count] = y
		count:+1
		
	EndIf
Next
mill = MilliSecs()-mill
Print mill/1000.0 +" seconds"
Rem
For Local i:Int = 0 Until count
	Print primes[i]
Next
EndRem
Print count + " primes found!"</pre><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056552"></a>

<a name="1056553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0.52 seconds here, Nate is on top again :p <br>EDIT: just figured out how i can make some massive improvements on the atkin sieve ;D<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056554"></a>

<a name="1056555"></a>

<a name="1056556"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> 8 core 2010 2.4ghz Mac pro (under OS X, under vista in bootcamp first post variant was actually a tiny bit slower, tough oddly the same install through parallels was the same as the mac... very wierd)<br><br>First post variant (current form with the first optimization update) 2.48600006 solidly<br><br>nate's release 2 posts from here up 0.186000004 to 0.189999998<br><br>running stuff in the background but that shouldn't matter...<br><br>would REALLY love to see a multi-threaded variant... 8 cores, with hyper-threading wants to know... :0)<br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056557"></a>

<a name="1056558"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> nevermind this post, was just OS randomness<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056559"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> @im747, couldnt see any difference in the generated assembly so i guess its just a 'placebo' effect :) <br><br></td></tr></table><br>
<a name="1056561"></a>

<a name="1056562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got the aktin sieve down to 0.58 seconds with some basic optimizations, Nates latest version is still slightly faster :p<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.standardio
Import brl.math

Const LIMIT:Int=15485864
Local isprime:Int[LIMIT]

'timer
Local time:Int=MilliSecs()

Rem
########################################################
sieve of atkin starts here :P
End Rem
For Local i:Int=5 To isprime.length-1
	isprime[i]=False
Next
Rem
'the original prime candidate generation code
For Local x:Int=1 To Sqr(LIMIT)
	Local xx:Int=x*x
	For Local y:Int=1 To Sqr(LIMIT)
	
		Local n:Int
		Local yy:Int=y*y
		
		n=4*xx+yy
		If (n&lt;=LIMIT) Then
			If ((n Mod 12 = 1) Or (n Mod 12 = 5)) Then
				isprime[n]=1-isprime[n]
			EndIf
		EndIf
		
		n=3*xx+yy
		If (n&lt;=LIMIT) And (n Mod 12 = 7) Then
			isprime[n]=1-isprime[n]
		EndIf
		
		n=3*xx-yy
		If (x&gt;y) And (n&lt;=LIMIT) And (n Mod 12 = 11) Then
			isprime[n]=1-isprime[n]
		EndIf
	
	Next
Next
End Rem
Rem
############################################################
optimized prime candidate code

# optimization 1, reduced x/y loop overhead

End Rem
Rem
4xx+yy
End Rem
For Local x:Int=1 To Sqr(LIMIT)
	Local xx:Int=x*x
	'only make y go up to values that keep 4xx+yy under LIMIT
	Local y_limit:Int=Sqr(LIMIT-(4*xx))
	For Local y:Int=1 To y_limit
		Local yy:Int=y*y
		Local n:Int=4*xx+yy
		'test if the n&lt;=LIMIT check is still needed?
		'If (n&lt;=LIMIT) And ((n Mod 12=1) Or (n Mod 12=5)) Then
		If (n Mod 12=1) Or (n Mod 12=5) Then
			isprime[n]=1-isprime[n]
		EndIf
	Next
Next
Rem
3xx+yy
End Rem
For Local x:Int=1 To Sqr(LIMIT)
	Local xx:Int=x*x
	'only make y go up to values that keep 3xx+yy under LIMIT
	Local y_limit:Int=Sqr(LIMIT-(3*xx))
	For Local y:Int=1 To y_limit
		Local yy:Int=y*y
		Local n:Int=3*xx+yy
		'If (n&lt;=LIMIT) And (n Mod 12=7) Then
		If (n Mod 12=7) Then
			isprime[n]=1-isprime[n]
		EndIf
	Next
Next
Rem
3xx-yy
End Rem
For Local x:Int=1 To Sqr(LIMIT)
	Local xx:Int=x*x
	'special case here for -yy.. y should only go up to x-1 instead
	For Local y:Int=1 To x-1
		Local yy:Int=y*y
		Local n:Int=3*xx-yy
		If (x&gt;y) And (n&lt;=LIMIT) And (n Mod 12=11) Then
			isprime[n]=1-isprime[n]
		EndIf
	Next
Next
Rem
End Rem
Print (MilliSecs()-time)/1000.0
Rem
sieve out false primes
End Rem
For Local i:Int=5 To Sqr(LIMIT)
	If (isprime[i]) Then
		Local k:Int=i*i
		Repeat
			isprime[k]=False
			k:+(i*i)
		Until (k&gt;LIMIT)
	EndIf
Next
Rem
End Rem
Print (MilliSecs()-time)/1000.0
Rem
done, put primes in a separate array
End Rem
Local primes:Int[LIMIT]
Local prime_index:Int=2
primes[0]=2
primes[1]=3
For Local i:Int=5 To isprime.length-1 Step 2
	If (isprime[i]) Then
		primes[prime_index]=i
		prime_index:+1
	EndIf
Next
Rem
########################################################
DONE, write result
End Rem
time=MilliSecs()-time
Print time/1000.0+" seconds.."+prime_index+" primes.."
Rem
validate result against the original function
End Rem
Print "validating.."
Local ref_primes:Int[]=primes_01(prime_index)
For Local i:Int=0 To prime_index-1
	If (ref_primes[i]&lt;&gt;primes[i]) Then
		Print "mismatch.."
		Print ref_primes[i]+":"+primes[i]+":"+i
		Exit
	EndIf
Next
Print "Done!"
End
Rem
########################################################
original code by nate the great for reference
End Rem
Function primes_01:Int[](primes_count:Int)
	Local PR:Int=3
	Local primelist:Int[primes_count]
	Local prcnt:Int=1
	primelist[0]=2
	Local n:Int=0
	Local flag:Byte=False
	Repeat
		n=0
		flag=False
		While primelist[n]*primelist[n]&lt;=PR
			If (PR/(primelist[n]*1.0))=Int(PR/primelist[n]) Then
				flag=True
				Exit
			EndIf
			n:+1
		Wend
		If Not flag
			primelist[prcnt]=pr
			prcnt:+1
		EndIf
		PR:+2
	Until prcnt=primes_count
	Return primelist
End Function
</textarea><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Slight improvement on nates latest code, keep finishing at around 0,49 seconds for me. Will probably run slower on older machines.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.standardio
Import brl.math

Global num:Int = 15485864
Global sqrnum:Int = Sqr(num)+1
Global PrimeFlags:Byte[num]
Global Primes:Int[num]
Local tim:Int
Local mill:Int = MilliSecs()
For Local x:Int = 2 Until sqrnum
	If primeflags[x] = 0 Then
		tim = x
		Repeat
			tim:+x
			primeflags[tim] = True
		Until x+tim =&gt; num
	EndIf
Next 
Local count:Int=0
primes[count]=2
count:+1
For Local y:Int = 3 Until num Step 2
	primes[count]=y
	count:+(primeflags[y]=False)
Next
mill = MilliSecs()-mill
Print mill/1000.0 +" seconds"
Rem
For Local i:Int = 0 Until count
	Print primes[i]
Next
EndRem
Print count + " primes found!"
</textarea> <br><br></td></tr></table><br>
<a name="1056572"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> first 10,000,000 primes in 6.0 seconds<br><br><pre class=code>SuperStrict
Framework brl.standardio
Import brl.math

Global num:Int = 179424674
Global sqrnum:Int = Sqr(num)+1
Global PrimeFlags:Byte[num]
Global Primes:Int[num]
Local tim:Int
Local mill:Int = MilliSecs()
For Local x:Int = 2 Until sqrnum
	If primeflags[x] = 0 Then
		tim = x
		Repeat
			tim:+x
			primeflags[tim] = True
		Until x+tim =&gt; num
	EndIf
Next 
Local count:Int=0
primes[count]=2
count:+1
For Local y:Int = 3 Until num Step 2
	primes[count]=y
	count:+(primeflags[y]=False)
Next
mill = MilliSecs()-mill
Print mill/1000.0 +" seconds"
Rem
For Local i:Int = 0 Until count
	Print primes[i]
Next
EndRem
Print count + " primes found!"
</pre><br><br>thanks for the optimization zzz <br><br></td></tr></table><br>
<a name="1056618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sweet<br><br>2.87800002 seconds<br>10000000 primes found! <br><br></td></tr></table><br>
<a name="1056654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice :P Finished in 7.13600016 seconds for me <br><br></td></tr></table><br>
<a name="1056660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.standardio
Import brl.math

Global num:Int = 179424674
'Global num:Int=15485864
Global sqrnum:Int = Sqr(num)+1
Global PrimeFlags:Byte[num]
Global Primes:Int[num]
Local tim:Int
Local mill:Int = MilliSecs()
'special case for 2,3
For Local x:Int=2 To 3
	If (primeflags[x]=0) Then
		Local tim:Int=x
		Repeat
			tim:+x
			primeflags[tim]=True
		Until x+tim&gt;=num
	EndIf
Next
'Print (MilliSecs()-mill)/1000.0
'mark of the rest
Rem
For Local i:Int = 6 Until sqrnum-1 Step 6
	Local x:Int
	x=i-1
	If primeflags[x] = 0 Then
		tim = x
		Repeat
			tim:+x
			primeflags[tim] = True
		Until x+tim =&gt; num
	EndIf
	x=i+1
	If primeflags[x]=0 Then
		tim=x
		Repeat
			tim:+x
			primeflags[tim]=True
		Until x+tim&gt;=num
	EndIf
Next 
End Rem
Local x:Int=5
Repeat
	If primeflags[x]=0 Then
		Local tim:Int=x
		Repeat
			tim:+x
			primeflags[tim]=True
		Until x+tim&gt;=num
	EndIf
	x:+2
	If primeflags[x]=0 Then
		Local tim:Int=x
		Repeat
			tim:+x
			primeflags[tim]=True
		Until x+tim=&gt;num
	EndIf
	x:+4
Until x&gt;=sqrnum-1
'..
Local count:Int=0
primes[count]=2
count:+1
For Local y:Int = 3 Until num Step 2
	primes[count]=y
	count:+(primeflags[y]=False)
Next
mill = MilliSecs()-mill
Print mill/1000.0 +" seconds"
Rem
For Local i:Int = 0 Until count
	Print primes[i]
Next
EndRem
Print count + " primes found!"
</textarea><br><br>Modified Nates a bit, finishes in around 6,85 for me now. <br><br></td></tr></table><br>
<a name="1056734"></a>

<a name="1056742"></a>

<a name="1056854"></a>

<a name="1056856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework brl.standardio
Import brl.math

'Local max_value:Int=179424674
Local max_value:Int=15485864

Local flags:Int[max_value/32+1]

Const mod32_mask:Int=%11111
Const div32_mask:Int=%11111111111111111111111111100000
Const even_mask:Int=%01010101010101010101010101010101

Local mask:Int[32]
For Local i:Int=0 To 31
	mask[i]=2^i
Next

'start
Local timer:Int=MilliSecs()

For Local i:Int=0 To flags.length-1
	flags[i]=even_mask
Next
flags[0]:~mask[2]

Local sqrnum:Int=Sqr(max_value)

For Local x:Int=3 To sqrnum Step 2
	Local index_byte:Int=(x &amp; div32_mask) Shr 5
	Local index_bit:Int=1 Shl (x &amp; mod32_mask)
	If ((flags[index_byte] &amp; index_bit)=0) Then
		Local tmp:Int=x
		Repeat
			tmp:+x
			index_byte=(tmp &amp; div32_mask) Shr 5
			index_bit=1 Shl (tmp &amp; mod32_mask)
			flags[index_byte]:|index_bit
		Until (tmp+x&gt;=max_value)
	EndIf
Next
Print (MilliSecs()-timer)/1000.0+" ..counting primes.."
Local count:Int=1
For Local k:Int=3 To max_value-1 Step 2
	Local index_byte:Int=(k &amp; div32_mask) Shr 5
	Local index_bit:Int=1 Shl (k &amp; mod32_mask)
	Rem
	If ((flags[index_byte] &amp; index_bit)=0) Then
		count:+1
	EndIf
	End Rem
	count:+((flags[index_byte] &amp; index_bit)=0)
Next

'finish
timer=MilliSecs()-timer
Print (timer/1000.0)+" seconds.. "+count+" primes found."

End
</textarea><br><br>A real mess, i tend to not delete any code i write when "scribbling" like this, instead putting comments all over the place :P <br><br>Anyways, nates latest sieve inspired me to write this one, the speed increase is pretty much only from reduced memory overhead. Churns out a million primes in ~0,145 seconds and 10 million in ~4,9 seconds on my core2duo t6400 (2ghz).<br><br>EDIT: cleaned up the code<br>EDIT2: small change suggested by Czar<br>EDIT3: changed the prime counting code a little, now doing ~0,11s/1m primes for me.<br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056771"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey zzz, what are the masks for?  I dont see how the masks are used to optimize it? <br><br></td></tr></table><br>
<a name="1056772"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Will making the masks constant improve speed more? <br><br></td></tr></table><br>
<a name="1056852"></a>

<a name="1056853"></a>

<a name="1056860"></a>

<a name="1056861"></a>

<a name="1056862"></a>

<a name="1056863"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> I used the div/mod mask to get rid of division. cpus calculate the remainder as a byproduct when doing division so the div/idiv opcodes gets used for either operation, and theyre really slow.. And with a fixed known value its pretty straightforward to use bitwise operators instead.<br>EDIT: that doesnt really have much impact on the code, at least not in a positive way. the main speed increase comes from reducing the memory footprint by using bits for flags instead of bytes. The extra fiddling is outweighted by the reduced memory overhead by a lot :) (and thats also a big reason to why it isnt much faster on the 10m prime test)<br><br>The third 'mask' is just a quickie way to mark of all even numbers, 16 numbers at a time :o <br><br>@Czar: that works indeed, got it down to ~0,12seconds/1m primes for me :)<br><br>sample code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework brl.standardio

Const LIMIT:Int=500000000

Const MOD32:Int=%11111
Const MASK32:Int=%11111111111111111111111111100000

Local timer:Int=MilliSecs()
Local k:Int
Local count:Int

For Local i:Int=1 To LIMIT
	k=i Mod 32
	count:+(k=0)
Next

timer=MilliSecs()-timer
Print "standard mod: "+timer/1000.0+" sec, count: "+count

count=0
timer=MilliSecs()

For Local i:Int=1 To LIMIT
	k=i &amp; mod32
	count:+(k=0)
Next

timer=MilliSecs()-timer
Print "bitwise and mod: "+timer/1000.0+" sec, count: "+count

End

</textarea><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056859"></a>

<a name="1056875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its now doing 1m primes in under 0,1 seconds for me :P, getting steady 0,097/0,099 second results. 10m primes in ~4,5 seconds.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework brl.standardio
Import brl.math

'Local max_value:Int=179424674
Local max_value:Int=15485864

Local flags:Int[max_value/32+1]

Const mod32_mask:Int=%11111
Const div32_mask:Int=%11111111111111111111111111100000
Const even_mask:Int=%01010101010101010101010101010101

Local mask:Int[32]
For Local i:Int=0 To 31
	mask[i]=2^i
Next

'start
Local timer:Int=MilliSecs()

For Local i:Int=0 To flags.length-1
	flags[i]=even_mask
Next
flags[0]:~mask[2]

Local sqrnum:Int=Sqr(max_value)

For Local x:Int=3 To sqrnum Step 2
	Local index_byte:Int=(x &amp; div32_mask) Shr 5
	Local index_bit:Int=1 Shl (x &amp; mod32_mask)
	If ((flags[index_byte] &amp; index_bit)=0) Then
		Local tmp:Int=x
		Repeat
			tmp:+x
			index_byte=(tmp &amp; div32_mask) Shr 5
			index_bit=1 Shl (tmp &amp; mod32_mask)
			flags[index_byte]:|index_bit
		Until (tmp+x&gt;=max_value)
	EndIf
Next
Print (MilliSecs()-timer)/1000.0+" ..counting primes.."

Local count:Int=0
Rem
For Local k:Int=3 To max_value-1 Step 2
	Local index_byte:Int=(k &amp; div32_mask) Shr 5
	Local index_bit:Int=1 Shl (k &amp; mod32_mask)
	'If ((flags[index_byte] &amp; index_bit)=0) Then
	'	count:+1
	'EndIf
	count:+((flags[index_byte] &amp; index_bit)=0)
Next
End Rem

'count primes
For Local ii:Int=0 To max_value/32-1
	
	Local b:Int=flags[ii]
	
	'unrolled loop..
	
	count:+(b &amp; (1 Shl 1))=0
	count:+(b &amp; (1 Shl 3))=0
	count:+(b &amp; (1 Shl 5))=0
	count:+(b &amp; (1 Shl 7))=0
	count:+(b &amp; (1 Shl 9))=0
	count:+(b &amp; (1 Shl 11))=0
	count:+(b &amp; (1 Shl 13))=0
	count:+(b &amp; (1 Shl 15))=0
	count:+(b &amp; (1 Shl 17))=0
	count:+(b &amp; (1 Shl 19))=0
	count:+(b &amp; (1 Shl 21))=0
	count:+(b &amp; (1 Shl 23))=0
	count:+(b &amp; (1 Shl 25))=0
	count:+(b &amp; (1 Shl 27))=0
	count:+(b &amp; (1 Shl 29))=0
	count:+(b &amp; (1 Shl 31))=0
	
Next
' check the last few candidates
Local m:Int=max_value/32
Local diff:Int=max_value-m*32

Local b:Int=flags[m]
For Local i:Int=1 To diff Step 2
	count:+(b &amp; mask[i])=0
	'Print m*32+i
Next

'finish
timer=MilliSecs()-timer
Print (timer/1000.0)+" seconds.. "+count+" primes found."

Local primes:Int[count]
Local prime_index:Int=0


For Local ii:Int=0 To max_value/32
	For Local b:Int=0 To 31
		If ((flags[ii] &amp; mask[b])=0) Then
			If (prime_index&lt;count) Then
				primes[prime_index]=ii*32+b
				If (primes[prime_index]&gt;1) Then
					prime_index:+1
				EndIf
			EndIf
		EndIf
	Next
Next

Print "done gathering primes.."
Print "getting ref primes.."

Local ref_primes:Int[]=primes_01(count)

For Local i:Int=0 To ref_primes.length-1
	If (ref_primes[i]&lt;&gt;primes[i]) Then
		Print ref_primes[i]+":"+primes[i]
		Exit
	EndIf
Next

Print "Done!"

End






Function primes_01:Int[](primes_count:Int)
	Local PR:Int=3
	Local primelist:Int[primes_count]
	Local prcnt:Int=1
	primelist[0]=2
	Local n:Int=0
	Local flag:Byte=False
	Repeat
		n=0
		flag=False
		While primelist[n]*primelist[n]&lt;=PR
			If (PR/(primelist[n]*1.0))=Int(PR/primelist[n]) Then
				flag=True
				Exit
			EndIf
			n:+1
		Wend
		If Not flag
			primelist[prcnt]=pr
			prcnt:+1
		EndIf
		PR:+2
	Until prcnt=primes_count
	Return primelist
End Function


</textarea><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1056930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is very exciting watching this thread over the last few days.<br><br>zzz, Nate, super fun!<br><br>Still analyzing your last bit of code zzz.  A pretty original line of thought there!<br><br><br>:D <br><br></td></tr></table><br>
<a name="1056931"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nate the Great</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow zzz, 3.9 seconds, 10,000,000 primes found.  I believe we have reached a sort of road block for efficiency of counting primes but zzz may prove me wrong.  (it may be faster in asm hint hint haha)  Anyway, I hadn't touched bmax for a while so this helped me really get into it and pick it back up.  thanks! <br><br></td></tr></table><br>
<a name="1056934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Shortwind, i realized it was the way to go when i messed around with nates latest creation. changing the flags array to ints instead of bytes made it way slower, so figured it would work the other way around too.<br><br>@Nate, try doing 1m primes instead, it will be way faster since the 10m prime test re-introduces the memory issue i tried to get rid of.. :)<br><br>I dont think ill mess around much more with this. Assembly wont really help since its mostly a memory issue now, the algo touches memory all over the place over and over again so it is most likely racking up a huge number of chache/page mispredictions. A single L2 misprediction can cost over 200 cycles accordingly to google, and for reference i think an ordinary integer addition is a one cycle ordeal.<br><br>One could probably rewrite the code to work around this in some way, but i cant really come up with any ideas atm. <br><br></td></tr></table><br>
<a name="1056957"></a>

<a name="1056958"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Expanded a bit on the preliminary culling, the code gives a pretty solid average of 0,075 seconds / 1m primes :D<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework brl.standardio
Import brl.math
Import brl.retro

'Local max_value:Int=179424674
Local max_value:Int=15485864

Local flags:Int[max_value/32+1]

Const mod32_mask:Int=%11111
Const div32_mask:Int=%11111111111111111111111111100000
Const even_mask:Int=%01010101010101010101010101010101

Local mask:Int[32]
For Local i:Int=0 To 31
	mask[i]=2^i
Next

'start
Local timer:Int=MilliSecs()

'/////////////////////////////////////////
'build a premask array
Local premask_size:Int=10
Repeat
	If (premask_size Mod 2 = 0) And (premask_size Mod 3 = 0) And (premask_size Mod 5 = 0) And (premask_size Mod 7 = 0) Then
		If (premask_size Mod 32 = 0) Then
			Exit
		EndIf
	EndIf
	premask_size:+10
Forever
'build array
Local premask_array:Int[premask_size/32]
For Local index:Int=0 To premask_array.length-1
	Local b:Int=0
	For Local i:Int=0 To 31
		If ((index*32+i) Mod 2 = 0) Then
			b :| Int(2^i)
		EndIf
		If ((index*32+i) Mod 3 = 0) Then
			b :| Int(2^i)
		EndIf
		If ((index*32+i) Mod 5 = 0) Then
			b :| Int(2^i)
		EndIf
		If ((index*32+i) Mod 7 = 0) Then
			b :| Int(2^i)
		EndIf
	Next
	premask_array[index]=b
Next
'debug
Rem
For Local index:Int=0 To premask_array.length-1
	Print Bin(premask_array[index])
Next
End Rem
'apply mask
Rem
For Local i:Int=0 To flags.length-1
	flags[i]=even_mask
Next
flags[0]:~mask[2]
End Rem

'apply premask

For Local index:Int=0 To flags.length-1
	flags[index]=premask_array[index Mod premask_array.length]
Next

flags[0]:~mask[2]
flags[0]:~mask[3]
flags[0]:~mask[5]
flags[0]:~mask[7]

'/////////////////////////////////////////

Local sqrnum:Int=Sqr(max_value)

For Local x:Int=9 To sqrnum Step 2
	Local index_byte:Int=(x &amp; div32_mask) Shr 5
	Local index_bit:Int=1 Shl (x &amp; mod32_mask)
	If ((flags[index_byte] &amp; index_bit)=0) Then
		Local tmp:Int=x
		Repeat
			tmp:+x
			index_byte=(tmp &amp; div32_mask) Shr 5
			index_bit=1 Shl (tmp &amp; mod32_mask)
			flags[index_byte]:|index_bit
		Until (tmp+x&gt;=max_value)
	EndIf
Next
Print (MilliSecs()-timer)/1000.0+" ..counting primes.."

Local count:Int=0
Rem
For Local k:Int=3 To max_value-1 Step 2
	Local index_byte:Int=(k &amp; div32_mask) Shr 5
	Local index_bit:Int=1 Shl (k &amp; mod32_mask)
	'If ((flags[index_byte] &amp; index_bit)=0) Then
	'	count:+1
	'EndIf
	count:+((flags[index_byte] &amp; index_bit)=0)
Next
End Rem

'count primes
For Local ii:Int=0 To max_value/32-1
	
	Local b:Int=flags[ii]
	
	'unrolled loop..
	
	count:+(b &amp; (1 Shl 1))=0
	count:+(b &amp; (1 Shl 3))=0
	count:+(b &amp; (1 Shl 5))=0
	count:+(b &amp; (1 Shl 7))=0
	count:+(b &amp; (1 Shl 9))=0
	count:+(b &amp; (1 Shl 11))=0
	count:+(b &amp; (1 Shl 13))=0
	count:+(b &amp; (1 Shl 15))=0
	count:+(b &amp; (1 Shl 17))=0
	count:+(b &amp; (1 Shl 19))=0
	count:+(b &amp; (1 Shl 21))=0
	count:+(b &amp; (1 Shl 23))=0
	count:+(b &amp; (1 Shl 25))=0
	count:+(b &amp; (1 Shl 27))=0
	count:+(b &amp; (1 Shl 29))=0
	count:+(b &amp; (1 Shl 31))=0
	
Next
' check the last few candidates
Local m:Int=max_value/32
Local diff:Int=max_value-m*32

Local b:Int=flags[m]
For Local i:Int=1 To diff Step 2
	count:+(b &amp; mask[i])=0
	'Print m*32+i
Next

'finish
timer=MilliSecs()-timer
Print (timer/1000.0)+" seconds.. "+count+" primes found."

Local primes:Int[count]
Local prime_index:Int=0


For Local ii:Int=0 To max_value/32
	For Local b:Int=0 To 31
		If ((flags[ii] &amp; mask[b])=0) Then
			If (prime_index&lt;count) Then
				primes[prime_index]=ii*32+b
				If (primes[prime_index]&gt;1) Then
					prime_index:+1
				EndIf
			EndIf
		EndIf
	Next
Next

Print "done gathering primes.."
Print "getting ref primes.."

Local ref_primes:Int[]=primes_01(count)

For Local i:Int=0 To ref_primes.length-1
	If (ref_primes[i]&lt;&gt;primes[i]) Then
		Print ref_primes[i]+":"+primes[i]
		Exit
	EndIf
Next

Print "Done!"

End






Function primes_01:Int[](primes_count:Int)
	Local PR:Int=3
	Local primelist:Int[primes_count]
	Local prcnt:Int=1
	primelist[0]=2
	Local n:Int=0
	Local flag:Byte=False
	Repeat
		n=0
		flag=False
		While primelist[n]*primelist[n]&lt;=PR
			If (PR/(primelist[n]*1.0))=Int(PR/primelist[n]) Then
				flag=True
				Exit
			EndIf
			n:+1
		Wend
		If Not flag
			primelist[prcnt]=pr
			prcnt:+1
		EndIf
		PR:+2
	Until prcnt=primes_count
	Return primelist
End Function




</textarea><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1057952"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xcessive</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> With the above code: 0.009200... seconds.<br><br>i7 extreme OC'd :D <br><br></td></tr></table><br>
<a name="1058478"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Imphenzia</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0.128000006 seconds<br>1000000 primes found!<br><br>i7 950 @ original 3.06GHz (non-debug) <br><br></td></tr></table><br>
<a name="1060003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> This thread is fantastic, well done all!  Fascinating. <br><br></td></tr></table><br>
<a name="1060035"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> 0.0540000014<br>1000000 primes found<br><br>i7 920 @ 2.98 GHZ (non-debug) <br><br></td></tr></table><br>
<a name="1060234"></a>

<a name="1060239"></a>

<a name="1060635"></a>

<a name="1060637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Had a bunch of school-related stuff to finish today, so figured the sensible thing to do was to write yet another sieve to post here. Same as the last one pretty much. Continuing on the memory footprint philosophy i threw out even numbers completely.<br><br>EDIT: on my computer it does 30m primes in just under 10 seconds, where 10m takes just over 2 seconds, so it scales fairly well this time. Set limit to 573259392 if you want to try :)<br><br>EDIT2: updated the prime number counting code so now it should run considerably faster on the 1m prime test too. For me its slightly more than twice as fast as the last one i posted.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

	SuperStrict
	
	Framework BRL.StandardIO
	Import BRL.Math
	Import BRL.Blitz
	
	'Const LIMIT:Int=1000
	'Const LIMIT:Int=982451654 '50m primes
	'Const LIMIT:Int=573259392 '30m primes
	'Const LIMIT:Int=179424674 '10m primes
	Const LIMIT:Int=15485864 '1m primes
	'Const LIMIT:Int=10000
	Const WORD_SIZE:Int=32
	
	Global wheel_mask:Int[]
	Global wheel_values:Int[]=[2,3,5,7,11,13]
	Global wheel_size:Int
	
	
	Global flags:Int[(LIMIT/2)/32+1]
	
	Const mod32:Int=%11111
	Const div32:Int=%11111111111111111111111111100000
	
	' ///////////////////////////////////////////////////////////////////////////
	
	InitWheel()
	
	WriteStdout "wheel bitmask initialized. "
	WriteStdout "size: "+(wheel_mask.length*WORD_SIZE)
	WriteStdout ", highest value: "+wheel_values[wheel_values.length-1]
	WriteStdout "~n"
	
	Delay 1000
	
	Print "Sieving values.."
	Local timer:Int=MilliSecs()
	
	For Local i:Int=0 To flags.length-1
		flags[i]=wheel_mask[i Mod wheel_mask.length]
	Next
	
	Local sqr_limit:Int=Sqr(LIMIT)/2+1
	For Local i:Int=1 To sqr_limit 'Sqr(LIMIT)/2+1
		Local index:Int=(i &amp; div32) Shr 5
		Local bit:Int=1 Shl (i &amp; mod32)
		If (flags[index] &amp; bit=0) Then
			Local v:Int=1+(i*2)
			Local temp:Int=i+v
			Repeat
				Local index:Int=(temp &amp; div32) Shr 5
				Local bit:Int=1 Shl (temp &amp; mod32)
				flags[index]:|bit
				temp:+v			
			Until (temp&gt;=(LIMIT/2))
		EndIf
	Next
	
	WriteStdout "Done! Took "+((MilliSecs()-timer)/1000.0)
	WriteStdout " seconds.. Counting primes.."
	WriteStdout "~n"
	
	' ----------------------------------------------------
		
	Local primes_count:Int=wheel_values.length
	For Local i:Int=0 To (LIMIT/2)/32-1
		Local b:Int=flags[i]
		Local count:Int=0
		'8
		count:+(b &amp; (1 Shl 0) = 0)
		count:+(b &amp; (1 Shl 1) = 0)
		count:+(b &amp; (1 Shl 2) = 0)
		count:+(b &amp; (1 Shl 3) = 0)
		count:+(b &amp; (1 Shl 4) = 0)
		count:+(b &amp; (1 Shl 5) = 0)
		count:+(b &amp; (1 Shl 6) = 0)
		count:+(b &amp; (1 Shl 7) = 0)
		'8
		count:+(b &amp; (1 Shl 8) = 0)
		count:+(b &amp; (1 Shl 9) = 0)
		count:+(b &amp; (1 Shl 10) = 0)
		count:+(b &amp; (1 Shl 11) = 0)
		count:+(b &amp; (1 Shl 12) = 0)
		count:+(b &amp; (1 Shl 13) = 0)
		count:+(b &amp; (1 Shl 14) = 0)
		count:+(b &amp; (1 Shl 15) = 0)
		'8
		count:+(b &amp; (1 Shl 16) = 0)
		count:+(b &amp; (1 Shl 17) = 0)
		count:+(b &amp; (1 Shl 18) = 0)
		count:+(b &amp; (1 Shl 19) = 0)
		count:+(b &amp; (1 Shl 20) = 0)
		count:+(b &amp; (1 Shl 21) = 0)
		count:+(b &amp; (1 Shl 22) = 0)
		count:+(b &amp; (1 Shl 23) = 0)
		'8
		count:+(b &amp; (1 Shl 24) = 0)
		count:+(b &amp; (1 Shl 25) = 0)
		count:+(b &amp; (1 Shl 26) = 0)
		count:+(b &amp; (1 Shl 27) = 0)
		count:+(b &amp; (1 Shl 28) = 0)
		count:+(b &amp; (1 Shl 29) = 0)
		count:+(b &amp; (1 Shl 30) = 0)
		count:+(b &amp; (1 Shl 31) = 0)
		' done
		primes_count:+count
	Next
	
	Local m:Int=(LIMIT/2)/32
	Local diff:Int=LIMIT-m*64
	diff:/2
	For Local i:Int=0 To diff-2
		primes_count:+(flags[m] &amp; Int(2^i) = 0)
	Next		
	
	timer=MilliSecs()-timer
	
	Local primes:Int[primes_count]
	primes_count=0
	
	For Local i:Int=0 To wheel_values.length-1
		primes[primes_count]=wheel_values[i]
		primes_count:+1
	Next
	
	For Local i:Int=1 To LIMIT/2-1
		Local index:Int=(i &amp; div32) Shr 5
		Local bit:Int=1 Shl (i &amp; mod32)
		If (flags[index] &amp; bit = 0) Then
			Local v:Int=1+(i*2)
			primes[primes_count]=v
			primes_count:+1
		EndIf	
	Next
	
	WriteStdout "Done! Took "+(timer/1000.0)+" seconds to find "
	WriteStdout "and count "+primes_count+" primes."
	
	Print ""
	Print "Validating result.."
	
	Local refprimes:Int[]=ReferencePrimes(primes_count)
	For Local i:Int=0 To primes_count-1
		'Print refprimes[i]
		If (refprimes[i]&lt;&gt;primes[i]) Then
			Print "!!"
			Print refprimes[i]+":"+primes[i]
			Exit
		EndIf
	Next
	
	Print "Done!"
	
	End
	
	' ///////////////////////////////////////////////////////////////////////////
	
	Function InitWheel()
		Local gcd:Int=wheel_values[0]
		For Local i:Int=1 To wheel_values.length-1
			gcd:*wheel_values[i]
		Next
		Local max_value:Int=gcd*32
		wheel_mask=New Int[gcd]
		For Local i:Int=0 To max_value-1
			Local value:Int=1+(i*2)
			For Local j:Int=0 To wheel_values.length-1
				If (value Mod wheel_values[j] = 0) Then
					Local index:Int=(i &amp; div32) Shr 5
					Local bit:Int=1 Shl (i &amp; mod32)
					wheel_mask[index]:|bit
				EndIf
			Next
		Next
		Return 
	End Function
	
	Function ReferencePrimes:Int[](primes_count:Int)
		Local PR:Int=3
		Local primelist:Int[primes_count]
		Local prcnt:Int=1
		primelist[0]=2
		Local n:Int=0
		Local flag:Byte=False
		Repeat
			n=0
			flag=False
			While primelist[n]*primelist[n]&lt;=PR
				If (PR/(primelist[n]*1.0))=Int(PR/primelist[n]) Then
					flag=True
					Exit
				EndIf
				n:+1
			Wend
			If Not flag
				primelist[prcnt]=pr
				prcnt:+1
			EndIf
			PR:+2
		Until prcnt=primes_count
		Return primelist
	End Function

</textarea><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060874"></a>

<a name="1060875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Am I the only one who still have some interest in this? Nate, Jesse, Shortwind? :) You guys probably have better things to do (im studying ~2days a week atm so i dont), just wondering if I should continue to post updates etc.<br><br>I could try and clarify whats going on in the code a bit if anyone wants me to. I havent done that much more than obfuscating the code from the original sieve so its not hard to understand the logic in any way.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060914"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Shortwind</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry, zzz, haven't lost interest, just been busy.<br><br>I believe the code we have in this thread is very usefull, and a good learning experience.  What I'd suggest now is that you modify your code to quickly, with reasonable memory requirements, find the X'th prime number, the next prime, and the previous prime.  (If you feel so inclined.)<br><br>In other words, if I tell your program that I want the 1,578th prime number, how fast can your program return that number?<br><br>If I give your program the number 95,456, how fast can it tell me the next or previous prime number?<br><br>And finally, (you'll have to start a new thread), what is the fastest method in BlitzMax for "factoring" a number into it's prime elements?<br><br>:D <br><br></td></tr></table><br>
<a name="1060937"></a>

<a name="1060938"></a>

<a name="1060940"></a>

<a name="1060941"></a>

<a name="1060950"></a>

<a name="1060952"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> That functionality would come as a bonus if i could get a segmented sieve to work properly (and fast enough). Youd still have a bit of overhead but it would be able to quite quickly calculate enough primes to be able to answer those questions :)<br><br>Ive been thinking about upping the performance of the sieve by packing values.. The last piece of code excludes even numbers completely, so:<br><br>a) I get a smaller memory footprint since the algorithm needs one bit per two values in the 1-limit range when culling prime candidates.<br><br>b) The culling code can be made much more efficient. Initially i hade the problem of prime multiples not existing in the flag array. For example the first multiple of 5 is 10, which is even so it doesnt exist as far as the sieve is concerned. This one was pretty easy to figure out and had the nice side-effect of making the culling loop twice as fast since i could skip every second multiple completely.<br><br>Ive been tinkering a bit with excluding multiples of 2,3,5 and 7 in the same way, but this makes the 1-limit range non-linear as opposed to just excluding odd numbers.. It would give the flag array a value density of around 440% (ie, 4,4values per bit) tho if i figured it out, which would give a very nice performance boost :D<br><br>After i nail those two ill get a factorization thread going :P<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1060982"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Proof of concept for a segmentet sieve. Seems to work properly so time to trim the code a bit i guess. Also opens up for multithreading which is always nice<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

	SuperStrict

	Framework BRL.StandardIO
	Import BRL.LinkedList
	
	Const MEMORY_LIMIT:Int=512 'kb
	Const SEGMENT_SIZE:Int=MEMORY_LIMIT*1000
	
	Global flags:Int[SEGMENT_SIZE]
	Global cull_values:TList=New TList
	Global current_segment:Int=0
	
	Const PRIME_INCREMENT:Int=64000 '64kb a time
	Global primes:Int[PRIME_INCREMENT]
	Global primes_count:Int=0
		
	'#####################################################################
		
	Const TARGET:Int=2000000
	Local time:Int=MilliSecs()
	
	Repeat
		Sieve()
	Until (primes_count&gt;=TARGET)
	
	time=MilliSecs()-time
	Print "The "+TARGET+"th prime is "+primes[TARGET-1]+". ("+(time/1000.0)+" s, "+current_segment+" segments)"
	
	End
	
	'#####################################################################
		
	Type TCullValue
		
		Field _base:Int
		Field _current:Int
		
		Function Create:TCullValue(p_base:Int, p_current:Int)
			Local this:TCullValue=New TCullValue
			this._base=p_base
			this._current=p_current
			Return this
		End Function
	
	End Type
	
	Function Sieve:Int()
		For Local i:Int=0 To flags.length-1
			flags[i]=0
		Next
		If (current_segment=0) Then
			''''''''''''''''''''''''''''''''''''''''''''''''''
			'first segment, do the ordinary sieve stuff here
			'sieve
			Local value:Int=2
			For Local i:Int=2 To SEGMENT_SIZE-1
				If (flags[i]=0) Then
					Local temp:Int=value+value
					If (temp&lt;SEGMENT_SIZE) Then
						Repeat
							flags[temp]=1
							temp:+value
						Until (temp&gt;=SEGMENT_SIZE)
					EndIf
					cull_values.AddLast(TCullValue.Create(value, temp))
				EndIf
				value:+1	
			Next
			'gather primes
			For Local i:Int=2 To SEGMENT_SIZE-1
				If (flags[i]=0) Then
					If (primes_count&gt;=primes.length) Then
						primes=primes[..primes.length+PRIME_INCREMENT]
					EndIf
					primes[primes_count]=i
					primes_count:+1
				EndIf
			Next
		Else
			''''''''''''''''''''''''''''''''''''''''''''''''''
			'arbitrary segment, cull with the values stored
			'from previous segments and then get the new
			'primes.
			Local value:Int=current_segment*SEGMENT_SIZE
			Local limit:Int=value+SEGMENT_SIZE
			'cull with stored values
			For Local o:TCullValue=EachIn cull_values
				While (o._current&lt;limit)
					If (o._current&gt;=value) Then
						flags[o._current-value]=1
					EndIf
					o._current:+o._base
				Wend
			Next
			'since no multiples can be found in the segment, count
			'new primes directly
			For Local i:Int=0 To SEGMENT_SIZE-1
				If (flags[i]=0) Then
					'add to cull values
					Local prime:Int=value+i
					cull_values.AddLast(TCullValue.Create(prime, prime+prime)) 
					'store prime
					If (primes_count&gt;=primes.length) Then
						primes=primes[..primes.length+PRIME_INCREMENT]
					EndIf
					primes[primes_count]=prime
					primes_count:+1
				EndIf
			Next
		EndIf
		current_segment:+1
	End Function

	End
</textarea> <br><br></td></tr></table><br>
<a name="1061047"></a>

<a name="1061049"></a>

<a name="1061051"></a>

<a name="1061053"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Messed around a bit today with this and managed to get a segmented sieve going. The code needs some major cleaning up which i dont feel like doing now so heres some pretty numbers to look at instead:<br><br>edit: changed my mind, heres the code instead. Bit of warning that while it churns out primes pretty fast (100000000th prime took 12sec for me) it gobbles up lots of memory.. The TARGET constant is what prime the code will find so mess around with that.<br><br>edit2: small optimization. its currently doing 10m primes in just over 0,7 seconds for me :P<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	SuperStrict

	Framework BRL.StandardIO
	Import BRL.LinkedList
	Import BRL.Math
	
	'GCD of 2,3,5,7 is 210, so segment size should be a multiple of this
	'expand this to 2,3,5,7,11,13 at least (GCD:30030, which is manageable)
	
	Const MEMORY_LIMIT:Int=500 'kb
	'Const SEGMENT_SIZE:Int=(MEMORY_LIMIT*210*4)
	Const SEGMENT_SIZE:Int=(2*3*5*7*11*13)
	
	Global flags:Byte[SEGMENT_SIZE]
	Global cull_values:TList=New TList
	Global current_segment:Int=0
	Global wheel:Byte[SEGMENT_SIZE]
	
	Global primes:TList=New TList
	Global primes_count:Int=0
	
	Global timer0:Int=0
	Global timer1:Int=0
	Global timer2:Int=0
	
	Global mem_usage:Int=0 'bytes
	mem_usage:+(SEGMENT_SIZE*2)
		
	'init wheel
	For Local i:Int=0 To SEGMENT_SIZE-1
		Local v:Int=1+(2*i)
		If (v Mod 2 = 0) Or (v Mod 3 = 0) Or (v Mod 5 = 0) Or (v Mod 7 = 0) Or (v Mod 11 = 0) Or (v Mod 13 = 0) Then
			wheel[i]=1
		EndIf
	Next
		
	'#####################################################################
		
	Delay 500
		
	Const TARGET:Int=10000000
	Local time:Int=MilliSecs()
	
	Repeat
		Sieve()
	Until (primes_count&gt;=TARGET)

	Local targetprime:Int=0
	Local count:Int=6
	
	For Local o:TCullValues=EachIn primes
		For Local i:Int=0 To o._count-1
			count:+1
			If (count=TARGET) Then
				targetprime=o._primes[i,0]
				Exit
			EndIf
		Next
	Next
	
	time=MilliSecs()-time
	Print "The "+TARGET+"th prime is "+targetprime+". ("+(time/1000.0)+" s, "+current_segment+" segments)"
	Print (timer0/1000.0)
	Print (timer1/1000.0)
	Print (timer2/1000.0)
	Print ""
	Print "Total memory usage: "+(mem_usage/1000)+" kb"
	Print ""

	
	End
	
	'#####################################################################
		
	Type TCullValue
		
		Field _base:Int
		Field _current:Int
		
		Function Create:TCullValue(p_base:Int, p_current:Int)
			Local this:TCullValue=New TCullValue
			this._base=p_base
			this._current=p_current
			Return this
		End Function
	
	End Type
	
	Type TCullValues
	
		Global prime_ratio:Int=1 'expected prime ratio 
	
		Field _base:Int
		Field _limit:Int
		Field _count:Int=0
		Field _primes:Int[,]
		
		Function Create:TCullValues(p_base:Int, p_limit:Int)
			Local this:TCullValues=New TCullValues
			this._base=p_base
			this._limit=p_limit
			this._count=0
			this._primes=New Int[(p_limit-p_base)/TCullValues.prime_ratio,2]
			mem_usage:+this._primes.length*8
			Return this
		End Function
		
	End Type
	
	Function Sieve:Int()
	
		Rem
		For Local i:Int=0 To flags.length-1
			flags[i]=wheel[i]
			'flags[i]=0
		Next
		End Rem
		
		MemCopy(Varptr flags[0], Varptr wheel[0], SEGMENT_SIZE)
		
		Local cull:TCullValues=TCullValues.Create(current_segment*SEGMENT_SIZE, current_segment*SEGMENT_SIZE+SEGMENT_SIZE)
		cull._count=0
		If (current_segment=0) Then
			Local t0:Int=MilliSecs()
			''''''''''''''''''''''''''''''''''''''''''''''''''
			'first segment, do the ordinary sieve stuff here
			primes_count:+4 '2,3,5,7
			'Local tt:Int=MilliSecs()
			For Local i:Int=1 To SEGMENT_SIZE-1
				Local value:Int=1+(i*2)
				If (flags[i]=0) Then
					Local temp:Int=i+value 'temp is an index, not value!
					If (temp&lt;SEGMENT_SIZE) Then
						Repeat
							flags[temp]=1
							temp:+value
						Until (temp&gt;=SEGMENT_SIZE)
					EndIf
					'cull_values.AddLast(TCullValue.Create(value, temp))
					cull._primes[cull._count,0]=value
					cull._primes[cull._count,1]=temp
					cull._count:+1
					primes_count:+1
				EndIf
			Next
			'tt=MilliSecs()-tt
			'Print "sieve: "+(tt/1000.0)
			t0=MilliSecs()-t0
			timer0:+t0
		Else
			''''''''''''''''''''''''''''''''''''''''''''''''''
			'arbitrary segment, cull with the values stored
			'from previous segments and then get the new
			'primes.
			'Local tt:Int=MilliSecs()
			Local t:Int
			t=MilliSecs()
			Local value:Int=current_segment*SEGMENT_SIZE
			Local limit:Int=value+SEGMENT_SIZE

				
			'cull with stored values..		
			For Local o:TCullValues=EachIn primes
				Local done:Int=False
				
				For Local i:Int=0 To o._count-1
				
					Local base:Int=o._primes[i,0]
					Local cur:Int=o._primes[i,1]
					
					If (base*base&gt;=limit*2) Then
						done=True
						Exit
					EndIf
					
					While (cur&lt;value)
						cur:+base
					Wend
					
					While (cur&lt;limit)
						flags[cur-value]=1
						cur:+base
					Wend
					
					o._primes[i,0]=base
					o._primes[i,1]=cur
					
				Next
				
				If (done=True) Then
					Exit
				EndIf
				
			Next
			
			
			
			t=MilliSecs()-t
			timer1:+t
			t=MilliSecs()
			
			'since no multiples can be found in the segment new primes can
			'be fetched right away
			For Local i:Int=0 To SEGMENT_SIZE-1
				If (flags[i]=0) Then
					'add to cull values
					Local prime:Int=1+2*(value+i)
					'Print prime
					'cull_values.AddLast(TCullValue.Create(prime, value+i)) 
					cull._primes[cull._count,0]=prime
					cull._primes[cull._count,1]=value+i
					cull._count:+1
					'Print cull._count
					primes_count:+1
				EndIf
			Next
			t=MilliSecs()-t
			timer2:+t
			'tt=MilliSecs()-tt
			'Print "sieve: "+(tt/1000.0)+" range: "+limit+"  primes: "+primes_count
		EndIf
		' update prime ratio and add current cull values to list
		TCullValues.prime_ratio=((cull._limit-cull._base)/cull._count)-1
		primes.AddLast(cull)
		current_segment:+1
	End Function

	End
</textarea><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1074334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> A bit of thread necromancy here.<br><br>I started refactoring the above code into something useful but lost interest soon afterwards.. Remembered the topic and figured id post it here anyways if someone is interested.<br><br>Feel free to try it and post some execution times :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

	Rem
	this version uses ~520mb of memory for 100m primes, while the
	bit array version uses ~140mb. The speed difference is quite big
	tho, 8s compared to ~15s, almost twice as fast..
	End Rem
	
	SuperStrict
	
	Framework brl.standardio
	Import brl.linkedlist
	Import brl.blitz
	Import brl.random
	Import brl.math

	Rem
	End Rem

	Print ""

	Local t:Int=MilliSecs()

	For Local i:Int=1 To 20
	
		Local index:Int=i*5000000
		Local prime:Int=TSoE.GetPrime(index)
		't=MilliSecs()-t
		Print "The "+index+"th prime is "+prime+". ( total running time: "+((MilliSecs()-t)/1000.0)+" seconds )"
		
	Next
	
	Input()
	
	End

	Rem
	######################################################################
	End Rem

	Type TSoE
	
		Rem
		End Rem
		
		Const SEGMENTSIZE:Int=2*3*5*7*11*13
		
		Global Init:Int=False
		
		Global arrSkipValues:Int[]=[2,3,5,7,11,13]
		Global arrWheel:Byte[SEGMENTSIZE]
	
		Global listCullValues:TList
		Global Primes:Int
		Global BiggestPrime:Int
		Global CurrentSegment:Int
		
		Rem
		End Rem
		
		Function Initialize:Int()
			If (TSoe.Init=False) Then
				'init wheel
				For Local i:Int=0 To TSoE.SEGMENTSIZE-1
					Local v:Int=1+(i Shl 1)
					'WriteStdout v
					For Local j:Int=0 To TSoe.arrSkipValues.length-1
						If (v Mod TSoE.arrSkipValues[j] = 0) Then
							'WriteStdout "!"
							TSoE.arrWheel[i]=1
							Continue
						EndIf
					Next
					'WriteStdout "~n"
				Next
				'init misc
				TSoE.listCullValues=New TList
				TSoE.Primes=0
				TSoE.BiggestPrime=0
				TSoE.CurrentSegment=0
				'done
				TSoE.Init=True
				Return True
			EndIf
			'no init done if object was already initialized
			Return False
		End Function
		
		Rem
		End Rem
		
		Function Sieve:TSoECull(segment:Int)
			'create cull object and flags
			Local cull:TSoECull=TSoECull.Create(segment*TSoE.SEGMENTSIZE, TSoE.SEGMENTSIZE)
			Local flags:Byte[TSoE.SEGMENTSIZE]
			'copy wheel to flags
			MemCopy(Varptr flags[0], Varptr TSoE.arrWheel[0], TSoE.SEGMENTSIZE)
			'sieve
			If (segment=0) Then
				'----------------------------------------------------
				'first segment
				TSoE.Primes:+TSoE.arrSkipValues.length
				For Local i:Int=1 To TSoE.SEGMENTSIZE-1
					Local value:Int=1+(i Shl 1)
					If (flags[i]=0) Then
						Local temp:Int=i+value
						If (temp&lt;TSoE.SEGMENTSIZE) Then
							Repeat
								flags[temp]=1
								temp:+value
							Until (temp&gt;=TSoE.SEGMENTSIZE)
						EndIf
						cull._flags[cull._primes]=value
						cull._primes:+1
					EndIf
				Next
			Else
				'----------------------------------------------------
				'arbitrary segment
				
				Local value:Int=segment*TSoE.SEGMENTSIZE
				Local limit:Int=value+TSoE.SEGMENTSIZE
				Local limit2:Int=limit Shl 1
				'limit2=Sqr(limit2)
				
				Local o:TSoECull
				For o=EachIn TSoE.listCullValues
					Exit
				Next
				
				'For Local o:TSoECull=EachIn TSoE.listCullValues
				
					'Local done:Int=False
					For Local i:Int=0 To o._primes-1
						Local base:Int=o._flags[i]
						If (base*base&gt;=limit2) Then
						'If (base&gt;limit2) Then
							Exit
						EndIf
						Local cur:Int=base Shr 1
						Local t:Int=value-cur
						cur:+(t-(t Mod base))
						cur:-value
						If (cur&lt;0) Then
							cur:+base
						EndIf
						While (cur&lt;TSoE.SEGMENTSIZE)
							flags[cur]=1
							cur:+base
						Wend
					Next
			
					'If (done=True) Then
					'	Exit
					'EndIf
				'Next
				
				'considering the limiting values above the code is a bit oddly
				'written, but nothing to gain from rewriting it really..
				
				For Local i:Int=0 To TSoE.SEGMENTSIZE-1
					If (flags[i]=0) Then
						Local prime:Int=1+((value+i) Shl 1)
						cull._flags[cull._primes]=prime
						cull._primes:+1
					EndIf
				Next
				
			EndIf
			'done
			Return cull
		End Function
		
		Rem
		End Rem
		
		Function GetPrime:Int(index:Int, threads:Int=1)
			TSoE.Initialize()
			While (TSoE.Primes&lt;index)
				Local cull:TSoECull=TSoE.Sieve(TSoE.CurrentSegment)
				TSoE.Primes:+cull._primes
				TSoE.listCullValues.AddLast(cull)
				TSoE.CurrentSegment:+1
				TSoECull.prime_ratio=(cull._range/cull._primes)-1
			Wend
			'prime can now be found in cull values.. find and
			'return it.
			Local prime:Int=0
			Local count:Int=TSoE.arrSkipValues.length
			For Local o:TSoECull=EachIn TSoE.listCullValues
				If (count+o._primes&lt;index) Then
					count:+o._primes
				Else
					For Local i:Int=0 To o._primes-1
						count:+1
						If (count=index) Then
							Return o._flags[i]
						EndIf
					Next
				EndIf
			Next
			'shouldnt get here..
			Return -1
		End Function
	
	End Type

	Rem
	######################################################################
	End Rem

	Type TSoECull

		Global prime_ratio:Int=1
		
		Field _base:Int
		Field _range:Int
		Field _primes:Int
		Field _flags:Int[]
		
		Function Create:TSoECull(base:Int, range:Int)
			Local this:TSoECull=New TSoECull
			this._base=base
			this._range=range
			this._primes=0
			this._flags=New Int[this._range/TSoECull.prime_ratio+1]
			Return this
		End Function

	End Type
</textarea> <br><br></td></tr></table><br>
<a name="1074484"></a>

<a name="1074570"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Peter</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
The 100000000th prime is 2038074743. ( total running time: 8.94799995 seconds )
</pre><br>from my company notebook (Intel Core 2 Duo, 2GHz, 2 GB RAM)<br><br><pre class=code>
The 100000000th prime is 2038074743. ( total running time: 7.98600006 seconds )
</pre><br>from my Intel Core 2 6400  2,13 GHz, 2 GB RAM (growing old now)<br><br>-- Peter<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1074488"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
The 100000000th prime is 2038074743. ( total running time: 5.26900005 seconds )
</pre><br><br>work pc: i3 3.06GHz <br><br></td></tr></table><br>
<a name="1074497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>The 100000000th prime is 2038074743. ( total running time: 6.32000017 seconds )</pre><br><br>Mac Pro (mid 2010) 8 core (2x4 2.4ghz Xenon) with a few things in the background (shouldn't make much of a difference, extra cores and such)<br><br>Wonder if memory/bus speed would start having an impact with that high a load generated in such a short time... <br><br></td></tr></table><br>
<a name="1167729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Nate the Grate!<br><br>It works just great on my laptop:<br><br>1.48599994 seconds<br>1000000 primes found!<br><br>My computer type is:<br>Intel Core 2 CPU T5200 @ 1.6 Ghz speed<br>(Centrino Duo) HP Pavilion DV6245us<br>4GB memory, 32-bit, Windows 7 <br><br></td></tr></table><br>
<a name="1167844"></a>

<a name="1167845"></a>

<a name="1167846"></a>

<a name="1167847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >PowerPC603</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
The 100000000th prime is 2038074743. ( total running time: 3.68799996 seconds )
</pre><br><br>64-bit Quad Core i5-3450 @3.1GHz<br>12GB RAM<br>64-bit Windows 7 Home Premium SP 1<br>AMD Radeon HD7770 1GB<br><br><br>Using the edited code in first post:<br><pre class=code>
0.194999993 seconds
1000000 primes found!
</pre><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
