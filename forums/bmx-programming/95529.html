<!DOCTYPE html><html lang="en" ><head ><title >Realtime Synthesis with openAL</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Realtime Synthesis with openAL</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Realtime Synthesis with openAL</a><br><br>
<a name="1100716"></a>

<a name="1100718"></a>

<a name="1100727"></a>

<a name="1100751"></a>

<a name="1101101"></a>

<a name="1101102"></a>

<a name="1101533"></a>

<a name="1102097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> YES, maybe I should make this a tutorial, but few of you may have been itching to figure this out and got as frustrated as I used to be about it.<br><br>But I did plenty of C++ coding in the meantime, learned a fair bit about realtime synthesis and got comfortable enough to have another look at it in Bmax again. That, and the fact that Tomas Petterson (drpetter) has been here for a few days and we've made a bunch of nonsense together. Anyway, here it goes...<br><br>OpenAL streaming to use for realtime synthesis in BlitzMax...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import pub.OpenAL
Import brl.RamStream
'=============================================================================
AppTitle="openAL realtime synth/streaming"

SetGraphicsDriver GLMax2DDriver()
Const Width:Int =	1280
Const Height:Int =	720
Global hWidth:Int=Width*0.5
Global hHeight:Int=Height*0.5
GLGraphics (Width,Height,0)

glewInit()
glFlush()
glOrtho (0, Width, Height, 0, -100, 100)
glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);

'============================ AUDIO setup ====================================
Global audiotrue:Byte = 0

If OpenALInstalled()
	audiotrue=1
Else
	GLDrawText"Audio OFF: OpenAL audio is not installed. &lt;hit any key to continue!&gt;",0,hHeight-17
	Flip 0
	WaitKey()
	End
End If

Private

Global ALDevice:Int
Global ALContext:Int

Function StartOpenAL()
	If Not ALContext
		ALDevice=alcOpenDevice(Null) 
		ALContext=alcCreateContext(ALDevice, Null) 
		alcMakeContextCurrent(ALContext)
	EndIf
EndFunction

Function StopOpenAL()
	If OpenALInstalled()
		alcDestroyContext(ALContext)
		alcCloseDevice(ALDevice)
		ALContext=0
		ALDevice=0
	End If
EndFunction

OnEnd StopOpenAL

Public

Type TListener
	Function SetMatrix(mat:Byte Ptr)
		StartOpenAL()
		Local matf:Float[16]
		MemCopy matf,mat,64
		alListener3f AL_POSITION,matf[12],matf[13],matf[14]
		alListenerfv AL_ORIENTATION,[matf[4],matf[5],matf[6],matf[8],matf[9],matf[10]]
	EndFunction
EndType
'============================ The Real Deal ==================================
Const BUFFER_SIZE:Int=1800

Global source:Int
Global buffers:Int[3]
Global frequency:Int
Global format:Int
Global buf:Byte Ptr

StartOpenAL()

alGenBuffers(3,buffers)
alGenSources(1, Varptr source)

Global buffer_A:Short[BUFFER_SIZE]

format = AL_FORMAT_MONO16
Local tick:Int = 0
buf = Byte Ptr buffer_A
For Local i:Int = 0 Until BUFFER_SIZE
		buffer_A[i] = 0
Next
alBufferData(buffers[0], format, buf,BUFFER_SIZE*2,44100)

alBufferData(buffers[1], format, buf,BUFFER_SIZE*2,44100)
alBufferData(buffers[2], format, buf,BUFFER_SIZE*2,44100)

alSourceQueueBuffers(source, 1, Varptr buffers[0])
alSourceQueueBuffers(source, 1, Varptr buffers[1])
alSourceQueueBuffers(source, 1, Varptr buffers[2])
alSourcePlay(source)
Local freq:Double = 1.0
Local vol:Double = 0.0
Local a:Double = 0.0

While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	glClear(GL_COLOR_BUFFER_BIT)
	If audiotrue
		Local buffer:Int
		Local val:Int
		
		alGetSourcei(source, AL_BUFFERS_PROCESSED, Varptr val)
			While(val)
				alSourceUnqueueBuffers(source,1, Varptr buffer)
				For Local i:Int = 0 Until BUFFER_SIZE
					buffer_A[i] = vol*Sin(a)*$7fff
					
					Local cntr:Double =0.5*2^(MouseX()/(0.125*Width))
					freq:+(cntr-freq)*0.0002
					a:+freq
					vol:+((1.0-(Double(MouseY())/Height))-vol)*0.0002
				Next
				alBufferData(buffer, format, buf, BUFFER_SIZE*2, 44100)
				alSourceQueueBuffers(source,1, Varptr buffer)
				val:-1
			Wend
		If val&lt;=0
			alGetSourcei(source, AL_SOURCE_STATE, Varptr val)
			If val&lt;&gt; AL_PLAYING
				alSourcePlay(source)
			End If
		End If
	End If
	
	Local st:Float = Float(Width)/8
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			glVertex2d(x*st,0)
			glVertex2d(x*st,Height)
		glEnd
	Next
	For Local i:Int = 0 Until BUFFER_SIZE
			Local v:Float = Float((buffer_A[i]+$7fff) Mod $ffff)/$ffff
			glBegin(GL_POINTS)
				glVertex2d(i,10+700*v)
			glEnd
	Next
	Flip 1
Wend

</textarea><br><br>I'll make it a tutorial, if you want me to. But it is fairly simple. A small setup section up there is from a type that &lt;argh, who was that again?&gt; posted here, but I was just too lazy to rewrite those lines.<br><br>HERE I SHALL POST THE LATEST CODE - ALWAYS:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import pub.OpenAL
Import brl.RamStream
Import brl.threads

'=============================================================================
AppTitle="Theriphone (openAL)              [F4]record steps               [F5]play"

SetGraphicsDriver GLMax2DDriver()
Const Width:Int =	1280
Const Height:Int =	720
Global hWidth:Int=Width*0.5
Global hHeight:Int=Height*0.5
GLGraphics (Width,Height,0)

glewInit()
glFlush()
glOrtho (0, Width, Height, 0, -100, 100)
glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 

'============================ AUDIO setup ====================================
Global audiotrue:Byte = 0

If OpenALInstalled()
	audiotrue=1
Else
	GLDrawText"Audio OFF: OpenAL audio is not installed. &lt;hit any key to continue!&gt;",0,hHeight-17
	Flip 0
	WaitKey()
	End
End If

'============================ The Real Deal ==================================
Const BUFFER_SIZE:Int=1400
Const SAMPLING_FRQ:Int=44100

Global source:Int
Global buffers:Int[3]
Global frequency:Int
Global format:Int
Global buf:Byte Ptr

Global ALDevice:Int =alcOpenDevice(Null) 
Global ALContext:Int =alcCreateContext(ALDevice, Null) 
alcMakeContextCurrent(ALContext)

alGenBuffers(3,buffers)
alGenSources(1, Varptr source)

alListenerfv(AL_POSITION,[0.0,0.0,0.0])
alListenerfv(AL_VELOCITY,[0.0,0.0,0.0])
alListenerfv(AL_ORIENTATION,[0.0,0.0,-1.0])

Global buffer_A:Short[BUFFER_SIZE]

format = AL_FORMAT_MONO16
buf = Byte Ptr buffer_A
For Local i:Int = 0 Until BUFFER_SIZE
		buffer_A[i] = 0
Next
alBufferData(buffers[0], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[1], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[2], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)

alSourceQueueBuffers(source, 1, Varptr buffers[0])
alSourceQueueBuffers(source, 1, Varptr buffers[1])
alSourceQueueBuffers(source, 1, Varptr buffers[2])
alSourcePlay(source)

Global mousetrap_x:Float
Global mousetrap_y:Float

Global pattern_ocw:Float
Global pattern_och:Float
Global pattern_ocx:Float
Global pattern_ocy:Float

Global tick:Int = 0
Global tick_gap:Int = 0
Global record:Byte = 0
Global timestep:Int = 0
Global timestep_advance:Byte=0
Global timestep_previous:Int
Global pattern_length:Int = 128
Global pattern:patterns = New patterns
For Local i:Int = 0 Until pattern_length
	pattern.Create(i)
Next
Global pattern_copy:Byte = 0
Global beam:notebeam = New notebeam

Global notefreqs:Float[] = [0.5,0.52973,0.56124,0.59461,0.62996,0.66742,0.70711,0.74916,0.7937 ,0.8409 ,0.8909 ,0.94388]
Global notenames:String[]= ["C-","C#","D-","D#","E-","F","F#","G-","G#","A-","A#","B-"]
Global notecols:Float[]  = [0.3,0.1,0.3,0.1,0.3,0.3,0.1,0.3,0.1,0.3,0.1,0.3]


Global play:Byte = 0
Global cur_step:Int = 0
Global timer:Int = 0
Global key_delay:Int = 0

Global tempo:Float = 120.0
Global speed:Int = 4
Global speeds:Float[]=[0.0625, 0.083333, 0.125, 0.166666 ,0.25 ,0.333333 ,0.5 ,0.666666 ,1.0 ,1.333333,2.0]
Global tempo_div:Float = 120/tempo
Global tempo_mod:Float =speeds[speed]*tempo_div

Global oct:Int = 1
Global note_oct:Int = 12
Global freq:Double = 1.0
Global vol:Double = 0.0
Global instrument_typ:Byte = 0

Global a:Double = 0.0
Global theremin_cntr:Double = 0.0
Global thrmn_snd:sound = New sound
thrmn_snd = sound.Create(0,0,0,instrument_typ)	

Global snd:sound = New sound

Global delay_length:Int = 44099
Global fx_tempo_mod:Float =delay_length*tempo_div
Global delay_buffer:Float[44100]
For Local i:Int = 0 Until 44100
	delay_buffer[i]=0
Next

While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	process()
	Flip 0
Wend
	alcDestroyContext(ALContext)
	alcCloseDevice(ALDevice)
	ALContext=0
	ALDevice=0
End

Function process:Object(data:Object = Null)
	glClear(GL_COLOR_BUFFER_BIT)
	Local SHIFT_DOWN:Byte = KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
	Local CONTROL_DOWN:Byte = KeyDown(KEY_LCONTROL) Or KeyDown(KEY_RCONTROL)
	Local note_value:Int = -1	
	If Not SHIFT_DOWN
		If KeyHit(KEY_HOME) Then If speed&lt;10 Then speed:+1;tempo_mod =speeds[speed]*tempo_div;fx_tempo_mod =delay_length*tempo_div
		If KeyHit(KEY_END) Then If speed&gt;0 Then speed:-1;tempo_mod =speeds[speed]*tempo_div;fx_tempo_mod =delay_length*tempo_div
		If KeyHit(KEY_PAGEUP) Then oct=oct Shl 1;note_oct:+12
		If KeyHit(KEY_PAGEDOWN) Then If oct&gt;1 Then oct=oct Shr 1;;note_oct:-12
	Else
		If KeyHit(KEY_PAGEUP) Then instrument_typ:+1;thrmn_snd.instrument=instrument_typ
		If KeyHit(KEY_PAGEDOWN) Then  instrument_typ:-1;thrmn_snd.instrument=instrument_typ
		If KeyHit(KEY_HOME) 
			tempo:+1; tempo_div = 120/tempo 
			tempo_mod =speeds[speed]*tempo_div
			fx_tempo_mod =delay_length*tempo_div
		EndIf
		If KeyHit(KEY_END) 
			tempo:-1; tempo_div = 120/tempo 
			tempo_mod =speeds[speed]*tempo_div
			fx_tempo_mod =delay_length*tempo_div
		EndIf
	End If
	
	
	If KeyHit(KEY_Z) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.5	,1.0,0 ,instrument_typ); note_value =0;beam.Create(note_oct+note_value,1.0)	
		If KeyHit(KEY_S) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.52973,1.0,1 ,instrument_typ); note_value =1;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_X) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.56124,1.0,2 ,instrument_typ); note_value =2;beam.Create(note_oct+note_value,1.0)	
		If KeyHit(KEY_D) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.59461,1.0,3 ,instrument_typ); note_value =3;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_C) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.62996,1.0,4 ,instrument_typ); note_value =4;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_V) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.66742,1.0,5 ,instrument_typ); note_value =5;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_G) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.70711,1.0,6 ,instrument_typ); note_value =6 ;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_B) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.74916,1.0,7 ,instrument_typ); note_value =7	;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_H) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.7937 ,1.0,8 ,instrument_typ); note_value =8	;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_N) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.8409 ,1.0,9 ,instrument_typ); note_value =9	;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_J) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.8909 ,1.0,10,instrument_typ); note_value =10;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_M) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*0.94388,1.0,11,instrument_typ); note_value =11;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_COMMA) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*1.0	,1.0,12,instrument_typ); note_value =12;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_L) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*1.05946,1.0,13,instrument_typ); note_value =13;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_PERIOD) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*1.12246,1.0,14,instrument_typ); note_value =14;beam.Create(note_oct+note_value,1.0)
	   If KeyHit(KEY_SEMICOLON)Then If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*1.18921,1.0,15,instrument_typ); note_value =15;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_SLASH) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 0)*1.25992,1.0,16,instrument_typ); note_value =16;beam.Create(note_oct+note_value,1.0)
																		 					
	If KeyHit(KEY_Q) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.5	,1.0,12,instrument_typ); note_value =12;beam.Create(note_oct+note_value,1.0)	
		If KeyHit(KEY_2) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.52973,1.0,13,instrument_typ); note_value =13;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_W) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.56124,1.0,14,instrument_typ); note_value =14;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_3) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.59461,1.0,15,instrument_typ); note_value =15;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_E) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.62996,1.0,16,instrument_typ); note_value =16;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_R) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.66742,1.0,17,instrument_typ); note_value =17;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_5) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.70711,1.0,18,instrument_typ); note_value =18;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_T) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.74916,1.0,19,instrument_typ); note_value =19;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_6) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.7937 ,1.0,20,instrument_typ); note_value =20;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_Y) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.8409 ,1.0,21,instrument_typ); note_value =21;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_7) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.8909 ,1.0,22,instrument_typ); note_value =22;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_U) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*0.94388,1.0,23,instrument_typ); note_value =23;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_I) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.0	,1.0,24,instrument_typ); note_value =24;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_9) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.05946,1.0,25,instrument_typ); note_value =25;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_O) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.12246,1.0,26,instrument_typ); note_value =26;beam.Create(note_oct+note_value,1.0)
		If KeyHit(KEY_0) Then 		If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.18921,1.0,27,instrument_typ); note_value =27;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_P) Then 			If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.25992,1.0,28,instrument_typ); note_value =28;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_OPENBRACKET)Then 	If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.33483,1.0,29,instrument_typ); note_value =29;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_EQUALS) 	  Then 	If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.41421,1.0,30,instrument_typ); note_value =30;beam.Create(note_oct+note_value,1.0)
	If KeyHit(KEY_CLOSEBRACKET)Then If Not SHIFT_DOWN Then sound.Create((oct Shl 1)*1.49831,1.0,31,instrument_typ); note_value =31;beam.Create(note_oct+note_value,1.0)
																							
																							
	'------------------------------------------ DRAW pattern
	Local pattern_bottom:Float = 0
	If pattern
		If MouseDown(3) 'mac users may not like that!
			If mousetrap_x&lt;0 Then mousetrap_x=MouseX();mousetrap_y=MouseY()
			If KeyDown(KEY_LALT) Or KeyDown(KEY_RALT)
				Local mx:Float = (mousetrap_x-pattern.cx)/pattern.cw
				Local my:Float = (pattern.cy+pattern.h-mousetrap_y)/pattern.ch
				pattern.cw=pattern_ocw+0.1*(MouseX()-mousetrap_x); If pattern.cw&lt;1 Then pattern.cw=1; If pattern.cw&gt;10 Then pattern.cw=10; 
				pattern.ch=pattern_och-0.1*(MouseY()-mousetrap_y); If pattern.ch&lt;1 Then pattern.ch=1; If pattern.ch&gt;10 Then pattern.ch=10; 
				pattern.cx=mousetrap_x-mx*pattern.cw
				pattern.cy=mousetrap_y+my*pattern.ch-pattern.h
			Else
				pattern.cx=pattern_ocx+(MouseX()-mousetrap_x) 
				pattern.cy=pattern_ocy+(MouseY()-mousetrap_y)
			EndIf
			'If pattern.cw&lt;(Width/pattern_length) Then pattern.cw=Width/pattern_length;
			If pattern.cw&lt;4 Then pattern.cw=4;
			If pattern.ch&lt;4 Then pattern.ch=4
			If pattern.cx&gt;0 Then pattern.cx=0;'mousetrap_x=MouseX();pattern_ocx=pattern.cx 
			'If pattern.cx&lt;Width-(pattern.cw*pattern_length) Then pattern.cx=Width-(pattern.cw*pattern_length);'mousetrap_x=MouseX();pattern_ocx=pattern.cx 
			If pattern.cy&lt;0 Then pattern.cy=0; 
			If pattern.cy&gt;(89*pattern.ch-pattern.h) Then pattern.cy=(89*pattern.ch-pattern.h) ; 
		Else If Not (MouseDown(1) Or MouseDown(2))
			mousetrap_x=-1
			pattern_ocw=pattern.cw
			pattern_och=pattern.ch
			pattern_ocx=pattern.cx
			pattern_ocy=pattern.cy
		End If
		pattern_bottom = pattern.y+pattern.h
		'----------------------- MEASURES (columns)
		glColor4f(0.25,0.15,0.05,1.0)
		Local measure_bar:Int = 3
		Local measure_counter:Int = 0
		For pattern = EachIn pattern.steplist
			If pattern.time&gt;=-(pattern.cx/pattern.cw+pattern.cw)
				'If pattern.time&gt;=pattern_length Then Exit
				If record Then If pattern.time=timestep Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
				If play Then If pattern.time=cur_step-1 Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
				
				If measure_counter = 0 Then measure_bar = 3 Else measure_bar = 1
				measure_counter=(pattern.time+1) Mod (2.0/speeds[speed])'4 	'--------- 4/4 signature
				
				If pattern.selected Then glColor3f(0.2,0.5,0.7); 
				Local x:Float = pattern.cx+	  pattern.time*pattern.cw+(measure_bar-1)
				Local w:Float = 			  pattern.cw-measure_bar
				quad(x,0,	w,pattern.h)
					
				glBlendFunc (GL_SRC_ALPHA,GL_ONE) 
				If pattern.note.value=-1 Or pattern.notelist.Count()=0 Then glColor3f(0.15,0.07,0.05)
				quad(x,0,	w,pattern.h)

				glColor3f(0.25,0.15,0.05)
				glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
			End If
		Next
		'----------------------- MEASURES (notes)
		
		For pattern = EachIn pattern.steplist
			For Local n:note = EachIn pattern.notelist
				If n.value&gt;-1 
					Local y:Float = pattern.cy+(pattern.h+11*pattern.ch)-n.value*pattern.ch
					If y&gt;-pattern.ch And y&lt;pattern.h 
						Select n.instrument
							Case 0 glColor4f(1.0,0.2,0.0,0.5)
							Case 1 glColor4f(0.0,1.0,0.2,0.5)
							Case 2 glColor4f(0.0,0.2,1.0,0.5)
						End Select
						quad(pattern.cx+pattern.time*pattern.cw+1,y,pattern.cw-2,pattern.ch)
						glColor3f(1.0,1.0,1.0)
						box(pattern.cx+pattern.time*pattern.cw+1,y,pattern.cw-2,pattern.ch)
					EndIf
				EndIf
			Next
		Next
		
		'----------------------- BOGUS FUN HIGHLIGHT PLAYED NOTE
		glBlendFunc (GL_SRC_ALPHA,GL_ONE) 
		beam.update(pattern.cy,pattern.h,pattern.ch)
		glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
		
		glColor4f(0.0,0.0,0.0,0.45)
		For Local i:Int = 0 To (pattern.h/pattern.ch)+1
			Local y:Float = (pattern.cy Mod pattern.ch)+pattern.h-(i)*pattern.ch
			If y&gt;pattern.x+pattern.h Then Continue
			line(pattern.cx,y,pattern.cw*pattern_length)
			If ((i+Int(pattern.cy/pattern.ch)) Mod 12)=0 Then line(pattern.cx,y-1,pattern.cw*pattern_length)
		Next
		glColor4f(0.1,0.0,0.0,0.25)
		For Local i:Int = 0 To (pattern.h/pattern.ch)+1
			Local y:Float = ((pattern.cy) Mod pattern.ch)+pattern.h-(i)*pattern.ch
			If y&lt;pattern.x+pattern.h 
				Local iy:Int = (i+Int(pattern.cy/pattern.ch))Mod 12
				If iy=2 Or iy=4 Or iy=7 Or iy=9 Or iy=11 Then quad(pattern.cx,y,pattern.cw*pattern_length,pattern.ch)
			EndIf
		Next
		'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MOUSE on pattern
		Local rela_my:Float = MouseY()
		Local rela_mx:Float = MouseX()-pattern.cx
		If rela_my&lt;pattern.h
			glBlendFunc (GL_SRC_ALPHA,GL_ONE) 
			glColor4f(0.25,0.1,0.0,1.0)
			Local hx:Int = rela_mx/pattern.cw
			If hx&lt;0 Then hx=0
			If hx&gt;pattern.steplist.Count()-1 Then hx = pattern.steplist.Count()-1
			quad(pattern.cx+pattern.cw*hx,0,pattern.cw,pattern.h)
			Local pattern_tmp:patterns = patterns(pattern.steplist.ValueAtIndex(hx))
			Local notepos:Int = (pattern.cy+pattern.h-rela_my)/pattern.ch
			quad(pattern.cx+pattern.cw*hx,pattern.cy+(pattern.h-pattern.ch)-notepos*pattern.ch,pattern.cw,pattern.ch)
			
			'==================== MOUSE LEFT CLICK section
			If MouseDown(1) 
				GLDrawText(pattern.selectlist.Count(),10,10)
				timestep=hx 
				pattern = patterns(pattern.steplist.ValueAtIndex(hx))
				If Not (SHIFT_DOWN)
					If Not pattern.selected And pattern_copy=0
						If pattern.clear_selected()
							pattern.clear_selection()		
						Else
							Local none:Byte = 1
							For Local n:note = EachIn pattern_tmp.notelist
								If n.value=(12+notepos) Then none=0
							Next
							If none Then pattern_tmp.add_note(12+notepos,instrument_typ)
							pattern_tmp.play(snd)
							snd.templist.clear()
						End If
						FlushMouse()
					Else
						If pattern_copy=0 Or mousetrap_x&gt;=0
							If mousetrap_x&lt;0 
								pattern.copy_selection(CONTROL_DOWN);
								mousetrap_x=Int(MouseX()/pattern.cw)*pattern.cw;
								mousetrap_y=MouseY()
							EndIf
							Local mx:Int = (MouseX()-mousetrap_x)'/pattern.cw
							Local my:Int = (MouseY()-mousetrap_y)/pattern.ch
							glColor4f(1.0,1.0,1.0,0.5)
							For Local org:patterns = EachIn pattern.selectlist
								org.newtime=(org.time*pattern.cw+mx)/pattern.cw
								org.note.newvalue = org.note.value-my
								For Local n:note = EachIn org.notelist
									If n.value&gt;-1 
										n.newvalue=n.value-my
										Local y:Float = pattern.cy+(pattern.h+11*pattern.ch)-n.newvalue*pattern.ch
										If y&gt;-pattern.ch And y&lt;pattern.h Then	quad(pattern.cx+org.newtime*pattern.cw+1,y,pattern.cw-2,pattern.ch)
									EndIf
								Next
							Next
							pattern_copy=1
						End If
					End If
				Else	
					If mousetrap_x&lt;0 Then mousetrap_y=Int(MouseY()/pattern.ch); mousetrap_x=0
					If timestep&lt;&gt;timestep_previous Then pattern.selecting(timestep)
					timestep_previous=timestep
				End If
			Else 
				If pattern.selectlist.Count()&gt;0 
					If pattern_copy
						For Local org:patterns = EachIn pattern.selectlist
							If org.newtime&gt;=0 Then pattern = patterns(pattern.steplist.ValueAtIndex(org.newtime))
							Local n:note = New note
							For n = EachIn org.notelist
								If n.newvalue&lt;10 Then org.notelist.Remove(n); Continue
								Local add:Byte = 1
								For pattern.note = EachIn pattern.notelist
									If pattern.note.value=n.newvalue Then add=0
								Next
								If add Then pattern.add_note(n.newvalue,n.instrument)
							Next
							If pattern.note.value=-1 Then pattern.note.value = pattern.note.newvalue = org.note.newvalue
							pattern.time = org.newtime
							pattern.newtime = org.newtime
							pattern.selected=1
						Next
						pattern_copy=0
						pattern.clear_selection()						
					End If
				End If
				timestep_previous = -1			
			EndIf
			If KeyHit(KEY_UP) Then pattern.selection_transpose(1+11*SHIFT_DOWN) 
			If KeyHit(KEY_DOWN) Then pattern.selection_transpose(-(1+11*SHIFT_DOWN)) 
			
			
			'==================== MOUSE RIGHT CLICK section
			If MouseDown(2)
				timestep=hx
				Local all:Byte = 1
				pattern = patterns(pattern.steplist.ValueAtIndex(timestep))
				If pattern.selected
					pattern.clear_selection()	
					pattern.clear_selected();FlushMouse()
				Else				
					For Local n:note = EachIn pattern.notelist
						If n.value=(12+notepos) Then pattern.notelist.Remove(n); all=0;FlushMouse()
					Next
					If all And pattern Then pattern.notelist.Clear(); If pattern.notelist.Count()=0 Then pattern.add_note(-1)
				EndIf
			End If
			glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
		End If
		'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RECORD
		If KeyHit(KEY_F4) Then record:~1
		If record
			If play Then play = 0
			If snd.templist.Count()&gt;0 And snd.temptimer=1
				timestep = timestep Mod pattern_length
				pattern = patterns(pattern.steplist.ValueAtIndex(timestep))
				If pattern 
					For snd = EachIn snd.templist
						pattern.add_note(note_oct+snd.note_collect,instrument_typ)	
					Next
				EndIf
				timestep_advance=1+SHIFT_DOWN
			End If
			If KeyHit(KEY_SPACE) 
				timestep = timestep Mod pattern_length
				pattern = patterns(pattern.steplist.ValueAtIndex(timestep))
				If pattern Then If pattern.notelist.Count()=0 Then pattern.add_note(-1)
				timestep:+1
			EndIf
			If KeyHit(KEY_LEFT)
				timestep:-1
				If timestep&lt;0 Then timestep = pattern_length-1
			End If
			If KeyHit(KEY_RIGHT)
				timestep:+1
				timestep = timestep Mod pattern_length
			End If
			If KeyHit(KEY_BACKSPACE)
				If SHIFT_DOWN
					For pattern = EachIn pattern.steplist
						pattern.clear()
					Next
				Else
					timestep:-1
					If timestep&lt;0 Then timestep:+pattern_length
					pattern = patterns(pattern.steplist.ValueAtIndex(timestep))
					If pattern Then pattern.notelist.Remove(pattern.notelist.last()); If pattern.notelist.Count()=0 Then pattern.add_note(-1)
				End If
			End If
			If KeyHit(KEY_DELETE)
				If SHIFT_DOWN
					For pattern = EachIn pattern.steplist
						pattern.clear()
					Next
				Else
					pattern = patterns(pattern.steplist.ValueAtIndex(timestep))
					If pattern Then pattern.notelist.Remove(pattern.notelist.last()); If pattern.notelist.Count()=0 Then pattern.add_note(-1)
				End If
			End If
			If snd.temptimer&gt;0 Then snd.temptimer:-1 Else snd.templist.Clear(); If timestep_advance Then timestep:+timestep_advance; timestep_advance=0
			glColor3f(1.0,0.0,0.0)
			glBegin(GL_QUADS)
				glVertex2d(10.0,0.0)
				glVertex2d(0.0 ,0.0)
				glVertex2d(0.0 ,10.0)
				glVertex2d(10.0,10.0)
			glEnd
			
			'---- just testing notelists of pattern steps
			Local yli:Int = 0
			glColor4f(1.0,1.0,1.0,0.5)
			If pattern 
				If timestep&lt;pattern_length Then pattern = patterns(pattern.steplist.ValueAtIndex(timestep))
				pattern.notelist.Sort(False,pattern.nsort)
				For Local n:note = EachIn pattern.notelist
					If n.value&gt;=0 Then GLDrawText(notenames[n.value Mod 12]+n.value/12,5,pattern_bottom+20+yli)
					yli:+12
				Next
			EndIf
			'----
		Else
			If snd.templist.Count()&gt;0 Then snd.templist.Clear()
			If KeyDown(KEY_LEFT) And key_delay=0 Then pattern_length:-1;patterns.steplist.Remove(patterns(pattern.steplist.ValueAtIndex(pattern_length))); key_delay=50 Else If key_delay&gt;0 Then key_delay:-1
			If KeyDown(KEY_RIGHT) And key_delay=0 Then pattern_length:+1; key_delay=50 Else If key_delay&gt;0 Then key_delay:-1
			If pattern_length&gt;patterns.steplist.Count() 
				pattern.Create(pattern_length-1)
			EndIf
		End If
		
	End If
	
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PLAY
	If KeyHit(KEY_F5) 
		If record Then record = 0
		If Not play Then cur_step=0
		play:~1
	End If
	If play
		glColor3f(0.0,1.0,0.0)
		glBegin(GL_TRIANGLES)
			glVertex2d(10.0,5.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
		glEnd
	End If
	
	'------------------------------------------ DRAW ouch bar to cover up sloppy pattern coding
	glColor4f(0.0,0.0,0.0,1.0)
	quad(0,pattern_bottom,Width,pattern.ch)
	'------------------------------------------ DRAW Theremin
	Local st:Float = Float(Width+20)/8
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			For Local i:Int = 0 Until 12
				glColor3f(2*notecols[i],1.1*notecols[i],notecols[i])
				glVertex2d(x*st+i*(st/12)-5,pattern_bottom)
				glVertex2d(x*st+i*(st/12)-5,Height)
			Next
		glEnd
	Next
	glColor3f(1.0,1.0,1.0)
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			glVertex2d(x*st-5,pattern_bottom)
			glVertex2d(x*st-5,Height)
		glEnd
	Next
	
	glBegin(GL_LINE_STRIP)
	For Local i:Int = 0 Until BUFFER_SIZE
			Local v:Float = Float((buffer_A[i]+$7fff) Mod $ffff)/$ffff
				glVertex2d(i,10+700*v)
	Next
	glEnd
	
	Local theremin:Byte = 0'MouseDown(1) And MouseY()&gt;theremin_top
	Local theremin_top:Int = 0
	If pattern Then theremin_top=pattern_bottom
	If MouseY()&gt;theremin_top
		MouseHit(1)
		theremin = MouseDown(1) 
	End If
	
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AUDIO section
	Local tempo_mod_use:Int = 44100*tempo_mod
	Local buffer:Int
	Local val:Int
	alGetSourcei(source, AL_BUFFERS_PROCESSED, Varptr val)
	While(val)
		Local accumulator:Double = 0
		alSourceUnqueueBuffers(source,1, Varptr buffer)
		For Local i:Int = 0 Until BUFFER_SIZE
		
			'======================== PATTERN section..................
			If play And (tick Mod tempo_mod_use)=0
				
				cur_step = cur_step Mod pattern_length
				pattern = patterns(pattern.steplist.ValueAtIndex(cur_step))
				pattern.play(snd)
				cur_step:+1
			End If
			
			accumulator = snd.update()
			
			'======================== FX section ......................
			Local delay_i:Int = tick Mod delay_length
			delay_buffer[delay_i]:*0.3
			accumulator:+ delay_buffer[delay_i]
			
			'======================== THEREMIN section.................
			If (vol&gt;0.0001 Or theremin)
				Local theremin_value:Float = vol*thrmn_snd.render(freq)	'Sin(a)
				accumulator:+theremin_value
				delay_buffer[delay_i]:+ 0.5*theremin_value
				If MouseY()&gt;theremin_top Then theremin_cntr =0.535*2^(MouseX()/(0.125*Width))
				freq:+(theremin_cntr-freq)*0.0003
				'a:+freq
				vol:+(theremin*(1.0-(Double(MouseY())/Height))-vol)*0.0003
			End If
			If Abs(accumulator)&gt;1.0 Then accumulator:/Abs(accumulator)
			buffer_A[i]=accumulator*$7fff
			
			tick:+1
		Next
		alBufferData(buffer, format, buf, BUFFER_SIZE*2, SAMPLING_FRQ)
		alSourceQueueBuffers(source,1, Varptr buffer)
		val:-1
	Wend
	If val&lt;=0
		alGetSourcei(source, AL_SOURCE_STATE, Varptr val)
		If val&lt;&gt; AL_PLAYING
			alSourcePlay(source)
		End If
	End If
	GLDrawText("BPM:"+Int(tempo)+"  DUR:1/"+Int(2.0/speeds[speed])+" OCT:"+note_oct/12+"  INSTRUMENT:"+instrument_typ,5,pattern_bottom+5)
End Function


Function quad(x:Float,y:Float, w:Float=4.0, h:Float=4.0)
	glBegin(GL_QUADS)
		glVertex2f(x+w,y  )
		glVertex2f(x  ,y  )
		glVertex2f(x  ,y+h)
		glVertex2f(x+w,y+h)
	glEnd()
End Function
Function line(x:Float,y:Float, x2:Float)
	glBegin(GL_QUADS)
		glVertex2f(x ,y)
		glVertex2f(x ,y+1)
		glVertex2f(x2,y+1)
		glVertex2f(x2,y)
	glEnd()
End Function
Function box(x0:Float,y0:Float,w:Float=4.0, h:Float=4.0)
	Local x1:Float = x0+w
	Local y1:Float = y0+h
	glBegin(GL_QUADS)
		glVertex2f(x1,y0)	; glVertex2f(x0,y0); glVertex2f(x0,y0+2); glVertex2f(x1,y0+2); 
		glVertex2f(x0+1,y0)	; glVertex2f(x0,y0); glVertex2f(x0,y1)	; glVertex2f(x0+1,y1); 
		glVertex2f(x1+1,y1)	; glVertex2f(x0,y1); glVertex2f(x0,y1+2); glVertex2f(x1+1,y1+2); 
		glVertex2f(x1+1,y0)	; glVertex2f(x1,y0); glVertex2f(x1,y1)	; glVertex2f(x1+1,y1); 
	glEnd
End Function


Type note
	Field instrument:Byte
	Field value:Int
	Field newvalue:Int
	Field velocity:Float
	Field duration:Float
	
	Field selected:Byte
End Type

Type notebeam
	Global notebeamlist:TList = CreateList()
	Field note:Int
	Field strength:Float
	
	Function update(cy:Float,h:Float, ch:Float)
		For Local nb:notebeam = EachIn notebeamlist
			nb.strength:*0.995
			If nb.strength&lt;0.01 Then notebeamlist.Remove(nb)
			glColor4f(0.25,0.34,0.45,nb.strength*nb.strength)
			quad(0,	cy+(h+11*ch)-nb.note*ch,Width,ch)
		Next
	End Function
	Function Create:notebeam(note:Int,strength:Float)
		Local nb:notebeam = New notebeam
		nb.note=note
		nb.strength=strength
		ListAddLast(notebeamlist,nb)
		Return nb
	End Function
EndType

Type patterns
	Global steplist:TList = CreateList()
	
	Global selectlist:TList = CreateList()
	
	Field notelist:TList
	Field note:note
	Field time:Int
	Field newtime:Int
	Field selected:Byte
	
	Global x:Float	'x position
	Global y:Float	'y position
	Global w:Float	'width
	Global h:Float	'height

	Global cx:Float	'cell x offset
	Global cy:Float	'cell y offset
	Global cw:Float  'cell width
	Global ch:Float	'cell height
	
	Method selecting(timestep:Int)
		selected:~1;
	End Method
	
	Method copy_selection(copy:Byte)
		For Local p:patterns = EachIn steplist
			If p.selected 
				Local newp:patterns = New patterns
				newp.time = p.time
				newp.newtime=p.time
				newp.note= New note
				newp.note.value =p.note.value
				newp.note.instrument =p.note.instrument
				newp.notelist = CreateList()
			'	newp.notelist = p.notelist.Copy()
				For p.note = EachIn p.notelist
					newp.note = New note
					newp.note.value = p.note.value
					newp.note.instrument = p.note.instrument
					ListAddLast(newp.notelist,newp.note)
				Next
				ListAddLast(selectlist,newp)
				If Not copy
					p.notelist.Clear()
					p.note.value=-1
				End If
				p.selected=0
			End If
		Next
	End Method
	
	Method clear_selection()
		selectlist.Clear()
	End Method
	
	Method clear_selected:Byte()
		Local check:Byte = 0
		For Local p:patterns = EachIn steplist
			If p.selected Then p.selected=0; check=1
		Next
		Return check
	End Method
	
	Method selection_transpose(amount:Int)
		For Local p:patterns = EachIn steplist
			If p.selected 
				For p.note = EachIn p.notelist
					If p.note.value&gt;-1 Then p.note.value:+amount
				Next
			EndIf
		Next
	End Method
	
	Function nsort:Int(o1:Object, o2:Object)
		Return note(o1).value-note(o2).value
	End Function
	
	Method play(snd:sound)
		For Local n:note = EachIn notelist
			If n.value&gt;-1
				Local octave:Int = Int(Float(n.value)/12)-1
				Local freq:Float = notefreqs[n.value Mod 12]
				freq:*(1 Shl octave)
				snd.Create(freq,1.0,0,n.instrument)
			End If
		Next
	End Method
	
	Method clear()
		notelist.Clear()
	End Method
	
	Method del()
		steplist.Remove(Self)
	End Method
	
	Method add_note(value:Int, i:Byte=0)
		note = New note
		note.value = value
		note.instrument = i
		ListAddLast(notelist,note)
	End Method
	
	Function Create:patterns(time:Int)
		Local p:patterns = New patterns
		p.note = New note
		p.note.value = -1
		p.time = time
		p.selected=0
		p.notelist:TList = CreateList()
		p.x = 0
		p.y = 0
		p.w = Width
		p.h = 360
		If steplist.Count()=0
			p.cx = 0
			p.cy = 0
			p.ch = 6
			p.cw = p.w/pattern_length
		End If
		ListAddLast(steplist,p)
		Return p
	End Function
End Type

Type sound
	Global templist:TList = CreateList()
	Global temptimer:Int
	
	Global selectlist:TList = CreateList()
	
	Field note_collect:Int
	Global list:TList = CreateList()
	
	Field instrument:Byte
	Field triggered:Byte
	Field note:Double
	Field vol:Float
	
	Field curvol:Float
	Field curfreq:Double
	
	Field inbuf:Double[8]
	Field phase:Double
	
	Function update:Float()
		Local combined_vol:Float=0
		Local value:Float = 0
		For Local s:sound = EachIn list
			value:+ s.fill()
	'		combined_vol:+s.curvol
		Next
	'	If combined_vol&gt;1.0 Then value:/combined_vol 'quick clipping fix, nothing to keep
		Return value
	EndFunction
	
	Method fill:Float()
		Local value:Float = curvol*render(note) 
		curvol:+(vol-curvol)*0.01		
		If vol&gt;0.00001 Then vol:*0.9999 Else vol=0;triggered=0;list.Remove(Self);Return 0
		Return value
	End Method
	
	Method render:Float(note:Double)
		 Select instrument
		 	Case 0	'sine
				curfreq:+note
				Return Float(Sin(curfreq))
			Case 1  'saw
			    Local dphase:Double =note*0.00555
			    phase:+dphase
			    If(phase&gt;1.0) Then phase:-2.0
				inbuf[0]=phase*(7.0/360.0 + phase*phase*(-1.0/36.0 + phase*phase*(1.0/120.0)));
				inbuf[1]= inbuf[4]-inbuf[0]
				inbuf[2]= inbuf[5]-inbuf[1]
				inbuf[3]= inbuf[6]-inbuf[2]
				Local out:Float =  Float(1.0/(dphase^4))* (inbuf[7]-inbuf[3])
				If Abs(out)&gt;1.0 Then out:/Abs(out)
				inbuf[4]= inbuf[0]; inbuf[5]= inbuf[1]; inbuf[6]= inbuf[2]; inbuf[7]= inbuf[3]
				Return out
			Case 2  'square
				Local freq:Double =note*0.00555 	
				Local dphase:Double=0.5-freq;
				phase:+freq;
				phase:-  2.0*(phase&gt;1.0);
				inbuf[0]=phase+dphase*inbuf[1];  
				inbuf[2]=phase+dphase*inbuf[3]; 
				inbuf[0]:-2.0*(inbuf[0]&gt;1.0);
				inbuf[2]:-2.0*(inbuf[2]&gt;1.0);
				inbuf[0]:+2.0*(inbuf[0]&lt;-1.0);      
				inbuf[2]:+1.0+2.0*(inbuf[2]&lt;-1.0);
				inbuf[2]:-2.0*(inbuf[2]&gt;1);
				inbuf[0]=inbuf[0]*inbuf[0]*(2*inbuf[0]*inbuf[0]-4);
				inbuf[2]=inbuf[2]*inbuf[2]*(2*inbuf[2]*inbuf[2]-4); 
				Local out:Float = inbuf[0]-inbuf[2]
				inbuf[1]=0.5*(1+ inbuf[0]+inbuf[1]);
				inbuf[3]=0.5*(1+ inbuf[2]+inbuf[3]);
				If Abs(out)&gt;1.0 Then out:/Abs(out)
				Return out
		 End Select
	End Method
	Method trigger(in_note:Double, in_velocity:Float)
		triggered = 1
		vol = in_velocity*0.3
		note = in_note*1.07
		curvol = 0
		curfreq = 0
		phase = 0
		For Local i:Int = 0 Until 8
			inbuf[i]=0
		Next
	End Method
	
	Function Create:sound(in_note:Double=1.0, in_velocity:Float=0.0,note_collect:Int=0,instrument:Byte=1)
		Local s:sound = New sound
		s.instrument=instrument
		s.trigger(in_note, in_velocity)
		ListAddLast(list,s)
		s.note_collect = note_collect
		ListAddLast(templist,s)
		temptimer = 50
		Return s
	End Function
End Type</textarea><br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's funny!<br>anyway, you're having an array out of bounds with the "buffers" array. It should be created with buffers[3] in order to allow a "2" as its maximum index.<br>sounds a lot like a theremin. I like it! <br><br></td></tr></table><br>
<a name="1100726"></a>

<a name="1100728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> AH woops, darned, forgot that I changed it and got sloppy, haha. Thanks!<br><br>The point of it is really that it's possible. By all the posts here that I ever found it appeared not to be. I'm therefore quite overjoyed, hehe. It's the beginning of some exciting exploration, I'm sure. <br><br>I figure that some of you may pick up on it and take it to higher places on your own. I can't believe how easy the setup can be, though. But it gets trickier from here, that's for sure!<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100735"></a>

<a name="1100736"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> does it supposed to be crackling and intermittently stopping?<br>I am thinking it's the OpenAL functionality on my mac.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100740"></a>

<a name="1100741"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> That is excellent.<br><br>I bet it could be adapted to work with old school emulators that use the old waveform patterns and then adjust the pitch to get the correct sound.<br><br>A fair while ago I was trying to get something similar working to work with a z80 emulator with pacman roms that I'd written, but resorted to other methods. This is more like what I wanted to achieve :P<br><br>I may pursue it in the future.. you never know :P<br><br>Thanks for sharing :D<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100749"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had all manner of problems with openal on my mac. went back to freeaudio. <br><br></td></tr></table><br>
<a name="1100750"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> does free audio support the buffer queuing in the same or similar manner? That would be interesting.<br><br>I also realized a few silly things in my code up there, I'll fix it real quick...<br><br>Thanks, guys! :)<br>*sorry about the mac issues with openAL. You could try to change the buffersize, see if that reduces the crackling with higher latency (4000 for example) <br><br></td></tr></table><br>
<a name="1100756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is really cool, thanks for sharing it! Say "hi" to drpetter, too -- he's done some great stuff and I really recommend a trawl around <a href="http://www.drpetter.se/index.html" target="_blank">his site</a> for anyone that hasn't been. In fact, his <a href="http://www.drpetter.se/article_sound.html" target="_blank">sound synthesis article</a> made me want to play with this stuff ages ago, and now I can! <br><br></td></tr></table><br>
<a name="1100757"></a>

<a name="1100779"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I had all manner of problems with openal on my mac. went back to freeaudio.<br> <br></div><br>That doesn't sound good [no pun intended... ok just a little]. <br><br>I mean, isn't OpenAL the #1 audio API for Mac?<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hehe...just added some keys to play along over almost the whole keyboard. It's still crude and lousy code, but I could share it with you, if you like. <br><br>I can't believe I'm doing this right now, though. It's really amazingly pleasing, hahaha.<br><br>Thanks, James, I'm happy you feel it, too! :o)<br>And, yes, Tomas rocks! 8)<br><br>Pahaha, Kryzon, I hope that's not the case. Whereby...hmmm...I do like to accumulate reasons for why I'm happy on the PC. ;) <br><br></td></tr></table><br>
<a name="1100778"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>just added some keys to play along over almost the whole keyboard. It's still crude and lousy code, but I could share it with you, if you like.<br> <br></div><br>Over here!<br><br>I like how short the original code is, too, though haven't tried to 'read' it yet... <br><br></td></tr></table><br>
<a name="1100803"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ian Thompson</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would love a tutorial on this kind of stuff please? <br><br></td></tr></table><br>
<a name="1100811"></a>

<a name="1100812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SLotman</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hahahah! Very cool, gives a great 'vintage sci-fi' feeling :)<br><br>I kind of understand the 'joy' of doing this - when I first played a sound sample on MSX, by resetting all registers and just changing the volume up and down... I couldn't believe it worked, until I figure it all out :)<br><br>You could include square waves in there...just for fun :)<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100814"></a>

<a name="1100816"></a>

<a name="1100817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ehehe, ok, here's the little vibraphone combination (lazy me, only sines, haha)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import pub.OpenAL
Import brl.RamStream
'=============================================================================
AppTitle="openAL realtime synth/streaming"

SetGraphicsDriver GLMax2DDriver()
Const Width:Int =	1280
Const Height:Int =	720
Global hWidth:Int=Width*0.5
Global hHeight:Int=Height*0.5
GLGraphics (Width,Height,0)

glewInit()
glFlush()
glOrtho (0, Width, Height, 0, -100, 100)

'============================ AUDIO setup ====================================
Global audiotrue:Byte = 0

If OpenALInstalled()
	audiotrue=1
Else
	GLDrawText"Audio OFF: OpenAL audio is not installed. &lt;hit any key to continue!&gt;",0,hHeight-17
	Flip 0
	WaitKey()
	End
End If

'============================ The Real Deal ==================================
Const BUFFER_SIZE:Int=1800
Const SAMPLING_FRQ:Int=47000

Global source:Int
Global buffers:Int[3]
Global frequency:Int
Global format:Int
Global buf:Byte Ptr

Global ALDevice:Int =alcOpenDevice(Null) 
Global ALContext:Int =alcCreateContext(ALDevice, Null) 
alcMakeContextCurrent(ALContext)

alGenBuffers(3,buffers)
alGenSources(1, Varptr source)

Global buffer_A:Short[BUFFER_SIZE]

format = AL_FORMAT_MONO16
Local tick:Int = 0
buf = Byte Ptr buffer_A
For Local i:Int = 0 Until BUFFER_SIZE
		buffer_A[i] = 0
Next
alBufferData(buffers[0], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[1], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[2], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)

alSourceQueueBuffers(source, 1, Varptr buffers[0])
alSourceQueueBuffers(source, 1, Varptr buffers[1])
alSourceQueueBuffers(source, 1, Varptr buffers[2])
alSourcePlay(source)

Global notecols:Float[]  = [0.3,0.1,0.3,0.1,0.3,0.3,0.1,0.3,0.1,0.3,0.1,0.3]

Local oct:Int = 1
Local freq:Double = 1.0
Local vol:Double = 0.0
Local a:Double = 0.0
Local snd:sound = sound.Create(0,256)

While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	glClear(GL_COLOR_BUFFER_BIT)
	If audiotrue
		Local buffer:Int
		Local val:Int

		If KeyHit(KEY_PAGEUP) Then oct=oct Shl 1
		If KeyHit(KEY_PAGEDOWN) Then If oct&gt;1 Then oct=oct Shr 1
				
		If KeyHit(KEY_Q) Then 			sound.Create((oct Shl 1)*1.0	,1.0)'; note = 1.0		
			If KeyHit(KEY_2) Then 		sound.Create((oct Shl 1)*1.05946,1.0)'; note = 1.05946	
		If KeyHit(KEY_W) Then 			sound.Create((oct Shl 1)*1.12246,1.0)'; note = 1.12246	
			If KeyHit(KEY_3) Then 		sound.Create((oct Shl 1)*1.18921,1.0)'; note = 1.18921	
		If KeyHit(KEY_E) Then 			sound.Create((oct Shl 1)*1.25992,1.0)'; note = 1.25992	
		If KeyHit(KEY_R) Then 			sound.Create((oct Shl 1)*1.33483,1.0)'; note = 1.33483	
			If KeyHit(KEY_5) Then 		sound.Create((oct Shl 1)*1.41421,1.0)'; note = 1.41421	
		If KeyHit(KEY_T) Then 			sound.Create((oct Shl 1)*1.49831,1.0)'; note = 1.49831	
			If KeyHit(KEY_6) Then 		sound.Create((oct Shl 1)*1.58740,1.0)'; note = 1.58740	
		If KeyHit(KEY_Y) Then 			sound.Create((oct Shl 1)*1.68179,1.0)'; note = 1.68179	
			If KeyHit(KEY_7) Then 		sound.Create((oct Shl 1)*1.78180,1.0)'; note = 1.78180	
		If KeyHit(KEY_U) Then 			sound.Create((oct Shl 1)*1.88775,1.0)'; note = 1.88775	
		If KeyHit(KEY_I) Then 			sound.Create((oct Shl 2)*1.0	,1.0)'; note = 2.0		
			If KeyHit(KEY_9) Then 		sound.Create((oct Shl 2)*1.05946,1.0)'; note = 1.05946	
		If KeyHit(KEY_O) Then 			sound.Create((oct Shl 2)*1.12246,1.0)'; note = 1.12246	
			If KeyHit(KEY_0) Then 		sound.Create((oct Shl 2)*1.18921,1.0)'; note = 1.18921	
		If KeyHit(KEY_P) Then 			sound.Create((oct Shl 2)*1.25992,1.0)'; note = 1.25992	
		If KeyHit(KEY_OPENBRACKET)Then 	sound.Create((oct Shl 2)*1.33483,1.0)'; note = 1.25992	
		If KeyHit(KEY_EQUALS) 	  Then 	sound.Create((oct Shl 2)*1.41421,1.0)'; note = 1.25992	
		If KeyHit(KEY_CLOSEBRACKET)Then sound.Create((oct Shl 2)*1.49831,1.0)'; note = 1.25992	
		
		If KeyHit(KEY_Z) Then 			sound.Create((oct Shl 0)*1.0	,1.0)
			If KeyHit(KEY_S) Then 		sound.Create((oct Shl 0)*1.05946,1.0)
		If KeyHit(KEY_X) Then 			sound.Create((oct Shl 0)*1.12246,1.0)
			If KeyHit(KEY_D) Then 		sound.Create((oct Shl 0)*1.18921,1.0)
		If KeyHit(KEY_C) Then 			sound.Create((oct Shl 0)*1.25992,1.0)
		If KeyHit(KEY_V) Then 			sound.Create((oct Shl 0)*1.33483,1.0)
			If KeyHit(KEY_G) Then 		sound.Create((oct Shl 0)*1.41421,1.0)
		If KeyHit(KEY_B) Then 			sound.Create((oct Shl 0)*1.49831,1.0)
			If KeyHit(KEY_H) Then 		sound.Create((oct Shl 0)*1.58740,1.0)
		If KeyHit(KEY_N) Then 			sound.Create((oct Shl 0)*1.68179,1.0)
			If KeyHit(KEY_J) Then 		sound.Create((oct Shl 0)*1.78180,1.0)
		If KeyHit(KEY_M) Then 			sound.Create((oct Shl 0)*1.88775,1.0)
		If KeyHit(KEY_COMMA) Then 		sound.Create((oct Shl 1)*1.0	,1.0)
			If KeyHit(KEY_L) Then 		sound.Create((oct Shl 1)*1.05946,1.0)
		If KeyHit(KEY_PERIOD) Then 		sound.Create((oct Shl 1)*1.12246,1.0)
		   If KeyHit(KEY_SEMICOLON)Then sound.Create((oct Shl 1)*1.18921,1.0)
		If KeyHit(KEY_SLASH) Then 		sound.Create((oct Shl 1)*1.25992,1.0)
		
		Local theremin:Byte = MouseDown(1)
		
		alGetSourcei(source, AL_BUFFERS_PROCESSED, Varptr val)
			While(val)
				alSourceUnqueueBuffers(source,1, Varptr buffer)
				For Local i:Int = 0 Until BUFFER_SIZE
					buffer_A[i] = snd.update()*$7fff
					
					If vol&gt;0.0001 Or theremin
						buffer_A[i]:+ vol*Sin(a)*$7fff
						Local cntr:Double =0.5*2^(MouseX()/(0.125*Width))
						freq:+(cntr-freq)*0.0002
						a:+freq
						vol:+(theremin*(1.0-(Double(MouseY())/Height))-vol)*0.0002
					End If
				Next
				alBufferData(buffer, format, buf, BUFFER_SIZE*2, SAMPLING_FRQ)
				alSourceQueueBuffers(source,1, Varptr buffer)
				val:-1
			Wend
		If val&lt;=0
			alGetSourcei(source, AL_SOURCE_STATE, Varptr val)
			If val&lt;&gt; AL_PLAYING
				alSourcePlay(source)
			End If
		End If
	End If
	
	Local st:Float = Float(Width)/8
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			For Local i:Int = 0 Until 12
				glColor3f(2*notecols[i],1.1*notecols[i],notecols[i])
				glVertex2d(x*st+i*(st/12),0)
				glVertex2d(x*st+i*(st/12),Height)
			Next
		glEnd
	Next
	st:Float = Float(Width)/8
	glColor3f(1.0,1.0,1.0)
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			glVertex2d(x*st,0)
			glVertex2d(x*st,Height)
		glEnd
	Next
	
	For Local i:Int = 0 Until BUFFER_SIZE
			Local v:Float = Float((buffer_A[i]+$7fff) Mod $ffff)/$ffff
			glBegin(GL_POINTS)
				glVertex2d(i,10+700*v)
			glEnd
	Next
	Flip 1
Wend
	alcDestroyContext(ALContext)
	alcCloseDevice(ALDevice)
	ALContext=0
	ALDevice=0
End


Type sound
	Global list:TList = CreateList()
	Field triggered:Byte
	Field note:Float
	Field vol:Float
	
	Field curvol:Float
	Field curfreq:Float
	
	Function update:Float()
		Local value:Float = 0
		For Local s:sound = EachIn list
			value:+ s.fill()
		Next
		Return value
	EndFunction
	
	Method fill:Float()
		Local value:Float = curvol*Sin(curfreq) 
		curfreq:+note
		curvol:+(vol-curvol)*0.01		
		If vol&gt;0.0001 Then vol:*0.9999 Else vol=0;triggered=0;list.Remove(Self);Return 0
		Return value
	End Method
	 
	Method trigger(in_note:Float, in_velocity:Float)
		triggered = 1
		vol = in_velocity*0.2
		note = in_note
		curvol = 0
		curfreq = 0
	End Method
	
	Function Create:sound(in_note:Float=1.0, in_velocity:Float=0.0)
		Local s:sound = New sound
		s.trigger(in_note, in_velocity)
		ListAddLast(list,s)
		Return s
	End Function
End Type</textarea><br><br>Alright, I will see that I write a tutorial later today. I think it's good for myself, too, haha. :}<br><br>And, please, don't judge to harshly on my code, but let me know, if you find something stupid or less favorable and share your optimizations. That would be nice. Thanks in advance!<br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100821"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> The party starts, if you add more SIN()-Functions to the formula:<br><br><pre class=code>buffer_A[i] = vol*(Sin(a)+Sin(a/1.02)+Sin(a*2))*$7fff
</pre><br><br>In nature a "sound" is a combination of a dozend of sinus-components (overtones). Each overtone has the a*2, a*3, a*4, .... value of the base freqency, but it is less loud:<br><br>Vol*Sin(a) + vol/2*Sin(a*2) + vol/4*Sin(a*3) + .....<br><br><br>Also try two nearly equal frenquenies:<br><br>Vol*Sin(a) + vol/2*Sin(a*1.02)<br><br>this sounds like a chorus effect.<br><br><br>But the best is "clipping", which you can listen to with the code above. The signal is too big (&gt; (255*255)) an starts again from Zero. This brings a lot of additional overtones to the signal<br><br><br>here is a "engine of a car":<br><br><pre class=code>buffer_A[i] = vol*(Sin(a/2)+Sin(a/3))*$7fff
</pre> <br><br></td></tr></table><br>
<a name="1100841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is great stuff, and midimaster's tweaks are interesting too -- I like how you can see the point at which the waveform starts clipping and the 'new' effect coming in.<br><br>(Besides the musical and sound effects possibilities, one thing I'd really like to recreate using this stuff is drpetter's engine sound from <a href="http://www.youtube.com/watch?v=Ic750lQPWMo&amp;feature=player_profilepage" target="_blank">this video</a> -- if you click More Info he describes how it's made. One of the best synthesised engines I've ever heard.)<br><br>I buried this in a link above, but this article is really well worth a read for anyone else interested in this stuff:<br><br><a href="http://www.drpetter.se/article_sound.html" target="_blank"><b>Basic sound theory and synthesis</b></a> <br><br></td></tr></table><br>
<a name="1100842"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ehehe, nice, yeah. There's no end to the possibilities. But it does get much more complicated, once you go into anti-aliased waveform generation and, of course, happy filtering. Whereby that's not so tough. Just springs, really.<br><br>Anyway, I've added a tiny pattern recorder and player, but the timing is horrible. I know, it's the oldest of all problems and tons of suggestions around, but I can't ever find the right solution.<br><br>Does anyone have a solid timing idea for pattern playback? <br><br>Thanks in advance. <br><br></td></tr></table><br>
<a name="1100844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> First of - hi all, this is my first post as a noob (7 weeks into blitzmax)<br><br>there are two things you need for timing<br>1. use events as your framework<br>2. use timer events to get your timing<br><br>for the framework here is the base code:<br>	While Not AppQuit<br>		WaitEvent()<br>		Select EventID()<br>			Case EVENT_APPTERMINATE AppQuit = True<br>			Case EVENT_TIMERTICK EventTimer()<br>		End Select<br>	Wend<br><br>this is very different from normal blitzbasic standard loops as it plays nice with the os :)<br><br>to set a timer use something like:<br>Global SongTimer:TTimer<br>Global SongBpm:Int = 130<br><br>If SongTimer StopTimer(SongTimer)<br>SongTimer = CreateTimer( SongBpm/15.0 )<br><br>the main issue you will have is that your program will now wait and not do any background processing. here there are two options:<br><br>1. move your audio processing into a thread so it will be independent<br>2. recode the audio subsystem<br><br>yep I know that both are not good answers but sorry on those!<br><br>You will need to ask yourself do i need to do it realtime, or can I pre-process it and play realtime which is a different thing<br><br>I've got a 32 track sequencer running realtime with no timing issues in blitzmax plus additive synthesis systems based on those from the ppg wave term and fairlight cmi. <br><br></td></tr></table><br>
<a name="1100847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> there is no need of "record" what you hear. You just can save the buffer directly to a file.<br><br>Here is a audio recorder listing based on OpenAl. Perhaps you can find some additional information:<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=90830" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=90830</a><br><br>and here is a code to save buffer directly to WAV-files. (sorry this part of the tutorial is only avaiable in german):<br><br><a href="http://www.blitzforum.de/forum/viewtopic.php?p=358688#358688" target="_blank">http://www.blitzforum.de/forum/viewtopic.php?p=358688#358688</a><br><br>Here is a (english) software of mine, based on theorie of stapling sinus waves to a more complex sound:<br><br><a href="http://www.midimaster.de/download/hoerensehen_demo.exe" target="_blank">http://www.midimaster.de/download/hoerensehen_demo.exe</a><br><br><br><img src="http://www.midimaster.de/images/HoerenKlein.png"> <br><br></td></tr></table><br>
<a name="1100864"></a>

<a name="1100877"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks JAddams, I'll continue with that. I had already started to implement hooks. When I'm done I'll post the code. I hope you'll spot any stupidities of mine. Chances are quite good, haha... :P<br><br><br>Midimaster, thanks, but that's not what this is about. When I say "record" I mean actually sequencing and not recording wave data. I've already done that 4 years ago, I think, with my offline synth. Now I want a complete realtime sound and music engine I can use with my games or simply to make some tracks. Anyway, thanks, looks good what you got going there! :)<br><br>Alright, here's a bit of a chaotic code, that tries to use the event system favorably for the timing. It starts to work, though.<br><br>I have no clue whatsoever about Threads, yet, and need to learn how to deal with them. So far it doesn't look all that easy at first glance. Don't know how to set up data sharing or any of this, no clue what I need or if I even need it. Anyone of you, who could take this code and turn the audio processing into it's own thread, or what ever would work best, it would be awesome!<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import pub.OpenAL
Import brl.RamStream
Import brl.timer
Import BRL.EventQueue
'=============================================================================
AppTitle="openAL realtime synth/streaming"

SetGraphicsDriver GLMax2DDriver()
Const Width:Int =	1280
Const Height:Int =	720
Global hWidth:Int=Width*0.5
Global hHeight:Int=Height*0.5
GLGraphics (Width,Height,0)

glewInit()
glFlush()
glOrtho (0, Width, Height, 0, -100, 100)
glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 

'============================ AUDIO setup ====================================
Global audiotrue:Byte = 0

If OpenALInstalled()
	audiotrue=1
Else
	GLDrawText"Audio OFF: OpenAL audio is not installed. &lt;hit any key to continue!&gt;",0,hHeight-17
	Flip 0
	WaitKey()
	End
End If

'============================ The Real Deal ==================================
Const BUFFER_SIZE:Int=1800
Const SAMPLING_FRQ:Int=47000

Global source:Int
Global buffers:Int[3]
Global frequency:Int
Global format:Int
Global buf:Byte Ptr

Global ALDevice:Int =alcOpenDevice(Null) 
Global ALContext:Int =alcCreateContext(ALDevice, Null) 
alcMakeContextCurrent(ALContext)

alGenBuffers(3,buffers)
alGenSources(1, Varptr source)

Global buffer_A:Short[BUFFER_SIZE]

format = AL_FORMAT_MONO16
Local tick:Int = 0
buf = Byte Ptr buffer_A
For Local i:Int = 0 Until BUFFER_SIZE
		buffer_A[i] = 0
Next
alBufferData(buffers[0], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[1], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[2], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)

alSourceQueueBuffers(source, 1, Varptr buffers[0])
alSourceQueueBuffers(source, 1, Varptr buffers[1])
alSourceQueueBuffers(source, 1, Varptr buffers[2])
alSourcePlay(source)

Global record:Byte = 0
Global timestep:Int = 0
Global pattern_length:Int = 32
Global pattern:pattern_step = New pattern_step
For Local i:Int = 0 Until pattern_length
	pattern.Create(i)
Next
Global notefreqs:Float[] = [1.0,1.05946,1.12246,1.18921,1.25992,1.33483,1.41421,1.49831,1.58740,1.68179,1.78180,1.88775]
Global notecols:Float[]  = [0.3,0.1,0.3,0.1,0.3,0.3,0.1,0.3,0.1,0.3,0.1,0.3]

Global play:Byte = 0
Global cur_step:Int = 0
Global timer:Int = 0
Global speed:Int = 15

Global oct:Int = 1
Global freq:Double = 1.0
Global vol:Double = 0.0
Global a:Double = 0.0
Global snd:sound = sound.Create(0,256)

Global songtimer:ttimer = CreateTimer(4)
AddHook FlipHook,process

While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	PollEvent()
	Select EventID()
		Case EVENT_TIMERTICK go()
	End Select
	Flip 0
Wend
	alcDestroyContext(ALContext)
	alcCloseDevice(ALDevice)
	ALContext=0
	ALDevice=0
End

Function go()
	If play
		cur_step = cur_step Mod pattern_length
		pattern = pattern_step(pattern.steplist.ValueAtIndex(cur_step))
		pattern.play(snd)
		cur_step:+1
	End If
End Function


Function process:Object(id:Int,data:Object,context:Object )
	glClear(GL_COLOR_BUFFER_BIT)
	
	Local note:Int = -1		
	If audiotrue
		Local buffer:Int
		Local val:Int
		
		Local theremin:Byte = MouseDown(1)
		
		alGetSourcei(source, AL_BUFFERS_PROCESSED, Varptr val)
			While(val)
				alSourceUnqueueBuffers(source,1, Varptr buffer)
				For Local i:Int = 0 Until BUFFER_SIZE
					buffer_A[i] = snd.update()*$7fff
					
					If vol&gt;0.0001 Or theremin
						buffer_A[i]:+ vol*Sin(a)*$7fff
						Local cntr:Double =0.5*2^(MouseX()/(0.125*Width))
						freq:+(cntr-freq)*0.0002
						a:+freq
						vol:+(theremin*(1.0-(Double(MouseY())/Height))-vol)*0.0002
					End If
				Next
				alBufferData(buffer, format, buf, BUFFER_SIZE*2, SAMPLING_FRQ)
				alSourceQueueBuffers(source,1, Varptr buffer)
				val:-1
			Wend
		If val&lt;=0
			alGetSourcei(source, AL_SOURCE_STATE, Varptr val)
			If val&lt;&gt; AL_PLAYING
				alSourcePlay(source)
			End If
		End If
	End If
		
		If KeyHit(KEY_PAGEUP) Then oct=oct Shl 1
		If KeyHit(KEY_PAGEDOWN) Then If oct&gt;1 Then oct=oct Shr 1
		If KeyHit(KEY_Z) Then 			sound.Create((oct Shl 0)*1.0	,1.0); note =0	
			If KeyHit(KEY_S) Then 		sound.Create((oct Shl 0)*1.05946,1.0); note =1	
		If KeyHit(KEY_X) Then 			sound.Create((oct Shl 0)*1.12246,1.0); note =2	
			If KeyHit(KEY_D) Then 		sound.Create((oct Shl 0)*1.18921,1.0); note =3	
		If KeyHit(KEY_C) Then 			sound.Create((oct Shl 0)*1.25992,1.0); note =4
		If KeyHit(KEY_V) Then 			sound.Create((oct Shl 0)*1.33483,1.0); note =5	
			If KeyHit(KEY_G) Then 		sound.Create((oct Shl 0)*1.41421,1.0); note =6
		If KeyHit(KEY_B) Then 			sound.Create((oct Shl 0)*1.49831,1.0); note =7
			If KeyHit(KEY_H) Then 		sound.Create((oct Shl 0)*1.58740,1.0); note =8
		If KeyHit(KEY_N) Then 			sound.Create((oct Shl 0)*1.68179,1.0); note =9
			If KeyHit(KEY_J) Then 		sound.Create((oct Shl 0)*1.78180,1.0); note =10
		If KeyHit(KEY_M) Then 			sound.Create((oct Shl 0)*1.88775,1.0); note =11
		If KeyHit(KEY_COMMA) Then 		sound.Create((oct Shl 1)*1.0	,1.0); note =12
			If KeyHit(KEY_L) Then 		sound.Create((oct Shl 1)*1.05946,1.0); note =13
		If KeyHit(KEY_PERIOD) Then 		sound.Create((oct Shl 1)*1.12246,1.0); note =14
		   If KeyHit(KEY_SEMICOLON)Then sound.Create((oct Shl 1)*1.18921,1.0); note =15
		If KeyHit(KEY_SLASH) Then 		sound.Create((oct Shl 1)*1.25992,1.0); note =16
		
		If KeyHit(KEY_Q) Then 			sound.Create((oct Shl 1)*1.0	,1.0); note =12	
			If KeyHit(KEY_2) Then 		sound.Create((oct Shl 1)*1.05946,1.0); note =13
		If KeyHit(KEY_W) Then 			sound.Create((oct Shl 1)*1.12246,1.0); note =14
			If KeyHit(KEY_3) Then 		sound.Create((oct Shl 1)*1.18921,1.0); note =15
		If KeyHit(KEY_E) Then 			sound.Create((oct Shl 1)*1.25992,1.0); note =16
		If KeyHit(KEY_R) Then 			sound.Create((oct Shl 1)*1.33483,1.0); note =17
			If KeyHit(KEY_5) Then 		sound.Create((oct Shl 1)*1.41421,1.0); note =18
		If KeyHit(KEY_T) Then 			sound.Create((oct Shl 1)*1.49831,1.0); note =19
			If KeyHit(KEY_6) Then 		sound.Create((oct Shl 1)*1.58740,1.0); note =20
		If KeyHit(KEY_Y) Then 			sound.Create((oct Shl 1)*1.68179,1.0); note =21
			If KeyHit(KEY_7) Then 		sound.Create((oct Shl 1)*1.78180,1.0); note =22
		If KeyHit(KEY_U) Then 			sound.Create((oct Shl 1)*1.88775,1.0); note =23
		If KeyHit(KEY_I) Then 			sound.Create((oct Shl 2)*1.0	,1.0); note =24
			If KeyHit(KEY_9) Then 		sound.Create((oct Shl 2)*1.05946,1.0); note =25
		If KeyHit(KEY_O) Then 			sound.Create((oct Shl 2)*1.12246,1.0); note =26
			If KeyHit(KEY_0) Then 		sound.Create((oct Shl 2)*1.18921,1.0); note =27
		If KeyHit(KEY_P) Then 			sound.Create((oct Shl 2)*1.25992,1.0); note =28
		If KeyHit(KEY_OPENBRACKET)Then 	sound.Create((oct Shl 2)*1.33483,1.0); note =29
		If KeyHit(KEY_EQUALS) 	  Then 	sound.Create((oct Shl 2)*1.41421,1.0); note =30
		If KeyHit(KEY_CLOSEBRACKET)Then sound.Create((oct Shl 2)*1.49831,1.0); note =31
	
	Local st:Float = Float(Width)/8
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			For Local i:Int = 0 Until 12
				glColor3f(2*notecols[i],1.1*notecols[i],notecols[i])
				glVertex2d(x*st+i*(st/12),200)
				glVertex2d(x*st+i*(st/12),Height)
			Next
		glEnd
	Next
	st:Float = Float(Width)/8
	glColor3f(1.0,1.0,1.0)
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			glVertex2d(x*st,200)
			glVertex2d(x*st,Height)
		glEnd
	Next
	
	For Local i:Int = 0 Until BUFFER_SIZE
			Local v:Float = Float((buffer_A[i]+$7fff) Mod $ffff)/$ffff
			glBegin(GL_POINTS)
				glVertex2d(i,10+700*v)
			glEnd
	Next
	
	'------------------------------------------ DRAW pattern
	glColor4f(0.25,0.15,0.05,1.0)
	Local dstepsize:Float = Width/pattern_length
	For pattern = EachIn pattern.steplist
		If record Then If pattern.time=timestep Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
		If play Then If pattern.time=cur_step Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
		If pattern.note.value=-1 Then glColor3f(0.15,0.07,0.05)
			quad(pattern.time*dstepsize,0,dstepsize-1.0,200)
		If pattern.note.value=-1 Then glColor3f(0.25,0.15,0.05)
	Next
	glColor3f(1.0,1.0,1.0)
	For pattern = EachIn pattern.steplist
		For Local n:note = EachIn pattern.notelist
			If n.value&gt;-1 Then quad(pattern.time*dstepsize,196-n.value*4,dstepsize)
		Next
	Next

	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RECORD
	If KeyHit(KEY_F1) Then record:~1
	If record
		If play Then play = 0
		If note&gt;-1
			timestep = timestep Mod pattern_length
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			If pattern Then pattern.add_note((oct*12)+note)
			timestep:+1
		End If
		If KeyHit(KEY_SPACE) 
			timestep = timestep Mod pattern_length
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			If pattern Then If pattern.notelist.Count()=0 Then pattern.add_note(-1)
			timestep:+1
		EndIf
		If KeyHit(KEY_LEFT)
			timestep:-1
			If timestep&lt;0 Then timestep = pattern_length
		End If
		If KeyHit(KEY_RIGHT)
			timestep:+1
			timestep = timestep Mod pattern_length
		End If
		If KeyHit(KEY_DELETE)
			If KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
				For pattern = EachIn pattern.steplist
					pattern.clear()
				Next
			Else
				timestep:-1
				If timestep&lt;0 Then timestep:+pattern_length
				pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
				If pattern Then pattern.notelist.Remove(pattern.notelist.last())
			End If
		End If
		
		glColor3f(1.0,0.0,0.0)
		glBegin(GL_QUADS)
			glVertex2d(10.0,0.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
			glVertex2d(10.0,10.0)
		glEnd
	End If
	
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PLAY
	If KeyHit(KEY_F2) 
		If record Then record = 0
		If Not play Then cur_step=0
		play:~1
	End If
	If play
		glColor3f(0.0,1.0,0.0)
		glBegin(GL_TRIANGLES)
			glVertex2d(10.0,5.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
		glEnd
	End If
End Function


Function quad(x:Float,y:Float, w:Float=4.0, h:Float=4.0)
	glBegin(GL_QUADS)
		glVertex2f(x+w,y  )
		glVertex2f(x  ,y  )
		glVertex2f(x  ,y+h)
		glVertex2f(x+w,y+h)
	glEnd()
End Function

Type note
	Field value:Int
	Field velocity:Float
End Type

Type pattern_step
	Global steplist:TList = CreateList()
	Field notelist:TList
	Field note:note
	Field time:Int
	
	Method play(snd:sound)
		For Local n:note = EachIn notelist
			If n.value&gt;-1
				Local octave:Int = Int(n.value/12)-1
				Local freq:Float = notefreqs[n.value Mod 12]
				freq:*(1 Shl octave)
				snd.Create(freq,1.0)
			End If
		Next
	End Method
	
	Method clear()
		notelist.Clear()
	End Method
	
	Method del()
		steplist.Remove(Self)
	End Method
	
	Method add_note(value:Int)
		note = New note
		note.value = value
		ListAddLast(notelist,note)
	End Method
	
	Function Create:pattern_step(time:Int)
		Local p:pattern_step = New pattern_step
		p.note = New note
		p.note.value = -1
		p.time = time
		p.notelist:TList = CreateList()
		ListAddLast(steplist,p)
		Return p
	End Function
End Type

Type sound
	Global list:TList = CreateList()
	Field triggered:Byte
	Field note:Float
	Field vol:Float
	
	Field curvol:Float
	Field curfreq:Float
	
	Function update:Float()
		Local value:Float = 0
		For Local s:sound = EachIn list
			value:+ s.fill()
		Next
		Return value
	EndFunction
	
	Method fill:Float()
		Local value:Float = curvol*Sin(curfreq) 
		curfreq:+note
		curvol:+(vol-curvol)*0.01		
		If vol&gt;0.0001 Then vol:*0.9999 Else vol=0;triggered=0;list.Remove(Self);Return 0
		Return value
	End Method
	 
	Method trigger(in_note:Float, in_velocity:Float)
		triggered = 1
		vol = in_velocity*0.2
		note = in_note
		curvol = 0
		curfreq = 0
	End Method
	
	Function Create:sound(in_note:Float=1.0, in_velocity:Float=0.0)
		Local s:sound = New sound
		s.trigger(in_note, in_velocity)
		ListAddLast(list,s)
		Return s
	End Function
End Type</textarea><br>How this works...<br>Hit [F1] to start step recording the sequence.<br>hit [F2] to playback the sequence.<br><br>When recording, your keyboard acts as piano, while [spacebar] or cursor right skips a step. <br>[delete] deletes the last entered note and moves back on its step so you can replace it.<br>[shift]+[delete] clears the whole sequence (while in record mode!)<br><br>While in playback mode you can always doodle to it with your mouse on the theremin section (and beyond, LOL) and with your keyboard, of course.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100881"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Taron, here's some real nice code for you.<br>it's the frequency tables of all notes :)<br><br>just copy/paste. any probe let me know :)<br><br><br><br>'this is the sample frequency data in octaves (12 notes per octave, 9 octaves)<br><br>#SampleNoteData<br>DefData 16.35, 17.32, 18.35, 19.45, 20.60, 21.83, 23.12, 24.50, 25.96, 27.50, 29.14, 30.87<br>DefData 32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 49.00, 51.91, 55.00, 58.27, 61.74<br>DefData 65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.8, 110.0, 116.5, 123.5<br>DefData 130.8, 138.6, 146.8, 155.6, 164.8, 174.6, 185.0, 196.0, 207.7, 220.0, 233.1, 246.9<br>DefData 261.6, 277.2, 293.7, 311.1, 329.6, 349.2, 370.0, 392.0, 415.3, 440.0, 466.2, 493.9<br>DefData 523.3, 554.4, 587.3, 622.3, 659.3, 698.5, 740.0, 784.0, 830.6, 880.0, 932.3, 987.8<br>DefData 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976<br>DefData 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951<br>DefData 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902<br><br>'initialise the data with a call to SetupNotes()<br>'rate=SampleNotes[octave,note] <br>'the notes go up to 17 so you can use an octave and 5 more notes on top<br>Global SampleNotes:Float[9,17]<br><br>'rate=SamplePureNotes[flat note number 0 to 108]<br>Global SamplePureNotes:Float[109]<br><br>function SetupNotes()<br>	Local k:Int<br>	Local j:Int<br>	Local freq:Float<br>	Local count:Int = 0<br><br>	RestoreData SampleNoteData<br>	For k = 0 To 8<br>		For j = 0 To 11<br>			ReadData freq<br>			SampleNotes[k,j] = freq/220<br>			If j &lt; 5 SampleNotes[k,j+12] = freq/110<br>			SamplePureNotes[count] = freq/220<br>			count = count + 1<br>		Next<br>	Next	<br>end function <br><br></td></tr></table><br>
<a name="1100882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> MidiMaster do you have any code that does FFT on a sample? I'm looking for something that will give me at least 48 frequencies ?? <br><br></td></tr></table><br>
<a name="1100884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Taron, instead of the many if commands - that will eat cpu time to check consider doing the following:<br><br>in your event loop add the following:<br><br>Case EVENT_KEYDOWN EventKeyDown(EventData())<br><br>then do all you keyboard processing here:<br><br>function EventKeyDown(EventKey:Int)<br>	Select EventKey<br>		Case KEY_ESCAPE<br>'do some code<br>		Case KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_0<br>'do some code<br>		Case KEY_NUM1<br>'do some code<br>end select<br>end function<br><br><br>the reason to use select/case instead of if, is case uses an internal jump table which is very efficient in speed terms :)<br><br>lots of if's will need all to be checked :( <br><br></td></tr></table><br>
<a name="1100887"></a>

<a name="1100889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah yes, that's a clever call. Thanks!<br>And thanks for the table, too.<br><br>I don't think I'll touch this thing until magically some good timing solution arises. It's a bit too frustrating to me right now. I hope, who ever figures it out finds inspiration enough to share as I'm sharing my findings.<br><br>OH, and JAddams, feel free to alter the code and post your version! ;)<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100891"></a>

<a name="1100894"></a>

<a name="1100904"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> WAAAHHHHHH...me SOOOOOO stupid! &lt;lol, shame&gt;<br>And again, drpetter came to the rescue. I don't know why my brains where so freaking weak today, but there's a much more elegant solution to this sort of timing...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import pub.OpenAL
Import brl.RamStream
Import brl.timer
Import BRL.EventQueue
'=============================================================================
AppTitle="openAL realtime synth/streaming"

SetGraphicsDriver GLMax2DDriver()
Const Width:Int =	1280
Const Height:Int =	720
Global hWidth:Int=Width*0.5
Global hHeight:Int=Height*0.5
GLGraphics (Width,Height,0)

glewInit()
glFlush()
glOrtho (0, Width, Height, 0, -100, 100)
glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 

'============================ AUDIO setup ====================================
Global audiotrue:Byte = 0

If OpenALInstalled()
	audiotrue=1
Else
	GLDrawText"Audio OFF: OpenAL audio is not installed. &lt;hit any key to continue!&gt;",0,hHeight-17
	Flip 0
	WaitKey()
	End
End If

'============================ The Real Deal ==================================
Const BUFFER_SIZE:Int=1800
Const SAMPLING_FRQ:Int=44100

Global source:Int
Global buffers:Int[3]
Global frequency:Int
Global format:Int
Global buf:Byte Ptr

Global ALDevice:Int =alcOpenDevice(Null) 
Global ALContext:Int =alcCreateContext(ALDevice, Null) 
alcMakeContextCurrent(ALContext)

alGenBuffers(3,buffers)
alGenSources(1, Varptr source)

Global buffer_A:Short[BUFFER_SIZE]

format = AL_FORMAT_MONO16
buf = Byte Ptr buffer_A
For Local i:Int = 0 Until BUFFER_SIZE
		buffer_A[i] = 0
Next
alBufferData(buffers[0], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[1], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[2], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)

alSourceQueueBuffers(source, 1, Varptr buffers[0])
alSourceQueueBuffers(source, 1, Varptr buffers[1])
alSourceQueueBuffers(source, 1, Varptr buffers[2])
alSourcePlay(source)

Global tick:Int = 0
Global record:Byte = 0
Global timestep:Int = 0
Global pattern_length:Int = 32
Global pattern:pattern_step = New pattern_step
For Local i:Int = 0 Until pattern_length
	pattern.Create(i)
Next
Global notefreqs:Float[] = [1.0,1.05946,1.12246,1.18921,1.25992,1.33483,1.41421,1.49831,1.58740,1.68179,1.78180,1.88775]
Global notecols:Float[]  = [0.3,0.1,0.3,0.1,0.3,0.3,0.1,0.3,0.1,0.3,0.1,0.3]

Global play:Byte = 0
Global cur_step:Int = 0
Global timer:Int = 0
Global speed:Int = 15

Global oct:Int = 1
Global freq:Double = 1.0
Global vol:Double = 0.0
Global a:Double = 0.0
Global snd:sound = sound.Create(0,256)

AddHook FlipHook,process

While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	Flip 0
Wend
	alcDestroyContext(ALContext)
	alcCloseDevice(ALDevice)
	ALContext=0
	ALDevice=0
End

Function process:Object(id:Int,data:Object,context:Object )
	glClear(GL_COLOR_BUFFER_BIT)
	
	Local note:Int = -1		
	If audiotrue
		Local buffer:Int
		Local val:Int
		
		Local theremin:Byte = MouseDown(1)
		alGetSourcei(source, AL_BUFFERS_PROCESSED, Varptr val)
			While(val)
				alSourceUnqueueBuffers(source,1, Varptr buffer)
				For Local i:Int = 0 Until BUFFER_SIZE
					If play And tick&gt;11025
						tick=0
						cur_step = cur_step Mod pattern_length
						pattern = pattern_step(pattern.steplist.ValueAtIndex(cur_step))
						pattern.play(snd)
						cur_step:+1
					End If
					
					buffer_A[i] = snd.update()*$7fff
					
					If vol&gt;0.0001 Or theremin
						buffer_A[i]:+ vol*Sin(a)*$7fff
						Local cntr:Double =0.5*2^(MouseX()/(0.125*Width))
						freq:+(cntr-freq)*0.0002
						a:+freq
						vol:+(theremin*(1.0-(Double(MouseY())/Height))-vol)*0.0002
					End If
					tick:+1
				Next
				alBufferData(buffer, format, buf, BUFFER_SIZE*2, SAMPLING_FRQ)
				alSourceQueueBuffers(source,1, Varptr buffer)
				val:-1
			Wend
		If val&lt;=0
			alGetSourcei(source, AL_SOURCE_STATE, Varptr val)
			If val&lt;&gt; AL_PLAYING
				alSourcePlay(source)
			End If
		End If
	End If
		
		If KeyHit(KEY_PAGEUP) Then oct=oct Shl 1
		If KeyHit(KEY_PAGEDOWN) Then If oct&gt;1 Then oct=oct Shr 1
		If KeyHit(KEY_Z) Then 			sound.Create((oct Shl 0)*1.0	,1.0); note =0	
			If KeyHit(KEY_S) Then 		sound.Create((oct Shl 0)*1.05946,1.0); note =1	
		If KeyHit(KEY_X) Then 			sound.Create((oct Shl 0)*1.12246,1.0); note =2	
			If KeyHit(KEY_D) Then 		sound.Create((oct Shl 0)*1.18921,1.0); note =3	
		If KeyHit(KEY_C) Then 			sound.Create((oct Shl 0)*1.25992,1.0); note =4
		If KeyHit(KEY_V) Then 			sound.Create((oct Shl 0)*1.33483,1.0); note =5	
			If KeyHit(KEY_G) Then 		sound.Create((oct Shl 0)*1.41421,1.0); note =6
		If KeyHit(KEY_B) Then 			sound.Create((oct Shl 0)*1.49831,1.0); note =7
			If KeyHit(KEY_H) Then 		sound.Create((oct Shl 0)*1.58740,1.0); note =8
		If KeyHit(KEY_N) Then 			sound.Create((oct Shl 0)*1.68179,1.0); note =9
			If KeyHit(KEY_J) Then 		sound.Create((oct Shl 0)*1.78180,1.0); note =10
		If KeyHit(KEY_M) Then 			sound.Create((oct Shl 0)*1.88775,1.0); note =11
		If KeyHit(KEY_COMMA) Then 		sound.Create((oct Shl 1)*1.0	,1.0); note =12
			If KeyHit(KEY_L) Then 		sound.Create((oct Shl 1)*1.05946,1.0); note =13
		If KeyHit(KEY_PERIOD) Then 		sound.Create((oct Shl 1)*1.12246,1.0); note =14
		   If KeyHit(KEY_SEMICOLON)Then sound.Create((oct Shl 1)*1.18921,1.0); note =15
		If KeyHit(KEY_SLASH) Then 		sound.Create((oct Shl 1)*1.25992,1.0); note =16
		
		If KeyHit(KEY_Q) Then 			sound.Create((oct Shl 1)*1.0	,1.0); note =12	
			If KeyHit(KEY_2) Then 		sound.Create((oct Shl 1)*1.05946,1.0); note =13
		If KeyHit(KEY_W) Then 			sound.Create((oct Shl 1)*1.12246,1.0); note =14
			If KeyHit(KEY_3) Then 		sound.Create((oct Shl 1)*1.18921,1.0); note =15
		If KeyHit(KEY_E) Then 			sound.Create((oct Shl 1)*1.25992,1.0); note =16
		If KeyHit(KEY_R) Then 			sound.Create((oct Shl 1)*1.33483,1.0); note =17
			If KeyHit(KEY_5) Then 		sound.Create((oct Shl 1)*1.41421,1.0); note =18
		If KeyHit(KEY_T) Then 			sound.Create((oct Shl 1)*1.49831,1.0); note =19
			If KeyHit(KEY_6) Then 		sound.Create((oct Shl 1)*1.58740,1.0); note =20
		If KeyHit(KEY_Y) Then 			sound.Create((oct Shl 1)*1.68179,1.0); note =21
			If KeyHit(KEY_7) Then 		sound.Create((oct Shl 1)*1.78180,1.0); note =22
		If KeyHit(KEY_U) Then 			sound.Create((oct Shl 1)*1.88775,1.0); note =23
		If KeyHit(KEY_I) Then 			sound.Create((oct Shl 2)*1.0	,1.0); note =24
			If KeyHit(KEY_9) Then 		sound.Create((oct Shl 2)*1.05946,1.0); note =25
		If KeyHit(KEY_O) Then 			sound.Create((oct Shl 2)*1.12246,1.0); note =26
			If KeyHit(KEY_0) Then 		sound.Create((oct Shl 2)*1.18921,1.0); note =27
		If KeyHit(KEY_P) Then 			sound.Create((oct Shl 2)*1.25992,1.0); note =28
		If KeyHit(KEY_OPENBRACKET)Then 	sound.Create((oct Shl 2)*1.33483,1.0); note =29
		If KeyHit(KEY_EQUALS) 	  Then 	sound.Create((oct Shl 2)*1.41421,1.0); note =30
		If KeyHit(KEY_CLOSEBRACKET)Then sound.Create((oct Shl 2)*1.49831,1.0); note =31
	
	Local st:Float = Float(Width)/8
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			For Local i:Int = 0 Until 12
				glColor3f(2*notecols[i],1.1*notecols[i],notecols[i])
				glVertex2d(x*st+i*(st/12),200)
				glVertex2d(x*st+i*(st/12),Height)
			Next
		glEnd
	Next
	st:Float = Float(Width)/8
	glColor3f(1.0,1.0,1.0)
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			glVertex2d(x*st,200)
			glVertex2d(x*st,Height)
		glEnd
	Next
	
	For Local i:Int = 0 Until BUFFER_SIZE
			Local v:Float = Float((buffer_A[i]+$7fff) Mod $ffff)/$ffff
			glBegin(GL_POINTS)
				glVertex2d(i,10+700*v)
			glEnd
	Next
	
	'------------------------------------------ DRAW pattern
	glColor4f(0.25,0.15,0.05,1.0)
	Local dstepsize:Float = Width/pattern_length
	For pattern = EachIn pattern.steplist
		If record Then If pattern.time=timestep Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
		If play Then If pattern.time=cur_step-1 Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
		quad(pattern.time*dstepsize,0,dstepsize-1.0,200)
			
		glBlendFunc (GL_SRC_ALPHA,GL_ONE) 
		If pattern.note.value=-1 Then glColor3f(0.15,0.07,0.05)
		quad(pattern.time*dstepsize,0,dstepsize-1.0,200)
			
		If pattern.note.value=-1 Then glColor3f(0.25,0.15,0.05)
		glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
	Next
	glColor3f(1.0,1.0,1.0)
	For pattern = EachIn pattern.steplist
		For Local n:note = EachIn pattern.notelist
			If n.value&gt;-1 Then quad(pattern.time*dstepsize,244-n.value*4,dstepsize)
		Next
	Next

	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RECORD
	If KeyHit(KEY_F1) Then record:~1
	If record
		If play Then play = 0
		If note&gt;-1
			timestep = timestep Mod pattern_length
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			If pattern Then pattern.add_note((oct*12)+note)
			timestep:+1
		End If
		If KeyHit(KEY_SPACE) 
			timestep = timestep Mod pattern_length
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			If pattern Then If pattern.notelist.Count()=0 Then pattern.add_note(-1)
			timestep:+1
		EndIf
		If KeyHit(KEY_LEFT)
			timestep:-1
			If timestep&lt;0 Then timestep = pattern_length
		End If
		If KeyHit(KEY_RIGHT)
			timestep:+1
			timestep = timestep Mod pattern_length
		End If
		If KeyHit(KEY_DELETE)
			If KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
				For pattern = EachIn pattern.steplist
					pattern.clear()
				Next
			Else
				timestep:-1
				If timestep&lt;0 Then timestep:+pattern_length
				pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
				If pattern Then pattern.notelist.Remove(pattern.notelist.last());pattern.add_note(-1)
			End If
		End If
		
		glColor3f(1.0,0.0,0.0)
		glBegin(GL_QUADS)
			glVertex2d(10.0,0.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
			glVertex2d(10.0,10.0)
		glEnd
	End If
	
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PLAY
	If KeyHit(KEY_F2) 
		If record Then record = 0
		If Not play Then cur_step=0
		play:~1
	End If
	If play
		glColor3f(0.0,1.0,0.0)
		glBegin(GL_TRIANGLES)
			glVertex2d(10.0,5.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
		glEnd
	End If
End Function


Function quad(x:Float,y:Float, w:Float=4.0, h:Float=4.0)
	glBegin(GL_QUADS)
		glVertex2f(x+w,y  )
		glVertex2f(x  ,y  )
		glVertex2f(x  ,y+h)
		glVertex2f(x+w,y+h)
	glEnd()
End Function

Type note
	Field value:Int
	Field velocity:Float
End Type

Type pattern_step
	Global steplist:TList = CreateList()
	Field notelist:TList
	Field note:note
	Field time:Int
	
	Method play(snd:sound)
		For Local n:note = EachIn notelist
			If n.value&gt;-1
				Local octave:Int = Int(n.value/12)-1
				Local freq:Float = notefreqs[n.value Mod 12]
				freq:*(1 Shl octave)
				snd.Create(freq,1.0)
			End If
		Next
	End Method
	
	Method clear()
		notelist.Clear()
	End Method
	
	Method del()
		steplist.Remove(Self)
	End Method
	
	Method add_note(value:Int)
		note = New note
		note.value = value
		ListAddLast(notelist,note)
	End Method
	
	Function Create:pattern_step(time:Int)
		Local p:pattern_step = New pattern_step
		p.note = New note
		p.note.value = -1
		p.time = time
		p.notelist:TList = CreateList()
		ListAddLast(steplist,p)
		Return p
	End Function
End Type

Type sound
	Global list:TList = CreateList()
	Field triggered:Byte
	Field note:Float
	Field vol:Float
	
	Field curvol:Float
	Field curfreq:Float
	
	Function update:Float()
		Local value:Float = 0
		For Local s:sound = EachIn list
			value:+ s.fill()
		Next
		Return value
	EndFunction
	
	Method fill:Float()
		Local value:Float = curvol*Sin(curfreq) 
		curfreq:+note
		curvol:+(vol-curvol)*0.01		
		If vol&gt;0.0001 Then vol:*0.9999 Else vol=0;triggered=0;list.Remove(Self);Return 0
		Return value
	End Method
	 
	Method trigger(in_note:Float, in_velocity:Float)
		triggered = 1
		vol = in_velocity*0.2
		note = in_note
		curvol = 0
		curfreq = 0
	End Method
	
	Function Create:sound(in_note:Float=1.0, in_velocity:Float=0.0)
		Local s:sound = New sound
		s.trigger(in_note, in_velocity)
		ListAddLast(list,s)
		Return s
	End Function
End Type</textarea><br><br>LOL<br>This doesn't care about the timing goofs of the system and just generates the sounds with their internal tick timing properly. Wow... I really underestimated my degree of stupidity.<br><br>Anyway, BIG THANKS to Tomas for his brilliance in simplicity and my humble apologies for sharing such silly frustration...<br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1100895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> This clumsy doodle may or may not amuse you -- created with the first keyboard version. (Recorded sequence then mouse afterwards.)<br><br><a href="http://www.sendspace.com/file/qkd4vy" target="_blank">http://www.sendspace.com/file/qkd4vy</a><br><br>(The unfortunate clicking actually came from Audacity recording the WindowsXP "What-U-Hear" device.) <br><br></td></tr></table><br>
<a name="1100903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow. very sad with the clipping from audacity. I'll write a little wav output or so... or why does it all have to be me? LOL<br><br>That's VERY cool, though! THANKS!<br><br>The theremin is great fun as bass, too. <br>Uh, I feel so relaxed now, haha, thank you, J! <br><br></td></tr></table><br>
<a name="1100910"></a>

<a name="1100911"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Way off topic but....<br><div class="quote"> <br>one thing I'd really like to recreate using this stuff is drpetter's engine sound from <a href="http://www.youtube.com/watch?v=Ic750lQPWMo&amp;feature=player_profilepage" target="_blank"><b>this video</b></a><br> <br></div><br><br>I once had a go in 4wd Dax Rush kit car with a full race cosworth engine plus goodies. The power figures were something stupid like 660bhp per tonne and it weighed in at 800kg and could go from 0 to 100mph and back to 0 in 9 secs!!! Truly amazing.<br><br>Anyway - It sounded identical to that engine noise in the vid and OMG!!! It would rev just as fast as the engine in that vid too. I took another friend out in it, and as he wasn't expecting the acceleration, it took his breath to the point his couldn't breathe during that initial squirt of power when going from 2,3,4 and into 5 gears :D<br><br>It was an amazing machine and I've never heard anything sound and rev like it until now. That savage scream at top revs will live with me forever :D<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101030"></a>

<a name="1101031"></a>

<a name="1101032"></a>

<a name="1101054"></a>

<a name="1101055"></a>

<a name="1101098"></a>

<a name="1101099"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sounds like quite a privilege there. Fun for sure! :)<br><br>Here's a little update...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import pub.OpenAL
Import brl.RamStream
Import BRL.EventQueue
'=============================================================================
AppTitle="Theriphone (openAL)              [F4]record steps               [F5]play"

SetGraphicsDriver GLMax2DDriver()
Const Width:Int =	1280
Const Height:Int =	720
Global hWidth:Int=Width*0.5
Global hHeight:Int=Height*0.5
GLGraphics (Width,Height,0)

glewInit()
glFlush()
glOrtho (0, Width, Height, 0, -100, 100)
glEnable(GL_ALPHA_TEST)
glAlphaFunc(GL_NOTEQUAL,0)           
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 

'============================ AUDIO setup ====================================
Global audiotrue:Byte = 0

If OpenALInstalled()
	audiotrue=1
Else
	GLDrawText"Audio OFF: OpenAL audio is not installed. &lt;hit any key to continue!&gt;",0,hHeight-17
	Flip 0
	WaitKey()
	End
End If

'============================ The Real Deal ==================================
Const BUFFER_SIZE:Int=2800
Const SAMPLING_FRQ:Int=44100

Global source:Int
Global buffers:Int[2]
Global frequency:Int
Global format:Int
Global buf:Byte Ptr

Global ALDevice:Int =alcOpenDevice(Null) 
Global ALContext:Int =alcCreateContext(ALDevice, Null) 
alcMakeContextCurrent(ALContext)

alGenBuffers(2,buffers)
alGenSources(1, Varptr source)

alListenerfv(AL_POSITION,[0.0,0.0,0.0])
alListenerfv(AL_VELOCITY,[0.0,0.0,0.0])
alListenerfv(AL_ORIENTATION,[0.0,0.0,-1.0])

Global buffer_A:Short[BUFFER_SIZE]

format = AL_FORMAT_MONO16
buf = Byte Ptr buffer_A
For Local i:Int = 0 Until BUFFER_SIZE
		buffer_A[i] = 0
Next
alBufferData(buffers[0], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
alBufferData(buffers[1], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)
'alBufferData(buffers[2], format, buf,BUFFER_SIZE*2,SAMPLING_FRQ)

alSourceQueueBuffers(source, 1, Varptr buffers[0])
alSourceQueueBuffers(source, 1, Varptr buffers[1])
'alSourceQueueBuffers(source, 1, Varptr buffers[2])
alSourcePlay(source)

Global tick:Int = 0
Global tick_gap:Int = 0
Global record:Byte = 0
Global timestep:Int = 0
Global timestep_advance:Byte=0
Global pattern_length:Int = 64
Global pattern:pattern_step = New pattern_step
For Local i:Int = 0 Until pattern_length
	pattern.Create(i)
Next
Global notefreqs:Float[] = [1.0,1.05946,1.12246,1.18921,1.25992,1.33483,1.41421,1.49831,1.58740,1.68179,1.78180,1.88775]
Global notecols:Float[]  = [0.3,0.1,0.3,0.1,0.3,0.3,0.1,0.3,0.1,0.3,0.1,0.3]

Global play:Byte = 0
Global cur_step:Int = 0
Global timer:Int = 0

Global speed:Int = 5
Global speeds:Float[]=[0.125 ,0.25 ,0.375 ,0.5 ,0.75 ,1.0 ,1.5 ,2.0]

Global oct:Int = 1
Global freq:Double = 1.0
Global vol:Double = 0.0
Global a:Double = 0.0
Global theremin_cntr:Double = 0.0
Global snd:sound = New sound

AddHook FlipHook,process

While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	Flip 0
Wend
	alcDestroyContext(ALContext)
	alcCloseDevice(ALDevice)
	ALContext=0
	ALDevice=0
End

Function process:Object(id:Int,data:Object,context:Object )
	glClear(GL_COLOR_BUFFER_BIT)
	
	Local note:Int = -1		
	If audiotrue
		Local buffer:Int
		Local val:Int
		
		Local theremin:Byte = MouseDown(1) And MouseY()&gt;200
		alGetSourcei(source, AL_BUFFERS_PROCESSED, Varptr val)
			While(val)
				alSourceUnqueueBuffers(source,1, Varptr buffer)
				For Local i:Int = 0 Until BUFFER_SIZE
					If play And tick&gt;12000*speeds[speed]
						tick=0
						cur_step = cur_step Mod pattern_length
						pattern = pattern_step(pattern.steplist.ValueAtIndex(cur_step))
						pattern.play(snd)
						cur_step:+1
					End If
					
					buffer_A[i] = snd.update()*$7fff
					
					If (vol&gt;0.0001 Or theremin)
						buffer_A[i]:+ vol*Sin(a)*$7fff
						If MouseY()&gt;200 Then theremin_cntr =0.535*2^(MouseX()/(0.125*Width))
						freq:+(theremin_cntr-freq)*0.0002
						a:+freq
						vol:+(theremin*(1.0-(Double(MouseY())/Height))-vol)*0.0002
					End If
					tick:+1
				Next
				alBufferData(buffer, format, buf, BUFFER_SIZE*2, SAMPLING_FRQ)
				alSourceQueueBuffers(source,1, Varptr buffer)
				val:-1
			Wend
		If val&lt;=0
			alGetSourcei(source, AL_SOURCE_STATE, Varptr val)
			If val&lt;&gt; AL_PLAYING
				alSourcePlay(source)
			End If
		End If
	End If
	If KeyHit(KEY_HOME) Then If speed&lt;7 Then speed:+1
	If KeyHit(KEY_END) Then If speed&gt;0 Then speed:-1
	
	If KeyHit(KEY_PAGEUP) Then oct=oct Shl 1
	If KeyHit(KEY_PAGEDOWN) Then If oct&gt;1 Then oct=oct Shr 1
	If KeyHit(KEY_Z) Then 			sound.Create((oct Shl 0)*1.0	,1.0,0 ); note =0	
		If KeyHit(KEY_S) Then 		sound.Create((oct Shl 0)*1.05946,1.0,1 ); note =1	
	If KeyHit(KEY_X) Then 			sound.Create((oct Shl 0)*1.12246,1.0,2 ); note =2	
		If KeyHit(KEY_D) Then 		sound.Create((oct Shl 0)*1.18921,1.0,3 ); note =3	
	If KeyHit(KEY_C) Then 			sound.Create((oct Shl 0)*1.25992,1.0,4 ); note =4
	If KeyHit(KEY_V) Then 			sound.Create((oct Shl 0)*1.33483,1.0,5 ); note =5	
		If KeyHit(KEY_G) Then 		sound.Create((oct Shl 0)*1.41421,1.0,6 ); note =6
	If KeyHit(KEY_B) Then 			sound.Create((oct Shl 0)*1.49831,1.0,7 ); note =7
		If KeyHit(KEY_H) Then 		sound.Create((oct Shl 0)*1.58740,1.0,8 ); note =8
	If KeyHit(KEY_N) Then 			sound.Create((oct Shl 0)*1.68179,1.0,9 ); note =9
		If KeyHit(KEY_J) Then 		sound.Create((oct Shl 0)*1.78180,1.0,10); note =10
	If KeyHit(KEY_M) Then 			sound.Create((oct Shl 0)*1.88775,1.0,11); note =11
	If KeyHit(KEY_COMMA) Then 		sound.Create((oct Shl 1)*1.0	,1.0,12); note =12
		If KeyHit(KEY_L) Then 		sound.Create((oct Shl 1)*1.05946,1.0,13); note =13
	If KeyHit(KEY_PERIOD) Then 		sound.Create((oct Shl 1)*1.12246,1.0,14); note =14
	   If KeyHit(KEY_SEMICOLON)Then sound.Create((oct Shl 1)*1.18921,1.0,15); note =15
	If KeyHit(KEY_SLASH) Then 		sound.Create((oct Shl 1)*1.25992,1.0,16); note =16
																		 
	If KeyHit(KEY_Q) Then 			sound.Create((oct Shl 1)*1.0	,1.0,12); note =12	
		If KeyHit(KEY_2) Then 		sound.Create((oct Shl 1)*1.05946,1.0,13); note =13
	If KeyHit(KEY_W) Then 			sound.Create((oct Shl 1)*1.12246,1.0,14); note =14
		If KeyHit(KEY_3) Then 		sound.Create((oct Shl 1)*1.18921,1.0,15); note =15
	If KeyHit(KEY_E) Then 			sound.Create((oct Shl 1)*1.25992,1.0,16); note =16
	If KeyHit(KEY_R) Then 			sound.Create((oct Shl 1)*1.33483,1.0,17); note =17
		If KeyHit(KEY_5) Then 		sound.Create((oct Shl 1)*1.41421,1.0,18); note =18
	If KeyHit(KEY_T) Then 			sound.Create((oct Shl 1)*1.49831,1.0,19); note =19
		If KeyHit(KEY_6) Then 		sound.Create((oct Shl 1)*1.58740,1.0,20); note =20
	If KeyHit(KEY_Y) Then 			sound.Create((oct Shl 1)*1.68179,1.0,21); note =21
		If KeyHit(KEY_7) Then 		sound.Create((oct Shl 1)*1.78180,1.0,22); note =22
	If KeyHit(KEY_U) Then 			sound.Create((oct Shl 1)*1.88775,1.0,23); note =23
	If KeyHit(KEY_I) Then 			sound.Create((oct Shl 2)*1.0	,1.0,24); note =24
		If KeyHit(KEY_9) Then 		sound.Create((oct Shl 2)*1.05946,1.0,25); note =25
	If KeyHit(KEY_O) Then 			sound.Create((oct Shl 2)*1.12246,1.0,26); note =26
		If KeyHit(KEY_0) Then 		sound.Create((oct Shl 2)*1.18921,1.0,27); note =27
	If KeyHit(KEY_P) Then 			sound.Create((oct Shl 2)*1.25992,1.0,28); note =28
	If KeyHit(KEY_OPENBRACKET)Then 	sound.Create((oct Shl 2)*1.33483,1.0,29); note =29
	If KeyHit(KEY_EQUALS) 	  Then 	sound.Create((oct Shl 2)*1.41421,1.0,30); note =30
	If KeyHit(KEY_CLOSEBRACKET)Then sound.Create((oct Shl 2)*1.49831,1.0,31); note =31
	
	Local st:Float = Float(Width+20)/8
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			For Local i:Int = 0 Until 12
				glColor3f(2*notecols[i],1.1*notecols[i],notecols[i])
				glVertex2d(x*st+i*(st/12)-5,200)
				glVertex2d(x*st+i*(st/12)-5,Height)
			Next
		glEnd
	Next
	'st:Float = Float(Width+20)/8
	glColor3f(1.0,1.0,1.0)
	For Local x:Int = 0 To 8
		glBegin(GL_LINES)
			glVertex2d(x*st-5,200)
			glVertex2d(x*st-5,Height)
		glEnd
	Next
	
	For Local i:Int = 0 Until BUFFER_SIZE
			Local v:Float = Float((buffer_A[i]+$7fff) Mod $ffff)/$ffff
			glBegin(GL_POINTS)
				glVertex2d(i,10+700*v)
			glEnd
	Next
	'------------------------------------------ DRAW pattern
	glColor4f(0.25,0.15,0.05,1.0)
	Local measure_bar:Int = 3
	Local measure_counter:Int = 0
	Local dstepsize:Float = Width/pattern_length
	For pattern = EachIn pattern.steplist
		If record Then If pattern.time=timestep Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
		If play Then If pattern.time=cur_step-1 Then glColor3f(0.07,0.3,0.05) Else glColor3f(0.25,0.15,0.05)
		If measure_counter = 0 Then measure_bar = 3 Else measure_bar = 1
		measure_counter:+1; measure_counter:Mod 4
		quad(pattern.time*dstepsize+(measure_bar-1),0,dstepsize-measure_bar,200)
			
		glBlendFunc (GL_SRC_ALPHA,GL_ONE) 
		If pattern.note.value=-1 Then glColor3f(0.15,0.07,0.05)
		quad(pattern.time*dstepsize+(measure_bar-1),0,dstepsize-measure_bar,200)
			
		If pattern.note.value=-1 Then glColor3f(0.25,0.15,0.05)
		glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
	Next
	glColor3f(1.0,1.0,1.0)
	For pattern = EachIn pattern.steplist
		For Local n:note = EachIn pattern.notelist
			If n.value&gt;-1 Then quad(pattern.time*dstepsize+1,244-n.value*4,dstepsize-2)
		Next
	Next
	GLDrawText(snd.list.Count(),20,700)
	
	glColor4f(0.0,0.0,0.0,0.45)
	For Local i:Int = 0 Until (200/4)
		line(0,200-i*4,Width)
		If (i Mod 12)=0 Then line(0,199-i*4,Width)
	Next
	glColor4f(0.1,0.0,0.0,0.15)
	For Local i:Int = 0 Until (200/4)
		Local y:Int = i Mod 12
		If y=2 Or y=4 Or y=7 Or y=9 Or y=11 Then quad(0,200-i*4,Width,4)
		If (i Mod 12)=0 Then line(0,199-i*4,Width)
	Next
	
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MOUSE on pattern
	If MouseY()&lt;200
		glBlendFunc (GL_SRC_ALPHA,GL_ONE) 
		glColor4f(0.25,0.1,0.0,1.0)
			Local hx:Int = MouseX()/dstepsize
			quad(dstepsize*hx,0,dstepsize,200)
		Local pattern_tmp:pattern_step = pattern_step(pattern.steplist.ValueAtIndex(hx))
		Local notepos:Int = (200-MouseY())/4
			quad(dstepsize*hx,196-notepos*4,dstepsize,4)
		If MouseHit(1) 
			timestep=hx 
			pattern_tmp.add_note((oct*12)+notepos)
			pattern_tmp.play(snd)
			snd.templist.clear()
		EndIf
		If MouseHit(2)
			timestep=hx
			Local all:Byte = 1
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			For Local n:note = EachIn pattern.notelist
				If n.value=((oct*12)+notepos) Then pattern.notelist.Remove(n); all=0
			Next
			If all And pattern Then pattern.notelist.Clear(); If pattern.notelist.Count()=0 Then pattern.add_note(-1)
		End If
		glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
	End If
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RECORD
	If KeyHit(KEY_F4) Then record:~1
	If record
		If play Then play = 0
		If snd.templist.Count()&gt;0 And snd.temptimer=1
			timestep = timestep Mod pattern_length
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			If pattern 
				For snd = EachIn snd.templist
					pattern.add_note((oct*12)+snd.note_collect)	
				Next
			EndIf
			timestep_advance=1+(KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT))
		End If
		If KeyHit(KEY_SPACE) 
			timestep = timestep Mod pattern_length
			pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
			If pattern Then If pattern.notelist.Count()=0 Then pattern.add_note(-1)
			timestep:+1
		EndIf
		If KeyHit(KEY_LEFT)
			timestep:-1
			If timestep&lt;0 Then timestep = pattern_length
		End If
		If KeyHit(KEY_RIGHT)
			timestep:+1
			timestep = timestep Mod pattern_length
		End If
		If KeyHit(KEY_DELETE)
			If KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
				For pattern = EachIn pattern.steplist
					pattern.clear()
				Next
			Else
				timestep:-1
				If timestep&lt;0 Then timestep:+pattern_length
				pattern = pattern_step(pattern.steplist.ValueAtIndex(timestep))
				If pattern Then pattern.notelist.Remove(pattern.notelist.last()); If pattern.notelist.Count()=0 Then pattern.add_note(-1)
			End If
		End If
		If snd.temptimer&gt;0 Then snd.temptimer:-1 Else snd.templist.Clear(); If timestep_advance Then timestep:+timestep_advance; timestep_advance=0
		glColor3f(1.0,0.0,0.0)
		glBegin(GL_QUADS)
			glVertex2d(10.0,0.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
			glVertex2d(10.0,10.0)
		glEnd
	Else
		If snd.templist.Count()&gt;0 Then snd.templist.Clear()
	End If
	
	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PLAY
	If KeyHit(KEY_F5) 
		If record Then record = 0
		If Not play Then cur_step=0
		play:~1
	End If
	If play
		glColor3f(0.0,1.0,0.0)
		glBegin(GL_TRIANGLES)
			glVertex2d(10.0,5.0)
			glVertex2d(0.0 ,0.0)
			glVertex2d(0.0 ,10.0)
		glEnd
	End If
End Function


Function quad(x:Float,y:Float, w:Float=4.0, h:Float=4.0)
	glBegin(GL_QUADS)
		glVertex2f(x+w,y  )
		glVertex2f(x  ,y  )
		glVertex2f(x  ,y+h)
		glVertex2f(x+w,y+h)
	glEnd()
End Function
Function line(x:Float,y:Float, x2:Float)
	glBegin(GL_QUADS)
		glVertex2f(x ,y)
		glVertex2f(x ,y+1)
		glVertex2f(x2,y+1)
		glVertex2f(x2,y)
	glEnd()
End Function

Type note
	Field value:Int
	Field velocity:Float
End Type

Type pattern_step
	Global steplist:TList = CreateList()
	Field notelist:TList
	Field note:note
	Field time:Int
	
	Method play(snd:sound)
		For Local n:note = EachIn notelist
			If n.value&gt;-1
				Local octave:Int = Int(n.value/12)-1
				Local freq:Float = notefreqs[n.value Mod 12]
				freq:*(1 Shl octave)
				snd.Create(freq,1.0,0)
			End If
		Next
	End Method
	
	Method clear()
		notelist.Clear()
	End Method
	
	Method del()
		steplist.Remove(Self)
	End Method
	
	Method add_note(value:Int)
		note = New note
		note.value = value
		ListAddLast(notelist,note)
	End Method
	
	Function Create:pattern_step(time:Int)
		Local p:pattern_step = New pattern_step
		p.note = New note
		p.note.value = -1
		p.time = time
		p.notelist:TList = CreateList()
		ListAddLast(steplist,p)
		Return p
	End Function
End Type

Type sound
	Global templist:TList = CreateList()
	Global temptimer:Int
	Field note_collect:Int
	Global list:TList = CreateList()
	Field triggered:Byte
	Field note:Float
	Field vol:Float
	
	Field curvol:Float
	Field curfreq:Float
	
	Function update:Float()
		Local combined_vol:Float=0
		Local value:Float = 0
		For Local s:sound = EachIn list
			value:+ s.fill()
			combined_vol:+s.curvol
		Next
		If combined_vol&gt;1.0 Then value:/combined_vol 'quick clipping fix, nothing to keep
		Return value
	EndFunction
	
	Method fill:Float()
		Local value:Float = curvol*Sin(curfreq) 
		curfreq:+note
		curvol:+(vol-curvol)*0.01		
		If vol&gt;0.00001 Then vol:*0.9999 Else vol=0;triggered=0;list.Remove(Self);Return 0
		Return value
	End Method
	 
	Method trigger(in_note:Float, in_velocity:Float)
		triggered = 1
		vol = in_velocity*0.3
		note = in_note*1.07
		curvol = 0
		curfreq = 0
	End Method
	
	Function Create:sound(in_note:Float=1.0, in_velocity:Float=0.0,note_collect:Int)
		Local s:sound = New sound
		s.trigger(in_note, in_velocity)
		ListAddLast(list,s)
		s.note_collect = note_collect
		ListAddLast(templist,s)
		temptimer = 50
		Return s
	End Function
End Type</textarea><br><br>It's now tuned properly again, including the theremin.<br>You can record chords now, too, which is great fun, actually. I don't think I've seen that before, but that doesn't matter.<br>Also I've reduced the buffers to 2 now, which makes it a bit more responsive to me. If it's crackly for you, change either the BUFFERSIZE or add a third one again. Just make sure you enter it everywhere it needs to be!<br><br>[F4] record mode<br>[F5] playback<br><br>[HOME] 1/(x+1) note length<br>[END] 1/(x-1) note length<br>[PAGE UP/DOWN] octaves (whereby that's a bit shotty)<br><br>[MOUSE EDITING of SEQUENCE] possible now. Still not perfect, but well.<br><br><font class="tiny">updated!</font><br><br><font class="tiny">Last edited 2011</font><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101063"></a>

<a name="1101064"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats really cool.<br>Reminds me of <a href="http://www.youtube.com/watch?v=rKrZiddRphw" target="_blank">This</a> and <a href="http://www.youtube.com/watch?v=Xpdq83DVHps&amp;feature=related" target="_blank">This</a><br><br>A neat feature would be to keep the note length related to time of the keys pressed :p<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101066"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> hehe, yeah, there are a number of possible choices for input. Currently it's just like a vibraphone, which is why there is no notelength at present. I did, however, hook in shift+key to skip one step, which can come in very handy.<br>I'm currently adding mouse editing, too.<br><br>It needs a few more things on the pattern type design and interaction, but it's beautifully open to that, too. Nothing is too convoluted, yet. That'll happen soon, though, hahaha. :P<br><br>THANKS, Dave! <br><br></td></tr></table><br>
<a name="1101071"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Taron, a quickie for you...<br>Are you on pc, linux or mac? <br>Mac here <br><br></td></tr></table><br>
<a name="1101087"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> pc (look at my tagline!) ;) <br><br></td></tr></table><br>
<a name="1101257"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Midimaster</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> You are on a good way....<br><br><br>Here some more ideas:<br><br>Use a sawtooth signal to get a more "piano" like sound.<br><br>Use a rectangle signal to get woodwind instruments. Of course the Envelope has to be changed back to linear volume<br><br>Use a staple of sinus signals to get an organ. linear volume!<br>ORGAN:<br>f=frequence<br>g=f*1.01<br>r=( sin(f)+sin(f*2)+ sin(f*3)+ sin(f*4)+ sin(f*5)+ sin(f*6)+ sin(f*7))<br>r=r+( sin(g)+sin(g*2)+ sin(g*3)+ sin(g*4)+ sin(g*5)+ sin(g*6)+ sin(g*7)<br>r=r/14<br><br>Do you know what ADSR means? Attack - Decay - Sustain - Release <br><br></td></tr></table><br>
<a name="1101269"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ian Thompson</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Lovely thread! +++ <br><br></td></tr></table><br>
<a name="1101274"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, Ian! I'm having great fun with it for sure. :)<br><br>Thanks, Midi. Once I'm done with the major mechanics, I'll add the synths. Those will have a great deal more than just waveforms, hehe. We shall see! :}<br><br>Right now I'm working out the pattern editor. My brain's a little fried right now, but it's coming together. It'll get really exciting, once I'll start dealing with parameter curve implementations and the likes. <br><br></td></tr></table><br>
<a name="1101410"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> This may be of interest here -- the source code to the old Amiga version of <a href="http://www.audio-evolution.com/" target="_blank">Audio Evolution</a>, a decent multitrack recorder/audio editor, has just been released:<br><br><a href="http://aminet.net/package/mus/edit/AudioEvolution3_src" target="_blank">http://aminet.net/package/mus/edit/AudioEvolution3_src</a><br><br>The main point of interest in the above .lha file (opens in WinRAR or 7zip) is "dsp.c", which has loads of audio processing functions in plain C code: filtering, pitch-shifting/time-stretching, FFT, compression, ring modulation, reverb, flange, etc. (The Sample structure is in "AudioEvolution.h".)<br><br>As the author states above, "You're free to study and use parts of the code in your own projects." <br><br></td></tr></table><br>
<a name="1101432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> NICE...that might be very pleasant to check out. Compression is most interesting to me, if it's any good.<br><br>I've added a whole bunch of things to the pattern editor, but I feel quite retarded, when I'm coding these days, haha. It ain't pretty, that's for sure. <br>If there was any indication of anyone here caring to participate actively, I would share my shameful mess, but currently it feels rather a bit like I'm flashing everyone with an ever more dysfunctional erection of code (like erection of a house, right, no? Maybe that word isn't so versatile after all?!) :}<br><br>Anyway, I'm ashamed. But it does work quite beautifully. It has zoom and pan, copy and move, perfect BPM and note lengths (+triplets) and a few more catastrophic implementations. &lt;lol&gt;<br><br>Thanks for the link, J, that's awesome! How long is it ago that I heard or saw LHA, hahaha. Wonderful! <br><br></td></tr></table><br>
<a name="1101534"></a>

<a name="1101535"></a>

<a name="1101537"></a>

<a name="1101538"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Posted an updated version in the first post.<br><br>Please, feel free to make known to me how lousy my coding is! Also, I'd be super grateful, if you can offer suggestions to correct some of my stupidities.<br><br><font class="tiny"><br>[LMB] = left mouse button<br>[MMB] = middle mouse button<br>[RMB] = right mouse button<br></font><br>New features:<br>- pattern editing dramatically improved:<br>...  shift+[LMB] toggles pattern step selection<br>...  [LMB] on selected steps and drag to move and transpose notes<br>...  control+[LMB] on selected steps to copy, move and transpose notes<br><br>...  [cursor up] transpose selection one note upward<br>...  shift+[cursor up] transpose selection up by an octave<br>...  [cursor down] transpose selection one note downward<br>...  shift+[cursor down] transpose selection down by an octave<br><br>...  [MMB] pan across pattern (if larger than screen)<br>...  alt+[MMB] zoom pattern<br><br>- went back to three buffers, which seems to allow for faster feedback (potentially)<br><br>- display of notes on a pattern step, if in record mode<br><br>Probably a whole bunch of other little things and a great deal of chaos, but it does kinda work. It may have a few little bugs with the selection dealings, but shouldn't be too disruptive. The coding is terrible, though, I'm sure.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101584"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know why you're so paranoid about your code -- looks fine to me!<br><br>Anyway, the latest version is really cool -- nice delay effect too! I don't think you should be put off posting updates just because nobody else contributes, either. I'm certainly interested in seeing any progress you make, and it appears that others are too.<br><br>I don't have any experience of this stuff -- just very interested in it -- and I still need to try and play with the original version (for simplicity's sake), so I don't think I have anything useful to contribute at this point!<br><br>Anyway, even if you were to never post a single new update, this stuff is invaluable! <br><br></td></tr></table><br>
<a name="1101614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nah, just a bit frustrated with myself, really. I have some "dumb" days, somehow. BUT: Thank you very much, James, it's much, much appreciated!<br><br>I will most likely continue to post some updates. I normally try to figure out as much as I can myself, but sometimes it's a bit rough and I'd be super happy about any support.<br><br>For example: I'm already thinking about preparing implementation of a player routine of it in a game. For that I'm sure it would be best to hook that into its own thread or process. I'm a bit shaky on that so far and if you know anything about that or have some suggestion, that would be quite cool. I guess it's about making it run fairly independently, but sending certain instructions into the thread such as queuing a song or playing a certain sound. <br><br>Well...there will be better days ahead again, I'm sure. You've been already helping the moral aspects a good deal! :) <br><br>Big Thanks! <br><br></td></tr></table><br>
<a name="1101673"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep, the code looks great.<br><br>tried to max it out with notes and it sorta went choppy with 30+ notes being played at once ;) <br><br></td></tr></table><br>
<a name="1101707"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ian Thompson</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, It's a great read, a bit beyond me but it's a great pleasure to see this evolve. I'm learning quite a bit from your example, thank you! <br><br></td></tr></table><br>
<a name="1101710"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Haha, now you're scaring me even more!!! Holy cow, I don't think my coding is a good example, really. Or at least I'm afraid it is not. I've seen such wonderful Tlist kung-fu in those threads and all the really clever stuff that my code is miles away from. Not to mention that I'm still a bit uncertain about some of the general logic, which may change to something better at some point, I hope, hehe. But it does work, that's true. I've got an update, too, which I will post later. Some little extra thingies. Maybe I even get saving in there.<br><br>I will try to use it in a little game and see how it performs, too. This could be really cool, I think. At least it SHOULD be (supposed to be). :o}<br><br>THANKS GUYS, really, very encouraging! If you have any questions, don't hold back! Might give me a chance to revisit some of my nonsense up there at some point, too, hahaha... :oP <br><br></td></tr></table><br>
<a name="1101757"></a>

<a name="1101759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had a quick look to see how it could be threaded, but it's a bit too complex for me, I think! Still looking though...<br><br>I suppose it's the actual manipulation of the audio data you want to move to another thread, but for what it's worth, it seems the actual <i>playback</i> happens in a separate thread, spawned automatically by OpenAL, <a href="http://stackoverflow.com/questions/6255734/playing-openal-sounds-from-background-thread/6255856#6255856" target="_blank">according to this</a>. Running Task Manager seems to confirm this -- it lists 4 threads for the program, and just under 50% CPU usage; I have 4 cores, so this means two cores are being fully used: the main app busy-loops (that would be showing 25% CPU usage on its own, ie. one core), so I guess the other 25% is OpenAL mixing and playing. (If I comment out the <i>process ()</i> call, I get 20% CPU usage, confirming that the app alone is using almost a full core. (Also, if I comment out all the device setup/OpenAL calls prior to the main loop, it shows only 3 threads, which seems to be normal for a BlitzMax app.)<br><br>BTW I noticed I could add a delay of 5-10 millisecs to the main loop, with no ill effects on the sound here, taking CPU usage right down to 2-10% in general, though I don't know how it would affect other systems.<br><br>Finally, I don't know if you're using the full <a href="http://connect.creativelabs.com/developer/Wiki/OpenAL%20SDK%20for%20Windows.aspx" target="_blank">SDK</a>, but it seems OpenAL actually provides a bunch of effects, so you could possibly avoid a lot of coding in this area; there's an example <a href="http://www.opentk.com/node/714" target="_blank">here</a>.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1101791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, James, that's awesome! Really, thanks for checking all this out!<br>I've seen the EFX extension stuff, but I guess I'll have to add some C to gain access to it. I'll see that I have a look at it for sure.<br><br>I'll do more tomorrow and check into all that.<br><br>Thanks again! <br><br></td></tr></table><br>
<a name="1102098"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just posted a little update, adding a few waveforms to it (saw and square) and some more goodies for editing and performance.<br>Code doesn't get less crazy, but well...<br><br>Page up/down controls octaves<br>+shift controls instrument type (just waveforms currently)<br><br>HOME / END controls note duration <br>+shift controls BPM<br><br>Don't know what all else I've changed, but you'll find it out, I'm sure. :) <br><br></td></tr></table><br>
<a name="1102211"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ian Thompson</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Damnit, won't be be near my BMX pc, till tonight, looking forward to it! <br><br></td></tr></table><br>
<a name="1102412"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ian Thompson</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excellent, it works well, esp. considering there is no assembly language here, which I assumed would be a pre-requisite fir this type of application. Even if you stop now Taron, this has proven to be a considerable insight into the obscure and black art of sound synthesis. <br><br></td></tr></table><br>
<a name="1102418"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> HAHAHA, I still tend to view it that way, too, haha, the black art of sound synthesis. ;D<br><br>I'm currently experimenting with making more buffers at smaller sizes, which seems to improve the feedback a bit. Not sure, if assembler would help in that regard anyway, unless one was to bypass openAL and write an audio-wrapper oneself. No idea, though. It's likely to improve the wave creation part, but bmax is surprisingly sufficient so far.<br><br>Thanks and you're very welcome. I figured it was time to solve that great audio riddle. :) <br><br></td></tr></table><br>
<a name="1106080"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Taron, do you have any experience with openal EFX stuff.<br><br>I'm trying to get any info on how the filters/delays etc can be used in blitz? <br><br></td></tr></table><br>
<a name="1106125"></a>

<a name="1106126"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks like you have to dig through their sdk and implement it yourself. I had a quick look, but didn't care to try hooking it up.<br><br>On a sidenote, I had no idea this was as good as it is before I tried it on a silly little laptop, where the latency appears to be next to nill, it's so quick. On my dumbass mac pro it felt hopeless with the big delay after each keystroke. Now I'm both pleased and freaked out! Have you all had such a great experience with this one, that the sound comes almost immediately with the keystroke and the mouse action on the theremin section?<br><br>Somebody could've told me, hahaha... or so. Anyway, just thought I'd share my joy.<br><br>I also started a new one, which already has a more sophisticated pattern editor and a the beginning of a neat GUI as well as a whole different kind of synthesis. Really promising, but I can't continue right now. :o[<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
