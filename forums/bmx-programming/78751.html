<!DOCTYPE html><html lang="en" ><head ><title >Lua tutorials down or not working?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Lua tutorials down or not working?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Lua tutorials down or not working?</a><br><br>
<a name="883956"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been looking around for how to use Lua in Blitzmax, but every link on these boards I find goes either to a site that is down (or post that is deleted) or a tutorial that seems horribly outdated and the example code won't compile in my blitzmax.<br><br>So, does anybody still have working links to something that works? <br><br></td></tr></table><br>
<a name="884034"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nino</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Below is the .bmx file.  you can get the lua package here:<br><a href="http://www.lua.org/mirrors.html" target="_blank">http://www.lua.org/mirrors.html</a><br><br>I think the latest version is 5.1.3 but this wrapper uses 5.1.2<br>put the bmx file named lua.bmx and the base lua directory (lua-5.1.2) in the mods directory:<br><br>mod/axe.mod/lua.mod<br><br>(sorry - no link to the whole package)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
superstrict

rem
bbdoc: Lua Core
end rem
Module axe.lua

ModuleInfo "Version: 1.24"
ModuleInfo "Author: Tecgraf,PUC-Rio"
ModuleInfo "License: MIT License"
ModuleInfo "Modserver: BRL"
ModuleInfo "Credit: Adapted for BlitzMax by Thomas Mayer, Noel Cower, Andreas Rozek and Simon Armstrong"

ModuleInfo "History: 1.24"
ModuleInfo "History: fixed int&lt;-&gt;long discrepancies between Lua and BlitzMAX"
ModuleInfo "History: 1.23"
ModuleInfo "History: several bugfixes and extensions"
ModuleInfo "History: support for strings with embedded ~0 (and byte arrays)"
ModuleInfo "History: modifications for Lua 5.1.2"
ModuleInfo "History: source code is now 'superstrict'-compliant"
ModuleInfo "History: added some documentation"
ModuleInfo "History: 1.22"
ModuleInfo "History: added lots of definitions to support most of the official Lua 5.1.1 API"
ModuleInfo "History: 1.21"
ModuleInfo "History: removed luac.c from build list"
ModuleInfo "History: 1.20"
ModuleInfo "History: fixed missing paramters in lua_createtable definition"
ModuleInfo "History: 1.19"
ModuleInfo "History: updated with lua5.1.1 source"
ModuleInfo "History: 1.18"
ModuleInfo "History: added extra Imports and luaL_openlibs decl"
ModuleInfo "History: 1.17"
ModuleInfo "History: added luaL_loadstring fixed missing lua_dostring"
ModuleInfo "History: 1.16"
ModuleInfo "History: Added lua_newtable as a BMax function"
ModuleInfo "History: Changed extern'd lua_newtable to lua_createtable"
ModuleInfo "History: Added lua_load, lua_dostring and lua_dobuffer."
ModuleInfo "History: 1.15 Release"
ModuleInfo "History: New LUA 5.1 based build"
ModuleInfo "History: Modified constants and added new wrappers for 5.1 compatability"
ModuleInfo "History: 1.14 Release"
ModuleInfo "History: Added luaopen_debug and ldblib.c"
ModuleInfo "History: Replaced byte ptr with $z (CString) where a C string is expected"
ModuleInfo "History: 1.12 Release"
ModuleInfo "History: Removed lua.h import"

import "lua-5.1.2/src/lstate.c"
import "lua-5.1.2/src/llex.c"
import "lua-5.1.2/src/ltm.c"
import "lua-5.1.2/src/lstring.c"
import "lua-5.1.2/src/ltable.c"
import "lua-5.1.2/src/lfunc.c"
import "lua-5.1.2/src/ldo.c"
import "lua-5.1.2/src/lgc.c"
import "lua-5.1.2/src/lzio.c"
import "lua-5.1.2/src/lobject.c"
import "lua-5.1.2/src/lparser.c"
import "lua-5.1.2/src/lvm.c"
import "lua-5.1.2/src/lundump.c"
import "lua-5.1.2/src/lmem.c"
import "lua-5.1.2/src/lcode.c"
import "lua-5.1.2/src/ldebug.c"
import "lua-5.1.2/src/lopcodes.c"
import "lua-5.1.2/src/lapi.c"
import "lua-5.1.2/src/ldump.c"
import "lua-5.1.2/src/lbaselib.c"
import "lua-5.1.2/src/lauxlib.c"
import "lua-5.1.2/src/liolib.c"
import "lua-5.1.2/src/lmathlib.c"
import "lua-5.1.2/src/lstrlib.c"
import "lua-5.1.2/src/ltablib.c"
import "lua-5.1.2/src/ldblib.c"

import "lua-5.1.2/src/linit.c"
import "lua-5.1.2/src/loadlib.c"
import "lua-5.1.2/src/loslib.c"
'import "lua-5.1.2/src/lua.c"
import "lua-5.1.2/src/luac.c"
import "lua-5.1.2/src/print.c"

import BRL.Retro

' ******************************************************************************
' *                                                                            *
' *                            Constant Definitions                            *
' *                                                                            *
' ******************************************************************************

  const LUA_IDSIZE:int = 60

' **** (lua.h) some basic definitions - just to be complete ****

  const LUA_VERSION:string   = "Lua 5.1"
  const LUA_RELEASE:string   = "Lua 5.1.2"
  const LUA_VERSION_NUM:int  = 501
  const LUA_COPYRIGHT:string = "Copyright (C) 1994-2006 Lua.org, PUC-Rio"
  const LUA_AUTHORS:string   = "R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes"

' **** (lua.h) option for multiple returns in `lua_pcall' and `lua_call' ****

  const LUA_MULTRET:int = -1

' **** (lua.h) pseudo-indices ****

  const LUA_REGISTRYINDEX:int = -10000
  const LUA_ENVIRONINDEX:int  = -10001
  const LUA_GLOBALSINDEX:int  = -10002

' **** (lua.h) thread status (0 is OK) ****

  const LUA_YIELD_:int    = 1   ' added _ after LUA_YIELD because of lua_yield function
  const LUA_ERRRUN:int    = 2
  const LUA_ERRSYNTAX:int = 3
  const LUA_ERRMEM:int    = 4
  const LUA_ERRERR:int    = 5

' **** (lua.h) basic types ****

  const LUA_TNONE:int          = -1
  const LUA_TNIL:int           =  0
  const LUA_TBOOLEAN:int       =  1
  const LUA_TLIGHTUSERDATA:int =  2
  const LUA_TNUMBER:int        =  3
  const LUA_TSTRING:int        =  4
  const LUA_TTABLE:int         =  5
  const LUA_TFUNCTION:int      =  6
  const LUA_TUSERDATA:int      =  7
  const LUA_TTHREAD:int        =  8

' **** (lua.h) garbage-collection options ****

  const LUA_GCSTOP:int       = 0
  const LUA_GCRESTART:int    = 1
  const LUA_GCCOLLECT:int    = 2
  const LUA_GCCOUNT:int      = 3
  const LUA_GCCOUNTB:int     = 4
  const LUA_GCSTEP:int       = 5
  const LUA_GCSETPAUSE:int   = 6
  const LUA_GCSETSTEPMUL:int = 7

' **** (lua.h) event codes ****

  const LUA_HOOKCALL:int    = 0
  const LUA_HOOKRET:int     = 1
  const LUA_HOOKLINE:int    = 2
  const LUA_HOOKCOUNT:int   = 3
  const LUA_HOOKTAILRET:int = 4

' **** (lua.h) event masks ****

  const LUA_MASKCALL:int  = (1 shl LUA_HOOKCALL)
  const LUA_MASKRET:int   = (1 shl LUA_HOOKRET)
  const LUA_MASKLINE:int  = (1 shl LUA_HOOKLINE)
  const LUA_MASKCOUNT:int = (1 shl LUA_HOOKCOUNT)

' ******************************************************************************
' *                                                                            *
' *                          The Lua API (Functions)                           *
' *                                                                            *
' ******************************************************************************

extern
  type lua_Debug
    field event:int
    field name:byte ptr                                         ' no ~0 expected
    field namewhat:byte ptr                                               ' dto.
    field what:byte ptr                                                   ' dto.
    field source:byte ptr                                                 ' dto.
    field currentline:int
    field nups:int
    field linedefined:int
    field lastlinedefined:int
'   field short_src:byte[LUA_IDSIZE]         ' we use padding to occupy 60 bytes
    field short_src:byte, short_src_01:byte, short_src_02:byte, short_src_03:byte
    field short_src_04:long, short_src_12:long, short_src_20:long
    field short_src_28:long, short_src_36:long, short_src_44:long
    field short_src_52:long
    field i_ci:int      ' "private" field - mentioned here to get the right size
  end type
end extern

extern
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_atpanic"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_atpanic:byte ptr (lua_state:byte ptr, panicf:int(ls:byte ptr))
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_call"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_call (lua_state:byte ptr, nargs:int, nresults:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_checkstack"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_checkstack:int (lua_state:byte ptr, extra:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_close"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_close (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_concat"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_concat (lua_state:byte ptr, n:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_cpcall"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_cpcall:int (lua_state:byte ptr, func:int(ls:byte ptr), ud:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_createtable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_createtable (lua_state:byte ptr, narr:int, nrec:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_dump"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_dump:int (lua_state:byte ptr, writer:int(ls:byte ptr,p:byte ptr,sz:int,ud:byte ptr), data:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_equal"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_equal:int (lua_state:byte ptr, index1:int, index2:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_error"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_error:int (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_gc"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_gc:int (lua_state:byte ptr, what:int, data:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getallocf"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getallocf:byte ptr (lua_state:byte ptr, ud:byte ptr ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getfenv"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getfenv (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getfield"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getfield (lua_state:byte ptr, index:int, k$z)              ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_gethook"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_gethook:byte ptr (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_gethookcount"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_gethookcount:int (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_gethookmask"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_gethookmask:int (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getinfo"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getinfo:int (lua_state:byte ptr, what$z, ar:lua_Debug ptr)    ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getlocal"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getlocal$z (lua_state:byte ptr, ar:lua_Debug ptr, n:int)     ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getmetatable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getmetatable:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getstack"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getstack:int (lua_state:byte ptr, level:int, ar:lua_Debug ptr) ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_gettable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_gettable (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_gettop"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_gettop:int (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getupvalue"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getupvalue$z (lua_state:byte ptr, funcindex:int, n:int)        ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_insert"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_insert (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_iscfunction"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_iscfunction:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isnumber"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isnumber:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isstring:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isuserdata"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isuserdata:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_lessthan"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_lessthan:int (lua_state:byte ptr, index1:int, index2:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_load"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_load:int (lua_state:byte ptr, reader:byte ptr(ls:byte ptr,data:byte ptr,sz:int ptr), data:byte ptr, chunkname$z) ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_newstate"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_newstate:byte ptr (f:byte ptr(ud:byte ptr, p:byte ptr, osize:int, nsize:int), ud:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_newthread"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_newthread:byte ptr (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_newuserdata"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_newuserdata:byte ptr (lua_state:byte ptr, size:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_next"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_next:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_objlen"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_objlen:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pcall"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pcall:int (lua_state:byte ptr, nargs:int, nresults:int, errfunc:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushboolean"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushboolean (lua_state:byte ptr, b:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushcclosure"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushcclosure (lua_state:byte ptr, fn:int(ls:byte ptr), n:int)
' function lua_pushfstring$z (lua_state:byte ptr, fmt$z, ...)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushinteger"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushinteger (lua_state:byte ptr, n:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushlightuserdata"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushlightuserdata (lua_state:byte ptr, p:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushlstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushlstring (lua_state:byte ptr, s:byte ptr, size:int)    ' without any conversion!
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushnil"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushnil (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushnumber"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushnumber (lua_state:byte ptr, n:double)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushstring (lua_state:byte ptr, s$z)                         ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushthread"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushthread:int (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushvalue"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushvalue (lua_state:byte ptr, index:int)
' function lua_pushvfstring$z (lua_state:byte ptr, fmt$z, argp:???)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_rawequal"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_rawequal:int (lua_state:byte ptr, index1:int, index2:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_rawget"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_rawget (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_rawgeti"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_rawgeti (lua_state:byte ptr, index:int, n:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_rawset"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_rawset (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_rawseti"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_rawseti (lua_state:byte ptr, index:int, n:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_remove"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_remove (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_replace"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_replace (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_resume"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_resume:int (lua_state:byte ptr, narg:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setallocf"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setallocf (lua_state:byte ptr, f:byte ptr(ud:byte ptr, p:byte ptr, osize:int, nsize:int), ud:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setfenv"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setfenv:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setfield"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setfield (lua_state:byte ptr, index:int, k$z)              ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_sethook"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_sethook:int (lua_state:byte ptr, f(ls:byte ptr,ar:lua_Debug ptr), mask:int, count:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setlocal"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setlocal$z (lua_state:byte ptr, ar:lua_Debug ptr, n:int)     ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setmetatable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setmetatable:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_settable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_settable (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_settop"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_settop (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setupvalue"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setupvalue$z (lua_state:byte ptr, funcindex:int, n:int)        ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_status"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_status:int (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_toboolean"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_toboolean:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_tocfunction"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_tocfunction:byte ptr (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_tointeger"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_tointeger:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_tolstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_tolstring:byte ptr (lua_state:byte ptr, index:int, size:int ptr) ' without any conversion!
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_tonumber"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_tonumber:double (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_topointer"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_topointer:byte ptr (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_tothread"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_tothread:byte ptr (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_touserdata"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_touserdata:byte ptr (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_type"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_type:int (lua_state:byte ptr, index:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_typename"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_typename$z (lua_state:byte ptr, tp:int)                      ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_xmove"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_xmove                (fromState:byte ptr, toState:byte ptr, n:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_yield"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_yield:int (lua_state:byte ptr, nresults:int)
end extern

' ******************************************************************************
' *                                                                            *
' *                            The Lua API (Macros)                            *
' *                                                                            *
' ******************************************************************************

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_getglobal"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_getglobal (lua_state:byte ptr, name:string)
    lua_getfield(lua_state, LUA_GLOBALSINDEX, name)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isboolean"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isboolean:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TBOOLEAN)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isfunction"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isfunction:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TFUNCTION)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_islightuserdata"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_islightuserdata:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TLIGHTUSERDATA)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isnil"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isnil:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TNIL)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isnone"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isnone:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TNONE)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isnoneornil"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isnoneornil:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) &lt;= 0)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_istable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_istable:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TTABLE)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_isthread"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_isthread:int (lua_state:byte ptr, index:int)
    return (lua_type(lua_state,index) = LUA_TTHREAD)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_newtable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_newtable (lua_state:byte ptr)
    lua_createtable(lua_state,0,0)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pop"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pop (lua_state:byte ptr, n:int)
    lua_settop(lua_state,-(n)-1)
  end function

  function lua_pushbytearray (lua_state:byte ptr, Buffer:byte[])
    lua_pushlstring(lua_state, VarPtr Buffer[0], Buffer.length)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_pushcfunction"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_pushcfunction (lua_state:byte ptr, fn:int(ls:byte ptr))
    lua_pushcclosure(lua_state, fn, 0)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_register"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_register (lua_state:byte ptr, name:string, f:int(ls:byte ptr))
    lua_pushcfunction(lua_state, f)
    lua_setglobal    (lua_state, name)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_setglobal"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_setglobal (lua_state:byte ptr, name:string)
    lua_setfield(lua_state, LUA_GLOBALSINDEX, name)
  end function

  function lua_tobytearray:byte[] (lua_state:byte ptr, index:int)
    local Length:int
    local DataPtr:byte ptr = lua_tolstring(lua_state, index, VarPtr Length)
    if (DataPtr = null) then
      return null
    else
      local Result:byte[] = new byte[Length]
        MemCopy(VarPtr Result[0], DataPtr, Length);
      return Result
    end if
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#lua_tostring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function lua_tostring:string (lua_state:byte ptr, index:int)
    local Length:int
    local StringPtr:byte ptr = lua_tolstring(lua_state, index, VarPtr Length)
    if (StringPtr = null) then
      return null
    else
      return String.fromBytes(StringPtr,Length)
    end if
  end function

' ******************************************************************************
' *                                                                            *
' *                     The Auxiliary Library (Functions)                      *
' *                                                                            *
' ******************************************************************************

extern
  type lua_Reg
    field name:byte ptr                                         ' no ~0 expected
    field func:int(ls:byte ptr)
  end type
end extern

extern
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_addlstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_addlstring (B:byte ptr, s:byte ptr, l:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_addsize"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_addsize (B:byte ptr, size:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_addstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_addstring (B:byte ptr, s$z)                                 ' no ~0 allowed!
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_addvalue"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_addvalue (B:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_argerror"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_argerror:int (lua_state:byte ptr, narg:int, extramsg$z)     ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_buffinit"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_buffinit (lua_state:byte ptr, B:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_callmeta"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_callmeta:int (lua_state:byte ptr, obj:int, e$z)             ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checkany"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checkany (lua_state:byte ptr, narg:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checkinteger"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checkinteger:int (lua_state:byte ptr, narg:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checklstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checklstring:byte ptr (lua_state:byte ptr, narg:int, size:int ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checknumber"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checknumber:double (lua_state:byte ptr, narg:int)
' function luaL_checkoption:int (lua_state:byte ptr, narg:int, def$z, lst$z[])
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checkstack"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checkstack (lua_state:byte ptr, sz:int, msg$z)                     ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checktype"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checktype (lua_state:byte ptr, narg:int, t:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checkudata"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checkudata:byte ptr (lua_state:byte ptr, narg:int, tname$z)        ' no ~0 expected
' function luaL_error:int (lua_state:byte ptr, fmt$z, ...)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_getmetafield"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_getmetafield:int (lua_state:byte ptr, obj:int, e$z)                ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_gsub"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_gsub$z (lua_state:byte ptr, s$z, p$z, r$z)                         ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_loadbuffer"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_loadbuffer:int (lua_state:byte ptr, buff:byte ptr, sz:int, name$z) ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_loadfile"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_loadfile:int (lua_state:byte ptr, filename$z)                      ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_loadstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_loadstring:int (lua_state:byte ptr, s$z)                           ' no ~0 allowed!
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_newmetatable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_newmetatable:int (lua_state:byte ptr, tname$z)                     ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_newstate"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_newstate:byte ptr ()
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_openlibs"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_openlibs (lua_state:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_optinteger"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_optinteger:int (lua_state:byte ptr, narg:int, d:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_optlstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_optlstring:byte ptr (lua_state:byte ptr, narg:int, d$z, size:int ptr) ' no ~0 expected in "d"
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_optnumber"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_optnumber:double (lua_state:byte ptr, narg:int, d:double)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_prepbuffer"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_prepbuffer:byte ptr (B:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_pushresult"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_pushresult (B:byte ptr)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_ref"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_ref:int (lua_state:byte ptr, t:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_register"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_register (lua_state:byte ptr, libname$z, l:lua_Reg ptr)            ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_typerror"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_typerror:int (lua_state:byte ptr, narg:int, tname$z)               ' no ~0 expected
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_unref"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_unref (lua_state:byte ptr, t:int, ref:int)
rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_where"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_where (lua_state:byte ptr, lvl:int)
end extern

' ******************************************************************************
' *                                                                            *
' *                       The Auxiliary Library (Macros)                       *
' *                                                                            *
' ******************************************************************************

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_addchar"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_addchar (B:byte ptr, c:string)
    luaL_addstring(B,left$(c,1))     ' not really efficient, just to be complete
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_argcheck"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_argcheck (lua_state:byte ptr, cond:int, narg:int, extramsg:string)
    if (not cond) then luaL_argerror(lua_state, narg, extramsg)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checkint"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checkint:int (lua_state:byte ptr, narg:int)
    return int(luaL_checkinteger(lua_state, narg))   ' Lua itself does the same!
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checklong"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checklong:long (lua_state:byte ptr, narg:int)
    return luaL_checkinteger(lua_state, narg)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_checkstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_checkstring:string (lua_state:byte ptr, narg:int)
    local Size:int
    local StringPtr:byte ptr = luaL_checklstring(lua_state, narg, VarPtr Size)
    if (StringPtr = null) then
      return null
    else
      return String.fromBytes(StringPtr,Size)
    end if
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_dofile"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_dofile:int (lua_state:byte ptr, filename:string)
    if (luaL_loadfile(lua_state,filename) &lt;&gt; 0) then
      return 1
    else
      return lua_pcall(lua_state, 0, LUA_MULTRET, 0)
    end if
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_dostring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_dostring:int (lua_state:byte ptr, str:string)
    if (luaL_loadstring(lua_state,str) &lt;&gt; 0) then
      return 1
    else
      return lua_pcall(lua_state, 0, LUA_MULTRET, 0)
    end if
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_getmetatable"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_getmetatable (lua_state:byte ptr, tname:string)
    lua_getfield(lua_state, LUA_REGISTRYINDEX, tname)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_optint"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_optint:int (lua_state:byte ptr, narg:int, d:int)
    return luaL_optinteger(lua_state, narg, d)
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_optlong"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_optlong:long (lua_state:byte ptr, narg:int, d:long)
    if ((abs(narg) &gt; lua_gettop(lua_state)) or lua_isnil(lua_state,narg)) then
      return d
    else
      return luaL_checklong(lua_state,narg)
    end if
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_optstring"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_optstring:string (lua_state:byte ptr, narg:int, d:string)
    local Size:int
    local StringPtr:byte ptr = luaL_optlstring(lua_state, narg, d, VarPtr Size)
    if (StringPtr = null) then
      return null
    else
      return string.fromBytes(StringPtr,Size)
    end if
  end function

rem
bbdoc: see &lt;a href="../lua-5.1.2/doc/manual.html#luaL_typename"&gt;Lua Reference Manual&lt;/a&gt;
end rem
  function luaL_typename:string (lua_state:byte ptr, idx:int)
    return lua_typename(lua_state, lua_type (lua_state,idx))
  end function

' ******************************************************************************
' *                                                                            *
' *     compatibility extensions (not to break existing axe.lua programs)      *
' *                                                                            *
' ******************************************************************************

extern
  function luaopen_base:int    (lua_state:byte ptr)
  function luaopen_debug:int   (lua_state:byte ptr)
  function luaopen_io:int      (lua_state:byte ptr)
  function luaopen_math:int    (lua_state:byte ptr)
  function luaopen_os:int      (lua_state:byte ptr)
  function luaopen_package:int (lua_state:byte ptr)
  function luaopen_string:int  (lua_state:byte ptr)
  function luaopen_table:int   (lua_state:byte ptr)
end extern

  function lua_dobuffer:int (lua_state:byte ptr, buff:string, sz:int, name:string)
    if (luaL_loadbuffer(lua_state,buff,sz,name) &lt;&gt; 0) then
      return 1
    else
      return lua_pcall(lua_state, 0, LUA_MULTRET, 0)
    end if
  end function

  function lua_dofile:int (lua_state:byte ptr, filename:string)
    return luaL_dofile(lua_state,filename)
  end function

  function lua_dostring:int (lua_state:byte ptr, str:string)
    return luaL_dostring(lua_state,str)
  end function

  function lua_strlen:int (lua_state:byte ptr, index:int)
    return lua_objlen(lua_state,index)
  end function
</textarea> <br><br></td></tr></table><br>
<a name="884036"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nino</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I will post some example code later but make sure you have the propper version.  There was an older wrapper for Lua that was pretty buggy.  It definately works and works well.  I use it for level creation and scripting in almost all of my games. <br><br></td></tr></table><br>
<a name="884044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nino</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> A basic implementation with "hello world"<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Import axe.lua

Type TLua
Global luaState:Byte Ptr
Method New() 
	luaState = luaL_newstate()
	luaL_openlibs(luaState)
EndMethod
Method doScript(source:String) 
	luaL_loadbuffer(luaState, source, source.length, source[0..10])
	Local b:Int = lua_pcall(luaState, 0, 0, 0)
	If b
		'' bad scripts generate errors
		Print("Error - " + lua_tostring(luaState, - 1) )
		lua_pop(luaState, 1)
	EndIf
EndMethod
''table sets a namespace for the function or value (namespace.function)
Method setFunction(name:String , fun(p:Byte Ptr) , table:String = "") 
	If table.length
		lua_getglobal(luaState, table)
		lua_pushstring(luaState, name)
		lua_pushcfunction(luaState, fun)
		lua_settable(luaState, - 3)	
	Else
		lua_register(luaState, name, fun)
	EndIf
EndMethod
Method setValue(key:String , value:Float , table:String = "") 
	If table.length
		lua_getglobal(luaState, table)
		lua_pushstring(luaState, key)
		lua_pushnumber(luaState, value)
		lua_settable(luaState, - 3)	
	Else
		lua_pushstring(luaState, key)
		lua_pushnumber(luaState, value)
		lua_settable(luaState , LUA_GLOBALSINDEX) 
	EndIf
EndMethod
EndType

'' lua function always takes 1 argument - a pointer to the lua state
Function _echo(p: Byte Ptr) 
	Local msg:String = lua_tostring(p, 1)
	If String(msg)
		Print(msg)
	Else
		Print(lua_tonumber(p, 1) )
	EndIf
EndFunction


Global Lua:TLua = New TLua
Lua.setFunction("echo", _echo) 
Lua.setValue("n", 10) 
Lua.doScript("echo('You are using '..tostring(_VERSION))") 
Lua.doScript("for i=0,n do echo(string.sub('hello world',0,i+1)) end") 
</textarea> <br><br></td></tr></table><br>
<a name="884436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, thank you. Just what I needed. I will try this tomorrow. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
