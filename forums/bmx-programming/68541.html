<!DOCTYPE html><html lang="en" ><head ><title >Blitzmax MIDI IN</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Blitzmax MIDI IN</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Blitzmax MIDI IN</a><br><br>
<a name="765895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JRBCM</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone know of a way of achieving MIDI IN in blitzmax? I've read the old postings which seem never to have got anywhere, and the FMOD stuff, but no MIDI IN. Anyone planning on doing MIDI stuff for Blitzmax??? <br><br></td></tr></table><br>
<a name="765964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blueapples</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is an interesting idea actually. I am getting more into the MIDI controller scene... never even thought to really write anything for it. A ReWire header would be really cool too... <br><br></td></tr></table><br>
<a name="766028"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Use portmidi it works! I have a C wrapper for BlitzMax and If I am able to find some time I will post it. <br><br></td></tr></table><br>
<a name="766031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> There was an attempt by Nigel Brown with portMidi, not sure if he succeeded.<br><br>EDIT : well it seems so! Just a tad faster than me at posting. <br><br></td></tr></table><br>
<a name="766922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Garfield</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> If I have more time I would like to help<br><br>I guess, a professionell way is to integrate the Max/MSP Language into BMAX  <br>maybe its possible and then the whole world of MIDI AUDIO and Video is open for BMAX PRogrammers<br><br><a href="http://www.cycling74.com/" target="_blank">http://www.cycling74.com/</a> <br><br></td></tr></table><br>
<a name="767190"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> max/msp isn't language. Second it's closed source, so no hope to "integrate" it. But you can have max/msp and a program compiled in blitzmax talking, through midi, tcp/ip or osc (this one you would have to code it from scratch).<br><br>If you are considering making an osc library for blitzmax, I am in. <br><br></td></tr></table><br>
<a name="767371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ziltch</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> What level of midi-in do you need?<br><br>I have a simple midi in/out mod working. I use it for controller reading/setting.<br>It does not do sysex dumps and other more tricky stuff.<br><br>I am busy at the moment , but if my arm is twisted I could write a demo and make the module public. <br><br></td></tr></table><br>
<a name="767454"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok a quick hack, hope this helps. Really needs someone to make this into a module Brucey?<br><br>Download portmidi28aug06 and place it inside your project.<br><br>main.bmx<br><pre class=code>
Strict

Import "portmidi28aug06/porttime/*.h"
Import "portmidi28aug06/porttime/porttime.c"

Import "portmidi28aug06/pm_common/*.h"
Import "portmidi28aug06/pm_common/portmidi.c"


?Win32

	Import "portmidi28aug06/porttime/ptwinmm.c"

	Import "portmidi28aug06/pm_win/*.h"
	Import "portmidi28aug06/pm_win/pmwin.c"
	Import "portmidi28aug06/pm_win/pmdll.c"
	Import "portmidi28aug06/pm_win/pmwinmm.c"

	Import "sysex.cpp"

Framework		brl.d3d7max2d

?MacOS
?Linux
?

Extern "C"		' sysex.cpp

	Global	OutputDevice:Int
	Global	InputDevice:Int
	Global	LoopbackInputDevice:Int
	Global	LoopbackOutputDevice:Int

	Global	midi_message:Byte[]

	Function 	midi_open:Int()
	Function 	midi_close:Int()
	Function 	midi_test:Byte Ptr()

	Function 	loopback_open:Int()
	Function 	loopback_close:Int()
	Function 	loopback_test:Int()

	Function 	get_midi_in()
	Function 	get_midi_out()

	Function 	sysex_receive_open:Int()
	Function 	sysex_receive_get:Byte Ptr()
	Function 	sysex_receive_close:Int()

	Function 	sysex_send( message:Byte Ptr )
	Function 	sysex_send_receive:Byte Ptr( message:Byte Ptr )

	Function 	sysex_initalise()
	Function 	sysex_set_device:Int( device:Byte Ptr, dir:Int )
	Function 	sysex_get_next_device:String( nxt:Int, dir:Int )
	Function 	sysex_get_number_of_devices:Int()

	Function 	sysex_finalise()

End Extern

Global device_enquiry:Byte[]=[ Byte($F0),Byte($7E),Byte($00),Byte($06),Byte($01),Byte($F7) ]

	sysex_initalise()
	Delay(1000)

	' List input / output devices
	For Local i:Int=0 To sysex_get_number_of_devices()-1
	
		If sysex_get_next_device(i,True) = ""
		Else
			DebugLog "Output Device [" + i + "] = " + sysex_get_next_device(i,True)
		EndIf
	
		If sysex_get_next_device(i,False) = ""
		Else
			DebugLog "Input Device [" + i + "] = " + sysex_get_next_device(i,False)
		EndIf
		
	Next

	' Change these to correct values for your setup.
	InputDevice = 2
	OutputDevice = 5

    '
    If sysex_get_next_device( InputDevice , False ) = ""
        If Not Confirm( "No compatible MIDI input device selected, Continue?", True )
            Return False
        EndIf
    EndIf

    '
    If sysex_get_next_device( OutputDevice, True ) = ""
        If Not Confirm( "No compatible MIDI output device selected, Continue?", True )
            Return False
        EndIf
    EndIf


    Global bp:Byte Ptr

    bp = sysex_send_receive(device_enquiry)

	'
	For Local i:Int=0 To 4
		DebugLog "bp[i] = " + bp[i]
	Next
	'
    If bp[0]=$F0 And bp[1]=$7E And bp[2]=$00 And bp[3]=$06 And bp[4]=$02	' Valid responce to device enquiry?
		'
		Notify( "Correct responce from device enquiry" )

    Else
		'
        Notify( "Invalid response from DeviceEnquiry(), Retry?", False )
    EndIf


sysex_finalise()

End
</pre><br><br>sysex.cpp<br><pre class=code>
#include "stdio.h"
#include "stdlib.h"
#include "assert.h"
#include "string.h"

#include "portmidi28aug06/pm_common/portmidi.h"
#include "portmidi28aug06/porttime/porttime.h"

extern "C" {

#define MIDI_SYSEX 0xf0
#define MIDI_EOX 0xf7

#define STRING_MAX 80
#define MIDI_MESSAGE_SIZE 1024

#define is_real_time_msg(msg) ((0xF0 &amp; Pm_MessageStatus(msg)) == 0xF8)

int InputDevice;
int OutputDevice;

int	 LoopbackInputDevice;
int	 LoopbackOutputDevice;

unsigned char midi_message[MIDI_MESSAGE_SIZE];

#define INPUT_BUFFER_SIZE 100
#define OUTPUT_BUFFER_SIZE 0
#define DRIVER_INFO NULL
#define TIME_PROC ((long (*)(void *)) Pt_Time)
#define TIME_INFO NULL
#define TIME_START Pt_Start(1, 0, 0) /* timer started w/millisecond accuracy */

PmStream *midiIn = NULL; 
PmStream *midiOut = NULL;


//char dummy[256];

PmStream *midi_in_stream;

// ----------------------------------------------------------
// Reset the message buffer
// ----------------------------------------------------------
void	reset_message( void )
// ----------------------------------------------------------
{
//return;

int		i;

	for ( i=0; i&lt;MIDI_MESSAGE_SIZE; i++ ) {
		midi_message[i] = 0;
	}
}

// ----------------------------------------------------------
// Open the MIDI ports
// ----------------------------------------------------------
bool midi_open( void )
// ----------------------------------------------------------
{
//return true;

	//
	Pm_OpenInput( &amp;midi_in_stream, InputDevice, DRIVER_INFO, INPUT_BUFFER_SIZE, TIME_PROC, TIME_INFO );

	//
	if ( midi_in_stream != NULL ) {
		return true;
	}

	return false;	
}


// ----------------------------------------------------------
// Close the MIDI ports
// ----------------------------------------------------------
bool midi_close( void )
// ----------------------------------------------------------
{
//return true;
		
	//
	if ( midi_in_stream != NULL) {
		Pm_Close(midi_in_stream);
		midi_in_stream = NULL;			
		return true;
	} else {
		return false;
	}
}


// ----------------------------------------------------------
// Read a short message
// ----------------------------------------------------------
signed char *midi_test( void )
// ----------------------------------------------------------
{
//return true;

	PmEvent buffer[1];
	PmError status, length;

	//
	status = Pm_Poll( midi_in_stream );
	if ( status == true ) {

		reset_message();

		length = Pm_Read( midi_in_stream, buffer, 1 );
		if ( length &gt; 0 ) {

			midi_message[0] = Pm_MessageStatus( buffer[0].message );
			midi_message[1] = Pm_MessageData1( buffer[0].message );			
			midi_message[2] = Pm_MessageData2( buffer[0].message );
			
//			printf("Got message: time %ld, %2lx %2lx %2lx\n",
	//					buffer[0].timestamp,
		//				midi_message[0] = Pm_MessageStatus( buffer[0].message ),
			//			Pm_MessageData1( buffer[0].message ),
				//		Pm_MessageData2( buffer[0].message ));

//			if ( Pm_MessageData1( buffer[0].message ) == 31 &amp;&amp; Pm_MessageData2(buffer[0].message ) == 64 ) return true;			

			return (signed char *)midi_message;
		}
	}

	return NULL;
}


// ----------------------------------------------------------
// Open the MIDI loopback ports
// ----------------------------------------------------------
bool loopback_open()
// ----------------------------------------------------------
{
//return true;

	//
	Pm_OpenOutput( &amp;midiOut, LoopbackOutputDevice, DRIVER_INFO, OUTPUT_BUFFER_SIZE, NULL, NULL, 0 );

	//
	Pm_OpenInput( &amp;midiIn, LoopbackInputDevice, DRIVER_INFO, INPUT_BUFFER_SIZE, TIME_PROC, TIME_INFO );

	//
	if ( ( midiOut != NULL ) &amp;&amp; ( midiIn != NULL ) ) {

		//
//		Pm_SetFilter( midiIn, PM_FILT_ACTIVE | PM_FILT_CLOCK );

	   // empty the buffer after setting filter, just in case anything got through.
//	    while (Pm_Poll(midiIn)) {
//	        Pm_Read( midiIn, buffer, 1 );
//	    }

		return true;
	}

	return false;	
}


// ----------------------------------------------------------
// Close the MIDI loopback ports
// ----------------------------------------------------------
bool loopback_close()
// ----------------------------------------------------------
{
//return true;

	//	
	if ( midiOut != NULL ) {
		Pm_Close(midiOut);
		midiOut = NULL;
		
		if ( midiIn != NULL) {
			Pm_Close(midiIn);
			midiIn = NULL;
			
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}


// ----------------------------------------------------------
// Write a short message then poll for a returned message
// ----------------------------------------------------------
bool loopback_test()
// ----------------------------------------------------------
{
//return true;

	PmEvent buffer[1];
	PmError status, length;

	// Note on
	Pm_WriteShort( midiOut, TIME_PROC(TIME_INFO), Pm_Message(0x90, 31, 64) );

	// Note off
//	Pm_WriteShort( midiOut, TIME_PROC(TIME_INFO), Pm_Message(0x80, 31, 40) );

//	buffer[0].timestamp = TIME_PROC(TIME_INFO);
//	buffer[0].message = Pm_Message(0x90,31,64);
//	Pm_Write( midiOut, buffer, 1);

	//
	status = Pm_Poll( midiIn );
	if ( status == true ) {

		length = Pm_Read( midiIn, buffer, 1 );
		if (length &gt; 0) {

//			printf("Got message: time %ld, %2lx %2lx %2lx\n",
//						buffer[0].timestamp,
//						Pm_MessageStatus( buffer[0].message ),
//						Pm_MessageData1( buffer[0].message ),
//						Pm_MessageData2( buffer[0].message ));

			if ( Pm_MessageData1( buffer[0].message ) == 31 &amp;&amp; Pm_MessageData2(buffer[0].message ) == 64 ) return true;			
		}
	}

	return false;
}


// ----------------------------------------------------------
// ----------------------------------------------------------
int		get_midi_in( void )
// ----------------------------------------------------------
{
//return true;

return InputDevice;
}


// ----------------------------------------------------------
// ----------------------------------------------------------
int		get_midi_out( void )
// ----------------------------------------------------------
{
//return true;

return OutputDevice;
}


// ----------------------------------------------------------
// ----------------------------------------------------------
void send_sysex( unsigned char *sysex_data ) 
// ----------------------------------------------------------
{
//return;

	PmStream *midi_out;
	
	//
	Pm_OpenOutput( &amp;midi_out, OutputDevice, DRIVER_INFO, OUTPUT_BUFFER_SIZE, NULL, NULL, 0 );

	if ( midi_out != NULL ) {

		Pm_WriteSysEx( midi_out, 0, sysex_data );
		Pm_Close( midi_out );
		midi_out = NULL;
	}
}


// ----------------------------------------------------------
void receive_sysex( PmStream *midi )
// ----------------------------------------------------------
{
//return;

	int shift = 0;
	unsigned char data = 0;
	int bytes_on_line = 0;
	PmEvent msg;
	PmError count;

	// read data and write to file
	while ( data != MIDI_EOX ) {
		
		count = Pm_Read(midi, &amp;msg, 1);
			
		// CAUTION: this causes busy waiting. It would be better to 
		// be in a polling loop to avoid being compute bound. PortMidi
		// does not support a blocking read since this is so seldom useful.
		
		if (count == 0) continue;
		
		// ignore real-time messages
		if (is_real_time_msg(Pm_MessageStatus(msg.message))) continue;

		// write 4 bytes of data until you reach an eox
		bool done = 0;
		for ( shift = 0; (shift &lt; 32) &amp;&amp; !done /*(data != MIDI_EOX)*/; shift += 8) {
			data = (msg.message &gt;&gt; shift) &amp; 0xFF;
			
			// if this is a status byte that's not MIDI_EOX, the sysex
			// message is incomplete and there is no more sysex data
			
			midi_message[ bytes_on_line ] = data;
			++bytes_on_line;
			
			done = ( data == MIDI_EOX );
		}
	}
}


// ----------------------------------------------------------
unsigned char *sysex_send_receive( unsigned char *sysex_data ) 
// ----------------------------------------------------------
{
//return;

	PmStream *midi_in;
	PmStream *midi_out;

	Pm_OpenInput( &amp;midi_in, InputDevice, DRIVER_INFO, INPUT_BUFFER_SIZE, NULL, NULL);
	Pm_OpenOutput( &amp;midi_out, OutputDevice, DRIVER_INFO, OUTPUT_BUFFER_SIZE, NULL, NULL, 0);

	if ( midi_out != NULL ) {

		Pm_WriteSysEx( midi_out, 0, sysex_data );

		if ( midi_in != NULL) {
			reset_message();
			receive_sysex( midi_in );
			Pm_Close(midi_in);
			midi_in = NULL;
		}

		Pm_Close(midi_out);
		midi_out = NULL;
	}
	
	return midi_message;
}


// ----------------------------------------------------------
void sysex_send( unsigned char *message )
// ----------------------------------------------------------
{
//return;
int i;

	PmStream *midi_in;
	PmStream *midi_out;

//	fprintf( stderr, "opening output\n" );

	Pm_OpenOutput( &amp;midi_out, OutputDevice, DRIVER_INFO, OUTPUT_BUFFER_SIZE, NULL, NULL, 0 );

//	fprintf( stderr, "opened output\n" );


	if ( midi_out != NULL ) {
	
		//
		Pm_WriteSysEx( midi_out, 0, message );
		
//		for( i=0; ( message[i] != MIDI_EOX ); i++ ) {
//			fprintf( stderr, "message[%d] = %.2x\n", i, message[i] );
//		}


		Pm_Close(midi_out);
		midi_out = NULL;

//		fprintf( stderr, "closed output\n" );
	}
	else {
	
		fprintf( stderr, "midi_out == NULL\n" );
	}
}


PmStream *midi_in = NULL;

// ----------------------------------------------------------
bool sysex_receive_open( void ) 
// ----------------------------------------------------------
{
//return true;

	Pm_OpenInput( &amp;midi_in, InputDevice, NULL, 512, NULL, NULL );

	if ( midi_in != NULL) {
		return true;
	}

	return false;	
}


// ----------------------------------------------------------
unsigned char *sysex_receive_get( void ) 
// ----------------------------------------------------------
{
//return dummy;

	if ( midi_in != NULL) {

		if ( Pm_Poll( midi_in ) &gt; 0 ) {
			reset_message();
			receive_sysex( midi_in );
			return midi_message;
		} else {
			return NULL;
		}
	} else {
		return NULL;
	}
}


// ----------------------------------------------------------
bool sysex_receive_close( void ) 
// ----------------------------------------------------------
{
//return true;

	if ( midi_in != NULL) {
		Pm_Close(midi_in);
		midi_in = NULL;
		return true;
	}
	return false;
}


#if 0
// ----------------------------------------------------------
char *sysex_send_receive( unsigned char *message )
// ----------------------------------------------------------
{
//return dummy;

	reset_message();

	send_receive_sysex( message );

	return midi_message;
}
#endif


// ----------------------------------------------------------
void	sysex_initalise( void )
// ----------------------------------------------------------
{
//return;

	int i;

	//
	Pm_Initialize();
	
#if 0	

	// list device information
	for (i = 0; i &lt; Pm_CountDevices(); i++) {

        const PmDeviceInfo *info = Pm_GetDeviceInfo(i);

        printf("%d: %s, %s", i, info-&gt;interf, info-&gt;name);
        if (info-&gt;input) printf(" (input)");
        if (info-&gt;output) printf(" (output)");
        printf("\n");

		if ( ( strcmp( info-&gt;name, "USB Audio Device" ) == 0 ) &amp;&amp; info-&gt;output ) {
			printf( "found output device %d\n", i );
			OutputDevice = i;
		}

		if ( ( strcmp( info-&gt;name, "USB Audio Device" ) == 0 ) &amp;&amp; info-&gt;input ) {
			printf( "found input device @ %d\n", i );
			InputDevice = i;
		}


		if ( ( strcmp( info-&gt;name, "USB Audio Device [3]" ) == 0 ) &amp;&amp; info-&gt;input ) {
			printf( "found intput loopback device @ %d\n", i );
			LoopbackInputDevice = i;
		}
	
		if ( ( strcmp( info-&gt;name, "USB Audio Device [2]" ) == 0 ) &amp;&amp; info-&gt;output ) {
			printf( "found output loopback device @ %d\n", i );
			LoopbackOutputDevice = i;
		}		
	}

#endif

	//
	reset_message();
}


// ----------------------------------------------------------
int		sysex_set_device( char *select, int dir )
// ----------------------------------------------------------
{
	int i;

	// list device information
	for (i = 0; i &lt; Pm_CountDevices(); i++) {
	
		const PmDeviceInfo *info = Pm_GetDeviceInfo(i);
		
//		printf("%d: %s, %s", i, info-&gt;interf, info-&gt;name);
//		if (info-&gt;input) printf(" (input)");
//		if (info-&gt;output) printf(" (output)");
//		printf("\n");

		if ( dir == true ) {
			if ( ( strcmp( info-&gt;name, select ) == 0 ) &amp;&amp; info-&gt;output ) {
				return i;
			}
		} else {
			if ( ( strcmp( info-&gt;name, select ) == 0 ) &amp;&amp; info-&gt;input ) {
				return i;
			}
		}
	}
	return -1;
}


#include &lt;brl.mod/blitz.mod/blitz_string.h&gt;

// ----------------------------------------------------------
BBString *sysex_get_next_device( int nxt, int dir )
// ----------------------------------------------------------
{	
	const PmDeviceInfo *info = Pm_GetDeviceInfo( nxt );
	
//	printf( "pointer = %p", info );		
//	printf("%d: %s, %s", nxt, info-&gt;interf, info-&gt;name);
//	if (info-&gt;input) printf(" (input)");
//	if (info-&gt;output) printf(" (output)");
//	printf("\n");

	if ( info != NULL ) {

		if ( (dir == true) &amp;&amp; info-&gt;output ) {
			return bbStringFromCString(info-&gt;name);
		}
	
		if ( (dir == false) &amp;&amp; info-&gt;input ) {
			return bbStringFromCString(info-&gt;name);
		}
	}

	return bbStringFromCString("");
}


// ----------------------------------------------------------
int sysex_get_device_dir( int nxt )
// ----------------------------------------------------------
{	
int dir = 0;

	const PmDeviceInfo *info = Pm_GetDeviceInfo( nxt );

	if ( info != NULL ) {

		if ( info-&gt;output ) dir |= 1;
		if ( info-&gt;input ) dir |= 2;
		return dir;
	}
}


// ----------------------------------------------------------
int sysex_get_number_of_devices( void ) {
// ----------------------------------------------------------
	return Pm_CountDevices();
}


// ----------------------------------------------------------
void	sysex_finalise( void )
// ----------------------------------------------------------
{
//return;

	Pm_Terminate();
}

} // extern "C" }

</pre> <br><br></td></tr></table><br>
<a name="769401"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JRBCM</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow - thanks so much for that Nigel- soon as I get a minute (ie. never!) I'm gonna get stuck right in to it. I'm a Blitzmax newbie but very familiar with MIDI, being a musician. <br><br>Answer to Zilch: I don't need sysex or MIDI controller stuff for my project, I just need simple note on/off, velocity and pedal data (I'm aiming for Mac and PC versions). <br><br></td></tr></table><br>
<a name="770398"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ziltch</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would go with nigels method then. As my mod only handles windows. <br><br></td></tr></table><br>
<a name="770872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello,<br><br>In sysex_initialise there is a typo (you'll have to choose in between "sysex_initialise" or "sysex_initalise" without "i".<br><br>After that, I have an error building main.bmx...<br><br>Building main<br>Compiling:porttime.c<br>Compiling:portmidi.c<br>Compiling:ptwinmm.c<br>Compiling:pmwin.c<br>Compiling:pmdll.c<br>Compiling:pmwinmm.c<br>Compiling:sysex.cpp<br>Compiling:main.bmx<br>flat assembler  version 1.66<br>3 passes, 3348 bytes.<br>Linking:main.exe<br>C:/Documents and Settings/jerome/Desktop/portmidi28aug06/portmidi28aug06/pm_win/.bmx/pmdll.c.release.win32.x86.o(.text+0x24):pmdll.c: multiple definition of `DllMain@12'<br>C:/Program Files/BlitzMax/mod/brl.mod/appstub.mod/appstub.release.win32.x86.a(appstub.win32.c.release.win32.x86.o)(.text+0x172):appstub.win32.c: first defined here<br>Build Error: Failed to link C:/Documents and Settings/jerome/Desktop/portmidi28aug06/main.exe<br>Process complete <br><br></td></tr></table><br>
<a name="771543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> any body succeeded in compiling this under windows? <br><br></td></tr></table><br>
<a name="772031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Try renaming the DllMain() in \portmidi28aug06\pm_win\pmdll.c to DllMain2()<br><br>And using the edited code main.bmx above. This now compiles on my dev system. <br><br></td></tr></table><br>
<a name="772305"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Nigel it compiles. However it fails capturing any Midi in messages and even worst it doesn't close *always* cleanly. I looked at portmidi readme and I tried the #define USE_DLL_FOR_CLEANUP as recommended for windows. <br><br>The above example "main.bmx" fails silently on sysex_send_receive. The device detection is working(and I edited input/output device numbers) but I can't get anything working further than that.<br><br>I will continue messing up with it... <br><br></td></tr></table><br>
<a name="773606"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could you indicate me how to open a port, and print the incoming messages? I am a bit confused by the wrapped functions... From there I should be able to test it completely.<br><br>Thanks <br><br></td></tr></table><br>
<a name="773799"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have uploaded the whole folder including the port MIDI I am using to:<br><br><a href="http://www.nigelibrown.pwp.blueyonder.co.uk/blitz/userlibs/index.htm" target="_blank">http://www.nigelibrown.pwp.blueyonder.co.uk/blitz/userlibs/index.htm</a><br><br>If you just want to deal exclusivley with MIDI messages then try opening - reading and then closing with something like this:<br><br><pre class=code>
Strict

Import "portmidi28aug06/porttime/*.h"
Import "portmidi28aug06/porttime/porttime.c"

Import "portmidi28aug06/pm_common/*.h"
Import "portmidi28aug06/pm_common/portmidi.c"


?Win32

	Import "portmidi28aug06/porttime/ptwinmm.c"

	Import "portmidi28aug06/pm_win/*.h"
	Import "portmidi28aug06/pm_win/pmwin.c"
	Import "portmidi28aug06/pm_win/pmdll.c"
	Import "portmidi28aug06/pm_win/pmwinmm.c"

	Import "sysex.cpp"

Framework		brl.d3d7max2d

?MacOS
?Linux
?

Extern "C"		' sysex.cpp

	Global	OutputDevice:Int
	Global	InputDevice:Int
	Global	LoopbackInputDevice:Int
	Global	LoopbackOutputDevice:Int

	Global	midi_message:Byte[]

	Function 	midi_open:Int()
	Function 	midi_close:Int()
	Function 	midi_test:Byte Ptr()

	Function 	loopback_open:Int()
	Function 	loopback_close:Int()
	Function 	loopback_test:Int()

	Function 	get_midi_in()
	Function 	get_midi_out()

	Function 	sysex_receive_open:Int()
	Function 	sysex_receive_get:Byte Ptr()
	Function 	sysex_receive_close:Int()

	Function 	sysex_send( message:Byte Ptr )
	Function 	sysex_send_receive:Byte Ptr( message:Byte Ptr )

	Function 	sysex_initalise()
	Function 	sysex_set_device:Int( device:Byte Ptr, dir:Int )
	Function 	sysex_get_next_device:String( nxt:Int, dir:Int )
	Function 	sysex_get_number_of_devices:Int()

	Function 	sysex_finalise()

End Extern

	sysex_initalise()
	Delay(5000)

	' List input / output devices
	For Local i:Int=0 To sysex_get_number_of_devices()-1
	
		If sysex_get_next_device(i,True) = ""
		Else
			DebugLog "Output Device [" + i + "] = " + sysex_get_next_device(i,True)
		EndIf
	
		If sysex_get_next_device(i,False) = ""
		Else
			DebugLog "Input Device [" + i + "] = " + sysex_get_next_device(i,False)
		EndIf
		
	Next

	' Change these to correct values for your setup.
	InputDevice = 2
	OutputDevice = 5

    '
    If sysex_get_next_device( InputDevice , False ) = ""
        If Not Confirm( "No compatible MIDI input device selected, Continue?", True )
            Return False
        EndIf
    EndIf

    '
    If sysex_get_next_device( OutputDevice, True ) = ""
        If Not Confirm( "No compatible MIDI output device selected, Continue?", True )
            Return False
        EndIf
    EndIf


	Global bp:Byte Ptr

	midi_open()

	Repeat
	
		bp = midi_test()

		If bp &lt;&gt; Null
			DebugLog "status = " + bp[0]
			DebugLog "data1 = " + bp[1]
			DebugLog "data2 = " + bp[2]
			DebugLog ""
		EndIf
	
	Until KeyDown(KEY_ESCAPE)
	
	midi_close()
	

sysex_finalise()

End


</pre> <br><br></td></tr></table><br>
<a name="773923"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Nigel, with the wrapped version downloaded on your website it works. It still doesn't close correctly all the time, but this could be my setup. <br><br></td></tr></table><br>
<a name="774139"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> If I ever get enough time I will wrap this as a BMax module. And do things a little more elegantly.<br><br>If you need it to do more please let me know, when you say "It still doesn't close correctly all the time" can you be a little more specific so I can try and emulate the same problem here? <br><br></td></tr></table><br>
<a name="774199"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well the problem occurs, when compiling the MIDI.bmx example, closing it pressing escape key, then one minute or 2 latter, recompiling it, it reports than midi.exe or midi.debug.exe is currently in use (so not closed properly although the exe doesn't appear in task manager anymore). It does it but not *always*, I tried a delay before closing bmx program (similar to the one after sysex_initialize), but it still happens "randomly".<br><br>My test system is WinXP pro, with a MAudio midisport Uno USB (input 1, output 4 in my setup) and a doepfer pocketdial (I have a Kaoss pad II, and a pocketfader as well but not wired currently).<br><br>I want to support Midi controllers principally (on the 3 platforms, from there comes my interest for portmidi), but some of them require midi feedback/ouput (to update a display or a motorized fader for example).<br><br>With Blitz3d I did a midichannel based dll (not based on devices), reading/writing midi messages only (the 3 nibbles). <br><br></td></tr></table><br>
<a name="774205"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If I ever get enough time I will wrap this as a BMax module. <br></div><br>If I had anything remotely Midi I could test this with, I would have been happy to help with that... <br><br></td></tr></table><br>
<a name="774220"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I did my Blitz3D dll without Midi Hardware, I was using this software midi controller : <a href="http://www.analogx.com/contents/download/audio/mousemod.htm" target="_blank">http://www.analogx.com/contents/download/audio/mousemod.htm</a> and the virtual piano controller (on the same website) along with Midi-Ox and Midi-Yoke <a href="http://www.midiox.com/" target="_blank">http://www.midiox.com/</a><br><br>I suppose similar soft-midi exist for Linux and MacOS. <br><br></td></tr></table><br>
<a name="781981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> LAB[au]<br><br>Take a look at BAH modules. Brucey now has a portmidi module available. I will answer any questions that I am able to. <br><br></td></tr></table><br>
<a name="781993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >LAB[au]</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah! It works perfect (didn't tried sysex yet). <br><br></td></tr></table><br>
<a name="814257"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eindbaas</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd like to use Brucey's portmidi package, and it seems to work (just started, but it did find all my midi-devices) but i think i'm having the same prob as Lab[au] described earlier.<br><br>Whenever i open a midi-device ( midi.openInput(devicenum) ) the program doesn't want to close anymore. The code after the openInput (which is opening a graphics window and do a while-wend loop on not pressing escape) does run (the window is opened), but pressing escape doesn't do anything. I see the process in my TaskManager, but i cant kill it (the prg-window disappears but the exe stays in the taskmanager-&gt;processes). <br><br>It does kill itself after about 5 minutes, but that's a long wait to be able to recompile my prg :(<br><br>Does anybody have some info or hints on this? <br><br></td></tr></table><br>
<a name="814264"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >eindbaas</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Found out that the running process will shut down only if i turn off my (external) midi-interface (or wait 5 minutes). Tried that with 2 different midi-interfaces, and the same thing happens. <br><br></td></tr></table><br>
<a name="815013"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nigel Brown</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Example code please, and I will have a look. Here are some ideas you should try.<br><br>in \portmidi28aug06\pm_win\pmwin.dll make sure that the line #define USE_DLL_FOR_CLEANUP is not commented out.<br><br>in your source include:<br>Import 		"portmidi28aug06/pm_win/pmdll.c"<br><br>and make sure you have the pmdll.dll inside your project folder. <br><br></td></tr></table><br>
<a name="1270406"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rendomizer</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Where can i found portmidi28aug06 ? need help <br><br></td></tr></table><br>
<a name="1270427"></a>

<a name="1270428"></a>

<a name="1270430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Brucey has a zip version here: <a href="http://brucey.net/programming/blitz/#bahportmidi" target="_blank">http://brucey.net/programming/blitz/#bahportmidi</a><br>It seems he has no svn or git version though.<br><br>Edit: wx.mod has a portmidi wrapper here: <a href="https://github.com/maxmods/wx.mod/tree/master/wxmidi.mod" target="_blank">https://github.com/maxmods/wx.mod/tree/master/wxmidi.mod</a> <br><br></td></tr></table><br>
<a name="1270436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I highly recommend rtMidi instead.<br><br>It is available here (rtmidi.mod) : <a href="https://github.com/maxmods/bah.mod" target="_blank">https://github.com/maxmods/bah.mod</a> <br><br></td></tr></table><br>
<a name="1341917"></a>

<a name="1341918"></a>

<a name="1341923"></a>

<a name="1341925"></a>

<a name="1341926"></a>

<a name="1341927"></a>

<a name="1341928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> This peace of Crap Github is not allowing you to download a sub directory..<br>instead it forces you to download the whole Bah.mod.<br>what the hell is wrong in this world? <br><br></td></tr></table><br>
<a name="1341933"></a>

<a name="1341935"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> why do i get this Compile Error: Can't find interface for module 'bah.rtmidi'<br><br><br>I put the bah.mod on the blitzmax mod and than tried to update modules <br>but still i get this error<br><br>i installed that silly mingw.. i think i did everything but yet it aint working and i get Error<br><br>Compile Error: Can't find interface for module 'bah.rtmidi'<br>Build Error: failed to compile D:/Portable/BlitzMax/mod/bah.mod/rtmidi.mod/examples/midi_in.bmx <br><br></td></tr></table><br>
<a name="1341963"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >markcw</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can see you're not in the best of moods today Hardcoal. Never mind, it is possible to download a subdirectory from github but you have to use the command line and you need SVN installed. The trick is to replace "tree/master" with "trunk" like so:<br><pre class=code>svn checkout <a href="https://github.com/maxmods/bah.mod/trunk/rtmidi.mod" target="_blank">https://github.com/maxmods/bah.mod/trunk/rtmidi.mod</a> C:/myfolder</pre> ...<br><br>"Can't find interface for module" means it probably hasn't been built. <br>You can try deleting the .bmx folder (to remove .i files) and then rebuild modules or like I prefer use the command line "bmk makemods -a bah.rtmidi". <br>If this doesn't work then your setup of MinGW may not be installed properly, so you could follow my guide <a href="/posts.php?topic=105834" target="_blank">HERE</a>. <br><br></td></tr></table><br>
<a name="1341968"></a>

<a name="1341969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Hardcoal</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> You are so right mark.. I feel rather awful today.. (various reasons..)<br>I really value you sensitivity and noticing of my feelings..<br><br>I greet you advices and I will try them on.<br><br>Many thanks to you Mark and Also Rick Nasher for cheering me up.<br><br>Ill try it later.. Im too tired right now <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
