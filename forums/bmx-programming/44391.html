<!DOCTYPE html><html lang="en" ><head ><title >2D Collision, Physics, Rigid body dynamics</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >2D Collision, Physics, Rigid body dynamics</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >2D Collision, Physics, Rigid body dynamics</a><br><br>
<a name="494319"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I might have an Idea for a community project.<br><br>I have spent the last three weeks trying to figure out a system in Max for polygon collision, and rigid body dynamics. After a lot of reading, and trying to interpret C++ code, I'm begining to understand some of it. But I still can't get my head completely around it.<br><br>So I thought I might see if the Blitz community wouldn't mind helping out :) I think that giving novice game programmers (like me!) an easy to use physics and collision library would bring up the level of quality in our games.<br><br>I believe that 2d is far from dead and that gameplay should always be considered more important than fancy graphics and eyecandy. So adding physics to games would make them so much better.<br><br>So does anyone want to maybe start a community project to create a module for 2d physics?<br><br>To give you a better idea of what I'm trying to accomplish, here is some code and examples of the type of libary I'm trying to create:<br><br><a href="http://uk.geocities.com/olivier_rebellion/Polycolly.zip" target="_blank">http://uk.geocities.com/olivier_rebellion/Polycolly.zip</a><br><br>The code belongs to Olivier Renault, who has created a pretty effeicient system in my opinion. I thinking about just porting some of his code over to Max, but I'm not sure if I would do it in the best way.<br><br>There are far better programmers around here then me, but I am willing to dedicate my time in order to see somthing come out of this. Its still just an idea though so any comments or suggestions are welcome.<br><br>Waddya think guys? <br><br></td></tr></table><br>
<a name="494330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, 2d rigidbody isnt really that hard...<br><br><a href="http://www.blitzcoder.com/cgi-bin/showcase/showcase_showentry.pl?id=andreas_blixt10032003205007&amp;comments=no" target="_blank">http://www.blitzcoder.com/cgi-bin/showcase/showcase_showentry.pl?id=andreas_blixt10032003205007&amp;comments=no</a><br><br>This is a great example of a rb system for b2d ny andreas blixt <br><br></td></tr></table><br>
<a name="494337"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the link,<br><br>I realise that it isn't hard for some people, but I'm sure there are many others who think it is hard, and it would benifit them to have simple, object oriented code that would allow for them to create games with as little or much physics as they would like. I dunno I just think it would be better to have one base module to work from rather than random bits source thrown into a project. I am willing to write my own but so far it's taking me a while. <br><br></td></tr></table><br>
<a name="494506"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sweenie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about a 3D physics engine which also can handle 2D simulations?<br>That way more users can benefit from it.<br><br>If done right one could just prevent motion and rotation in the z-axis, not the "hacky" way but actually ignore the z-axis in the actual integration.<br><br>[Correction]<br>What I mean above was...<br>Only allow movement along the X &amp; Y axis and<br>only allow rotation about the z-axis. :)<br><br>One way to "ignore" movement along the z-axis is to use an infinite mass for forces acting on the z-axis.<br>The same goes for the rotation but instead use an infinite inertia for x &amp; y axis.<br><br>However, if the collision-system only reports collisionpoints along the z-xis and the collisionimpulses is aligned with the z-axis you wouldn't even need to constrain the z-axis, but I think small floating point inaccuracies could interfere though. <br><br></td></tr></table><br>
<a name="587455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry for digging up a corpse, but I want to mention that this<br>tutorial is very good.  Bot Builder was a little rude.  You two <br>are probably not around anymore, but if you are, thank you  <br>altitudems for this sourcecode. <br><br></td></tr></table><br>
<a name="587550"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tobs</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow that's an excellent tutorial.  I've already started implementing something similar in Max, this will just speed me along.  If I actually get something up worth showing I'll be sure to share. <br><br></td></tr></table><br>
<a name="587582"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Haramanai</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> a polygon? you think it's faster than lines segments?<br>edit: oh ... this topic was for rigid bodies not for phisics... <br><br></td></tr></table><br>
<a name="587605"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Will</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> The download from the link doesn't work for me - anyone got a mirror?<br><br>Also, can I port this code for my use in blitzmax?  I assume so since the source is provided. <br><br></td></tr></table><br>
<a name="587617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this what you wanted?<br><br><a href="http://soldiers.250free.com/BlitZMax/Polycolly.zip" target="_blank">http://soldiers.250free.com/BlitZMax/Polycolly.zip</a><br><br>I'll host it for a bit if his server is on the fritz. <br><br></td></tr></table><br>
<a name="587786"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Will</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, I'v got it now :D <br><br></td></tr></table><br>
<a name="587790"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Altitudems! Sorry that I didn't saw this thread before.<br>This is exactly what I are trying to do. Those demos where might impressive! If we can copy this to Bmax we are almost done already. <br><br>I do not agree that a 3D library should be used in 2D. The other way around. Let's build a solid 2D Physics library and then we can in the future expand it to 3D. Adding a dimention shouldn't be that hard, seems like most of the work would be in making a 3DVector that inherits our 2DVector. 2D is simpler than 3D and should be the logical place to start.<br> <br>If you want you can always jump to my thread. <br><br></td></tr></table><br>
<a name="724619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did anyone actually port PolyColly to bmax? it seems quite ideal ish. <br><br></td></tr></table><br>
<a name="724634"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I implemented a physics simulation in BB for a project at school, so I researched loads for it.<br><br><a href="http://www.harveycartel.org/metanet/tutorials/tutorialA.html" target="_blank">http://www.harveycartel.org/metanet/tutorials/tutorialA.html</a><br>This is a great link from a great game on separating axis theory.<br><br><a href="http://www.gamedev.net" target="_blank">http://www.gamedev.net</a><br>has loads of great code snippits on finding the center of gravity and moment of inertia for arbitary poly meshes.<br><br>Its something that I was just about to tackly for the game im working on so I realy would love to help out. I only need a 2D implementation but that doest matter. 3D rigid body physics is much harder, especialy for collision detection and MOI solving, etc.<br><br>I had a look at PolyColly a little more than a year back on flipcode and its writen realy well so I guess a port wouldnt be too hard. If no one else is willing then I mite take a stab at a direct port not just wraping. <br><br></td></tr></table><br>
<a name="724869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I emailed the author to ask his concent for a PolyColly port<br>as he didnt specify his wishes for the library in any of the source code.<br>I will start to make the port into pure native BlitzMax code, not a wraper.<br>I guess i'll just release the code threw the various stages of the port into the codearchives.<br>If the author doesnt give me the go ahead then that will be that.<br>Who will be interested in the port?<br>Does anyone have any perticular needs/features that they would like to see? <br><br></td></tr></table><br>
<a name="724888"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >North</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> &lt;- interested... the more the better <br><br></td></tr></table><br>
<a name="724968"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pantheon,<br><br>Definately for a game one would like to be able to create and remove rigid bodies on the fly, and return x,y and rotation values from a rigid body object. Types are ideal for this...<br><br>Then we can just recall the values any time we wish to draw. Think of a shootemup which needs to scroll new rb items into view as time goes by? do we offset the drawing positions or the rigid bodies? <br><br></td></tr></table><br>
<a name="724978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, i'v started looking at the source code and have writen up a all the method stubs.<br><br>@ One Eyed Jack:<br>Removing rigid bodys is fine. My concern is that creating rigid bodys would incur a speed penalty as some quite heavy functions are called to find the mass and other important values.<br>A way around this would be to precache the rigid bodies that you would use, rather like a template.<br>You could then insert this into the simulation later with no speed penalty. All your other requirements are met by the origial library.<br><br>I would still like to know who will be intrested and if they there are any other suggestions, etc. <br><br></td></tr></table><br>
<a name="725046"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> The only other suggestion I can think of would be anything to make it more maxish and easier to use if possible :) Very large numbers of people want thise sort of thing, they just haven't seen this post by you yet. <br><br></td></tr></table><br>
<a name="725089"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah I think im going to change the library interface quite a bit to make it more simple to use (without removing any of its power :). Im toying with the idea of implementing soft bodies and articulation to the library. All the papers I look at on articulation are practicaly impenatrable. <br><br></td></tr></table><br>
<a name="725202"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well your comments have me positively drooling! let me know if I can assist with testing during the development stage. <br><br></td></tr></table><br>
<a name="725203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Will do, :) <br><br></td></tr></table><br>
<a name="725240"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stu_ovine</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Same here......  sounds an excellent project and one that most people would appreciate once completed.<br><br>me for one ! <br><br></td></tr></table><br>
<a name="725260"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Binary_Moon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you're looking for encouragement I am happy to give it. A decent 2d physics engine would be wonderful. <br><br></td></tr></table><br>
<a name="725427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> /pokes head up and looks about - any news? :) <br><br></td></tr></table><br>
<a name="725986"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> any news?<br><br>Well, im back home for the weekend so that gives me a long time to read over loads of game physics related papers. Im concentrating at the moment on the features that I want to be included and how the API should look. Once im happy enough with that then I will start to produce the goods.<br><br>One of the problems I have is how to supply the simulator with the geometery for each rigid body. Also Is the problem of a terrain callback (just like tokamak). I was thinking of using a vertex array for both, just a pointer to a series of either integer of float pairs (x, y).<br><br>Its just going to take a little while to get the design right then the implementation should drop in place quite nicely. Polycolly has some problems with stacking that I will need to sort out so its looking more and more that i will take polycolly as a reference and work up a new implementation for the physics.<br><br>I already have the trivial stuff like the matrix and vector classed coded and a prototype of the API.<br><br>Food for thought is how you will construct your geometry? remembering that it has to be convex. That is if you decide to use a polygon based rigid body. There will also mathmatical bodies representing spheres and rectangles. They will probably be easiest to implement for someone new to the library or looking for a minimal effort use of the library.<br><br>Another adition I am planning are sensors (again like tokamak). They can be attached to a body, projecting a straight line onto the next closest body, kinda like linepick in B3D. They should be usefull for many things.<br><br>Sorry for this post being all over the place, thats just because I have thousands of ideas and stuff floating around my head for this project and its taking its tole as I try to condense them all into something that will work and be reliable. <br><br></td></tr></table><br>
<a name="726090"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm happy if you let us just compose one rigid body out of several rigid bodies. For example two rectangles making up a cross (treated as one object). <br><br></td></tr></table><br>
<a name="726204"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have abstracted the collision handler so each rigid body objects will specify what collision handlers they support and the simmulator will choose the most optimal one to resolve the collision between the two bodies. This will later let me/us implement soft/non-convex bodies by providing different collision handlers than seporating axis theory<br><br>EDIT: I had in mind that SAT was strictly convex only but I just realised that it wasnt. That makes things simpler :). If I leave the collision handler in then that will allow 1337 coders to optimize it to their games with perhaps a BSP/portaling engine some how (that for them to decide).<br><br>I read over a whole bunch of papers on constraints and it looks like implementing joints shouldnt be so hard.<br><br>Im feeling pretty good about the API as it looks both robust and extendible. Before I start and major work perhaps people would like to look at the API and have their say as this is a comunity project and all.<br><br>Does anyone have any webspace? I could zip it up and give it to them and they could post a link. I would dump it here but it spans loads of source files. <br><br></td></tr></table><br>
<a name="726220"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> I do not have webspace at the moment, but I think is fantastic what you are doing. I am not too much of a technical person but it sounds fabulous. Will you be able to shoot like in the pollycolly tech demos?<br><br>What did you mean by non-convex? that sounds most exciting of all. Could I then define a closed vector area and use those points as the collision?<br><br>One more question for you: will we be able to for example, have some rigid bodies which are immovable, such as the background or things I would prefer not to budge? <br><br></td></tr></table><br>
<a name="726415"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can create a number of rigid bodys, either from supplied arguments (spheres/rectangles) or from a given set of vertices (polymesh).<br><br>When an object is convex it has no slight orifaces, all of an objects vertices lie on the negative side of each edge. Non-convex objects are thoes with any form or edge layout. (Im so bad at explaining things)<br><br><div class="quote"> Could I then define a closed vector area and use those points as the collision? <br></div><br>Yes.<br><br><div class="quote"> Will we be able to for example, have some rigid bodies which are immovable, such as the background or things I would prefer not to budge? <br></div><br>Yes, you can set objects to imobile. They will not be simulated but other objects will still be able to collide with them. Another good point is that objects will be able to be made imobile/mobile when every you like.<br>As for the back ground you have two choises. You could model it with imobile objects or you could use a terrain callback:<br><br>A terrain callback is a small function that you would provide to the simulator in the form of a function pointer and this would be called during the simulation. The simulator would pass some spatial paramaters to the function and you are then expected to pass back some geometric information that the simulator will use for collision. This is very usefull for instance if you have array bassed terrain, a BSP tree or some other space partitioning scheme. <br><br></td></tr></table><br>
<a name="726457"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well the game I am working on is a shootemup with physics for fun. I haven't worked out if its best to just scroll by offsetting the drawing positions or physically moving everything.<br><br>Maybe a bit of both, re-using rigid bodies or something as they nearly come on screen. <br><br></td></tr></table><br>
<a name="726743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Binary_Moon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have stacks of webspace. If you still need space then mail the file to - binarymooon at gmail.com - and I will setup a download for you. <br><br></td></tr></table><br>
<a name="726826"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Weird have lost posts? <br><br></td></tr></table><br>
<a name="726983"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Will</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'd like to see some sort of screen-space conversions or way to do easy mouse interaction.<br><br>Also, some kind of tool for setting these things up, making the poly's with the joints, masses, frictions, etc, and saving / loading them.<br><br>Great project, keep it up! <br><br></td></tr></table><br>
<a name="727010"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hm, screen space conversions are a good point. Max2D is well, 2D and so something to this effect needs to be thought out. <br><br></td></tr></table><br>
<a name="727936"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'v had a realy tough week at uni and what not so I havent had much time to do anything with this project apart from reading stacks of techincal articles. When I get back to my proper computer then I will get a source forge address and upload a rough copy of the API.<br>Constraints are still doing my head in but im sure that sometime soon they will make sence or that some smart coder can blaze into the project and put them in.<br>Yeah I was thinking about an app to do all the rigging and modeling.<br>Cool, at the start of next week, i'll try and get all this going. <br><br></td></tr></table><br>
<a name="728199"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would just focus on a straight and simple port of pollycolly personally...<br><br>then build from there. <br><br></td></tr></table><br>
<a name="728276"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, I just sent off an application to source forge so I'll just be waiting to hear a reply.<br>How can I create a sticky topic?<br><br>Here is my description for SourceForge:<br><br><div class="quote"> <br>-- project: "Motive" --<br><br>Motive will be a public domain physics simulation library for the BlitzMax programing comunity. The library will handle purely 2D simulations of rigid bodys. It will be implemented in native BlitzMax programing language so as to aid integration/adaptation of the library to suit an individuals projects. Motive will be designed to reduce the learning cure required to use a powerfull physics library. It will also be aimed to be highly modular in implementation where possible to aid the extensions/adaptations by project contributors and final users alike.<br>Some of the inital project goals are as follows:<br><br>.&gt; Real-Time Simulation of Rigid Bodys in an arbitrary polygonal environment<br>.&gt; Multiple Rigid-Body representations (Polygonal or mathmatical)<br>.&gt; Easy integration into new and currently established games<br>.&gt; A stable simulation core<br>.&gt; Support for concevable libary additions (soft-body, etc)<br>.&gt; Visualy satisfying/plausable simulation of:<br>+--&gt; rigid body stacking<br> --&gt; shock propagation<br> --&gt; collison<br> --&gt; contact<br> --&gt; friction<br>.&gt; Unified and consistant API<br>.&gt; Minimise any extra content creation required from the final users<br><br>Some future direction of the library include:<br><br>.&gt; Articulation amongst multiple bodies<br>.&gt; Soft Body simulation<br>.&gt; Unification/Optimisation of the library code<br>.&gt; Inverse Kinematics<br>.&gt; Implicit Animation<br> <br></div> <br><br></td></tr></table><br>
<a name="728341"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>How can I create a sticky topic?<br> <br></div><br>Stickies are for moderators. Just create a new thread when there's something people can play with and drop me an email (support@...). Looking forward to seeing this project! <br><br></td></tr></table><br>
<a name="728402"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Klaas</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi there,<br>this sounds very interesting!<br><br>I've tried to write an verlet engine myself for a jump'n run game but failed. I dident sort out how to do a dynamic to dynamic object collision response.<br>I'm not that good in those math stuff.<br><br>But if you need any support, i'm in.<br><br>It looks like its just you developing this, Pantheon?<br><br>At least i could do graphics or help you code the editor, do something that keeps your hands/mind free for this serious stuff. So, if your interested in some help, just write a mail to: rayzor-s-edge@... <br><br></td></tr></table><br>
<a name="728572"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jake L.</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just came back to BB forum after a while to see this thread. Can't wait to see a good and solid physics-module.<br><br>@Pantheon:<br><br>If you haven't solved your webspace-problem yet, leave me a mail. I have plenty of bandwidth available and can host any files related to this project.<br><br>Jake <br><br></td></tr></table><br>
<a name="728596"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey guys,<br><br>Sorry I haven't noticed this sooner, but I am ready to devote some time to the development of this. Pantheon, seems like you have a good idea of what this project should accomplish. Let me know what I can do to help. Has it already been a year? <br><br></td></tr></table><br>
<a name="728621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, thanks guys.<br><br>I also have some good news. I found a website with papers from the Game Developers Confrence:<br><a href="http://www.gphysics.com/" target="_blank">http://www.gphysics.com/</a><br><br>This guy gave a presentation on his method for game physics and man is it good. The best part is that the maths and algorythms involved are so simple. At least check out the downloadable demo.<br><br>I think that I may use his techniques for the library. Its starting to look realy feasable. Im gna start coding when I get home.<br><br>Oh yeah:<br>.&gt; It handles Constraints (Joints that is)<br>.&gt; Friction<br>.&gt; Stacking<br>.&gt; Just have a look... <br><br></td></tr></table><br>
<a name="728690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice find, very simple &amp; straight forward. I have always coded my collision code for SAT impulse based response. Obviously his example code is for box&gt;box collisions only but we could easily add in circle&gt;box &amp; circle&gt;circle. I don't think you would need much more than that in a 2d game. Although arguably polygonal collision checks could be helpful. In any case all of these alogarithms are available for the SAT approach. The only really tricky part would be programming the response.<br><br>I think it would be the most beneficial to create a simple base of code to start from, maybe with just one type of body and minimal collision response, and then work from there. Create something to get people interested, and actually start using the code in test projects. I think if we can do this then we will start to many contributions.<br><br>I'm excited, physics make programming fun. <br><br></td></tr></table><br>
<a name="729089"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, just in case you need it, I just finished porting the mathutils.h file from the Box2d lib.<br><br>Due to BMax's lack of support for operator overloading some functions have long awkward names. My goal here is just to get the code working, not to make it look pretty.<br><br>Edit: Updated for consistent naming.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto <a href="http://www.gphysics.com" target="_blank">http://www.gphysics.com</a>
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem
Const FLT_MAX:Float = 10^37

Function Vec2:TVec2 (_x:Float, _y:Float) 'Constructor
	Local v:TVec2 = New TVec2
	v.X = _x
	v.Y = _y
	Return v
End Function

Type TVec2
	Field X:Float, Y:Float
	Method Set(_x:Float, _y:Float)
		X = _x
		Y = _y
	End Method
	Method Reverse:TVec2() '-()
		Return Vec2(-X, -Y)
	End Method
	Method AddV(v:TVec2) '+=
		X :+ v.X
		y :+ v.Y
	End Method
	Method SubV(v:TVec2) '-=
		X :- v.X
		y :- v.Y
	End Method
	Method Mult(a:Float) '*=
		X :* a
		y :* a
	End Method
	
	Method Length:Float ()
		Return Sqr(X * X + Y * Y)
	End Method

End Type

Function Mat22:TMat22(_col1:TVec2,_col2:TVec2) 'Constructor
	Local m:TMat22 = New TMat22
	m.col1 = _col1
	m.col2 = _col2
	Return m 
End Function
Function Mat22_Angle:TMat22(angle:Float) 'Constructor from angle
	Local m:TMat22 = New TMat22
	Local c:Float = Float(Cos(angle)), s:Float = Float(Sin(angle))
	m.col1.X = c
	m.col2.X = -s
	m.col1.Y = s
	m.col2.Y = c
	Return m 
End Function
	
Type TMat22
	Field col1:TVec2
	Field col2:TVec2
	Method New()
		col1 = New TVec2
		col2 = New TVec2
	End Method
	Method Transpose:TMat22()
		Return Mat22(Vec2(col1.X, col2.X), Vec2(col1.Y, col2.Y))
	End Method
	Method Invert:TMat22()
		Local a:Float = col1.x, b:Float = col2.x, c:Float = col1.y, d:Float = col2.y
		Local E:TMat22
		Local det:Float = a * d - b * c
		Assert (det &lt;&gt; 0.0),"Error: Type Mat22&gt;Invert"
		det = 1.0 / det
		E.col1.X =  det * d
		E.col2.x = -det * b
		
		E.col1.Y = -det * c
		E.col2.y =  det * a
		Return E
	End Method
End Type

Function Dot:Float(a:TVec2, b:TVec2)
	Return a.X * b.X + a.X * b.X
End Function

Function CrossVec2Vec2:Float(a:TVec2, b:TVec2)
	Return a.X * b.Y - a.Y * b.X
End Function

Function CrossVec2Float:TVec2(a:TVec2, s:Float)
	Return Vec2(s * a.Y, -s * a.X)
End Function

Function CrossFloatVec2:TVec2(s:Float, a:TVec2)
	Return Vec2(-s * a.Y, s * a.X)
End Function

Function MultMat22Vec2:TVec2 (A:TMat22, v:TVec2)
	Return Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y)
End Function

Function AddVec2Vec2:TVec2 (a:TVec2, b:TVec2)
	Return Vec2(a.x + b.x, a.y + b.y)
End Function

Function SubVec2Vec2:TVec2 (a:TVec2, b:TVec2)
	Return Vec2(a.x - b.x, a.y - b.y)
End Function

Function MultFloatVec2:TVec2 (s:Float, v:TVec2)
	Return Vec2(s * v.x, s * v.y)
End Function

Function AddMat22Mat22:TMat22 (A:TMat22, B:TMat22)
	Return Mat22(AddVec2Vec2(A.col1, B.col1), AddVec2Vec2(A.col2, B.col2))
End Function

Function MultMat22Mat22:TMat22 (A:TMat22, B:TMat22)
	Return Mat22(MultMat22Vec2(A, B.col1), MultMat22Vec2(A, B.col2))
End Function

Function AbsoluteVec2:TVec2(a:TVec2)
	Return Vec2(Abs(a.x), Abs(a.y))
End Function

Function AbsoluteMat22:TMat22 (A:TMat22)
	Return Mat22(AbsoluteVec2(A.col1), AbsoluteVec2(A.col2))
End Function

Function Sign:Float(x:Float)
	Return Sgn(x)
End Function

Function MinFloat:Float(a:Float, b:Float)
	If a &lt; b Return a Else Return b
End Function

Function MaxFloat:Float(a:Float, b:Float)
	If a &gt; b Return a Else Return b
End Function

Function ClampFloat:Float(a:Float, low:Float, high:Float)
	Return MaxFloat(low, MinFloat(a, high))
End Function

Function Swap(a:Object, b:Object)
	Local tmp:Object = a
	a = b
	b = tmp
End Function

' Random number in range [-1,1]
Function Random:Float()
	Return Float(Rnd(-1,1))
End Function

Function Random2:Float(lo:Float, hi:Float)
	Return Float(Rnd(lo,hi))
End Function
</textarea> <br><br></td></tr></table><br>
<a name="729105"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here is a ported version of Body.h and Body.cpp:<br><br>Edit: Updated to include BodyList<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Include "MathUtils.bmx"
Global BodyList:TList = CreateList()
Function Body:TBody()
	Local b:Tbody = New TBody
	b.position.Set(0.0, 0.0)
	b.rotation = 0.0
	b.velocity.Set(0.0, 0.0)
	b.angularVelocity = 0.0
	b.force.Set(0.0, 0.0)
	b.torque = 0.0
	b.friction = 0.2

	b.width.Set(1.0, 1.0)
	b.mass = FLT_MAX
	b.invMass = 0.0
	b.I = FLT_MAX
	b.invI = 0.0
	Return New TBody
End Function

Type TBody
	Field position:TVec2
	Field rotation:Float

	Field velocity:TVec2
	Field angularVelocity:Float

	Field force:TVec2
	Field torque:Float
	
	Field width:TVec2

	Field friction:Float
	Field mass:Float, invMass:Float
	Field I:Float, invI:Float

	Method New()
		position = New TVec2
		velocity = New TVec2
		force = New TVec2
		width = New TVec2
		BodyList.AddLast(Self)
	End Method
	Method Set(w:TVec2, m:Float)
		position.Set(0.0, 0.0)
		rotation = 0.0
		velocity.Set(0.0, 0.0)
		angularVelocity = 0.0
		force.Set(0.0, 0.0)
		torque = 0.0
		friction = 0.2
	
		width = w
		mass = m
	
		If (mass &lt; FLT_MAX)
			invMass = 1.0 / mass
			I = mass * (width.x * width.x + width.y * width.y) / 12.0
			invI = 1.0 / I
		Else
			invMass = 0.0
			I = FLT_MAX
			invI = 0.0
		End If
	End Method
	
	Method AddForce (f:TVec2)
		force.AddV(f)
	End Method

End Type
</textarea> <br><br></td></tr></table><br>
<a name="729134"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats great!<br><br>I also started to port some code into an API which I will explain in a minuite.<br>His code uses a seporating axis for the box-box collision and modifying this to work with arbitary polygon shapes should just be a case of rewriting the collision handler to use SAT (ala PolyColly). The final step would also be to create a function to find the center of mass and the moment of inerta (both of which can be taken from PolyColly). Other than that I realy cant see any other great changes needed for the code.<br><br>I will now give a rough explanation of the API. I thought this project should be called Motive because it was the only thing I could think that was kina cool. Here is a rough sketch of the types:<br><br>Classes:<br><br>Simulator {<br><br>    CreateRigidBody:RigidBody( bodytype, vertices:float ptr, numvertices )<br>    CreateJoint:Joint( bod1:RigidBody, Bod2:RigidBody )<br>    CreateSensor:Sensor( bod1:RigidBody )<br>    CreateEvent:Event( bod1:RigidBody )<br>    Advance( timeStep:float, iterations=5 )<br>    SetState( state:int, Flag:int )<br><br>}<br><br>RigidBody (abstract class)<br>+  SoftBody  (extender)<br>+  MathBody  ( '' )<br>+  PolyBody  ( '' ) {<br><br>    ApplyForce( vector )<br>    SetState( state:int, flag:int )<br>    SetPosition( vec2 )<br>    GetPosition:vec2( )<br>    SetVelocity( vec2 )<br>    GetVelocity:vec2( )<br>    SetOrientation( float )<br>    GetOrientation:float( )<br>    <br>    etc....<br><br>}<br><br>Joint (abstract class)<br>+  Penalty (extender)<br>+  Impulse ( '' ) {<br><br>    Create( blah blah )<br>    <br>    etc....<br><br>}<br><br>Sensor {<br><br>    SetCallback( function pointer )<br>    SetPosition( Vec2 )<br>    GetPosition:Vec2(  )<br>    SetOrientation(  )<br>    GetOrientation(  )<br>    SetLength(  )<br>    GetLength(  )<br><br>}<br><br>Event {<br><br>    This will just specify collision callbacks or joint limit exceeds or huge forces' or something. This could be used for destroyable bodies by breaking joints when huge forces are applyed.<br><br>}<br><br>Some other features of the library are that an abstract collision type is made that will interface with the simulator and the rigid bodys. This can be extended to handle SAT or something more bulky for non-convex shapes. Each Body can constain a constant (set of flags) defined by what collision handlers they support.<br><br>const CollHandSAT:int = $000F    '// seporating axis<br>const CollHandNCT:int = $00F0    '// non covex test method<br><br>For the moment only seporating axis will be used. I was also planning that before release all the vetor and matrix math could be manualy inserted into the code to get speeds simmilar to inline functions (I hate that blitz doesnt have them).<br><br>That will probably take a lot to diggest because its kinda just a brain spill. I cant upload and code because im at Uni just now. So the question is how do we merge the two?<br><br>You could keep porting the code directly and then that would make it easy for me to integrate it into the API?<br><br>I think is great what you have done so far so, I guess you can decide what you wana do.<br><br>Perhaps we should just directly port his code and then focus on customising and extending it or perhaps I could just work on geting it running with polys?<br><br>Fun fun. <br><br></td></tr></table><br>
<a name="729162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> that's a great start on outlining the api, I will take more time to look at it later.<br><br>It is debatable whether or not inline functions improve performance, I think we should not worry about inserting vector and matrix code directly into the API. Just make sure that whatever code we use for those systems is extendable, and easily used for other things.<br><br>I think we should do a direct port for now and just get some code working and a demo. That will get others excited and possibly working on "Motive" (I like the name by the way). Obviously the direct port will be fairly sloppy code. The actual API I think should have very easy to understand code, with variables spelled out, comments explaining logic, etc. This will allow others to contribute more easily and reduce confusion.<br><br>While we direct port the code, we can plan the API more. The  first step might be to just get ridged body physics simulation working for just OOBBs. And then expand from there.<br><br>Edit:<br>Another thing we should think about is how someone would actually implement this into their game. How will bodies be attached to game-world entities, etc. <br><br></td></tr></table><br>
<a name="729229"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now that sounds like a plan.<br><br>Ok, lets divy up the files.<br>Unless you have any objections then we could split them up like this:<br><br>altitudems -&gt;<br><br>  MathUtils.h             done!<br>  Body.cpp / Body.h       done!<br>  World.cpp / World.h<br>  Main.cpp<br><br>Pantheon -&gt;<br><br>  Collide.cpp<br>  Arbiter.cpp / Arbiter.h<br>  Joint.cpp / Joint.h<br><br>One question is: Are we going to use all the OpenGL commands (It uses GLUT so some slight modifications may be needed (font drawing, etc)) or use Max2D?<br>If you wanna do the Main.cpp file then its your call :)<br><br>I guess i'll try to stick to the naming convention you used to aid the ease of the merge.<br><br>I guess that when we have this done then we can realy spot the pros and cons of this system before starting any more work on the full library.<br><br>I have a few deadlines for Uni so my progress may be a little slow but I will try and have it done in the next couple of days :)<br><br>Cool, this should be fun. <br><br></td></tr></table><br>
<a name="729235"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, Im converting Arbiter.cpp and one problem arrises :<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Arbiter::Arbiter(Body* b1, Body* b2)
{
	if (b1 &lt; b2)
	{
		body1 = b1;
		body2 = b2;
	}
	else
	{
		body1 = b2;
		body2 = b1;
	}

...

</textarea><br><br>If b1 and b2 are pointers then he has just compared their memory addresses. I can only come up with one explanation for this and thats that he wants body1 to have the lower memory address so that he can expect body2 to be in the CPU cache as I presume he accesses that second.<br><br>Other than that I can see what he could hope to achive by that.<br><br>Any suggestions? <br><br></td></tr></table><br>
<a name="729259"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> That break up sounds good, I think I will convert the glut code to Max2d.<br>I did notice that several of the function names aren't very consistent, I will updated that real quick.<br><br>It seems that he is using pointer arithmetic to determine which body is last in the stack and then test against that first. I think we will end up using lists or arrays instead so we can compare them by their position. If pointers end up being needed for speed we might me out of luck. As far as I know BlitzMax only supports adding and subtracting of pointers. <br><br></td></tr></table><br>
<a name="729304"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just want to say that if it doesn't use max2D, I will definately not use it :)<br><br>The ideal way would be to have it use a simple 0-100 or -100 to 100 scale, and let us translate the physics to our chosen resolution.<br><br>Many will use 2D libraries for drawing, 3D engines or even Max2D (I suspect the majority will have graphics engines in place)...<br><br>So if you fix the physics to a basic simple number system we can choose our own resolutions and engines. <br><br></td></tr></table><br>
<a name="729495"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rite now we are just trying to make a direct port of the excelent Physics Demo created by Erin Catto. It was writen in C++ and used the OpenGL helper library GLUT. I think altitudems is going to convert the demo to use Max2D but as for the final library, I will be API independant, meaning that you have to querie the Simulator to figure out how you should draw your objects. Another posibility is that you just supply a render callback function, but im getting ahead of myself.<br>All this will be addressed later :) <br><br></td></tr></table><br>
<a name="729512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pantheon,<br><br>I'm finding it difficult to port any more code because the files I'm working on are dependent on yours. :)<br><br>I am going to go ahead and port over joint.h/cpp post that here unless you have already completed it. I know you said you are working on arbiter.h/cpp. Let me know if I should do this. <br><br></td></tr></table><br>
<a name="729553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats cool,<br><br>Yeah im still working on Collision and Arbiter so go ahead. I coded up all the stubs of all the functions and types for my compulation.<br><br>How far are you along? I should be about 75% done by tomorow and possibly have it done by tomorow night. I guess we can just post what we have completed and then spend about 5 muinites joining them en voila. <br><br></td></tr></table><br>
<a name="729562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you need an Arbiter Stub then use this one, i'll have it finished real soon:<br><br><pre class=code>
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

'/**
' *
' */
Const inEdge1:Int = 0
Const inEdge2:Int = 1
Const outEdge1:Int = 2
Const outEdge2:Int = 3

'/**
' *
' */
Type TFeaturePair

	Field e:Byte Ptr
	Field key:Int

	Method New( )
		e = Byte Ptr( Varptr( key ) )
	End Method

End Type

'/**
' *
' */
Type TContact

	Field position:TVec2
	Field normal:TVec2
	Field separation:Float
	Field accumulatedNormalImpulse:Float
	Field accumulatedTangentImpulse:Float
	Field massNormal:Float, massTangent:Float
	Field bias:Float
	Field feature:TFeaturePair;

End Type

'/**
' *
' */
Function Arbiter:TArbiter( a:TBody, b:TBody )

End Function

'/**
' *
' */
Type TArbiter

	Const MAX_POINTS:Int = 2
	
	Field contacts:TContact[MAX_POINTS]
	Field numContacts:Int
	Field body1:TBody
	Field body2:TBody
	Field friction:Float
	
	Method Update( contacts:TContact[], int numContacts )
	
	End Method
	
	Method PreStep( inv_dt:Float )
		
	End Method

	Method ApplyImpulse( )
	
	End Method

End Type
</pre><br><br>Instead of TFeaturePair.e.inEdgex use TFeaturePair.e[inEdgex] ;) <br><br></td></tr></table><br>
<a name="729573"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Im getting a compilation error with this constructor function:<br><br><pre class=code>
'/**
' *
' */
Function Arbiter:TArbiter( a:TBody, b:TBody )

	nArb:TArbiter = New TArbiter
	nArb.body1 = a
	nArb.body2 = b
	nArb.numContacts = 0 '// Collide(contacts, body1, body2)
	nArb.friction = Sqr( body1.friction * body2.friction )

	Return nArb
End Function

</pre><br><br>The error is:<br><br>Compile error:<br>identifier 'friction' not found<br><br>Its defined in both the TArbiter class and the TBody class. Its probably one of thoes stupid mistakes that creeps up on you. <br><br></td></tr></table><br>
<a name="729574"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great, could you maybe use &lt;codebox&gt; instead?<br><br>I am only as far along as what you see posted here, I will work on world.h/cpp next.<br><br>I think there will have to be some time for getting everything working together. I'm sure it won't run correctly right away. Also I'm not sure if we are on the same page with using pointers. I have been converting them into straight variables unless the are being used to manipulate something outside of the methods/functions scope. <br><br>Ok here is a quick port of Joint.h/cpp:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Include "MathUtils.bmx"
Include "Body.bmx"

Function Joint:TJoint ()
	Return New TJoint
End Function

Type TJoint
	Field M:TMat22
	Field localAnchor1:TVec2, localAnchor2:TVec2
	Field r1:TVec2, r2:TVec2
	Field bias:TVec2
	Field accumulatedImpulse:TVec2
	Field body1:TBody
	Field body2:TBody
	Field relaxation:Float
	
	Method New()
		AccumulatedImpulse = New TVec2
		Relaxation = 1.0
	End Method
	
	Method Set (b1:TBody,  b2:TBody, anchor:TVec2)
		body1 = b1
		body2 = b2
	
		Local Rot1:TMat22 = Mat22_Angle(body1.rotation)
		Local Rot2:TMat22 = Mat22_Angle(body2.rotation)
		Local Rot1T:TMat22 = Rot1.Transpose()
		Local Rot2T:TMat22 = Rot2.Transpose()
		localAnchor1 = MultMat22Vec2(Rot1T,  SubVec2Vec2(anchor, body1.position))
		localAnchor1 = MultMat22Vec2(Rot2T,  SubVec2Vec2(anchor, body2.position))
	
		accumulatedImpulse.Set(0.0, 0.0)
		relaxation = 1.0
	End Method

	Method  PreStep(inv_dt:Float)
		' Pre-compute anchors, mass matrix, And bias.
		Local Rot1:TMat22 = Mat22_Angle(body1.rotation)
		Local Rot2:TMat22 = Mat22_Angle(body2.rotation)
		
		r1 = MultMat22Vec2(Rot1, localAnchor1)
		r2 = MultMat22Vec2(Rot2, localAnchor2)
	
		' deltaV = deltaV0 + K * impulse
		' invM = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		'      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		'        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
		Local K1:TMat22 = New TMat22
		K1.col1.x = body1.invMass + body2.invMass;	K1.col2.x = 0.0
		K1.col1.y = 0.0; 							K1.col2.y = body1.invMass + body2.invMass
	
		Local K2:TMat22
		K2.col1.x =  body1.invI * r1.y * r1.y;		K2.col2.x = -body1.invI * r1.x * r1.y
		K2.col1.y = -body1.invI * r1.x * r1.y;		K2.col2.y =  body1.invI * r1.x * r1.x
	
		Local K3:TMat22
		K3.col1.x =  body2.invI * r2.y * r2.y;		K3.col2.x = -body2.invI * r2.x * r2.y;
		K3.col1.y = -body2.invI * r2.x * r2.y;		K3.col2.y =  body2.invI * r2.x * r2.x;
	
		Local K:TMat22 = AddMat22Mat22(AddMat22Mat22(K1, K2), K3)
		M = K.Invert()
	
		Local p1:TVec2 = AddVec2Vec2(body1.position, r1)
		Local p2:TVec2 = AddVec2Vec2(body2.position, r2)
		Local dp:TVec2 = SubVec2Vec2(p2, p1)
		bias = MultFloatVec2((-0.1 * inv_dt), dp)
	
	
		'Apply accumulated impulse.
		accumulatedImpulse.Mult(relaxation)
	
		body1.velocity.SubV(MultFloatVec2(body1.invMass, accumulatedImpulse))
		body1.angularVelocity :- body1.invI * CrossVec2Vec2(r1, accumulatedImpulse)
	
		body2.velocity.AddV(MultFloatVec2(body2.invMass, accumulatedImpulse))
		body2.angularVelocity :+ body2.invI * CrossVec2Vec2(r2, accumulatedImpulse)
	End Method
	
	Method ApplyImpulse()
		Local dv:TVec2 = AddVec2Vec2(body2.velocity, CrossFloatVec2(body2.angularVelocity, r2))
		dv.SubV(SubVec2Vec2(body1.velocity, CrossFloatVec2(body1.angularVelocity, r1)))

		Local impulse:TVec2 = MultMat22Vec2(M, AddVec2Vec2(dv.Reverse(), bias))
	
		body1.velocity.SubV(MultFloatVec2(body1.invMass,impulse))
		body1.angularVelocity :-  body1.invI * CrossVec2Vec2(r1, impulse)
	
		body2.velocity.AddV(MultFloatVec2(body2.invMass,  impulse))
		body2.angularVelocity :+ body2.invI * CrossVec2Vec2(r2, impulse)
	
		accumulatedImpulse.AddV(impulse)
	End Method
	
End Type
</textarea> <br><br></td></tr></table><br>
<a name="729575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> As far as I know in TBody the friction field is defined properly in the type and initialized in the Body() Constructor. Are you running the code or just building it? <br><br></td></tr></table><br>
<a name="729578"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Building it...<br><br>Im stumped.<br><br>(Im goin back to my flat now so i'll have to catch you tomorw) <br><br></td></tr></table><br>
<a name="729667"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AlexO</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure how far you're on this project. But I figured I'd just throw in the source I have for anyone willing to scavenge something useful from it. It's basically a direct port of Oliver Renualt's 2D physics tutorial (pollycolly) while reading Chris Hecker's Rigid body tutorial. I went back and did a weak attempt of making it more OO a while back. Anyway, Here's the link:<br><b> www.paradeofrain.com/download.php?id=9 </b><br><br>Seems you guys already have a decent framework setup so my code probably won't contribute much. One file of interest some might find useful is Transformation.bmx. It deals with 2D transformation so I guess that's a good start should you want to draw polygons at arbitrary orientations. <br><br>The code compiles into a simple working demo (compile from Rigid Body Test.bmx). WSAD to move one of the rigid bodies. SPACE resets the body. It's a bit buggy, lacking friction, but I doubt I'll be coming back to this for a while so I figured I'd just release the unfinished code. <br><br>You'll find folders in the zip of previous more 'concept' demos that follow more in lines with Oliver's tutorials. The 'C' and 'SPACE' key is usually used for those. Hope it's useful. <br><br></td></tr></table><br>
<a name="730265"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks very much .Alex, i'll have a good look at the code later. Im sure that will help speed up the process of creating the basic library.<br><br>altitudems, here is the Arbiter file and a segment of the collision file:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

'/**
' *
' */
Const inEdge1:Int = 0
Const inEdge2:Int = 1
Const outEdge1:Int = 2
Const outEdge2:Int = 3

'/**
' *
' */
Type TFeaturePair

	Field e:Byte Ptr
	Field key:Int

	Method New( )
		e = Byte Ptr( Varptr( key ) )
	End Method
End Type

'/**
' *
' */
Type TContact

	Field position:TVec2
	Field normal:TVec2
	Field separation:Float
	Field accumulatedNormalImpulse:Float
	Field accumulatedTangentImpulse:Float
	Field massNormal:Float, massTangent:Float
	Field bias:Float
	Field feature:TFeaturePair;
End Type

'/**
' *
' */
Function Arbiter:TArbiter( a:TBody, b:TBody )

	Local nArb:TArbiter = New TArbiter
	nArb.body1 = a
	nArb.body2 = b
	nArb.numContacts = Collide( nArb.contacts[TArbiter.MAX_POINTS], nArb.body1, nArb.body2 )
	nArb.friction = Sqr( nArb.body1.friction * nArb.body2.friction )
	Return nArb
End Function

'/**
' *
' */
Type TArbiter

	Const MAX_POINTS:Int = 2
	
	Field contacts:TContact[MAX_POINTS]
	Field numContacts:Int
	Field body1:TBody
	Field body2:TBody
	Field friction:Float
		
	Method Update( newContacts:TContact[], numNewContacts:Int )
	
		Local i:Int, j:Int, k:Int
		Local mergedContacts:TContact[2]

		For i = 0 To numNewContacts-1
		
			Local cNew:TContact = newContacts[ i ]
			k = -1
			
			For j = 0 To numContacts-1

				Local cOld:TContact = contacts[ j ]
				
				If cNew.feature.key = cOld.feature.key
				
					k = j
					Exit
				EndIf
			Next	

			If k &gt; -1
			
				local c:TContact = mergedContacts[i]
				local cOld:TContact = contacts[k]
				c = cNew
				c.accumulatedNormalImpulse = cOld.accumulatedNormalImpulse
				c.accumulatedTangentImpulse = cOld.accumulatedTangentImpulse
			Else

				mergedContacts[i] = newContacts[i]
			EndIf
		Next

		For i = 0 To numNewContacts-1
		
			contacts[i] = mergedContacts[i]
		Next
		
		numContacts = numNewContacts
	End Method
	
	Method PreStep( inv_dt:Float )
	
		Local k_allowedPenetration:Float = Float( 0.01 )
		Local i:Int

 		For i = 0 To numContacts-1
		
			Local c:TContact = contacts[i]
			Local r1:TVec2 = SubVec2Vec2( c.position, body1.position )
			Local r2:TVec2 = SubVec2Vec2( c.position, body2.position )

			'// Precompute normal mass, tangent mass, And bias.
			Local rn1:Float = Dot( r1, c.normal )
			Local rn2:Float = Dot( r2, c.normal )
			Local kNormal:Float = body1.invMass + body2.invMass
			kNormal :+ body1.invI * (Dot(r1, r1) - rn1 * rn1)
			kNormal :+ body2.invI * (Dot(r2, r2) - rn2 * rn2)
			c.massNormal = 1.0 / kNormal

			Local tangent:TVec2 = CrossVec2Float( c.normal, 1 )
			Local rt1:Float = Dot( r1, tangent )
			Local rt2:Float = Dot( r2, tangent )
			local kTangent:Float = body1.invMass + body2.invMass
			kTangent :+ body1.invI*(Dot(r1, r1)-rt1*rt1)+body2.invI*(Dot(r2, r2)-rt2*rt2)
			c.massTangent = 1 / kTangent

			c.bias = -0.1 * inv_dt * Min(0, c.separation + k_allowedPenetration)
			
			'// Apply normal + friction impulse
			local tVector1:TVec2 = c.normal.MultEx( c.accumulatedNormalImpulse )
			local tVector2:TVec2 = tangent.MultEx( c.accumulatedTangentImpulse )
			Local impulse:TVec2 = AddVec2Vec2( tVector1, tVector2 )

			body1.velocity = AddVec2Vec2( body1.velocity, impulse.MultEx( body1.invMass ) )
			body1.angularVelocity :- CrossVec2Vec2( Impulse, r1 ) * body1.invI
			body2.velocity = AddVec2Vec2( body2.velocity, impulse.MultEx( body2.invMass ) )
			body2.angularVelocity :+ CrossVec2Vec2( Impulse, r2 ) * body2.invI
		Next
	End Method

	Method ApplyImpulse( )
	
		local b1:TBody = body1
		local b2:TBody = body2
	
		local i:int
	
		For i = 0 to numContacts-1
		
			Local c:TContact = contacts[i]
			Local r1:TVec2 = SubVec2Vec2( c.position, body1.position )
			Local r2:TVec2 = SubVec2Vec2( c.position, body2.position )
		
			'// Relative velocity at contact
			local rv:TVec2 = AddVec2Vec2( b2.velocity, CrossFloatVec2( b2.angularVelocity, r2 ) )
			rv = SubVec2Vec2( rv, b1.velocity )
			rv = SubVec2Vec2( rv, CrossFloatVec2( b1.angularVelocity, r1 ) )
			local dv:TVec2 = Vec2( rv.x, rv.y )
	
			'// Compute normal impulse with bias.
			local vn:Float = Dot( dv, c.normal )
			local normalImpulse:Float = c.massNormal * ( -vn + c.bias )
	
			'// Clamp the accumulated impulse
			local oldNormalImpulse:float = c.accumulatedNormalImpulse
			c.accumulatedNormalImpulse = Max( oldNormalImpulse + normalImpulse, 0 )
			normalImpulse = c.accumulatedNormalImpulse - oldNormalImpulse

			'// Apply contact impulse
			local impulse:TVec2 = c.normal.MultEx( normalImpulse )
	
			b1.velocity = SubVec2Vec2( b1.velocity, impulse.multEx( b1.invMass ) )
			b1.angularVelocity :- CrossVec2Vec2( r1, impulse ) * b1.invI
	
			b2.velocity = SubVec2Vec2( b2.velocity, impulse.multEx( b2.invMass ) )
			b2.angularVelocity :+ CrossVec2Vec2( r2, impulse ) * b2.invI

			'// Compute friction impulse
			local maxTangentImpulse:Float = friction * c.accumulatedNormalImpulse
	
			local tangent:TVec2 = CrossVec2Float( c.normal, 1 )
			local vt:Float = Dot( rv, tangent )
			local tangentImpulse:Float = c.massTangent * (-vt)
	
			'// Clamp friction
			Local oldTangentImpulse:float = c.accumulatedTangentImpulse
			c.accumulatedTangentImpulse = ClampFloat(oldTangentImpulse + tangentImpulse, -maxTangentImpulse, maxTangentImpulse)
			tangentImpulse = c.accumulatedTangentImpulse - oldTangentImpulse
	
			'// Apply contact impulse
			impulse = tangent.MultEx( tangentImpulse )
	
			b1.velocity = SubVec2Vec2( b1.velocity, impulse.MultEx( b1.invMass ) )
			b1.angularVelocity :- b1.invI * CrossVec2Vec2( r1, impulse )
	
			b2.velocity = SubVec2Vec2( b2.velocity, impulse.MultEx( b2.invMass ) )
			b2.angularVelocity :+ b2.invI * CrossVec2Vec2( r2, impulse )
			
		Next
	End Method
End Type
</textarea><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

const FACE_A_X:Int	= 1
const FACE_A_Y:Int	= 2
const FACE_B_X:Int	= 3
const FACE_B_Y:Int	= 4

const NO_EDGE:Int	= 0
const EDGE1:Int		= 1
const EDGE2:Int		= 2
const EDGE3:Int		= 3
const EDGE4:Int		= 4

Type TClipVertex

	field v:TVec2
	field fp:TFeaturePair
	
End Type

Function _Flip( fp:TFeaturePair )
	'Swap( fp.e[ inEdge1 ], fp.e[ inEdge2 ] )
	'Swap( fp.e[outEdge1 ], fp.e[outEdge2 ] )
End Function

Function ClipSegmentToLine:Int( vOut:TClipVertex[], vIn:TClipVertex[], normal:TVec2, Offset:Float, ClipEdge:Int )
		
End Function

Function ComputeIncidentEdge( c:TClipVertex[], h:TVec2, Pos:TVec2, Rot:TMat22, normal:TVec2 )	
	
End Function

Function Collide:int( contacts:TContact, bodyA:TBody, bodyB:TBody )
	
End Function
</textarea><br><br>I also added these lines to the TVec2 class in mathutils. It was just to simplify writing the vector equations.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	Method MultEx:TVec2( a:Float )
		local nVec2:TVec2 = New TVec2
		nVec2.x = x*a
		nVec2.y = y*a
		return nVec2	
	End Method

	Method Neg( )
		x = -x
		y = -y
	End Method
</textarea><br><br>I will try and get collision finished as soon as i can. I also fixed the compilation error in the constructor function, yeah it was a stupid mistake.<br><br>I literaly convered the source files line by line so im sure that there will be a few logic mistakes in the above code but they shouldnt be too hard to fix. <br><br></td></tr></table><br>
<a name="730430"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pantheon,<br><br>That's great. I'm glad you found the problem. I am working on the World.h/cpp file now but because of my lack on C++ knowledge, I'm not sure what the following means:<br>World.cpp<br><pre class=code>typedef set&lt;Arbiter&gt;::iterator ArbIter;</pre><br>Which is later used like this:<br><pre class=code>ArbIter arb = arbiters.find(newArb);</pre><br>Is "ArbIter" something special? I think "arbiters" is basically equivalent to a list right?<br><br>Also the world class now will hold lists for Bodies,Joints and Arbiters.<br><br>Edit: Here is a logo mockup I made for the project:<br><img src="http://img75.imageshack.us/img75/8201/motivelogoforumrv6.png"> <br><br></td></tr></table><br>
<a name="730564"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its an awesome logo :) <br><br></td></tr></table><br>
<a name="730602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, that will create a Set (a list) of Arbiter objects stored with the identifier ArbIter (I hate c++ for case sensetivity), and Arbiters becomes a global within the source. In World.h vectors (another kind of list) are also created for Bodys and Joints. As well as another set of arbiters definied within the class. Im not sure why the global arbiter set is there then. I think im the same as you, I know the theory about C++ but I dont have much of a clue about the standard library. I think this part may need quite a bit of conversion.<br>Nice logo, btw, its cool :)<br><br>Oh, yeah, I have also finished the Collision file but I keep forgeting to put it on my usb drive, the stub should work for compiling now but i'll post the collision tmrw. <br><br></td></tr></table><br>
<a name="730704"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pantheon, that little explanation helped. I think I have successfuly port World.h/cpp now. Please take a look:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto <a href="http://www.gphysics.com" target="_blank">http://www.gphysics.com</a>
*
* Permission to use, copy, modify, distribute and sell this software
* and its documentation for any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software for any purpose.  
* It is provided "as is" without express or implied warranty.
End Rem

Function  World:TWorld (gravity:TVec2, iterations:Int)
	Local w:TWorld = New TWorld
	w.gravity = gravity
	w.iterations = iterations
	Return w
End Function
Type TWorld
	Field Bodies:TList
	Field Joints:TList
	Field Arbiters:TList
	Field Gravity:TVec2
	Field iterations:Int
	Method New()
		Bodies = CreateList()
		Joints = CreateList()
		Arbiters = CreateList()
		Gravity = Vec2(0.0,0.0)
	End Method
	Method Add ( obj:Object )
		If TBody(obj) Bodies.AddLast(obj)
		If TJoint(obj) Joints.AddLast(obj)
	End Method
	Method Clear()
		Bodies.Clear
		Joints.Clear
		Arbiters.Clear
	End Method
	
	Method BroadPhase()
		' O(n^2) broad-phase
		Local BodiesArray:Object [] = Bodies.ToArray()
		For Local i:Int = 0 To BodiesArray.Length - 1
			Local bi:Tbody = TBody(BodiesArray[i])
			For Local j:Int = i + 1 To BodiesArray.Length - 1
				Local bj:TBody = TBody(BodiesArray[j])
				If (bi.invMass = 0.0 And bj.invMass = 0.0) Continue
				Local newArb:TArbiter = Arbiter(bi, bj)
				If (newArb.numContacts &gt; 0)
					'Not sure what is being accomplished here:
					Local arb:TLink = Arbiters.FindLink(newArb)
					'ArbIter arb = arbiters.find(newArb)
					If (arb = Arbiters.LastLink())
						Arbiters.AddLast(newArb)
					Else
						TArbiter(arb.Value()).Update(newArb.contacts, newArb.numContacts)
					End If
				Else
					Arbiters.Remove(newArb)
				End If
			Next
		Next
	End Method
	
	Method _Step (dt:Float)
		Local inv_dt:Float
		If dt &gt; 0.0 Then inv_dt = 1.0 / dt Else inv_dt = 0.0
		BroadPhase()
		Local BodiesArray:Object [] = Bodies.ToArray()
		For Local i:Int = 0 To BodiesArray.Length -1
			Local b:TBody = TBody(BodiesArray[i])
			
			If (b.invMass = 0.0)	Continue
	
			b.velocity.AddV(MultFloatVec2(dt,(AddVec2Vec2(gravity, MultFloatVec2(b.invMass, b.force)))))
			b.angularVelocity :+ dt * b.invI * b.torque
		Next

		For Local arb:TArbiter = EachIn Arbiters
			arb.PreStep(inv_dt)
		Next

		Local JointsArray:Object [] = Bodies.ToArray()
		For Local i:Int = 0 To JointsArray.Length - 1
			TJoint(JointsArray[i]).PreStep(inv_dt)
		Next

		For Local i:Int = 0 To iterations
			For Local arb:TArbiter = EachIn Arbiters
				arb.ApplyImpulse()
			Next
			For Local j:Int = 0 To JointsArray.Length - 1
				TJoint(JointsArray[j]).ApplyImpulse()
			Next
		Next

		For Local i:Int = 0 To BodiesArray.Length - 1
			Local b:TBody = TBody(BodiesArray[i])
			b.position.AddV(MultFLoatVec2(dt,b.velocity))
			b.rotation :+ dt * b.angularVelocity
	
			b.force.Set(0.0, 0.0)
			b.torque = 0.0
		Next
	End Method
End Type
</textarea><br><br>I'm glad you like the logo. More on that soon. By the way when should we start a new thread? I've got graphics and stuff for that. <br><br></td></tr></table><br>
<a name="730839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think we should start a new thread when we have this demo working, that way it gives people a chance to see first hand the quality of the simulations possible.<br><br>This still needs a tiny bit of work, mostly to finish some vector equations and the swap things. I'll just directly change this code as its completed.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

'/**
' *
' */
'Type Axis
	const FACE_A_X:Int	= 1
	const FACE_A_Y:Int	= 2
	const FACE_B_X:Int	= 3
	const FACE_B_Y:Int	= 4
'End Type

'/**
' *
' */
'Type EdgeNumbers
	const NO_EDGE:Int	= 0
	const EDGE1:Int		= 1
	const EDGE2:Int		= 2
	const EDGE3:Int		= 3
	const EDGE4:Int		= 4
'End Type

'/**
' *
' */
Type TClipVertex

	field v:TVec2
	field fp:TFeaturePair
	
End Type

'/**
' *
' */
Function _Flip( fp:TFeaturePair )
	'Swap( fp.e[ inEdge1 ], fp.e[ inEdge2 ] )
	'Swap( fp.e[outEdge1 ], fp.e[outEdge2 ] )
End Function

'/**
' *
' */
Function ClipSegmentToLine:Int( vOut:TClipVertex[], vIn:TClipVertex[], normal:TVec2, Offset:Float, ClipEdge:Int )
	'// Start with no output points
	local numOut:Int = 0

	'// Calculate the distance of end points to the line
	local distance0:Float = Dot( normal, vIn[0].v ) - Offset
	local distance1:Float = Dot( normal, vIn[1].v ) - Offset

	'// If the points are behind the plane
	if ( distance0 &lt;= 0 ) vOut[numOut] = vIn[0];
	if ( distance1 &lt;= 0 ) vOut[numOut+1] = vIn[1];
	numOut :+2

	'// If the points are on different sides of the plane
	if ( distance0 * distance1 &lt; 0 )

		'// Find intersection point of edge and plane
		local interp:Float = distance0 / (distance0 - distance1)
		vOut[numOut].v = subVec2Vec2( vIn[1].v, vIn[0].v ).MultEx( interp )
		vOut[numOut].v = addVec2Vec2( vIn[0].v, vOut[numOut].v )
		if ( distance0 &gt; 0 )

			vOut[numOut].fp = vIn[0].fp;
			vOut[numOut].fp.e[inEdge1] = clipEdge
			vOut[numOut].fp.e[inEdge2] = NO_EDGE
		else

			vOut[numOut].fp = vIn[1].fp
			vOut[numOut].fp.e[outEdge1] = clipEdge
			vOut[numOut].fp.e[outEdge2] = NO_EDGE
		endif

		numOut :+1
	endif

	return numOut
End Function

'/**
' *
' */
Function ComputeIncidentEdge( c:TClipVertex[], h:TVec2, Pos:TVec2, Rot:TMat22, normal:TVec2 )	
	'// The normal is from the reference box. Convert it
	'// to the incident boxe's frame and flip sign.
	local RotT:TMat22 = Rot.Transpose( )
	local n:TVec2 = MultMat22Vec2( RotT, normal )
	n.Neg( )
	local nAbs:TVec2 = AbsoluteVec2( n )

	if ( nAbs.x &gt; nAbs.y )

		if ( Sign( n.x ) &gt; 0 )

			c[0].v.Set( h.x, -h.y )
			c[0].fp.e[inEdge2] = EDGE3
			c[0].fp.e[outEdge2] = EDGE4

			c[1].v.Set( h.x, h.y )
			c[1].fp.e[inEdge2] = EDGE4
			c[1].fp.e[outEdge2] = EDGE1
		else

			c[0].v.Set( -h.x, h.y )
			c[0].fp.e[inEdge2] = EDGE1
			c[0].fp.e[outEdge2] = EDGE2

			c[1].v.Set( -h.x, -h.y )
			c[1].fp.e[inEdge2] = EDGE2
			c[1].fp.e[outEdge2] = EDGE3
		endif
	else
	
		if ( Sign(n.y) &gt; 0 )

			c[0].v.Set( h.x, h.y )
			c[0].fp.e[inEdge2] = EDGE4
			c[0].fp.e[outEdge2] = EDGE1

			c[1].v.Set( -h.x, h.y )
			c[1].fp.e[inEdge2] = EDGE1
			c[1].fp.e[outEdge2] = EDGE2
		else

			c[0].v.Set( -h.x, -h.y )
			c[0].fp.e[inEdge2] = EDGE2
			c[0].fp.e[outEdge2] = EDGE3

			c[1].v.Set( h.x, -h.y )
			c[1].fp.e[inEdge2] = EDGE3
			c[1].fp.e[outEdge2] = EDGE4
		endif
	endif

'	c[0].v = Pos + Rot * c[0].v
'	c[1].v = Pos + Rot * c[1].v
End Function

'/**
' *
' */
Function Collide:int( contacts:TContact, bodyA:TBody, bodyB:TBody )
	
End Function
</textarea><br><br>It compiles any way. So i guess we can sync up all the other classes that use arrays to the main lists by using the TList.toArray( ) thing. Or will that create new instances of each object or something (I guess thats realy implausable). So is that all the files now (after collide is finished)?<br><br>I have a feeling that loads of bugs are gna fly up when we join these. I cant wait to see it working though. <br><br></td></tr></table><br>
<a name="730850"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok we will wait to get the demo ported then. I too fear there will be some bugs when we link things together. However I will tell you that I can compile everything together so that's something. The last thing we need to do is port main.cpp. I am starting on that now so it should be done soon. <br><br></td></tr></table><br>
<a name="730855"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool, ok well I'll finish of the collision file now then.<br>Even if you just port one of the tests then we can test it.<br><br>This better be cool, I think i'll be equaly scaird if it just worked :) <br><br></td></tr></table><br>
<a name="730886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> I WISH THAT BLITZ MAX SUPPORTS OPERATOR DEFENITIONS!!!!<br><br>BlitzMax + OPPERATORS = Sweet! <br><br></td></tr></table><br>
<a name="730892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> Big Ditto <br><br></td></tr></table><br>
<a name="731086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> How is it going on collide?<br>Here is the first demo ported over in main.bmx:<br>(Maybe it will work at first go. It builds fine at least.)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Include "mathutils.bmx"
Include "body.bmx"
Include "joint.bmx"
Include "arbiter.bmx"
Include "collide.bmx"
Include "World.bmx"

Graphics 800,600

Global DeltaTime:Float = 1.0 / 60.0

Global _World:TWorld = World(Vec2(0.0, -10.0), 10)
Global Bomb:TBody

'* Demo 1 "A single box"
Local Ground:TBody = Body()
Ground.Set(Vec2(100.0, 20.0), FLT_MAX)
Ground.Position.Set(0.0, -0.5 * Ground.Width.Y)
_World.Add(Ground)

Local Box:TBody = Body()
Box.Set(Vec2(1.0, 1.0), 100.0)
Box.position.Set(0.0, 4.0)
_World.Add(Box)

While Not KeyHit(KEY_ESCAPE)
	If KeyHit(KEY_SPACE)
		LaunchBomb
	End If
	
	Cls
	_World._Step(DeltaTime)
	For Local b:TBody = EachIn _World.bodies
		DrawBody(b)
	Next
	For Local j:TJoint = EachIn _World.joints
		DrawJoint(j)
	Next
	DrawText("Demo 1",0,0)
	DrawText("Press Space to Launch the Bomb",0,15)
	Flip
Wend

Function DrawBody (body:Tbody)
	Local R:TMat22 = Mat22_Angle(body.rotation)
	Local x:TVec2 = body.Position
	Local h:TVec2 = MultFloatVec2(0.5, body.width)

	Local v1:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(-h.x, -h.y)))
	Local v2:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(h.x, -h.y)))
	Local v3:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(h.x, h.y)))
	Local v4:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(-h.x, h.y)))

	If (body = Bomb)
		SetColor 128,255,128
	Else
		SetColor 200,200,255
	End If
	
	DrawLine v1.x, v1.y, v2.x, v2.y
	DrawLine v2.x, v2.y, v3.x, v3.y
	DrawLine v3.x, v3.y, v4.x, v4.y
	DrawLine v4.x, v4.y, v1.x, v1.y
End Function

Function DrawJoint (joint:TJoint)
	Local b1:TBody = joint.body1
	Local b2:TBody = joint.body2

	Local R1:TMat22 Mat22_Angle(b1.rotation)
	Local R2:TMat22 Mat22_Angle(b2.rotation)

	Local x1:TVec2 = b1.position
	Local p1:TVec2 = AddVec2Vec2(x1, MultMat22Vec2(R1, joint.localAnchor1))

	Local x2:TVec2 = b2.position
	Local p2:TVec2 = AddVec2Vec2(x2, MultMat22Vec2(R2, joint.localAnchor2))

	SetColor 128,128,200

	DrawLine x1.x, x1.y, p1.x, p1.y
	DrawLine p1.x, p1.y, x2.x, x2.y
	DrawLine x2.x, x2.y, p2.x, p2.y
	DrawLine p2.x, p2.y, x1.x, x1.y
End Function

Function LaunchBomb ()
	If (Not bomb)
		Bomb = Body()
		Bomb.Set(Vec2(1.0, 1.0), 50.0)
		Bomb.Friction = 0.2
		_World.Add(Bomb)
	End If

	Bomb.position.Set(Random2(-15.0, 15.0), 15.0)
	Bomb.rotation = Random2(-1.5, 1.5)
	Bomb.velocity = MultFloatVec2(-1.5, Bomb.position)
	Bomb.angularVelocity = Random2(-20.0, 20.0)
End Function
</textarea> <br><br></td></tr></table><br>
<a name="731488"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, Its taking a little while partly because of my course work and because I'm having to wade through Vector math without the use of opperators. I'v converted everything apart from the vector math in the last function Collide so I will try and have that done by tmrw then lets see what happens.<br><br>:) <br><br></td></tr></table><br>
<a name="731530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stu_ovine</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> Keep going..... it'll be really interesting and useful when you've done it. <br><br></td></tr></table><br>
<a name="731575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pantheon,<br><br>I understand :) Been there before too. Finish it when you have time. Yes it would be so much easier with opperator definitions.<br><br>OvineByDesign,<br>Thanks for your support, first demo shouldn't be too far off. <br><br></td></tr></table><br>
<a name="731629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work lads, remember we are rooting for you! <br><br></td></tr></table><br>
<a name="732900"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Just to let you know that im still working on the code, all be it realy slowly. I have loads of course work to submit by tomorow and one peice on friday. Im sorry for this stall but after that then loads of my time will be with BlitzMax. :) <br><br></td></tr></table><br>
<a name="733014"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> No problem :) Finals week right? Good luck! <br><br></td></tr></table><br>
<a name="736631"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey,<br>I hope people dont think i've lost intrest in this project. My Uni is just sucking rite now. Im feelin bad about not being able to move forward with this rite now.<br>Just too much to do and not enough time. I feel bad because I realy wana start properly on this. <br><br></td></tr></table><br>
<a name="737096"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert Cummings</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> We have the faith in you <br><br></td></tr></table><br>
<a name="738200"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >aristid</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> looking forward to it. <br><br></td></tr></table><br>
<a name="738652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its probaly more fair if I post the code we have so far for others while I am occupied. So here is a complete post of all the files so far. Note: Collide.bmx only needs some vector and matrix equations converted. I've commented out the work still to be completed so it should run, but with major errors however. It should be debugable however.<br><br>arbiter.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

'/**
' *
' */
Const inEdge1:Int = 0
Const inEdge2:Int = 1
Const outEdge1:Int = 2
Const outEdge2:Int = 3

'/**
' *
' */
Type TFeaturePair

	Field e:Byte Ptr
	Field key:Int

	Method New( )
		e = Byte Ptr( Varptr( key ) )
	End Method
End Type

'/**
' *
' */
Type TContact

	Field position:TVec2
	Field normal:TVec2
	Field separation:Float
	Field accumulatedNormalImpulse:Float
	Field accumulatedTangentImpulse:Float
	Field massNormal:Float, massTangent:Float
	Field bias:Float
	Field feature:TFeaturePair;
End Type

'/**
' *
' */
Function Arbiter:TArbiter( a:TBody, b:TBody )

	Local nArb:TArbiter = New TArbiter
	nArb.body1 = a
	nArb.body2 = b
	nArb.numContacts = Collide( nArb.contacts[TArbiter.MAX_POINTS], nArb.body1, nArb.body2 )
	nArb.friction = Sqr( nArb.body1.friction * nArb.body2.friction )
	Return nArb
End Function

'/**
' *
' */
Type TArbiter

	Const MAX_POINTS:Int = 2
	
	Field contacts:TContact[MAX_POINTS]
	Field numContacts:Int
	Field body1:TBody
	Field body2:TBody
	Field friction:Float
		
	Method Update( newContacts:TContact[], numNewContacts:Int )
	
		Local i:Int, j:Int, k:Int
		Local mergedContacts:TContact[2]

		For i = 0 To numNewContacts-1
		
			Local cNew:TContact = newContacts[ i ]
			k = -1
			
			For j = 0 To numContacts-1

				Local cOld:TContact = contacts[ j ]
				
				If cNew.feature.key = cOld.feature.key
				
					k = j
					Exit
				EndIf
			Next	

			If k &gt; -1
			
				Local c:TContact = mergedContacts[i]
				Local cOld:TContact = contacts[k]
				c = cNew
				c.accumulatedNormalImpulse = cOld.accumulatedNormalImpulse
				c.accumulatedTangentImpulse = cOld.accumulatedTangentImpulse
			Else

				mergedContacts[i] = newContacts[i]
			EndIf
		Next

		For i = 0 To numNewContacts-1
		
			contacts[i] = mergedContacts[i]
		Next
		
		numContacts = numNewContacts
	End Method
	
	Method PreStep( inv_dt:Float )
	
		Local k_allowedPenetration:Float = Float( 0.01 )
		Local i:Int

 		For i = 0 To numContacts-1
		
			Local c:TContact = contacts[i]
			Local r1:TVec2 = SubVec2Vec2( c.position, body1.position )
			Local r2:TVec2 = SubVec2Vec2( c.position, body2.position )

			'// Precompute normal mass, tangent mass, And bias.
			Local rn1:Float = Dot( r1, c.normal )
			Local rn2:Float = Dot( r2, c.normal )
			Local kNormal:Float = body1.invMass + body2.invMass
			kNormal :+ body1.invI * (Dot(r1, r1) - rn1 * rn1)
			kNormal :+ body2.invI * (Dot(r2, r2) - rn2 * rn2)
			c.massNormal = 1.0 / kNormal

			Local tangent:TVec2 = CrossVec2Float( c.normal, 1 )
			Local rt1:Float = Dot( r1, tangent )
			Local rt2:Float = Dot( r2, tangent )
			Local kTangent:Float = body1.invMass + body2.invMass
			kTangent :+ body1.invI*(Dot(r1, r1)-rt1*rt1)+body2.invI*(Dot(r2, r2)-rt2*rt2)
			c.massTangent = 1 / kTangent

			c.bias = -0.1 * inv_dt * Min(0, c.separation + k_allowedPenetration)
			
			'// Apply normal + friction impulse
			Local tVector1:TVec2 = c.normal.MultEx( c.accumulatedNormalImpulse )
			Local tVector2:TVec2 = tangent.MultEx( c.accumulatedTangentImpulse )
			Local impulse:TVec2 = AddVec2Vec2( tVector1, tVector2 )

			body1.velocity = AddVec2Vec2( body1.velocity, impulse.MultEx( body1.invMass ) )
			body1.angularVelocity :- CrossVec2Vec2( Impulse, r1 ) * body1.invI
			body2.velocity = AddVec2Vec2( body2.velocity, impulse.MultEx( body2.invMass ) )
			body2.angularVelocity :+ CrossVec2Vec2( Impulse, r2 ) * body2.invI
		Next
	End Method

	Method ApplyImpulse( )
	
		Local b1:TBody = body1
		Local b2:TBody = body2
	
		Local i:Int
	
		For i = 0 To numContacts-1
		
			Local c:TContact = contacts[i]
			Local r1:TVec2 = SubVec2Vec2( c.position, body1.position )
			Local r2:TVec2 = SubVec2Vec2( c.position, body2.position )
		
			'// Relative velocity at contact
			Local rv:TVec2 = AddVec2Vec2( b2.velocity, CrossFloatVec2( b2.angularVelocity, r2 ) )
			rv = SubVec2Vec2( rv, b1.velocity )
			rv = SubVec2Vec2( rv, CrossFloatVec2( b1.angularVelocity, r1 ) )
			Local dv:TVec2 = Vec2( rv.x, rv.y )
	
			'// Compute normal impulse with bias.
			Local vn:Float = Dot( dv, c.normal )
			Local normalImpulse:Float = c.massNormal * ( -vn + c.bias )
	
			'// Clamp the accumulated impulse
			Local oldNormalImpulse:Float = c.accumulatedNormalImpulse
			c.accumulatedNormalImpulse = Max( oldNormalImpulse + normalImpulse, 0 )
			normalImpulse = c.accumulatedNormalImpulse - oldNormalImpulse

			'// Apply contact impulse
			Local impulse:TVec2 = c.normal.MultEx( normalImpulse )
	
			b1.velocity = SubVec2Vec2( b1.velocity, impulse.multEx( b1.invMass ) )
			b1.angularVelocity :- CrossVec2Vec2( r1, impulse ) * b1.invI
	
			b2.velocity = SubVec2Vec2( b2.velocity, impulse.multEx( b2.invMass ) )
			b2.angularVelocity :+ CrossVec2Vec2( r2, impulse ) * b2.invI

			'// Compute friction impulse
			Local maxTangentImpulse:Float = friction * c.accumulatedNormalImpulse
	
			Local tangent:TVec2 = CrossVec2Float( c.normal, 1 )
			Local vt:Float = Dot( rv, tangent )
			Local tangentImpulse:Float = c.massTangent * (-vt)
	
			'// Clamp friction
			Local oldTangentImpulse:Float = c.accumulatedTangentImpulse
			c.accumulatedTangentImpulse = ClampFloat(oldTangentImpulse + tangentImpulse, -maxTangentImpulse, maxTangentImpulse)
			tangentImpulse = c.accumulatedTangentImpulse - oldTangentImpulse
	
			'// Apply contact impulse
			impulse = tangent.MultEx( tangentImpulse )
	
			b1.velocity = SubVec2Vec2( b1.velocity, impulse.MultEx( b1.invMass ) )
			b1.angularVelocity :- b1.invI * CrossVec2Vec2( r1, impulse )
	
			b2.velocity = SubVec2Vec2( b2.velocity, impulse.MultEx( b2.invMass ) )
			b2.angularVelocity :+ b2.invI * CrossVec2Vec2( r2, impulse )
			
		Next
	End Method
End Type
</textarea><br><br>body.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

'/**
' *
' */
Function Body:TBody()
	Local b:Tbody = New TBody
	b.position.Set(0.0, 0.0)
	b.rotation = 0.0
	b.velocity.Set(0.0, 0.0)
	b.angularVelocity = 0.0
	b.force.Set(0.0, 0.0)
	b.torque = 0.0
	b.friction = 0.2

	b.width.Set(1.0, 1.0)
	b.mass = FLT_MAX
	b.invMass = 0.0
	b.I = FLT_MAX
	b.invI = 0.0
	Return New TBody
End Function

'/**
' *
' */
Type TBody
	Field position:TVec2
	Field rotation:Float

	Field velocity:TVec2
	Field angularVelocity:Float

	Field force:TVec2
	Field torque:Float
	
	Field width:TVec2

	Field friction:Float
	Field mass:Float, invMass:Float
	Field I:Float, invI:Float

	Method New()
		position = New TVec2
		velocity = New TVec2
		force = New TVec2
		width = New TVec2
	End Method
	
	Method Set(w:TVec2, m:Float)
		position.Set(0.0, 0.0)
		rotation = 0.0
		velocity.Set(0.0, 0.0)
		angularVelocity = 0.0
		force.Set(0.0, 0.0)
		torque = 0.0
		friction = 0.2
	
		width = w
		mass = m
	
		If (mass &lt; FLT_MAX)
		
			invMass = 1.0 / mass
			I = mass * (width.x * width.x + width.y * width.y) / 12.0
			invI = 1.0 / I
		Else
		
			invMass = 0.0
			I = FLT_MAX
			invI = 0.0
		End If
	End Method
	
	Method AddForce (f:TVec2)
		force.AddV(f)
	End Method

End Type
</textarea><br><br>joint.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

Function Joint:TJoint ()
	Return New TJoint
End Function

Type TJoint

	Field M:TMat22
	Field localAnchor1:TVec2, localAnchor2:TVec2
	Field r1:TVec2, r2:TVec2
	Field bias:TVec2
	Field accumulatedImpulse:TVec2
	Field body1:TBody
	Field body2:TBody
	Field relaxation:Float
	
	Method New()
	
		AccumulatedImpulse = New TVec2
		Relaxation = 1.0
	End Method
	
	Method Set (b1:TBody,  b2:TBody, anchor:TVec2)
	
		body1 = b1
		body2 = b2
	
		Local Rot1:TMat22 = Mat22_Angle(body1.rotation)
		Local Rot2:TMat22 = Mat22_Angle(body2.rotation)
		Local Rot1T:TMat22 = Rot1.Transpose()
		Local Rot2T:TMat22 = Rot2.Transpose()
		localAnchor1 = MultMat22Vec2(Rot1T,  SubVec2Vec2(anchor, body1.position))
		localAnchor1 = MultMat22Vec2(Rot2T,  SubVec2Vec2(anchor, body2.position))
	
		accumulatedImpulse.Set(0.0, 0.0)
		relaxation = 1.0
	End Method

	Method  PreStep(inv_dt:Float)
		' Pre-compute anchors, mass matrix, And bias.
		Local Rot1:TMat22 = Mat22_Angle(body1.rotation)
		Local Rot2:TMat22 = Mat22_Angle(body2.rotation)
		
		r1 = MultMat22Vec2(Rot1, localAnchor1)
		r2 = MultMat22Vec2(Rot2, localAnchor2)
	
		' deltaV = deltaV0 + K * impulse
		' invM = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
		'      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
		'        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
		Local K1:TMat22 = New TMat22
		K1.col1.x = body1.invMass + body2.invMass;	K1.col2.x = 0.0
		K1.col1.y = 0.0; 							K1.col2.y = body1.invMass + body2.invMass
	
		Local K2:TMat22
		K2.col1.x =  body1.invI * r1.y * r1.y;		K2.col2.x = -body1.invI * r1.x * r1.y
		K2.col1.y = -body1.invI * r1.x * r1.y;		K2.col2.y =  body1.invI * r1.x * r1.x
	
		Local K3:TMat22
		K3.col1.x =  body2.invI * r2.y * r2.y;		K3.col2.x = -body2.invI * r2.x * r2.y;
		K3.col1.y = -body2.invI * r2.x * r2.y;		K3.col2.y =  body2.invI * r2.x * r2.x;
	
		Local K:TMat22 = AddMat22Mat22(AddMat22Mat22(K1, K2), K3)
		M = K.Invert()
	
		Local p1:TVec2 = AddVec2Vec2(body1.position, r1)
		Local p2:TVec2 = AddVec2Vec2(body2.position, r2)
		Local dp:TVec2 = SubVec2Vec2(p2, p1)
		bias = MultFloatVec2((-0.1 * inv_dt), dp)
	
	
		'Apply accumulated impulse.
		accumulatedImpulse.Mult(relaxation)
	
		body1.velocity.SubV(MultFloatVec2(body1.invMass, accumulatedImpulse))
		body1.angularVelocity :- body1.invI * CrossVec2Vec2(r1, accumulatedImpulse)
	
		body2.velocity.AddV(MultFloatVec2(body2.invMass, accumulatedImpulse))
		body2.angularVelocity :+ body2.invI * CrossVec2Vec2(r2, accumulatedImpulse)
	End Method
	
	Method ApplyImpulse()
	
		Local dv:TVec2 = AddVec2Vec2(body2.velocity, CrossFloatVec2(body2.angularVelocity, r2))
		dv.SubV(SubVec2Vec2(body1.velocity, CrossFloatVec2(body1.angularVelocity, r1)))

		Local impulse:TVec2 = MultMat22Vec2(M, AddVec2Vec2(dv.Reverse(), bias))
	
		body1.velocity.SubV(MultFloatVec2(body1.invMass,impulse))
		body1.angularVelocity :-  body1.invI * CrossVec2Vec2(r1, impulse)
	
		body2.velocity.AddV(MultFloatVec2(body2.invMass,  impulse))
		body2.angularVelocity :+ body2.invI * CrossVec2Vec2(r2, impulse)
	
		accumulatedImpulse.AddV(impulse)
	End Method
	
End Type
</textarea><br><br>world.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto &lt;a href="http://www.gphysics.com" target="_blank"&gt;www.gphysics.com&lt;/a&gt;
*
* Permission to use, copy, modify, distribute and sell this software
* and its documentation for any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software for any purpose.  
* It is provided "as is" without express or implied warranty.
End Rem

Function  World:TWorld (gravity:TVec2, iterations:Int)
	Local w:TWorld = New TWorld
	w.gravity = gravity
	w.iterations = iterations
	Return w
End Function
Type TWorld
	Field Bodies:TList
	Field Joints:TList
	Field Arbiters:TList
	Field Gravity:TVec2
	Field iterations:Int
	Method New()
		Bodies = CreateList()
		Joints = CreateList()
		Arbiters = CreateList()
		Gravity = Vec2(0.0,0.0)
	End Method
	Method Add ( obj:Object )
		If TBody(obj) Bodies.AddLast(obj)
		If TJoint(obj) Joints.AddLast(obj)
	End Method
	Method Clear()
		Bodies.Clear
		Joints.Clear
		Arbiters.Clear
	End Method
	
	Method BroadPhase()
		' O(n^2) broad-phase
		Local BodiesArray:Object [] = Bodies.ToArray()
		For Local i:Int = 0 To BodiesArray.Length - 1
			Local bi:Tbody = TBody(BodiesArray[i])
			For Local j:Int = i + 1 To BodiesArray.Length - 1
				Local bj:TBody = TBody(BodiesArray[j])
				If (bi.invMass = 0.0 And bj.invMass = 0.0) Continue
				Local newArb:TArbiter = Arbiter(bi, bj)
				If (newArb.numContacts &gt; 0)
					'Not sure what is being accomplished here:
					Local arb:TLink = Arbiters.FindLink(newArb)
					'ArbIter arb = arbiters.find(newArb)
					If (arb = Arbiters.LastLink())
						Arbiters.AddLast(newArb)
					Else
						TArbiter(arb.Value()).Update(newArb.contacts, newArb.numContacts)
					End If
				Else
					Arbiters.Remove(newArb)
				End If
			Next
		Next
	End Method
	
	Method _Step (dt:Float)
		Local inv_dt:Float
		If dt &gt; 0.0 Then inv_dt = 1.0 / dt Else inv_dt = 0.0
		BroadPhase()
		Local BodiesArray:Object [] = Bodies.ToArray()
		For Local i:Int = 0 To BodiesArray.Length -1
			Local b:TBody = TBody(BodiesArray[i])
			
			If (b.invMass = 0.0)	Continue
	
			b.velocity.AddV(MultFloatVec2(dt,(AddVec2Vec2(gravity, MultFloatVec2(b.invMass, b.force)))))
			b.angularVelocity :+ dt * b.invI * b.torque
		Next

		For Local arb:TArbiter = EachIn Arbiters
			arb.PreStep(inv_dt)
		Next

		Local JointsArray:Object [] = Bodies.ToArray()
		For Local i:Int = 0 To JointsArray.Length - 1
			TJoint(JointsArray[i]).PreStep(inv_dt)
		Next

		For Local i:Int = 0 To iterations
			For Local arb:TArbiter = EachIn Arbiters
				arb.ApplyImpulse()
			Next
			For Local j:Int = 0 To JointsArray.Length - 1
				TJoint(JointsArray[j]).ApplyImpulse()
			Next
		Next

		For Local i:Int = 0 To BodiesArray.Length - 1
			Local b:TBody = TBody(BodiesArray[i])
			b.position.AddV(MultFLoatVec2(dt,b.velocity))
			b.rotation :+ dt * b.angularVelocity
	
			b.force.Set(0.0, 0.0)
			b.torque = 0.0
		Next
	End Method
End Type
</textarea><br><br>mathutils.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto &lt;a href="http://www.gphysics.com" target="_blank"&gt;www.gphysics.com&lt;/a&gt;
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

Const FLT_MAX:Float = 10^37

Function Vec2:TVec2 (_x:Float, _y:Float) 'Constructor
	Local v:TVec2 = New TVec2
	v.X = _x
	v.Y = _y
	Return v
End Function

Type TVec2

	Field x:Float, y:Float
	
	Method Set(_x:Float, _y:Float)
		X = _x
		Y = _y
	End Method
	
	Method Reverse:TVec2() '-()
		Return Vec2(-X, -Y)
	End Method
	
	Method AddV(v:TVec2) '+=
		X :+ v.X
		y :+ v.Y
	End Method
	
	Method SubV(v:TVec2) '-=
		X :- v.X
		y :- v.Y
	End Method
	
	Method Mult(a:Float) '*=
		x :* a
		y :* a
	End Method
	
	Method Neg( )
		x =-x
		y =-y
	End Method
	
	Method MultEx:TVec2( a:Float )
		Local nVec2:TVec2 = New TVec2
		nVec2.x = x*a
		nVec2.y = y*a
		Return nVec2	
	End Method
	
	Method NegEx:TVec2( )
		Local nVec2:TVec2 = New TVec2
		nVec2.x =-x
		nVec2.y =-y
		Return nVec2
	End Method

	Method Length:Float ()
		Return Sqr(X * X + Y * Y)
	End Method

End Type

Function Mat22:TMat22(_col1:TVec2,_col2:TVec2) 'Constructor
	Local m:TMat22 = New TMat22
	m.col1 = _col1
	m.col2 = _col2
	Return m 
End Function

Function Mat22_Angle:TMat22(angle:Float) 'Constructor from angle
	Local m:TMat22 = New TMat22
	Local c:Float = Float(Cos(angle)), s:Float = Float(Sin(angle))
	m.col1.X = c
	m.col2.X = -s
	m.col1.Y = s
	m.col2.Y = c
	Return m 
End Function
	
Type TMat22

	Field col1:TVec2
	Field col2:TVec2
	
	Method New()
		col1 = New TVec2
		col2 = New TVec2
	End Method
	
	Method Transpose:TMat22()
		Return Mat22(Vec2(col1.X, col2.X), Vec2(col1.Y, col2.Y))
	End Method
	
	Method Invert:TMat22()
		Local a:Float = col1.x, b:Float = col2.x, c:Float = col1.y, d:Float = col2.y
		Local E:TMat22
		Local det:Float = a * d - b * c
		Assert (det &lt;&gt; 0.0),"Error: Type Mat22&gt;Invert"
		det = 1.0 / det
		E.col1.X =  det * d
		E.col2.x = -det * b
		
		E.col1.Y = -det * c
		E.col2.y =  det * a
		Return E
	End Method
	
End Type

Function Dot:Float(a:TVec2, b:TVec2)
	Return a.X * b.X + a.X * b.X
End Function

Function CrossVec2Vec2:Float(a:TVec2, b:TVec2)
	Return a.X * b.Y - a.Y * b.X
End Function

Function CrossVec2Float:TVec2(a:TVec2, s:Float)
	Return Vec2(s * a.Y, -s * a.X)
End Function

Function CrossFloatVec2:TVec2(s:Float, a:TVec2)
	Return Vec2(-s * a.Y, s * a.X)
End Function

Function MultMat22Vec2:TVec2 (A:TMat22, v:TVec2)
	Return Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y)
End Function

Function AddVec2Vec2:TVec2 (a:TVec2, b:TVec2)
	Return Vec2(a.x + b.x, a.y + b.y)
End Function

Function SubVec2Vec2:TVec2 (a:TVec2, b:TVec2)
	Return Vec2(a.x - b.x, a.y - b.y)
End Function

Function MultFloatVec2:TVec2 (s:Float, v:TVec2)
	Return Vec2(s * v.x, s * v.y)
End Function

Function AddMat22Mat22:TMat22 (A:TMat22, B:TMat22)
	Return Mat22(AddVec2Vec2(A.col1, B.col1), AddVec2Vec2(A.col2, B.col2))
End Function

Function MultMat22Mat22:TMat22 (A:TMat22, B:TMat22)
	Return Mat22(MultMat22Vec2(A, B.col1), MultMat22Vec2(A, B.col2))
End Function

Function AbsoluteVec2:TVec2(a:TVec2)
	Return Vec2(Abs(a.x), Abs(a.y))
End Function

Function AbsoluteMat22:TMat22 (A:TMat22)
	Return Mat22(AbsoluteVec2(A.col1), AbsoluteVec2(A.col2))
End Function

Function Sign:Float(x:Float)
	Return Sgn(x)
End Function

Function MinFloat:Float(a:Float, b:Float)
	If a &lt; b Return a Else Return b
End Function

Function MaxFloat:Float(a:Float, b:Float)
	If a &gt; b Return a Else Return b
End Function

Function ClampFloat:Float(a:Float, low:Float, high:Float)
	Return MaxFloat(low, MinFloat(a, high))
End Function

Function Swap(a:Object, b:Object)
	Local tmp:Object = a
	a = b
	b = tmp
End Function

' Random number in range [-1,1]
Function Random:Float()
	Return Float(Rnd(-1,1))
End Function

Function Random2:Float(lo:Float, hi:Float)
	Return Float(Rnd(lo,hi))
End Function
</textarea><br><br>main.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem
SuperStrict

Include "Source\MathUtils.bmx"
Include "Source\Arbiter.bmx"
Include "Source\Body.bmx"
Include "Source\Collide.bmx"
Include "Source\Joint.bmx"
Include "Source\World.bmx"

Graphics 800,600

Global DeltaTime:Float = 1.0 / 60.0

Global _World:TWorld = World(Vec2(0.0, -10.0), 10)
Global Bomb:TBody

'* Demo 1 "A single box"
Local Ground:TBody = Body()
Ground.Set(Vec2(100.0, 20.0), FLT_MAX)
Ground.Position.Set(0.0, -0.5 * Ground.Width.Y)
_World.Add(Ground)

Local Box:TBody = Body()
Box.Set(Vec2(1.0, 1.0), 100.0)
Box.position.Set(0.0, 4.0)
_World.Add(Box)

While Not KeyHit(KEY_ESCAPE)
	If KeyHit(KEY_SPACE)
		LaunchBomb
	End If
	
	Cls
	_World._Step(DeltaTime)
	For Local b:TBody = EachIn _World.bodies
		DrawBody(b)
	Next
	For Local j:TJoint = EachIn _World.joints
		DrawJoint(j)
	Next
	DrawText("Demo 1",0,0)
	DrawText("Press Space to Launch the Bomb",0,15)
	Flip
Wend

Function DrawBody (body:Tbody)
	Local R:TMat22 = Mat22_Angle(body.rotation)
	Local x:TVec2 = body.Position
	Local h:TVec2 = MultFloatVec2(0.5, body.width)

	Local v1:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(-h.x, -h.y)))
	Local v2:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(h.x, -h.y)))
	Local v3:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(h.x, h.y)))
	Local v4:TVec2 = AddVec2Vec2(x, MultMat22Vec2(R, Vec2(-h.x, h.y)))

	If (body = Bomb)
		SetColor 128,255,128
	Else
		SetColor 200,200,255
	End If
	
	DrawLine v1.x, v1.y, v2.x, v2.y
	DrawLine v2.x, v2.y, v3.x, v3.y
	DrawLine v3.x, v3.y, v4.x, v4.y
	DrawLine v4.x, v4.y, v1.x, v1.y
End Function

Function DrawJoint (joint:TJoint)
	Local b1:TBody = joint.body1
	Local b2:TBody = joint.body2

	Local R1:TMat22 Mat22_Angle(b1.rotation)
	Local R2:TMat22 Mat22_Angle(b2.rotation)

	Local x1:TVec2 = b1.position
	Local p1:TVec2 = AddVec2Vec2(x1, MultMat22Vec2(R1, joint.localAnchor1))

	Local x2:TVec2 = b2.position
	Local p2:TVec2 = AddVec2Vec2(x2, MultMat22Vec2(R2, joint.localAnchor2))

	SetColor 128,128,200

	DrawLine x1.x, x1.y, p1.x, p1.y
	DrawLine p1.x, p1.y, x2.x, x2.y
	DrawLine x2.x, x2.y, p2.x, p2.y
	DrawLine p2.x, p2.y, x1.x, x1.y
End Function

Function LaunchBomb ()
	If (Not bomb)
		Bomb = Body()
		Bomb.Set(Vec2(1.0, 1.0), 50.0)
		Bomb.Friction = 0.2
		_World.Add(Bomb)
	End If

	Bomb.position.Set(Random2(-15.0, 15.0), 15.0)
	Bomb.rotation = Random2(-1.5, 1.5)
	Bomb.velocity = MultFloatVec2(-1.5, Bomb.position)
	Bomb.angularVelocity = Random2(-20.0, 20.0)
End Function
</textarea><br><br>collide.bmx<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
* Copyright (c) 2006 Erin Catto http://www.gphysics.com"
*
* Permission To use, copy, modify, distribute And sell this software
* And its documentation For any purpose is hereby granted without fee,
* provided that the above copyright notice appear in all copies.
* Erin Catto makes no representations about the suitability 
* of this software For any purpose.  
* It is provided "as is" without express Or implied warranty.
End Rem

'/**
' *
' */
Type TAxis
	Const FACE_A_X:Int	= 1
	Const FACE_A_Y:Int	= 2
	Const FACE_B_X:Int	= 3
	Const FACE_B_Y:Int	= 4
End Type

'/**
' *
' */
'Type EdgeNumbers
	Const NO_EDGE:Int	= 0
	Const EDGE1:Int		= 1
	Const EDGE2:Int		= 2
	Const EDGE3:Int		= 3
	Const EDGE4:Int		= 4
'End Type

'/**
' *
' */
Type TClipVertex

	Field v:TVec2
	Field fp:TFeaturePair
	
End Type

'/**
' *
' */
Function _Flip( fp:TFeaturePair )
	'Swap( fp.e[ inEdge1 ], fp.e[ inEdge2 ] )
	'Swap( fp.e[outEdge1 ], fp.e[outEdge2 ] )
End Function

'/**
' *
' */
Function ClipSegmentToLine:Int( vOut:TClipVertex[], vIn:TClipVertex[], normal:TVec2, Offset:Float, ClipEdge:Int )
	'// Start with no output points
	Local numOut:Int = 0

	'// Calculate the distance of end points to the line
	Local distance0:Float = Dot( normal, vIn[0].v ) - Offset
	Local distance1:Float = Dot( normal, vIn[1].v ) - Offset

	'// If the points are behind the plane
	If ( distance0 &lt;= 0 ) vOut[numOut] = vIn[0];
	If ( distance1 &lt;= 0 ) vOut[numOut+1] = vIn[1];
	numOut :+2

	'// If the points are on different sides of the plane
	If ( distance0 * distance1 &lt; 0 )

		'// Find intersection point of edge and plane
		Local interp:Float = distance0 / (distance0 - distance1)
		vOut[numOut].v = subVec2Vec2( vIn[1].v, vIn[0].v ).MultEx( interp )
		vOut[numOut].v = addVec2Vec2( vIn[0].v, vOut[numOut].v )
		If ( distance0 &gt; 0 )

			vOut[numOut].fp = vIn[0].fp;
			vOut[numOut].fp.e[inEdge1] = clipEdge
			vOut[numOut].fp.e[inEdge2] = NO_EDGE
		Else

			vOut[numOut].fp = vIn[1].fp
			vOut[numOut].fp.e[outEdge1] = clipEdge
			vOut[numOut].fp.e[outEdge2] = NO_EDGE
		EndIf

		numOut :+1
	EndIf

	Return numOut
End Function

'/**
' *
' */
Function ComputeIncidentEdge( c:TClipVertex[], h:TVec2, Pos:TVec2, Rot:TMat22, normal:TVec2 )	
	'// The normal is from the reference box. Convert it
	'// to the incident boxe's frame and flip sign.
	Local RotT:TMat22 = Rot.Transpose( )
	Local n:TVec2 = MultMat22Vec2( RotT, normal )
	n.Neg( )
	Local nAbs:TVec2 = AbsoluteVec2( n )

	If ( nAbs.x &gt; nAbs.y )

		If ( Sign( n.x ) &gt; 0 )

			c[0].v.Set( h.x, -h.y )
			c[0].fp.e[inEdge2] = EDGE3
			c[0].fp.e[outEdge2] = EDGE4

			c[1].v.Set( h.x, h.y )
			c[1].fp.e[inEdge2] = EDGE4
			c[1].fp.e[outEdge2] = EDGE1
		Else

			c[0].v.Set( -h.x, h.y )
			c[0].fp.e[inEdge2] = EDGE1
			c[0].fp.e[outEdge2] = EDGE2

			c[1].v.Set( -h.x, -h.y )
			c[1].fp.e[inEdge2] = EDGE2
			c[1].fp.e[outEdge2] = EDGE3
		EndIf
	Else
	
		If ( Sign(n.y) &gt; 0 )

			c[0].v.Set( h.x, h.y )
			c[0].fp.e[inEdge2] = EDGE4
			c[0].fp.e[outEdge2] = EDGE1

			c[1].v.Set( -h.x, h.y )
			c[1].fp.e[inEdge2] = EDGE1
			c[1].fp.e[outEdge2] = EDGE2
		Else

			c[0].v.Set( -h.x, -h.y )
			c[0].fp.e[inEdge2] = EDGE2
			c[0].fp.e[outEdge2] = EDGE3

			c[1].v.Set( h.x, -h.y )
			c[1].fp.e[inEdge2] = EDGE3
			c[1].fp.e[outEdge2] = EDGE4
		EndIf
	EndIf

'	c[0].v = Pos + Rot * c[0].v
'	c[1].v = Pos + Rot * c[1].v
End Function

'/**
' *
' */
Function Collide:Int( contacts:TContact, bodyA:TBody, bodyB:TBody )
	'// Setup
	Local hA:TVec2 = bodyA.width.MultEx( 0.5 )
	Local hB:TVec2 = bodyB.width.MultEx( 0.5 )

	Local posA:TVec2 = bodyA.position
	Local posB:TVec2 = bodyB.position

	Local RotA:TMat22 = MAT22_Angle( bodyA.rotation )
	Local RotB:TMat22 = MAT22_Angle( bodyB.rotation )

	Local RotAT:TMat22 = RotA.Transpose( )
	Local RotBT:TMat22 = RotB.Transpose( )

	Local a1:TVec2 = RotA.col1
	Local a2:TVec2 = RotA.col2
	Local b1:TVec2 = RotB.col1
	Local b2:TVec2 = RotB.col2

	Local dp:TVec2 = SubVec2Vec2( posB, posA )
	Local dA:TVec2 = MultMat22Vec2( RotAT, dp )
	Local dB:TVec2 = MultMat22Vec2( RotBT, dp )
	
	Local C:TMat22 = MultMat22Mat22( RotAT, RotB )
	Local absC:TMat22 = AbsoluteMat22( C )
	Local absCT:TMat22 = absC.Transpose()

	'// Box A faces
	Local faceA:TVec2 = AbsoluteVec2( dA )' - hA - absC * hB
	If (faceA.x &gt; 0 Or faceA.y &gt; 0)
		Return 0
	EndIf

	'// Box B faces
	Local faceB:TVec2 = AbsoluteVec2( dB )' - absCT * hA - hB
	If (faceB.x &gt; 0 Or faceB.y &gt; 0)
		Return 0
	EndIf

	'// Find best axis
	Local axis:Int
	Local separation:Float
	Local normal:TVec2

	'// Box A faces
	axis = TAxis.FACE_A_X
	separation = faceA.x
	If ( dA.x &gt; 0 )
		normal = RotA.col1
	Else
		normal = RotA.col1.NegEx( )
	EndIf

	If (faceA.y &gt; (1.05 * separation + 0.01 * hA.y))
		axis = TAxis.FACE_A_Y
		separation = faceA.y
		If (dA.y &gt; 0)
			normal = RotA.col2
		Else
			normal = RotA.col2.NegEx( )
		EndIf
	EndIf

	'// Box B faces
	If (faceB.x &gt; (1.05 * separation + 0.01 * hB.x))
		axis = TAxis.FACE_B_X
		separation = faceB.x
		If (dB.x &gt; 0)
			normal = RotB.col1
		Else
			normal = RotB.col1.NegEx( )
		EndIf
	EndIf

	If (faceB.y &gt; 1.05 * separation + 0.01 * hB.y)
		axis = TAxis.FACE_B_Y
		separation = faceB.y;
		If (dB.y &gt; 0.0)
			normal = RotB.col2
		Else
			normal = RotB.col2.NegEx( )
		EndIf
	EndIf

Rem

	'// Setup clipping plane data based on the separating axis
	Local frontNormal:TVec2
	Local sideNormal:TVec2
	Local incidentEdge:TClipVertex[2]
	Local front:Float, negSide:Float, posSide:Float
	Local negEdge:Byte, posEdge:Byte

	'// Compute the clipping lines And the line segment To be clipped
	Select (axis)
	Case TAxis.FACE_A_X

		frontNormal = normal
		front = Dot(posA, frontNormal) + hA.x
		sideNormal = RotA.col2
		Float side = Dot(posA, sideNormal)
		negSide = -side + hA.y
		posSide =  side + hA.y
		negEdge = EDGE3
		posEdge = EDGE1
		ComputeIncidentEdge(incidentEdge, hB, posB, RotB, frontNormal)
	Case TAxis.FACE_A_Y

		frontNormal = normal
		front = Dot(posA, frontNormal) + hA.y
		sideNormal = RotA.col1
		Float side = Dot(posA, sideNormal)
		negSide = -side + hA.x
		posSide =  side + hA.x
		negEdge = EDGE2
		posEdge = EDGE4
		ComputeIncidentEdge(incidentEdge, hB, posB, RotB, frontNormal)
	Case TAxis.FACE_B_X

		frontNormal = -normal
		front = Dot(posB, frontNormal) + hB.x
		sideNormal = RotB.col2
		Float side = Dot(posB, sideNormal)
		negSide = -side + hB.y
		posSide =  side + hB.y
		negEdge = EDGE3
		posEdge = EDGE1
		ComputeIncidentEdge( incidentEdge, hA, posA, RotA, frontNormal )
	Case TAxis.FACE_B_Y

		frontNormal = -normal
		front = Dot(posB, frontNormal) + hB.y
		sideNormal = RotB.col1
		Float side = Dot(posB, sideNormal)
		negSide = -side + hB.x
		posSide =  side + hB.x
		negEdge = EDGE2
		posEdge = EDGE4
		ComputeIncidentEdge( incidentEdge, hA, posA, RotA, frontNormal )
	End Select

	'// clip other face with 5 box planes (1 face plane, 4 edge planes)
	Local clipPoints1:TClipVertex[2]
	Local clipPoints2:TClipVertex[2]
	Local np:Int

	'// Clip To box side 1
	np = ClipSegmentToLine( clipPoints1, incidentEdge,-sideNormal, negSide, negEdge )

	If (np &lt; 2)
		Return 0
	EndIf

	'// Clip To negative box side 1
	np = ClipSegmentToLine( clipPoints2, clipPoints1,  sideNormal, posSide, posEdge )

	If (np &lt; 2)
		Return 0
	EndIf

	'// Now clipPoints2 contains the clipping points.
	'// Due To roundoff, it is possible that clipping removes all points.

	Local numContacts:Int = 0, i:Int
	For i = 0 To 1
	
		Local separation:Float = Dot( frontNormal, clipPoints2[i].v ) - front

		If (separation &lt;= 0)

			contacts[numContacts].separation = separation
			contacts[numContacts].normal = normal
			'// slide contact point onto reference face (easy To cull)
			contacts[numContacts].position = clipPoints2[i].v - separation * frontNormal
			contacts[numContacts].feature = clipPoints2[i].fp
			If ((axis = FACE_B_X) Or (axis = FACE_B_Y))
				_Flip(contacts[numContacts].feature)
			EndIf
			numContacts:+1
		EndIf
	Next

	Return numContacts
	
End Rem
End Function
</textarea><br><br>Oh yeah, and merry christmas :) <br><br></td></tr></table><br>
<a name="745447"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stu_ovine</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> any more news on this yet ? ;) <br><br></td></tr></table><br>
<a name="745560"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, to be honest I haven't thought about this for a while. I was waiting on Pantheon to finish collide.bmx. I might try to finish it tonight, unless Pantheon already has (have you?).<br><br>But I still want this to go somewhere. Hopefully we can get this first demo running and then invite other coders to contribute to the actual engine. <br><br></td></tr></table><br>
<a name="746316"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt Merkulov</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very interesting and useful thing! Thanks! I'm making a 2D engine and will use this code (if it's freeware). It seems it'll fit there just right. Why you don't start a worklog? <br><br></td></tr></table><br>
<a name="746338"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well worklogs sort of defeat the idea of a community project. If you want to help us with this just let me know. Also there really isn't anything working right now. You might want to wait until then. <br><br></td></tr></table><br>
<a name="746347"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt Merkulov</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, are community projects productive? As I have seen so far, one or two people really works on the project while others just speaking or testing (though it helps a few).<br><br>Well, I was impressed by original engine, but how much is ported to blitz at this moment? And what help is needed? <br><br></td></tr></table><br>
<a name="746946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello,<br><br>Thats my exams out the way now :) sorry to keep you all waiting.<br><br>So I have the time for this project again. When I tried to run the project as it is so far there were a whole bunch of memory exception errors which isnt too cool. I have bought a 50 book on Game Physics by MK which im progressivly reading.<br><br>I was thinking that it mite be easier to code the physics library in C++ so as to take advantage of custom operators. The drawback is that debugging is very hard.<br><br>I think im being put off the direct port slightly due to not full understanding the implementation. It may be easier to code a loose physics framework and slowly build it up with impulse collision handling, which can easily be extended to the catto method. This way the library will be usefull to people with every update.<br><br>What is your thoughts altitudems? <br><br></td></tr></table><br>
<a name="747030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sure that sounds fine, I was still hoping to have at least some sort of demo to get people interested though. I know there are other interested in helping in particular the people from the MAX physics threads. <a href="http://www.blitzbasic.com/Community/posts.php?topic=52589" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=52589</a><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=52760" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=52760</a><br><br>If we start working on the engine now we should probably start a new thread. I'm thinking we should include an outline of the project, along with coding conventions, required mini projects, maybe goals? Like I said before I have graphics and logo's we can use. Let me know if you want to start a thread. I wonder if we should use google code for this. <br><br></td></tr></table><br>
<a name="747188"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stu_ovine</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> here here ....<br><br>Im sure theres enough of us that will test it for yer too (and maybe help out if possible) <br><br></td></tr></table><br>
<a name="747387"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> Outlining coding practice sounds like a good idea.<br><br>I tried to setup the google code thing a while ago, but it wouldnt give me an option so start a new project so perhaps someone with more experience with it should have a look.<br><br>If we start on the new engine then we could have a nice (simple) demo working quite soon. We could also post new demos with every feature release.<br><br>I think more progress would be made writing code that we have designed and thus intrinsicly know.<br><br>Features I would like to see:<br>o    Particle Dynamics<br>o    Rigid Body Dynamics<br>o    Soft Body Dynamics (the presure body model)<br>o    Combining Soft Body Dynamics with 2D metaballs 8D<br>o    Soft Constraints (penalty method (springs))<br>o    Hard Constraints (Catto proposed lazy impulses)<br>o    Friction, Stacking, etc.<br><br>Thats all I can think of off the top of my head (in no perticular order). Its all quite scalable and can be distributed easily threw out the development. Each new feature can build nicely on what has been developed before.<br><br>The Catto demo is realy nice and has most of the features everyone would want from a library. The good thing is that it came with a presentation paper so we can learn exactly what he proposed and extend out library with it.<br><br><pre class=code>

    _____          __  .__   project -            
   /     \   _____/  |_|__|__  __ ____  
  /  \ /  \ /  _ \   __\  \  \/ // __ \ 
 /    Y    (  &lt;_&gt; )  | |  |\   /\  ___/ 
 \____|__  /\____/|__| |__| \_/  \___  &gt;
         \/                          \/
</pre> <br><br></td></tr></table><br>
<a name="747449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sounds like we should get started soon then, however I'm going to be very busy at work for the next couple of days, so I wont be able to give any time to the project until after that. Maybe we can spend some time researching more and thinking about exactly what we want to achieve for the first demo? <br><br></td></tr></table><br>
<a name="747699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, i'll try and decypher cattos presentation slides to figure out whats going on. Then I guess we can try and flesh out a road map for the project.<br><br>Cool <br><br></td></tr></table><br>
<a name="747702"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matt Merkulov</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> The big advantage of coding physics library in BMax is that every BlitzMax coder then could alter this code to satisfy his needs while making physics engine for his game or something else. Also these modules can be understandable by those who do not know C, but want to khow how it all works. So I suggest making whole thing in BMax and I want to help porting it. <br><br></td></tr></table><br>
<a name="747754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, im preaty sure that it will end up being writen entirely in BMX. Writing C++ and compiling with MinGW or linking with a lib file, etc cant be debuged, a total turn off.<br><br>The only think that will bug me is that operators can be used on custom types (sucking majorly).<br><br>Why dont I just go out on a whim and define my coding standard as a basis. Please comment on this if there are issues for anyone that will be working on this project.<br><br>- <b>Conditional statements</b><br><br>-- A blank line must be included after a conditional statements.<br>-- Tabbing will increment (tabs must be used for indentation, not spaces) after that line<br>-- A blank line does not follow a conditional statements end.<br><br>- <b>Commenting</b><br><br>-- commenting for a single line will be all in lower case and preceed the statement it will reffer to.<br>-- single line comments must be in the same indentation as the code line they reffer to.<br>-- commenting for a function or data type will be done with a comment block as follows:<br><pre class=code>
'/**
' * COMMENT HEADER
' *   descriptive comment text
' *   that spanns multiple lines
' */
</pre><br>-- The comment block must be placed at the same intentation as the declaration that it applies to.<br><br>- <b>Significant code</b><br><br>-- significant blocks of code can be seporated by a blank line preseeding and following the block.<br>-- extreemly significant code can prefixed with a comment block.<br><br><br>well I guess that sorts out the formating and layout of the source code (if anyone has beef with it then just shout :). Im no good at naming conventions because I generaly make them up on the spot for whatever mood im in. They will become very important as the project grows and especialy for maths routines (without operators &gt;:).<br><br>we need something like constants are all capital. Types have capitals for each word in there name. Members start of lower case (java anyone :) and then follow type rule. local and global variables are all lower case (hmmm).<br><br>Thats just my thoughts though and imo looks nice and neat. <br><br></td></tr></table><br>
<a name="747756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
/**
 *
 *      _____          __  .__   project -            
 *     /     \   _____/  |_|__|__  __ ____  
 *    /  \ /  \ /  _ \   __\  \  \/ // __ \ 
 *   /    Y    (  &lt;_&gt; )  | |  |\   /\  ___/ 
 *   \____|__  /\____/|__| |__| \_/  \___  &gt;
 *           \/                          \/
 *
 *		Blitz Max Physics
 *
 *	Source File : sourceName.bmx
 *	writen by   : author
 *	extended by : who extended the file
 *	              more people
 *
 *	description : what does this file provide
 *
 */
</pre><br><br>perhaps this could be the standard file header ?<br><br>It looks like a realy retro menu screen :) <br><br></td></tr></table><br>
<a name="747765"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone wanna try google code? <br><br></td></tr></table><br>
<a name="747811"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >altitudems</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Pantheon, I won't be able to give much input today, extremely busy. But things look good so far, I look forward to working on the project tomorrow. <br><br></td></tr></table><br>
<a name="749729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stu_ovine</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#98">[#98]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about a small demo to start ?<br><br>I suggest a simple line drawn terrain (slopes) with various shapes dropping from the top of the screen ? <br><br></td></tr></table><br>
<a name="749746"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pantheon</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#99">[#99]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have infact started work on a small demo library to help make sure that I understand all the implementation details that Erin Catto proposed.<br>Work is going well and its being combined with the polycolly style SAT test for polygons.<br>I have also started work on a new GUI to manipulate and edit rigid bodies.<br>I was going to use this to make sure im comfortable with the math behind the code but it could be used for a small demo to launch the project.<br>Its a wee way off though :) <br><br></td></tr></table><br>
<a name="749760"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Stu_ovine</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#100">[#100]</a></td></tr></table></td></tr><tr ><td class="posttext"> Im sure once you release the engine (in any working state), theres enough of us that are willing to do some demos for it. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
