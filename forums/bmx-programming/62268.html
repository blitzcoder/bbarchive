<!DOCTYPE html><html lang="en" ><head ><title >more on memory pools</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >more on memory pools</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >more on memory pools</a><br><br>
<a name="695857"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Defoc8</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok..this may well be common knowledge, but its interesting<br>anyway. It would seem that released objects are cached,<br>so that subsequent 'new' allocations will infact simply return<br>an object from the cache - how well this works for complex<br>objects i dont know..but this simple sample demonstrates<br>the bmax memory management in action..well sortof anwyay.<br><br>type v3df<br> field x:float, y:float, z:float<br>endtype<br><br>Local vecs1:v3df[150000]<br><br>For Local z:Int=0 To 1<br>Print "~n~n~n PASS "+z<br>	Local t:Int=MilliSecs()<br>	For Local n:Int=0 To 150000-1<br>	 vecs1[n]=New v3df<br>	Next<br>	For n:Int=0 To 150000-1<br>	 vecs1[n]=Null<br>	Next<br>	t=MilliSecs()-t<br>	Print "~n time taken = "+t<br>Next<br><br><br><br>It may well be that if the objects in the pool are inactive for<br>a given time, they are released - infact i would imagine this<br>is how how it works...but regardless, this does atleast<br>highlight the fact that you may not need to implement<br>a custom system..<br><br>forcing gcCollect() - will trash this, the cache will be flushed. keep this in mind..<br><br>a little more info from BRL on how the memory manager<br>works would be quite helpful...so if your about mr sibly or <br>mr armstrong..perhaps you could enlighten us :p ;) <br><br></td></tr></table><br>
<a name="695909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you time the create and null seperately then the time saved in the second pass is in the 'null' stage. <br>Slight saving in the create but most in the 'nullify'<br><pre class=code>
Type v3df
Field x:Float, y:Float, z:Float
EndType

Local vecs1:v3df[150000]
'GCSetMode 2

For Local z:Int = 0 To 1
Print "~n~n~n PASS "+z
Local t1:Int=MilliSecs()
For Local n:Int=0 To 150000-1
vecs1[n]=New v3df
Next
Local t2:Int=MilliSecs()
For n:Int=0 To 150000-1
vecs1[n]=Null
Next
Local t3:Int = MilliSecs()
Print "~n create time taken = " + (t2 - t1)
Print "~n nullify time taken = " + (t3 - t2)
'gccollect()
Next

</pre><br>Is it possible auto-GC runs during the first pass but not the second?<br>If you gcsetmode 2 then the results are reversed. If you then gccollect (i.e. do what we think auto-gc is doing) then the original results are returned. <br><br></td></tr></table><br>
<a name="695927"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DStastny</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think you miss the point of custom pools.<br><br>If you look at the source of the garbage collector its quite simple how it works actually.  Yes it pools, but not as fast as a custom pool. It pools by size of memory requested for the object, If you look at the example I provided its quite apparent in that test, that custom pool is signficantly faster than default GC memory Pool.<br><br>The Garbage collector is invoked by allocations bbGCAlloc. The default behavor is set to automatically sweep after a set number of allocations.  The rate is currently set to 500 allocations.  So if you allocate 500 objects on the 501s object it will sweep to see if any can be released.<br><br>The reason a custom pool is faster is no allocations take place.  I think the part you are missing in your example is you are still newing 150000 objects that will invoke the GC.  Also you are calling print which with a computed string.  <br><pre class=code>
Print "~n~n~n PASS "+z
</pre><br>This too will invoke the garbage collector invalidating your test.  Strings are immutable objects so doing any concationation creates new objects.  new objects invoke allocation which will then sweep the garbage collector.<br><br>The idea of pools is to preallocate what you need before you go into a loop that uses the objects.<br><br>The creation of your own pools is to minimize allocations which in turn minimize the chance of a sweep unfortunalty there is not any way to prevent sweeping at all if you use objects like TList and foreach loops as invoking those commands will create objects.<br><br>The key is to minimize allocations not sweeps.  Allocations are what is slow, because they may cause a sweep.  And a custom pool is the fastest way to deal with that,  especially if you have lots of tiny objects that you are creating and destroying.<br><br>Blitz Max is very fast,  Marks allocation routines are fast however there is a lot of code being executed in there, if you are trying to squeeze every bit of performance out of a tight loop.  You dont want to execute that.<br><br>The garbage collector is not magic, it is invoked by new'ing objects. The part most dont realize that calling a blitzmax command may be new'ing and causing the sweeeps.<br><br>If you write simple for loop and count something the GC will never be invoked.<br><br>Doug Stastny <br><br></td></tr></table><br>
<a name="695932"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Defoc8</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> budman - im not getting at you - i simply didnt know how<br>the memory manager in bmax worked..i performed my<br>own tests too..with a custom pooling system..which was<br>better in some cases and worse in others..though to be<br>fair i probably arsed something up.. ;)<br><br>i was jst trying to point out that bmax seems to handle<br>things reasonably well without it..<br><br>i was wondering why the 2nd pass takes so little time to<br>allocate over the first pass...thats all..<br><br>sorry if i offended you..<br> - that wasnt my intention. <br><br></td></tr></table><br>
<a name="695947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DStastny</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was not offended, sorry if I came across that I was. Maybe i need to read my text before I post :).<br><br>I was trying to clarify what it does and does not do.  I agree BMAX does a real good job of minimize the performance hit.  And creating a POOL can be PIA, since you have to actually write more code.  However it really can improve your main loops in game code dramitically.<br><br>I actually like these discussion, on maximizing performance,  BMAX is fast but when needing tight code sometimes you have look for alternatives to optimize.<br><br>My example was Vectors since doing math with them creates lots of little objects in the main loop.<br><br>Now if we could minimzie the performance hit of the method calls that would be HUGE!.  Unfortunatly that requires inlining.<br><br>So no worries let discuss performance and extreme optimizations :)<br><br>Doug Stastny <br><br></td></tr></table><br>
<a name="695985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Defoc8</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> you can get around the inlining problem - but you'd have to<br>customise the editor - adding macro support.<br> - using a macro like function system, would in effect produce<br>inlined code..but writing/modding such a system might be<br>quite tricky.... - maybe someone will create an editor patch<br>allowing the rest of us to macro our code to death..<br><br>The only downside is that it would be none standard, so<br>passing the code to another developer, would require them<br>to have the same editor/macro system.<br><br>inline methods would be cleaner.. <br><br></td></tr></table><br>
<a name="695991"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DStastny</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> A true preprocessor would help,  but agree native inlining would be huge!  Looking at how BMAX creates the module headers the .i files it should be possible for Mark to put methods marked as inline in the .i as inline resolution.  Then the tough issue is making it work with the debugger.<br><br>Its just frustrating to have a little method to do a vector add and add all that overhead of context switch of a asm call routine.  It makes complex data types in BMAX estentially useless as your better off just coding them out all over the place.<br><br>Another thing that would help is actually making Vector2 Vector3 Vector4 and Matrices as integral data types. Be very cool to define vectors like this.<br><br>[Code]<br>local v1:Vector3(1,2,3)<br>local v2:Vecotr3(4,5,6)<br>local v3:Vector3<br>v3=v1+v2<br>[/code]<br><br>That would so rock.  If you needed a vertex buffer create an array of Vector3s with contigous memory buffers. Who knows maybe he has something up his sleeve for the 3d module.<br><br>Doug Stastny <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
