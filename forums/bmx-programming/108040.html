<!DOCTYPE html><html lang="en" ><head ><title >TList save/load complication</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >TList save/load complication</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >TList save/load complication</a><br><br>
<a name="1341231"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've got a weird one for y'all...<br><br>I've made a type that contains TLinks to previous and ahead Tlinks.<br><br>Pseudo...<br><pre class=code>
Type element
field prev:element
field ahead:element
EndType 
</pre><br><br>How would you save and load this again?<br><br>I've tried a number of things, including providing IDs and then parsing for them, which works, but is awfully slow and seems dumb to me?!<br><br>Thanks in advance for any advice! <br><br></td></tr></table><br>
<a name="1341232"></a>

<a name="1341233"></a>

<a name="1341237"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wouldn't even bother saving that information.  Is there a special reason why you need to?<br><br>As the element objects are held in a TList you know for a fact that you'll be loading the data in the same order as you saved it, so once you've done that, just recalculate the prev/ahead links at load-time if you really need them.  It's probably only going to take a couple of millisecs, if that - no biggie when loading data.  It's not like you're doing it every frame (is it)? <br><br></td></tr></table><br>
<a name="1341238"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh...you're saying they will remain relative? So...hmmm...I'll make some experiments. Sounds great! THANKS! 8D <br><br></td></tr></table><br>
<a name="1341239"></a>

<a name="1341240"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> This stuff really remains foggy to me...<br>I know, I must be hovering over the solution, but it's tiring...<br><br>...I'm so sorry, I don't know why I never went into that deeply enough? 8{<br><br>Ahaha, .ToString will return a hex number as string, but then .ToInt will return nonsense, of course...meh. <br>So, I could consider trying to figure out how I convert a hex out of a string to an int or simply have faith that it's all proper addresses, hahaha...dang.<br><br>Anyway, another curious little journey into BlitzMax. <br><br></td></tr></table><br>
<a name="1341241"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not that answering a question with a question is a solution, but, what on earth do you need the memory address for?<br><br>Maybe more info would help, i.e. what are you trying to achieve?  Wondering if you might be over-thinking something. <br><br></td></tr></table><br>
<a name="1341242"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeh, I'm not yet sure how I can do that... cast the object as...danged, I don't know.<br><br>Any idea on how you would actually write a recalculation? A tiny hint might help me already... <br><br>I can't very well do current_object:-first_object to get to some address that then could be relative a new first_object. At least, i don't know how?! <br><br></td></tr></table><br>
<a name="1341243"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure it's even possible.  AFAIK you can't rely on data being in the same memory address, not even relative to each other. <br><br></td></tr></table><br>
<a name="1341246"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I'm afraid I'm overthinking it!<br><br>All I need would be an INDEX, but I don't know how I could get that unless I'd convert it to an array, but even then I'd have to find the IDs again.<br><br>Ok, here's the situation:<br><br>I made a cute little vector painter just as a test, which automatically smooths curves at draw time. For that I store the previous and next line element to ensure I know what has to happen. Since I want those vectors modifiable afterwards, I don't want to just store coordinates. <br><br>The above pseudo code illustrates the problem perfectly, though!<br><br>Now, I can ask for an object VIA index (ValueAtIndex), but I don't know how I can GET the index of an object. If that would be possible, then I could easily store that instead. But I don't know how I can get the index...I think, I must have missed something?! <br><br></td></tr></table><br>
<a name="1341247"></a>

<a name="1341248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> ValueAtIndex can be slow, particularly with huge lists.  Fine for one-shot/occasional use but as much as I remember, if you want the value at index 100, it has to iterate through the first 99 in order to get it.  Obviously this is all going to get silly with thousands of objects in a list.<br><br>Have you considered using a TMap?  It sounds like it might be better suited to your situation.  That way each node (I presume) can have its own unique index and be retrieved with <b>node:element = element(myTMap.ValueForKey(myIndex))</b>.  Note that the index <b>must</b> be cast to a string, and you must also manually cast the result to whatever you know it to be - an object of type 'element', in this case. <br><br></td></tr></table><br>
<a name="1341249"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, that is a great idea! I thought about it a moment ago, using maps instead. Sounds like it would be the rare kind of ideal case. 8)<br><br>I've never done it, so that would be interesting all by itself.<br><br>THANKS and sorry, if I come across just as frustrated as I am about this. I keep thinking about just doing everything manually, because that would be the least trouble for my brains. Using faith based concepts always gets me on edge somehow.<br><br>Ironic, of course, considering that I am truly considering to try TMaps, haha! 8P<br><br>Anyhow...you're awesome, Gfk! 8D <br><br></td></tr></table><br>
<a name="1341250"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Are you looking for something like this?<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Type TElement
	Global Head:TElement = Null
	Global Tail:TElement = Null
	
	Field PrevElem:TElement = Null
	Field NextElem:TElement = Null
	
	Field x:Int, y:Int
	
	Function Create:TElement(x:Int, y:Int)
		Local Element:TElement = New TElement
		Element.x = x
		Element.y = y
		
		If Not Head
			Head = Element
			Tail = Element
		Else
			Element.PrevElem = Tail
			Tail.NextElem = Element
			Tail = Element
		End If
		Return Element
	End Function
	
	Function Clear()
		Local CurrentElem:TElement = Head
		While CurrentElem
			CurrentElem.PrevElem = Null
			CurrentElem = CurrentElem.NextElem
			If CurrentElem Then CurrentElem.PrevElem.NextElem = Null
		Wend
		head = Null
		Tail = Null
	End Function	
End Type

Graphics 800,600

While Not KeyHit(KEY_ESCAPE) And Not AppTerminate()
	Local CurrentElem:TElement = TElement.Head
	Local NextElem:TElement
	Cls
	
	While CurrentElem
		NextElem = CurrentElem.NextElem
		If NextElem Then DrawLine CurrentElem.x,CurrentElem.y,NextElem.x,NextElem.y
		CurrentElem = NextElem
	Wend
	Flip
	Local MX:Int = MouseX(), MY:Int = MouseY()
	If MouseHit(1)
		TELement.Create(MX,MY)
	End If
	
	If KeyHit(KEY_S)
		Cls
		DrawText "Saving...",10,10
		Flip
		Local out:TStream = WriteStream("lines.lns")
		If Not out Then RuntimeError("Couldn't open lines.lns for writing")
		CurrentElem = TElement.Head
		While CurrentElem
			WriteInt(out,CurrentElem.x)
			WriteInt(out,CurrentElem.y)
			CurrentElem = CurrentElem.NextElem
		Wend
		CloseStream out
	End If
	
	If KeyHit(KEY_L)
		Cls
		DrawText "Loading...",10,10
		Flip
		Local in:TStream = ReadStream("lines.lns")
		If Not in Then RuntimeError("Couldn't open lines.lns for reading")
		TElement.Clear()
		While Not Eof(in)
			Local x:Int = ReadInt(in)
			Local y:Int = ReadInt(in)
			TElement.Create(x,y)
		Wend
		CloseStream in
	End If
Wend

		
	
	
</textarea> <br><br></td></tr></table><br>
<a name="1341253"></a>

<a name="1341255"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hihi, no, but that's sweet, thank you!<br><br>This is a piece of what I have, and you'll see the insane ID solution...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

'======================= LOAD FILE ===================================
Function LoadDrawing()
	Local cmpheader:String = "Drawling version"
	Local filter:String = "drawling project(*.drp):drp;All Files:*"
	filename = RequestFile("Open drawling project(*.drp)", filter:String)
	If filename
		Local inFile:TStream = ReadStream(filename)
		Local bank:TBank = CreateBank()
		bank = ReadDataBank(inFile) 
		Local BStream:TStream = CreateBankStream(bank)
		Local header:String = bstream.ReadString(16)
		If BStream
			If header.contains(cmpheader)
				elementList.Clear()
				undolist.Clear()
				selectedList.Clear()
				ID_GEN = 0
				Local version:Byte = BStream.ReadByte()
				Local e:Element 
				Local a:vec = vec.Create(0,0)
				Local b:vec = vec.Create(0,0)
				For Local i:Int = 0 Until BStream.ReadInt()
					a.x = BStream.ReadFloat()
					a.y = BStream.ReadFloat()
					b.x = BStream.ReadFloat()
					b.y = BStream.ReadFloat()
					e = Element.Create(a,b)
					e.cr=BStream.ReadFloat()
					e.cg=BStream.ReadFloat()
					e.cb=BStream.ReadFloat()
					e.ca=BStream.ReadFloat()
					e.Width = BStream.ReadFloat()
					e.total_length = BStream.ReadFloat()
					e.prev_id = BStream.ReadInt()
					e.ahead_id = BStream.ReadInt()
				Next
				For Local e:Element = EachIn elementList
					If(e.ahead_id&gt;0)
						For Local se:Element = EachIn elementList
							If(se.id = e.ahead_id) e.ahead = se; 'Print se.id+" &lt;A"+e.id+"&gt; "+e.ahead_id 
						Next 
					EndIf 
					If(e.prev_id&gt;0)
						For Local se:Element = EachIn elementList
							If(se.id = e.prev_id) e.prev = se; 'Print se.id+" &lt;P"+e.id+"&gt; "+e.prev_id 
						Next 
					EndIf 
				Next 
			EndIf
		EndIf 
	EndIf 
End Function

'======================= SAVE FILE ===================================
Function SaveDrawing()
	Local saveit:Byte = True

	Local filter:String = "drawling project(*.drp):drp;All Files:*"
	If(Not filename) 
		filename = RequestFile("Save drawling project(*.drp)", filter:String, True,filename)
		FlushKeys()
	Else
		saveit=Confirm("Overwrite "+filename+"?")
	EndIf 
	If Not saveit Then Return 

	Local outFile:TStream=WriteStream( filename )
	Local header:String = "Drawling version"
	Local bank:TBank = CreateBank()
	Local BStream:TStream = CreateBankStream(bank)
	'--- format ---
	BStream.WriteString(header)
	BStream.WriteByte( 1)
	
	BStream.WriteInt(elementList.Count())
	For Local e:Element = EachIn elementList
		BStream.WriteFloat(e.a.x)
		BStream.WriteFloat(e.a.y)
		BStream.WriteFloat(e.b.x)
		BStream.WriteFloat(e.b.y)
		BStream.WriteFloat(e.cr)
		BStream.WriteFloat(e.cg)
		BStream.WriteFloat(e.cb)
		BStream.WriteFloat(e.ca)
		BStream.WriteFloat(e.Width)
		BStream.WriteFloat(e.total_length)
	'	BStream.WriteObject(Object(e.ahead))
	'	BStream.WriteObject(Object(e.prev))
		BStream.WriteInt(e.prev_id)
		BStream.WriteInt(e.ahead_id)
		
	Next
	CloseStream(BStream)
	WriteDataBank(outFile, bank) 
	CloseStream(outFile)
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1341254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I should clarify: The issue is that I can't rely on the previous or next element to really be previous or next in the list. They could be anywhere in the list, you know. <br><br></td></tr></table><br>
<a name="1341256"></a>

<a name="1341257"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> So to summarise:<br><br>1. You have a bunch of nodes (currently stored in a TList).<br>2. The nodes immediately before and after a node on screen, won't necessarily be next to each other in the list (presumably the user can insert nodes and so on, and a new node would simply be added to the end of the list?), hence the requirement for storing the previous and next nodes.<br><br><br>That being correct, then I would suspect that you were thinking along the right lines having a unique ID per node.<br><br>In the interests of speed, what I would do is have the ID as an integer field in the object.  When you reload, load the objects into a temporary TMap, rather than a TList.  Something like this should do it.<br><br><pre class=code>myTMap.Insert(String(myElement.ID),myElement))</pre><br><br>Then you can iterate through each object in the TMap:<br><br><pre class=code>For e:element = EachIn myTMap.Values()
  If e.prevID &lt;&gt; 0 ' is there a previous node?
    e.prev = element(myTMap.ValueForKey(String(e.prevID)))
  EndIf
  If e.nextID &lt;&gt; 0 ' is there a next node?
    e.next = element(myTMap.ValueForKey(String(e.prevID)))
  EndIf
  myListOrWhatever.AddLast(e)
Next
myTMap = Null
</pre><br><br>...or something like that.  Code typed straight into the reply box, so it's untested but you get the idea. <br><br></td></tr></table><br>
<a name="1341277"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is really a list isn't it? There is a first item. Then the ahead link gives the one after that, and that one's ahead link gives the next one etc. You somehow know when you are at the end, presumably a Null ahead link.<br><br>So you traverse the list in this way and save each one. When they are reloaded they will be in the desired order. <br><br></td></tr></table><br>
<a name="1341278"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @GfK:<br>Yes, the type has a field id:int and ahead_id and prev_id.<br>I must try the TMap for sure! Thanks for the further example, that's great!<br><br>@Floyd:<br>It's not a simple array, if that's what you mean. Though it currently generates a seemingly connected strip of elements, each one may be redirected along other elements, things could be cut or reconstructed in other ways, it's meant to be very open. <br>My very first test was to simply go one step back and one forth to get previous and ahead items, but it was flawed. <br>Though, come to think of it, I later found out that I forgot a field for the total length of the segment...hmmm...<br><br>Anyway, I'll try more! Thanks all three of you! 8D <br><br></td></tr></table><br>
<a name="1341283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Floyd...it's quite funny, I have to say. You know how sometimes one little mistake can send you off on a tangent to roam the nightmarish realm of confusion, frustration and denial... (pfffmaha) ...and every now and then you emerge from it with a great deal of additional clarity and real discoveries about what likely will be needed later on, BUT ... (THE GIANT KIND OF BUTS) ... then it turns out that you remember the little neglected mistake that you fixed later, sort of knowing that it could've been the source of all evil, but the stuff that scared you into full focus seemed more relevant so that the little mistake sort of lost weight or at least all attention...<br><br>Well, so I literally, literally, literally just held down my friendly Ctrl+Z for a while to see Blide take away allllll the pretty nonsense I wrote right up until the crucial very first take on the issue and right before I started the huge, confusing stumble into TLink madness...two steps before I noticed and fixed that little mistake.<br>I then fixed it right there and voila... problem solved (for now!).<br><br>Funny how that sometimes goes. (blush)<br><br>I will, as my personal walk of shame, post my entire code here promptly, but it ain't much, yet, and likely not very pretty. If you have a tablet, though, you might get a kick out of it already, too! 8) <br><br></td></tr></table><br>
<a name="1341285"></a>

<a name="1341286"></a>

<a name="1341287"></a>

<a name="1341288"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> As promised, a real big mess...but quit fun already!<br><br>Instructions:<br>(m) to toggle modes VECTOR | FREEHAND<br>(g) to toggle Grid <br>(space)+LMB or MMB to pan canvas<br>(space)+{ctrl}+LMB or MW to zoom <br>(home) to reset zoom and pan<br> hold (delete) and hover over lines to delete individual lines<br>(shift)+(delete) clears the canvas<br>(ctrl)+(z) undo ...endless<br>...no redo, yet!<br>(s) to save<br>(o) to open<br><br>If you have a graphics tablet (Wacom or the likes), pressure controls opacity in FREEHAND mode.<br><br>Vector mode has snapping and drag or click/click solution for making vectors. Snapping with RMB! <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Framework brl.GLMax2D
Import pub.glew
Import brl.standardio
Import pub.tablet 
Import brl.ramstream 
Import pub.zlib 

'------------ INCLUDES ---------------
Global filename:String 

'======================= LOAD FILE ===================================
Function LoadDrawing()
	Local cmpheader:String = "Drawling version"
	Local filter:String = "drawling project(*.drp):drp;All Files:*"
	filename = RequestFile("Open drawling project(*.drp)", filter:String)
	If filename
		Local inFile:TStream = ReadStream(filename)
		Local bank:TBank = CreateBank()
		bank = ReadDataBank(inFile) 
		Local BStream:TStream = CreateBankStream(bank)
		Local header:String = bstream.ReadString(16)
		If BStream
			If header.contains(cmpheader)
				elementList.Clear()
				undolist.Clear()
				selectedList.Clear()
				hoverList.Clear()
				
				Local version:Byte = BStream.ReadByte()
				Local e:Element 
				Local put_ahead:Element = Null
				Local put_prev:Element = Null
				Local a:vec = vec.Create(0,0)
				Local b:vec = vec.Create(0,0)
				Local count:Int = BStream.ReadInt()
				For Local i:Int = 0 Until count
					a.x = BStream.ReadFloat()
					a.y = BStream.ReadFloat()
					b.x = BStream.ReadFloat()
					b.y = BStream.ReadFloat()
					e = Element.Create(a,b)
					e.cr=BStream.ReadFloat()
					e.cg=BStream.ReadFloat()
					e.cb=BStream.ReadFloat()
					e.ca=BStream.ReadFloat()
					e.Width = BStream.ReadFloat()
					e.total_length = BStream.ReadFloat()
					If(put_ahead) Element(elementList.FindLink(e).PrevLink().Value()).ahead = e
					If(BStream.ReadByte()) put_ahead=e Else put_ahead=Null
					If(BStream.ReadByte() And put_prev) e.prev = put_prev
					put_prev = e;
				Next
			EndIf
		EndIf 
	EndIf 
End Function

'======================= SAVE FILE ===================================
Function SaveDrawing()

	Local filter:String = "drawling project(*.drp):drp;All Files:*"
	filename = RequestFile("Save drawling project(*.drp)", filter:String, True,filename)
	If Not filename Return 
	FlushKeys()

	Local outFile:TStream=WriteStream( filename )
	Local header:String = "Drawling version"
	Local bank:TBank = CreateBank()
	Local BStream:TStream = CreateBankStream(bank)
	'--- format ---
	'"Verve Painter version"				(16 bytes)..16
	BStream.WriteString(header)
	'version number 					(1 bytes)...17
	BStream.WriteByte( 1)
	
	BStream.WriteInt(elementList.Count())
	For Local e:Element = EachIn elementList
		BStream.WriteFloat(e.a.x)
		BStream.WriteFloat(e.a.y)
		BStream.WriteFloat(e.b.x)
		BStream.WriteFloat(e.b.y)
		BStream.WriteFloat(e.cr)
		BStream.WriteFloat(e.cg)
		BStream.WriteFloat(e.cb)
		BStream.WriteFloat(e.ca)
		BStream.WriteFloat(e.Width)
		BStream.WriteFloat(e.total_length)
		Local ahead:Byte = False 
		If(e.ahead) ahead = True 	
		BStream.WriteByte(ahead)
		Local prev:Byte = False 
		If(e.prev) prev = True 	
		BStream.WriteByte(prev)
	Next
	CloseStream(BStream)
	'bank = compressBank(bank) 'And your bank is now compressed 
	WriteDataBank(outFile, bank) 
	CloseStream(outFile)
End Function

'======================= BANK FUNCTIONS ===================================

Const SEGMENT_START:String = "&lt;SEGMENT&gt;"
CONST SEGMENT_END:String = "&lt;/SEGMENT&gt;"
CONST SEGMENT_SIZE_START:String = "&lt;SIZE&gt;"
CONST SEGMENT_SIZE_END:String = "&lt;/SIZE&gt;"
'saves all given banks to a stream (at current position) 
Function WriteDataBank:Int(stream:TStream, bank:TBank) 
	if not stream then return False

	'compress
	bank = CompressRawDataBank(bank)

	stream.WriteLine(SEGMENT_START)
	stream.WriteLine(SEGMENT_SIZE_START)
	stream.WriteLine(Bank.Size())
	stream.WriteLine(SEGMENT_SIZE_END)
	CopyBankToStream(bank, stream)
	stream.WriteLine(SEGMENT_END)

	return TRUE
End Function


'read a bank from the stream (beginning from current position)
Function ReadDataBank:TBank(stream:TStream)
	if not stream then return null
	if stream.Eof() then return null

	'seek segment information
	local segmentStart:int = GetStreamPatternPosition(stream, SEGMENT_START, stream.Pos())
	if segmentStart = -1 then return null

	local segmentSize:int = int(GetStreamPatternValue(stream, SEGMENT_SIZE_START, SEGMENT_SIZE_END, stream.Pos() ))
	if segmentSize &lt;= 0 then return null
	'current position in stream is now right before "segment_size_end"
	'so add the length of the string
	'also add "1" as we want to position at the first byte of the data segment
	local segmentDataPos:int = stream.Pos() + Len(SEGMENT_SIZE_END) + 1

	local bank:TBank = CreateBankFromStream(stream, segmentDataPos, segmentSize)
	bank = UncompressRawDataBank(bank)
	return bank
End Function


'returns a string between two patterns (eg. &lt;SIZE&gt;1234&lt;/SIZE&gt;)
Function GetStreamPatternValue:string(stream:TStream, patternStart:String, patternEnd:String, offset:int=0)
	local startPos:int = GetStreamPatternPosition(stream, patternStart, offset)
	if startPos = -1 then return ""
	local endPos:int = GetStreamPatternPosition(stream, patternEnd, Max(offset, startPos))
	if endPos = -1 then return ""

	'adjust positions (char after patternStart end + one char before patternEnd)
	startPos :+ len(patternStart)
	endPos :- 1

	local length:int = endPos - startPos + 1
	local value:string = ""
	stream.Seek(startPos)
	For local i:int = 0 until length
		value :+ Chr(stream.ReadByte())
	Next
	return value
End Function


'returns the position of the first char of a pattern
Function GetStreamPatternPosition:int(stream:TStream, pattern:String, offset:int=0)
	local patternFound:int = FALSE
	'array of bytes representing the chars of the pattern
	local bytePattern:byte[]
	local patternPos:int = 0

	For local i:int = 0 until len(pattern)
		bytePattern :+ [byte(pattern[i])]
	Next

	'start from the given offset
	stream.Seek( Min(offset, stream.Size()) )

	'repeat until end of stream or pattern was found
	while not stream.EOF() or not patternFound
		local b:byte = stream.ReadByte()
		'if the given pattern character was found: increase to next char
		'else start with first again
		if b = bytePattern[patternPos]
			patternPos :+1
		else
			patternPos = 0
		endif
		'found all characters of a pattern
		if patternPos &gt;= len(pattern)
			return (stream.Pos() - len(pattern) +1)
		endif
		'this byte was the last in the stream?
		if stream.EOF() then return -1
	Wend
	return -1
End Function


'copy a bunch of bytes from offset till offset+size into a bank
Function CreateBankFromStream:TBank(stream:TStream, offset:int, size:int)
	if not stream then return null

	'limit copyable part to stream size
	size = Min(size, stream.Size()-offset)
	local bank:TBank = CreateBank(size)

	'I thought I could use "readbank" - but as soon as the size
	'is 230 or more - you get an error and "malloc(): memory corruption")
	'maybe that is some kind of "buffer" for reading a stream
	'ReadBank( bank, stream, offset, size )

	'so : slow but steady :D
	stream.Seek(offset)
	for local i:int = 0 until size
		bank.PokeByte(i, stream.ReadByte())
	Next

	return bank
End Function


'copy the whole bank into a given stream
Function CopyBankToStream(bank:TBank, stream:TStream)
	if not stream then return
	if not bank then return

	CopyBytes(CreateBankStream(bank), stream, bank.Size())
End Function


Function UncompressRawDataBank:TBank(bank:TBank)
	''print "   got a bank to decompress"
	''print "     compressed: "+bank.Size()
	'uncompress
	bank = uncompressBank(bank)
	''print "     decompressed: "+bank.Size()
	return Bank
End Function


'Function CompressRawDataBank:int(bank:TBank var)
Function CompressRawDataBank:TBank(bank:TBank)
	'print "   got a bank to compress"
	'print "     decompressed: "+bank.Size()
	'uncompress
	bank = compressBank(bank)
	'print "     compressed: "+bank.Size()
	return bank
End Function


Function compressBank:TBank(sourceBank:TBank, level:Int = 9) 
	Local CurrentSize:Int = SourceBank.Size()
	Local destBankSize:Int = Ceil(sourceBank.Size() * 1.001) + 2 + 4
	Local destBank:TBank = CreateBank(destBankSize)
	compress2(destBank.Buf(), destBankSize, sourceBank.Buf(), sourceBank.Size(), level)
	'resize bank to it's compressed size
	destBank.Resize(destBankSize+4)
	'The size of the bank is included at the end - so you don't need to know the destination size later
	destBank.PokeInt(destBankSize,CurrentSize)
	Return destBank
End Function

Function uncompressBank:TBank(sourceBank:TBank) 
	Local destBankSize:Int = sourceBank.PeekInt(Sourcebank.size()-4)
	Local destBank:TBank = CreateBank(destBankSize)
	uncompress(destBank.Buf(), destBankSize, sourceBank.Buf(), sourceBank.Size())
	Return destBank
End Function



'==================================================================================
AppTitle="GL"

SetGraphicsDriver GLMax2DDriver()
Global Width:Int = 1280
Global Height:Int = 720
GLGraphics (Width,Height,0)
glOrtho (0, Width, Height, 0, -100, 100)
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA) 
glEnable (GL_LINE_SMOOTH)
glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)

Type vec
	Field x:Float
	Field y:Float
	
	Method set(v:vec)
		x = v.x
		y = v.y 
	End Method
	
	Method add(v:vec)
		x:+v.x 
		y:+v.y
	End Method
	
	Method sub(v:vec)
		x:-v.x 
		y:-v.y
	End Method
	
	Method mul(v:vec)
		x:*v.x 
		y:*v.y
	End Method
	Method rscale:vec(m:Float)
		Local v:vec = vec.Create(x,y)
		v.scale(m)
		Return v
	End Method
	
	Method scale(m:Float)
		x:*m 
		y:*m
	End Method
	
	Method lengthto:Float(d:vec)
		Return (x-d.x)^2+(y-d.y)^2
	End Method
	
	Method dot:Float(d:vec)
		Return x*d.x+y*d.y 
	End Method
	
	Method normalize()
		Local n:Float = x^2+y^2
		If(n&gt;0) Then n=Sqr(n) Else Return 
		x:/n
		y:/n
	End Method
	
	Function Create:vec(x:Float=0, y:Float=0)
		Local v:vec = New vec
		v.x=x
		v.y=y
		Return v
	End Function
EndType

Global selectedList:TList = CreateList()
Global hoverList:TList = CreateList()
Global elementList:TList = CreateList()

Global undolist:TList = CreateList()
Global undos:undo 
Type undo
	Field clusterlist:TList
	Method add(e:Element)
		clusterlist.AddLast(e)
	End Method
	
	Method remove()
		For Local e:Element = EachIn clusterlist
			elementList.Remove(e)
		Next
		clusterlist.Clear()
		undolist.Remove(Self)
	End Method
	
	Function Create:undo()
		Local u:undo = New undo
		u.clusterlist = CreateList()
		undolist.AddLast(u)
		Return u
	End Function
EndType 

Type Element
	Field state:Byte 
	Field a:vec
	Field b:vec
	Field cr:Float
	Field cg:Float
	Field cb:Float 
	Field ca:Float 
	Field width:Float 
	Field prev:Element 
	Field ahead:Element 
	Field total_length:Float 
	
	Method compute_total_length()
		total_length = Sqr((a.x-b.x)^2+(a.y-b.y)^2)+Sqr((prev.a.x-prev.b.x)^2+(prev.a.y-prev.b.y)^2)
	End Method
	
	Method add_ahead(_e:Element)
		ahead = _e
	End Method
	
	Method add_prev(_e:Element)
		prev = _e
	End Method
	
	Method remove()
		If(prev) Then prev.ahead = Null
		If(ahead) Then ahead.prev = Null
		elementList.Remove(Self)
	End Method
	
	Function Create:Element(_a:vec, _b:vec)
		Local e:Element = New Element
		e.a = vec.Create(_a.x,_a.y)
		e.b = vec.Create(_b.x,_b.y)
		e.cr = e.cg = e.cb=0.3
		e.ca = 1.0
		e.Width = 1.0
		e.state = False 
		e.prev = Null 
		e.ahead = Null 
		elementList.addlast(e)
		Return e
	End Function
	
	Method draw()
		glColor4f(cr,cg,cb, ca)
		glLineWidth(Width)'/zoom
		If(zoom&lt;1.0) Then glLineWidth(Width/zoom)
		
		If Not prev And Not ahead
			glBegin(GL_LINES)
				glVertex2d(a.x ,a.y )
				glVertex2d(b.x ,b.y )
			glEnd()
		Else If Not prev
			glBegin(GL_LINES)
				glVertex2d(a.x ,a.y )
				glVertex2d(a.x+(b.x-a.x)*0.5 ,a.y+(b.y-a.y)*0.5 )
			glEnd()
		Else If Not ahead
			glBegin(GL_LINES)
				glVertex2d(a.x+(b.x-a.x)*0.5 ,a.y+(b.y-a.y)*0.5 )
				glVertex2d(b.x ,b.y )
			glEnd()
		Else
			Local subdivisions:Float = Int(total_length/3 /zoom)
			If(subdivisions&lt;1)subdivisions = 1
			If(subdivisions&gt;100) subdivisions = 100
			
			Local colorstep:Float = (ca-prev.ca)/subdivisions
			Local color_ca:Float = prev.ca 
			If(zoom&gt;1.0)
				color_ca:/zoom^0.75
				colorstep:/zoom^0.75 
			EndIf 
			Local subvec_a:vec = vec.Create(0,0)
			subvec_a.set(prev.b)
			subvec_a.sub(prev.a)
			subvec_a.scale(0.5/subdivisions)
			
			Local subvec_b:vec = vec.Create(0,0)
			subvec_b.set(b)
			subvec_b.sub(a)
			subvec_b.scale(0.5/subdivisions)
			
			Local substep_a:vec = vec.Create(0,0)
			substep_a.set(prev.a)
			substep_a.add(subvec_a.rscale(subdivisions))
			
			Local substep_b:vec = vec.Create(0,0)
			substep_b.set(a)
			
			Local substep:Float = 1.0/subdivisions
			Local stepper:Float = 0
			Local sv:vec = vec.Create(substep_a.x,substep_a.y)
			
			glBegin(GL_LINE_STRIP)
				glColor4f(cr,cg,cb, color_ca)
				glVertex2d((sv.x ),(sv.y ))
				For Local i:Int = 0 To subdivisions
					sv.x =substep_a.x+(substep_b.x-substep_a.x)*stepper
					sv.y =substep_a.y+(substep_b.y-substep_a.y)*stepper
					color_ca:+colorstep
					glColor4f(cr,cg,cb, color_ca)
					glVertex2d(sv.x ,sv.y )
					
					substep_a.add(subvec_a)
					substep_b.add(subvec_b)
					stepper:+substep
				Next
			glEnd()
		End If
	End Method
	
	Method snap:vec(t:vec)
		Local dist:Float = a.lengthto(t)
		If(dist&lt;b.lengthto(t))
			Return a
		Else
			Return b 
		EndIf 
	End Method
	
	Method find:Byte(pos:vec)
		'If ca&lt;1.0 Then Return False 
		Local am:vec = vec.Create((pos.x-a.x), (pos.y-a.y))
		Local l:vec =  vec.Create(b.x-a.x, b.y-a.y)
		Local length:Float = Sqr(l.x^2+l.y^2)
		l.normalize()
		Local check_inside:Float = l.dot(am)
		If(check_inside&lt;-4*zoom Or check_inside&gt;length+4*zoom)
			cr = 0.0
			Return False 
		EndIf 
		
		Local ol:vec =  vec.Create(-l.y, l.x)
		If(Abs(ol.dot(am))&lt;4.0*zoom) 
			cr = 0.75
		 	Return True
		Else
			cr = 0.0
			Return False 		
		EndIf 
	End Method
	
EndType

Global tmp_element:Element 
Global tab_confirm:Byte = False 
If TabletOpen() Then tab_confirm = True
Global pressure:Float 

Global mouseButtonDown:Byte[3] 
Global mouseDrag:Byte[3] 
Global mouseButtonUp:Byte[3] 
Global mouseClicked:Byte[3] 
Global mousePos:vec = vec.Create(MouseX(),MouseY())
Global mousePos_lock:vec = vec.Create(MouseX(),MouseY())
Global LOCK_MOUSE:Byte = False
Global mouseVec:vec = vec.Create(MouseX(),MouseY())
Global mouseVecBuffer:Float = 0
Global mouseCanvasPos:vec = vec.Create(mousePos.x,mousePos.y)
Global zoom:Float = 1.0
Global pan:vec = vec.Create(-640.0,-360.0)
Global pan_lock:vec = vec.Create(-640,-360)
glLoadIdentity()
glOrtho (pan.x, Width+pan.x, Height+pan.y, +pan.y, -100, 100)

Global element_started:Byte = False
Global mouseDone:Byte = False
Global tmp:vec

Const VectorLines:Byte = 0
Const FreeHand:Byte = 1

Global mode:Byte = VectorLines
Global show_grid:Byte = False 

Function mouseAction:Byte()
	Local action:Byte = False
 	
	mouseVec.x = mousePos.x
	mouseVec.y = mousePos.y 
	mousePos.x = MouseX()
	mousePos.y = MouseY()
	pressure = TabletPressure()^3
	If(TabletPressure()=0 Or TabletCursor()=0) Then pressure=1.0
	
	For Local i:Int = 0 Until 3
		mouseClicked[i]=False 
		If(mouseButtonDown[i] And mouseVec.lengthto(mousePos)&gt;16)
			mouseDrag[i]=True;
			action = True 
		EndIf 
		If(mouseButtonUp[i]) Then mouseButtonUp[i] = False 
		If(mouseButtonDown[i] And Not MouseDown(i+1))
			mouseButtonDown[i]=False
			mouseButtonUp[i]=True
			If(Not mouseDrag[i]) Then mouseClicked[i]=True;
			mouseDrag[i]=False;
			action = True 
		EndIf 
		If(Not mouseButtonDown[i] And MouseDown(i+1))
			mouseButtonDown[i] = True 
			action = True 
		EndIf  
	Next
	
	mouseVec.sub(mousePos)
	Return action 
End Function
glClearColor(0.87,0.86,0.84,1.0)
While Not (KeyHit(KEY_ESCAPE) Or AppTerminate())
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	glColor4f(0.3,0.3,0.3,1.0)
	
	mouseAction()
	'GLDrawText("action:"+mouseAction(),20,0)
	'GLDrawText("Down....left:"+mouseButtonDown[0]+" middle:"+mouseButtonDown[2]+" right:"+mouseButtonDown[1],20,20)
	'GLDrawText("Up......left:"+mouseButtonUp[0]+" middle:"+mouseButtonUp[2]+" right:"+mouseButtonUp[1],20,40)
	'GLDrawText("Drag....left:"+mouseDrag[0]+" middle:"+mouseDrag[2]+" right:"+mouseDrag[1],20,60)
	'GLDrawText("Clicked.left:"+mouseClicked[0]+" middle:"+mouseClicked[2]+" right:"+mouseClicked[1],20,80)
	If KeyHit(KEY_M)
		mode:~1
		element_started = False
		If(tmp_element) Then tmp_element.ca = 1.0
		tmp_element=Null 
	End If
	If KeyHit(KEY_G)
		show_grid:~1
	End If
	
	If KeyHit(KEY_S) Then SaveDrawing()
	If KeyHit(KEY_O) Then LoadDrawing()
	
	If KeyHit(KEY_HOME)
		pan.x = -640
		pan.y = -360 
		zoom = 1.0
		pan_lock.set(pan)
		glLoadIdentity()
		glOrtho (pan.x, Width*zoom+pan.x, Height*zoom+pan.y, +pan.y, -100, 100)
	End If
		
	If mouseButtonDown[2]
		'zoom:+mouseVec.y*0.1
		pan.add(mouseVec.rscale(zoom))
		pan_lock.set(pan)
		glLoadIdentity()
		glOrtho (pan.x, Width*zoom+pan.x, Height*zoom+pan.y, +pan.y, -100, 100)
	End If
	If(MouseZ()&lt;0)' zoom OUT (wheel DOWN)
		pan_lock.x  = (pan.x-mousePos_lock.x)/zoom
		pan_lock.y  = (pan.y-mousePos_lock.y)/zoom
		zoom:+0.1*zoom;
		If(zoom&lt;0.1) Then zoom=0.1
		If(zoom&gt;500) Then zoom=500
		pan.x =mousePos_lock.x+pan_lock.x*zoom
		pan.y =mousePos_lock.y+pan_lock.y*zoom
		glLoadIdentity()
		glOrtho (pan.x, Width*zoom+pan.x, Height*zoom+pan.y, +pan.y, -100, 100)
		FlushMouse()
	EndIf 
	If(MouseZ()&gt;0) 'zoom IN (wheel UP)
		pan_lock.x  = (pan.x-mousePos_lock.x)/zoom
		pan_lock.y  = (pan.y-mousePos_lock.y)/zoom
		zoom:-0.1*zoom;
		If(zoom&lt;0.1) Then zoom=0.1
		If(zoom&gt;500) Then zoom=500
		pan.x = mousePos_lock.x+pan_lock.x*zoom
		pan.y = mousePos_lock.y+pan_lock.y*zoom
		glLoadIdentity()
		glOrtho (pan.x, Width*zoom+pan.x, Height*zoom+pan.y, +pan.y, -100, 100)
		FlushMouse()
	EndIf 
	
	
	If(KeyDown(KEY_SPACE))
		If mouseButtonDown[0]
			If Not KeyDown(KEY_LCONTROL) Or KeyDown(KEY_RCONTROL)
				pan.add(mouseVec.rscale(zoom))
				pan_lock.set(pan)
			Else 
				pan_lock.x  = (pan.x-mousePos_lock.x)/zoom
				pan_lock.y  = (pan.y-mousePos_lock.y)/zoom
					zoom:-mouseVec.y*0.01*zoom
				If(zoom&lt;0.1) Then zoom=0.1
				If(zoom&gt;500) Then zoom=500
				pan.x =mousePos_lock.x+pan_lock.x*zoom
				pan.y =mousePos_lock.y+pan_lock.y*zoom
				LOCK_MOUSE = True
			EndIf 
		Else
			mouseCanvasPos = vec.Create(mousePos.x,mousePos.y)
			mouseCanvasPos.add(pan.rscale(1.0/zoom))
			mouseCanvasPos.scale(zoom)
			mousePos_lock.set(mouseCanvasPos)
			LOCK_MOUSE = False
		End If
		
		glLoadIdentity()
		glOrtho (pan.x, Width*zoom+pan.x, Height*zoom+pan.y, +pan.y, -100, 100)
	Else 
'---------------------- CREATE MOUSE POSITION ------------------------
		mouseCanvasPos = vec.Create(mousePos.x,mousePos.y)
		mouseCanvasPos.add(pan.rscale(1.0/zoom))
		mouseCanvasPos.scale(zoom)
				
		Local position:vec = vec.Create(mouseCanvasPos.x, mouseCanvasPos.y)
		If Not LOCK_MOUSE Then mousePos_lock.set(position)

		If mouseButtonDown[1]
			Local dist:Float = 999999999
			Local target:vec = vec.Create(position.x, position.y)
			For Local e:Element = EachIn elementList
				If(Not tmp_element Or (e &lt;&gt; tmp_element)) 
					tmp = e.snap(target)
					If(tmp.lengthto(target)&lt;dist)
						dist = 	tmp.lengthto(target)
						position.set(tmp)
					EndIf 
				EndIf 
			Next
			glColor4f(0.7,0,0,0.5)
			Local q:Float = 3*zoom;
			glBegin(GL_QUADS)
				glVertex2d(position.x+q,position.y-q)
				glVertex2d(position.x-q,position.y-q)
				glVertex2d(position.x-q,position.y+q)
				glVertex2d(position.x+q,position.y+q)
			glEnd()
			'GLDrawRect(position.x-2,position.y-2,5,5)
		End If
		
	'---------------------------- CREATE ELEMENT --------------------------
	'FREEHAND ====================================
		If(mode=1)
			If Not element_started
				If (mouseButtonDown[0])
					tmp_element = Element.Create(position, position)
					If(tab_confirm)	tmp_element.ca = pressure^2
					element_started = True 
					undos = undo.Create()
				End If
			Else
				If(mouseButtonDown[0])
					mouseVecBuffer :+mouseVec.dot(mouseVec)
					If(mouseVecBuffer&gt;2)
					
						tmp_element.b.set(position)
						tmp_element.add_ahead(Element.Create(position, position))
						tmp_element.ahead.add_prev(tmp_element) 
						undos.add(tmp_element)
						tmp_element = tmp_element.ahead
						tmp_element.compute_total_length()
						If(tab_confirm)	tmp_element.ca = pressure^2

					'	mouseVecBuffer=10
					'	Local inv:Float = 1.0/mouseVecBuffer
					'	Local funvec:vec = vec.Create(mouseVec.x, mouseVec.y)
					'	funvec.normalize()
					'	Local funperp:vec = vec.Create(funvec.y, -funvec.x)
					'	Local orgpos:vec = vec.Create(position.x,position.y)
					'	For Local i:Int = 0 Until mouseVecBuffer
					'		Local funperp:vec = vec.Create(funvec.y, -funvec.x)
					'		funperp.scale(Sin(Double(sinner*100))*pressure*100)
					'		sinner:+1
					'		orgpos.x=position.x+funperp.x
					'		orgpos.y=position.y+funperp.y
					'		position.sub(mouseVec.rscale(inv))
					'		
					'		tmp_element.b.set(orgpos)
					'		tmp_element.add_ahead(Element.Create(orgpos, orgpos))
					'		tmp_element.ahead.add_prev(tmp_element) 
					'		undos.add(tmp_element)
					'		tmp_element = tmp_element.ahead
					'		tmp_element.compute_total_length()
					'		If(tab_confirm)	tmp_element.ca = pressure^2
					'	Next 
						mouseVecBuffer = 0
					EndIf 
				Else
					element_started = False 
					undos.add(tmp_element)
					
					tmp_element = Null 
				EndIf 
			End If
		Else
	'VECTOR =====================================
	'CLICKS--------------------------------------
			If Not element_started
				If (mouseButtonDown[0] Or mouseButtonDown[1])
					If(tmp_element)
						tmp_element.b.set(position)
						undos.add(tmp_element)
					Else
						tmp_element = Element.Create(position, position)
						undos = undo.Create()
						tmp_element.ca = 0.25
					EndIf 
					element_started = True 
				End If
				If(tmp_element.state) 
					tmp_element.b.set(position)
					ortho()
				EndIf 
				If(KeyDown(KEY_LCONTROL) Or KeyDown(KEY_RCONTROL) And Not tmp_element )
					For Local e:Element = EachIn hoverList
						If(Not selectedList.Contains(e))	
							selectedList.AddLast(e)
							e.cb = 1.0
						EndIf 
					Next
				EndIf 
			Else
	'DRAGS---------------------------------------		
				If (mouseDrag[0]Or mouseDrag[1])
					tmp_element.b.set(position)
					ortho()
				EndIf 
				If (mouseButtonUp[0]Or mouseButtonUp[1])
					If (mouseClicked[0] Or mouseClicked[1])
						If(tmp_element.state)
							tmp_element.ca = 1.0
							tmp_element = Null 
						Else
							tmp_element.state = True
						EndIf 
						element_started = False 
					Else
						tmp_element.ca = 1.0
						undos.add(tmp_element)
						tmp_element = Null 
						element_started = False 
					End If
				End If
			End If
		End If 
	EndIf 
	
	If(undolist.Count()&gt;0)
		If(KeyHit(KEY_Z) And KeyDown(KEY_LCONTROL))
		 	undo(undolist.Last()).remove()
		 
		EndIf 
	EndIf 
	
	If(show_grid) Then DrawPaper()
	glColor4f(0,0,0,0.5)
	GLDrawText("mouse x:"+mouseCanvasPos.x,5,5)
	GLDrawText("mouse y:"+mouseCanvasPos.y,5,18)
	GLDrawText("zoom:"+zoom,5,36)
	GLDrawText("elements:"+elementList.Count(),5,60)

'---------------------------- DRAW ELEMENTS --------------------------
	hoverList.Clear()
	For Local e:Element = EachIn elementList
		e.draw()
	Next
	If KeyDown(KEY_DELETE)
		hoverList.Clear()
		For Local e:Element = EachIn elementList
			If(e.find(mouseCanvasPos))
				hoverList.AddLast(e)
			EndIf 
		Next
		For Local e:Element = EachIn hoverList
			e.Remove()
		Next 	
		If KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT)
			elementList.Clear()
			FlushKeys()
		End If
	EndIf 
	If(mouseAction)
		Flip -1	
	Else
		Flip 1
	EndIf 
Wend
End
Function ortho()
	If(KeyDown(KEY_LSHIFT) Or KeyDown(KEY_RSHIFT))
		Local straightVec:vec = vec.Create(tmp_element.b.x-tmp_element.a.x,tmp_element.b.y-tmp_element.a.y)
		
		If(hoverList.Count()=0)
			Local gap:Float =Abs(straightVec.x)-Abs(straightVec.y)
			If(Abs(gap)&lt;0.5*straightVec.dot(straightVec)^0.5)
				Local diagonal:Float = tmp_element.b.y-tmp_element.a.y
				diagonal:/Abs(diagonal)
				If(gap&lt;0)
					diagonal:*Abs(tmp_element.b.y-tmp_element.a.y)
				Else
					diagonal:*Abs(tmp_element.b.x-tmp_element.a.x)
				EndIf 
				tmp_element.b.y = tmp_element.a.y+diagonal 
				If((tmp_element.b.x-tmp_element.a.x)&gt;0)
					tmp_element.b.x = tmp_element.a.x+Abs(diagonal)
				Else
					tmp_element.b.x = tmp_element.a.x-Abs(diagonal)
				EndIf 
			Else If(gap&gt;0)
				tmp_element.b.y = tmp_element.a.y 
			Else
				tmp_element.b.x = tmp_element.a.x 
			EndIf 
		Else
		EndIf 
	EndIf 
End Function

Function DrawPaper()
	glColor4f(0,0,0,0.125)
	Local gridpos:Float = -2000.0*Int(1+zoom/2)
	Local gridstep:Float = 20*Int(1+zoom/2)
	Local gridmax:Float = gridpos
	
	glLineWidth(1)
	glBegin(GL_LINES)
		glVertex2d(-gridmax,0);glVertex2d(gridmax,0)
		glVertex2d(0,-gridmax);glVertex2d(0,gridmax)
		glColor4f(0,0,0,0.0625)
	For Local i:Int = 0 Until 200
		glVertex2d(-gridmax,gridpos);glVertex2d(gridmax,gridpos)
		glVertex2d(gridpos,-gridmax);glVertex2d(gridpos,gridmax)
		gridpos:+gridstep
	Next
	glEnd()
	
End Function</textarea><br><br>It's a messy code, as I said, probably plenty of stupid things in there, but I post it as some kind of an apology for all the ruckus. 8] <br><br></td></tr></table><br>
<a name="1341289"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compile Error: Can't find interface for module 'pub.tablet'<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1341290"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have to look for the tablet mod. Should be in archives or there about!<br>I wished there was a 64bit compile of it for BlitzMaxNG. I couldn't do it, thus far... pity.<br><br>But, yeah, you'll find the tablet.mod!<br>If you don't have a tablet, you might as well just take out all the tablet stuff. It'll work fine with the mouse. Just no "pressure". <br><br></td></tr></table><br>
<a name="1341313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Taron</td><td align="right"><font class=tiny>(Posted May)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ha, imagine that, I've had to share it again years ago...funny.<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=102767" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=102767</a> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
