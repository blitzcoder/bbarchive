<!DOCTYPE html><html lang="en" ><head ><title >Alternative for weak references?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Alternative for weak references?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Alternative for weak references?</a><br><br>
<a name="991129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been using weak references extensively with C++ and Java.  Since BlitzMax does not support weak references, I have to find alternatives and I'm facing the following:<br><br>1) Create two generic proxy types, one for strong references and another for weak references.  The approach works (no resource leaks) but it is pretty ugly due to the packing and unpacking required to get the actual objects from their proxies.<br><br>2) Manually call dispose functions.  This approach is clean for simple objects like GUI, but is a nightmare for AI callbacks.<br><br>3) Use lua, which has both strong and weak references.  I have used this approach before in C and has been happy with it.  However, I have never use this approach in BlitzMax.<br><br>If anybody here has implemented these approaches before and would share me experiences, I would feel very grateful.  <br><br>Of course, if you know another alternative and would enlighten me, I'll feel grateful too. <br><br></td></tr></table><br>
<a name="991154"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Could you give some examples of Blitz code that is giving you nightmares? <br><br></td></tr></table><br>
<a name="991175"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear Czar,<br><br>I am trying to port AI code written in C++ and Java to BlitzMax so I don't have Blitz code yet.  However, I'll try to explain the situation.<br><br>The program has many actors.  Actors subscribe to events from multiple sources.  The sources may be other actors or global objects like the system event queue.  <br><br>To prevent leaks, actors must be unsubscribed from the event sources when they are no longer in use.  However, an actor can be in many places in the program so it is not trivial to determine if an actor is still being used or not.  <br><br>In the original code, the event sources hold weak references to the actors so they can automatically unsubscribe actors once their weak references become invalid.<br><br>Without weak references, one has to put a reference count in the actor.  But that means one also has to remember to increment/decrement the count.  Another way is to use proxy types like I said in the original post but they are very ugly.<br><br>Actors are not the only elements in the program with this issue.  The GUI elements also have this problem.  However, GUI elements are cheap to recreate so they have more workarounds. <br><br></td></tr></table><br>
<a name="991181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could try turning off the garbage collector, or maybe using pointers instead of references to objects. <br><br></td></tr></table><br>
<a name="991193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear Czar,<br><br>I don't think I understand what you're trying to suggest.  Event handling runs throughout the entire life of the program.  Does this mean I will have to turn off the garbage collector for the entire life of the program?  Wouldn't that mean I will have to manually manage not just actors but everything else too?<br><br>Besides, I think using VarPtr with a user defined type is no longer supported. <br><br></td></tr></table><br>
<a name="991233"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> To be honest, I don't really understand what you are asking. Maybe you should look at why you are porting the code in the first place. It might make more sense to import the C++ into a Blitz program directly (so then you can control the memory however you want C++ side), rather than porting it and risking it not working. <br><br></td></tr></table><br>
<a name="991238"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear Czar,<br><br>It's getting quite off topic but, the reason for porting is long term maintenance.  It is hard to create an AI library that will work for every program.  Most of the time, there must be some tweaking and I believe languages like BlitzMax are easier to tweak than C++, especially for new folks on the team.  <br><br>Anyway, thanks for reminding me that BlitzMax can use C++.  I'll check how BlitzMax works with C++ exceptions. <br><br></td></tr></table><br>
<a name="991245"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure if I should be posting here, I am getting into unknown waters here. But Can't you just use the BlitzMax's Lua  integrated module to do that? just a curious thought. <br><br></td></tr></table><br>
<a name="991248"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear Jesse,<br><br>I know about the Lua module.  I just wanted to know whether there's anybody here who used Lua to get around the lack of weak references in BlitzMax.  <br><br>I can do some experiments myself but it is possible that problems won't show up in small experiments.  Of course, making large experiments are very time consuming...<br><br>Weak references have helped me reduce a lot of code in the past so I don't want to let it go until I'm sure I have no choice.  However, it seems like mentioning AI confused many people to think that this is an AI topic.  I'm sorry if I did confuse you. <br><br></td></tr></table><br>
<a name="991322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> why do you need the proxy for strong refs?  how does one proxy for weak not solve the problem? <br><br></td></tr></table><br>
<a name="991342"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear dmaz,<br><br>In my implementation, weak references need to be informed when their object is no longer being used.  This is done by the Delete() method of the strong reference holding the same object.  <br><br>You can not use the Delete() method of the object to notify the weak references because the weak references themselves have a copy of the object.<br><br>This implementation will only work if all managed objects are wrapped into references.  The same object can not be in two strong references.  You also can not store objects directly in any data structure.  It is hell ugly.<br><br>If you know of a better way that would not require a proxy for strong references, I would be grateful if you can tell me.  I can't afford those that rely on undocumented features though. <br><br></td></tr></table><br>
<a name="991507"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about using HandleToObject() and HandleFromObject()? <br><br></td></tr></table><br>
<a name="991531"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dear Arowx,<br><br>According to my understanding, HandleFromObject() increments the reference count of the object.  It takes ownership of the object, preventing the garbage collector from disposing it.<br><br>A weak reference checks whether the object has been disposed by the garbage collector.  Therefore, it must not stop the garbage collector from disposing the object.<br><br>If my understanding of HandleFromObject() is wrong, please enlighten me. <br><br></td></tr></table><br>
<a name="991536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> It sounds like your working with john holland style adaptive agents. <br>Could you not bypass object references and use a lookup ID/table?<br>I think like others i'm having difficulty understanding the scope of the coupling. <br><br></td></tr></table><br>
<a name="991557"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Aek, no need for enlightenment the handle is still reference counted until Release(handle) is called then it is Nulled!<br><br>Sounds like GW's idea for id'd objects would work well! <br><br></td></tr></table><br>
<a name="991560"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> GW,<br><br>If I store objects in a table, it will be alive forever until I remove it from the table manually.  However, it is not always trivial to determine when I can safely remove objects from the table.<br><br>I guess it boils down to whether the object life time is obvious.  With GUI programming, you know you can delete all child windows when user closes the parent window.  With most games, you know you can destroy all characters when the player finishes the level.  With my stuff, some objects will live much longer than the rest and there's no break point. <br><br></td></tr></table><br>
<a name="991562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Arowx,<br><br>That means the object will be alive until I call Release right?  The problem is I don't have an easy way to determine when it is safe to call Release...<br><br>I might have a workaround if I can determine the reference count of an object.  If the reference count is one, I'll call Release.  However, there's no official way to determine the reference count...<br><br>OK! Considering all the confusion because of my stupidity of mentioning AI, I'll change my question.  How can I know if an object is shared? <br><br></td></tr></table><br>
<a name="991564"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Aek,<br><br>Extending GW's idea ... How about a simple id to map approach?<br><br>When an Actor is removed from the map it's reference is nulled but it's id can remain...<br><br>To notify the Actor the event system uses the id as a reference to find the actor via the map, Nulled actor id's can then be released from the system.<br><br>In fact it doesn't even have to be a map an array of object pointers and indexes could work and be faster, although allocation sizes might be an issue in a dynamic system.<br><br>I think this would be a good way to approach it! <br><br></td></tr></table><br>
<a name="991567"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Remember that even if an object is still alive from the gc's perspective, the local reference can be (set to) null. <br>So if an agent is no longer a consumer of a resource (set to null from the perspective of the resource) then that check works out as normal.  <br>If an agent, under natural operation, drops every connection to its (resource)producers, then the gc will clean up the object in the background for you.   <br><br>If you go with the array based method i mentioned above, you would basically have an array of id's of consumers in each resource. <br>You loop through these arrays from the perspective of the agent looking for 0 references of its own id. If its not found, then its an orphan. <br><br></td></tr></table><br>
<a name="991568"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Arowx,<br><br>Using your example, my problem would be knowing when it is appropriate to remove the actor from the map.  You remove the actor from the map when the actor is no longer in use.  But, how do you know that the actor is no longer in use?  <br><br>An actor could be many things, a widget, a part of a game character's brain, etc. There are many places in the program that you will have to search.  And you have to do correctly it at run-time.  If you remove the actor from the map prematurely, the actor will miss events.  If you forget to remove the actor, there will be a resource leak.<br><br>If weak references are available, the actor will be null-ed out automatically by the garbage collector when it is no longer in use.  If weak references are not available but the reference count can be queried, I can manually remove all actors from the map when its count is one because that means the actor exists only in the map.  But none of the two is available which is why I'm asking whether there's alternatives. <br><br></td></tr></table><br>
<a name="991570"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> GW,<br><br>I think I get what you're saying.  It is similar to what the garbage collector does.  However, wouldn't that have trouble when two agents are consumers of each other? <br><br></td></tr></table><br>
<a name="991571"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, shoot.  Even if I can get the reference count, I'll still have trouble with circular references. <br><br></td></tr></table><br>
<a name="991572"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> wouldn't that have trouble when two agents are consumers of each other? <br></div><br>I don't see how. <br>One of them has to expire somehow. This is a circular reference that every GC has trouble with. <br><br>There are 2 parts here, that i think are causing some confusion (for me).<br>#1. is agents naturally falling out of scope in the simulation. how are other consumers and producers to be updated? <br>#2. is the actual memory of the object getting reclaimed by the gc.<br><br>I have a feeling that you can solve your problem, without regard for Bmax GC at all. it will take care of itself.<br><br>Are object links one way or two way? <br><br>How about this?<br>If each agent had a flag called 'alive'. this is what gets set when an object is set 'dead'.  The object itself null's out all of its own references, consumers of itself ect.. <br>Then on next update of all the other objects, the alive flag is check for each reference it contains, if its false then the local reference is nulled and that object is skipped.<br>If every object does this check, then hidden references cant occur. <br><br></td></tr></table><br>
<a name="991576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Aek</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> GW,<br><br>Agents can be in more than one simulation at the same time.  Each simulation tests different aspects of the agent.  The criterion to remove an agent from a simulation varies.  Once an agent is removed from all simulations, it is considered unreachable by the program.  <br><br>In Java, the garbage collector searches for unreachable agents and notifies all weak references to the agents automatically.  Before an event source attempts to send an event to the agent, it will query the weak reference of the agent.  If the agent has already been claimed, null will be returned and the event source will remove the dead agent so it will not be checked again.<br><br>C++ is similar.  However, there's no garbage collector to handle circular references so one must also use weak references to prevent circular references.  <br><br>It is not my intention to trouble this many people...  I just wanted to know whether anybody here has gone through the same problem I had and tried the same workarounds I listed in my original post.  I also wanted to know how it went for them...<br><br>My time is running out so I guess I have to close this topic and start hacking code.  I thank everybody here for helping me. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
