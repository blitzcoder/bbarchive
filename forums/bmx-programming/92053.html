<!DOCTYPE html><html lang="en" ><head ><title >Anyone up to a challenge?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Anyone up to a challenge?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Anyone up to a challenge?</a><br><br>
<a name="1047848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jalih</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi all,<br><br>I recently wrote <a href="http://xob.kapsi.fi/~ljl/peli/raycaster.zip" target="_blank">a little raycaster in Hollywood</a><br><br>Number keys 1-7 change the drawing mode in demo.<br><br>Problem is: Hollywood is not really very well suited for this kind of stuff and some bloke on a local programming forum just  shot my implementation down without even seeing the code! He even hinted that porting code to BlitzMax wouldn't make much of an speed difference!<br><br>Since learning BlitzMax is still currently on my todo list, anyone here care to prove him wrong?<br><br>Porting from Hollywood to BlitzMax should be quite easy as Hollywood has a basic dialect. Code itself has only a very few lines and is very simple with stuff like basic vector addition and basic trigonometry.<br><br>I can post the code if someone is interested. <br><br></td></tr></table><br>
<a name="1047869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you're willing to post it go for it, never know what feedback you'll get :0) if it's short enough and I have time I'll take a stab. If it looks like basic there's a good chance a lot of it will just work, thought I've never seen Hollywood before so can't really promise that... porting math heavy code I find isn't usually that hard as math is usually about the same in every language... With a ray caster I would expect your bottleneck to be in the drawing implementation since pixel by pixel drawing on modern hardware is usually tedious to say the least (opengl and directx are made for bigger things than pixels) <br><br></td></tr></table><br>
<a name="1047870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think he can be proved wrong.<br><br>However, there might be generic optimizations (algorithm rather than compiler) that can improve speed.<br><br>Also, with a bit of luck you can port the more intensive parts to C and include them in your BMax program. If that's not fast enough then swithing to raw opengl might make it a bit faster.<br><br>Could be an interesting challenge. <br><br></td></tr></table><br>
<a name="1047883"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jalih</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for showing some interest!<br><br><a href="http://xob.kapsi.fi/~ljl/peli/raycaster.hws" target="_blank">Here is the Hollywood code</a> <br><br></td></tr></table><br>
<a name="1047887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DrDeath</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this based on <a href="http://www.student.kuleuven.be/~m0216922/CG/raycasting.html" target="_blank">this example</a>? <br><br></td></tr></table><br>
<a name="1047889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jalih</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, that example was the starting point.  I 'm gonna send it to Hollywood forums when it's finished as an example for beginners. I kept all the variable names intact, so they can easily follow the original tutorial.<br><br>I just added some stuff to guard for zero divides, added simple distance shading and removed some parts that did not seem to affect the end result. <br><br></td></tr></table><br>
<a name="1047895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> i had a crack at it<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Rem
/*
************************************************************
**
** Created by: CodeBench 0.13 (16.02.2010)
**
** Project: Raycaster
**
** File: 
**
** Date: 19-09-2010 19:09:22
**
************************************************************
*/
'
' Simple raycaster in Hollywood. There is some room For improvement in speed.
' For example I'm currently dividing the color RGB value of y-side walls by 2 to
' make them appear darker. Better way off course would be To use two separate textures
' lighter version For x-walls And darker version For y-walls. Distance And intensity
' values For Floor casting could also be pre-calculated And put in To tables.
'
EndRem

Graphics 240,360,0,60

Local img1:TPixmap=LoadPixmap( "pics\redbrick.png")
If img1=Null
RuntimeError "arg"
EndIf
Local img3:TPixmap=LoadPixmap( "pics\greystone.png")
Local img2:TPixmap=LoadPixmap(  "pics\mossy.png")

Const MAPWIDHT# = 24
Const MAPHEIGHT# = 24

Const ROTSPEED# = 0.10
Const MOVESPEED# = 0.25

Const TW#= 63
Const TH# = 63

Const DISTFACTOR# = 1/24

Global map[][24]
map[0]  = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
map[1]  = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
map[2]  = [1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
map[3]  = [1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
map[4]  = [1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1]
map[5]  = [1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1]
map[6]  = [1,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,0,0,0,3,1,0,0,1]
map[7]  = [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,1]
map[8]  = [1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,1]
map[9]  = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1]
map[10] = [1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,1,0,1]
map[11] = [1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,1]
map[12] = [1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,1]
map[13] = [1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1]
map[14] = [1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1]
map[15] = [1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1]
map[16] = [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
map[17] = [1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,1]
map[18] = [1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1]
map[19] = [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1]
map[20] = [1,0,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1]
map[21] = [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1]
map[22] = [1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1]
map[23] = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]



Global w=359 
Global h = 239

Global mode = 1

Global posX = 22
Global posY = 22

Global dirX = -1
Global dirY = 0

Global planeX = 0
Global planeY = 0.66

Global optionkeydown = False
Global walltexture:Double[TW,TH]
Global floortexture:Int[TW,TH]
Global ceilingtexture[TW,TH]

Rem
p_InitTexture()
' Textures from brushes To tables
Function p_InitTexture()


	
	For Local x = 0 To TW
		For Local y = 0 To TH
			walltexture[x,y] = ReadPixel(img1,x, y)
		Next
	Next
	
	

	
	For  x = 0 To TW 
		For  y = 0 To TH
			floortexture[x,y] = ReadPixel(img2,x, y)
		Next
	Next
	
	
	

	
	For  x = 0 To TW
		For  y = 0 To TH
			ceilingtexture[x,y] = ReadPixel(img3,x, y)
		Next
	Next
	
	
	
	
	
EndFunction
EndRem



' Filled walls And filled Floor And ceiling.
Function p_CastRays1()

	'SetFillStyle(#FILLCOLOR)
	SetColor	(255,255,0)
	DrawRect(0, 0, GraphicsWidth() + 1, (GraphicsHeight() + 1)/2)
	SetColor(0,255,255)
	DrawRect((GraphicsHeight() + 1)/2,0, GraphicsWidth() + 1, (GraphicsHeight() + 1))

	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		DebugLog camerax+"camerax"
		
		Local rayPosX = posX
		Local rayPosY = PosY
		
		DebugLog diry+"diry"
		
		DebugLog PlaneY+"planey"
		
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
		
		DebugLog raydiry+" raydiry"
		
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side


	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible	

		
		Local lineHeight = Abs(Int(h / perpWallDist))
			
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		If drawStart &lt; 0 Then drawStart = 0
		Local drawEnd = lineHeight * 0.5 + h * 0.5
		If drawEnd &gt; h Then drawEnd = h
		
		SetColor(100,100,100)
			
		DrawLine(x, drawStart, x, drawEnd)
						
	Next
	
EndFunction



' Filled distance shaded walls, filled Floor And ceiling.
Function p_CastRays2()

		
	SetColor	(255,255,0)
	DrawRect(0, 0, GraphicsWidth() + 1, (GraphicsHeight() + 1)/2)
	SetColor(0,255,255)
	DrawRect((GraphicsHeight() + 1)/2,0, GraphicsWidth() + 1, (GraphicsHeight() + 1))


	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		Local rayPosX = posX
		Local rayPosY = PosY
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
	
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side


	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible	
		Local intensity = DISTFACTOR * (24 - perpWallDist)
		
		Local lineHeight = Abs(Int(h / perpWallDist))
			
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		If drawStart &lt; 0 Then drawStart = 0
		Local drawEnd = lineHeight * 0.5 + h * 0.5
		If drawEnd &gt; h Then drawEnd = h
		SetColor 100*intensity,100*intensity,100*intensity
		'changecolor(color,intensity)
					
		DrawLine(x, drawStart, x, drawEnd)
						
	Next
	
EndFunction




' Filled walls, Floor And ceiling. All distance shaded.
Function p_CastRays3()

	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		Local rayPosX = posX
		Local rayPosY = PosY
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
	
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side
	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible	
		Local intensity = DISTFACTOR * (24 - perpWallDist)
		
		Local lineHeight = Abs(Int(h / perpWallDist))
			
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		If drawStart &lt; 0 Then drawStart = 0
		Local drawEnd = lineHeight * 0.5 + h * 0.5
		If drawEnd &gt; h Then drawEnd = h
		
		
		Local R = Int(100 * intensity)
		Local G = Int(100 * intensity)
		Local B = Int(100 * intensity)			
		SetColor (R,G,B)
					
		DrawLine(x, drawStart, x, drawEnd)
		
		
		
		' Floor casting	
		Local floorXWall
		Local FloorYWall

		If side = 0 And rayDirX &gt; 0
		floorXWall = mapX
		floorYWall = mapY + wallX
		
		ElseIf side = 0 And rayDirX &lt; 0
			floorXWall = mapX + 1.0
			floorYWall = mapY + wallX
		
		ElseIf side = 1 And rayDirY &gt; 0
			floorXWall = mapX + wallX
			floorYWall = mapY
		
		Else
			floorXWall = mapX + wallX
			floorYWall = mapY + 1.0
		EndIf
	
	
		If drawEnd &lt; 0 Then drawEnd = h
		
	
		For y = drawEnd + 1 To h + 1
	
			Local currentDist = h / (2.0 * y - h + 1)
					
			intensity = 1/currentDist					
										
			
		changecolor(color,intensity)
					
		changecolor(color,intensity)
		
			Plot(x, y) ' Floor
			Plot(x, h-y) ' Ceiling (symmetrical)
	
		Next		

														
	Next
		
EndFunction




' Textured walls, filled Floor And ceiling.
Function p_CastRays4()

		SetColor	(255,255,0)
	DrawRect(0, 0, GraphicsWidth() + 1, (GraphicsHeight() + 1)/2)
	SetColor(0,255,255)
	DrawRect((GraphicsHeight() + 1)/2,0, GraphicsWidth() + 1, (GraphicsHeight() + 1))


	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		Local rayPosX = posX
		Local rayPosY = PosY
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
	
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side


	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible	

		
		Local lineHeight = Abs(Int(h / perpWallDist))
		
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		Local texYScale = TH / lineHeight
		
		If drawStart &lt; 0 
			texY = -drawStart * texYScale
			drawStart = 0
		Else
			texY = 0		
		EndIf
		
		Local drawEnd = lineHeight * 0.5 + h * 0.5
	
		If drawEnd &gt; h Then drawEnd = h
	
		Local wallX
	
		If side  = 1
			wallX = rayPosX + ((mapY - rayPosY + (1 - stepY) * 0.5) / rayDirY) * rayDirX	
		Else
			wallX = rayPosY + ((mapX - rayPosX + (1 - stepX) * 0.5) / rayDirX) * rayDirY
		EndIf
		
		wallX = wallX - Floor(wallX)
		Local texX = Int(wallX * TW)
							
		For Local y = drawStart To drawEnd
			
			If side = 0
				Plot(x,y)
			Else
				Plot(x, y)
			EndIf
			
			texY = texY + texYScale
			
		Next
						
	Next
	
EndFunction



' Textured distance shaded walls. Filled Floor And ceiling.
Function p_CastRays5()

		SetColor	(255,255,0)
	DrawRect(0, 0, GraphicsWidth() + 1, (GraphicsHeight() + 1)/2)
	SetColor(0,255,255)
	DrawRect((GraphicsHeight() + 1)/2,0, GraphicsWidth() + 1, (GraphicsHeight() + 1))


	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		Local rayPosX = posX
		Local rayPosY = PosY
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
	
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side


	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible	
		Local intensity = DISTFACTOR * (24 - perpWallDist)
		
		Local lineHeight = Abs(Int(h / perpWallDist))
		
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		Local texYScale = TH / lineHeight
		
		If drawStart &lt; 0 
			texY = -drawStart * texYScale
			drawStart = 0
		Else
			texY = 0		
		EndIf
		
		Local drawEnd = lineHeight * 0.5 + h * 0.5
	
		If drawEnd &gt; h Then drawEnd = h
	
		Local wallX
	
		If side  = 1
			wallX = rayPosX + ((mapY - rayPosY + (1 - stepY) * 0.5) / rayDirY) * rayDirX	
		Else
			wallX = rayPosY + ((mapX - rayPosX + (1 - stepX) * 0.5) / rayDirX) * rayDirY
		EndIf
		
		wallX = wallX - Floor(wallX)
		Local texX = Int(wallX * TW)
								
		For Local y = drawStart To drawEnd
			Local r:Int
			Local g:Int
			Local b:Int
			GetColor(r, g, b)

			Local color = walltexture[texX,Int(texY)]
		changecolor(color,intensity)
													
			If side = 0
				Plot(x, y)
			Else
				Plot(x, y)
			EndIf
			
			texY = texY + texYScale
			
		Next
						
	Next
	
EndFunction



' Textured walls, Floor And ceiling.
Function p_CastRays6()

	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		Local rayPosX = posX
		Local rayPosY = PosY
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
	
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side

	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible	

		
		Local lineHeight = Abs(Int(h / perpWallDist))
		
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		Local texYScale = TH / lineHeight
		
		If drawStart &lt; 0 
			texY = -drawStart * texYScale
			drawStart = 0
		Else
			texY = 0		
		EndIf
		
		Local drawEnd = lineHeight * 0.5 + h * 0.5
	
		If drawEnd &gt; h Then drawEnd = h
	
		Local wallX
	
		If side  = 1
			wallX = rayPosX + ((mapY - rayPosY + (1 - stepY) * 0.5) / rayDirY) * rayDirX	
		Else
			wallX = rayPosY + ((mapX - rayPosX + (1 - stepX) * 0.5) / rayDirX) * rayDirY
		EndIf
		
		wallX = wallX - Floor(wallX)
		Local texX = Int(wallX * TW)
								
		For Local y = drawStart To drawEnd
			
			'Local color = walltexture[texX][Int(texY)]
						
			If side = 0
				Plot(x, y)
			Else
				Plot(x, y)
			EndIf
			
			texY = texY + texYScale
			
		Next


		' Floor casting	
		Local floorXWall
		Local FloorYWall

		If side = 0 And rayDirX &gt; 0
			floorXWall = mapX
			floorYWall = mapY + wallX
		
		ElseIf side = 0 And rayDirX &lt; 0
			floorXWall = mapX + 1.0
			floorYWall = mapY + wallX
		
		ElseIf side = 1 And rayDirY &gt; 0
			floorXWall = mapX + wallX
			floorYWall = mapY
		
		Else
			floorXWall = mapX + wallX
			floorYWall = mapY + 1.0
		EndIf
	
		Local distWall = perpWallDist

	
		If drawEnd &lt; 0 Then drawEnd = h
			
		For y = drawEnd + 1 To h + 1
	
			Local currentDist = h / (2.0 * y - h + 1)
										
			Local weight = currentDist / distWall
							
			Local currentFloorX = weight * floorXWall + (1.0 - weight) * posX
			Local currentFloorY = weight * floorYWall + (1.0 - weight) * posY
	
			Local floorTexX = Int(currentFloorX * TW) Mod TW
			Local floorTexY = Int(currentFloorY * TH) Mod TH
				
			Local fcolor = floortexture[floorTexX,floorTexY]
			changecolor(fcolor,intensity)
			Plot(x, y) ' Floor
			
			Local ccolor = ceilingtexture[floorTexX,floorTexY]
			
			changecolor(ccolor,intensity)
			
			Plot(x, h - y) ' Ceiling (symmetrical)
	
		Next

						
	Next
	
EndFunction


' Textured walls, Floor And ceiling. All distance shaded.
Function p_CastRays7()

	For Local x = 0 To w 

		Local cameraX = 2 * x / w - 1
		Local rayPosX = posX
		Local rayPosY = PosY
		Local rayDirX = dirX + planeX * cameraX
		Local rayDirY = dirY + planeY * cameraX
	
		Local mapX = Int(rayPosX)
		Local mapY = Int(rayPosY)
	
		Local deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		Local deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
	
		Local hit = 0
		Local stepX
		Local stepY
		Local sideDistX
		Local sideDistY
		Local side

	
		If rayDirX &lt; 0
			stepX = -1
			sideDistX = (rayPosX - mapX) *  deltaDistX
		Else
			stepX = 1
			sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
		EndIf
	
		If rayDirY &lt; 0
			stepY = -1
			sideDistY = (rayPosY - mapY) * deltaDistY
		Else
			stepY = 1
			sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
		EndIf
	
		While hit = 0
	
			If sideDistX &lt; sideDistY
				sideDistX = sideDistX + deltaDistX
				mapX = mapX + stepX
				side = 0
			Else
				sideDistY = sideDistY + deltaDistY
				mapY = mapY + stepY
				side = 1
			EndIf
		
			If map[mapX][mapY] &gt; 0 Then hit = 1
	
		Wend

		Local perpWallDist

		If side = 0
			perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
		Else
			perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
		EndIf
	
		If perpWallDist = 0 Then perpWallDist = 1 ' Make sure no divide by zero is possible
		Local intensity = DISTFACTOR * (24 - perpWallDist)	

		
		Local lineHeight = Abs(Int(h / perpWallDist))
		
		Local drawStart = -lineHeight * 0.5 + h * 0.5
		Local texYScale = TH / lineHeight
		
		If drawStart &lt; 0 
			texY = -drawStart * texYScale
			drawStart = 0
		Else
			texY = 0		
		EndIf
		
		Local drawEnd = lineHeight * 0.5 + h * 0.5
	
		If drawEnd &gt; h Then drawEnd = h
	
		Local wallX
	
		If side  = 1
			wallX = rayPosX + ((mapY - rayPosY + (1 - stepY) * 0.5) / rayDirY) * rayDirX	
		Else
			wallX = rayPosY + ((mapX - rayPosX + (1 - stepX) * 0.5) / rayDirX) * rayDirY
		EndIf
		
		wallX = wallX - Floor(wallX)
		Local texX = Int(wallX * TW)
								
		For Local y = drawStart To drawEnd
			
			Local color = walltexture[texX,Int(texY)]
		changecolor(color,intensity)
							
			If side = 0
				Plot(x, y)
			Else
				Plot(x, y)
			EndIf
			
			texY = texY + texYScale
			
		Next


		' Floor casting	
		Local floorXWall
		Local FloorYWall

		If side = 0 And rayDirX &gt; 0
			floorXWall = mapX
			floorYWall = mapY + wallX
		
		ElseIf side = 0 And rayDirX &lt; 0
			floorXWall = mapX + 1.0
			floorYWall = mapY + wallX
		
		ElseIf side = 1 And rayDirY &gt; 0
			floorXWall = mapX + wallX
			floorYWall = mapY
		
		Else
			floorXWall = mapX + wallX
			floorYWall = mapY + 1.0
		EndIf
	
		Local distWall = perpWallDist
	
		If drawEnd &lt; 0 Then drawEnd = h
			
		For y = drawEnd + 1 To h + 1
	
			Local currentDist = h / (2.0 * y - h + 1)
			intensity = 1/currentDist
										
			Local weight = currentDist / distWall
							
			Local currentFloorX = weight * floorXWall + (1.0 - weight) * posX
			Local currentFloorY = weight * floorYWall + (1.0 - weight) * posY
	
			Local floorTexX = Int(currentFloorX * TW) Mod TW
			Local floorTexY = Int(currentFloorY * TH) Mod TH
				
			Local fcolor = floortexture[floorTexX,floorTexY]
			changecolor(fcolor,intensity)
			Plot(x, y) ' Floor
			
			Local ccolor = ceilingtexture[floorTexX,floorTexY]
			changecolor(ccolor,intensity)
			
			Plot(x, h- y) ' Ceiling (symmetrical)
	
		Next

						
	Next
	
EndFunction






Function p_MainLoop()
	Local oldDirX
	Local oldDirY
	Local oldPlaneX
	
	
	If KeyDown(KEY_1)
		If optionkeydown = False
			mode = 1
			optionkeydown = True
		EndIf
	ElseIf KeyDown(KEY_2)
		If optionkeydown = False
			mode = 2
			optionkeydown = True
		EndIf
	ElseIf KeyDown(KEY_3)
		If optionkeydown = False
			mode = 3
			optionkeydown = True
		EndIf
	ElseIf KeyDown(KEY_4)
		If optionkeydown = False
			mode = 4
			optionkeydown = True
		EndIf
	ElseIf KeyDown(KEY_5)
		If optionkeydown = False
			mode = 5
			optionkeydown = True
		EndIf
	ElseIf KeyDown(KEY_6)
		If optionkeydown = False
			mode = 6
			optionkeydown = True
		EndIf
	ElseIf KeyDown(KEY_7)
		If optionkeydown = False
			mode = 7
			optionkeydown = True
		EndIf						
	Else
		optionkeydown = False						
	EndIf	

	If KeyDown(KEY_LEFT)			
		If KeyDown(KEY_LALT)
			oldDirX = dirX
			oldDirY = dirY
			
			dirX = dirX * Cos(Rad(90)) - dirY * Sin(Rad(90))
			dirY = oldDirX * Sin(Rad(90)) + dirY * Cos(Rad(90))
		
			If map[Int(posX + dirX * MOVESPEED)][Int(posY)] = 0 Then posX = posX + dirX * MOVESPEED
			If map[Int(posX)][Int(posY + dirY * MOVESPEED)] = 0 Then posY = posY + dirY * MOVESPEED

			dirX = oldDirX
			dirY = oldDirY
			
		Else
			oldDirX = dirX				
			dirX = dirX * Cos(ROTSPEED) - dirY * Sin(ROTSPEED)
			dirY = oldDirX * Sin(ROTSPEED) + dirY * Cos(ROTSPEED)
		
			oldPlaneX = planeX
			planeX = planeX * Cos(ROTSPEED) - planeY * Sin(ROTSPEED)'
			planeY = oldPlaneX * Sin(ROTSPEED) + planeY * Cos(ROTSPEED)
		EndIf
			
	ElseIf KeyDown(KEY_RIGHT)	
		If KeyDown(KEY_LALT)
			oldDirX = dirX
			oldDirY = dirY
		
			dirX = dirX * Cos(Rad(-90)) - dirY * Sin(Rad(-90))
			dirY = oldDirX * Sin(Rad(-90)) + dirY * Cos(Rad(-90))
		
			If map[Int(posX + dirX * MOVESPEED)][Int(posY)] = 0 Then posX = posX + dirX * MOVESPEED
			If map[Int(posX)][Int(posY + dirY * MOVESPEED)] = 0 Then posY = posY + dirY * MOVESPEED

			dirX = oldDirX
			dirY = oldDirY
					
		Else
			oldDirX = dirX				
			dirX = dirX * Cos(-ROTSPEED) - dirY * Sin(-ROTSPEED)
			dirY = oldDirX * Sin(-ROTSPEED) + dirY * Cos(-ROTSPEED)
		
			oldPlaneX = planeX
			planeX = planeX * Cos(-ROTSPEED) - planeY * Sin(-ROTSPEED)
			planeY = oldPlaneX * Sin(-ROTSPEED) + planeY * Cos(-ROTSPEED)
		EndIf
		
	EndIf
	
	If KeyDown(KEY_UP)
		If map[Int(posX + dirX * MOVESPEED)][Int(posY)] = 0 Then posX = posX + dirX * MOVESPEED
		If map[Int(posX)][Int(posY + dirY * MOVESPEED)] = 0 Then posY = posY + dirY * MOVESPEED
		
	ElseIf KeyDown(KEY_DOWN)
		If map[Int(posX - dirX * MOVESPEED)][Int(posY)] = 0 Then posX = posX - dirX * MOVESPEED
		If map[Int(posX)][Int(posY - dirY * MOVESPEED)] = 0 Then posY = posY - dirY * MOVESPEED
		
	EndIf
	


	Select mode
		Case 1
			p_CastRays1()
		Case 2
			p_CastRays2()
		Case 3
			p_CastRays3()
		Case 4
			p_CastRays4()
		Case 5
			p_CastRays5()	 
		p_CastRays5()
		Case 6
			p_CastRays6()
		Case 7
			p_CastRays7()
		Default
			p_CastRays1()
	EndSelect
	
	Flip
	
EndFunction




Graphics 800,600

Repeat
 p_MainLoop()
Until KeyHit(KEY_ESCAPE)

Function changeColor(color:Int,intensity=1)
	SetColor ((color Shr 16) &amp; $ff)*intensity,((color Shr 8)&amp; $ff)*intensity,(color &amp; $ff)*intensity
End Function
	
	Function rad(num:Int)
	Return num
	EndFunction
</textarea><br><br>couldnt work out how to read the pixels into an array because int and double both return error messages,<br>also i get a divide by zero error with raydiry <br><br></td></tr></table><br>
<a name="1047920"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> first time I hear of that CL.<br><br>I would try it but that CL don't seem to have proper declaration of variables. I can't tell if the variables are supposed to be integers or floats. I don't know if there is such a thing as "superStrict" for that language. you really need it. I noticed that there are variables being used in a function as part of a calculation and had not been previously declared while others you declared as local at the beginning of the function. That way of programming makes it hard for others to understand or even attempt to understand and translate. <br>One of the thing I like most about BMax is it's ability to force programmers into a disciplined way of programming. <br><br>Anyway, that was just my opinion. I am sure someone has experience in "Hollywood" and BMax and can figure it out with no problems. <br><br></td></tr></table><br>
<a name="1047925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jalih</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Some info about Hollywood language:<br><br>Hollywood only has one 64-bit data type for numbers. It can be used to store signed integers or real numbers. <br><br>Variables can be declared anywhere in the code. If you assign a value to a variable for the first time, then this variable will become global if you did not explicitly tell Hollywood that it shall be local by using the Local keyword. <br><br>If there is a local variable that has the same name as the global variable, then Hollywood will always use this local variable first.<br><br>Local variables are faster and can be easily collected by garbage collector, when they are not needed anymore. Globals must be explicitly set to Nil. <br><br></td></tr></table><br>
<a name="1047979"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> With a ray caster I would expect your bottleneck to be in the drawing implementation since pixel by pixel drawing on modern hardware is usually tedious to say the least (opengl and directx are made for bigger things than pixels) <br></div><br><br>We found a solution a while back...<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=89478#1016434" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=89478#1016434</a><br><br>:) <br><br></td></tr></table><br>
<a name="1048007"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jalih</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks! that does the trick!<br><br>I will modify it a bit, add distant shading, floor casting, sprites and what ever else comes to mind... <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
