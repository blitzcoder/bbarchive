<!DOCTYPE html><html lang="en" ><head ><title >Interesting polymorphic problem.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Interesting polymorphic problem.</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Interesting polymorphic problem.</a><br><br>
<a name="663585"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's the thing ...<br><br>- I have a TSprite with a Draw() method and a SpecialDraw() method.<br>- I extend the TSprite to TPlayer<br>- TPlayer also has a draw() method (overriding TSprite.draw())<br>- In TPlayer.Draw() I call Super.Draw() then I call Super.SpecialDraw()<br>- SpecialDraw() changes SetBlend to LIGHTBLEND and then draws the sprite again over the top of the original by calling Draw().  This is where the problem lies.  It get's stuck in an infinite loop because when SpecialDraw() calls Draw() it doesn't called TSprite.Draw() it must be calling TPlayer.Draw() which calls SpecialDraw() again and so on.<br><br>here's some example code:<br><br><pre class=code>
Type TSprite
   Method Draw()
   End MEthod

   MEthod SpecialDraw()
      SetBlend LIGHTBLEND
      Draw()
   End Method
End Type

Type TPlayer extends TSprite
   Method Draw() 'overridden
      Super.Draw()
      Super.DrawSpecial
   End Method
End Type
</pre><br><br>I tried changing the draw call in SpecialDraw() with a typecast:<br><br><pre class=code>TSprite(self).Draw()</pre> and this has the same hang.<br><br>I tried changing typecasting Super as a TPlayer:<br><br><pre class=code>TPlayer(Super).Draw()</pre> and this still hangs.  Anyway this would be undersireable as it would only work for TPlayer and the whole point is I want sprites and exended sprites to be able to use SpecialDraw().<br><br>So then ... any bright ideas about how I can instruct it to call TSprite.Draw()?  I know I could make TSprite.Draw() into a wrapper for another method called DoDraw() or something and then in SpecialDraw() call DoDraw() which, providing it isn't overridden in the extended type, will work (I've tested this), but that's pretty lame.  There must be an easier way to do this.  Ideas?  Thanks in advance. <br><br></td></tr></table><br>
<a name="663602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did you try Self.Draw() ?<br><br>You could just duplicate the draw method and call it `LocalDraw()` or something.<br><br>But I guess you're trying to go with some kind of clever technique? <br><br></td></tr></table><br>
<a name="663603"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Or what if you do:<br><br>Local MyFunctionPtr()=Self.Draw()<br><br>MyFunctionPtr()<br><br>Does that do anything different? <br><br></td></tr></table><br>
<a name="663607"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >taxlerendiosk</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Or what if you do:<br><br>Local MyFunctionPtr()=Self.Draw() <br></div><br>You can't have a pointer to a method though, only functions. <br><br></td></tr></table><br>
<a name="663609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AlexO</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can see why its getting stuck. But not exactly sure why you would do that. All you are changing is your blend mode and calling the same draw function, which with dynamic binding will just recursively call the closest (in this case TPlayer's) method in the heiarchy to the runtime type of that object. Hope that makes sense.<br><br>But if you're trying to alter draw SETTINGS i'd recommend abstracting it out a little more. I've used drawStates or renderstates to help with drawing special types.<br><br>so for instance<br><br><pre class=code>
Type TSprite
   Field rState:RenderState

   Method Draw()
   End MEthod

End Type

Type TPlayer extends TSprite
   
   Method Draw() 'overridden
      Super.Draw()
      rstate.set()
      Super.Draw()

   End Method

End Type

Type RenderState
	field alpha
	field scalex
	field scaley
	field rotation
	field blend
	field r,g,b
	
	method new()
		r= 255
		g = 255
		b = 255
		alpha = 1
		rotation = 0
		scalex = 1
		scaley = 1
		blend = SOLIDBLEND
	end method

	method set()
		setcolor r,g,b
		setrotation rotation
		setalpha alpha
		setscale scalex,scaley
		setblend blend
	end method

End Type
</pre><br><br>and for player sprites you simply alter the renderState on creation and you'd be set. <br><br></td></tr></table><br>
<a name="663621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks for your help...<br><br><div class="quote"> Did you try Self.Draw() ? <br></div> yep first thing I did.<br><br><div class="quote"> All you are changing is your blend mode and calling the same draw function, which with dynamic binding will just recursively call the closest (in this case TPlayer's) method in the heiarchy to the runtime type of that object. Hope that makes sense.<br> <br></div> Well it wasn't just changing the blend mode, that was an example, there's more, enough to merit a method.  I get that it's calling the closest method to the runtime type, but in theory you ought to be able to call the TSprite's draw() method as well, except you can't ...<br><br>I like the renderstate idea, I was just trying to keep the draw function as simple as possible for speed, and having to check if the renderstate has changed each time is an extra bit of code I'd rather avoid ... but I may have no choice.  Or I'd have to set the state before the draw, and the reset it afterwards, all in TPlayer.Draw() and I was trying to remove that many lines of code from TPlayer.Draw() and plonk them in TSprite where it can be reused.  In fact what I want to call in TPlayer.Draw is this:<br><br><pre class=code>Super.DrawLight(DamageCounter/DamageFadeLength,1,0,0)
</pre> all on one line, thus not having to set state, draw, reset state.  I know that will work, but I just want to put as much functionality in TSprite so later on I can do TAlien.Draw() and call Super.DrawLight() when it's damaged etc. <br><br></td></tr></table><br>
<a name="663632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think what Grey Alien is trying to do makes perfect sense.  <br><br>The sprite type should always call it's own Draw() method when it tries to Draw() from within itself.<br><br>And the player type should call the sprite's Draw() method, unless the player type has it's own Draw() method.<br><br>It doesn't make sense for the code in the sprite type to call the player's draw method when the draw method is overridden in the player type, because then the person that wrote the sprite type cannot predict how his own functions will behave when given these overridden types.<br><br><br>On the other hand, if you need a player to draw in a special way, and the sprite type's update function draws all the sprites with the sprite's draw method, then in order to use that update function and have it draw the players correctly, the sprite's draw method must be overridden.<br><br><br>But what if the sprite's draw method counts on the fact that draw works a certain way, and it draws shadows by calling the draw mwthod after setting some blending modes?  Then that shadow casting functionality will break as soon as the user who wrote the player type overrides the sprite type.<br><br>This doesn't seem like it prevents bugs to me.  It seems to me that if the aim is to have objects that you don't need to consider the internals of when making new objects, that having methods that override the methods another type calls itself internally is a very bad thing.<br><br>On the other hand, being able to call sprite.update() to draw all the sprites is useful, and if you can't override the draw function your players won't be drawn correctly.<br><br>But should it be?  That Sprite.Update() function is for updating sprites.  And a player is not a sprite...  Well, actually it is a sprite in the world of OOP.  The sprite is not an object the player moves, the player is a sprite.  <br><br>I think I still hate OOP.<br><br>Btw, grey, why are you making a sprite type, I thought you were using my sprite system? :-)  If you've changed it, you should know it already handles drawing sprites brighter than normal and the draw function won't allow you to override the   blend mode in that way.  I suspect you're making your own sprite type though so that wouldn't be an issue then. <br><br></td></tr></table><br>
<a name="663634"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AlexO</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I like the renderstate idea, I was just trying to keep the draw function as simple as possible for speed, and having to check if the renderstate has changed each time is an extra bit of code I'd rather avoid ... <br> <br></div><br><br>This is where stacks come in handy . I refactored your original example of the types to give the same result below. Added in renderstate stacks to show you don't have to check if a renderstate has changed<br><br>example:<br><br><pre class=code>
Type TSprite
   Field rState:RenderState

   Method Draw()
	rstate.Push()
	' draw stuff
	rstate.pop()
   End MEthod
	
	Method SpecialDraw()
		setBlend LIGHTBLEND
	end Method
End Type

Type TPlayer extends TSprite
   
 	Method Draw()
		super.draw()
		super.specialDraw()
		super.draw()
	end Method

End Type

Type RenderState
	global stack:Tlist = createList()
	field alpha
	field scalex
	field scaley
	field rotation
	field blend
	field r,g,b
	
	method new()
		r= 255
		g = 255
		b = 255
		alpha = 1
		rotation = 0
		scalex = 1
		scaley = 1
		blend = SOLIDBLEND
		
	end method

	method set()
		setcolor r,g,b
		setrotation rotation
		setalpha alpha
		setscale scalex,scaley
		setblend blend
	end method

	method push()
		stack.addLast(Self)
		set()
	end method

	method pop()
		stack.removeLast(Self)
		RenderState(stack.Last()).set()
	end method
End Type

</pre><br><br>I can't see any other way around the recursion. I imagine if you wanted specialDraw() to setup some sort of lighting algorithm you can do that in specialDraw(), but do not call Draw() in the same function. In Player you call specialDraw() then draw(). This might sound cumbersome but look at the whole picture in the end:<br>- when I create a player type all I have to do is calle myPlayer.draw(). no needed extra work. <br><br></td></tr></table><br>
<a name="663635"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AlexO</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>But should it be? That Sprite.Update() function is for updating sprites. And a player is not a sprite... Well, actually it is a sprite in the world of OOP. The sprite is not an object the player moves, the player is a sprite. <br> <br></div><br><br>This is where it seems your confused. Again, look at the heiarchy<br><br>Sprite<br>|<br>|<br>Player extends Sprite<br><br>This says a 'Player IS A Sprite' but a 'Sprite IS NOT a player. Look at bottom of heiarchy anything above it 'Is a' of that type. you can't 'is a' down the heiarchy. Makes perfect sense...<br><br><div class="quote"> <br>It doesn't make sense for the code in the sprite type to call the player's draw method when the draw method is overridden in the player type, because then the person that wrote the sprite type cannot predict how his own functions will behave when given these overridden types.<br> <br></div><br><br>the very meaning of 'overriding' a method is to replace original functionality completely.<br><br>With that said. if you had a 3000 line function in a super type and you want to derive another type that'll just change 1 line in that huge function...you're out of luck. And usually a sign of bad implementation. <br><br></td></tr></table><br>
<a name="663655"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nelvin</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Working the way it does is exactly why polymorphism exists (maybe you guys having problem with that should try to find a decent tutorial about the topic) if you'd call mySprite.Draw and it wouldn't call the Draw method of the concrete object mySprite points to, it wouldn't make any sense at all. It's meant to decouple your code from knowing concrete types but work with the given interfaces of it's base class.<br><br>In that specail case the solution would be to create a system without cycling contexts.<br><br><pre class=code>
Type Sprite
	Method Draw()
		BaseDraw()
	End Method
	
	Method BaseDraw()
		Print( "BaseDraw" )
	End Method

	Method SpecialDraw()
		Print( "SpecialDraw" )
		BaseDraw()
	End Method
End Type


Type Player Extends Sprite
	Method Draw()
		Print( "PlayerDraw" )
		SpecialDraw()
	End Method
End Type	


Type SuperPlayer Extends Player
	Method SpecialDraw()
		Print( "SuperPlayerSpecialDraw" )
		Super.SpecialDraw()
	End Method
End Type


Local spr:Sprite = New SuperPlayer
spr.Draw()
</pre><br>now our spr is only of the base type Sprite but it calls Player.Draw() which calls SuperPlayer.SpecialDraw() doing something specialspecial, Then calls Sprite.SpecialDraw doing the standardspecial and then calls Sprite.BasicDraw<br>Note that you can in addition customize the BaseDraw for derived types, but you first have to get what in that sample happens and *why*, then you shouldn't have problems with this in the future. <br><br></td></tr></table><br>
<a name="663661"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>This is where it seems your confused. Again, look at the heiarchy<br><br>Sprite<br>|<br>|<br>Player extends Sprite<br><br>This says a 'Player IS A Sprite' but a 'Sprite IS NOT a player. Look at bottom of heiarchy anything above it 'Is a' of that type. you can't 'is a' down the heiarchy. Makes perfect sense... <br> <br></div><br><br><br>I'm not confused at all, because I said that that is how it is right after I said it was another way.  I said it was the other way first to point out how confusing and backwards OOP can be.  It may make sense from an OOP standpoint that a player is a sprite, but as far as I'll always be concerned, a sprite is a polygon on the video card, and the player is moving it.  The player is not a sprite, it controls a sprite.<br><br><div class="quote"> <br>now our spr is only of the base type Sprite but it calls Player.Draw() which calls SuperPlayer.SpecialDraw() doing something specialspecial, Then calls Sprite.SpecialDraw doing the standardspecial and then calls Sprite.BasicDraw<br> <br></div><br><br>I can now see how OOP is not confusing at all!  <br>/sarcasm <br><br></td></tr></table><br>
<a name="663662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Azathoth</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It doesn't make sense for the code in the sprite type to call the player's draw method when the draw method is overridden in the player type, because then the person that wrote the sprite type cannot predict how his own functions will behave when given these overridden types. <br></div><br>This is how virtual methods work, it makes perfect sense. <br><br></td></tr></table><br>
<a name="663677"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow the debate rages on.<br><br>Sswift: I've had a TSprite for ages in the framework.  I was just adding some extra functionality today for when the player/alien gets hit, so they can flash brighter.  Glad you can see my point.  The rest of the OOP is fine, but there ought to be a way to call the base type Draw() in fact that's what I'm expecting it to do in this case, but it doesn't...  Actually there are cases where you *wouldn't* want it to call the base type Draw() as well when in TSprite so I guess it's swings and roundabouts.<br><br>Alex.O: nice bit of code thanks.<br><br>Nelvin: Don't worry I understand OOP and Polymorphism fine.  I already thought of making a wrapper for Draw() as per my first post where I mentioned DoDraw().  But I decided this was less desirable if there was a quick and easy way to be able to call the basetype's draw() from within itself, rather than it calling the exended type's overridden draw().<br><br>If you are able to call super.draw() from within TPlayer, why can't you can't draw() in some special way within TSprite and have it call TSprite's draw()?  I can see why "self" fails, because self is still a TPlayer.  So I typecasted self as TSprite but that still didn't work because polymorphism is still working of course.  So it sounds like basically there is no way to do this without making a wrapper function to avoid "cycling contexts", or using renderstates ... sigh.  The code is working fine right now using a wrapper function, I just found that a bid sad :-( <br><br></td></tr></table><br>
<a name="663925"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It doesn't make sense for the code in the sprite type to call the player's draw method when the draw method is overridden in the player type, because then the person that wrote the sprite type cannot predict how his own functions will behave when given these overridden types. <br></div><br>yes it does make perfect sense. if the extended type overrides the base draw that means the extended type (TPlayer) must be doing something that the base draw can’t.  which means that the base now has NO IDEA how to draw TPlayer correctly.  It must use TPlayer’s draw!   The base class assumes that TPlayer will use the base draw when appropriate, which is up to the programmer.<br><br>If the programmer of TSprite didn’t want draw overridden he should finalize the method. <br><br></td></tr></table><br>
<a name="663926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If you are able to call super.draw() from within TPlayer, why can't you can't draw() in some special way within TSprite and have it call TSprite's draw()? I can see why "self" fails, because self is still a TPlayer. So I typecasted self as TSprite but that still didn't work because polymorphism is still working of course. So it sounds like basically there is no way to do this without making a wrapper function to avoid "cycling contexts", or using renderstates ... sigh. The code is working fine right now using a wrapper function, I just found that a bid sad :-( <br></div><br><br>TPlayer needs to decide which draw to use... NOT the base because the base doen't have all the information <br><br></td></tr></table><br>
<a name="663930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> here's the thing Grey.  what you want to do is not logical. your base is fine and makes perfect sense but your TPlayer is not right because your're calling specialdraw from draw... when specialdraw already calls draw.  doesn't make sense.<br><br>what you should be doing is overriding specialdraw.... because it is a specialdraw by the fact that you are calling the base specialdraw.<br><pre class=code>Type TSprite
   Method Draw() Final
      Print "base draw"
   End Method

   Method SpecialDraw()
      Print "base superdraw"
      Draw()
   End Method
End Type

Type TPlayer Extends TSprite
   Method SpecialDraw() 'overridden
      Print "player - start sdraw"
      Super.Draw()
      Super.SpecialDraw()
      Print "player - end sdraw"
   End Method
End Type

Local t:TPlayer = New TPlayer
t.SpecialDraw()</pre><br><br>[edit] actually, looking at it again... I would probably do what Nelvin suggested with draw, basedraw and specialdraw but I would make basedraw final <br><br></td></tr></table><br>
<a name="663931"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I understand what you're saying but it still seems backwards to me.<br><br>I look at it like this.  Each class I create should be like a library.  <br><br>I can see the interface to library.  I can access the functions and fields it provides to me.  But what goes on inside it is a mystery, and I have no access to it.<br><br>Is not the idea of OOP that objects are encapsulated, and only those parts that you want accesses you make acessable, and the other fields you make private?<br><br>If we go back to the physics library example now, if you imagine there is a function for calculating distance, I could "override" that function in my code.  I could make my OWN distance function with the same name.  In doing so, my own code would access that distance function instead of the one in the physics lib.  But the physics lib itself would remain unaffected.  It would continue to use it's own distance function.  And that's good, because I'm not supposed to look at it's internals!  Everything I need to access it is supposed to be available from it's interface.<br><br>But what you're suggesting... Overriding the draw function of the sprite class, in such a way that the sprite class now calls that draw function instead...  That's like hacking into the class to change it's behavior.  It seems to me that that goes against the OOP philosophy.  <br><br>If I use a calculator as an example...<br><br>The caclulator has a display.  Tat display is physically capable of drawing the numbers 0 thru 9.  <br><br>The calculator has a CPU.  The CPU knows how to take input, and tell the display what numbers to display, but it cannot alter the display to be capalbe of showing letters.  <br><br>The buttons know how to take input from the user and provide that input to the CPU.  But the buttons can't change how the CPU's SINE function works.  If the CPU's SINE function takes radians normally, and you need it to take degrees, you don't tell the buttons to alter the CPU's sine function, you directly alter the CPU itself.<br><br>Is this not the concept behind OOP?  Each object is self contained, and a model of the real world?  What you suggest, having an object change the sprite's draw function is like having the buttons tell the calculator's CPU that it should take degrees inatead os radians in it's sine function.  And that is obviously silly.<br><br>So if your sprite type doesn't know how to draw fruit, then it needs to be updated to draw fruit.  But you don't have the fruit type make that change, you go into the sprite type and make the change.<br><br>If OOP deisign says to do otherwise, then OOP isn't OOP at all, if OOP is supposed to be based on objects in the real world! <br><br></td></tr></table><br>
<a name="663935"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If we go back to the physics library example now, if you imagine there is a function for calculating distance, I could "override" that function in my code. I could make my OWN distance function with the same name. In doing so, my own code would access that distance function instead of the one in the physics lib. But the physics lib itself would remain unaffected. It would continue to use it's own distance function. And that's good, because I'm not supposed to look at it's internals! Everything I need to access it is supposed to be available from it's interface. <br></div><br>Same here!  The base physics “type” WILL (as with the lib) continue to use it’s own distance function and remains unaffected just like the lib you describe above.  It will do this even if it’s been extended but only for it’s own objects.  tplayer’s objects are tplayer’s objects, as such it needs to manage them.<br><br><div class="quote"> But what you're suggesting... Overriding the draw function of the sprite class, in such a way that the sprite class now calls that draw function instead... That's like hacking into the class to change it's behavior. It seems to me that that goes against the OOP philosophy. <br></div><br>but that’s exactly what you are doing… changing it’s behavior.  As a developer you need take this into account.  That’s what word like “final” and “abstract” are for.  Also I would like to point out the VERY important fact that the sprite clase ONLY calls the player draw when the object is a player….. in other words, when the developer of the player type wants it to.  <br><br>Tell me, how can the developer of the sprite class know when to call and when not to call something he’s never seen (if the authors are different)?<br><br>Tsprite is NOT tplayer… tplayer is like a whole new lib built using the foundation of tsprite. <br><br></td></tr></table><br>
<a name="663937"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dmaz</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> First your calculator example is poor because those are all separate objects that work together.  they are not objects built on one another.... they are not OOP<br><br><div class="quote"> Is this not the concept behind OOP? Each object is self contained, and a model of the real world? <br></div><br>yes, each type is as self contained as the developer needs or wants it be.  Tell me, how is TSprite not self contained?<br><br><div class="quote">  What you suggest, having an object change the sprite's draw function is like having the buttons tell the calculator's CPU that it should take degrees inatead os radians in it's sine function. And that is obviously silly. <br></div>the object ISN'T changing the sprite's draw function!  it's OVERRIDING it... which mean exactly what that says.... since it overridden you can't use it (unless tplayer directly calls it)<br><br>it's kinda bothering me why you're not following this... what you're saying seems so illogical to me.... but I remember going through this myself. <br><br></td></tr></table><br>
<a name="663944"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nelvin</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>If I use a calculator as an example...<br><br>The caclulator has a display. Tat display is physically capable of drawing the numbers 0 thru 9. <br><br>The calculator has a CPU. The CPU knows how to take input, and tell the display what numbers to display, but it cannot alter the display to be capalbe of showing letters. <br><br>The buttons know how to take input from the user and provide that input to the CPU. But the buttons can't change how the CPU's SINE function works. If the CPU's SINE function takes radians normally, and you need it to take degrees, you don't tell the buttons to alter the CPU's sine function, you directly alter the CPU itself.<br> <br></div><br><br>Now take your example and think of about displaying the numbers using an LCD and alternatively LEDs (not in terms of using different bitmaps, but real different ways of displaying them, be it hardware or f.i. using bitmaps for LCDs and vector shapes for LEDs).<br><br>If you give the CPU an LCDDisplay type and use that, you cannot change the behaviour without altering the CPU code - if you use an abstract CalcDisplay just defining the interface and implement derived types LCDDisplay and LEDDisplay you can use instances of both and just hand them to the CPU as a CalcDisplay because the CPU really isn't interested in the concrete type of display. <br><br></td></tr></table><br>
<a name="663952"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> "First your calculator example is poor because those are all separate objects that work together. they are not objects built on one another.... they are not OOP"<br><br><br>Okay, then let's use an example that works with OOP as you see it.<br><br><br>I have a car.  The car has a generic engine, tires, and chassis.  Those aren't objects however, those are the car's methods.<br><br>If I want I can make the car into a volvo.  To do that though, I need to replace the engine, tires and chassis.  The car still knows how to use these things, but they're different on the volvo and the generic car.<br><br>I can go one step further, and upgrade to a Volvo SE.  That comes with additional features like heated seats and power windows that the car doesn't know how to use or need to know how to use.  But I can access them if I have the Volvo SE.<br><br><br>So now let's go back to the sprite system.  Let's say my sprite is a junker.  It has bald tires, and shimmies at 30mph.  I want to replace it's draw "engine" to make it go fast.<br><br>Would you say it would be wise for me to just strap a jet engine on the back of that puppy to take over for the failing engine?  Probably not.  For one, those tires are bald.  And for another, I don't know if the car's body would take the stress.  It might just tear itself apart.  Also, the weight of the car, and how it behaves at high speed are important to know or I could just flip over, or be unable to steer.<br><br>Once you start overriding methods in a class, you need to know how that class, and all the classes that it is desired from, work, in great detail, or you're just asking for a <a href="http://www.snopes.com/autos/dream/jato.asp" target="_blank">darwin award</a>.<br><br>And that just doesn't seem like a safe and reliable way to program to me. <br><br></td></tr></table><br>
<a name="663961"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AlexO</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Once you start overriding methods in a class, you need to know how that class, and all the classes that it is desired from, work, in great detail, or you're just asking for a darwin award.<br> <br></div><br><br>using your car example... if I wanted to make my car go faster I would imagine I would have to know in relative 'great detail' how engines work to even consider altering/overriding some of its functionality or I'll end up with an even bigger pile of junk :D. Same I would think applies to overridding methods in Bmax. <br><br></td></tr></table><br>
<a name="663969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well like I said, I already had code in place like Nelvin's and I'm sticking with that for now.  But like swift said, if this was function-based programming I *would* be able to call SpriteDraw() and it would work fine. <br><br></td></tr></table><br>
<a name="663970"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >IPete2</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Grey,<br><br>Why not simply set a flag and have only one draw routine.  Send everything to the same routine and divert to additional blend features (Special Draw method) with the flag?<br><br>IPete2. <br><br></td></tr></table><br>
<a name="663974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> IPete2: yes I could do that.  In fact as soon as it didn't work I thought of several methods.  My point was really why can't I call TSprite.Draw() when the object is a TPlayer.  I know *why* it calls TPlayer.Draw() instead but I just wondered if there was a way to do what I wanted in that way, just for interest really. <br><br></td></tr></table><br>
<a name="664027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nelvin</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok guy's either you don't get the benefits of polymorphic programming (it's designed to solve the problems of setting a flag for special handling because that's pretty bad if you have to maintain your code for a long time) or you just have that small projects that it really doesn't matter - then why bother, just skip the stuff and code however it's best suited for you. That's not a bad decision at all - in the end what really counts are the results.<br><br>An engine is not a method - the difference between a method and an object is it's state. An engine holds lots of states like age, number of runs, current speed, power etc..<br>Another example - powersuply in your house - you think your sockets should have "methods" for a TV, for a toaster, for a pc? Or isn't it better (well there's no chance one can question that) to have an abstract interface just for supplying energy to whatever "user" usese that common interface. Note the slight difference, the way you think about programming at the moment would be that your socket has methods like PowerToaster(), PowerTV() moving the usage decision to the wrong side of the fence. <br><br></td></tr></table><br>
<a name="664042"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> That is interesting. Casting to the base class does work in C++ and I don't quite see why Max behaves differently although Max doesn't have multiple inheritance so maybe doesn't fit with the optimal design:<br><br>test.bmx prints "b+"<br><pre class=code>
Type a
	Method b()
		Print "b"
	End Method
End Type

Type aa Extends a
	Method b()
		Print "b+"
	End Method
End Type

Local a1:aa=New aa
a(a1).b
</pre><br><br>test.cpp prints "b"<br><pre class=code>
#include &lt;stdio.h&gt;

struct a{
virtual void b(){printf("b\n");}
};

struct aa:a{
virtual void b(){printf("b+\n");}
};

main(){
	aa a1;
	a(a1).b();
}
</pre> <br><br></td></tr></table><br>
<a name="664045"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> There we go, I knew it was possible, just not in Max.<br><br>What happens in C++ if you create a variable of type a called x and typecast aa to it (x=a(a1)), and then call a.b().  Surely then it will print "b+" because it's using polymorphism.  This is actually an inconsistency really isn't it?  They should both do the same thing.  However, it should also be possible to call the baseclass method too, so that developers can have the best of both worlds.<br><br>Nelvin: I get it. I don't have any flags.  My polymorphic code works fine, I just wondered if this extra little option of calling a base class method within the base class was possible that's all. <br><br></td></tr></table><br>
<a name="664051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nelvin</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your C++ sample is wrong.<br>Polymorphism is only a topic on pointer/references.<br>What your sample does, is creating a concrete, known instance of the derived type.<br><br>And then you use that to create a concrete instance of the base type (a temporary but still an object, this has nothing to do with casting pointer/reference types) which the compilier initializes using a default copy constructor created automatically (because you didn't implement one).<br><br>Seems like you'd be surprised that the results would be different by changing the code to:<br><pre class=code>
main(){
aa* a1 = new a();
a* a2 = a1;
a2-&gt;b();
}
</pre><br><br>which is the way max works and how it generally is suppost to work using virtual/abstract methods.<br><br>@Grey - it wasn't aimed at you, more to the generality having problems with the topic - I should probably use more quotes :-) <br><br></td></tr></table><br>
<a name="664063"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ooops. :) <br><br></td></tr></table><br>
<a name="664070"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> hah, I've been trying to test this but my Visual Studio Beta has expired. So I tried Borland C which I had on my drive, but turns out that was from before my current install of XP (infact it's probably from a win98 install ages ago) thus woudn't run.  So I dropped back to the DJGPP compiler with RHIDE but that crash out a lot in XP, so I ran it in DOSBOX, but it still generated in errors.  So out of compilers, I've decided to update my MS stuff to the latest free visual studio express.  However I uninstalled the old stuff in the wrong order; did .net framework 2 first then SQL server wouldn't uninstall without it, how naff is that.  So I had to download and reinstall it just to uninstall SQL server gah!  Anyway, now I need a reboot (hope that doesn't fail, if you don't see any posts of mine for a few days, you now XP has gone *bad*) then I can finally download and install the new stuff so I'm back with the modern world in terms of C++ and C# compilers!<br><br>Hey Blitz Max compile c++?  I can can't it?  How do I do that...? <br><br></td></tr></table><br>
<a name="664077"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> You name the file blah.cpp and press f5... <br><br></td></tr></table><br>
<a name="664078"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> cool thanks haha, that easy heh.  Well sod the MS pap.  Hey I could get my old Allegro stuff working again! <br><br></td></tr></table><br>
<a name="664081"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Nelvin: This doesn't compile it says "invalid conversion from `a*' to `aa*'"<br><div class="quote"> main(){<br>aa* a1 = new a();<br>a* a2 = a1;<br>a2-&gt;b();<br>} <br></div><br><br>did you mean to put aa* a1 = new aa()   ?  This fixes the problem and demonstrates your point.<br><br>btw...<div class="quote"> There we go, I knew it was possible, just not in Max. <br></div>I take it back :-( <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
