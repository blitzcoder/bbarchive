<!DOCTYPE html><html lang="en" ><head ><title >Copy Array onto a larger array?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Copy Array onto a larger array?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Copy Array onto a larger array?</a><br><br>
<a name="1006999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, I'm making a Tetris clone, (for the first time :D)<br><br>How would I copy a defined 4x4 peice array (for example):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

'I Peice
Global IPeice:Int[4, 4] = [0, 0, 1, 0,  ..
							0, 0, 1, 0,  ..
							0, 0, 1, 0,  ..
							0, 0, 1, 0]
Global IPeice90:Int[4, 4] = [0, 0, 0, 0,  ..
							1, 1, 1, 1,  ..
							0, 0, 0, 0,  ..
							0, 0, 0, 0]

'J Peice
Global JPeice:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 1, 0, 0,  ..
							0, 1, 1, 1,  ..
							0, 0, 0, 0]
Global JPeice90:Int[4, 4] = [0, 1, 1, 0,  ..
							0, 1, 0, 0,  ..
							0, 1, 0, 0,  ..
							0, 0, 0, 0]
Global JPeice180:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 1, 1, 1,  ..
							0, 0, 0, 1,  ..
							0, 0, 0, 0]
Global JPeice270:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 0, 1, 0,  ..
							0, 0, 1, 0,  ..
							0, 1, 1, 0]

'L Peice
Global LPeice:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 0, 1, 0,  ..
							1, 1, 1, 0,  ..
							0, 0, 0, 0]
Global LPeice90:Int[4, 4] = [0, 0, 1, 0,  ..
							0, 0, 1, 0,  ..
							0, 0, 1, 1,  ..
							0, 0, 0, 0]
Global LPeice180:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 1, 0, 0,  ..
							0, 1, 1, 1,  ..
							0, 0, 0, 0]
Global LPeice270:Int[4, 4] = [1, 1, 0, 0,  ..
							0, 1, 0, 0,  ..
							0, 1, 0, 0,  ..
							0, 0, 0, 0]
							
'O Peice
Global OPeice:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 1, 1, 0,  ..
							0, 1, 1, 0,  ..
							0, 0, 0, 0]
'S Peice
Global SPeice:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 0, 1, 1,  ..
							0, 1, 1, 0,  ..
							0, 0, 0, 0]
Global SPeice90:Int[4, 4] = [0, 0, 1, 0,  ..
							0, 0, 1, 1,  ..
							0, 0, 0, 1,  ..
							0, 0, 0, 0]
'T Peice
Global TPeice:Int[4, 4] = [0, 0, 1, 0,  ..
							0, 1, 1, 1,  ..
							0, 0, 0, 0,  ..
							0, 0, 0, 0]
Global TPeice90:Int[4, 4] = [0, 0, 1, 0,  ..
							0, 0, 1, 1,  ..
							0, 0, 1, 0,  ..
							0, 0, 0, 0]
Global TPeice180:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 1, 1, 1,  ..
							0, 0, 1, 0,  ..
							0, 0, 0, 0]
Global TPeice270:Int[4, 4] = [0, 0, 0, 1,  ..
							0, 0, 1, 1,  ..
							0, 0, 0, 1,  ..
							0, 0, 0, 0]
'Z Peice
Global ZPeice:Int[4, 4] = [0, 0, 0, 0,  ..
							0, 1, 1, 0,  ..
							0, 0, 1, 1,  ..
							0, 0, 0, 0]
Global ZPeice90:Int[4, 4] = [0, 0, 0, 1,  ..
							0, 0, 1, 1,  ..
							0, 0, 1, 0,  ..
							0, 0, 0, 0]
</textarea><br><br>Onto a larger tile map, (the screen):<br><pre class=code>
Global Screen:Int[25, 24]
</pre><br><br>That way I can just loop through the screen and draw the tiles.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="1007008"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Scaremonger</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> In Tetris, I seem to remember there are 7 tiles of 5x5 blocks. Each Tile pivots in the center (5x5 allows the 1x4 block to rotate correctly), although I like the idea of a 4x4.<br><br>To position a piece on the screen you'll need a function that takes the position of the Tile relative to the scren array, the tile, and the tile orientation. A nested loop will be required to map the pieces onto the screen a square at a time. <br><br></td></tr></table><br>
<a name="1007012"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> As wierd as it might sound, it can be better to store shapes as a list of points rather than a 2d array as it wastes less space, but it can get complicated and what's a few bytes on a modern computer? :P<br><br>A hint - there's no need to store 4 different variations for each rotation. Just store the piece in one rotation, and then when you create a new piece to use, rotated it 0-3 times randomly.<br><br>For your screen grid, you can store the colour code of whichever block occupies that space. Give each possible colour a unique id constant.. eg Red is 1, Green is 2, and leave 0 for Empty. Update your arrays so that instead of just 1s, they'll have the number that corresponds to their colour. So if you want the Z piece as Green, give it 2s.<br><br>To place a piece on the grid, use double nested for loops.<br><br><pre class=code>
Const Empty:Int = 0, Red:Int = 1 '.......
'......
Function PlacePiece:Int(atX:Int, atY:Int, Piece:Int[,])
	For X = 0 Until 4
		For Y = 0 Until 4.
			If Piece[X, Y] &lt;&gt; Empty And Screen[atX + X, atY + Y] &lt;&gt; Empty
				'you are trying to place a piece where one already exists!
				Return False
			End If
		Next
	Next
	For X = 0 Until 4
		For Y = 0 Until 4
			'copy over the piece's colour info to the grid
			If Piece[X, Y] &lt;&gt; Empty ' you don't want to overwrite any other pieces nearby with Empty's
				Screen[atX + X, atY + Y] = Piece[X, Y]
			End If
		Next
	Next
	'Piece placed successfully
	Return True
End Function</pre><br>You can use this to easily check for losing. When placing the next piece at the top of the board, if this function returns False, there is no space and the player has lost!<br><br>Remove a piece in the same way. It doesn't do any checks, so if the piece is not in fact there it could mess up the grid. None of the functions also check that the target coordinates are on the grid either. That's for you to worry about :)<br><pre class=code>Function RemovePiece(atX:Int, atY:Int, Piece:Int[,])
	For X = 0 Until 4
		For Y = 0 Until 4.
			If Piece[X, Y] &lt;&gt; Empty Then Screen[atX + X, atY + Y] = Empty
		Next
	Next
End Function</pre><br><br>How to move a piece? Don't create a complex collision checking algorithm as you try to move each individual block down one at time! This lazy way is better :)<br>1. Remove the piece from the board.<br>2. Try to place the piece 1 downwards (for gravity, but you can use any new location)<br>3. If that fails, replace at original location.<br><pre class=code>Function MovePiece:Int(atX:Int, atY:Int, toX:Int, toY:Int, Piece:Int[,])
	RemovePiece(atX, atY, Piece)
	If Not PlacePiece(toX, toY, Piece)
		'cannot place here, put back
		PlacePiece(atX, atY, Piece)
		Return False
	Else
		'placed in new location
		Return True
	End If
End Function</pre><br><br>You can rotate using the same method. Pick up, rotate, attempt to place down. If this fails, reverse the rotation so it's back to how it was, and replace in the old location.<br><br>Ok this should get you started. If you need more help, just ask :)<br><br>Disclaimer: code above writen fresh and therefore untested! <br><br></td></tr></table><br>
<a name="1007471"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yahfree</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> alright, I went with a data route.... but I'm having some problems.. when the piece rotates near the edge of the screen it goes out of bounds sometimes, the obvious answer would be to test where it goes before putting it there..<br><br>Another weird thing which I don't know the answer to is this weird effect when I use different pieces (I was testing with just the L piece).<br><br><br>Here's my code:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TBlock Extends tlEntity
	Field Placed:Byte'hit the bottom?
	Field tiles:Int[4]
	Field ax:Int, ay:Int
	Field rot:Int
	Field Timer:Int
	Field Shape:Int[4, 4]
	Field szShape:String
	Field Length:Int, Height:Int
	Global BlockList:TList = CreateList()
	
	Method Create:TBlock(_shape:String, _ax:Int, _ay:Int)
		szShape = _shape
		LoadShape(szShape, 0)
		x = _ax * TILE_SIZE
		y = _ay * TILE_SIZE
		ax = _ax
		ay = _ay
		ListAddLast(BlockList, Self)
		CopyToScreen()
		Return Self
	End Method
	
	Method Update()
		If Not Placed
			If KeyHit(KEY_LEFT) Translate(-1, 0)
			If KeyHit(KEY_RIGHT) Translate(1, 0)
			If KeyHit(KEY_Z)
				rot:+1
				If rot &gt; 3 rot = 0
				LoadShape(szShape, rot)
				RemoveFromScreen()
				CopyToScreen()
			End If
			If Timer &gt; 20
				Translate(0, 1)
				Timer = 0
			End If
			Timer:+1
		End If
	End Method
	
	Method CopyToScreen:Byte()
		For Local _x = 0 To 3
			For Local _y = 0 To 3
				If Shape[_x, _y] &lt;&gt; 0 And Screen[ax + _x, ay + _y] &lt;&gt; 0
					Return False
				End If
			Next
		Next
		For _x = 0 To 3
			For _y = 0 To 3
				If Shape[_x, _y] &lt;&gt; 0 And Screen[ax + _x, ay + _y] = 0
					Screen[ax + _x, ay + _y] = Shape[_x, _y]
				End If
			Next
		Next
		Return True
	End Method
	
	Method RemoveFromScreen()
		For _x = 0 To Length
			For _y = 0 To height
				If Screen[ax + _x, ay + _y] &lt;&gt; 10 Screen[ax + _x, ay + _y] = 0
			Next
		Next
	End Method
	
	Method Translate(distx:Int, disty:Int)
		If ax + distx &lt; 0 Return
		If ax + distx + Length &gt; 24 Return
		RemoveFromScreen()
		ax:+distx
		ay:+disty
		If Not CopyToScreen()
			ax:-distx
			ay:-disty
			CopyToScreen()
			Solidify()
		End If
		If ay+height = 23 Solidify() 
	End Method
	Method Solidify()
		For _x = 0 To Length
			For _y = 0 To height
				If Screen[ax + _x, ay + _y] = 1 Screen[ax + _x, ay + _y] = 10
			Next
		Next
		Placed = True
	End Method
	Method LoadShape(_shape:String, rotation:Int)
		Local data:Int
		Select _shape
			Case "L"
				Select rotation
					Case 0
						RestoreData L0
						Length = 3
						height = 3
					Case 1
						RestoreData L90
						Length = 3
						height = 2
					Case 2
						RestoreData L180
						Length = 2
						height = 3
					Case 3
						RestoreData L270
						Length = 3
						height = 2
				End Select
			Case "O"
				Select rotation
					Case 0
						RestoreData O0
						Length = 2
						height = 2
					Case 1
						RestoreData O0
						Length = 2
						height = 2
					Case 2
						RestoreData O0
						Length = 2
						height = 2
					Case 3
						RestoreData O0
						Length = 2
						height = 2
				End Select
			Case "I"
				Select rotation
					Case 0
						RestoreData I0
						Length = 4
						height = 1
					Case 1
						RestoreData I90
						Length = 1
						height = 4
					Case 2
						RestoreData I0
						Length = 4
						height = 1
					Case 3
						RestoreData I90
						Length = 1
						height = 4
				End Select
			Case "T"
				Select rotation
					Case 0
						RestoreData T0
						Length = 3
						height = 2
					Case 1
						RestoreData T90
						Length = 2
						height = 3
					Case 2
						RestoreData T180
						Length = 3
						height = 2
					Case 3
						RestoreData T270
						Length = 2
						height = 3
				End Select
			Case "S"
				Select rotation
					Case 0
						RestoreData S0
						Length = 4
						height = 2
					Case 1
						RestoreData S90
						Length = 2
						height = 4
					Case 2
						RestoreData S0
						Length = 4
						height = 2
					Case 3
						RestoreData S90
						Length = 2
						height = 4
				End Select
			Case "J"
				Select rotation
					Case 0
						RestoreData J0
						Length = 3
						height = 3
					Case 1
						RestoreData J90
						Length = 3
						height = 2
					Case 2
						RestoreData J180
						Length = 2
						height = 3
					Case 3
						RestoreData J270
						Length = 3
						height = 2
				End Select
			Case "Z"
				Select rotation
					Case 0
						RestoreData Z0
						Length = 3
						height = 2
					Case 1
						RestoreData Z90
						Length = 2
						height = 3
					Case 2
						RestoreData Z0
						Length = 3
						height = 2
					Case 3
						RestoreData Z90
						Length = 2
						height = 3
				End Select
		End Select
		For Local _x:Int = 0 To 3
			For Local _y:Int = 0 To 3
				ReadData data
					Shape[_x, _y] = data
			Next
		Next
	End Method
	
	Function UpdateAll()
		For Local i:TBlock = EachIn BlockList
			i.Update
		Next
	End Function
End Type
</textarea><br><br>And my peice data:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'L Shape
#L0
DefData 1, 0, 0, 0
DefData 1, 0, 0, 0
DefData 1, 1, 0, 0
DefData 0, 0, 0, 0

#L90
DefData 1, 1, 1, 0
DefData 1, 0, 0, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#L180
DefData 1, 1, 0, 0
DefData 0, 1, 0, 0
DefData 0, 1, 0, 0
DefData 0, 0, 0, 0

#L270
DefData 0, 0, 1, 0
DefData 1, 1, 1, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

'J Shape
#J0
DefData 0, 1, 0, 0
DefData 0, 1, 0, 0
DefData 1, 1, 0, 0
DefData 0, 0, 0, 0

#J90
DefData 1, 0, 0, 0
DefData 1, 1, 1, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#J180
DefData 1, 1, 0, 0
DefData 1, 0, 0, 0
DefData 1, 0, 0, 0
DefData 0, 0, 0, 0

#J270
DefData 1, 1, 1, 0
DefData 0, 0, 1, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

'I Shape
#I0
DefData 1, 1, 1, 1
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#I90
DefData 1, 0, 0, 0
DefData 1, 0, 0, 0
DefData 1, 0, 0, 0
DefData 1, 0, 0, 0

'O Shape
#O0
DefData 1, 1, 0, 0
DefData 1, 1, 0, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

'S Shape
#S0
DefData 0, 1, 1, 1
DefData 1, 1, 0, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#S90
DefData 1, 0, 0, 0
DefData 1, 1, 0, 0
DefData 0, 1, 0, 0
DefData 0, 0, 0, 0

'Z Shape
#Z0
DefData 1, 1, 0, 0
DefData 0, 1, 1, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#Z90
DefData 0, 1, 0, 0
DefData 1, 1, 0, 0
DefData 1, 0, 0, 0
DefData 0, 0, 0, 0

'TShape
#T0
DefData 0, 1, 0, 1
DefData 1, 1, 1, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#T90
DefData 1, 0, 0, 0
DefData 1, 1, 0, 0
DefData 1, 0, 0, 0
DefData 0, 0, 0, 0

#T180
DefData 1, 1, 1, 0
DefData 0, 1, 0, 0
DefData 0, 0, 0, 0
DefData 0, 0, 0, 0

#T270
DefData 0, 1, 0, 0
DefData 1, 1, 0, 0
DefData 0, 1, 0, 0
DefData 0, 0, 0, 0
</textarea> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
