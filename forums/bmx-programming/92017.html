<!DOCTYPE html><html lang="en" ><head ><title >Problems with code for a card game.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Problems with code for a card game.</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Problems with code for a card game.</a><br><br>
<a name="1047415"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey folks!<br><br>I'm working on a game engine for Solitaire type card games right now, and having<br>a tad of trouble.<br><br>I used this tutorial.<br><a href="http://www.informit.com/articles/article.aspx?p=130837&amp;seqNum=3" target="_blank">http://www.informit.com/articles/article.aspx?p=130837&amp;seqNum=3</a><br><br>But it's for Visual Basic. So I've been converting it all into BlitzMax, with a relative<br>degree of success.<br><br>However I've run into a snag ;)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80"> 'A beginning to the card calamity
'(OMG!)

Rem 
The library of routines presented in this chapter actually consists of two classes: clsCard And clsDeck. The clsCard class includes the data members And methods required To manipulate a 
single card, And the clsDeck class draws on the clsCard class To Create And manipulate a deck of 52 cards, each of which is an Object of the clsCard class. The clsDeck class also enables 
you To group card objects into hands. Listing 8.1 shows the source code For the clsCard class.
Listing 8.1 The clsCard Class
End Rem 

Graphics 1024,768,0,60
AutoMidHandle True 
SeedRnd MilliSecs()


Const MAXHANDS = 4

Global FaceDown:Int = False 
Global FaceUp:Int = True 
 

Global Diamonds$ = "Diamonds"
Global Clubs$ = "Clubs"
Global Spades$ = "Spades"
Global Hearts$ = "Hearts"
 
Global Ace$ = "Ace"
Global Two$ = "Two"
Global Three$ = "Three"
Global Four$ = "Four"
Global Five$ = "Five"
Global Six$ = "Six"
Global Seven$ = "Seven"
Global Eight$ = "Eight"
Global Nine$ = "Nine"
Global Ten$ = "Ten"
Global Jack$ = "Jack"
Global Queen$ = "Queen"
Global King$ = "King"

'///////////////////////////////////////////////////////////
'// The clsCard Class
'///////////////////////////////////////////////////////////

Type clsCard
Field m_xPosition:Int,m_yPosition:Int,m_value:Int 

'///////////////////////////////////////////////////////////
'// Class_Initialize
'///////////////////////////////////////////////////////////
Method Class_Initialize()
m_xPosition = -1
m_yPosition = -1
m_value = 0
End Method 
 
'///////////////////////////////////////////////////////////
'// Display
'//
'// This subroutine displays the card at the coordinates
'// x,y. The card is displayed face-up or face-down based
'// on the face parameter.
'///////////////////////////////////////////////////////////
Method Display(x:Int, y:Int, face:Int)
xPosition = x
yPosition = y
If face = FaceUp Then
	ShowFace()
Else
	ShowBack()
End If
End Method 

'///////////////////////////////////////////////////////////
'// ShowFace
'//
'// This subroutine displays the card's face. The card must
'// have been previously displayed with the Display()
'// subroutine, which sets the card's screen coordinates.
'///////////////////////////////////////////////////////////
Method ShowFace()
DrawImage (m_value), xPosition, yPosition
End Method

'///////////////////////////////////////////////////////////
'// ShowBack
'//
'// This subroutine displays the card's back. The card must
'// have been previously displayed with the Display()
'// subroutine function, which sets the card's screen
'// coordinates.
'///////////////////////////////////////////////////////////
Method ShowBack()
DrawImage (52), xPosition, yPosition
End Method 

'///////////////////////////////////////////////////////////
'// EraseCard
'//
'// This subroutine erases the card from the CardForm
'// display.
'///////////////////////////////////////////////////////////
Method EraseCard()
DrawImage (53), xPosition, yPosition
End Method

'///////////////////////////////////////////////////////////
'// Get and Let xPosition
'///////////////////////////////////////////////////////////
Method GetxPosition:Int()
xPosition = m_xPosition
End Method
 
Method LetxPosition(vNewValue:Int)
m_xPosition = vNewValue
End Method

'///////////////////////////////////////////////////////////
'// Get and Let yPosition
'///////////////////////////////////////////////////////////
Method GetyPosition:Int()
yPosition = m_yPosition
End Method 
 
Method LetyPosition(vNewValue:Int)
m_yPosition = vNewValue
End Method 
 
'///////////////////////////////////////////////////////////
'// Get and Let value
'///////////////////////////////////////////////////////////
Method Getvalue:Int() 
value = m_value
End Method
 
Method Letvalue(vNewValue:Int)
m_value = vNewValue
End Method 

Rem 
Analysis - The Display Method (Lines 27 through 35) displays the card Object at the pixel coordinates given as the Method's x and y parameters. The face parameter determines whether the card is displayed face-up (by calling the ShowFace method) or face-down (by calling the ShowBack method). The Display method saves the card's screen location in the object's xPosition and yPosition properties.
Analysis - The ShowFace Method (Lines 44 through 47) displays the card Object's face. The card must have been previously displayed with the Display method, which sets the card's screen coordinates and saves those coordinates in the xPosition and yPosition properties. ShowFace calls the PaintPicture method of the CardForm object (which should be your program's main form) to display the card image, which is one of the images in the Picture1 PictureBox control array.
Analysis - The ShowBack Method (Lines 57 through 60) displays the card's back. As with the ShowFace method, the card must have been previously displayed with the Display method, which sets the card's screen coordinates and saves them in the xPosition and yPosition properties. ShowBack calls the PaintPicture method of the CardForm object (which should be your program's main form) to display the card-back image, which is the next-to-last image in the Picture1 PictureBox control array.
Analysis - The EraseCard Method (Lines 68 through 71) erases a card from the screen. As with the ShowFace Method, the card must have been previously displayed with the Display Method, which sets the card's screen coordinates and saves them in the xPosition and yPosition properties. EraseCard calls PaintPicture method of the CardForm object (which should be your program's main form) to display the blank card image, which is the last image in the Picture1 PictureBox control array.
Analysis - The Get And Let methods For each of the properties (Lines 76 through 104) enable a program To obtain the values of the class Object's properties. You should use the Let methods with caution because it's not a good idea to change the property values unless you're very sure of what you're doing. For example, if you change a card's xPosition and yPosition properties, a card will be drawn on the screen in one place while the class object thinks the card is in another place.

In this class, the properties xPosition And yPosition (stored in the m_xPosition And m_yPosition variables) are the card's x,y screen coordinates, and value (stored in m_value) is the card's value (which is really more an ID than a card value). The m_value property can be a number from 0 to 51, with the cards numbered as they appear in Figure 8.1.

Figure 8.1
The order of the cards from ID 0 To 51.

You can use integer division To determine a card's suit. The formula is suit = value \ 13. This formula results in a value of 0, 1, 2, or 3, which indicates diamonds, clubs, spades, or hearts, respectively.

Use modulus division To determine a card's face value, as in the formula faceValue = value mod 13. This formula yields a result from 0 to 12, with 0 being an ace and 12 being a king. Of course, a specific card program must determine the actual point value of a card.

The clsCard class includes four methods, which are listed And described in Table 8.1.
Table 8.1 Methods of the clsCard Class
Method	
Description

Display(x As	
Sets the card's coordinates and displays the card at the x,y coordinates. The Integer, y As card is displayed face-up or face-down based on the face parameter, Integer, face which will be the value FaceUp or FaceDown.As Integer)

EraseCard	
Erases the card from the CardForm display.

ShowFace	
Displays the card's face. The card must have been previously displayed with the Display method, which sets the card's screen coordinates.

ShowBack	
Displays the card's back. The card must have been previously displayed with the Display method, which sets the card's screen coordinates.
End Rem 
End Type 



Rem 
Although Table 8.1 explains how the clsCard class works, you probably won't often need to access the clsCard class directly because it's handled mostly by the clsDeck class. The source code looks like Listing 8.2.
Listing 8.2 The clsDeck Class
End Rem 

'///////////////////////////////////////////////////////////
'// The clsDeck class
'///////////////////////////////////////////////////////////
Type Hand
Field PositionInHand:Int
Field cards:clsCard[52]
End Type


Type clsDeck
 
Field m_Hands:hand[5]'hand 
Field m_Cards:clsCard[52]'clsCard
Field m_PositionInDeck:Int 
Field m_NumCardsInHand:Int 
 
'///////////////////////////////////////////////////////////
'// Class_Initialize
'///////////////////////////////////////////////////////////
Method Class_Initialize()
Local i:Int

m_PositionInDeck = 0
For i = 0 To 51
m_Cards:clsCard[i] = New clsCard
m_Cards[i].m_value = i
Next
Init_Hands
End Method 

'///////////////////////////////////////////////////////////
'// Shuffle
'//
'// This subroutine shuffles the deck, resets the
'// m_PositionInDeck marker, and initializes the m_Hands.
'///////////////////////////////////////////////////////////
Method Shuffle()
Local CardNum:Int
Local temp:clsCard
Local i:Int 
 
m_PositionInDeck = 0
For i = 0 To 51
'CardNum = Int(Rnd * 52) 'Need to figure out what to do with this one...
CardNum = Rand(1,51)
temp = m_Cards(i)
m_Cards(i) = m_Cards(CardNum)
m_Cards(CardNum) = temp
Next
Init_Hands
End Method 

'///////////////////////////////////////////////////////////
'// Deal
'//
'// This subroutine deals num cards into the given hand,
'// displaying the cards on screen starting at x,y and
'// spacing them each one card width over plus the spacing
'// parameter. The parameter face controls whether the cards
'// are dealt face-up or face-down.
'///////////////////////////////////////////////////////////
Method Deal(num:Int, hand:Int, x:Int, y:Int, spacing:Int, face:Int)
Local pos:Int 
Local i:Int 
 
For i = 0 To num - 1
pos = m_Hands(hand).PositionInHand
m_Hands(hand).cards(pos) = m_Cards(m_PositionInDeck)
m_Cards(m_PositionInDeck).Display x, y, face
m_PositionInDeck = m_PositionInDeck + 1
If m_PositionInDeck &gt; 51 Then m_PositionInDeck = 0
m_Hands(hand).PositionInHand = m_Hands(hand).PositionInHand + 1
If m_Hands(hand).PositionInHand &gt; 51 Then m_Hands(hand).PositionInHand = 0
x = x + 56 + spacing
Next 
End Method 

'///////////////////////////////////////////////////////////
'// ShowHand
'//
'// This subroutine shows all the cards in the given hand
'// starting at the screen coordinates x,y and spaced
'// apart according to the spacing parameter. The cards
'// are displayed face-up or face-down depending on the
'// face parameter.
'///////////////////////////////////////////////////////////
Method ShowHand(hand:Int, x:Int, y:Int, spacing:Int, face:Int)
Local num:Int 
Local i:Int 
 
num = m_Hands(hand).PositionInHand
For i = 0 To num - 1
m_Hands(hand).cards(i).Display x, y, face
x = x + 56 + spacing
Next 
End Method 

'///////////////////////////////////////////////////////////
'// DealReplace
'//
'// This subroutine deals one card into the given hand,
'// replacing the card at the position pos. The parameter
'// face controls whether the card is displayed face-up
'// Or face-down.
'///////////////////////////////////////////////////////////
Method DealReplace(hand:Int, pos:Int, face:Int)
Local x:Int 
Local y:Int 
 
x = m_Hands(hand).cards(pos).m_xPosition
y = m_Hands(hand).cards(pos).m_yPosition
m_Hands(hand).cards(pos) = m_Cards(m_PositionInDeck)
m_Cards(m_PositionInDeck).Display x, y, face
m_PositionInDeck = m_PositionInDeck + 1
If m_PositionInDeck &gt; 51 Then m_PositionInDeck = 0
End Method 

'///////////////////////////////////////////////////////////
'// Discard
'//
'// This subroutine removes the card at position pos from
'// the hand specified bt the hand parameter.
'///////////////////////////////////////////////////////////
Method Discard(hand:Int, pos:Int)
Local x:Int 
Local y:Int 
Local DiscardPos:Int 
Local i:Int 

DiscardPos = m_Hands(MAXHANDS - 1).PositionInHand
m_Hands(MAXHANDS - 1).PositionInHand = m_Hands(MAXHANDS - 1).PositionInHand + 1
m_Hands(MAXHANDS - 1).cards(DiscardPos) = m_Hands(hand).cards(pos)
For i = pos To m_Hands(hand).PositionInHand - 1
m_Hands(hand).cards(i) = m_Hands(hand).cards(i + 1)
Next 
m_Hands(hand).PositionInHand = m_Hands(hand).PositionInHand - 1
End Method
 
'///////////////////////////////////////////////////////////
'// EraseCard
'//
'// This subroutine erases the card at position pos in
'// the hand specified by the hand parameter.
'///////////////////////////////////////////////////////////
Method EraseCard(HandNum:Int, pos:Int)
m_Hands(HandNum).cards(pos).EraseCard
End Method 
 
'///////////////////////////////////////////////////////////
'// ShowHandCard
'//
'// This subroutine displays the card at position pos in
'// the given hand. The parameter face controls whether
'// the card is displayed face-up or face-down.
'///////////////////////////////////////////////////////////
Method ShowHandCard(hand:Int, pos:Int, face:Int)
If face = FaceUp Then
m_Hands(hand).cards(pos).ShowFace
Else
m_Hands(hand).cards(pos).ShowBack
End If
End Method 

'///////////////////////////////////////////////////////////
'// MoveHandCard
'//
'// This subroutine moves the card at position pos in the
'// given hand to new screen coordinates. The parameter
'// face controls whether the card is displayed face-up or
'// face-down.
'///////////////////////////////////////////////////////////
Method MoveHandCard(hand:Int, pos:Int, x:Int, y:Int, face:Int)
m_Hands(hand).cards(pos).Display x, y, face
End Method 

'///////////////////////////////////////////////////////////
'// GetCardValue
'//
'// This function returns the value of the card at pos in
'// the given hand. The value is a number from 0 to 51.
'///////////////////////////////////////////////////////////
Method GetCardValue:Int(hand:Int, pos:Int)
G:Int = m_Hands(hand).cards(pos).m_value
Return G
End Method 
 
'///////////////////////////////////////////////////////////
'// Init_Hands
'//
'// This subroutine initializes the m_Hands property,
'// setting all cards in m_Hands to Nothing and setting
'// each hand's PositionInHand property to zero.
'///////////////////////////////////////////////////////////
Method Init_Hands()
Local i:Int 
Local j:Int 
 
For i = 0 To MAXHANDS - 1
m_Hands(i).PositionInHand = 0
For j = 0 To 51
m_Hands(i).cards(j) = Null
Next 
Next 
End Method

'///////////////////////////////////////////////////////////
'// Restore
'//
'// This subroutine sets the position in the deck back to
'// the beginning of the deck.
'///////////////////////////////////////////////////////////
Method Restore()
m_PositionInDeck = 0
End Method 
 
'///////////////////////////////////////////////////////////
'// Get NumCardsInHand
'///////////////////////////////////////////////////////////
Method GetNumCardsInHand:Int(hand:Int)
If hand &lt; 0 Or hand &gt; MAXHANDS - 1 Then RuntimeError("OMG, Something is out of bounds!")
NumCardsInHand = m_Hands(hand).PositionInHand
End Method 

End Type 

'Double-click the project's form in order to display the code window, and then type the following lines at the top of the program:

Global Deck:clsDeck = New clsDeck
'Deck.Shuffle()

MainLoopOMG()
Function MainLoopOMG()

While Not KeyDown(KEY_ESCAPE)

Command1_Click()

Flip ; Cls 
Wend 

End Function 

'The Deck Object will represent the deck of cards in the program.

Rem 
Analysis - In the class's Class_Initialize method, Line 18 ensures that the class is capable of producing a different shuffled deck every time it's used. Line 19 initializes the m_PositionInDeck property, and Lines 20 through 23 create 52 objects of the clsCard class. The Init_Hands call (Line 24) empties all the card hands.
Analysis - The Shuffle Method shuffles the deck (Lines 39 To 44) by swapping each card with another randomly selected card. The Method also resets the m_PositionInDeck marker (Line 38) To 0, which makes the first card in the deck the Next card To be drawn. Finally, the Method empties all hands (Line 45).
ANALYSIS - The Deal Method deals the requested number of cards (specified by the num parameter) into the hand specified by the hand parameter. The cards are displayed on the screen starting at x,y, with each card spaced one card width over plus the spacing parameter. The parameter face controls whether the cards are dealt face-up Or face-down. Line 62 begins a For statement that iterates once For each card To display. Inside the For loop, Line 63 gets the position in the hand To which the Current card should be dealt, And Line 64 sets the card in that hand position To the Next card in the deck. Line 65 calls the card Object's Display method to paint the card on the screen, and Lines 66 and 67 move the current position in the deck to the next card. Lines 68 to 71 move forward the location for the next card in the hand. Finally, Line 72 adds the spacing parameter to the horizontal position for the next card to display.
Analysis - This ShowHand Method shows all the cards in the given hand, starting at the screen coordinates x,y And spaced apart according To the spacing parameter. The cards are displayed face-up Or face-down depending on the face parameter. Line 90 gets the number of cards in the hand, And Lines 91 To 94 call each card Object's Display method to show the card on the screen. Notice how the Display method is a member of the currently indexed element of the cards() array, which is itself a member of the m_Hands() array.
Analysis - The DealReplace Method deals one card into the given hand, replacing the card at the position pos. The parameter face controls whether the card is displayed face-up Or face-down. Lines 110 And 111 get the coordinates of the card To Replace, And Line 112 places the Next card in the deck into the given position in the hand. Line 113 Then displays the New card on the screen. Finally, Lines 114 And 115 move the position in the deck To the Next card.
Analysis - The Discard Method removes the card at position pos from the hand specified by the hand parameter. Line 130 gets the Current position in the discard hand, And Lines 131 And 132 move the discard hand's current position forward one card. Line 133 removes the discarded card from the hand and places it into the discard hand, and then Lines 135 to 137 move the cards in the hand back one position in order to fill in the position where the discarded card used to be. Finally, Line 138 updates the position in the hand, setting it back one.
Analysis - The EraseCard Method erases the card at position pos in the hand specified by the hand parameter. Calling the card Object's EraseCard method is all that's required to erase the card from the screen.
Analysis - The ShowHandCard Method displays the card at position pos in the given hand. The parameter face controls whether the card is displayed face-up Or face-down. Lines 160 And 161 display the card's face if the face parameter is FaceUp, and Lines 162 and 163 display the card face-down if the face parameter is FaceDown.
Analysis - The MoveHandCard Method moves the card at position pos in the given hand To New screen coordinates. The parameter face controls whether the card is displayed face-up Or face-down. Line 177 calls the card Object's Display method to display the card in its new position.
Analysis - The GetCardValue Function returns the value of the card at pos in the given hand. The value is a number from 0 To 51 And is obtained from the card Object's value property in Line 188.
Analysis - The Init_Hands Method initializes the m_Hands property, setting all cards in m_Hands To Nothing (Lines 204 To 206) And setting each hand's PositionInHand property to zero (Line 203). 
Analysis - The Restore Method sets the position in the deck back To the beginning of the deck. It does this in Line 217 by setting m_PositionInDeck To 0. This Method is handy when you want To reuse the same deck of cards.

In the clsDeck class, the variable m_Cards is a 52-element array of clsCard objects. These objects make up the deck of cards. The integer m_PositionInDeck keeps track of the Next card To be dealt. That is, at the beginning of a program, m_PositionInDeck is 0, indicating that the first card in the deck will be dealt Next. Each time a card is dealt, m_PositionInDeck increments. When m_PositionInDeck equals 51, there's only one card left to deal in the deck. To avoid array-indexing errors, if your program tries to deal more than 52 cards before reshuffling the deck, m_PositionInDeck starts back at 0 and goes through the deck again.

The variable m_Hands is an array of hand objects, which is a user-defined data Type (defined in a Module called Cards.bas). The hand data Type is as follows:
Public Type hand
 PositionInHand:Int 
 cards(51) As clsCard
End Type

As you can see, the members of hand are similar To two members of the clsDeck class. The integer PositionInHand keeps track of the position in the hand where the Next card will be dealt. The array cards holds the clsCard objects that make up the hand.

Although you cannot anticipate all the different ways that you might need To manipulate a deck of cards, the clsDeck class includes 10 methods that you can call in your programs. These methods, which are listed in Table 8.2, enable you To program many card games without adding anything To the class. Study this table now so that you understand how To use the clsDeck class.
Table 8.2 Methods of the clsDeck Class
Member Function	
Description

Shuffle	
Shuffles the deck And resets the m_PositionInDeck marker. It also calls the Private member Function Init_Hands To initialize all eight hands that the clsDeck class handles.

Deal(num:Int ,	
Deals num cards into the hand specified by the hand parameter And hand:Int , x As displays the cards onscreen, starting at the coordinates x And y And Integer, y:Int , spacing the cards each one card-width over plus the spacing para-spacing:Int , meter. The parameter face must have the value FaceUp Or FaceDown,face:Int ) which controls whether the cards are dealt face-up Or face-down.

ShowHand(hand As	
Shows all the cards in the hand specified by hand, starting at the Integer, x:Int , screen coordinates x And y And spaced apart according To the spacingy:Int , spacing parameter. The cards are displayed face-up Or face-down depending:Int , face As on the face parameter with a value that must be either FaceUp Or Integer) FaceDown.

DealReplace(hand As	
Deals one card into the given hand, replacing the card at the position Integer, pos As pos. The parameter face, which must be the value FaceUp Or FaceDown Integer, face As controls whether the cards are displayed face-up Or face-down.Integer)

EraseCard(HandNum As	
Erases the card at position pos in the hand specified by the HandNum Integer, pos As parameter.Integer)

Discard(hand As	
Removes the card at position pos from hands(hand), placing the card Integer, pos As into hands(7), which is the discard pile.Integer)

Sub ShowHandCard(hand	
Displays the card at position pos in the given hand. The parameter:Int , pos As face, which must have the value FaceUp Or FaceDown, controls Integer, face As whether the cards are displayed face-up Or face-down.Integer)

MoveHandCard(hand As	
Moves the card at position pos in the given hand To the New screenInteger, pos As coordinates, x And y. The parameter face, which must have the value Integer, x:Int , FaceUp Or FaceDown, controls whether the card is displayed face-up y:Int , face As Or face-down.Integer)

GetCardValue(hand As	
Returns the value of the card at the position pos in the given hand. Integer, pos As The value is a number from 0 To 51.Integer)

Restore	
Sets the m_PositionInDeck data member back To 0, restoring the deck To the state it was in before the program dealt the first card.
End Rem 

Rem 
Demonstrating the clsCard And clsDeck Classes

Now that you've looked over the classes, you might be a little unsure exactly how to use them in your own programs. In this section, you'll build a demo program that puts the classes to work.
Building the Program

Follow these steps To Create the demo program:

Start a New Standard EXE Visual Basic project.

Set the following form properties To the values shown here. (Note that the form must be named CardForm because that's the name the clsDeck class expects it to have.)

Name = CardForm

AutoRedraw = True

BackColor = Black

Height = 7815

ScaleMode = Pixel

Width = 7995

Add a CommandButton control To the form, giving it the following properties:

Caption = "Test Cards"

Height = 40

Left = 18

Top = 439

Width = 144

Use the Add Form command on the Project menu To add the frmCards.frm form file To the project. You can find this form in the Classes folder of this book's CD-ROM. The frmCards.frm contains the card images, as you can see in Figure 8.2.

You need this form because it contains the card images.

Use the Add Class Module command on the Project menu To add the clsCard.Cls And clsDeck.Cls class Module files To the project. You can find these class modules in the Classes folder of this book's CD-ROM.

In order To use the clsCard And clsDeck classes in your program, you must add their files To your project, which you did in this Step.

Figure 8.2
The frmCards.frm form.

Use the Add Module command on the Project menu To add the Cards.bas Module file To the project. You can find this Module in the Classes folder of this book's CD-ROM.

The Cards.bas Module defines the constants, enumerations, And types needed by the program And the classes, as you can see in Listing 8.3.
Listing 8.3 The Cards.bas Module

End Rem 



'Add To the code window the command button handler For the form Object, shown in Listing 8.5. You can either Type the code Or copy it from the Cards2.txt file, which you can find in the Chap08\Code directory of this book's CD-ROM.
'Listing 8.5 The Command1_Click Handler
Function Command1_Click()
  Select TestNumber
  Case 0
   ShowFullDeck
  Case 1
   ShowShuffledDeck
  Case 2
   ShowFaceDownDeck
  Case 3
   Deal7CardHand
  Case 4
   ShowFaceDownHand
  Case 5
   ShowFaceUpHand
  Case 6
   ReplaceTwoCards
  Case 7
   DiscardEachCard
  Case 8
   MoveCards
  End Select
  TestNumber = TestNumber + 1
WaitKey 
FlushKeys 
  If TestNumber &gt; 8 Then
   TestNumber = 0
   Deck = Null 
  End If
End Function 
'Analysis - The command button handler calls a different subroutine depending upon the value of the TestNumber variable. This causes the program To cycle through the various tests of the clsDeck And clsCard classes.

'Add To the code window the general program subroutines shown in Listing 8.6, which are the subroutines that actually put the classes To the test. You can either Type the code Or copy 
'it from the Cards3.txt file, which you can find in the Chap08\Code directory of this book's CD-ROM.
'Listing 8.6 The General Subroutines
Function ShowFullDeck()
  'Local Deck = New clsDeck
  Cls
  CurrentX = 250
  CurrentY = 430
  Print "Full Unshuffled Deck"
  Deck.Deal 13, 0, 20, 20, -20, FaceUp
  Deck.Deal 13, 1, 20, 120, -20, FaceUp
  Deck.Deal 13, 2, 20, 220, -20, FaceUp
  Deck.Deal 13, 3, 20, 320, -20, FaceUp
End Function 
 
Function ShowShuffledDeck()
 Cls
 CurrentX = 250
 CurrentY = 430
 Print "Full Shuffled Deck"
 Deck.Shuffle
 Deck.Deal 13, 0, 20, 20, -20, FaceUp
 Deck.Deal 13, 1, 20, 120, -20, FaceUp
 Deck.Deal 13, 2, 20, 220, -20, FaceUp
 Deck.Deal 13, 3, 20, 320, -20, FaceUp
End Function
 
Function ShowFaceDownDeck()
 Cls
 CurrentX = 250
 CurrentY = 430
 Print "Full Face Down Deck"
 Deck.Deal 13, 0, 20, 20, -20, FaceDown
 Deck.Deal 13, 1, 20, 120, -20, FaceDown
 Deck.Deal 13, 2, 20, 220, -20, FaceDown
 Deck.Deal 13, 3, 20, 320, -20, FaceDown
End Function 
 
Function Deal7CardHand()
 Cls
 CurrentX = 250
 CurrentY = 430
 Print "7-Card Hand"
 Deck.Shuffle
 Deck.Deal 7, 0, 20, 20, 10, FaceUp
End Function
 
Function ShowFaceDownHand()
 Local i:Int

 Cls
 CurrentX = 250
 CurrentY = 430
 Print "Face Down Hand"
 For i = 0 To 6
 Deck.ShowHandCard 0, i, FaceDown
 Next 
End Function 
 
Function ShowFaceUpHand()
 Local i:Int 
 
 Cls
 CurrentX = 250
 CurrentY = 430
 Print "Face Up Hand"
 For i = 0 To 6
 Deck.ShowHandCard 0, i, FaceUp
 Next 
End Function
 
Function ReplaceTwoCards()
 Local i:Int 
 
 PrepareScreen
 Print "Replace Two Cards"
 For i = 0 To 6
 Deck.ShowHandCard 0, i, FaceUp
 Next 
 Deck.DealReplace 0, 2, FaceDown
 Deck.DealReplace 0, 3, FaceDown
End Function
 
Function DiscardEachCard()
 Local i:Int 
 Local MsgBox

 PrepareScreen
 Print "Discard Cards"
 Deck.ShowHand 0, 20, 20, 10, FaceUp
 For i = 6 To 0 Step -1
 MsgBox=Confirm("Click OK to discard a card")
 Deck.EraseCard 0, i
 Deck.Discard 0, 0
 Deck.ShowHand 0, 20, 20, 10, FaceUp
 Deck.ShowHand 7, 20, 110, -20, FaceUp
 Next 
End Function
 
Function MoveCards()
 Local i:Int 
 
 PrepareScreen
 Print "Move Cards"
 For i = 0 To 6
 Deck.EraseCard 7, i
 Deck.MoveHandCard 7, i, i * 20 + 20, 200, FaceUp
 Next 
End Function 
 
Function PrepareScreen()
 Cls
 CurrentX = 250
 CurrentY = 430
End Function 

Rem 
Analysis - These subroutines are the guts of the program. You'll look at this source code in detail a little later in this chapter.

Save the project's form file as CardForm.frm and the project file as Cards.vbp.

You've now completed the Cards demo program.
Running the Demo Program

When you run this program, you first see the screen shown in Figure 8.3. Here the program has dealt four hands of 13 cards each, all before shuffling the deck. As you can see, all the cards are in order. When you press Enter, the program shuffles the cards And redeals the four hands, as shown in Figure 8.4. You can see that the cards were indeed shuffled, so the program deals them randomly. Press Enter again And the program deals the same cards face-down.

Figure 8.3
The unshuffled deck.

After showing the entire deck, the program manipulates the hand. Each time that you press Enter Or click the Test Cards button, the program performs a New Function on the Current hand. First, it deals a seven-card hand And displays it face-up. The program Then shows the hand face-down And again face-up.

Figure 8.4
The deck after shuffling.

Next, the program deals two New face-down cards into the hand (see Figure 8.5) And Then reveals them by turning them over. Then, each time you press Enter, the program discards a card from the hand And displays the New discard pile. Finally, the program moves the discard pile To a New location on the screen.

Figure 8.5
Dealing New cards into a hand.
Using the clsDeck Class

The demonstration program shows most of what you need To know To use the clsDeck class. Before the program can access the clsDeck class, it must Create a Deck Object:
Dim Deck As clsDeck

Now, To deal four, 13-card hands from the deck, the program calls the Deal subroutine four times:

 Deck.Deal 13, 0, 20, 20, -20, FaceUp
 Deck.Deal 13, 1, 20, 120, -20, FaceUp
 Deck.Deal 13, 2, 20, 220, -20, FaceUp
 Deck.Deal 13, 3, 20, 320, -20, FaceUp

The Deal Method's arguments are the number of cards to deal, the hand where the cards will be dealt, the x,y screen coordinates of the first card in the hand, the onscreen distance between each card in the hand, and the cards' orientation (either FaceUp or FaceDown). In the preceding code segment, notice that the distance between the cards is -20. A negative distance causes the cards to appear overlapped. Positive distances separate the right and left edges of adjacent cards by the given number of pixels.

Because the cards in the Deck Object are all in order, the deck must be shuffled:
 Deck.Shuffle

After the shuffle, the program redeals the 13-card hands in random order:
 Deck.Deal 13, 0, 20, 20, -20, FaceUp
 Deck.Deal 13, 1, 20, 120, -20, FaceUp
 Deck.Deal 13, 2, 20, 220, -20, FaceUp
 Deck.Deal 13, 3, 20, 320, -20, FaceUp

Next, the program deals a seven-card hand, which is displayed onscreen first face-up And Then face-down. The program switches the cards' orientation by using the ShowHandCard method, which can display any card face-up or face-down:
 For i = 0 To 6
  Deck.ShowHandCard 0, i, FaceUp
 Next I

The arguments For ShowHandCard are the number of the hand where the card is located, the card's position in the hand (starting at 0 for the first card), and the card's new orientation (either FaceUp or FaceDown).

To Replace cards in a hand, the program calls the DealReplace Method:
 Deck.DealReplace 0, 2, FaceDown
 Deck.DealReplace 0, 3, FaceDown

This Method's arguments are the number of the hand where the card to be replaced is located, the position in the hand of the card to be replaced, and the orientation of the new card's display. Note that DealReplace does not add replaced cards to the discard pile. To add cards to the discard pile, you must call the Discard method. The example program in Listing 8.7 does this.
Listing 8.7 Discarding Cards
End Rem 

Rem 
1:  For i = 6 To 0 Step -1
2:   MsgBox "Click OK to discard a card"
3:   Deck.EraseCard 0, i
4:   Deck.Discard 0, 0
5:   Deck.ShowHand 0, 20, 20, 10, FaceUp
6:   Deck.ShowHand 7, 20, 110, -20, FaceUp
7: Next I
'Analysis - In the For loop, the program discards each card from the hand one at a time (Lines 3 And 4), displaying the New discard pile after each discard (Lines 5 And 6). The Discard Method's arguments are the number of the hand where cards must be discarded and the position within the hand of the card to discard. In the preceding code segment, Discard's arguments are always 0,0 because the first card in the hand is always the one being discarded. When a card is discarded, the other cards in the hand move back to fill in the empty space.

'Finally, the example program moves the discard pile To a New screen location by calling the MoveHandCard Method:
 For i = 0 To 6
  Deck.EraseCard 7, i
  Deck.MoveHandCard 7, i, i * 20 + 20, 200, FaceUp
 Next I

'MoveHandCard moves a single card To a New screen location. Its arguments are the number of the hand that holds the card To move, the position of the card in the hand, the New x,y coordinates For the card, And the card's orientation.





'Blackjack, Anyone?
End Rem 
</textarea><br><br>There's my code as it stands, with 3 Types, and a short function near the<br>bottom for testing all the functions to make sure things work.<br><br>I managed to create an instance of the clsDeck type, named Deck. When it<br>tries to access the Hand type though, it returns an error that the type doesn't<br>exist.<br><br>I'm pretty darn sure it's because I need to create type lists for everything, to<br>keep track of them. However since all 3 types interact with each other a LOT,<br>and some of the type fields reference other types, I'm getting a bit confused<br>as to how this all works out. I've never used types within types this much<br>before, and am not sure where to make calls to the type lists.<br><br>If someone could help me out, that would be really, really nice.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="1047427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> .<br><br>Even though the info was correct in the old post regarding arrays, I noticed the syntax wasnt, so, heres a quick version:-<br><br><pre class=code>
Type MyType
	Field arr:Int[] ' Not initialized

	Method New() ' This function is called when a new MyType is created with New
		arr = New Int[32]
		'or you could init with a normal for..loop and using New on each element
	End Method
End Type

Local a_type:MyType = New MyType

a_type.arr[16] = 10

Print a_type.arr[16]
</pre><br><br>Dabz <br><br></td></tr></table><br>
<a name="1047431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh My God.<br><br>That is some of the worst Blitz Code I have ever seen.<br><br><pre class=code>Method GetxPosition:Int()
xPosition = m_xPosition
End Method</pre><br>What the hell is that supposed to be??? A getter??? It's going in a global variable!!!<br><br>Ahem, sorry.<br><br><br><br><br>There is a reason why nobody takes Visual Basic seriously. Find a better tutorial before you are lost irreversibly to the dark programming gods.<br><br><br>And personally I can't stand prefixing members with "m_". If you can't keep track of what's a member and what isn't, you shouldn't be allowed to program. <br><br></td></tr></table><br>
<a name="1047456"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Dabz, thanks Dabz, I'll give that a shot ;)<br>And yes, I know I need to indent. I still need to clean up the code a lot, I just want<br>to get the basics working first.<br><br>@Czar Flavius<br><div class="quote">  That is some of the worst Blitz Code I have ever seen.  <br></div><br>I am fully aware of this fact ;)<br>Although I have now created my first commercial game, I am still very far away from being a 'clean' coder. I.e, someone who codes something that is well written, and easily understandable.<br><br>Also keep in mind that for a lot of this I'm just giving it my best guess, since I have<br>0 experience with Visual Basic. I'm converting it as best as I can.<br><br>I had no clue what the m_ is for, so I just left them all in there.<br>This is the best tutorial I could find, and does(Supposedly) everything I want<br>my game to do. I just need to figure out how to convert it.<br><br>I'll try Dabz suggestion(Keep in mind, I only started using arrays a month ago, so<br>I'm still relatively new at them), and see what that does.<br><br>Thanks! <br><br></td></tr></table><br>
<a name="1047464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I had no clue what the m_ is for, so I just left them all in there.<br> <br></div><br><br>Generally, the m_ prefix means that its a member variable of a type/class (In some cases it may suggest the variables scope, like if a variable is private)... Its just a naming convention really, like how we put a capital 'T' at the start of our Type names: eg<br><br>Type TWorld<br>End Type<br><br>Type TMenu<br>End Type<br><br>etc etc<br><br>Dabz <br><br></td></tr></table><br>
<a name="1047465"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the clarification Dabz! <br><br></td></tr></table><br>
<a name="1047468"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> You've also got to remember that when converting from one platform to another, you really need to know the intimate behavior of the one your converting from, so you can make compromises in the platform your converting too.<br><br>Take converting BlitzMax to XNA... Pretty simple, the main coding doesnt take much converting to C#, but, if you didnt know XNA uses radians instead of degrees, your gonna see some odd results, but, if you know this, you can quickly knock out a small bit of code to convert between the two and your away!<br><br>You are probably better off rolling up your sleeves and trying to build something yourself if no code for Blitzmax is lying around, this will essentially save you a lot of hard work when you try to change or add to your code in the future, because for one, its in a language you know well, and two, its your own code.<br><br>:)<br><br>Dabz <br><br></td></tr></table><br>
<a name="1047483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I created cardsLib.bmx that include all of the basic types clsCard and clsDeck, cardForm and Hand:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Const MAXHANDS:Int = 8

Const FaceDown:Int = 1
Const FaceUp:Int = 2
 
Const Diamonds:Int = 1
Const Clubs:Int = 2
Const Spades:Int = 3
Const Hearts:Int = 4

Const Ace:Int = 1
Const Two:Int = 2
Const Three:Int = 3
Const Four:Int = 4
Const Five:Int = 5
Const Six:Int = 6
Const Seven:Int = 7
Const Eight:Int = 8
Const Nine:Int = 9
Const Ten:Int = 10
Const Jack:Int = 11
Const Queen:Int = 12
Const King:Int = 13

 '///////////////////////////////////////////////////////////
 '// The clsCard Class
 '///////////////////////////////////////////////////////////
Type clsCard  

	Field _xPosition:Int
	Field _yPosition:Int
	Field _value:Int
		 
	'///////////////////////////////////////////////////////////
	'// Class_Initialize
	'///////////////////////////////////////////////////////////
	Method Initialize()
		_xPosition = -1
		_yPosition = -1
		_value = 0
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Display
	'//
	'// This methodroutine displays the card at the coordinates
	'// x,y. The card is displayed face-up or face-down based
	'// on the face parameter.
	'///////////////////////////////////////////////////////////
	Method Display(x:Int, y:Int, face:Int)
		_xPosition = x
		_yPosition = y
		If face = FaceUp Then
			ShowFace
		Else
			ShowBack
		End If
	End Method

	'///////////////////////////////////////////////////////////
	'// ShowFace
	'//
	'// This methodroutine displays the card's face. The card must
	'// have been previously displayed with the Display()
	'// methodroutine, which sets the card's screen coordinates.
	'///////////////////////////////////////////////////////////
	Method ShowFace()
		CardForm.PaintPicture _value, _xPosition, _yPosition
	End Method
 
	'///////////////////////////////////////////////////////////
	'// ShowBack
	'//
	'// This methodroutine displays the card's back. The card must
	'// have been previously displayed with the Display()
	'// methodroutine method, which sets the card's screen
	'// coordinates.
	'///////////////////////////////////////////////////////////
	Method ShowBack()
		CardForm.PaintPicture 52, _xPosition, _yPosition
	End Method

	'///////////////////////////////////////////////////////////
	'// EraseCard
	'//
	'// This methodroutine erases the card from the CardForm
	'// display.
	'///////////////////////////////////////////////////////////
	Method EraseCard()
		CardForm.PaintPicture 53, _xPosition, _yPosition
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Get and Let xPosition
	'///////////////////////////////////////////////////////////
	Method GetPositionx:Int()
		Return _xPosition
	End Method
 
	Method SetPositionX(vNewValue:Int)
		_xPosition = vNewValue
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Get and Let yPosition
	'///////////////////////////////////////////////////////////
	Method GetPositiony:Int()
		Return _yPosition
	End Method
 
	Method SetPositiony(vNewValue:Int)
		_yPosition = vNewValue
	End Method

	'///////////////////////////////////////////////////////////
	'// Get And Let value
	'///////////////////////////////////////////////////////////
	Method GetValue:Int()
		Return _value
	End Method
 
	Method SetaValue(vNewValue:Int)
		_value = vNewValue
	End Method
End Type

'///////////////////////////////////////////////////////////
'// The clsDeck class
'///////////////////////////////////////////////////////////
 
Type clsDeck

	Field _Hands:hand[MAXHANDS] 
	Field _Cards:clsCard[52]
	Field _PositionInDeck:Int
	Field _NumCardsInHand:Int
 
	'///////////////////////////////////////////////////////////
	'// Class_Initialize
	'///////////////////////////////////////////////////////////
	Method Initialize()
		Local i:Int
		SeedRnd MilliSecs()
		_PositionInDeck = 0
		For i = 0 To 51
			_Cards[i] = New clsCard
	 		_Cards[i]._value = i
		Next
		Init_Hands
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Shuffle
	'//
	'// This methodroutine shuffles the deck, resets the
	'// _PositionInDeck marker, and initializes the _Hands.
	'///////////////////////////////////////////////////////////
	Method Shuffle()
		Local CardNum:Int
		Local temp:clsCard
		Local i:Int
		 
		_PositionInDeck = 0
		For i = 0 To 51
			CardNum = Rand(0,51)
			temp = _Cards[i]
			_Cards[i] = _Cards[CardNum]
			_Cards[CardNum] = temp
		Next
		Init_Hands
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Deal
	'//
	'// This methodroutine deals num cards into the given hand,
	'// displaying the cards on screen starting at x,y and
	'// spacing them each one card width over plus the spacing
	'// parameter. The parameter face controls whether the cards
	'// are dealt face-up or face-down.
	'///////////////////////////////////////////////////////////
	Method Deal(num:Int, hand:Int, x:Int, y:Int, spacing:Int, face:Int)
		Local pos:Int
		Local i:Int
		For i = 0 To num - 1
			pos = _Hands[hand].PositionInHand
			_Hands[hand].cards[pos] = _Cards[_PositionInDeck]
			_Cards[_PositionInDeck].Display x, y, face
			_PositionInDeck = _PositionInDeck + 1
			If _PositionInDeck &gt; 51 Then _PositionInDeck = 0
			_Hands[hand].PositionInHand = _Hands[hand].PositionInHand + 1
			If _Hands[hand].PositionInHand &gt; 51 Then _Hands[hand].PositionInHand = 0
			x = x + 56 + spacing
		Next
	End Method
 
	'///////////////////////////////////////////////////////////
	'// ShowHand
	'//
	'// This methodroutine shows all the cards in the given hand
	'// starting at the screen coordinates x,y and spaced
	'// apart according to the spacing parameter. The cards
	'// are displayed face-up or face-down depending on the
	'// face parameter.
	'///////////////////////////////////////////////////////////
	Method ShowHand(hand:Int, x:Int, y:Int, spacing:Int, face:Int)
		Local num:Int
		Local i:Int
 
		num = _Hands[hand].PositionInHand
		For i = 0 To num - 1
			_Hands[hand].cards[i].Display x, y, face
			x = x + 56 + spacing
		Next
	End Method
 
	'///////////////////////////////////////////////////////////
	'// DealReplace
	'//
	'// This methodroutine deals one card into the given hand,
	'// replacing the card at the position pos. The parameter
	'// face controls whether the card is displayed face-up
	'// or face-down.
	'///////////////////////////////////////////////////////////
	Method DealReplace(hand:Int, pos:Int, face:Int)
		Local x:Int
		Local y:Int

		x = _Hands[hand].cards[pos]._xPosition
		y = _Hands[hand].cards[pos]._yPosition
		_Hands[hand].cards[pos] = _Cards[_PositionInDeck]
		 _Cards[_PositionInDeck].Display x, y, face
		 _PositionInDeck = _PositionInDeck + 1
		 If _PositionInDeck &gt; 51 Then _PositionInDeck = 0
	End Method

	'///////////////////////////////////////////////////////////
	'// Discard
	'//
	'// This methodroutine removes the card at position pos from
	'// the hand specified bt the hand parameter.
	'///////////////////////////////////////////////////////////
	Method Discard(hand:Int, pos:Int)
		Local x:Int
		Local y:Int
		Local DiscardPos:Int
		Local i:Int
 
		DiscardPos = _Hands[MAXHANDS - 1].PositionInHand
		_Hands[MAXHANDS - 1].PositionInHand = _Hands[MAXHANDS - 1].PositionInHand + 1
		_Hands[MAXHANDS - 1].cards[DiscardPos] = _Hands[hand].cards[pos]
		For i = pos To _Hands[hand].PositionInHand - 1
			_Hands[hand].cards[i] = _Hands[hand].cards[i + 1]
		Next
		_Hands[hand].PositionInHand = _Hands[hand].PositionInHand - 1
	End Method
 
	'///////////////////////////////////////////////////////////
	'// EraseCard
	'//
	'// This methodroutine erases the card at position pos in
	'// the hand specified by the hand parameter.
	'///////////////////////////////////////////////////////////
	Method EraseCard(HandNum:Int, pos:Int)
		_Hands[HandNum].cards[pos].EraseCard
	End Method
 
	'///////////////////////////////////////////////////////////
	'// ShowHandCard
	'//
	'// This methodroutine displays the card at position pos in
	'// the given hand. The parameter face controls whether
	'// the card is displayed face-up or face-down.
	'///////////////////////////////////////////////////////////
	Method ShowHandCard(hand:Int, pos:Int, face:Int)
		If face = FaceUp Then
			_Hands[hand].cards[pos].ShowFace
		Else
			_Hands[hand].cards[pos].ShowBack
		End If
	End Method

	'///////////////////////////////////////////////////////////
	'// MoveHandCard
	'//
	'// This methodroutine moves the card at position pos in the
	'// given hand to new screen coordinates. The parameter
	'// face controls whether the card is displayed face-up or
	'// face-down.
	'///////////////////////////////////////////////////////////
	Method MoveHandCard(hand:Int, pos:Int, x:Int, y:Int, face:Int)
		_Hands[hand].cards[pos].Display x, y, face
	End Method
 
	'///////////////////////////////////////////////////////////
	'// GetCardValue
	'//
	'// This function returns the value of the card at pos in
	'// the given hand. The value is a number from 0 to 51.
	'///////////////////////////////////////////////////////////
	Method GetCardValue:Int(hand:Int, pos:Int)
		Return _Hands[hand].cards[pos]._value
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Init_Hands
	'//
	'// This methodroutine initializes the _Hands property,
	'// setting all cards in _Hands to Nothing and setting
	'// each hand's PositionInHand property to zero.
	'///////////////////////////////////////////////////////////
	Method Init_Hands()
		Local i:Int
		Local j:Int
		For i = 0 To MAXHANDS - 1
			_Hands[i] = New hand
			_Hands[i].PositionInHand = 0
			For j = 0 To 51
				_Hands[i].cards[j] = Null
			Next
		Next
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Restore
	'//
	'// This methodroutine sets the position in the deck back to
	'// the beginning of the deck.
	'///////////////////////////////////////////////////////////
	Method Restore()
		_PositionInDeck = 0
	End Method
 
	'///////////////////////////////////////////////////////////
	'// Get NumCardsInHand
	'///////////////////////////////////////////////////////////
	Method GetNumCardsInHand:Int(hand:Int)
		If hand &lt; 0 Or hand &gt; MAXHANDS - 1 Then Notify "Err.Raise 9"
		Return _Hands[hand].PositionInHand
	End Method
End Type


Type hand
	Field PositionInHand:Int
	Field cards:clsCard[52]
End Type

Type cardForm
	Global images:TImage

	Method New()
		images = LoadAnimImage("cards.png",48,60,0,54)
		If images = Null DebugLog "unable to load images"
	End Method
	
	Function paintPicture(num:Int, xPosition:Int,yPosition:Int)
		DrawImage images, xPosition,yPosition,num
	End Function
End Type

New cardForm
</textarea><br>this is as accurate as I can get it but there might be some errors(or not)  not tested enough. <br><br></td></tr></table><br>
<a name="1047489"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice work Jesse! :)<br><br>Dabz <br><br></td></tr></table><br>
<a name="1047497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Jesse!<br><br>Much appreciated :) <br><br></td></tr></table><br>
<a name="1047544"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> The code above was never tested as I had one hour to do it and post it.  I finally got some time to really try it out and discovered that there were quite a few errors so I updated the code above and added a type to load the images and modified the clsCard to display accordingly. it is still not complete but I am trying to test it and I am creating a type with the code posted on the link you posted WERDNA. <br><br>this is what I got so far(I'll finish it tomorrow):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SSuperStrict

Include "cardLib.bmx"

Type classTestCards
	Field Deck:clsDeck
	Field TestNumber:Int
	
	Method New()
		deck = New clsDeck
		deck.initialize
	End Method

	Method Form_Load()
		TestNumber = 0
	End Method

	Method Command1_Click()
		Select TestNumber
			Case 0
				ShowFullDeck
			Case 1
				ShowShuffledDeck
			Case 2
				ShowFaceDownDeck
			Case 3
				Deal7CardHand
			Case 4
				ShowFaceDownHand
			Case 5
				ShowFaceUpHand
			Case 6
				ReplaceTwoCards
			Case 7
				DiscardEachCard
			Case 8
				MoveCards
		End Select
		TestNumber = TestNumber + 1
		If TestNumber &gt; 8 Then
			TestNumber = 0
			Deck = Null
		End If
	End Method

	Method ShowFullDeck()
		Cls
		DrawText "Full Unshuffled Deck",250,600
		Deck.Deal 13, 0, 20, 20, -20, FaceUp
		Deck.Deal 13, 1, 20, 120, -20, FaceUp
		Deck.Deal 13, 2, 20, 220, -20, FaceUp
		Deck.Deal 13, 3, 20, 320, -20, FaceUp
	End Method

	Method ShowShuffledDeck()
		Cls
		DrawText "Full Shuffled Deck",250,600
		Deck.Shuffle
		Deck.Deal 13, 0, 20, 20, -20, FaceUp
		Deck.Deal 13, 1, 20, 120, -20, FaceUp
		Deck.Deal 13, 2, 20, 220, -20, FaceUp
		Deck.Deal 13, 3, 20, 320, -20, FaceUp
	End Method

	Method ShowFaceDownDeck()
		Cls
		DrawText "Full Face Down Deck",250,600
		Deck.Deal 13, 0, 20, 20, -20, FaceDown
		Deck.Deal 13, 1, 20, 120, -20, FaceDown
		Deck.Deal 13, 2, 20, 220, -20, FaceDown
		Deck.Deal 13, 3, 20, 320, -20, FaceDown
	End Method
	
	Method Deal7CardHand()
		Cls
		DrawText "7-Card Hand",250,600
		Deck.Shuffle
		Deck.Deal 7, 0, 20, 20, 10, FaceUp
		End Method

	Method ShowFaceDownHand()
		Local i:Int

		Cls
		DrawText "Face Down Hand",250,600
		For i = 0 To 6
			Deck.ShowHandCard 0, i, FaceDown
		Next
	End Method

	Method ShowFaceUpHand()
		Local i:Int

		Cls
		DrawText "Face Up Hand",250,600
		For i = 0 To 6
			Deck.ShowHandCard 0, i, FaceUp
		Next
	End Method

	Method ReplaceTwoCards()
		Local i:Int

		Cls
		DrawText "Replace Two Cards",250,600
		For i = 0 To 6
			Deck.ShowHandCard 0, i, FaceUp
		Next
		Deck.DealReplace 0, 2, FaceDown
		Deck.DealReplace 0, 3, FaceDown
	End Method

	Method DiscardEachCard()
		Local i:Int

		Cls
		DrawText "Discard Cards",250,600
		Deck.ShowHand 0, 20, 20, 10, FaceUp
		For i = 6 To 0 Step -1
			Notify "Click OK to discard a card"
			Deck.EraseCard 0, i
			Deck.Discard 0, 0
			Deck.ShowHand 0, 20, 20, 10, FaceUp
			Deck.ShowHand 7, 20, 110, -20, FaceUp
		Next
	End Method

	Method MoveCards()
		Local  i:Int
 
		Cls
		DrawText "Move Cards",250,600
		For i = 0 To 6
			Deck.EraseCard 7, i
			Deck.MoveHandCard 7, i, i * 20 + 20, 200, FaceUp
		Next
	End Method
 
End Type

Graphics 900,700
Local testCards:classTestCards = New classTestCards

For Local n:Int = 1 To 9
	Cls
	testcards.command1_click()
	Flip()
	WaitKey()
Next

</textarea><br><br>[edited]<br> working demo now. <br><br></td></tr></table><br>
<a name="1047599"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Really appreciate the help Jesse!<br><br>And omg, paypal does to!<br><br>Check your e-mail ;) <br><br></td></tr></table><br>
<a name="1047609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh, you shouldn't have but thanks anyway. I don't do it to get payed. I do it to help others and myself at the same time. Besides, it was not that difficult.  Most of it was search and replace except for the annoying line numbers.<br><br>I made a spider solitaire game a while ago that I wanted to compare code with the one from your link. That was my main interest and the fact that I had some free time and wanted to challenge myself to see if I could do it. I programmed in Visual Basic for a couple of months but that was the first year it came out.  I left it because it wasn't working for me as I hoped. I did noticed that some of the stuff was a little bit different than I originally remembered. <br><br>I will keep working on it to see if I can get the engine working correctly.  I will post a working demo when and if I get it running. No guarantee. <br><br></td></tr></table><br>
<a name="1047650"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cheers WERDNA,<br>I think I have it now! I tried it with a dummy deck and it looks like it's working.<br> <br>To use it, set the "CardForm " "new" method to load the cards graphics and it will work properly. there might be some bugs that I am not aware of but if someone points them out I might be able to fix them. <br><br>I used cards graphics that don't have a black image so I couldn't tell if it was deleting them or not.<br><br>I updated my last post that has source code with the updated demo code. <br><br></td></tr></table><br>
<a name="1047651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> You deserved payment. You saved me a great deal of time and effort :)<br><br>Using the code that you posted(With a few modifications), I managed to get it up<br>and working. I can now use any of the functions and methods, I just need to put it<br>all together into a game now. Which won't be too hard now that the basics are done.<br><br>The main problem was in the Init_Hands method.<br><br>A new hand was never created, thus I nothing to hold the code up with and got<br>errors.<br><br><br>But I think it all works fine now, so thanks for the help!<br><br>I might like to hire you for a bit of codework in the future if I get stuck again, lol. <br><br></td></tr></table><br>
<a name="1047652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes I made the mistake of  creating a new deck after auto creating and initializing it.<br>I did fixed the code above. I don't know if you seen it sense I thing we were posting at the same time. <br><br></td></tr></table><br>
<a name="1047679"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >WERDNA</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I saw when reading my post for typo's ;)<br><br>Thanks a bundle!<br><br>I really appreciate it! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
