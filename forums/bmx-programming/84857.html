<!DOCTYPE html><html lang="en" ><head ><title >Optimization idea</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Optimization idea</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Optimization idea</a><br><br>
<a name="959028"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just thought about this:<br><br>If switching render states is expensive, then can't we minimize those by ordering the renders so that there's as few switches as possible?<br><br>Well, there's no way to easily do it, since if you want to have overlapping items, you have to draw them in a specific order.<br><br>However, isn't bmax acually ortographic 3d? And if it is, can the zordering not be affected to be able to sort items by blend mode?<br><br>The downside is that its not something that can be written inside the bmax engine, since this changes the way programs must be designed. However, I'm still interested if this can be done "manually".<br><br>As my game is supposed to both look good and run fast on Intel GMAs, I really want to squeeze anything I can out of it, and this kind of optimization might help others as well.<br><br>Cheers,<br>JIM <br><br></td></tr></table><br>
<a name="959055"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >beanage</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a really great idea.. I really had use for this in my fullscreen ui window system (dont ask)..<br><br>Maybe you could implement something like "drawing layers", or "zorder layers" .. default layer would be zero so normal bmax 2d functionality is maintained, then you call for e.g.<br>Type extRenderLayer<br>* extAddRenderLayer()<br>* extSetCurrentRenderLayer()<br>* extMoveRenderLayer()<br>* extRemoveRenderLayer()<br><br>also Flip() would only refer to the current layer .. the other layers stay untouched, and the whole thing gets drawn in the order specified by the layers zcoords..<br>mmh maybe this equally could form a simple implementation of FBOs, couldnt it?<br><br>[edit]: wouldnt this be easy to code in via a mod? <br><br></td></tr></table><br>
<a name="959061"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm... I was thinking about something else :)<br><br>Like, lets say you have a RED square, then over it a GREEN circle, and over it a RED triangle.<br><br>The old way you'd have:<br><br><pre class=code>
SetColor(255,0,0)
DrawSquare()
SetColor(0,255,0)
DrawCircle()
SetColor(255,0,0)
DrawTriangle()
</pre><br><br>The new way would be:<br><br><pre class=code>
SetColor(255,0,0)
DrawSquare(2)
DrawTriangle(0)
SetColor(0,255,0)
DrawCircle(1)
</pre><br><br>Your idea is similar, but not quite the same. Nevertheless, a good feature anyway.<br><br>What I'm affraid of though is that I'm going to have to wrap/rewrite most/all of the drawing functions. Also, I'm not sure if the rendering is ortographic or not. <br><br></td></tr></table><br>
<a name="959103"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> You'd really have better luck writing a new Max2D driver from the ground up. <br><br></td></tr></table><br>
<a name="959196"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Waking up this morning, I thought that this wouldn't work for overlapped objects with 8 bit alpha, as they would need to be drawn in a specific order.<br><br><div class="quote"> <br>You'd really have better luck writing a new Max2D driver from the ground up. <br> <br></div><br><br>This is tempting, but I don't have the time right now. Also, I might need to run a few tests and see if the performance imrovement is worth the effort. If  a new driver is the only way, then there's room for a whole lot of other changes that could speed up the rendering. <br><br></td></tr></table><br>
<a name="959226"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fetze</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using Z-Ordering without ordering your non-Maskblend object draw calls by their z-value, you'll mess up blending and SetBLend will be useless.<br><br>If you intend to only draw Maskblended or Solidblended stuff, utilizing the z-Buffer is a great idea. But you'll have to sort by yourself as before as soon as you implement graphics that uses any other blendmode. Most particles for example.<br><br>Also, on modern graphic cards, I believe the state change overhead is nothing in matters of time usage - you'll most likely get a far higher performance increase if optimizing your code properly in matters of collision detection or culling. <br><br></td></tr></table><br>
<a name="959234"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >beanage</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @anotherjim: Aaah, better got your point now.. ok, my idea (or my interpretation of your idea) is different, but may end up with kinda the same features, and a render-to-texture implementation in addition..<br>anyone knowing bplus here? missing something like the setbuffer() functionality in max .. this could be it.<br>Mmmmh therefore the question occurs, if switching fbos is less expensive then switching renderstates like color, rotation, scale etc.. sure not. ok, in the context, my idea is useless :(.<br><br>Anyway, i think i will code a prototype of it, hence the features look too promising to simply forget about it \:<br><br>@fetze: .. an intel gma isnt much of a modern graphics card, isnt it :) <br><br></td></tr></table><br>
<a name="959237"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >beanage</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> [edit:] mmmh, thinking about it, why not finally implementing an "objective graphics" sytem, performing the renderstate change minimazation automatically?<br><br>red = CreateColor( 255,0,0 )<br>green = CreateColor( 0,255,0 )<br>mytri = CreateTriangle( red,0 )<br>mycircle = CreateCircle( green,1 )<br>myrect = CreateRectangle( red,2 )<br><br>repeat{ DrawObjects() }<br><br>.. mind-blowing. But it would be really hard work in programming and dev, and i must admit i am too much of a EXT_gl_newb to code this.. any guru here with time and patience^^? mark? o0 he doesnt hear me :( <br><br></td></tr></table><br>
<a name="959239"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @BeAnAge<br><br>I was thinking about that when Nillium said I should write a new driver.<br><br>Since BMax has a 3D engine, why not treat it as a 3D engine? :)<br>But this would change the way BMax is used almost entirely, as it would move towards B3D:<br><br>UpdateWorld()<br>RenderWorld()<br><br>Also, treatin it this way, lots of other stuff could be done... static geometry, culling, etc. All of this would be automatically handled by the renderer. That would be cool, but time-consuming :)<br><br>Also, I need to find an Intel GMA fast and test stuff on it, cuz its pretty hard to target lowend cards on this PC :D Changing renderstates has absolutely no impact (not even 1 in 600 fps) on the speed. But I need to see how VIA Chrome 9 and Intel GMA 950 handle those. <br><br></td></tr></table><br>
<a name="959241"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >beanage</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh is see :D<br><br>glMax2DEngineDriver() .. hehe^^<br>it wouldnt just change how its used, it would be a COMPLETE REWRITE of all its graphics features!! Kinda blitzMax 2.0! And it would save us tons, tons, tons of work, hence we all actually have had to implement such an objective system into our apps ourselves, always and repetitive, hadnt we?<br><br>Couldnt this be an extension for the existing (none-used) max3d engine?<br><br>sry, talking outa my a**. <br><br></td></tr></table><br>
<a name="959249"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, I am tempted to start such a project. But as I said, I don't have the time now (exams :P).<br><br>Also, it would probably require more than one person's effort.<br><br>But, my original question has partially been answered: renderstates are not that expensive (except probably for a particle system with each particle different from the other) and this optimization could be done with lots of effort and quite a few limitations :) <br><br></td></tr></table><br>
<a name="959250"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >beanage</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> mmmh the funny thing is: i do my exams at the moment too.. here in germany we got the opportunity to do kinda "special learning performances" as replacement for a exam subject.. i already do a very experimental open source (maybe july)  engine project featuring ibr,fbp;multiprocess,nn ai and some more interesting stuff .. maybe i could include something like our glMax2DDriver2..<br>but the solutuions would be restricted to the engine usage.. and the engine is far future in terms of industries time calculation .. just wanted to point out its not everything lost :)<br><br>btw, i did some testing on gl switching states perf myself when i began designing my ib renderer; results where you can draw approx. 10000 quads switching the color each quad using plain max2d .. maybe that helps you.. dont ask for the apps source, its lost anywhere on my hd and i cant find it :| .. results where taken on a 1.6 ghz cpu + 32 mb onboard gpu laptop.. <br><br></td></tr></table><br>
<a name="959254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> 10000 quads on such a video card is very nice. My game will probably never hit 200 quads onscreen so switching renderstates is definately not the performance killer. :-) <br><br></td></tr></table><br>
<a name="959479"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know that switching blend modes is a significant performance penalty, it is more widely known that switching to a differently bound texture is one of the more time consuming activities. If you can make sure you are drawing many images from a single texture, or minimizing the number of times you switch to a different image, that will help probably more than worrying about blend modes. <br><br></td></tr></table><br>
<a name="959487"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I don't know that switching blend modes is a significant performance penalty, it is more widely known that switching to a differently bound texture is one of the more time consuming activities. If you can make sure you are drawing many images from a single texture, or minimizing the number of times you switch to a different image, that will help probably more than worrying about blend modes. <br> <br></div><br><br>Usefull piece of information there. But I doubt I could get more than 5-6 texture changes out of my rendering loop.<br><br>I'd appreciate more of those "not-so-obvious" or rather "obvious after they are pointed out" ways to optimize rendering.<br><br>So far, I found out that drawing a 2x scaled 512x512 image is twice as fast as drawing an 1024x1024 image, however this improvement becomes drastically less significant when going from 512x512 to 256x256 or lower. <br><br></td></tr></table><br>
<a name="959507"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> what about doing a check to see if the next texture to be drawn is the same as the last texture? <br>also, would instancing of geometry help with fill-rate? <br><br></td></tr></table><br>
<a name="959514"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> If someone converted Jim's SpriteMaster Pro lib to Bmax there would be pretty massive speed up in drawing. <br><br></td></tr></table><br>
<a name="959521"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Uh... you can do instancing of geometry in BMax?<br>I'm not sure I got my grips on the term, but I'm pretty sure it's not the same as drawing the same "TImage" at different positions. (which is what I'm doing right now) <br><br></td></tr></table><br>
<a name="959522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> the SMPro lib isn't instancing as I know it, All the images are added to single single mesh, vertexes are use to control alpha and color for each image and zorder. but only a single mesh is drawn to the screen. When i used it for Blitz3d I was blown away by the speed. Jim did a great job on the whole library. <br><br></td></tr></table><br>
<a name="959523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> instancing is opengl, <br><br></td></tr></table><br>
<a name="959561"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> This `instancing` sounds like the same thing as keeping many images on one texture to avoid texture swaps. Instancing of geometry (a quad is geometry) just means drawing multiple instances of the same thing as quickly as possible. I am presuming that in OpenGL that would mean recording geometry into a display list and then calling the list many times. For quads that isn't going to speed things up much because the geometry is so simple. It's better for more complex 3d objects.<br><br>You can get about a 200% speed increase by using vertex arrays, however.<br><br>Also in order to switch to a new texture, you have to usually call glEnd to end the current geometry and then glBegin to start a new quad. So if you're doing that for every image drawn, that's not only a lot of texture switches but also a lot of begins and ends of geometry. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
