<!DOCTYPE html><html lang="en" ><head ><title >C Help</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >C Help</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >C Help</a><br><br>
<a name="1046174"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ghost Dancer</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been looking for ways to use COM objects from Max and found something called [url=http://disphelper.sourceforge.net/]disphelper[/url] which should do the job. I'm trying to write a Blitz wrapper module for this but my C knowledge isn't great.<br><br>I've used the C for Blitzers tutorial and got some basic C code to work in Blitz, but I'm having problems importing the disphelper code. I have the following code:<br><br><pre class=code>
SuperStrict
Import "*.h"
Import "disphelper.c"
</pre><br><br>and I'm getting loads of "undefined reference to" compiler errors. I'm guessing this something to do with the C includes but not sure. <br><br>disphelper.h:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#ifndef DISPHELPER_H_INCLUDED
#define DISPHELPER_H_INCLUDED

#include &lt;objbase.h&gt;
#include &lt;time.h&gt;

#ifdef __cplusplus
extern "C" {
#endif

HRESULT dhCreateObject(LPCOLESTR szProgId, LPCWSTR szMachine, IDispatch ** ppDisp);
HRESULT dhGetObject(LPCOLESTR szFile, LPCOLESTR szProgId, IDispatch ** ppDisp);

HRESULT dhCreateObjectEx(LPCOLESTR szProgId, REFIID riid, DWORD dwClsContext, COSERVERINFO * pServerInfo, void ** ppv);
HRESULT dhGetObjectEx(LPCOLESTR szFile, LPCOLESTR szProgId, REFIID riid, DWORD dwClsContext, LPVOID lpvReserved, void ** ppv);

HRESULT dhCallMethod(IDispatch * pDisp, LPCOLESTR szMember, ...);
HRESULT dhPutValue(IDispatch * pDisp, LPCOLESTR szMember, ...);
HRESULT dhPutRef(IDispatch * pDisp, LPCOLESTR szMember, ...);
HRESULT dhGetValue(LPCWSTR szIdentifier, void * pResult, IDispatch * pDisp, LPCOLESTR szMember, ...);

HRESULT dhInvoke(int invokeType, VARTYPE returnType, VARIANT * pvResult, IDispatch * pDisp, LPCOLESTR szMember, ...);
HRESULT dhInvokeArray(int invokeType, VARIANT * pvResult, UINT cArgs, IDispatch * pDisp, LPCOLESTR szMember, VARIANT * pArgs);

HRESULT dhCallMethodV(IDispatch * pDisp, LPCOLESTR szMember, va_list * marker);
HRESULT dhPutValueV(IDispatch * pDisp, LPCOLESTR szMember, va_list * marker);
HRESULT dhPutRefV(IDispatch * pDisp, LPCOLESTR szMember, va_list * marker);
HRESULT dhGetValueV(LPCWSTR szIdentifier, void * pResult, IDispatch * pDisp, LPCOLESTR szMember, va_list * marker);
HRESULT dhInvokeV(int invokeType, VARTYPE returnType, VARIANT * pvResult, IDispatch * pDisp, LPCOLESTR szMember, va_list * marker);

HRESULT dhAutoWrap(int invokeType, VARIANT * pvResult, IDispatch * pDisp, LPCOLESTR szMember, UINT cArgs, ...);
HRESULT dhParseProperties(IDispatch * pDisp, LPCWSTR szProperties, UINT * lpcPropsSet);

HRESULT dhEnumBegin(IEnumVARIANT ** ppEnum, IDispatch * pDisp, LPCOLESTR szMember, ...);
HRESULT dhEnumBeginV(IEnumVARIANT ** ppEnum, IDispatch * pDisp, LPCOLESTR szMember, va_list * marker);
HRESULT dhEnumNextObject(IEnumVARIANT * pEnum, IDispatch ** ppDisp);
HRESULT dhEnumNextVariant(IEnumVARIANT * pEnum, VARIANT * pvResult);

HRESULT dhInitializeImp(BOOL bInitializeCOM, BOOL bUnicode);
void dhUninitialize(BOOL bUninitializeCOM);

#define dhInitializeA(bInitializeCOM) dhInitializeImp(bInitializeCOM, FALSE)
#define dhInitializeW(bInitializeCOM) dhInitializeImp(bInitializeCOM, TRUE)

#ifdef UNICODE
#define dhInitialize dhInitializeW
#else
#define dhInitialize dhInitializeA
#endif

#define AutoWrap dhAutoWrap
#define DISPATCH_OBJ(objName) IDispatch * objName = NULL
#define dhFreeString(string) SysFreeString((BSTR) string)

#ifndef SAFE_RELEASE
#ifdef __cplusplus
#define SAFE_RELEASE(pObj) { if (pObj) { (pObj)-&gt;Release(); (pObj) = NULL; } }
#else
#define SAFE_RELEASE(pObj) { if (pObj) { (pObj)-&gt;lpVtbl-&gt;Release(pObj); (pObj) = NULL; } }
#endif
#endif

#define SAFE_FREE_STRING(string) { dhFreeString(string); (string) = NULL; }




/* ===================================================================== */
#ifndef DISPHELPER_NO_WITH

#define WITH0(objName, pDisp, szMember) { \
	DISPATCH_OBJ(objName);            \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember))) {

#define WITH1(objName, pDisp, szMember, arg1) { \
	DISPATCH_OBJ(objName);                  \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1))) {

#define WITH2(objName, pDisp, szMember, arg1, arg2) { \
	DISPATCH_OBJ(objName);                        \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1, arg2))) {

#define WITH3(objName, pDisp, szMember, arg1, arg2, arg3) { \
	DISPATCH_OBJ(objName);                              \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1, arg2, arg3))) {

#define WITH4(objName, pDisp, szMember, arg1, arg2, arg3, arg4) { \
	DISPATCH_OBJ(objName);                                    \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1, arg2, arg3, arg4))) {

#define WITH WITH0

#define ON_WITH_ERROR(objName) } else {

#define END_WITH(objName) } SAFE_RELEASE(objName); }

#endif /* ----- DISPHELPER_NO_WITH ----- */




/* ===================================================================== */
#ifndef DISPHELPER_NO_FOR_EACH

#define FOR_EACH0(objName, pDisp, szMember) { \
	IEnumVARIANT * xx_pEnum_xx = NULL;    \
	DISPATCH_OBJ(objName);                \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember))) { \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#define FOR_EACH1(objName, pDisp, szMember, arg1) { \
	IEnumVARIANT * xx_pEnum_xx = NULL;          \
	DISPATCH_OBJ(objName);                      \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1))) { \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#define FOR_EACH2(objName, pDisp, szMember, arg1, arg2) { \
	IEnumVARIANT * xx_pEnum_xx = NULL;          \
	DISPATCH_OBJ(objName);                      \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1, arg2))) { \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {


#define FOR_EACH3(objName, pDisp, szMember, arg1, arg2, arg3) { \
	IEnumVARIANT * xx_pEnum_xx = NULL;          \
	DISPATCH_OBJ(objName);                      \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1, arg2, arg3))) { \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {


#define FOR_EACH4(objName, pDisp, szMember, arg1, arg2, arg3, arg4) { \
	IEnumVARIANT * xx_pEnum_xx = NULL;          \
	DISPATCH_OBJ(objName);                      \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1, arg2, arg3, arg4))) { \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#define FOR_EACH FOR_EACH0

#define ON_FOR_EACH_ERROR(objName) SAFE_RELEASE(objName); }} else {{

#define NEXT(objName) SAFE_RELEASE(objName); }} SAFE_RELEASE(objName); SAFE_RELEASE(xx_pEnum_xx); }

#endif /* ----- DISPHELPER_NO_FOR_EACH ----- */




/* ===================================================================== */
#ifndef DISPHELPER_NO_EXCEPTIONS

/* Structure to store a DispHelper exception */
typedef struct tagDH_EXCEPTION
{
	LPCWSTR szInitialFunction;
	LPCWSTR szErrorFunction;

	HRESULT hr;

	WCHAR szMember[64];
	WCHAR szCompleteMember[256];

	UINT swCode;
	LPWSTR szDescription;
	LPWSTR szSource;
	LPWSTR szHelpFile;
	DWORD dwHelpContext;

	UINT iArgError;

	BOOL bDispatchError;

#ifdef DISPHELPER_INTERNAL_BUILD
	BOOL bOld;
#endif
} DH_EXCEPTION, * PDH_EXCEPTION;

typedef void (*DH_EXCEPTION_CALLBACK) (PDH_EXCEPTION);

/* Structure to store exception options. */
typedef struct tagDH_EXCEPTION_OPTIONS
{
	HWND hwnd;
	LPCWSTR szAppName;
	BOOL bShowExceptions;
	BOOL bDisableRecordExceptions;
	DH_EXCEPTION_CALLBACK pfnExceptionCallback;
} DH_EXCEPTION_OPTIONS, * PDH_EXCEPTION_OPTIONS;

/* Functions to manipulate global exception options */
HRESULT dhToggleExceptions(BOOL bShow);
HRESULT dhSetExceptionOptions(PDH_EXCEPTION_OPTIONS pExceptionOptions);
HRESULT dhGetExceptionOptions(PDH_EXCEPTION_OPTIONS pExceptionOptions);

/* Functions to show an exception, format an exception into a string
 * and get a copy of the last exception */
HRESULT dhShowException(PDH_EXCEPTION pException);
HRESULT dhGetLastException(PDH_EXCEPTION * pException);
HRESULT dhFormatExceptionW(PDH_EXCEPTION pException, LPWSTR szBuffer, UINT cchBufferSize, BOOL bFixedFont);
HRESULT dhFormatExceptionA(PDH_EXCEPTION pException, LPSTR szBuffer, UINT cchBufferSize, BOOL bFixedFont);

#ifdef UNICODE
#define dhFormatException dhFormatExceptionW
#else
#define dhFormatException dhFormatExceptionA
#endif

#ifdef DISPHELPER_INTERNAL_BUILD

void dhEnter(void);
HRESULT dhExitEx(HRESULT hr, BOOL bDispatchError, LPCWSTR szMember, LPCWSTR szCompleteMember, EXCEPINFO * pExcepInfo, UINT iArgError, LPCWSTR szFunctionName);
void dhCleanupThreadException(void);

#define DH_ENTER(szFunctionName) static LPCWSTR xx_szFunctionName_xx = szFunctionName; \
				    dhEnter()

#define DH_EXITEX(hr, bDispatchError, szMember, szCompleteMember, pExcepInfo, iArgError) \
		dhExitEx(hr, bDispatchError, szMember, szCompleteMember, pExcepInfo, iArgError, xx_szFunctionName_xx)

#define DH_EXIT(hr, szCompleteMember) DH_EXITEX(hr, FALSE, NULL, szCompleteMember, NULL, 0)

#endif /* ----- DISPHELPER_INTERNAL_BUILD ----- */

#else  /* ----- DISPHELPER_NO_EXCEPTIONS ----- */

/* These macros define out calls to selected exception functions */
#define dhToggleExceptions(bShow) (E_NOTIMPL)
#define dhSetExceptionOptions(pExcepOptions) (E_NOTIMPL)

#ifdef DISPHELPER_INTERNAL_BUILD
#define DH_ENTER(szFunctionName)
#define DH_EXITEX(hr, bDispatchError, szMember, szCompleteMember, pExcepInfo, iArgError) \
	(((hr == DISP_E_EXCEPTION &amp;&amp; pExcepInfo) ?                      \
	(SysFreeString(((EXCEPINFO *)(pExcepInfo))-&gt;bstrSource),        \
	 SysFreeString(((EXCEPINFO *)(pExcepInfo))-&gt;bstrDescription),   \
	 SysFreeString(((EXCEPINFO *)(pExcepInfo))-&gt;bstrHelpFile), 0) : (0)), hr)
#define DH_EXIT(hr, szCompleteMember)(hr)
#endif

#endif /* ----- DISPHELPER_NO_EXCEPTIONS ----- */






/* ===================================================================== */
#ifdef DISPHELPER_INTERNAL_BUILD

#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;wchar.h&gt;

/* Macro to include or lose debug code. */
#ifdef DEBUG
#define DBG_CODE(code) code
#else
#define DBG_CODE(code)
#endif

/* Are we in unicode mode? */
extern BOOL dh_g_bIsUnicodeMode;

/* Number of objects in an array */
#undef ARRAYSIZE
#define ARRAYSIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

/* Maximum number of arguments for a member */
#define DH_MAX_ARGS 25

/* Maximum length of a member string */
#define DH_MAX_MEMBER 512

/* This macro is missing from Dev-Cpp/Mingw */
#ifndef V_UI4
#define V_UI4(X) V_UNION(X, ulVal)
#endif

/* Macro to notify programmer of invalid identifier in debug mode. */
#define DEBUG_NOTIFY_INVALID_IDENTIFIER(chIdentifier) \
DBG_CODE( { \
		char buf[256]; \
		sprintf(buf,"DEBUG: The format string or return identifier contained the invalid identifier '%c'.\n" \
		"The valid identifiers are \"d/u/e/b/v/B/S/s/T/o/O/t/W/D/f/m\".\n" \
		"Each %% character should be followed by a valid identifier.\n" \
		"Identifiers are case sensitive.", (chIdentifier)); \
		MessageBoxA(NULL, buf, "DEBUG: Invalid Format Identifier", MB_ICONSTOP); \
	} )

#ifdef _MSC_VER
#pragma warning(disable : 4706) /* Assignment in conditional expression */
#endif

#ifndef DISPHELPER_NO_PRAGMA_LIB
#ifdef __LCC__
#pragma lib &lt;ole32.lib&gt;
#pragma lib &lt;oleaut32.lib&gt;
#pragma lib &lt;uuid.lib&gt;
#endif
#endif


#endif /* ----- DISPHELPER_INTERNAL_BUILD ----- */

#ifndef DISPHELPER_NO_PRAGMA_LIB
#if defined(_MSC_VER) || defined(__BORLANDC__)
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")
#endif
#endif



#ifdef __cplusplus
}
#endif




/* ===================================================================== */
#if defined(__cplusplus) &amp;&amp; !defined(DISPHELPER_NO_CPP_EXTENSIONS)

#include &lt;iostream&gt;
#include &lt;string&gt;

#ifdef _MSC_VER
#pragma warning( disable : 4290 ) /* throw() specification ignored */
#endif

#ifndef DISPHELPER_USE_MS_SMART_PTR

template &lt;class T&gt;
class CDhComPtr
{
public:
	CDhComPtr() throw() : m_pInterface (NULL) {}

	CDhComPtr(T* pInterface) throw() : m_pInterface (pInterface)
	{
		if (m_pInterface) m_pInterface-&gt;AddRef();
	}

	CDhComPtr(const CDhComPtr&amp; original) throw() : m_pInterface (original.m_pInterface)
	{
		if (m_pInterface) m_pInterface-&gt;AddRef();
	}

	~CDhComPtr() throw()
	{
		Dispose();
	}

	void Dispose() throw()
	{
		if (m_pInterface)
		{
			m_pInterface-&gt;Release();
			m_pInterface = NULL;
		}
	}

	T* Detach() throw()
	{
		T* temp = m_pInterface;
		m_pInterface = NULL;
		return temp;
	}

	inline operator T*() const throw()
	{
        	return m_pInterface;
	}

	T** operator&amp;() throw()
	{
		Dispose();
        	return &amp;m_pInterface;
	}

	T* operator-&gt;() const throw(HRESULT)
	{
		if (!m_pInterface) throw E_POINTER;
		return m_pInterface;
	}

	CDhComPtr&amp; operator=(T* pInterface) throw()
	{
		if (m_pInterface != pInterface)
		{
			T* pOldInterface = m_pInterface;
			m_pInterface = pInterface;
			if (m_pInterface)  m_pInterface-&gt;AddRef();
			if (pOldInterface) pOldInterface-&gt;Release();
		}

		return *this;
	}

	CDhComPtr&amp; operator=(const int null) throw(HRESULT)
	{
		if (null != 0) throw(E_POINTER);
		return operator=((T*) NULL);
	}

	CDhComPtr&amp; operator=(const CDhComPtr&amp; rhs) throw()
	{
		return operator=(rhs.m_pInterface);
	}

private:
	T* m_pInterface;
};

typedef CDhComPtr&lt;IDispatch&gt;    CDispPtr;
typedef CDhComPtr&lt;IEnumVARIANT&gt; CEnumPtr;
typedef CDhComPtr&lt;IUnknown&gt;     CUnknownPtr;

#else /* DISPHELPER_USE_MS_SMART_PTR */

#include &lt;comdef.h&gt; 
typedef IDispatchPtr    CDispPtr;
typedef IEnumVARIANTPtr CEnumPtr;
typedef IUnknownPtr     CUnknownPtr;

#endif /* DISPHELPER_USE_MS_SMART_PTR */




/* ===================================================================== */
template &lt;class T&gt;
class CDhStringTemplate
{
public:
	CDhStringTemplate() throw() : m_strptr (NULL) {}

	CDhStringTemplate(const CDhStringTemplate&amp; original) throw()
	{
		Copy(original.m_strptr);
	}

	CDhStringTemplate(const int null) throw(HRESULT) : m_strptr (NULL)
	{
		if (null != 0) throw(E_POINTER);
	}

	~CDhStringTemplate() throw()
	{
		Dispose();
	}

	void Dispose() throw()
	{
		dhFreeString(m_strptr);
		m_strptr = NULL;
	}

	T* Detach() throw()
	{
		T* temp = m_strptr;
		m_strptr = NULL;
		return temp;
	}

	T** operator&amp;() throw()
	{
		Dispose();
		return &amp;m_strptr;
	}

	inline operator T*() const throw()
	{
		return m_strptr;
	}

	inline T&amp; operator[](int nIndex) const throw()
	{
		return m_strptr[nIndex];
	}

	CDhStringTemplate&amp; operator=(const CDhStringTemplate&amp; rhs)
	{
		if (m_strptr != rhs.m_strptr)
		{
			T* temp = m_strptr;
			Copy(rhs.m_strptr);
			dhFreeString(temp);
		}

		return *this;
	}

	CDhStringTemplate&amp; operator=(const int null) throw(HRESULT)
	{
		if (null != 0) throw(E_POINTER);
		Dispose();
		return *this;
	}

private:
	void Copy(const T* rhs)
	{
		if (rhs == NULL)
		{
			m_strptr = NULL;
		}
		else if (sizeof(T) == sizeof(CHAR))
		{
			m_strptr = (T*) SysAllocStringByteLen((LPCSTR) rhs, SysStringByteLen((BSTR) rhs));
		}
		else
		{
			m_strptr = (T*) SysAllocStringLen((OLECHAR *) rhs, SysStringLen((BSTR) rhs));
		}
	}

	T* m_strptr;
};

typedef CDhStringTemplate&lt;CHAR&gt;    CDhStringA;  /* Ansi string - LPSTR */
typedef CDhStringTemplate&lt;WCHAR&gt;   CDhStringW;  /* Unicode string - LPWSTR */
typedef CDhStringTemplate&lt;OLECHAR&gt; CDhStringB;  /* Unicode bstring - BSTR */
typedef CDhStringTemplate&lt;TCHAR&gt;   CDhStringT;  /* T string - LPTSTR */
typedef CDhStringTemplate&lt;TCHAR&gt;   CDhString;   /* T string - LPTSTR */

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CDhStringA&amp; s)
{
	return os &lt;&lt; (s ? s : (char*) "(null)");
}

inline std::wostream&amp; operator&lt;&lt;(std::wostream&amp; os, const CDhStringW&amp; s)
{
	return os &lt;&lt; (s ? s : (wchar_t*) L"(null)");
}




/* ===================================================================== */
class CDhInitialize
{
public:
	CDhInitialize(const BOOL bInitCom = TRUE) throw() : m_bInitCom (bInitCom)
	{
		dhInitialize(m_bInitCom);
	}

	~CDhInitialize() throw()
	{
		dhUninitialize(m_bInitCom);
	}
private:
	BOOL m_bInitCom;
};




/* ===================================================================== */
#ifndef DISPHELPER_NO_EXCEPTIONS
class dhThrowFunctions
{
public:
	static void throw_string() throw(std::string)
	{
		CHAR szMessage[512];
		dhFormatExceptionA(NULL, szMessage, sizeof(szMessage)/sizeof(szMessage[0]), TRUE);
		throw std::string(szMessage);
	}

	static void throw_wstring() throw(std::wstring)
	{
		WCHAR szMessage[512];
		dhFormatExceptionW(NULL, szMessage, sizeof(szMessage)/sizeof(szMessage[0]), TRUE);
		throw std::wstring(szMessage);
	}
	
	static void throw_dhexception() throw(PDH_EXCEPTION)
	{
		PDH_EXCEPTION pException = NULL;
		dhGetLastException(&amp;pException);
		throw pException;
	}
};
#endif /* DISPHELPER_NO_EXCEPTIONS */




/* ===================================================================== */
#ifndef DISPHELPER_NO_EXCEPTIONS
inline bool dhIfFailThrowString(HRESULT hr) throw(std::string)
{
	if (FAILED(hr)) dhThrowFunctions::throw_string();
	return true;
}

inline bool dhIfFailThrowWString(HRESULT hr) throw(std::wstring)
{
	if (FAILED(hr)) dhThrowFunctions::throw_wstring();
	return true;
}

inline bool dhIfFailThrowDhException(HRESULT hr) throw(PDH_EXCEPTION)
{
	if (FAILED(hr)) dhThrowFunctions::throw_dhexception();
	return true;
}

#define dhCheck dhIfFailThrowString

#endif /* DISPHELPER_NO_EXCEPTIONS */




/* ===================================================================== */
#ifndef DISPHELPER_NO_WITH

#undef WITH0
#define WITH0(objName, pDisp, szMember) { \
	CDispPtr objName;                 \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember))) {

#undef WITH1
#define WITH1(objName, pDisp, szMember, arg1) { \
	CDispPtr objName;                       \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1))) {

#undef WITH2
#define WITH2(objName, pDisp, szMember, arg1, arg2) { \
	CDispPtr objName;                             \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1, arg2))) {

#undef WITH3
#define WITH3(objName, pDisp, szMember, arg1, arg2, arg3) { \
	CDispPtr objName;                                   \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1, arg2, arg3))) {

#undef WITH4
#define WITH4(objName, pDisp, szMember, arg1, arg2, arg3, arg4) { \
	CDispPtr objName;                                         \
	if (SUCCEEDED(dhGetValue(L"%o", &amp;objName, pDisp, szMember, arg1, arg2, arg3, arg4))) {

#undef ON_WITH_ERROR
#define ON_WITH_ERROR(objName) } else {

#undef END_WITH
#define END_WITH(objName) }}

#define END_WITH_THROW(objName) } else { dhThrowFunctions::throw_string(); }}

#endif /* DISPHELPER_NO_WITH */




/* ===================================================================== */
#ifndef DISPHELPER_NO_FOR_EACH

#undef FOR_EACH0
#define FOR_EACH0(objName, pDisp, szMember) { \
	CEnumPtr xx_pEnum_xx;     \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember))) { \
		CDispPtr objName; \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#undef FOR_EACH1
#define FOR_EACH1(objName, pDisp, szMember, arg1) { \
	CEnumPtr xx_pEnum_xx;     \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1))) { \
		CDispPtr objName; \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#undef FOR_EACH2
#define FOR_EACH2(objName, pDisp, szMember, arg1, arg2) { \
	CEnumPtr xx_pEnum_xx;     \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1, arg2))) { \
		CDispPtr objName; \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#undef FOR_EACH3
#define FOR_EACH3(objName, pDisp, szMember, arg1, arg2, arg3) { \
	CEnumPtr xx_pEnum_xx;     \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1, arg2, arg3))) { \
		CDispPtr objName; \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#undef FOR_EACH4
#define FOR_EACH4(objName, pDisp, szMember, arg1, arg2, arg3, arg4) { \
	CEnumPtr xx_pEnum_xx;     \
	if (SUCCEEDED(dhEnumBegin(&amp;xx_pEnum_xx, pDisp, szMember, arg1, arg2, arg3, arg4))) { \
		CDispPtr objName; \
		while (dhEnumNextObject(xx_pEnum_xx, &amp;objName) == NOERROR) {

#undef ON_FOR_EACH_ERROR
#define ON_FOR_EACH_ERROR(objName) }} else {{

#undef NEXT
#define NEXT(objName) }}}

#define NEXT_THROW(objName) }} else { dhThrowFunctions::throw_string(); }}

#endif /* DISPHELPER_NO_FOR_EACH */

#ifdef _MSC_VER
#pragma warning( default : 4290 )
#endif

#endif /* defined(__cplusplus) &amp;&amp; !defined(DISPHELPER_NO_CPP_EXTENSIONS) */

#endif /* ----- DISPHELPER_H_INCLUDED ----- */
</textarea><br><br>disphelper.c:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#define DISPHELPER_INTERNAL_BUILD
#include "disphelper.h"
#include &lt;math.h&gt;
#include &lt;assert.h&gt;

/* ----- convert.h ----- */

HRESULT ConvertFileTimeToVariantTime(FILETIME * pft, DATE * pDate);
HRESULT ConvertVariantTimeToFileTime(DATE date, FILETIME * pft);

HRESULT ConvertVariantTimeToSystemTime(DATE date, SYSTEMTIME * pSystemTime);
HRESULT ConvertSystemTimeToVariantTime(SYSTEMTIME * pSystemTime, DATE * pDate);

HRESULT ConvertTimeTToVariantTime(time_t timeT, DATE * pDate);
HRESULT ConvertVariantTimeToTimeT(DATE date, time_t * pTimeT);

HRESULT ConvertAnsiStrToBStr(LPCSTR szAnsiIn, BSTR * lpBstrOut);
HRESULT ConvertBStrToAnsiStr(BSTR bstrIn, LPSTR * lpszOut);

/* ----- dh_create.c ----- */

HRESULT dhCreateObjectEx(LPCOLESTR szProgId, REFIID riid, DWORD dwClsContext,
			    COSERVERINFO * pServerInfo, void ** ppv)
{
	CLSID clsid;
	HRESULT hr;
	IClassFactory * pCf = NULL;

	DH_ENTER(L"CreateObjectEx");

	if (!szProgId || !riid || !ppv) return DH_EXIT(E_INVALIDARG, szProgId);

	if (L'{' == szProgId[0])
		hr = CLSIDFromString((LPOLESTR) szProgId, &amp;clsid);
	else
		hr = CLSIDFromProgID(szProgId, &amp;clsid);

	if (SUCCEEDED(hr)) hr = CoGetClassObject(&amp;clsid, dwClsContext, pServerInfo, &amp;IID_IClassFactory, (void **) &amp;pCf);
	if (SUCCEEDED(hr)) hr = pCf-&gt;lpVtbl-&gt;CreateInstance(pCf, NULL, riid, ppv);

	if (pCf) pCf-&gt;lpVtbl-&gt;Release(pCf);

	return DH_EXIT(hr, szProgId);
}

HRESULT dhGetObjectEx(LPCOLESTR szPathName, LPCOLESTR szProgId, REFIID riid,
		         DWORD dwClsContext, LPVOID lpvReserved, void ** ppv)
{
	HRESULT hr;

	DH_ENTER(L"GetObjectEx");

	if ((!szProgId &amp;&amp; !szPathName) || !riid || !ppv || lpvReserved) return DH_EXIT(E_INVALIDARG, szProgId);

	if (szPathName)
	{

		if (!szProgId)
		{
			hr = CoGetObject(szPathName, NULL, riid, ppv);
		}
		else
		{
			IPersistFile * ppf = NULL;

			hr = dhCreateObjectEx(szProgId, &amp;IID_IPersistFile, dwClsContext, NULL, (void **) &amp;ppf);

			if (SUCCEEDED(hr)) hr = ppf-&gt;lpVtbl-&gt;Load(ppf, szPathName, 0);
			if (SUCCEEDED(hr)) hr = ppf-&gt;lpVtbl-&gt;QueryInterface(ppf, riid, ppv);

			if (ppf) ppf-&gt;lpVtbl-&gt;Release(ppf);
		}
	}
	else
	{

		CLSID clsid;
		IUnknown * pUnk = NULL;

		if (L'{' == szProgId[0])
			hr = CLSIDFromString((LPOLESTR) szProgId, &amp;clsid);
		else
			hr = CLSIDFromProgID(szProgId, &amp;clsid);

		if (SUCCEEDED(hr)) hr = GetActiveObject(&amp;clsid, NULL, &amp;pUnk);
		if (SUCCEEDED(hr)) hr = pUnk-&gt;lpVtbl-&gt;QueryInterface(pUnk, riid, ppv);

		if (pUnk) pUnk-&gt;lpVtbl-&gt;Release(pUnk);
	}

	return DH_EXIT(hr, szProgId);
}

HRESULT dhCreateObject(LPCOLESTR szProgId, LPCWSTR szMachine, IDispatch ** ppDisp)
{
	COSERVERINFO si = { 0 };

	DH_ENTER(L"CreateObject");

	si.pwszName = (LPWSTR) szMachine;

	return DH_EXIT(dhCreateObjectEx(szProgId, &amp;IID_IDispatch,
			  szMachine ? CLSCTX_REMOTE_SERVER : CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,
			  szMachine ? &amp;si : NULL, (void **) ppDisp), szProgId);
}

HRESULT dhGetObject(LPCOLESTR szPathName, LPCOLESTR szProgId, IDispatch ** ppDisp)
{
	DH_ENTER(L"GetObject");

	return DH_EXIT(dhGetObjectEx(szPathName, szProgId, &amp;IID_IDispatch,
			  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER, NULL, (void **) ppDisp), szProgId);
}

HRESULT dhCallMethod(IDispatch * pDisp, LPCOLESTR szMember, ... )
{
	HRESULT hr;
	va_list marker;

	DH_ENTER(L"CallMethod");

	va_start(marker, szMember);

	hr = dhCallMethodV(pDisp, szMember, &amp;marker);

	va_end(marker);

	return DH_EXIT(hr, szMember);
}

HRESULT dhPutValue(IDispatch * pDisp, LPCOLESTR szMember, ...)
{
	HRESULT hr;
	va_list marker;

	DH_ENTER(L"PutValue");

	va_start(marker, szMember);

	hr = dhPutValueV(pDisp, szMember, &amp;marker);

	va_end(marker);

	return DH_EXIT(hr, szMember);
}

HRESULT dhPutRef(IDispatch * pDisp, LPCOLESTR szMember, ...)
{
	HRESULT hr;
	va_list marker;

	DH_ENTER(L"PutRef");

	va_start(marker, szMember);

	hr = dhPutRefV(pDisp, szMember, &amp;marker);

	va_end(marker);

	return DH_EXIT(hr, szMember);
}

HRESULT dhGetValue(LPCWSTR szIdentifier, void * pResult, IDispatch * pDisp, LPCOLESTR szMember, ...)
{
	HRESULT hr;
	va_list marker;

	DH_ENTER(L"GetValue");

	va_start(marker, szMember);

	hr = dhGetValueV(szIdentifier, pResult, pDisp, szMember, &amp;marker);

	va_end(marker);

	return DH_EXIT(hr, szMember);
}

HRESULT dhInvoke(int invokeType, VARTYPE returnType, VARIANT * pvResult, IDispatch * pDisp, LPCOLESTR szMember, ...)
{
	HRESULT hr;
	va_list marker;

	DH_ENTER(L"Invoke");

	va_start(marker, szMember);

	hr = dhInvokeV(invokeType, returnType, pvResult, pDisp, szMember, &amp;marker);

	va_end(marker);

	return DH_EXIT(hr, szMember);
}

/* ----- dh_core.c ----- */

BOOL dh_g_bIsUnicodeMode;

HRESULT dhInvokeArray(int invokeType, VARIANT * pvResult, UINT cArgs,
                         IDispatch * pDisp, LPCOLESTR szMember, VARIANT * pArgs)
{
	DISPPARAMS dp       = { 0 };
	EXCEPINFO excep     = { 0 };
	DISPID dispidNamed  = DISPID_PROPERTYPUT;
	DISPID dispID;
	UINT uiArgErr;
	HRESULT hr;

	DH_ENTER(L"InvokeArray");

	if(!pDisp || !szMember || (cArgs != 0 &amp;&amp; !pArgs)) return DH_EXIT(E_INVALIDARG, szMember);

	hr = pDisp-&gt;lpVtbl-&gt;GetIDsOfNames(pDisp, &amp;IID_NULL, (LPOLESTR *) &amp;szMember, 1, LOCALE_USER_DEFAULT, &amp;dispID);

	if(FAILED(hr)) return DH_EXITEX(hr, TRUE, szMember, szMember, NULL, 0);

	if (pvResult != NULL) VariantInit(pvResult);

	dp.cArgs  = cArgs;
	dp.rgvarg = pArgs;

	if(invokeType &amp; (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
	{
		dp.cNamedArgs = 1;
		dp.rgdispidNamedArgs = &amp;dispidNamed;
	}

	hr = pDisp-&gt;lpVtbl-&gt;Invoke(pDisp, dispID, &amp;IID_NULL, LOCALE_USER_DEFAULT, (WORD) invokeType, &amp;dp, pvResult, &amp;excep, &amp;uiArgErr);

	return DH_EXITEX(hr, TRUE, szMember, szMember, &amp;excep, uiArgErr);
}

HRESULT dhCallMethodV(IDispatch * pDisp, LPCOLESTR szMember, va_list * marker)
{
	DH_ENTER(L"CallMethodV");

	return DH_EXIT(dhInvokeV(DISPATCH_METHOD, VT_EMPTY, NULL, pDisp, szMember, marker), szMember);
}

HRESULT dhPutValueV(IDispatch * pDisp, LPCOLESTR szMember, va_list * marker)
{
	DH_ENTER(L"PutValueV");

	return DH_EXIT(dhInvokeV(DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, pDisp, szMember, marker), szMember);
}

HRESULT dhPutRefV(IDispatch * pDisp, LPCOLESTR szMember, va_list * marker)
{
	DH_ENTER(L"PutRefV");

	return DH_EXIT(dhInvokeV(DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, pDisp, szMember, marker), szMember);
}

HRESULT dhGetValueV(LPCWSTR szIdentifier, void * pResult, IDispatch * pDisp, LPCOLESTR szMember, va_list * marker)
{
	VARIANT vtResult;
	VARTYPE returnType;
	HRESULT hr;

	DH_ENTER(L"GetValueV");

	if (!pResult || !szIdentifier) return DH_EXIT(E_INVALIDARG, szMember);

	if (*szIdentifier == L'%') szIdentifier++;

	switch(*szIdentifier)
	{
		case L'd': returnType = VT_I4;       break;
		case L'u': returnType = VT_UI4;      break;
		case L'e': returnType = VT_R8;       break;
		case L'b': returnType = VT_BOOL;     break;
		case L'v': returnType = VT_EMPTY;    break;
		case L'B': returnType = VT_BSTR;     break;
		case L'S': returnType = VT_BSTR;     break;
		case L's': returnType = VT_BSTR;     break;
		case L'T': returnType = VT_BSTR;     break;
		case L'o': returnType = VT_DISPATCH; break;
		case L'O': returnType = VT_UNKNOWN;  break;
		case L't': returnType = VT_DATE;     break;
		case L'W': returnType = VT_DATE;     break;
		case L'f': returnType = VT_DATE;     break;
		case L'D': returnType = VT_DATE;     break;
#ifndef _WIN64
		case L'p': returnType = VT_I4;       break;
#else
		case L'p': returnType = VT_I8;       break;
#endif
		default:
			DEBUG_NOTIFY_INVALID_IDENTIFIER(*szIdentifier);
			return DH_EXIT(E_INVALIDARG, szMember);
	}

	hr = dhInvokeV(DISPATCH_PROPERTYGET|DISPATCH_METHOD, returnType, &amp;vtResult, pDisp, szMember, marker);
	if (FAILED(hr)) return DH_EXIT(hr, szMember);

	switch(*szIdentifier)
	{
		case L'd':
			*((LONG *) pResult) = V_I4(&amp;vtResult);
			break;

		case L'u':
			*((ULONG *) pResult) = V_UI4(&amp;vtResult);
			break;

		case L'e':
			*((DOUBLE *) pResult) = V_R8(&amp;vtResult);
			break;

		case L'b':
			*((BOOL *) pResult) = V_BOOL(&amp;vtResult);
			break;

		case L'v':
			*((VARIANT *) pResult) = vtResult;
			break;

		case L'B':
			*((BSTR *) pResult) = V_BSTR(&amp;vtResult);
			break;

		case L'S':
			*((LPWSTR *) pResult) = V_BSTR(&amp;vtResult);
			break;

		case L's':
			hr = ConvertBStrToAnsiStr(V_BSTR(&amp;vtResult), (LPSTR *) pResult);
			SysFreeString(V_BSTR(&amp;vtResult));
			break;

		case L'T':
			if (dh_g_bIsUnicodeMode)
			{
				*((LPWSTR *) pResult) = V_BSTR(&amp;vtResult);
			}
			else
			{
				hr = ConvertBStrToAnsiStr(V_BSTR(&amp;vtResult), (LPSTR *) pResult);
				SysFreeString(V_BSTR(&amp;vtResult));
			}
			break;

		case L'o':
			*((IDispatch **) pResult) = V_DISPATCH(&amp;vtResult);
			if (V_DISPATCH(&amp;vtResult) == NULL) hr = E_NOINTERFACE;
			break;

		case L'O':
			*((IUnknown **) pResult) = V_UNKNOWN(&amp;vtResult);
			if (V_UNKNOWN(&amp;vtResult) == NULL) hr = E_NOINTERFACE;
			break;

		case L't':
			hr = ConvertVariantTimeToTimeT(V_DATE(&amp;vtResult), (time_t *) pResult);
			break;

		case L'W':
			hr = ConvertVariantTimeToSystemTime(V_DATE(&amp;vtResult), (SYSTEMTIME *) pResult);
			break;

		case L'f':
			hr = ConvertVariantTimeToFileTime(V_DATE(&amp;vtResult), (FILETIME *) pResult);
			break;

		case L'D':
			*((DATE *) pResult) = V_DATE(&amp;vtResult);
			break;

		case L'p':
#ifndef _WIN64
			*((LPVOID *) pResult) = (LPVOID) V_I4(&amp;vtResult);
#else
			*((LPVOID *) pResult) = (LPVOID) V_I8(&amp;vtResult);
#endif
			break;
	}

	return DH_EXIT(hr, szMember);
}

/* ----- dh_invoke.c ----- */

static HRESULT TraverseSubObjects(IDispatch ** ppDisp, LPWSTR * lpszMember, va_list * marker);
static HRESULT CreateArgumentArray(LPWSTR szTemp, VARIANT * pArgs, BOOL * pbFreeList, UINT * pcArgs, va_list * marker);
static HRESULT InternalInvokeV(int invokeType, VARTYPE returnType, VARIANT * pvResult, IDispatch * pDisp, LPOLESTR szMember, va_list * marker);
static HRESULT ExtractArgument(VARIANT * pvArg, WCHAR chIdentifier, BOOL * pbFreeArg, va_list * marker);

HRESULT dhInvokeV(int invokeType, VARTYPE returnType, VARIANT * pvResult,
                     IDispatch * pDisp, LPCOLESTR szMember, va_list * marker)
{
	WCHAR szCopy[DH_MAX_MEMBER];
	LPWSTR szTemp                  = szCopy;
	SIZE_T cchDest                 = ARRAYSIZE(szCopy);
	HRESULT hr;

	DH_ENTER(L"InvokeV");

	if (!pDisp || !szMember || !marker) return DH_EXIT(E_INVALIDARG, szMember);

	do
	{
		if (cchDest-- == 0) return DH_EXIT(E_INVALIDARG, szMember);
	}
	while( (*szTemp++ = *szMember++) );

	szTemp = szCopy;

	hr = TraverseSubObjects(&amp;pDisp, &amp;szTemp, marker);

	if (SUCCEEDED(hr))
	{
		hr = InternalInvokeV(invokeType, returnType, pvResult, pDisp, szTemp, marker);

		pDisp-&gt;lpVtbl-&gt;Release(pDisp);
	}

	return DH_EXIT(hr, szMember);
}

static HRESULT TraverseSubObjects(IDispatch ** ppDisp, LPWSTR * lpszMember, va_list * marker)
{
	LPWSTR szSeperator, szTemp;
	VARIANT vtObject;
	HRESULT hr;

	DH_ENTER(L"TraverseSubObjects");

	if (**lpszMember == L'.') (*lpszMember)++;

	(*ppDisp)-&gt;lpVtbl-&gt;AddRef(*ppDisp);

	szSeperator = wcschr(*lpszMember, L'.');

	if (szSeperator == NULL) return DH_EXIT(NOERROR, *lpszMember);

	szTemp = *lpszMember;

	do
	{
		*szSeperator = L'\0';

		hr = InternalInvokeV(DISPATCH_METHOD|DISPATCH_PROPERTYGET, VT_DISPATCH,
		                     &amp;vtObject, *ppDisp, szTemp, marker);

		if (!vtObject.pdispVal &amp;&amp; SUCCEEDED(hr)) hr = E_NOINTERFACE;

		(*ppDisp)-&gt;lpVtbl-&gt;Release(*ppDisp);

		if (FAILED(hr)) break;

		*ppDisp = vtObject.pdispVal;

		szTemp = szSeperator + 1;

	}
	while ( (szSeperator = wcschr(szTemp, L'.') ) != NULL);

	*lpszMember = szTemp;

	return DH_EXIT(hr, *lpszMember);
}

static HRESULT InternalInvokeV(int invokeType, VARTYPE returnType, VARIANT * pvResult,
                               IDispatch * pDisp, LPOLESTR szMember, va_list * marker)
{
	VARIANT vtArgs[DH_MAX_ARGS];
	BOOL bFreeList[DH_MAX_ARGS];
	HRESULT hr;
	UINT cArgs, iArg;

	DH_ENTER(L"InternalInvokeV");

	hr = CreateArgumentArray(szMember, vtArgs, bFreeList, &amp;cArgs, marker);

	if (SUCCEEDED(hr))
	{
		hr = dhInvokeArray(invokeType, pvResult, cArgs, pDisp, szMember, &amp;vtArgs[DH_MAX_ARGS - cArgs]);

		for (iArg = DH_MAX_ARGS - cArgs;iArg &lt; DH_MAX_ARGS;iArg++)
		{
			if (bFreeList[iArg]) VariantClear(&amp;vtArgs[iArg]);
		}

		if (SUCCEEDED(hr) &amp;&amp; pvResult != NULL &amp;&amp;
	            pvResult-&gt;vt != returnType &amp;&amp; returnType != VT_EMPTY)
		{
			hr = VariantChangeType(pvResult, pvResult, 16 , returnType);
			if (FAILED(hr)) VariantClear(pvResult);
		}
	}

	return DH_EXIT(hr, szMember);
}

static HRESULT CreateArgumentArray(LPWSTR szMember, VARIANT * pArgs, BOOL * pbFreeList,
				   UINT * pcArgs, va_list * marker)
{
	HRESULT hr        = NOERROR;
	INT iArg          = DH_MAX_ARGS;
	BOOL bInArguments = FALSE;

	DH_ENTER(L"CreateArgumentArray");

	while (*szMember)
	{
		if (!bInArguments &amp;&amp;
                   (*szMember == L'(' || *szMember == L' ' || *szMember == L'=') )
		{
			bInArguments = TRUE;

			*szMember = L'\0';
		}
		else if  (*szMember == L'%')
		{
			if (!bInArguments)
			{
				bInArguments = TRUE;
				*szMember = L'\0';
			}

			iArg--;

			if (iArg == -1) { hr = E_INVALIDARG; break; }

			szMember++;

			hr = ExtractArgument(&amp;pArgs[iArg], *szMember, &amp;pbFreeList[iArg], marker);

			if (FAILED(hr)) break;
		}

		szMember++;
	}

	*pcArgs = DH_MAX_ARGS - iArg;

	if (FAILED(hr))
	{
		for (++iArg;iArg &lt; DH_MAX_ARGS; iArg++)
		{
			if (pbFreeList[iArg]) VariantClear(&amp;pArgs[iArg]);
		}
	}

	return DH_EXIT(hr, szMember);
}

static HRESULT ExtractArgument(VARIANT * pvArg, WCHAR chIdentifier, BOOL * pbFreeArg, va_list * marker)
{
	HRESULT hr = NOERROR;

	*pbFreeArg = FALSE;

	if (chIdentifier == L'T') chIdentifier = (dh_g_bIsUnicodeMode ? L'S' : L's');

	switch (chIdentifier)
	{
		case L'd':
			V_VT(pvArg)  = VT_I4;
			V_I4(pvArg)  = va_arg(*marker, LONG);
			break;

		case L'u':
			V_VT(pvArg)  = VT_UI4;
			V_UI4(pvArg) = va_arg(*marker, ULONG);
			break;

		case L'e':
			V_VT(pvArg)  = VT_R8;
			V_R8(pvArg)  = va_arg(*marker, DOUBLE);
			break;

		case L'b':
			V_VT(pvArg)   = VT_BOOL;
			V_BOOL(pvArg) = ( va_arg(*marker, BOOL) ? VARIANT_TRUE : VARIANT_FALSE );
			break;

		case L'v':
			*pvArg  = *va_arg(*marker, VARIANT *);
			break;

		case L'm':
			V_VT(pvArg)    = VT_ERROR;
			V_ERROR(pvArg) = DISP_E_PARAMNOTFOUND;
			break;

		case L'B':
			V_VT(pvArg)   = VT_BSTR;
			V_BSTR(pvArg) = va_arg(*marker, BSTR);
			break;

		case L'S':
		{
			LPOLESTR szTemp = va_arg(*marker, LPOLESTR);

			V_VT(pvArg)   = VT_BSTR;
			V_BSTR(pvArg) = SysAllocString(szTemp);

			if (V_BSTR(pvArg) == NULL &amp;&amp; szTemp != NULL) hr = E_OUTOFMEMORY;

			*pbFreeArg = TRUE;
			break;
		}

		case L's':
			V_VT(pvArg) = VT_BSTR;
			hr = ConvertAnsiStrToBStr(va_arg(*marker, LPSTR), &amp;V_BSTR(pvArg));
			*pbFreeArg = TRUE;
			break;

		case L'o':
			V_VT(pvArg)       = VT_DISPATCH;
			V_DISPATCH(pvArg) = va_arg(*marker, IDispatch *);
			break;

		case L'O':
			V_VT(pvArg)      = VT_UNKNOWN;
			V_UNKNOWN(pvArg) = va_arg(*marker, IUnknown *);
			break;

		case L'D':
			V_VT(pvArg)   = VT_DATE;
			V_DATE(pvArg) = va_arg(*marker, DATE);
			break;

		case L't':
			V_VT(pvArg) = VT_DATE;
			hr = ConvertTimeTToVariantTime(va_arg(*marker, time_t), &amp;V_DATE(pvArg));
			break;

		case L'W':
			V_VT(pvArg) = VT_DATE;
			hr = ConvertSystemTimeToVariantTime(va_arg(*marker, SYSTEMTIME *), &amp;V_DATE(pvArg));
			break;

		case L'f':
			V_VT(pvArg) = VT_DATE;
			hr = ConvertFileTimeToVariantTime(va_arg(*marker, FILETIME *), &amp;V_DATE(pvArg));
			break;

		case L'p':
#ifndef _WIN64
			V_VT(pvArg) = VT_I4;
			V_I4(pvArg) = (LONG) va_arg(*marker, LPVOID);
#else
			V_VT(pvArg) = VT_I8;
			V_I8(pvArg) = (LONGLONG) va_arg(*marker, LPVOID);
#endif
			break;

		default:
			hr = E_INVALIDARG;
			DEBUG_NOTIFY_INVALID_IDENTIFIER(chIdentifier);
			break;
	}

	return hr;
}

/* ----- dh_enum.c ----- */

HRESULT dhEnumBeginV(IEnumVARIANT ** ppEnum, IDispatch * pDisp, LPCOLESTR szMember, va_list * marker)
{
	DISPPARAMS dp    = { 0 };
	EXCEPINFO excep  = { 0 };
	VARIANT vtResult;
	IDispatch * pDispObj;
	HRESULT hr;

	DH_ENTER(L"EnumBeginV");

	if (!ppEnum || !pDisp) return DH_EXIT(E_INVALIDARG, szMember);

	if (szMember != NULL)
	{
		hr = dhGetValueV(L"%o", &amp;pDispObj, pDisp, szMember, marker);
		if (FAILED(hr)) return DH_EXIT(hr, szMember);
	}
	else
	{
		pDispObj = pDisp;
	}

	hr = pDispObj-&gt;lpVtbl-&gt;Invoke(pDispObj, DISPID_NEWENUM, &amp;IID_NULL, LOCALE_USER_DEFAULT,
				 DISPATCH_METHOD | DISPATCH_PROPERTYGET, &amp;dp, &amp;vtResult, &amp;excep, NULL);

	if (szMember != NULL) pDispObj-&gt;lpVtbl-&gt;Release(pDispObj);

	if (FAILED(hr)) return DH_EXITEX(hr, TRUE, L"_NewEnum", szMember, &amp;excep, 0);

	if (vtResult.vt == VT_DISPATCH)
		hr = vtResult.pdispVal-&gt;lpVtbl-&gt;QueryInterface(vtResult.pdispVal, &amp;IID_IEnumVARIANT, (void **) ppEnum);
	else if (vtResult.vt == VT_UNKNOWN)
		hr = vtResult.punkVal-&gt;lpVtbl-&gt;QueryInterface(vtResult.punkVal, &amp;IID_IEnumVARIANT, (void **) ppEnum);
	else
		hr = E_NOINTERFACE;

	VariantClear(&amp;vtResult);

	return DH_EXIT(hr, szMember);
}

HRESULT dhEnumNextVariant(IEnumVARIANT * pEnum, VARIANT * pvResult)
{
	DH_ENTER(L"EnumNextVariant");

	if (!pEnum || !pvResult) return DH_EXIT(E_INVALIDARG, L"Enumerator");

	return DH_EXIT(pEnum-&gt;lpVtbl-&gt;Next(pEnum, 1, pvResult, NULL), L"Enumerator");
}

HRESULT dhEnumNextObject(IEnumVARIANT * pEnum, IDispatch ** ppDisp)
{
	VARIANT vtResult;
	HRESULT hr;

	DH_ENTER(L"EnumNextObject");

	if (!pEnum || !ppDisp) return DH_EXIT(E_INVALIDARG, L"Enumerator");

	hr = pEnum-&gt;lpVtbl-&gt;Next(pEnum, 1, &amp;vtResult, NULL);

	if (hr == S_OK)
	{
		if (vtResult.vt == VT_DISPATCH)
		{
			*ppDisp = vtResult.pdispVal;
		}
		else
		{
			hr = VariantChangeType(&amp;vtResult, &amp;vtResult, 0, VT_DISPATCH);
			if (SUCCEEDED(hr)) *ppDisp = vtResult.pdispVal;
			else VariantClear(&amp;vtResult);
		}
	}

	return DH_EXIT(hr, L"Enumerator");
}

HRESULT dhEnumBegin(IEnumVARIANT ** ppEnum, IDispatch * pDisp, LPCOLESTR szMember, ...)
{
	HRESULT hr;
	va_list marker;

	DH_ENTER(L"EnumBegin");

	va_start(marker, szMember);

	hr = dhEnumBeginV(ppEnum, pDisp, szMember, &amp;marker);

	va_end(marker);

	return DH_EXIT(hr, szMember);
}

/* ----- convert.c ----- */

static const LONGLONG FILE_TIME_ONE_DAY           = 864000000000;

static const LONGLONG FILE_TIME_VARIANT_DAY0      = 94353120000000000;

static const ULONGLONG FILE_TIME_VARIANT_OVERFLOW  = 2650467744000000000;

static const DATE      VARIANT_FILE_TIME_DAY0      = -109205;

static const DATE      VARIANT_TIMET_DAY0          = 25569;

static const LONG      TIMET_ONE_DAY               = 86400;

#ifndef _WIN64
static const DATE      VARIANT_TIMET_MAX           = 50424.13480;
#else
static const time_t    TIMET_VARIANT_OVERFLOW      = 253402300800;
#endif

HRESULT ConvertFileTimeToVariantTime(FILETIME * pft, DATE * pDate)
{
	ULONGLONG ftScalar;

	if (!pft || !pDate) return E_INVALIDARG;

	ftScalar = *((ULONGLONG *) pft) + 500;

	if (ftScalar &gt;= FILE_TIME_VARIANT_OVERFLOW) return E_INVALIDARG;
	*pDate = (LONGLONG) (ftScalar - FILE_TIME_VARIANT_DAY0) / (double) FILE_TIME_ONE_DAY;
	if (*pDate &lt; 0) *pDate = floor(*pDate) + (floor(*pDate) - *pDate);

	return NOERROR;
}

HRESULT ConvertVariantTimeToFileTime(DATE date, FILETIME * pft)
{
	ULONGLONG ftScalar;

	if (!pft) return E_INVALIDARG;

	if (date &lt; 0) date = ceil(date) + (ceil(date) - date);

	if (date &lt; VARIANT_FILE_TIME_DAY0) return E_INVALIDARG;
	ftScalar = (ULONGLONG) ((date * FILE_TIME_ONE_DAY) + FILE_TIME_VARIANT_DAY0);

	*pft = *((FILETIME *) &amp;ftScalar);

	return NOERROR;
}

HRESULT ConvertVariantTimeToSystemTime(DATE date, SYSTEMTIME * pSystemTime)
{
	HRESULT hr;
	FILETIME fileTime;

	if (!pSystemTime) return E_INVALIDARG;
	if (FAILED(hr = ConvertVariantTimeToFileTime(date, &amp;fileTime))) return hr;
	return (FileTimeToSystemTime(&amp;fileTime, pSystemTime) ? NOERROR : HRESULT_FROM_WIN32( GetLastError() ));
}

HRESULT ConvertSystemTimeToVariantTime(SYSTEMTIME * pSystemTime, DATE * pDate)
{
	FILETIME fileTime;

	if (!pSystemTime || !pDate) return E_INVALIDARG;
	if (!SystemTimeToFileTime(pSystemTime, &amp;fileTime)) return HRESULT_FROM_WIN32( GetLastError() );
	return ConvertFileTimeToVariantTime(&amp;fileTime, pDate);
}

HRESULT ConvertVariantTimeToTimeT(DATE date, time_t * pTimeT)
{
	struct tm * ptm;

	if (!pTimeT) return E_INVALIDARG;

#ifndef _WIN64
	if (date &lt; VARIANT_TIMET_DAY0 || date &gt; VARIANT_TIMET_MAX) return E_INVALIDARG;
#else
	if (date &lt; VARIANT_TIMET_DAY0) return E_INVALIDARG;
#endif

	*pTimeT = (time_t) (((date - VARIANT_TIMET_DAY0) * TIMET_ONE_DAY) + 0.5);

	if ( (ptm = gmtime(pTimeT)) == NULL || !(ptm-&gt;tm_isdst = -1) ||
	     (*pTimeT = mktime(ptm)) == (time_t) -1 ) return E_FAIL;

	return NOERROR;
}

HRESULT ConvertTimeTToVariantTime(time_t timeT, DATE * pDate)
{
	struct tm localtm, utctm, * ptm;
	time_t timeTLocal, timeTUtc;

	if (!pDate) return E_INVALIDARG;

	if ( (ptm = localtime(&amp;timeT)) == NULL) return E_FAIL;
	localtm = *ptm;

	if ( (ptm = gmtime(&amp;timeT)) == NULL) return E_FAIL;
	utctm = *ptm;

	localtm.tm_isdst = 0;
	utctm.tm_isdst   = 0;

	if ( (timeTLocal = mktime(&amp;localtm)) == (time_t) -1 ||
	     (timeTUtc   = mktime(&amp;utctm))   == (time_t) -1) return E_FAIL;

	timeT += timeTLocal - timeTUtc;

#ifdef _WIN64
	if (timeT &gt;= TIMET_VARIANT_OVERFLOW) return E_INVALIDARG;
#endif
	*pDate = (DATE)  (timeT / (double) TIMET_ONE_DAY) + VARIANT_TIMET_DAY0;

	return NOERROR;
}

HRESULT ConvertAnsiStrToBStr(LPCSTR szAnsiIn, BSTR * lpBstrOut)
{
	DWORD dwSize;

	if (lpBstrOut == NULL) return E_INVALIDARG;
	if (szAnsiIn == NULL) { *lpBstrOut = NULL; return NOERROR; }

	dwSize = MultiByteToWideChar(CP_ACP, 0, szAnsiIn, -1, NULL, 0);
	if (dwSize == 0) return HRESULT_FROM_WIN32( GetLastError() );

	*lpBstrOut = SysAllocStringLen(NULL, dwSize - 1);
	if (*lpBstrOut == NULL) return E_OUTOFMEMORY;

	if ( !MultiByteToWideChar(CP_ACP, 0, szAnsiIn, -1, *lpBstrOut, dwSize) )
	{
		SysFreeString(*lpBstrOut);
		return HRESULT_FROM_WIN32( GetLastError() );
	}

	return NOERROR;
}

HRESULT ConvertBStrToAnsiStr(BSTR bstrIn, LPSTR * lpszOut)
{
	DWORD dwSize;

	if (lpszOut == NULL) return E_INVALIDARG;
	if (bstrIn == NULL) { *lpszOut = NULL; return NOERROR; }

	dwSize = WideCharToMultiByte(CP_ACP, 0, bstrIn, -1, NULL, 0, NULL, NULL);
	if (dwSize == 0) return HRESULT_FROM_WIN32( GetLastError() );

	*lpszOut = (LPSTR) SysAllocStringByteLen(NULL, dwSize - 1);
	if (*lpszOut == NULL) return E_OUTOFMEMORY;

	if ( !WideCharToMultiByte(CP_ACP, 0, bstrIn, -1, *lpszOut, dwSize, NULL, NULL) )
	{
		SysFreeString((BSTR) *lpszOut);
		return HRESULT_FROM_WIN32( GetLastError() );
	}

	return NOERROR;
}

/* ----- dh_exceptions.c ----- */

#ifndef DISPHELPER_NO_EXCEPTIONS

static DH_EXCEPTION_OPTIONS g_ExceptionOptions;

static LONG  f_lngTlsInitBegin = -1, f_lngTlsInitEnd = -1;
static DWORD f_TlsIdxStackCount, f_TlsIdxException;

#define SetStackCount(nStackCount)   TlsSetValue(f_TlsIdxStackCount, (LPVOID) (nStackCount))
#define SetExceptionPtr(pException)  TlsSetValue(f_TlsIdxException, pException);
#define GetStackCount()       (UINT) TlsGetValue(f_TlsIdxStackCount)
#define GetExceptionPtr()            TlsGetValue(f_TlsIdxException)
#define CheckTlsInitialized()        if (f_lngTlsInitEnd != 0) InitializeTlsIndexes();

static void hlprStringCchCopyW(LPWSTR pszDest, SIZE_T cchDest, LPCWSTR pszSrc)
{
	assert(cchDest &gt; 0);

	do
	{
		if (--cchDest == 0) break;
	}
	while ((*pszDest++ = *pszSrc++));

	*pszDest = L'\0';
}

static void InitializeTlsIndexes(void)
{
	if (0 == InterlockedIncrement(&amp;f_lngTlsInitBegin))
	{
		f_TlsIdxStackCount = TlsAlloc();
		f_TlsIdxException  = TlsAlloc();
		f_lngTlsInitEnd    = 0;
	}
	else
	{
		while (f_lngTlsInitEnd != 0) Sleep(5);
	}
}

void dhEnter(void)
{
	CheckTlsInitialized();
	SetStackCount(GetStackCount() + 1);
}

HRESULT dhExitEx(HRESULT hr, BOOL bDispatchError, LPCWSTR szMember, LPCWSTR szCompleteMember,
                 EXCEPINFO * pExcepInfo, UINT iArgError, LPCWSTR szFunctionName)
{
	UINT nStackCount = GetStackCount();

	SetStackCount(nStackCount - 1);

	if (FAILED(hr) &amp;&amp; !g_ExceptionOptions.bDisableRecordExceptions)
	{
		PDH_EXCEPTION pException = GetExceptionPtr();

		if (!pException)
		{
			pException = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DH_EXCEPTION));
			if (!pException) return hr;
			SetExceptionPtr(pException);
		}
		else if (pException-&gt;bOld)
		{
			SysFreeString(pException-&gt;szDescription);
			SysFreeString(pException-&gt;szSource);
			SysFreeString(pException-&gt;szHelpFile);
			ZeroMemory(pException, sizeof(DH_EXCEPTION));
		}

		if (pException-&gt;hr == 0)
		{
			pException-&gt;hr              = hr;
			pException-&gt;iArgError       = iArgError;
			pException-&gt;szErrorFunction = szFunctionName;
			pException-&gt;bDispatchError  = bDispatchError;

			if (szMember) hlprStringCchCopyW(pException-&gt;szMember, ARRAYSIZE(pException-&gt;szMember), szMember);

			if (pExcepInfo &amp;&amp; hr == DISP_E_EXCEPTION)
			{
				if (pExcepInfo-&gt;pfnDeferredFillIn &amp;&amp;
				    !IsBadCodePtr((FARPROC) pExcepInfo-&gt;pfnDeferredFillIn)) pExcepInfo-&gt;pfnDeferredFillIn(pExcepInfo);

				pException-&gt;szDescription = pExcepInfo-&gt;bstrDescription;
				pException-&gt;szSource      = pExcepInfo-&gt;bstrSource;
				pException-&gt;szHelpFile    = pExcepInfo-&gt;bstrHelpFile;
				pException-&gt;dwHelpContext = pExcepInfo-&gt;dwHelpContext;
				pException-&gt;swCode        = (pExcepInfo-&gt;wCode ? pExcepInfo-&gt;wCode : pExcepInfo-&gt;scode);
			}
		}

		if (nStackCount == 1)
		{
			pException-&gt;bOld              = TRUE;
			pException-&gt;szInitialFunction = szFunctionName;

			if (szCompleteMember) hlprStringCchCopyW(pException-&gt;szCompleteMember, ARRAYSIZE(pException-&gt;szCompleteMember), szCompleteMember);

			if (g_ExceptionOptions.bShowExceptions)
				dhShowException(pException);

			if (g_ExceptionOptions.pfnExceptionCallback)
				g_ExceptionOptions.pfnExceptionCallback(pException);
		}
	}
	else if (hr == DISP_E_EXCEPTION &amp;&amp; pExcepInfo)
	{
		SysFreeString(pExcepInfo-&gt;bstrDescription);
		SysFreeString(pExcepInfo-&gt;bstrSource);
		SysFreeString(pExcepInfo-&gt;bstrHelpFile);
	}

	return hr;
}

HRESULT dhShowException(PDH_EXCEPTION pException)
{
	WCHAR szMessage[512];

	dhFormatExceptionW(pException, szMessage, ARRAYSIZE(szMessage), FALSE);

	MessageBoxW(g_ExceptionOptions.hwnd, szMessage, g_ExceptionOptions.szAppName,
	            MB_ICONSTOP | MB_SETFOREGROUND);

	return NOERROR;
}

HRESULT dhFormatExceptionW(PDH_EXCEPTION pException, LPWSTR szBuffer, UINT cchBufferSize, BOOL bFixedFont)
{
	HRESULT hr;
	UINT cch = 0;
#	define DESCRIPTION_LENGTH 255

	if (!szBuffer &amp;&amp; cchBufferSize) return E_INVALIDARG;

	if (!pException)
	{
		dhGetLastException(&amp;pException);
		if (!pException)
		{
			if (cchBufferSize != 0)
			{
				_snwprintf(szBuffer, cchBufferSize, L"No error information available.");
				szBuffer[cchBufferSize - 1] = L'\0';
			}

			return NOERROR;
		}
	}

	hr = (pException-&gt;hr == DISP_E_EXCEPTION &amp;&amp; pException-&gt;swCode ?
			pException-&gt;swCode : pException-&gt;hr);

	if (!pException-&gt;szSource)
	{
		if (pException-&gt;bDispatchError)
			pException-&gt;szSource = SysAllocString(L"IDispatch Interface");
		else
			pException-&gt;szSource = SysAllocString(L"Application");
	}

	if (!pException-&gt;szDescription)
	{
		pException-&gt;szDescription = SysAllocStringLen(NULL, DESCRIPTION_LENGTH);

		if (pException-&gt;szDescription)
		{
			switch (hr)
			{
				case E_NOINTERFACE:
					_snwprintf(pException-&gt;szDescription, DESCRIPTION_LENGTH, L"Object required");
					break;

				case DISP_E_UNKNOWNNAME:
				case DISP_E_MEMBERNOTFOUND:
					_snwprintf(pException-&gt;szDescription, DESCRIPTION_LENGTH, L"Object doesn't support this property or method: '%s'", pException-&gt;szMember);
					break;

				case DISP_E_TYPEMISMATCH:
					if (pException-&gt;szMember[0])
					{
						_snwprintf(pException-&gt;szDescription, DESCRIPTION_LENGTH, L"Type mismatch: '%s'. Argument Index: %d", pException-&gt;szMember, pException-&gt;iArgError);
						break;
					}

				default:
				{
#ifndef UNICODE
					CHAR szDescription[DESCRIPTION_LENGTH];
#else
					LPWSTR szDescription = pException-&gt;szDescription;
#endif
					cch = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					             NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					             szDescription, DESCRIPTION_LENGTH, NULL);

					if (!cch) wcscpy(pException-&gt;szDescription, L"Unknown runtime error");
#ifndef UNICODE
					else MultiByteToWideChar(CP_ACP, 0, szDescription, -1, pException-&gt;szDescription, DESCRIPTION_LENGTH);
#endif
				}
			}
		}
	}

	if (pException-&gt;szDescription)
	{

		if (!cch) cch = wcslen(pException-&gt;szDescription);

		if (cch &gt;= 2 &amp;&amp; pException-&gt;szDescription[cch - 2] == L'\r')
			pException-&gt;szDescription[cch - 2] = L'\0';
		else if (cch &gt;= 1 &amp;&amp; pException-&gt;szDescription[cch - 1] == L'\n')
			pException-&gt;szDescription[cch - 1] = L'\0';
	}

	if (cchBufferSize)
	{
		if (!bFixedFont)
		{
			_snwprintf(szBuffer, cchBufferSize, L"Member:\t  %s\r\nFunction:\t  %s\t\t\r\nError In:\t  %s\r\nError:\t  %s\r\nCode:\t  %x\r\nSource:\t  %s",
				pException-&gt;szCompleteMember,
				pException-&gt;szInitialFunction, pException-&gt;szErrorFunction,
				pException-&gt;szDescription, hr,
				pException-&gt;szSource);
		}
		else
		{
			_snwprintf(szBuffer, cchBufferSize, L"Member:   %s\r\nFunction: %s\r\nError In: %s\r\nError:    %s\r\nCode:     %x\r\nSource:   %s",
				pException-&gt;szCompleteMember,
				pException-&gt;szInitialFunction, pException-&gt;szErrorFunction,
				pException-&gt;szDescription, hr,
				pException-&gt;szSource);
		}

		szBuffer[cchBufferSize - 1] = L'\0';
	}

	return NOERROR;
}

HRESULT dhFormatExceptionA(PDH_EXCEPTION pException, LPSTR szBuffer, UINT cchBufferSize, BOOL bFixedFont)
{
	WCHAR szBufferW[1024];

	dhFormatExceptionW(pException, szBufferW, ARRAYSIZE(szBufferW), bFixedFont);

	if (0 == WideCharToMultiByte(CP_ACP, 0, szBufferW, -1, szBuffer, cchBufferSize, NULL, NULL))
		return HRESULT_FROM_WIN32( GetLastError() );

	return NOERROR;
}

HRESULT dhGetLastException(PDH_EXCEPTION * ppException)
{
	if (!ppException) return E_INVALIDARG;

	CheckTlsInitialized();
	*ppException = GetExceptionPtr();

	return NOERROR;
}

HRESULT dhToggleExceptions(BOOL bShow)
{
	g_ExceptionOptions.bShowExceptions = bShow;
	if (bShow) g_ExceptionOptions.bDisableRecordExceptions = FALSE;

	return NOERROR;
}

HRESULT dhSetExceptionOptions(PDH_EXCEPTION_OPTIONS pExceptionOptions)
{
	if (!pExceptionOptions) return E_INVALIDARG;

	g_ExceptionOptions.hwnd                     = pExceptionOptions-&gt;hwnd;
	g_ExceptionOptions.szAppName                = pExceptionOptions-&gt;szAppName;
	g_ExceptionOptions.bShowExceptions          = pExceptionOptions-&gt;bShowExceptions;
	g_ExceptionOptions.bDisableRecordExceptions = pExceptionOptions-&gt;bDisableRecordExceptions;
	g_ExceptionOptions.pfnExceptionCallback     = pExceptionOptions-&gt;pfnExceptionCallback;

	return NOERROR;
}

HRESULT dhGetExceptionOptions(PDH_EXCEPTION_OPTIONS pExceptionOptions)
{
	if (!pExceptionOptions) return E_INVALIDARG;

	pExceptionOptions-&gt;hwnd                     = g_ExceptionOptions.hwnd;
	pExceptionOptions-&gt;szAppName                = g_ExceptionOptions.szAppName;
	pExceptionOptions-&gt;bShowExceptions          = g_ExceptionOptions.bShowExceptions;
	pExceptionOptions-&gt;bDisableRecordExceptions = g_ExceptionOptions.bDisableRecordExceptions;
	pExceptionOptions-&gt;pfnExceptionCallback     = g_ExceptionOptions.pfnExceptionCallback;

	return NOERROR;
}

void dhCleanupThreadException(void)
{
	PDH_EXCEPTION pException;

	CheckTlsInitialized();
	pException = GetExceptionPtr();

	if (pException)
	{
		SysFreeString(pException-&gt;szDescription);
		SysFreeString(pException-&gt;szSource);
		SysFreeString(pException-&gt;szHelpFile);

		HeapFree(GetProcessHeap(), 0, pException);

		SetExceptionPtr(NULL);
	}
}

#endif

/* ----- dh_init.c ----- */

HRESULT dhInitializeImp(BOOL bInitializeCOM, BOOL bUnicode)
{
	dh_g_bIsUnicodeMode = bUnicode;

	if (bInitializeCOM) return CoInitialize(NULL);

	return NOERROR;
}

void dhUninitialize(BOOL bUninitializeCOM)
{
#ifndef DISPHELPER_NO_EXCEPTIONS
	dhCleanupThreadException();
#endif
	if (bUninitializeCOM) CoUninitialize();
}

</textarea> <br><br></td></tr></table><br>
<a name="1046176"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Zeke</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> add:<br><pre class=code>Import "-lole32"
Import "-loleaut32"
Import "-luuid"</pre> <br><br></td></tr></table><br>
<a name="1046177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Ghost Dancer</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> You are a star, thank you :)<br><br>I would be intersted to know what those lines do and/or why they are needed? <br><br></td></tr></table><br>
<a name="1046343"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> They link libraries at compile time, specifically the Windows libraries ole32, oleaut32 and uuid (which I do not believe is a standard library). <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
