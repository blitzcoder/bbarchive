<!DOCTYPE html><html lang="en" ><head ><title >Why are stack references not counted?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Why are stack references not counted?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Why are stack references not counted?</a><br><br>
<a name="725730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fabian.</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi!<br><br>A BlitzMax object's reference counter only counts Global and Field variables pointing to the object. Local variables aren't counted; when the GC gets called there's a loop running over the stack and counting the Locals.<br><br>Why is it done this way?<br>I guess it's for speed optimizing? or what is it for?<br>Or is there any other advantage because it's done like it is?<br><br>And as my second question: would you change this behaviour if we could have this features if all references were counted:<br>- multithreading (could really be possible in BMX!)<br>- Object Ptr not confusing the GC<br>- a method returning the refcount <br><br></td></tr></table><br>
<a name="725733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why: Because the GC knows exactly where the scope of the variable ends and thus can set it in the "clean list" for the current scope.<br>Its only a "real object" if it is transfered out of its scope and from that moment on its references are counted.<br><br>Multithreading wouldn't change due to that behavior. The GC is not multithreading save, that easy it is currently. It does not make any sense to try to implement it currently as you can not prevent the GC from trying to access the object to clean it. The GC would need to be replaced, from what I remember, some input has been given on that point by some experienced users in this area. Perhaps those things are implemented some day, as multithreading is definitely a must have. Systems are going 2 - 4 cores by default.<br><br>Returning refcount is currently possible. Not officially but through a little hack ( Byte Ptr(object)[-4] ). I agree that an official way to retrieve this count without the possibility to modify it would be a really good thing.<br><br>Only point I do not understand is how Object Ptr confuse the GC. They don't do it actually, the GC just ignores them. You have to manage it yourself and take care it is not pointing to a "dead" object, because the GC has no knowledge of them nor does it want to know of them as they bypass his handling system.<br>Or do I missunderstand what you are actually trying to say. <br><br></td></tr></table><br>
<a name="725776"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Fabian.</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> As I understand the GC it just adds a bbRelease and bbRetain to each write access to a Global or Field variable of type Object (or something derivered from it).<br>These macros aren't added to a write acces to a Local variable. So the program flow had to go different depending on where the Object Ptr points to: if it points to a Local variable it could simply set the assigned value, but if it points to a Global or Field variable it would need to bbRetain the assigned value and to bbRelease the previously contained value. Of course this could be done by simply comparing the address of the variable pointed by the Object Ptr variable with the current stack pos, esp, and the stack-top stored in the GCStackTop variable. But this would add a big overhead to each dereferenced write access to an Object Ptr variable, which could be done easily if you would say: bbRelease and bbRetain need to be added to each write access to object variables, so each reference is counted in the object's ref-count and there's no need to scan the stack for references.<br><br>"The GC is not multithreading save, that easy it is currently"<br>Here are some points which would be needed for a threadsafe GC:<br>- a global synchronization object (an Event object on win32) which makes sure that only one thread enters one of the GC functions. So there should be a call to WaitForSingleObject at the beginning of each GC function (GCAlloc, GCFree, collectmem...) and a call to SetEvent at the ending.<br>- the bbretain and bbrelease code needs lock statements to prevent simultaneous execution on multi-processor systems. the bbrelease code needs to have only one access to the ref count, which does two things: decrement the count and check whether it became zero, to eventually call GCFree<br>- no stack search any more, instead counting all variables with bbretain and bbrelease, so the bbGCStackTop variable wouldn't be needed any more.<br>I think these are the most important changes to create a threadsafe GC or is there anything else? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
