<!DOCTYPE html><html lang="en" ><head ><title >Debugging Memory Leaks</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Debugging Memory Leaks</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Debugging Memory Leaks</a><br><br>
<a name="704394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I haven't currently got any, but I'm aware that with developing a game engine, and with my TV3D and other modules underneath, there is a good chance I'm going to come up with one at some stage. I'm wondering what people consider the best practice to spot these early on.<br><br>At the moment, I have a GCCollect in the main loop, which I figure is harmless ( except for possible speed issues, but I develop in debug mode, so who cares? ) and means that when I see memory increasing it's because there's a leak and not because the garbage collector can't be bothered to do anything about all the memory I'm finished with.<br><br>Is this a decent practice, and do I need to do anything else? <br><br></td></tr></table><br>
<a name="704395"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Speed issues?<br>The garbage had to be collected any way, so surly haveing control over it and ensureing that it is done every frame is a good thing? <br><br></td></tr></table><br>
<a name="704397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> well general wisdom on garbage collectors is that they know best when to empty themselves, not you. Perhaps with a game, emptying every frame is more conducive to a consistent framerate, but even then, I don't know if that's true. I've no prior experience with GC's. <br><br></td></tr></table><br>
<a name="704411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no memory leak on the BM side.<br>The only leaks you have to take care of is stuff you get from C side ie everything you get by BytePtr. And there is no way from within BM to find those. You need the process manager or getting some usefull coding style (ie assign it to an object which you use within BM instead of relying on C++ code unstructure and free the byteptr memory in the Method Delete ).<br><br>Using unmanaged code which is not encapsulated within managed objects is something hardly liked in a managed environment as it gives you nearly a guarantee that you will have leaks at some point. <br><br></td></tr></table><br>
<a name="704424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't think you've understood my question. It's not particularly related to any external modules, although that did occur to me later.<br><br>Managed or unmanaged, Garbage Collector or no, anyone can write code which has memory leaks. I'm simply asking the best practices to spot them early. <br><br></td></tr></table><br>
<a name="704452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thinking out aloud.<br>Could you use GCCollect within an 'if my_memcheck=1' condition at the beginning and end of each function/method and write out entry/exit gcmemalloced() values into a type. At the end of the program write out the type values along with the function name to a text file. Maybe add them to a function global as exit_gcmemalloced()-entry_gcmemalloced() to see whether it's building up memory?<br>Could be really clever and add it to a debug module along with 'number of times called' with 'total ms' and 'average ms' to see which functions are memory and ms intensive. <br><br></td></tr></table><br>
<a name="704512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kenshin</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> When I found out about memory leaks, I already had a fair bit of code with the problem.  It took nearly a month for me to track down and fix all of them.<br><br>Now, I'm writing the status of memory to a debug file every frame, as well as use ProcessExplorer to keep an eye on it.  I often leave the program running overnight to check whether the mem usage creeps up or whether there's any long term crash/bug problems.<br><br>I guess it's similar to how most people handle the problem. <br><br></td></tr></table><br>
<a name="704577"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> BM has nearly no internal memory leaks anymore.<br>Thus using GCMemAlloced is quite useless, as it won't give you any type of general memory usage information. Only its own data, which don't leak.<br><br>As mentioned: Most common leak is usage of BytePtr within BM but not attached to a GC managed object. Thats a big no no and anyone using such constructs doesn't deserve anything else than memory leaks. (sorry but a little question to those people that don't use BytePtr only as fields within types: Have you ever asked yourself why Microsoft introduced .NET and C# and apple Objective C, if the C++ pointer hacking wouldn't have been system stability critical? If it wouldn't be millions of times easier to introduce a memory leak in unmanaged than finding it again?) <br><br></td></tr></table><br>
<a name="704603"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Dreamora. <br>Gabriel is talking about programming errors resulting in additional memory being retained when it would normally be released. In terms of this particular program that could be considered a memory 'leak' whether or not the issue is caused by BMax code or not.<br>In these situations GCMemalloced() will be useful... no? <br><br></td></tr></table><br>
<a name="704609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, thats right. sorry if my reaction might have been over the top.<br><br>But the only way getting a BM internal leak is a serious design error in the object hierarchy, as only cyclic references which don't break up the "parent - child" double links are able to create such leaks. So as long as you have a destroy method that null-ifies all references on the type instance, this type of BM internal leak can't happen. (yes it needs to be an own method. Null-ifying within Delete is worthless, as delete won't be called until the references are nullified)<br><br>All other things within BM are no leaks (theoretically not even above) as there are still references on the given object and I only count stuff as leak that is still allocated but not referenced by anything anymore. Last thing like that were leaking were sounds, when I remember correctly. (not fully sure if they are completely leak free by now) <br><br></td></tr></table><br>
<a name="704616"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> But the only way getting ..  <br></div><br>How about, for example, ...<br>1) Create 1000 objects in for/next loop.<br>2) Attempt to delete those objects but mistype 100 instead of 1000 without noticing.<br>?<br><br>I'm not sure why you don't consider them memory leaks. <br>BRL program a product called Bmax. If BRL had a hiccup while coding and memory was mis-used you're saying it's a memory leak in Bmax... Yep, agreed.<br>If I program a product called MyProduct and had a hiccup while coding and memory was mis-used you're saying it's *NOT* a memory leak in MyProduct... ? Then I disagree.<br>A problem where memory is taken and not released when it should be is a memory leak whatever the product.<br>IMO. <br><br></td></tr></table><br>
<a name="704621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't understand the "example"<br>You create 1000 objects, ok.<br>As what?<br>- local? -&gt; go out of scope automatically and are freed<br><br>- local but added to a list? -&gt; list.clear()  or someList = null -&gt; out of scope and freed as well<br><br>Actually I don't see how you want to create a leak this way, its all managed.<br><br><br>On the "MyProduct": I call it a memory leak there as well. But the BM functionality won't give you any way to find the leak. BM itself does not leak unless you have a serious object design error in your OO constructs which you better hunt on paper where you easily spot it instead of using memory supervicing and stuff like that.<br>So the only leak you get is the leak from interfacing from outside which GCMemAlloced won't tell you anything about nor does it worry about that as it isn't BMs problem or area of interest.<br><br><br>I hope you see my point now.<br>Leaks within BM mean a serious design error which you better hunt on your class design and functionality paper and not at runtime as this won't help you much. (thats the way Microsoft hunted bugs in Win98 and ME and we all know the result)<br><br><br>And if you train yourself to only use unmanaged stuff linked to a managed object, you will find yourself in the happy situation where memory leaks become a very rare thing. <br><br></td></tr></table><br>
<a name="704623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't *WANT* to create the leak.. that's why memory leaks are programming errors.<br>Maybe it was a poor example. Basically, if you create 1000 objects, stick them on a list but only remove 100 when you were supposed to remove 1000, you'll get a 'memory leak'.<br><br>BM function helps you find 'Memory leaks' in your own code via the gcmemalloced() command.<br>&lt;edit&gt; In case it explains better...<br><pre class=code>
Type ttest
	Field COUNT:Int
	Field NAME:String
End Type
test_list:TList=CreateList()
For x = 1 To 100
	GCCollect()
	GC1:Int=GCMemAlloced()
	For x = 1 To 1000
	   temp:TTest = New TTEST
		TEMP.COUNT=X
		TEMP.NAME="basdkjhfsaeifkashfklasehfklasdhfkasdhfklasdhflkash"
	   ListAddLast test_list,temp
	Next
	GCCollect()
	GC2:Int=GCMemAlloced()
	For x=1 To 100   ' This should read 1000 but ***programming error*** I put 100.
	 	test_list.remove(test_list.first())
	Next
	GCCollect()
	gc3:Int=GCMemAlloced()
Next
Print gc1 + " " + gc2 + " " + gc3
</pre> <br><br></td></tr></table><br>
<a name="704680"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats no leak.<br>A leak is uncontrolled lose of memory.<br>Yours will stay at that point.<br><br>But perhaps you start to see the point of managed functionality and modern mechanics:<br><br>TList.clear() is one<br>For local t:TTest = eachin test_list  is the other<br><br>This example is one of those good example that show how B3D programmers approach a solution from the counter productive way. You want to perform an operation on all entries in a list, so do it with the correct mechanics and you won't run into problems.<br>Thats quite exactly what I meant by serious problems in the design. Stuff that is designed this way is great for C++ ... so for 10 year old apps. But we are in 2006 and BM offers some of the modern mechanics and it is just nonsense to not use them just because one is used to "how the old stuff" worked and I don't mind if such behavior results in many hours of debugging. perhaps people then will learn the new possibilities offered to them and understand their true power.<br><br>PS: Even in the old way you wouldn't do it with a number based loop. You would do: while not test_list.isEmpty() remove  thats good and secure code as it has a clearly stated break condition. using count variables on a dynamic structure like a list is garbage. thats good for arrays where an indexed access exists. <br><br></td></tr></table><br>
<a name="704774"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm also not used to these garbage collectors.<br>Mostly I have the taskmanager open behind the running app and try to watch out for leaks arising. This takes a lot of time and patience. <br><br>But how about calling "GCSuspend" and "GCResume" to track leaks? Or is that too simple? :) <br><br></td></tr></table><br>
<a name="704783"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Thinking out aloud.<br>Could you use GCCollect within an 'if my_memcheck=1' condition at the beginning and end of each function/method and write out entry/exit gcmemalloced() values into a type. At the end of the program write out the type values along with the function name to a text file. Maybe add them to a function global as exit_gcmemalloced()-entry_gcmemalloced() to see whether it's building up memory?<br>Could be really clever and add it to a debug module along with 'number of times called' with 'total ms' and 'average ms' to see which functions are memory and ms intensive. <br></div><br><br>I like this. It could be quite difficult to implement cleanly, but I'll have a think about this, because it could prove invaluable if I can implement it right.<br><br><div class="quote"> Now, I'm writing the status of memory to a debug file every frame, as well as use ProcessExplorer to keep an eye on it. I often leave the program running overnight to check whether the mem usage creeps up or whether there's any long term crash/bug problems. <br></div><br><br>Sounds good. I'm finding that my program burns memory like it's going out of fashion just for using local variables in the main loop to cycle through objects in a tlist. It worried me at first but then I realised that the GC was just taking it's sweet time to clean up after me. Now that I've added a GCCollect in the main loop, this seems to work reasonably well though.<br><br><div class="quote"> Thats no leak.<br>A leak is uncontrolled lose of memory. <br></div><br>That's because it's an example. I don't know if you're being intentionally obtuse to annoy TonyG, but his examples make perfect sense to me. If ( to use his example ) you create 1000 objects and delete 999 of them, but it's in your main game loop, it IS a memory leak. You only need to miss one. As much as you like to go on about managed functionality, BMax object control and being leakproof, it's really easy to  get memory leaks, and not just with cyclic references ( which are a reality in most complex projects anyway. ) There are all sorts of ways to allocate memory both internally and externally which the GC does not even manage. If the GC isn't managing it, you are and if you're NOT, you've got memory leaks.<br><br><div class="quote"> But how about calling "GCSuspend" and "GCResume" to track leaks? Or is that too simple? :) <br></div><br>I'm not sure what you mean. If I shutdown the garbage collector, I'm just going to stop things from being cleaned up, so surely that makes it even harder for me to spot leaks? I've been doing the opposite, and forcing the GC to collect every frame specifically because that makes it easier for me to spot memory usage increasing. How would I do what you're suggesting? <br><br></td></tr></table><br>
<a name="704787"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Curtastic</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a memory leak. Not blitzmax's fault but still. I believe GCMemAlloced() will show you that you have a memory leak. But you have to find it.<br><br><pre class=code>
'main loop
repeat
update()
draw()
listaddlast nodelist,new node 'oops
forever
</pre> <br><br></td></tr></table><br>
<a name="704791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no leak.<br>You just uncontrolled add useless stuff without ever removing anything.<br><br>You just flood the memory because the design leaks not the program. this most likely happens if there is not enough time invested into designing the software but only writting it and that although at least 50% of the time is actually designing. At least if you plan to write it in a way that prevents you from rewritting it 3 times. <br><br></td></tr></table><br>
<a name="704819"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> As per Gabe.<br>In a way I hope you ARE being obtuse as your inability to understand this thread is startling.<br>Anyway, if memory is taken and not released then memory has leaked. 'Managed functionality' can't compensate for 'stupidity'. <br><br></td></tr></table><br>
<a name="704829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Leak: memory that can not be accessed anymore but that is still allocated.<br>Within a managed environment, normally this can't happen. In BM its possible to create that as BM does not have root references. So it is possible to have a whole cyclic group of objects within GC memory pool without the ability to access and thus remove it anymore. The chance that this happens raises with structures that have bidirectional parent-child relationships.<br>Another possibility is using the MemAlloc functionality or getting memory blocks from extern via BytePtr that is not manually freed through "free".<br><br>The above is just stupidity or program design error and has nothing to do with the phenomenom called memory leak.<br><br>Defition of memory leak: (which clearly states memory that is not needed anymore -&gt; no usable reference to it anymore)<br><a href="http://www.webopedia.com/TERM/M/memory_leak.html" target="_blank">http://www.webopedia.com/TERM/M/memory_leak.html</a><br>http://www.pcmag.com/encyclopedia_term/0,2542,t=memory+leak&amp;i=46775,00.asp <br><br></td></tr></table><br>
<a name="704838"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doesn't that second link cover this situation?<br><div class="quote"> <br>A condition caused by a program that does not free up the extra memory it allocates. <br> <br></div><br>Yep, the program has allocated extra memory but has not freed it up.<br><div class="quote"> <br>In programming languages, such as C/C++, the programmer can dynamically allocate additional memory to hold data and variables that are required for the moment, but not used throughout the program. When those memory areas are no longer needed, the programmer must remember to deallocate them.<br> <br></div><br>Yep, not c++ but it's MyProduct, I've allocated memory to hold data and, as the programmer, not remembered to deallocate it.<br><div class="quote"> <br>When memory is allocated, but not deallocated, a memory leak occurs (the memory has leaked out of the computer).<br> <br></div><br>Yep again. memory has been allocated and not deallocated.<br><div class="quote"> <br>If too many memory leaks occur, they can usurp all of memory and bring everything to a halt or slow the processing considerably. In other environments, such as Java, the operating system allocates and deallocates memory automatically. Specifically allocating and deallocating memory, while error prone (in case one forgets to deallocate), allows the programmer more control over the computer's resources. See garbage collection. <br> <br></div><br>Yep, that'd happen. <br>Alternatively, you could ignore you posted that link and refer to the first. <br><a href="http://en.wikipedia.org/wiki/Memory_leak" target="_blank"> Not sure why you didn't link to our friend </a><br>&lt;edit&gt; In fact the first definition is open to interpretation as well. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
