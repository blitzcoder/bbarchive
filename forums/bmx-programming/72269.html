<!DOCTYPE html><html lang="en" ><head ><title >Can I create a HUGE bitmap and then display it?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Can I create a HUGE bitmap and then display it?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Can I create a HUGE bitmap and then display it?</a><br><br>
<a name="807632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SofaKng</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can I create a huge bitmap/texture (5000x3000 pixels @ ARGB), draw on it and then display it?  (eg. TPixMap?)<br><br>I know that video card textures are usually limited to 2096x2096 but I'm hoping to store my huge texture/bitmap in system memory and then upload only parts of it to the video card.<br><br>The keys parts of what I'm trying to do are:<br><br>1) Storing a huge bitmap (ARGB format)<br>2) Drawing on it (changing alpha values mostly)<br>3) Display part of the bitmap to the screen<br><br>Every so-often I will need to change the huge bitmap (alpha values).<br><br>Thanks for any help! <br><br></td></tr></table><br>
<a name="807639"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> With pixmaps you can, images will not work with that size.<br>You don't need to upload it, you can draw pixmaps or paste parts of the pixmap to a different pixmap and only draw that pixmap.<br><br>Problem is the massive size of it 58 MB RAM usage.<br><br>BUT: you can not draw on anything. BM has no buffer support.<br>What you would have to do is to manually modify pixel after pixel or paste a different pixmap into this pixmap. Alternative you access the byte ptr of the pixmap and modify it "in data" directly without all "looking nice but beeing slower" wrapping functions.<br><br>Main problem is that Alpha does not work when drawing pixmaps. Only Images have Alpha as only Images are 3D objects, pixmaps are copied directly into the backbuffer, not rendered. No alpha support therefor.<br><br><br>Sounds like you want to use it for a worms like terrain and use the alpha to destroy pixels?<br>If you plan to use it for something like this, you might consider using a more tilemap like approach to restrict the "modification access size" drastically to 1-X tiles instead of 58MB of data. That would drastically reduce the upload time as well as you only upload modified tiles, not a whole screen full of data, which will not work in realtime. and upload sadly is needed if you plan to use image alpha. <br><br></td></tr></table><br>
<a name="807648"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's no problem with you creating a large pixmap, it can be pretty much as large as you like. The fastest way to modify pixels in it, even if it's just the alpha values, is to read the whole pixel using an Int Pointer, based on the PixmapPtr(), changing the component that you want to modify, then writing it back to the same pointer. Alternatively you can use ReadPixmap and WritePixmap (or is it ReadPixel and WritePixel).<br><br>Like Dreamora says, it is going to consume quite a few megs of ram to keep a pixmap that large - but hey, that's your decision, and on today's machines people tend to have a lot more ram than they used to.<br><br>What you then want to do is treat your pixmap like a pool of image data (for example, similar to the megatexture system which is becoming popular right now) - where you spool small sections of image from your pixmap into images in video ram on an as-needed basis, for display purposes only. The fastest way to do that is create empty textures and then upload the texture data, using the appropriate values to read a window in your pixmap. You should not need to be grabbing whole sections of pixmap and pasting it back into a pixmap just to get the window functionality.<br><br>Then when you render your display you are pulling from the images that you've uploaded previously, reusing those that were on-screen in the last frame, and those which you just pre-uploaded for the areas of screen that are just off the display. Then you only need a little more than 1 screen's worth of images consuming video ram. It's much faster to draw an image, and to re-use an image that you uploaded some time previously, rather than to upload whole pixmaps of data every frame for the whole display. You will still take a performance hit for transferring pixmap data to the texture(s) but nowhere near as much as drawing entire pixmaps. And then you can render with alpha blending. <br><br></td></tr></table><br>
<a name="807662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SofaKng</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the replies!!<br><br>@Dreamora: Can you explain the tiling idea a little more?  I'd like to create my terrain dynamically in a process like this:<br><br>1) Create outline of terrain<br>2) Fill terrain with mountain image<br>3) Draw tunnels (eg. another image) inside of terrain<br>4) Place grass (another image) on top of terrain<br><br>The end result would be my terrain (and would be very huge, perhaps 5000x3000 to fill a few screens of 1920x1200, but would scale down for lower resolutions)<br><br>I don't think tiling would really work because no two sections of my terrain would be the same...<br><br>@ImaginaryHuman: That is the exact idea I had for streaming textures.  (eg. the video card would only contain one screen worth of data [plus a little more] and as the user scrolled the map new texture data would be uploaded, thus drastically reducing the amount of video ram required).<br><br>How can I create textures on the video card?  (do I need D3D/OGL specific calls?)<br><br>How do I upload data from my pixmap to the textures?<br><br>Also, can I use the built-in per-pixel collision with a pixmap?<br><br>Thanks again for your help! <br><br></td></tr></table><br>
<a name="807772"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could use the helper functions that Blitz provides to convert a pixmap to a texture, returning a texture handle, or do your own direct GL calls.  No idea about DX.<br><br>Look at the sourcecode for those helper functions for an idea how to do it.<br><br>You cannot use collision detection with pixmaps, I'm fairly sure it's image based. Nevertheless I would code your own collision detection which uses the pixmap, so you can read from it very quickly (compared to transferring data from the backbuffer).<br><br>Also for your update sequence, where you're uploading newly required images, considering spreading out/staggering the number of image pieces that need to be uploaded per frame, based on how many pixels the world has scrolled, so that you aren't uploading lots at a time - ie just one or two uploads per frame. <br><br></td></tr></table><br>
<a name="807954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Tiling this massive sizes is what is done in other hardware accelerated 2D games as well.<br><br>The best known example most likely is Clonks in its newer incarnations.<br>The tiling there is done for the simple reason to reduce the amount of image data needed to modify the terrain dynamically.<br><br>If you do not need it for dynamic alteration at runtime, you could easily create a massive pixmap for your terrain and paste in object after object.<br><br>When you are done, create textures out of subsections (256x256 or 512x512 I would suggest for performance reasons on slower / capped cards with only 64bit bus ie 70% of all users) and use those textures to draw, as textures are 10 times faster and more, depending on the hardware.<br><br><br>if you need dynamic modification, then you do the same steps as so far but you would use subsections far smaller. 64x64 or 128x128, to make the amount of data you need to reupload smaller which makes the whole dynamic update and modification of the images seriously faster. (the smaller the section you download and upload, the less time the card will be locked and the less rendertime lost as a general rule) <br><br></td></tr></table><br>
<a name="808018"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree. Also as you scroll the view of the game world you should be progressively uploading the `tile` sections which are about to come into view - rather than upload a whole horizontal and/or vertical strip of tiles all in one frame you should spread the upload out over the number of frames it takes before they become visible, so that with slower scrolling you upload less frequently and faster scrolling it adapts to the scroll speed. Then you are only uploading a few tiles per frame, and by the time you've scrolled say 64 pixels and are ready to see the newly uploaded tiles coming into view, you might've taken 16 frames to upload them, which is better than creating a sudden jerk due to a mass upload.<br><br>I also recommend keeping a fairly decent sized `extra` number of tiles in video ram that have been `used recently`, which are further away from the current camera view but which were perhaps uploaded not long ago. While you're still within a given megabyte limit, you can just let the uploaded tiles accumulate into new image sections so that when you change scroll direction and go back where you just came from you don't have to start uploading new stuff. OR, you could start uploading new stuff but at the far outer edges of the parts which are cached, meaning you have much more time to upload them before you need to start worrying about not having time to get them all updated.<br><br>Also you have to ask yourself how much of your landscape will likely get modified and how much of it will likely stay unchanged. If there are only going to be a few modifications then the unmodified areas could use repeating textures versus per-pixel state. <br><br></td></tr></table><br>
<a name="808151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> As far as rendering goes, wouldn't the 3D card only keep in Vram what it needs, in basically a FIFO style? Bmax uses managed resources so in theory you should be able to load everything in system memory using normal image load functions and the gpu will cache as needed. ? ? ? <br><br></td></tr></table><br>
<a name="808165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> No it wouldn't<br>A card does not keep anything, it is like RAM.<br><br>On DX Side, DX itself manages the needed stuff in VRAM according its rendering.<br>In OpenGL you must do it or BM does it by reuploading images from pixmaps as needed.<br><br>But in both cases, we are not talking about keeping stuff in VRAM.<br><br>We are talking about what you need to render!<br><br>If you use larger images, you potentially risk to keep a large image in VRAM and render it even if you only need a small part on a corner of that image. That effect is reduced with smaller images where only a subsection of the image is used.<br><br>As well as mentioned above: most users don't have XX GB bandwidth on their video cards, so its a wise decision not to block it with 90% of image data you do not need (-&gt; large images).<br>Especially as we are talking of 2D here. If you do 2D, follow common 2D principles. Might be that current cards are very capable in 3D, but believe me, thanks to their total incapability on the over draw end, you will bring them down extremely fast with 2D if you don't use all the tricks known from pure 2D! <br><br></td></tr></table><br>
<a name="808235"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree. You can define priorities in GL so that when it runs out of video ram it starts spooling textures off to main memory, but you do NOT want that to happen, it is extraordinarily slow and will totally cripple your game. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
